[{"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Python", "code": "\ndef is_prime(number):\n    return True # code omitted - see Primality by Trial Division\n\ndef m_factor(p):\n    max_k = 16384 / p # arbitrary limit; since Python automatically uses long's, it doesn't overflow\n    for k in xrange(max_k):\n        q = 2*p*k + 1\n        if not is_prime(q):\n            continue\n        elif q % 8 != 1 and q % 8 != 7:\n            continue\n        elif pow(2, p, q) == 1:\n            return q\n    return None\n\nif __name__ == '__main__':\n    exponent = int(raw_input(\"Enter exponent of Mersenne number: \"))\n    if not is_prime(exponent):\n        print \"Exponent is not prime: %d\" % exponent\n    else:\n        factor = m_factor(exponent)\n        if not factor:\n            print \"No factor found for M%d\" % exponent\n        else:\n            print \"M%d has a factor: %d\" % (exponent, factor)\n\n\nExample:\nEnter exponent of Mersenne number: 929\nM929 has a factor: 13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "C", "code": "\nint isPrime(int n){\n\tif (n%2==0) return n==2;\n\tif (n%3==0) return n==3;\n\tint d=5;\n\twhile(d*d<=n){\n\t\tif(n%d==0) return 0;\n\t\td+=2;\n\t\tif(n%d==0) return 0;\n\t\td+=4;}\n\treturn 1;}\n\nmain() {int i,d,p,r,q=929;\n\tif (!isPrime(q)) return 1; \n\tr=q;\n\twhile(r>0) r<<=1;\n\td=2*q+1;\n\tdo { \tfor(p=r, i= 1; p; p<<= 1){\n\t\t\ti=((long long)i * i) % d;\n\t\t\tif (p < 0) i *= 2;\n\t\t\tif (i > d) i -= d;}\n\t\tif (i != 1) d += 2*q;\n\t\telse break;\n\t} while(1);\n\tprintf(\"2^%d - 1 = 0 (mod %d)\\n\", q, d);}\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "C++", "code": "\n#include <iostream>\n#include <cstdint>\n\ntypedef uint64_t integer;\n\ninteger bit_count(integer n) {\n    integer count = 0;\n    for (; n > 0; count++)\n        n >>= 1;\n    return count;\n}\n\ninteger mod_pow(integer p, integer n) {\n    integer square = 1;\n    for (integer bits = bit_count(p); bits > 0; square %= n) {\n        square *= square;\n        if (p & (1 << --bits))\n            square <<= 1;\n    }\n    return square;\n}\n\nbool is_prime(integer n) {\n    if (n < 2)\n        return false;\n    if (n % 2 == 0)\n        return n == 2;\n    for (integer p = 3; p * p <= n; p += 2)\n        if (n % p == 0)\n            return false;\n    return true;\n}\n\ninteger find_mersenne_factor(integer p) {\n    for (integer k = 0, q = 1;;) {\n        q = 2 * ++k * p + 1;\n        if ((q % 8 == 1 || q % 8 == 7) && mod_pow(p, q) == 1 && is_prime(q))\n            return q;\n    }\n    return 0;\n}\n\nint main() {\n    std::cout << find_mersenne_factor(929) << std::endl;\n    return 0;\n}\n\n\nOutput:\n13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Java", "code": "\nimport java.math.BigInteger;\n\nclass MersenneFactorCheck\n{\n\n  private final static BigInteger TWO = BigInteger.valueOf(2);\n  \n  public static boolean isPrime(long n)\n  {\n    if (n == 2)\n      return true;\n    if ((n < 2) || ((n & 1) == 0))\n      return false;\n    long maxFactor = (long)Math.sqrt((double)n);\n    for (long possibleFactor = 3; possibleFactor <= maxFactor; possibleFactor += 2)\n      if ((n % possibleFactor) == 0)\n        return false;\n    return true;\n  }\n  \n  public static BigInteger findFactorMersenneNumber(int primeP)\n  {\n    if (primeP <= 0)\n      throw new IllegalArgumentException();\n    BigInteger bigP = BigInteger.valueOf(primeP);\n    BigInteger m = BigInteger.ONE.shiftLeft(primeP).subtract(BigInteger.ONE);\n    // There are more complicated ways of getting closer to sqrt(), but not that important here, so go with simple\n    BigInteger maxFactor = BigInteger.ONE.shiftLeft((primeP + 1) >>> 1);\n    BigInteger twoP = BigInteger.valueOf(primeP << 1);\n    BigInteger possibleFactor = BigInteger.ONE;\n    int possibleFactorBits12 = 0;\n    int twoPBits12 = primeP & 3;\n    \n    while ((possibleFactor = possibleFactor.add(twoP)).compareTo(maxFactor) <= 0)\n    {\n      possibleFactorBits12 = (possibleFactorBits12 + twoPBits12) & 3;\n      // \"Furthermore, q must be 1 or 7 mod 8\". We know it's odd due to the +1 done above, so bit 0 is set. Therefore, we only care about bits 1 and 2 equaling 00 or 11\n      if ((possibleFactorBits12 == 0) || (possibleFactorBits12 == 3))\n        if (TWO.modPow(bigP, possibleFactor).equals(BigInteger.ONE))\n          return possibleFactor;\n    }\n    return null;\n  }\n  \n  public static void checkMersenneNumber(int p)\n  {\n    if (!isPrime(p))\n    {\n      System.out.println(\"M\" + p + \" is not prime\");\n      return;\n    }\n    BigInteger factor = findFactorMersenneNumber(p);\n    if (factor == null)\n      System.out.println(\"M\" + p + \" is prime\");\n    else\n      System.out.println(\"M\" + p + \" is not prime, has factor \" + factor);\n    return;\n  }\n\n  public static void main(String[] args)\n  {\n    for (int p = 1; p <= 50; p++)\n      checkMersenneNumber(p);\n    checkMersenneNumber(929);\n    return;\n  }\n  \n}\n\n\nOutput:\nM1 is not prime\nM2 is prime\nM3 is prime\nM4 is not prime\nM5 is prime\nM6 is not prime\nM7 is prime\nM8 is not prime\nM9 is not prime\nM10 is not prime\nM11 is not prime, has factor 23\nM12 is not prime\nM13 is prime\nM14 is not prime\n...\nM47 is not prime, has factor 2351\nM48 is not prime\nM49 is not prime\nM50 is not prime\nM929 is not prime, has factor 13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "C#", "code": "\nusing System;\n\nnamespace prog\n{\n\tclass MainClass\n\t{\n\t\tpublic static void Main (string[] args)\n\t\t{\n\t\t\tint q = 929;\n\t\t\tif ( !isPrime(q) ) return;\n\t\t\tint r = q;\n\t\t\twhile( r > 0 ) \n\t\t\t\tr <<= 1;\n\t\t\tint d = 2 * q + 1;\n\t\t\tdo\n\t\t\t{\n\t\t\t\tint i = 1;\n\t\t\t\tfor( int p=r; p!=0; p<<=1 )\n\t\t\t\t{\n\t\t\t\t\ti = (i*i) % d;\n\t\t\t\t\tif (p < 0) i *= 2;\n\t\t\t\t\tif (i > d) i -= d;\n\t\t\t\t}\n\t\t\t\tif (i != 1) d += 2 * q; else break;\t\t\t\t\n\t\t\t}\n\t\t\twhile(true);\n\t\t\t\n\t\t\tConsole.WriteLine(\"2^\"+q+\"-1 = 0 (mod \"+d+\")\"); \n\t\t}\n\t\t\n\t\tstatic bool isPrime(int n)\n\t\t{\n\t\t\tif ( n % 2 == 0 ) return n == 2;\n\t\t\tif ( n % 3 == 0 ) return n == 3;\n\t\t\tint d = 5;\n\t\t\twhile( d*d <= n )\n\t\t\t{\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 2;\n\t\t\t\tif ( n % d == 0 ) return false;\n\t\t\t\td += 4;\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\t}\n}\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "JavaScript", "code": "\nfunction mersenne_factor(p){\n  var limit, k, q\n  limit = Math.sqrt(Math.pow(2,p) - 1)\n  k = 1\n  while ((2*k*p - 1) < limit){\n    q = 2*k*p + 1\n    if (isPrime(q) && (q % 8 == 1 || q % 8 == 7) && trial_factor(2,p,q)){\n      return q // q is a factor of 2**p-1\n    }\n    k++\n  }\n  return null\n}\n \nfunction isPrime(value){\n  for (var i=2; i < value; i++){\n    if (value % i == 0){\n      return false\n    }\n    if (value % i != 0){\n      return true;\n\t }\n  }\n}\n \nfunction trial_factor(base, exp, mod){\n  var square, bits\n  square = 1\n  bits = exp.toString(2).split('')\n  for (var i=0,ln=bits.length; i<ln; i++){\n    square = Math.pow(square, 2) * (bits[i] == 1 ? base : 1) % mod\n  }\n  return (square == 1)\n}\n \nfunction check_mersenne(p){\n  var f, result\n  console.log(\"M\"+p+\" = 2^\"+p+\"-1 is \")\n  f = mersenne_factor(p)\n  console.log(f == null ? \"prime\" : \"composite with factor \"+f)\n}\n\n> check_mersenne(3)\n\"M3 = 2**3-1 is prime\"\n> check_mersenne(23)\n\"M23 = 2**23-1 is composite with factor 47\"\n> check_mersenne(929)\n\"M929 = 2**929-1 is composite with factor 13007\"\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "PHP", "code": "\nTranslation of: D\n\necho 'M929 has a factor: ',  mersenneFactor(929), '</br>';\n\nfunction mersenneFactor($p) {\n    $limit = sqrt(pow(2, $p) - 1);\n    for ($k = 1; 2 * $p * $k - 1 < $limit; $k++) { \n        $q = 2 * $p * $k + 1;\n        if (isPrime($q) && ($q % 8 == 1 || $q % 8 == 7) && bcpowmod(\"2\", \"$p\", \"$q\") == \"1\") {\n            return $q;\n        }\n    }\n    return 0;\n}\n\nfunction isPrime($n) {\n    if ($n < 2 || $n % 2 == 0) return $n == 2;\n    for ($i = 3; $i * $i <= $n; $i += 2) {\n        if ($n % $i == 0) {\n            return false;\n        }\n    }\n    return true;\n}\n\n\nOutput:\nM929 has a factor: 13007\n", "explain": "Requires bcmath\n"}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nPROGRAM EXAMPLE\n  IMPLICIT NONE\n  INTEGER :: exponent, factor\n\n  WRITE(*,*) \"Enter exponent of Mersenne number\"\n  READ(*,*) exponent\n  factor = Mfactor(exponent)\n  IF (factor == 0) THEN\n    WRITE(*,*) \"No Factor found\"\n  ELSE\n    WRITE(*,\"(A,I0,A,I0)\") \"M\", exponent, \" has a factor: \", factor\n  END IF\n\nCONTAINS\n\nFUNCTION isPrime(number)\n!   code omitted - see [[Primality by Trial Division]]\nEND FUNCTION\n\nFUNCTION  Mfactor(p)\n  INTEGER :: Mfactor\n  INTEGER, INTENT(IN) :: p\n  INTEGER :: i, k,  maxk, msb, n, q\n\n  DO i = 30, 0 , -1\n    IF(BTEST(p, i)) THEN\n      msb = i\n      EXIT\n    END IF\n  END DO\n \n  maxk = 16384  / p     ! limit for k to prevent overflow of 32 bit signed integer\n  DO k = 1, maxk\n    q = 2*p*k + 1\n    IF (.NOT. isPrime(q)) CYCLE\n    IF (MOD(q, 8) /= 1 .AND. MOD(q, 8) /= 7) CYCLE\n    n = 1\n    DO i = msb, 0, -1\n      IF (BTEST(p, i)) THEN\n        n = MOD(n*n*2, q)\n      ELSE\n        n = MOD(n*n, q)\n      ENDIF\n    END DO\n    IF (n == 1) THEN\n      Mfactor = q\n      RETURN\n    END IF\n  END DO\n  Mfactor = 0\nEND FUNCTION\nEND PROGRAM EXAMPLE\n\n\nOutput:\nM929 has a factor: 13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\n// limit search to small primes.  really this is higher than\n// you'd want it, but it's fun to factor M67.\nconst qlimit = 2e8\n\nfunc main() {\n    mtest(31)\n    mtest(67)\n    mtest(929)\n}\n\nfunc mtest(m int32) {\n    // the function finds odd prime factors by\n    // searching no farther than sqrt(N), where N = 2^m-1.\n    // the first odd prime is 3, 3^2 = 9, so M3 = 7 is still too small.\n    // M4 = 15 is first number for which test is meaningful.\n    if m < 4 {\n        fmt.Printf(\"%d < 4.  M%d not tested.\\n\", m, m)\n        return\n    }\n    flimit := math.Sqrt(math.Pow(2, float64(m)) - 1)\n    var qlast int32\n    if flimit < qlimit {\n        qlast = int32(flimit)\n    } else {\n        qlast = qlimit\n    }\n    composite := make([]bool, qlast+1)\n    sq := int32(math.Sqrt(float64(qlast)))\nloop:\n    for q := int32(3); ; {\n        if q <= sq {\n            for i := q * q; i <= qlast; i += q {\n                composite[i] = true\n            }\n        }\n        if q8 := q % 8; (q8 == 1 || q8 == 7) && modPow(2, m, q) == 1 {\n            fmt.Printf(\"M%d has factor %d\\n\", m, q)\n            return\n        }\n        for {\n            q += 2\n            if q > qlast {\n                break loop\n            }\n            if !composite[q] {\n                break\n            }\n        }\n    }\n    fmt.Printf(\"No factors of M%d found.\\n\", m)\n}\n\n// base b to power p, mod m\nfunc modPow(b, p, m int32) int32 {\n    pow := int64(1)\n    b64 := int64(b)\n    m64 := int64(m)\n    bit := uint(30)\n    for 1<<bit&p == 0 {\n        bit--\n    }\n    for {\n        pow *= pow\n        if 1<<bit&p != 0 {\n            pow *= b64\n        }\n        pow %= m64\n        if bit == 0 {\n            break\n        }\n        bit--\n    }\n    return int32(pow)\n}\n\n\nOutput:\nNo factors of M31 found.\nM67 has factor 193707721\nM929 has factor 13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Ruby", "code": "\nWorks with: Ruby version 1.9.3+\nrequire 'prime'\n\ndef mersenne_factor(p)\n  limit = Math.sqrt(2**p - 1)\n  k = 1\n  while (2*k*p - 1) < limit\n    q = 2*k*p + 1\n    if q.prime? and (q % 8 == 1 or q % 8 == 7) and trial_factor(2,p,q)\n      # q is a factor of 2**p-1\n      return q\n    end\n    k += 1\n  end\n  nil\nend\n\ndef trial_factor(base, exp, mod)\n  square = 1\n  (\"%b\" % exp).each_char {|bit| square = square**2 * (bit == \"1\" ? base : 1) % mod}\n  (square == 1)\nend\n\ndef check_mersenne(p)\n  print \"M#{p} = 2**#{p}-1 is \"\n  f = mersenne_factor(p)\n  if f.nil?\n    puts \"prime\"\n  else\n    puts \"composite with factor #{f}\"\n  end\nend\n\nPrime.each(53) { |p| check_mersenne p }\ncheck_mersenne 929\n\n\nOutput:\nM2 = 2**2-1 is prime\nM3 = 2**3-1 is prime\nM5 = 2**5-1 is prime\nM7 = 2**7-1 is prime\nM11 = 2**11-1 is composite with factor 23\nM13 = 2**13-1 is prime\nM17 = 2**17-1 is prime\nM19 = 2**19-1 is prime\nM23 = 2**23-1 is composite with factor 47\nM29 = 2**29-1 is composite with factor 233\nM31 = 2**31-1 is prime\nM37 = 2**37-1 is composite with factor 223\nM41 = 2**41-1 is composite with factor 13367\nM43 = 2**43-1 is composite with factor 431\nM47 = 2**47-1 is composite with factor 2351\nM53 = 2**53-1 is composite with factor 6361\nM929 = 2**929-1 is composite with factor 13007\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Rust", "code": "\nTranslation of: C++\nfn bit_count(mut n: usize) -> usize {\n    let mut count = 0;\n    while n > 0 {\n        n >>= 1;\n        count += 1;\n    }\n    count\n}\n\nfn mod_pow(p: usize, n: usize) -> usize {\n    let mut square = 1;\n    let mut bits = bit_count(p);\n    while bits > 0 {\n        square = square * square;\n        bits -= 1;\n        if (p & (1 << bits)) != 0 {\n            square <<= 1;\n        }\n        square %= n;\n    }\n    return square;\n}\n\nfn is_prime(n: usize) -> bool {\n    if n < 2 {\n        return false;\n    }\n    if n % 2 == 0 {\n        return n == 2;\n    }\n    if n % 3 == 0 {\n        return n == 3;\n    }\n    let mut p = 5;\n    while p * p <= n {\n        if n % p == 0 {\n            return false;\n        }\n        p += 2;\n        if n % p == 0 {\n            return false;\n        }\n        p += 4;\n    }\n    true\n}\n\nfn find_mersenne_factor(p: usize) -> usize {\n    let mut k = 0;\n    loop {\n        k += 1;\n        let q = 2 * k * p + 1;\n        if q % 8 == 1 || q % 8 == 7 {\n            if mod_pow(p, q) == 1 && is_prime(p) {\n                return q;\n            }\n        }\n    }\n}\n\nfn main() {\n    println!(\"{}\", find_mersenne_factor(929));\n}\n\n\nOutput:\n13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Swift", "code": "\nimport Foundation\n\nextension BinaryInteger {\n  var isPrime: Bool {\n    if self == 0 || self == 1 {\n      return false\n    } else if self == 2 {\n      return true\n    }\n\n    let max = Self(ceil((Double(self).squareRoot())))\n\n    for i in stride(from: 2, through: max, by: 1) where self % i == 0  {\n      return false\n    }\n\n    return true\n  }\n\n  func modPow(exp: Self, mod: Self) -> Self {\n    guard exp != 0 else {\n      return 1\n    }\n\n    var res = Self(1)\n    var base = self % mod\n    var exp = exp\n\n    while true {\n      if exp & 1 == 1 {\n        res *= base\n        res %= mod\n      }\n\n      if exp == 1 {\n        return res\n      }\n\n      exp >>= 1\n      base *= base\n      base %= mod\n    }\n  }\n}\n\nfunc mFactor(exp: Int) -> Int? {\n  for k in 0..<16384 {\n    let q = 2*exp*k + 1\n\n    if !q.isPrime {\n      continue\n    } else if q % 8 != 1 && q % 8 != 7 {\n      continue\n    } else if 2.modPow(exp: exp, mod: q) == 1 {\n      return q\n    }\n  }\n\n  return nil\n}\n\nprint(mFactor(exp: 929)!)\n\n\nOutput:\n13007\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Visual_Basic", "code": "\nTranslation of: BBC BASIC\nWorks with: Visual Basic version VB6 Standard\nSub mersenne()\n    Dim q As Long, k As Long, p As Long, d As Long\n    Dim factor As Long, i As Long, y As Long, z As Long\n    Dim prime As Boolean\n    q = 929   'input value\n    For k = 1 To 1048576   '2**20\n        p = 2 * k * q + 1\n        If (p And 7) = 1 Or (p And 7) = 7 Then    'p=*001 or p=*111\n            'p is prime?\n            prime = False\n            If p Mod 2 = 0 Then GoTo notprime\n            If p Mod 3 = 0 Then GoTo notprime\n            d = 5\n            Do While d * d <= p\n                If p Mod d = 0 Then GoTo notprime\n                d = d + 2\n                If p Mod d = 0 Then GoTo notprime\n                d = d + 4\n            Loop\n            prime = True\n        notprime:   'modpow\n            i = q: y = 1: z = 2\n            Do While i   'i <> 0\n                On Error GoTo okfactor\n                If i And 1 Then y = (y * z) Mod p  'test first bit\n                z = (z * z) Mod p\n                On Error GoTo 0\n                i = i \\ 2\n            Loop\n            If prime And y = 1 Then factor = p: GoTo okfactor\n        End If\n    Next k\n    factor = 0\nokfactor:\n    Debug.Print \"M\" & q, \"factor=\" & factor\nEnd Sub\n\n\nOutput:\nM47           factor=2351\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;\n--  reuse Is_Prime from [[Primality by Trial Division]]\nwith Is_Prime;\n\nprocedure Mersenne is\n   function Is_Set (Number : Natural; Bit : Positive) return Boolean is\n   begin\n      return Number / 2 ** (Bit - 1) mod 2 = 1;\n   end Is_Set;\n\n   function Get_Max_Bit (Number : Natural) return Natural is\n      Test : Natural := 0;\n   begin\n      while 2 ** Test <= Number loop\n         Test := Test + 1;\n      end loop;\n      return Test;\n   end Get_Max_Bit;\n\n   function Modular_Power (Base, Exponent, Modulus : Positive) return Natural is\n      Maximum_Bit : constant Natural := Get_Max_Bit (Exponent);\n      Square      : Natural := 1;\n   begin\n      for Bit in reverse 1 .. Maximum_Bit loop\n         Square := Square ** 2;\n         if Is_Set (Exponent, Bit) then\n            Square := Square * Base;\n         end if;\n         Square := Square mod Modulus;\n      end loop;\n      return Square;\n   end Modular_Power;\n\n   Not_A_Prime_Exponent : exception;\n\n   function Get_Factor (Exponent : Positive) return Natural is\n      Factor : Positive;\n   begin\n      if not Is_Prime (Exponent) then\n         raise Not_A_Prime_Exponent;\n      end if;\n      for K in 1 .. 16384 / Exponent loop\n         Factor := 2 * K * Exponent + 1;\n         if Factor mod 8 = 1 or else Factor mod 8 = 7 then\n            if Is_Prime (Factor) and then Modular_Power (2, Exponent, Factor) = 1 then\n               return Factor;\n            end if;\n         end if;\n      end loop;\n      return 0;\n   end Get_Factor;\n\n   To_Test : constant Positive := 929;\n   Factor  : Natural;\nbegin\n   Ada.Text_IO.Put (\"2 **\" & Integer'Image (To_Test) & \" - 1 \");\n   begin\n      Factor := Get_Factor (To_Test);\n      if Factor = 0 then\n         Ada.Text_IO.Put_Line (\"is prime.\");\n      else\n         Ada.Text_IO.Put_Line (\"has factor\" & Integer'Image (Factor));\n      end if;\n   exception\n      when Not_A_Prime_Exponent =>\n         Ada.Text_IO.Put_Line (\"is not a Mersenne number\");\n   end;\nend Mersenne;\n\n\nOutput:\n2 ** 929 - 1 has factor 13007\n", "explain": "mersenne.adb:\n"}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Julia", "code": "\n# v0.6\n\nusing Primes\n\nfunction mersennefactor(p::Int)::Int\n    q = 2p + 1\n    while true\n        if log2(q) > p / 2\n            return -1\n        elseif q % 8 in (1, 7) && Primes.isprime(q) && powermod(2, p, q) == 1\n            return q\n        end\n    q += 2p\n    end\nend\n\nfor i in filter(Primes.isprime, push!(collect(1:20), 929))\n    mf = mersennefactor(i)\n    if mf != -1 println(\"M$i = \", mf, \" \u00d7 \", (big(2) ^ i - 1) \u00f7 mf)\n    else println(\"M$i is prime\") end\nend\n\n\nOutput:\nM2 is prime\nM3 is prime\nM5 is prime\nM7 is prime\nM11 = 23 \u00d7 89\nM13 is prime\nM17 is prime\nM19 is prime\nM929 = 13007 \u00d7 34889024892493825975045478116339093030512026953827804293400962134\n88946572057852012474541189660261508521493994102599382170621001921687473524507195\n61908445272675574320888385228421992652298715687625495638077382028762529439880103\n124705348782610789919949159935587158612289264184273\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Kotlin", "code": "\nTranslation of: C\n// version 1.0.6\n\nfun isPrime(n: Int): Boolean {\n    if (n < 2) return false\n    if (n % 2 == 0) return n == 2\n    if (n % 3 == 0) return n == 3\n    var d = 5\n    while (d * d <= n) {\n        if (n % d == 0) return false\n        d += 2\n        if (n % d == 0) return false\n        d += 4\n    }\n    return true\n}\n\nfun main(args: Array<String>) {\n    // test 929 plus all prime numbers below 100 which are known not to be Mersenne primes\n    val q = intArrayOf(11, 23, 29, 37, 41, 43, 47, 53, 59, 67, 71, 73, 79, 83, 97, 929)\n    for (k in 0 until q.size) {\n        if (isPrime(q[k])) {\n            var i: Long\n            var d: Int\n            var p: Int\n            var r: Int = q[k]\n            while (r > 0) r = r shl 1\n            d = 2 * q[k] + 1\n            while (true) {\n                i = 1L\n                p = r\n                while (p != 0) {\n                    i = (i * i) % d\n                    if (p < 0) i *= 2\n                    if (i > d) i -= d\n                    p = p shl 1\n                }\n                if (i != 1L)\n                    d += 2 * q[k]\n                else\n                    break\n            }\n            println(\"2^${\"%3d\".format(q[k])} - 1 = 0 (mod $d)\")\n        } else {\n            println(\"${q[k]} is not prime\")\n        }\n    }\n}\n\n\nOutput:\n2^ 11 - 1 = 0 (mod 23)\n2^ 23 - 1 = 0 (mod 47)\n2^ 29 - 1 = 0 (mod 233)\n2^ 37 - 1 = 0 (mod 223)\n2^ 41 - 1 = 0 (mod 13367)\n2^ 43 - 1 = 0 (mod 431)\n2^ 47 - 1 = 0 (mod 2351)\n2^ 53 - 1 = 0 (mod 6361)\n2^ 59 - 1 = 0 (mod 179951)\n2^ 67 - 1 = 0 (mod 193707721)\n2^ 71 - 1 = 0 (mod 228479)\n2^ 73 - 1 = 0 (mod 439)\n2^ 79 - 1 = 0 (mod 2687)\n2^ 83 - 1 = 0 (mod 167)\n2^ 97 - 1 = 0 (mod 11447)\n2^929 - 1 = 0 (mod 13007)\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Perl", "code": "\nuse strict;\nuse utf8;\n\nsub factors {\n\tmy $n = shift;\n\tmy $p = 2;\n\tmy @out;\n \n\twhile ($n >= $p * $p) {\n\t\twhile ($n % $p == 0) {\n\t\t\tpush @out, $p;\n\t\t\t$n /= $p;\n\t\t}\n\t\t$p = next_prime($p);\n\t}\n\tpush @out, $n if $n > 1 || !@out;\n\t@out;\n}\n \nsub next_prime {\n\tmy $p = shift;\n\tdo { $p = $p == 2 ? 3 : $p + 2 } until is_prime($p);\n\t$p;\n}\n \nmy %pcache;\nsub is_prime { \n\tmy $x = shift;\n\t$pcache{$x} //=\t(factors($x) == 1)\n}\n\nsub mtest {\n\tmy @bits = split \"\", sprintf(\"%b\", shift);\n\tmy $p = shift;\n\tmy $sq = 1;\n\twhile (@bits) {\n\t\t$sq = $sq * $sq;\n\t\t$sq *= 2 if shift @bits;\n\t\t$sq %= $p;\n\t}\n\t$sq == 1;\n}\n\nfor my $m (2 .. 60, 929) {\n\tnext unless is_prime($m);\n\tuse bigint;\n\n\tmy ($f, $k, $x) = (0, 0, 2**$m - 1);\n\n\tmy $q;\n\twhile (++$k) {\n\t\t$q = 2 * $k * $m + 1;\n\t\tnext if (($q & 7) != 1 && ($q & 7) != 7);\n\t\tnext unless is_prime($q);\n\t\tlast if $q * $q > $x;\n\t\tlast if $f = mtest($m, $q);\n\t}\n\n\tprint $f? \"M$m = $x = $q \u00d7 @{[$x / $q]}\\n\"\n\t\t: \"M$m = $x is prime\\n\";\n}\n\n\nOutput:\nM2 = 3 is prime\nM2 = 3 is prime\nM3 = 7 is prime\nM5 = 31 is prime\nM7 = 127 is prime\nM11 = 2047 = 23  \u00d7 89\nM13 = 8191 is prime\n...\nM53 = 9007199254740991 = 6361 \u00d7 1416003655831\nM59 = 576460752303423487 = 179951 \u00d7 3203431780337\nM929 = 4538..<yadda yadda>..8911 = 13007 \u00d7 348890..<blah blah>..84273\n\nuse Math::GMP;\n\n# Use GMP's simple probable prime test.\nsub is_prime { Math::GMP->new(shift)->probab_prime(20); }\n\n# Lucas-Lehmer test, deterministic for 2^p-1 given p\nsub is_mersenne_prime {\n  my($p, $mp, $s) = ($_[0], Math::GMP->new(2)**$_[0]-1, Math::GMP->new(4));\n  return 1 if $p == 2;\n  $s = ($s * $s - 2) % $mp  for 3 .. $p;\n  $s == 0;\n}\n\nfor my $p (2 .. 100, 929) {\n  next unless is_prime($p);\n  my $mp = Math::GMP->new(2) ** $p - 1;\n  my $lim = $mp->bsqrt();\n  $lim = 1000000 if $lim > 1000000;   # We're using it as a pre-test\n  my $factor;\n  for (my $q = Math::GMP->new(2*$p+1);  $q <= $lim && !$factor;  $q += 2*$p) {\n    next unless ($q & 7) == 1 || ($q & 7) == 7;\n    next unless is_prime($q);\n    $factor = $q if Math::GMP->new(2)->powm_gmp($p,$q) == 1;  #  $mp\u00a0% $q == 0\n  }\n  if ($factor) {\n    print \"M$p = $factor * \",$mp/$factor,\"\\n\";\n  } else {\n    print \"M$p is \", is_mersenne_prime($p) ? \"prime\" : \"composite\", \"\\n\";\n  }\n}\n\n\nOutput:\nM2 is prime\nM3 is prime\nM5 is prime\nM7 is prime\nM11 = 23 * 89\nM13 is prime\nM17 is prime\nM19 is prime\nM23 = 47 * 178481\nM29 = 233 * 2304167\nM31 is prime\nM37 = 223 * 616318177\nM41 = 13367 * 164511353\nM43 = 431 * 20408568497\nM47 = 2351 * 59862819377\nM53 = 6361 * 1416003655831\nM59 = 179951 * 3203431780337\nM61 is prime\nM67 is composite\nM71 = 228479 * 10334355636337793\nM73 = 439 * 21514198099633918969\nM79 = 2687 * 224958284260258499201\nM83 = 167 * 57912614113275649087721\nM89 is prime\nM97 = 11447 * 13842607235828485645766393\nM929 = 13007 * 348890248924[.....]64184273\n\n", "explain": "Following the task introduction, this uses GMP's modular exponentiation and simple probable prime test for the small numbers, then looks for small factors before doing a Lucas-Lehmer test.  For ranges above about p=2000, looking for small factors this way saves time (the amount of testing should be adjusted based on the input size and platform -- this example just uses a fixed amount).  Note as well that the Lucas-Lehmer test shown here is ignoring the large speedup we can get by optimizing the modulo operation, but that's a different task.\n"}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Prolog", "code": "\nmersenne_factor(P, F) :-\n    prime(P),\n    once((\n        between(1, 100_000, K),  % Fail if we can't find a small factor\n        Q is 2*K*P + 1,\n        test_factor(Q, P, F))).\n\ntest_factor(Q, P, prime) :- Q*Q > (1 << P - 1), !.\ntest_factor(Q, P, Q) :-\n    R is Q /\\ 7, member(R, [1, 7]),\n    prime(Q),\n    powm(2, P, Q) =:= 1.\n\n\nwheel235(L) :-\n   W = [4, 2, 4, 2, 4, 6, 2, 6 | W],\n   L = [1, 2, 2 | W].\n\nprime(N) :-\n   N >= 2,\n   wheel235(W),\n   prime(N, 2, W).\n\nprime(N, D, _) :- D*D > N, !.\nprime(N, D, [A|As]) :-\n    N mod D =\\= 0,\n    D2 is D + A, prime(N, D2, As).\n\n\nOutput:\n?- mersenne_factor(23, X).\nX = 47.\n\n?- mersenne_factor(5,X).\nX = prime.\n\n?- mersenne_factor(25,X).\nfalse.\n\n?- mersenne_factor(929,X).\nX = 13007.\n\n?- mersenne_factor(127,X).\nfalse.\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Scala", "code": "\nLibrary: Scala\nFull-blown version[edit]\n/** Find factors of a Mersenne number\n *\n * The implementation finds factors for M929 and further.\n *\n * @example M59 = 2^059 - 1 =             576460752303423487  (   2 msec)\n * @example = 179951 \u00d7 3203431780337.\n */\nobject FactorsOfAMersenneNumber extends App {\n\n  val two: BigInt = 2\n  // An infinite stream of primes, lazy evaluation and memo-ized\n  val oddPrimes = sieve(LazyList.from(3, 2))\n\n  def sieve(nums: LazyList[Int]): LazyList[Int] =\n    LazyList.cons(nums.head, sieve((nums.tail) filter (_ % nums.head != 0)))\n\n  def primes: LazyList[Int] = sieve(2 #:: oddPrimes)\n\n  def factorMersenne(p: Int): Option[Long] = {\n    val limit = (mersenne(p) - 1 min Int.MaxValue).toLong\n\n    def factorTest(p: Long, q: Long): Boolean = {\n      (List(1, 7) contains (q % 8)) && two.modPow(p, q) == 1 && BigInt(q).isProbablePrime(7)\n    }\n\n    // Build a stream of factors from (2*p+1) step-by (2*p)\n    def s(a: Long): LazyList[Long] = a #:: s(a + (2 * p)) // Build stream of possible factors\n\n    // Limit and Filter Stream and then take the head element\n    val e = s(2 * p + 1).takeWhile(_ < limit).filter(factorTest(p, _))\n    e.headOption\n  }\n\n  def mersenne(p: Int): BigInt = (two pow p) - 1\n\n  // Test\n  (primes takeWhile (_ <= 97)) ++ List(929, 937) foreach { p => { // Needs some intermediate results for nice formatting\n    val nMersenne = mersenne(p);\n    val lit = s\"${nMersenne}\"\n    val preAmble = f\"${s\"M${p}\"}%4s = 2^$p%03d - 1 = ${lit}%s\"\n\n    val datum = System.nanoTime\n    val result = factorMersenne(p)\n    val mSec = ((System.nanoTime - datum) / 1.0e+6).round\n\n    def decStr = {\n      if (lit.length > 30) f\"(M has ${lit.length}%3d dec)\" else \"\"\n    }\n\n    def sPrime: String = {\n      if (result.isEmpty) \" is a Mersenne prime number.\" else \" \" * 28\n    }\n\n    println(f\"$preAmble${sPrime} ${f\"($mSec%,1d\"}%13s msec)\")\n    if (result.isDefined)\n      println(f\"${decStr}%-17s = ${result.get} \u00d7 ${nMersenne / result.get}\")\n  }\n  }\n}\n\n\nOutput:\n  M2 = 2^002 - 1 =                              3 is a Mersenne prime number.           (63 msec)\n  M3 = 2^003 - 1 =                              7 is a Mersenne prime number.            (0 msec)\n  M5 = 2^005 - 1 =                             31 is a Mersenne prime number.            (1 msec)\n  M7 = 2^007 - 1 =                            127 is a Mersenne prime number.            (2 msec)\n M11 = 2^011 - 1 =                           2047                                    (2.097 msec)\n                  = 23 \u00d7 89\n M13 = 2^013 - 1 =                           8191 is a Mersenne prime number.           (33 msec)\n M17 = 2^017 - 1 =                         131071 is a Mersenne prime number.          (254 msec)\n M19 = 2^019 - 1 =                         524287 is a Mersenne prime number.          (524 msec)\n M23 = 2^023 - 1 =                        8388607                                        (0 msec)\n                  = 47 \u00d7 178481\n M29 = 2^029 - 1 =                      536870911                                        (0 msec)\n                  = 233 \u00d7 2304167\n M31 = 2^031 - 1 =                     2147483647 is a Mersenne prime number.       (31.484 msec)\n M37 = 2^037 - 1 =                   137438953471                                        (0 msec)\n                  = 223 \u00d7 616318177\n M41 = 2^041 - 1 =                  2199023255551                                        (0 msec)\n                  = 13367 \u00d7 164511353\n M43 = 2^043 - 1 =                  8796093022207                                        (0 msec)\n                  = 431 \u00d7 20408568497\n M47 = 2^047 - 1 =                140737488355327                                        (0 msec)\n                  = 2351 \u00d7 59862819377\n M53 = 2^053 - 1 =               9007199254740991                                        (0 msec)\n                  = 6361 \u00d7 1416003655831\n M59 = 2^059 - 1 =             576460752303423487                                        (1 msec)\n                  = 179951 \u00d7 3203431780337\n M61 = 2^061 - 1 =            2305843009213693951 is a Mersenne prime number.       (16.756 msec)\n M67 = 2^067 - 1 =          147573952589676412927                                    (1.435 msec)\n                  = 193707721 \u00d7 761838257287\n M71 = 2^071 - 1 =         2361183241434822606847                                        (2 msec)\n                  = 228479 \u00d7 10334355636337793\n M73 = 2^073 - 1 =         9444732965739290427391                                        (0 msec)\n                  = 439 \u00d7 21514198099633918969\n M79 = 2^079 - 1 =       604462909807314587353087                                        (0 msec)\n                  = 2687 \u00d7 224958284260258499201\n M83 = 2^083 - 1 =      9671406556917033397649407                                        (0 msec)\n                  = 167 \u00d7 57912614113275649087721\n M89 = 2^089 - 1 =    618970019642690137449562111 is a Mersenne prime number.       (11.097 msec)\n M97 = 2^097 - 1 = 158456325028528675187087900671                                        (0 msec)\n                  = 11447 \u00d7 13842607235828485645766393\nM929 = 2^929 - 1 = 4538015467766671944574165338592225830478699345884382504442663144885072806275648112625635725391102144133907238129251016389326737199538896813326509341743147661691195191795226666084858428449394948944821764472508048114220424520501343042471615418544488778723282182172070046459244838911                                        (0 msec)\n(M has 280 dec)   = 13007 \u00d7 348890248924938259750454781163390930305120269538278042934009621348894657205785201247454118966026150852149399410259938217062100192168747352450719561908445272675574320888385228421992652298715687625495638077382028762529439880103124705348782610789919949159935587158612289264184273\nM937 = 2^937 - 1 = 1161731959748268017810986326679609812602547032546401921137321765090578638406565916832162745700122148898280252961088260195667644723081957584211586391486245801392945969099578026517723757683045106929874371704962060317240428677248343818872733547147389127353160238636049931893566678761471                                        (0 msec)\n(M has 283 dec)   = 28111 \u00d7 41326596696960905617409068573854000661753300577937530544531385048222355604801178073784737138491058621119143856891902109340387916583613446131819799775399160520541637405271175928203328152077304504637841830776637626453716647477796727931156257235508844486256634009321971181870679761\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "D", "code": "\nimport std.stdio, std.math, std.traits;\n\nulong mersenneFactor(in ulong p) pure nothrow @nogc {\n    static bool isPrime(T)(in T n) pure nothrow @nogc {\n        if (n < 2 || n % 2 == 0)\n            return n == 2;\n        for (Unqual!T i = 3; i ^^ 2 <= n; i += 2)\n            if (n % i == 0)\n                return false;\n        return true;\n    }\n\n    static ulong modPow(in ulong cb, in ulong ce,in ulong m)\n    pure nothrow @nogc {\n        ulong b = cb;\n        ulong result = 1;\n        for (ulong e = ce; e > 0; e >>= 1) {\n            if ((e & 1) == 1)\n                result = (result * b) % m;\n            b = (b ^^ 2) % m;\n        }\n        return result;\n    }\n\n    immutable ulong limit = p <= 64 ? cast(ulong)(real(2.0) ^^ p - 1).sqrt : uint.max; // prevents silent overflows\n    for (ulong k = 1; (2 * p * k + 1) < limit; k++) {\n        immutable ulong q = 2 * p * k + 1;\n        if ((q % 8 == 1 || q % 8 == 7) && isPrime(q) && \n            modPow(2, p, q) == 1)\n            return q;\n    }\n    return 1; // returns a sensible smallest factor\n}\n\nvoid main() {\n    writefln(\"Factor of M929: %d\", 929.mersenneFactor);\n}\n\n\nOutput:\nFactor of M929: 13007\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Haskell", "code": "\n\nimport Data.List\nimport HFM.Primes (isPrime)\nimport Control.Monad\nimport Control.Arrow\n\nint2bin = reverse.unfoldr(\\x -> if x==0 then Nothing\n                                else Just ((uncurry.flip$(,))$divMod x 2))\n\ntrialfac m = take 1. dropWhile ((/=1).(\\q -> foldl (((`mod` q).).pm) 1 bs)) $ qs\n  where qs = filter (liftM2 (&&) (liftM2 (||) (==1) (==7) .(`mod`8)) isPrime ).\n              map (succ.(2*m*)). enumFromTo 1 $ m `div` 2\n        bs = int2bin m\n        pm n b = 2^b*n*n\n\n*Main> trialfac 929\n[13007]\n\n", "explain": "Using David Amos module Primes [1] for prime number testing:\n"}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "VBScript", "code": "\nTranslation of: REXX\n' Factors of a Mersenne number\n    for i=1 to 59\n        z=i\n        if z=59 then z=929  ':) 61 turns into 929.\n        if isPrime(z) then \n            r=testM(z)\n            zz=left(\"M\" & z & space(4),4)\n            if r=0 then \n                Wscript.echo zz & \" prime.\"\n            else \n                Wscript.echo zz & \" not prime, a factor: \" & r\n            end if\n        end if\n    next\n\nfunction modPow(base,n,div)\n    dim i,y,z\n    i = n : y = 1 : z = base\n    do while i\n        if i and 1 then y = (y * z) mod div\n        z = (z * z) mod div\n        i = i \\ 2\n    loop\n    modPow= y\nend function\n\nfunction isPrime(x)\n    dim i\n    if x=2 or x=3 or _\n       x=5 or x=7 _\n                  then isPrime=1: exit function\n    if x<11       then isPrime=0: exit function\n    if x mod 2=0  then isPrime=0: exit function\n    if x mod 3=0  then isPrime=0: exit function\n    i=5\n    do\n        if (x mod i)     =0 or _\n           (x mod (i+2)) =0 _\n                  then isPrime=0: exit function\n        if i*i>x  then isPrime=1: exit function\n        i=i+6\n    loop\nend function\n\nfunction testM(x)\n    dim sqroot,k,q\n    sqroot=Sqr(2^x)\n    k=1\n    do\n        q=2*k*x+1\n        if q>sqroot then exit do\n        if (q and 7)=1 or (q and 7)=7 then\n            if isPrime(q) then\n                if modPow(2,x,q)=1 then \n                    testM=q\n                    exit function\n                end if\n            end if\n        end if\n        k=k+1\n    loop\n    testM=0 \nend function\n\n\nOutput:\nM2   prime.\nM3   prime.\nM5   prime.\nM7   prime.\nM11  not prime, a factor: 23\nM13  prime.\nM17  prime.\nM19  prime.\nM23  not prime, a factor: 47\nM29  not prime, a factor: 233\nM31  prime.\nM37  not prime, a factor: 223\nM41  not prime, a factor: 13367\nM43  not prime, a factor: 431\nM47  not prime, a factor: 2351\nM53  not prime, a factor: 6361\nM929 not prime, a factor: 13007\n\n", "explain": ""}, {"task_name": "Factors of a Mersenne number", "task_url": "https://rosettacode.org/wiki/Factors_of_a_Mersenne_number", "task_cat": "Arithmetic", "lang": "Scheme", "code": "\n\n#lang scheme\n\n;;; this needs to be changed for other R6RS implementations\n(require rnrs/arithmetic/bitwise-6)\n\n;;; modpow, as per the task description.\n(define (modpow exponent base)\n  (let loop ([square 1] [index (- (bitwise-length exponent) 1)])\n    (if (< index 0)\n        square\n        (loop (modulo (* (if (bitwise-bit-set? exponent index) 2 1)\n                      square square) base)\n              (- index 1)))))\n\n;;; search through all integers from 1 on to find the first divisor\n;;; returns #f if 2^p-1 is prime\n(define (mersenne-factor p)\n  (for/first ((i (in-range 1 (floor (expt 2 (quotient p 2))) (* 2 p)))\n              #:when (and (or (= 1 (modulo i 8)) (= 7 (modulo i 8)))\n                          (= 1 (modpow p i))))\n    i))\n\n\nOutput:\n> (mersenne-factor 929)\n13007\n> (mersenne-factor 23)\n47\n> (mersenne-factor 3)\n#f\n\n", "explain": "This works with PLT Scheme, other implementations only need to change the inclusion.\n"}]