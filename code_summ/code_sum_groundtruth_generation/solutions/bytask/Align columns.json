[{"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Python", "code": "\nProcedural[edit]\nUsing f-strings[edit]\nfrom itertools import zip_longest\n\ntxt = \"\"\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\"\"\n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\nwidths = [max(len(word) for word in col) \n          for col in zip_longest(*parts, fillvalue='')]\n \nfor justify in \"<_Left ^_Center >_Right\".split():\n    j, jtext = justify.split('_')\n    print(f\"{jtext} column-aligned output:\\n\")\n    for line in parts:\n        print(' '.join(f\"{wrd:{j}{wdth}}\" for wdth, wrd in zip(widths, line)))\n    print(\"- \" * 52)\n\n\nOutput:\nLeft column-aligned output:\n\nGiven      a          txt        file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.  \nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nCenter column-aligned output:\n\n  Given        a         txt      file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space. \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nRight column-aligned output:\n\n     Given          a        txt   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - \nUsing StringIO[edit]\nfrom StringIO import StringIO\n \ntextinfile = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n \nj2justifier = dict(L=str.ljust, R=str.rjust, C=str.center)\n \ndef aligner(infile, justification = 'L'):\n  ''' \\\n  Justify columns of textual tabular input where the row separator is the newline\n  and the field separator is a 'dollar' character.\n  justification can be L, R, or C; (Left, Right, or Centered).\n \n  Return the justified output as a string\n  '''\n  assert justification in j2justifier, \"justification can be L, R, or C; (Left, Right, or Centered).\"\n  justifier = j2justifier[justification]\n \n  fieldsbyrow= [line.strip().split('$') for line in infile]\n  # pad to same number of fields per row\n  maxfields = max(len(row) for row in fieldsbyrow)\n  fieldsbyrow = [fields + ['']*(maxfields - len(fields))\n                    for fields in fieldsbyrow]\n  # rotate\n  fieldsbycolumn = zip(*fieldsbyrow)\n  # calculate max fieldwidth per column\n  colwidths = [max(len(field) for field in column)\n               for column in fieldsbycolumn]\n  # pad fields in columns to colwidth with spaces\n  fieldsbycolumn = [ [justifier(field, width) for field in column]\n                     for width, column in zip(colwidths, fieldsbycolumn) ]\n  # rotate again\n  fieldsbyrow = zip(*fieldsbycolumn)\n \n  return \"\\n\".join( \" \".join(row) for row in fieldsbyrow)\n \n \nfor align in 'Left Right Center'.split():\n  infile = StringIO(textinfile)\n  print \"\\n# %s Column-aligned output:\" % align\n  print aligner(infile, align[0])\n\n\nOutput:\n# Left Column-aligned output:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n\n# Right Column-aligned output:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.                     \n\n# Center Column-aligned output:\n  Given        a         text     file    of      many     lines,    where    fields  within   a    line \n   are     delineated     by       a    single  'dollar' character,  write      a    program             \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column      are     separated    by     at     least      one      space.                              \n Further,    allow       for      each   word      in        a       column     to      be   either left \njustified,   right    justified,   or   center justified   within     its    column.                     \nBrief native version[edit]\n\n'''\ncat <<'EOF' > align_columns.dat\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEOF\n'''\n\nfor align in '<^>':\n  rows = [ line.strip().split('$') for line in open('align_columns.dat') ]\n  fmts = [ '{:%s%d}' % (align, max( len(row[i]) if i < len(row) else 0 for row in rows ))\n           for i in range(max(map(len, rows))) ]\n  for row in rows:\n    print(' '.join(fmts).format(*(row + [''] * len(fmts))))\n  print('')\n\n\nAlternative[edit]\nTranslation of: D\ntxt = \"\"\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\"\"\n \nparts = [line.rstrip(\"$\").split(\"$\") for line in txt.splitlines()]\n \nmax_widths = {}\nfor line in parts:\n    for i, word in enumerate(line):\n        max_widths[i] = max(max_widths.get(i, 0), len(word))\n \nfor i, justify in enumerate([str.ljust, str.center, str.rjust]):\n    print([\"Left\", \"Center\", \"Right\"][i], \" column-aligned output:\\n\")\n    for line in parts:\n        for j, word in enumerate(line):\n            print(justify(word, max_widths[j]), end=' ')\n        print()\n    print(\"- \" * 52)\n\nFunctional[edit]\nAs a fold[edit]\n\nWorks with: Python version 3.7\n'''Variously aligned columns\n   from delimited text.\n'''\n\nfrom functools import reduce\nfrom itertools import repeat\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Test of three alignments.'''\n\n    txt = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n\n    rows = [x.split('$') for x in txt.splitlines()]\n    table = paddedRows(max(map(len, rows)))('')(rows)\n\n    print('\\n\\n'.join(map(\n        alignedTable(table)('  '),\n        [-1, 0, 1]  # Left, Center, Right\n    )))\n\n\n# alignedTable\u00a0:: [[String]] -> Alignment -> String -> String\ndef alignedTable(rows):\n    '''Tabulation of rows of cells, with cell alignment\n       specified by:\n           eAlign -1 = left\n           eAlign  0 = center\n           eAlign  1 = right\n       and separator between columns\n       supplied by the `sep` argument.\n    '''\n    def go(sep, eAlign):\n        lcr = ['ljust', 'center', 'rjust'][1 + eAlign]\n\n        # nextAlignedCol\u00a0:: [[String]] -> [String] -> [[String]]\n        def nextAlignedCol(cols, col):\n            w = max(len(cell) for cell in col)\n            return cols + [\n                [getattr(s, lcr)(w, ' ') for s in col]\n            ]\n\n        return '\\n'.join([\n            sep.join(cells) for cells in\n            zip(*reduce(nextAlignedCol, zip(*rows), []))\n        ])\n    return lambda sep: lambda eAlign: go(sep, eAlign)\n\n\n# GENERIC -------------------------------------------------\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -> [[a]]\ndef paddedRows(n):\n    '''A list of rows of even length,\n       in which each may be padded (but\n       not truncated) to length n with\n       appended copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return [pad(row) for row in xs]\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nGiven       a           text        file    of      many       lines,      where     fields   within   a       line  \nare         delineated  by          a       single  'dollar'   character,  write     a        program                \nthat        aligns      each        column  of      fields     by          ensuring  that     words    in      each  \ncolumn      are         separated   by      at      least      one         space.                                    \nFurther,    allow       for         each    word    in         a           column    to       be       either  left  \njustified,  right       justified,  or      center  justified  within      its       column.                         \n\n  Given         a          text      file     of       many      lines,     where     fields   within    a     line  \n   are      delineated      by        a     single   'dollar'  character,   write       a     program                \n   that       aligns       each     column    of      fields       by      ensuring    that    words     in    each  \n  column       are      separated     by      at      least       one       space.                                   \n Further,     allow        for       each    word       in         a        column      to       be    either  left  \njustified,    right     justified,    or    center  justified    within      its     column.                         \n\n     Given           a        text    file      of       many      lines,     where   fields   within       a  line  \n       are  delineated          by       a  single   'dollar'  character,     write        a  program                \n      that      aligns        each  column      of     fields          by  ensuring     that    words      in  each  \n    column         are   separated      by      at      least         one    space.                                  \n  Further,       allow         for    each    word         in           a    column       to       be  either  left  \njustified,       right  justified,      or  center  justified      within       its  column.      \n", "explain": "Works with Python 2 and 3.\n\nA fold/reduce between two transpositions. \n(Selection of string justification methods via getattr):\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "C", "code": "\n\n", "explain": "See Column Aligner/C\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "C++", "code": "\n\n", "explain": "See Column Aligner/C++\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Java", "code": "\nWorks with: Java version 7\nLibrary: Apache Commons Lang\nimport java.io.IOException;\nimport java.nio.charset.StandardCharsets;\nimport java.nio.file.Files;\nimport java.nio.file.Paths;\nimport java.util.ArrayList;\nimport java.util.List;\n\nimport org.apache.commons.lang3.StringUtils;\n\n/**\n * Aligns fields into columns, separated by \"|\"\n */\npublic class ColumnAligner {\n    private List<String[]> words = new ArrayList<>();\n    private int columns = 0;\n    private List<Integer> columnWidths = new ArrayList<>();\n\n    /**\n     * Initialize columns aligner from lines in a single string\n     * \n     * @param s\n     *            lines in a single string. Empty string does form a column.\n     */\n    public ColumnAligner(String s) {\n        String[] lines = s.split(\"\\\\n\");\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    /**\n     * Initialize columns aligner from lines in a list of strings\n     * \n     * @param lines\n     *            lines in a single string. Empty string does form a column.\n     */\n    public ColumnAligner(List<String> lines) {\n        for (String line : lines) {\n            processInputLine(line);\n        }\n    }\n\n    private void processInputLine(String line) {\n        String[] lineWords = line.split(\"\\\\$\");\n        words.add(lineWords);\n        columns = Math.max(columns, lineWords.length);\n        for (int i = 0; i < lineWords.length; i++) {\n            String word = lineWords[i];\n            if (i >= columnWidths.size()) {\n                columnWidths.add(word.length());\n            } else {\n                columnWidths.set(i, Math.max(columnWidths.get(i), word.length()));\n            }\n        }\n    }\n\n    interface AlignFunction {\n        String align(String s, int length);\n    }\n\n    /**\n     * Left-align all columns\n     * \n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignLeft() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.rightPad(s, length);\n            }\n        });\n    }\n\n    /**\n     * Right-align all columns\n     * \n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignRight() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.leftPad(s, length);\n            }\n        });\n    }\n\n    /**\n     * Center-align all columns\n     * \n     * @return Lines, terminated by \"\\n\" of columns, separated by \"|\"\n     */\n    public String alignCenter() {\n        return align(new AlignFunction() {\n            @Override\n            public String align(String s, int length) {\n                return StringUtils.center(s, length);\n            }\n        });\n    }\n\n    private String align(AlignFunction a) {\n        StringBuilder result = new StringBuilder();\n        for (String[] lineWords : words) {\n            for (int i = 0; i < lineWords.length; i++) {\n                String word = lineWords[i];\n                if (i == 0) {\n                    result.append(\"|\");\n                }\n                result.append(a.align(word, columnWidths.get(i)) + \"|\");\n            }\n            result.append(\"\\n\");\n        }\n        return result.toString();\n    }\n\n    public static void main(String args[]) throws IOException {\n        if (args.length < 1) {\n            System.out.println(\"Usage: ColumnAligner file [left|right|center]\");\n            return;\n        }\n        String filePath = args[0];\n        String alignment = \"left\";\n        if (args.length >= 2) {\n            alignment = args[1];\n        }\n        ColumnAligner ca = new ColumnAligner(Files.readAllLines(Paths.get(filePath), StandardCharsets.UTF_8));\n        switch (alignment) {\n        case \"left\":\n            System.out.print(ca.alignLeft());\n            break;\n        case \"right\":\n            System.out.print(ca.alignRight());\n            break;\n        case \"center\":\n            System.out.print(ca.alignCenter());\n            break;\n        default:\n            System.err.println(String.format(\"Error! Unknown alignment: '%s'\", alignment));\n            break;\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "C#", "code": "\nOld version[edit]\n\nWorks with: C# version 2+\nusing System;\nclass ColumnAlignerProgram\n{\n    delegate string Justification(string s, int width);\n\n    static string[] AlignColumns(string[] lines, Justification justification)\n    {\n        const char Separator = '$';\n        // build input table and calculate columns count\n        string[][] table = new string[lines.Length][];\n        int columns = 0;\n        for (int i = 0; i < lines.Length; i++)\n        {\n            string[] row = lines[i].TrimEnd(Separator).Split(Separator);\n            if (columns < row.Length) columns = row.Length;\n            table[i] = row;\n        }\n        // create formatted table\n        string[][] formattedTable = new string[table.Length][];\n        for (int i = 0; i < formattedTable.Length; i++)\n        {\n            formattedTable[i] = new string[columns];\n        }\n        for (int j = 0; j < columns; j++)\n        {\n            // get max column width\n            int columnWidth = 0;\n            for (int i = 0; i < table.Length; i++)\n            {\n                if (j < table[i].Length && columnWidth < table[i][j].Length)\n                    columnWidth = table[i][j].Length;\n            }\n            // justify column cells\n            for (int i = 0; i < formattedTable.Length; i++)\n            {\n                if (j < table[i].Length)\n                    formattedTable[i][j] = justification(table[i][j], columnWidth);\n                else \n                    formattedTable[i][j] = new String(' ', columnWidth);\n            }\n        }\n        // create result\n        string[] result = new string[formattedTable.Length];\n        for (int i = 0; i < result.Length; i++)\n        {\n            result[i] = String.Join(\" \", formattedTable[i]);\n        }\n        return result;\n    }\n\n    static string JustifyLeft(string s, int width) { return s.PadRight(width); }\n    static string JustifyRight(string s, int width) { return s.PadLeft(width); }\n    static string JustifyCenter(string s, int width) \n    { \n        return s.PadLeft((width + s.Length) / 2).PadRight(width); \n    }\n\n    static void Main()\n    {\n        string[] input = {    \n            \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n            \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n            \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n            \"column$are$separated$by$at$least$one$space.\",\n            \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n            \"justified,$right$justified,$or$center$justified$within$its$column.\",\n        };\n\n        foreach (string line in AlignColumns(input, JustifyCenter))\n        {\n            Console.WriteLine(line);\n        }\n    }\n}\n\nNewer version[edit]\n\nWorks with: C# version 8+\nusing System;\nusing System.Linq;\n\nenum Justification { Left, Center, Right }\n\npublic class Program\n{\n    static void Main()\n    {\n        string text =\n@\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\";\n\n        AlignColumns(text, Justification.Left);\n        Console.WriteLine();\n        AlignColumns(text, Justification.Center);\n        Console.WriteLine();\n        AlignColumns(text, Justification.Right);\n    }\n\n    public static void AlignColumns(string text, Justification justification) =>\n        AlignColumns(text.Split(Environment.NewLine), justification);\n\n    public static void AlignColumns(string[] lines, Justification justification) =>\n        AlignColumns(lines.Select(line => line.Split('$')).ToArray(), justification);\n\n    public static void AlignColumns(string[][] table, Justification justification)\n    {\n        Console.WriteLine(justification + \":\");\n        int columns = table.Max(line => line.Length);\n        var columnWidths =\n            Enumerable.Range(0, columns)\n            .Select(i => table.Max(line => i < line.Length ? line[i].Length : 0)\n            ).ToArray();\n        \n        foreach (var line in table) {\n            Console.WriteLine(string.Join(\" \",\n                Enumerable.Range(0, line.Length)\n                .Select(i => justification switch {\n                    Justification.Left => line[i].PadRight(columnWidths[i]),\n                    Justification.Right => line[i].PadLeft(columnWidths[i]),\n                    _ => line[i].PadLeft(columnWidths[i] / 2).PadRight(columnWidths[i])\n                })\n            ));\n        }\n    }    \n\n}\n\n\nOutput:\nLeft:\nGiven      a          text       file   of     many      lines,     where    fields  within   a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words    in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be       either left\njustified, right      justified, or     center justified within     its      column.\n\nCenter:\nGiven          a       text      file    of    many      lines,     where    fields  within     a    line\n  are      delineated    by        a    single 'dollar'  character, write      a     program\n that      aligns      each      column  of    fields       by      ensuring that    words     in    each\ncolumn       are      separated   by     at    least       one      space.\nFurther,   allow        for      each   word     in          a      column    to       be     either left\njustified, right      justified,  or    center justified within      its     column.\n\nRight:\n     Given          a       text   file     of      many     lines,    where  fields   within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that    words     in each\n    column        are  separated     by     at     least        one  space.\n  Further,      allow        for   each   word        in          a   column      to       be either left\njustified,      right justified,     or center justified     within      its column.\n", "explain": "Uses a delegate, which were added to the language in C# 2, to define left-, right-, or center-justified.\nUses features of newer versions, like LINQ, lambdas and switch expressions.\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "JavaScript", "code": "\nImperative[edit]\nvar justification=\"center\",\ninput=[\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n\"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n\"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n\"column$are$separated$by$at$least$one$space.\",\n\"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n\"justified,$right$justified,$or$center$justified$within$its$column.\"],\nx,y,cols,max,cols=0,diff,left,right\n\nString.prototype.repeat=function(n){return new Array(1 + parseInt(n)).join(this);}\n\nfor(x=0;x<input.length;x++) {\n input[x]=input[x].split(\"$\");\n if(input[x].length>cols) cols=input[x].length;\n}\nfor(x=0;x<cols;x++) {\n max=0;\n for(y=0;y<input.length;y++) if(input[y][x]&&max<input[y][x].length) max=input[y][x].length;\n for(y=0;y<input.length;y++) \n  if(input[y][x]) {\n   diff=(max-input[y][x].length)/2;\n   left=\" \".repeat(Math.floor(diff));\n   right=\" \".repeat(Math.ceil(diff));\n   if(justification==\"left\") {right+=left;left=\"\"}\n   if(justification==\"right\") {left+=right;right=\"\"}\n   input[y][x]=left+input[y][x]+right;\n  }\n}\nfor(x=0;x<input.length;x++) input[x]=input[x].join(\" \");\ninput=input.join(\"\\n\");\ndocument.write(input);\n\nFunctional[edit]\n//break up each string by '$'. The assumption is that the user wants the trailing $.\nvar data = [\n  \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\",\n  \"are$delineated$by$a$single$'dollar'$character,$write$a$program\",\n  \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\",\n  \"column$are$separated$by$at$least$one$space.\",\n  \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\",\n  \"justified,$right$justified,$or$center$justified$within$its$column.\"\n].map(function (str) { return str.split('$'); })\n\n//boilerplate: get longest array or string in array\nvar getLongest = function (arr) {\n  return arr.reduce(function (acc, item) { return acc.length > item.length ? acc : item; }, 0);\n};\n\n//boilerplate: this function would normally be in a library like underscore, lodash, or ramda\nvar zip = function (items, toInsert) {\n  toInsert = (toInsert === undefined) ? null : toInsert;\n  var longestItem = getLongest(items);\n  return longestItem.map(function (_unused, index) {\n    return items.map(function (item) {\n      return item[index] === undefined ? toInsert : item[index];\n    });\n  });\n};\n\n//here's the part that's not boilerplate\nvar makeColumns = function (formatting, data) {\n  var zipData = zip(data, '');\n  var makeSpaces = function (num) { return new Array(num + 1).join(' '); };\n  var formattedCols = zipData.map(function (column) {\n    var maxLen = getLongest(column).length;//find the maximum word length\n    if (formatting === 'left') {\n      return column.map(function (word) { return word + makeSpaces(maxLen - word.length); });\n    } else if (formatting === 'right') {\n      return column.map(function (word) { return makeSpaces(maxLen - word.length) + word; });\n    } else {\n      return column.map(function (word) {\n        var spaces = maxLen - word.length,\n            first = ~~(spaces / 2),\n            last = spaces - first;\n        return makeSpaces(first) + word + makeSpaces(last);\n      });\n    }\n  });\n\n  return zip(formattedCols).map(function (row) { return row.join(' '); }).join('\\n');\n};\n\n\n(function (strText) {\n    'use strict';\n \n    // [[a]] -> [[a]]\n    function transpose(lst) {\n        return lst[0].map(function (_, iCol) {\n            return lst.map(function (row) {\n                return row[iCol];\n            })\n        });\n    }\n \n    // (a -> b -> c) -> [a] -> [b] -> [c]\n    function zipWith(f, xs, ys) {\n        return xs.length === ys.length ? (\n            xs.map(function (x, i) {\n                return f(x, ys[i]);\n            })\n        ) : undefined;\n    }\n \n    // (a -> a -> Ordering) -> [a] -> a \n    function maximumBy(f, xs) {\n        return xs.reduce(function (a, x) {\n            return a === undefined ? x : (\n                f(x) > f(a) ? x : a\n            );\n        }, undefined)\n    }\n \n    // [String] -> String\n    function widest(lst) {\n        return maximumBy(length, lst)\n            .length;\n    }\n \n    // [[a]] -> [[a]]\n    function fullRow(lst, n) {\n        return lst.concat(Array.apply(null, Array(n - lst.length))\n            .map(function () {\n                return ''\n            }));\n    }\n \n    // String -> Int -> String\n    function nreps(s, n) {\n        var o = '';\n        if (n < 1) return o;\n        while (n > 1) {\n            if (n & 1) o += s;\n            n >>= 1;\n            s += s;\n        }\n        return o + s;\n    }\n \n    // [String] -> String\n    function unwords(xs) {\n        return xs.join('  ');\n    }\n \n    // [String] -> String\n    function unlines(xs) {\n        return xs.join('\\n');\n    }\n \n    // [a] -> Int\n    function length(xs) {\n        return xs.length;\n    }\n \n    // -- Int -> [String] -> [[String]]\n    function padWords(n, lstWords, eAlign) {\n        return lstWords.map(function (w) {\n            var lngPad = n - w.length;\n \n            return (\n                    (eAlign === eCenter) ? (function () {\n                        var lngHalf = Math.floor(lngPad / 2);\n \n                        return [\n                            nreps(' ', lngHalf), w,\n                            nreps(' ', lngPad - lngHalf)\n                        ];\n                    })() : (eAlign === eLeft) ? \n                        ['', w, nreps(' ', lngPad)] :\n                        [nreps(' ', lngPad), w, '']\n                )\n                .join('');\n        });\n    }\n \n    // MAIN\n \n    var eLeft = -1,\n        eCenter = 0,\n        eRight = 1;\n \n    var lstRows = strText.split('\\n')\n        .map(function (x) {\n            return x.split('$');\n        }),\n \n        lngCols = widest(lstRows),\n        lstCols = transpose(lstRows.map(function (r) {\n            return fullRow(r, lngCols)\n        })),\n        lstColWidths = lstCols.map(widest);\n \n    // THREE PARAGRAPHS, WITH VARIOUS WORD COLUMN ALIGNMENTS:\n \n    return [eLeft, eRight, eCenter]\n        .map(function (eAlign) {\n            var fPad = function (n, lstWords) {\n                return padWords(n, lstWords, eAlign);\n            };\n \n            return transpose(\n                    zipWith(fPad, lstColWidths, lstCols)\n                )\n                .map(unwords);\n        })\n        .map(unlines)\n        .join('\\n\\n');\n \n})(\n    \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\n\\\nare$delineated$by$a$single$'dollar'$character,$write$a$program\\n\\\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\n\\\ncolumn$are$separated$by$at$least$one$space.\\n\\\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\\n\\\njustified,$right$justified,$or$center$justified$within$its$column.\"\n);\n\n\nOutput:\nGiven       a           text        file    of      many       lines,      where     fields   within   a       line  \nare         delineated  by          a       single  'dollar'   character,  write     a        program                \nthat        aligns      each        column  of      fields     by          ensuring  that     words    in      each  \ncolumn      are         separated   by      at      least      one         space.                                    \nFurther,    allow       for         each    word    in         a           column    to       be       either  left  \njustified,  right       justified,  or      center  justified  within      its       column.                         \n\n     Given           a        text    file      of       many      lines,     where   fields   within       a  line  \n       are  delineated          by       a  single   'dollar'  character,     write        a  program                \n      that      aligns        each  column      of     fields          by  ensuring     that    words      in  each  \n    column         are   separated      by      at      least         one    space.                                  \n  Further,       allow         for    each    word         in           a    column       to       be  either  left  \njustified,       right  justified,      or  center  justified      within       its  column.                         \n\n  Given         a          text      file     of      many       lines,     where    fields   within     a     line  \n   are      delineated      by        a     single  'dollar'   character,   write       a     program                \n   that       aligns       each     column    of     fields        by      ensuring   that     words     in    each  \n  column       are      separated     by      at      least       one       space.                                   \n Further,     allow        for       each    word      in          a        column     to       be     either  left  \njustified,    right     justified,    or    center  justified    within      its     column.                         \n", "explain": "\nOr (ES5) using transpose and zipWith:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Visual_Basic_.NET", "code": "\nModule Module1\n    Private Delegate Function Justification(s As String, width As Integer) As String\n\n    Private Function AlignColumns(lines As String(), justification As Justification) As String()\n        Const Separator As Char = \"$\"c\n        ' build input container table and calculate columns count\n        Dim containerTbl As String()() = New String(lines.Length - 1)() {}\n        Dim columns As Integer = 0\n        For i As Integer = 0 To lines.Length - 1\n            Dim row As String() = lines(i).TrimEnd(Separator).Split(Separator)\n            If columns < row.Length Then\n                columns = row.Length\n            End If\n            containerTbl(i) = row\n        Next\n        ' create formatted container table\n        Dim formattedTable As String()() = New String(containerTbl.Length - 1)() {}\n        For i As Integer = 0 To formattedTable.Length - 1\n            formattedTable(i) = New String(columns - 1) {}\n        Next\n        For j As Integer = 0 To columns - 1\n            ' get max column width\n            Dim columnWidth As Integer = 0\n            For i As Integer = 0 To containerTbl.Length - 1\n                If j < containerTbl(i).Length AndAlso columnWidth < containerTbl(i)(j).Length Then\n                    columnWidth = containerTbl(i)(j).Length\n                End If\n            Next\n            ' justify column cells\n            For i As Integer = 0 To formattedTable.Length - 1\n                If j < containerTbl(i).Length Then\n                    formattedTable(i)(j) = justification(containerTbl(i)(j), columnWidth)\n                Else\n                    formattedTable(i)(j) = New [String](\" \"c, columnWidth)\n                End If\n            Next\n        Next\n        ' create result\n        Dim result As String() = New String(formattedTable.Length - 1) {}\n        For i As Integer = 0 To result.Length - 1\n            result(i) = [String].Join(\" \", formattedTable(i))\n        Next\n        Return result\n    End Function\n\n    Private Function JustifyLeft(s As String, width As Integer) As String\n        Return s.PadRight(width)\n    End Function\n    Private Function JustifyRight(s As String, width As Integer) As String\n        Return s.PadLeft(width)\n    End Function\n    Private Function JustifyCenter(s As String, width As Integer) As String\n        Return s.PadLeft((width + s.Length) / 2).PadRight(width)\n    End Function\n\n    Sub Main()\n        Dim input As String() = {\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\", \"are$delineated$by$a$single$'dollar'$character,$write$a$program\", \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\", \"column$are$separated$by$at$least$one$space.\", \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\", \"justified,$right$justified,$or$center$justified$within$its$column.\"}\n\n        For Each line As String In AlignColumns(input, AddressOf JustifyLeft)\n            Console.WriteLine(line)\n        Next\n        Console.ReadLine()\n    End Sub\n\nEnd Module\n\nOutput:\n-- Left:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n\n-- Center:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n\n-- Right:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "PHP", "code": "\n<?php\n$j2justtype = array('L' => STR_PAD_RIGHT,\n                    'R' => STR_PAD_LEFT,\n                    'C' => STR_PAD_BOTH);\n \n/**\n Justify columns of textual tabular input where the record separator is the newline\n and the field separator is a 'dollar' character.\n justification can be L, R, or C; (Left, Right, or Centered).\n \n Return the justified output as a string\n*/\nfunction aligner($str, $justification = 'L') {\n  global $j2justtype;\n  assert(array_key_exists($justification, $j2justtype));\n  $justtype = $j2justtype[$justification];\n\n  $fieldsbyrow = array();\n  foreach (explode(\"\\n\", $str) as $line)\n    $fieldsbyrow[] = explode('$', $line);\n  $maxfields = max(array_map('count', $fieldsbyrow));\n\n  foreach (range(0, $maxfields - 1) as $col) {\n    $maxwidth = 0;\n    foreach ($fieldsbyrow as $fields)\n      $maxwidth = max($maxwidth, strlen(array_key_exists($col, $fields) ? $fields[$col] : 0));\n    foreach ($fieldsbyrow as &$fields)\n      $fields[$col] = str_pad(array_key_exists($col, $fields) ? $fields[$col] : \"\", $maxwidth, ' ', $justtype);\n    unset($fields); // see http://bugs.php.net/29992\n  }\n  $result = '';\n  foreach ($fieldsbyrow as $fields)\n    $result .= implode(' ', $fields) . \"\\n\";\n  return $result;\n}\n\n$textinfile = 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$\\'dollar\\'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.';\n \nforeach (array('L', 'R', 'C') as $j)\n  echo aligner($textinfile, $j);\n\n?>\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Fortran", "code": "\n\n      SUBROUTINE RAKE(IN,M,X,WAY)\t!Casts forth text in fixed-width columns.\nCollates column widths so that each column is wide enough for its widest member.\n       INTEGER IN\t\t!Fingers the input file.\n       INTEGER M\t\t!Maximum record length thereof.\n       CHARACTER*1 X\t\t!The delimiter, possibly a comma.\n       INTEGER WAY\t\t!Alignment style.\n       INTEGER W(M + 1)\t\t!If every character were X in the maximum-length record,\n       INTEGER C(0:M + 1)\t!Then M + 1 would be the maximum number of fields possible.\n       CHARACTER*(M) ACARD\t!A scratchpad big enough for the biggest.\n       CHARACTER*(28 + 4*M) FORMAT\t!Guess. Allow for \"Ann,\" per field.\n       INTEGER I\t\t!A stepper.\n       INTEGER L,LF\t\t!Text fingers.\n       INTEGER NF,MF\t\t!Field counts.\n       CHARACTER*6 WAYNESS(-1:+1)\t!Some annotation may be helpful.\n       PARAMETER (WAYNESS = (/\"Left\",\"Centre\",\"Right\"/))\t!Using normal language.\n       INTEGER LINPR\t!The mouthpiece.\n       COMMON LINPR\t!Used all over.\n        W = 0\t\t!Maximum field widths so far seen.\n        MF = 0\t\t!Maximum number of fields to a record.\n        C(0) = 0\t!Syncopation for the first field's predecessor.\n        WRITE (LINPR,*)\t!Some separation.\n        WRITE (LINPR,*) \"Align \",WAYNESS(MIN(MAX(WAY,-1),+1))\t!Explain, cautiously.\n\nChase through the file assessing the lengths of each field.\n   10   READ (IN,11,END = 20) L,ACARD(1:L)\t!Grab a record.\n   11   FORMAT (Q,A)\t\t\t\t!Working only up to its end.\n        CALL LIZZIEBORDEN\t!Find the chop points.\n        W(1:NF) = MAX(W(1:NF),C(1:NF) - C(0:NF - 1) - 1)\t!Thereby the lengths between.\n        MF = MAX(MF,NF)\t\t!Also want to know the most number of chops.\n        GO TO 10\t\t!Get the next record.\n\nConcoct a FORMAT based on the maximum size of each field. Plus one.\n   20   REWIND(IN)\t\t!Back to the beginning.\n        WRITE (FORMAT,21) W(1:MF) + 1\t!Add one to meet the specified at least one space between columns.\n   21   FORMAT (\"(\",<MF>(\"A\",I0,\",\"))\t!Generates a sequence of An, items.\n        LF = INDEX(FORMAT,\", \")\t\t!The last one has a trailing comma.\n        IF (LF.LE.0) STOP \"Format trouble!\"\t!Or, maybe not!\n        FORMAT(LF:LF) = \")\"\t\t\t!Convert it to the closing bracket.\n        WRITE (LINPR,*) \"Format\",FORMAT(1:LF)\t!Present it.\n\nChug afresh, this time knowing the maximum length of each field.\n   30   READ (IN,11,END = 40) L,ACARD(1:L)\t!Place just the record's content.\n        CALL LIZZIEBORDEN\t\t!Find the chop points.\n        SELECT CASE(WAY)\t!What is to be done?\n         CASE(-1)\t\t!Shove leftwards by appending spaces.\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t!The chopped text.\n     1     REPEAT(\" \",W(I) - C(I) + C(I - 1) + 1),I = 1,NF)\t!Some spaces.\n         CASE( 0)\t\t!Centre by appending half as many spaces.\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1)//\t!The chopped text.\n     1     REPEAT(\" \",(W(I) - C(I) + C(I - 1) + 1)/2),I = 1,NF)\t!Some spaces.\n         CASE(+1)\t\t!Align rightwards is the default style.\n          WRITE (LINPR,FORMAT) (ACARD(C(I - 1) + 1:C(I) - 1),I = 1,NF)\t!So, just the texts.\n         CASE DEFAULT\t\t!This shouldn't happen.\n         WRITE (LINPR,*) \"Huh? WAY=\",WAY\t!But if it does,\n         STOP \"Unanticipated value for WAY!\"\t!Explain.\n        END SELECT\t\t!So much for that record.\n        GO TO 30\t\t!Go for another.\nClosedown\n   40   REWIND(IN)\t\t!Be polite.\n       CONTAINS\t!This also marks the end of source for RAKE...\n        SUBROUTINE LIZZIEBORDEN\t!Take an axe to ACARD, chopping at X.\n          NF = 0\t\t!No strokes so far.\n          DO I = 1,L\t\t!So, step away.\n            IF (ICHAR(ACARD(I:I)).EQ.ICHAR(X)) THEN\t!Here?\n              NF = NF + 1\t\t!Yes!\n              C(NF) = I\t\t!The place!\n            END IF\t\t!So much for that.\n          END DO\t\t!On to the next.\n          NF = NF + 1\t\t!And the end of ACARD is also a chop point.\n          C(NF) = L + 1\t\t!As if here.\n        END SUBROUTINE LIZZIEBORDEN\t!She was aquitted.\n      END SUBROUTINE RAKE\t!So much raking over.\n\n      INTEGER L,M,N\t!To be determined the hard way.\n      INTEGER LINPR,IN\t!I/O unit numbers.\n      COMMON LINPR\t!Some of general note.\n      LINPR = 6\t\t!Standard output via this unit number.\n      IN = 10\t\t!Some unit number for the input file.\n      OPEN (IN,FILE=\"Rake.txt\",STATUS=\"OLD\",ACTION=\"READ\")\t!For formatted input.\n      N = 0\t\t!No records read.\n      M = 0\t\t!Longest record so far.\n\n    1 READ (IN,2,END = 10) L\t!How long is this record?\n    2 FORMAT (Q)\t!Obviously, Q specifies the length, not a content field.\n      N = N + 1\t\t!Anyway, another record has been read.\n      M = MAX(M,L)\t!And this is the longest so far.\n      GO TO 1\t\t!Go back for more.\n\n   10 REWIND (IN)\t!We're ready now.\n      WRITE (LINPR,*) N,\"Recs, longest rec. length is \",M\n      CALL RAKE(IN,M,\"$\",-1)\t!Align left.\n      CALL RAKE(IN,M,\"$\", 0)\t!Centre.\n      CALL RAKE(IN,M,\"$\",+1)\t!Align right.\n      END\t!That's all.\n\n\n          6 Recs, longest rec. length is           66\n\nAlign Left\nFormat(A11,A11,A11,A7,A7,A10,A11,A9,A8,A8,A7,A5,A1)\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\nAlign Centre\nFormat(A11,A11,A11,A7,A7,A10,A11,A9,A8,A8,A7,A5,A1)\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line\n    are    delineated     by        a   single  'dollar' character,   write     a    program\n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each\n  column       are     separated   by     at     least       one     space.\n Further,     allow       for     each   word      in         a      column     to      be   either left\njustified,    right   justified,   or   center justified   within      its   column.\n\nAlign Right\nFormat(A11,A11,A11,A7,A7,A10,A11,A9,A8,A8,A7,A5,A1)\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n\n", "explain": "For the general situation, a utility has no knowledge of the maximum number of fields in a record nor the maximum length of a record, still less knowledge of the sizes of the fields in the records. Decent file systems (for example, that of the Burroughs 6700) make available the MaxRecordLength of a file when a file is opened, but many systems are less than helpful. It is possible to open a file as UNFORMATTED and then simply read sequences of binary data to be interpreted to taste, but in the ASCII world that means deciding on record markers being CR, CRLF, LF, or LFCR and I have encountered files with mixtures... In any case, a file with a fixed record length will likely not contain any such markers.\nThe plan here is to read the file to find out. But, given that the maximum record length is unknown, reading records into some storage area is problematical. Some systems can create a \"string\" variable via the read statement that will be of the proper size, but older Fortran works always with storage sizes fixed at compile time. However, after F77 started being extended, a common extension was the Q-element in FORMAT statements, which instead of interpreting the content of a record, reports instead the number of characters yet unread in a record. Thus, a statement like READ(in,\"(Q)\") L will read a record of input and the first action is to place in variable L the number of characters yet to be processed of that record. Since the content of the record is not being transferred, there is no need for a CHARACTER area of sufficient size to receive all of it. Indeed here, nothing is read. As for the LF/CRLF/LFCR/CR issue, with FORMATTED input the file system makes its decision and presents record content without incorporating such out-of-context data.\nWhen data are being read into a CHARACTER variable, once the receiver is filled subsequent data in a long record will be ignored, and if the input record was smaller than the variable, trailing spaces will be supplied to fill out the variable. It is for this reason that the read statement is READ (IN,11,END = 20) L,ACARD(1:L) so that, on-the-fly, the length of the record is determined, and then only that number of characters are placed in ACARD with no (possibly large number of) trailing spaces being appended. Naturally, subsequent inspection of ACARD will have to be careful not to look beyond character L, where detritus from previous usage will languish. \nOnce the main programme has ascertained the maximum record length, subroutine RAKE can be invoked with this as a parameter. From F90 on, as introduced by Algol in the 1960s, functions and subroutines have been allowed to declare arrays of a size specified by a variable and so the \"surely big enough\" issue is reduced. Thus, given a maximum length of M, a record containing M field delimiters can represent M + 1 fields, all null. The last field's delimiter is the end-of-record, so one more. It is also possible to use ALLOCATE(...) to request storage of suitable dimension for a variable within a routine, but that introduces verbiage. So, a programme can request just enough storage for its particular tasks and thereby possibly succeed on a problem too large for an always-big-enough storage scheme, but on the other hand, the fixed storage allocation scheme doesn't suddenly run out in the middle of a job.\nAccordingly, a second scan of the records of the text file can be made, with a view to ascertaining the maximum widths for the first, second, etc. columns. This is done by storing in array C the positions of the delimiters in the text, so the content of a field i on a record will be starting with C(I - 1) + 1, and ending with C(I) - 1, - that is, the first character following a delimiter to the last character before a delimiter. In other words, the delimiter is not a part of the field's content. For convenience in this, C(0) = 0, since the first field is number one, and the last field's delimiter is one past the end of the record. Having an array start with non-default bounds is a feature of F90, similarly the array assignment that tracks the maximum field widths in array W. The specification makes no call for leading or trailing spaces in a field's content to be trimmed; if it did then two sets of fingers would be used to mark the first and last position of each text. Happily, there is also no call to recognise quoted texts, that might contain delimiter characters that are not delimiters.\nEquipped at last with knowledge of each column's maximum width, yet another pass can be made through the file to produce the output. A feature of the format code Aw is that text is aligned to the right within the width of w. So, concoct a FORMAT text with suitable Aw entries, also augmenting the width by one for each column to meet the requirement that each column's content is separated from the others by at least one space. This concoction is easy enough, and could be improved by taking advantage of the \"factoring\" that format statements allow so that for example \"A7,A7\" can be replaced by \"2A7\", and further, bracketing of sequences is allowed and with repeat counts for them also. Alas, finding the minimum sequence is in general a very difficult problem, so no attempt is made. As for \"sufficient storage\" for the FORMAT variable, a two-digit width specification seems sufficient so each field's format code would be \"Add,\" - four characters. Only later Fortran allows the I0 format code, meaning that an integer will be written only with sufficient digits, not a fixed \"sufficiency\" of digits. A pity the code for this isn't just \"I\" rather than \"I0\" which implies a width of zero.\nA difficulty now arises in terminating the format text with the closing bracket. This is done by searching for the sequence \", \" and replacing the comma by the closing bracket. This is present only because format 21 specifies <MF> as a repeat count. If it were say 666 instead, after the last W value was written the format processing would cycle back to its next repetition, write out an \"A\", then stop since there is no W value to write via the \"I0\" format code. Thus, the format text ends \",A\" and the INDEX fails to find the desired \", \". It could instead search for \",A \" (just \",A\" would stop on the second field's format code) but \", \" seems clear. The <MF> usage is standard only for recent Fortran. Formatted output opportunities are many and options numerous. Other schemes could be used, such as the write statement specifying the text literals in its items, but that would require an implied-DO output list and it seemed nicer to be able to use the array specification W(1:MF) instead.\nGiven a FORMAT text that produces output in aligned columns makes it easy enough to meet the other requirements. To cause texts to be aligned left, append sufficient spaces to each output text, and for centred text, half that number. This relies on the special intrinsic function REPEAT(text,n) returning a varying number of characters - CHARACTER functions have to return a fixed number of characters, until the standardisation of varying-length strings in F2003 et seq. Earlier Fortrans lack the REPEAT function, but its effect can be gained via something like CHARACTER*66 SPACE, where SPACE is set to spaces, and SPACE(1:N) is used where REPEAT(\" \",N) is desired. And if messing with variable FORMAT is unwanted, the REPEAT scheme can be used for the right-justified output also.\nEvery line of output starts with a space, and if it were to be sent to a lineprinter, this would be used as the carriage control character (meaning, advance one line then print the rest) - the first column does not need to be set off by one space from the previous column,  but rather than devise special treatment it is spaced off anyway. The free-format output statements also start with a space. Output:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nconst text = `Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.`\n\ntype formatter struct {\n    text  [][]string\n    width []int\n}\n\nfunc newFormatter(text string) *formatter {\n    var f formatter\n    for _, line := range strings.Split(text, \"\\n\") {\n        words := strings.Split(line, \"$\")\n        for words[len(words)-1] == \"\" {\n            words = words[:len(words)-1]\n        }\n        f.text = append(f.text, words)\n        for i, word := range words {\n            if i == len(f.width) {\n                f.width = append(f.width, len(word))\n            } else if len(word) > f.width[i] {\n                f.width[i] = len(word)\n            }\n        }\n    }\n    return &f\n}\n\nconst (\n    left = iota\n    middle\n    right\n)\n\nfunc (f formatter) print(j int) {\n    for _, line := range f.text {\n        for i, word := range line {\n            fmt.Printf(\"%-*s \", f.width[i], fmt.Sprintf(\"%*s\",\n                len(word)+(f.width[i]-len(word))*j/2, word))\n        }\n        fmt.Println(\"\")\n    }\n    fmt.Println(\"\")\n}\n\nfunc main() {\n    f := newFormatter(text)\n    f.print(left)\n    f.print(middle)\n    f.print(right)\n}\n\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program alignColumn.s     */\n \n /* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ BUFFERSIZE, 20 * 10\n \n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessLeft:        .asciz \"LEFT\u00a0:\\n\"\nszMessRight:       .asciz \"\\nRIGHT\u00a0:\\n\" \nszMessCenter:      .asciz \"\\nCENTER\u00a0:\\n\" \nszCarriageReturn:  .asciz \"\\n\"\n\nszLine1:    .asciz \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\nszLine2:    .asciz \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\nszLine3:    .asciz \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\nszLine4:    .asciz \"column$are$separated$by$at$least$one$space.\"\nszLine5:    .asciz \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\nszLine6:    .asciz \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\nitbPtLine:    .int szLine1,szLine2,szLine3,szLine4,szLine5,szLine6\n              .equ NBLINES, (. - itbPtLine) / 4\n \n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                               @ entry of program \n    ldr r0,iAdritbPtLine\n    bl computeMaxiLengthWords\n    mov r10,r0                      @ column counter\n    ldr r0,iAdrszMessLeft\n    bl affichageMess\n    ldr r0,iAdritbPtLine\n    mov r1,r10                      @ column size\n    bl alignLeft\n    ldr r0,iAdrszMessRight\n    bl affichageMess\n    ldr r0,iAdritbPtLine\n    mov r1,r10                      @ column size\n    bl alignRight\n    ldr r0,iAdrszMessCenter\n    bl affichageMess\n    ldr r0,iAdritbPtLine\n    mov r1,r10                      @ column size\n    bl alignCenter\n100:                                @ standard end of the program \n    mov r0, #0                      @ return code\n    mov r7, #EXIT                   @ request to exit program\n    svc #0                          @ perform the system call\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessLeft:           .int szMessLeft\niAdrszMessRight:          .int szMessRight\niAdrszMessCenter:         .int szMessCenter\niAdritbPtLine:            .int itbPtLine\n/******************************************************************/\n/*      compute maxi words                                 */ \n/******************************************************************/\n/* r0 contains adresse pointer array */\ncomputeMaxiLengthWords:\n    push {r1-r6,lr}          @ save registers\n    mov r2,#0                @ indice pointer array\n    mov r3,#0                @ maxi length words\n1:\n    ldr r1,[r0,r2,lsl #2]    @ load pointer\n    mov r4,#0                @ length words counter\n    mov r5,#0                @ indice line character\n2:\n    ldrb r6,[r1,r5]          @ load a line character\n    cmp r6,#0                @ line end\u00a0?\n    beq 4f\n    cmp r6,#'$'              @ separator\u00a0?\n    bne 3f\n    cmp r4,r3\n    movgt r3,r4              @ ig greather replace maxi\n    mov r4,#-1               @ raz length counter\n3:\n    add r4,r4,#1\n    add r5,r5,#1             @ increment character indice\n    b 2b                     @ and loop\n4:                           @ end line\n    cmp r4,r3                @ compare word counter and maxi\n    movgt r3,r4              @ if greather replace maxi\n    add r2,r2,#1             @ increment indice line pointer\n    cmp r2,#NBLINES          @ maxi\u00a0?\n    blt 1b                   @ no -> loop\n\n    mov r0,r3                @ return maxi length counter\n100:\n    pop {r1-r6,pc}\n\n/******************************************************************/\n/*      align left                                                */ \n/******************************************************************/\n/* r0 contains the address of pointer array*/\n/* r1 contains column size */\nalignLeft:\n    push {r4-r7,fp,lr}       @ save registers\n    sub sp,sp,#BUFFERSIZE    @ reserve place for output buffer\n    mov fp,sp\n    mov r5,r0                @ array address\n    mov r2,#0                @ indice array\n1:\n    ldr r3,[r5,r2,lsl #2]    @ load line pointer\n    mov r4,#0                @ line character indice\n    mov r7,#0                @ output buffer character indice\n    mov r6,#0                @ word lenght \n2:\n    ldrb r0,[r3,r4]          @ load a character line\n    strb r0,[fp,r7]          @ store in buffer\n    cmp r0,#0                @ line end\u00a0?\n    beq 6f\n    cmp r0,#'$'              @ separator\u00a0?\n    bne 5f\n    mov r0,#' '\n    strb r0,[fp,r7]          @ replace $ by space\n3:\n    cmp r6,r1                @ length word >= length column\n    bge 4f\n    add r7,r7,#1\n    mov r0,#' '\n    strb r0,[fp,r7]          @ add space to buffer\n    add r6,r6,#1\n    b 3b                     @ and loop\n4:\n    mov r6,#-1               @ raz word length\n5:\n    add r4,r4,#1             @ increment line indice\n    add r7,r7,#1             @ increment buffer indice\n    add r6,r6,#1             @ increment word length\n    b 2b\n    \n6:\n    mov r0,#'\\n'\n    strb r0,[fp,r7]          @ return line\n    add r7,r7,#1\n    mov r0,#0\n    strb r0,[fp,r7]          @ final z\u00e9ro\n    mov r0,fp\n    bl affichageMess         @ display output buffer\n    add r2,r2,#1\n    cmp r2,#NBLINES\n    blt 1b\n    \n100:\n    add sp,sp,#BUFFERSIZE\n    pop {r4-r7,fp,pc}\n/******************************************************************/\n/*      align right                                                */ \n/******************************************************************/\n/* r0 contains the address of pointer array*/\n/* r1 contains column size */\nalignRight:\n    push {r4-r9,fp,lr}       @ save registers\n    sub sp,sp,#BUFFERSIZE    @ reserve place for output buffer\n    mov fp,sp\n    mov r5,r0                @ array address\n    mov r2,#0                @ indice array\n1:\n    ldr r3,[r5,r2,lsl #2]    @ load line pointer\n    mov r4,#0                @ line character indice\n    mov r7,#0                @ output buffer character indice\n    mov r6,#0                @ word lenght \n    mov r8,r3                @ word begin address\n2:                           @ compute word length\n    ldrb r0,[r3,r4]          @ load a character line\n    cmp r0,#0                @ line end\u00a0?\n    beq 3f\n    cmp r0,#'$'              @ separator\u00a0?\n    beq 3f\n    add r4,r4,#1             @ increment line indice\n    add r6,r6,#1             @ increment word length\n    b 2b\n\n3:\n    cmp r6,#0\n    beq 4f\n    sub r6,r1,r6             @ compute left spaces to add\n4:                           @ loop add spaces to buffer\n    cmp r6,#0\n    blt 5f\n    mov r0,#' '\n    strb r0,[fp,r7]          @ add space to buffer\n    add r7,r7,#1\n    sub r6,r6,#1\n    b 4b                     @ and loop\n5:\n    mov r9,#0\n6:                           @ copy loop word to buffer\n    ldrb r0,[r8,r9]\n    cmp r0,#'$'\n    beq 7f\n    cmp r0,#0                @ line end\n    beq 8f\n    strb r0,[fp,r7]\n    add r7,r7,#1\n    add r9,r9,#1\n    b 6b\n7:\n    add r8,r8,r9\n    add r8,r8,#1             @ new word begin\n    mov r6,#0                @ raz word length\n    add r4,r4,#1             @ increment line indice\n    b 2b\n    \n8:\n    mov r0,#'\\n'\n    strb r0,[fp,r7]          @ return line\n    add r7,r7,#1\n    mov r0,#0\n    strb r0,[fp,r7]          @ final z\u00e9ro\n    mov r0,fp\n    bl affichageMess         @ display output buffer\n    add r2,r2,#1\n    cmp r2,#NBLINES\n    blt 1b\n    \n100:\n    add sp,sp,#BUFFERSIZE\n    pop {r4-r9,fp,pc}\n/******************************************************************/\n/*      align center                                                */ \n/******************************************************************/\n/* r0 contains the address of pointer array*/\n/* r1 contains column size */\nalignCenter:\n    push {r4-r12,lr}         @ save registers\n    sub sp,sp,#BUFFERSIZE    @ reserve place for output buffer\n    mov fp,sp\n    mov r5,r0                @ array address\n    mov r2,#0                @ indice array\n1:\n    ldr r3,[r5,r2,lsl #2]    @ load line pointer\n    mov r4,#0                @ line character indice\n    mov r7,#0                @ output buffer character indice\n    mov r6,#0                @ word length\n    mov r8,r3                @ word begin address\n2:                           @ compute word length\n    ldrb r0,[r3,r4]          @ load a character line\n    cmp r0,#0                @ line end\u00a0?\n    beq 3f\n    cmp r0,#'$'              @ separator\u00a0?\n    beq 3f\n    add r4,r4,#1             @ increment line indice\n    add r6,r6,#1             @ increment word length\n    b 2b\n3:\n    cmp r6,#0\n    beq 5f\n    sub r6,r1,r6             @ total spaces number to add\n    mov r12,r6\n    lsr r6,r6,#1             @ divise by 2 = left spaces number\n4:\n    cmp r6,#0\n    blt 5f\n    mov r0,#' '\n    strb r0,[fp,r7]          @ add space to buffer\n    add r7,r7,#1             @ increment output indice\n    sub r6,r6,#1             @ decrement number space\n    b 4b                     @ and loop\n5:\n    mov r9,#0\n6:                           @ copy loop word to buffer\n    ldrb r0,[r8,r9]\n    cmp r0,#'$'              @ s\u00e9parator\u00a0?\n    beq 7f\n    cmp r0,#0                @ line end\u00a0?\n    beq 10f\n    strb r0,[fp,r7]\n    add r7,r7,#1\n    add r9,r9,#1\n    b 6b\n7:\n    lsr r6,r12,#1            @ divise total spaces by 2\n    sub r6,r12,r6            @ and compute number spaces to right side\n8:                           @ loop to add right spaces \n    cmp r6,#0\n    ble 9f\n    mov r0,#' '\n    strb r0,[fp,r7]          @ add space to buffer\n    add r7,r7,#1\n    sub r6,r6,#1\n    b 8b                     @ and loop\n\n9:\n    add r8,r8,r9\n    add r8,r8,#1             @ new address word begin\n    mov r6,#0                @ raz word length\n    add r4,r4,#1             @ increment line indice\n    b 2b                     @ and loop new word\n    \n10:\n    mov r0,#'\\n'\n    strb r0,[fp,r7]          @ return line\n    add r7,r7,#1\n    mov r0,#0\n    strb r0,[fp,r7]          @ final z\u00e9ro\n    mov r0,fp\n    bl affichageMess         @ display output buffer\n    add r2,r2,#1             @ increment line indice\n    cmp r2,#NBLINES          @ maxi\u00a0?\n    blt 1b                   @ loop\n    \n100:\n    add sp,sp,#BUFFERSIZE\n    pop {r4-r12,pc}\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nLEFT\u00a0:\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line\nare        delineated by         a          single     'dollar'   character, write      a          program\nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each\ncolumn     are        separated  by         at         least      one        space.\nFurther,   allow      for        each       word       in         a          column     to         be         either     left\njustified, right      justified, or         center     justified  within     its        column.\n\nRIGHT\u00a0:\n      Given          a       text       file         of       many     lines,      where     fields     within          a       line\n        are delineated         by          a     single   'dollar' character,      write          a    program\n       that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n     column        are  separated         by         at      least        one     space.\n   Further,      allow        for       each       word         in          a     column         to         be     either       left\n justified,      right justified,         or     center  justified     within        its    column.\n\nCENTER\u00a0:\n   Given        a         text       file        of        many      lines,     where      fields     within       a         line\n    are     delineated     by         a        single    'dollar'  character,   write        a       program\n    that      aligns      each      column       of       fields       by      ensuring     that      words        in        each\n   column      are     separated      by         at       least       one       space.\n  Further,    allow       for        each       word        in         a        column       to         be       either      left\n justified,   right    justified,     or       center   justified    within      its      column.\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Delphi", "code": "\nLibrary: Delphi StdCtrls, Classes, SysUtils, StrUtils, Contnrs\nUSES\n   StdCtrls, Classes, SysUtils, StrUtils, Contnrs;\n\nprocedure AlignByColumn(Output: TMemo; Align: TAlignment);\nconst\n   TextToAlign =\n   'Given$a$text$file$of$many$lines,$where$fields$within$a$line$'#$D#$A +\n   'are$delineated$by$a$single$''dollar''$character,$write$a$program'#$D#$A +\n   'that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$'#$D#$A +\n   'column$are$separated$by$at$least$one$space.'#$D#$A +\n   'Further,$allow$for$each$word$in$a$column$to$be$either$left$'#$D#$A +\n   'justified,$right$justified,$or$center$justified$within$its$column.';\nvar\n   TextLine, TempTString: TStringlist;\n   TextLines: TObjectList;\n   MaxLength, i, j: Byte;\n   OutPutString, EmptyString, Item: String;\nbegin\n   TRY\n      MaxLength := 0;\n      TextLines := TObjectList.Create(True);\n      TextLine := TStringList.Create;\n      TextLine.text := TextToAlign;\n      for i:= 0 to TextLine.Count - 1 do\n      begin\n         TempTString := TStringlist.create;\n         TempTString.text :=AnsiReplaceStr(TextLine[i], '$', #$D#$A);\n         TextLines.Add(TempTString);\n      end;\n      for i := 0 to TextLines.Count - 1 do\n         for j := 0 to TStringList(TextLines.Items[i]).Count - 1 do\n            If Length(TStringList(TextLines.Items[i])[j]) > MaxLength then\n               MaxLength := Length(TStringList(TextLines.Items[i])[j]);\n      If MaxLength > 0 then\n         MaxLength := MaxLength + 2; // Add to empty spaces to it\n      for i := 0 to TextLines.Count - 1 do\n      begin\n         OutPutString := '';\n         for j := 0 to TStringList(TextLines.Items[i]).Count - 1 do\n         begin\n            EmptyString := StringOfChar(' ', MaxLength);\n            Item := TStringList(TextLines.Items[i])[j];\n            case Align of\n               taLeftJustify: Move(Item[1], EmptyString[2], Length(Item));\n               taRightJustify: Move(Item[1], EmptyString[MaxLength - Length(Item) + 1], Length(Item));\n               taCenter: Move(Item[1], EmptyString[(MaxLength - Length(Item) + 1) div 2 + 1], Length(Item));\n            end;\n            OutPutString := OutPutString + EmptyString;\n         end;\n         Output.Lines.Add(OutPutString);\n      end;\n   FINALLY\n      FreeAndNil(TextLine);\n      FreeAndNil(TextLines);\n   END;\nend;\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Ruby", "code": "\nWorks with: Ruby version 1.9.3+\nJ2justifier = {Left: :ljust, Right: :rjust, Center: :center}\n\n=begin\nJustify columns of textual tabular input where the record separator is the newline\nand the field separator is a 'dollar' character.\njustification can be Symbol; (:Left, :Right, or :Center).\n\nReturn the justified output as a string\n=end\ndef aligner(infile, justification = :Left)\n  fieldsbyrow = infile.map {|line| line.strip.split('$')}\n  # pad to same number of fields per record\n  maxfields = fieldsbyrow.map(&:length).max\n  fieldsbyrow.map! {|row| row + ['']*(maxfields - row.length)}\n  # calculate max fieldwidth per column\n  colwidths = fieldsbyrow.transpose.map {|column|\n    column.map(&:length).max\n  }\n  # pad fields in columns to colwidth with spaces\n  justifier = J2justifier[justification]\n  fieldsbyrow.map {|row|\n    row.zip(colwidths).map {|field, width|\n      field.send(justifier, width)\n    }.join(\" \")\n  }.join(\"\\n\")\nend\n\nrequire 'stringio'\n\ntextinfile = <<END\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\nfor align in [:Left, :Right, :Center]\n  infile = StringIO.new(textinfile)\n  puts \"\\n# %s Column-aligned output:\" % align\n  puts aligner(infile, align)\nend\n\n\nOutput:\n# Left Column-aligned output:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program            \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.                              \nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.                    \n\n# Right Column-aligned output:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program            \n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.                            \n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.                    \n\n# Center Column-aligned output:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program            \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.                             \n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.                    \n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Rust", "code": "\nuse std::iter::{repeat, Extend};\n\nenum AlignmentType {\n    Left,\n    Center,\n    Right,\n}\n\nfn get_column_widths(text: &str) -> Vec<usize> {\n    let mut widths = Vec::new();\n    for line in text\n        .lines()\n        .map(|s| s.trim_matches(' ').trim_end_matches('$'))\n    {\n        let lens = line.split('$').map(|s| s.chars().count());\n        for (idx, len) in lens.enumerate() {\n            if idx < widths.len() {\n                widths[idx] = std::cmp::max(widths[idx], len);\n            } else {\n                widths.push(len);\n            }\n        }\n    }\n    widths\n}\n\nfn align_columns(text: &str, alignment: AlignmentType) -> String {\n    let widths = get_column_widths(text);\n    let mut result = String::new();\n    for line in text\n        .lines()\n        .map(|s| s.trim_matches(' ').trim_end_matches('$'))\n    {\n        for (s, w) in line.split('$').zip(widths.iter()) {\n            let blank_count = w - s.chars().count();\n            let (pre, post) = match alignment {\n                AlignmentType::Left => (0, blank_count),\n                AlignmentType::Center => (blank_count / 2, (blank_count + 1) / 2),\n                AlignmentType::Right => (blank_count, 0),\n            };\n            result.extend(repeat(' ').take(pre));\n            result.push_str(s);\n            result.extend(repeat(' ').take(post));\n            result.push(' ');\n        }\n        result.push_str(\"\\n\");\n    }\n    result\n}\n\nfn main() {\n    let text = r#\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"#;\n\n    println!(\"{}\", align_columns(text, AlignmentType::Left));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Center));\n    println!(\"{}\", repeat('-').take(110).collect::<String>());\n    println!(\"{}\", align_columns(text, AlignmentType::Right));\n}\n\n\nOutput:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n---------------------------------------------------------------------------------------------------------\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\n---------------------------------------------------------------------------------------------------------\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Swift", "code": "\nTranslation of: Rust\nimport Foundation\n\nextension String {\n  func dropLastIf(_ char: Character) -> String {\n    if last == char {\n      return String(dropLast())\n    } else {\n      return self\n    }\n  }\n}\n\nenum Align {\n  case left, center, right\n}\n\nfunc getLines(input: String) -> [String] {\n  input\n    .components(separatedBy: \"\\n\")\n    .map({ $0.replacingOccurrences(of: \" \", with: \"\").dropLastIf(\"$\") })\n}\n\nfunc getColWidths(from: String) -> [Int] {\n  var widths = [Int]()\n  let lines = getLines(input: from)\n\n  for line in lines {\n    let lens = line.components(separatedBy: \"$\").map({ $0.count })\n\n    for (i, len) in lens.enumerated() {\n      if i < widths.count {\n        widths[i] = max(widths[i], len)\n      } else {\n        widths.append(len)\n      }\n    }\n  }\n\n  return widths\n}\n\nfunc alignCols(input: String, align: Align = .left) -> String {\n  let widths = getColWidths(from: input)\n  let lines = getLines(input: input)\n  var res = \"\"\n\n  for line in lines {\n    for (str, width) in zip(line.components(separatedBy: \"$\"), widths) {\n      let blanks = width - str.count\n      let pre: Int, post: Int\n\n      switch align {\n      case .left:\n        (pre, post) = (0, blanks)\n      case .center:\n        (pre, post) = (blanks / 2, (blanks + 1) / 2)\n      case .right:\n        (pre, post) = (blanks, 0)\n      }\n\n      res += String(repeating: \" \", count: pre)\n      res += str\n      res += String(repeating: \" \", count: post)\n      res += \" \"\n    }\n\n    res += \"\\n\"\n  }\n\n  return res\n}\n\nlet input = \"\"\"\n            Given$a$text$file$of$many$lines,$where$fields$within$a$line$\n            are$delineated$by$a$single$'dollar'$character,$write$a$program\n            that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\n            column$are$separated$by$at$least$one$space.\n            Further,$allow$for$each$word$in$a$column$to$be$either$left$\n            justified,$right$justified,$or$center$justified$within$its$column.\n            \"\"\"\n\nprint(alignCols(input: input))\nprint()\nprint(alignCols(input: input, align: .center))\nprint()\nprint(alignCols(input: input, align: .right))\n\n\nOutput:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n\n\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n\n\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column. \n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "R", "code": "\n# Read in text\nlines <- readLines(tc <- textConnection(\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\")); close(tc)\n\n#Split words by the dollar\nwords <- strsplit(lines, \"\\\\$\")\n\n#Reformat\nmaxlen <- max(sapply(words, length))\nwords <- lapply(words, function(x) {length(x) <- maxlen; x})\nblock <- matrix(unlist(words), byrow=TRUE, ncol=maxlen)\nblock[is.na(block)] <- \"\"\nleftjust <- format(block)\nrightjust <- format(block, justify=\"right\")\ncentrejust <- format(block, justify=\"centre\")\n\n# Print\nprint0 <- function(x) invisible(apply(x, 1, function(x) cat(x, \"\\n\")))\nprint0(leftjust)\nprint0(rightjust)\nprint0(centrejust)\n\n\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line \n       are delineated         by          a     single   'dollar' character,      write          a    program                       \n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each \n    column        are  separated         by         at      least        one     space.                                             \n  Further,      allow        for       each       word         in          a     column         to         be     either       left \njustified,      right justified,         or     center  justified     within        its    column.                                  \n\n", "explain": "Right justified output shown.\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "COBOL", "code": "\n       identification division.\n       program-id. AlignColumns.\n\n       data division.\n       working-storage section.\n      *>-> Constants\n       78 MAX-LINES value 6.\n       78 MAX-LINE-SIZE value 66.\n       78 MAX-COLUMNS value 12.\n       78 MAX-COLUMN-SIZE value 16.\n      *>-> Indexes\n       01 w-idx                   pic is 9(2).\n       01 w-idy                   pic is 9(2).\n       01 w-pos                   pic is 9(3).\n      *>-> Data structures\n       01 w-lines.\n          05 w-line               pic is x(MAX-LINE-SIZE) occurs MAX-LINES.\n       01 w-column-sizes.\n          05 w-column-size        pic is 99 occurs MAX-COLUMNS value zeros.\n       01 w-matrix.\n          05 filler               occurs MAX-LINES.\n             10 filler            occurs MAX-COLUMNS.\n                15 w-content      pic is x(MAX-COLUMN-SIZE).\n      *>-> Output\n       01 w-line-out              pic is x(120).\n      *>-> Data alignment\n       01 w-alignment             pic is x(1).\n          88 alignment-left       value is \"L\".\n          88 alignment-center     value is \"C\".\n          88 alignment-right      value is \"R\".\n\n       procedure division.\n       main.\n           move \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" to w-line(1)\n           move \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" to w-line(2)\n           move \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" to w-line(3)\n           move \"column$are$separated$by$at$least$one$space.\" to w-line(4)\n           move \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" to w-line(5)\n           move \"justified,$right$justified,$or$center$justified$within$its$column.\" to w-line(6)\n           perform calculate-size-columns\n           set alignment-left to true\n           perform show-content\n           set alignment-center to true\n           perform show-content\n           set alignment-right to true\n           perform show-content\n           goback\n           .\n       calculate-size-columns.\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              unstring w-line(w-idx) delimited by \"$\" into w-content(w-idx, 1), w-content(w-idx, 2), \n                  w-content(w-idx, 3), w-content(w-idx, 4), w-content(w-idx, 5), w-content(w-idx, 6), \n                  w-content(w-idx, 7), w-content(w-idx, 8), w-content(w-idx, 9), w-content(w-idx, 10), \n                  w-content(w-idx, 11), w-content(w-idx, 12),\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 if function stored-char-length(w-content(w-idx, w-idy)) > w-column-size(w-idy)\n                    move function stored-char-length(w-content(w-idx, w-idy)) to w-column-size(w-idy)\n                 end-if\n              end-perform\n           end-perform\n           .\n       show-content.\n           move all \"-\" to w-line-out\n           display w-line-out\n           perform\n              varying             w-idx from 1 by 1\n                 until            w-idx > MAX-LINES\n              move spaces to w-line-out\n              move 1 to w-pos\n              perform\n                 varying          w-idy from 1 by 1\n                    until         w-idy > MAX-COLUMNS\n                 call \"C$JUSTIFY\" using w-content(w-idx, w-idy)(1:w-column-size(w-idy)), w-alignment\n                 move w-content(w-idx, w-idy) to w-line-out(w-pos:w-column-size(w-idy))\n                 compute w-pos = w-pos + w-column-size(w-idy) + 1\n              end-perform\n              display w-line-out\n           end-perform\n           .\n\n\nOutput:\n------------------------------------------------------------------------------------------------------------------------\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n------------------------------------------------------------------------------------------------------------------------\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n------------------------------------------------------------------------------------------------------------------------\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Visual_Basic", "code": "\nSub AlignCols(Lines, Optional Align As AlignmentConstants, Optional Sep$ = \"$\", Optional Sp% = 1)\nDim i&, j&, D&, L&, R&: ReDim W(UBound(Lines)): ReDim C&(0)\n \n  For j = 0 To UBound(W)\n    W(j) = Split(Lines(j), Sep)\n    If UBound(W(j)) > UBound(C) Then ReDim Preserve C(UBound(W(j)))\n    For i = 0 To UBound(W(j)): If Len(W(j)(i)) > C(i) Then C(i) = Len(W(j)(i))\n  Next i, j\n\n  For j = 0 To UBound(W): For i = 0 To UBound(W(j))\n    D = C(i) - Len(W(j)(i))\n    L = Choose(Align + 1, 0, D, D \\ 2)\n    R = Choose(Align + 1, D, 0, D - L) + Sp\n    Debug.Print Space(L); W(j)(i); Space(R); IIf(i < UBound(W(j)), \"\", vbLf);\n  Next i, j\nEnd Sub\nUsage:Sub Main() 'usage of the above\nConst Text$ = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & vbLf & _\n              \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & vbLf & _\n              \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & vbLf & _\n              \"column$are$separated$by$at$least$one$space.\" & vbLf & _\n              \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & vbLf & _\n              \"justified,$right$justified,$or$center$justified$within$its$column.\"\n \n  Debug.Print vbLf; \"-- Left:\":   AlignCols Split(Text, vbLf), vbLeftJustify\n  Debug.Print vbLf; \"-- Center:\": AlignCols Split(Text, vbLf), vbCenter\n  Debug.Print vbLf; \"-- Right:\":  AlignCols Split(Text, vbLf), vbRightJustify\nEnd Sub\n\nOutput:\n-- Left:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line  \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each  \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left  \njustified, right      justified, or     center justified within     its      column. \n\n-- Center:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line  \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each  \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left  \njustified,   right    justified,   or   center justified   within     its    column. \n\n-- Right:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line  \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each  \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left  \njustified,      right justified,     or center justified     within      its column.\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Ada", "code": "\nLibrary: Simple components for Ada\nwith Ada.Characters.Latin_1;  use Ada.Characters.Latin_1;\nwith Ada.Text_IO;             use Ada.Text_IO;\nwith Strings_Edit;            use Strings_Edit; \n\nprocedure Column_Aligner is\n   Text : constant String :=\n      \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\" & NUL &\n      \"are$delineated$by$a$single$'dollar'$character,$write$a$program\" & NUL &\n      \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\" & NUL &\n      \"column$are$separated$by$at$least$one$space.\" & NUL &\n      \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\" & NUL &\n      \"justified,$right$justified,$or$center$justified$within$its$column.\" & NUL;\n   File    : File_Type;\n   Width   : array (1..1_000) of Natural := (others => 0);\n   Line    : String (1..200);\n   Column  : Positive := 1;\n   Start   : Positive := 1;\n   Pointer : Positive;\nbegin\n   Create (File, Out_File, \"columned.txt\");\n      -- Determining the widths of columns\n   for I in Text'Range loop\n      case Text (I) is\n         when '$' | NUL =>\n            Width (Column) := Natural'Max (Width (Column), I - Start + 1);\n            Start  := I + 1;\n            if Text (I) = NUL then\n               Column := 1;\n            else\n               Column := Column + 1;\n            end if;\n         when others =>\n            null;\n      end case;\n   end loop;\n      -- Formatting\n   for Align in Alignment loop\n      Column  := 1;\n      Start   := 1;\n      Pointer := 1;\n      for I in Text'Range loop\n         case Text (I) is\n            when '$' | NUL =>\n               Put -- Formatted output of a word\n               (  Destination => Line,\n                  Pointer     => Pointer,\n                  Value       => Text (Start..I - 1),\n                  Field       => Width (Column),\n                  Justify     => Align\n               );\n               Start  := I + 1;\n               if Text (I) = NUL then\n                  Put_Line (File, Line (1..Pointer - 1));\n                  Pointer := 1;\n                  Column := 1;\n               else\n                  Column := Column + 1;\n               end if;\n            when others =>\n               null;\n         end case;\n      end loop;\n   end loop;\n   Close (File);\nend Column_Aligner;\n\n\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line  \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each  \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left  \njustified, right      justified, or     center justified within     its      column. \n      Given          a       text   file     of      many     lines,    where  fields  within      a line \n        are delineated         by      a single  'dollar' character,    write       a program\n       that     aligns       each column     of    fields         by ensuring    that   words     in each \n     column        are  separated     by     at     least        one   space.\n   Further,      allow        for   each   word        in          a   column      to      be either left \n justified,      right justified,     or center justified     within      its column.\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line  \n    are    delineated     by        a   single  'dollar' character,   write     a    program \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each  \n  column       are     separated   by     at     least       one     space.  \n Further,     allow       for     each   word      in         a      column     to      be   either left  \njustified,    right   justified,   or   center justified   within      its   column. \n\n", "explain": "Formatted file sample:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Julia", "code": "\nTranslation of: Python\ntxt = \"\"\"Given\\$a\\$txt\\$file\\$of\\$many\\$lines,\\$where\\$fields\\$within\\$a\\$line\\$\nare\\$delineated\\$by\\$a\\$single\\$'dollar'\\$character,\\$write\\$a\\$program\nthat\\$aligns\\$each\\$column\\$of\\$fields\\$by\\$ensuring\\$that\\$words\\$in\\$each\\$\ncolumn\\$are\\$separated\\$by\\$at\\$least\\$one\\$space.\nFurther,\\$allow\\$for\\$each\\$word\\$in\\$a\\$column\\$to\\$be\\$either\\$left\\$\njustified,\\$right\\$justified,\\$or\\$center\\$justified\\$within\\$its\\$column.\"\"\"\n\n# left/right/center justification of strings:\nljust(s, width) = s * \" \"^max(0, width - length(s))\nrjust(s, width) = \" \"^max(0, width - length(s)) * s\nfunction center(s, width)\n  pad = width - length(s)\n  if pad <= 0\n    return s\n  else\n    pad2 = div(pad, 2)\n    return \" \"^pad2 * s * \" \"^(pad - pad2)\n  end\nend\n \nparts = [split(rstrip(line, '$'), '$') for line in split(txt, '\\n')]\n \nmax_widths = zeros(Int, maximum(length, parts))\nfor line in parts\n  for (i, word) in enumerate(line)\n    max_widths[i] = max(max_widths[i], length(word))\n  end\nend    \nmax_widths += 1 # separate cols by at least one space\n\nfor (label, justify) in ((\"Left\", ljust), (\"Right\",rjust), (\"Center\",center))\n  println(label, \" column-aligned output:\")\n  for line in parts\n    for (j, word) in enumerate(line)\n      print(justify(word, max_widths[j]))\n    end\n    println()\n  end\n  println(\"-\"^sum(max_widths))\nend\n\n\nOutput:\nLeft column-aligned output:\nGiven      a          txt        file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n---------------------------------------------------------------------------------------------------------\nRight column-aligned output:\n      Given          a        txt   file     of      many     lines,    where  fields  within      a line\n        are delineated         by      a single  'dollar' character,    write       a program\n       that     aligns       each column     of    fields         by ensuring    that   words     in each\n     column        are  separated     by     at     least        one   space.\n   Further,      allow        for   each   word        in          a   column      to      be either left\n justified,      right justified,     or center justified     within      its column.\n---------------------------------------------------------------------------------------------------------\nCenter column-aligned output:\n   Given        a         txt     file    of      many     lines,     where   fields  within    a   line \n    are    delineated     by        a   single  'dollar' character,   write     a    program \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column       are     separated   by     at     least       one     space.  \n Further,     allow       for     each   word      in         a      column     to      be   either left \njustified,    right   justified,   or   center justified   within      its   column. \n---------------------------------------------------------------------------------------------------------\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Kotlin", "code": "\nimport java.nio.charset.StandardCharsets\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\nenum class AlignFunction {\n    LEFT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + s.length + 's').format(s)) },\n    RIGHT { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + l + 's').format(s)) },\n    CENTER { override fun invoke(s: String, l: Int) = (\"%-\" + l + 's').format((\"%\" + ((l + s.length) / 2) + 's').format(s)) };\n\n    abstract operator fun invoke(s: String, l: Int): String\n}\n\n/** Aligns fields into columns, separated by \"|\".\n * @constructor Initializes columns aligner from lines in a list of strings.\n * @property lines Lines in a single string. Empty string does form a column.\n */\nclass ColumnAligner(val lines: List<String>) {\n     operator fun invoke(a: AlignFunction) : String {\n        var result = \"\"\n        for (lineWords in words) {\n            for (i in lineWords.indices) {\n                if (i == 0)\n                    result += '|'\n                result += a(lineWords[i], column_widths[i])\n                result += '|'\n            }\n            result += '\\n'\n        }\n        return result\n    }\n\n    private val words = arrayListOf<Array<String>>()\n    private val column_widths = arrayListOf<Int>()\n\n    init {\n        lines.forEach  {\n            val lineWords = java.lang.String(it).split(\"\\\\$\")\n            words += lineWords\n            for (i in lineWords.indices) {\n                if (i >= column_widths.size) {\n                    column_widths += lineWords[i].length\n                } else {\n                    column_widths[i] = Math.max(column_widths[i], lineWords[i].length)\n                }\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    if (args.isEmpty()) {\n        println(\"Usage: ColumnAligner file [L|R|C]\")\n        return\n    }\n    val ca = ColumnAligner(Files.readAllLines(Paths.get(args[0]), StandardCharsets.UTF_8))\n    val alignment = if (args.size >= 2) args[1] else \"L\"\n    when (alignment) {\n        \"L\" -> print(ca(AlignFunction.LEFT))\n        \"R\" -> print(ca(AlignFunction.RIGHT))\n        \"C\" -> print(ca(AlignFunction.CENTER))\n        else -> System.err.println(\"Error! Unknown alignment: \" + alignment)\n    }\n}\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Perl", "code": "\n#/usr/bin/perl -w\nuse strict ;\n\ndie \"Call\u00a0: perl columnaligner.pl <inputfile> <printorientation>!\\n\" unless\n   @ARGV == 2 ; #$ARGV[ 0 ] contains example file , $ARGV[1] any of 'left' , 'right' or 'center'\ndie \"last argument must be one of center, left or right!\\n\" unless\n   $ARGV[ 1 ] =~ /center|left|right/ ;\nsub printLines( $$$ )\u00a0;\nopen INFILE , \"<\" , \"$ARGV[ 0 ]\" or die \"Can't open $ARGV[ 0 ]!\\n\"\u00a0;\nmy @lines = <INFILE>\u00a0;\nclose INFILE\u00a0;\nchomp @lines\u00a0;\nmy @fieldwidths = map length, split /\\$/ , $lines[ 0 ]\u00a0;\nforeach my $i ( 1..$#lines ) {\n   my @words = split /\\$/ , $lines[ $i ] ;\n   foreach my $j ( 0..$#words ) {\n      if ( $j <= $#fieldwidths ) {\n         if ( length $words[ $j ] > $fieldwidths[ $j ] ) {\n               $fieldwidths[ $j ] = length $words[ $j ] ;\n         }\n      }\n      else {\n         push @fieldwidths, length $words[ $j ] ;\n      }\n   }\n}\nprintLine( $_ , $ARGV[ 1 ] , \\@fieldwidths ) foreach @lines ;\n##################################################################    ####\nsub printLine {\n   my $line = shift ;\n   my $orientation = shift ;\n   my $widthref = shift ;\n   my @words = split /\\$/, $line ;\n   foreach my $k ( 0..$#words ) {\n      my $printwidth = $widthref->[ $k ] + 1 ;\n      if ( $orientation eq 'center' ) {\n         $printwidth++ ;\n      }\n      if ( $orientation eq 'left' ) {\n         print $words[ $k ] ;\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n      }\n      elsif ( $orientation eq 'right' ) {\n         print \" \" x ( $printwidth - length $words[ $k ] ) ;\n         print $words[ $k ] ;\n      }\n      elsif ( $orientation eq 'center' ) {\n         my $left = int( ( $printwidth - length $words[ $k ] )     / 2 ) ;\n         my $right = $printwidth - length( $words[ $k ] ) - $left      ;\n         print \" \" x $left ;\n         print $words[ $k ] ;\n         print \" \" x $right ;\n      }\n   }\n   print \"\\n\" ;\n}\n\n\nuse List::Util qw(max);\n\nsub columns {\n    my @lines = map [split /\\$/] => split /\\n/ => shift;\n    my $pos = {qw/left 0 center 1 right 2/}->{+shift};\n    for my $col (0 .. max map {$#$_} @lines) {\n        my $max = max my @widths = map {length $_->[$col]} @lines;\n        for my $row (0 .. $#lines) {\n            my @pad = map {' ' x $_, ' ' x ($_ + 0.5)} ($max - $widths[$row]) / 2;\n            for ($lines[$row][$col])\n                {$_ = join '' => @pad[0 .. $pos-1], $_, @pad[$pos .. $#pad]}\n        }\n    }\n    join '' => map {\"@$_\\n\"} @lines\n}\n\nprint columns <<'END', $_ for qw(left right center);\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\nEND\n\n", "explain": "a shorter solution\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Prolog", "code": "\n\naligner :-\n\tL =\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\",\n\n\t% read the lines and the words\n\t% compute the length of the longuest word.\n\t% LP is the list of lines, \n\t% each line is a list of words\n\tparse(L, 0, N, LP, []),\n\n\t% we need to add 1 to aligned\n\tN1 is N+1,\n\t% words will be left aligned\n\tsformat(AL, '~~w~~t~~~w|', [N1]),\n\t% words will be centered\n\tsformat(AC, '~~t~~w~~t~~~w|', [N1]),\n\t% words will be right aligned\n\tsformat(AR, '~~t~~w~~~w|', [N1]),\n\n\twrite('Left justified\u00a0:'), nl,\n\tmaplist(affiche(AL), LP), nl,\n\twrite('Centered justified\u00a0:'), nl,\n\tmaplist(affiche(AC), LP), nl,\n\twrite('Right justified\u00a0:'), nl,\n\tmaplist(affiche(AR), LP), nl.\n\naffiche(F, L) :-\n\tmaplist(my_format(F), L),\n\tnl.\n\nmy_format(_F, [13]) :-\n\tnl.\n\nmy_format(F, W) :-\n\tstring_to_atom(W,AW),\n\tsformat(AF, F, [AW]),\n\twrite(AF).\n\n\nparse([], Max, Max) --> [].\n\nparse(T, N, Max) -->\n\t{ parse_line(T, 0, N1, T1, L, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[L],\n\tparse(T1, N2, Max).\n\nparse_line([], NF, NF, []) --> [].\n\nparse_line([H|TF], NF, NF, TF) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\n\nparse_line(T, N, NF, TF) -->\n\t{ parse_word(T, 0, N1, T1, W, []),\n\t  (   N1 > N -> N2 = N1; N2 = N)},\n\t[W],\n\tparse_line(T1, N2, NF, TF).\n\n% 36 is the code of '$'\nparse_word([36|T], N, N, T) -->\n\t{!},\n\t[].\n\nparse_word([H|T], N, N, [H|T]) -->\n\t{code_type(H, end_of_line), !},\n\t[].\n\nparse_word([], N, N, []) --> [].\n\nparse_word([H|T], N1, NF, TF) -->\n\t[H],\n\t{N2 is  N1 + 1},\n\tparse_word(T, N2, NF, TF).\n\n\nOutput:\n\u00a0?- aligner.\nLeft justified\u00a0:\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line       \nare        delineated by         a          single     'dollar'   character, write      a          program    \nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each       \ncolumn     are        separated  by         at         least      one        space.     \nFurther,   allow      for        each       word       in         a          column     to         be         either     left       \njustified, right      justified, or         center     justified  within     its        column.    \n\nCentered justified\u00a0:\n   Given        a        text       file        of        many      lines,      where     fields     within        a        line    \n    are    delineated     by          a       single    'dollar'  character,    write        a       program  \n   that      aligns      each      column       of       fields       by      ensuring     that       words       in        each    \n  column       are     separated     by         at        least       one      space.   \n Further,     allow       for       each       word        in          a       column       to         be       either      left    \njustified,    right   justified,     or       center    justified   within       its      column.  \n\nRight justified\u00a0:\n      Given          a       text       file         of       many     lines,      where     fields     within          a       line\n        are delineated         by          a     single   'dollar' character,      write          a    program\n       that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n     column        are  separated         by         at      least        one     space.\n   Further,      allow        for       each       word         in          a     column         to         be     either       left\n justified,      right justified,         or     center  justified     within        its    column.\n\ntrue .\n", "explain": "Works with SWI-Prolog.\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Lua", "code": "\nWorks with: Lua version 5.1\nlocal tWord = {}        -- word table\nlocal tColLen = {}      -- maximum word length in a column\nlocal rowCount = 0      -- row counter\n--store maximum column lengths at 'tColLen'; save words into 'tWord' table\nlocal function readInput(pStr)\n    for line in pStr:gmatch(\"([^\\n]+)[\\n]-\") do  -- read until '\\n' character\n        rowCount = rowCount + 1\n        tWord[rowCount] = {}                     -- create new row\n        local colCount = 0\n        for word in line:gmatch(\"[^$]+\") do      -- read non '$' character\n            colCount = colCount + 1\n            tColLen[colCount] = math.max((tColLen[colCount] or 0), #word)   -- store column length\n            tWord[rowCount][colCount] = word                                -- store words\n        end--for word\n    end--for line\nend--readInput\n--repeat space to align the words in the same column\nlocal align = {\n    [\"left\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        return pWord .. (\" \"):rep(n)\n    end;--[\"left\"]\n    [\"right\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        return (\" \"):rep(n) .. pWord\n    end;--[\"right\"]\n    [\"center\"] = function (pWord, pColLen)\n        local n = (pColLen or 0) - #pWord + 1\n        local n1 = math.floor(n/2)\n        return (\" \"):rep(n1) .. pWord .. (\" \"):rep(n-n1)\n    end;--[\"center\"]\n}\n--word table padder\nlocal function padWordTable(pAlignment)\n    local alignFunc = align[pAlignment]                         -- selecting the spacer function\n    for rowCount, tRow in ipairs(tWord) do\n        for colCount, word in ipairs(tRow) do\n            tRow[colCount] = alignFunc(word, tColLen[colCount]) -- save the padded words into the word table\n        end--for colCount, word\n    end--for rowCount, tRow\nend--padWordTable\n--main interface\n--------------------------------------------------[]\nfunction alignColumn(pStr, pAlignment, pFileName)\n--------------------------------------------------[]\n    readInput(pStr)                           -- store column lengths and words\n    padWordTable(pAlignment or \"left\")        -- pad the stored words\n    local output = \"\"\n    for rowCount, tRow in ipairs(tWord) do\n        local line = table.concat(tRow)       -- concatenate words in one row\n        print(line)                           -- print the line\n        output = output .. line .. \"\\n\"       -- concatenate the line for output, add line break\n    end--for rowCount, tRow\n    if (type(pFileName) == \"string\") then\n        local file = io.open(pFileName, \"w+\")\n        file:write(output)                    -- write output to file\n        file:close()\n    end--if type(pFileName)\n    return output\nend--alignColumn\n\n\ninput =\n[[Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.]]\n\n\noutputLeft = alignColumn(input)\noutputRight = alignColumn(input, \"right\")\nalignColumn(input, \"center\", \"output.txt\")\n\n", "explain": "Usage Example:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Scala", "code": "\nWorks with: scala version 2.8.0.r18997-b20091009021954\n\nobject ColumnAligner {\n  val eol = System.getProperty(\"line.separator\")\n  def getLines(filename: String) = scala.io.Source.fromPath(filename).getLines(eol)\n  def splitter(line: String) = line split '$'\n  def getTable(filename: String) = getLines(filename) map splitter\n  def fieldWidths(fields: Array[String]) = fields map (_ length)\n  def columnWidths(txt: Iterator[Array[String]]) = (txt map fieldWidths).toList.transpose map (_ max)\n\n  def alignField(alignment: Char)(width: Int)(field: String) = alignment match {\n    case 'l' | 'L' => \"%-\"+width+\"s\" format field\n    case 'r' | 'R' => \"%\"+width+\"s\" format field\n    case 'c' | 'C' => val padding = (width - field.length) / 2; \" \"*padding+\"%-\"+(width-padding)+\"s\" format field\n    case _ => throw new IllegalArgumentException\n  }\n\n  def align(aligners: List[String => String])(fields: Array[String]) =\n    aligners zip fields map Function.tupled(_ apply _)\n  \n  def alignFile(filename: String, alignment: Char) = {\n    def table = getTable(filename)\n    val aligners = columnWidths(table) map alignField(alignment)\n    table map align(aligners) map (_ mkString \" \")\n  }\n  \n  def printAlignedFile(filename: String, alignment: Char) {\n    alignFile(filename, alignment) foreach println\n  }\n}\n\n\ndef pad(s:String, i:Int, d:String) = {\n  val padsize = (i-s.length).max(0)\n  d match {\n    case \"left\" => s+\" \"*padsize\n    case \"right\" => \" \"*padsize+s\n    case \"center\" => \" \"*(padsize/2) + s + \" \"*(padsize-padsize/2)\n  }\n}\n \nval lines = scala.io.Source.fromFile(\"c:\\\\text.txt\").getLines.map(_.trim())\nval words = lines.map(_.split(\"\\\\$\").toList).toList\nval lens = words.map(l => l.map(_.length)).toList\n \nvar maxlens = Map[Int,Int]() withDefaultValue 0\nlens foreach (l =>\n  for(i <- (0 until l.length)){\n    maxlens += i -> l(i).max(maxlens(i))\n  }\n)\n  \nval padded = words map ( _.zipWithIndex.map{case(s,i)=>pad(s,maxlens(i),\"center\")+\" \"} )\npadded map (_.reduceLeft(_ + _)) foreach println\n\n", "explain": "For Scala 2.7, change from fromPath to fromFile, and remove the extra parameter to Source's getLines.\nAnother take:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.string, std.algorithm, std.range, std.typetuple;\n\n    immutable data =\n\"Given$a$txt$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\"\n    .split.map!(r => r.chomp(\"$\").split(\"$\")).array;\n\n    size_t[size_t] maxWidths;\n    foreach (const line; data)\n        foreach (immutable i, const word; line)\n            maxWidths[i] = max(maxWidths.get(i, 0), word.length);\n\n    foreach (immutable just; TypeTuple!(leftJustify, center, rightJustify))\n        foreach (immutable line; data)\n            writefln(\"%-(%s\u00a0%)\", line.length.iota\n                     .map!(i => just(line[i], maxWidths[i], ' ')));\n}\n\n\nOutput:\nGiven      a          txt        file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.   \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column. \n  Given        a         txt      file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.  \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column. \n     Given          a        txt   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space. \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column. \n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Haskell", "code": "\nimport Data.List (unfoldr, transpose)\nimport Control.Arrow (second)\n\ndat =\n  \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\\n\" ++\n  \"are$delineated$by$a$single$'dollar'$character,$write$a$program\\n\" ++\n  \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\\n\" ++\n  \"column$are$separated$by$at$least$one$space.\\n\" ++\n  \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\\n\" ++\n  \"justified,$right$justified,$or$center$justified$within$its$column.\\n\"\n\nbrkdwn =\n  takeWhile (not . null) . unfoldr (Just . second (drop 1) . span ('$' /=))\n\nformat j ls = map (unwords . zipWith align colw) rows\n  where\n    rows = map brkdwn $ lines ls\n    colw = map (maximum . map length) . transpose $ rows\n    align cw w =\n      case j of\n        'c' -> replicate l ' ' ++ w ++ replicate r ' '\n        'r' -> replicate dl ' ' ++ w\n        'l' -> w ++ replicate dl ' '\n      where\n        dl = cw - length w\n        (l, r) = (dl `div` 2, dl - l)\n\n\nOutput:\n*Main> mapM_ putStrLn $ format 'c' dat\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n\nimport Prelude as P\nimport Data.Text as T\n       (Text, pack, unpack, splitOn, unlines, unwords, length,\n        justifyLeft, justifyRight, center)\nimport Data.List (transpose, zip, maximumBy)\nimport Data.Ord (comparing)\n \nrows :: [[Text]]\nrows =\n  (splitOn (pack \"$\") . pack) <$>\n  [ \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n  , \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n  , \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n  , \"column$are$separated$by$at$least$one$space.\"\n  , \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n  , \"justified,$right$justified,$or$center$justified$within$its$column.\"\n  ]\n \ncols :: [[Text]]\ncols =\n  transpose $\n  ((++) <*>\n   (flip P.replicate (pack []) .\n    (-) (maximum (P.length <$> rows)) . P.length)) <$>\n  rows\n \nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  [ (\\cols f ->\n        (unpack . T.unlines) $\n        T.unwords <$> transpose ((\\(xs, n) -> f (n + 1) ' ' <$> xs) <$> cols))\n      (zip cols ((T.length . maximumBy (comparing T.length)) <$> cols))\n  ] <*>\n  [justifyLeft, justifyRight, center]\n\n\nOutput:\nGiven       a           text        file    of      many       lines,      where     fields   within   a       line   \nare         delineated  by          a       single  'dollar'   character,  write     a        program                 \nthat        aligns      each        column  of      fields     by          ensuring  that     words    in      each   \ncolumn      are         separated   by      at      least      one         space.                                     \nFurther,    allow       for         each    word    in         a           column    to       be       either  left   \njustified,  right       justified,  or      center  justified  within      its       column.                          \n\n      Given           a        text    file      of       many      lines,     where   fields   within       a  line  \n        are  delineated          by       a  single   'dollar'  character,     write        a  program                \n       that      aligns        each  column      of     fields          by  ensuring     that    words      in  each  \n     column         are   separated      by      at      least         one    space.                                  \n   Further,       allow         for    each    word         in           a    column       to       be  either  left  \n justified,       right  justified,      or  center  justified      within       its  column.                         \n\n   Given         a          text      file     of      many       lines,     where    fields   within     a     line  \n    are      delineated      by        a     single  'dollar'   character,   write       a     program                \n    that       aligns       each     column    of     fields        by      ensuring   that     words     in    each  \n   column       are      separated     by      at      least       one       space.                                   \n  Further,     allow        for       each    word      in          a        column     to       be     either  left  \n justified,    right     justified,    or    center  justified    within      its     column. \n", "explain": "\nOr, using Text and its functions as an alternative to [Char] strings:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "VBScript", "code": "\nTranslation of: Rexx\n' Align columns - RC - VBScript\n\tConst nr=16, nc=16\n\tReDim d(nc),t(nr), wor(nr,nc)\n\ti=i+1: t(i) = \"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n\ti=i+1: t(i) = \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n\ti=i+1: t(i) = \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n\ti=i+1: t(i) = \"column$are$separated$by$at$least$one$space.\"\n\ti=i+1: t(i) = \"Further,$allow$for$each$word$in$a$column$To$be$either$left$\"\n\ti=i+1: t(i) = \"justified,$right$justified,$or$center$justified$within$its$column.\"\n\tFor r=1 to nr\n\t\tIf t(r)=\"\" Then Exit For\n\t\tw=xRTrim(t(r),\"$\")\n\t\tm=Split(w,\"$\")\n\t\tFor c=1 To UBound(m)+1\n\t\t\twor(r,c)=m(c-1)\n\t\t\tIf Len(wor(r,c))>d(c) Then d(c)=Len(wor(r,c))\n\t\tNext 'c\n\t\tIf c>cols Then cols=c\n\tNext 'r\n\trows=r-1\n\ttt=Array(\"Left\",\"Right\",\"Center\")\n\tFor n=1 To 3\n\t\tWscript.Echo \n\t\tWscript.Echo \"*****\" & tt(n-1) & \"*****\" \n\t\tFor r=1 To rows\n\t\t\tw=\"\"\n\t\t\tFor c=1 To cols\n\t\t\t\tx=wor(r,c): s=Space(d(c))\n\t\t\t\tSelect Case n\n\t\t\t\t\tCase 1: w=w &\" \"& Left   (x & s,d(c)) \n\t\t\t\t\tCase 2: w=w &\" \"& Right  (s & x,d(c))\n\t\t\t\t\tCase 3: w=w &\" \"& xCentre(x,d(c),\" \")\n\t\t\t\tEnd Select 'n\n\t\t\tNext 'c\n\t\t\tWscript.Echo Mid(w,2)\n\t\tNext 'r\n\tNext 'n\n\t\nFunction xCentre(c, n, Pad) \n    Dim j\n    If n > Len(c) Then\n\t\tj = (n - Len(c)) \\  2\n\t\tIf (n - Len(c)) Mod 2 <> 0 Then j = j + 1\n\t\txCentre = Mid(String(j, Pad) & c & String(j, Pad), 1, n)\n    Else\n\t\txCentre = c\n    End If\nEnd Function 'xCentre\n\nFunction xRTrim(c, Pad) \n\tDim i2, l, cc \n\tcc = \"\": l = Len(c)\n\tIf l > 0 Then\n\t\ti2 = l\n\t\tDo While (Mid(c, i2, 1) = Pad And i2 > 1)\n\t\t\ti2 = i2 - 1\n\t\tLoop\n\t\tIf i2 = 1 And Mid(c, i2, 1) = Pad Then i2 = 0\n\t\tIf i2 > 0 Then cc = Mid(c, 1, i2)\n\tEnd If\n\txRTrim = cc\nEnd Function 'xRTrim\n\nOutput:\n*****Left*****\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   To      be      either left\njustified, right      justified, or     center justified within     its      column.\n\n*****Right*****\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      To      be either left\njustified,      right justified,     or center justified     within      its column.\n\n*****Center*****\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line\n    are    delineated     by        a   single  'dollar' character,   write     a    program\n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each\n  column       are     separated   by     at     least       one     space.\n Further,     allow       for     each   word      in         a      column     To      be   either left\njustified,    right   justified,   or   center justified   within      its   column.\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Scheme", "code": "\n(import (scheme base)\n        (scheme write)\n        (srfi 1)\n        (except (srfi 13) string-for-each string-map)\n        (srfi 14))\n\n;; text is a list of lines, alignment is left/right/center\n;; displays the aligned text in columns with a single space gap\n(define (align-columns text alignment)\n  (define (split line) ; splits string on $ into list of strings\n    (string-tokenize line (char-set-complement (->char-set \"$\"))))\n  (define (extend lst n) ; extends list to length n, by adding \"\" to end\n    (append lst (make-list (- n (length lst)) \"\")))\n  (define (align-word word width) ; align single word to fit width\n    (case alignment\n      ((left) (string-pad-right word width))\n      ((right) (string-pad word width))\n      ((center) (let ((rem (- width (string-length word))))\n                  (string-pad-right (string-pad word (- width (truncate (/ rem 2))))\n                                    width)))))\n  ;\n  (display alignment) (newline)\n  (let* ((text-list (map split text))\n         (max-line-len (fold (lambda (text val) (max (length text) val)) 0 text-list))\n         (text-lines (map (lambda (line) (extend line max-line-len)) text-list))\n         (min-col-widths (map (lambda (col) \n                                (fold (lambda (line val) \n                                        (max (string-length (list-ref line col))\n                                             val)) \n                                      0 \n                                      text-lines))\n                              (iota max-line-len))))\n    (map (lambda (line) \n           (map (lambda (word width) \n                  (display (string-append (align-word word width)\n                                          \" \")))\n                line min-col-widths)\n           (newline))\n         text-lines))\n  (newline))\n\n;; show example\n(define *example* \n  '(\"Given$a$text$file$of$many$lines,$where$fields$within$a$line$\"\n    \"are$delineated$by$a$single$'dollar'$character,$write$a$program\"\n    \"that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\"\n    \"column$are$separated$by$at$least$one$space.\"\n    \"Further,$allow$for$each$word$in$a$column$to$be$either$left$\"\n    \"justified,$right$justified,$or$center$justified$within$its$column.\"))\n\n(align-columns *example* 'left)\n(align-columns *example* 'center)\n(align-columns *example* 'right)\n\n\nOutput:\nleft\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n\ncenter\n   Given        a        text     file    of      many     lines,     where   fields  within    a   line \n    are    delineated     by        a   single  'dollar' character,   write     a    program             \n   that      aligns      each    column   of     fields      by     ensuring   that   words    in   each \n  column       are     separated   by     at     least       one     space.                              \n Further,     allow       for     each   word      in         a      column     to      be   either left \njustified,    right   justified,   or   center justified   within      its   column.                     \n\nright\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.                     \n\n\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "PowerShell", "code": "\n$file = \n@'\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n'@.Split(\"`n\")\n\n$arr = @()\n$file | foreach {\n    $line = $_\n    $i = 0\n    $hash = [ordered]@{}\n    $line.split('$') | foreach{\n        $hash[\"$i\"] = \"$_\"\n        $i++\n     }\n    $arr += @([pscustomobject]$hash)\n}\n$arr | Format-Table -HideTableHeaders -Wrap *\n\n\nGiven      a          text       file   of     many      lines,     where    fields  within   a      line   \nare        delineated by         a      single 'dollar'  character, write    a       program                \nthat       aligns     each       column of     fields    by         ensuring that    words    in     each   \ncolumn     are        separated  by     at     least     one        space.                                  \nFurther,   allow      for        each   word   in        a          column   to      be       either left   \njustified, right      justified, or     center justified within     its      column.\n\n", "explain": "Output:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "ABAP", "code": "\nreport z_align no standard page header.\nstart-of-selection.\n\ndata: lt_strings type standard table of string,\n      lv_strings type string.\nappend: 'Given$a$text$file$of$many$lines,$where$fields$within$a$line$' to lt_strings,\n        'are$delineated$by$a$single$''dollar''$character,$write$a$program' to lt_strings,\n        'that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$' to lt_strings,\n        'column$are$separated$by$at$least$one$space.' to lt_strings,\n        'Further,$allow$for$each$word$in$a$column$to$be$either$left$' to lt_strings,\n        'justified,$right$justified,$or$center$justified$within$its$column.' to lt_strings.\ntypes ty_strings type standard table of string.\n\nperform align_col using 'LEFT' lt_strings.\nskip.\nperform align_col using 'RIGHT' lt_strings.\nskip.\nperform align_col using 'CENTER' lt_strings.\n\n\nform align_col using iv_just type string iv_strings type ty_strings.\n  constants: c_del value '$'.\n  data: lv_string type string,\n        lt_strings type table of string,\n        lt_tables like table of lt_strings,\n        lv_first type string,\n        lv_second type string,\n        lv_longest type i value 0,\n        lv_off type i value 0,\n        lv_len type i.\n  \" Loop through the supplied text. It is expected at the input is a table of strings, with each\n  \" entry in the table representing a new line of the input.\n  loop at iv_strings into lv_string.\n    \" Split the current line at the delimiter.\n    split lv_string at c_del into lv_first lv_second.\n    \" Loop through the line splitting at every delimiter.\n    do.\n      append lv_first to lt_strings.\n      lv_len = strlen( lv_first ).\n      \" Check if the length of the new string is greater than the currently stored length.\n      if lv_len > lv_longest.\n        lv_longest = lv_len.\n      endif.\n      if lv_second na c_del.\n        \" Check if the string is longer than the recorded maximum.\n        lv_len = strlen( lv_second ).\n        if lv_len > lv_longest.\n          lv_longest = lv_len.\n        endif.\n        append lv_second to lt_strings.\n        exit.\n      endif.\n      split lv_second at c_del into lv_first lv_second.\n    enddo.\n\n    append lt_strings to lt_tables.\n    clear lt_strings.\n  endloop.\n\n  \" Loop through each line of input.\n  loop at lt_tables into lt_strings.\n    \" Loop through each word in the line (Separated by specified delimiter).\n    loop at lt_strings into lv_string.\n      lv_off = ( sy-tabix - 1 ) * ( lv_longest + 2 ).\n      case iv_just.\n        when 'LEFT'.\n          write : at (lv_longest) lv_string left-justified.\n        when 'RIGHT'.\n          write at (lv_longest) lv_string right-justified.\n        when 'CENTER'.\n          write at (lv_longest) lv_string centered.\n      endcase.\n    endloop.\n    skip.\n    sy-linno = sy-linno - 1.\n  endloop.\nendform.\n\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line\nare        delineated by         a          single     'dollar'   character, write      a          program\nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each\ncolumn     are        separated  by         at         least      one        space.\nFurther,   allow      for        each       word       in         a          column     to         be         either     left\njustified, right      justified, or         center     justified  within     its        column.\n\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line\n       are delineated         by          a     single   'dollar' character,      write          a    program\n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n    column        are  separated         by         at      least        one     space.\n  Further,      allow        for       each       word         in          a     column         to         be     either       left\njustified,      right justified,         or     center  justified     within        its    column.\n\n  Given        a         text       file        of        many      lines,     where      fields     within       a         line\n   are     delineated     by         a        single    'dollar'  character,   write        a       program\n   that      aligns      each      column       of       fields       by      ensuring     that      words        in        each\n  column      are     separated      by         at       least       one       space.\n Further,    allow       for        each       word        in         a        column       to         be       either      left\njustified,   right    justified,     or       center   justified    within      its      column.\n", "explain": ""}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "F#", "code": "\nopen System\nopen System.IO\n\nlet tableFromPath path =\n    let lines =\n        [ for line in File.ReadAllLines(path) -> (line.TrimEnd('$').Split('$')) ]\n    let width = List.fold (fun max (line : string[]) -> if max < line.Length then line.Length else max) 0 lines\n    List.map (fun (a : string[]) -> (List.init width (fun i -> if i < a.Length then a.[i] else \"\"))) lines\n\nlet rec trans m =\n    match m with\n    | []::_ -> []\n    | _ -> (List.map List.head m) :: trans (List.map List.tail m)\n\nlet colWidth table =\n    List.map (fun col -> List.max (List.map String.length col)) (trans table)\n\nlet left = (fun (s : string) n -> s.PadRight(n))\nlet right = (fun (s : string) n -> s.PadLeft(n))\nlet center = (fun (s : string) n -> s.PadLeft((n + s.Length) / 2).PadRight(n))\n\n[<EntryPoint>]\nlet main argv =\n    let table = tableFromPath argv.[0]\n    let width = Array.ofList (colWidth table)\n    let format table align =\n        List.map (fun (row : string list) -> List.mapi (fun i s -> sprintf \"%s\" (align s width.[i])) row) table\n        |> List.iter (fun row -> printfn \"%s\" (String.Join(\" \", Array.ofList row)))\n\n    for align in [ left; right; center ] do\n        format table align\n        printfn \"%s\" (new String('-', (Array.sum width) + width.Length - 1))\n    0\n\n\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line\nare        delineated by         a      single 'dollar'  character, write    a       program\nthat       aligns     each       column of     fields    by         ensuring that    words   in     each\ncolumn     are        separated  by     at     least     one        space.\nFurther,   allow      for        each   word   in        a          column   to      be      either left\njustified, right      justified, or     center justified within     its      column.\n--------------------------------------------------------------------------------------------------------\n     Given          a       text   file     of      many     lines,    where  fields  within      a line\n       are delineated         by      a single  'dollar' character,    write       a program\n      that     aligns       each column     of    fields         by ensuring    that   words     in each\n    column        are  separated     by     at     least        one   space.\n  Further,      allow        for   each   word        in          a   column      to      be either left\njustified,      right justified,     or center justified     within      its column.\n--------------------------------------------------------------------------------------------------------\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line\n   are     delineated     by       a    single 'dollar'  character,  write      a    program\n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each\n  column      are     separated    by     at     least      one      space.\n Further,    allow       for      each   word     in         a       column    to      be    either left\njustified,   right    justified,   or   center justified   within     its    column.\n--------------------------------------------------------------------------------------------------------\n", "explain": "Output, when called with a file containing the sample input\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "Groovy", "code": "\n\ndef alignColumns = { align, rawText ->\n    def lines = rawText.tokenize('\\n')\n    def words = lines.collect { it.tokenize(/\\$/) }\n    def maxLineWords = words.collect {it.size()}.max()\n    words = words.collect { line -> line + [''] * (maxLineWords - line.size()) }\n    def columnWidths = words.transpose().collect{ column -> column.collect { it.size() }.max() }\n\n    def justify = [   Right  : { width, string -> string.padLeft(width) },\n                            Left   : { width, string -> string.padRight(width) },\n                            Center : { width, string -> string.center(width) }      ]\n    def padAll = { pad, colWidths, lineWords -> [colWidths, lineWords].transpose().collect { pad(it) + ' ' } }\n\n    words.each { padAll(justify[align], columnWidths, it).each { print it }; println() }\n}\n\n\ndef rawTextInput = '''Given$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.'''\n\n['Left', 'Center', 'Right'].each { align -> \n    println \"${align} Justified:\"\n    alignColumns(align, rawTextInput)\n    println()\n}\n\n\nOutput:\nLeft Justified:\nGiven      a          text       file   of     many      lines,     where    fields  within  a      line \nare        delineated by         a      single 'dollar'  character, write    a       program             \nthat       aligns     each       column of     fields    by         ensuring that    words   in     each \ncolumn     are        separated  by     at     least     one        space.                               \nFurther,   allow      for        each   word   in        a          column   to      be      either left \njustified, right      justified, or     center justified within     its      column.                     \n\nCenter Justified:\n  Given        a         text     file    of     many      lines,    where   fields  within    a    line \n   are     delineated     by       a    single 'dollar'  character,  write      a    program             \n   that      aligns      each    column   of    fields       by     ensuring  that    words    in   each \n  column      are     separated    by     at     least      one      space.                              \n Further,    allow       for      each   word     in         a       column    to      be    either left \njustified,   right    justified,   or   center justified   within     its    column.                     \n\nRight Justified:\n     Given          a       text   file     of      many     lines,    where  fields  within      a line \n       are delineated         by      a single  'dollar' character,    write       a program             \n      that     aligns       each column     of    fields         by ensuring    that   words     in each \n    column        are  separated     by     at     least        one   space.                             \n  Further,      allow        for   each   word        in          a   column      to      be either left \njustified,      right justified,     or center justified     within      its column.\n", "explain": "Solution:\nTest Program:\n"}, {"task_name": "Align columns", "task_url": "https://rosettacode.org/wiki/Align_columns", "task_cat": "Text processing", "lang": "AWK", "code": "\n# syntax: GAWK -f ALIGN_COLUMNS.AWK ALIGN_COLUMNS.TXT\nBEGIN {\n    colsep = \" \" # separator between columns\n    report(\"raw data\")\n}\n{   printf(\"%s\\n\",$0)\n    arr[NR] = $0\n    n = split($0,tmp_arr,\"$\")\n    for (j=1; j<=n; j++) {\n      width = max(width,length(tmp_arr[j]))\n    }\n}\nEND {\n    report(\"left justified\")\n    report(\"right justified\")\n    report(\"center justified\")\n    exit(0)\n}\nfunction report(text,  diff,i,j,l,n,r,tmp_arr) {\n    printf(\"\\nreport: %s\\n\",text)\n    for (i=1; i<=NR; i++) {\n      n = split(arr[i],tmp_arr,\"$\")\n      if (tmp_arr[n] == \"\") { n-- }\n      for (j=1; j<=n; j++) {\n        if (text ~ /^[Ll]/) { # left\n          printf(\"%-*s%s\",width,tmp_arr[j],colsep)\n        }\n        else if (text ~ /^[Rr]/) { # right\n          printf(\"%*s%s\",width,tmp_arr[j],colsep)\n        }\n        else if (text ~ /^[Cc]/) { # center\n          diff = width - length(tmp_arr[j])\n          l = r = int(diff / 2)\n          if (diff != l + r) { r++ }\n          printf(\"%*s%s%*s%s\",l,\"\",tmp_arr[j],r,\"\",colsep)\n        }\n      }\n      printf(\"\\n\")\n    }\n}\nfunction max(x,y) { return((x > y) ? x : y) }\n\n\nreport: raw data\nGiven$a$text$file$of$many$lines,$where$fields$within$a$line$\nare$delineated$by$a$single$'dollar'$character,$write$a$program\nthat$aligns$each$column$of$fields$by$ensuring$that$words$in$each$\ncolumn$are$separated$by$at$least$one$space.\nFurther,$allow$for$each$word$in$a$column$to$be$either$left$\njustified,$right$justified,$or$center$justified$within$its$column.\n\nreport: left justified\nGiven      a          text       file       of         many       lines,     where      fields     within     a          line\nare        delineated by         a          single     'dollar'   character, write      a          program\nthat       aligns     each       column     of         fields     by         ensuring   that       words      in         each\ncolumn     are        separated  by         at         least      one        space.\nFurther,   allow      for        each       word       in         a          column     to         be         either     left\njustified, right      justified, or         center     justified  within     its        column.\n\nreport: right justified\n     Given          a       text       file         of       many     lines,      where     fields     within          a       line\n       are delineated         by          a     single   'dollar' character,      write          a    program\n      that     aligns       each     column         of     fields         by   ensuring       that      words         in       each\n    column        are  separated         by         at      least        one     space.\n  Further,      allow        for       each       word         in          a     column         to         be     either       left\njustified,      right justified,         or     center  justified     within        its    column.\n\nreport: center justified\n  Given        a         text       file        of        many      lines,     where      fields     within       a         line\n   are     delineated     by         a        single    'dollar'  character,   write        a       program\n   that      aligns      each      column       of       fields       by      ensuring     that      words        in        each\n  column      are     separated      by         at       least       one       space.\n Further,    allow       for        each       word        in         a        column       to         be       either      left\njustified,   right    justified,     or       center   justified    within      its      column.\n\n", "explain": "Output:"}]