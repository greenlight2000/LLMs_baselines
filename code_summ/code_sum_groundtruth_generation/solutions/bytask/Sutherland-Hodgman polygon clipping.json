[{"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Python", "code": "\ndef clip(subjectPolygon, clipPolygon):\n   def inside(p):\n      return(cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0])\n      \n   def computeIntersection():\n      dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ]\n      dp = [ s[0] - e[0], s[1] - e[1] ]\n      n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0]\n      n2 = s[0] * e[1] - s[1] * e[0] \n      n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0])\n      return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3]\n\n   outputList = subjectPolygon\n   cp1 = clipPolygon[-1]\n   \n   for clipVertex in clipPolygon:\n      cp2 = clipVertex\n      inputList = outputList\n      outputList = []\n      s = inputList[-1]\n\n      for subjectVertex in inputList:\n         e = subjectVertex\n         if inside(e):\n            if not inside(s):\n               outputList.append(computeIntersection())\n            outputList.append(e)\n         elif inside(s):\n            outputList.append(computeIntersection())\n         s = e\n      cp1 = cp2\n   return(outputList)\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct { double x, y; } vec_t, *vec;\n\ninline double dot(vec a, vec b)\n{\n\treturn a->x * b->x + a->y * b->y;\n}\n\ninline double cross(vec a, vec b)\n{\n\treturn a->x * b->y - a->y * b->x;\n}\n\ninline vec vsub(vec a, vec b, vec res)\n{\n\tres->x = a->x - b->x;\n\tres->y = a->y - b->y;\n\treturn res;\n}\n\n/* tells if vec c lies on the left side of directed edge a->b\n * 1 if left, -1 if right, 0 if colinear\n */\nint left_of(vec a, vec b, vec c)\n{\n\tvec_t tmp1, tmp2;\n\tdouble x;\n\tvsub(b, a, &tmp1);\n\tvsub(c, b, &tmp2);\n\tx = cross(&tmp1, &tmp2);\n\treturn x < 0 ? -1 : x > 0;\n}\n\nint line_sect(vec x0, vec x1, vec y0, vec y1, vec res)\n{\n\tvec_t dx, dy, d;\n\tvsub(x1, x0, &dx);\n\tvsub(y1, y0, &dy);\n\tvsub(x0, y0, &d);\n\t/* x0 + a dx = y0 + b dy ->\n\t   x0 X dx = y0 X dx + b dy X dx ->\n\t   b = (x0 - y0) X dx / (dy X dx) */\n\tdouble dyx = cross(&dy, &dx);\n\tif (!dyx) return 0;\n\tdyx = cross(&d, &dx) / dyx;\n\tif (dyx <= 0 || dyx >= 1) return 0;\n\n\tres->x = y0->x + dyx * dy.x;\n\tres->y = y0->y + dyx * dy.y;\n\treturn 1;\n}\n\n/* === polygon stuff === */\ntypedef struct { int len, alloc; vec v; } poly_t, *poly;\n\npoly poly_new()\n{\n\treturn (poly)calloc(1, sizeof(poly_t));\n}\n\nvoid poly_free(poly p)\n{\n\tfree(p->v);\n\tfree(p);\n}\n\nvoid poly_append(poly p, vec v)\n{\n\tif (p->len >= p->alloc) {\n\t\tp->alloc *= 2;\n\t\tif (!p->alloc) p->alloc = 4;\n\t\tp->v = (vec)realloc(p->v, sizeof(vec_t) * p->alloc);\n\t}\n\tp->v[p->len++] = *v;\n}\n\n/* this works only if all of the following are true:\n *   1. poly has no colinear edges;\n *   2. poly has no duplicate vertices;\n *   3. poly has at least three vertices;\n *   4. poly is convex (implying 3).\n*/\nint poly_winding(poly p)\n{\n\treturn left_of(p->v, p->v + 1, p->v + 2);\n}\n\nvoid poly_edge_clip(poly sub, vec x0, vec x1, int left, poly res)\n{\n\tint i, side0, side1;\n\tvec_t tmp;\n\tvec v0 = sub->v + sub->len - 1, v1;\n\tres->len = 0;\n\n\tside0 = left_of(x0, x1, v0);\n\tif (side0 != -left) poly_append(res, v0);\n\n\tfor (i = 0; i < sub->len; i++) {\n\t\tv1 = sub->v + i;\n\t\tside1 = left_of(x0, x1, v1);\n\t\tif (side0 + side1 == 0 && side0)\n\t\t\t/* last point and current straddle the edge */\n\t\t\tif (line_sect(x0, x1, v0, v1, &tmp))\n\t\t\t\tpoly_append(res, &tmp);\n\t\tif (i == sub->len - 1) break;\n\t\tif (side1 != -left) poly_append(res, v1);\n\t\tv0 = v1;\n\t\tside0 = side1;\n\t}\n}\n\npoly poly_clip(poly sub, poly clip)\n{\n\tint i;\n\tpoly p1 = poly_new(), p2 = poly_new(), tmp;\n\n\tint dir = poly_winding(clip);\n\tpoly_edge_clip(sub, clip->v + clip->len - 1, clip->v, dir, p2);\n\tfor (i = 0; i < clip->len - 1; i++) {\n\t\ttmp = p2; p2 = p1; p1 = tmp;\n\t\tif(p1->len == 0) {\n\t\t\tp2->len = 0;\n\t\t\tbreak;\n\t\t}\n\t\tpoly_edge_clip(p1, clip->v + i, clip->v + i + 1, dir, p2);\n\t}\n\n\tpoly_free(p1);\n\treturn p2;\n}\n\nint main()\n{\n\tint i;\n\tvec_t c[] = {{100,100}, {300,100}, {300,300}, {100,300}};\n\t//vec_t c[] = {{100,300}, {300,300}, {300,100}, {100,100}};\n\tvec_t s[] = {\t{50,150}, {200,50}, {350,150},\n\t\t\t{350,300},{250,300},{200,250},\n\t\t\t{150,350},{100,250},{100,200}};\n#define clen (sizeof(c)/sizeof(vec_t))\n#define slen (sizeof(s)/sizeof(vec_t))\n\tpoly_t clipper = {clen, 0, c};\n\tpoly_t subject = {slen, 0, s};\n\n\tpoly res = poly_clip(&subject, &clipper);\n\n\tfor (i = 0; i < res->len; i++)\n\t\tprintf(\"%g %g\\n\", res->v[i].x, res->v[i].y);\n\n\t/* long and arduous EPS printout */\n\tFILE * eps = fopen(\"test.eps\", \"w\");\n\tfprintf(eps, \"%%!PS-Adobe-3.0\\n%%%%BoundingBox: 40 40 360 360\\n\"\n\t\t\"/l {lineto} def /m{moveto} def /s{setrgbcolor} def\"\n\t\t\"/c {closepath} def /gs {fill grestore stroke} def\\n\");\n\tfprintf(eps, \"0 setlinewidth %g %g m \", c[0].x, c[0].y);\n\tfor (i = 1; i < clen; i++)\n\t\tfprintf(eps, \"%g %g l \", c[i].x, c[i].y);\n\tfprintf(eps, \"c .5 0 0 s gsave 1 .7 .7 s gs\\n\");\n\n\tfprintf(eps, \"%g %g m \", s[0].x, s[0].y);\n\tfor (i = 1; i < slen; i++)\n\t\tfprintf(eps, \"%g %g l \", s[i].x, s[i].y);\n\tfprintf(eps, \"c 0 .2 .5 s gsave .4 .7 1 s gs\\n\");\n\n\tfprintf(eps, \"2 setlinewidth [10 8] 0 setdash %g %g m \",\n\t\tres->v[0].x, res->v[0].y);\n\tfor (i = 1; i < res->len; i++)\n\t\tfprintf(eps, \"%g %g l \", res->v[i].x, res->v[i].y);\n\tfprintf(eps, \"c .5 0 .5 s gsave .7 .3 .8 s gs\\n\");\n\n\tfprintf(eps, \"%%%%EOF\");\n\tfclose(eps);\n\tprintf(\"test.eps written\\n\");\n\n\treturn 0;\n}\n\nOutput:200 250\n175 300\n125 300\n100 250\n100 200\n100 116.667\n125 100\n275 100\n300 116.667\n300 300\n250 300\n\ntest.eps written\n", "explain": "Most of the code is actually storage util routines, such is C.  Prints out nodes, and writes test.eps file in current dir.\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "C++", "code": "\n#include <iostream>\n#include <span>\n#include <vector>\n\nstruct vec2 {\n    float x = 0.0f, y = 0.0f;\n\n    constexpr vec2 operator+(vec2 other) const {\n        return vec2{x + other.x, y + other.y};\n    }\n\n    constexpr vec2 operator-(vec2 other) const {\n        return vec2{x - other.x, y - other.y};\n    }\n};\n\nconstexpr vec2 operator*(vec2 a, float b) { return vec2{a.x * b, a.y * b}; }\n\nconstexpr float dot(vec2 a, vec2 b) { return a.x * b.x + a.y * b.y; }\n\nconstexpr float cross(vec2 a, vec2 b) { return a.x * b.y - b.x * a.y; }\n\n// check if a point is on the LEFT side of an edge\nconstexpr bool is_inside(vec2 point, vec2 a, vec2 b) {\n    return (cross(a - b, point) + cross(b, a)) < 0.0f;\n}\n\n// calculate intersection point\nconstexpr vec2 intersection(vec2 a1, vec2 a2, vec2 b1, vec2 b2) {\n    return ((b1 - b2) * cross(a1, a2) - (a1 - a2) * cross(b1, b2)) *\n           (1.0f / cross(a1 - a2, b1 - b2));\n}\n\n// Sutherland-Hodgman clipping\nstd::vector<vec2> suther_land_hodgman(\n    std::span<vec2 const> subject_polygon, std::span<vec2 const> clip_polygon) {\n    if (clip_polygon.empty() || subject_polygon.empty()) {\n        return {};\n    }\n\n    std::vector<vec2> ring{subject_polygon.begin(), subject_polygon.end()};\n\n    vec2 p1 = clip_polygon[clip_polygon.size() - 1];\n\n    std::vector<vec2> input;\n\n    for (vec2 p2 : clip_polygon) {\n        input.clear();\n        input.insert(input.end(), ring.begin(), ring.end());\n        vec2 s = input[input.size() - 1];\n\n        ring.clear();\n\n        for (vec2 e : input) {\n            if (is_inside(e, p1, p2)) {\n                if (!is_inside(s, p1, p2)) {\n                    ring.push_back(intersection(p1, p2, s, e));\n                }\n\n                ring.push_back(e);\n            } else if (is_inside(s, p1, p2)) {\n                ring.push_back(intersection(p1, p2, s, e));\n            }\n\n            s = e;\n        }\n\n        p1 = p2;\n    }\n\n    return ring;\n}\n\nint main(int argc, char **argv) {\n    // subject polygon\n    vec2 subject_polygon[] = {{50, 150},  {200, 50},  {350, 150},\n                              {350, 300}, {250, 300}, {200, 250},\n                              {150, 350}, {100, 250}, {100, 200}};\n\n    // clipping polygon\n    vec2 clip_polygon[] = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n    // apply clipping\n    std::vector<vec2> clipped_polygon =\n        suther_land_hodgman(subject_polygon, clip_polygon);\n\n    // print clipped polygon points\n    std::cout << \"Clipped polygon points:\" << std::endl;\n    for (vec2 p : clipped_polygon) {\n        std::cout << \"(\" << p.x << \", \" << p.y << \")\" << std::endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n\nOutput:\nClipped polygon points:\n(100, 116.667)\n(125, 100)\n(275, 100)\n(300, 116.667)\n(300, 300)\n(250, 300)\n(200, 250)\n(175, 300)\n(125, 300)\n(100, 250)\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Java", "code": "\nWorks with: Java version 7\nimport java.awt.*;\nimport java.awt.geom.Line2D;\nimport java.util.*;\nimport java.util.List;\nimport javax.swing.*;\n\npublic class SutherlandHodgman extends JFrame {\n\n    SutherlandHodgmanPanel panel;\n\n    public static void main(String[] args) {\n        JFrame f = new SutherlandHodgman();\n        f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        f.setVisible(true);\n    }\n\n    public SutherlandHodgman() {\n        Container content = getContentPane();\n        content.setLayout(new BorderLayout());\n        panel = new SutherlandHodgmanPanel();\n        content.add(panel, BorderLayout.CENTER);\n        setTitle(\"SutherlandHodgman\");\n        pack();\n        setLocationRelativeTo(null);\n    }\n}\n\nclass SutherlandHodgmanPanel extends JPanel {\n    List<double[]> subject, clipper, result;\n\n    public SutherlandHodgmanPanel() {\n        setPreferredSize(new Dimension(600, 500));\n\n        // these subject and clip points are assumed to be valid\n        double[][] subjPoints = {{50, 150}, {200, 50}, {350, 150}, {350, 300},\n        {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}};\n\n        double[][] clipPoints = {{100, 100}, {300, 100}, {300, 300}, {100, 300}};\n\n        subject = new ArrayList<>(Arrays.asList(subjPoints));\n        result  = new ArrayList<>(subject);\n        clipper = new ArrayList<>(Arrays.asList(clipPoints));\n\n        clipPolygon();\n    }\n\n    private void clipPolygon() {\n        int len = clipper.size();\n        for (int i = 0; i < len; i++) {\n\n            int len2 = result.size();\n            List<double[]> input = result;\n            result = new ArrayList<>(len2);\n\n            double[] A = clipper.get((i + len - 1) % len);\n            double[] B = clipper.get(i);\n\n            for (int j = 0; j < len2; j++) {\n\n                double[] P = input.get((j + len2 - 1) % len2);\n                double[] Q = input.get(j);\n\n                if (isInside(A, B, Q)) {\n                    if (!isInside(A, B, P))\n                        result.add(intersection(A, B, P, Q));\n                    result.add(Q);\n                } else if (isInside(A, B, P))\n                    result.add(intersection(A, B, P, Q));\n            }\n        }\n    }\n\n    private boolean isInside(double[] a, double[] b, double[] c) {\n        return (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0]);\n    }\n\n    private double[] intersection(double[] a, double[] b, double[] p, double[] q) {\n        double A1 = b[1] - a[1];\n        double B1 = a[0] - b[0];\n        double C1 = A1 * a[0] + B1 * a[1];\n\n        double A2 = q[1] - p[1];\n        double B2 = p[0] - q[0];\n        double C2 = A2 * p[0] + B2 * p[1];\n\n        double det = A1 * B2 - A2 * B1;\n        double x = (B2 * C1 - B1 * C2) / det;\n        double y = (A1 * C2 - A2 * C1) / det;\n\n        return new double[]{x, y};\n    }\n\n    @Override\n    public void paintComponent(Graphics g) {\n        super.paintComponent(g);\n        Graphics2D g2 = (Graphics2D) g;\n        g2.translate(80, 60);\n        g2.setStroke(new BasicStroke(3));\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawPolygon(g2, subject, Color.blue);\n        drawPolygon(g2, clipper, Color.red);\n        drawPolygon(g2, result, Color.green);\n    }\n\n    private void drawPolygon(Graphics2D g2, List<double[]> points, Color color) {\n        g2.setColor(color);\n        int len = points.size();\n        Line2D line = new Line2D.Double();\n        for (int i = 0; i < len; i++) {\n            double[] p1 = points.get(i);\n            double[] p2 = points.get((i + 1) % len);\n            line.setLine(p1[0], p1[1], p2[0], p2[1]);\n            g2.draw(line);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "C#", "code": "\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\n\nnamespace Sutherland\n{\n    public static class SutherlandHodgman\n    {\n        #region Class: Edge\n\n        /// <summary>\n        /// This represents a line segment\n        /// </summary>\n        private class Edge\n        {\n            public Edge(Point from, Point to)\n            {\n                this.From = from;\n                this.To = to;\n            }\n\n            public readonly Point From;\n            public readonly Point To;\n        }\n\n        #endregion\n\n        /// <summary>\n        /// This clips the subject polygon against the clip polygon (gets the intersection of the two polygons)\n        /// </summary>\n        /// <remarks>\n        /// Based on the psuedocode from:\n        /// http://en.wikipedia.org/wiki/Sutherland%E2%80%93Hodgman\n        /// </remarks>\n        /// <param name=\"subjectPoly\">Can be concave or convex</param>\n        /// <param name=\"clipPoly\">Must be convex</param>\n        /// <returns>The intersection of the two polygons (or null)</returns>\n        public static Point[] GetIntersectedPolygon(Point[] subjectPoly, Point[] clipPoly)\n        {\n            if (subjectPoly.Length < 3 || clipPoly.Length < 3)\n            {\n                throw new ArgumentException(string.Format(\"The polygons passed in must have at least 3 points: subject={0}, clip={1}\", subjectPoly.Length.ToString(), clipPoly.Length.ToString()));\n            }\n\n            List<Point> outputList = subjectPoly.ToList();\n\n            //\tMake sure it's clockwise\n            if (!IsClockwise(subjectPoly))\n            {\n                outputList.Reverse();\n            }\n\n            //\tWalk around the clip polygon clockwise\n            foreach (Edge clipEdge in IterateEdgesClockwise(clipPoly))\n            {\n                List<Point> inputList = outputList.ToList();\t\t//\tclone it\n                outputList.Clear();\n\n                if (inputList.Count == 0)\n                {\n                    //\tSometimes when the polygons don't intersect, this list goes to zero.  Jump out to avoid an index out of range exception\n                    break;\n                }\n\n                Point S = inputList[inputList.Count - 1];\n\n                foreach (Point E in inputList)\n                {\n                    if (IsInside(clipEdge, E))\n                    {\n                        if (!IsInside(clipEdge, S))\n                        {\n                            Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);\n                            if (point == null)\n                            {\n                                throw new ApplicationException(\"Line segments don't intersect\");\t\t//\tmay be colinear, or may be a bug\n                            }\n                            else\n                            {\n                                outputList.Add(point.Value);\n                            }\n                        }\n\n                        outputList.Add(E);\n                    }\n                    else if (IsInside(clipEdge, S))\n                    {\n                        Point? point = GetIntersect(S, E, clipEdge.From, clipEdge.To);\n                        if (point == null)\n                        {\n                            throw new ApplicationException(\"Line segments don't intersect\");\t\t//\tmay be colinear, or may be a bug\n                        }\n                        else\n                        {\n                            outputList.Add(point.Value);\n                        }\n                    }\n\n                    S = E;\n                }\n            }\n\n            //\tExit Function\n            return outputList.ToArray();\n        }\n\n        #region Private Methods\n\n        /// <summary>\n        /// This iterates through the edges of the polygon, always clockwise\n        /// </summary>\n        private static IEnumerable<Edge> IterateEdgesClockwise(Point[] polygon)\n        {\n            if (IsClockwise(polygon))\n            {\n                #region Already clockwise\n\n                for (int cntr = 0; cntr < polygon.Length - 1; cntr++)\n                {\n                    yield return new Edge(polygon[cntr], polygon[cntr + 1]);\n                }\n\n                yield return new Edge(polygon[polygon.Length - 1], polygon[0]);\n\n                #endregion\n            }\n            else\n            {\n                #region Reverse\n\n                for (int cntr = polygon.Length - 1; cntr > 0; cntr--)\n                {\n                    yield return new Edge(polygon[cntr], polygon[cntr - 1]);\n                }\n\n                yield return new Edge(polygon[0], polygon[polygon.Length - 1]);\n\n                #endregion\n            }\n        }\n\n        /// <summary>\n        /// Returns the intersection of the two lines (line segments are passed in, but they are treated like infinite lines)\n        /// </summary>\n        /// <remarks>\n        /// Got this here:\n        /// http://stackoverflow.com/questions/14480124/how-do-i-detect-triangle-and-rectangle-intersection\n        /// </remarks>\n        private static Point? GetIntersect(Point line1From, Point line1To, Point line2From, Point line2To)\n        {\n            Vector direction1 = line1To - line1From;\n            Vector direction2 = line2To - line2From;\n            double dotPerp = (direction1.X * direction2.Y) - (direction1.Y * direction2.X);\n\n            // If it's 0, it means the lines are parallel so have infinite intersection points\n            if (IsNearZero(dotPerp))\n            {\n                return null;\n            }\n\n            Vector c = line2From - line1From;\n            double t = (c.X * direction2.Y - c.Y * direction2.X) / dotPerp;\n            //if (t < 0 || t > 1)\n            //{\n            //    return null;\t\t//\tlies outside the line segment\n            //}\n\n            //double u = (c.X * direction1.Y - c.Y * direction1.X) / dotPerp;\n            //if (u < 0 || u > 1)\n            //{\n            //    return null;\t\t//\tlies outside the line segment\n            //}\n\n            //\tReturn the intersection point\n            return line1From + (t * direction1);\n        }\n\n        private static bool IsInside(Edge edge, Point test)\n        {\n            bool? isLeft = IsLeftOf(edge, test);\n            if (isLeft == null)\n            {\n                //\tColinear points should be considered inside\n                return true;\n            }\n\n            return !isLeft.Value;\n        }\n        private static bool IsClockwise(Point[] polygon)\n        {\n            for (int cntr = 2; cntr < polygon.Length; cntr++)\n            {\n                bool? isLeft = IsLeftOf(new Edge(polygon[0], polygon[1]), polygon[cntr]);\n                if (isLeft\u00a0!= null)\t\t//\tsome of the points may be colinear.  That's ok as long as the overall is a polygon\n                {\n                    return !isLeft.Value;\n                }\n            }\n\n            throw new ArgumentException(\"All the points in the polygon are colinear\");\n        }\n\n        /// <summary>\n        /// Tells if the test point lies on the left side of the edge line\n        /// </summary>\n        private static bool? IsLeftOf(Edge edge, Point test)\n        {\n            Vector tmp1 = edge.To - edge.From;\n            Vector tmp2 = test - edge.To;\n\n            double x = (tmp1.X * tmp2.Y) - (tmp1.Y * tmp2.X);\t\t//\tdot product of perpendicular?\n\n            if (x < 0)\n            {\n                return false;\n            }\n            else if (x > 0)\n            {\n                return true;\n            }\n            else\n            {\n                //\tColinear points;\n                return null;\n            }\n        }\n\n        private static bool IsNearZero(double testValue)\n        {\n            return Math.Abs(testValue) <= .000000001d;\n        }\n\n        #endregion\n    }\n}\n\n<Window x:Class=\"Sutherland.MainWindow\"\n        xmlns=\"http://schemas.microsoft.com/winfx/2006/xaml/presentation\"\n        xmlns:x=\"http://schemas.microsoft.com/winfx/2006/xaml\"\n        Title=\"Sutherland Hodgman\" Background=\"#B0B0B0\" ResizeMode=\"CanResizeWithGrip\" Width=\"525\" Height=\"450\">\n    <Grid Margin=\"4\">\n        <Grid.RowDefinitions>\n            <RowDefinition Height=\"1*\"/>\n            <RowDefinition Height=\"auto\"/>\n        </Grid.RowDefinitions>\n\n        <Border Grid.Row=\"0\" CornerRadius=\"4\" BorderBrush=\"#707070\" Background=\"#FFFFFF\" BorderThickness=\"2\">\n            <Canvas Name=\"canvas\"/>\n        </Border>\n\n        <UniformGrid Grid.Row=\"1\" Rows=\"1\" Margin=\"0,4,0,0\">\n            <Button Name=\"btnTriRect\" Content=\"Triangle - Rectangle\" Margin=\"4,0\" Click=\"btnTriRect_Click\"/>\n            <Button Name=\"btnConvex\" Content=\"Concave - Convex\" Click=\"btnConvex_Click\"/>\n        </UniformGrid>\n    </Grid>\n</Window>\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\nusing System.Windows;\nusing System.Windows.Controls;\nusing System.Windows.Data;\nusing System.Windows.Documents;\nusing System.Windows.Input;\nusing System.Windows.Media;\nusing System.Windows.Media.Imaging;\nusing System.Windows.Navigation;\nusing System.Windows.Shapes;\n\nnamespace Sutherland\n{\n    public partial class MainWindow\u00a0: Window\n    {\n        #region Declaration Section\n\n        private Random _rand = new Random();\n\n        private Brush _subjectBack = new SolidColorBrush(ColorFromHex(\"30427FCF\"));\n        private Brush _subjectBorder = new SolidColorBrush(ColorFromHex(\"427FCF\"));\n        private Brush _clipBack = new SolidColorBrush(ColorFromHex(\"30D65151\"));\n        private Brush _clipBorder = new SolidColorBrush(ColorFromHex(\"D65151\"));\n        private Brush _intersectBack = new SolidColorBrush(ColorFromHex(\"609F18CC\"));\n        private Brush _intersectBorder = new SolidColorBrush(ColorFromHex(\"9F18CC\"));\n\n        #endregion\n\n        #region Constructor\n\n        public MainWindow()\n        {\n            InitializeComponent();\n        }\n\n        #endregion\n\n        #region Event Listeners\n\n        private void btnTriRect_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                double width = canvas.ActualWidth;\n                double height = canvas.ActualHeight;\n\n                Point[] poly1 = new Point[] {\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height),\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height),\n\t\t\t\t    new Point(_rand.NextDouble() * width, _rand.NextDouble() * height) };\n\n                Point rectPoint = new Point(_rand.NextDouble() * (width * .75d), _rand.NextDouble() * (height * .75d));\t\t//\tdon't let it start all the way at the bottom right\n                Rect rect = new Rect(\n                    rectPoint,\n                    new Size(_rand.NextDouble() * (width - rectPoint.X), _rand.NextDouble() * (height - rectPoint.Y)));\n\n                Point[] poly2 = new Point[] { rect.TopLeft, rect.TopRight, rect.BottomRight, rect.BottomLeft };\n\n                Point[] intersect = SutherlandHodgman.GetIntersectedPolygon(poly1, poly2);\n\n                canvas.Children.Clear();\n                ShowPolygon(poly1, _subjectBack, _subjectBorder, 1d);\n                ShowPolygon(poly2, _clipBack, _clipBorder, 1d);\n                ShowPolygon(intersect, _intersectBack, _intersectBorder, 3d);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString(), this.Title, MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n        }\n        private void btnConvex_Click(object sender, RoutedEventArgs e)\n        {\n            try\n            {\n                Point[] poly1 = new Point[] { new Point(50, 150), new Point(200, 50), new Point(350, 150), new Point(350, 300), new Point(250, 300), new Point(200, 250), new Point(150, 350), new Point(100, 250), new Point(100, 200) };\n                Point[] poly2 = new Point[] { new Point(100, 100), new Point(300, 100), new Point(300, 300), new Point(100, 300) };\n\n                Point[] intersect = SutherlandHodgman.GetIntersectedPolygon(poly1, poly2);\n\n                canvas.Children.Clear();\n                ShowPolygon(poly1, _subjectBack, _subjectBorder, 1d);\n                ShowPolygon(poly2, _clipBack, _clipBorder, 1d);\n                ShowPolygon(intersect, _intersectBack, _intersectBorder, 3d);\n            }\n            catch (Exception ex)\n            {\n                MessageBox.Show(ex.ToString(), this.Title, MessageBoxButton.OK, MessageBoxImage.Error);\n            }\n        }\n\n        #endregion\n\n        #region Private Methods\n\n        private void ShowPolygon(Point[] points, Brush background, Brush border, double thickness)\n        {\n            if (points == null || points.Length == 0)\n            {\n                return;\n            }\n\n            Polygon polygon = new Polygon();\n            polygon.Fill = background;\n            polygon.Stroke = border;\n            polygon.StrokeThickness = thickness;\n\n            foreach (Point point in points)\n            {\n                polygon.Points.Add(point);\n            }\n\n            canvas.Children.Add(polygon);\n        }\n\n        /// <summary>\n        /// This is just a wrapper to the color converter (why can't they have a method off the color class with all\n        /// the others?)\n        /// </summary>\n        private static Color ColorFromHex(string hexValue)\n        {\n            if (hexValue.StartsWith(\"#\"))\n            {\n                return (Color)ColorConverter.ConvertFromString(hexValue);\n            }\n            else\n            {\n                return (Color)ColorConverter.ConvertFromString(\"#\" + hexValue);\n            }\n        }\n\n        #endregion\n    }\n}\n\n", "explain": "This was written in .net 4.0 using wpf\nWorker class:\nWindow code:\n\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "JavaScript", "code": "\n\n<html>\n    <head>\n\t<script>\n        function clip (subjectPolygon, clipPolygon) {\n            \n            var cp1, cp2, s, e;\n            var inside = function (p) {\n                return (cp2[0]-cp1[0])*(p[1]-cp1[1]) > (cp2[1]-cp1[1])*(p[0]-cp1[0]);\n            };\n            var intersection = function () {\n                var dc = [ cp1[0] - cp2[0], cp1[1] - cp2[1] ],\n                    dp = [ s[0] - e[0], s[1] - e[1] ],\n                    n1 = cp1[0] * cp2[1] - cp1[1] * cp2[0],\n                    n2 = s[0] * e[1] - s[1] * e[0], \n                    n3 = 1.0 / (dc[0] * dp[1] - dc[1] * dp[0]);\n                return [(n1*dp[0] - n2*dc[0]) * n3, (n1*dp[1] - n2*dc[1]) * n3];\n            };\n            var outputList = subjectPolygon;\n            cp1 = clipPolygon[clipPolygon.length-1];\n            for (var j in clipPolygon) {\n                cp2 = clipPolygon[j];\n                var inputList = outputList;\n                outputList = [];\n                s = inputList[inputList.length - 1]; //last on the input list\n                for (var i in inputList) {\n                    e = inputList[i];\n                    if (inside(e)) {\n                        if (!inside(s)) {\n                            outputList.push(intersection());\n                        }\n                        outputList.push(e);\n                    }\n                    else if (inside(s)) {\n                        outputList.push(intersection());\n                    }\n                    s = e;\n                }\n                cp1 = cp2;\n            }\n            return outputList\n        }\n\n        function drawPolygon(context, polygon, strokeStyle, fillStyle) {\n            context.strokeStyle = strokeStyle;\n            context.fillStyle = fillStyle;\n            context.beginPath();\n            context.moveTo(polygon[0][0],polygon[0][1]); //first vertex\n            for (var i = 1; i < polygon.length ; i++)\n                context.lineTo(polygon[i][0],polygon[i][1]);\n            context.lineTo(polygon[0][0],polygon[0][1]); //back to start\n            context.fill();\n            context.stroke();\n            context.closePath();\n        }\n\n        window.onload = function () {\n\t        var context = document.getElementById('canvas').getContext('2d');\n\t        var subjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300], [250, 300], [200, 250], [150, 350], [100, 250], [100, 200]],\n\t            clipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]];\n\t        var clippedPolygon = clip(subjectPolygon, clipPolygon);\n\t        drawPolygon(context, clipPolygon, '#888','#88f');\n\t        drawPolygon(context, subjectPolygon, '#888','#8f8');\n\t        drawPolygon(context, clippedPolygon, '#000','#0ff');\n    \t}\n        </script>\n    <body>\n    \t<canvas id='canvas' width='400' height='400'></canvas>\n    </body>\n</html>\n\n\n", "explain": "Solution:\nYou can see it running here\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "PHP", "code": "\n<?php\nfunction clip ($subjectPolygon, $clipPolygon) {\n\n    function inside ($p, $cp1, $cp2) {\n        return ($cp2[0]-$cp1[0])*($p[1]-$cp1[1]) > ($cp2[1]-$cp1[1])*($p[0]-$cp1[0]);\n    }\n    \n    function intersection ($cp1, $cp2, $e, $s) {\n        $dc = [ $cp1[0] - $cp2[0], $cp1[1] - $cp2[1] ];\n        $dp = [ $s[0] - $e[0], $s[1] - $e[1] ];\n        $n1 = $cp1[0] * $cp2[1] - $cp1[1] * $cp2[0];\n        $n2 = $s[0] * $e[1] - $s[1] * $e[0];\n        $n3 = 1.0 / ($dc[0] * $dp[1] - $dc[1] * $dp[0]);\n\n        return [($n1*$dp[0] - $n2*$dc[0]) * $n3, ($n1*$dp[1] - $n2*$dc[1]) * $n3];\n    }\n    \n    $outputList = $subjectPolygon;\n    $cp1 = end($clipPolygon);\n    foreach ($clipPolygon as $cp2) {\n        $inputList = $outputList;\n        $outputList = [];\n        $s = end($inputList);\n        foreach ($inputList as $e) {\n            if (inside($e, $cp1, $cp2)) {\n                if (!inside($s, $cp1, $cp2)) {\n                    $outputList[] = intersection($cp1, $cp2, $e, $s);\n                }\n                $outputList[] = $e;\n            }\n            else if (inside($s, $cp1, $cp2)) {\n                $outputList[] = intersection($cp1, $cp2, $e, $s);\n            }\n            $s = $e;\n        }\n        $cp1 = $cp2;\n    }\n    return $outputList;\n}\n\n$subjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300], [250, 300], [200, 250], [150, 350], [100, 250], [100, 200]];\n$clipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]];\n$clippedPolygon = clip($subjectPolygon, $clipPolygon);\n\necho json_encode($clippedPolygon);\necho \"\\n\";\n?>\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Fortran", "code": "\n\nmodule SutherlandHodgmanUtil\n  ! functions and type needed for Sutherland-Hodgman algorithm\n\n  ! --------------------------------------------------------\u00a0!\n  type polygon\n    !type for polygons\n    ! when you define a polygon, the first and the last vertices have to be the same\n    integer :: n\n    double precision, dimension(:,:), allocatable :: vertex\n  end type polygon\n  \n  contains \n  \n  ! --------------------------------------------------------\u00a0!\n  subroutine sutherlandHodgman( ref, clip, outputPolygon )\n    ! Sutherland Hodgman algorithm for 2d polygons\n  \n    ! -- parameters of the subroutine --\n    type(polygon) :: ref, clip, outputPolygon\n  \n    ! -- variables used is the subroutine\n    type(polygon) :: workPolygon               ! polygon clipped step by step \n    double precision, dimension(2) :: y1,y2    ! vertices of edge to clip workPolygon\n    integer :: i  \n  \n    ! allocate workPolygon with the maximal possible size\n    !   the sum of the size of polygon ref and clip\n    allocate(workPolygon%vertex( ref%n+clip%n , 2 ))\n    \n    !  initialise the work polygon with clip\n    workPolygon%n = clip%n\n    workPolygon%vertex(1:workPolygon%n,:) = clip%vertex(1:workPolygon%n,:)\n\n    do i=1,ref%n-1 ! for each edge i of the polygon ref\n      y1(:) = ref%vertex(i,:)   !  vertex 1 of edge i\n      y2(:) = ref%vertex(i+1,:) !  vertex 2 of edge i\n  \n      ! clip the work polygon by edge i\n      call edgeClipping( workPolygon, y1, y2, outputPolygon)\n      ! workPolygon <= outputPolygon\n      workPolygon%n = outputPolygon%n\n      workPolygon%vertex(1:workPolygon%n,:) = outputPolygon%vertex(1:workPolygon%n,:)\n\n    end do \n    deallocate(workPolygon%vertex)\n  end subroutine sutherlandHodgman\n  \n  ! --------------------------------------------------------\u00a0!\n  subroutine edgeClipping( poly, y1, y2, outputPoly )\n    ! make the clipping  of the polygon by the line (x1x2)\n    \n    type(polygon) :: poly, outputPoly\n    double precision, dimension(2) :: y1, y2, x1, x2, intersecPoint\n    integer ::  i, c\n    \n    c = 0 ! counter for the output polygon\n    \n    do i=1,poly%n-1 ! for each edge i of poly\n      x1(:) = poly%vertex(i,:)   ! vertex 1 of edge i\n      x2(:) = poly%vertex(i+1,:) ! vertex 2 of edge i\n      \n      if ( inside(x1, y1, y2) ) then ! if vertex 1 in inside clipping region\n        if ( inside(x2, y1, y2) ) then ! if vertex 2 in inside clipping region\n          ! add the vertex 2 to the output polygon\n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n\n        else ! vertex i+1 is outside\n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n        end if\n      else ! vertex i is outside\n        if ( inside(x2, y1, y2) ) then\n          intersecPoint = intersection(x1, x2, y1,y2)\n          c = c+1\n          outputPoly%vertex(c,:) = intersecPoint(:)\n          \n          c = c+1\n          outputPoly%vertex(c,:) = x2(:)\n        end if\n      end if\n    end do\n    \n    if (c .gt. 0) then\n      ! if the last vertice is not equal to the first one\n      if ( (outputPoly%vertex(1,1) .ne. outputPoly%vertex(c,1)) .or. & \n           (outputPoly%vertex(1,2) .ne. outputPoly%vertex(c,2)))  then\n        c=c+1\n        outputPoly%vertex(c,:) = outputPoly%vertex(1,:)\n      end if\n    end if\n    ! set the size of the outputPolygon\n    outputPoly%n = c\n  end subroutine edgeClipping\n  \n  ! --------------------------------------------------------\u00a0!\n  function intersection( x1, x2, y1, y2)\n    ! computes the intersection between segment [x1x2] \n    ! and line the line (y1y2) \n\n    ! -- parameters of the function --\n    double precision, dimension(2) :: x1, x2, &  ! points of the segment\n                                      y1, y2     ! points of the line\n    \n    double precision, dimension(2) :: intersection, vx, vy, x1y1 \n    double precision :: a\n  \n    vx(:) = x2(:) - x1(:) \n    vy(:) = y2(:) - y1(:)\n\n    ! if the vectors are colinear\n    if ( crossProduct(vx,vy) .eq. 0.d0) then\n      x1y1(:) = y1(:) - x1(:)\n      ! if the the segment [x1x2] is included in the line (y1y2)\n      if ( crossProduct(x1y1,vx) .eq. 0.d0) then\n        ! the intersection is the last point of the segment\n        intersection(:) = x2(:)\n      end if\n    else ! the vectors are not colinear\n      ! we want to find the inersection between [x1x2]\n      ! and (y1,y2).\n      ! mathematically, we want to find a in [0;1] such\n      ! that\u00a0:\n      !     x1 + a vx = y1 + b vy        \n      ! <=> a vx = x1y1 + b vy\n      ! <=> a vx^vy = x1y1^vy      , ^ is cross product\n      ! <=> a = x1y1^vy / vx^vy\n     \n      x1y1(:) = y1(:) - x1(:) \n      ! we compute a\n      a = crossProduct(x1y1,vy)/crossProduct(vx,vy)\n      ! if a is not in [0;1]\n      if ( (a .gt. 1.d0) .or. (a .lt. 0)) then\n        ! no intersection\n      else\n        intersection(:) = x1(:) + a*vx(:)\n      end if\n    end if\n\n  end function intersection\n  \n  \n  ! --------------------------------------------------------\u00a0!\n  function inside( p, y1, y2)\n    ! function that tells is the point p is at left of the line (y1y2)\n    \n    double precision, dimension(2) :: p, y1, y2, v1, v2\n    logical :: inside\n    v1(:) = y2(:) -  y1(:)\n    v2(:) = p(:)  -  y1(:)  \n    if ( crossProduct(v1,v2) .ge. 0.d0) then\n      inside = .true.\n    else \n      inside = .false.\n    end if\n   \n   contains \n  end function inside\n\n  ! --------------------------------------------------------\u00a0!\n  function dotProduct( v1, v2)\n    ! compute the dot product of vectors v1 and v2\n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: dotProduct\n    dotProduct = v1(1)*v2(1) + v1(2)*v2(2)\n  end function dotProduct\n\n  ! --------------------------------------------------------\u00a0!\n  function crossProduct( v1, v2)\n    ! compute the crossproduct of vectors v1 and v2\n    double precision, dimension(2) :: v1\n    double precision, dimension(2) :: v2\n    double precision :: crossProduct\n    crossProduct = v1(1)*v2(2) - v1(2)*v2(1)\n  end function crossProduct\n\nend module SutherlandHodgmanUtil\n\nprogram main\n  \n  ! load the module for S-H algorithm\n  use SutherlandHodgmanUtil, only : polygon, &\n                                    sutherlandHodgman, &\n                                    edgeClipping\n\n  type(polygon) :: p1, p2, res\n  integer :: c, n \n  double precision, dimension(2) :: y1, y2\n  \n  ! when you define a polygon, the first and the last vertices have to be the same\n\n  ! first polygon\n  p1%n = 10\n  allocate(p1%vertex(p1%n,2))\n  p1%vertex(1,1)=50.d0\n  p1%vertex(1,2)=150.d0\n  \n  p1%vertex(2,1)=200.d0\n  p1%vertex(2,2)=50.d0\n  \n  p1%vertex(3,1)= 350.d0\n  p1%vertex(3,2)= 150.d0\n  \n  p1%vertex(4,1)= 350.d0\n  p1%vertex(4,2)= 300.d0\n  \n  p1%vertex(5,1)= 250.d0\n  p1%vertex(5,2)= 300.d0\n  \n  p1%vertex(6,1)= 200.d0\n  p1%vertex(6,2)= 250.d0\n  \n  p1%vertex(7,1)= 150.d0\n  p1%vertex(7,2)= 350.d0\n  \n  p1%vertex(8,1)= 100.d0\n  p1%vertex(8,2)= 250.d0\n  \n  p1%vertex(9,1)= 100.d0\n  p1%vertex(9,2)= 200.d0\n  \n  p1%vertex(10,1)=  50.d0\n  p1%vertex(10,2)= 150.d0\n \n  y1 = (/ 100.d0, 300.d0 /)\n  y2 = (/ 300.d0, 300.d0 /)\n  \n  ! second polygon\n  p2%n = 5\n  allocate(p2%vertex(p2%n,2))\n\n  p2%vertex(1,1)= 100.d0\n  p2%vertex(1,2)= 100.d0\n  \n  p2%vertex(2,1)= 300.d0\n  p2%vertex(2,2)= 100.d0\n  \n  p2%vertex(3,1)= 300.d0\n  p2%vertex(3,2)= 300.d0\n  \n  p2%vertex(4,1)= 100.d0\n  p2%vertex(4,2)= 300.d0\n  \n  p2%vertex(5,1)= 100.d0\n  p2%vertex(5,2)= 100.d0\n \n  allocate(res%vertex(p1%n+p2%n,2))\n  call sutherlandHodgman( p2, p1, res)\n  write(*,*) \"Suterland-Hodgman\"\n  do c=1, res%n\n    write(*,*) res%vertex(c,1), res%vertex(c,2)\n  end do\n  deallocate(res%vertex)\n\nend program main\n\n\n  Suterland-Hodgman\n  300.00000000000000        300.00000000000000     \n  250.00000000000000        300.00000000000000     \n  200.00000000000000        250.00000000000000     \n  175.00000000000000        300.00000000000000     \n  125.00000000000000        300.00000000000000     \n  100.00000000000000        250.00000000000000     \n  100.00000000000000        200.00000000000000     \n  100.00000000000000        200.00000000000000     \n  100.00000000000000        116.66666666666667     \n  125.00000000000000        100.00000000000000     \n  275.00000000000000        100.00000000000000     \n  300.00000000000000        116.66666666666666     \n  300.00000000000000        300.00000000000000\n\n", "explain": "Infos:\nThe polygons are fortran type with an allocatable array \"vertex\" that contains the vertices and an integer n that is the size of the polygon. For any polygon, the first vertex and the last vertex have to be the same. \nAs you will see, in the main function, we allocate the vertex array of the result polygon with its maximal size. \nOutput:\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\ntype point struct {\n    x, y float32\n}\n\nvar subjectPolygon = []point{{50, 150}, {200, 50}, {350, 150}, {350, 300},\n    {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}}\n\nvar clipPolygon = []point{{100, 100}, {300, 100}, {300, 300}, {100, 300}}\n\nfunc main() {\n    var cp1, cp2, s, e point\n    inside := func(p point) bool {\n        return (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)\n    }\n    intersection := func() (p point) {\n        dcx, dcy := cp1.x-cp2.x, cp1.y-cp2.y\n        dpx, dpy := s.x-e.x, s.y-e.y\n        n1 := cp1.x*cp2.y - cp1.y*cp2.x\n        n2 := s.x*e.y - s.y*e.x\n        n3 := 1 / (dcx*dpy - dcy*dpx)\n        p.x = (n1*dpx - n2*dcx) * n3\n        p.y = (n1*dpy - n2*dcy) * n3\n        return\n    }\n    outputList := subjectPolygon\n    cp1 = clipPolygon[len(clipPolygon)-1]\n    for _, cp2 = range clipPolygon { // WP clipEdge is cp1,cp2 here\n        inputList := outputList\n        outputList = nil\n        s = inputList[len(inputList)-1]\n        for _, e = range inputList {\n            if inside(e) {\n                if !inside(s) {\n                    outputList = append(outputList, intersection())\n                }\n                outputList = append(outputList, e)\n            } else if inside(s) {\n                outputList = append(outputList, intersection())\n            }\n            s = e\n        }\n        cp1 = cp2\n    }\n    fmt.Println(outputList)\n}\n\n\nOutput:\n[{100 116.66667} {125 100} {275 100} {300 116.66667} {300 300} {250 300} {200 250} {175 300} {125 300} {100 250}]\n\n\n", "explain": "No extra credit today.\n(You can try it online)\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Ruby", "code": "\nTranslation of: Go\nPoint = Struct.new(:x,:y) do\n  def to_s; \"(#{x}, #{y})\" end\nend\n\ndef sutherland_hodgman(subjectPolygon, clipPolygon)\n  # These inner functions reduce the argument passing to\n  # \"inside\" and \"intersection\".\n  cp1, cp2, s, e = nil\n  inside = proc do |p|\n    (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)\n  end\n  intersection = proc do\n    dcx, dcy = cp1.x-cp2.x, cp1.y-cp2.y\n    dpx, dpy = s.x-e.x, s.y-e.y\n    n1 = cp1.x*cp2.y - cp1.y*cp2.x\n    n2 = s.x*e.y - s.y*e.x\n    n3 = 1.0 / (dcx*dpy - dcy*dpx)\n    Point[(n1*dpx - n2*dcx) * n3, (n1*dpy - n2*dcy) * n3]\n  end\n  \n  outputList = subjectPolygon\n  cp1 = clipPolygon.last\n  for cp2 in clipPolygon\n    inputList = outputList\n    outputList = []\n    s = inputList.last\n    for e in inputList\n      if inside[e]\n        outputList << intersection[] unless inside[s]\n        outputList << e\n      elsif inside[s]\n        outputList << intersection[]\n      end\n      s = e\n    end\n    cp1 = cp2\n  end\n  outputList\nend\n\nsubjectPolygon = [[50, 150], [200, 50], [350, 150], [350, 300],\n                  [250, 300], [200, 250], [150, 350], [100, 250],\n                  [100, 200]].collect{|pnt| Point[*pnt]}\n \nclipPolygon = [[100, 100], [300, 100], [300, 300], [100, 300]].collect{|pnt| Point[*pnt]}\n \nputs sutherland_hodgman(subjectPolygon, clipPolygon)\n\n\nOutput:\n(100.0, 116.66666666666667)\n(125.00000000000001, 100.0)\n(275.0, 100.0)\n(300.0, 116.66666666666667)\n(300.0, 299.99999999999994)\n(250.0, 300.0)\n(200, 250)\n(175.0, 300.0)\n(125.0, 300.0)\n(100.0, 250.0)\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Rust", "code": "\nTranslation of: Ruby\n#[derive(Debug, Clone)]\nstruct Point {\n    x: f64,\n    y: f64,\n}\n\n#[derive(Debug, Clone)]\nstruct Polygon(Vec<Point>);\n\nfn is_inside(p: &Point, cp1: &Point, cp2: &Point) -> bool {\n    (cp2.x - cp1.x) * (p.y - cp1.y) > (cp2.y - cp1.y) * (p.x - cp1.x)\n}\n\nfn compute_intersection(cp1: &Point, cp2: &Point, s: &Point, e: &Point) -> Point {\n    let dc = Point {\n        x: cp1.x - cp2.x,\n        y: cp1.y - cp2.y,\n    };\n    let dp = Point {\n        x: s.x - e.x,\n        y: s.y - e.y,\n    };\n    let n1 = cp1.x * cp2.y - cp1.y * cp2.x;\n    let n2 = s.x * e.y - s.y * e.x;\n    let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);\n    Point {\n        x: (n1 * dp.x - n2 * dc.x) * n3,\n        y: (n1 * dp.y - n2 * dc.y) * n3,\n    }\n}\n\nfn sutherland_hodgman_clip(subject_polygon: &Polygon, clip_polygon: &Polygon) -> Polygon {\n    let mut result_ring = subject_polygon.0.clone();\n    let mut cp1 = clip_polygon.0.last().unwrap();\n    for cp2 in &clip_polygon.0 {\n        let input = result_ring;\n        let mut s = input.last().unwrap();\n        result_ring = vec![];\n        for e in &input {\n            if is_inside(e, cp1, cp2) {\n                if !is_inside(s, cp1, cp2) {\n                    result_ring.push(compute_intersection(cp1, cp2, s, e));\n                }\n                result_ring.push(e.clone());\n            } else if is_inside(s, cp1, cp2) {\n                result_ring.push(compute_intersection(cp1, cp2, s, e));\n            }\n            s = e;\n        }\n        cp1 = cp2;\n    }\n    Polygon(result_ring)\n}\n\nfn main() {\n    let _p = |x: f64, y: f64| Point { x, y };\n    let subject_polygon = Polygon(vec![\n        _p(50.0, 150.0), _p(200.0, 50.0), _p(350.0, 150.0), _p(350.0, 300.0), _p(250.0, 300.0),\n        _p(200.0, 250.0), _p(150.0, 350.0), _p(100.0, 250.0), _p(100.0, 200.0),\n    ]);\n    let clip_polygon = Polygon(vec![\n        _p(100.0, 100.0),_p(300.0, 100.0),_p(300.0, 300.0),_p(100.0, 300.0),\n    ]);\n    let result = sutherland_hodgman_clip(&subject_polygon, &clip_polygon);\n    println!(\"{:?}\", result);\n}\n\n\nOutput:\nPolygon([\n    Point { x: 100, y: 116.66666666666667 }, Point { x: 125.00000000000001, y: 100 }, Point { x: 275, y: 100 },\n    Point { x: 300, y: 116.66666666666667 }, Point { x: 300, y: 299.99999999999994 }, Point { x: 250, y: 300 },\n    Point { x: 200, y: 250 }, Point { x: 175, y: 300 }, Point { x: 125, y: 300 }, Point { x: 100, y: 250 }])\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Swift", "code": "\nTranslation of: Rust\nstruct Point {\n  var x: Double\n  var y: Double\n}\n\nstruct Polygon {\n  var points: [Point]\n\n  init(points: [Point]) {\n    self.points = points\n  }\n\n  init(points: [(Double, Double)]) {\n    self.init(points: points.map({ Point(x: $0.0, y: $0.1) }))\n  }\n}\n\nfunc isInside(_ p1: Point, _ p2: Point, _ p3: Point) -> Bool {\n  (p3.x - p2.x) * (p1.y - p2.y) > (p3.y - p2.y) * (p1.x - p2.x)\n}\n\nfunc computeIntersection(_ p1: Point, _ p2: Point, _ s: Point, _ e: Point) -> Point {\n  let dc = Point(x: p1.x - p2.x, y: p1.y - p2.y)\n  let dp = Point(x: s.x - e.x, y: s.y - e.y)\n  let n1 = p1.x * p2.y - p1.y * p2.x\n  let n2 = s.x * e.y - s.y * e.x\n  let n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x)\n\n  return Point(x: (n1 * dp.x - n2 * dc.x) * n3, y: (n1 * dp.y - n2 * dc.y) * n3)\n}\n\nfunc sutherlandHodgmanClip(subjPoly: Polygon, clipPoly: Polygon) -> Polygon {\n  var ring = subjPoly.points\n  var p1 = clipPoly.points.last!\n\n  for p2 in clipPoly.points {\n    let input = ring\n    var s = input.last!\n\n    ring = []\n\n    for e in input {\n      if isInside(e, p1, p2) {\n        if !isInside(s, p1, p2) {\n          ring.append(computeIntersection(p1, p2, s, e))\n        }\n\n        ring.append(e)\n      } else if isInside(s, p1, p2) {\n        ring.append(computeIntersection(p1, p2, s, e))\n      }\n\n      s = e\n    }\n\n    p1 = p2\n  }\n\n  return Polygon(points: ring)\n}\n\nlet subj = Polygon(points: [\n  (50.0, 150.0),\n  (200.0, 50.0),\n  (350.0, 150.0),\n  (350.0, 300.0),\n  (250.0, 300.0),\n  (200.0, 250.0),\n  (150.0, 350.0),\n  (100.0, 250.0),\n  (100.0, 200.0)\n])\n\nlet clip = Polygon(points: [\n  (100.0, 100.0),\n  (300.0, 100.0),\n  (300.0, 300.0),\n  (100.0, 300.0)\n])\n\nprint(sutherlandHodgmanClip(subjPoly: subj, clipPoly: clip))\n\n\nOutput:\nPolygon(points: [Point(x: 100.0, y: 116.66666666666667), Point(x: 125.00000000000001, y: 100.0), Point(x: 275.0, y: 100.0), Point(x: 300.0, y: 116.66666666666667), Point(x: 300.0, y: 299.99999999999994), Point(x: 250.0, y: 300.0), Point(x: 200.0, y: 250.0), Point(x: 175.0, y: 300.0), Point(x: 125.0, y: 300.0), Point(x: 100.0, y: 250.0)])\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Ada", "code": "\nwith Ada.Containers.Doubly_Linked_Lists;\nwith Ada.Text_IO;\n\nprocedure Main is\n   package FIO is new Ada.Text_IO.Float_IO (Float);\n\n   type Point is record\n      X, Y : Float;\n   end record;\n\n   function \"-\" (Left, Right : Point) return Point is\n   begin\n      return (Left.X - Right.X, Left.Y - Right.Y);\n   end \"-\";\n\n   type Edge is array (1 .. 2) of Point;\n\n   package Point_Lists is new Ada.Containers.Doubly_Linked_Lists\n     (Element_Type => Point);\n   use type Point_Lists.List;\n   subtype Polygon is Point_Lists.List;\n\n   function Inside (P : Point; E : Edge) return Boolean is\n   begin\n      return (E (2).X - E (1).X) * (P.Y - E (1).Y) >\n             (E (2).Y - E (1).Y) * (P.X - E (1).X);\n   end Inside;\n\n   function Intersecton (P1, P2 : Point; E : Edge) return Point is\n      DE : Point := E (1) - E (2);\n      DP : Point := P1 - P2;\n      N1 : Float := E (1).X * E (2).Y - E (1).Y * E (2).X;\n      N2 : Float := P1.X * P2.Y - P1.Y * P2.X;\n      N3 : Float := 1.0 / (DE.X * DP.Y - DE.Y * DP.X);\n   begin\n      return ((N1 * DP.X - N2 * DE.X) * N3, (N1 * DP.Y - N2 * DE.Y) * N3);\n   end Intersecton;\n\n   function Clip (P, C : Polygon) return Polygon is\n      use Point_Lists;\n      A, B, S, E : Cursor;\n      Inputlist  : List;\n      Outputlist : List := P;\n      AB         : Edge;\n   begin\n      A := C.First;\n      B := C.Last;\n      while A /= No_Element loop\n         AB        := (Element (B), Element (A));\n         Inputlist := Outputlist;\n         Outputlist.Clear;\n         S := Inputlist.Last;\n         E := Inputlist.First;\n         while E /= No_Element loop\n            if Inside (Element (E), AB) then\n               if not Inside (Element (S), AB) then\n                  Outputlist.Append\n                    (Intersecton (Element (S), Element (E), AB));\n               end if;\n               Outputlist.Append (Element (E));\n            elsif Inside (Element (S), AB) then\n               Outputlist.Append\n                 (Intersecton (Element (S), Element (E), AB));\n            end if;\n            S := E;\n            E := Next (E);\n         end loop;\n         B := A;\n         A := Next (A);\n      end loop;\n      return Outputlist;\n   end Clip;\n\n   procedure Print (P : Polygon) is\n      use Point_Lists;\n      C : Cursor := P.First;\n   begin\n      Ada.Text_IO.Put_Line (\"{\");\n      while C /= No_Element loop\n         Ada.Text_IO.Put (\" (\");\n         FIO.Put (Element (C).X, Exp => 0);\n         Ada.Text_IO.Put (',');\n         FIO.Put (Element (C).Y, Exp => 0);\n         Ada.Text_IO.Put (')');\n         C := Next (C);\n         if C /= No_Element then\n            Ada.Text_IO.Put (',');\n         end if;\n         Ada.Text_IO.New_Line;\n      end loop;\n      Ada.Text_IO.Put_Line (\"}\");\n   end Print;\n\n   Source  : Polygon;\n   Clipper : Polygon;\n   Result  : Polygon;\nbegin\n   Source.Append ((50.0, 150.0));\n   Source.Append ((200.0, 50.0));\n   Source.Append ((350.0, 150.0));\n   Source.Append ((350.0, 300.0));\n   Source.Append ((250.0, 300.0));\n   Source.Append ((200.0, 250.0));\n   Source.Append ((150.0, 350.0));\n   Source.Append ((100.0, 250.0));\n   Source.Append ((100.0, 200.0));\n   Clipper.Append ((100.0, 100.0));\n   Clipper.Append ((300.0, 100.0));\n   Clipper.Append ((300.0, 300.0));\n   Clipper.Append ((100.0, 300.0));\n   Result := Clip (Source, Clipper);\n   Print (Result);\nend Main;\n\n\nOutput:\n{\n (100.00000,116.66667),\n (125.00000,100.00000),\n (275.00000,100.00000),\n (300.00000,116.66667),\n (300.00000,300.00000),\n (250.00000,300.00000),\n (200.00000,250.00000),\n (175.00000,300.00000),\n (125.00000,300.00000),\n (100.00000,250.00000)\n}\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Julia", "code": "\nusing Luxor\n\nisinside(p, a, b) = (b.x - a.x) * (p.y - a.y) > (b.y - a.y) * (p.x - a.x)\n\nfunction intersection(a, b, s, f)\n    dc = [a.x - b.x, a.y - b.y]\n    dp = [s.x - f.x, s.y - f.y]\n    n1 = a.x * b.y - a.y * b.x\n    n2 = s.x * f.y - s.y * f.x\n    n3 = 1.0 / (dc[1] * dp[2] - dc[2] * dp[1])\n    Point((n1 * dp[1] - n2 * dc[1]) * n3, (n1 * dp[2] - n2 * dc[2]) * n3)\nend\n\nfunction clipSH(spoly, cpoly)\n    outarr = spoly\n    q = cpoly[end]\n    for p in cpoly\n        inarr = outarr\n        outarr = Point[]\n        s = inarr[end]\n        for vtx in inarr\n            if isinside(vtx, q, p)\n                if !isinside(s, q, p)\n                    push!(outarr, intersection(q, p, s, vtx))\n                end\n                push!(outarr, vtx)\n            elseif isinside(s, q, p)\n                push!(outarr, intersection(q, p, s, vtx))\n            end\n            s = vtx\n        end\n        q = p\n    end\n    outarr\nend\n\nsubjectp = [Point(50, 150), Point(200, 50), Point(350, 150), Point(350, 300),\n    Point(250, 300), Point(200, 250), Point(150, 350), Point(100, 250), Point(100, 200)]\n\nclipp = [Point(100, 100), Point(300, 100), Point(300, 300), Point(100, 300)]\n\nDrawing(400, 400, \"intersecting-polygons.png\")\nbackground(\"white\")\nsethue(\"red\")\npoly(subjectp, :stroke, close=true)\nsethue(\"blue\")\npoly(clipp, :stroke, close=true)\nclipped = clipSH(subjectp, clipp)\nsethue(\"gold\")\npoly(clipped, :fill, close=true)\nfinish()\npreview()\nprintln(clipped)\n\nOutput:\nPoint[Point(100.0, 116.667), Point(125.0, 100.0), Point(275.0, 100.0), Point(300.0, 116.667),\n    Point(300.0, 300.0), Point(250.0, 300.0), Point(200.0, 250.0), Point(175.0, 300.0), \n    Point(125.0, 300.0), Point(100.0, 250.0)]\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.2\n\nimport java.awt.*\nimport java.awt.geom.Line2D\nimport javax.swing.*\n \nclass SutherlandHodgman : JPanel() {\n    private val subject = listOf(\n        doubleArrayOf( 50.0, 150.0), doubleArrayOf(200.0,  50.0), doubleArrayOf(350.0, 150.0), \n        doubleArrayOf(350.0, 300.0), doubleArrayOf(250.0, 300.0), doubleArrayOf(200.0, 250.0), \n        doubleArrayOf(150.0, 350.0), doubleArrayOf(100.0, 250.0), doubleArrayOf(100.0, 200.0)\n    )\n\n    private val clipper = listOf(\n        doubleArrayOf(100.0, 100.0), doubleArrayOf(300.0, 100.0), \n        doubleArrayOf(300.0, 300.0), doubleArrayOf(100.0, 300.0)\n    )\n\n    private var result = subject.toMutableList()\n\n    init {\n        preferredSize = Dimension(600, 500)\n        clipPolygon()\n    } \n\n    private fun clipPolygon() {\n        val len = clipper.size\n        for (i in 0 until len) { \n            val len2 = result.size\n            val input = result\n            result = mutableListOf<DoubleArray>() \n            val a = clipper[(i + len - 1) % len]\n            val b = clipper[i]\n \n            for (j in 0 until len2) {\n                val p = input[(j + len2 - 1) % len2]\n                val q = input[j]\n \n                if (isInside(a, b, q)) {\n                    if (!isInside(a, b, p)) result.add(intersection(a, b, p, q))\n                    result.add(q)\n                } \n                else if (isInside(a, b, p)) result.add(intersection(a, b, p, q))\n            }\n        }\n    } \n\n    private fun isInside(a: DoubleArray, b: DoubleArray, c: DoubleArray) =\n        (a[0] - c[0]) * (b[1] - c[1]) > (a[1] - c[1]) * (b[0] - c[0])\n\n    private fun intersection(a: DoubleArray, b: DoubleArray, \n                             p: DoubleArray, q: DoubleArray): DoubleArray {\n        val a1 = b[1] - a[1]\n        val b1 = a[0] - b[0]\n        val c1 = a1 * a[0] + b1 * a[1]\n \n        val a2 = q[1] - p[1]\n        val b2 = p[0] - q[0]\n        val c2 = a2 * p[0] + b2 * p[1]\n \n        val d = a1 * b2 - a2 * b1\n        val x = (b2 * c1 - b1 * c2) / d\n        val y = (a1 * c2 - a2 * c1) / d\n \n        return doubleArrayOf(x, y)\n    }\n\n    override fun paintComponent(g: Graphics) {\n        super.paintComponent(g)\n        val g2 = g as Graphics2D         \n        g2.translate(80, 60)\n        g2.stroke = BasicStroke(3.0f)\n        g2.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                            RenderingHints.VALUE_ANTIALIAS_ON) \n        drawPolygon(g2, subject, Color.blue)\n        drawPolygon(g2, clipper, Color.red)\n        drawPolygon(g2, result, Color.green)\n    }\n\n    private fun drawPolygon(g2: Graphics2D, points: List<DoubleArray>, color: Color) {\n        g2.color = color\n        val len = points.size\n        val line = Line2D.Double()\n        for (i in 0 until len) {\n            val p1 = points[i]\n            val p2 = points[(i + 1) % len]\n            line.setLine(p1[0], p1[1], p2[0], p2[1])\n            g2.draw(line)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater {\n        val f = JFrame()\n        with(f) {\n            defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n            add(SutherlandHodgman(), BorderLayout.CENTER)\n            title = \"Sutherland-Hodgman\"\n            pack()\n            setLocationRelativeTo(null)\n            isVisible = true\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Perl", "code": "\nTranslation of: Raku\nuse strict;\nuse warnings;\n\nsub intersection {\n    my($L11, $L12, $L21, $L22) = @_;\n    my ($d1x, $d1y) = ($$L11[0] - $$L12[0], $$L11[1] - $$L12[1]);\n    my ($d2x, $d2y) = ($$L21[0] - $$L22[0], $$L21[1] - $$L22[1]);\n    my $n1 = $$L11[0] * $$L12[1] - $$L11[1] * $$L12[0];\n    my $n2 = $$L21[0] * $$L22[1] - $$L21[1] * $$L22[0];\n    my $n3 = 1 / ($d1x * $d2y - $d2x * $d1y);\n    [($n1 * $d2x - $n2 * $d1x) * $n3, ($n1 * $d2y - $n2 * $d1y) * $n3]\n}\n\nsub is_inside {\n    my($p1, $p2, $p3) = @_;\n    ($$p2[0] - $$p1[0]) * ($$p3[1] - $$p1[1]) > ($$p2[1] - $$p1[1]) * ($$p3[0] - $$p1[0])\n}\n\nsub sutherland_hodgman {\n    my($polygon, $clip) = @_;\n    my @output = @$polygon;\n    my $clip_point1 = $$clip[-1];\n    for my $clip_point2 (@$clip) {\n        my @input = @output;\n        @output = ();\n        my $start = $input[-1];\n        for my $end (@input) {\n            if (is_inside($clip_point1, $clip_point2, $end)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end)\n                  unless is_inside($clip_point1, $clip_point2, $start);\n                push @output, $end;\n            } elsif (is_inside($clip_point1, $clip_point2, $start)) {\n                push @output, intersection($clip_point1, $clip_point2, $start, $end);\n            }\n            $start = $end;\n        }\n        $clip_point1 = $clip_point2;\n    }\n    @output\n}\n\nmy @polygon = ([50,  150], [200, 50],  [350, 150], [350, 300], [250, 300],\n              [200, 250], [150, 350], [100, 250], [100, 200]);\n\nmy @clip    = ([100, 100], [300, 100], [300, 300], [100, 300]);\n\nmy @clipped = sutherland_hodgman(\\@polygon, \\@clip);\n\nprint \"Clipped polygon:\\n\";\nprint '(' . join(' ', @$_) . ') ' for @clipped;\n\n\nOutput:\nClipped polygon:\n(100 116.666666666667) (125 100) (275 100) (300 116.666666666667) (300 300) (250 300) (200 250) (175 300) (125 300) (100 250)\n", "explain": ""}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Lua", "code": "\n\nTranslation of: Go\nsubjectPolygon = {\n  {50, 150}, {200, 50}, {350, 150}, {350, 300},\n  {250, 300}, {200, 250}, {150, 350}, {100, 250}, {100, 200}\n}\n \nclipPolygon = {{100, 100}, {300, 100}, {300, 300}, {100, 300}}\n\nfunction inside(p, cp1, cp2)\n  return (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x)\nend\n\nfunction intersection(cp1, cp2, s, e)\n  local dcx, dcy = cp1.x-cp2.x, cp1.y-cp2.y\n  local dpx, dpy = s.x-e.x, s.y-e.y\n  local n1 = cp1.x*cp2.y - cp1.y*cp2.x\n  local n2 = s.x*e.y - s.y*e.x\n  local n3 = 1 / (dcx*dpy - dcy*dpx)\n  local x = (n1*dpx - n2*dcx) * n3\n  local y = (n1*dpy - n2*dcy) * n3\n  return {x=x, y=y}\nend\n\nfunction clip(subjectPolygon, clipPolygon)\n  local outputList = subjectPolygon\n  local cp1 = clipPolygon[#clipPolygon]\n  for _, cp2 in ipairs(clipPolygon) do  -- WP clipEdge is cp1,cp2 here\n    local inputList = outputList\n    outputList = {}\n    local s = inputList[#inputList]\n    for _, e in ipairs(inputList) do\n      if inside(e, cp1, cp2) then\n        if not inside(s, cp1, cp2) then\n          outputList[#outputList+1] = intersection(cp1, cp2, s, e)\n        end\n        outputList[#outputList+1] = e\n      elseif inside(s, cp1, cp2) then\n        outputList[#outputList+1] = intersection(cp1, cp2, s, e)\n      end\n      s = e\n    end\n    cp1 = cp2\n  end\n  return outputList\nend\n\nfunction main()\n  local function mkpoints(t)\n    for i, p in ipairs(t) do\n      p.x, p.y = p[1], p[2]\n    end\n  end\n  mkpoints(subjectPolygon)\n  mkpoints(clipPolygon)\n\n  local outputList = clip(subjectPolygon, clipPolygon)\n\n  for _, p in ipairs(outputList) do\n    print(('{%f, %f},'):format(p.x, p.y))\n  end\nend\n\nmain()\n\n\nOutput:\n{100.000000, 116.666667},\n{125.000000, 100.000000},\n{275.000000, 100.000000},\n{300.000000, 116.666667},\n{300.000000, 300.000000},\n{250.000000, 300.000000},\n{200.000000, 250.000000},\n{175.000000, 300.000000},\n{125.000000, 300.000000},\n{100.000000, 250.000000},\n\n\n", "explain": "No extra credit.\n(You can also see it live)\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Scala", "code": "\n\nimport javax.swing.{ JFrame, JPanel }\n\nobject SutherlandHodgman extends JFrame with App {\n    import java.awt.BorderLayout\n\n    setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE)\n    setVisible(true)\n    val content = getContentPane()\n    content.setLayout(new BorderLayout())\n    content.add(SutherlandHodgmanPanel, BorderLayout.CENTER)\n    setTitle(\"SutherlandHodgman\")\n    pack()\n    setLocationRelativeTo(null)\n}\n\nobject SutherlandHodgmanPanel extends JPanel {\n    import java.awt.{ Color, Graphics, Graphics2D }\n\n    setPreferredSize(new java.awt.Dimension(600, 500))\n\n    // subject and clip points are assumed to be valid\n    val subject = Seq((50D, 150D), (200D, 50D), (350D, 150D), (350D, 300D), (250D, 300D), (200D, 250D), (150D, 350D), (100D, 250D), (100D, 200D))\n    val clipper = Seq((100D, 100D), (300D, 100D), (300D, 300D), (100D, 300D))\n    var result = subject\n\n    val len = clipper.size\n    for (i <- 0 until len) {\n        val len2 = result.size\n        val input = result\n        result = Seq()\n\n        val A = clipper((i + len - 1) % len)\n        val B = clipper(i)\n\n        for (j <- 0 until len2) {\n            val P = input((j + len2 - 1) % len2)\n            val Q = input(j)\n\n            if (inside(A, B, Q)) {\n                if (!inside(A, B, P))\n                    result = result :+ intersection(A, B, P, Q)\n                result = result :+ Q\n            }\n            else if (inside(A, B, P))\n                result = result :+ intersection(A, B, P, Q)\n        }\n    }\n\n    override def paintComponent(g: Graphics) {\n        import java.awt.RenderingHints._\n\n        super.paintComponent(g)\n        val g2 = g.asInstanceOf[Graphics2D]\n        g2.translate(80, 60)\n        g2.setStroke(new java.awt.BasicStroke(3))\n        g2.setRenderingHint(KEY_ANTIALIASING, VALUE_ANTIALIAS_ON)\n        g2.draw_polygon(subject, Color.blue)\n        g2.draw_polygon(clipper, Color.red)\n        g2.draw_polygon(result, Color.green)\n    }\n\n    private def inside(a: (Double, Double), b: (Double, Double), c: (Double, Double)) =\n        (a._1 - c._1) * (b._2 - c._2) > (a._2 - c._2) * (b._1 - c._1)\n\n    private def intersection(a: (Double, Double), b: (Double, Double), p: (Double, Double), q: (Double, Double)) = {\n        val A1 = b._2 - a._2\n        val B1 = a._1 - b._1\n        val C1 = A1 * a._1 + B1 * a._2\n        val A2 = q._2 - p._2\n        val B2 = p._1 - q._1\n        val C2 = A2 * p._1 + B2 * p._2\n\n        val det = A1 * B2 - A2 * B1\n        ((B2 * C1 - B1 * C2) / det, (A1 * C2 - A2 * C1) / det)\n    }\n\n    private implicit final class Polygon_drawing(g: Graphics2D) {\n        def draw_polygon(points: Seq[(Double, Double)], color: Color) {\n            g.setColor(color)\n            val len = points.length\n            val line = new java.awt.geom.Line2D.Double()\n            for (i <- 0 until len) {\n                val p1 = points(i)\n                val p2 = points((i + 1) % len)\n                line.setLine(p1._1, p1._2, p2._1, p2._2)\n                g.draw(line)\n            }\n        }\n    }\n}\n\n", "explain": "From Java snippet.\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "D", "code": "\nimport std.stdio, std.array, std.range, std.typecons, std.algorithm;\n\nstruct Vec2 { // To be replaced with Phobos code.\n    double x, y;\n\n    Vec2 opBinary(string op=\"-\")(in Vec2 other)\n    const pure nothrow @safe @nogc {\n        return Vec2(this.x - other.x, this.y - other.y);\n    }\n\n    typeof(x) cross(in Vec2 other) const pure nothrow @safe @nogc {\n        return this.x * other.y - this.y * other.x;\n    }\n}\n\nimmutable(Vec2)[] clip(in Vec2[] subjectPolygon, in Vec2[] clipPolygon)\npure /*nothrow*/ @safe in {\n    assert(subjectPolygon.length > 1);\n    assert(clipPolygon.length > 1);\n    // Probably clipPolygon needs to be convex and probably\n    // its vertices need to be listed in a direction.\n} out(result) {\n    assert(result.length > 1);\n} body {\n    alias Edge = Tuple!(Vec2,\"p\", Vec2,\"q\");\n\n    static enum isInside = (in Vec2 p, in Edge cle)\n    pure nothrow @safe @nogc =>\n        (cle.q.x - cle.p.x) * (p.y - cle.p.y) >\n        (cle.q.y - cle.p.y) * (p.x - cle.p.x);\n\n    static Vec2 intersection(in Edge se, in Edge cle)\n    pure nothrow @safe @nogc {\n        immutable dc = cle.p - cle.q;\n        immutable dp = se.p - se.q;\n        immutable n1 = cle.p.cross(cle.q);\n        immutable n2 = se.p.cross(se.q);\n        immutable n3 = 1.0 / dc.cross(dp);\n        return Vec2((n1 * dp.x - n2 * dc.x) * n3,\n                    (n1 * dp.y - n2 * dc.y) * n3);\n    }\n\n    // How much slower is this compared to lower-level code?\n    static enum edges = (in Vec2[] poly) pure nothrow @safe @nogc =>\n        // poly[$ - 1 .. $].chain(poly).zip!Edge(poly);\n        poly[$ - 1 .. $].chain(poly).zip(poly).map!Edge;\n\n    immutable(Vec2)[] result = subjectPolygon.idup; // Not nothrow.\n\n    foreach (immutable clipEdge; edges(clipPolygon)) {\n        immutable inputList = result;\n        result.destroy;\n        foreach (immutable inEdge; edges(inputList)) {\n            if (isInside(inEdge.q, clipEdge)) {\n                if (!isInside(inEdge.p, clipEdge))\n                    result ~= intersection(inEdge, clipEdge);\n                result ~= inEdge.q;\n            } else if (isInside(inEdge.p, clipEdge))\n                result ~= intersection(inEdge, clipEdge);\n        }\n    }\n\n    return result;\n}\n\n// Code adapted from the C version.\nvoid saveEPSImage(in string fileName, in Vec2[] subjPoly,\n                  in Vec2[] clipPoly, in Vec2[] clipped)\nin {\n    assert(!fileName.empty);\n    assert(subjPoly.length > 1);\n    assert(clipPoly.length > 1);\n    assert(clipped.length > 1);\n} body {\n    auto eps = File(fileName, \"w\");\n\n    // The image bounding box is hard-coded, not computed.\n    eps.writeln(\n\"%%!PS-Adobe-3.0\n%%%%BoundingBox: 40 40 360 360\n/l {lineto} def\n/m {moveto} def\n/s {setrgbcolor} def\n/c {closepath} def\n/gs {fill grestore stroke} def\n\");\n\n    eps.writef(\"0 setlinewidth %g %g m \", clipPoly[0].tupleof);\n    foreach (immutable cl; clipPoly[1 .. $])\n        eps.writef(\"%g %g l \", cl.tupleof);\n    eps.writefln(\"c 0.5 0 0 s gsave 1 0.7 0.7 s gs\");\n\n    eps.writef(\"%g %g m \", subjPoly[0].tupleof);\n    foreach (immutable s; subjPoly[1 .. $])\n        eps.writef(\"%g %g l \", s.tupleof);\n    eps.writefln(\"c 0 0.2 0.5 s gsave 0.4 0.7 1 s gs\");\n\n    eps.writef(\"2 setlinewidth [10 8] 0 setdash %g %g m \",\n               clipped[0].tupleof);\n    foreach (immutable c; clipped[1 .. $])\n        eps.writef(\"%g %g l \", c.tupleof);\n    eps.writefln(\"c 0.5 0 0.5 s gsave 0.7 0.3 0.8 s gs\");\n\n    eps.writefln(\"%%%%EOF\");\n    eps.close;\n    writeln(fileName, \" written.\");\n}\n\nvoid main() {\n    alias V = Vec2;\n    immutable subjectPolygon = [V(50, 150), V(200, 50), V(350, 150),\n                                V(350, 300), V(250, 300), V(200, 250),\n                                V(150, 350), V(100, 250), V(100, 200)];\n    immutable clippingPolygon = [V(100, 100), V(300, 100),\n                                 V(300, 300), V(100, 300)];\n    immutable clipped = subjectPolygon.clip(clippingPolygon);\n    writefln(\"%(%s\\n%)\", clipped);\n    saveEPSImage(\"sutherland_hodgman_clipping_out.eps\",\n                 subjectPolygon, clippingPolygon, clipped);\n}\n\n\nOutput:\nimmutable(Vec2)(100, 116.667)\nimmutable(Vec2)(125, 100)\nimmutable(Vec2)(275, 100)\nimmutable(Vec2)(300, 116.667)\nimmutable(Vec2)(300, 300)\nimmutable(Vec2)(250, 300)\nimmutable(Vec2)(200, 250)\nimmutable(Vec2)(175, 300)\nimmutable(Vec2)(125, 300)\nimmutable(Vec2)(100, 250)\nsutherland_hodgman_clipping_out.eps written.\n\n", "explain": "It also outputs an EPS file, the same as the C entry.\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Haskell", "code": "\nmodule SuthHodgClip (clipTo) where\n\nimport Data.List\n\ntype   Pt a = (a, a)\ntype   Ln a = (Pt a, Pt a)\ntype Poly a = [Pt a]\n\n-- Return a polygon from a list of points.\npolyFrom ps = last ps : ps\n\n-- Return a list of lines from a list of points.\nlinesFrom pps@(_:ps) = zip pps ps\n\n-- Return true if the point (x,y) is on or to the left of the oriented line\n-- defined by (px,py) and (qx,qy).\n(.|) :: (Num a, Ord a) => Pt a -> Ln a -> Bool\n(x,y) .| ((px,py),(qx,qy)) = (qx-px)*(y-py) >= (qy-py)*(x-px)\n\n-- Return the intersection of two lines.\n(><) :: Fractional a => Ln a -> Ln a -> Pt a\n((x1,y1),(x2,y2)) >< ((x3,y3),(x4,y4)) =\n    let (r,s) = (x1*y2-y1*x2, x3*y4-y3*x4)\n        (t,u,v,w) = (x1-x2, y3-y4, y1-y2, x3-x4)\n        d = t*u-v*w \n    in ((r*w-t*s)/d, (r*u-v*s)/d)\n\n-- Intersect the line segment (p0,p1) with the clipping line's left halfspace,\n-- returning the point closest to p1.  In the special case where p0 lies outside\n-- the halfspace and p1 lies inside we return both the intersection point and\n-- p1.  This ensures we will have the necessary segment along the clipping line.\n(-|) :: (Fractional a, Ord a) => Ln a -> Ln a -> [Pt a]\nln@(p0, p1) -| clipLn =\n    case (p0 .| clipLn, p1 .| clipLn) of\n      (False, False) -> []\n      (False, True)  -> [isect, p1]\n      (True,  False) -> [isect]\n      (True,  True)  -> [p1]\n    where isect = ln >< clipLn\n\n-- Intersect the polygon with the clipping line's left halfspace.\n(<|) :: (Fractional a, Ord a) => Poly a -> Ln a -> Poly a\npoly <| clipLn = polyFrom $ concatMap (-| clipLn) (linesFrom poly)\n\n-- Intersect a target polygon with a clipping polygon.  The latter is assumed to\n-- be convex.\nclipTo :: (Fractional a, Ord a) => [Pt a] -> [Pt a] -> [Pt a]\ntargPts `clipTo` clipPts = \n    let targPoly = polyFrom targPts\n        clipLines = linesFrom (polyFrom clipPts)\n    in foldl' (<|) targPoly clipLines\n\n\nimport Graphics.HGL\nimport SuthHodgClip\n\ntargPts = [( 50,150), (200, 50), (350,150), (350,300), (250,300), \n           (200,250), (150,350), (100,250), (100,200)] :: [(Float,Float)]\nclipPts = [(100,100), (300,100), (300,300), (100,300)] :: [(Float,Float)]\n\ntoInts = map (\\(a,b) -> (round a, round b))\ncomplete xs = last xs : xs\n\ndrawSolid w c = drawInWindow w . withRGB c . polygon\ndrawLines w p = drawInWindow w . withPen p . polyline . toInts . complete\n\nblue  = RGB 0x99 0x99 0xff\ngreen = RGB 0x99 0xff 0x99\npink  = RGB 0xff 0x99 0x99\nwhite = RGB 0xff 0xff 0xff\n\nmain = do\n  let resPts = targPts `clipTo` clipPts\n      sz = 400\n      win = [(0,0), (sz,0), (sz,sz), (0,sz)]\n  runWindow \"Sutherland-Hodgman Polygon Clipping\" (sz,sz) $ \\w -> do\n         print $ toInts resPts\n         penB <- createPen Solid 3 blue\n         penP <- createPen Solid 5 pink\n         drawSolid w white win\n         drawLines w penB targPts\n         drawLines w penP clipPts\n         drawSolid w green $ toInts resPts\n         getKey w\n\n\nOutput:\n[(100,200),(100,200),(100,117),(125,100),(275,100),(300,117),(300,300),(250,300),(200,250),(175,300),(125,300),(100,250),(100,200)]\n\n\n", "explain": "Print the resulting list of points and display the polygons in a window.\n\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "Scheme", "code": "\nTranslation of: ATS\nWorks with: Guile version at least 2.0\nWorks with: Gauche Scheme version 0.9.12\nWorks with: CHICKEN Scheme version 5.3.0\nWorks with: Gambit Scheme version 4.9.4\n;;; Sutherland-Hodgman polygon clipping.\n\n(define (evaluate-line x1 y1 x2 y2 x)\n  ;; Given the straight line between (x1,y1) and (x2,y2), evaluate it\n  ;; at x.\n  (let ((dy (- y2 y1))\n        (dx (- x2 x1)))\n    (let ((slope (/ dy dx))\n          (intercept (/ (- (* dx y1) (* dy x1)) dx)))\n      (+ (* slope x) intercept))))\n\n(define (intersection-of-lines x1 y1 x2 y2 x3 y3 x4 y4)\n  ;; Given the line between (x1,y1) and (x2,y2), and the line between\n  ;; (x3,y3) and (x4,y4), find their intersection.\n  (cond ((= x1 x2) (list x1 (evaluate-line x3 y3 x4 y4 x1)))\n        ((= x3 x4) (list x3 (evaluate-line x1 y1 x2 y2 x3)))\n        (else (let ((denominator (- (* (- x1 x2) (- y3 y4))\n                                    (* (- y1 y2) (- x3 x4))))\n                    (x1*y2-y1*x2 (- (* x1 y2) (* y1 x2)))\n                    (x3*y4-y3*x4 (- (* x3 y4) (* y3 x4))))\n                (let ((xnumerator (- (* x1*y2-y1*x2 (- x3 x4))\n                                     (* (- x1 x2) x3*y4-y3*x4)))\n                      (ynumerator (- (* x1*y2-y1*x2 (- y3 y4))\n                                     (* (- y1 y2) x3*y4-y3*x4))))\n                  (list (/ xnumerator denominator)\n                        (/ ynumerator denominator)))))))\n\n(define (intersection-of-edges e1 e2)\n  ;;\n  ;; A point is a list of two coordinates, and an edge is a list of\n  ;; two points.\n  ;;\n  ;; I am not using any SRFI-9 records, or the like, that define\n  ;; actual new types, although I would do so if writing a more\n  ;; serious implementation. Also, I am not using any pattern matcher.\n  ;; A pattern matcher would make this code less tedious with\n  ;; \"cadaddaddr\" notations.\n  (let ((point1 (car e1))\n        (point2 (cadr e1))\n        (point3 (car e2))\n        (point4 (cadr e2)))\n    (let ((x1 (car point1))\n          (y1 (cadr point1))\n          (x2 (car point2))\n          (y2 (cadr point2))\n          (x3 (car point3))\n          (y3 (cadr point3))\n          (x4 (car point4))\n          (y4 (cadr point4)))\n      (intersection-of-lines x1 y1 x2 y2 x3 y3 x4 y4))))\n\n(define (point-is-left-of-edge? pt edge)\n  (let ((x (car pt))\n        (y (cadr pt))\n        (x1 (caar edge))\n        (y1 (cadar edge))\n        (x2 (caadr edge))\n        (y2 (cadadr edge)))\n    ;; Outer product of the vectors (x1,y1)-->(x,y) and\n    ;; (x1,y1)-->(x2,y2)\n    (negative? (- (* (- x x1) (- y2 y1))\n                  (* (- x2 x1) (- y y1))))))\n\n(define (clip-subject-edge subject-edge clip-edge accum)\n  (define left-of? point-is-left-of-edge?)\n  (define (intersection)\n    (intersection-of-edges subject-edge clip-edge))\n  (let ((s1 (car subject-edge))\n        (s2 (cadr subject-edge)))\n    (let ((s2-is-inside? (left-of? s2 clip-edge))\n          (s1-is-inside? (left-of? s1 clip-edge)))\n      (if s2-is-inside?\n          (if s1-is-inside?\n              (cons s2 accum)\n              (cons s2 (cons (intersection) accum)))\n          (if s1-is-inside?\n              (cons (intersection) accum)\n              accum)))))\n\n(define (for-each-subject-edge i subject-points clip-edge accum)\n  (define n (vector-length subject-points))\n  (if (= i n)\n      (list->vector (reverse accum))\n      (let ((s2 (vector-ref subject-points i))\n            (s1 (vector-ref subject-points\n                            (- (if (zero? i) n i) 1))))\n        (let ((accum (clip-subject-edge (list s1 s2)\n                                        clip-edge accum)))\n          (for-each-subject-edge (+ i 1) subject-points\n                                 clip-edge accum)))))\n\n(define (for-each-clip-edge i subject-points clip-points)\n  (define n (vector-length clip-points))\n  (if (= i n)\n      subject-points\n      (let ((c2 (vector-ref clip-points i))\n            (c1 (vector-ref clip-points (- (if (zero? i) n i) 1))))\n        (let ((subject-points\n               (for-each-subject-edge 0 subject-points\n                                      (list c1 c2) '())))\n          (for-each-clip-edge (+ i 1) subject-points clip-points)))))\n\n(define (clip subject-points clip-points)\n  (for-each-clip-edge 0 subject-points clip-points))\n\n(define (write-eps subject-points clip-points result-points)\n\n  ;; I use only some of the most basic output procedures. Schemes tend\n  ;; to include more advanced means to write output, often resembling\n  ;; those of Common Lisp.\n\n  (define (x pt) (exact->inexact (car pt)))\n  (define (y pt) (exact->inexact (cadr pt)))\n\n  (define (moveto pt)\n    (display (x pt))\n    (display \" \")\n    (display (y pt))\n    (display \" moveto\")\n    (newline))\n\n  (define (lineto pt)\n    (display (x pt))\n    (display \" \")\n    (display (y pt))\n    (display \" lineto\")\n    (newline))\n\n  (define (setrgbcolor rgb)\n    (display rgb)\n    (display \" setrgbcolor\")\n    (newline))\n\n  (define (simple-word word)\n    (lambda ()\n      (display word)\n      (newline)))\n\n  (define closepath (simple-word \"closepath\"))\n  (define fill (simple-word \"fill\"))\n  (define stroke (simple-word \"stroke\"))\n  (define gsave (simple-word \"gsave\"))\n  (define grestore (simple-word \"grestore\"))\n\n  (define (showpoly poly line-color fill-color)\n    (define n (vector-length poly))\n    (moveto (vector-ref poly 0))\n    (do ((i 1 (+ i 1)))\n        ((= i n))\n      (lineto (vector-ref poly i)))\n    (closepath)\n    (setrgbcolor line-color)\n    (gsave)\n    (setrgbcolor fill-color)\n    (fill)\n    (grestore)\n    (stroke))\n\n  (define (code s)\n    (display s)\n    (newline))\n\n  (code \"%!PS-Adobe-3.0 EPSF-3.0\")\n  (code \"%%BoundingBox: 40 40 360 360\")\n  (code \"0 setlinewidth\")\n  (showpoly clip-points \".5 0 0\" \"1 .7 .7\")\n  (showpoly subject-points \"0 .2 .5\" \".4 .7 1\")\n  (code \"2 setlinewidth\")\n  (code \"[10 8] 0 setdash\")\n  (showpoly result-points \".5 0 .5\" \".7 .3 .8\")\n  (code \"%%EOF\"))\n\n(define (write-eps-to-file outfile subject-points clip-points\n                           result-points)\n  (with-output-to-file outfile\n    (lambda ()\n      (write-eps subject-points clip-points result-points))))\n\n(define subject-points\n  #((50 150)\n    (200 50)\n    (350 150)\n    (350 300)\n    (250 300)\n    (200 250)\n    (150 350)\n    (100 250)\n    (100 200)))\n\n(define clip-points\n  #((100 100)\n    (300 100)\n    (300 300)\n    (100 300)))\n\n(define result-points (clip subject-points clip-points))\n\n(display result-points)\n(newline)\n(write-eps-to-file \"sutherland-hodgman.eps\"\n                   subject-points clip-points result-points)\n(display \"Wrote sutherland-hodgman.eps\")\n(newline)\n\n\nOutput:\n#((100 350/3) (125 100) (275 100) (300 350/3) (300 300) (250 300) (200 250) (175 300) (125 300) (100 250))\nWrote sutherland-hodgman.eps\n\n", "explain": "\n"}, {"task_name": "Sutherland-Hodgman polygon clipping", "task_url": "https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping", "task_cat": "Graphics algorithms", "lang": "TypeScript", "code": "\ninterface XYCoords  {\n    x\u00a0: number;\n    y\u00a0: number;\n}\n\nconst inside = ( cp1\u00a0: XYCoords, cp2\u00a0: XYCoords, p\u00a0: XYCoords) : boolean => {\n    return (cp2.x-cp1.x)*(p.y-cp1.y) > (cp2.y-cp1.y)*(p.x-cp1.x);\n};\n\nconst intersection = ( cp1\u00a0: XYCoords ,cp2\u00a0: XYCoords ,s\u00a0: XYCoords, e\u00a0: XYCoords ) : XYCoords => {\n    const dc = {\n\tx:  cp1.x - cp2.x,\n\ty\u00a0: cp1.y - cp2.y\n\t },\n    dp = { x: s.x - e.x,\n\t   y\u00a0: s.y - e.y\n\t },\n    n1 = cp1.x * cp2.y - cp1.y * cp2.x,\n    n2 = s.x * e.y - s.y * e.x, \n    n3 = 1.0 / (dc.x * dp.y - dc.y * dp.x);\n    return { x : (n1*dp.x - n2*dc.x) * n3,\n\t     y : (n1*dp.y - n2*dc.y) * n3\n\t   };\n};\n\nexport const sutherland_hodgman = ( subjectPolygon\u00a0: Array<XYCoords>,\n\t\t\t\t   clipPolygon\u00a0: Array<XYCoords> ) : Array<XYCoords> => {\n    \n    let cp1\u00a0: XYCoords = clipPolygon[clipPolygon.length-1];\n    let cp2\u00a0: XYCoords;\n    let s\u00a0: XYCoords;\n    let e\u00a0: XYCoords;\n    \n    let outputList\u00a0: Array<XYCoords> = subjectPolygon;\n    \n    for( var j in clipPolygon ) {\n        cp2 = clipPolygon[j];\n        var inputList = outputList;\n        outputList = [];\n        s = inputList[inputList.length - 1]; // last on the input list\n        for (var i in inputList) {\n\t    e = inputList[i];\n\t    if (inside(cp1,cp2,e)) {\n                if (!inside(cp1,cp2,s)) {\n\t\t    outputList.push(intersection(cp1,cp2,s,e));\n                }\n                outputList.push(e);\n\t    }\n\t    else if (inside(cp1,cp2,s)) {\n                outputList.push(intersection(cp1,cp2,s,e));\n\t    }\n\t    s = e;\n        }\n        cp1 = cp2;\n    }\n    return outputList\n}\n\n\n", "explain": "\n"}]