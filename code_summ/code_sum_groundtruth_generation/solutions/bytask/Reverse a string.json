[{"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Python", "code": "\nOptimized for user input[edit]\ninput()[::-1]\nAlready known string[edit]\nstring[::-1]\n\n''.join(reversed(string))\nPython: Unicode reversal[edit]\n\nimport unicodedata\n\ndef ureverse(ustring):\n    'Reverse a string including unicode combining characters'\n    groupedchars = []\n    uchar = list(ustring)\n    while uchar:\n        if unicodedata.combining(uchar[0])\u00a0!= 0:\n            groupedchars[-1] += uchar.pop(0)\n        else:\n            groupedchars.append(uchar.pop(0))\n    # Grouped reversal\n    groupedchars = groupedchars[::-1]\n \n    return ''.join(groupedchars)\n\ndef say_string(s):\n    return ' '.join([s, '=', ' | '.join(unicodedata.name(ch, '') for ch in s)])\n\ndef say_rev(s):\n    print(f\"Input:              {say_string(s)}\")\n    print(f\"Character reversed: {say_string(s[::-1])}\")\n    print(f\"Unicode reversed:   {say_string(ureverse(s))}\")\n    print(f\"Unicode reverse\u00b2:   {say_string(ureverse(ureverse(s)))}\")\n        \nif __name__ == '__main__':\n    ucode = ''.join(chr(int(n[2:], 16)) for n in \n                     'U+0041 U+030A U+0073 U+0074 U+0072 U+006F U+0308 U+006D'.split())\n    say_rev(ucode)\n\nOutput:\nInput:              \u00c5str\u00f6m = LATIN CAPITAL LETTER A | COMBINING RING ABOVE | LATIN SMALL LETTER S | LATIN SMALL LETTER T | LATIN SMALL LETTER R | LATIN SMALL LETTER O | COMBINING DIAERESIS | LATIN SMALL LETTER M\nCharacter reversed: m\u0308orts\u030aA = LATIN SMALL LETTER M | COMBINING DIAERESIS | LATIN SMALL LETTER O | LATIN SMALL LETTER R | LATIN SMALL LETTER T | LATIN SMALL LETTER S | COMBINING RING ABOVE | LATIN CAPITAL LETTER A\nUnicode reversed:   m\u00f6rts\u00c5 = LATIN SMALL LETTER M | LATIN SMALL LETTER O | COMBINING DIAERESIS | LATIN SMALL LETTER R | LATIN SMALL LETTER T | LATIN SMALL LETTER S | LATIN CAPITAL LETTER A | COMBINING RING ABOVE\nUnicode reverse\u00b2:   \u00c5str\u00f6m = LATIN CAPITAL LETTER A | COMBINING RING ABOVE | LATIN SMALL LETTER S | LATIN SMALL LETTER T | LATIN SMALL LETTER R | LATIN SMALL LETTER O | COMBINING DIAERESIS | LATIN SMALL LETTER M\n\n\nucode = ''.join(chr(int(n[2:], 16)) for n in \n                 'U+006B U+0301 U+0075 U+032D U+006F U+0304 U+0301 U+006E'.split())\nsay_rev(ucode)\n\n\nOutput:\nInput:              \u1e31\u1e77\u1e53n = LATIN SMALL LETTER K | COMBINING ACUTE ACCENT | LATIN SMALL LETTER U | COMBINING CIRCUMFLEX ACCENT BELOW | LATIN SMALL LETTER O | COMBINING MACRON | COMBINING ACUTE ACCENT | LATIN SMALL LETTER N\nCharacter reversed: \u0144\u0304o\u032d\u00fak = LATIN SMALL LETTER N | COMBINING ACUTE ACCENT | COMBINING MACRON | LATIN SMALL LETTER O | COMBINING CIRCUMFLEX ACCENT BELOW | LATIN SMALL LETTER U | COMBINING ACUTE ACCENT | LATIN SMALL LETTER K\nUnicode reversed:   n\u1e53\u1e77\u1e31 = LATIN SMALL LETTER N | LATIN SMALL LETTER O | COMBINING MACRON | COMBINING ACUTE ACCENT | LATIN SMALL LETTER U | COMBINING CIRCUMFLEX ACCENT BELOW | LATIN SMALL LETTER K | COMBINING ACUTE ACCENT\nUnicode reverse\u00b2:   \u1e31\u1e77\u1e53n = LATIN SMALL LETTER K | COMBINING ACUTE ACCENT | LATIN SMALL LETTER U | COMBINING CIRCUMFLEX ACCENT BELOW | LATIN SMALL LETTER O | COMBINING MACRON | COMBINING ACUTE ACCENT | LATIN SMALL LETTER N\n\nucode = ''.join(chr(int(n, 16))\n                 for n in ['61', '73', '20dd', '64', '66', '305'])\nsay_rev(ucode)\n\n\nOutput:\nInput:              as\u20dddf\u0305 = LATIN SMALL LETTER A | LATIN SMALL LETTER S | COMBINING ENCLOSING CIRCLE | LATIN SMALL LETTER D | LATIN SMALL LETTER F | COMBINING OVERLINE\nCharacter reversed: \u0305fd\u20ddsa = COMBINING OVERLINE | LATIN SMALL LETTER F | LATIN SMALL LETTER D | COMBINING ENCLOSING CIRCLE | LATIN SMALL LETTER S | LATIN SMALL LETTER A\nUnicode reversed:   f\u0305d\u20ddsa = LATIN SMALL LETTER F | COMBINING OVERLINE | LATIN SMALL LETTER D | COMBINING ENCLOSING CIRCLE | LATIN SMALL LETTER S | LATIN SMALL LETTER A\nUnicode reverse\u00b2:   as\u20dddf\u0305 = LATIN SMALL LETTER A | LATIN SMALL LETTER S | COMBINING ENCLOSING CIRCLE | LATIN SMALL LETTER D | LATIN SMALL LETTER F | COMBINING OVERLINE\n", "explain": "or\n(See this article for more information from which this is improved)\nNote: How this looks may be subject to how the tool you are using to view this page can render Unicode. \nIf this code is then used:\nIt produces this output\n\nThis uses the unicode string mentioned in the task:\nIt produces this output\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n#include <wchar.h>\n\nconst char *sa = \"abcdef\";\nconst char *su = \"as\u20dddf\u0305\"; /* Should be in your native locale encoding. Mine is UTF-8 */\n\nint is_comb(wchar_t c)\n{\n\tif (c >= 0x300 && c <= 0x36f) return 1;\n\tif (c >= 0x1dc0 && c <= 0x1dff) return 1;\n\tif (c >= 0x20d0 && c <= 0x20ff) return 1;\n\tif (c >= 0xfe20 && c <= 0xfe2f) return 1;\n\treturn 0;\n}\n\nwchar_t* mb_to_wchar(const char *s)\n{\n\twchar_t *u;\n\tsize_t len = mbstowcs(0, s, 0) + 1;\n\tif (!len) return 0;\n\n\tu = malloc(sizeof(wchar_t) * len);\n\tmbstowcs(u, s, len);\n\treturn u;\n}\n\nwchar_t* ws_reverse(const wchar_t* u)\n{\n\tsize_t len, i, j;\n\twchar_t *out;\n\tfor (len = 0; u[len]; len++);\n\tout = malloc(sizeof(wchar_t) * (len + 1));\n\tout[len] = 0;\n\tj = 0;\n\twhile (len) {\n\t\tfor (i = len - 1; i && is_comb(u[i]); i--);\n\t\twcsncpy(out + j, u + i, len - i);\n\t\tj += len - i;\n\t\tlen = i;\n\t}\n\treturn out;\n}\n\nchar *mb_reverse(const char *in)\n{\n\tsize_t len;\n\tchar *out;\n\twchar_t *u = mb_to_wchar(in);\n\twchar_t *r = ws_reverse(u);\n\tlen = wcstombs(0, r, 0) + 1;\n\tout = malloc(len);\n\twcstombs(out, r, len);\n\tfree(u);\n\tfree(r);\n\treturn out;\n}\n\nint main(void)\n{\n\tsetlocale(LC_CTYPE, \"\");\n\n\tprintf(\"%s => %s\\n\", sa, mb_reverse(sa));\n\tprintf(\"%s => %s\\n\", su, mb_reverse(su));\n\treturn 0;\n}\n\n\nOutput:\nabcdef => fedcba\nas\u20dddf\u0305 => f\u0305ds\u20dda\nLibrary: GLib\n#include <glib.h>\ngchar *srev (const gchar *s) {\n    if (g_utf8_validate(s,-1,NULL)) {\n        return g_utf8_strreverse (s,-1);\n}   }\n// main\nint main (void) {\n    const gchar *t=\"asdf\";\n    const gchar *u=\"as\u20dddf\u0305\";\n    printf (\"%s\\n\",srev(t));\n    printf (\"%s\\n\",srev(u));\n    return 0;\n}\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nint main() {\n  std::string s;\n  std::getline(std::cin, s);\n  std::reverse(s.begin(), s.end()); // modifies s\n  std::cout << s << '\\n';\n}\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Java", "code": "\nReverse Unicode Codepoints[edit]\n\nString reversed = new StringBuilder(\"as\u20dddf\u0305\").reverse().toString(); // fd\u20ddsa\nString reversed = new StringBuffer(\"as\u20dddf\u0305\").reverse().toString(); // fd\u20ddsa\n\nString string = \"as\u20dddf\u0305\";\nStringBuilder reversed = new StringBuilder();\nfor (int index = string.length() - 1; index >= 0; index--)\n    reversed.append(string.charAt(index));\nreversed; // fd\u20ddsa\nReverse Unicode Graphemes[edit]\n\nimport java.text.BreakIterator;\n\npublic class Reverse {\n  /* works with Java 20+ only\n   * cf. https://bugs.openjdk.org/browse/JDK-8291660\n   */\n  public static StringBuilder graphemeReverse(String text) {\n    BreakIterator boundary = BreakIterator.getCharacterInstance();\n    boundary.setText(text);\n    StringBuilder reversed = new StringBuilder();\n    int end = boundary.last();\n    int start = boundary.previous();\n    while (start\u00a0!= BreakIterator.DONE) {\n      reversed.append(text.substring(start, end));\n      end = start;\n      start = boundary.previous();\n    }\n    return reversed;\n  }\n  public static void main(String[] args) throws Exception {\n    String a = \"as\u20dddf\u0305\";\n    System.out.println(graphemeReverse(a)); // f\u0305ds\u20dda\n  }\n}\n", "explain": "Reversing codepoints works in most cases when reversing single characters wherever they are encoded on multi-bytes or not. But this doesn't work for composed characters.\nAlternately, you could use a for-loop with the same issue.\nA third-party solution is to use ICU4J.\nA native solution, since JDK 15, is to use Pattern.compile( \"\\\\X\" ) from java.util.regex to parse grapemes.\nAnother native solution, since JDK 20, is to use java.text.BreakIterator class that now parse graphemes correctly[1].\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "C#", "code": "\n\nstatic string ReverseString(string input)\n{\n    char[] inputChars = input.ToCharArray();\n    Array.Reverse(inputChars);\n    return new string(inputChars);\n}\n\n\nusing System.Linq;\n\n// ...\n\nreturn new string(input.Reverse().ToArray());\n\n// ...\n\n\npublic string ReverseElements(string s)\n{\n    // In .NET, a text element is series of code units that is displayed as one character, and so reversing the text\n    // elements of the string correctly handles combining character sequences and surrogate pairs.\n    var elements = System.Globalization.StringInfo.GetTextElementEnumerator(s);\n    return string.Concat(AsEnumerable(elements).OfType<string>().Reverse());\n}\n\n// Wraps an IEnumerator, allowing it to be used as an IEnumerable.\npublic IEnumerable AsEnumerable(IEnumerator enumerator)\n{\n    while (enumerator.MoveNext())\n        yield return enumerator.Current;\n}\n\n", "explain": "C# does not have a built-in Reverse method for strings, and cannot reverse them in place because they are immutable. One way to implement this is to convert the string to an array of characters, reverse that, and return a new string from the reversed array:\nAs of .Net 3.5 the LINQ-to-objects allows the Reverse() extension method to be called on a string, since String implements the IEnumerable<char> interface. Because of this, the return type of Reverse is IEnumerable<char>. Fortunately, LINQ also provides the ToArray extension method, which can be used in conjunction with the constructor of string that accepts a char array:\nVersion supporting combining characters:\nSystem.Globalization.StringInfo provides a means of separating a string into individual graphemes.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nUnicode[edit]\nSplit code points[edit]\n\nexample = 'Tux \ud83d\udc27 penguin';\n\n// array expansion operator\n[...example].reverse().join('') // 'niugnep \ud83d\udc27 xuT'\n// split regexp separator with Unicode mode\nexample.split(/(?:)/u).reverse().join('') // 'niugnep \ud83d\udc27 xuT'\n\n// do not use\nexample.split('').reverse().join(''); // 'niugnep \\udc27\\ud83d xuT'\nSplit graphemes =[edit]\n\na = \"\\u{1F466}\\u{1F3FB}\\u{1f44b}\"; // '\ud83d\udc66\ud83c\udffb\ud83d\udc4b'\n\n// wrong behavior - ASCII sequences\na.split('').reverse().join(''); // '\\udc4b\ud83c\udc66\\ud83d'\n\n// wrong behavior - Unicode code points\n[...a].reverse().join(''); // '\ud83d\udc4b\ud83c\udffb\ud83d\udc66'\na.split(/(?:)/u).reverse().join(''); // '\ud83d\udc4b\ud83c\udffb\ud83d\udc66'\n\n// correct behavior - Unicode graphemes\n[...new Intl.Segmenter().segment(a)].map(x => x.segment).reverse().join('') // \ud83d\udc4b\ud83d\udc66\ud83c\udffb\nASCII[edit]\nES5[edit]\n//using chained methods\nfunction reverseStr(s) {\n  return s.split('').reverse().join('');\n}\n\n//fast method using for loop\nfunction reverseStr(s) {\n  for (var i = s.length - 1, o = ''; i >= 0; o += s[i--]) { }\n  return o;\n}\n\n//fast method using while loop (faster with long strings in some browsers when compared with for loop)\nfunction reverseStr(s) {\n  var i = s.length, o = '';\n  while (i--) o += s[i];\n  return o;\n}\nES6[edit]\n(() => {\n\n    // .reduceRight() can be useful when reversals\n    // are composed with some other process\n\n    let reverse1 = s => Array.from(s)\n        .reduceRight((a, x) => a + (x\u00a0!== ' '\u00a0? x\u00a0: ' <- '), ''),\n\n        // but ( join . reverse . split ) is faster for\n        // simple string reversals in isolation\n\n        reverse2 = s => s.split('').reverse().join('');\n\n\n    return [reverse1, reverse2]\n        .map(f => f(\"Some string to be reversed\"));\n\n})();\n\nOutput:\n[\"desrever <- eb <- ot <- gnirts <- emoS\", \"desrever eb ot gnirts emoS\"]\n", "explain": "split('') (with empty string argument) works only for ASCII. For Unicode strings, one of the two following methods can be used.\nMore generally, one would want to combine characters such as joining emojis or diacritics to be handled properly so enumerating over graphemes is a must.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Visual_Basic_.NET", "code": "\n\n#Const REDIRECTOUT = True\n\nModule Program\n    Const OUTPATH = \"out.txt\"\n\n    ReadOnly TestCases As String() = {\"asdf\", \"as\u20dddf\u0305\", \"Les Mis\u00e9rables\"}\n\n    ' SIMPLE VERSION\n    Function Reverse(s As String) As String\n        Dim t = s.ToCharArray()\n        Array.Reverse(t)\n        Return New String(t)\n    End Function\n\n    ' EXTRA CREDIT VERSION\n    Function ReverseElements(s As String) As String\n        ' In .NET, a text element is series of code units that is displayed as one character, and so reversing the text\n        ' elements of the string correctly handles combining character sequences and surrogate pairs.\n        Dim elements = Globalization.StringInfo.GetTextElementEnumerator(s)\n        Return String.Concat(AsEnumerable(elements).OfType(Of String).Reverse())\n    End Function\n\n    ' Wraps an IEnumerator, allowing it to be used as an IEnumerable.\n    Iterator Function AsEnumerable(enumerator As IEnumerator) As IEnumerable\n        Do While enumerator.MoveNext()\n            Yield enumerator.Current\n        Loop\n    End Function\n\n    Sub Main()\n        Const INDENT = \"    \"\n\n#If REDIRECTOUT Then\n        Const OUTPATH = \"out.txt\"\n        Using s = IO.File.Open(OUTPATH, IO.FileMode.Create),\n              sw As New IO.StreamWriter(s)\n            Console.SetOut(sw)\n#Else\n        Try\n            Console.OutputEncoding = Text.Encoding.ASCII\n            Console.OutputEncoding = Text.Encoding.UTF8\n            Console.OutputEncoding = Text.Encoding.Unicode\n        Catch ex As Exception\n            Console.WriteLine(\"Failed to set console encoding to Unicode.\" & vbLf)\n        End Try\n#End If\n            For Each c In TestCases\n                Console.WriteLine(c)\n                Console.WriteLine(INDENT & \"SIMPLE:   \" & Reverse(c))\n                Console.WriteLine(INDENT & \"ELEMENTS: \" & ReverseElements(c))\n                Console.WriteLine()\n            Next\n#If REDIRECTOUT Then\n        End Using\n#End If\n    End Sub\nEnd Module\n\nOutput (copied from Notepad):\n\nasdf\n    SIMPLE:   fdsa\n    ELEMENTS: fdsa\n\nas\u20dddf\u0305\n    SIMPLE:   \u0305fd\u20ddsa\n    ELEMENTS: f\u0305ds\u20dda\n\nLes Mis\u00e9rables\n    SIMPLE:   selba\u0155esiM seL\n    ELEMENTS: selbar\u00e9siM seL\n", "explain": "Compiler: >= Visual Basic 2012\nIncludes both a simple version and a version that uses .NET's built-in ability to enumerate strings by grapheme to support combining characters.\nSince the windows console may not support Unicode, the program can optionally redirect its output to a file.\nOutput is presented using non-fixed-width typeface to properly display combining characters.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "PHP", "code": "\nUnicode[edit]\nCode points[edit]\n\n// Will split every Unicode character to array, reverse array and will convert it to string.\njoin('', array_reverse(preg_split('\"\"u', $string, -1, PREG_SPLIT_NO_EMPTY)));\n\nimplode('', array_reverse(mb_str_split($string)));\nGraphemes[edit]\n\n$a = mb_convert_encoding('&#x1F466;&#x1F3FB;&#x1f44b;', 'UTF-8', 'HTML-ENTITIES'); // \ud83d\udc66\ud83c\udffb\ud83d\udc4b\n\nfunction str_to_array($string)\n{\n  $length = grapheme_strlen($string);\n  $ret = [];\n\n  for ($i = 0; $i < $length; $i += 1) {\n\n    $ret[] = grapheme_substr($string, $i, 1);\n  }\n\n  return $ret;\n}\n\nfunction utf8_strrev($string)\n{\n  return implode(array_reverse(str_to_array($string)));\n}\n\nprint_r(utf8_strrev($a)); // \ud83d\udc4b\ud83d\udc66\ud83c\udffb\nASCII[edit]\nstrrev($string);\n", "explain": "If you want Unicode support, you have to use some multibyte function. Sadly, PHP doesn't contain mb_strrev(). One of functions which support Unicode and is useful in this case is preg_split().\nWith PHP 7.4+ and 8+, it's also possible to use mb_str_split(), which may ends easier.\nWhen using combining characters such as diacritics or ZWJ (joining), reversing code points will mess with the result, reversing the graphemes instead is mandatory. This is generally the best and safest approach. As there is no grapheme_reverse() function or grapheme iterator, one has to implement it with grapheme_strlen and grapheme_substr. In PHP, there is no Unicode escape sequence so to specify characters by code point a tricks must be used: for example, using the escape sequence of HTML entities and then convert it to a Unicode encoding such as UTF-8.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "MATLAB", "code": "\n\n>> fliplr(['She told me that she spoke English and I said great. '...\n'Grabbed her hand out the club and I said let''s skate.'])\n\nans =\n\n.etaks s'tel dias I dna bulc eht tuo dnah reh debbarG .taerg dias I dna hsilgnE ekops ehs taht em dlot ehS\n", "explain": "A built-in function, \"fliplr(string)\" handles reversing a string of ASCII characters. Unicode is a whole other beast, if you need this functionality test to see if \"fliplr()\" properly handles the unicode characters you use. If it doesn't then you will need to code a function that is specific to your application.\nSample Usage:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nPROGRAM Example\n\n  CHARACTER(80) :: str = \"This is a string\"\n  CHARACTER :: temp\n  INTEGER :: i, length\n\n  WRITE (*,*) str\n  length = LEN_TRIM(str) ! Ignores trailing blanks. Use LEN(str) to reverse those as well\n  DO i = 1, length/2\n     temp = str(i:i)\n     str(i:i) = str(length+1-i:length+1-i)\n     str(length+1-i:length+1-i) = temp\n  END DO\n  WRITE(*,*) str\n\nEND PROGRAM Example\n\n\nOutput:\nThis is a string\ngnirts a si sihT\n\n\nprogram reverse_string\n\n  implicit none\n  character (*), parameter :: string = 'no devil lived on'\n\n  write (*, '(a)') string\n  write (*, '(a)') reverse (string)\n\ncontains\n\n  recursive function reverse (string) result (res)\n\n    implicit none\n    character (*), intent (in) :: string\n    character (len (string)) :: res\n\n    if (len (string) == 0) then\n      res = ''\n    else\n      res = string (len (string) :) // reverse (string (: len (string) - 1))\n    end if\n\n  end function reverse\n\nend program reverse_string\n\n\nOutput:\nno devil lived on\nno devil lived on\n\n program reverse_string\n  implicit none\n  character (80) :: cadena\n  integer :: k, n\n  !\n  cadena = \"abcdefgh\"\n  n = len_trim (cadena)\n  !\n  write (*,*) cadena\n  forall (k=1:n) cadena (k:k) = cadena (n-k+1:n-k+1)\n  write (*,*) cadena\n  !\nend program reverse_string\n\n\nOutput:\nabcdefgh\nhgfedcba \n", "explain": "Another implementation that uses a recursive not-in-place algorithm:\nAnother shorter implementation (adapted version from stackoverflow question 10605574 how-to-reverse-a-chain-of-character-fortran-90):\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Scratch", "code": "\n\n", "explain": "\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode\"\n    \"unicode/utf8\"\n)\n\n// no encoding\nfunc reverseBytes(s string) string {\n    r := make([]byte, len(s))\n    for i := 0; i < len(s); i++ {\n        r[i] = s[len(s)-1-i]\n    }\n    return string(r)\n}\n\n// reverseCodePoints interprets its argument as UTF-8 and ignores bytes\n// that do not form valid UTF-8.  return value is UTF-8.\nfunc reverseCodePoints(s string) string {\n    r := make([]rune, len(s))\n    start := len(s)\n    for _, c := range s {\n        // quietly skip invalid UTF-8\n        if c != utf8.RuneError {\n            start--\n            r[start] = c\n        }\n    }\n    return string(r[start:])\n}\n\n// reversePreservingCombiningCharacters interprets its argument as UTF-8\n// and ignores bytes that do not form valid UTF-8.  return value is UTF-8.\nfunc reversePreservingCombiningCharacters(s string) string {\n    if s == \"\" {\n        return \"\"\n    }\n    p := []rune(s)\n    r := make([]rune, len(p))\n    start := len(r)\n    for i := 0; i < len(p); {\n        // quietly skip invalid UTF-8\n        if p[i] == utf8.RuneError {\n            i++\n            continue\n        }\n        j := i + 1\n        for j < len(p) && (unicode.Is(unicode.Mn, p[j]) ||\n            unicode.Is(unicode.Me, p[j]) || unicode.Is(unicode.Mc, p[j])) {\n            j++\n        }\n        for k := j - 1; k >= i; k-- {\n            start--\n            r[start] = p[k]\n        }\n        i = j\n    }\n    return (string(r[start:]))\n}\n\nfunc main() {\n    test(\"asdf\")\n    test(\"as\u20dddf\u0305\")\n}\n\nfunc test(s string) {\n    fmt.Println(\"\\noriginal:      \", []byte(s), s)\n    r := reverseBytes(s)\n    fmt.Println(\"reversed bytes:\", []byte(r), r)\n    fmt.Println(\"original code points:\", []rune(s), s)\n    r = reverseCodePoints(s)\n    fmt.Println(\"reversed code points:\", []rune(r), r)\n    r = reversePreservingCombiningCharacters(s)\n    fmt.Println(\"combining characters:\", []rune(r), r)\n}\n\n\nOutput:\noriginal:       [97 115 100 102] asdf\nreversed bytes: [102 100 115 97] fdsa\noriginal code points: [97 115 100 102] asdf\nreversed code points: [102 100 115 97] fdsa\ncombining characters: [102 100 115 97] fdsa\n\noriginal:       [97 115 226 131 157 100 102 204 133] as\u20dddf\u0305\nreversed bytes: [133 204 102 100 157 131 226 115 97] \ufffd\ufffdfd\ufffd\ufffd\ufffdsa\noriginal code points: [97 115 8413 100 102 773] as\u20dddf\u0305\nreversed code points: [773 102 100 8413 115 97] \u0305fd\u20ddsa\ncombining characters: [102 773 100 115 8413 97] f\u0305ds\u20dda\n\n", "explain": "Functions below assume UTF-8 encoding.  (The task mentions Unicode but does not specify an encoding.)  Strings in Go are not restricted to be UTF-8, but Go has good support for it and works with UTF-8 most natually.  As shown below, certain string conversions work in UTF-8 and the range clause over a string works in UTF-8.  Go also has a Unicode package in the standard library that makes easy work of recognizing combining characters for this task.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n# First, it gets the length of the original string\n# Then, it allocates memory from the copy\n# Then it copies the pointer to the original string, and adds the strlen\n#     subtract 1, then that new pointer is at the last char.\n# while(strlen)\n#     copy char\n#     decrement strlen\n#     decrement source pointer\n#     increment target pointer\n\n.text\n\nstrcpy:\n  addi $sp, $sp, -4\n  sw $s0, 0($sp)\n  add $s0, $zero, $zero\n\nL1: \n  add $t1, $s0, $a1\n  lb $t2, 0($t1)\n  add $t3, $s0, $a0\n  sb $t2, 0($t3)\n  beq $t2, $zero, L2\n  addi $s0, $s0, 1\n  j L1\n\nL2:\n  lw $s0, 0($sp)\n  addi $sp, $sp, 4\n  jr $ra\n\n.data \n\tex_msg_og: .asciiz \"Original string:\\n\"\n\tex_msg_cpy: .asciiz \"\\nCopied string:\\n\"\n\tstring: .asciiz \"Nice string you got there!\\n\"\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nfunction ReverseString(const InString: string): string;\nvar\n  i: integer;\nbegin\n  for i := Length(InString) downto 1 do\n    Result := Result + InString[i];\nend;\n\n\nStrUtils.ReverseString\n\n\nfunction Reverse(const s: string): string;\nvar\n  i, aLength, ahalfLength: Integer;\n  c: Char;\nbegin\n  Result := s;\n  aLength := Length(s);\n  ahalfLength := aLength div 2;\n  if aLength > 1 then\n    for i := 1 to ahalfLength do\n    begin\n      c := result[i];\n      result[i] := result[aLength - i + 1];\n      result[aLength - i + 1] := c;\n    end;\nend;\n\n\n", "explain": "You could also use this RTL function Introduced in Delphi 6:\nAnother alternative.\nAll versions has the same perfomance, then StrUtils is recomended.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Ruby", "code": "\nstr = \"asdf\"\nreversed = str.reverse\n\"r\u00e9sum\u00e9 ni\u00f1o\".reverse #=> \"o\u00f1in \u00e9mus\u00e9r\"\n\ngraphemes = 'as\u20dddf\u0305'.scan(/\\X/)\nreversed = graphemes.reverse\ngraphemes.join #=> \"f\u0305ds\u20dda\"\n", "explain": "for extra credit\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Rust", "code": "\n\nlet mut buffer = b\"abcdef\".to_vec();\nbuffer.reverse();\nassert_eq!(buffer, b\"fedcba\");\n\nlet output: String = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\".chars().rev().collect();\nassert_eq!(output, \"\u5341\u4e5d\u516b\u4e03\u516d\u4e94\u56db\u4e09\u4e8c\u4e00\");\n\nlet output: String = \"as\u20dddf\u0305\".chars().rev().collect();\nassert_ne!(output, \"f\u0305ds\u20dda\"); // should be this\nassert_eq!(output, \"\u0305fd\u20ddsa\");\n\nuse unicode_segmentation::UnicodeSegmentation;\n\nlet output: String = \"as\u20dddf\u0305\".graphemes(true).rev().collect();\nassert_eq!(output, \"f\u0305ds\u20dda\");\n", "explain": "Reversing ASCII byte-slice (in-place):\nReversing Unicode scalar values:\nReversing a Chars iterator doesn't solve the complete problem, because it iterates unicode scalar values, which doesn't account for combining marks:\nReversing graphemes clusters, which is provided by the unicode-segmentation crate, solves the problem:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Swift", "code": "\n\nWorks with: Swift version 2.x+\nfunc reverseString(s: String) -> String {\n  return String(s.characters.reverse())\n}\nprint(reverseString(\"asdf\"))\nprint(reverseString(\"as\u20dddf\u0305\"))\nWorks with: Swift version 1.x\nfunc reverseString(s: String) -> String {\n  return String(reverse(s))\n}\nprintln(reverseString(\"asdf\"))\nprintln(reverseString(\"as\u20dddf\u0305\"))\n\nOutput:\nfdsa\nf\u0305ds\u20dda\n\n\n", "explain": "Swift's strings are iterated by Characters, which represent \"Unicode grapheme clusters\", so reversing it reverses it with combining characters too:\n\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "R", "code": "\nWorks with: R version 2.8.1\n\nrevstring <- function(stringtorev) {\n   return(\n      paste(\n           strsplit(stringtorev,\"\")[[1]][nchar(stringtorev):1]\n           ,collapse=\"\")\n           )\n}\n\n revstring <- function(s) paste(rev(strsplit(s,\"\")[[1]]),collapse=\"\")\nrevstring(\"asdf\")\nrevstring(\"m\\u00f8\\u00f8se\")\nEncoding(\"m\\u00f8\\u00f8se\")   # just to check if on your system it's something\n                              # different!\n\nOutput:\n[1] \"fdsa\"\n[1] \"es\u00f8\u00f8m\"\n[1] \"UTF-8\"\n\n\n", "explain": "The following code works with UTF-8 encoded strings too.\nAlternatively (using rev() function):\nR can encode strings in Latin1 and UTF-8 (the default may depend on the locale); the Encoding(string) can be used to know if the string is encoded in Latin1 or UTF-8; the encoding can be forced (Encoding(x) <- \"latin1\"), or we can use iconv to properly translate between encodings whenever possible.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "COBOL", "code": "\nFUNCTION REVERSE('QWERTY')\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 6\nDebug.Print VBA.StrReverse(\"Visual Basic\")\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Text_IO; use Ada.Text_IO;\n \nprocedure Reverse_String is\n   function Reverse_It (Item : String) return String is\n      Result : String (Item'Range);\n   begin\n      for I in Item'range loop\n         Result (Result'Last - I + Item'First) := Item (I);\n      end loop;\n      return Result;\n   end Reverse_It;\nbegin\n   Put_Line (Reverse_It (Get_Line));\nend Reverse_String;\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Julia", "code": "\njulia> reverse(\"hey\")\n\"yeh\"\n\njulia> join(reverse(collect(graphemes(\"as\u20dddf\u0305\"))))\n\"f\u0305ds\u20dda\"\n", "explain": "The reverse function reverses codepoints (because this is the right behavior for the main application of string reversal: reversed string processing by external C libraries).  However, starting in Julia 0.4, you can also reverse the graphemes if you want (i.e. to reverse \"visual order\" including combining characters etc.) by:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "SAS", "code": "\ndata _null_;\nlength a b $11;\na=\"I am Legend\";\nb=reverse(a);\nput a;\nput b;\nrun;\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\nfun main(args: Array<String>) {\n    println(\"asdf\".reversed())\n}\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Perl", "code": "\n\nuse utf8;\nbinmode STDOUT, \":utf8\";\n\n# to reverse characters (code points):\nprint scalar reverse('visor'), \"\\n\";\n\n# to reverse graphemes:\nprint join(\"\", reverse \"Jos\u00e9\" =~ /\\X/g), \"\\n\";\n\n$string = '\u2135\u0391\u03a9 \u99f1\u99dd\u9053 \ud83e\udd14 \ud83c\uddf8\ud83c\udde7 \ud83c\uddfa\ud83c\uddf8 \ud83c\uddec\ud83c\udde7\u200d \ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66\ud83c\udd97\ud83d\uddfa';\nprint join(\"\", reverse $string =~ /\\X/g), \"\\n\";\n\nOutput:\nrosiv\n\u00e9soJ\n\ud83d\uddfa\ud83c\udd97\ud83d\udc68\u200d\ud83d\udc69\u200d\ud83d\udc67\u200d\ud83d\udc66 \ud83c\uddec\ud83c\udde7\u200d \ud83c\uddfa\ud83c\uddf8 \ud83c\uddf8\ud83c\udde7 \ud83e\udd14 \u9053\u99dd\u99f1 \u03a9\u0391\u2135\n", "explain": "reverse() works in the context of a List or a scalar, not a string.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Objective-C", "code": "\n\n#import <Foundation/Foundation.h>\n\n@interface NSString (Extended)\n-(NSString *)reverseString;\n@end\n\n@implementation NSString (Extended)\n-(NSString *) reverseString\n{\n    NSUInteger len = [self length];\n    NSMutableString *rtr=[NSMutableString stringWithCapacity:len];\n    //        unichar buf[1];\n    \n    while (len > (NSUInteger)0) { \n        unichar uch = [self characterAtIndex:--len]; \n        [rtr appendString:[NSString stringWithCharacters:&uch length:1]];\n    }\n    return rtr;\n}\n@end\n\nint main()\n{\n    @autoreleasepool {\n        \n        NSString *test = [@\"!A string to be reverted!\" reverseString];\n    \n        NSLog(@\"%@\", test);\n    \n    }\n    return 0;\n}\nSupporting combining characters[edit]\n\n#import <Foundation/Foundation.h>\n\n@interface NSString (Extended)\n-(NSString *)reverseString;\n@end\n\n@implementation NSString (Extended)\n-(NSString *)reverseString\n{\n\tNSInteger l = [self length] - 1;\n\tNSMutableString *ostr = [NSMutableString stringWithCapacity:[self length]];\n\twhile (l >= 0)\n\t{\n\t\tNSRange range = [self rangeOfComposedCharacterSequenceAtIndex:l];\n\t\t[ostr appendString:[self substringWithRange:range]];\n\t\tl -= range.length;\n\t}\n\treturn ostr;\n}\n@end\n\nint main()\n{\n    @autoreleasepool {\n        \n        NSString *test = [@\"as\u20dddf\u0305\" reverseString];\n    \n        NSLog(@\"%@\", test);\n    \n    }\n    return 0;\n}\n", "explain": "This extends the NSString object adding a reverseString class method.\nUsage example:\nExtra credit\nUsage example:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nreverse(\"abcd\", L), string_to_list(S,L).\n\nOutput:\nL = [100,99,98,97],\nS = \"dcba\". \n\naccRev([H|T], A, R)\u00a0:- accRev(T, [H|A], R).\naccRev([], A, A).\n\nrev(L,R)\u00a0:- accRev(L,[],R).\n", "explain": "The main workings are hidden inside the reverse/2 predicate, \nso lets write one to see how it works:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Lua", "code": "\n\nASCII[edit]\nexample = 'asdf'\nstring.reverse(example) -- fdsa\nexample:reverse() -- fdsa\nUnicode[edit]\n\n", "explain": "Built-in string.reverse(s) or s:reverse().\nLua doesn't support Unicode strings.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Scala", "code": "\n\n\"asdf\".reverse\n\n\"asdf\".foldRight(\"\")((a,b) => b+a)\n\ndef reverse(s: String) = {\n  import java.text.{Normalizer,BreakIterator}\n  val norm = Normalizer.normalize(s, Normalizer.Form.NFKC) // wa\ufb04e -> waffle (optional)\n  val it = BreakIterator.getCharacterInstance\n  it setText norm\n  def break(it: BreakIterator, prev: Int, result: List[String] = Nil): List[String] = it.next match {\n    case BreakIterator.DONE => result\n    case cur => break(it, cur, norm.substring(prev, cur)\u00a0:: result)\n  }\n  break(it, it.first).mkString\n}\n\nOutput:\nscala> reverse(\"as\u20dddf\u0305\")\nres0: String = f\u0305ds\u20dda\n\ndef reverseString(s: String) = {\n  import java.lang.Character._\n  \n  val combiningTypes = List(NON_SPACING_MARK, ENCLOSING_MARK, COMBINING_SPACING_MARK)\n  def isCombiningCharacter(c: Char) = combiningTypes contains c.getType\n  def isCombiningSurrogate(high: Char, low: Char) = combiningTypes contains getType(toCodePoint(high, low))\n  def isCombining(l: List[Char]) = l match {\n    case List(a, b) => isCombiningSurrogate(a, b)\n    case List(a) => isCombiningCharacter(a)\n    case Nil => true\n    case _ => throw new IllegalArgumentException(\"isCombining expects a list of up to two characters\")\n  }\n  \n  def cleanSurrogate(l: List[Char]) = l match {\n    case List(a, b) if a.isHighSurrogate && b.isLowSurrogate => l\n    case List(a, b) if a.isLowSurrogate => Nil\n    case List(a, b) => List(a)\n    case _ => throw new IllegalArgumentException(\"cleanSurrogate expects lists of two characters, exactly\")\n  }\n  \n  def splitString(string: String) = (string+\" \").iterator sliding 2 map (_.toList) map cleanSurrogate toList\n\n  def recurse(fwd: List[List[Char]], rev: List[Char]): String = fwd match {\n    case Nil => rev.mkString\n    case c\u00a0:: rest =>\n      val (combining, remaining) = rest span isCombining\n      recurse(remaining, c\u00a0::: combining.foldLeft(List[Char]())(_\u00a0::: _)\u00a0::: rev)\n  }\n  recurse(splitString(s), Nil)\n}\n\nscala> res71 map (\"\\\\u%04x\" format _.toInt)\nres80: scala.collection.immutable.IndexedSeq[String] = IndexedSeq(\\u0061, \\u0073, \\u20dd, \\u0064, \\u0066, \\u0305)\n\nscala> reverseString(res71) map (\"\\\\u%04x\" format _.toInt)\nres81: scala.collection.immutable.IndexedSeq[String] = IndexedSeq(\\u0066, \\u0305, \\u0064, \\u0073, \\u20dd, \\u0061)\n\n", "explain": "Easy way:\nSlightly less easy way:\nUnicode-aware, method 1:\nUnicode-aware, method 2: I can't guarantee it get all the cases, but it does work with combining characters as well as supplementary characters. I did not bother to preserve the order of newline characters, and I didn't even consider directionality beyond just ruling it out.\nREPL on Windows doesn't handle Unicode, so I'll show the bytes instead:\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Dart", "code": "\n\nString reverse(String s) => new String.fromCharCodes(s.runes.toList().reversed);\n\n\nimport 'package:unittest/unittest.dart';\n\nString reverse(String s) => new String.fromCharCodes(s.runes.toList().reversed);\n\nmain() {\n  group(\"Reverse a string -\", () {\n    test(\"Strings with ASCII characters are reversed correctly.\", () {\n      expect(reverse(\"hello, world\"), equals(\"dlrow ,olleh\"));\n    });\n    test(\"Strings with non-ASCII BMP characters are reversed correctly.\", () {\n      expect(reverse(\"\\u4F60\\u4EEC\\u597D\"), equals(\"\\u597D\\u4EEC\\u4F60\"));\n    });\n    test(\"Strings with non-BMP characters are reversed correctly.\", () {\n      expect(reverse(\"hello, \\u{1F310}\"), equals(\"\\u{1F310} ,olleh\"));\n    });\n  });\n}\n\n\n", "explain": "Since Dart strings are sequences of UTF-16 code units, it would not be sufficient to simply reverse the characters in strings, as this would not work with UTF-16 surrogate pairs (pairs of UTF-16 code units that represent single characters outside the Unicode BMP). However, Dart provides a method to convert strings to sequences of unicode code points (called \"runes\" in Dart), and these sequences can easily be reversed and used to create new strings, so a string reversal function can be written with a single line of Dart code:\nA more complete example with unit tests would look like this:\n\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "D", "code": "\nvoid main() {\n\timport std.range, std.conv;\n\n\tstring s1 = \"hello\"; // UTF-8\n\tassert(s1.retro.text == \"olleh\");\n\n\twstring s2 = \"hello\"w; // UTF-16\n\tassert(s2.retro.wtext == \"olleh\"w);\n\n\tdstring s3 = \"hello\"d; // UTF-32\n\tassert(s3.retro.dtext == \"olleh\"d);\n\n\t// without using std.range:\n\tdstring s4 = \"hello\"d;\n\tassert(s4.dup.reverse == \"olleh\"d); // simple but inefficient (copies first, then reverses)\n}\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nreverse = foldl (flip (:)) []\n\n\naccumulatingReverse :: [a] -> [a]\naccumulatingReverse lst =\n  let rev xs a = foldl (flip (:)) a xs\n  in rev lst []\n\nSupporting combining characters[edit]\nimport Data.Char (isMark)\nimport Data.List (groupBy)\nmyReverse = concat . reverse . groupBy (const isMark)\n\n\n", "explain": "This function as defined in the Haskell Prelude.\nThough variants using a helper function with an additional accumulator argument are more efficient, and are now used by default in GHC.List unless the USE_REPORT_PRELUDE key is set.\nPerhaps, for example:\ngroupBy (const isMark) is an unusual way of splitting a string into its combined characters\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nWorks with: Windows Script Host version *\nWScript.Echo StrReverse(\"asdf\")\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Scheme", "code": "\n(define (string-reverse s)\n  (list->string (reverse (string->list s))))\n> (string-reverse \"asdf\")\n\"fdsa\"\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Apex", "code": "\nString str = 'Hello World!';\nstr = str.reverse();\nsystem.debug(str);\n\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\nFor ASCII[edit]\n\n$s = \"asdf\"\nArray indexing[edit]\n\nWorks with: PowerShell version 1\n[string]::Join('', $s[$s.Length..0])\nWorks with: PowerShell version 2\n-join ($s[$s.Length..0])\nWorks with: PowerShell version 2\n[array]::Reverse($s)\nRegular expressions[edit]\n\nWorks with: PowerShell version 1\n$s -replace\n      ('(.)' * $s.Length),\n      [string]::Join('', ($s.Length..1 | ForEach-Object { \"`$$_\" }))\nWorks with: PowerShell version 2\n$s -replace\n      ('(.)' * $s.Length),\n      -join ($s.Length..1 | ForEach-Object { \"`$$_\" } )\nWorks with: PowerShell version 3\n[Regex]::Matches($s,'.','RightToLeft').Value -join ''\nFor Unicode[edit]\nFor codepoints[edit]\n\n$a = 'abc \ud83d\udc27 def'\n$enum = $a.EnumerateRunes() |\u00a0% { \"$_\" }\n-join $enum[$enum.length..0] # fed \ud83d\udc27 cba\nFor graphemes[edit]\n\n$a = \"aeiou`u{0308}yz\"\n$enum = [System.Globalization.StringInfo]::GetTextElementEnumerator($a)\n$arr = @()\nwhile($enum.MoveNext()) { $arr += $enum.GetTextElement() }\n[array]::reverse($arr)\n$arr -join '' # zy\u00fcoiea\n", "explain": "Test string\nCreating a character array from the end to the string's start and join it together into a string again.\nCreating a regular expression substitution which captures every character of the string in a capture group and uses a reverse-ordered string of references to those to construct the reversed string.\nSince PowerShell 7, there is a EnumerateRunes() method to enumerate Unicode codepoints. Enumerating codepoints works for multi-bytes characters but not for composing or joining.\nFor composing or joining, enumerating graphemes is required.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Logo", "code": "\n\nprint reverse \"cat  \u00a0; tac\n", "explain": "REVERSE works on both words and lists.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\n\n<cfset myString  = \"asdf\" />\n<cfset myString  = reverse( myString ) />\n\n", "explain": "You can reverse anything that can be written to the document in hashmarks (i.e. strings, numbers, now( ), etc.).\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "F#", "code": "\nThe function[edit]\n// Reverse a string. Nigel Galloway: August 14th., 2019\nlet strRev \u03b1=let N=System.Globalization.StringInfo.GetTextElementEnumerator(\u03b1)\n             List.unfold(fun n->if n then Some(N.GetTextElement(),N.MoveNext()) else None)(N.MoveNext())|>List.rev|>String.concat \"\"\n\nThe Task[edit]\n\nprintfn \"%s\" (strRev \"as\u20dddf\u0305\")\nprintfn \"%s\" (strRev \"Nigel\")\n\n\nOutput:\nf\u0305ds\u20dda\nlegiN\n\n", "explain": "I was a little concerned when entering this task because in the edit window the overline appears above the d, but when previewed it is correctly above the f, using Firefox anyway. Using XTERM the output is correct with the s inside a circle but appears as sO in Firefox.\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Groovy", "code": "\nSolution:[edit]\nprintln \"Able was I, 'ere I saw Elba.\".reverse()\n\n\nOutput:\n.ablE was I ere' ,I saw elbA\nExtra Credit:[edit]\ndef string = \"as\u20dddf\u0305\"\n\nList combiningBlocks = [\n    Character.UnicodeBlock.COMBINING_DIACRITICAL_MARKS,\n    Character.UnicodeBlock.COMBINING_DIACRITICAL_MARKS_SUPPLEMENT,\n    Character.UnicodeBlock.COMBINING_HALF_MARKS,\n    Character.UnicodeBlock.COMBINING_MARKS_FOR_SYMBOLS\n]\nList chars = string as List\nchars[1..-1].eachWithIndex { ch, i ->\n    if (Character.UnicodeBlock.of((char)ch) in combiningBlocks) {\n        chars[i..(i+1)] = chars[(i+1)..i]\n    }\n}\nprintln chars.reverse().join()\n\n\nOutput:\nf\u0305ds\u20dda\n", "explain": ""}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "Zig", "code": "\n\nvar s = \"socat\".*;\nstd.mem.reverse(u8, &s);\n\nvar s = \"socat\".*;\nstd.mem.reverse(u8, s[0..]);\n\n\n\u2191 https://bugs.openjdk.org/browse/JDK-8291660\n\n\n\n\n\n", "explain": "We can use `.*` to dereference a literal string pointer to an array, and use `std.mem.reverse` to reverse the slice of that array in-place:\nor:\nString `s` now becomes `\"tacos\"`.\nTested on version 0.9.0. Reference: [1].\n"}, {"task_name": "Reverse a string", "task_url": "https://rosettacode.org/wiki/Reverse_a_string", "task_cat": "String manipulation", "lang": "AWK", "code": "\nfunction reverse(s)\n{\n  p = \"\"\n  for(i=length(s); i > 0; i--) { p = p substr(s, i, 1) }\n  return p\n}\n\nBEGIN {\n  print reverse(\"edoCattesoR\")\n}\n\nRecursive\nfunction reverse(s   ,l)\n{\n  l = length(s)\n  return l < 2 ? s:( substr(s,l,1) reverse(substr(s,1,l-1)) )\n}\n\nBEGIN {\n  print reverse(\"edoCattesoR\")\n}\n\nusing split, then joining in front\n\n# Usage: awk -f reverse.awk -v s=Rosetta\n\nfunction rev(s,   i,len,a,r) {\n   len = split(s, a, \"\")\n  #for (i in a) r = a[i] r\t# may not work - order is not guaranteed\u00a0!\n   for (i=1; i<=len; i++) r = a[i] r\n   return r\n}\nBEGIN { \n   if(!s) s = \"Hello, world!\" \n   print s, \"<-->\", rev(s)\n}\n\n\nOutput:\n Rosetta <--> attesoR\n\n", "explain": ""}]