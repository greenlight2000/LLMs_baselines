[{"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Python", "code": "\ndef dotp(a,b):\n    assert len(a) == len(b), 'Vector sizes must match'\n    return sum(aterm * bterm for aterm,bterm in zip(a, b))\n\nif __name__ == '__main__':\n    a, b = [1, 3, -5], [4, -2, -1]\n    assert dotp(a,b) == 3\n\n\nWorks with: Python version 3.7\n'''Dot product'''\n\nfrom operator import (mul)\n\n\n# dotProduct\u00a0:: Num a => [a] -> [a] -> Either String a\ndef dotProduct(xs):\n    '''Either the dot product of xs and ys,\n       or a string reporting unmatched vector sizes.\n    '''\n    return lambda ys: Left('vector sizes differ') if (\n        len(xs) != len(ys)\n    ) else Right(sum(map(mul, xs, ys)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Dot product of other vectors with [1, 3, -5]'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(str)(\n            compose(\n                either(append('Undefined\u00a0:: '))(str)\n            )(dotProduct([1, 3, -5]))\n        )([[4, -2, -1, 8], [4, -2], [4, 2, -1], [4, -2, -1]])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Left\u00a0:: a -> Either a b\ndef Left(x):\n    '''Constructor for an empty Either (option type) value\n       with an associated string.\n    '''\n    return {'type': 'Either', 'Right': None, 'Left': x}\n\n\n# Right\u00a0:: b -> Either a b\ndef Right(x):\n    '''Constructor for a populated Either (option type) value'''\n    return {'type': 'Either', 'Left': None, 'Right': x}\n\n\n# append (++)\u00a0:: [a] -> [a] -> [a]\n# append (++)\u00a0:: String -> String -> String\ndef append(xs):\n    '''Two lists or strings combined into one.'''\n    return lambda ys: xs + ys\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\ndef either(fl):\n    '''The application of fl to e if e is a Left value,\n       or the application of fr to e if e is a Right value.\n    '''\n    return lambda fr: lambda e: fl(e['Left']) if (\n        None is e['Right']\n    ) else fr(e['Right'])\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nDot product of other vectors with [1, 3, -5]:\n\n[4, -2, -1, 8] -> Undefined\u00a0:: vector sizes differ\n       [4, -2] -> Undefined\u00a0:: vector sizes differ\n    [4, 2, -1] -> 15\n   [4, -2, -1] -> 3\n", "explain": "\nOption types can provide a composable alternative to assertions and error-handling. \nHere is an example of an Either type, which returns either a computed value (in a Right wrapping), or an explanatory string (in a Left wrapping).\nA higher order either function can apply one of two supplied functions to an Either value - one for Left Either values, and one for Right Either values:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint dot_product(int *, int *, size_t);\n\nint\nmain(void)\n{\n        int a[3] = {1, 3, -5};\n        int b[3] = {4, -2, -1};\n\n        printf(\"%d\\n\", dot_product(a, b, sizeof(a) / sizeof(a[0])));\n\n        return EXIT_SUCCESS;\n}\n\nint\ndot_product(int *a, int *b, size_t n)\n{\n        int sum = 0;\n        size_t i;\n\n        for (i = 0; i < n; i++) {\n                sum += a[i] * b[i];\n        }\n\n        return sum;\n}\n\n\nOutput:3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "C++", "code": "\n#include <iostream>\n#include <numeric>\n\nint main()\n{\n    int a[] = { 1, 3, -5 };\n    int b[] = { 4, -2, -1 };\n\n    std::cout << std::inner_product(a, a + sizeof(a) / sizeof(a[0]), b, 0) << std::endl;\n\n    return 0;\n}\n\n\nOutput:3\nAlternative using std::valarray[edit]\n#include <valarray>\n#include <iostream>\n\nint main()\n{\n    std::valarray<double> xs = {1,3,-5};\n    std::valarray<double> ys = {4,-2,-1};\n\n    double result = (xs * ys).sum();\n\n    std::cout << result << '\\n';\n    \n    return 0;\n}\n\n\nOutput:3\nAlternative using std::inner_product[edit]\n#include <iostream>\n#include <vector>\n#include <numeric>\n\nint main() {\n  std::vector<int> v1 { 1,  3, -5, };\n  std::vector<int> v2 { 4, -2, -1, };\n  auto dp = std::inner_product(v1.cbegin(), v1.cend(), v2.cbegin(), 0);\n  std::cout << \"dot.product of {1,3,-5} and {4,-2,-1}: \" << dp << std::endl;\n  return 0;\n}\n\n\nOutput:dot.product of {1,3,-5} and {4,-2,-1}: 3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Java", "code": "\npublic class DotProduct {\n\t\n\tpublic static void main(String[] args) {\n\t\tdouble[] a = {1, 3, -5};\n\t\tdouble[] b = {4, -2, -1};\n\t\t\n\t\tSystem.out.println(dotProd(a,b));\n\t}\n\t\n\tpublic static double dotProd(double[] a, double[] b){\n\t\tif(a.length != b.length){\n\t\t\tthrow new IllegalArgumentException(\"The dimensions have to be equal!\");\n\t\t}\n\t\tdouble sum = 0;\n\t\tfor(int i = 0; i < a.length; i++){\n\t\t\tsum += a[i] * b[i];\n\t\t}\n\t\treturn sum;\n\t}\n}\n\n\nOutput:3.0\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "C#", "code": "\nstatic void Main(string[] args)\n{\n\tConsole.WriteLine(DotProduct(new decimal[] { 1, 3, -5 }, new decimal[] { 4, -2, -1 }));\n\tConsole.Read();\n}\n\nprivate static decimal DotProduct(decimal[] vec1, decimal[] vec2) \n{\n\tif (vec1 == null)\n\t\treturn 0;\n\n\tif (vec2 == null)\n\t\treturn 0;\n\n\tif (vec1.Length != vec2.Length)\n\t\treturn 0;\n\n\tdecimal tVal = 0;\n\tfor (int x = 0; x < vec1.Length; x++)\n\t{\n\t\ttVal += vec1[x] * vec2[x];\n\t}\n\n\treturn tVal;\n}\n\n\nOutput:3\nAlternative using Linq (C# 4)[edit]\nWorks with: C# version 4\npublic static decimal DotProduct(decimal[] a, decimal[] b) {\n    return a.Zip(b, (x, y) => x * y).Sum();\n}\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nES5[edit]\nfunction dot_product(ary1, ary2) {\n    if (ary1.length != ary2.length)\n        throw \"can't find dot product: arrays have different lengths\";\n    var dotprod = 0;\n    for (var i = 0; i < ary1.length; i++)\n        dotprod += ary1[i] * ary2[i];\n    return dotprod;\n}\n\nprint(dot_product([1,3,-5],[4,-2,-1])); // ==> 3\nprint(dot_product([1,3,-5],[4,-2,-1,0])); // ==> exception\n\n\nfunction dotp(x,y) {\n    function dotp_sum(a,b) { return a + b; }\n    function dotp_times(a,i) { return x[i] * y[i]; }\n    if (x.length != y.length)\n        throw \"can't find dot product: arrays have different lengths\";\n    return x.map(dotp_times).reduce(dotp_sum,0);\n}\n\ndotp([1,3,-5],[4,-2,-1]); // ==> 3\ndotp([1,3,-5],[4,-2,-1,0]); // ==> exception\n\nES6[edit]\n\n(() => {\n    \"use strict\";\n\n    // ------------------- DOT PRODUCT -------------------\n\n    // dotProduct\u00a0:: [Num] -> [Num] -> Either Null Num\n    const dotProduct = xs =>\n        ys => xs.length === ys.length\n            ? sum(zipWith(mul)(xs)(ys))\n            : null;\n\n\n    // ---------------------- TEST -----------------------\n\n    // main\u00a0:: IO ()\n    const main = () =>\n        dotProduct([1, 3, -5])([4, -2, -1]);\n\n\n    // --------------------- GENERIC ---------------------\n\n    // mul\u00a0:: Num -> Num -> Num\n    const mul = x =>\n        y => x * y;\n\n\n    // sum\u00a0:: [Num] -> Num\n    const sum = xs =>\n    // The numeric sum of all values in xs.\n        xs.reduce((a, x) => a + x, 0);\n\n\n    // zipWith\u00a0:: (a -> b -> c) -> [a] -> [b] -> [c]\n    const zipWith = f =>\n    // A list constructed by zipping with a\n    // custom function, rather than with the\n    // default tuple constructor.\n        xs => ys => xs.map(\n            (x, i) => f(x)(ys[i])\n        ).slice(\n            0, Math.min(xs.length, ys.length)\n        );\n\n    // MAIN ---\n    return main();\n})();\n\n", "explain": "We could also use map and reduce in lieu of iteration,\nComposing functional primitives into a dotProduct() which returns a null value (rather than an error) when the array lengths are unmatched.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Module1\n\n    Function DotProduct(a As Decimal(), b As Decimal()) As Decimal\n        Return a.Zip(b, Function(x, y) x * y).Sum()\n    End Function\n\n    Sub Main()\n        Console.WriteLine(DotProduct({1, 3, -5}, {4, -2, -1}))\n        Console.ReadLine()\n    End Sub\n\nEnd Module\n\nOutput:\n3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "SQL", "code": "\n\nselect i, k, sum(A.N*B.N) as N\n        from A inner join B on A.j=B.j\n        group by i, k\n", "explain": "ANSI sql does not support functions and is missing some other concepts that would be needed for a general case implementation of inner product (column names and tables would need to be first class in SQL -- capable of being passed to functions).\nHowever, inner product is fairly simple to specify in SQL.\nGiven two tables A and B where A has key columns i and j and B has key columns j and k and both have value columns N, the inner product of A and B would be:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "PHP", "code": "\n<?php\nfunction dot_product($v1, $v2) {\n  if (count($v1) != count($v2))\n    throw new Exception('Arrays have different lengths');\n  return array_sum(array_map('bcmul', $v1, $v2));\n}\n\necho dot_product(array(1, 3, -5), array(4, -2, -1)), \"\\n\";\n?>\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "MATLAB", "code": "\n\nA = [1 3 -5]\nB = [4 -2 -1]\nC = dot(A,B)\n\n\nfunction C = DotPro(A,B)\n  C = sum( A.*B );\nend\n\n", "explain": "The dot product operation is a built-in function that operates on vectors of arbitrary length.\nFor the Octave implimentation:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Fortran", "code": "\nprogram test_dot_product\n\n  write (*, '(i0)') dot_product ([1, 3, -5], [4, -2, -1])\n\nend program test_dot_product\n\n\nOutput:3\n\n", "explain": "The intrinsic function Dot_Product(X,Y) accepts various precisions of integer, floating-point and complex arrays (for which it is Sum(Conjg(x)*y)) and even logical, for which it is Any(x .AND. y) returning zero if either array is of length zero, or false for logical types.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Go", "code": "\nImplementation[edit]\npackage main\n\nimport (\n    \"errors\"\n    \"fmt\"\n    \"log\"\n)\n\nvar (\n    v1 = []int{1, 3, -5}\n    v2 = []int{4, -2, -1}\n)\n\nfunc dot(x, y []int) (r int, err error) {\n    if len(x) != len(y) {\n        return 0, errors.New(\"incompatible lengths\")\n    }\n    for i, xi := range x {\n        r += xi * y[i]\n    }\n    return\n}\n\nfunc main() {\n    d, err := dot([]int{1, 3, -5}, []int{4, -2, -1})\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(d)\n}\n\n\nOutput:\n3\n\nLibrary gonum/floats[edit]\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/gonum/floats\"\n)\n\nvar (\n    v1 = []float64{1, 3, -5}\n    v2 = []float64{4, -2, -1}\n)\n\nfunc main() {\n    fmt.Println(floats.Dot(v1, v2))\n}\n\n\nOutput:\n3\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "X86_Assembly", "code": "\n\nformat PE64 console\nentry start\n\n    include 'win64a.inc'\n\nsection '.text' code readable executable\n\n    start:\n        stdcall dotProduct, vA, vB\n        invoke printf, msg_num, rax\n        \n        stdcall dotProduct, vA, vC\n        invoke printf, msg_num, rax\n        \n        invoke ExitProcess, 0\n        \n    proc dotProduct vectorA, vectorB\n        mov rax, [rcx]\n        cmp rax, [rdx]\n        je .calculate\n        \n        invoke printf, msg_sizeMismatch\n        mov rax, 0\n        ret\n        \n        .calculate:\n        mov r8, rcx\n        add r8, 8\n        mov r9, rdx\n        add r9, 8\n        mov rcx, rax\n        mov rax, 0\n        mov rdx, 0\n        \n        .next:\n            mov rbx, [r9]\n            imul rbx, [r8]\n            add rax, rbx\n            add r8, 8\n            add r9, 8\n            loop .next\n        \n        ret\n    endp\n\nsection '.data' data readable\n\n    msg_num db \"%d\", 0x0D, 0x0A, 0\n    msg_sizeMismatch db \"Size mismatch; can't calculate.\", 0x0D, 0x0A, 0\n    \n    struc Vector [symbols] {\n        common\n        .length dq (.end - .symbols) / 8\n        .symbols dq symbols\n        .end:\n    }\n    \n    vA Vector 1, 3, -5\n    vB Vector 4, -2, -1\n    vC Vector 7, 2, 9, 0\n    \nsection '.idata' import data readable writeable\n\n    library kernel32, 'KERNEL32.DLL',\\\n            msvcrt, 'MSVCRT.DLL'\n\n    include 'api/kernel32.inc'\n\n    import  msvcrt,\\\n            printf, 'printf'\n\nOutput:3\nSize mismatch; can't calculate.\n0\n", "explain": "Using FASM. Targets x64 Microsoft Windows.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Delphi", "code": "\nWorks with: Lazarus\nprogram Project1;\n\n{$APPTYPE CONSOLE}\n\ntype\n  doublearray = array of Double;\n\nfunction DotProduct(const A, B : doublearray): Double;\nvar\nI: integer;\nbegin\n  assert (Length(A) = Length(B), 'Input arrays must be the same length');\n  Result := 0;\n  for I := 0 to Length(A) - 1 do\n    Result := Result + (A[I] * B[I]);\nend;\n\nvar\n  x,y: doublearray;\nbegin\n  SetLength(x, 3);\n  SetLength(y, 3);\n  x[0] := 1; x[1] := 3; x[2] := -5;\n  y[0] := 4; y[1] :=-2; y[2] := -1;\n  WriteLn(DotProduct(x,y));\n  ReadLn;\nend.\n\n\nOutput: 3.00000000000000E+0000\n\n", "explain": "Note: Delphi does not like arrays being declared in procedure headings, so it is necessary to declare it beforehand. To use integers, modify doublearray to be an array of integer.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Ruby", "code": "\n\nirb(main):001:0> require 'matrix'\n=> true\nirb(main):002:0> Vector[1, 3, -5].inner_product Vector[4, -2, -1]\n=> 3\n\nclass Array\n  def dot_product(other)\n    raise \"not the same size!\" if self.length\u00a0!= other.length\n    zip(other).sum {|a, b| a*b}\n  end\nend\n\np [1, 3, -5].dot_product [4, -2, -1]   # => 3\n", "explain": "With the standard library, require 'matrix' and call Vector#inner_product.\nOr implement dot product.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Rust", "code": "\n\n// alternatively, fn dot_product(a: &Vec<u32>, b: &Vec<u32>)\n// but using slices is more general and rustic\nfn dot_product(a: &[i32], b: &[i32]) -> Option<i32> {\n    if a.len()\u00a0!= b.len() { return None }\n    Some(\n        a.iter()\n            .zip( b.iter() )\n            .fold(0, |sum, (el_a, el_b)| sum + el_a*el_b)\n    )\n}\n\n\nfn main() {\n    let v1 = vec![1, 3, -5];\n    let v2 = vec![4, -2, -1];\n\n    println!(\"{}\", dot_product(&v1, &v2).unwrap());\n}\n\n#![feature(zero_one)] // <-- unstable feature\nuse std::ops::{Add, Mul};\nuse std::num::Zero;\n\nfn dot_product<T1, T2, U, I1, I2>(lhs: I1, rhs: I2) -> Option<U>\n    where T1: Mul<T2, Output = U>,\n          U: Add<U, Output = U> + Zero,\n          I1: IntoIterator<Item = T1>,\n          I2: IntoIterator<Item = T2>,\n          I1::IntoIter: ExactSizeIterator,\n          I2::IntoIter: ExactSizeIterator,\n{\n    let (iter_lhs, iter_rhs) = (lhs.into_iter(), rhs.into_iter());\n    match (iter_lhs.len(), iter_rhs.len()) {\n        (0, _) | (_, 0) => None,\n        (a,b) if a\u00a0!= b => None,\n        (_,_) => Some( iter_lhs.zip(iter_rhs)\n           .fold(U::zero(), |sum, (a, b)| sum + (a * b)) )\n    }\n}\n\n\n\nfn main() {\n    let v1 = vec![1, 3, -5];\n    let v2 = vec![4, -2, -1];\n\n    println!(\"{}\", dot_product(&v1, &v2).unwrap());\n}\n", "explain": "Implemented as a simple function with check for equal length of vectors.\n\nAlternatively as a very generic function which works for any two types that can be multiplied to result in a third type which can be added with itself. Works with any argument convertible to an Iterator of known length (ExactSizeIterator).\nUses an unstable feature.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Swift", "code": "\nWorks with: Swift version 1.2+\nfunc dot(v1: [Double], v2: [Double]) -> Double {\n  return reduce(lazy(zip(v1, v2)).map(*), 0, +)\n}\n\nprintln(dot([1, 3, -5], [4, -2, -1]))\n\nOutput:\n3.0\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "R", "code": "\n\nx <- c(1, 3, -5)\ny <- c(4, -2, -1)\n\nsum(x*y)  # compute products, then do the sum\nx %*% y   # inner product\n\n# loop implementation\ndotp <- function(x, y) {\n\tn <- length(x)\n\tif(length(y) != n) stop(\"invalid argument\")\n\ts <- 0\n\tfor(i in 1:n) s <- s + x[i]*y[i]\n\ts\n}\n\ndotp(x, y)\n\n", "explain": "Here are several ways to do the task.\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 6\nOption Explicit\n\nFunction DotProduct(a() As Long, b() As Long) As Long\nDim l As Long, u As Long, i As Long\n  Debug.Assert DotProduct = 0 'return value automatically initialized with 0\n  l = LBound(a())\n  If l = LBound(b()) Then\n    u = UBound(a())\n    If u = UBound(b()) Then\n      For i = l To u\n        DotProduct = DotProduct + a(i) * b(i)\n      Next i\n    Exit Function\n    End If\n  End If\n  Err.Raise vbObjectError + 123, , \"invalid input\"\nEnd Function\n\nSub Main()\nDim a() As Long, b() As Long, x As Long\n  ReDim a(2)\n  a(0) = 1\n  a(1) = 3\n  a(2) = -5\n  ReDim b(2)\n  b(0) = 4\n  b(1) = -2\n  b(2) = -1\n  x = DotProduct(a(), b())\n  Debug.Assert x = 3\n  ReDim Preserve a(3)\n  a(3) = 10\n  ReDim Preserve b(3)\n  b(3) = 2\n  x = DotProduct(a(), b())\n  Debug.Assert x = 23\n  ReDim Preserve a(4)\n  a(4) = 10\n  On Error Resume Next\n  x = DotProduct(a(), b())\n  Debug.Assert Err.Number = vbObjectError + 123\n  Debug.Assert Err.Description = \"invalid input\"\nEnd Sub\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Ada", "code": "\nwith Ada.Text_IO; use Ada.Text_IO;\nprocedure dot_product is\n\ttype vect is array(Positive range <>) of Integer;\n\tv1 : vect := (1,3,-5);\n\tv2 : vect := (4,-2,-1);\n\n\tfunction dotprod(a: vect; b: vect) return Integer is\n\t\tsum : Integer := 0;\n\t\tbegin\n\t\tif not (a'Length=b'Length) then raise Constraint_Error; end if;\n\t\tfor p in a'Range loop\n\t\t\tsum := sum + a(p)*b(p);\n\t\tend loop;\n\t\treturn sum;\n\tend dotprod;\n\t\nbegin\nput_line(Integer'Image(dotprod(v1,v2)));\nend dot_product;\n\n\nOutput:3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Julia", "code": "\n\nx = [1, 3, -5]\ny = [4, -2, -1]\nz = dot(x, y)\nz = x'*y\nz = x \u22c5 y\n\n", "explain": "Dot products and many other linear-algebra functions are built-in functions in Julia (and are largely implemented by calling functions from LAPACK).\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Kotlin", "code": "\nWorks with: Kotlin version 1.0+\nfun dot(v1: Array<Double>, v2: Array<Double>) =\n    v1.zip(v2).map { it.first * it.second }.reduce { a, b -> a + b }\n\nfun main(args: Array<String>) {\n    dot(arrayOf(1.0, 3.0, -5.0), arrayOf(4.0, -2.0, -1.0)).let { println(it) }\n}\n\n\nOutput:\n3.0\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Perl", "code": "\nsub dotprod\n{\n        my($vec_a, $vec_b) = @_;\n        die \"they must have the same size\\n\" unless @$vec_a == @$vec_b;\n        my $sum = 0;\n        $sum += $vec_a->[$_] * $vec_b->[$_] for 0..$#$vec_a;\n        return $sum;\n}\n\nmy @vec_a = (1,3,-5);\nmy @vec_b = (4,-2,-1);\n\nprint dotprod(\\@vec_a,\\@vec_b), \"\\n\"; # 3\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Objective-C", "code": "\n#import <stdio.h>\n#import <stdint.h>\n#import <stdlib.h>\n#import <string.h>\n#import <Foundation/Foundation.h>\n\n// this class exists to return a result between two\n// vectors: if vectors have different \"size\", valid\n// must be NO\n@interface VResult\u00a0: NSObject\n{\n @private\n  double value;\n  BOOL valid;\n}\n+(instancetype)new: (double)v isValid: (BOOL)y;\n-(instancetype)init: (double)v isValid: (BOOL)y;\n-(BOOL)isValid;\n-(double)value;\n@end\n\n@implementation VResult\n+(instancetype)new: (double)v isValid: (BOOL)y\n{\n  return [[self alloc] init: v isValid: y];\n}\n-(instancetype)init: (double)v isValid: (BOOL)y\n{\n  if ((self == [super init])) {\n    value = v;\n    valid = y;\n  }\n  return self;\n}\n-(BOOL)isValid { return valid; }\n-(double)value { return value; }\n@end\n\n\n@interface RCVector\u00a0: NSObject\n{\n @private\n  double *vec;\n  uint32_t size;\n}\n+(instancetype)newWithArray: (double *)v ofLength: (uint32_t)l; \n-(instancetype)initWithArray: (double *)v ofLength: (uint32_t)l;\n-(VResult *)dotProductWith: (RCVector *)v;\n-(uint32_t)size;\n-(double *)array;\n-(void)free;\n@end\n\n@implementation RCVector\n+(instancetype)newWithArray: (double *)v ofLength: (uint32_t)l\n{\n  return [[self alloc] initWithArray: v ofLength: l];\n}\n-(instancetype)initWithArray: (double *)v ofLength: (uint32_t)l\n{\n  if ((self = [super init])) {\n    size = l;\n    vec = malloc(sizeof(double) * l);\n    if ( vec == NULL )\n      return nil;\n    memcpy(vec, v, sizeof(double)*l);\n  }\n  return self;\n}\n-(void)dealloc\n{\n  free(vec);\n}\n-(uint32_t)size { return size; }\n-(double *)array { return vec; }\n-(VResult *)dotProductWith: (RCVector *)v\n{\n  double r = 0.0;\n  uint32_t i, s;\n  double *v1;\n  if ( [self size] != [v size] ) return [VResult new: r isValid: NO];\n  s = [self size];\n  v1 = [v array];\n  for(i = 0; i < s; i++) {\n    r += vec[i] * v1[i];\n  }\n  return [VResult new: r isValid: YES];\n}\n@end\n\ndouble val1[] = { 1, 3, -5 };\ndouble val2[] = { 4,-2, -1 }; \n\nint main()\n{\n  @autoreleasepool {\n    RCVector *v1 = [RCVector newWithArray: val1 ofLength: sizeof(val1)/sizeof(double)];\n    RCVector *v2 = [RCVector newWithArray: val2 ofLength: sizeof(val1)/sizeof(double)];\n    VResult *r = [v1 dotProductWith: v2];\n    if ( [r isValid] ) {\n      printf(\"%lf\\n\", [r value]);\n    } else {\n      fprintf(stderr, \"length of vectors differ\\n\");\n    }\n  }\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Prolog", "code": "\n\ndot_product(L1, L2, N) :-\n\tmaplist(mult, L1, L2, P),\n\tsumlist(P, N).\n\nmult(A,B,C) :-\n\tC is A*B.\n\n\n\u00a0?- dot_product([1,3,-5], [4,-2,-1], N).\nN = 3.\n", "explain": "Works with SWI-Prolog.\nExample\u00a0:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Lua", "code": "\nfunction dotprod(a, b)\n  local ret = 0\n  for i = 1, #a do\n    ret = ret + a[i] * b[i]\n  end\n  return ret\nend\n\nprint(dotprod({1, 3, -5}, {4, -2, 1}))\n\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Scala", "code": "\nLibrary: Scalaclass Dot[T](v1: Seq[T])(implicit n: Numeric[T]) {\n  import n._ // import * operator\n  def dot(v2: Seq[T]) = {\n    require(v1.size == v2.size)\n    (v1 zip v2).map{ Function.tupled(_ * _)}.sum\n  }\n}\n\nobject Main extends App {\n  implicit def toDot[T: Numeric](v1: Seq[T]) = new Dot(v1)\n\n  val v1 = List(1, 3, -5)\n  val v2 = List(4, -2, -1)\n  println(v1 dot v2)\n}\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Dart", "code": "\nnum dot(List<num> A, List<num> B){\n  if (A.length != B.length){\n    throw new Exception('Vectors must be of equal size');\n  }\n  num result = 0;\n  for (int i = 0; i < A.length; i++){\n    result += A[i] * B[i];\n  }\n  return result;\n}\n\nvoid main(){\n  var l = [1,3,-5];\n  var k = [4,-2,-1];\n  print(dot(l,k));\n}\n\n\nOutput:\n3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.numeric;\n\n    [1.0, 3.0, -5.0].dotProduct([4.0, -2.0, -1.0]).writeln;\n}\n\n\nOutput:\n3\n\nvoid main() {\n    import std.stdio, std.algorithm;\n\n    double[3] a = [1.0, 3.0, -5.0];\n    double[3] b = [4.0, -2.0, -1.0];\n    double[3] c = a[] * b[];\n    c[].sum.writeln;\n}\n\n", "explain": "Using an array operation:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Haskell", "code": "\ndotp :: Num a => [a] -> [a] -> a \ndotp a b | length a == length b = sum (zipWith (*) a b)\n         | otherwise = error \"Vector sizes must match\"\n \nmain = print $ dotp [1, 3, -5] [4, -2, -1] -- prints 3\n\n\ndotProduct :: Num a => [a] -> [a] -> Maybe a\ndotProduct a b \n  | length a == length b = Just $ dp a b\n  | otherwise = Nothing\n    where\n      dp x y = sum $ zipWith (*) x y\n\n\nmain :: IO ()\nmain = print n\n  where\n    Just n = dotProduct [1, 3, -5] [4, -2, -1]\n\n", "explain": "Or, using the Maybe monad to avoid exceptions and keep things composable:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "VBScript", "code": "\nWScript.Echo DotProduct(\"1,3,-5\",\"4,-2,-1\")\n\nFunction DotProduct(vector1,vector2)\n\tarrv1 = Split(vector1,\",\")\n\tarrv2 = Split(vector2,\",\")\n\tIf UBound(arrv1) <> UBound(arrv2) Then\n\t\tWScript.Echo \"The vectors are not of the same length.\"\n\t\tExit Function\n\tEnd If\n\tDotProduct = 0\n\tFor i = 0 To UBound(arrv1)\n\t\tDotProduct = DotProduct + (arrv1(i) * arrv2(i))\n\tNext\nEnd Function\n\nOutput:\n3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Scheme", "code": "\nWorks with: Scheme version R\n\n\n\n\n\n5\n\n\n\n{\\displaystyle ^5}\n\nRS\n(define (dot-product a b)\n  (apply + (map * a b)))\n\n(display (dot-product '(1 3 -5) '(4 -2 -1)))\n(newline)\n\nOutput:3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "PowerShell", "code": "\nfunction dotproduct( $a, $b) {\n    $a | foreach -Begin {$i = $res = 0} -Process { $res += $_*$b[$i++] } -End{$res}\n} \ndotproduct (1..2) (1..2) \ndotproduct (1..10) (11..20)\n\n\n \n5 \n935\n\n", "explain": "Output:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Logo", "code": "\nto dotprod :a :b\n  output apply \"sum (map \"product :a :b)\nend\n\nshow dotprod [1 3 -5] [4 -2 -1]   \u00a0; 3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "ABAP", "code": "\nreport zdot_product\ndata: lv_n type i,\n      lv_sum type i,\n      lt_a type standard table of i,\n      lt_b type standard table of i.\n\nappend: '1' to lt_a, '3' to lt_a, '-5' to lt_a.\nappend: '4' to lt_b, '-2' to lt_b, '-1' to lt_b.\ndescribe table lt_a lines lv_n.\n\nperform dot_product using lt_a lt_b lv_n changing lv_sum.\n\nwrite lv_sum left-justified.\n\nform dot_product using it_a like lt_a\n                       it_b like lt_b\n                       iv_n type i\n                 changing\n                       ev_sum type i.\n  field-symbols: <wa_a> type i, <wa_b> type i.\n\n  do iv_n times.\n    read table: it_a assigning <wa_a> index sy-index, it_b assigning <wa_b> index sy-index.\n    lv_sum = lv_sum + ( <wa_a> * <wa_b> ).\n  enddo.\nendform.\n\n\nOutput:3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "F#", "code": "\nlet dot_product (a:array<'a>) (b:array<'a>) =\n    if Array.length a <> Array.length b then failwith \"invalid argument: vectors must have the same lengths\"\n    Array.fold2 (fun acc i j -> acc + (i * j)) 0 a b\n\n> dot_product [| 1; 3; -5 |] [| 4; -2; -1 |]\u00a0;;\nval it\u00a0: int = 3\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Groovy", "code": "\n\ndef dotProduct = { x, y ->\n    assert x && y && x.size() == y.size()\n    [x, y].transpose().collect{ xx, yy -> xx * yy }.sum()\n}\n\n\nprintln dotProduct([1, 3, -5], [4, -2, -1])\n\n\nOutput:3\n", "explain": "Solution:\nTest:\n"}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "Zig", "code": "\nconst std = @import(\"std\");\nconst Vector = std.meta.Vector;\n\npub fn main() !void {\n    const a: Vector(3, i32) = [_]i32{1, 3, -5};\n    const b: Vector(3, i32) = [_]i32{4, -2, -1};\n    var dot: i32 = @reduce(.Add, a*b);\n\n    try std.io.getStdOut().writer().print(\"{d}\\n\", .{dot});\n}\n", "explain": ""}, {"task_name": "Dot product", "task_url": "https://rosettacode.org/wiki/Dot_product", "task_cat": "Geometry", "lang": "AWK", "code": "\n# syntax: GAWK -f DOT_PRODUCT.AWK\nBEGIN {\n    v1 = \"1,3,-5\"\n    v2 = \"4,-2,-1\"\n    if (split(v1,v1arr,\",\") != split(v2,v2arr,\",\")) {\n      print(\"error: vectors are of unequal lengths\")\n      exit(1)\n    }\n    printf(\"%g\\n\",dot_product(v1arr,v2arr))\n    exit(0)\n}\nfunction dot_product(v1,v2,  i,sum) {\n    for (i in v1) {\n      sum += v1[i] * v2[i]\n    }\n    return(sum)\n}\n\n\nOutput:3\n", "explain": ""}]