[{"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Python", "code": "\nimport sys\nfor n in xrange(sys.maxint):\n    print oct(n)\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "C", "code": "\n#include <stdio.h>\n\nint main()\n{\n        unsigned int i = 0;\n        do { printf(\"%o\\n\", i++); } while(i);\n        return 0;\n}\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "C++", "code": "\n\n#include <iostream>\n\nint main()\n{\n  unsigned i = 0;\n  do\n  {\n    std::cout << std::oct << i << std::endl;\n    ++i;\n  } while(i != 0);\n  return 0;\n}\n\n", "explain": "This prevents an infinite loop by counting until the counter overflows and produces a 0 again. This could also be done with a for or while loop, but you'd have to print 0 (or the last number) outside the loop.\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Java", "code": "\nvoid printCount() {\n    for (int value = 0; value <= 20; value++) {\n        /* the 'o' specifier will print the octal integer */\n        System.out.printf(\"%o%n\", value);\n    }\n}\n\n0\n1\n2\n3\n4\n5\n6\n7\n10\n11\n12\n13\n14\n15\n16\n17\n20\n21\n22\n23\n24\n\n\npublic class Count{\n    public static void main(String[] args){\n        for(int i = 0;i >= 0;i++){\n            System.out.println(Integer.toOctalString(i)); //optionally use \"Integer.toString(i, 8)\"\n        }\n    }\n}\n\n", "explain": "\nAn alternate implementation\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        var number = 0;\n        do\n        {\n            Console.WriteLine(Convert.ToString(number, 8));\n        } while (++number > 0);\n    }\n}\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "JavaScript", "code": "\nfor (var n = 0; n < 1e14; n++) { // arbitrary limit that's not too big\n    document.writeln(n.toString(8)); // not sure what's the best way to output it in JavaScript\n}\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "PHP", "code": "\n<?php\nfor ($n = 0; is_int($n); $n++) {\n  echo decoct($n), \"\\n\";\n}\n?>\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Fortran", "code": "\nWorks with: Fortran version 95 and later\nprogram Octal\n  implicit none\n  \n  integer, parameter :: i64 = selected_int_kind(18)\n  integer(i64) :: n = 0\n  \n! Will stop when n overflows from\n! 9223372036854775807 to -92233720368547758078 (1000000000000000000000 octal)\n  do while(n >= 0)\n    write(*, \"(o0)\") n\n    n = n + 1\n  end do\nend program\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Scratch", "code": "\n\n", "explain": "\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc main() {\n    for i := int8(0); ; i++ {\n        fmt.Printf(\"%o\\n\", i)\n        if i == math.MaxInt8 {\n            break\n        }\n    }\n}\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n10\n11\n12\n...\n175\n176\n177\n\n\nfunc main() {\n    for i := uint16(0); ; i++ {  // type specified here\n        fmt.Printf(\"%o\\n\", i)\n        if i == math.MaxUint16 { // maximum value for type specified here\n            break\n        }\n    }\n}\n\n\n...\n177775\n177776\n177777\n\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 0.; ; {\n        fmt.Printf(\"%o\\n\", int64(i))\n        /* uncomment to produce example output\n        if i == 3 {\n            i = float64(1<<53 - 4) // skip to near the end\n            fmt.Println(\"...\")\n        } */\n        next := i + 1\n        if next == i {\n            break\n        }\n        i = next\n    }\n}\n\n\n0\n1\n2\n3\n...\n377777777777777775\n377777777777777776\n377777777777777777\n400000000000000000\n\n\nimport (\n    \"big\"\n    \"fmt\"\n)\n\nfunc main() {\n    defer func() {\n        recover()\n    }()\n    one := big.NewInt(1)\n    for i := big.NewInt(0); ; i.Add(i, one) {\n        fmt.Printf(\"%o\\n\", i)\n    }\n}\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n10\n11\n12\n13\n14\n...\n\n", "explain": "Output:\nNote that to use a different integer type, code must be changed in two places.  Go has no way to query a type for its maximum value.  Example:\nOutput:\nNote also that if floating point types are used for the counter, loss of precision will prevent the program from from ever reaching the maximum value.  If you stretch interpretation of the task wording \"maximum value\" to mean \"maximum value of contiguous integers\" then the following will work:\nOutput, with skip uncommented:\nBig integers have no maximum value, but the Go runtime will panic when memory allocation fails.  The deferred recover here allows the program to terminate silently should the program run until this happens.\nOutput:\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program countoctal.s   */\n \n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:        .ascii \"Count\u00a0: \"\nsMessValeur:        .fill 11, 1, ' '            @ size => 11\nszCarriageReturn:   .asciz \"\\n\"\n\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                             @ entry of program \n    mov r4,#0                                     @ loop indice\n1:                                                @ begin loop\n    mov r0,r4\n    ldr r1,iAdrsMessValeur\n    bl conversion8                                @ call conversion octal\n    ldr r0,iAdrsMessResult\n    bl affichageMess                              @ display message\n    add r4,#1\n    cmp r4,#64\n    ble 1b\n\n\n100:                                              @ standard end of the program \n    mov r0, #0                                    @ return code\n    mov r7, #EXIT                                 @ request to exit program\n    svc #0                                        @ perform the system call\n \niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to octal                             */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion8:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n \n1:                                                  @ start loop\n    mov r1,r0\n    lsr r0,#3                                       @ / by 8\n    sub r1,r0,lsl #3                                @ compute remainder r1 - (r0 * 8)\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b                                          @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n \n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Delphi", "code": "\nprogram CountingInOctal;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nfunction DecToOct(aValue: Integer): string;\nvar\n  lRemainder: Integer;\nbegin\n  Result := '';\n  repeat\n    lRemainder := aValue mod 8;\n    Result := IntToStr(lRemainder) + Result;\n    aValue := aValue div 8;\n  until aValue = 0;\nend;\n\nvar\n  i: Integer;\nbegin\n  for i := 0 to 20 do\n    WriteLn(DecToOct(i));\nend.\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Ruby", "code": "\nn = 0\nloop do\n  puts \"%o\" % n\n  n += 1\nend\n\n# or\nfor n in (0..)\n  puts n.to_s(8)\nend\n\n# or\n0.upto(1/0.0) do |n|\n  printf \"%o\\n\", n\nend\n\n# version 2.1 later\n0.step do |n|\n  puts format(\"%o\", n)\nend\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Rust", "code": "\nfn main() {\n    for i in 0..std::usize::MAX {\n        println!(\"{:o}\", i);\n    }\n}\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Swift", "code": "\nimport Foundation\n\nfunc octalSuccessor(value: String) -> String {\n   if value.isEmpty {\n        return \"1\"\n   } else {\n     let i = value.startIndex, j = value.endIndex.predecessor()\n     switch (value[j]) {\n       case \"0\": return value[i..<j] + \"1\"\n       case \"1\": return value[i..<j] + \"2\"\n       case \"2\": return value[i..<j] + \"3\"\n       case \"3\": return value[i..<j] + \"4\"\n       case \"4\": return value[i..<j] + \"5\"\n       case \"5\": return value[i..<j] + \"6\"\n       case \"6\": return value[i..<j] + \"7\"\n       case \"7\": return octalSuccessor(value[i..<j]) + \"0\"\n       default:\n         NSException(name:\"InvalidDigit\", reason: \"InvalidOctalDigit\", userInfo: nil).raise();\n         return \"\"\n     }\n  }\n}\n\nvar n = \"0\"\nwhile strtoul(n, nil, 8) < UInt.max {\n  println(n)\n  n = octalSuccessor(n)\n}\n\n\nOutput:\n\n0\n1\n2\n3\n4\n5\n6\n7\n10\n11\n12\n13\n14\n15\n16\n17\n20\n21\n22\n23\n", "explain": "The first few lines. anyway:\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "COBOL", "code": "\nTranslation of: Delphi\nWorks with: GNU Cobol version 2.0\n       >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. count-in-octal.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION dec-to-oct\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  i                                   PIC 9(18).\n\nPROCEDURE DIVISION.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i = 0\n        DISPLAY FUNCTION dec-to-oct(i)\n    END-PERFORM\n    .\nEND PROGRAM count-in-octal.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. dec-to-oct.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  rem                                 PIC 9.\n\n01  dec                                 PIC 9(18).\n\nLINKAGE SECTION.\n01  dec-arg                             PIC 9(18).\n\n01  oct                                 PIC 9(18).\n\nPROCEDURE DIVISION USING dec-arg RETURNING oct.\n    MOVE dec-arg TO dec *> Copy is made to avoid modifying reference arg.\n    PERFORM WITH TEST AFTER UNTIL dec = 0\n        MOVE FUNCTION REM(dec, 8) TO rem\n        STRING rem, oct DELIMITED BY SPACES INTO oct\n        DIVIDE 8 INTO dec\n    END-PERFORM\n    .\nEND FUNCTION dec-to-oct.\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Octal is\n   package IIO is new Ada.Text_IO.Integer_IO(Integer);\nbegin\n   for I in 0 .. Integer'Last loop\n      IIO.Put(I, Base => 8);\n      Ada.Text_IO.New_Line;\n   end loop;\nend Octal;\n\n\n       8#0#\n       8#1#\n       8#2#\n       8#3#\n       8#4#\n       8#5#\n       8#6#\n       8#7#\n      8#10#\n      8#11#\n      8#12#\n      8#13#\n      8#14#\n      8#15#\n      8#16#\n      8#17#\n      8#20#\n", "explain": "First few lines of Output:\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Julia", "code": "\nfor i in one(Int64):typemax(Int64)\n    print(oct(i), \" \")\n    sleep(0.1)\nend\n\n\n\nOutput:\n1 2 3 4 5 6 7 10 11 12 13 14 15 16 17 20 21 22 23 24 25 26 27 30 31 32 33 34 35 36 ^C\n\n", "explain": "I slowed the loop down with a sleep to make it possible to see the result without being swamped.\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Kotlin", "code": "\n//  version 1.1\n\n//  counts up to 177 octal i.e. 127 decimal\nfun main(args: Array<String>) {\n    (0..Byte.MAX_VALUE).forEach { println(\"%03o\".format(it)) }\n}\n\n\nOutput:\n\n000\n001\n002\n003\n004\n005\n006\n007\n010\n011\n\n", "explain": "First ten lines:\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Perl", "code": "\n\nuse POSIX;\nprintf \"%o\\n\", $_ for (0 .. POSIX::UINT_MAX);\n\n\nuse bigint;\nmy $i = 0;\nprintf \"%o\\n\", $i++ while 1\n\n\n#!/usr/bin/perl\n\n$_ = 0;\ns/([^7])?(7*)$/ $1 + 1 . $2 =~ tr!7!0!r /e while print \"$_\\n\";\n\n", "explain": "Since task says \"system register\", I take it to mean \"no larger than machine native integer limit\":\nOtherwise:\nThe above count in binary or decimal and convert to octal.\nThis actually counts in octal.\nIt will run forever or until the universe ends, whichever comes first.\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Prolog", "code": "\n\no(O) :- member(O, [0,1,2,3,4,5,6,7]).\n\noctal([O]) :- o(O).\noctal([A|B]) :- \n\toctal(O), \n\to(T), \n\tappend(O, [T], [A|B]),\n\tdif(A, 0).\n\t\noctalize :-\n\tforall(\n\t\toctal(X),\n\t\t(maplist(write, X), nl)\n\t).\n\n", "explain": "Rather than just printing out a list of octal numbers, this code will generate a sequence. \noctal/1 can also be used to tell if a number is a valid octal number or not. \noctalize will keep producing and printing octal number, there is no limit. \n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Lua", "code": "\nfor l=1,2147483647 do\n  print(string.format(\"%o\",l))\nend\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Scala", "code": "\nStream from 0 foreach (i => println(i.toOctalString))\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "D", "code": "\nvoid main() {\n    import std.stdio;\n\n    ubyte i;\n    do writefln(\"%o\", i++);\n    while(i);\n}\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Haskell", "code": "\nimport Numeric (showOct)\n\nmain :: IO ()\nmain =\n  mapM_\n    (putStrLn . flip showOct \"\")\n    [1 .. maxBound :: Int]\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "VBScript", "code": "\nFor i = 0 To 20\n\tWScript.StdOut.WriteLine Oct(i)\nNext\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Scheme", "code": "\n(do ((i 0 (+ i 1))) (#f) (display (number->string i 8)) (newline))\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "PowerShell", "code": "\n[int64]$i = 0\nWhile ( $True )\n    {\n    [Convert]::ToString( ++$i, 8 )\n    }\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Logo", "code": "\n\nto increment_octal :n\n  ifelse [empty? :n] [\n    output 1\n  ] [\n    local \"last\n    make \"last last :n\n    local \"butlast\n    make \"butlast butlast :n\n    make \"last sum :last 1\n    ifelse [:last < 8] [\n      output word :butlast :last\n    ] [\n      output word (increment_octal :butlast) 0\n    ]\n  ]\nend\n\nmake \"oct 0\nwhile [\"true] [\n  print :oct\n  make \"oct increment_octal :oct\n]\n", "explain": "No built-in octal-formatting, so it's probably more efficient to just manually increment a string than to increment a number and then convert the whole thing to octal every time we print.  This also lets us keep counting as long as we have room for the string.\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "F#", "code": "\nlet rec countInOctal num : unit =\n  printfn \"%o\" num\n  countInOctal (num + 1)\n\ncountInOctal 1\n\n", "explain": ""}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "Groovy", "code": "\n\nprintln 'decimal  octal'\nfor (def i = 0; i <= Integer.MAX_VALUE; i++) {\n    printf ('%7d \u00a0%#5o\\n', i, i)\n}\n\n\nprintln 'decimal  octal'\nfor (def i = 0g; true; i += 1g) {\n    printf ('%7d \u00a0%#5o\\n', i, i)\n}\n\n\ndecimal  octal\n      0     00\n      1     01\n      2     02\n      3     03\n      4     04\n      5     05\n      6     06\n      7     07\n      8    010\n      9    011\n     10    012\n     11    013\n     12    014\n     13    015\n     14    016\n     15    017\n     16    020\n     17    021\n...\n", "explain": "Size-limited solution:\nUnbounded solution:\nOutput:\n"}, {"task_name": "Count in octal", "task_url": "https://rosettacode.org/wiki/Count_in_octal", "task_cat": "Iteration", "lang": "AWK", "code": "\n\nBEGIN {\n  for (l = 0; l <= 2147483647; l++) {\n    printf(\"%o\\n\", l);\n  }\n}\n\n", "explain": "The awk extraction and reporting language uses the underlying C library to provide support for the printf command. This enables us to use that function to output the counter value as octal:\n"}]