[{"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nAnalytic[edit]\n\nfrom math import *\n\ndef analytic_fibonacci(n):\n  sqrt_5 = sqrt(5);\n  p = (1 + sqrt_5) / 2;\n  q = 1/p;\n  return int( (p**n + q**n) / sqrt_5 + 0.5 )\n\nfor i in range(1,31):\n  print analytic_fibonacci(i),\n\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\n\nIterative[edit]\ndef fibIter(n):\n    if n < 2:\n        return n\n    fibPrev = 1\n    fib = 1\n    for _ in range(2, n):\n        fibPrev, fib = fib, fib + fibPrev\n    return fib\nIterative positive and negative[edit]\ndef fib(n,x=[0,1]):\n   for i in range(abs(n)-1): x=[x[1],sum(x)]\n   return x[1]*pow(-1,abs(n)-1) if n<0 else x[1] if n else 0\n\nfor i in range(-30,31): print fib(i),\n\n-832040 514229 -317811 196418 -121393 75025 -46368 28657 -17711 10946 -6765 4181 -2584 1597 -987 \n610 -377 233 -144 89 -55 34 -21 13 -8 5 -3 2 -1 1 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 \n1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\n\nRecursive[edit]\ndef fibRec(n):\n    if n < 2:\n        return n\n    else:\n        return fibRec(n-1) + fibRec(n-2)\nRecursive with Memoization[edit]\ndef fibMemo():\n    pad = {0:0, 1:1}\n    def func(n):\n        if n not in pad:\n            pad[n] = func(n-1) + func(n-2)\n        return pad[n]\n    return func\n\nfm = fibMemo()\nfor i in range(1,31):\n    print fm(i),\n\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\n\nBetter Recursive doesn't need Memoization[edit]\n\ndef fibFastRec(n):\n    def fib(prvprv, prv, c):\n        if c < 1: \n            return prvprv\n        else: \n            return fib(prv, prvprv + prv, c - 1) \n    return fib(0, 1, n)\n\nGenerative[edit]\ndef fibGen(n):\n    a, b = 0, 1\n    while n>0:\n        yield a\n        a, b, n = b, a+b, n-1\nExample use[edit]\n>>> [i for i in fibGen(11)]\n\n[0,1,1,2,3,5,8,13,21,34,55]\nMatrix-Based[edit]\n\ndef prevPowTwo(n):\n    'Gets the power of two that is less than or equal to the given input'\n    if ((n & -n) == n):\n        return n\n    else:\n        n -= 1\n        n |= n >> 1\n        n |= n >> 2\n        n |= n >> 4\n        n |= n >> 8\n        n |= n >> 16\n        n += 1\n        return (n/2)\n\ndef crazyFib(n):\n    'Crazy fast fibonacci number calculation'\n    powTwo = prevPowTwo(n)\n    \n    q = r = i = 1\n    s = 0\n    \n    while(i < powTwo):\n        i *= 2\n        q, r, s = q*q + r*r, r * (q + s), (r*r + s*s)\n        \n    while(i < n):\n        i += 1\n        q, r, s = q+r, q, r\n        \n    return q\nLarge step recurrence[edit]\n\ndef fib(n, c={0:1, 1:1}):\n    if n not in c:\n        x = n // 2\n        c[n] = fib(x-1) * fib(n-x-1) + fib(x) * fib(n - x)\n    return c[n]\n\nfib(10000000)  # calculating it takes a few seconds, printing it takes eons\nSame as above but slightly faster[edit]\n\nF = {0: 0, 1: 1, 2: 1}\ndef fib(n):\n    if n in F:\n        return F[n]\n    f1 = fib(n // 2 + 1)\n    f2 = fib((n - 1) // 2)\n    F[n] = (f1 * f1 + f2 * f2 if n & 1 else f1 * f1 - f2 * f2)\n    return F[n]\nGenerative with Recursion[edit]\n\ndef fib():\n    \"\"\"Yield fib[n+1] + fib[n]\"\"\"\n    yield 1  # have to start somewhere\n    lhs, rhs = fib(), fib()\n    yield next(lhs) # move lhs one iteration ahead\n    while True:\n        yield next(lhs)+next(rhs)\n\nf=fib()\nprint [next(f) for _ in range(9)]\n\n[1, 1, 2, 3, 5, 8, 13, 21, 34]\n\nfrom itertools import islice\n\ndef fib():\n    yield 0\n    yield 1\n    a, b = fib(), fib()\n    next(b)\n    while True:\n        yield next(a)+next(b)\n \nprint(tuple(islice(fib(), 10)))\nAs a scan or a fold[edit]\nitertools.accumulate[edit]\n\nWorks with: Python version 3.7\n'''Fibonacci accumulation'''\n\nfrom itertools import accumulate, chain\nfrom operator import add\n\n\n# fibs\u00a0:: Integer\u00a0:: [Integer]\ndef fibs(n):\n    '''An accumulation of the first n integers in\n       the Fibonacci series. The accumulator is a\n       pair of the two preceding numbers.\n    '''\n    def go(ab, _):\n        return ab[1], add(*ab)\n\n    return [xy[1] for xy in accumulate(\n        chain(\n            [(0, 1)],\n            range(1, n)\n        ),\n        go\n    )]\n\n\n# MAIN ---\nif __name__ == '__main__':\n    print(\n        'First twenty: ' + repr(\n            fibs(20)\n        )\n    )\n\nOutput:\nFirst twenty: [1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765]\nfunctools.reduce[edit]\n\nWorks with: Python version 3.7\n'''Nth Fibonacci term (by folding)'''\n\nfrom functools import reduce\nfrom operator import add\n\n\n# nthFib\u00a0:: Integer -> Integer\ndef nthFib(n):\n    '''Nth integer in the Fibonacci series.'''\n    def go(ab, _):\n        return ab[1], add(*ab)\n    return reduce(go, range(1, n), (0, 1))[1]\n\n\n# MAIN ---\nif __name__ == '__main__':\n    print(\n        '1000th term: ' + repr(\n            nthFib(1000)\n        )\n    )\n\nOutput:\n1000th term: 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\nWorks with: Python version 3.9\ndef fib(n):\n    from functools import reduce\n    return reduce(lambda x, y: (x[1], x[0] + x[1]), range(n), (0, 1))[0]\nArray and Range[edit]\nfibseq = [1,1,]\nfiblength = 21\nfor x in range(1,fiblength-1):\n\txcount = fibseq[x-1] + fibseq[x]\n\tfibseq.append(xcount)\nprint(xcount)\n\nOutput:\n10946\n\nMinimal from Russia[edit]\nfi1=fi2=fi3=1 # FIB Russia rextester.com/FEEJ49204\nfor da in range(1, 88): # Danilin\n    print(\".\"*(20-len(str(fi3))), end=' ')\n    print(fi3)\n    fi3 = fi2+fi1\n    fi1 = fi2\n    fi2 = fi3\n\nOutput:\n................... 1\n................... 2\n................... 3\n\n....... 6557470319842\n...... 10610209857723\n...... 17167680177565\n\n.. 420196140727489673\n.. 679891637638612258\n. 1100087778366101931\n", "explain": "Binet's formula: \nOutput:\nOutput:\nOutput:\n\nThe recursive code as written two sections above is incredibly slow and inefficient due to the nested recursion calls.  Although the memoization above makes the code run faster, it is at the cost of extra memory use.  The below code is syntactically recursive but actually encodes the efficient iterative process, and thus doesn't require memoization:\nHowever, although much faster and not requiring memory, the above code can only work to a limited 'n' due to the limit on stack recursion depth by Python; it is better to use the iterative code above or the generative one below.\nTranslation of the matrix-based approach used in F#.\nThis is much faster for a single, large value of n:\nPutting the dictionary outside the function makes this about 2 seconds faster, could just make a wrapper:\nThis can get very slow and uses a lot of memory. Can be sped up by caching the generator results.\nOutput:\nAnother version of recursive generators solution, starting from 0\nThe Fibonacci series can be defined quite simply and efficiently as a scan or accumulation, in which the accumulator is a pair of the two last numbers.\nA fold can be understood as an amnesic scan, and functools.reduce can provide a useful and efficient re-write of the scanning version above, if we only need the Nth term in the series:\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\nRecursive[edit]\nlong long fibb(long long a, long long b, int n) {\n    return (--n>0)?(fibb(b, a+b, n)):(a);\n}\n\nIterative[edit]\nlong long int fibb(int n) {\n\tint fnow = 0, fnext = 1, tempf;\n\twhile(--n>0){\n\t\ttempf = fnow + fnext;\n\t\tfnow = fnext;\n\t\tfnext = tempf;\n\t\t}\n\t\treturn fnext;\t\n}\n\nAnalytic[edit]\n#include <tgmath.h>\n#define PHI ((1 + sqrt(5))/2)\n\nlong long unsigned fib(unsigned n) {\n    return floor( (pow(PHI, n) - pow(1 - PHI, n))/sqrt(5) );\n}\n\nGenerative[edit]\nTranslation of: Python\nWorks with: gcc version version 4.1.2 20080704 (Red Hat 4.1.2-44)\n#include <stdio.h>\ntypedef enum{false=0, true=!0} bool;\ntypedef void iterator;\n\n#include <setjmp.h>\n/* declare label otherwise it is not visible in sub-scope */\n#define LABEL(label) jmp_buf label; if(setjmp(label))goto label;\n#define GOTO(label) longjmp(label, true)\n\n/* the following line is the only time I have ever required \"auto\" */\n#define FOR(i, iterator) { auto bool lambda(i); yield_init = (void *)&lambda; iterator; bool lambda(i)\n#define DO {\n#define     YIELD(x) if(!yield(x))return\n#define     BREAK    return false\n#define     CONTINUE return true\n#define OD CONTINUE; } }\n\nstatic volatile void *yield_init; /* not thread safe */\n#define YIELDS(type) bool (*yield)(type) = yield_init\n\niterator fibonacci(int stop){\n    YIELDS(int);\n    int f[] = {0, 1};\n    int i;\n    for(i=0; i<stop; i++){\n        YIELD(f[i%2]);\n        f[i%2]=f[0]+f[1];\n    }\n}\n\nmain(){\n  printf(\"fibonacci: \");\n  FOR(int i, fibonacci(16)) DO\n    printf(\"%d, \",i);\n  OD;\n  printf(\"...\\n\");\n}\n\n\nOutput:\nfibonacci: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, ...\n\nFast method for a single large value[edit]\n#include <stdlib.h>\n#include <stdio.h>\n#include <gmp.h>\n\ntypedef struct node node;\nstruct node {\n\tint n;\n\tmpz_t v;\n\tnode *next;\n};\n\n#define CSIZE 37\nnode *cache[CSIZE];\n\n// very primitive linked hash table\nnode * find_cache(int n)\n{\n\tint idx = n % CSIZE;\n\tnode *p;\n\n\tfor (p = cache[idx]; p && p->n != n; p = p->next);\n\tif (p) return p;\n\n\tp = malloc(sizeof(node));\n\tp->next = cache[idx];\n\tcache[idx] = p;\n\n\tif (n < 2) {\n\t\tp->n = n;\n\t\tmpz_init_set_ui(p->v, 1);\n\t} else {\n\t\tp->n = -1; // -1: value not computed yet\n\t\tmpz_init(p->v);\n\t}\n\treturn p;\n}\n\nmpz_t tmp1, tmp2;\nmpz_t *fib(int n)\n{\n\tint x;\n\tnode *p = find_cache(n);\n\n\tif (p->n < 0) {\n\t\tp->n = n;\n\t\tx = n / 2;\n\n\t\tmpz_mul(tmp1, *fib(x-1), *fib(n - x - 1));\n\t\tmpz_mul(tmp2, *fib(x), *fib(n - x));\n\t\tmpz_add(p->v, tmp1, tmp2);\n\t}\n\treturn &p->v;\n}\n\nint main(int argc, char **argv)\n{\n\tint i, n;\n\tif (argc < 2) return 1;\n\n\tmpz_init(tmp1);\n\tmpz_init(tmp2);\n\n\tfor (i = 1; i < argc; i++) {\n\t\tn = atoi(argv[i]);\n\t\tif (n < 0) {\n\t\t\tprintf(\"bad input: %s\\n\", argv[i]);\n\t\t\tcontinue;\n\t\t}\n\n\t\t// about 75% of time is spent in printing\n\t\tgmp_printf(\"%Zd\\n\", *fib(n));\n\t}\n\treturn 0;\n}\n\n\nOutput:\n% ./a.out 0 1 2 3 4 5\n1\n1\n2\n3\n5\n8\n% ./a.out 10000000 | wc -c    # count length of output, including the newline\n1919488\n\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <iostream>\n\nint main()\n{\n        unsigned int a = 1, b = 1;\n        unsigned int target = 48;\n        for(unsigned int n = 3; n <= target; ++n)\n        {\n                unsigned int fib = a + b;\n                std::cout << \"F(\"<< n << \") = \" << fib << std::endl;\n                a = b;\n                b = fib;\n        }\n\n        return 0;\n}\n\n\nLibrary: GMP\n\n#include <iostream>\n#include <gmpxx.h>\n\nint main()\n{\n        mpz_class a = mpz_class(1), b = mpz_class(1);\n        mpz_class target = mpz_class(100);\n        for(mpz_class n = mpz_class(3); n <= target; ++n)\n        {\n                mpz_class fib = b + a;\n                if ( fib < b )\n                {\n                        std::cout << \"Overflow at \" << n << std::endl;\n                        break;\n                }\n                std::cout << \"F(\"<< n << \") = \" << fib << std::endl;\n                a = b;\n                b = fib;\n        }\n        return 0;\n}\n\n\n#include <algorithm>\n#include <vector>\n#include <functional>\n#include <iostream>\n \nunsigned int fibonacci(unsigned int n) {\n  if (n == 0) return 0;\n  std::vector<int> v(n+1);\n  v[1] = 1;\n  transform(v.begin(), v.end()-2, v.begin()+1, v.begin()+2, std::plus<int>());\n  // \"v\" now contains the Fibonacci sequence from 0 up\n  return v[n];\n}\n\n#include <numeric>\n#include <vector>\n#include <functional>\n#include <iostream>\n\nunsigned int fibonacci(unsigned int n) {\n  if (n == 0) return 0;\n  std::vector<int> v(n, 1);\n  adjacent_difference(v.begin(), v.end()-1, v.begin()+1, std::plus<int>());\n  // \"array\" now contains the Fibonacci sequence from 1 up\n  return v[n-1];\n}\n\n#include <iostream>\n\ntemplate <int n> struct fibo\n{\n    enum {value=fibo<n-1>::value+fibo<n-2>::value};\n};\n \ntemplate <> struct fibo<0>\n{\n    enum {value=0};\n};\n\ntemplate <> struct fibo<1>\n{\n    enum {value=1};\n};\n\n\nint main(int argc, char const *argv[])\n{\n    std::cout<<fibo<12>::value<<std::endl;\n    std::cout<<fibo<46>::value<<std::endl;\n    return 0;\n}\n\n#include <iostream>\n\ninline void fibmul(int* f, int* g)\n{\n  int tmp = f[0]*g[0] + f[1]*g[1];\n  f[1] = f[0]*g[1] + f[1]*(g[0] + g[1]);\n  f[0] = tmp;\n}\n\nint fibonacci(int n)\n{\n  int f[] = { 1, 0 };\n  int g[] = { 0, 1 };\n  while (n > 0)\n  {\n    if (n & 1) // n odd\n    {\n      fibmul(f, g);\n      --n;\n    }\n    else\n    {\n      fibmul(g, g);\n      n >>= 1;\n    }\n  }\n  return f[1];\n}\n\nint main()\n{\n  for (int i = 0; i < 20; ++i)\n    std::cout << fibonacci(i) << \" \";\n  std::cout << std::endl;\n}\n\nOutput:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181\n\nUsing Zeckendorf Numbers[edit]\n\n// Use Zeckendorf numbers to display Fibonacci sequence.\n// Nigel Galloway October 23rd., 2012\nint main(void) {\n  char NG[22] = {'1',0};\n  int x = -1;\n  N G;\n  for (int fibs = 1; fibs <= 20; fibs++) {\n   for (;G <= N(NG); ++G) x++;\n   NG[fibs] = '0';\n   NG[fibs+1] = 0;\n   std::cout << x << \" \";\n  }\n  std::cout << std::endl;\n  return 0;\n}\n\nOutput:\n1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946\n\nUsing Standard Template Library[edit]\n\n// Use Standard Template Library to display Fibonacci sequence.\n// Nigel Galloway March 30th., 2013\n#include <algorithm>\n#include <iostream>\n#include <iterator>\nint main()\n{\n   int x = 1, y = 1;\n   generate_n(std::ostream_iterator<int>(std::cout, \" \"), 21, [&]{int n=x; x=y; y+=n; return n;});\n   return 0;\n}\n\nOutput:\n\n", "explain": "Using unsigned int, this version only works up to 48 before fib overflows. \n\nThis version does not have an upper bound.\nVersion using transform:\nFar-fetched version using adjacent_difference:\nVersion which computes at compile time with metaprogramming:\nThe following version is based on fast exponentiation:\nThe nth fibonacci is represented as Zeckendorf 1 followed by n-1 zeroes. Here I define a class N which defines the operations increment ++() and comparison <=(other N) for Zeckendorf Numbers.\nPossibly less \"Far-fetched version\".\n1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nIterative[edit]\npublic static long itFibN(int n)\n{\n if (n < 2)\n  return n;\n long ans = 0;\n long n1 = 0;\n long n2 = 1;\n for(n--; n > 0; n--)\n {\n  ans = n1 + n2;\n  n1 = n2;\n  n2 = ans;\n }\n return ans;\n}\n/**\n * O(log(n))\n */\npublic static long fib(long n) {\n    if (n <= 0)\n\treturn 0;\n\n    long i = (int) (n - 1);\n    long a = 1, b = 0, c = 0, d = 1, tmp1,tmp2;\n\n    while (i > 0) {\n\tif (i\u00a0% 2\u00a0!= 0) {\n            tmp1 = d * b + c * a;\n\t    tmp2 = d * (b + a) + c * b;\n\t    a = tmp1;\n\t    b = tmp2;\n\t}\n\n        tmp1 = (long) (Math.pow(c, 2) + Math.pow(d, 2));\n        tmp2 = d * (2 * c + d);\n\t\t\t\n        c = tmp1;\n        d = tmp2;\n\n        i = i / 2;\n    }\n    return a + b;\n}\nRecursive[edit]\npublic static long recFibN(final int n)\n{\n return (n < 2)\u00a0? n\u00a0: recFibN(n - 1) + recFibN(n - 2);\n}\nCaching-recursive[edit]\n\npublic class Fibonacci {\n\n    static final Map<Integer, Long> cache = new HashMap<>();\n    static {\n        cache.put(1, 1L);\n        cache.put(2, 1L);\n    }\n\n    public static long get(int n)\n    {\n        return (n < 2)\u00a0? n\u00a0: impl(n);\n    }\n    \n    private static long impl(int n)\n    {\n        return cache.computeIfAbsent(n, k -> impl(k-1) + impl(k-2));\n    }\n}\nAnalytic[edit]\n\npublic static long anFibN(final long n)\n{\n double p = (1 + Math.sqrt(5)) / 2;\n double q = 1 / p;\n return (long) ((Math.pow(p, n) + Math.pow(q, n)) / Math.sqrt(5));\n}\nTail-recursive[edit]\npublic static long fibTailRec(final int n)\n{\n return fibInner(0, 1, n);\n}\n\nprivate static long fibInner(final long a, final long b, final int n)\n{\n return n < 1\u00a0? a\u00a0: n == 1\u00a0?  b\u00a0: fibInner(b, a + b, n - 1);\n}\nStreams[edit]\nimport java.util.function.LongUnaryOperator;\nimport java.util.stream.LongStream;\n\npublic class FibUtil {\n public static LongStream fibStream() {\n  return LongStream.iterate( 1l, new LongUnaryOperator() {\n   private long lastFib = 0;\n   @Override public long applyAsLong( long operand ) {\n    long ret = operand + lastFib;\n    lastFib = operand;\n    return ret;\n   }\n  });\n }\n public static long fib(long n) {\n  return fibStream().limit( n ).reduce((prev, last) -> last).getAsLong();\n }\n}\n", "explain": "A variant on recursive, that caches previous results, reducing complexity from O(n2) to simply O(n). Leveraging Java\u2019s Map.computeIfAbsent makes this thread-safe, and the implementation pretty trivial.\nThis method works up to the 92nd Fibonacci number. After that, it goes out of range.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nRecursive[edit]\npublic static ulong Fib(uint n) {\n    return (n < 2)? n : Fib(n - 1) + Fib(n - 2);\n}\n\nTail-Recursive[edit]\npublic static ulong Fib(uint n) {\n    return Fib(0, 1, n);\n}\n\nprivate static ulong Fib(ulong a, ulong b, uint n) {\n    return (n < 1)? a :(n == 1)?  b : Fib(b, a + b, n - 1);\n}\n\nIterative[edit]\npublic static ulong Fib(uint x) {\n    if (x == 0) return 0;\n\n    ulong prev = 0;\n    ulong next = 1;\n    for (int i = 1; i < x; i++)\n    {\n        ulong sum = prev + next;\n        prev = next;\n        next = sum;\n    }\n    return next;\n}\n\nIterative[edit]\nusing System; using System.Text; // FIBRUS.cs Russia\nnamespace Fibrus { class Program { static void Main() \n{ long fi1=1; long fi2=1; long fi3=1; int da; int i; int d; \nfor (da=1; da<=78; da++) // rextester.com/MNGUV70257\n    { d = 20-Convert.ToInt32((Convert.ToString(fi3)).Length);\n    for (i=1; i<d; i++) Console.Write(\".\");\nConsole.Write(fi3); Console.Write(\" \"); Console.WriteLine(da);\n    fi3 = fi2 + fi1;\n    fi1 = fi2;\n    fi2 = fi3;\n}}}}\n\n\nOutput:\n..................1 1\n..................2 2\n..................3 3\n...\n...5527939700884757 76\n...8944394323791464 77\n..14472334024676221 78\n\nEager-Generative[edit]\npublic static IEnumerable<long> Fibs(uint x) {\n    IList<ulong> fibs = new List<ulong>();\n\n    ulong prev = -1;\n    ulong next = 1;\n    for (int i = 0; i < x; i++)\n    {\n     long sum = prev + next;\n        prev = next;\n        next = sum;\n        fibs.Add(sum); \n    }\n    return fibs;\n}\n\nLazy-Generative[edit]\npublic static IEnumerable<ulong> Fibs(uint x) {\n    ulong prev = -1;\n    ulong next = 1;\n    for (uint i = 0; i < x; i++) {\n        ulong sum = prev + next;\n        prev = next;\n        next = sum;\n        yield return sum;\n    }\n}\n\nAnalytic[edit]\n\nstatic double r5 = Math.Sqrt(5.0), Phi = (r5 + 1.0) / 2.0;\n\nstatic ulong fib(uint n) {\n    if (n > 71) throw new ArgumentOutOfRangeException(\"n\", n, \"Needs to be smaller than 72.\"); \n    double r = Math.Pow(Phi, n) / r5; \n    return (ulong)(n < 64 ? Math.Round(r) : Math.Floor(r)); }\nTo get to the 93rd Fibonacci number, one must use the decimal type, rather than the double type, like this:static decimal Sqrt_dec(decimal x, decimal g) { decimal t, lg;\n    do { t = x / g; lg = g; g = (t + g) / 2M; } while (lg != g);\n    return g; }\n\nstatic decimal Pow_dec (decimal bas, uint exp) {\n    if (exp == 0) return 1M;\n    decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 1) tmp *= bas; return tmp; }\n\nstatic decimal r5 = Sqrt_dec(5.0M, (decimal)Math.Sqrt(5.0)),\n               Phi = (r5 + 1.0M) / 2.0M;\n\nstatic ulong fib(uint n) {\n    if (n > 93) throw new ArgumentOutOfRangeException(\"n\", n, \"Needs to be smaller than 94.\"); \n    decimal r = Pow_dec(Phi, n) / r5; \n    return (ulong)(n < 64 ? Math.Round(r) : Math.Floor(r)); }\nNote that the Math.Pow() function and the Math.Sqrt() function must be replaced with ones returning the decimal type.If one allows the fib() function to return the decimal type, one can reach the 138th Fibonacci number.  However, the accuracy is lost after the 128th.static decimal Sqrt_dec(decimal x, decimal g) { decimal t, lg;\n    do { t = x / g; lg = g; g = (t + g) / 2M; } while (lg != g);\n    return g; }\n\nstatic decimal Pow_dec (decimal bas, uint exp) {\n    if (exp == 0) return 1M;\n    decimal tmp = Pow_dec(bas, exp >> 1); tmp *= tmp;\n    if ((exp & 1) == 1) tmp *= bas; return tmp; }\n\nstatic decimal r5 = Sqrt_dec(5.0M, (decimal)Math.Sqrt(5.0)),\n               Phi = (r5 + 1.0M) / 2.0M;\n\nstatic decimal fib(uint n) {\n    if (n > 128) throw new ArgumentOutOfRangeException(\"n\", n, \"Needs to be smaller than 129.\"); \n    decimal r = Pow_dec(Phi, n) / r5; \n    return n < 64 ? Math.Round(r) : Math.Floor(r); }\n\nMatrix[edit]\n\n\n\n\n\n\n\n(\n\n\n\n1\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n\n)\n\nn\n\n=\n\n(\n\n\n\nF\n(\nn\n+\n1\n)\n\n\nF\n(\nn\n)\n\n\n\n\nF\n(\nn\n)\n\n\nF\n(\nn\n\u2212\n1\n)\n\n\n\n)\n\n\n\n{\\displaystyle \\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}^n = \\begin{pmatrix}F(n+1)&F(n)\\\\F(n)&F(n-1)\\end{pmatrix}}\n\n.\n\npublic static ulong Fib(uint n) {\n    var M = new Matrix(1,0,0,1);\n    var N = new Matrix(1,1,1,0);\n    for (uint i = 1; i < n; i++) M *= N;\n    return (ulong)M[0][0];\n}\n\n\nprivate static Matrix M;\nprivate static readonly Matrix N = new Matrix(1,1,1,0);\n\npublic static ulong Fib(uint n) {\n    M = new Matrix(1,0,0,1);\n    MatrixPow(n-1);\n    return (ulong)M[0][0];\n}\n\nprivate static void MatrixPow(double n){\n    if (n > 1) {\n        MatrixPow(n/2);\n        M *= M;\n    }\n    if (n % 2 == 0) M *= N;\n}\n\nArray (Table) Lookup[edit]\nprivate static int[] fibs = new int[]{ -1836311903, 1134903170, \n  -701408733, 433494437, -267914296, 165580141, -102334155, \n  63245986, -39088169, 24157817, -14930352, 9227465, -5702887, \n  3524578, -2178309, 1346269, -832040, 514229, -317811, 196418, \n  -121393, 75025, -46368, 28657, -17711, 10946, -6765, 4181, \n  -2584, 1597, -987, 610, -377, 233, -144, 89, -55, 34, -21, 13, \n  -8, 5, -3, 2, -1, 1, 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, \n  144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711,\n  28657, 46368, 75025, 121393, 196418, 317811, 514229, 832040,\n  1346269, 2178309, 3524578, 5702887, 9227465, 14930352, 24157817,\n  39088169, 63245986, 102334155, 165580141, 267914296, 433494437,\n  701408733, 1134903170, 1836311903};\n\npublic static int Fib(int n) {\n    if(n < -46 || n > 46) throw new ArgumentOutOfRangeException(\"n\", n, \"Has to be between -46 and 47.\")\n    return fibs[n+46];\n}\n\nArbitrary Precision[edit]\nLibrary: System.Numerics\n\nusing System;\nusing System.Collections.Generic;\nusing BI = System.Numerics.BigInteger;\n \nclass Program\n{\n    // A sparse array of values calculated along the way\n    static SortedList<int, BI> sl = new SortedList<int, BI>();\n \n    // This routine is semi-recursive, but doesn't need to evaluate every number up to n.\n    // Algorithm from here: http://www.maths.surrey.ac.uk/hosted-sites/R.Knott/Fibonacci/fibFormula.html#section3\n    static BI Fsl(int n)\n    {\n        if (n < 2) return n;\n        int n2 = n >> 1, pm = n2 + ((n & 1) << 1) - 1; IfNec(n2); IfNec(pm);\n        return n2 > pm ? (2 * sl[pm] + sl[n2]) * sl[n2] : sqr(sl[n2]) + sqr(sl[pm]);\n        // Helper routine for Fsl(). It adds an entry to the sorted list when necessary\n        void IfNec(int x) { if (!sl.ContainsKey(x)) sl.Add(x, Fsl(x)); }\n        // Helper function to square a BigInteger\n        BI sqr(BI x) { return x * x; }\n    }\n \n    // Conventional iteration method (not used here)\n    public static BI Fm(BI n)\n    {\n        if (n < 2) return n; BI cur = 0, pre = 1;\n        for (int i = 0; i <= n - 1; i++) { BI sum = cur + pre; pre = cur; cur = sum; }\n        return cur;\n    }\n \n    public static void Main()\n    {\n        int num = 2_000_000, digs = 35, vlen;\n        var sw = System.Diagnostics.Stopwatch.StartNew(); var v = Fsl(num); sw.Stop();\n        Console.Write(\"{0:n3} ms to calculate the {1:n0}th Fibonacci number, \",\n          sw.Elapsed.TotalMilliseconds, num);\n        Console.WriteLine(\"number of digits is {0}\", vlen = (int)Math.Ceiling(BI.Log10(v)));\n        if (vlen < 10000) {\n            sw.Restart(); Console.WriteLine(v); sw.Stop();\n            Console.WriteLine(\"{0:n3} ms to write it to the console.\", sw.Elapsed.TotalMilliseconds);\n        } else\n            Console.Write(\"partial: {0}...{1}\", v / BI.Pow(10, vlen - digs), v % BI.Pow(10, digs));\n    }\n}\n\n\nOutput:\n137.209 ms to calculate the 2,000,000th Fibonacci number, number of digits is 417975\npartial: 85312949175076415430516606545038251...91799493108960825129188777803453125\n\nShift PowerMod[edit]\nLibrary: System.Numerics\n\nusing System;\nusing BI = System.Numerics.BigInteger;\n\nclass Program {\n  \n  // returns the nth Fibonacci number without calculating 0..n-1\n  static BI oneFib(int n) {\n    BI z = (BI)1 << ++n;\n    return BI.ModPow(z, n, (z << n) - z - 1) % z;\n  }\n\n  // returns an array of Fibonacci numbers from the 0th to the nth\n  static BI[] fibTab(int n) {\n    var res = new BI[++n];\n    BI z = (BI)1 << 1, zz = z << 1;\n    for (int i = 0; i < n; ) {\n      res[i] = BI.ModPow(z, ++i, zz - z - 1) % z;\n      z <<= 1; zz <<= 2;\n    }\n    return res;\n  }\n  \n  static void Main(string[] args) {\n    int n = 20;\n    Console.WriteLine(\"Fibonacci numbers 0..{0}: {1}\", n, string.Join(\" \",fibTab(n)));\n    n = 1000;\n    Console.WriteLine(\"Fibonacci({0}): {1}\", n, oneFib(n));\n  }\n}\n\n\nOutput:\nFibonacci numbers 0..20: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765\nFibonacci(1000): 43466557686937456435688527675040625802564660517371780402481729089536555417949051890403879840079255169295922593080322634775209689623239873322471161642996440906533187938298969649928516003704476137795166849228875\n", "explain": "This returns digits up to the 93rd Fibonacci number, but the digits become inaccurate past the 71st. There is custom rounding applied to the result that allows the function to be accurate at the 71st number instead of topping out at the 70th.\nAlgorithm is based on\nNeeds System.Windows.Media.Matrix or similar Matrix class. \nCalculates in \n\n\n\nO\n(\nn\n)\n\n\n{\\displaystyle O(n)}\n\n.\nNeeds System.Windows.Media.Matrix or similar Matrix class. \nCalculates in \n\n\n\nO\n(\nlog\n\u2061\n\nn\n\n)\n\n\n{\\displaystyle O(\\log{n})}\n\n.\nThis large step recurrence routine can calculate the two millionth Fibonacci number in under 1 / 5 second at tio.run.  This routine can generate the fifty millionth Fibonacci number in under 30 seconds at tio.run.  The unused conventional iterative method times out at two million on tio.run, you can only go to around 1,290,000 or so to keep the calculation time (plus string conversion time) under the 60 second timeout limit there.  When using this large step recurrence method, it takes around 5 seconds to convert the two millionth Fibonacci number (417975 digits) into a string (so that one may count those digits).\nIllustrated here is an algorithm to compute a Fibonacci number directly, without needing to calculate any of the Fibonacci numbers less than the desired result.  It uses shifting and the power mod function (BigInteger.ModPow() in C#).  It calculates more quickly than the large step recurrence routine (illustrated above) for smaller Fibonacci numbers (less than 2800 digits or so, around Fibonacci(13000)), but gets slower for larger ones, as the intermediate BigIntegers created are very large, much larger than the Fibonacci result.\nAlso included is a routine that returns an array of Fibonacci numbers (fibTab()).  It reuses the intermediate large shifted BigIntegers on suceeding iterations, therfore it is a little more efficient than calling the oneshot (oneFib()) routine repeatedly from a loop.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\nRecursive[edit]\n\nfunction fib(n) {\n  return n<2?n:fib(n-1)+fib(n-2);\n}\n\nfunction fib(n) {\n if (n<2) { return n; } else { return fib(n-1)+fib(n-2); }\n}\n\nfunction fib(n) {\n  return function(n,a,b) {\n    return n>0\u00a0? arguments.callee(n-1,b,a+b)\u00a0: a;\n  }(n,0,1);\n}\nIterative[edit]\nfunction fib(n) {\n  var a = 0, b = 1, t;\n  while (n-- > 0) {\n    t = a;\n    a = b;\n    b += t;\n    console.log(a);\n  }\n  return a;\n}\nMemoization[edit]\n\nvar fib = (function(cache){\n    return cache = cache || {}, function(n){\n        if (cache[n]) return cache[n];\n        else return cache[n] = n == 0\u00a0? 0\u00a0: n < 0\u00a0? -fib(-n)\n           \u00a0: n <= 2\u00a0? 1\u00a0: fib(n-2) + fib(n-1);\n    };\n})();\n\n(function () {\n    'use strict';\n\n    function fib(n) {\n        return Array.apply(null, Array(n + 1))\n            .map(function (_, i, lst) {\n                return lst[i] = (\n                    i\u00a0? i < 2\u00a0? 1\u00a0:\n                    lst[i - 2] + lst[i - 1]\u00a0:\n                    0\n                );\n            })[n];\n    }\n\n    return fib(32);\n\n})();\n\n\nOutput:\n2178309\nY-Combinator[edit]\nfunction Y(dn) {\n    return (function(fn) {\n        return fn(fn);\n    }(function(fn) {\n        return dn(function() {\n            return fn(fn).apply(null, arguments);\n        });\n    }));\n}\nvar fib = Y(function(fn) {\n    return function(n) {\n        if (n === 0 || n === 1) {\n            return n;\n        }\n        return fn(n - 1) + fn(n - 2);\n    };\n});\nGenerators[edit]\nfunction* fibonacciGenerator() {\n    var prev = 0;\n    var curr = 1;\n    while (true) {\n        yield curr;\n        curr = curr + prev;\n        prev = curr - prev;\n    }\n}\nvar fib = fibonacciGenerator();\nES6[edit]\nMemoized[edit]\n\n(() => {\n    'use strict';\n\n    // Nth member of fibonacci series\n\n    // fib\u00a0:: Int -> Int\n    function fib(n) {\n        return mapAccumL(([a, b]) => [\n            [b, a + b], b\n        ], [0, 1], range(1, n))[0][0];\n    };\n\n    // GENERIC FUNCTIONS\n\n    // mapAccumL\u00a0:: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\n    let mapAccumL = (f, acc, xs) => {\n        return xs.reduce((a, x) => {\n            let pair = f(a[0], x);\n\n            return [pair[0], a[1].concat(pair[1])];\n        }, [acc, []]);\n    }\n\n    // range\u00a0:: Int -> Int -> Maybe Int -> [Int]\n    let range = (m, n) =>\n        Array.from({\n            length: Math.floor(n - m) + 1\n        }, (_, i) => m + i);\n\n\n    // TEST\n    return fib(32);\n\n    // --> 2178309\n})();\n\nTranslation of: Haskell (Memoized fold example)\n(() => {\n    'use strict';\n\n    // fib\u00a0:: Int -> Int\n    let fib = n => range(1, n)\n        .reduce(([a, b]) => [b, a + b], [0, 1])[0];\n\n\n    // GENERIC [m..n]\n\n    // range\u00a0:: Int -> Int -> [Int]\n    let range = (m, n) =>\n        Array.from({\n            length: Math.floor(n - m) + 1\n        }, (_, i) => m + i);\n\n\n    // TEST\n    return fib(32);\n\n    // --> 2178309\n})();\n\nOutput:\n2178309\n", "explain": "Basic recursive function:\nCan be rewritten as:\nOne possibility familiar to Scheme programmers is to define an internal function for iteration through anonymous tail recursion:\nWith the keys of a dictionary,\nwith the indices of an array,\n\nIf we want access to the whole preceding series, as well as a memoized route to a particular member, \nwe can use an accumulating fold.\nOtherwise, a simple fold will suffice.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "SQL", "code": "\nAnalytic[edit]\n\nselect round ( exp ( sum (ln ( ( 1 + sqrt( 5 ) ) / 2)\n        ) over ( order by level ) ) / sqrt( 5 ) ) fibo\nfrom dual\nconnect by level <= 10;\n       FIB\n----------\n         1\n         1\n         2\n         3\n         5\n         8\n        13\n        21\n        34\n        55\n\n10 rows selected.\n\n\nselect round ( power( ( 1 + sqrt( 5 ) ) / 2, level ) / sqrt( 5 ) ) fib\nfrom dual\nconnect by level <= 10;\n       FIB\n----------\n         1\n         1\n         2\n         3\n         5\n         8\n        13\n        21\n        34\n        55\n\n10 rows selected.\n\nRecursive[edit]\nWorks with: Oracle\n\nSQL> with fib(e,f) as (select 1, 1 from dual union all select e+f,e from fib where e <= 55) select f from fib;\n\n         F\n----------\n         1\n         1\n         2\n         3\n         5\n         8\n        13\n        21\n        34\n        55\n\n10 rows selected.\nWorks with: PostgreSQL\nCREATE FUNCTION fib(n int) RETURNS numeric AS $$\n    -- This recursive with generates endless list of Fibonacci numbers.\n    WITH RECURSIVE fibonacci(current, previous) AS (\n        -- Initialize the current with 0, so the first value will be 0.\n        -- The previous value is set to 1, because its only goal is not\n        -- special casing the zero case, and providing 1 as the second\n        -- number in the sequence.\n        --\n        -- The numbers end with dots to make them numeric type in\n        -- Postgres. Numeric type has almost arbitrary precision\n        -- (technically just 131,072 digits, but that's good enough for\n        -- most purposes, including calculating huge Fibonacci numbers)\n        SELECT 0., 1.\n    UNION ALL\n        -- To generate Fibonacci number, we need to add together two\n        -- previous Fibonacci numbers. Current number is saved in order\n        -- to be accessed in the next iteration of recursive function.\n        SELECT previous + current, current FROM fibonacci\n    )\n    -- The user is only interested in current number, not previous.\n    SELECT current FROM fibonacci\n    -- We only need one number, so limit to 1\n    LIMIT 1\n    -- Offset the query by the requested argument to get the correct\n    -- position in the list.\n    OFFSET n\n$$ LANGUAGE SQL RETURNS NULL ON NULL INPUT IMMUTABLE;\n", "explain": "As a running sum:\nAs a power:\nOracle 12c required\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nIterative[edit]\nfunction fibIter($n) {\n    if ($n < 2) {\n        return $n;\n    }\n    $fibPrev = 0;\n    $fib = 1;\n    foreach (range(1, $n-1) as $i) {\n        list($fibPrev, $fib) = array($fib, $fib + $fibPrev);\n    }\n    return $fib;\n}\nRecursive[edit]\nfunction fibRec($n) {\n    return $n < 2\u00a0? $n\u00a0: fibRec($n-1) + fibRec($n-2);\n}\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\nMatrix[edit]\nTranslation of: Julia\nfunction f = fib(n)\n\t\n\tf = [1 1\u00a0; 1 0]^(n-1);\n\tf = f(1,1);\n\t\nend\nIterative[edit]\nfunction F = fibonacci(n)\n    \n    Fn = [1 0]; %Fn(1) is F_{n-2}, Fn(2) is F_{n-1} \n    F = 0; %F is F_{n}\n    \n    for i = (1:abs(n))\n        Fn(2) = F;\n        F = sum(Fn);\n        Fn(1) = Fn(2);\n    end\n        \n    if n < 0\n        F = F*((-1)^(n+1));\n    end   \n\nend\nDramadah Matrix Method[edit]\n\nfunction number = fibonacci2(n)\n    \n    if n == 1\n        number = 1;\n    elseif n == 0\n        number = 0;\n    elseif n < 0\n        number = ((-1)^(n+1))*fibonacci2(-n);;\n    else\n        number = det(gallery('dramadah',n,3));\n    end\n\nend\nTartaglia/Pascal Triangle Method[edit]\nfunction number = fibonacci(n)\n%construct the Tartaglia/Pascal Triangle\n    pt=tril(ones(n));\n    for r = 3\u00a0: n\n   \u00a0% Every element is the addition of the two elements\n   \u00a0% on top of it. That means the previous row.\n        for c = 2\u00a0: r-1\n            pt(r, c) = pt(r-1, c-1) + pt(r-1, c);\n        end   \n    end\n    number=trace(rot90(pt));\nend\n", "explain": "The MATLAB help file suggests an interesting method of generating the Fibonacci numbers. Apparently the determinate of the Dramadah Matrix of type 3 (MATLAB designation) and size n-by-n is the nth Fibonacci number. This method is implimented below.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nFORTRAN IV[edit]\nC     FIBONACCI SEQUENCE - FORTRAN IV\n      NN=46\n      DO 1 I=0,NN\n    1 WRITE(*,300) I,IFIBO(I)\n  300 FORMAT(1X,I2,1X,I10)\n      END\nC\n      FUNCTION IFIBO(N)\n      IF(N) 9,1,2\n    1 IFN=0\n      GOTO 9\n    2 IF(N-1) 9,3,4\n    3 IFN=1\n      GOTO 9\n    4 IFNM1=0\n      IFN=1\n      DO 5 I=2,N\n      IFNM2=IFNM1\n      IFNM1=IFN\n    5 IFN=IFNM1+IFNM2\n    9 IFIBO=IFN\n      END\n\nOutput:\n  0          0\n  1          1\n  2          1\n  3          2\n  4          3\n  5          5\n  6          8\n  7         13\n  8         21\n  9         34\n 10         55\n...\n 45 1134903170\n 46 1836311903\n\nFORTRAN 77[edit]\n      FUNCTION IFIB(N)\n      IF (N.EQ.0) THEN\n        ITEMP0=0\n      ELSE IF (N.EQ.1) THEN\n        ITEMP0=1\n      ELSE IF (N.GT.1) THEN\n        ITEMP1=0\n        ITEMP0=1\n        DO 1 I=2,N\n          ITEMP2=ITEMP1\n          ITEMP1=ITEMP0\n          ITEMP0=ITEMP1+ITEMP2\n    1   CONTINUE\n      ELSE\n        ITEMP1=1\n        ITEMP0=0\n        DO 2 I=-1,N,-1\n          ITEMP2=ITEMP1\n          ITEMP1=ITEMP0\n          ITEMP0=ITEMP2-ITEMP1\n    2   CONTINUE\n      END IF\n      IFIB=ITEMP0\n      END\n\n      EXTERNAL IFIB\n      CHARACTER*10 LINE\n      PARAMETER ( LINE = '----------' )\n      WRITE(*,900) 'N', 'F[N]', 'F[-N]'\n      WRITE(*,900) LINE, LINE, LINE\n      DO 1 N = 0, 10\n        WRITE(*,901) N, IFIB(N), IFIB(-N)\n    1 CONTINUE\n  900 FORMAT(3(X,A10))\n  901 FORMAT(3(X,I10))\n      END\n\nOutput:\n          N       F[N]      F[-N]\n ---------- ---------- ----------\n          0          0          0\n          1          1          1\n          2          1         -1\n          3          2          2\n          4          3         -3\n          5          5          5\n          6          8         -8\n          7         13         13\n          8         21        -21\n          9         34         34\n         10         55        -55\n\nRecursive[edit]\n\nmodule fibonacci\ncontains\n    recursive function fibR(n) result(fib)\n        integer, intent(in)\u00a0:: n\n        integer            \u00a0:: fib\n        \n        select case (n)\n            case (:0);      fib = 0\n            case (1);       fib = 1\n            case default;   fib = fibR(n-1) + fibR(n-2)\n        end select\n    end function fibR\nIterative[edit]\n\n    function fibI(n)\n        integer, intent(in)\u00a0:: n\n        integer, parameter\u00a0:: fib0 = 0, fib1 = 1\n        integer           \u00a0:: fibI, back1, back2, i\n \n        select case (n)\n            case (:0);      fibI = fib0\n            case (1);       fibI = fib1\n     \n            case default\n                fibI = fib1\n                back1 = fib0\n                do i = 2, n\n                    back2 = back1\n                    back1 = fibI\n                    fibI   = back1 + back2\n                end do\n         end select\n    end function fibI\nend module fibonacci\n\nprogram fibTest\n    use fibonacci\n    \n    do i = 0, 10\n        print *, fibr(i), fibi(i)\n    end do \nend program fibTest\n\nOutput:\n0 0\n1 1\n1 1\n2 2\n3 3\n5 5\n8 8\n13 13\n21 21\n34 34\n55 55\n\n", "explain": "Test program\nIn ISO Fortran 90 or later, use a RECURSIVE function:\nIn ISO Fortran 90 or later:\nTest program\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\nRecursive[edit]\nfunc fib(a int) int {\n  if a < 2 {\n    return a\n  }\n  return fib(a - 1) + fib(a - 2)\n}\nIterative[edit]\nimport (\n\t\"math/big\"\n)\n\nfunc fib(n uint64) *big.Int {\n\tif n < 2 {\n\t\treturn big.NewInt(int64(n))\n\t}\n\ta, b\u00a0:= big.NewInt(0), big.NewInt(1)\n\tfor n--; n > 0; n-- {\n\t\ta.Add(a, b)\n\t\ta, b = b, a\n\t}\n\treturn b\n}\nIterative using a closure[edit]\nfunc fibNumber() func() int {\n\tfib1, fib2\u00a0:= 0, 1\n\treturn func() int {\n\t\tfib1, fib2 = fib2, fib1 + fib2\n\t\treturn fib1\n\t}\n}\n\nfunc fibSequence(n int) int {\n\tf\u00a0:= fibNumber()\n\tfib\u00a0:= 0\n\tfor i\u00a0:= 0; i < n; i++ {\n\t\tfib = f()\n\t}\n\treturn fib\n}\nUsing a goroutine and channel[edit]\nfunc fib(c chan int) {\n\ta, b\u00a0:= 0, 1\n\tfor {\n\t\tc <- a\n\t\ta, b = b, a+b\n\t}\n}\n\nfunc main() {\n\tc\u00a0:= make(chan int)\n\tgo fib(c)\n\tfor i\u00a0:= 0; i < 10; i++ {\n\t\tfmt.Println(<-c)\n\t}\n}\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\n\nfibonacci:\n        push  {r1-r3}\n        mov   r1,  #0\n        mov   r2,  #1\n        \nfibloop:\n        mov   r3,  r2\n        add   r2,  r1,  r2\n        mov   r1,  r3\n        sub   r0,  r0,  #1\n        cmp   r0,  #1\n        bne   fibloop\n        \n        mov   r0,  r2\n        pop   {r1-r3}\n        mov   pc,  lr\n", "explain": "Expects to be called with \n\n\n\nn\n\n\n{\\displaystyle n}\n\n in R0, and will return \n\n\n\nf\n(\nn\n)\n\n\n{\\displaystyle f(n)}\n\n in the same register.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "MIPS_Assembly", "code": "\n\n\t.text\nmain:\tli\t$v0, 5\t\t# read integer from input. The read integer will be stroed in $v0\n\tsyscall\n\t\n\tbeq\t$v0, 0, is1\n\tbeq\t$v0, 1,\tis1\t\n\t\n\tli\t$s4, 1\t\t# the counter which has to equal to $v0\t\n\t\t\n\tli\t$s0, 1\n\tli\t$s1, 1\n\nloop:\tadd\t$s2, $s0, $s1\n\taddi\t$s4, $s4, 1\n\tbeq\t$v0, $s4, iss2\n\t\n\tadd\t$s0, $s1, $s2\n\taddi\t$s4, $s4, 1\n\tbeq\t$v0, $s4, iss0\n\t\n\tadd\t$s1, $s2, $s0\n\taddi\t$s4, $s4, 1\n\tbeq\t$v0, $s4, iss1\n\n\tb \tloop\n\niss0:\tmove\t$a0, $s0\t\n\tb\tprint\n\niss1:\tmove\t$a0, $s1\t\n\tb\tprint\n\niss2:\tmove\t$a0, $s2\t\n\tb\tprint\n\t\n\t\nis1:\tli\t$a0, 1\n\tb \tprint\n\t\nprint:\tli\t$v0, 1\n\tsyscall\n\tli\t$v0, 10\n\tsyscall\n", "explain": "This is the iterative approach to the Fibonacci sequence.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nIterative[edit]\nfunction FibonacciI(N: Word): UInt64;\nvar\n  Last, New: UInt64;\n  I: Word;\nbegin\n  if N < 2 then\n    Result\u00a0:= N\n  else begin\n    Last\u00a0:= 0;\n    Result\u00a0:= 1;\n    for I\u00a0:= 2 to N do\n    begin\n      New\u00a0:= Last + Result;\n      Last\u00a0:= Result;\n      Result\u00a0:= New;\n    end;\n  end;\nend;\nRecursive[edit]\nfunction Fibonacci(N: Word): UInt64;\nbegin\n  if N < 2 then\n    Result\u00a0:= N\n  else\n   Result\u00a0:= Fibonacci(N - 1) + Fibonacci(N - 2);\nend;\nMatrix[edit]\n\n\n\n\n\n\n\n(\n\n\n\n1\n\n\n1\n\n\n\n\n1\n\n\n0\n\n\n\n)\n\nn\n\n=\n\n(\n\n\n\nF\n(\nn\n+\n1\n)\n\n\nF\n(\nn\n)\n\n\n\n\nF\n(\nn\n)\n\n\nF\n(\nn\n\u2212\n1\n)\n\n\n\n)\n\n\n\n{\\displaystyle \\begin{pmatrix}1&1\\\\1&0\\end{pmatrix}^n = \\begin{pmatrix}F(n+1)&F(n)\\\\F(n)&F(n-1)\\end{pmatrix}}\n\n.\nfunction fib(n: Int64): Int64;\n\n  type TFibMat = array[0..1] of array[0..1] of Int64;\n\t\n  function FibMatMul(a,b: TFibMat): TFibMat;\n  var i,j,k: integer;\n      tmp: TFibMat;\n  begin\n    for i\u00a0:= 0 to 1 do\n      for j\u00a0:= 0 to 1 do\n      begin\n\ttmp[i,j]\u00a0:= 0;\n\tfor k\u00a0:= 0 to 1 do tmp[i,j]\u00a0:= tmp[i,j] + a[i,k] * b[k,j];\n      end;\n    FibMatMul\u00a0:= tmp;\n  end;\n\t\n  function FibMatExp(a: TFibMat; n: Int64): TFibmat;\n  begin\n    if n <= 1 then fibmatexp\u00a0:= a\n    else if (n mod 2 = 0) then FibMatExp\u00a0:= FibMatExp(FibMatMul(a,a), n div 2)\n    else if (n mod 2 = 1) then FibMatExp\u00a0:= FibMatMul(a, FibMatExp(FibMatMul(a,a), n div 2));\n  end;\n\nvar \n  matrix: TFibMat;\n\t\nbegin\n  matrix[0,0]\u00a0:= 1;\n  matrix[0,1]\u00a0:= 1;\n  matrix[1,0]\u00a0:= 1;\n  matrix[1,1]\u00a0:= 0;\n  if n > 1 then\n    matrix\u00a0:= fibmatexp(matrix,n-1);\n  fib\u00a0:= matrix[0,0];\nend;\n", "explain": "Algorithm is based on\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nIterative[edit]\ndef fib(n)\n  if n < 2\n    n\n  else\n    prev, fib = 0, 1\n    (n-1).times do\n      prev, fib = fib, fib + prev\n    end\n    fib\n  end\nend\n\np (0..10).map { |i| fib(i) }\n\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\nRecursive[edit]\ndef fib(n, sequence=[1])\n  return sequence.last if n == 0\n\n  current_number, last_number = sequence.last(2)\n  sequence << current_number + (last_number or 0)\n\n  fib(n-1, sequence)\nend\nRecursive with Memoization[edit]\n# Use the Hash#default_proc feature to\n# lazily calculate the Fibonacci numbers.\n\nfib = Hash.new do |f, n|\n  f[n] = if n <= -2\n           (-1)**(n + 1) * f[n.abs]\n         elsif n <= 1\n           n.abs\n         else\n           f[n - 1] + f[n - 2]\n         end\nend\n# examples: fib[10] => 55, fib[-10] => (-55/1)\nMatrix[edit]\nrequire 'matrix'\n\n# To understand why this matrix is useful for Fibonacci numbers, remember\n# that the definition of Matrix.**2 for any Matrix[[a, b], [c, d]] is\n# is [[a*a + b*c, a*b + b*d], [c*a + d*b, c*b + d*d]].  In other words, the\n# lower right element is computing F(k - 2) + F(k - 1) every time M is multiplied\n# by itself (it is perhaps easier to understand this by computing M**2, 3, etc, and\n# watching the result march up the sequence of Fibonacci numbers).\n\nM = Matrix[[0, 1], [1,1]]\n\n# Matrix exponentiation algorithm to compute Fibonacci numbers.\n# Let M be Matrix [[0, 1], [1, 1]].  Then, the lower right element of M**k is\n# F(k + 1).  In other words, the lower right element of M is F(2) which is 1, and the\n# lower right element of M**2 is F(3) which is 2, and the lower right element\n# of M**3 is F(4) which is 3, etc.\n#\n# This is a good way to compute F(n) because the Ruby implementation of Matrix.**(n)\n# uses O(log n) rather than O(n) matrix multiplications.  It works by squaring squares\n# ((m**2)**2)... as far as possible\n# and then multiplying that by by M**(the remaining number of times).  E.g., to compute\n# M**19, compute partial = ((M**2)**2) = M**16, and then compute partial*(M**3) = M**19.\n# That's only 5 matrix multiplications of M to compute M*19. \ndef self.fib_matrix(n)\n  return 0 if n <= 0 # F(0)\n  return 1 if n == 1 # F(1)\n  # To get F(n >= 2), compute M**(n - 1) and extract the lower right element.\n  return CS::lower_right(M**(n - 1))\nend\n\n# Matrix utility to return\n# the lower, right-hand element of a given matrix.\ndef self.lower_right matrix\n  return nil if matrix.row_size == 0\n  return matrix[matrix.row_size - 1, matrix.column_size - 1]\nend\nGenerative[edit]\nfib = Enumerator.new do |y|\n  f0, f1 = 0, 1\n  loop do\n    y <<  f0\n    f0, f1 = f1, f0 + f1\n  end\nend\n\np fib.lazy.drop(8).next # => 21\nWorks with: Ruby version 1.9\n\nfib = Fiber.new do\n  a,b = 0,1\n  loop do\n    Fiber.yield a\n    a,b = b,a+b\n  end\nend\n9.times {puts fib.resume}\n\ndef fib_gen\n    a, b = 1, 1\n    lambda {ret, a, b = a, b, a+b; ret}\nend\nirb(main):034:0> fg = fib_gen\n=> #<Proc:0xb7cdf750@(irb):22>\nirb(main):035:0> 9.times { puts fg.call}\n1\n1\n2\n3\n5\n8\n13\n21\n34\n=> 9\n\nBinet's Formula[edit]\ndef fib\n    phi = (1 + Math.sqrt(5)) / 2\n    ((phi**self - (-1 / phi)**self) / Math.sqrt(5)).to_i\nend\n1.9.3p125 :001 > def fib\n1.9.3p125 :002?>   phi = (1 + Math.sqrt(5)) / 2\n1.9.3p125 :003?>   ((phi**self - (-1 / phi)**self) / Math.sqrt(5)).to_i\n1.9.3p125 :004?>   end\n => nil \n1.9.3p125 :005 > (0..10).map(&:fib)\n => [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55]\n\n", "explain": "Output:\nUsage:\n\"Fibers are primitives for implementing light weight cooperative concurrency in Ruby. Basically they are a means of creating code blocks that can be paused and resumed, much like threads. The main difference is that they are never preempted and that the scheduling must be done by the programmer and not the VM.\" [2]\nusing a lambda\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nIterative[edit]\nfn main() {\n    let mut prev = 0;\n    // Rust needs this type hint for the checked_add method\n    let mut curr = 1usize;\n\n    while let Some(n) = curr.checked_add(prev) {\n        prev = curr;\n        curr = n;\n        println!(\"{}\", n);\n    }\n}\nRecursive[edit]\nuse std::mem;\nfn main() {\n    fibonacci(0,1);\n}\n\nfn fibonacci(mut prev: usize, mut curr: usize) {\n    mem::swap(&mut prev, &mut curr);\n    if let Some(n) = curr.checked_add(prev) {\n        println!(\"{}\", n);\n        fibonacci(prev, n);\n    }\n}\nRecursive (with pattern matching)[edit]\nfn fib(n: u32) -> u32 {\n    match n {\n        0 => 0,\n        1 => 1,\n        n => fib(n - 1) + fib(n - 2),\n    }\n}\nTail recursive (with pattern matching)[edit]\nfn fib_tail_recursive(nth: usize) -> usize {\n  fn fib_tail_iter(n: usize, prev_fib: usize, fib: usize) -> usize {\n    match n {\n      0 => prev_fib,\n      n => fib_tail_iter(n - 1, fib, prev_fib + fib),\n    }\n  }\n  fib_tail_iter(nth, 0, 1)\n}\nAnalytic[edit]\nfn main() {\n    for num in fibonacci_sequence() {\n        println!(\"{}\", num);\n    }\n}\n\nfn fibonacci_sequence() -> impl Iterator<Item = u64> {\n    let sqrt_5 = 5.0f64.sqrt();\n    let p = (1.0 + sqrt_5) / 2.0;\n    let q = 1.0 / p;\n    // The range is sufficient up to 70th Fibonacci number\n    (0..1).chain((1..70).map(move |n| ((p.powi(n) + q.powi(n)) / sqrt_5 + 0.5) as u64))\n}\nUsing an Iterator[edit]\n\nuse std::mem;\n\nstruct Fib {\n    prev: usize,\n    curr: usize,\n} \n\nimpl Fib {\n    fn new() -> Self {\n        Fib {prev: 0, curr: 1}\n    }\n}\n\nimpl Iterator for Fib {\n    type Item = usize;\n    fn next(&mut self) -> Option<Self::Item>{\n        mem::swap(&mut self.curr, &mut self.prev);\n        self.curr.checked_add(self.prev).map(|n| { \n            self.curr = n;\n            n\n        })\n    }\n}\n\nfn main() {\n    for num in Fib::new() {\n        println!(\"{}\", num);\n    }\n}\n\nIterator \"Successors\"[edit]\nfn main() {\n    std::iter::successors(Some((1u128, 0)), |&(a, b)| a.checked_add(b).map(|s| (b, s)))\n        .for_each(|(_, u)| println!(\"{}\", u));\n}\n\n", "explain": "Iterators are very idiomatic in rust, though they may be overkill for such a simple problem.\n\n\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nAnalytic[edit]\nimport Cocoa\n\nfunc fibonacci(n: Int) -> Int {\n    let square_root_of_5 = sqrt(5.0)\n    let p = (1 + square_root_of_5) / 2\n    let q = 1 / p\n    return Int((pow(p,CDouble(n)) + pow(q,CDouble(n))) / square_root_of_5 + 0.5)\n}\n\nfor i in 1...30 {\n    println(fibonacci(i))\n}\nIterative[edit]\nfunc fibonacci(n: Int) -> Int {\n    if n < 2 {\n        return n\n    }\n    var fibPrev = 1\n    var fib = 1\n    for num in 2...n {\n        (fibPrev, fib) = (fib, fib + fibPrev)\n    }\n    return fib\n}\n\nfunc fibonacci() -> SequenceOf<UInt> {\n  return SequenceOf {() -> GeneratorOf<UInt> in\n    var window: (UInt, UInt, UInt) = (0, 0, 1)\n    return GeneratorOf {\n      window = (window.1, window.2, window.1 + window.2)\n      return window.0\n    }\n  }\n}\nRecursive[edit]\nfunc fibonacci(n: Int) -> Int {\n    if n < 2 {\n        return n\n    } else {\n        return fibonacci(n-1) + fibonacci(n-2)\n    }\n}\n\nprintln(fibonacci(30))\n", "explain": "Sequence:\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nIterative positive and negative[edit]\nfib=function(n,x=c(0,1)) {\n   if (abs(n)>1) for (i in seq(abs(n)-1)) x=c(x[2],sum(x))\n   if (n<0) return(x[2]*(-1)^(abs(n)-1)) else if (n) return(x[2]) else return(0)\n}  \n\nsapply(seq(-31,31),fib)\n\n [1] 1346269 -832040  514229 -317811  196418 -121393   75025  -46368   28657\n[10]  -17711   10946   -6765    4181   -2584    1597    -987     610    -377\n[19]     233    -144      89     -55      34     -21      13      -8       5\n[28]      -3       2      -1       1       0       1       1       2       3\n[37]       5       8      13      21      34      55      89     144     233\n[46]     377     610     987    1597    2584    4181    6765   10946   17711\n[55]   28657   46368   75025  121393  196418  317811  514229  832040 1346269\n\nOther methods[edit]\n# recursive\nrecfibo <- function(n) {\n  if ( n < 2 ) n\n  else Recall(n-1) + Recall(n-2)\n}\n\n# print the first 21 elements\nprint.table(lapply(0:20, recfibo))\n\n# iterative\niterfibo <- function(n) {\n  if ( n < 2 )\n    n\n  else {\n    f <- c(0, 1)\n    for (i in 2:n) {\n      t <- f[2]\n      f[2] <- sum(f)\n      f[1] <- t\n    }\n    f[2]\n  }\n}\n\nprint.table(lapply(0:20, iterfibo))\n\n# iterative but looping replaced by map-reduce'ing\nfuncfibo <- function(n) {\n  if (n < 2) \n    n\n  else {\n    generator <- function(f, ...) {\n      c(f[2], sum(f))\n    }\n    Reduce(generator, 2:n, c(0,1))[2]\n  }\n}\n\nprint.table(lapply(0:20, funcfibo))\n\n\nOutput:\n\n [1] 0    1    1    2    3    5    8    13   21   34   55   89   144  233  377 \n[16] 610  987  1597 2584 4181 6765\n", "explain": "Output:\nNote that an idiomatic way to implement such low level, basic arithmethic operations in R is to implement them C and then call the compiled code.\nAll three solutions print\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\nIterative[edit]\nProgram-ID. Fibonacci-Sequence.\nData Division.\nWorking-Storage Section.\n  01  FIBONACCI-PROCESSING.\n    05  FIBONACCI-NUMBER  PIC 9(36)   VALUE 0.\n    05  FIB-ONE           PIC 9(36)   VALUE 0.\n    05  FIB-TWO           PIC 9(36)   VALUE 1.\n  01  DESIRED-COUNT       PIC 9(4).\n  01  FORMATTING.\n    05  INTERM-RESULT     PIC Z(35)9.\n    05  FORMATTED-RESULT  PIC X(36).\n    05  FORMATTED-SPACE   PIC x(35).\nProcedure Division.\n  000-START-PROGRAM.\n    Display \"What place of the Fibonacci Sequence would you like (<173)? \" with no advancing.\n    Accept DESIRED-COUNT.\n    If DESIRED-COUNT is less than 1\n      Stop run.\n    If DESIRED-COUNT is less than 2\n      Move FIBONACCI-NUMBER to INTERM-RESULT\n      Move INTERM-RESULT to FORMATTED-RESULT\n      Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT\n      Display FORMATTED-RESULT\n      Stop run.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\n    Perform 100-COMPUTE-FIBONACCI until DESIRED-COUNT = zero.\n    Stop run.\n  100-COMPUTE-FIBONACCI.\n    Compute FIBONACCI-NUMBER = FIB-ONE + FIB-TWO.\n    Move FIB-TWO to FIB-ONE.\n    Move FIBONACCI-NUMBER to FIB-TWO.\n    Subtract 1 from DESIRED-COUNT.\n    Move FIBONACCI-NUMBER to INTERM-RESULT.\n    Move INTERM-RESULT to FORMATTED-RESULT.\n    Unstring FORMATTED-RESULT delimited by all spaces into FORMATTED-SPACE,FORMATTED-RESULT.\n    Display FORMATTED-RESULT.\nRecursive[edit]\nWorks with: GNU Cobol version 2.0\n       >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. fibonacci-main.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  num                                 PIC 9(6) COMP.\n01  fib-num                             PIC 9(6) COMP.\n\nPROCEDURE DIVISION.\n    ACCEPT num\n    CALL \"fibonacci\" USING CONTENT num RETURNING fib-num\n    DISPLAY fib-num\n    .\nEND PROGRAM fibonacci-main.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. fibonacci RECURSIVE.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  1-before                            PIC 9(6) COMP.\n01  2-before                            PIC 9(6) COMP.\n\nLINKAGE SECTION.\n01  num                                 PIC 9(6) COMP.\n\n01  fib-num                             PIC 9(6) COMP BASED.\n\nPROCEDURE DIVISION USING num RETURNING fib-num.\n    ALLOCATE fib-num\n    EVALUATE num\n        WHEN 0\n            MOVE 0 TO fib-num\n        WHEN 1\n            MOVE 1 TO fib-num\n        WHEN OTHER\n            SUBTRACT 1 FROM num\n            CALL \"fibonacci\" USING CONTENT num RETURNING 1-before\n            SUBTRACT 1 FROM num\n            CALL \"fibonacci\" USING CONTENT num RETURNING 2-before\n            ADD 1-before TO 2-before GIVING fib-num\n    END-EVALUATE\n    .\nEND PROGRAM fibonacci.\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nRecursive[edit]\nwith Ada.Text_IO, Ada.Command_Line;\n\nprocedure Fib is\n\n   X: Positive := Positive'Value(Ada.Command_Line.Argument(1));\n\n   function Fib(P: Positive) return Positive is\n   begin\n      if P <= 2 then\n         return 1;\n      else\n         return Fib(P-1) + Fib(P-2);\n      end if;\n   end Fib;\n\nbegin\n   Ada.Text_IO.Put(\"Fibonacci(\" & Integer'Image(X) & \" ) = \");\n   Ada.Text_IO.Put_Line(Integer'Image(Fib(X)));\nend Fib;\n\nIterative, build-in integers[edit]\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Fibonacci is\n   function Fibonacci (N : Natural) return Natural is\n      This : Natural := 0;\n      That : Natural := 1;\n      Sum  : Natural;\n   begin\n      for I in 1..N loop\n         Sum  := This + That;\n         That := This;\n         This := Sum;\n      end loop;\n      return This;\n   end Fibonacci;\nbegin\n   for N in 0..10 loop\n      Put_Line (Positive'Image (Fibonacci (N)));\n   end loop;\nend Test_Fibonacci;\n\n\nOutput:\n 0\n 1\n 1\n 2\n 3\n 5\n 8\n 13\n 21\n 34\n 55\n\nIterative, long integers[edit]\n\nwith Ada.Text_IO, Ada.Command_Line, Crypto.Types.Big_Numbers;\n\nprocedure Fibonacci is\n\n   X: Positive := Positive'Value(Ada.Command_Line.Argument(1));\n\n   Bit_Length: Positive := 1 + (696 * X) / 1000;\n   -- that number of bits is sufficient to store the full result.\n\n   package LN is new Crypto.Types.Big_Numbers\n     (Bit_Length + (32 - Bit_Length mod 32));\n     -- the actual number of bits has to be a multiple of 32\n   use LN;\n\n   function Fib(P: Positive) return Big_Unsigned is\n      Previous: Big_Unsigned := Big_Unsigned_Zero;\n      Result:   Big_Unsigned := Big_Unsigned_One;\n      Tmp:      Big_Unsigned;\n   begin\n      -- Result = 1 = Fibonacci(1)\n      for I in 1 .. P-1 loop\n         Tmp := Result;\n         Result := Previous + Result;\n         Previous := Tmp;\n         -- Result = Fibonacci(I+1))\n      end loop;\n      return Result;\n   end Fib;\n\nbegin\n   Ada.Text_IO.Put(\"Fibonacci(\" & Integer'Image(X) & \" ) = \");\n   Ada.Text_IO.Put_Line(LN.Utils.To_String(Fib(X)));\nend Fibonacci;\n\n\nOutput:\n> ./fibonacci 777\nFibonacci( 777 ) = 1081213530912648191985419587942084110095342850438593857649766278346130479286685742885693301250359913460718567974798268702550329302771992851392180275594318434818082\nFast method using fast matrix exponentiation[edit]\nwith ada.text_io;\nuse  ada.text_io;\n\nprocedure fast_fibo is \n\t-- We work with biggest natural integers in a 64 bits machine \n\ttype Big_Int is mod 2**64;\n\n\t-- We provide an index type for accessing the fibonacci sequence terms \n\ttype Index is new Big_Int;\n\n\t-- fibo is a generic function that needs a modulus type since it will return\n\t-- the n'th term of the fibonacci sequence modulus this type (use Big_Int to get the\t\n\t-- expected behaviour in this particular task)\n\tgeneric\n\t\ttype ring_element is mod <>;\n\t\twith function \"*\" (a, b : ring_element) return ring_element is <>;\n\t\tfunction fibo (n : Index) return ring_element;\n\tfunction fibo (n : Index) return ring_element is\n\n\t\ttype matrix is array (1 .. 2, 1 .. 2) of ring_element;\n\n\t\t-- f is the matrix you apply to a column containing (F_n, F_{n+1}) to get \n\t\t-- the next one containing (F_{n+1},F_{n+2})\n\t\t-- could be a more general matrix (given as a generic parameter) to deal with \n\t\t-- other linear sequences of order 2\n\t\tf : constant matrix := (1 => (0, 1), 2 => (1, 1));\n\n\t\tfunction \"*\" (a, b : matrix) return matrix is\n\t\t(1 => (a(1,1)*b(1,1)+a(1,2)*b(2,1), a(1,1)*b(1,2)+a(1,2)*b(2,2)),\n\t\t 2 => (a(2,1)*b(1,1)+a(2,2)*b(2,1), a(2,1)*b(1,2)+a(2,2)*b(2,2)));\n\n\t\tfunction square (m : matrix) return matrix is (m * m);\n\n\t\t-- Fast_Pow could be non recursive but it doesn't really matter since\n\t\t-- the number of calls is bounded up by the size (in bits) of Big_Int (e.g 64)\n\t\tfunction fast_pow (m : matrix; n : Index) return matrix is\n\t\t(if n = 0 then (1 => (1, 0), 2 => (0, 1)) -- = identity matrix\n\t\t elsif n mod 2 = 0 then square (fast_pow (m, n / 2)) \n\t\t else m * square (fast_pow (m, n / 2)));\n\n\tbegin\n\t\treturn fast_pow (f, n)(2, 1);\n\tend fibo;\n\n\tfunction Big_Int_Fibo is new fibo (Big_Int);\nbegin\n\t-- calculate instantly F_n with n=10^15 (modulus 2^64 )\n\tput_line (Big_Int_Fibo (10**15)'img);\nend fast_fibo;\n\n", "explain": "Using the big integer implementation from a cryptographic library [1].\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nRecursive[edit]\nfib(n) = n < 2\u00a0? n\u00a0: fib(n-1) + fib(n-2)\nIterative[edit]\nfunction fib(n)\n  x,y = (0,1)\n  for i = 1:n x,y = (y, x+y) end\n  x\nend\nMatrix form[edit]\nfib(n) = ([1 1\u00a0; 1 0]^n)[1,2]\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\nIterative[edit]\n\ndata fib;\n    a=0;\n    b=1;\n    do n=0 to 20;\n       f=a;\n       output;\n       a=b;\n       b=f+a;\n    end;\n    keep n f;\nrun;\nNaive recursive[edit]\n\noptions cmplib=work.f;\n\nproc fcmp outlib=work.f.p;\n    function fib(n);\n    if n = 0 or n = 1\n        then return(1);\n        else return(fib(n - 2) + fib(n - 1));\n    endsub;\nrun;\n\ndata _null_;\n    x = fib(5);\n    put 'fib(5) = ' x;\nrun;\n", "explain": "This code builds a table fib holding the first few values of the Fibonacci sequence.\nThis code provides a simple example of defining a function and using it recursively. One of the members of the sequence is written to the log.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nenum class Fibonacci {\n    ITERATIVE {\n        override fun get(n: Int): Long = if (n < 2) {\n            n.toLong()\n        } else {\n            var n1 = 0L\n            var n2 = 1L\n            repeat(n) {\n                val sum = n1 + n2\n                n1 = n2\n                n2 = sum\n            }\n            n1\n        }\n    },\n    RECURSIVE {\n        override fun get(n: Int): Long = if (n < 2) n.toLong() else this[n - 1] + this[n - 2]\n    },\n    CACHING {\n        val cache: MutableMap<Int, Long> = mutableMapOf(0 to 0L, 1 to 1L)\n        override fun get(n: Int): Long = if (n < 2) n.toLong() else impl(n)\n        private fun impl(n: Int): Long = cache.computeIfAbsent(n) { impl(it-1) + impl(it-2) }\n    },\n   \u00a0;\n \n    abstract operator fun get(n: Int): Long\n}\n \nfun main() {\n    val r = 0..30\n    for (fib in Fibonacci.values()) {\n        print(\"${fib.name.padEnd(10)}:\")\n        for (i in r) { print(\" \" + fib[i]) }\n        println()\n    }\n}\n\nOutput:\nITERATIVE:  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\nRECURSIVE:  0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\nCACHING  \u00a0: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229 832040\n\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nIterative[edit]\nsub fib_iter {\n  my $n = shift;\n  use bigint try => \"GMP,Pari\";\n  my ($v2,$v1) = (-1,1);\n  ($v2,$v1) = ($v1,$v2+$v1) for 0..$n;\n  $v1;\n}\nRecursive[edit]\nsub fibRec {\n    my $n = shift;\n    $n < 2\u00a0? $n\u00a0: fibRec($n - 1) + fibRec($n - 2);\n}\nModules[edit]\n\n# Uses GMP method so very fast\nuse Math::AnyNum qw/fibonacci/;\nsay fibonacci(10000);\n\n# Uses GMP method, so also very fast\nuse Math::GMP;\nsay Math::GMP::fibonacci(10000);\n\n# Binary ladder, GMP if available, Pure Perl otherwise\nuse ntheory qw/lucasu/;\nsay lucasu(1, -1, 10000);\n\n# All Perl\nuse Math::NumSeq::Fibonacci;\nmy $seq = Math::NumSeq::Fibonacci->new;\nsay $seq->ith(10000);\n\n# All Perl\nuse Math::Big qw/fibonacci/;\nsay 0+fibonacci(10000);  # Force scalar context\n\n# Perl, gives floating point *approximation*\nuse Math::Fibonacci qw/term/;\nsay term(10000);\nArray accumulation[edit]\n\n\nsub fibonacci {\n    my $n = shift;    \n    \n    return 0 if $n <  1;\n    return 1 if $n == 1;\n        \n    my @numbers = (0, 1);\n\n    push @numbers, $numbers[-1] + $numbers[-2] foreach 2 .. $n;\n    \n    return $numbers[-1];\n}\n\nprint \"Fibonacci($_) -> \", (fibonacci $_), \"\\n\"\n    foreach (0 .. 20, 50, 93, 94, 100, 200, 1000, 1476, 1477);\n\nOutput:\nFibonacci(0) -> 0\nFibonacci(1) -> 1\nFibonacci(2) -> 1\nFibonacci(3) -> 2\nFibonacci(4) -> 3\nFibonacci(5) -> 5\nFibonacci(6) -> 8\nFibonacci(7) -> 13\nFibonacci(8) -> 21\nFibonacci(9) -> 34\nFibonacci(10) -> 55\nFibonacci(11) -> 89\nFibonacci(12) -> 144\nFibonacci(13) -> 233\nFibonacci(14) -> 377\nFibonacci(15) -> 610\nFibonacci(16) -> 987\nFibonacci(17) -> 1597\nFibonacci(18) -> 2584\nFibonacci(19) -> 4181\nFibonacci(20) -> 6765\nFibonacci(50) -> 12586269025\nFibonacci(93) -> 12200160415121876738\nFibonacci(94) -> 1.97402742198682e+19\nFibonacci(100) -> 3.54224848179262e+20\nFibonacci(200) -> 2.8057117299251e+41\nFibonacci(1000) -> 4.34665576869374e+208\nFibonacci(1476) -> 1.3069892237634e+308\nFibonacci(1477) -> Inf\n\n", "explain": "Quite a few modules have ways to do this.  Performance is not typically an issue with any of these until 100k or so.  With GMP available, the first three are much faster at large values.\nThis solution accumulates all Fibonacci numbers up to n into an array of n+1 elements (to account for the zeroth Fibonacci number). When the loop reaches n, the function returns the last element of the array, i.e. the n-th Fibonacci number. This function only works for positive integers, but it can be easily extended into negatives.Note that, without the use of big integer libraries, pure Perl switches to floats in scientific notation above n=93 and treats any number as infinite above n=1476 (see output). This behaviour could vary across Perl implementations."}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\nRecursive[edit]\n-(long)fibonacci:(int)position\n{\n    long result = 0;\n    if (position < 2) {\n        result = position;\n    } else {\n        result = [self fibonacci:(position -1)] + [self fibonacci:(position -2)];\n    }\n    return result;    \n}\nIterative[edit]\n+(long)fibonacci:(int)index {\n    long beforeLast = 0, last = 1;\n    while (index > 0) {\n        last += beforeLast;\n        beforeLast = last - beforeLast;\n        --index;\n    }\n    return last;\n}\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nWorks with: GNU Prolog\nWorks with: YAP\nfib(1, 1)\u00a0:-\u00a0!.\nfib(0, 0)\u00a0:-\u00a0!.\nfib(N, Value)\u00a0:-\n  A is N - 1, fib(A, A1),\n  B is N - 2, fib(B, B1),\n  Value is A1 + B1.\n\n?- time(fib(0,F)).\n% 2 inferences, 0.000 CPU in 0.000 seconds (88% CPU, 161943 Lips)\nF = 0.\n\n?- time(fib(10,F)).\n% 265 inferences, 0.000 CPU in 0.000 seconds (98% CPU, 1458135 Lips)\nF = 55.\n\n?- time(fib(20,F)).\n% 32,836 inferences, 0.016 CPU in 0.016 seconds (99% CPU, 2086352 Lips)\nF = 6765.\n\n?- time(fib(30,F)).\n% 4,038,805 inferences, 1.122 CPU in 1.139 seconds (98% CPU, 3599899 Lips)\nF = 832040.\n\n?- time(fib(40,F)).\n% 496,740,421 inferences, 138.705 CPU in 140.206 seconds (99% CPU, 3581264 Lips)\nF = 102334155.\n\nPoor man's memoization[edit]\nWorks with: SWI Prolog\nWorks with: YAP\nWorks with: GNU Prolog\n\n%:- dynamic fib/2. \u00a0% This is ISO, but GNU doesn't like it.\n:- dynamic(fib/2). \u00a0% Not ISO, but works in SWI, YAP and GNU unlike the ISO declaration.\nfib(1, 1)\u00a0:-\u00a0!.\nfib(0, 0)\u00a0:-\u00a0!.\nfib(N, Value)\u00a0:-\n  A is N - 1, fib(A, A1),\n  B is N - 2, fib(B, B1),\n  Value is A1 + B1,\n  asserta((fib(N, Value)\u00a0:-\u00a0!)).\n\n?- time(fib(0,F)).\n% 2 inferences, 0.000 CPU in 0.000 seconds (90% CPU, 160591 Lips)\nF = 0.\n\n?- time(fib(10,F)).\n% 37 inferences, 0.000 CPU in 0.000 seconds (96% CPU, 552610 Lips)\nF = 55.\n\n?- time(fib(20,F)).\n% 41 inferences, 0.000 CPU in 0.000 seconds (96% CPU, 541233 Lips)\nF = 6765.\n\n?- time(fib(30,F)).\n% 41 inferences, 0.000 CPU in 0.000 seconds (95% CPU, 722722 Lips)\nF = 832040.\n\n?- time(fib(40,F)).\n% 41 inferences, 0.000 CPU in 0.000 seconds (96% CPU, 543572 Lips)\nF = 102334155.\n\n?- listing(fib).\n:- dynamic fib/2.\n\nfib(40, 102334155)\u00a0:-\u00a0!.\nfib(39, 63245986)\u00a0:-\u00a0!.\nfib(38, 39088169)\u00a0:-\u00a0!.\nfib(37, 24157817)\u00a0:-\u00a0!.\nfib(36, 14930352)\u00a0:-\u00a0!.\nfib(35, 9227465)\u00a0:-\u00a0!.\nfib(34, 5702887)\u00a0:-\u00a0!.\nfib(33, 3524578)\u00a0:-\u00a0!.\nfib(32, 2178309)\u00a0:-\u00a0!.\nfib(31, 1346269)\u00a0:-\u00a0!.\nfib(30, 832040)\u00a0:-\u00a0!.\nfib(29, 514229)\u00a0:-\u00a0!.\nfib(28, 317811)\u00a0:-\u00a0!.\nfib(27, 196418)\u00a0:-\u00a0!.\nfib(26, 121393)\u00a0:-\u00a0!.\nfib(25, 75025)\u00a0:-\u00a0!.\nfib(24, 46368)\u00a0:-\u00a0!.\nfib(23, 28657)\u00a0:-\u00a0!.\nfib(22, 17711)\u00a0:-\u00a0!.\nfib(21, 10946)\u00a0:-\u00a0!.\nfib(20, 6765)\u00a0:-\u00a0!.\nfib(19, 4181)\u00a0:-\u00a0!.\nfib(18, 2584)\u00a0:-\u00a0!.\nfib(17, 1597)\u00a0:-\u00a0!.\nfib(16, 987)\u00a0:-\u00a0!.\nfib(15, 610)\u00a0:-\u00a0!.\nfib(14, 377)\u00a0:-\u00a0!.\nfib(13, 233)\u00a0:-\u00a0!.\nfib(12, 144)\u00a0:-\u00a0!.\nfib(11, 89)\u00a0:-\u00a0!.\nfib(10, 55)\u00a0:-\u00a0!.\nfib(9, 34)\u00a0:-\u00a0!.\nfib(8, 21)\u00a0:-\u00a0!.\nfib(7, 13)\u00a0:-\u00a0!.\nfib(6, 8)\u00a0:-\u00a0!.\nfib(5, 5)\u00a0:-\u00a0!.\nfib(4, 3)\u00a0:-\u00a0!.\nfib(3, 2)\u00a0:-\u00a0!.\nfib(2, 1)\u00a0:-\u00a0!.\nfib(1, 1)\u00a0:-\u00a0!.\nfib(0, 0)\u00a0:-\u00a0!.\nfib(A, D)\u00a0:-\n\tB is A+ -1,\n\tfib(B, E),\n\tC is A+ -2,\n\tfib(C, F),\n\tD is E+F,\n\tasserta((fib(A, D):-!)).\n\nContinuation passing style[edit]\n\n:- use_module(lambda).\nfib(N, FN)\u00a0:-\n\tcont_fib(N, _, FN, \\_^Y^_^U^(U = Y)).\n\ncont_fib(N, FN1, FN, Pred)\u00a0:-\n\t(   N < 2 ->\n\t    call(Pred, 0, 1, FN1, FN)\n\t;\n\t    N1 is N - 1,\n\t    P = \\X^Y^Y^U^(U is X + Y),\n\t    cont_fib(N1, FNA, FNB, P),\n\t    call(Pred, FNA, FNB, FN1, FN)\n\t).\nWith lazy lists[edit]\n\nfib([0,1|X])\u00a0:-\n    ffib(0,1,X).\nffib(A,B,X)\u00a0:-\n    freeze(X, (C is A+B, X=[C|Y], ffib(B,C,Y)) ).\n\n?- fib(X), length(A,15), append(A,_,X), writeln(A).\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\nGenerators idiom[edit]\ntake( 0, Next, Z-Z, Next).\ntake( N, Next, [A|B]-Z, NZ):- N>0,\u00a0!, next( Next, A, Next1),\n  N1 is N-1,\n  take( N1, Next1, B-Z, NZ).\n\nnext( fib(A,B), A, fib(B,C)):- C is A+B.\n\n%% usage:\u00a0?- take(15, fib(0,1), _X-[], G), writeln(_X).\n%% [0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377]\n%% G = fib(610, 987)\nYet another implementation[edit]\n\n% Fibonacci sequence generator\nfib(C, [P,S], C, N) \u00a0:- N is P + S.\nfib(C, [P,S], Cv, V)\u00a0:- succ(C, Cn), N is P + S,\u00a0!, fib(Cn, [S,N], Cv, V).\n\nfib(0, 0).\nfib(1, 1).\nfib(C, N)\u00a0:- fib(2, [0,1], C, N).\u00a0% Generate from 3rd sequence on\n\n\u00a0?- time(fib(30,X)).\n% 86 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 832040 \n\u00a0?- time(fib(40,X)).\n% 116 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 102334155\n\u00a0?- time(fib(100,X)).\n% 296 inferences, 0.000 CPU in 0.001 seconds (0% CPU, Infinite Lips)\nX = 354224848179261915075 \n\n\n?- time(fib(X,Fib)).\n% 0 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = Fib, Fib = 0\u00a0;\n% 1 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = Fib, Fib = 1\u00a0;\n% 3 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 2,\nFib = 1\u00a0;\n% 5 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 3,\nFib = 2\u00a0;\n% 5 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 4,\nFib = 3\u00a0;\n% 5 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = Fib, Fib = 5\u00a0;\n% 5 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 6,\nFib = 8\n...etc.\n\n\u00a0?- time(fib(100,354224848179261915075)).\n% 296 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\ntrue .\n\n?- time(fib(X,354224848179261915075)).\n% 394 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 100 .\nEfficient implementation[edit]\n% John Devou: 26-Nov-2021\n% Efficient program to calculate n-th Fibonacci number.\n% Works fast for n \u2264 1 000 000 000.\n\nb(0,Bs,Bs).\nb(N,Bs,Res):- N > 0, B is mod(N,2), M is div(N,2), b(M,[B|Bs],Res).\n\nf([],A,_,_,A).\nf([X|Xs],A,B,C,Res):- AA is A^2, BB is B^2, A_ is 2*BB-3*AA-C, B_ is AA+BB,\n    (X =:= 1 -> T is A_+B_, f(Xs,B_,T,-2,Res); f(Xs,A_,B_,2,Res)).\n\nfib(N,F):- b(N,[],Bs), f(Bs,0,1,2,F),\u00a0!.\n\nOutput:\n?- time(fib(30,X)).\n% 59 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 832040.\n\n?- time(fib(100,X)).\n% 80 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 354224848179261915075.\n\n?- time(fib(500,X)). \n% 102 inferences, 0.000 CPU in 0.000 seconds (?% CPU, Infinite Lips)\nX = 139423224561697880139724382870407283950070256587697307264108962948325571622863290691557658876222521294125.\n\n?- time(fib(1000000000,_)). \n% 334 inferences, 7.078 CPU in 7.526 seconds (94% CPU, 47 Lips)\ntrue.\n\n", "explain": "This naive implementation works, but is very slow for larger values of N.  Here are some simple measurements (in SWI-Prolog):\nAs you can see, the calculation time goes up exponentially as N goes higher.\nThe performance problem can be readily fixed by the addition of two lines of code (the first and last in this version):\nLet's take a look at the execution costs now:\nIn this case by asserting the new N,Value pairing as a rule in the database we're making the classic time/space tradeoff.  Since the space costs are (roughly) linear by N and the time costs are exponential by N, the trade-off is desirable.  You can see the poor man's memoizing easily:\nAll of the interim N/Value pairs have been asserted as facts for quicker future use, speeding up the generation of the higher Fibonacci numbers.\nWorks with SWI-Prolog and module lambda, written by Ulrich Neumerkel found there http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/lambda.pl\nWorks with SWI-Prolog and others that support freeze/2.  \nThe predicate fib(Xs) unifies Xs with an infinite list whose values are the Fibonacci sequence.  The list can be used like this:\nOne of my favorites; loosely similar to the first example, but without the performance penalty, and needs nothing special to implement.  Not even a dynamic database predicate. Attributed to M.E. for the moment, but simply because I didn't bother to search for the many people who probably did it like this long before I did.  If someone knows who came up with it first, please let us know.\nLooking at performance:\nWhat I really like about this one, is it is also a generator- i.e. capable of generating all the numbers in sequence needing no bound input variables or special Prolog predicate support (such as freeze/3 in the previous example):\nIt stays at 5 inferences per iteration after X=3. Also, quite useful:\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nRecursive[edit]\n--calculates the nth fibonacci number. Breaks for negative or non-integer n.\nfunction fibs(n) \n  return n < 2 and n or fibs(n - 1) + fibs(n - 2) \nend\nPedantic Recursive[edit]\n--more pedantic version, returns 0 for non-integer n\nfunction pfibs(n)\n  if n ~= math.floor(n) then return 0\n  elseif n < 0 then return pfibs(n + 2) - pfibs(n + 1)\n  elseif n < 2 then return n\n  else return pfibs(n - 1) + pfibs(n - 2)\n  end\nend\nTail Recursive[edit]\nfunction a(n,u,s) if n<2 then return u+s end return a(n-1,u+s,u) end\nfunction trfib(i) return a(i-1,1,0) end\nTable Recursive[edit]\nfib_n = setmetatable({1, 1}, {__index = function(z,n) return n<=0 and 0 or z[n-1] + z[n-2] end})\nTable Recursive 2[edit]\n-- table recursive done properly (values are actually saved into table;\n-- also the first element of Fibonacci sequence is 0, so the initial table should be {0, 1}).\nfib_n = setmetatable({0, 1}, {\n  __index = function(t,n)\n    if n <= 0 then return 0 end\n    t[n] = t[n-1] + t[n-2]\n    return t[n]\n  end\n})\nIterative[edit]\nfunction ifibs(n)\n  local p0,p1=0,1\n  for _=1,n do p0,p1 = p1,p0+p1 end\n  return p0\nend\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nRecursive[edit]\ndef fib(i: Int): Int = i match {\n  case 0 => 0\n  case 1 => 1\n  case _ => fib(i - 1) + fib(i - 2)\n}\nLazy sequence[edit]\nlazy val fib: LazyList[Int] = 0 #:: 1 #:: fib.zip(fib.tail).map { case (a, b) => a + b }\nTail recursive[edit]\nimport scala.annotation.tailrec\n@tailrec\nfinal def fib(x: Int, prev: BigInt = 0, next: BigInt = 1): BigInt = x match {\n  case 0 => prev\n  case _ => fib(x - 1, next, next + prev)\n}\nfoldLeft[edit]\n// Fibonacci using BigInt with LazyList.foldLeft optimized for GC (Scala v2.13 and above)\n// Does not run out of memory for very large Fibonacci numbers\ndef fib(n: Int): BigInt = {\n\n  def series(i: BigInt, j: BigInt): LazyList[BigInt] = i #:: series(j, i + j)\n\n  series(1, 0).take(n).foldLeft(BigInt(\"0\"))(_ + _)\n}\n\n// Small test\n(0 to 13) foreach {n => print(fib(n).toString + \" \")}\n\n// result: 0 1 1 2 3 5 8 13 21 34 55 89 144 233\nIterator[edit]\nval it: Iterator[Int] = Iterator.iterate((0, 1)) { case (a, b) => (b, a + b) }.map(_._1)\n\ndef fib(n: Int): Int = it.drop(n).next()\n\n// example:\nprintln(it.take(13).mkString(\",\")) // prints: 0,1,1,2,3,5,8,13,21,34,55,89,144\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nint fib(int n) {\n  if (n==0 || n==1) {\n    return n;\n  }\n  var prev=1;\n  var current=1;\n  for (var i=2; i<n; i++) {\n    var next = prev + current;\n    prev = current;\n    current = next;    \n  }\n  return current;\n}\n\nint fibRec(int n) => n==0 || n==1\u00a0? n\u00a0: fibRec(n-1) + fibRec(n-2);\n\nmain() {\n  print(fib(11));\n  print(fibRec(11));\n}\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\n\nimport std.stdio, std.conv, std.algorithm, std.math;\n\nlong sgn(alias unsignedFib)(int n) { // break sign manipulation apart\n    immutable uint m = (n >= 0)\u00a0? n\u00a0: -n;\n    if (n < 0 && (n\u00a0% 2 == 0))\n        return -unsignedFib(m);\n    else\n        return unsignedFib(m);\n}\n\nlong fibD(uint m) { // Direct Calculation, correct for abs(m) <= 84\n    enum sqrt5r =  1.0L / sqrt(5.0L);         //  1 / sqrt(5)\n    enum golden = (1.0L + sqrt(5.0L)) / 2.0L; // (1 + sqrt(5)) / 2\n    return roundTo!long(pow(golden, m) * sqrt5r);\n}\n\nlong fibI(in uint m) pure nothrow { // Iterative\n    long thisFib = 0;\n    long nextFib = 1;\n    foreach (i; 0 .. m) {\n        long tmp = nextFib;\n        nextFib += thisFib;\n        thisFib  = tmp;\n    }\n    return thisFib;\n}\n\nlong fibR(uint m) { // Recursive\n    return (m < 2)\u00a0? m\u00a0: fibR(m - 1) + fibR(m - 2);\n}\n\nlong fibM(uint m) { // memoized Recursive\n    static long[] fib = [0, 1];\n    while (m >= fib.length )\n        fib ~= fibM(m - 2) + fibM(m - 1);\n    return fib[m];\n}\n\nalias sgn!fibD sfibD;\nalias sgn!fibI sfibI;\nalias sgn!fibR sfibR;\nalias sgn!fibM sfibM;\n\nauto fibG(in int m) { // generator(?)\n    immutable int sign = (m < 0)\u00a0? -1\u00a0: 1;\n    long yield;\n    \n    return new class {\n        final int opApply(int delegate(ref int, ref long) dg) {\n            int idx = -sign; // prepare for pre-increment\n            foreach (f; this)\n                if (dg(idx += sign, f))\n                    break;\n            return 0;\n        }\n        \n        final int opApply(int delegate(ref long) dg) {\n            long f0, f1 = 1;\n            foreach (p; 0 .. m * sign + 1) {\n                if (sign == -1 && (p\u00a0% 2 == 0))\n                    yield = -f0;\n                else\n                    yield = f0;\n                if (dg(yield)) break;\n                auto temp = f1;\n                f1 = f0 + f1;\n                f0 = temp;\n            }\n            return 0;\n        }\n    };\n}\n\nvoid main(in string[] args) {\n    int k = args.length > 1\u00a0? to!int(args[1])\u00a0: 10;\n    writefln(\"Fib(%3d) = \", k);\n    writefln(\"D\u00a0: %20d <- %20d + %20d\",\n             sfibD(k), sfibD(k - 1), sfibD(k - 2));\n    writefln(\"I\u00a0: %20d <- %20d + %20d\",\n             sfibI(k), sfibI(k - 1), sfibI(k - 2));\n    if (abs(k) < 36 || args.length > 2)\n        // set a limit for recursive version\n        writefln(\"R\u00a0: %20d <- %20d + %20d\",\n                 sfibR(k), sfibM(k - 1), sfibM(k - 2));\n    writefln(\"O\u00a0: %20d <- %20d + %20d\",\n             sfibM(k), sfibM(k - 1), sfibM(k - 2));\n    foreach (i, f; fibG(-9))\n        writef(\"%d:%d | \", i, f);\n}\n\nOutput: for n = 85\n\nFib( 85) = \nD\u00a0:   259695496911122586 <-   160500643816367088 +    99194853094755497\nI\u00a0:   259695496911122585 <-   160500643816367088 +    99194853094755497\nO\u00a0:   259695496911122585 <-   160500643816367088 +    99194853094755497\n0:0 | -1:1 | -2:-1 | -3:2 | -4:-3 | -5:5 | -6:-8 | -7:13 | -8:-21 | -9:34 | \nMatrix Exponentiation Version[edit]\nimport std.bigint;\n\nT fibonacciMatrix(T=BigInt)(size_t n) {\n    int[size_t.sizeof * 8] binDigits;\n    size_t nBinDigits;\n    while (n > 0) {\n        binDigits[nBinDigits] = n\u00a0% 2;\n        n /= 2;\n        nBinDigits++;\n    }\n\n    T x=1, y, z=1;\n    foreach_reverse (b; binDigits[0 .. nBinDigits]) {\n        if (b) {\n            x = (x + z) * y;\n            y = y ^^ 2 + z ^^ 2;\n        } else {\n            auto x_old = x;\n            x = x ^^ 2 + y ^^ 2;\n            y = (x_old + z) * y;\n        }\n        z = x + y;\n    }\n\n    return y;\n}\n\nvoid main() {\n    10_000_000.fibonacciMatrix;\n}\nFaster Version[edit]\n\nimport std.bigint, std.math;\n\n// Algorithm from: Takahashi, Daisuke,\n// \"A fast algorithm for computing large Fibonacci numbers\".\n// Information Processing Letters 75.6 (30 November 2000): 243-246.\n// Implementation from:\n// pythonista.wordpress.com/2008/07/03/pure-python-fibonacci-numbers\nBigInt fibonacci(in ulong n)\nin {\n    assert(n > 0, \"fibonacci(n): n must be > 0.\");\n} body {\n    if (n <= 2)\n        return 1.BigInt;\n    BigInt F = 1;\n    BigInt L = 1;\n    int sign = -1;\n    immutable uint n2 = cast(uint)n.log2.floor;\n    auto mask = 2.BigInt ^^ (n2 - 1);\n    foreach (immutable i; 1 .. n2) {\n        auto temp = F ^^ 2;\n        F = (F + L) / 2;\n        F = 2 * F ^^ 2 - 3 * temp - 2 * sign;\n        L = 5 * temp + 2 * sign;\n        sign = 1;\n        if (n & mask) {\n            temp = F;\n            F = (F + L) / 2;\n            L = F + 2 * temp;\n            sign = -1;\n        }\n        mask /= 2;\n    }\n    if ((n & mask) == 0) {\n        F *= L;\n    } else {\n        F = (F + L) / 2;\n        F = F * L - sign;\n    }\n    return F;\n}\n\nvoid main() {\n    10_000_000.fibonacci;\n}\n", "explain": "Here are four versions of Fibonacci Number calculating functions. FibD has an argument limit of magnitude 84 due to floating point precision, the others have a limit of 92 due to overflow (long).The traditional recursive version is inefficient. It is optimized by supplying a static storage to store intermediate results. A Fibonacci Number generating function is added.\nAll functions have support for negative arguments.\nFor N = 10_000_000 this is about twice faster (run-time about 2.20 seconds) than the matrix exponentiation version.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nAnalytic[edit]\nWorks with: exact-real version 0.12.5.1\n\nimport Data.CReal\n\nphi = (1 + sqrt 5) / 2\n\nfib\u00a0:: (Integral b) => b -> CReal 0\nfib n = (phi^^n - (-phi)^^(-n))/sqrt 5\n\n\u03bb> fib 10\u00a0:: CReal 0\n55\n(0.01 secs, 137,576 bytes)\n\u03bb> fib 100\u00a0:: CReal 0\n354224848179261915075\n(0.01 secs, 253,152 bytes)\n\u03bb> fib 10000\u00a0:: CReal 0\n33644764876431783266621612005107543310302148460680063906564769974680081442166662368155595513633734025582065332680836159373734790483865268263040892463056431887354544369559827491606602099884183933864652731300088830269235673613135117579297437854413752130520504347701602264758318906527890855154366159582987279682987510631200575428783453215515103870818298969791613127856265033195487140214287532698187962046936097879900350962302291026368131493195275630227837628441540360584402572114334961180023091208287046088923962328835461505776583271252546093591128203925285393434620904245248929403901706233888991085841065183173360437470737908552631764325733993712871937587746897479926305837065742830161637408969178426378624212835258112820516370298089332099905707920064367426202389783111470054074998459250360633560933883831923386783056136435351892133279732908133732642652633989763922723407882928177953580570993691049175470808931841056146322338217465637321248226383092103297701648054726243842374862411453093812206564914032751086643394517512161526545361333111314042436854805106765843493523836959653428071768775328348234345557366719731392746273629108210679280784718035329131176778924659089938635459327894523777674406192240337638674004021330343297496902028328145933418826817683893072003634795623117103101291953169794607632737589253530772552375943788434504067715555779056450443016640119462580972216729758615026968443146952034614932291105970676243268515992834709891284706740862008587135016260312071903172086094081298321581077282076353186624611278245537208532365305775956430072517744315051539600905168603220349163222640885248852433158051534849622434848299380905070483482449327453732624567755879089187190803662058009594743150052402532709746995318770724376825907419939632265984147498193609285223945039707165443156421328157688908058783183404917434556270520223564846495196112460268313970975069382648706613264507665074611512677522748621598642530711298441182622661057163515069260029861704945425047491378115154139941550671256271197133252763631939606902895650288268608362241082050562430701794976171121233066073310059947366875\n(0.02 secs, 4,847,128 bytes)\n\u03bb> fib (-10)\u00a0:: CReal 0\n-55\n(0.01 secs, 138,408 bytes)\nRecursive[edit]\n\nfib x =\n  if x < 1\n    then 0\n    else if x < 2\n           then 1\n           else fib (x - 1) + fib (x - 2)\nRecursive with Memoization[edit]\n\nfib x =\n  if x < 1\n    then 0\n    else if x == 1\n           then 1\n           else fibs\u00a0!! (x - 1) + fibs\u00a0!! (x - 2)\n  where\n    fibs = map fib [0 ..]\nRecursive with Memoization using memoized library[edit]\n\nimport Data.MemoTrie\nfib\u00a0:: Integer -> Integer\nfib = memo f where\n   f 0 = 0\n   f 1 = 1\n   f n = fib (n-1) + fib (n-2)\n\nimport Data.MemoTrie\nfib\u00a0:: Integer -> Integer\nfib = memo $ \\x -> case x of\n   0 -> 0\n   1 -> 1\n   n -> fib (n-1) + fib (n-2)\n\n{-# Language LambdaCase #-}\nimport Data.MemoTrie\nfib\u00a0:: Integer -> Integer\nfib = memo $ \\case \n   0 -> 0\n   1 -> 1\n   n -> fib (n-1) + fib (n-2)\n\n{-# Language LambdaCase #-}\nimport Data.MemoTrie\nfib\u00a0:: Integer -> Integer\nfib = memo $ \\case \n   0 -> 0\n   1 -> 1\n   n | n>0 -> fib (n-1) + fib (n-2)\n     | otherwise -> fib (n+2) - fib (n+1)\nIterative[edit]\nfib n = go n 0 1\n  where\n    go n a b\n      | n == 0 = a\n      | otherwise = go (n - 1) b (a + b)\nWith lazy lists[edit]\n\nfib = 0\u00a0: 1\u00a0: zipWith (+) fib (tail fib)\n\nfib = 0\u00a0: 1\u00a0: (zipWith (+) <*> tail) fib\n\nfib = 0\u00a0: 1\u00a0: next fib where next (a: t@(b:_)) = (a+b)\u00a0: next t\n\nfib = 0\u00a0: scanl (+) 1 fib\nAs a fold[edit]\n\nimport Data.List (foldl') --'\n\nfib\u00a0:: Integer -> Integer\nfib n =\n  fst $\n  foldl' --'\n    (\\(a, b) _ -> (b, a + b))\n    (0, 1)\n    [1 .. n]\nWith matrix exponentiation[edit]\n\nimport Data.List (transpose)\n\nfib\n \u00a0:: (Integral b, Num a)\n  => b -> a\nfib 0 = 0 -- this line is necessary because \"something ^ 0\" returns \"fromInteger 1\", which unfortunately\n-- in our case is not our multiplicative identity (the identity matrix) but just a 1x1 matrix of 1\nfib n = (last . head . unMat) (Mat [[1, 1], [1, 0]] ^ n)\n\n-- Code adapted from Matrix exponentiation operator task ---------------------\n(<+>)\n \u00a0:: Num c\n  => [c] -> [c] -> [c]\n(<+>) = zipWith (+)\n\n(<*>)\n \u00a0:: Num a\n  => [a] -> [a] -> a\n(<*>) = (sum .) . zipWith (*)\n\nnewtype Mat a = Mat\n  { unMat\u00a0:: [[a]]\n  } deriving (Eq)\n\ninstance Show a =>\n         Show (Mat a) where\n  show xm = \"Mat \" ++ show (unMat xm)\n\ninstance Num a =>\n         Num (Mat a) where\n  negate xm = Mat $ map (map negate) $ unMat xm\n  xm + ym = Mat $ zipWith (<+>) (unMat xm) (unMat ym)\n  xm * ym =\n    Mat\n      [ [ xs Main.<*> ys -- to distinguish from standard applicative operator\n        | ys <- transpose $ unMat ym ]\n      | xs <- unMat xm ]\n  fromInteger n = Mat [[fromInteger n]]\n  abs = undefined\n  signum = undefined\n\n-- TEST ----------------------------------------------------------------------\nmain\u00a0:: IO ()\nmain = (print . take 10 . show . fib) (10 ^ 5)\n\n\nOutput:\n\"2597406934\"\nWith recurrence relations[edit]\n\nimport Control.Arrow ((&&&))\n\nfibstep\u00a0:: (Integer, Integer) -> (Integer, Integer)\nfibstep (a, b) = (b, a + b)\n\nfibnums\u00a0:: [Integer]\nfibnums = map fst $ iterate fibstep (0, 1)\n\nfibN2\u00a0:: Integer -> (Integer, Integer)\nfibN2 m\n  | m < 10 = iterate fibstep (0, 1)\u00a0!! fromIntegral m\nfibN2 m = fibN2_next (n, r) (fibN2 n)\n  where\n    (n, r) = quotRem m 3\n\nfibN2_next (n, r) (f, g)\n  | r == 0 = (a, b) -- 3n  ,3n+1\n  | r == 1 = (b, c) -- 3n+1,3n+2\n  | r == 2 = (c, d) -- 3n+2,3n+3   (*)\n  where\n    a =\n      5 * f ^ 3 +\n      if even n\n        then 3 * f\n        else (-3 * f) -- 3n\n    b = g ^ 3 + 3 * g * f ^ 2 - f ^ 3 -- 3n+1\n    c = g ^ 3 + 3 * g ^ 2 * f + f ^ 3 -- 3n+2\n    d =\n      5 * g ^ 3 +\n      if even n\n        then (-3 * g)\n        else 3 * g -- 3(n+1)   (*)\n\nmain\u00a0:: IO ()\nmain = print $ (length &&& take 20) . show . fst $ fibN2 (10 ^ 2)\n\nOutput:\n(21,\"35422484817926191507\")\n\n *Main> (length &&& take 20) . show . fst $ fibN2 (10^6)\n(208988,\"19532821287077577316\")\n\nf (n,(a,b)) = (2*n,(a*a+b*b,2*a*b+b*b))     -- iterate f (1,(0,1))\u00a0; b is nth\n\ng (n,(a,b)) = (2*n,(2*a*b-a*a,a*a+b*b))     -- iterate g (1,(1,1))\u00a0; a is nth\n", "explain": "Using Binet's formula and exact real arithmetic library we can calculate arbitrary Fibonacci number exactly. \nLet's try it for large numbers:\nSimple definition, very inefficient.\nVery fast.\nEven faster and simpler is to use a defined memoizer (e.g. from MemoTrie package): \nYou can rewrite this without introducing f explicitly\nOr using LambdaCase extension you can write it even shorter:\nThe version that supports negative numbers:\nThis is a standard example how to use lazy lists. Here's the (infinite) list of all Fibonacci numbers:\nOr alternatively:\nThe nth Fibonacci number is then just fib\u00a0!! n. The above is equivalent to \nAlso\nAccumulator holds last two members of the series:\nAdapting the (rather slow) code from Matrix exponentiation operator,\nwe can simply write:\nSo, for example, the hundred-thousandth Fibonacci number starts with the digits:\nUsing Fib[m=3n+r] recurrence identities:\n(fibN2 n) directly calculates a pair (f,g) of two consecutive Fibonacci numbers, (Fib[n], Fib[n+1]), from recursively calculated such pair at about n/3:\nThe above should take less than 0.1s to calculate on a modern box. \nOther identities that could also be used are here. In particular, for (n-1,n) ---> (2n-1,2n) transition which is equivalent to the matrix exponentiation scheme, we have\nand for (n,n+1) ---> (2n,2n+1) (derived from d'Ocagne's identity, for example),\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "PL/SQL", "code": "\ncreate or replace function fnu_fibonacci(p_num integer) return integer is\n  f integer;\n  p integer;\n  q integer;\nbegin\n  case when p_num < 0 or p_num\u00a0!= trunc(p_num) \n                            then raise_application_error(-20001, 'Invalid input: ' || p_num, true);\n       when p_num in (0, 1) then f\u00a0:= p_num;\n       else\n            p\u00a0:= 0;\n            q\u00a0:= 1;\n            for i in 2 .. p_num loop\n              f\u00a0:= p + q;\n              p\u00a0:= q;\n              q\u00a0:= f;\n            end loop;\n  end case;\n  return(f);\nend fnu_fibonacci;\n/\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\nIterative[edit]\n(define (fib-iter n)\n  (do ((num 2 (+ num 1))\n       (fib-prev 1 fib)\n       (fib 1 (+ fib fib-prev)))\n      ((>= num n) fib)))\nRecursive[edit]\n(define (fib-rec n)\n  (if (< n 2)\n      n\n      (+ (fib-rec (- n 1))\n         (fib-rec (- n 2)))))\n\n(define (fib n)\n  (let loop ((a 0) (b 1) (n n))\n    (if (= n 0) a\n        (loop b (+ a b) (- n 1)))))\nRecursive Sequence Generator[edit]\n\n(define (fib)\n  (define (nxt lv nv) (cons nv (lambda () (nxt nv (+ lv nv)))))\n  (cons 0 (lambda () (nxt 0 1))))\n\n;;; test...\n(define (show-stream-take n strm)\n  (define (shw-nxt n strm) (begin (display (car strm))\n                                  (if (> n 1) (begin (display \" \") (shw-nxt (- n 1) ((cdr strm)))) (display \")\"))))\n  (begin (display \"(\") (shw-nxt n strm)))\n(show-stream-take 30 (fib))\n\nOutput:\n(0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 75025 121393 196418 317811 514229)\nDijkstra Algorithm[edit]\n;;; Fibonacci numbers using Edsger Dijkstra's algorithm\n;;; http://www.cs.utexas.edu/users/EWD/ewd06xx/EWD654.PDF\n\n(define (fib n)\n  (define (fib-aux a b p q count)\n    (cond ((= count 0) b)\n          ((even? count)\n           (fib-aux a\n                    b\n                    (+ (* p p) (* q q))\n                    (+ (* q q) (* 2 p q))\n                    (/ count 2)))\n          (else\n           (fib-aux (+ (* b q) (* a q) (* a p))\n                    (+ (* b p) (* a q))\n                    p\n                    q\n                    (- count 1)))))\n  (fib-aux 1 0 0 1 n))\n", "explain": "This version is tail recursive:\nAlthough the tail recursive version above is quite efficient, it only generates the final nth Fibonacci number and not the sequence up to that number without wasteful repeated calls to the procedure/function.\nThe following procedure generates the sequence of Fibonacci numbers using a simplified version of a lazy list/stream - since no memoization is requried, it just implements future values by using a zero parameter lambda \"thunk\" with a closure containing the last and the pre-calculated next value of the sequence; in this way it uses almost no memory during the sequence generation other than as required for the last and the next values of the sequence (note that the test procedure does not generate a linked list to contain the elements of the sequence to show, but rather displays each one by one in sequence):\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Apex", "code": "\n/*\n author: snugsfbay\n date: March 3, 2016\n description: Create a list of x numbers in the Fibonacci sequence.\n     - user may specify the length of the list \n     - enforces a minimum of 2 numbers in the sequence because any fewer is not a sequence\n     - enforces a maximum of 47 because further values are too large for integer data type \n     - Fibonacci sequence always starts with 0 and 1 by definition\n*/\npublic class FibNumbers{\n\nfinal static Integer MIN = 2; //minimum length of sequence\nfinal static Integer MAX = 47; //maximum length of sequence\n\n/* \n  description: method to create a list of numbers in the Fibonacci sequence \n  param: user specified integer representing length of sequence should be 2-47, inclusive.\n      - Sequence starts with 0 and 1 by definition so the minimum length could be as low as 2.\n      - For 48th number in sequence or greater, code would require a Long data type rather than an Integer.\n  return: list of integers in sequence.\n*/\npublic static List<Integer> makeSeq(Integer len){\n\n  List<Integer> fib = new List<Integer>{0,1}; // initialize list with first two values\n  Integer i;\n  \n  if(len<MIN || len==null || len>MAX) {\n      if (len>MAX){\n          len=MAX; //set length to maximum if user entered too high a value\n      }else{\n          len=MIN; //set length to minimum if user entered too low a value or none\n      }\n  } //This could be refactored using teneray operator, but we want code coverage to be reflected for each condition\n  \n  //start with initial list size to find previous two values in the sequence, continue incrementing until list reaches user defined length\n  for(i=fib.size(); i<len; i++){ \n    fib.add(fib[i-1]+fib[i-2]); //create new number based on previous numbers and add that to the list\n  }\n\n  return fib; \n  }\n  \n}\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nIterative[edit]\nfunction FibonacciNumber ( $count )\n{\n    $answer = @(0,1)\n    while ($answer.Length -le $count)\n    {\n        $answer += $answer[-1] + $answer[-2]\n    }\n    return $answer\n}\n\n$count = 8\n$answer = @(0,1)\n0..($count - $answer.Length) | Foreach { $answer += $answer[-1] + $answer[-2] }\n$answer\nRecursive[edit]\nfunction fib($n) {\n    switch ($n) {\n        0            { return 0 }\n        1            { return 1 }\n        { $_ -lt 0 } { return [Math]::Pow(-1, -$n + 1) * (fib (-$n)) }\n        default      { return (fib ($n - 1)) + (fib ($n - 2)) }\n    }\n}\n", "explain": "An even shorter version that eschews function calls altogether:\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto fib :n [:a 0] [:b 1]\n  if :n < 1 [output :a]\n  output (fib :n-1 :b :a+:b)\nend\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "ABAP", "code": "\nIterative[edit]\nFORM fibonacci_iter USING index TYPE i\n                    CHANGING number_fib TYPE i.\n  DATA: lv_old type i,\n        lv_cur type i.\n  Do index times.\n    If sy-index = 1 or sy-index = 2.\n      lv_cur = 1.\n      lv_old = 0.\n    endif.\n    number_fib = lv_cur + lv_old.\n    lv_old = lv_cur.\n    lv_cur = number_fib.\n  enddo.\nENDFORM.\n\nImpure Functional[edit]\nWorks with: ABAP version 7.4 SP08 Or above only\ncl_demo_output=>display( REDUCE #( INIT fibnm = VALUE stringtab( ( |0| ) ( |1| ) )\n                                        n TYPE string\n                                        x = `0`\n                                        y = `1`\n                                      FOR i = 1 WHILE i <= 100\n                                     NEXT n = ( x + y )\n                                          fibnm = VALUE #( BASE fibnm ( n ) )\n                                          x = y\n                                          y = n ) ).\n\n", "explain": ""}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nlet fibonacci n\u00a0: bigint =\n  let rec f a b n =\n    match n with\n    | 0 -> a\n    | 1 -> b\n    | n -> (f b (a + b) (n - 1))\n  f (bigint 0) (bigint 1) n\n> fibonacci 100;;\nval it\u00a0: bigint = 354224848179261915075I\n\nlet rec fib = seq { yield! [0;1];\n                    for (a,b) in Seq.zip fib (Seq.skip 1 fib) -> a+b}\n\nlet fibonacci = Seq.unfold (fun (x, y) -> Some(x, (y, x + y))) (0I,1I)\nfibonacci |> Seq.nth 10000\n\nopen System\nopen System.Diagnostics\nopen System.Numerics\n\n/// Finds the highest power of two which is less than or equal to a given input.\nlet inline prevPowTwo (x\u00a0: int) =\n    let mutable n = x\n    n <- n - 1\n    n <- n ||| (n >>> 1)\n    n <- n ||| (n >>> 2)\n    n <- n ||| (n >>> 4)\n    n <- n ||| (n >>> 8)\n    n <- n ||| (n >>> 16)\n    n <- n + 1\n    match x with\n    | x when x = n -> x\n    | _ -> n/2\n\n/// Evaluates the nth Fibonacci number using matrix arithmetic and\n/// exponentiation by squaring.\nlet crazyFib (n\u00a0: int) =\n    let powTwo = prevPowTwo n\n\n    /// Applies 2n rule repeatedly until another application of the rule would\n    /// go over the target value (or the target value has been reached).\n    let rec iter1 i q r s =\n        match i with\n        | i when i < powTwo ->\n            iter1 (i*2) (q*q + r*r) (r * (q+s)) (r*r + s*s)\n        | _ -> i, q, r, s\n\n    /// Applies n+1 rule until the target value is reached.\n    let rec iter2 (i, q, r, s) =\n        match i with\n        | i when i < n -> \n            iter2 ((i+1), (q+r), q, r)\n        | _ -> q\n\n    match n with\n    | 0 -> 1I\n    | _ ->\n        iter1 1 1I 1I 0I\n        |> iter2\n", "explain": "This is a fast [tail-recursive] approach using the F# big integer support:\nLazy evaluated using sequence workflow:\nThe above is extremely slow due to the nested recursions on sequences, which aren't very efficient at the best of times.  The above takes seconds just to compute the 30th Fibonacci number!\nLazy evaluation using the sequence unfold anamorphism is much much better as to efficiency:\nApproach similar to the Matrix algorithm in C#, with some shortcuts involved.\nSince it uses exponentiation by squaring, calculations of fib(n) where n is a power of 2 are particularly quick.\nEg. fib(2^20) was calculated in a little over 4 seconds on this poster's laptop.\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nRecursive[edit]\n\ndef rFib\nrFib = { \n    it == 0  \u00a0? 0 \n   \u00a0: it == 1\u00a0? 1 \n   \u00a0: it > 1 \u00a0? rFib(it-1) + rFib(it-2)\n    /*it < 0*/: rFib(it+2) - rFib(it+1)\n    \n}\nIterative[edit]\ndef iFib = { \n    it == 0  \u00a0? 0 \n   \u00a0: it == 1\u00a0? 1 \n   \u00a0: it > 1 \u00a0? (2..it).inject([0,1]){i, j -> [i[1], i[0]+i[1]]}[1]\n    /*it < 0*/: (-1..it).inject([0,1]){i, j -> [i[1]-i[0], i[0]]}[0]\n}\nAnalytic[edit]\nfinal \u03c6 = (1 + 5**(1/2))/2\ndef aFib = { (\u03c6**it - (-\u03c6)**(-it))/(5**(1/2)) as BigInteger }\n\ndef time = { Closure c ->\n    def start = System.currentTimeMillis()\n    def result = c()\n    def elapsedMS = (System.currentTimeMillis() - start)/1000\n    printf '(%6.4fs elapsed)', elapsedMS\n    result\n}\n\nprint \"  F(n)      elapsed time   \"; (-10..10).each { printf ' %3d', it }; println()\nprint \"--------- -----------------\"; (-10..10).each { print ' ---' }; println()\n[recursive:rFib, iterative:iFib, analytic:aFib].each { name, fib ->\n    printf \"%9s \", name\n    def fibList = time { (-10..10).collect {fib(it)} }\n    fibList.each { printf ' %3d', it }\n    println()\n}\n\nOutput:\n  F(n)      elapsed time    -10  -9  -8  -7  -6  -5  -4  -3  -2  -1   0   1   2   3   4   5   6   7   8   9  10\n--------- ----------------- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- --- ---\nrecursive (0.0080s elapsed) -55  34 -21  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13  21  34  55\niterative (0.0040s elapsed) -55  34 -21  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13  21  34  55\n analytic (0.0030s elapsed) -55  34 -21  13  -8   5  -3   2  -1   1   0   1   1   2   3   5   8  13  21  34  55\n", "explain": "Full \"extra credit\" solutions.\nA recursive closure must be pre-declared.\nTest program:\n"}, {"task_name": "Fibonacci sequence", "task_url": "https://rosettacode.org/wiki/Fibonacci_sequence", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\n$ awk 'func fib(n){return(n<2?n:fib(n-1)+fib(n-2))}{print \"fib(\"$1\")=\"fib($1)}'\n10\nfib(10)=55\n\n", "explain": "As in many examples, this one-liner contains the function as well as testing with input from stdin, output to stdout.\n"}]