[{"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "C", "code": "\n\ntcc -DSTRUCT=struct -DCONST=const -DINT=int -DCHAR=char -DVOID=void -DMAIN=main -DIF=if -DELSE=else -DWHILE=while -DFOR=for -DDO=do -DBREAK=break -DRETURN=return -DPUTCHAR=putchar UCCALENDAR.c\n\n/* UPPER CASE ONLY VERSION OF THE ORIGINAL CALENDAR.C, CHANGES MOSTLY TO AVOID NEEDING #INCLUDES */\n/* ERROR MESSAGES GO TO STDOUT TO SLIGHTLY SIMPLIFY THE I/O HANDLING                             */\n/* WHEN COMPILING THIS, THE COMMAND LINE SHOULD SPECIFY -D OPTIONS FOR THE FOLLOWING WORDS:      */\n/*    STRUCT, VOID, INT, CHAR, CONST, MAIN, IF, ELSE, WHILE, FOR, DO, BREAK, RETURN, PUTCHAR     */\n/* THE VALUE OF EACH MACRO SHOULD BE THE WORD IN LOWER-CASE                                      */\n\nINT PUTCHAR(INT);\n\nINT WIDTH = 80, YEAR = 1969;\nINT COLS, LEAD, GAP;\n \nCONST CHAR *WDAYS[] = { \"SU\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\" };\nSTRUCT MONTHS {\n    CONST CHAR *NAME;\n    INT DAYS, START_WDAY, AT;\n} MONTHS[12] = {\n    { \"JANUARY\",    31, 0, 0 },\n    { \"FEBRUARY\",    28, 0, 0 },\n    { \"MARCH\",    31, 0, 0 },\n    { \"APRIL\",    30, 0, 0 },\n    { \"MAY\",    31, 0, 0 },\n    { \"JUNE\",    30, 0, 0 },\n    { \"JULY\",    31, 0, 0 },\n    { \"AUGUST\",    31, 0, 0 },\n    { \"SEPTEMBER\",    30, 0, 0 },\n    { \"OCTOBER\",    31, 0, 0 },\n    { \"NOVEMBER\",    30, 0, 0 },\n    { \"DECEMBER\",    31, 0, 0 }\n};\n \nVOID SPACE(INT N) { WHILE (N-- > 0) PUTCHAR(' '); }\nVOID PRINT(CONST CHAR * S){ WHILE (*S != '\\0') { PUTCHAR(*S++); } }\nINT  STRLEN(CONST CHAR * S)\n{\n   INT L = 0;\n   WHILE (*S++ != '\\0') { L ++; };\nRETURN L;\n}\nINT ATOI(CONST CHAR * S)\n{\n    INT I = 0;\n    INT SIGN = 1;\n    CHAR C;\n    WHILE ((C = *S++) != '\\0') {\n        IF (C == '-')\n            SIGN *= -1;\n        ELSE {\n            I *= 10;\n            I += (C - '0');\n        }\n    }\nRETURN I * SIGN;\n}\n\nVOID INIT_MONTHS(VOID)\n{\n    INT I;\n \n    IF ((!(YEAR % 4) && (YEAR % 100)) || !(YEAR % 400))\n        MONTHS[1].DAYS = 29;\n \n    YEAR--;\n    MONTHS[0].START_WDAY\n        = (YEAR * 365 + YEAR/4 - YEAR/100 + YEAR/400 + 1) % 7;\n \n    FOR (I = 1; I < 12; I++)\n        MONTHS[I].START_WDAY =\n            (MONTHS[I-1].START_WDAY + MONTHS[I-1].DAYS) % 7;\n \n    COLS = (WIDTH + 2) / 22;\n    WHILE (12 % COLS) COLS--;\n    GAP = COLS - 1 ? (WIDTH - 20 * COLS) / (COLS - 1) : 0;\n    IF (GAP > 4) GAP = 4;\n    LEAD = (WIDTH - (20 + GAP) * COLS + GAP + 1) / 2;\n        YEAR++;\n}\n \nVOID PRINT_ROW(INT ROW)\n{\n    INT C, I, FROM = ROW * COLS, TO = FROM + COLS;\n    SPACE(LEAD);\n    FOR (C = FROM; C < TO; C++) {\n        I = STRLEN(MONTHS[C].NAME);\n        SPACE((20 - I)/2);\n        PRINT(MONTHS[C].NAME);\n        SPACE(20 - I - (20 - I)/2 + ((C == TO - 1) ? 0 : GAP));\n    }\n    PUTCHAR('\\012');\n \n    SPACE(LEAD);\n    FOR (C = FROM; C < TO; C++) {\n        FOR (I = 0; I < 7; I++) {\n            PRINT(WDAYS[I]);\n            PRINT(I == 6 ? \"\" : \" \");\n        }\n        IF (C < TO - 1) SPACE(GAP);\n        ELSE PUTCHAR('\\012');\n    }\n \n    WHILE (1) {\n        FOR (C = FROM; C < TO; C++)\n            IF (MONTHS[C].AT < MONTHS[C].DAYS) BREAK;\n        IF (C == TO) BREAK;\n \n        SPACE(LEAD);\n        FOR (C = FROM; C < TO; C++) {\n            FOR (I = 0; I < MONTHS[C].START_WDAY; I++) SPACE(3);\n            WHILE(I++ < 7 && MONTHS[C].AT < MONTHS[C].DAYS) {\n                INT MM = ++MONTHS[C].AT;\n                PUTCHAR((MM < 10) ? ' ' : '0' + (MM /10));\n                PUTCHAR('0' + (MM %10));\n                IF (I < 7 || C < TO - 1) PUTCHAR(' ');\n            }\n            WHILE (I++ <= 7 && C < TO - 1) SPACE(3);\n            IF (C < TO - 1) SPACE(GAP - 1);\n            MONTHS[C].START_WDAY = 0;\n        }\n        PUTCHAR('\\012');\n    }\n    PUTCHAR('\\012');\n}\n \nVOID PRINT_YEAR(VOID)\n{\n    INT Y = YEAR;\n    INT ROW;\n    CHAR BUF[32];\n    CHAR * B = &(BUF[31]);\n    *B-- = '\\0';\n    DO {\n        *B-- = '0' + (Y % 10);\n        Y /= 10;\n    } WHILE (Y > 0);\n    B++;\n    SPACE((WIDTH - STRLEN(B)) / 2);\n    PRINT(B);PUTCHAR('\\012');PUTCHAR('\\012');\n    FOR (ROW = 0; ROW * COLS < 12; ROW++)\n        PRINT_ROW(ROW);\n}\n \nINT MAIN(INT C, CHAR **V)\n{\n    INT I, YEAR_SET = 0, RESULT = 0;\n    FOR (I = 1; I < C && RESULT == 0; I++) {\n        IF (V[I][0] == '-' && V[I][1] == 'W' && V[I][2] == '\\0') {\n            IF (++I == C || (WIDTH = ATOI(V[I])) < 20)\n                RESULT = 1;\n        } ELSE IF (!YEAR_SET) {\n            YEAR = ATOI(V[I]);\n            IF (YEAR <= 0)\n                YEAR = 1969;\n            YEAR_SET = 1;\n        } ELSE\n            RESULT = 1;\n    }\n \n    IF (RESULT == 0) {\n        INIT_MONTHS();\n        PRINT_YEAR();\n    } ELSE {\n        PRINT(\"BAD ARGS\\012USAGE: \");\n        PRINT(V[0]);\n        PRINT(\" YEAR [-W WIDTH (>= 20)]\\012\");\n    }\nRETURN RESULT;\n}\n\n", "explain": "Note: Historically, some UNIX systems were connected to upper-case only terminals, and users of those systems needed to write C programs. One could configure the terminal using the \"stty\" command, setting the olcuc and iuclc options to translate uppercase to lowercase on input, and convert lowercase to uppercase on output (although typically the setting was applied by the \"getty\" program so that logging in would be possible).\nSo the text that was actually saved in the C source code would be lowercase, but it would appear on the terminal as uppercase.\n\nThis would also apply to any other language source or document.\n\n\nModern versions of Linux and MacOS have preserved this feature.\n\n\nHowever, the following is an actual upper-case only version of the C Calendar task.\nIt relies on the ability of most C compilers to allow #defines to be specified on the command line and also declares the putchar function to avoid needing any #includes (neither #define nor #include could be specified in upper-case without a non-standard pre-processor).\n\nThe program can be compiled with the following (substitute the name of your compiler for tcc):\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Visual_Basic_.NET", "code": "\n\nWorks with: .NET Core version 2.1\n\nOPTION COMPARE BINARY\nOPTION EXPLICIT ON\nOPTION INFER ON\nOPTION STRICT ON\n\nIMPORTS SYSTEM.GLOBALIZATION\nIMPORTS SYSTEM.TEXT\nIMPORTS SYSTEM.RUNTIME.INTEROPSERVICES\nIMPORTS SYSTEM.RUNTIME.COMPILERSERVICES\n\nMODULE ARGHELPER\n    READONLY _ARGDICT AS NEW DICTIONARY(OF STRING, STRING)()\n\n    DELEGATE FUNCTION TRYPARSE(OF T, TRESULT)(VALUE AS T, <OUT> BYREF RESULT AS TRESULT) AS BOOLEAN\n\n    SUB INITIALIZEARGUMENTS(ARGS AS STRING())\n        FOR EACH ITEM IN ARGS\n            ITEM = ITEM.TOUPPERINVARIANT()\n\n            IF ITEM.LENGTH > 0 ANDALSO ITEM(0) <> \"\"\"\"C THEN\n                DIM COLONPOS = ITEM.INDEXOF(\":\"C, STRINGCOMPARISON.ORDINAL)\n\n                IF COLONPOS <> -1 THEN\n                    ' SPLIT ARGUMENTS WITH COLUMNS INTO KEY(PART BEFORE COLON) / VALUE(PART AFTER COLON) PAIRS.\n                    _ARGDICT.ADD(ITEM.SUBSTRING(0, COLONPOS), ITEM.SUBSTRING(COLONPOS + 1, ITEM.LENGTH - COLONPOS - 1))\n                END IF\n            END IF\n        NEXT\n    END SUB\n\n    SUB FROMARGUMENT(OF T)(\n            KEY AS STRING,\n            <OUT> BYREF VAR AS T,\n            GETDEFAULT AS FUNC(OF T),\n            TRYPARSE AS TRYPARSE(OF STRING, T),\n            OPTIONAL VALIDATE AS PREDICATE(OF T) = NOTHING)\n\n        DIM VALUE AS STRING = NOTHING\n        IF _ARGDICT.TRYGETVALUE(KEY.TOUPPERINVARIANT(), VALUE) THEN\n            IF NOT (TRYPARSE(VALUE, VAR) ANDALSO (VALIDATE IS NOTHING ORELSE VALIDATE(VAR))) THEN\n                CONSOLE.WRITELINE($\"INVALID VALUE FOR {KEY}: {VALUE}\")\n                ENVIRONMENT.EXIT(-1)\n            END IF\n        ELSE\n            VAR = GETDEFAULT()\n        END IF\n    END SUB\nEND MODULE\n\nMODULE PROGRAM\n    SUB MAIN(ARGS AS STRING())\n        DIM DT AS DATE\n        DIM COLUMNS, ROWS, MONTHSPERROW AS INTEGER\n        DIM VERTSTRETCH, HORIZSTRETCH, RESIZEWINDOW AS BOOLEAN\n\n        INITIALIZEARGUMENTS(ARGS)\n        FROMARGUMENT(\"DATE\", DT, FUNCTION() NEW DATE(1969, 1, 1), ADDRESSOF DATE.TRYPARSE)\n        FROMARGUMENT(\"COLS\", COLUMNS, FUNCTION() 80, ADDRESSOF INTEGER.TRYPARSE, FUNCTION(V) V >= 20)\n        FROMARGUMENT(\"ROWS\", ROWS, FUNCTION() 43, ADDRESSOF INTEGER.TRYPARSE, FUNCTION(V) V >= 0)\n        FROMARGUMENT(\"MS/ROW\", MONTHSPERROW, FUNCTION() 0, ADDRESSOF INTEGER.TRYPARSE, FUNCTION(V) V <= 12 ANDALSO V <= COLUMNS \\ 20)\n        FROMARGUMENT(\"VSTRETCH\", VERTSTRETCH, FUNCTION() TRUE, ADDRESSOF BOOLEAN.TRYPARSE)\n        FROMARGUMENT(\"HSTRETCH\", HORIZSTRETCH, FUNCTION() TRUE, ADDRESSOF BOOLEAN.TRYPARSE)\n        FROMARGUMENT(\"WSIZE\", RESIZEWINDOW, FUNCTION() TRUE, ADDRESSOF BOOLEAN.TRYPARSE)\n\n        ' THE SCROLL BAR IN COMMAND PROMPT SEEMS TO TAKE UP PART OF THE LAST COLUMN.\n        IF RESIZEWINDOW THEN\n            CONSOLE.WINDOWWIDTH = COLUMNS + 1\n            CONSOLE.WINDOWHEIGHT = ROWS\n        END IF\n\n        IF MONTHSPERROW < 1 THEN MONTHSPERROW = MATH.MAX(COLUMNS \\ 22, 1)\n\n        FOR EACH ROW IN GETCALENDARROWS(DT:=DT, WIDTH:=COLUMNS, HEIGHT:=ROWS, MONTHSPERROW:=MONTHSPERROW, VERTSTRETCH:=VERTSTRETCH, HORIZSTRETCH:=HORIZSTRETCH)\n            CONSOLE.WRITE(ROW)\n        NEXT\n    END SUB\n\n    ITERATOR FUNCTION GETCALENDARROWS(\n            DT AS DATE,\n            WIDTH AS INTEGER,\n            HEIGHT AS INTEGER,\n            MONTHSPERROW AS INTEGER,\n            VERTSTRETCH AS BOOLEAN,\n            HORIZSTRETCH AS BOOLEAN) AS IENUMERABLE(OF STRING)\n\n        DIM YEAR = DT.YEAR\n        DIM CALENDARROWCOUNT AS INTEGER = CINT(MATH.CEILING(12 / MONTHSPERROW))\n        ' MAKE ROOM FOR THE THREE EMPTY LINES ON TOP.\n        DIM MONTHGRIDHEIGHT AS INTEGER = HEIGHT - 3\n\n        YIELD \"[SNOOPY]\".PADCENTER(WIDTH) & ENVIRONMENT.NEWLINE\n        YIELD YEAR.TOSTRING(CULTUREINFO.INVARIANTCULTURE).PADCENTER(WIDTH) & ENVIRONMENT.NEWLINE\n        YIELD ENVIRONMENT.NEWLINE\n\n        DIM MONTH = 0\n        DO WHILE MONTH < 12\n            DIM ROWHIGHESTMONTH = MATH.MIN(MONTH + MONTHSPERROW, 12)\n\n            DIM CELLWIDTH = WIDTH \\ MONTHSPERROW\n            DIM CELLCONTENTWIDTH = IF(MONTHSPERROW = 1, CELLWIDTH, (CELLWIDTH * 19) \\ 20)\n\n            DIM CELLHEIGHT = MONTHGRIDHEIGHT \\ CALENDARROWCOUNT\n            DIM CELLCONTENTHEIGHT = (CELLHEIGHT * 19) \\ 20\n\n            ' CREATES A MONTH CELL FOR THE SPECIFIED MONTH (1-12).\n            DIM GETMONTHFROM =\n                FUNCTION(M AS INTEGER) BUILDMONTH(\n                    DT:=NEW DATE(DT.YEAR, M, 1),\n                    WIDTH:=CELLCONTENTWIDTH,\n                    HEIGHT:=CELLCONTENTHEIGHT,\n                    VERTSTRETCH:=VERTSTRETCH,\n                    HORIZSTRETCH:=HORIZSTRETCH).SELECT(FUNCTION(X) X.PADCENTER(CELLWIDTH))\n\n            ' THE MONTHS IN THIS ROW OF THE CALENDAR.\n            DIM MONTHSTHISROW AS IENUMERABLE(OF IENUMERABLE(OF STRING)) =\n                ENUMERABLE.SELECT(ENUMERABLE.RANGE(MONTH + 1, ROWHIGHESTMONTH - MONTH), GETMONTHFROM)\n\n            DIM CALENDARROW AS IENUMERABLE(OF STRING) =\n                INTERLEAVED(\n                    MONTHSTHISROW,\n                    USEINNERSEPARATOR:=FALSE,\n                    USEOUTERSEPARATOR:=TRUE,\n                    OUTERSEPARATOR:=ENVIRONMENT.NEWLINE)\n\n            DIM EN = CALENDARROW.GETENUMERATOR()\n            DIM HASNEXT = EN.MOVENEXT()\n            DO WHILE HASNEXT\n\n                DIM CURRENT AS STRING = EN.CURRENT\n\n                ' TO MAINTAIN THE (NOT STRICTLY NEEDED) CONTRACT OF YIELDING COMPLETE ROWS, KEEP THE NEWLINE AFTER\n                ' THE CALENDAR ROW WITH THE LAST TERMINAL ROW OF THE ROW.\n                HASNEXT = EN.MOVENEXT()\n                YIELD IF(HASNEXT, CURRENT, CURRENT & ENVIRONMENT.NEWLINE)\n            LOOP\n\n            MONTH += MONTHSPERROW\n        LOOP\n    END FUNCTION\n\n    ''' <SUMMARY>\n    ''' INTERLEAVES THE ELEMENTS OF THE SPECIFIED SUB-SOURCES BY MAKING SUCCESSIVE PASSES THROUGH THE SOURCE\n    ''' ENUMERABLE, YIELDING A SINGLE ELEMENT FROM EACH SUB-SOURCE IN SEQUENCE IN EACH PASS, OPTIONALLY INSERTING A\n    ''' SEPARATOR BETWEEN ELEMENTS OF ADJACENT SUB-SOURCES AND OPTIONALLY A DIFFERENT SEPARATOR AT THE END OF EACH\n    ''' PASS THROUGH ALL THE SOURCES. (I.E., BETWEEN ELEMENTS OF THE LAST AND FIRST SOURCE)\n    ''' </SUMMARY>\n    ''' <TYPEPARAM NAME=\"T\">THE TYPE OF THE ELEMENTS OF THE SUB-SOURCES.</TYPEPARAM>\n    ''' <PARAM NAME=\"SOURCES\">A SEQUENCE OF THE SEQUENCES WHOSE ELEMENTS ARE TO BE INTERLEAVED.</PARAM>\n    ''' <PARAM NAME=\"USEINNERSEPARATOR\">WHETHER TO INSERT <PARAMREF NAME=\"USEINNERSEPARATOR\"/> BETWEEN THE ELEMENTS OFADJACENT SUB-SOURCES.</PARAM>\n    ''' <PARAM NAME=\"INNERSEPARATOR\">THE SEPARATOR BETWEEN ELEMENTS OF ADJACENT SUB-SOURCES.</PARAM>\n    ''' <PARAM NAME=\"USEOUTERSEPARATOR\">WHETHER TO INSERT <PARAMREF NAME=\"OUTERSEPARATOR\"/> BETWEEN THE ELEMENTS OF THE LAST AND FIRST SUB-SOURCES.</PARAM>\n    ''' <PARAM NAME=\"OUTERSEPARATOR\">THE SEPARATOR BETWEEN ELEMENTS OF THE LAST AND FIRST SUB-SOURCE.</PARAM>\n    ''' <PARAM NAME=\"WHILEANY\">IF <SEE LANGWORD=\"TRUE\"/>, THE ENUMERATION CONTINUES UNTIL EVERY GIVEN SUBSOURCE IS EMPTY;\n    ''' IF <SEE LANGWORD=\"FALSE\"/>, THE ENUMERATION STOPS AS SOON AS ANY ENUMERABLE NO LONGER HAS AN ELEMENT TO SUPPLY FOR THE NEXT PASS.</PARAM>\n    ITERATOR FUNCTION INTERLEAVED(OF T)(\n            SOURCES AS IENUMERABLE(OF IENUMERABLE(OF T)),\n            OPTIONAL USEINNERSEPARATOR AS BOOLEAN = FALSE,\n            OPTIONAL INNERSEPARATOR AS T = NOTHING,\n            OPTIONAL USEOUTERSEPARATOR AS BOOLEAN = FALSE,\n            OPTIONAL OUTERSEPARATOR AS T = NOTHING,\n            OPTIONAL WHILEANY AS BOOLEAN = TRUE) AS IENUMERABLE(OF T)\n        DIM SOURCEENUMERATORS AS IENUMERATOR(OF T)() = NOTHING\n\n        TRY\n            SOURCEENUMERATORS = SOURCES.SELECT(FUNCTION(X) X.GETENUMERATOR()).TOARRAY()\n            DIM NUMSOURCES = SOURCEENUMERATORS.LENGTH\n            DIM ENUMERATORSTATES(NUMSOURCES - 1) AS BOOLEAN\n\n            DIM ANYPREVITERS AS BOOLEAN = FALSE\n            DO\n                ' INDICES OF FIRST AND LAST SUB-SOURCES THAT HAVE ELEMENTS.\n                DIM FIRSTACTIVE = -1, LASTACTIVE = -1\n\n                ' DETERMINE WHETHER EACH SUB-SOURCE THAT STILL HAVE ELEMENTS.\n                FOR I = 0 TO NUMSOURCES - 1\n                    ENUMERATORSTATES(I) = SOURCEENUMERATORS(I).MOVENEXT()\n                    IF ENUMERATORSTATES(I) THEN\n                        IF FIRSTACTIVE = -1 THEN FIRSTACTIVE = I\n                        LASTACTIVE = I\n                    END IF\n                NEXT\n\n                ' DETERMINE WHETHER TO YIELD ANYTHING IN THIS ITERATION BASED ON WHETHER WHILEANY IS TRUE.\n                ' NOT YIELDING ANYTHING THIS ITERATION IMPLIES THAT THE ENUMERATION HAS ENDED.\n                DIM THISITERHASRESULTS AS BOOLEAN = IF(WHILEANY, FIRSTACTIVE <> -1, FIRSTACTIVE = 0 ANDALSO LASTACTIVE = NUMSOURCES - 1)\n                IF NOT THISITERHASRESULTS THEN EXIT DO\n\n                ' DON'T INSERT A SEPARATOR ON THE FIRST PASS.\n                IF ANYPREVITERS THEN\n                    IF USEOUTERSEPARATOR THEN YIELD OUTERSEPARATOR\n                ELSE\n                    ANYPREVITERS = TRUE\n                END IF\n\n                ' GO THROUGH AND YIELD FROM THE SUB-SOURCES THAT STILL HAVE ELEMENTS.\n                FOR I = 0 TO NUMSOURCES - 1\n                    IF ENUMERATORSTATES(I) THEN\n                        ' DON'T INSERT A SEPARATOR BEFORE THE FIRST ELEMENT.\n                        IF I > FIRSTACTIVE ANDALSO USEINNERSEPARATOR THEN YIELD INNERSEPARATOR\n                        YIELD SOURCEENUMERATORS(I).CURRENT\n                    END IF\n                NEXT\n            LOOP\n\n        FINALLY\n            IF SOURCEENUMERATORS ISNOT NOTHING THEN\n                FOR EACH EN IN SOURCEENUMERATORS\n                    EN.DISPOSE()\n                NEXT\n            END IF\n        END TRY\n    END FUNCTION\n\n    ''' <SUMMARY>\n    ''' RETURNS THE ROWS REPRESENTING ONE MONTH CELL WITHOUT TRAILING NEWLINES. APPROPRIATE LEADING AND TRAILING\n    ''' WHITESPACE IS ADDED SO THAT EVERY ROW HAS THE LENGTH OF WIDTH.\n    ''' </SUMMARY>\n    ''' <PARAM NAME=\"DT\">A DATE WITHIN THE MONTH TO REPRESENT.</PARAM>\n    ''' <PARAM NAME=\"WIDTH\">THE WIDTH OF THE CELL.</PARAM>\n    ''' <PARAM NAME=\"HEIGHT\">THE HEIGHT.</PARAM>\n    ''' <PARAM NAME=\"VERTSTRETCH\">IF <SEE LANGWORD=\"TRUE\" />, BLANK ROWS ARE INSERTED TO FIT THE AVAILABLE HEIGHT.\n    ''' OTHERWISE, THE CELL HAS A CONSTANT HEIGHT OF </PARAM>\n    ''' <PARAM NAME=\"HORIZSTRETCH\">IF <SEE LANGWORD=\"TRUE\" />, THE SPACING BETWEEN INDIVIDUAL DAYS IS INCREASED TO\n    ''' FIT THE AVAILABLE WIDTH. OTHERWISE, THE CELL HAS A CONSTANT WIDTH OF 20 CHARACTERS AND IS PADDED TO BE IN\n    ''' THE CENTER OF THE EXPECTED WIDTH.</PARAM>\n    ITERATOR FUNCTION BUILDMONTH(DT AS DATE, WIDTH AS INTEGER, HEIGHT AS INTEGER, VERTSTRETCH AS BOOLEAN, HORIZSTRETCH AS BOOLEAN) AS IENUMERABLE(OF STRING)\n        CONST DAY_WDT = 2 ' WIDTH OF A DAY.\n        CONST ALLDAYS_WDT = DAY_WDT * 7 ' WIDTH OF AL LDAYS COMBINED.\n\n        ' NORMALIZE THE DATE TO JANUARY 1.\n        DT = NEW DATE(DT.YEAR, DT.MONTH, 1)\n\n        ' HORIZONTAL WHITESPACE BETWEEN DAYS OF THE WEEK. CONSTANT OF 6 REPRESENTS 6 SEPARATORS PER LINE.\n        DIM DAYSEP AS NEW STRING(\" \"C, MATH.MIN((WIDTH - ALLDAYS_WDT) \\ 6, IF(HORIZSTRETCH, INTEGER.MAXVALUE, 1)))\n        ' NUMBER OF BLANK LINES BETWEEN ROWS.\n        DIM VERTBLANKCOUNT = IF(NOT VERTSTRETCH, 0, (HEIGHT - 8) \\ 7)\n\n        ' WIDTH OF EACH DAY * 7 DAYS IN ONE ROW + DAY SEPARATOR LENGTH * 6 SEPARATORS PER LINE.\n        DIM BLOCKWIDTH = ALLDAYS_WDT + DAYSEP.LENGTH * 6\n\n        ' THE WHITESPACE AT THE BEGINNING OF EACH LINE.\n        DIM LEFTPAD AS NEW STRING(\" \"C, (WIDTH - BLOCKWIDTH) \\ 2)\n        ' THE WHITESPACE FOR BLANK LINES.\n        DIM FULLPAD AS NEW STRING(\" \"C, WIDTH)\n\n        ' LINES ARE \"STAGED\" IN THE STRINGBUILDER.\n        DIM SB AS NEW STRINGBUILDER(LEFTPAD)\n        DIM NUMLINES = 0\n\n        ' GET THE CURRENT LINE SO FAR FORM THE STRINGBUILDER AND BEGIN A NEW LINE.\n        ' RETURNS THE CURRENT LINE AND TRAILING BLANK LINES USED FOR VERTICAL PADDING (IF ANY).\n        ' RETURNS EMPTY ENUMERABLE IF THE HEIGHT REQUIREMENT HAS BEEN REACHED.\n        DIM ENDLINE =\n         FUNCTION() AS IENUMERABLE(OF STRING)\n             DIM FINISHEDLINE AS STRING = SB.TOSTRING().PADRIGHT(WIDTH)\n             SB.CLEAR()\n             SB.APPEND(LEFTPAD)\n\n             ' USE AN INNER ITERATOR TO PREVENT LAZY EXECUTION OF SIDE EFFECTS OF OUTER FUNCTION.\n             RETURN IF(NUMLINES >= HEIGHT,\n                 ENUMERABLE.EMPTY(OF STRING)(),\n                 ITERATOR FUNCTION() AS IENUMERABLE(OF STRING)\n                     YIELD FINISHEDLINE\n                     NUMLINES += 1\n\n                     FOR I = 1 TO VERTBLANKCOUNT\n                         IF NUMLINES >= HEIGHT THEN RETURN\n                         YIELD FULLPAD\n                         NUMLINES += 1\n                     NEXT\n                 END FUNCTION())\n         END FUNCTION\n\n        ' YIELD THE MONTH NAME.\n        SB.APPEND(PADCENTER(DT.TOSTRING(\"MMMM\", CULTUREINFO.INVARIANTCULTURE), BLOCKWIDTH).TOUPPER())\n        FOR EACH L IN ENDLINE()\n            YIELD L\n        NEXT\n\n        ' YIELD THE HEADER OF WEEKDAY NAMES.\n        DIM WEEKNMABBREVS = [ENUM].GETNAMES(GETTYPE(DAYOFWEEK)).SELECT(FUNCTION(X) X.SUBSTRING(0, 2).TOUPPER())\n        SB.APPEND(STRING.JOIN(DAYSEP, WEEKNMABBREVS))\n        FOR EACH L IN ENDLINE()\n            YIELD L\n        NEXT\n\n        ' DAY OF WEEK OF FIRST DAY OF MONTH.\n        DIM STARTWKDY = CINT(DT.DAYOFWEEK)\n\n        ' INITIALIZE WITH EMPTY SPACE FOR THE FIRST LINE.\n        DIM FIRSTPAD AS NEW STRING(\" \"C, (DAY_WDT + DAYSEP.LENGTH) * STARTWKDY)\n        SB.APPEND(FIRSTPAD)\n\n        DIM D = DT\n        DO WHILE D.MONTH = DT.MONTH\n            SB.APPENDFORMAT(CULTUREINFO.INVARIANTCULTURE, $\"{{0,{DAY_WDT}}}\", D.DAY)\n\n            ' EACH ROW ENDS ON SATURDAY.\n            IF D.DAYOFWEEK = DAYOFWEEK.SATURDAY THEN\n                FOR EACH L IN ENDLINE()\n                    YIELD L\n                NEXT\n            ELSE\n                SB.APPEND(DAYSEP)\n            END IF\n\n            D = D.ADDDAYS(1)\n        LOOP\n\n        ' KEEP ADDING EMPTY LINES UNTIL THE HEIGHT QUOTA IS MET.\n        DIM NEXTLINES AS IENUMERABLE(OF STRING)\n        DO\n            NEXTLINES = ENDLINE()\n            FOR EACH L IN NEXTLINES\n                YIELD L\n            NEXT\n        LOOP WHILE NEXTLINES.ANY()\n    END FUNCTION\n\n    ''' <SUMMARY>\n    ''' RETURNS A NEW STRING THAT CENTER-ALIGNS THE CHARACTERS IN THIS STRING BY PADDING TO THE LEFT AND RIGHT WITH\n    ''' THE SPECIFIED CHARACTER TO A SPECIFIED TOTAL LENGTH.\n    ''' </SUMMARY>\n    ''' <PARAM NAME=\"S\">THE STRING TO CENTER-ALIGN.</PARAM>\n    ''' <PARAM NAME=\"TOTALWIDTH\">THE NUMBER OF CHARACTERS IN THE RESULTING STRING.</PARAM>\n    ''' <PARAM NAME=\"PADDINGCHAR\">THE PADDING CHARACTER.</PARAM>\n    <EXTENSION()>\n    PRIVATE FUNCTION PADCENTER(S AS STRING, TOTALWIDTH AS INTEGER, OPTIONAL PADDINGCHAR AS CHAR = \" \"C) AS STRING\n        RETURN S.PADLEFT(((TOTALWIDTH - S.LENGTH) \\ 2) + S.LENGTH, PADDINGCHAR).PADRIGHT(TOTALWIDTH, PADDINGCHAR)\n    END FUNCTION\nEND MODULE\n\n\nOutput \u00a0\u2014\u00a0 for input COLS:132 ROWS:25 MS/ROW:6 HSTRETCH:FALSE VSTRETCH:FALSE:\n                                                              [SNOOPY]                                                              \n                                                                1969                                                                \n\n       JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE         \n SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA \n           1  2  3  4                     1                     1         1  2  3  4  5               1  2  3   1  2  3  4  5  6  7 \n  5  6  7  8  9 10 11   2  3  4  5  6  7  8   2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10   8  9 10 11 12 13 14 \n 12 13 14 15 16 17 18   9 10 11 12 13 14 15   9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21 \n 19 20 21 22 23 24 25  16 17 18 19 20 21 22  16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28 \n 26 27 28 29 30 31     23 24 25 26 27 28     23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31  29 30                \n                                             30 31                                                                                  \n                                                                                                                                    \n                                                                                                                                    \n         JULY                 AUGUST              SEPTEMBER              OCTOBER               NOVEMBER              DECEMBER       \n SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA \n        1  2  3  4  5                  1  2      1  2  3  4  5  6            1  2  3  4                     1      1  2  3  4  5  6 \n  6  7  8  9 10 11 12   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8   7  8  9 10 11 12 13 \n 13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15  14 15 16 17 18 19 20 \n 20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27 \n 27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31          \n                       31                                                                30                                         \n                                                                                                                                    \n                                                                                                                                    \n\n", "explain": "Compiler: Roslyn Visual Basic (language version >= 15.8)\nCopied from Calendar#Visual_Basic_.NET and converted to uppercase. See entry there for description.\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "PHP", "code": "\n\n<?PHP\nECHO <<<REALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n       JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n        1  2  3  4  5                  1  2                  1  2      1  2  3  4  5  6            1  2  3  4                     1\n  6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8\n 13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15\n 20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22\n 27 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29\n                                             31                                                                30 \n\n         JULY                 AUGUST               SEPTEMBER              OCTOBER              NOVEMBER              DECEMBER\n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n     1  2  3  4  5  6               1  2  3   1  2  3  4  5  6  7         1  2  3  4  5                  1  2   1  2  3  4  5  6  7\n  7  8  9 10 11 12 13   4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14\n 14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21\n 21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28\n 28 29 30 31           25 26 27 28 29 30 31  29 30                 27 28 29 30 31        24 25 26 27 28 29 30  29 30 31\nREALPROGRAMMERSTHINKINUPPERCASEANDCHEATBYUSINGPRINT\n                                                                                                             ; // MAGICAL SEMICOLON\n\n", "explain": "While PHP functions are case-sensitive (aside of _()), this isn't the case for language constructs.\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Fortran", "code": "\n\n       MODULE DATEGNASH\n\n       TYPE DATEBAG\n        INTEGER DAY,MONTH,YEAR\n       END TYPE DATEBAG\n\n       CHARACTER*9 MONTHNAME(12),DAYNAME(0:6)\n       PARAMETER (MONTHNAME = (/\"JANUARY\",\"FEBRUARY\",\"MARCH\",\"APRIL\",\n     1  \"MAY\",\"JUNE\",\"JULY\",\"AUGUST\",\"SEPTEMBER\",\"OCTOBER\",\"NOVEMBER\",\n     2  \"DECEMBER\"/))\n       PARAMETER (DAYNAME = (/\"SUNDAY\",\"MONDAY\",\"TUESDAY\",\"WEDNESDAY\",\n     1  \"THURSDAY\",\"FRIDAY\",\"SATURDAY\"/))\n\n       INTEGER*4 JDAYSHIFT\n       PARAMETER (JDAYSHIFT = 2415020)\n       CONTAINS\n       INTEGER FUNCTION LSTNB(TEXT)\n        CHARACTER*(*),INTENT(IN):: TEXT\n        INTEGER L\n         L = LEN(TEXT)\n    1    IF (L.LE.0) GO TO 2\n         IF (ICHAR(TEXT(L:L)).GT.ICHAR(\" \")) GO TO 2\n         L = L - 1\n         GO TO 1\n    2    LSTNB = L\n        RETURN\n       END FUNCTION LSTNB\n      CHARACTER*2 FUNCTION I2FMT(N)\n       INTEGER*4 N\n        IF (N.LT.0) THEN\n          IF (N.LT.-9) THEN\n            I2FMT = \"-!\"\n           ELSE\n            I2FMT = \"-\"//CHAR(ICHAR(\"0\") - N)\n          END IF\n        ELSE IF (N.LT.10) THEN\n          I2FMT = \" \" //CHAR(ICHAR(\"0\") + N)\n        ELSE IF (N.LT.100) THEN\n          I2FMT = CHAR(N/10      + ICHAR(\"0\"))\n     1           //CHAR(MOD(N,10) + ICHAR(\"0\"))\n        ELSE\n          I2FMT = \"+!\"\n        END IF\n      END FUNCTION I2FMT\n      CHARACTER*8 FUNCTION I8FMT(N)\n       INTEGER*4 N\n       CHARACTER*8 HIC\n        WRITE (HIC,1) N\n    1   FORMAT (I8)\n        I8FMT = HIC\n      END FUNCTION I8FMT\n\n      SUBROUTINE SAY(OUT,TEXT)\n       INTEGER OUT\n       CHARACTER*(*) TEXT\n        WRITE (6,1) TEXT(1:LSTNB(TEXT))\n    1   FORMAT (A)\n      END SUBROUTINE SAY\n\n       INTEGER*4 FUNCTION DAYNUM(YY,M,D)\n        INTEGER*4 JDAYN\n        INTEGER YY,Y,M,MM,D\n         Y = YY\n         IF (Y.LT.1) Y = Y + 1\n         MM = (M - 14)/12\n         JDAYN = D - 32075\n     A    + 1461*(Y + 4800  + MM)/4\n     B    +  367*(M - 2     - MM*12)/12\n     C    -    3*((Y + 4900 + MM)/100)/4\n         DAYNUM = JDAYN - JDAYSHIFT\n       END FUNCTION DAYNUM\n\n       TYPE(DATEBAG) FUNCTION MUNYAD(DAYNUM)\n        INTEGER*4 DAYNUM,JDAYN\n        INTEGER Y,M,D,L,N\n         JDAYN = DAYNUM + JDAYSHIFT\n         L = JDAYN + 68569\n         N = 4*L/146097\n         L = L - (146097*N + 3)/4\n         Y = 4000*(L + 1)/1461001\n         L = L - 1461*Y/4 + 31\n         M = 80*L/2447\n         D = L - 2447*M/80\n         L = M/11\n         M = M + 2 - 12*L\n         Y = 100*(N - 49) + Y + L\n         IF (Y.LT.1) Y = Y - 1\n         MUNYAD%YEAR  = Y\n         MUNYAD%MONTH = M\n         MUNYAD%DAY   = D\n       END FUNCTION MUNYAD\n\n       INTEGER FUNCTION PMOD(N,M)\n        INTEGER N,M\n         PMOD = MOD(MOD(N,M) + M,M)\n       END FUNCTION PMOD\n\n      SUBROUTINE CALENDAR(Y1,Y2,COLUMNS)\n\n       INTEGER Y1,Y2,YEAR\n       INTEGER M,M1,M2,MONTH\n       INTEGER*4 DN1,DN2,DN,D\n       INTEGER W,G\n       INTEGER L,LINE\n       INTEGER COL,COLUMNS,COLWIDTH\n       CHARACTER*200 STRIPE(6),SPECIAL(6),MLINE,DLINE\n        W = 3\n        G = 1\n        COLWIDTH = 7*W + G\n      Y:DO YEAR = Y1,Y2\n          CALL SAY(MSG,\"\")\n          IF (YEAR.EQ.0) THEN\n            CALL SAY(MSG,\"THERE IS NO YEAR ZERO.\")\n            CYCLE Y\n          END IF\n          MLINE = \"\"\n          L = (COLUMNS*COLWIDTH - G - 8)/2\n          IF (YEAR.GT.0) THEN\n            MLINE(L:) = I8FMT(YEAR)\n           ELSE\n            MLINE(L - 1:) = I8FMT(-YEAR)//\"BC\"\n          END IF\n          CALL SAY(MSG,MLINE)\n          DO MONTH = 1,12,COLUMNS\n            M1 = MONTH\n            M2 = MIN(12,M1 + COLUMNS - 1)\n            MLINE = \"\"\n            DLINE = \"\"\n            STRIPE = \"\"\n            SPECIAL = \"\"\n            L0 = 1\n            DO M = M1,M2\n              L = (COLWIDTH - G - LSTNB(MONTHNAME(M)))/2 - 1\n              MLINE(L0 + L:) = MONTHNAME(M)\n              DO D = 0,6\n                L = L0 + (3 - W) + D*W\n                DLINE(L:L + 2) = DAYNAME(D)(1:W - 1)\n              END DO\n              DN1 = DAYNUM(YEAR,M,1)\n              DN2 = DAYNUM(YEAR,M + 1,0)\n              COL = MOD(PMOD(DN1,7) + 7,7)\n              LINE = 1\n              D = 1\n              DO DN = DN1,DN2\n                L = L0 + COL*W\n                STRIPE(LINE)(L:L + 1) = I2FMT(D)\n                D = D + 1\n                COL = COL + 1\n                IF (COL.GT.6) THEN\n                  LINE = LINE + 1\n                  COL = 0\n                END IF\n              END DO\n              L0 = L0 + 7*W + G\n            END DO\n            CALL SAY(MSG,MLINE)\n            CALL SAY(MSG,DLINE)\n            DO LINE = 1,6\n              IF (STRIPE(LINE).NE.\"\") THEN\n                CALL SAY(MSG,STRIPE(LINE))\n              END IF\n            END DO\n          END DO\n        END DO Y\n        CALL SAY(MSG,\"\")\n      END SUBROUTINE CALENDAR\n      END MODULE DATEGNASH\n\n      PROGRAM SHOW1968\n       USE DATEGNASH\n       INTEGER NCOL\n        DO NCOL = 1,6\n          CALL CALENDAR(1969,1969,NCOL)\n        END DO\n      END\n\n\n                                                                1969\n      JANUARY              FEBRUARY                MARCH                 APRIL                  MAY                  JUNE\nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n          1  2  3  4                     1                     1         1  2  3  4  5               1  2  3   1  2  3  4  5  6  7\n 5  6  7  8  9 10 11   2  3  4  5  6  7  8   2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10   8  9 10 11 12 13 14\n12 13 14 15 16 17 18   9 10 11 12 13 14 15   9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21\n19 20 21 22 23 24 25  16 17 18 19 20 21 22  16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28\n26 27 28 29 30 31     23 24 25 26 27 28     23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31  29 30\n                                            30 31\n       JULY                 AUGUST               SEPTEMBER              OCTOBER              NOVEMBER              DECEMBER\nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n       1  2  3  4  5                  1  2      1  2  3  4  5  6            1  2  3  4                     1      1  2  3  4  5  6\n 6  7  8  9 10 11 12   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8   7  8  9 10 11 12 13\n13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15  14 15 16 17 18 19 20\n20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27\n27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31\n                      31                                                                30\n\n\n", "explain": "Alas, the header \"FORTRAN\" is not recognised - REAL programmers were absent that day? Even upon the apperance of lower case, I have preferred to use shouting for programme source, and normal upper/lower case for commentary. Aside from petty details such as 1 and l being nowhere as distinct as 1 and L, this allows the two sorts of blather to be identifiably different without ratiocination as the hours drag past. Further, the names of variables can easily be distinguished from the same word in discussion, as in ... the text in TEXT will be printed as the subtitle to the text in TITLE ... Anyway, in the spirit of old, herewith the source without tedious commentary:\nAnd for output, the wide form:\nActual lineprinters offer the opportunity of overprinting lines so double (or triple) printing of the same text gave a bold effect if with some blurring due to wobble. Further decoration was possible: via underlines (and for overlines, an underline on the previous line) the appearance can be improved. Vertical bars can also be used, and more advanced lineprinters (IBM1403 etc. using the \"TN\" chain) or dot-matrix printers also supplied \"corner\" glyphs so that boxes would not have leaks.\n\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Go", "code": "\n\nPACKAGE MAIN\n \nIMPORT (\n    \"FMT\"\n    \"TIME\"\n)\n \nCONST PAGEWIDTH = 80\n \nFUNC MAIN() {\n    PRINTCAL(1969)\n}\n \nFUNC PRINTCAL(YEAR INT) {\n    THISDATE := TIME.DATE(YEAR, 1, 1, 1, 1, 1, 1, TIME.UTC)\n    VAR (\n        DAYARR                  [12][7][6]INT // MONTH, WEEKDAY, WEEK\n        MONTH, LASTMONTH        TIME.MONTH\n        WEEKINMONTH, DAYINMONTH INT\n    )\n    FOR THISDATE.YEAR() == YEAR {\n        IF MONTH = THISDATE.MONTH(); MONTH != LASTMONTH {\n            WEEKINMONTH = 0\n            DAYINMONTH = 1\n        }\n        WEEKDAY := THISDATE.WEEKDAY()\n        IF WEEKDAY == 0 && DAYINMONTH > 1 {\n            WEEKINMONTH++\n        }\n        DAYARR[INT(MONTH)-1][WEEKDAY][WEEKINMONTH] = THISDATE.DAY()\n        LASTMONTH = MONTH\n        DAYINMONTH++\n        THISDATE = THISDATE.ADD(TIME.HOUR * 24)\n    }\n    CENTRE := FMT.SPRINTF(\"%D\", PAGEWIDTH/2)\n    FMT.PRINTF(\"%\"+CENTRE+\"S\\N\\N\", \"[SNOOPY]\")\n    CENTRE = FMT.SPRINTF(\"%D\", PAGEWIDTH/2-2)\n    FMT.PRINTF(\"%\"+CENTRE+\"D\\N\\N\", YEAR)\n    MONTHS := [12]STRING{\n        \" JANUARY \", \" FEBRUARY\", \"  MARCH  \", \"  APRIL  \",\n        \"   MAY   \", \"   JUNE  \", \"   JULY  \", \"  AUGUST \",\n        \"SEPTEMBER\", \" OCTOBER \", \" NOVEMBER\", \" DECEMBER\"}\n    DAYS := [7]STRING{\"SU\", \"MO\", \"TU\", \"WE\", \"TH\", \"FR\", \"SA\"}\n    FOR QTR := 0; QTR < 4; QTR++ {\n        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { // MONTH NAMES\n            FMT.PRINTF(\"      %S           \", MONTHS[QTR*3+MONTHINQTR])\n        }\n        FMT.PRINTLN()\n        FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ { // DAY NAMES\n            FOR DAY := 0; DAY < 7; DAY++ {\n                FMT.PRINTF(\" %S\", DAYS[DAY])\n            }\n            FMT.PRINTF(\"     \")\n        }\n        FMT.PRINTLN()\n        FOR WEEKINMONTH = 0; WEEKINMONTH < 6; WEEKINMONTH++ {\n            FOR MONTHINQTR := 0; MONTHINQTR < 3; MONTHINQTR++ {\n                FOR DAY := 0; DAY < 7; DAY++ {\n                    IF DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH] == 0 {\n                        FMT.PRINTF(\"   \")\n                    } ELSE {\n                        FMT.PRINTF(\"%3D\", DAYARR[QTR*3+MONTHINQTR][DAY][WEEKINMONTH])\n                    }\n                }\n                FMT.PRINTF(\"     \")\n            }\n            FMT.PRINTLN()\n        }\n        FMT.PRINTLN()\n    }\n}\n\n\npackage main\n\nimport (\n    \"io/ioutil\"\n    \"log\"\n    \"os\"\n    \"os/exec\"\n    \"strings\"\n)\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc main() {\n    lower := []string{\n        \"const \", \"else \", \"for \", \"func \", \"if \", \"import \", \"int \", \"package \", \"string \", \"var \",\n        \" int\", \"int(\", \"string{\", \" main\", \"main(\", \"fmt\", \"time\", \"%d\", \"%s\", \"%3d\", `d\\n\\n`, `s\\n\\n`,\n    }\n    title := []string{\n        \".add\", \".date\", \".day\", \".hour\", \".month\", \".printf\", \".println\", \".sprintf\", \".weekday\", \".year\",\n    }\n    code, err := ioutil.ReadFile(\"realcal_UC.txt\")\n    check(err)\n    text := string(code)\n    for _, lwr := range lower {\n        text = strings.Replace(text, strings.ToUpper(lwr), lwr, -1)\n    }\n    for _, ttl := range title {\n        text = strings.Replace(text, strings.ToUpper(ttl), \".\"+strings.Title(ttl[1:]), -1)\n    }\n    err = ioutil.WriteFile(\"realcal_NC.go\", []byte(text), 0666)\n    check(err)\n    cmd := exec.Command(\"go\", \"run\", \"realcal_NC.go\")\n    cmd.Stdout = os.Stdout\n    cmd.Stderr = os.Stderr\n    check(cmd.Run())\n}\n\n\n                                [SNOOPY]\n\n                                  1969\n\n       JANUARY                   FEBRUARY                   MARCH             \n SU MO TU WE TH FR SA      SU MO TU WE TH FR SA      SU MO TU WE TH FR SA     \n           1  2  3  4                         1                         1     \n  5  6  7  8  9 10 11       2  3  4  5  6  7  8       2  3  4  5  6  7  8     \n 12 13 14 15 16 17 18       9 10 11 12 13 14 15       9 10 11 12 13 14 15     \n 19 20 21 22 23 24 25      16 17 18 19 20 21 22      16 17 18 19 20 21 22     \n 26 27 28 29 30 31         23 24 25 26 27 28         23 24 25 26 27 28 29     \n                                                     30 31                    \n\n        APRIL                      MAY                       JUNE             \n SU MO TU WE TH FR SA      SU MO TU WE TH FR SA      SU MO TU WE TH FR SA     \n        1  2  3  4  5                   1  2  3       1  2  3  4  5  6  7     \n  6  7  8  9 10 11 12       4  5  6  7  8  9 10       8  9 10 11 12 13 14     \n 13 14 15 16 17 18 19      11 12 13 14 15 16 17      15 16 17 18 19 20 21     \n 20 21 22 23 24 25 26      18 19 20 21 22 23 24      22 23 24 25 26 27 28     \n 27 28 29 30               25 26 27 28 29 30 31      29 30                    \n                                                                              \n\n         JULY                     AUGUST                  SEPTEMBER           \n SU MO TU WE TH FR SA      SU MO TU WE TH FR SA      SU MO TU WE TH FR SA     \n        1  2  3  4  5                      1  2          1  2  3  4  5  6     \n  6  7  8  9 10 11 12       3  4  5  6  7  8  9       7  8  9 10 11 12 13     \n 13 14 15 16 17 18 19      10 11 12 13 14 15 16      14 15 16 17 18 19 20     \n 20 21 22 23 24 25 26      17 18 19 20 21 22 23      21 22 23 24 25 26 27     \n 27 28 29 30 31            24 25 26 27 28 29 30      28 29 30                 \n                           31                                                 \n\n       OCTOBER                   NOVEMBER                  DECEMBER           \n SU MO TU WE TH FR SA      SU MO TU WE TH FR SA      SU MO TU WE TH FR SA     \n           1  2  3  4                         1          1  2  3  4  5  6     \n  5  6  7  8  9 10 11       2  3  4  5  6  7  8       7  8  9 10 11 12 13     \n 12 13 14 15 16 17 18       9 10 11 12 13 14 15      14 15 16 17 18 19 20     \n 19 20 21 22 23 24 25      16 17 18 19 20 21 22      21 22 23 24 25 26 27     \n 26 27 28 29 30 31         23 24 25 26 27 28 29      28 29 30 31              \n                           30                                                 \n\n", "explain": "Go is case-sensitive: all its keywords and certain other identifiers/verbs are lower case and imported functions etc. are title case. Consequently, it is impossible to run an upper case version of the Calendar task program as it stands. So what I've done instead is to follow the approach of the Kotlin entry:\n1. Saved the Calendar program, after conversion to upper case to a text file called realcal_UC.txt. \n2. Written another program called realcal.go which takes realcalc_UC.txt as input, outputs a runnable program called realcal_NC.go to disk, runs it and prints the output to the terminal (Ubuntu 16.04 being used). This program only makes the minimum changes to realcal_UC.txt to enable it to run. Everything else is left as upper case even though this is at odds with the usual Go naming conventions. \nThis is realcal_UC.txt:\nand this is realcal.go:\nwhich produces (as expected) this output:\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "X86_Assembly", "code": "\n\n        .MODEL  TINY\n        .CODE\n        .486\n        ORG     100H            ;.COM FILES START HERE\nYEAR    EQU     1969            ;DISPLAY CALENDAR FOR SPECIFIED YEAR\nSTART:  MOV     CX, 61          ;SPACE(61);  TEXT(0, \"[SNOOPY]\");  CRLF(0)\n        CALL    SPACE\n        MOV     DX, OFFSET SNOOPY\n        CALL    TEXT\n        MOV     CL, 63          ;SPACE(63);  INTOUT(0, YEAR);  CRLF(0);  CRLF(0)\n        CALL    SPACE\n        MOV     AX, YEAR\n        CALL    INTOUT\n        CALL    CRLF\n        CALL    CRLF\n\n        MOV     DI, 1           ;FOR MONTH:= 1 TO 12 DO         DI=MONTH\nL22:    XOR     SI, SI          ; FOR COL:= 0 TO 6-1 DO         SI=COL\nL23:    MOV     CL, 5           ;  SPACE(5)\n        CALL    SPACE\n        MOV     DX, DI          ;  TEXT(0, MONAME(MONTH+COL-1));  SPACE(7);\n        DEC     DX              ;  DX:= (MONTH+COL-1)*10+MONAME\n        ADD     DX, SI\n        IMUL    DX, 10\n        ADD     DX, OFFSET MONAME\n        CALL    TEXT\n        MOV     CL, 7\n        CALL    SPACE\n        CMP     SI, 5           ;  IF COL<5 THEN SPACE(1);\n        JGE     L24\n         MOV    CL, 1\n         CALL   SPACE\n         INC    SI\n         JMP    L23\nL24:    CALL    CRLF\n\n        MOV     SI, 6           ; FOR COL:= 0 TO 6-1 DO\nL25:    MOV     DX, OFFSET SUMO ;  TEXT(0, \"SU MO TU WE TH FR SA\");\n        CALL    TEXT\n        DEC     SI              ;   IF COL<5 THEN SPACE(2);\n        JE      L27\n         MOV    CL, 2\n         CALL   SPACE\n         JMP    L25\nL27:    CALL    CRLF\n\n        XOR     SI, SI          ;FOR COL:= 0 TO 6-1 DO\nL28:    MOV     BX, DI          ;DAY OF FIRST SUNDAY OF MONTH (CAN BE NEGATIVE)\n        ADD     BX, SI          ;DAY(COL):= 1 - WEEKDAY(YEAR, MONTH+COL, 1);\n        MOV     BP, YEAR\n\n;DAY OF WEEK FOR FIRST DAY OF THE MONTH (0=SUN 1=MON..6=SAT)\n        CMP     BL, 2           ;IF MONTH<=2 THEN\n        JG      L3\n         ADD    BL, 12          ; MONTH:= MONTH+12;\n         DEC    BP              ; YEAR:= YEAR-1;\nL3:\n;REM((1-1 + (MONTH+1)*26/10 + YEAR + YEAR/4 + YEAR/100*6 + YEAR/400)/7)\n        INC     BX              ;MONTH\n        IMUL    AX, BX, 26\n        MOV     CL, 10\n        CWD\n        IDIV    CX\n        MOV     BX, AX\n        MOV     AX, BP          ;YEAR\n        ADD     BX, AX\n        SHR     AX, 2\n        ADD     BX, AX\n        MOV     CL, 25\n        CWD\n        IDIV    CX\n        IMUL    DX, AX, 6       ;YEAR/100*6\n        ADD     BX, DX\n        SHR     AX, 2           ;YEAR/400\n        ADD     AX, BX\n        MOV     CL, 7\n        CWD\n        IDIV    CX\n        NEG     DX\n        INC     DX\n        MOV     [SI+DAY], DL    ;COL+DAY\n        INC     SI\n        CMP     SI, 5\n        JLE     L28\n\n        MOV     BP, 6           ;FOR LINE:= 0 TO 6-1 DO         BP=LINE\nL29:    XOR     SI, SI          ; FOR COL:= 0 TO 6-1 DO         SI=COL\nL30:    MOV     BX, DI          ;  DAYMAX:= DAYS(MONTH+COL);\n        MOV     BL, [BX+SI+DAYS]\n\n;IF MONTH+COL=2 & (REM(YEAR/4)=0 & REM(YEAR/100)#0\u00a0! REM(YEAR/400)=0) THEN\n        MOV     AX, DI          ;MONTH\n        ADD     AX, SI\n        CMP     AL, 2\n        JNE     L32\n        MOV     AX, YEAR\n        TEST    AL, 03H\n        JNE     L32\n        MOV     CL,100\n        CWD\n        IDIV    CX\n        TEST    DX, DX\n        JNE     L31\n        TEST    AL, 03H\n        JNE     L32\nL31:     INC    BX              ;IF FEBRUARY AND LEAP YEAR THEN ADD A DAY\nL32:\n        MOV     DX, 7           ;FOR WEEKDAY:= 0 TO 7-1 DO\nL33:    MOVZX   AX, [SI+DAY]    ; IF DAY(COL)>=1 & DAY(COL)<=DAYMAX THEN\n        CMP     AL, 1\n        JL      L34\n        CMP     AL, BL\n        JG      L34\n        CALL    INTOUT          ; INTOUT(0, DAY(COL));\n        CMP     AL, 10          ; IF DAY(COL)<10 THEN SPACE(1); LEFT JUSTIFY\n        JGE     L36\n         MOV    CL, 1\n         CALL   SPACE\n        JMP     L36\nL34:    MOV     CL, 2           ; ELSE SPACE(2);\n        CALL    SPACE           ; SUPPRESS OUT OF RANGE DAYS\nL36:    MOV     CL, 1           ; SPACE(1);\n        CALL    SPACE\n        INC     BYTE PTR [SI+DAY] ; DAY(COL):= DAY(COL)+1;\n        DEC     DX              ;NEXT WEEKDAY\n        JNE     L33\n\n        CMP     SI, 5           ;IF COL<5 THEN SPACE(1);\n        JGE     L37\n         MOV    CL, 1\n         CALL   SPACE\n         INC    SI\n         JMP    L30\nL37:    CALL    CRLF\n\n        DEC     BP              ;NEXT LINE DOWN\n        JNE     L29\n        CALL    CRLF\n\n        ADD     DI, 6           ;NEXT 6 MONTHS\n        CMP     DI, 12\n        JLE     L22\n        RET\n\n;DISPLAY POSITIVE INTEGER IN AX\nINTOUT: PUSHA\n        MOV     BX, 10\n        XOR     CX, CX\nNO10:   CWD\n        IDIV    BX\n        PUSH    DX\n        INC     CX\n        TEST    AX, AX\n        JNE     NO10\nNO20:   MOV     AH, 02H\n        POP     DX\n        ADD     DL, '0'\n        INT     21H\n        LOOP    NO20\n        POPA\n        RET\n\n;DISPLAY CX SPACE CHARACTERS\nSPACE:  PUSHA\nSP10:   MOV     AH, 02H\n        MOV     DL, 20H\n        INT     21H\n        LOOP    SP10\n        POPA\n        RET\n\n;START A NEW LINE\nCRLF:   MOV     DX, OFFSET LCRLF\n\n;DISPLAY STRING AT DX\nTEXT:   MOV     AH, 09H\n        INT     21H\n        RET\n\nSNOOPY  DB      \"[SNOOPY]\"\nLCRLF   DB      0DH, 0AH, '$'\nMONAME  DB      \" JANUARY $ FEBRUARY$  MARCH  $  APRIL  $   MAY   $   JUNE  $\"\n        DB      \"   JULY  $  AUGUST $SEPTEMBER$  OCTOBER$ NOVEMBER$ DECEMBER$\"\nSUMO    DB      \"SU MO TU WE TH FR SA$\"\nDAYS    DB      0, 31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31\nDAY     DB      ?, ?, ?, ?, ?, ?\n        END     START\n\n\nOutput:\n                                                             [SNOOPY]\n                                                               1969\n\n      JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE         \nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n         1  2  3  4                     1                     1         1  2  3  4  5               1  2  3   1  2  3  4  5  6  7  \n5  6  7  8  9  10 11  2  3  4  5  6  7  8   2  3  4  5  6  7  8   6  7  8  9  10 11 12  4  5  6  7  8  9  10  8  9  10 11 12 13 14 \n12 13 14 15 16 17 18  9  10 11 12 13 14 15  9  10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21 \n19 20 21 22 23 24 25  16 17 18 19 20 21 22  16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28 \n26 27 28 29 30 31     23 24 25 26 27 28     23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31  29 30                \n                                            30 31                                                                                  \n\n        JULY                 AUGUST              SEPTEMBER               OCTOBER              NOVEMBER              DECEMBER       \nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n      1  2  3  4  5                  1  2      1  2  3  4  5  6            1  2  3  4                     1      1  2  3  4  5  6  \n6  7  8  9  10 11 12  3  4  5  6  7  8  9   7  8  9  10 11 12 13  5  6  7  8  9  10 11  2  3  4  5  6  7  8   7  8  9  10 11 12 13 \n13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18  9  10 11 12 13 14 15  14 15 16 17 18 19 20 \n20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27 \n27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31          \n                      31                                                                30                                         \n\n", "explain": "ASSEMBLE WITH: TASM CALENDAR; TLINK /t CALENDAR\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Ruby", "code": "\n\nloadup.rb is the program loader.\n# loadup.rb - run UPPERCASE RUBY program\n\nclass Object\n  alias lowercase_method_missing method_missing\n\n  # Allow UPPERCASE method calls.\n  def method_missing(sym, *args, &block)\n    str = sym.to_s\n    if str == (down = str.downcase)\n      lowercase_method_missing sym, *args, &block\n    else\n      send down, *args, &block\n    end\n  end\n\n  # RESCUE an exception without the 'rescue' keyword.\n  def RESCUE(_BEGIN, _CLASS, _RESCUE)\n    begin _BEGIN.CALL\n    rescue _CLASS\n      _RESCUE.CALL; end\n  end\nend\n\n_PROGRAM = ARGV.SHIFT\n_PROGRAM || ABORT(\"USAGE: #{$0} PROGRAM.RB ARGS...\")\nLOAD($0 = _PROGRAM)\n\nCAL.RB is an UPPERCASE RUBY translation of Calendar#Ruby.\nWorks with: Ruby version 1.8.7\n# CAL.RB - CALENDAR\nREQUIRE 'DATE'.DOWNCASE\n\n# FIND CLASSES.\nOBJECT = [].CLASS.SUPERCLASS\nDATE = OBJECT.CONST_GET('DATE'.DOWNCASE.CAPITALIZE)\n\n# CREATES A CALENDAR OF _YEAR_. RETURNS THIS CALENDAR AS A MULTI-LINE\n# STRING FIT TO _COLUMNS_.\nOBJECT.SEND(:DEFINE_METHOD, :CAL) {|_YEAR, _COLUMNS|\n\n  # START AT JANUARY 1.\n  #\n  # DATE::ENGLAND MARKS THE SWITCH FROM JULIAN CALENDAR TO GREGORIAN\n  # CALENDAR AT 1752 SEPTEMBER 14. THIS REMOVES SEPTEMBER 3 TO 13 FROM\n  # YEAR 1752. (BY FORTUNE, IT KEEPS JANUARY 1.)\n  #\n  _DATE = DATE.NEW(_YEAR, 1, 1, DATE::ENGLAND)\n\n  # COLLECT CALENDARS OF ALL 12 MONTHS.\n  _MONTHS = (1..12).COLLECT {|_MONTH|\n    _ROWS = [DATE::MONTHNAMES[_MONTH].UPCASE.CENTER(20),\n             \"SU MO TU WE TH FR SA\"]\n\n    # MAKE ARRAY OF 42 DAYS, STARTING WITH SUNDAY.\n    _DAYS = []\n    _DATE.WDAY.TIMES { _DAYS.PUSH \"  \" }\n    CATCH(:BREAK) {\n      LOOP {\n        (_DATE.MONTH == _MONTH) || THROW(:BREAK)\n        _DAYS.PUSH(\"%2D\".DOWNCASE % _DATE.MDAY)\n        _DATE += 1 }}\n    (42 - _DAYS.LENGTH).TIMES { _DAYS.PUSH \"  \" }\n\n    _DAYS.EACH_SLICE(7) {|_WEEK| _ROWS.PUSH(_WEEK.JOIN \" \") }\n    _ROWS }\n\n  # CALCULATE MONTHS PER ROW (MPR).\n  #  1. DIVIDE COLUMNS BY 22 COLUMNS PER MONTH, ROUNDED DOWN. (PRETEND\n  #     TO HAVE 2 EXTRA COLUMNS; LAST MONTH USES ONLY 20 COLUMNS.)\n  #  2. DECREASE MPR IF 12 MONTHS WOULD FIT IN THE SAME MONTHS PER\n  #     COLUMN (MPC). FOR EXAMPLE, IF WE CAN FIT 5 MPR AND 3 MPC, THEN\n  #     WE USE 4 MPR AND 3 MPC.\n  _MPR = (_COLUMNS + 2).DIV 22\n  _MPR = 12.DIV((12 + _MPR - 1).DIV _MPR)\n\n  # USE 20 COLUMNS PER MONTH + 2 SPACES BETWEEN MONTHS.\n  _WIDTH = _MPR * 22 - 2\n\n  # JOIN MONTHS INTO CALENDAR.\n  _ROWS = [\"[SNOOPY]\".CENTER(_WIDTH), \"#{_YEAR}\".CENTER(_WIDTH)]\n  _MONTHS.EACH_SLICE(_MPR) {|_SLICE|\n    _SLICE[0].EACH_INDEX {|_I|\n      _ROWS.PUSH(_SLICE.MAP {|_A| _A[_I]}.JOIN \"  \") }}\n  _ROWS.JOIN(\"\\012\") }\n\n\n(ARGV.LENGTH == 1) || ABORT(\"USAGE: #{$0} YEAR\")\n\n# GUESS WIDTH OF TERMINAL.\n#  1. OBEY ENVIRONMENT VARIABLE COLUMNS.\n#  2. TRY TO REQUIRE 'IO/CONSOLE' FROM RUBY 1.9.3.\n#  3. TRY TO RUN `TPUT CO`.\n#  4. ASSUME 80 COLUMNS.\nLOADERROR = OBJECT.CONST_GET('LOAD'.DOWNCASE.CAPITALIZE +\n                             'ERROR'.DOWNCASE.CAPITALIZE)\nSTANDARDERROR = OBJECT.CONST_GET('STANDARD'.DOWNCASE.CAPITALIZE +\n                                 'ERROR'.DOWNCASE.CAPITALIZE)\n_INTEGER = 'INTEGER'.DOWNCASE.CAPITALIZE\n_TPUT_CO = 'TPUT CO'.DOWNCASE\n_COLUMNS = RESCUE(PROC {SEND(_INTEGER, ENV[\"COLUMNS\"] || \"\")},\n                  STANDARDERROR,\n                  PROC {\n                    RESCUE(PROC {\n                             REQUIRE 'IO/CONSOLE'.DOWNCASE\n                             IO.CONSOLE.WINSIZE[1]\n                           }, LOADERROR,\n                           PROC {\n                             RESCUE(PROC {\n                                      SEND(_INTEGER, `#{_TPUT_CO}`)\n                                    }, STANDARDERROR,\n                                    PROC {80}) }) })\n\nPUTS CAL(ARGV[0].TO_I, _COLUMNS)\n\nA local variable must start with a lowercase letter or an underscore, so we have many leading underscores (_YEAR, _COLUMN, _DATE and so on).\nWe form blocks with curly braces { ... }, never with lowercase keywords do ... end.\nOBJECT = [].CLASS.SUPERCLASS finds the superclass of the class of the empty array; this is the Object class! Class#CONST_GET finds some other classes.\nClass#DEFINE_METHOD defines a new method, Object#CAL, without a def keyword.\nKernel#LOOP, Kernel#THROW, Kernel#CATCH and operator || act like a while loop without a while keyword.\n$ ruby loadup.rb CAL.RB 1969   \n                                                             [SNOOPY]                                                             \n                                                               1969                                                               \n      JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE        \nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n          1  2  3  4                     1                     1         1  2  3  4  5               1  2  3   1  2  3  4  5  6  7\n 5  6  7  8  9 10 11   2  3  4  5  6  7  8   2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10   8  9 10 11 12 13 14\n12 13 14 15 16 17 18   9 10 11 12 13 14 15   9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17  15 16 17 18 19 20 21\n19 20 21 22 23 24 25  16 17 18 19 20 21 22  16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24  22 23 24 25 26 27 28\n26 27 28 29 30 31     23 24 25 26 27 28     23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31  29 30               \n                                            30 31                                                                                 \n        JULY                 AUGUST              SEPTEMBER              OCTOBER               NOVEMBER              DECEMBER      \nSU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA  SU MO TU WE TH FR SA\n       1  2  3  4  5                  1  2      1  2  3  4  5  6            1  2  3  4                     1      1  2  3  4  5  6\n 6  7  8  9 10 11 12   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8   7  8  9 10 11 12 13\n13 14 15 16 17 18 19  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15  14 15 16 17 18 19 20\n20 21 22 23 24 25 26  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22  21 22 23 24 25 26 27\n27 28 29 30 31        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29  28 29 30 31         \n                      31                                                                30                                        \n", "explain": "UPPERCASE RUBY is normally impossible, because Ruby is sensitive to case, and most methods and keywords have lowercase letters. To solve this task, we wrote a new program loader for UPPERCASE RUBY programs.\nOur program loader responds to unknown method calls by calling their lowercase equivalents, so Kernel#PUTS acts like Kernel#puts. Our program loader also defines Object#RESCUE to replace the 'rescue' keyword. We can now write UPPERCASE RUBY programs that call uppercase methods and use no lowercase keywords.\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "COBOL", "code": "\n\n", "explain": "Although it seems to be missing the pinup of Snoopy, see COBOL Calendar task entry\nwhere the code, and output, is already an example of a \"REAL programmer\" calendar; even down to the 6 character, all uppercase, program name CALEND.\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Ada", "code": "\n\nWITH PRINTABLE_CALENDAR;\n\nPROCEDURE REAL_CAL IS\n\n   C: PRINTABLE_CALENDAR.CALENDAR := PRINTABLE_CALENDAR.INIT_132\n     ((WEEKDAY_REP =>\n          \"MO TU WE TH FR SA SO\",\n       MONTH_REP   =>\n         (\"      JANUARY       \", \"      FEBRUARY      \",\n          \"       MARCH        \", \"       APRIL        \",\n          \"        MAY         \", \"        JUNE        \",\n          \"        JULY        \", \"       AUGUST       \",\n          \"      SEPTEMBER     \", \"       OCTOBER      \",\n          \"      NOVEMBER      \", \"      DECEMBER      \")\n      ));\n\nBEGIN\n   C.PRINT_LINE_CENTERED(\"[SNOOPY]\");\n   C.NEW_LINE;\n   C.PRINT(1969, \"NINETEEN-SIXTY-NINE\");\nEND REAL_CAL;\n\n\nOutput:\n                                                             [SNOOPY]                                                             \n\n                                                        NINETEEN-SIXTY-NINE                                                        \n\n       JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE        \n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n        1  2  3  4  5                  1  2                  1  2      1  2  3  4  5  6            1  2  3  4                     1\n  6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8\n 13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15\n 20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22\n 27 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29\n                                             31                                                                30                  \n\n         JULY                 AUGUST               SEPTEMBER              OCTOBER              NOVEMBER              DECEMBER      \n MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO  MO TU WE TH FR SA SO\n     1  2  3  4  5  6               1  2  3   1  2  3  4  5  6  7         1  2  3  4  5                  1  2   1  2  3  4  5  6  7\n  7  8  9 10 11 12 13   4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14\n 14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21\n 21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28\n 28 29 30 31           25 26 27 28 29 30 31  29 30                 27 28 29 30 31        24 25 26 27 28 29 30  29 30 31  \n\n", "explain": "In Ada, the task is really easy, because Ada is case insensitive. I.e., one could simply replicate the code from Ada solution of the calendar task and convert every lowercase character to uppercase. \nInstead of doing that, the implementation below reuses the package \"PRINTABLE_CALENDAR\" (same as \"Printable_Calendar\" or \"printable_calendar\") from the calendar task:\nTo change the output to 80-character devices, replace \"INIT_132\" by \"INIT_80\".\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Julia", "code": "\n\n# IF THIS SMALL FUNCTION IS PLACED IN THE STARTUP.JL\n# FILE, IT WILL BE LOADED ON STARTUP. THE REST OF\n# THIS EXAMPLE IS IN ALL UPPERCASE.\nfunction RUNUPPERCASECODE(CO)\n    COD = replace(lowercase(CO), \"date\" => \"Date\")\n    for E in Meta.parse(COD, 1) eval(E) end\nend\n\n\nCODE = \"\"\"BEGIN\n\nUSING DATES;\nCENTEROBJECT(X, N) = BEGIN S = UPPERCASE(STRING(X)); RPAD(LPAD(S, DIV(N + LENGTH(S), 2)), N) END;\nFUNCTION FORMATMONTH(YR, MO)\n    DT = DATE(\\\"\\$YR-\\$MO-01\\\");\n    DAYOFWEEKFIRST = DAYOFWEEK(DT);\n    NUMWEEKLINES = 1;\n    STR = UPPERCASE(CENTEROBJECT(MONTHNAME(DT), 20) * \\\"\\\\NMO TU WE TH FR SA SU\\\\N\\\");\n    STR *= \\\" \\\" ^ (3 * (DAYOFWEEKFIRST - 1)) * LPAD(STRING(1), 2);\n    FOR I = 2:DAYSINMONTH(DT)\n        IF (I + DAYOFWEEKFIRST + 5)\u00a0% 7 == 0\n            STR *= \\\"\\\\N\\\" * LPAD(I, 2);\n            NUMWEEKLINES += 1;\n        ELSE\n            STR *= LPAD(STRING(I), 3);\n        END;\n    END;\n    STR *= NUMWEEKLINES < 6\u00a0? \\\"\\\\N\\\\N\\\\N\\\"\u00a0: \\\"\\\\N\\\\N\\\";\n    ARR = [];\n    FOR S IN SPLIT(STR, \\\"\\\\N\\\")\n        PUSH!(ARR, RPAD(S, 20)[1:20])\n    END;\n    JOIN(ARR, \\\"\\\\N\\\");\nEND;\n \nFUNCTION FORMATYEAR(DISPLAYYEAR)\n    CALMONTHS = [FORMATMONTH(DISPLAYYEAR, MO) FOR MO IN 1:12];\n    MONTHSPERLINE = 6;\n    JOINSPACES = 2;\n    STR = \\\"\\\\N\\\" * CENTEROBJECT(DISPLAYYEAR, 132) * \\\"\\\\N\\\";\n    MONTHCAL = [SPLIT(FORMATMONTH(DISPLAYYEAR, I), \\\"\\\\N\\\") FOR I IN 1:12];\n    FOR I IN 1:MONTHSPERLINE:LENGTH(CALMONTHS) - 1\n        FOR J IN 1:LENGTH(MONTHCAL[1])\n            MONTHLINES = MAP(X->MONTHCAL[X][J], I:I + MONTHSPERLINE - 1);\n            STR *= RPAD(JOIN(MONTHLINES, \\\" \\\" ^ JOINSPACES), 132) * \\\"\\\\N\\\";\n        END;\n        STR *= \\\"\\\\N\\\";\n    END;\n    STR;\nEND;\n\nPRINTLN(FORMATYEAR(1969));\n\nEND;\n\"\"\"\n\nRUNUPPERCASECODE(CODE)\n \nOutput: \n\n                                                               1969\n      JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE\nMO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU\n       1  2  3  4  5                  1  2                  1  2      1  2  3  4  5  6            1  2  3  4                     1\n 6  7  8  9 10 11 12   3  4  5  6  7  8  9   3  4  5  6  7  8  9   7  8  9 10 11 12 13   5  6  7  8  9 10 11   2  3  4  5  6  7  8\n13 14 15 16 17 18 19  10 11 12 13 14 15 16  10 11 12 13 14 15 16  14 15 16 17 18 19 20  12 13 14 15 16 17 18   9 10 11 12 13 14 15\n20 21 22 23 24 25 26  17 18 19 20 21 22 23  17 18 19 20 21 22 23  21 22 23 24 25 26 27  19 20 21 22 23 24 25  16 17 18 19 20 21 22\n27 28 29 30 31        24 25 26 27 28        24 25 26 27 28 29 30  28 29 30              26 27 28 29 30 31     23 24 25 26 27 28 29\n                                            31                                                                30                  \n\n\n\n        JULY                 AUGUST              SEPTEMBER              OCTOBER               NOVEMBER              DECEMBER\nMO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU  MO TU WE TH FR SA SU\n    1  2  3  4  5  6               1  2  3   1  2  3  4  5  6  7         1  2  3  4  5                  1  2   1  2  3  4  5  6  7\n 7  8  9 10 11 12 13   4  5  6  7  8  9 10   8  9 10 11 12 13 14   6  7  8  9 10 11 12   3  4  5  6  7  8  9   8  9 10 11 12 13 14\n14 15 16 17 18 19 20  11 12 13 14 15 16 17  15 16 17 18 19 20 21  13 14 15 16 17 18 19  10 11 12 13 14 15 16  15 16 17 18 19 20 21\n21 22 23 24 25 26 27  18 19 20 21 22 23 24  22 23 24 25 26 27 28  20 21 22 23 24 25 26  17 18 19 20 21 22 23  22 23 24 25 26 27 28\n28 29 30 31           25 26 27 28 29 30 31  29 30                 27 28 29 30 31        24 25 26 27 28 29 30  29 30 31             \n\n\n", "explain": "Julia code is a valid data type in Julia. Executable code can be created from a String with Meta.parse() and run with eval. \nThis example does require a small function with Julia's lowercase keywords, perhaps loaded on startup from a separate file. \n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Kotlin", "code": "\n\nIMPORT JAVA.TEXT.*\nIMPORT JAVA.UTIL.*\nIMPORT JAVA.IO.PRINTSTREAM\n \nINTERNAL FUN PRINTSTREAM.PRINTCALENDAR(YEAR: INT, NCOLS: BYTE, LOCALE: LOCALE?) {\n    IF (NCOLS < 1 || NCOLS > 12)\n        THROW ILLEGALARGUMENTEXCEPTION(\"ILLEGAL COLUMN WIDTH.\")\n    VAL W = NCOLS * 24\n    VAL NROWS = MATH.CEIL(12.0 / NCOLS).TOINT()\n \n    VAL DATE = GREGORIANCALENDAR(YEAR, 0, 1)\n    VAR OFFS = DATE.GET(CALENDAR.DAY_OF_WEEK) - 1\n \n    VAL DAYS = DATEFORMATSYMBOLS(LOCALE).SHORTWEEKDAYS.SLICE(1..7).MAP { IT.SLICE(0..1) }.JOINTOSTRING(\" \", \" \")\n    VAL MONS = ARRAY(12) { ARRAY(8) { \"\" } }\n    DATEFORMATSYMBOLS(LOCALE).MONTHS.SLICE(0..11).FOREACHINDEXED { M, NAME ->\n        VAL LEN = 11 + NAME.LENGTH / 2\n        VAL FORMAT = MESSAGEFORMAT.FORMAT(\"%{0}S%{1}S\", LEN, 21 - LEN)\n        MONS[M][0] = STRING.FORMAT(FORMAT, NAME, \"\")\n        MONS[M][1] = DAYS\n        VAL DIM = DATE.GETACTUALMAXIMUM(CALENDAR.DAY_OF_MONTH)\n        FOR (D IN 1..42) {\n            VAL ISDAY = D > OFFS && D <= OFFS + DIM\n            VAL ENTRY = IF (ISDAY) STRING.FORMAT(\" %2S\", D - OFFS) ELSE \"   \"\n            IF (D % 7 == 1)\n                MONS[M][2 + (D - 1) / 7] = ENTRY\n            ELSE\n                MONS[M][2 + (D - 1) / 7] += ENTRY\n        }\n        OFFS = (OFFS + DIM) % 7\n        DATE.ADD(CALENDAR.MONTH, 1)\n    }\n \n    PRINTF(\"%\" + (W / 2 + 10) + \"S%N\", \"[SNOOPY PICTURE]\")\n    PRINTF(\"%\" + (W / 2 + 4) + \"S%N%N\", YEAR)\n \n    FOR (R IN 0..NROWS - 1) {\n        FOR (I IN 0..7) {\n            VAR C = R * NCOLS\n            WHILE (C < (R + 1) * NCOLS && C < 12) {\n                PRINTF(\"   %S\", MONS[C][I].TOUPPERCASE())  // ORIGINAL CHANGED TO PRINT IN UPPER CASE \n                C++\n            }\n            PRINTLN()\n        }\n        PRINTLN()\n    }\n}\n \nFUN MAIN(ARGS: ARRAY<STRING>) {\n    SYSTEM.OUT.PRINTCALENDAR(1969, 3, LOCALE.US)\n}\n\n\n// version 1.1.3\n\nimport java.io.File\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\n\nfun main(args: Array<String>) {\n    val keywords = listOf(\n        \"import\", \"internal\", \"fun\", \"if\", \"throw\", \"val\", \"var\", \"for\", \"in\", \"while\"\n    )\n\n    val singleCase = listOf(\n        \"java.text\",\n        \"java.util\",\n        \"java.io\",\n        \"else\",     // really a keyword but doesn't have a following space here\n        \"ceil\",\n        \"it\",       // really a keyword but doesn't have a following space here\n        \"get(\",     // also included in GETACTUALMAXIMUM       \n        \"slice\",\n        \"map\",\n        \"months\",        \n        \"length\",\n        \".format\",  // also variable called FORMAT        \n        \"add\",\n        \"printf\", \n        \"println\",\n        \"out\",\n        \"main\",\n        \"args\",\n        \"s%{1}s\",\n        \"%2s\",\n        \"s%n%n\",\n        \"s%n\",\n        \"%s\"\n    ) \n         \n    val mixedCase = listOf( \n        \"PRINTSTREAM\" to \"PrintStream\",\n        \"INT,\" to \"Int,\",  // also included in PRINTCALENDAR\n        \"BYTE\" to \"Byte\",\n        \"LOCALE?\" to \"Locale?\",  // also variable called LOCALE\n        \"LOCALE.\" to \"Locale.\",\n        \"ILLEGALARGUMENTEXCEPTION\" to \"IllegalArgumentException\",\n        \"MATH\" to \"Math\",\n        \"GREGORIANCALENDAR\" to \"GregorianCalendar\",\n        \"DATEFORMATSYMBOLS\" to \"DateFormatSymbols\",\n        \"ARRAY\" to \"Array\",\n        \"MESSAGEFORMAT\" to \"MessageFormat\",\n        \"JOINTOSTRING\" to \"joinToString\",\n        \"STRING\" to \"String\",\n        \"CALENDAR.\" to \"Calendar.\", // also included in PRINTCALENDAR\n        \"SYSTEM\" to \"System\",\n        \"TOINT\" to \"toInt\",\n        \"SHORTWEEKDAYS\" to \"shortWeekdays\",\n        \"FOREACHINDEXED\" to \"forEachIndexed\",\n        \"GETACTUALMAXIMUM\" to \"getActualMaximum\",\n        \"TOUPPERCASE\" to \"toUpperCase\"\n    )\n        \n    var text = File(\"calendar_UC.txt\").readText()\n    for (k in keywords)   text = text.replace(\"${k.toUpperCase()} \", \"$k \") // add a following space to be on safe side\n    for (s in singleCase) text = text.replace(s.toUpperCase(), s)\n    for (m in mixedCase)  text = text.replace(m.first, m.second)\n    File(\"calendar_NC.kt\").writeText(text)\n    val commands = listOf(\"kotlinc\", \"calendar_NC.kt\", \"-include-runtime\", \"-d\", \"calendar_X.jar\")\n    val pb = ProcessBuilder(commands)\n    pb.redirectErrorStream(true)\n    val process = pb.start()\n    process.waitFor()\n    val commands2 = listOf(\"java\", \"-jar\", \"calendar_NC.jar\")\n    val pb2 = ProcessBuilder(commands2)\n    pb2.redirectErrorStream(true)\n    val process2 = pb2.start()\n    val out = StringBuilder()\n    val br = BufferedReader(InputStreamReader(process2.inputStream))\n    while (true) {\n        val line = br.readLine()\n        if (line == null) break\n        out.append(line).append('\\n')\n    }\n    br.close()\n    println(out.toString()) \n}\n\n\nimport java.text.*\nimport java.util.*\nimport java.io.PrintStream\n \ninternal fun PrintStream.PRINTCALENDAR(YEAR: Int, NCOLS: Byte, LOCALE: Locale?) {\n    if (NCOLS < 1 || NCOLS > 12)\n        throw IllegalArgumentException(\"ILLEGAL COLUMN WIDTH.\")\n    val W = NCOLS * 24\n    val NROWS = Math.ceil(12.0 / NCOLS).toInt()\n \n    val DATE = GregorianCalendar(YEAR, 0, 1)\n    var OFFS = DATE.get(Calendar.DAY_OF_WEEK) - 1\n \n    val DAYS = DateFormatSymbols(LOCALE).shortWeekdays.slice(1..7).map { it.slice(0..1) }.joinToString(\" \", \" \")\n    val MONS = Array(12) { Array(8) { \"\" } }\n    DateFormatSymbols(LOCALE).months.slice(0..11).forEachIndexed { M, NAME ->\n        val LEN = 11 + NAME.length / 2\n        val FORMAT = MessageFormat.format(\"%{0}s%{1}s\", LEN, 21 - LEN)\n        MONS[M][0] = String.format(FORMAT, NAME, \"\")\n        MONS[M][1] = DAYS\n        val DIM = DATE.getActualMaximum(Calendar.DAY_OF_MONTH)\n        for (D in 1..42) {\n            val ISDAY = D > OFFS && D <= OFFS + DIM\n            val ENTRY = if (ISDAY) String.format(\" %2s\", D - OFFS) else \"   \"\n            if (D % 7 == 1)\n                MONS[M][2 + (D - 1) / 7] = ENTRY\n            else\n                MONS[M][2 + (D - 1) / 7] += ENTRY\n        }\n        OFFS = (OFFS + DIM) % 7\n        DATE.add(Calendar.MONTH, 1)\n    }\n \n    printf(\"%\" + (W / 2 + 10) + \"s%n\", \"[SNOOPY PICTURE]\")\n    printf(\"%\" + (W / 2 + 4) + \"s%n%n\", YEAR)\n \n    for (R in 0..NROWS - 1) {\n        for (I in 0..7) {\n            var C = R * NCOLS\n            while (C < (R + 1) * NCOLS && C < 12) {\n                printf(\"   %s\", MONS[C][I].toUpperCase())  // ORIGINAL CHANGED TO PRINT in UPPER CASE \n                C++\n            }\n            println()\n        }\n        println()\n    }\n}\n \nfun main(args: Array<String>) {\n    System.out.PRINTCALENDAR(1969, 3, Locale.US)\n}\n\n\n                              [SNOOPY PICTURE]\n                                    1969\n\n          JANUARY                 FEBRUARY                 MARCH        \n    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA\n              1  2  3  4                       1                       1\n     5  6  7  8  9 10 11     2  3  4  5  6  7  8     2  3  4  5  6  7  8\n    12 13 14 15 16 17 18     9 10 11 12 13 14 15     9 10 11 12 13 14 15\n    19 20 21 22 23 24 25    16 17 18 19 20 21 22    16 17 18 19 20 21 22\n    26 27 28 29 30 31       23 24 25 26 27 28       23 24 25 26 27 28 29\n                                                    30 31               \n\n           APRIL                    MAY                     JUNE        \n    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA\n           1  2  3  4  5                 1  2  3     1  2  3  4  5  6  7\n     6  7  8  9 10 11 12     4  5  6  7  8  9 10     8  9 10 11 12 13 14\n    13 14 15 16 17 18 19    11 12 13 14 15 16 17    15 16 17 18 19 20 21\n    20 21 22 23 24 25 26    18 19 20 21 22 23 24    22 23 24 25 26 27 28\n    27 28 29 30             25 26 27 28 29 30 31    29 30               \n                                                                        \n\n            JULY                   AUGUST                SEPTEMBER      \n    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA\n           1  2  3  4  5                    1  2        1  2  3  4  5  6\n     6  7  8  9 10 11 12     3  4  5  6  7  8  9     7  8  9 10 11 12 13\n    13 14 15 16 17 18 19    10 11 12 13 14 15 16    14 15 16 17 18 19 20\n    20 21 22 23 24 25 26    17 18 19 20 21 22 23    21 22 23 24 25 26 27\n    27 28 29 30 31          24 25 26 27 28 29 30    28 29 30            \n                            31                                          \n\n          OCTOBER                 NOVEMBER                DECEMBER      \n    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA    SU MO TU WE TH FR SA\n              1  2  3  4                       1        1  2  3  4  5  6\n     5  6  7  8  9 10 11     2  3  4  5  6  7  8     7  8  9 10 11 12 13\n    12 13 14 15 16 17 18     9 10 11 12 13 14 15    14 15 16 17 18 19 20\n    19 20 21 22 23 24 25    16 17 18 19 20 21 22    21 22 23 24 25 26 27\n    26 27 28 29 30 31       23 24 25 26 27 28 29    28 29 30 31         \n                            30                                          \n\n", "explain": "Kotlin is case-sensitive: all its keywords and packages are lower case, all its library classes are mixed case and its library functions are either lower case or mixed case. Consequently, it is impossible to run an upper case version of the Calendar task program as it stands. So what I've done instead (and similar to what several other languages in the same boat have done) is:\n1. Saved the Calendar program, after conversion to upper case and a small marked alteration to give upper case output, to a text file called calendar_UC.txt.\n2. Written another program called real_calendar.kt which takes calendar_UC.txt as input, outputs a runnable program called calendar_NC.kt to disk, compiles it to a .jar file, runs it, captures the output and prints it to the terminal (Ubuntu 14.04 being used). This program only makes the minimum changes to calendar_UC.txt to enable it to run. Everything else is left as upper case even though almost certainly no Kotlin programmer (\"REAL\" or not) would write such a program in practice. \nThis is calendar_UC.txt:\nand this is real_calendar.kt:\nwhich generates (on disk) calendar_NC.kt:\nwhich when compiled and run produces output of:\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Perl", "code": "\n\n$PROGRAM = '\\'\n\nMY @START_DOW = (3, 6, 6, 2, 4, 0, \n                 2, 5, 1, 3, 6, 1);\nMY @DAYS = (31, 28, 31, 30, 31, 30,\n            31, 31, 30, 31, 30, 31);\n\nMY @MONTHS;\nFOREACH MY $M (0 .. 11) {\n    FOREACH MY $R (0 .. 5) {\n        $MONTHS[$M][$R] = JOIN \" \",\n            MAP { $_ < 1 || $_ > $DAYS[$M]\u00a0? \"  \"\u00a0: SPRINTF \"%2D\", $_ }\n            MAP { $_ - $START_DOW[$M] + 1 }\n            $R * 7 .. $R * 7 + 6;\n    }\n}\n\nSUB P { WARN $_[0], \"\\\\N\" }\nP UC \"                                                       [INSERT SNOOPY HERE]\";\nP \"                                                               1969\";\nP \"\";\nFOREACH (UC(\"      JANUARY               FEBRUARY               MARCH                 APRIL                  MAY                   JUNE\"),\n         UC(\"        JULY                 AUGUST              SEPTEMBER              OCTOBER               NOVEMBER              DECEMBER\")) {\n    P $_;\n    MY @MS = SPLICE @MONTHS, 0, 6;\n    P JOIN \"  \", ((UC \"SU MO TU WE TH FR SA\") X 6);\n    P JOIN \"  \", MAP { SHIFT @$_ } @MS FOREACH 0 .. 5;\n}\n\n\\'';\n\n# LOWERCASE LETTERS\n$E = '%' | '@';\n$C = '#' | '@';\n$H = '(' | '@';\n$O = '/' | '@';\n$T = '4' | '@';\n$R = '2' | '@';\n$A = '!' | '@';\n$Z = ':' | '@';\n$P = '0' | '@';\n$L = ',' | '@';\n\n`${E}${C}${H}${O} $PROGRAM | ${T}${R} A-Z ${A}-${Z} | ${P}${E}${R}${L}`;\n\nAlthough, if we are abusing the backticks and other innocent programs, why not just: $_=$ARGV[0]//1969;`\\143\\141\\154 $_ >&2`\n\n", "explain": "Since we can't use eval or print (or any other keywords) \nat the top level, we need to abuse backticks in order to print anything, as in the infamous JAPH with no letters or numbers. Consequently, the calendar is printed to standard error instead of standard output.\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "Lua", "code": "\n\nFUNCTION PRINT_CAL(YEAR)\n  LOCAL MONTHS={\"JANUARY\",\"FEBRUARY\",\"MARCH\",\"APRIL\",\"MAY\",\"JUNE\",\n                \"JULY\",\"AUGUST\",\"SEPTEMBER\",\"OCTOBER\",\"NOVEMBER\",\"DECEMBER\"}\n  LOCAL DAYSTITLE=\"MO TU WE TH FR SA SU\"\n  LOCAL DAYSPERMONTH={31,28,31,30,31,30,31,31,30,31,30,31}\n  LOCAL STARTDAY=((YEAR-1)*365+MATH.FLOOR((YEAR-1)/4)-MATH.FLOOR((YEAR-1)/100)+MATH.FLOOR((YEAR-1)/400))%7\n  IF YEAR%4==0 AND YEAR%100~=0 OR YEAR%400==0 THEN\n    DAYSPERMONTH[2]=29\n  END\n  LOCAL SEP=5\n  LOCAL MONTHWIDTH=DAYSTITLE:LEN()\n  LOCAL CALWIDTH=3*MONTHWIDTH+2*SEP\n \n  FUNCTION CENTER(STR, WIDTH)\n    LOCAL FILL1=MATH.FLOOR((WIDTH-STR:LEN())/2)\n    LOCAL FILL2=WIDTH-STR:LEN()-FILL1\n    RETURN STRING.REP(\" \",FILL1)..STR..STRING.REP(\" \",FILL2)\n  END\n \n  FUNCTION MAKEMONTH(NAME, SKIP,DAYS)\n    LOCAL CAL={\n      CENTER(NAME,MONTHWIDTH),\n      DAYSTITLE\n    }\n    LOCAL CURDAY=1-SKIP\n    WHILE #CAL<9 DO\n      LINE={}\n      FOR I=1,7 DO\n        IF CURDAY<1 OR CURDAY>DAYS THEN\n          LINE[I]=\"  \"\n        ELSE\n          LINE[I]=STRING.FORMAT(\"%2D\",CURDAY)\n        END\n        CURDAY=CURDAY+1\n      END\n      CAL[#CAL+1]=TABLE.CONCAT(LINE,\" \")\n    END\n    RETURN CAL\n  END\n \n  LOCAL CALENDAR={}\n  FOR I,MONTH IN IPAIRS(MONTHS) DO\n    LOCAL DPM=DAYSPERMONTH[I]\n    CALENDAR[I]=MAKEMONTH(MONTH, STARTDAY, DPM)\n    STARTDAY=(STARTDAY+DPM)%7\n  END\n \n \n  PRINT(CENTER(\"[SNOOPY]\",CALWIDTH):UPPER(),\"\\N\")\n  PRINT(CENTER(\"--- \"..YEAR..\" ---\",CALWIDTH):UPPER(),\"\\N\")\n \n  FOR Q=0,3 DO\n    FOR L=1,9 DO\n      LINE={}\n      FOR M=1,3 DO\n        LINE[M]=CALENDAR[Q*3+M][L]\n      END\n      PRINT(TABLE.CONCAT(LINE,STRING.REP(\" \",SEP)):UPPER())\n    END\n  END\nEND\n \nPRINT_CAL(1969)\n\n\ndo io.input( arg[ 1 ] ); local s = io.read( \"*a\" ):lower(); io.close(); assert( load( s ) )() end\n\n\n\nOutput:\n                               [SNOOPY]                               \t\n\n                             --- 1969 ---                             \t\n\n      JANUARY                  FEBRUARY                  MARCH        \nMO TU WE TH FR SA SU     MO TU WE TH FR SA SU     MO TU WE TH FR SA SU\n       1  2  3  4  5                     1  2                     1  2\n 6  7  8  9 10 11 12      3  4  5  6  7  8  9      3  4  5  6  7  8  9\n13 14 15 16 17 18 19     10 11 12 13 14 15 16     10 11 12 13 14 15 16\n20 21 22 23 24 25 26     17 18 19 20 21 22 23     17 18 19 20 21 22 23\n27 28 29 30 31           24 25 26 27 28           24 25 26 27 28 29 30\n                                                  31                  \n                                                                      \n       APRIL                     MAY                      JUNE        \nMO TU WE TH FR SA SU     MO TU WE TH FR SA SU     MO TU WE TH FR SA SU\n    1  2  3  4  5  6               1  2  3  4                        1\n 7  8  9 10 11 12 13      5  6  7  8  9 10 11      2  3  4  5  6  7  8\n14 15 16 17 18 19 20     12 13 14 15 16 17 18      9 10 11 12 13 14 15\n21 22 23 24 25 26 27     19 20 21 22 23 24 25     16 17 18 19 20 21 22\n28 29 30                 26 27 28 29 30 31        23 24 25 26 27 28 29\n                                                  30                  \n                                                                      \n        JULY                    AUGUST                 SEPTEMBER      \nMO TU WE TH FR SA SU     MO TU WE TH FR SA SU     MO TU WE TH FR SA SU\n    1  2  3  4  5  6                  1  2  3      1  2  3  4  5  6  7\n 7  8  9 10 11 12 13      4  5  6  7  8  9 10      8  9 10 11 12 13 14\n14 15 16 17 18 19 20     11 12 13 14 15 16 17     15 16 17 18 19 20 21\n21 22 23 24 25 26 27     18 19 20 21 22 23 24     22 23 24 25 26 27 28\n28 29 30 31              25 26 27 28 29 30 31     29 30               \n                                                                      \n                                                                      \n      OCTOBER                  NOVEMBER                 DECEMBER      \nMO TU WE TH FR SA SU     MO TU WE TH FR SA SU     MO TU WE TH FR SA SU\n       1  2  3  4  5                     1  2      1  2  3  4  5  6  7\n 6  7  8  9 10 11 12      3  4  5  6  7  8  9      8  9 10 11 12 13 14\n13 14 15 16 17 18 19     10 11 12 13 14 15 16     15 16 17 18 19 20 21\n20 21 22 23 24 25 26     17 18 19 20 21 22 23     22 23 24 25 26 27 28\n27 28 29 30 31           24 25 26 27 28 29 30     29 30 31            \n                                                                      \n                                                                      \n\n", "explain": "Tested with Lua 5.3.2\n\nLua is case sensitive and all the keywords and library routines are in lower case. As with the D sample, we use a simple pre-processor to execute the (slightly modified) upper-cased source of the Lua solution for the standard Calendar task.\n\nThe upper case Lua source - stored in a file called UCCALENDAR.LUU:\n\nThe following \"one-liner\" standard Lua source will down-case and run the program in the source file specified as it's parameter (file luu.lua):\nThe following command will execute the UCCALENDAR.LUU source (replace lua532 with the appropriate command for your system):\n\n\nlua532 luu.lua UCCALENDAR.LUU\n\n"}, {"task_name": "Calendar - for \"REAL\" programmers", "task_url": "https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers", "task_cat": "Date and time", "lang": "D", "code": "\n\nIMPORT STD.STDIO, STD.DATETIME, STD.STRING, STD.CONV,\n       STD.ALGORITHM, STD.ARRAY;\n\nVOID PRINT_CALENDAR(IN UINT YEAR, IN UINT COLS)\nIN {\n    ASSERT(COLS > 0 && COLS <= 12);\n} BODY {\n    STATIC ENUM CAMEL_CASE = (STRING[] PARTS) PURE =>\n        PARTS[0] ~ PARTS[1 .. $].MAP!CAPITALIZE.JOIN;\n\n    IMMUTABLE ROWS = 12 / COLS + (12\u00a0% COLS\u00a0!= 0);\n    MIXIN(\"AUTO DATE = \" ~ \"DATE(YEAR, 1, 1);\".CAPITALIZE);\n    ENUM STRING S1 = CAMEL_CASE(\"DAY OF WEEK\".SPLIT);\n    MIXIN(FORMAT(\"AUTO OFFS = CAST(INT)DATE.%S;\", S1));\n    CONST MONTHS = \"JANUARY FEBRUARY MARCH APRIL MAY JUNE\n        JULY AUGUST SEPTEMBER OCTOBER NOVEMBER DECEMBER\"\n        .SPLIT.MAP!CAPITALIZE.ARRAY;\n\n    STRING[8][12] MONS;\n    FOREACH (IMMUTABLE M; 0 .. 12) {\n        MONS[M][0] = MONTHS[M].CENTER(21);\n        MONS[M][1] = \" \" ~ \"SU MO TU WE TH FR SA\"\n                           .SPLIT.MAP!CAPITALIZE.JOIN(\" \");\n        ENUM STRING S2 = CAMEL_CASE(\"DAYS IN MONTH\".SPLIT);\n        MIXIN(FORMAT(\"IMMUTABLE DIM = DATE.%S;\", S2));\n        FOREACH (IMMUTABLE D; 1 .. 43) {\n            IMMUTABLE DAY = D > OFFS && D <= OFFS + DIM;\n            IMMUTABLE STR = DAY\u00a0? FORMAT(\" %2S\", D-OFFS)\u00a0: \"   \";\n            MONS[M][2 + (D - 1) / 7] ~= STR;\n        }\n        OFFS = (OFFS + DIM)\u00a0% 7;\n        DATE.ADD!\"MONTHS\"(1);\n    }\n\n    FORMAT(\"[%S %S]\", \"SNOOPY\".CAPITALIZE, \"PICTURE\".CAPITALIZE)\n    .CENTER(COLS * 24 + 4).WRITELN;\n    WRITELN(YEAR.TEXT.CENTER(COLS * 24 + 4), \"\\N\");\n    FOREACH (IMMUTABLE R; 0 .. ROWS) {\n        STRING[8] S;\n        FOREACH (IMMUTABLE C; 0 .. COLS) {\n            IF (R * COLS + C > 11)\n                BREAK;\n            FOREACH (IMMUTABLE I, LINE; MONS[R * COLS + C])\n                S[I] ~= FORMAT(\"   %S\", LINE);\n        }\n        WRITEFLN(\"%-(%S\\N%)\\N\", S);\n    }\n}\n\nSTATIC THIS() {\n    PRINT_CALENDAR(1969, 3);\n}\n\nimport std.string;mixin(import(\"CALENDAR\").toLower);void main(){}\n\n\nOutput:\n                              [Snoopy Picture]                              \n                                    1969                                    \n\n          January                February                  March        \n    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa\n              1  2  3  4                       1                       1\n     5  6  7  8  9 10 11     2  3  4  5  6  7  8     2  3  4  5  6  7  8\n    12 13 14 15 16 17 18     9 10 11 12 13 14 15     9 10 11 12 13 14 15\n    19 20 21 22 23 24 25    16 17 18 19 20 21 22    16 17 18 19 20 21 22\n    26 27 28 29 30 31       23 24 25 26 27 28       23 24 25 26 27 28 29\n                                                    30 31               \n\n           April                    May                    June         \n    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa\n           1  2  3  4  5                 1  2  3     1  2  3  4  5  6  7\n     6  7  8  9 10 11 12     4  5  6  7  8  9 10     8  9 10 11 12 13 14\n    13 14 15 16 17 18 19    11 12 13 14 15 16 17    15 16 17 18 19 20 21\n    20 21 22 23 24 25 26    18 19 20 21 22 23 24    22 23 24 25 26 27 28\n    27 28 29 30             25 26 27 28 29 30 31    29 30               \n                                                                        \n\n           July                   August                 September      \n    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa\n           1  2  3  4  5                    1  2        1  2  3  4  5  6\n     6  7  8  9 10 11 12     3  4  5  6  7  8  9     7  8  9 10 11 12 13\n    13 14 15 16 17 18 19    10 11 12 13 14 15 16    14 15 16 17 18 19 20\n    20 21 22 23 24 25 26    17 18 19 20 21 22 23    21 22 23 24 25 26 27\n    27 28 29 30 31          24 25 26 27 28 29 30    28 29 30            \n                            31                                          \n\n          October                November                December       \n    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa    Su Mo Tu We Th Fr Sa\n              1  2  3  4                       1        1  2  3  4  5  6\n     5  6  7  8  9 10 11     2  3  4  5  6  7  8     7  8  9 10 11 12 13\n    12 13 14 15 16 17 18     9 10 11 12 13 14 15    14 15 16 17 18 19 20\n    19 20 21 22 23 24 25    16 17 18 19 20 21 22    21 22 23 24 25 26 27\n    26 27 28 29 30 31       23 24 25 26 27 28 29    28 29 30 31         \n                            30       \n", "explain": "D keywords are lower case, so this silly solution uses the whole Calendar Task code, with small changes and all in upper case, in a text file named \"CALENDAR\":\nThen in another source code file there is a little loader, that imports it and mixes-in it (for safety this program must be compiled with -Jsomepath):\n"}]