[{"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Python", "code": "\nLinux (including cygwin) and Mac OSX Leopard[edit]\nWorks with: Python version 2.6\n\nimport __main__, os\n\ndef isOnlyInstance():\n    # Determine if there are more than the current instance of the application\n    # running at the current time.\n    return os.system(\"(( $(ps -ef | grep python | grep '[\" +\n                     __main__.__file__[0] + \"]\" + __main__.__file__[1:] +\n                     \"' | wc -l) > 1 ))\") != 0\n\n\n", "explain": "Must be run from an application, not the interpreter.\nThis is not a solution - one can run the same app by copying the code to another location. A solution may be a lock file or lock directory created by the first instance and hold while the first instance is running.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "C", "code": "\nPOSIX with file lock[edit]\n\nLibrary: POSIX\n#include <fcntl.h>\t/* fcntl, open */\n#include <stdlib.h>\t/* atexit, getenv, malloc */\n#include <stdio.h>\t/* fputs, printf, puts, snprintf */\n#include <string.h>\t/* memcpy */\n#include <unistd.h>\t/* sleep, unlink */\n\n/* Filename for only_one_instance() lock. */\n#define INSTANCE_LOCK \"rosetta-code-lock\"\n\nvoid\nfail(const char *message)\n{\n\tperror(message);\n\texit(1);\n}\n\n/* Path to only_one_instance() lock. */\nstatic char *ooi_path;\n\nvoid\nooi_unlink(void)\n{\n\tunlink(ooi_path);\n}\n\n/* Exit if another instance of this program is running. */\nvoid\nonly_one_instance(void)\n{\n\tstruct flock fl;\n\tsize_t dirlen;\n\tint fd;\n\tchar *dir;\n\n\t/*\n\t * Place the lock in the home directory of this user;\n\t * therefore we only check for other instances by the same\n\t * user (and the user can trick us by changing HOME).\n\t */\n\tdir = getenv(\"HOME\");\n\tif (dir == NULL || dir[0] != '/') {\n\t\tfputs(\"Bad home directory.\\n\", stderr);\n\t\texit(1);\n\t}\n\tdirlen = strlen(dir);\n\n\tooi_path = malloc(dirlen + sizeof(\"/\" INSTANCE_LOCK));\n\tif (ooi_path == NULL)\n\t\tfail(\"malloc\");\n\tmemcpy(ooi_path, dir, dirlen);\n\tmemcpy(ooi_path + dirlen, \"/\" INSTANCE_LOCK,\n\t    sizeof(\"/\" INSTANCE_LOCK));  /* copies '\\0' */\n\n\tfd = open(ooi_path, O_RDWR | O_CREAT, 0600);\n\tif (fd < 0)\n\t\tfail(ooi_path);\n\n\tfl.l_start = 0;\n\tfl.l_len = 0;\n\tfl.l_type = F_WRLCK;\n\tfl.l_whence = SEEK_SET;\n\tif (fcntl(fd, F_SETLK, &fl) < 0) {\n\t\tfputs(\"Another instance of this program is running.\\n\",\n\t\t    stderr);\n\t\texit(1);\n\t}\n\n\t/*\n\t * Run unlink(ooi_path) when the program exits. The program\n\t * always releases locks when it exits.\n\t */\n\tatexit(ooi_unlink);\n}\n\n/*\n * Demo for Rosetta Code.\n * http://rosettacode.org/wiki/Determine_if_only_one_instance_is_running\n */\nint\nmain()\n{\n\tint i;\n\n\tonly_one_instance();\n\n\t/* Play for 10 seconds. */\n\tfor(i = 10; i > 0; i--) {\n\t\tprintf(\"%d...%s\", i, i % 5 == 1 ? \"\\n\" : \" \");\n\t\tfflush(stdout);\n\t\tsleep(1);\n\t}\n\tputs(\"Fin!\");\n\treturn 0;\n}\n\nPOSIX with file creation[edit]\n\nLibrary: POSIX\n#include <fcntl.h>\n#include <signal.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n/* unistd for sleep */\n\nvoid sigint_handler(int sig)\n{\n   fprintf(stderr, \"Caught signal %d.\\n\", sig);\n   unlink(\"/tmp/MyUniqueName\");\n   /* exit() is not safe in a signal handler, use _exit() */\n   _exit(1);\n}\n\nint main()\n{\n   struct sigaction act;\n   int myfd;\n   \n   myfd = open(\"/tmp/MyUniqueName\", O_CREAT|O_EXCL);\n   if ( myfd < 0 )\n   {\n      fprintf(stderr, \"I am already running!\\n\");\n      exit(1);\n   }\n   act.sa_handler = sigint_handler;\n   sigemptyset(&act.sa_mask);\n   act.sa_flags = 0;\n   sigaction(SIGINT, &act, NULL);\n   /* here the real code of the app*/\n   sleep(20);\n   /* end of the app */\n   unlink(\"/tmp/MyUniqueName\"); close(myfd);\n   return 0;\n}\n\n", "explain": "This solution opens ~/rosetta-code-lock and uses fcntl() to set a write lock on the file. Only one instance can set this lock. If fcntl() fails, this program assumes that another instance is running. This program always clears its lock when it terminates.\nThe user might use an interrupt or other signal to terminate the program. If so, the lock file survives, but the system still clears the lock. The user can run the program again.\nNote that the underlying file system needs to support file locking; for example if ~/ directory is on a NFS mounted partition, success in a locking fcntl() call is not always meaningful.\nThis solution opens a file with O_CREAT|O_EXCL. If the file already exists, this program assumes that another instance is running. This solution is not as good as file locking, because the program might terminate without deleting the file.\nThe program, when terminating, must be sure to unlink() the file. This example has unlink() at two places: at the end of main(), and at a SIGINT handler. If you interrupt the program, it will probably delete /tmp/MyUniqueName, but not if SIGINT wins a race before the program installs its handler. If you terminate the program with a different signal, then you will get stuck, because /tmp/MyUniqueName will still exist, preventing another execution of the program. One might add code to catch some other signals, but there is no way to catch SIGKILL!\nThis program uses a regular file, with open() and unlink(). There is an older version that uses a semaphore, with sem_open() and sem_unlink(). The switch from a semaphore to a regular file was easy, because the program never used the semaphore as a semaphore; it only checked the existence of a semaphore. If you get stuck, rm /tmp/MyUniqueName might be easier than deleting a semaphore.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "C++", "code": "\nMicrosoft Windows[edit]\nWorks with: Windows version 2000 or later\n\n#include <afx.h>\n\n\nHANDLE mutex;\n\n\nmutex = CreateMutex( NULL, TRUE, \"MyApp\" );\nif ( GetLastError() == ERROR_ALREADY_EXISTS )\n{\n     // There's another instance running.  What do you do?\n}\n\n\nCloseHandle( mutex );\n\n", "explain": "This line needs to be near the top of the file (or in stdafx.h, if you use one.)\nYou need a variable of type HANDLE with the same lifetime as your program.  Perhaps as a member of your CWinApp object.\nAt the earliest possible point in your program, you need to initialize it and perform your check. \"MyApp\" should be a string unique to your application.  See here for full details.\nFinally, near the end of your program, you need to close the mutex.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Java", "code": "\nimport java.io.IOException;\nimport java.net.InetAddress;\nimport java.net.ServerSocket;\nimport java.net.UnknownHostException;\n \npublic class SingletonApp\n{\n    private static final int PORT = 65000;  // random large port number\n    private static ServerSocket s;\n\n    // static initializer\n    static {\n        try {\n            s = new ServerSocket(PORT, 10, InetAddress.getLocalHost());\n        } catch (UnknownHostException e) {\n            // shouldn't happen for localhost\n        } catch (IOException e) {\n            // port taken, so app is already running\n            System.out.print(\"Application is already running,\");\n            System.out.println(\" so terminating this instance.\");\n            System.exit(0);\n        }\n    }\n\n    public static void main(String[] args) {\n        System.out.print(\"OK, only this instance is running\");\n        System.out.println(\" but will terminate in 10 seconds.\");\n        try {\n            Thread.sleep(10000);\n            if (s != null && !s.isClosed()) s.close();\n        } catch (Exception e) {\n            System.err.println(e);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "C#", "code": "\nUsing a TCP Port[edit]\nusing System;\nusing System.Net;\nusing System.Net.Sockets;\n\nclass Program {        \n    static void Main(string[] args) {        \n        try {\n            TcpListener server = new TcpListener(IPAddress.Any, 12345);\n            server.Start();\n        } \n       \n        catch (SocketException e) {\n            if (e.SocketErrorCode == SocketError.AddressAlreadyInUse) {\n                Console.Error.WriteLine(\"Already running.\");\n            }\n        }\n    }\n}\n\nUsing a mutex[edit]\n// Use this class in your process to guard against multiple instances\n//\n// This is valid for C# running on Windows, but not for C# with Linux.\n//\nusing System;\nusing System.Threading;\n\n/// <summary>\n/// RunOnce should be instantiated in the calling processes main clause\n/// (preferably using a \"using\" clause) and then calling process\n/// should then check AlreadyRunning and do whatever is appropriate\n/// </summary>\npublic class RunOnce : IDisposable\n{\n\tpublic RunOnce( string name )\n\t{\n\t\tm_name = name;\n\t\tAlreadyRunning = false;\n\n\t\tbool created_new = false;\n\n\t\tm_mutex = new Mutex( false, m_name, out created_new );\n\n\t\tAlreadyRunning = !created_new;\n\t}\n\n\t~RunOnce()\n\t{\n\t\tDisposeImpl( false );\n\t}\n\n\tpublic bool AlreadyRunning\n\t{\n\t\tget { return m_already_running; }\n\t\tprivate set { m_already_running = value; }\n\t}\n\n\tprivate void DisposeImpl( bool is_disposing )\n\t{\n\t\tGC.SuppressFinalize( this );\n\n\t\tif( is_disposing )\n\t\t{\n\t\t\tm_mutex.Close();\n\t\t}\n\t}\n\n\t#region IDisposable Members\n\n\tpublic void Dispose()\n\t{\n\t\tDisposeImpl( true );\n\t}\n\n\t#endregion\n\n\tprivate string m_name;\n\tprivate bool m_already_running;\n\tprivate Mutex m_mutex;\n}\n\nclass Program\n{\n    // Example code to use this\n    static void Main( string[] args )\n    {\n        using ( RunOnce ro = new RunOnce( \"App Name\" ) )\n        {\n            if ( ro.AlreadyRunning )\n            {\n                Console.WriteLine( \"Already running\" );\n                return;\n            }\n\n            // Program logic\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Go", "code": "\nPort[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"net\"\n    \"time\"\n)\n\nconst lNet = \"tcp\"\nconst lAddr = \":12345\"\n\nfunc main() {\n    if _, err := net.Listen(lNet, lAddr); err != nil {\n        fmt.Println(\"an instance was already running\")\n        return\n    }\n    fmt.Println(\"single instance started\")\n    time.Sleep(10 * time.Second)\n}\n\nFile[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"time\"\n)\n\n// The path to the lock file should be an absolute path starting from the root.\n// (If you wish to prevent the same program running in different directories,\n// that is.)\nconst lfn = \"/tmp/rclock\"\n\nfunc main() {\n    lf, err := os.OpenFile(lfn, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)\n    if err != nil {\n        fmt.Println(\"an instance is already running\")\n        return\n    }\n    lf.Close()\n    fmt.Println(\"single instance started\")\n    time.Sleep(10 * time.Second)\n    os.Remove(lfn)\n}\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"time\"\n)\n\n// The path to the lock file should be an absolute path starting from the root.\n// (If you wish to prevent the same program running in different directories, that is.)\nconst lfn = \"/tmp/rclock\"\n\nfunc main() {\n    lf, err := os.OpenFile(lfn, os.O_RDWR|os.O_CREATE|os.O_EXCL, 0666)\n    if err == nil {\n        // good\n        // 10 digit pid seems to be a standard for lock files\n        fmt.Fprintf(lf, \"%10d\", os.Getpid())\n        lf.Close()\n        defer os.Remove(lfn)\n    } else {\n        // problem\n        fmt.Println(err)\n        // dig deeper\n        lf, err = os.Open(lfn)\n        if err != nil {\n            return\n        }\n        defer lf.Close()\n        fmt.Println(\"inspecting lock file...\")\n        b10 := make([]byte, 10)\n        _, err = lf.Read(b10)\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        pid, err := strconv.Atoi(strings.TrimSpace(string(b10)))\n        if err != nil {\n            fmt.Println(err)\n            return\n        }\n        fmt.Println(\"lock file created by pid\", pid)\n        return\n    }\n    fmt.Println(os.Getpid(), \"running...\")\n    time.Sleep(1e10)\n}\n\n", "explain": "Recommended over file based solutions.  It has the advantage that the port is always released\nwhen the process ends.\nSolution using O_CREATE|O_EXCL.  This solution has the problem that if anything terminates the\nprogram early, the lock file remains.\nHere's a fluffier version that stores the PID in the lock file to provide better messages.\nIt has the same problem of the lock file remaining if anything terminates the program early.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Delphi", "code": "\nprogram OneInstance;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, Windows;\n\nvar\n  FMutex: THandle;\nbegin\n  FMutex := CreateMutex(nil, True, 'OneInstanceMutex');\n  if FMutex = 0 then\n    RaiseLastOSError\n  else\n  begin\n    try\n      if GetLastError = ERROR_ALREADY_EXISTS then\n        Writeln('Program already running.  Closing...')\n      else\n      begin\n        // do stuff ...\n        Readln;\n      end;\n    finally\n      CloseHandle(FMutex);\n    end;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Ruby", "code": "\n\ndef main\n  puts \"first instance\"\n  sleep 20\n  puts :done\nend\n\nif $0 == __FILE__\n  if File.new(__FILE__).flock(File::LOCK_EX | File::LOCK_NB)\n    main\n  else\n    raise \"another instance of this program is running\"\n  end\nend\n\n__END__\n\n", "explain": "Uses file locking on the program file\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Rust", "code": "\n\nuse std::net::TcpListener;\n\nfn create_app_lock(port: u16) -> TcpListener {\n    match TcpListener::bind((\"0.0.0.0\", port)) {\n        Ok(socket) => {\n            socket\n        },\n        Err(_) => {\n            panic!(\"Couldn't lock port {}: another instance already running?\", port);\n        }\n    }\n}\n\nfn remove_app_lock(socket: TcpListener) {\n    drop(socket);\n}\n\nfn main() {\n    let lock_socket = create_app_lock(12345);\n    // ...\n    // your code here\n    // ...\n    remove_app_lock(lock_socket);\n}\n\n", "explain": "Using TCP socket\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Swift", "code": "\n\nimport Foundation\n\nlet globalCenter = NSDistributedNotificationCenter.defaultCenter()\nlet time = NSDate().timeIntervalSince1970\n\nglobalCenter.addObserverForName(\"OnlyOne\", object: nil, queue: NSOperationQueue.mainQueue()) {not in\n    if let senderTime = not.userInfo?[\"time\"] as? NSTimeInterval where senderTime != time {\n        println(\"More than one running\")\n        exit(0)\n    } else {\n        println(\"Only one\")\n    }\n}\n\nfunc send() {\n    globalCenter.postNotificationName(\"OnlyOne\", object: nil, userInfo: [\"time\": time])\n    \n    let waitTime = dispatch_time(DISPATCH_TIME_NOW, Int64(3 * NSEC_PER_SEC))\n    \n    dispatch_after(waitTime, dispatch_get_main_queue()) {\n        send()\n    }\n}\n\nsend()\nCFRunLoopRun()\n\n", "explain": "Uses NSDistributedNotificationCenter. Works with Swift 1.2.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 4\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\nDim onlyInstance as Boolean\nonlyInstance = not App.PrevInstance\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;\n\nprocedure Single_Instance is\n\n   package IO renames Ada.Text_IO;\n   Lock_File: IO.File_Type;\n   Lock_File_Name: String := \"single_instance.magic_lock\";\n\nbegin\n   begin\n      IO.Open(File => Lock_File, Mode=> IO.In_File, Name => Lock_File_Name);\n      IO.Close(Lock_File);\n      IO.Put_Line(\"I can't -- another instance of me is running ...\");\n   exception\n      when IO.Name_Error =>\n         IO.Put_Line(\"I can run!\");\n         IO.Create(File => Lock_File, Name => Lock_File_Name);\n         for I in 1 .. 10 loop\n            IO.Put(Integer'Image(I));\n            delay 1.0; -- wait one second\n         end loop;\n         IO.Delete(Lock_File);\n         IO.New_Line;\n         IO.Put_Line(\"I am done!\");\n   end;\nexception\n   when others => IO.Delete(Lock_File);\nend Single_Instance;\n\n\n", "explain": "The following solution tries to open a file for reading. If the file does not exist, a 'Name_Error' is raised. The exception handler creates that file, allows the program to perform its task, and, eventually, makes sure the file is deleted. If no exception is raised, the file exists, so another instance is running, and the program stops. It also stops if the wrong exception is raised, i.e., any exception other than 'Name_Error'. \nNote that there is a race condition: If another instance tries to open the file for reading, before the first one has created it, then more than one instance will actually run.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Julia", "code": "\nTranslation of: Javausing Sockets\n\nconst portnum = 12345\n\nfunction canopen()\n    try\n        server = listen(portnum)\n        println(\"This is the only instance.\")\n        sleep(20)\n    catch y\n        if findfirst(\"EADDRINUSE\", string(y)) != nothing\n            println(\"There is already an instance running.\")\n        end\n    end\nend\n\ncanopen()\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nimport java.io.IOException\nimport java.net.*\n\nobject SingleInstance {\n    private var ss: ServerSocket? = null  \n\n    fun alreadyRunning(): Boolean {\n        try {\n            ss = ServerSocket(65000, 10, InetAddress.getLocalHost()) // using private port 65000        \n        }\n        catch (e: IOException) {\n            // port already in use so an instance is already running\n            return true   \n        }\n        return false\n    }\n\n    fun close() {\n        if (ss == null || ss?.isClosed() == true) return\n        ss?.close()\n    }\n}\n\nfun main(args: Array<String>) {\n    if (SingleInstance.alreadyRunning()) {\n        println(\"Application is already running, so terminating this instance\")\n        System.exit(0)\n    }\n    else { \n        println(\"OK, only this instance is running but will terminate in 10 seconds\")\n        Thread.sleep(10000)\n        SingleInstance.close()  \n    }\n}\n\n\nOutput:\n\nOK, only this instance is running but will terminate in 10 seconds\n\n\nOutput:\n\nApplication is already running, so terminating this instance\n\n", "explain": "First output window:\nSecond output window (second instance started within 10 seconds of first):\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Perl", "code": "\n\nuse Fcntl ':flock';\n\nINIT\n{\n\tdie \"Not able to open $0\\n\" unless (open ME, $0);\n\tdie \"I'm already running\u00a0!!\\n\" unless(flock ME, LOCK_EX|LOCK_NB);\n}\n\nsleep 60; # then your code goes here\n\n", "explain": "The INIT block is runned just before the Perl runtime begins execution. See perlmod\nThen it tries to get a lock to its own file, from where the script was called.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Scala", "code": "\nJava Interoperability[edit]\n\nOutput:Best seen running in your browser Scastie (remote JVM).\nimport java.io.IOException\nimport java.net.{InetAddress, ServerSocket}\n\nobject SingletonApp extends App {\n  private val port = 65000\n\n  try {\n    val s = new ServerSocket(port, 10, InetAddress.getLocalHost)\n  }\n  catch {\n    case _: IOException =>\n      // port taken, so app is already running\n      println(\"Application is already running, so terminating this instance.\")\n      sys.exit(-1)\n  }\n\n  println(\"OK, only this instance is running but will terminate in 10 seconds.\")\n\n  Thread.sleep(10000)\n\n  sys.exit(0)\n\n}\n\n", "explain": ""}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "D", "code": "\nUnix Domain Socket[edit]\n\nThere is no need to worry about possible collisions with existing files in the filesystem.\nThere is no socket file to be removed upon program termination.\nWe do not need to create a file for the socket at all. This obviates target directory existence, permissions checks, and reduces filesystem clutter. Also, it works in chrooted environments.\n\nbool is_unique_instance()\n{\n    import std.socket;\n    auto socket = new Socket(AddressFamily.UNIX, SocketType.STREAM);\n    auto addr = new UnixAddress(\"\\0/tmp/myapp.uniqueness.sock\");\n    try\n    {\n        socket.bind(addr);\n        return true;\n    }\n    catch (SocketOSException e)\n    {\n        import core.stdc.errno : EADDRINUSE;\n\n        if (e.errorCode == EADDRINUSE)\n            return false;\n        else\n            throw e;\n    }\n}\n\n", "explain": "Unix domain sockets support another addressing mode, via the so-called abstract namespace. This allows us to bind sockets to names rather than to files. What we get are the following benefits (see page 1175 in The Linux Programming Interface):\nAll we need is to generate a unique name for our program and pass it as the address when calling bind(). The trick is that instead of specifying a file path as the address, we pass a null byte followed by the name of our choosing (e.g. \"\\0my-unique-name\"). The initial null byte is what distinguishes abstract socket names from conventional Unix domain socket path names, which consist of a string of one or more non-null bytes terminated by a null byte.\nRead more here: [1]\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "Haskell", "code": "\n\nimport Control.Concurrent\nimport System.Directory (doesFileExist, getAppUserDataDirectory,\n    removeFile)\nimport System.IO (withFile, Handle, IOMode(WriteMode), hPutStr)\n\noneInstance :: IO ()\noneInstance = do\n    -- check if file \"$HOME/.myapp.lock\" exists\n    user <- getAppUserDataDirectory \"myapp.lock\"\n    locked <- doesFileExist user\n    if locked\n    then print \"There is already one instance of this program running.\"\n    else do\n        t <- myThreadId\n        -- this is the entry point to the main program:\n        -- withFile creates a file, then calls a function,\n        -- then closes the file\n        withFile user WriteMode (do_program t)\n        -- remove the lock when we're done\n        removeFile user\n\ndo_program :: ThreadId -> Handle -> IO ()\ndo_program t h = do\n    let s = \"Locked by thread: \" ++ show t\n    -- print what thread has acquired the lock\n    putStrLn s\n    -- write the same message to the file, to show that the\n    -- thread \"owns\" the file\n    hPutStr h s\n    -- wait for one second\n    threadDelay 1000000\n\nmain :: IO ()\nmain = do\n    -- launch the first thread, which will create the lock file\n    forkIO oneInstance\n    -- wait for half a second\n    threadDelay 500000\n    -- launch the second thread, which will find the lock file and\n    -- thus will exit immediately\n    forkIO oneInstance\n    return ()\n\n", "explain": "Simple implementation using a lock file. Two threads are launched, but the second cannot start because the first has created a lock file which is deleted when it has finished.\n"}, {"task_name": "Determine if only one instance is running", "task_url": "https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running", "task_cat": "Programming environment operations", "lang": "PowerShell", "code": "\nif (Get-Process -Name \"notepad\" -ErrorAction SilentlyContinue)\n{\n    Write-Warning -Message \"notepad is already running.\"\n}\nelse\n{\n    Start-Process -FilePath C:\\Windows\\notepad.exe\n}\n\n\n\nOutput:\n\n\nif (Get-Process -Name \"notepad\" -ErrorAction SilentlyContinue)\n{\n    Write-Warning -Message \"notepad is already running.\"\n}\nelse\n{\n    Start-Process -FilePath C:\\Windows\\notepad.exe\n}\n\n\n\nOutput:\nWARNING: notepad is already running\n\n", "explain": "No output because notepad.exe was not running, so it was started.\nRun it again.\nSince it is running a warning message is output.\n"}]