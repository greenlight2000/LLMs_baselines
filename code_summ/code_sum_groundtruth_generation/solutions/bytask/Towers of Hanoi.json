[{"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nRecursive[edit]\ndef hanoi(ndisks, startPeg=1, endPeg=3):\n    if ndisks:\n        hanoi(ndisks-1, startPeg, 6-startPeg-endPeg)\n        print(f\"Move disk {ndisks} from peg {startPeg} to peg {endPeg}\")\n        hanoi(ndisks-1, 6-startPeg-endPeg, endPeg)\n \nhanoi(4)\n\nOutput: for ndisks=2\nMove disk 1 from peg 1 to peg 2\nMove disk 2 from peg 1 to peg 3\nMove disk 1 from peg 2 to peg 3\n\n\nWorks with: Python version 3.7\n'''Towers of Hanoi'''\n\n\n# hanoi\u00a0:: Int -> String -> String -> String -> [(String, String)]\ndef hanoi(n):\n    '''A list of (from, to) label pairs,\n       where a, b and c are labels for each of the\n       three Hanoi tower positions.'''\n    def go(n, a, b, c):\n        p = n - 1\n        return (\n            go(p, a, c, b) + [(a, b)] + go(p, c, b, a)\n        ) if 0 < n else []\n    return lambda a: lambda b: lambda c: go(n, a, b, c)\n\n\n# TEST ----------------------------------------------------\nif __name__ == '__main__':\n\n    # fromTo\u00a0:: (String, String) -> String\n    def fromTo(xy):\n        '''x -> y'''\n        x, y = xy\n        return x.rjust(5, ' ') + ' -> ' + y\n\n    print(__doc__ + ':\\n\\n' + '\\n'.join(\n        map(fromTo, hanoi(4)('left')('right')('mid'))\n    ))\n\nOutput:\nTowers of Hanoi:\n\n left -> mid\n left -> right\n  mid -> right\n left -> mid\nright -> left\nright -> mid\n left -> mid\n left -> right\n  mid -> right\n  mid -> left\nright -> left\n  mid -> right\n left -> mid\n left -> right\n  mid -> right\nGraphic[edit]\n\nWorks with: Python version 3.7\n'''Towers of Hanoi'''\n\nfrom itertools import accumulate, chain, repeat\nfrom inspect import signature\nimport operator\n\n\n# hanoi\u00a0:: Int -> [(Int, Int)]\ndef hanoi(n):\n    '''A list of index pairs, representing disk moves\n       between indexed Hanoi positions.\n    '''\n    def go(n, a, b, c):\n        p = n - 1\n        return (\n            go(p, a, c, b) + [(a, b)] + go(p, c, b, a)\n        ) if 0 < n else []\n    return go(n, 0, 2, 1)\n\n\n# hanoiState\u00a0:: ([Int],[Int],[Int], String) -> (Int, Int) ->\n#               ([Int],[Int],[Int], String)\ndef hanoiState(tpl, ab):\n    '''A new Hanoi tower state'''\n    a, b = ab\n    xs, ys = tpl[a], tpl[b]\n\n    w = 3 * (2 + (2 * max(map(max, filter(len, tpl[:-1])))))\n\n    def delta(i):\n        return tpl[i] if i not in ab else xs[1:] if (\n            i == a\n        ) else [xs[0]] + ys\n\n    tkns = moveName(('left', 'mid', 'right'))(ab)\n    caption = ' '.join(tkns)\n    return tuple(map(delta, [0, 1, 2])) + (\n        (caption if tkns[0]\u00a0!= 'mid' else caption.rjust(w, ' ')),\n    )\n\n\n# showHanoi\u00a0:: ([Int],[Int],[Int], String) -> String\ndef showHanoi(tpl):\n    '''Captioned string representation of an updated Hanoi tower state.'''\n\n    def fullHeight(n):\n        return lambda xs: list(repeat('', n - len(xs))) + xs\n\n    mul = curry(operator.mul)\n    lt = curry(operator.lt)\n    rods = fmap(fmap(mul('__')))(\n        list(tpl[0:3])\n    )\n    h = max(map(len, rods))\n    w = 2 + max(\n        map(\n            compose(max)(fmap(len)),\n            filter(compose(lt(0))(len), rods)\n        )\n    )\n    xs = fmap(concat)(\n        transpose(fmap(\n            compose(fmap(center(w)(' ')))(\n                fullHeight(h)\n            )\n        )(rods))\n    )\n    return tpl[3] + '\\n\\n' + unlines(xs) + '\\n' + ('___' * w)\n\n\n# moveName\u00a0:: (String, String, String) -> (Int, Int) -> [String]\ndef moveName(labels):\n    '''(from, to) index pair represented as an a -> b string.'''\n    def go(ab):\n        a, b = ab\n        return [labels[a], ' to ', labels[b]] if a < b else [\n            labels[b], ' from ', labels[a]\n        ]\n    return lambda ab: go(ab)\n\n\n# TEST ----------------------------------------------------\ndef main():\n    '''Visualisation of a Hanoi tower sequence for N discs.\n    '''\n    n = 3\n    print('Hanoi sequence for ' + str(n) + ' disks:\\n')\n    print(unlines(\n        fmap(showHanoi)(\n            scanl(hanoiState)(\n                (enumFromTo(1)(n), [], [], '')\n            )(hanoi(n))\n        )\n    ))\n\n\n# GENERIC -------------------------------------------------\n\n# center\u00a0:: Int -> Char -> String -> String\ndef center(n):\n    '''String s padded with c to approximate centre,\n       fitting in but not truncated to width n.'''\n    return lambda c: lambda s: s.center(n, c)\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xs):\n    '''The concatenation of all the elements\n       in a list or iterable.'''\n\n    def f(ys):\n        zs = list(chain(*ys))\n        return ''.join(zs) if isinstance(ys[0], str) else zs\n\n    return (\n        f(xs) if isinstance(xs, list) else (\n            chain.from_iterable(xs)\n        )\n    ) if xs else []\n\n\n# curry\u00a0:: ((a, b) -> c) -> a -> b -> c\ndef curry(f):\n    '''A curried function derived\n       from an uncurried function.'''\n    if 1 < len(signature(f).parameters):\n        return lambda x: lambda y: f(x, y)\n    else:\n        return f\n\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# fmap\u00a0:: (a -> b) -> [a] -> [b]\ndef fmap(f):\n    '''fmap over a list.\n       f lifted to a function over a list.\n    '''\n    return lambda xs: list(map(f, xs))\n\n\n# scanl\u00a0:: (b -> a -> b) -> b -> [a] -> [b]\ndef scanl(f):\n    '''scanl is like reduce, but returns a succession of\n       intermediate values, building from the left.\n    '''\n    return lambda a: lambda xs: (\n        accumulate(chain([a], xs), f)\n    )\n\n\n# showLog\u00a0:: a -> IO String\ndef showLog(*s):\n    '''Arguments printed with\n       intercalated arrows.'''\n    print(\n        ' -> '.join(map(str, s))\n    )\n\n\n# transpose\u00a0:: Matrix a -> Matrix a\ndef transpose(m):\n    '''The rows and columns of the argument transposed.\n       (The matrix containers and rows can be lists or tuples).\n    '''\n    if m:\n        inner = type(m[0])\n        z = zip(*m)\n        return (type(m))(\n            map(inner, z) if tuple\u00a0!= inner else z\n        )\n    else:\n        return m\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.\n    '''\n    return '\\n'.join(xs)\n\n\n# TEST ----------------------------------------------------\nif __name__ == '__main__':\n    main()\nHanoi sequence for 3 disks:\n\n\n   __                   \n  ____                  \n ______                 \n________________________\nleft  to  right\n\n  ____                  \n ______            __   \n________________________\nleft  to  mid\n\n ______   ____     __   \n________________________\n        mid  from  right\n\n           __           \n ______   ____          \n________________________\nleft  to  right\n\n           __           \n          ____   ______ \n________________________\nleft  from  mid\n\n   __     ____   ______ \n________________________\n          mid  to  right\n\n                  ____  \n   __            ______ \n________________________\nleft  to  right\n\n                   __   \n                  ____  \n                 ______ \n________________________\nLibrary: VPython[edit]\n\n", "explain": "\nOr, separating the definition of the data from its display:\nRefactoring the version above to recursively generate a simple visualisation:\nThere is a 3D hanoi-game in the examples that come with VPython,\nand at github.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n\nvoid move(int n, int from, int via, int to)\n{\n  if (n > 1) {\n    move(n - 1, from, to, via);\n    printf(\"Move disk from pole %d to pole %d\\n\", from, to);\n    move(n - 1, via, from, to);\n  } else {\n    printf(\"Move disk from pole %d to pole %d\\n\", from, to);\n  }\n}\nint main()\n{\n  move(4, 1,2,3);\n  return 0;\n}\n\nAnimate it for fun:#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n\ntypedef struct { int *x, n; } tower;\ntower *new_tower(int cap)\n{\n\ttower *t = calloc(1, sizeof(tower) + sizeof(int) * cap);\n\tt->x = (int*)(t + 1);\n\treturn t;\n}\n\ntower *t[3];\nint height;\n\nvoid text(int y, int i, int d, const char *s)\n{\n\tprintf(\"\\033[%d;%dH\", height - y + 1, (height + 1) * (2 * i + 1) - d);\n\twhile (d--) printf(\"%s\", s);\n}\n\nvoid add_disk(int i, int d)\n{\n\tt[i]->x[t[i]->n++] = d;\n\ttext(t[i]->n, i, d, \"==\");\n\n\tusleep(100000);\n\tfflush(stdout);\n}\n\nint remove_disk(int i)\n{\n\tint d = t[i]->x[--t[i]->n];\n\ttext(t[i]->n + 1, i, d, \"  \");\n\treturn d;\n}\n\nvoid move(int n, int from, int to, int via)\n{\n\tif (!n) return;\n\n\tmove(n - 1, from, via, to);\n\tadd_disk(to, remove_disk(from));\n\tmove(n - 1, via, to, from);\n}\n\nint main(int c, char *v[])\n{\n\tputs(\"\\033[H\\033[J\");\n\n\tif (c <= 1 || (height = atoi(v[1])) <= 0)\n\t\theight = 8;\n\tfor (c = 0; c < 3; c++)\t t[c] = new_tower(height);\n\tfor (c = height; c; c--) add_disk(0, c);\n\n\tmove(height, 0, 2, 1);\n\n\ttext(1, 0, 1, \"\\n\");\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\nWorks with: g++\nvoid move(int n, int from, int to, int via) {\n  if (n == 1) {\n    std::cout << \"Move disk from pole \" << from << \" to pole \" << to << std::endl;\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n\nChipmunk Basic[edit]\nWorks with: Chipmunk Basic version 3.6.4\nTranslation of: FreeBASIC\n100 cls\n110 print \"Three disks\" : print\n120 hanoi(3,1,2,3)\n130 print chr$(10)\"Four disks\" chr$(10)\n140 hanoi(4,1,2,3)\n150 print : print \"Towers of Hanoi puzzle completed!\"\n160 end\n170 sub hanoi(n,desde,hasta,via)\n180   if n > 0 then\n190     hanoi(n-1,desde,via,hasta)\n200     print \"Move disk \" n \"from pole \" desde \"to pole \" hasta\n210     hanoi(n-1,via,hasta,desde)\n220   endif\n230 end sub\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\npublic void move(int n, int from, int to, int via) {\n  if (n == 1) {\n    System.out.println(\"Move disk from pole \" + from + \" to pole \" + to);\n  } else {\n    move(n - 1, from, via, to);\n    move(1, from, to, via);\n    move(n - 1, via, to, from);\n  }\n}\n\n\n\nExample use:\nmove(3, 1, 2, 3);\n\n\nOutput:\nMove disk from pole 1 to pole 2\nMove disk from pole 1 to pole 3\nMove disk from pole 2 to pole 3\nMove disk from pole 1 to pole 2\nMove disk from pole 3 to pole 1\nMove disk from pole 3 to pole 2\nMove disk from pole 1 to pole 2\n\n", "explain": "Where n is the number of disks to move and from, to, and via are the poles.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\npublic  void move(int n, int from, int to, int via) {\n   if (n == 1) {\n     System.Console.WriteLine(\"Move disk from pole \" + from + \" to pole \" + to);\n   } else {\n     move(n - 1, from, via, to);\n     move(1, from, to, via);\n     move(n - 1, via, to, from);\n   }\n }\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\nfunction move(n, a, b, c) {\n  if (n > 0) {\n    move(n-1, a, c, b);\n    console.log(\"Move disk from \" + a + \" to \" + c);\n    move(n-1, b, a, c);\n  }\n}\nmove(4, \"A\", \"B\", \"C\");\n\n\n(function () {\n\n    // hanoi\u00a0:: Int -> String -> String -> String -> [[String, String]]\n    function hanoi(n, a, b, c) {\n        return n ? hanoi(n - 1, a, c, b)\n            .concat([\n                [a, b]\n            ])\n            .concat(hanoi(n - 1, c, b, a)) : [];\n    }\n\n    return hanoi(3, 'left', 'right', 'mid')\n        .map(function (d) {\n            return d[0] + ' -> ' + d[1];\n        });\n})();\n\n\nOutput:\n[\"left -> right\", \"left -> mid\",\n \"right -> mid\", \"left -> right\", \n \"mid -> left\", \"mid -> right\", \n \"left -> right\"]\n\nES6[edit]\n(() => {\n    \"use strict\";\n\n    // ----------------- TOWERS OF HANOI -----------------\n\n    // hanoi\u00a0:: Int -> String -> String ->\n    // String -> [[String, String]]\n    const hanoi = n =>\n        (a, b, c) => {\n            const go = hanoi(n - 1);\n\n            return Boolean(n) ? [\n                ...go(a, c, b),\n                ...[\n                    [a, b]\n                ],\n                ...go(c, b, a)\n            ] : [];\n        };\n\n\n    // ---------------------- TEST -----------------------\n    return hanoi(3)(\"left\", \"right\", \"mid\")\n        .map(d => `${d[0]} -> ${d[1]}`)\n        .join(\"\\n\");\n})();\n\n\nOutput:\nleft -> right\nleft -> mid\nright -> mid\nleft -> right\nmid -> left\nmid -> right\nleft -> right\n", "explain": "\nOr, as a functional expression, rather than a statement with side effects:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\nModule TowersOfHanoi\n    Sub MoveTowerDisks(ByVal disks As Integer, ByVal fromTower As Integer, ByVal toTower As Integer, ByVal viaTower As Integer)\n        If disks > 0 Then\n            MoveTowerDisks(disks - 1, fromTower, viaTower, toTower)\n            System.Console.WriteLine(\"Move disk {0} from {1} to {2}\", disks, fromTower, toTower)\n            MoveTowerDisks(disks - 1, viaTower, toTower, fromTower)\n        End If\n    End Sub\n\n    Sub Main()\n        MoveTowerDisks(4, 1, 2, 3)\n    End Sub\nEnd Module\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nTranslation of: Java\nfunction move($n,$from,$to,$via) {\n    if ($n === 1) {\n        print(\"Move disk from pole $from to pole $to\");\n    } else {\n        move($n-1,$from,$via,$to);\n        move(1,$from,$to,$via);\n        move($n-1,$via,$to,$from);\n    }\n}\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\n\nfunction towerOfHanoi(n,A,C,B)\n    if (n~=0)\n        towerOfHanoi(n-1,A,B,C);\n        disp(sprintf('Move plate %d from tower %d to tower %d',[n A C]));\n        towerOfHanoi(n-1,B,C,A);\n    end\nend\n\n\nSample output:\ntowerOfHanoi(3,1,3,2)\nMove plate 1 from tower 1 to tower 3\nMove plate 2 from tower 1 to tower 2\nMove plate 1 from tower 3 to tower 2\nMove plate 3 from tower 1 to tower 3\nMove plate 1 from tower 2 to tower 1\nMove plate 2 from tower 2 to tower 3\nMove plate 1 from tower 1 to tower 3\n", "explain": "This is a direct translation from the Python example given in the Wikipedia entry for the Tower of Hanoi puzzle.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nPROGRAM TOWER\n                             \n  CALL Move(4, 1, 2, 3)\n                \nCONTAINS\n\n  RECURSIVE SUBROUTINE Move(ndisks, from, to, via)\n    INTEGER, INTENT (IN) :: ndisks, from, to, via\n   \n    IF (ndisks == 1) THEN\n       WRITE(*, \"(A,I1,A,I1)\") \"Move disk from pole \", from, \" to pole \", to\n    ELSE\n       CALL Move(ndisks-1, from, via, to)\n       CALL Move(1, from, to, via)\n       CALL Move(ndisks-1, via, to, from)\n    END IF\n  END SUBROUTINE Move\n\nEND PROGRAM TOWER\n\n\nPROGRAM TOWER2\n \n  CALL Move(4, 1, 2, 3)\n \nCONTAINS\n \n  RECURSIVE SUBROUTINE Move(ndisks, from, via, to)\n    INTEGER, INTENT (IN) :: ndisks, from, via, to\n \n    IF (ndisks > 1) THEN\n       CALL Move(ndisks-1, from, to, via)\n       WRITE(*, \"(A,I1,A,I1,A,I1)\") \"Move disk \", ndisks, \"  from pole \", from, \" to pole \", to\n       Call Move(ndisks-1,via,from,to)\n    ELSE\n       WRITE(*, \"(A,I1,A,I1,A,I1)\") \"Move disk \", ndisks, \"  from pole \", from, \" to pole \", to\n    END IF\n  END SUBROUTINE Move\n \nEND PROGRAM TOWER2\n\n", "explain": "Template:More informative version\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\n// a towers of hanoi solver just has one method, play\ntype solver interface {\n    play(int)\n}\n\nfunc main() {\n    var t solver    // declare variable of solver type\n    t = new(towers) // type towers must satisfy solver interface\n    t.play(4)\n}\n\n// towers is example of type satisfying solver interface\ntype towers struct {\n    // an empty struct.  some other solver might fill this with some\n    // data representation, maybe for algorithm validation, or maybe for\n    // visualization.\n}\n\n// play is sole method required to implement solver type\nfunc (t *towers) play(n int) {\n    // drive recursive solution, per task description\n    t.moveN(n, 1, 2, 3)\n}\n\n// recursive algorithm\nfunc (t *towers) moveN(n, from, to, via int) {\n    if n > 0 {\n        t.moveN(n-1, from, via, to)\n        t.move1(from, to)\n        t.moveN(n-1, via, to, from)\n    }\n}\n\n// example function prints actions to screen.\n// enhance with validation or visualization as needed.\nfunc (t *towers) move1(from, to int) {\n    fmt.Println(\"move disk from rod\", from, \"to rod\", to)\n}\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tmove(3, \"A\", \"B\", \"C\")\n}\n\nfunc move(n uint64, a, b, c string) {\n\tif n > 0 {\n\t\tmove(n-1, a, c, b)\n\t\tfmt.Println(\"Move disk from \" + a + \" to \" + c)\n\t\tmove(n-1, b, a, c)\n\t}\n}\n\n", "explain": "In other words:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\n.text\n.global\t_start\n_start:\tmov\tr0,#4\t\t@ 4 disks,\n\tmov\tr1,#1\t\t@ from pole 1,\n\tmov\tr2,#2\t\t@ via pole 2,\n\tmov\tr3,#3\t\t@ to pole 3.\n\tbl\tmove\n\tmov\tr0,#0\t\t@ Exit to Linux afterwards\n\tmov\tr7,#1\n\tswi\t#0\n\t@@@\tMove r0 disks from r1 via r2 to r3\nmove:\tsubs\tr0,r0,#1\t@ One fewer disk in next iteration\n\tbeq\tshow\t\t@ If last disk, just print move\n\tpush\t{r0-r3,lr}\t@ Save all the registers incl. link register\n\teor\tr2,r2,r3\t@ Swap the 'to' and 'via' registers\n\teor\tr3,r2,r3\n\teor\tr2,r2,r3\n\tbl\tmove\t\t@ Recursive call\n\tpop\t{r0-r3}\t\t@ Restore all the registers except LR\n\tbl\tshow\t\t@ Show current move\n\teor\tr1,r1,r3\t@ Swap the 'to' and 'via' registers\n\teor\tr3,r1,r3\n\teor\tr1,r1,r3\n\tpop\t{lr}\t\t@ Restore link register\n\tb\tmove\t\t@ Tail call\n\t@@@\tShow move\nshow:\tpush\t{r0-r3,lr}\t@ Save all the registers\n\tadd\tr1,r1,#'0\t@ Write the source pole\n\tldr\tlr,=spole\n\tstrb\tr1,[lr] \n\tadd\tr3,r3,#'0\t@ Write the destination pole\n\tldr\tlr,=dpole\n\tstrb\tr3,[lr]\n\tmov\tr0,#1\t\t@ 1 = stdout\n\tldr\tr1,=moves\t@ Pointer to string\n\tldr\tr2,=mlen\t@ Length of string\n\tmov\tr7,#4\t\t@ 4 = Linux write syscall\n\tswi\t#0 \t\t@ Print the move\n\tpop\t{r0-r3,pc}\t@ Restore all the registers and return\n.data\nmoves:\t.ascii\t\"Move disk from pole \"\nspole:\t.ascii\t\"* to pole \"\ndpole:\t.ascii\t\"*\\n\"\nmlen\t=\t. - moves\n\n\nOutput:\nMove disk from pole 1 to pole 2\nMove disk from pole 1 to pole 3\nMove disk from pole 3 to pole 1\nMove disk from pole 1 to pole 2\nMove disk from pole 2 to pole 3\nMove disk from pole 2 to pole 1\nMove disk from pole 1 to pole 2\nMove disk from pole 1 to pole 3\nMove disk from pole 3 to pole 1\nMove disk from pole 3 to pole 2\nMove disk from pole 2 to pole 3\nMove disk from pole 3 to pole 1\nMove disk from pole 1 to pole 2\nMove disk from pole 1 to pole 3\nMove disk from pole 3 to pole 1\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "MIPS_Assembly", "code": "\n# Towers of Hanoi\n# MIPS assembly implementation (tested with MARS)\n# Source: https://stackoverflow.com/questions/50382420/hanoi-towers-recursive-solution-using-mips/50383530#50383530\n\n.data\nprompt: .asciiz \"Enter a number: \"\npart1: .asciiz \"\\nMove disk \"\npart2: .asciiz \" from rod \"\npart3: .asciiz \" to rod \"\n\n.text\n.globl main\nmain:\n    li $v0,  4          # print string\n    la $a0,  prompt\n    syscall\n    li $v0,  5          # read integer\n    syscall\n\n    # parameters for the routine\n    add $a0, $v0, $zero # move to $a0\n    li $a1, 'A'\n    li $a2, 'B'\n    li $a3, 'C'\n\n    jal hanoi           # call hanoi routine\n\n    li $v0, 10          # exit\n    syscall\n\nhanoi:\n\n    #save in stack\n    addi $sp, $sp, -20 \n    sw   $ra, 0($sp)\n    sw   $s0, 4($sp)\n    sw   $s1, 8($sp)\n    sw   $s2, 12($sp)\n    sw   $s3, 16($sp)\n\n    add $s0, $a0, $zero\n    add $s1, $a1, $zero\n    add $s2, $a2, $zero\n    add $s3, $a3, $zero\n\n    addi $t1, $zero, 1\n    beq $s0, $t1, output\n\n    recur1:\n\n        addi $a0, $s0, -1\n        add $a1, $s1, $zero\n        add $a2, $s3, $zero\n        add $a3, $s2, $zero\n        jal hanoi\n\n        j output\n\n    recur2:\n\n        addi $a0, $s0, -1\n        add $a1, $s3, $zero\n        add $a2, $s2, $zero\n        add $a3, $s1, $zero\n        jal hanoi\n\n    exithanoi:\n\n        lw   $ra, 0($sp)        # restore registers from stack\n        lw   $s0, 4($sp)\n        lw   $s1, 8($sp)\n        lw   $s2, 12($sp)\n        lw   $s3, 16($sp)\n\n        addi $sp, $sp, 20       # restore stack pointer\n\n        jr $ra\n\n    output:\n\n        li $v0,  4              # print string\n        la $a0,  part1\n        syscall\n        li $v0,  1              # print integer\n        add $a0, $s0, $zero\n        syscall\n        li $v0,  4              # print string\n        la $a0,  part2\n        syscall\n        li $v0,  11             # print character\n        add $a0, $s1, $zero\n        syscall\n        li $v0,  4              # print string\n        la $a0,  part3\n        syscall\n        li $v0,  11             # print character\n        add $a0, $s2, $zero\n        syscall\n\n        beq $s0, $t1, exithanoi\n        j recur2\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nversion 1[edit]\ndef move(num_disks, start=0, target=1, using=2)\n  if num_disks == 1\n   @towers[target] << @towers[start].pop\n    puts \"Move disk from #{start} to #{target}\u00a0: #{@towers}\"\n  else\n    move(num_disks-1, start, using, target)\n    move(1,           start, target, using)\n    move(num_disks-1, using, target, start)\n  end \nend\n\nn = 5\n@towers = [[*1..n].reverse, [], []]\nmove(n)\n\nOutput:\nMove disk from 0 to 1\u00a0: [[5, 4, 3, 2], [1], []]\nMove disk from 0 to 2\u00a0: [[5, 4, 3], [1], [2]]\nMove disk from 1 to 2\u00a0: [[5, 4, 3], [], [2, 1]]\nMove disk from 0 to 1\u00a0: [[5, 4], [3], [2, 1]]\nMove disk from 2 to 0\u00a0: [[5, 4, 1], [3], [2]]\nMove disk from 2 to 1\u00a0: [[5, 4, 1], [3, 2], []]\nMove disk from 0 to 1\u00a0: [[5, 4], [3, 2, 1], []]\nMove disk from 0 to 2\u00a0: [[5], [3, 2, 1], [4]]\nMove disk from 1 to 2\u00a0: [[5], [3, 2], [4, 1]]\nMove disk from 1 to 0\u00a0: [[5, 2], [3], [4, 1]]\nMove disk from 2 to 0\u00a0: [[5, 2, 1], [3], [4]]\nMove disk from 1 to 2\u00a0: [[5, 2, 1], [], [4, 3]]\nMove disk from 0 to 1\u00a0: [[5, 2], [1], [4, 3]]\nMove disk from 0 to 2\u00a0: [[5], [1], [4, 3, 2]]\nMove disk from 1 to 2\u00a0: [[5], [], [4, 3, 2, 1]]\nMove disk from 0 to 1\u00a0: [[], [5], [4, 3, 2, 1]]\nMove disk from 2 to 0\u00a0: [[1], [5], [4, 3, 2]]\nMove disk from 2 to 1\u00a0: [[1], [5, 2], [4, 3]]\nMove disk from 0 to 1\u00a0: [[], [5, 2, 1], [4, 3]]\nMove disk from 2 to 0\u00a0: [[3], [5, 2, 1], [4]]\nMove disk from 1 to 2\u00a0: [[3], [5, 2], [4, 1]]\nMove disk from 1 to 0\u00a0: [[3, 2], [5], [4, 1]]\nMove disk from 2 to 0\u00a0: [[3, 2, 1], [5], [4]]\nMove disk from 2 to 1\u00a0: [[3, 2, 1], [5, 4], []]\nMove disk from 0 to 1\u00a0: [[3, 2], [5, 4, 1], []]\nMove disk from 0 to 2\u00a0: [[3], [5, 4, 1], [2]]\nMove disk from 1 to 2\u00a0: [[3], [5, 4], [2, 1]]\nMove disk from 0 to 1\u00a0: [[], [5, 4, 3], [2, 1]]\nMove disk from 2 to 0\u00a0: [[1], [5, 4, 3], [2]]\nMove disk from 2 to 1\u00a0: [[1], [5, 4, 3, 2], []]\nMove disk from 0 to 1\u00a0: [[], [5, 4, 3, 2, 1], []]\n\nversion 2[edit]\n# solve(source, via, target)\n# Example:\n# solve([5, 4, 3, 2, 1], [], [])\n# Note this will also solve randomly placed disks,\n# \"place all disk in target with legal moves only\".\ndef solve(*towers)\n  # total number of disks\n  disks = towers.inject(0){|sum, tower| sum+tower.length}\n  x=0 # sequence number\n  p towers # initial trace\n  # have we solved the puzzle yet?\n  while towers.last.length < disks do\n    x+=1 # assume the next step\n    from = (x&x-1)%3\n    to = ((x|(x-1))+1)%3\n    # can we actually take from tower?\n    if top = towers[from].last\n      bottom = towers[to].last\n      # is the move legal?\n      if !bottom || bottom > top\n        # ok, do it!\n        towers[to].push(towers[from].pop)\n        p towers # trace\n      end\n    end\n  end\nend\n\nsolve([5, 4, 3, 2, 1], [], [])\n\nOutput:\n[[5, 4, 3, 2, 1], [], []]\n[[5, 4, 3, 2], [], [1]]\n[[5, 4, 3], [2], [1]]\n[[5, 4, 3], [2, 1], []]\n[[5, 4], [2, 1], [3]]\n[[5, 4, 1], [2], [3]]\n[[5, 4, 1], [], [3, 2]]\n[[5, 4], [], [3, 2, 1]]\n[[5], [4], [3, 2, 1]]\n[[5], [4, 1], [3, 2]]\n[[5, 2], [4, 1], [3]]\n[[5, 2, 1], [4], [3]]\n[[5, 2, 1], [4, 3], []]\n[[5, 2], [4, 3], [1]]\n[[5], [4, 3, 2], [1]]\n[[5], [4, 3, 2, 1], []]\n[[], [4, 3, 2, 1], [5]]\n[[1], [4, 3, 2], [5]]\n[[1], [4, 3], [5, 2]]\n[[], [4, 3], [5, 2, 1]]\n[[3], [4], [5, 2, 1]]\n[[3], [4, 1], [5, 2]]\n[[3, 2], [4, 1], [5]]\n[[3, 2, 1], [4], [5]]\n[[3, 2, 1], [], [5, 4]]\n[[3, 2], [], [5, 4, 1]]\n[[3], [2], [5, 4, 1]]\n[[3], [2, 1], [5, 4]]\n[[], [2, 1], [5, 4, 3]]\n[[1], [2], [5, 4, 3]]\n[[1], [], [5, 4, 3, 2]]\n[[], [], [5, 4, 3, 2, 1]]\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nTranslation of: C\nfn move_(n: i32, from: i32, to: i32, via: i32) {\n    if n > 0 {\n        move_(n - 1, from, via, to);\n        println!(\"Move disk from pole {} to pole {}\", from, to);\n        move_(n - 1, via, to, from);\n    }\n}\n\nfn main() {\n    move_(4, 1,2,3);\n}\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nTranslation of: JavaScript\nfunc hanoi(n:Int, a:String, b:String, c:String) {\n    if (n > 0) {\n        hanoi(n - 1, a, c, b)\n        println(\"Move disk from \\(a) to \\(c)\")\n        hanoi(n - 1, b, a, c)\n    }\n}\n\nhanoi(4, \"A\", \"B\", \"C\")\n\nfunc hanoi(n:Int, a:String, b:String, c:String) {\n  if (n > 0) {\n    hanoi(n - 1, a: a, b: c, c: b)\n    print(\"Move disk from \\(a) to \\(c)\")\n    hanoi(n - 1, a: b, b: a, c: c)\n  }\n}\n \nhanoi(4, a:\"A\", b:\"B\", c:\"C\")\n", "explain": "Swift 2.1\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nTranslation of: Octave\nhanoimove <- function(ndisks, from, to, via) {\n  if (ndisks == 1) {\n    cat(\"move disk from\", from, \"to\", to, \"\\n\")\n  } else {\n    hanoimove(ndisks - 1, from, via, to)\n    hanoimove(1, from, to, via)\n    hanoimove(ndisks - 1, via, to, from)\n  }\n}\n\nhanoimove(4, 1, 2, 3)\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\nTranslation of: C\nWorks with: OpenCOBOL version 2.0\n       >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. towers-of-hanoi.\n\nPROCEDURE DIVISION.\n    CALL \"move-disk\" USING 4, 1, 2, 3\n    .\nEND PROGRAM towers-of-hanoi.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. move-disk RECURSIVE.\n\nDATA DIVISION.\nLINKAGE SECTION.\n01  n                         PIC 9 USAGE COMP.\n01  from-pole                 PIC 9 USAGE COMP.\n01  to-pole                   PIC 9 USAGE COMP.\n01  via-pole                  PIC 9 USAGE COMP.\n\nPROCEDURE DIVISION USING n, from-pole, to-pole, via-pole.\n    IF n > 0\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, from-pole, via-pole, to-pole\n       DISPLAY \"Move disk from pole \" from-pole \" to pole \" to-pole\n       CALL \"move-disk\" USING CONTENT n, via-pole, to-pole, from-pole\n    END-IF\n    .\nEND PROGRAM move-disk.\n\n\n \nIDENTIFICATION DIVISION.\nPROGRAM-ID. towers-of-hanoi.\n \nPROCEDURE DIVISION.\n    CALL \"move-disk\" USING 4, 1, 2, 3\n    .\nEND PROGRAM towers-of-hanoi.\n \nIDENTIFICATION DIVISION.\nPROGRAM-ID. move-disk RECURSIVE.\n \nDATA DIVISION.\nLINKAGE SECTION.\n01  n                         PIC 9 USAGE COMP.\n01  from-pole                 PIC 9 USAGE COMP.\n01  to-pole                   PIC 9 USAGE COMP.\n01  via-pole                  PIC 9 USAGE COMP.\n \nPROCEDURE DIVISION USING n, from-pole, to-pole, via-pole.\n    IF n > 0\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, from-pole, via-pole, to-pole\n       ADD 1 TO n\n       DISPLAY \"Move disk number \"n \" from pole \" from-pole \" to pole \" to-pole\n       SUBTRACT 1 FROM n\n       CALL \"move-disk\" USING CONTENT n, via-pole, to-pole, from-pole\n    END-IF\n    .\nEND PROGRAM move-disk.\n\nANSI-74 solution[edit]\n\nWorks with: CIS COBOL version 4.2Works with: GnuCOBOL version 3.0-rc1.0\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ITERATIVE-TOWERS-OF-HANOI.\n       AUTHOR. SOREN ROUG.\n       DATE-WRITTEN. 2019-06-28.\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       SOURCE-COMPUTER. LINUX.\n       OBJECT-COMPUTER. KAYPRO4.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       77  NUM-DISKS                   PIC 9 VALUE 4.\n       77  N1                          PIC 9 COMP.\n       77  N2                          PIC 9 COMP.\n       77  FROM-POLE                   PIC 9 COMP.\n       77  TO-POLE                     PIC 9 COMP.\n       77  VIA-POLE                    PIC 9 COMP.\n       77  FP-TMP                      PIC 9 COMP.\n       77  TO-TMP                      PIC 9 COMP.\n       77  P-TMP                       PIC 9 COMP.\n       77  TMP-P                       PIC 9 COMP.\n       77  I                           PIC 9 COMP.\n       77  DIV                         PIC 9 COMP.\n       01  STACKNUMS.\n           05  NUMSET OCCURS 3 TIMES.\n               10  DNUM                PIC 9 COMP.\n       01  GAMESET.\n           05  POLES OCCURS 3 TIMES.\n               10  STACK OCCURS 10 TIMES.\n                   15  POLE            PIC 9 USAGE COMP.\n\n       PROCEDURE DIVISION.\n       HANOI.\n           DISPLAY \"TOWERS OF HANOI PUZZLE WITH \", NUM-DISKS, \" DISKS.\".\n           ADD NUM-DISKS, 1 GIVING N1.\n           ADD NUM-DISKS, 2 GIVING N2.\n           MOVE 1 TO DNUM (1).\n           MOVE N1 TO DNUM (2), DNUM (3).\n           MOVE N1 TO POLE (1, N1), POLE (2, N1), POLE (3, N1).\n           MOVE 1 TO POLE (1, N2).\n           MOVE 2 TO POLE (2, N2).\n           MOVE 3 TO POLE (3, N2).\n           MOVE 1 TO I.\n           PERFORM INIT-PUZZLE UNTIL I = N1.\n           MOVE 1 TO FROM-POLE.\n           DIVIDE 2 INTO NUM-DISKS GIVING DIV.\n           MULTIPLY 2 BY DIV.\n           IF DIV NOT = NUM-DISKS PERFORM INITODD ELSE PERFORM INITEVEN.\n           PERFORM MOVE-DISK UNTIL DNUM (3) NOT > 1.\n           DISPLAY \"TOWERS OF HANOI PUZZLE COMPLETED!\".\n           STOP RUN.\n       INIT-PUZZLE.\n           MOVE I TO POLE (1, I).\n           MOVE 0 TO POLE (2, I), POLE (3, I).\n           ADD 1 TO I.\n       INITEVEN.\n           MOVE 2 TO TO-POLE.\n           MOVE 3 TO VIA-POLE.\n       INITODD.\n           MOVE 3 TO TO-POLE.\n           MOVE 2 TO VIA-POLE.\n       MOVE-DISK.\n           MOVE DNUM (FROM-POLE) TO FP-TMP.\n           MOVE POLE (FROM-POLE, FP-TMP) TO I.\n           DISPLAY \"MOVE DISK FROM \", POLE (FROM-POLE, N2),\n               \" TO \", POLE (TO-POLE, N2).\n           ADD 1 TO DNUM (FROM-POLE).\n           MOVE VIA-POLE TO TMP-P.\n           SUBTRACT 1 FROM DNUM (TO-POLE).\n           MOVE DNUM (TO-POLE) TO TO-TMP.\n           MOVE I TO POLE (TO-POLE, TO-TMP).\n           DIVIDE 2 INTO I GIVING DIV.\n           MULTIPLY 2 BY DIV.\n           IF I NOT = DIV PERFORM MOVE-TO-VIA ELSE\n               PERFORM MOVE-FROM-VIA.\n       MOVE-TO-VIA.\n           MOVE TO-POLE TO VIA-POLE.\n           MOVE DNUM (FROM-POLE) TO FP-TMP.\n           MOVE DNUM (TMP-P) TO P-TMP.\n           IF POLE (FROM-POLE, FP-TMP) > POLE (TMP-P, P-TMP)\n               PERFORM MOVE-FROM-TO\n           ELSE MOVE TMP-P TO TO-POLE.\n       MOVE-FROM-TO.\n           MOVE FROM-POLE TO TO-POLE.\n           MOVE TMP-P TO FROM-POLE.\n           MOVE DNUM (FROM-POLE) TO FP-TMP.\n           MOVE DNUM (TMP-P) TO P-TMP.\n       MOVE-FROM-VIA.\n           MOVE FROM-POLE TO VIA-POLE.\n           MOVE TMP-P TO FROM-POLE.\n\n", "explain": "Template:Number of disks also\nEarly versions of COBOL did not have recursion. There are no locally-scoped variables and the call of a procedure does not have to use a stack to save return state. Recursion would cause undefined results. It is therefore necessary to use an iterative algorithm. This solution is an adaptation of Kolar's Hanoi Tower algorithm no. 1.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Towers is\n   type Pegs is (Left, Center, Right);\n   procedure Hanoi (Ndisks : Natural; Start_Peg : Pegs := Left; End_Peg : Pegs := Right; Via_Peg : Pegs := Center) is\n   begin\n      if Ndisks > 0 then\n         Hanoi(Ndisks - 1, Start_Peg, Via_Peg, End_Peg);\n         Put_Line(\"Move disk\" & Natural'Image(Ndisks) & \" from \" & Pegs'Image(Start_Peg) & \" to \" & Pegs'Image(End_Peg));\n         Hanoi(Ndisks - 1, Via_Peg, End_Peg, Start_Peg);\n      end if;\n   end Hanoi;\nbegin\n   Hanoi(4);\nend Towers;\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nTranslation of: R\nfunction solve(n::Integer, from::Integer, to::Integer, via::Integer)\n  if n == 1\n    println(\"Move disk from $from to $to\")\n  else\n    solve(n - 1, from, via, to)\n    solve(1, from, to, via)\n    solve(n - 1, via, to, from)\n  end\nend\n\nsolve(4, 1, 2, 3)\n\n\nOutput:\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\nMove disk from 1 to 3\nMove disk from 2 to 1\nMove disk from 2 to 3\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\nMove disk from 3 to 1\nMove disk from 2 to 1\nMove disk from 3 to 2\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.1.0\n\nclass Hanoi(disks: Int) {\n    private var moves = 0\n\n    init {\n        println(\"Towers of Hanoi with $disks disks:\\n\")\n        move(disks, 'L', 'C', 'R')\n        println(\"\\nCompleted in $moves moves\\n\")\n    }\n\n    private fun move(n: Int, from: Char, to: Char, via: Char) {\n        if (n > 0) {\n            move(n - 1, from, via, to)\n            moves++\n            println(\"Move disk $n from $from to $to\")\n            move(n - 1, via, to, from)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    Hanoi(3)\n    Hanoi(4)\n}\n\n\nOutput:\nTowers of Hanoi with 3 disks:\n\nMove disk 1 from L to C\nMove disk 2 from L to R\nMove disk 1 from C to R\nMove disk 3 from L to C\nMove disk 1 from R to L\nMove disk 2 from R to C\nMove disk 1 from L to C\n\nCompleted in 7 moves\n\nTowers of Hanoi with 4 disks:\n\nMove disk 1 from L to R\nMove disk 2 from L to C\nMove disk 1 from R to C\nMove disk 3 from L to R\nMove disk 1 from C to L\nMove disk 2 from C to R\nMove disk 1 from L to R\nMove disk 4 from L to C\nMove disk 1 from R to C\nMove disk 2 from R to L\nMove disk 1 from C to L\nMove disk 3 from R to C\nMove disk 1 from L to R\nMove disk 2 from L to C\nMove disk 1 from R to C\n\nCompleted in 15 moves\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nsub hanoi {\n    my ($n, $from, $to, $via) = (@_, 1, 2, 3);\n\n    if ($n == 1) {\n        print \"Move disk from pole $from to pole $to.\\n\";\n    } else {\n        hanoi($n - 1, $from, $via, $to);\n        hanoi(1, $from, $to, $via);\n        hanoi($n - 1, $via, $to, $from);\n    };\n};\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n\nWorks with: GNUstep\n\n#import <Foundation/NSObject.h>\n\n@interface TowersOfHanoi: NSObject {\n\tint pegFrom;\n\tint pegTo;\n\tint pegVia;\n\tint numDisks;\n}\n\n-(void) setPegFrom: (int) from andSetPegTo: (int) to andSetPegVia: (int) via andSetNumDisks: (int) disks;\n-(void) movePegFrom: (int) from andMovePegTo: (int) to andMovePegVia: (int) via andWithNumDisks: (int) disks;\n@end\n\n#import \"TowersOfHanoi.h\"\n@implementation TowersOfHanoi\n\n-(void) setPegFrom: (int) from andSetPegTo: (int) to andSetPegVia: (int) via andSetNumDisks: (int) disks {\n\tpegFrom = from;\n\tpegTo = to;\n\tpegVia = via;\n\tnumDisks = disks;\n}\n\n-(void) movePegFrom: (int) from andMovePegTo: (int) to andMovePegVia: (int) via andWithNumDisks: (int) disks {\n\tif (disks == 1) {\n            printf(\"Move disk from pole %i to pole %i\\n\", from, to);\n        } else {\n \t\t\t[self movePegFrom: from andMovePegTo: via andMovePegVia: to andWithNumDisks: disks-1];\n\t\t\t[self movePegFrom: from andMovePegTo: to andMovePegVia: via andWithNumDisks: 1];\n\t\t\t[self movePegFrom: via andMovePegTo: to andMovePegVia: from andWithNumDisks: disks-1];\n        }\n}\n\n@end\n\n#import <stdio.h>\n#import \"TowersOfHanoi.h\"\n\nint main( int argc, const char *argv[] ) {\n\t@autoreleasepool {\n\n\t\tTowersOfHanoi *tower = [[TowersOfHanoi alloc] init];\n\n\t\tint from = 1;\n\t\tint to = 3;\n\t\tint via = 2;\n\t\tint disks = 3;\n\n\t\t[tower setPegFrom: from andSetPegTo: to andSetPegVia: via andSetNumDisks: disks];\n\n\t\t[tower movePegFrom: from andMovePegTo: to andMovePegVia: via andWithNumDisks: disks];\n\n\t}\n\treturn 0;\n}\n", "explain": "From here\nIt should be compatible with XCode/Cocoa on MacOS too.\nThe Interface - TowersOfHanoi.h:\nThe Implementation - TowersOfHanoi.m:\nTest code: TowersTest.m:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\nhanoi(N)\u00a0:- move(N,left,center,right).\n\nmove(0,_,_,_)\u00a0:-\u00a0!.\nmove(N,A,B,C)\u00a0:-\n    M is N-1,\n    move(M,A,C,B),\n    inform(A,B),\n    move(M,C,B,A).\n\ninform(X,Y)\u00a0:- write([move,a,disk,from,the,X,pole,to,Y,pole]), nl.\n\nhanoi(N, Src, Aux, Dest, Moves-NMoves)\u00a0:-\n  NMoves is 2^N - 1,\n  length(Moves, NMoves),\n  phrase(move(N, Src, Aux, Dest), Moves).\n\n\nmove(1, Src, _, Dest) -->\u00a0!,\n  [Src->Dest].\n\nmove(2, Src, Aux, Dest) -->\u00a0!,\n  [Src->Aux,Src->Dest,Aux->Dest].\n\nmove(N, Src, Aux, Dest) -->\n  { succ(N0, N) },\n  move(N0, Src, Dest, Aux),\n  move(1, Src, Aux, Dest),\n  move(N0, Aux, Src, Dest).\n", "explain": "From Programming in Prolog by W.F. Clocksin & C.S. Mellish\nUsing DCGs and separating core logic from IO\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction move(n, src, dst, via)\n    if n > 0 then\n        move(n - 1, src, via, dst)\n        print(src, 'to', dst)\n        move(n - 1, via, dst, src)\n    end\nend\n\nmove(4, 1, 2, 3)\n\n\nfunction move(n, src, via, dst)\n    if n > 0 then\n        move(n - 1, src, dst, via)\n        print('Disk ',n,' from ' ,src, 'to', dst)\n        move(n - 1, via, src, dst)\n        \n    end\nend\n \nmove(4, 1, 2, 3)\n\nHanoi Iterative[edit]\n#!/usr/bin/env luajit\nlocal function printf(fmt, ...) io.write(string.format(fmt, ...)) end\nlocal runs=0\nlocal function move(tower, from, to)\n\tif #tower[from]==0 \n\t\tor (#tower[to]>0 \n\t\tand tower[from][#tower[from]]>tower[to][#tower[to]]) then\n\t\t\tto,from=from,to\n\tend\n\tif #tower[from]>0 then\n\t\ttower[to][#tower[to]+1]=tower[from][#tower[from]]\n\t\ttower[from][#tower[from]]=nil\n\n\t\tio.write(tower[to][#tower[to]],\":\",from, \"\u2192\", to, \" \")\n\tend\nend\n\nlocal function hanoi(n)\n\tlocal src,dst,via={},{},{}\n\tlocal tower={src,dst,via}\n\tfor i=1,n do src[i]=n-i+1 end\n\tlocal one,nxt,lst\n\tif n%2==1 then -- odd\n\t\tone,nxt,lst=1,2,3\n\telse\n\t\tone,nxt,lst=1,3,2\n\tend\n\t--repeat\n\t::loop::\n\t\tmove(tower, one, nxt)\n\t\tif #dst==n then return end\n\t\tmove(tower, one, lst)\n\t\tone,nxt,lst=nxt,lst,one\n\tgoto loop\n\t--until false\nend\n\nlocal num=arg[1] and tonumber(arg[1]) or 4\n\nhanoi(num)\n\n\nOutput:\n> ./hanoi_iter.lua 5\n1:1\u21922 2:1\u21923 1:2\u21923 3:1\u21922 1:3\u21921 2:3\u21922 1:1\u21922 4:1\u21923 1:2\u21923 2:2\u21921 1:3\u21921 3:2\u21923 1:1\u21922 2:1\u21923 1:2\u21923 5:1\u21922 1:3\u21921 2:3\u21922 1:1\u21922 3:3\u21921 1:2\u21923 2:2\u21921 1:3\u21921 4:3\u21922 1:1\u21922 2:1\u21923 1:2\u21923 3:1\u21922 1:3\u21921 2:3\u21922 1:1\u21922\n\nHanoi Bitwise Fast[edit]\n#!/usr/bin/env luajit\n-- binary solution\nlocal bit=require\"bit\"\nlocal band,bor=bit.band,bit.bor\nlocal function hanoi(n)\n\tlocal even=(n-1)%2\n\tfor m=1,2^n-1 do\n\t\tio.write(m,\":\",band(m,m-1)%3+1, \"\u2192\", (bor(m,m-1)+1)%3+1, \" \")\n\tend\nend\n\nlocal num=arg[1] and tonumber(arg[1]) or 4\n\nhanoi(num)\n\n\nOutput:\n> ./hanoi_bit.lua 4\n1:1\u21923 2:1\u21922 3:3\u21922 4:1\u21923 5:2\u21921 6:2\u21923 7:1\u21923 8:1\u21922 9:3\u21922 10:3\u21921 11:2\u21921 12:3\u21922 13:1\u21923 14:1\u21922 15:3\u21922 \n> time ./hanoi_bit.lua 30 >/dev/null \u00a0; on AMD FX-8350 @ 4 GHz\n./hanoi_bit.lua 30 > /dev/null  297,40s user 1,39s system 99% cpu 4:59,01 total\n\n", "explain": "Template:More informative version\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef move(n: Int, from: Int, to: Int, via: Int)\u00a0: Unit = {\n    if (n == 1) {\n      Console.println(\"Move disk from pole \" + from + \" to pole \" + to)\n    } else {\n      move(n - 1, from, via, to)\n      move(1, from, to, via)\n      move(n - 1, via, to, from)\n    }\n  }\n\nobject TowersOfHanoi {\n  import scala.reflect.Manifest\n  \n  def simpleName(m:Manifest[_]):String = {\n    val name = m.toString\n    name.substring(name.lastIndexOf('$')+1)\n  }\n  \n  trait Nat\n  final class _0 extends Nat\n  final class Succ[Pre<:Nat] extends Nat\n \n  type _1 = Succ[_0]\n  type _2 = Succ[_1]\n  type _3 = Succ[_2]\n  type _4 = Succ[_3]\n \n  case class Move[N<:Nat,A,B,C]()\n \n  implicit def move0[A,B,C](implicit a:Manifest[A],b:Manifest[B]):Move[_0,A,B,C] = {\n        System.out.println(\"Move from \"+simpleName(a)+\" to \"+simpleName(b));null\n  }\n \n  implicit def moveN[P<:Nat,A,B,C](implicit m1:Move[P,A,C,B],m2:Move[_0,A,B,C],m3:Move[P,C,B,A])\n   :Move[Succ[P],A,B,C] = null\n  \n  def run[N<:Nat,A,B,C](implicit m:Move[N,A,B,C]) = null\n  \n  case class Left()\n  case class Center()\n  case class Right()\n  \n  def main(args:Array[String]){\n    run[_2,Left,Right,Center]\n  }\n}\n", "explain": "This next example is from http://gist.github.com/66925 it is a translation to Scala of a Prolog solution and solves the problem at compile time\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nmain() { \n  moveit(from,to) {\n    print(\"move ${from} ---> ${to}\");\n  }\n\n  hanoi(height,toPole,fromPole,usePole) {\n    if (height>0) {\n      hanoi(height-1,usePole,fromPole,toPole);  \n      moveit(fromPole,toPole);\n      hanoi(height-1,toPole,usePole,fromPole);\n    }\n  }\n\n  hanoi(3,3,1,2);\n}\n\n\nmain() {\n  String say(String from, String to) => \"$from ---> $to\"; \n\n  hanoi(int height, int toPole, int fromPole, int usePole) {\n    if (height > 0) {\n      hanoi(height - 1, usePole, fromPole, toPole);  \n      print(say(fromPole.toString(), toPole.toString()));\n      hanoi(height - 1, toPole, usePole, fromPole);\n    }\n  }\n\n  hanoi(3, 3, 1, 2);\n}\n\n\nOutput:\nmove 1 ---> 3\nmove 1 ---> 2\nmove 3 ---> 2\nmove 1 ---> 3\nmove 2 ---> 1\nmove 2 ---> 3\nmove 1 ---> 3\n\n", "explain": "The same as above, with optional static type annotations and styled according to http://www.dartlang.org/articles/style-guide/\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nRecursive Version[edit]\nimport std.stdio;\n\nvoid hanoi(in int n, in char from, in char to, in char via) {\n    if (n > 0) {\n        hanoi(n - 1, from, via, to);\n        writefln(\"Move disk %d from %s to %s\", n, from, to);\n        hanoi(n - 1, via, to, from);\n    }\n}\n\nvoid main() {\n    hanoi(3, 'L', 'M', 'R');\n}\n\n\nOutput:\nMove disk 1 from L to M\nMove disk 2 from L to R\nMove disk 1 from M to R\nMove disk 3 from L to M\nMove disk 1 from R to L\nMove disk 2 from R to M\nMove disk 1 from L to M\nFast Iterative Version[edit]\n\n// Code found and then improved by Glenn C. Rhoads,\n// then some more by M. Kolar (2000).\nvoid main(in string[] args) {\n    import core.stdc.stdio, std.conv, std.typetuple;\n\n    immutable size_t n = (args.length > 1) ? args[1].to!size_t : 3;\n    size_t[3] p = [(1 << n) - 1, 0, 0];\n\n    // Show the start configuration of the pegs.\n    '|'.putchar;\n    foreach_reverse (immutable i; 1 .. n + 1)\n        printf(\" %d\", i);\n    \"\\n|\\n|\".puts;\n\n    foreach (immutable size_t x; 1 .. (1 << n)) {\n        {\n            immutable size_t i1 = x & (x - 1);\n            immutable size_t fr = (i1 + i1 / 3) & 3;\n            immutable size_t i2 = (x | (x - 1)) + 1;\n            immutable size_t to = (i2 + i2 / 3) & 3;\n\n            size_t j = 1;\n            for (size_t w = x; !(w & 1); w >>= 1, j <<= 1) {}\n\n            // Now j is not the number of the disk to move,\n            // it contains the single bit to be moved:\n            p[fr] &= ~j;\n            p[to] |= j;\n        }\n\n        // Show the current configuration of pegs.\n        foreach (immutable size_t k; TypeTuple!(0, 1, 2)) {\n            \"\\n|\".printf;\n            size_t j = 1 << n;\n            foreach_reverse (immutable size_t w; 1 .. n + 1) {\n                j >>= 1;\n                if (j & p[k])\n                    printf(\" %zd\", w);\n            }\n        }\n        '\\n'.putchar;\n    }\n}\n\n\nOutput:\n| 3 2 1\n|\n|\n\n| 3 2\n|\n| 1\n\n| 3\n| 2\n| 1\n\n| 3\n| 2 1\n|\n\n|\n| 2 1\n| 3\n\n| 1\n| 2\n| 3\n\n| 1\n|\n| 3 2\n\n|\n|\n| 3 2 1\n\n", "explain": "See: The shortest and \"mysterious\" TH algorithm\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nhanoi :: Integer -> a -> a -> a -> [(a, a)]\nhanoi 0 _ _ _ = []\nhanoi n a b c = hanoi (n-1) a c b ++ [(a,b)] ++ hanoi (n-1) c b a\n\n\nhanoi :: Integer -> a -> a -> a -> [(a, a)]\n\nhanoi n a b c = hanoiToList n a b c []\n  where\n    hanoiToList 0 _ _ _ l = l\n    hanoiToList n a b c l = hanoiToList (n-1) a c b ((a, b) : hanoiToList (n-1) c b a l)\n\n\nhanoiIO n = mapM_ f $ hanoi n 1 2 3 where\n  f (x,y) = putStrLn $ \"Move \" ++ show x ++ \" to \" ++ show y\n\n\nhanoiM :: Integer -> IO ()\nhanoiM n = hanoiM' n 1 2 3 where\n  hanoiM' 0 _ _ _ = return ()\n  hanoiM' n a b c = do\n    hanoiM' (n-1) a c b\n    putStrLn $ \"Move \" ++ show a ++ \" to \" ++ show b\n    hanoiM' (n-1) c b a\n\n\n-------------------------- HANOI -------------------------\n\nhanoi ::\n  Int ->\n  String ->\n  String ->\n  String ->\n  [(String, String)]\nhanoi 0 _ _ _ = mempty\nhanoi n l r m =\n  hanoi (n - 1) l m r\n    <> [(l, r)]\n    <> hanoi (n - 1) m r l\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = putStrLn $ showHanoi 5\n\n------------------------- DISPLAY ------------------------\nshowHanoi :: Int -> String\nshowHanoi n =\n  unlines $\n    fmap\n      ( \\(from, to) ->\n          concat [justifyRight 5 ' ' from, \" -> \", to]\n      )\n      (hanoi n \"left\" \"right\" \"mid\")\n\njustifyRight :: Int -> Char -> String -> String\njustifyRight n c = (drop . length) <*> (replicate n c <>)\n\n\nOutput:\n left -> right\n left -> mid\nright -> mid\n left -> right\n  mid -> left\n  mid -> right\n left -> right\n left -> mid\nright -> mid\nright -> left\n  mid -> left\nright -> mid\n left -> right\n left -> mid\nright -> mid\n left -> right\n  mid -> left\n  mid -> right\n left -> right\n  mid -> left\nright -> mid\nright -> left\n  mid -> left\n  mid -> right\n left -> right\n left -> mid\nright -> mid\n left -> right\n  mid -> left\n  mid -> right\n left -> right\n", "explain": "Most of the programs on this page use an imperative approach \n(i.e., print out movements as side effects during program execution). \nHaskell favors a purely functional approach, where you would for example return a (lazy) list of movements from a to b via c:\nYou can also do the above with one tail-recursion call:\nOne can use this function to produce output, just like the other programs:\nor, instead, one can of course also program imperatively, using the IO monad directly:\nor, defining it as a monoid, and adding some output:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\n\nSub Move(n,fromPeg,toPeg,viaPeg)\n\tIf n > 0 Then\n\t\tMove n-1, fromPeg, viaPeg, toPeg\n\t\tWScript.StdOut.Write \"Move disk from \" & fromPeg & \" to \" & toPeg\n\t\tWScript.StdOut.WriteBlankLines(1)\n\t\tMove n-1, viaPeg, toPeg, fromPeg\n\tEnd If\nEnd Sub\n\nMove 4,1,2,3\nWScript.StdOut.Write(\"Towers of Hanoi puzzle completed!\")\n\nOutput:\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\nMove disk from 1 to 3\nMove disk from 2 to 1\nMove disk from 2 to 3\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\nMove disk from 3 to 1\nMove disk from 2 to 1\nMove disk from 3 to 2\nMove disk from 1 to 3\nMove disk from 1 to 2\nMove disk from 3 to 2\nTowers of Hanoi puzzle completed!\n", "explain": "Derived from the BASIC256 version.\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n(define (towers-of-hanoi n from to spare)\n  (define (print-move from to)\n    (display \"Move[\")\n    (display from)\n    (display \", \")\n    (display to)\n    (display \"]\")\n    (newline))\n  (cond ((= n 0) \"done\")\n        (else\n         (towers-of-hanoi (- n 1) from spare to)\n         (print-move from to)\n         (towers-of-hanoi (- n 1) spare to from))))\n\n(towers-of-hanoi 3 \"A\" \"B\" \"C\")\n\nOutput:\nMove[A, B]\nMove[A, C]\nMove[B, C]\nMove[A, B]\nMove[C, A]\nMove[C, B]\nMove[A, B]\n\"done\"\n", "explain": "Recursive Process\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 4.0\nfunction hanoi($n, $a,  $b, $c) {\n    if($n -eq 1) {\n        \"$a -> $c\"\n    } else{    \n         hanoi ($n - 1) $a $c $b\n         hanoi 1 $a $b $c\n         hanoi ($n - 1) $b $a $c\n    }\n}\nhanoi 3 \"A\" \"B\" \"C\"\n\nA -> C\nA -> B\nC -> B\nA -> C\nB -> A\nB -> C\nA -> C\n\n", "explain": "Output:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto move :n :from :to :via\n  if :n = 0 [stop]\n  move :n-1 :from :via :to\n  (print [Move disk from] :from [to] :to)\n  move :n-1 :via :to :from\nend\nmove 4 \"left \"middle \"right\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n#light\nlet rec hanoi num start finish =\n  match num with\n  | 0 -> [ ]\n  | _ -> let temp = (6 - start - finish)\n         (hanoi (num-1) start temp) @ [ start, finish ] @ (hanoi (num-1) temp finish)\n\n[<EntryPoint>]\nlet main args =\n  (hanoi 4 1 2) |> List.iter (fun pair -> match pair with\n                                          | a, b -> printf \"Move disc from %A to %A\\n\" a b)\n  0\n\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef tail = { list, n ->  def m = list.size(); list.subList([m - n, 0].max(),m) }\n\nfinal STACK = [A:[],B:[],C:[]].asImmutable()\n\ndef report = { it -> }\ndef check = { it -> }\n\ndef moveRing = { from, to ->  to << from.pop(); report(); check(to) }\n\ndef moveStack\nmoveStack = { from, to, using = STACK.values().find { !(it.is(from) || it.is(to)) } ->\n    if (!from) return\n    def n = from.size()\n    moveStack(tail(from, n-1), using, to)\n    moveRing(from, to)\n    moveStack(tail(using, n-1), to, from)\n}\n\n\nenum Ring {\n    S('\u00b0'), M('o'), L('O'), XL('( )');\n    private sym\n    private Ring(sym) { this.sym=sym }\n    String toString() { sym }\n}\n\nreport = { STACK.each { k, v ->  println \"${k}: ${v}\" }; println() }\ncheck = { to -> assert to == ([] + to).sort().reverse() }\n\nRing.values().reverseEach { STACK.A << it }\nreport()\ncheck(STACK.A)\nmoveStack(STACK.A, STACK.C)\n\n\nOutput:\nA: [( ), O, o, \u00b0]\nB: []\nC: []\n\nA: [( ), O, o]\nB: [\u00b0]\nC: []\n\nA: [( ), O]\nB: [\u00b0]\nC: [o]\n\nA: [( ), O]\nB: []\nC: [o, \u00b0]\n\nA: [( )]\nB: [O]\nC: [o, \u00b0]\n\nA: [( ), \u00b0]\nB: [O]\nC: [o]\n\nA: [( ), \u00b0]\nB: [O, o]\nC: []\n\nA: [( )]\nB: [O, o, \u00b0]\nC: []\n\nA: []\nB: [O, o, \u00b0]\nC: [( )]\n\nA: []\nB: [O, o]\nC: [( ), \u00b0]\n\nA: [o]\nB: [O]\nC: [( ), \u00b0]\n\nA: [o, \u00b0]\nB: [O]\nC: [( )]\n\nA: [o, \u00b0]\nB: []\nC: [( ), O]\n\nA: [o]\nB: [\u00b0]\nC: [( ), O]\n\nA: []\nB: [\u00b0]\nC: [( ), O, o]\n\nA: []\nB: []\nC: [( ), O, o, \u00b0]\n", "explain": "Unlike most solutions here this solution manipulates more-or-less actual stacks of more-or-less actual rings.\nTest program:\n"}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "Zig", "code": "\nTranslation of: C\nconst std = @import(\"std\");\n\npub fn print(from: u32, to: u32) void {\n    std.log.info(\"Moving disk from rod {} to rod {}\", .{ from, to });\n}\n\npub fn move(n: u32, from: u32, via: u32, to: u32) void {\n    if (n > 1) {\n        move(n - 1, from, to, via);\n        print(from, to);\n        move(n - 1, via, from, to);\n    } else {\n        print(from, to);\n    }\n}\n\npub fn main() !void {\n    move(4, 1, 2, 3);\n}\n", "explain": ""}, {"task_name": "Towers of Hanoi", "task_url": "https://rosettacode.org/wiki/Towers_of_Hanoi", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\nTranslation of: Logo\n$ awk 'func hanoi(n,f,t,v){if(n>0){hanoi(n-1,f,v,t);print(f,\"->\",t);hanoi(n-1,v,t,f)}}\nBEGIN{hanoi(4,\"left\",\"middle\",\"right\")}'\n\n\nOutput:\nleft -> right\nleft -> middle\nright -> middle\nleft -> right\nmiddle -> left\nmiddle -> right\nleft -> right\nleft -> middle\nright -> middle\nright -> left\nmiddle -> left\nright -> middle\nleft -> right\nleft -> middle\nright -> middle\n", "explain": ""}]