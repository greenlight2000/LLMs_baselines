[{"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Python", "code": "\ndef bsd_rand(seed):\n   def rand():\n      rand.seed = (1103515245*rand.seed + 12345) & 0x7fffffff\n      return rand.seed\n   rand.seed = seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      rand.seed = (214013*rand.seed + 2531011) & 0x7fffffff\n      return rand.seed >> 16\n   rand.seed = seed\n   return rand\n\nWorks with: Python version 3.x\ndef bsd_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (1103515245*seed + 12345) & 0x7fffffff\n      return seed\n   return rand\n\ndef msvcrt_rand(seed):\n   def rand():\n      nonlocal seed\n      seed = (214013*seed + 2531011) & 0x7fffffff\n      return seed >> 16\n   return rand\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "C", "code": "\n\n#include <stdio.h>\n\n/* always assuming int is at least 32 bits */\nint rand();\nint rseed = 0;\n\ninline void srand(int x)\n{\n\trseed = x;\n}\n\n#ifndef MS_RAND\n#define RAND_MAX ((1U << 31) - 1)\n\ninline int rand()\n{\n\treturn rseed = (rseed * 1103515245 + 12345) & RAND_MAX;\n}\n\n#else /* MS rand */\n\n#define RAND_MAX_32 ((1U << 31) - 1)\n#define RAND_MAX ((1U << 15) - 1)\n\ninline int rand()\n{\n\treturn (rseed = (rseed * 214013 + 2531011) & RAND_MAX_32) >> 16;\n}\n\n#endif/* MS_RAND */\n\nint main()\n{\n\tint i;\n\tprintf(\"rand max is %d\\n\", RAND_MAX);\n\n\tfor (i = 0; i < 100; i++)\n\t\tprintf(\"%d\\n\", rand());\n\n\treturn 0;\n}\n\n", "explain": "In a pretended lib style, this code produces a rand() function depends on compiler macro: gcc -DMS_RAND uses MS style, otherwise it's BSD rand by default.\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "C++", "code": "\n#include <iostream>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nclass mRND\n{\npublic:\n    void seed( unsigned int s ) { _seed = s; }\n\nprotected:\n    mRND() : _seed( 0 ), _a( 0 ), _c( 0 ), _m( 2147483648 ) {}\n    int rnd() { return( _seed = ( _a * _seed + _c ) % _m ); }\n\n    int _a, _c;\n    unsigned int _m, _seed;\n};\n//--------------------------------------------------------------------------------------------------\nclass MS_RND : public mRND\n{\npublic:\n    MS_RND()  { _a = 214013; _c = 2531011; }\n    int rnd() { return mRND::rnd() >> 16; }\n};\n//--------------------------------------------------------------------------------------------------\nclass BSD_RND : public mRND\n{\npublic:\n    BSD_RND() { _a = 1103515245; _c = 12345; }\n    int rnd() { return mRND::rnd(); }\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    BSD_RND bsd_rnd;\n    MS_RND ms_rnd;\n\n    cout << \"MS RAND:\" << endl << \"========\" << endl;\n    for( int x = 0; x < 10; x++ )\n\tcout << ms_rnd.rnd() << endl;\n\n    cout << endl  << \"BSD RAND:\" << endl << \"=========\" << endl;\n    for( int x = 0; x < 10; x++ )\n\tcout << bsd_rnd.rnd() << endl;\n\n    cout << endl << endl;\n    system( \"pause\" );\n    return 0;\n}\n//--------------------------------------------------------------------------------------------------\n\n\nMS RAND:\n========\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\nBSD RAND:\n=========\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\nC++11\nWorks with: C++11\n#include <iostream>\n#include <random>\n\nint main() {\n\n  std::linear_congruential_engine<std::uint_fast32_t, 1103515245, 12345, 1 << 31> bsd_rand(0);\n  std::linear_congruential_engine<std::uint_fast32_t, 214013, 2531011, 1 << 31> ms_rand(0);\n\n  std::cout << \"BSD RAND:\" << std::endl << \"========\" << std::endl;\n  for (int i = 0; i < 10; i++) {\n    std::cout << bsd_rand() << std::endl;\n  }\n  std::cout << std::endl;\n  std::cout << \"MS RAND:\" << std::endl << \"========\" << std::endl;\n  for (int i = 0; i < 10; i++) {\n    std::cout << (ms_rand() >> 16) << std::endl;\n  }\n  \n  return 0;\n}\n\n\nBSD RAND:\n========\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\nMS RAND:\n========\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\n", "explain": "Output:\nOutput:\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Java", "code": "\nWorks with: Java version 8\nimport java.util.stream.IntStream;\nimport static java.util.stream.IntStream.iterate;\n\npublic class LinearCongruentialGenerator {\n    final static int mask = (1 << 31) - 1;\n\n    public static void main(String[] args) {\n        System.out.println(\"BSD:\");\n        randBSD(0).limit(10).forEach(System.out::println);\n\n        System.out.println(\"\\nMS:\");\n        randMS(0).limit(10).forEach(System.out::println);\n    }\n\n    static IntStream randBSD(int seed) {\n        return iterate(seed, s -> (s * 1_103_515_245 + 12_345) & mask).skip(1);\n    }\n\n    static IntStream randMS(int seed) {\n        return iterate(seed, s -> (s * 214_013 + 2_531_011) & mask).skip(1)\n                .map(i -> i >> 16);\n    }\n}\n\nBSD:\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\nMS:\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "C#", "code": "\nWorks with: C# version 6+\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\n\nnamespace LinearCongruentialGenerator\n{\n    static class LinearCongruentialGenerator\n    {\n        static int _seed = (int)DateTime.Now.Ticks; // from bad random gens might as well have bad seed!\n        static int _bsdCurrent = _seed;\n        static int _msvcrtCurrent = _seed;\n\n        static int Next(int seed, int a, int b) => (a * seed + b) & int.MaxValue;\n\n        static int BsdRand() => _bsdCurrent = Next(_bsdCurrent, 1103515245, 12345); \n\n        static int MscvrtRand() => _msvcrtCurrent = Next (_msvcrtCurrent << 16,214013,2531011) >> 16;\n\n        static void PrintRandom(int count, bool isBsd)\n        {\n            var name = isBsd ? \"BSD\" : \"MS\";\n            WriteLine($\"{name} next {count} Random\");\n            var gen = isBsd ? (Func<int>)(BsdRand) : MscvrtRand;\n            foreach (var r in Enumerable.Repeat(gen, count))\n                WriteLine(r.Invoke());\n        }\n\n        static void Main(string[] args)\n        {\n            PrintRandom(10, true);\n            PrintRandom(10, false);\n            Read();\n        }\n    }\n}\n\n\nBSD next 10 Random\n1587930915\n19022880\n1025044953\n1143293854\n1642451583\n1110934092\n773706389\n1830436778\n1527715739\n2072016696\nMS next 10 Random\n24368\n8854\n28772\n16122\n11064\n24190\n23724\n6690\n14784\n21222\n\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace FreeCellDeals\n{\n    public class LCG\n    {\n        private int _state;\n        public bool Microsoft { get; set;}\n        public bool BSD\n        {\n            get\n            {\n                return !Microsoft;\n            }\n            set\n            {\n                Microsoft = !value;\n            }\n        }\n\n        public LCG(bool microsoft = true)\n        {\n            _state = (int)DateTime.Now.Ticks;\n            Microsoft = microsoft;\n        }\n\n        public LCG(int n, bool microsoft = true)\n        {\n            _state = n;\n            Microsoft = microsoft;\n        }\n\n        public int Next()\n        {\n            if (BSD)\n            {\n                return _state = (1103515245 * _state + 12345) & int.MaxValue;\n            }\n            return ((_state = 214013 * _state + 2531011) & int.MaxValue) >> 16;\n        }\n\n        public IEnumerable<int> Seq()\n        {\n            while (true)\n            {\n                yield return Next();\n            }\n        }\n    }\n\n    class Program\n    {\n        static void Main()\n        {\n            LCG ms = new LCG(0, true);\n            LCG bsd = new LCG(0,false);\n            Console.WriteLine(\"Microsoft\");\n            ms.Seq().Take(10).ToList().ForEach(Console.WriteLine);\n            Console.WriteLine(\"\\nBSD\");\n            bsd.Seq().Take(10).ToList().ForEach(Console.WriteLine);\n            Console.ReadKey();\n        }\n    }\n}\n\n\nMicrosoft\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\nBSD\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\n", "explain": "Produces:\nFrom a Free Cell Deal solution\nOutput:\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "PHP", "code": "\nWorks with: PHP version 5.3+\n<?php\nfunction bsd_rand($seed) {\n    return function() use (&$seed) {\n        return $seed = (1103515245 * $seed + 12345) % (1 << 31);\n    };\n}\n\nfunction msvcrt_rand($seed) {\n    return function() use (&$seed) {\n        return ($seed = (214013 * $seed + 2531011) % (1 << 31)) >> 16;\n    };\n}\n\n$lcg = bsd_rand(0);\necho \"BSD \";\nfor ($i = 0; $i < 10; $i++)\n    echo $lcg(), \" \";\necho \"\\n\";\n\n$lcg = msvcrt_rand(0);\necho \"Microsoft \";\nfor ($i = 0; $i < 10; $i++)\n    echo $lcg(), \" \";\necho \"\\n\";\n?>\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nmodule lcgs\n  implicit none\n\n  integer, parameter :: i64 = selected_int_kind(18)\n  integer, parameter :: a1 = 1103515245, a2 = 214013\n  integer, parameter :: c1 = 12345, c2 = 2531011\n  integer, parameter :: div = 65536\n  integer(i64), parameter :: m = 2147483648_i64  ! need to go to 64 bits because\n                                                 ! of the use of signed integers\ncontains \n\nfunction bsdrand(seed)\n  integer :: bsdrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n  \n  if(present(seed)) x = seed\n  x = mod(a1 * x + c1, m)\n  bsdrand = x\nend function\n\nfunction msrand(seed)\n  integer :: msrand\n  integer, optional, intent(in) :: seed\n  integer(i64) :: x = 0\n \n  if(present(seed)) x = seed \n  x = mod(a2 * x + c2, m)\n  msrand = x / div\nend function\nend module\n\nprogram lcgtest\n  use lcgs\n  implicit none\n  integer :: i\n  \n  write(*, \"(a)\") \"      BSD            MS\"\n  do i = 1, 10\n    write(*, \"(2i12)\") bsdrand(), msrand()\n  end do\nend program\n\n\n      BSD            MS\n       12345          38\n  1406932606        7719\n   654583775       21238\n  1449466924        2437\n   229283573        8855\n  1109335178       11797\n  1051550459        8365\n  1293799192       32285\n   794471793       10450\n   551188310       30612\n", "explain": "Output\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\n// basic linear congruential generator\nfunc lcg(a, c, m, seed uint32) func() uint32 {\n    r := seed\n    return func() uint32 {\n        r = (a*r + c) % m\n        return r\n    }\n}\n\n// microsoft generator has extra division step\nfunc msg(seed uint32) func() uint32 {\n    g := lcg(214013, 2531011, 1<<31, seed)\n    return func() uint32 {\n        return g() / (1 << 16)\n    }\n}\n\nfunc example(seed uint32) {\n    fmt.Printf(\"\\nWith seed = %d\\n\", seed)\n    bsd := lcg(1103515245, 12345, 1<<31, seed)\n    msf := msg(seed)\n    fmt.Println(\"       BSD  Microsoft\")\n    for i := 0; i < 5; i++ {\n        fmt.Printf(\"%10d    %5d\\n\", bsd(), msf())\n    }\n}\n\nfunc main() {\n    example(0)\n    example(1)\n}\n\n\nWith seed = 0\n       BSD  Microsoft\n     12345       38\n1406932606     7719\n 654583775    21238\n1449466924     2437\n 229283573     8855\n\nWith seed = 1\n       BSD  Microsoft\n1103527590       41\n 377401575    18467\n 662824084     6334\n1147902781    26500\n2035015474    19169\n\n", "explain": "Output:\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "X86_Assembly", "code": "\n\n;x86-64 assembly code for Microsoft Windows\n;Tested in windows 7 Enterprise Service Pack 1 64 bit\n;With the AMD FX(tm)-6300 processor\n;Assembled with NASM version 2.11.06 \n;Linked to C library with gcc version 4.9.2 (x86_64-win32-seh-rev1, Built by MinGW-W64 project)\n\n;Assembled and linked with the following commands:\n;nasm -f win64 <filename>.asm -o <filename>.obj\n;gcc <filename>.obj -o <filename>\n\n;Takes number of iterations to run RNG loop as command line parameter.\n\nextern printf,puts,atoi,exit,time,malloc\n\nsection .data\nalign 64\nerrmsg_argnumber: db \"There should be no more than one argument.\",0\nalign 64\nerrmsg_noarg: db \"Number of iterations was not specified.\",0\nalign 64\nerrmsg_zeroiterations: db \"Zero iterations of RNG loop specified.\",0\n\nalign 64\nerrmsg_timefail: db \"Unable to retrieve calender time.\",0\nalign 64\nerrmsg_mallocfail: db \"Unable to allocate memory for array of random numbers.\",0\n\nalign 64\nfmt_random: db \"The %u number generated is %d\",0xa,0xd,0\n\nsection .bss\n\nsection .text\nglobal main\n\nmain:\n\n;check for argument\ncmp rcx,1\njle err_noarg\n\n;ensure that only one argument was entered\ncmp rcx,2\njg err_argnumber\n\n\n;get number of times to iterate get_random\nmov rcx,[rdx + 8]\ncall atoi\n\n\n;ensure that number of iterations is greater than 0\ncmp rax,0\njle err_zeroiterations\nmov rcx,rax\n\n\n;calculate space needed for an array containing the random numbers\nshl rcx,2\n\n;move size of array into r14\nmov r14,rcx\n\n;reserve memory for array of random numbers with malloc\ncall malloc\n\ncmp rax,0\njz err_mallocfail\n\n;pointer to array in r15\nmov r15,rax\n\n\n;seed the RNG using time()\nxor rcx,rcx\ncall time\n\n;ensure that time returns valid output\ncmp rax,-1\njz err_timefail\n\n;calculate address of end of array in r14\nadd r14,r15\n\n\n;pointer to array of random numbers in r15\n;address of end of array in r14\n;current address in array in rdi\n;multiplier in rbx\n;seed in rax\n;current random number in rcx\n\n\n;prepare random number generator\n\nmov rdi,r15\n\nmov rbx,214013\n\n\nget_random:\n\n;multiply by 214013 and add 2561011 to get next state\nmul ebx\nadd eax,2531011\n\n;shr by 16 and AND with 0x7FFF to get current random number\nmov ecx,eax\nshr ecx,16\nand ecx,0x7fff\n\n;store random number in array\nmov [rdi],ecx\n\nadd rdi,4\ncmp rdi,r14\njl get_random\n\n\n;pointer to array of random numbers in r15\n;address of end of array in r14\n;current address in array in rdi\n;array index in rsi\n\n\nxor rsi,rsi\nmov rdi,r15\n\nprint_random:\n\nmov rcx,fmt_random\nmov rdx,rsi\nmov r8d,[rdi]\ncall printf\n\nadd rsi,1\nadd rdi,4\ncmp rdi,r14\njl print_random\n\nxor rcx,rcx\ncall exit\n\n\n;;;;;;;;;;ERROR MESSAGES;;;;;;;;;;;;;;;;\n\nerr_argnumber:\n\nmov rcx,errmsg_argnumber\ncall puts\n\njmp exit_one\n\n\nerr_noarg:\n\nmov rcx,errmsg_noarg\ncall puts\n\njmp exit_one\n\n\nerr_zeroiterations:\n\nmov rcx,errmsg_zeroiterations\ncall puts\n\njmp exit_one\n\n\nerr_timefail:\n\nmov rcx,errmsg_timefail\ncall puts\n\njmp exit_one\n\n\nerr_mallocfail:\n\nmov rcx,errmsg_mallocfail\ncall puts\n\n\nexit_one:\n\nmov rcx,1\ncall exit\n\n\n\n\nThis example is incorrect.  Please fix the code and remove this message.Details: It will not produce output identical to that of the Microsoft rand() function.\n\n;x86-64 assembly code for Microsoft Windows\n;Tested in windows 7 Enterprise Service Pack 1 64 bit\n;With the AMD FX(tm)-6300 processor\n;Assembled with NASM version 2.11.06 \n;Linked to C library with gcc version 4.9.2 (x86_64-win32-seh-rev1, Built by MinGW-W64 project)\n\n;Assembled and linked with the following commands:\n;nasm -f win64 <filename>.asm -o <filename>.obj\n;gcc <filename>.obj -o <filename>\n\n;Takes number of iterations to run RNG loop as command line parameter.\n\nextern printf,puts,atoi,exit,time,_aligned_malloc\n\nsection .data\nalign 64\nerrmsg_argnumber: db \"There should be no more than one argument.\",0\nalign 64\nerrmsg_noarg: db \"Number of iterations was not specified.\",0\nalign 64\nerrmsg_zeroiterations: db \"Zero iterations of RNG loop specified.\",0\n\nalign 64\nerrmsg_timefail: db \"Unable to retrieve calender time.\",0\nalign 64\nerrmsg_mallocfail: db \"Unable to allocate memory for array of random numbers.\",0\n\nalign 64\nfmt_random: db \"The %u number generated is %d\",0xa,0xd,0\n\nalign 16\nmultiplier: dd 214013,17405,214013,69069\nalign 16\naddend: dd 2531011, 10395331, 13737667, 1\nalign 16\nmask: dd  0xffffffff,0,0xffffffff,0 \nalign 16\nmasklo: dd 0x7fff,0x7fff,0x7fff,0x7fff\n\nsection .bss\n\nsection .text\nglobal main\n\nmain:\n\n;check for argument\ncmp rcx,1\njle err_noarg\n\n;ensure that only one argument was entered\ncmp rcx,2\njg err_argnumber\n\n\n;get number of times to iterate get_random\nmov rcx,[rdx + 8]\ncall atoi\n\n\n;ensure that number of iterations is greater than 0\ncmp rax,0\njle err_zeroiterations\nmov rcx,rax\n\n\n;calculate space needed for an array containing the random numbers\nshl rcx,4\n\n;move size of array into r14\nmov r14,rcx\n\n;16 byte alignment boundary\nmov rdx,16\n\n;reserve memory aligned to 16 byte boundary for array with _aligned_malloc\ncall _aligned_malloc\n\ncmp rax,0\njz err_mallocfail\n\n;pointer to array in r15\nmov r15,rax\n\n\n;seed the RNG using time()\nxor rcx,rcx\ncall time\n\n;ensure that time returns valid output\ncmp rax,-1\njz err_timefail\n\n\n;pointer to array of random numbers in r15\n;address of end of array at in r14\n;states stored in xmm0\n\n;calculate address of end of array in r14\nadd r14,r15\n\n;load seed,seed+1,seed,seed+1 into xmm0\nlea rbx,[rax - 1]\nshl rax,32\nor rax,rbx\n\nmovq xmm0,rax\nvpslldq xmm1,xmm0,8\nvpor xmm0,xmm0,xmm1\n\n\n;pointer to array of random numbers in r15\n;address of end of array in r14\n;current address in array in rdi\n;current states in xmm0\n;multiplier in xmm1\n;addened in xmm2\n;mask in xmm3\n;masklo in xmm4\n;split seed in xmm5\n;current set of random numbers in xmm6\n\n;prepare random number generator\n\nmov rdi,r15\n\nvmovdqa xmm1,[multiplier]\nvmovdqa xmm2,[addend]\nvmovdqa xmm3,[mask]\nvmovdqa xmm4,[masklo]\n\n\nget_random:\n\n;arrange order of current states to 2,3,0,1 and store in split seed\nvpshufd xmm5,xmm0,10110001b\n\n;multiply current states by multiplier\nvpmulld xmm0,xmm0,xmm1\n\n;set order of multiplier to 2,3,0,1\nvpshufd xmm1,xmm1,10110001b\n\n;multiply split seed by multiplier\nvpmulld xmm5,xmm5,xmm1\n\n;and current states with mask\nvpand xmm0,xmm0,xmm3\n\n;and current split seed with mask\nvpand xmm5,xmm5,xmm3\n\n;set order of split seed to 2,3,0,1\nvpshufd xmm5,xmm5,10110001b\n\n;or current states with split seed\nvpor xmm0,xmm0,xmm5\n\n;add adder to current states\nvpaddd xmm0,xmm0,xmm2\n\n\n;shift vector right by two bytes\nvpsrldq xmm6,xmm0,2\n\n;and each state with 0x7fff\nvpand xmm6,xmm6,xmm4\n\nvmovdqa [rdi],xmm6\n\nadd rdi,16\ncmp rdi,r14\njl get_random\n\n\n;pointer to array of random numbers in r15\n;address of end of array in r14\n;current address in array in rdi\n;array index in rsi\n\n\nxor rsi,rsi\nmov rdi,r15\n\nprint_random:\n\nmov rcx,fmt_random\nmov rdx,rsi\nmov r8d,[rdi]\ncall printf\n\nadd rsi,1\nadd rdi,4\ncmp rdi,r14\njl print_random\n\nxor rcx,rcx\ncall exit\n\n\n;;;;;;;;;;ERROR MESSAGES;;;;;;;;;;;;;;;;\n\nerr_argnumber:\n\nmov rcx,errmsg_argnumber\ncall puts\n\njmp exit_one\n\n\nerr_noarg:\n\nmov rcx,errmsg_noarg\ncall puts\n\njmp exit_one\n\n\nerr_zeroiterations:\n\nmov rcx,errmsg_zeroiterations\ncall puts\n\njmp exit_one\n\n\nerr_timefail:\n\nmov rcx,errmsg_timefail\ncall puts\n\njmp exit_one\n\n\nerr_mallocfail:\n\nmov rcx,errmsg_mallocfail\ncall puts\n\n\nexit_one:\n\nmov rcx,1\ncall exit\n\n\nSample:\n\nF:\\>lcgint.exe 20\nThe 0 number generated is 20272\nThe 1 number generated is 4467\nThe 2 number generated is 8618\nThe 3 number generated is 1587\nThe 4 number generated is 2687\nThe 5 number generated is 21398\nThe 6 number generated is 29522\nThe 7 number generated is 27724\nThe 8 number generated is 23875\nThe 9 number generated is 2399\nThe 10 number generated is 4086\nThe 11 number generated is 923\nThe 12 number generated is 23002\nThe 13 number generated is 11586\nThe 14 number generated is 13200\nThe 15 number generated is 22090\nThe 16 number generated is 26528\nThe 17 number generated is 14271\nThe 18 number generated is 10476\nThe 19 number generated is 9981\n\nF:\\>\n\nF:\\>lcgavx.exe 5\nThe 0 number generated is 20370\nThe 1 number generated is 45\nThe 2 number generated is 20541\nThe 3 number generated is 15699\nThe 4 number generated is 23637\nThe 5 number generated is 30131\nThe 6 number generated is 26151\nThe 7 number generated is 27319\nThe 8 number generated is 26933\nThe 9 number generated is 28417\nThe 10 number generated is 16647\nThe 11 number generated is 14840\nThe 12 number generated is 29228\nThe 13 number generated is 16968\nThe 14 number generated is 1027\nThe 15 number generated is 12099\nThe 16 number generated is 17170\nThe 17 number generated is 23893\nThe 18 number generated is 18556\nThe 19 number generated is 16434\n\nF:\\>\n", "explain": "These programs are based off of the implementations described in this article: \"https://software.intel.com/en-us/articles/fast-random-number-generator-on-the-intel-pentiumr-4-processor\", using the Microsoft equation.\nFirst example using integer instructions.\nSecond example using AVX instructions.\nInteger instruction example:\nAVX instruction example:\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  Winapi.Windows\nTranslation of: C#\nprogram Linear_congruential_generator;\n\n{$APPTYPE CONSOLE}\n{$R *.res}\n\nuses\n  System.SysUtils,\n  Winapi.Windows;\n\ntype\n  TRandom = record\n  private\n    FSeed: Cardinal;\n    FBsdCurrent: Cardinal;\n    FMsvcrtCurrent: Cardinal;\n    class function Next(seed, a, b: Cardinal): Cardinal; static;\n  public\n    constructor Create(const seed: Cardinal);\n    function Rand(Bsd: Boolean = True): Cardinal;\n    property Seed: Cardinal read FSeed;\n  end;\n\n{ TRandom }\n\nclass function TRandom.Next(seed, a, b: Cardinal): Cardinal;\nbegin\n  Result := (a * seed + b) and MAXDWORD;\nend;\n\nfunction TRandom.Rand(Bsd: Boolean): Cardinal;\nbegin\n  if Bsd then\n  begin\n    FBsdCurrent := Next(FBsdCurrent, 1103515245, 12345);\n    Result := FBsdCurrent;\n  end\n  else\n  begin\n    FMsvcrtCurrent := Next(FMsvcrtCurrent shl 16, 214013, 2531011) shr 16;\n    Result := FMsvcrtCurrent;\n  end;\nend;\n\nconstructor TRandom.Create(const seed: Cardinal);\nbegin\n  FSeed := seed;\n  FBsdCurrent := FSeed;\n  FMsvcrtCurrent := FSeed;\nend;\n\nvar\n  r: TRandom;\n\nprocedure PrintRandom(count: Integer; IsBsd: Boolean);\nconst\n  NAME: array[Boolean] of string = ('MS', 'BSD');\nvar\n  i: Integer;\nbegin\n  Writeln(NAME[IsBsd], ' next ', count, ' Random'#10);\n  for i := 0 to count - 1 do\n    writeln('   ', r.Rand(IsBsd));\n  writeln;\nend;\n\nbegin\n  r.Create(GetTickCount);\n  PrintRandom(10, True);\n  PrintRandom(10, False);\n  readln;\nend.\n\n\nOutput:\nBSD next 10 Random\n\n   3076996592\n   1668591465\n   978771438\n   1655648911\n   3482994972\n   245356837\n   1171712762\n   1870031019\n   3901807368\n   2560221857\n\nMS next 10 Random\n\n   22925\n   26495\n   34217\n   21291\n   29349\n   31799\n   10113\n   52643\n   58173\n   35439\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Ruby", "code": "\n\nmodule LCG\n  module Common\n    # The original seed of this generator.\n    attr_reader :seed\n\n    # Creates a linear congruential generator with the given _seed_.\n    def initialize(seed)\n      @seed = @r = seed\n    end\n  end\n\n  # LCG::Berkeley generates 31-bit integers using the same formula\n  # as BSD rand().\n  class Berkeley\n    include Common\n    def rand\n      @r = (1103515245 * @r + 12345) & 0x7fff_ffff\n    end\n  end\n\n  # LCG::Microsoft generates 15-bit integers using the same formula\n  # as rand() from the Microsoft C Runtime.\n  class Microsoft\n    include Common\n    def rand\n      @r = (214013 * @r + 2531011) & 0x7fff_ffff\n      @r >> 16\n    end\n  end\nend\n\n\nlcg = LCG::Berkeley.new(1)\np (1..5).map {lcg.rand}\n# prints [1103527590, 377401575, 662824084, 1147902781, 2035015474]\n\nlcg = LCG::Microsoft.new(1)\np (1..5).map {lcg.rand}\n# prints [41, 18467, 6334, 26500, 19169]\n\n", "explain": "You can create multiple instances of LCG::Berkeley or LCG::Microsoft. Each instance privately keeps the original seed in @seed, and the current state in @r. Each class resembles the core Random class, but with fewer features. The .new method takes a seed. The #rand method returns the next random number. The #seed method returns the original seed.\nThe next example sets the seed to 1, and prints the first 5 random numbers.\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Rust", "code": "\nextern crate rand;\n\npub use rand::{Rng, SeedableRng};\n\npub struct BsdLcg {\n    state: u32,\n}\n\nimpl Rng for BsdLcg {\n    // Because the output is in the range [0, 2147483647], this should technically be `next_u16`\n    // (the largest integer size which is fully covered, as `rand::Rng` assumes).  The `rand`\n    // crate does not provide it however.  If serious usage is required, implementing this\n    // function as a concatenation of two `next_u16`s (elsewhere defined) should work.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(1_103_515_245).wrapping_add(12_345);\n        self.state %= 1 << 31;\n        self.state\n    }\n}\n\nimpl SeedableRng<u32> for BsdLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\npub struct MsLcg {\n    state: u32,\n}\n\nimpl Rng for MsLcg {\n    // Similarly, this outputs in the range [0, 32767] and should output a `u8`.  Concatenate\n    // four `next_u8`s for serious usage.\n    fn next_u32(&mut self) -> u32 {\n        self.state = self.state.wrapping_mul(214_013).wrapping_add(2_531_011);\n        self.state %= 1 << 31;\n        self.state >> 16 // rand_n = state_n / 2^16\n    }\n}\n\nimpl SeedableRng<u32> for MsLcg {\n    fn from_seed(seed: u32) -> Self {\n        Self { state: seed }\n    }\n    fn reseed(&mut self, seed: u32) {\n        self.state = seed;\n    }\n}\n\nfn main() {\n    println!(\"~~~ BSD ~~~\");\n    let mut bsd = BsdLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", bsd.next_u32());\n    }\n\n    println!(\"~~~ MS ~~~\");\n    let mut ms = MsLcg::from_seed(0);\n    for _ in 0..10 {\n        println!(\"{}\", ms.next_u32());\n    }\n\n    // Because we have implemented the `rand::Rng` trait, we can generate a variety of other types.\n    println!(\"~~~ Others ~~~\");\n    println!(\"{:?}\", ms.gen::<[u32; 5]>());\n    println!(\"{}\", ms.gen::<bool>());\n    println!(\"{}\", ms.gen_ascii_chars().take(15).collect::<String>());\n}\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Swift", "code": "\nimport Cocoa\n\nclass LinearCongruntialGenerator {\n    \n    var state = 0 //seed of 0 by default\n    let a, c, m, shift: Int\n    \n    //we will use microsoft random by default\n    init() {\n        self.a = 214013\n        self.c = 2531011\n        self.m = Int(pow(2.0, 31.0)) //2^31 or 2147483648\n        self.shift = 16\n    }\n    \n    init(a: Int, c: Int, m: Int, shift: Int) {\n        self.a = a\n        self.c = c\n        self.m = m //2^31 or 2147483648\n        self.shift = shift\n    }\n    \n    func seed(seed: Int) -> Void {\n        state = seed;\n    }\n    \n    func random() -> Int {\n        state = (a * state + c) % m\n        return state >> shift\n    }\n}\n\nlet microsoftLinearCongruntialGenerator = LinearCongruntialGenerator()\nlet BSDLinearCongruntialGenerator = LinearCongruntialGenerator(a: 1103515245, c: 12345, m: 2147483648, shift: 0)\n\nprint(\"Microsft Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(microsoftLinearCongruntialGenerator.random())\n}\n\nprint(\"\") //new line for readability\nprint(\"BSD Rand:\")\nfor(var i = 0; i < 10; i++)\n{\n    print(BSDLinearCongruntialGenerator.random())\n}\n\n\nOutput:Microsft Rand:\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\nBSD Rand:\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n\n551188310\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "R", "code": "\nlibrary(gmp) # for big integers\n\nrand_BSD <- function(n = 1) {\n  a <- as.bigz(1103515245)\n  c <- as.bigz(12345)\n  m <- as.bigz(2^31)\n  x <- rep(as.bigz(0), n)\n  x[1] <- (a * as.bigz(seed) + c) %% m\n  i <- 1\n  while (i < n) {\n    x[i+1] <- (a * x[i] + c) %% m\n    i <- i + 1\n  }\n  as.integer(x)\n}\n\nseed <- 0\nrand_BSD(10)\n##  [1]      12345 1406932606  654583775 1449466924  229283573 1109335178\n##  [7] 1051550459 1293799192  794471793  551188310\n\nrand_MS <- function(n = 1) {\n  a <- as.bigz(214013)\n  c <- as.bigz(2531011)\n  m <- as.bigz(2^31)\n  x <- rep(as.bigz(0), n)\n  x[1] <- (a * as.bigz(seed) + c) %% m\n  i <- 1\n  while (i < n) {\n    x[i+1] <- (a * x[i] + c) %% m\n    i <- i + 1\n  }\n  as.integer(x / 2^16)\n}\n\nseed <- 0\nrand_MS(10)\n##  [1]    38  7719 21238  2437  8855 11797  8365 32285 10450 30612\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Ada", "code": "\n\ngeneric\n   type Base_Type is mod <>;\n   Multiplyer, Adder: Base_Type;\n   Output_Divisor: Base_Type := 1;\npackage LCG is\n\n   procedure Initialize(Seed: Base_Type);\n   function Random return Base_Type;\n   -- changes the state and outputs the result\n\nend LCG;\n\n\npackage body LCG is\n\n   State: Base_Type := Base_Type'First;\n\n   procedure Initialize(Seed: Base_Type) is\n   begin\n      State := Seed;\n   end Initialize;\n\n   function Random return Base_Type is\n   begin\n      State := State * Multiplyer + Adder;\n      return State / Output_Divisor;\n   end Random;\n\nend LCG;\n\n\nwith Ada.Text_IO, LCG;\n\nprocedure Run_LCGs is\n\n   type M31 is mod 2**31;\n\n   package BSD_Rand is new LCG(Base_Type => M31, Multiplyer => 1103515245,\n                               Adder => 12345);\n\n   package MS_Rand  is new LCG(Base_Type => M31, Multiplyer => 214013,\n                               Adder => 2531011, Output_Divisor => 2**16);\n\nbegin\n   for I in 1 .. 10 loop\n      Ada.Text_IO.Put_Line(M31'Image(BSD_Rand.Random));\n   end loop;\n   for I in 1 .. 10 loop\n       Ada.Text_IO.Put_Line(M31'Image(MS_Rand.Random));\n   end loop;\nend Run_LCGs;\n\n\n 12345\n 1406932606\n 654583775\n 1449466924\n 229283573\n 1109335178\n 1051550459\n 1293799192\n 794471793\n 551188310\n 38\n 7719\n 21238\n 2437\n 8855\n 11797\n 8365\n 32285\n 10450\n 30612\n", "explain": "We first specify a generic package LCG:\nThen we provide a generic implementation:\nNext, we define the MS- and BSD-instantiations of the generic package:\nFinally, we run the program, which generates the following output (note that the first ten lines are from the BSD generator, the next ten from the MS generator): \n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Julia", "code": "\n\nusing Printf\n\nfunction getlgc(r::Integer, a::Integer, c::Integer, m::Integer, sh::Integer)\n    state = r\n    return function lgcrand()\n        state = mod(a * state + c, m)\n        return state >> sh\n    end\nend\n\nseed, nrep = 0, 10\nbsdrand = getlgc(seed, 1103515245, 12345, 2 ^ 31, 0)\n\nprintln(\"The first $nrep results for a BSD rand seeded with $seed:\")\nfor _ in 1:nrep\n    @printf(\"%14d\\n\", bsdrand())\nend\n\nmsrand = getlgc(seed, 214013, 2531011, 2 ^ 31, 16)\n\nprintln(\"\\nThe first $nrep results for a M\\$ rand seeded with $seed:\")\nfor _ in 1:nrep\n    @printf(\"%14d\\n\", msrand())\nend\n\n\nOutput:\nThe first 10 results for a BSD rand seeded with 0:\n         12345\n    1406932606\n     654583775\n    1449466924\n     229283573\n    1109335178\n    1051550459\n    1293799192\n     794471793\n     551188310\n\nThe first 10 results for a M$ rand seeded with 0:\n            38\n          7719\n         21238\n          2437\n          8855\n         11797\n          8365\n         32285\n         10450\n         30612\n", "explain": "getlgc creates a linear congruential generator as a closure.  This function is used to create the two generators called for by the task.\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Kotlin", "code": "\n// version 1.1.3\n\nclass Lcg(val a: Long, val c: Long, val m: Long, val d: Long, val s: Long) {\n    private var state = s\n    \n    fun nextInt(): Long {\n        state = (a * state + c) % m\n        return state / d\n    }\n}\n\nfun main(args: Array<String>) {\n    println(\"First 10 BSD random numbers - seed 0\")\n    val bsd = Lcg(1103515245, 12345, 1 shl 31, 1, 0)\n    for (i in 1..10) println(\"${bsd.nextInt()}\")\n    println(\"\\nFirst 10 MSC random numbers - seed 0\")\n    val msc = Lcg(214013, 2531011, 1 shl 31, 1 shl 16, 0)\n    for (i in 1..10) println(\"${msc.nextInt()}\")\n}\n\n\nOutput:\nFirst 10 BSD random numbers - seed 0\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\nFirst 10 MSC random numbers - seed 0\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Perl", "code": "\nCreates a magic scalar whose value is next in the LCG sequence when read.use strict;\npackage LCG;\n\nuse overload '0+'  => \\&get;\n\nuse integer;\nsub gen_bsd { (1103515245 * shift() + 12345) % (1 << 31) }\n\nsub gen_ms  {\n\tmy $s = (214013 * shift() + 2531011) % (1 << 31);\n\t$s, $s / (1 << 16)\n}\n\nsub set { $_[0]->{seed} = $_[1] } # srand\nsub get {\n\tmy $o = shift;\n\t($o->{seed}, my $r) = $o->{meth}->($o->{seed});\n\t$r //= $o->{seed}\n}\n\nsub new {\n\tmy $cls = shift;\n\tmy %opts = @_;\n\tbless {\n\t\tseed => $opts{seed},\n\t\tmeth => $opts{meth} eq 'MS' ? \\&gen_ms : \\&gen_bsd,\n\t}, ref $cls || $cls;\n}\n\npackage main;\n\nmy $rand = LCG->new;\n\nprint \"BSD:\\n\";\nprint \"$rand\\n\" for 1 .. 10;\n\n$rand = LCG->new(meth => 'MS');\n\nprint \"\\nMS:\\n\";\nprint \"$rand\\n\" for 1 .. 10;\noutputBSD:\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\nMS:\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Lua", "code": "\nWorks with: Lua version 5.3\n\nlocal RNG = {\n  new = function(class, a, c, m, rand) \n    local self = setmetatable({}, class)\n    local state = 0\n    self.rnd = function() \n      state = (a * state + c) % m\n      return rand and rand(state) or state\n    end\n    self.seed = function(new_seed)\n      state = new_seed % m\n    end\n    return self\n  end\n}\n\nbsd = RNG:new(1103515245, 12345, 1<<31)\nms = RNG:new(214013, 2531011, 1<<31, function(s) return s>>16 end)\n\nprint\"BSD:\"\nfor _ = 1,10 do\n  print((\"\\t%10d\"):format(bsd.rnd()))\nend\nprint\"Microsoft:\"\nfor _ = 1,10 do\n  print((\"\\t%10d\"):format(ms.rnd()))\nend\n\n\nOutput:\nBSD:\n\t     12345\n\t1406932606\n\t 654583775\n\t1449466924\n\t 229283573\n\t1109335178\n\t1051550459\n\t1293799192\n\t 794471793\n\t 551188310\nMicrosoft:\n\t        38\n\t      7719\n\t     21238\n\t      2437\n\t      8855\n\t     11797\n\t      8365\n\t     32285\n\t     10450\n\t     30612\n\n", "explain": "This requires Lua 5.3 or later because previous versions didn't have support for large integers or integral arithmetic operations.\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Scala", "code": "\nobject LinearCongruentialGenerator {\n  def bsdRandom(rseed:Int):Iterator[Int]=new Iterator[Int]{\n    var seed=rseed\n    override def hasNext:Boolean=true\n    override def next:Int={seed=(seed * 1103515245 + 12345) & Int.MaxValue; seed}\n  }\n\n  def msRandom(rseed:Int):Iterator[Int]=new Iterator[Int]{\n    var seed=rseed\n    override def hasNext:Boolean=true\n    override def next:Int={seed=(seed * 214013 + 2531011) & Int.MaxValue; seed >> 16}\n  }\n\t\t\n  def toString(it:Iterator[Int], n:Int=20)=it take n mkString \", \"\n\t\t\n  def main(args:Array[String]){\n    println(\"-- seed 0 --\")\n    println(\"BSD: \"+ toString(bsdRandom(0)))\n    println(\"MS\u00a0: \"+ toString(msRandom(0)))\n\t\t\t\t\t\t\n    println(\"-- seed 1 --\")\n    println(\"BSD: \"+ toString(bsdRandom(1)))\n    println(\"MS\u00a0: \"+ toString( msRandom(1)))\n  }\n}\n\n\nOutput:\n-- seed 0 --\nBSD: 12345, 1406932606, 654583775, 1449466924, 229283573, 1109335178, 1051550459, 1293799192,\n794471793, 551188310, 803550167, 1772930244, 370913197, 639546082, 1381971571, 1695770928, \n2121308585, 1719212846, 996984527, 1157490780\n\nMS\u00a0: 38, 7719, 21238, 2437, 8855, 11797, 8365, 32285, 10450, 30612, 5853, 28100, 1142, 281, 20537,\n15921, 8945, 26285, 2997, 14680\n\n-- seed 1 --\nBSD: 1103527590, 377401575, 662824084, 1147902781, 2035015474, 368800899, 1508029952, 486256185,\n1062517886, 267834847, 180171308, 836760821, 595337866, 790425851, 2111915288, 1149758321,\n1644289366, 1388290519, 1647418052, 1675546029\n\nMS\u00a0: 41, 18467, 6334, 26500, 19169, 15724, 11478, 29358, 26962, 24464, 5705, 28145, 23281, 16827,\n9961, 491, 2995, 11942, 4827, 5436\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "D", "code": "\nstruct LinearCongruentialGenerator {\n    enum uint RAND_MAX = (1U << 31) - 1;\n    uint seed = 0;\n\n    uint randBSD() pure nothrow @nogc {\n        seed = (seed * 1_103_515_245 + 12_345) & RAND_MAX;\n        return seed;\n    }\n\n    uint randMS() pure nothrow @nogc {\n        seed = (seed * 214_013 + 2_531_011) & RAND_MAX;\n        return seed >> 16;\n    }\n}\n\nvoid main() {\n    import std.stdio;\n\n    LinearCongruentialGenerator rnd;\n\n    foreach (immutable i; 0 .. 10)\n        writeln(rnd.randBSD);\n    writeln;\n\n    rnd.seed = 0;\n    foreach (immutable i; 0 .. 10)\n        writeln(rnd.randMS);\n}\n\n\n12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n", "explain": "Output:\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Haskell", "code": "\nbsd = tail . iterate (\\n -> (n * 1103515245 + 12345) `mod` 2^31)\nmsr = map (`div` 2^16) . tail . iterate (\\n -> (214013 * n + 2531011) `mod` 2^31)\n\nmain = do\n\tprint $ take 10 $ bsd 0 -- can take seeds other than 0, of course\n\tprint $ take 10 $ msr 0\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Scheme", "code": "\n\n(import (scheme base)\n        (scheme write))\n\n(define ((bsd-rand state))\n  (set! state (remainder (+ (* 1103515245 state) 12345) 2147483648))\n    state)\n\n(define ((msvcrt-rand state))\n  (set! state (remainder (+ (* 214013 state) 2531011) 2147483648))\n    (quotient state 65536))\n\n; auxiliary function to get a list of 'n random numbers from generator 'r\n(define (rand-list r n)\n  (if (zero? n) '() (cons (r) (rand-list r (- n 1)))))\n\n(display (rand-list (bsd-rand 0) 10))\n; (12345 1406932606 654583775 1449466924 229283573 1109335178 1051550459 1293799192 794471793 551188310)\n\n(newline)\n\n(display (rand-list (msvcrt-rand 0) 10))\n; (38 7719 21238 2437 8855 11797 8365 32285 10450 30612)\n\n", "explain": "For R7RS Scheme.\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "PowerShell", "code": "\nFunction msstate{\n    Param($current_seed)\n    Return (214013*$current_seed+2531011)%2147483648}\n    \nFunction randMS{\n    Param($MSState)\n    Return [int]($MSState/65536)}\n    \nFunction randBSD{\n    Param($BSDState)\n    Return (1103515245*$BSDState+12345)%2147483648}    \n\nWrite-Host \"MS: seed=0\"\n$seed=0 #initialize seed\nFor($i=1;$i-le5;$i++){\n    $seed = msstate($seed)\n    $rand = randMS($seed)\n    Write-Host $rand}\n\nWrite-Host \"BSD: seed=0\"\n$seed=0 #initialize seed\nFor($j=1;$j-le5;$j++){\n    $seed = randBSD($seed)\n    Write-Host $seed}\n\n\nOutput:\nMS: seed=0\n39\n7720\n21238\n2437\n8855\nBSD: seed=0\n12345\n1406932606\n654583775\n1449466924\n229283573\n\n", "explain": ""}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "Logo", "code": "\n\n; Configuration parameters for Microsoft and BSD implementations\nmake \"LCG_MS [214013 2531011 65536 2147483648]\nmake \"LCG_BSD [1103515245 12345 1 2147483648]\n\n; Default seed is 0\nmake \"_lcg_value 0\n\n; set the seed\nto lcg_seed :seed\n  make \"_lcg_value :seed\nend\n\n; generate the next number in the series using the given parameters\nto lcg_rand [:config :LCG_MS]\n  local \"a local \"c local \"d local \"m\n  foreach [a c d m] [\n    make\u00a0? item # :config\n  ]\n  make \"_lcg_value (modulo (sum (product :a :_lcg_value) :c) :m)\n  output int quotient :_lcg_value :d\nend\n\nforeach (list :LCG_BSD :LCG_MS) [\n  lcg_seed 0\n  repeat 10 [\n    print (lcg_rand\u00a0?)\n  ]\n  print []\n]\nbye\nOutput:12345\n1406932606\n654583775\n1449466924\n229283573\n1109335178\n1051550459\n1293799192\n794471793\n551188310\n\n38\n7719\n21238\n2437\n8855\n11797\n8365\n32285\n10450\n30612\n\nUCBLogo output for the BSD section: 12345\n1406932606\n654583808\n1358247936\n2138638336\n1459132416\n1445521408\n370866176\n1896597568\n1518859008\n", "explain": "Note that, perhaps ironically, UCB Logo, as of version 6.0, doesn't generate the proper output from the BSD constants; it uses double-precision floating point, which is not enough for some of the intermediate products.  In UCBLogo, the BSD series deviates starting with the third value (see sample output below).\n"}, {"task_name": "Linear congruential generator", "task_url": "https://rosettacode.org/wiki/Linear_congruential_generator", "task_cat": "Randomness", "lang": "F#", "code": "\nmodule lcg =\n    let bsd seed =\n        let state = ref seed\n        (fun (_:unit) ->\n            state := (1103515245 * !state + 12345) &&& System.Int32.MaxValue\n            !state)\n \n    let ms seed =\n        let state = ref seed\n        (fun (_:unit) ->\n            state := (214013 * !state + 2531011) &&& System.Int32.MaxValue\n            !state / (1<<<16))\n\nlet rndBSD = lcg.bsd 0;; \nlet BSD=[for n in [0 .. 9] -> rndBSD()];;\n\nlet rndMS = lcg.ms 0;; \nlet MS=[for n in [0 .. 9] -> rndMS()];;\n\nval BSD\u00a0: int list =\n  [12345; 1406932606; 654583775; 1449466924; 229283573; 1109335178; 1051550459;\n   1293799192; 794471793; 551188310]\nval MS\u00a0: int list =\n  [38; 7719; 21238; 2437; 8855; 11797; 8365; 32285; 10450; 30612]\n", "explain": ""}]