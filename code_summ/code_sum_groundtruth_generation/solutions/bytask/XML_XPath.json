[{"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Python", "code": "\n# Python has basic xml parsing built in\n\nfrom xml.dom import minidom\n\nxmlfile = file(\"test3.xml\") # load xml document from file \nxmldoc = minidom.parse(xmlfile).documentElement # parse from file stream or...\nxmldoc = minidom.parseString(\"<inventory title=\"OmniCorp Store #45x10^3\">...</inventory>\").documentElement # alternatively, parse a string\n\t\n#  1st Task: Retrieve the first \"item\" element\ni = xmldoc.getElementsByTagName(\"item\") # get a list of all \"item\" tags\nfirstItemElement = i[0] # get the first element\n\n# 2nd task: Perform an action on each \"price\" element (print it out)\nfor j in xmldoc.getElementsByTagName(\"price\"): # get a list of all \"price\" tags\n\tprint j.childNodes[0].data # XML Element . TextNode . data of textnode\n\n# 3rd Task: Get an array of all the \"name\" elements\nnamesArray = xmldoc.getElementsByTagName(\"name\")\n\n\nimport xml.etree.ElementTree as ET\n\nxml = open('inventory.xml').read()\ndoc = ET.fromstring(xml)\n\ndoc = ET.parse('inventory.xml')  # or load it directly\n\n# Note, ElementTree's root is the top level element. So you need \".//\" to really start searching from top\n\n# Return first Item\nitem1 = doc.find(\"section/item\")  # or \".//item\"\n\n# Print each price\nfor p in doc.findall(\"section/item/price\"):  # or \".//price\"\n    print \"{0:0.2f}\".format(float(p.text))  # could raise exception on missing text or invalid float() conversion\n\n# list of names\nnames = doc.findall(\"section/item/name\")  # or \".//name\"\n\n\nfrom lxml import etree\n\nxml = open('inventory.xml').read()\ndoc = etree.fromstring(xml)\n\ndoc = etree.parse('inventory.xml')  # or load it directly\n\n# Return first item\nitem1 = doc.xpath(\"//section[1]/item[1]\")\n\n# Print each price\nfor p in doc.xpath(\"//price\"):\n    print \"{0:0.2f}\".format(float(p.text))  # could raise exception on missing text or invalid float() conversion\n\nnames = doc.xpath(\"//name\")  # list of names\n\n", "explain": "In Python 2.5+ you can use ElementTree's limited XPath support\nOr, you can install the lxml package and get full XPath support\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "C", "code": "\nLibrary: LibXML\n\n#include <libxml/parser.h>\n#include <libxml/xpath.h>\n\nxmlDocPtr getdoc (char *docname) {\n\txmlDocPtr doc;\n\tdoc = xmlParseFile(docname);\n\n\treturn doc;\n}\n\nxmlXPathObjectPtr getnodeset (xmlDocPtr doc, xmlChar *xpath){\n\t\n\txmlXPathContextPtr context;\n\txmlXPathObjectPtr result;\n\n\tcontext = xmlXPathNewContext(doc);\n\n\tresult = xmlXPathEvalExpression(xpath, context);\n\txmlXPathFreeContext(context);\n\n\treturn result;\n}\n\nint main(int argc, char **argv) {\n\n\tif (argc <= 2) {\n\t\tprintf(\"Usage: %s <XML Document Name> <XPath expression>\\n\", argv[0]);\n\t\treturn 0;\n\t}\n\t\n\tchar *docname;\n\txmlDocPtr doc;\n\txmlChar *xpath = (xmlChar*) argv[2];\n\txmlNodeSetPtr nodeset;\n\txmlXPathObjectPtr result;\n\tint i;\n\txmlChar *keyword;\n\n\tdocname = argv[1];\n\tdoc = getdoc(docname);\n\tresult = getnodeset (doc, xpath);\n\tif (result) {\n\t\tnodeset = result->nodesetval;\n\t\tfor (i=0; i < nodeset->nodeNr; i++) {\n\t\txmlNodePtr titleNode = nodeset->nodeTab[i];\n\t\tkeyword = xmlNodeListGetString(doc, titleNode->xmlChildrenNode, 1);\n\t\tprintf(\"Value %d: %s\\n\",i+1, keyword);\n\t\txmlFree(keyword);\n\t\t}\n\t\txmlXPathFreeObject (result);\n\t}\n\txmlFreeDoc(doc);\n\txmlCleanupParser();\n\treturn 0;\n}\n\n\nC:\\rosettaCode>xPather.exe testXML.xml //price\nValue 1: 14.50\nValue 2: 23.99\nValue 3: 4.95\nValue 4: 3.56\n\nC:\\rosettaCode>xPather.exe testXML.xml //name\nValue 1: Invisibility Cream\nValue 2: Levitation Salve\nValue 3: Blork and Freen Instameal\nValue 4: Grob winglets\n\n", "explain": "Takes XML document and XPath expression as inputs and prints results, usage is printed if invoked incorrectly.\ntestXML.xml contains the XML mentioned in the task description. Code must be compiled with the correct flags.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "C++", "code": "\n\nLibrary: LibXML\n#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <stdexcept>\n#include <utility>\n#include <vector>\n\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <libxml/xmlerror.h>\n#include <libxml/xmlstring.h>\n#include <libxml/xmlversion.h>\n#include <libxml/xpath.h>\n\n#ifndef LIBXML_XPATH_ENABLED\n#   error libxml was not configured with XPath support\n#endif\n\n// Because libxml2 is a C library, we need a couple things to make it work\n// well with modern C++:\n//   1) a ScopeGuard-like type to handle cleanup functions; and\n//   2) an exception type that transforms the library's errors.\n\n// ScopeGuard-like type to handle C library cleanup functions.\ntemplate <typename F>\nclass [[nodiscard]] scope_exit\n{\npublic:\n    // C++20: Constructor can (and should) be [[nodiscard]].\n    /*[[nodiscard]]*/ constexpr explicit scope_exit(F&& f) :\n        f_{std::move(f)}\n    {}\n\n    ~scope_exit()\n    {\n        f_();\n    }\n\n    // Non-copyable, non-movable.\n    scope_exit(scope_exit const&) = delete;\n    scope_exit(scope_exit&&) = delete;\n    auto operator=(scope_exit const&) -> scope_exit& = delete;\n    auto operator=(scope_exit&&) -> scope_exit& = delete;\n\nprivate:\n    F f_;\n};\n\n// Exception that gets last libxml2 error.\nclass libxml_error : public std::runtime_error\n{\npublic:\n    libxml_error() : libxml_error(std::string{}) {}\n\n    explicit libxml_error(std::string message) :\n        std::runtime_error{make_message_(std::move(message))}\n    {}\n\nprivate:\n    static auto make_message_(std::string message) -> std::string\n    {\n        if (auto const last_error = ::xmlGetLastError(); last_error)\n        {\n            if (not message.empty())\n                message += \": \";\n            message += last_error->message;\n        }\n\n        return message;\n    }\n};\n\nauto main() -> int\n{\n    try\n    {\n        // Initialize libxml.\n        ::xmlInitParser();\n        LIBXML_TEST_VERSION\n        auto const libxml_cleanup = scope_exit{[] { ::xmlCleanupParser(); }};\n\n        // Load and parse XML document.\n        auto const doc = ::xmlParseFile(\"test.xml\");\n        if (not doc)\n            throw libxml_error{\"failed to load document\"};\n        auto const doc_cleanup = scope_exit{[doc] { ::xmlFreeDoc(doc); }};\n\n        // Create XPath context for document.\n        auto const xpath_context = ::xmlXPathNewContext(doc);\n        if (not xpath_context)\n            throw libxml_error{\"failed to create XPath context\"};\n        auto const xpath_context_cleanup = scope_exit{[xpath_context]\n            { ::xmlXPathFreeContext(xpath_context); }};\n\n        // Task 1 ============================================================\n        {\n            std::cout << \"Task 1:\\n\";\n\n            auto const xpath =\n                reinterpret_cast<::xmlChar const*>(u8\"//item[1]\");\n\n            // Create XPath object (same for every task).\n            auto xpath_obj = ::xmlXPathEvalExpression(xpath, xpath_context);\n            if (not xpath_obj)\n                throw libxml_error{\"failed to evaluate XPath\"};\n            auto const xpath_obj_cleanup = scope_exit{[xpath_obj]\n                { ::xmlXPathFreeObject(xpath_obj); }};\n\n            // 'result' a xmlNode* to the desired node, or nullptr if it\n            // doesn't exist. If not nullptr, the node is owned by 'doc'.\n            auto const result = xmlXPathNodeSetItem(xpath_obj->nodesetval, 0);\n            if (result)\n                std::cout << '\\t' << \"node found\" << '\\n';\n            else\n                std::cout << '\\t' << \"node not found\" << '\\n';\n        }\n\n        // Task 2 ============================================================\n        {\n            std::cout << \"Task 2:\\n\";\n\n            auto const xpath =\n                reinterpret_cast<::xmlChar const*>(u8\"//price/text()\");\n\n            // Create XPath object (same for every task).\n            auto xpath_obj = ::xmlXPathEvalExpression(xpath, xpath_context);\n            if (not xpath_obj)\n                throw libxml_error{\"failed to evaluate XPath\"};\n            auto const xpath_obj_cleanup = scope_exit{[xpath_obj]\n                { ::xmlXPathFreeObject(xpath_obj); }};\n\n            // Printing the results.\n            auto const count =\n                xmlXPathNodeSetGetLength(xpath_obj->nodesetval);\n            for (auto i = decltype(count){0}; i < count; ++i)\n            {\n                auto const node =\n                    xmlXPathNodeSetItem(xpath_obj->nodesetval, i);\n                assert(node);\n\n                auto const content = XML_GET_CONTENT(node);\n                assert(content);\n\n                // Note that reinterpret_cast here is a Bad Idea, because\n                // 'content' is UTF-8 encoded, which may or may not be the\n                // encoding cout expects. A *PROPER* solution would translate\n                // content to the correct encoding (or at least verify that\n                // UTF-8 *is* the correct encoding).\n                //\n                // But this \"works\" well enough for illustration.\n                std::cout << \"\\n\\t\" << reinterpret_cast<char const*>(content);\n            }\n\n            std::cout << '\\n';\n        }\n\n        // Task 3 ============================================================\n        {\n            std::cout << \"Task 3:\\n\";\n\n            auto const xpath =\n                reinterpret_cast<::xmlChar const*>(u8\"//name\");\n\n            // Create XPath object (same for every task).\n            auto xpath_obj = ::xmlXPathEvalExpression(xpath, xpath_context);\n            if (not xpath_obj)\n                throw libxml_error{\"failed to evaluate XPath\"};\n            auto const xpath_obj_cleanup = scope_exit{[xpath_obj]\n                { ::xmlXPathFreeObject(xpath_obj); }};\n\n            // 'results' is a vector of pointers to the result nodes. The\n            // nodes pointed to are owned by 'doc'.\n            auto const results = [ns=xpath_obj->nodesetval]()\n            {\n                auto v = std::vector<::xmlNode*>{};\n                if (ns && ns->nodeTab)\n                    v.assign(ns->nodeTab, ns->nodeTab + ns->nodeNr);\n                return v;\n            }();\n            std::cout << '\\t' << \"set of \" << results.size()\n                << \" node(s) found\" << '\\n';\n        }\n    }\n    catch (std::exception const& x)\n    {\n        std::cerr << \"ERROR: \" << x.what() << '\\n';\n        return EXIT_FAILURE;\n    }\n}\n\n", "explain": "The following code uses each of the three tasks given to demonstrate a different method of handling the resulting node set from an XPath query.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Java", "code": "\nimport java.io.StringReader;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.xpath.XPath;\nimport javax.xml.xpath.XPathConstants;\nimport javax.xml.xpath.XPathFactory;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Node;\nimport org.w3c.dom.NodeList;\nimport org.xml.sax.InputSource;\n\npublic class XMLParser {\n\tfinal static String xmlStr = \n\t\t\t  \"<inventory title=\\\"OmniCorp Store #45x10^3\\\">\"\n\t\t\t+ \"  <section name=\\\"health\\\">\"\n\t\t\t+ \"    <item upc=\\\"123456789\\\" stock=\\\"12\\\">\"\n\t\t\t+ \"      <name>Invisibility Cream</name>\"\n\t\t\t+ \"      <price>14.50</price>\"\n\t\t\t+ \"      <description>Makes you invisible</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"445322344\\\" stock=\\\"18\\\">\"\n\t\t\t+ \"      <name>Levitation Salve</name>\"\n\t\t\t+ \"      <price>23.99</price>\"\n\t\t\t+ \"      <description>Levitate yourself for up to 3 hours per application</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\"\n\t\t\t+ \"  <section name=\\\"food\\\">\"\n\t\t\t+ \"    <item upc=\\\"485672034\\\" stock=\\\"653\\\">\"\n\t\t\t+ \"      <name>Blork and Freen Instameal</name>\"\n\t\t\t+ \"      <price>4.95</price>\"\n\t\t\t+ \"      <description>A tasty meal in a tablet; just add water</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"    <item upc=\\\"132957764\\\" stock=\\\"44\\\">\"\n\t\t\t+ \"      <name>Grob winglets</name>\"\n\t\t\t+ \"      <price>3.56</price>\"\n\t\t\t+ \"      <description>Tender winglets of Grob. Just add priwater</description>\"\n\t\t\t+ \"    </item>\"\n\t\t\t+ \"  </section>\" \n\t\t\t+ \"</inventory>\";\n\n\tpublic static void main(String[] args) {\n\t\ttry {\n\t\t\tDocument doc = DocumentBuilderFactory.newInstance()\n\t\t\t\t\t.newDocumentBuilder()\n\t\t\t\t\t.parse(new InputSource(new StringReader(xmlStr)));\n\t\t\tXPath xpath = XPathFactory.newInstance().newXPath();\n\t\t\t// 1\n\t\t\tSystem.out.println(((Node) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item[1]\", doc, XPathConstants.NODE))\n\t\t\t\t\t.getAttributes().getNamedItem(\"upc\"));\n\t\t\t// 2, 3\n\t\t\tNodeList nodes = (NodeList) xpath.evaluate(\n\t\t\t\t\t\"/inventory/section/item/price\", doc,\n\t\t\t\t\tXPathConstants.NODESET);\n\t\t\tfor (int i = 0; i < nodes.getLength(); i++)\n\t\t\t\tSystem.out.println(nodes.item(i).getTextContent());\n\t\t} catch (Exception e) {\n\t\t\tSystem.out.println(\"Error ocurred while parsing XML.\");\n\t\t}\n\t}\n}\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "C#", "code": "\nXmlReader XReader;\n \n// Either read the xml from a string ...\nXReader = XmlReader.Create(new StringReader(\"<inventory title=... </inventory>\"));\n \n// ... or read it from the file system.\nXReader = XmlReader.Create(\"xmlfile.xml\");\n \n// Create a XPathDocument object (which implements the IXPathNavigable interface)\n// which is optimized for XPath operation. (very fast).\nIXPathNavigable XDocument = new XPathDocument(XReader);\n \n// Create a Navigator to navigate through the document.\nXPathNavigator Nav = XDocument.CreateNavigator();\nNav = Nav.SelectSingleNode(\"//item\");\n \n// Move to the first element of the selection. (if available).\nif(Nav.MoveToFirst())\n{\n  Console.WriteLine(Nav.OuterXml); // The outer xml of the first item element.\n}\n \n// Get an iterator to loop over multiple selected nodes.\nXPathNodeIterator Iterator = XDocument.CreateNavigator().Select(\"//price\");\n \nwhile (Iterator.MoveNext())\n{\n  Console.WriteLine(Iterator.Current.Value);\n}\n \nIterator = XDocument.CreateNavigator().Select(\"//name\");\n \n// Use a generic list.\nList<string> NodesValues = new List<string>();\n \nwhile (Iterator.MoveNext())\n{\n  NodesValues.Add(Iterator.Current.Value);\n}\n \n// Convert the generic list to an array and output the count of items.\nConsole.WriteLine(NodesValues.ToArray().Length);\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "JavaScript", "code": "\nWorks with: Firefox version 2.0\n//create XMLDocument object from file\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'file.xml', false);\nxhr.send(null);\nvar doc = xhr.responseXML;\n\n//get first <item> element\nvar firstItem = doc.evaluate( '//item[1]', doc, null, XPathResult.FIRST_ORDERED_NODE_TYPE, null ).singleNodeValue;\nalert( firstItem.textContent );\n\n//output contents of <price> elements\nvar prices = doc.evaluate( '//price', doc, null, XPathResult.ANY_TYPE, null );\nfor( var price = prices.iterateNext(); price != null; price = prices.iterateNext() ) {\n  alert( price.textContent );\n}\n\n//add <name> elements to array\nvar names = doc.evaluate( '//name', doc, null, XPathResult.ANY_TYPE, null);\nvar namesArray = [];\nfor( var name = names.iterateNext(); name != null; name = names.iterateNext() ) {\n  namesArray.push( name );\n}\nalert( namesArray );\n\n\n//create XML object from file\nvar xhr = new XMLHttpRequest();\nxhr.open('GET', 'file.xml', false);\nxhr.send(null);\nvar doc = new XML(xhr.responseText);\n\n//get first <item> element\nvar firstItem = doc..item[0];\nalert( firstItem );\n\n//output contents of <price> elements\nfor each( var price in doc..price ) {\n  alert( price );\n}\n\n//add <name> elements to array\nvar names = [];\nfor each( var name in doc..name ) {\n  names.push( name );\n}\nalert( names );\n\n", "explain": "Although some browsers support XPath, working with XML is much easier with E4X.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Visual_Basic_.NET", "code": "\nDim first_item = xml.XPathSelectElement(\"//item\")\nConsole.WriteLine(first_item)\n \nFor Each price In xml.XPathSelectElements(\"//price\")\n    Console.WriteLine(price.Value)\nNext\n \nDim names = (From item In xml.XPathSelectElements(\"//name\") Select item.Value).ToArray\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "PHP", "code": "\n<?php\n//PHP5 only example due to changes in XML extensions between version 4 and 5 (Tested on PHP5.2.0)\n$doc = DOMDocument::loadXML('<inventory title=\"OmniCorp Store #45x10^3\">...</inventory>');\n//Load from file instead with $doc = DOMDocument::load('filename');\n$xpath = new DOMXPath($doc);\n/* \n    1st Task: Retrieve the first \"item\" element\n*/\n$nodelist = $xpath->query('//item');\n$result = $nodelist->item(0);\n/* \n    2nd task: Perform an action on each \"price\" element (print it out)\n*/\n$nodelist = $xpath->query('//price');\nfor($i = 0; $i < $nodelist->length; $i++)\n{\n  //print each price element in the DOMNodeList instance, $nodelist, as text/xml followed by a newline\n  print $doc->saveXML($nodelist->item($i)).\"\\n\";\n}\n/* \n    3rd Task: Get an array of all the \"name\" elements\n*/\n$nodelist = $xpath->query('//name');\n//our array to hold all the name elements, though in practice you'd probably not need to do this and simply use the DOMNodeList\n$result = array(); \n//a different way of iterating through the DOMNodeList\nforeach($nodelist as $node)\n{\n  $result[] = $node; \n}\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Go", "code": "\n\npackage main\n\nimport (\n\t\"encoding/xml\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n)\n\ntype Inventory struct {\n\tXMLName  xml.Name `xml:\"inventory\"`\n\tTitle    string   `xml:\"title,attr\"`\n\tSections []struct {\n\t\tXMLName xml.Name `xml:\"section\"`\n\t\tName    string   `xml:\"name,attr\"`\n\t\tItems   []struct {\n\t\t\tXMLName     xml.Name `xml:\"item\"`\n\t\t\tName        string   `xml:\"name\"`\n\t\t\tUPC         string   `xml:\"upc,attr\"`\n\t\t\tStock       int      `xml:\"stock,attr\"`\n\t\t\tPrice       float64  `xml:\"price\"`\n\t\t\tDescription string   `xml:\"description\"`\n\t\t} `xml:\"item\"`\n\t} `xml:\"section\"`\n}\n\n// To simplify main's error handling\nfunc printXML(s string, v interface{}) {\n\tfmt.Println(s)\n\tb, err := xml.MarshalIndent(v, \"\", \"\\t\")\n\tif err != nil {\n\t\tlog.Fatal(err)\n\t}\n\tfmt.Println(string(b))\n\tfmt.Println()\n}\n\nfunc main() {\n\tfmt.Println(\"Reading XML from standard input...\")\n\n\tvar inv Inventory\n\tdec := xml.NewDecoder(os.Stdin)\n\tif err := dec.Decode(&inv); err != nil {\n\t\tlog.Fatal(err)\n\t}\n\n\t// At this point, inv is Go struct with all the fields filled\n\t// in from the XML data. Well-formed XML input that doesn't\n\t// match the specification of the fields in the Go struct are\n\t// discarded without error.\n\n\t// We can reformat the parts we parsed:\n\t//printXML(\"Got:\", inv)\n\n\t// 1. Retrieve first item:\n\titem := inv.Sections[0].Items[0]\n\tfmt.Println(\"item variable:\", item)\n\tprintXML(\"As XML:\", item)\n\n\t// 2. Action on each price:\n\tfmt.Println(\"Prices:\")\n\tvar totalValue float64\n\tfor _, s := range inv.Sections {\n\t\tfor _, i := range s.Items {\n\t\t\tfmt.Println(i.Price)\n\t\t\ttotalValue += i.Price * float64(i.Stock)\n\t\t}\n\t}\n\tfmt.Println(\"Total inventory value:\", totalValue)\n\tfmt.Println()\n\n\t// 3. Slice of all the names:\n\tvar names []string\n\tfor _, s := range inv.Sections {\n\t\tfor _, i := range s.Items {\n\t\t\tnames = append(names, i.Name)\n\t\t}\n\t}\n\tfmt.Printf(\"names: %q\\n\", names)\n}\n\n\nOutput:\nReading XML from standard input...\nitem variable: {{ item} Invisibility Cream 123456789 12 14.5 Makes you invisible}\nAs XML:\n<item upc=\"123456789\" stock=\"12\">\n\t<name>Invisibility Cream</name>\n\t<price>14.5</price>\n\t<description>Makes you invisible</description>\n</item>\n\nPrices:\n14.5\n23.99\n4.95\n3.56\nTotal inventory value: 3994.81\n\nnames: [\"Invisibility Cream\" \"Levitation Salve\" \"Blork and Freen Instameal\" \"Grob winglets\"]\n\nLibrary: xmlpath\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n\n    \"launchpad.net/xmlpath\"\n)\n\nfunc main() {\n    f, err := os.Open(\"test3.xml\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    n, err := xmlpath.Parse(f)\n    f.Close()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    q1 := xmlpath.MustCompile(\"//item\")\n    if _, ok := q1.String(n); !ok {\n        fmt.Println(\"no item\")\n    }\n    q2 := xmlpath.MustCompile(\"//price\")\n    for it := q2.Iter(n); it.Next(); {\n        fmt.Println(it.Node())\n    }\n    q3 := xmlpath.MustCompile(\"//name\")\n    names := []*xmlpath.Node{}\n    for it := q3.Iter(n); it.Next(); {\n        names = append(names, it.Node())\n    }\n    if len(names) == 0 {\n        fmt.Println(\"no names\")\n    }\n}\n\n\nOutput:\n14.50\n23.99\n4.95\n3.56\n\n", "explain": "Using the standard encoding/xml package:\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program xpathXml.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n.equ NBMAXELEMENTS,    100\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure xmlNode*/\n    .struct  0\nxmlNode_private:                         @ application data\n    .struct  xmlNode_private + 4 \nxmlNode_type:                            @ type number, must be second\u00a0!\n    .struct  xmlNode_type + 4 \nxmlNode_name:                            @ the name of the node, or the entity\n    .struct  xmlNode_name + 4 \nxmlNode_children:                        @ parent->childs link\n    .struct  xmlNode_children + 4 \nxmlNode_last:                            @ last child link\n    .struct  xmlNode_last + 4 \nxmlNode_parent:                          @ child->parent link \n    .struct  xmlNode_parent + 4 \nxmlNode_next:                            @ next sibling link\n    .struct  xmlNode_next + 4 \nxmlNode_prev:                            @ previous sibling link \n    .struct  xmlNode_prev + 4 \nxmlNode_doc:                             @ the containing document\n    .struct  xmlNode_doc + 4 \nxmlNode_ns:                              @ pointer to the associated namespace\n    .struct  xmlNode_ns + 4 \nxmlNode_content:                         @ the content\n    .struct  xmlNode_content + 4 \nxmlNode_properties:                      @ properties list\n    .struct  xmlNode_properties + 4\nxmlNode_nsDef:                           @ namespace definitions on this node \n    .struct  xmlNode_nsDef + 4\nxmlNode_psvi:                            @ for type/PSVI informations\n    .struct  xmlNode_psvi + 4\nxmlNode_line:                            @ line number\n    .struct  xmlNode_line + 4\nxmlNode_extra:                           @ extra data for XPath/XSLT\n    .struct  xmlNode_extra + 4\nxmlNode_fin:\n/********************************************/\n/* structure xmlNodeSet*/\n    .struct  0\nxmlNodeSet_nodeNr:                       @ number of nodes in the set\n    .struct  xmlNodeSet_nodeNr + 4 \nxmlNodeSet_nodeMax:                      @ size of the array as allocated \n    .struct  xmlNodeSet_nodeMax + 4 \nxmlNodeSet_nodeTab:                      @ array of nodes in no particular order\n    .struct  xmlNodeSet_nodeTab + 4 \nxmlNodeSet_fin:\n/********************************************/\n/* structure xmlXPathObject*/\n    .struct  0\nxmlPathObj_type:                         @\n    .struct  xmlPathObj_type + 4 \nxmlPathObj_nodesetval:                   @\n    .struct  xmlPathObj_nodesetval + 4 \nxmlPathObj_boolval:                      @\n    .struct  xmlPathObj_boolval + 4 \nxmlPathObj_floatval:                     @\n    .struct  xmlPathObj_floatval + 4 \nxmlPathObj_stringval:                    @\n    .struct  xmlPathObj_stringval + 4 \nxmlPathObj_user:                         @\n    .struct  xmlPathObj_user + 4 \nxmlPathObj_index:                        @\n    .struct  xmlPathObj_index + 4 \nxmlPathObj_user2:                        @\n    .struct  xmlPathObj_user2 + 4 \nxmlPathObj_index2:                       @\n    .struct  xmlPathObj_index2 + 4 \n\n\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessEndpgm:      .asciz \"\\nNormal end of program.\\n\" \nszMessDisVal:      .asciz \"\\nDisplay set values.\\n\" \nszMessDisArea:     .asciz \"\\nDisplay area values.\\n\" \nszFileName:        .asciz \"testXml.xml\" \nszMessError:       .asciz \"Error detected\u00a0!!!!. \\n\"\n\n\nszLibName:         .asciz \"name\"\nszLibPrice:        .asciz \"//price\"\nszLibExtName:      .asciz \"//name\"\nszCarriageReturn:  .asciz \"\\n\"\n\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n.align 4\ntbExtract:          .skip 4 * NBMAXELEMENTS      @ result extract area\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                     @ entry of program \n    ldr r0,iAdrszFileName \n    bl xmlParseFile                       @ create doc\n    mov r9,r0                             @ doc address\n    mov r0,r9                             @ doc\n    bl xmlDocGetRootElement               @ get root\n    bl xmlFirstElementChild               @ get first section\n    bl xmlFirstElementChild               @ get first item\n    bl xmlFirstElementChild               @ get first name\n    bl xmlNodeGetContent                  @ extract content\n    bl affichageMess                      @ for display\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n\n    ldr r0,iAdrszMessDisVal\n    bl affichageMess\n    mov r0,r9\n    ldr r1,iAdrszLibPrice                  @ extract prices\n    bl extractValue\n    mov r0,r9\n    ldr r1,iAdrszLibExtName                @ extact names\n    bl extractValue\n    ldr r0,iAdrszMessDisArea\n    bl affichageMess\n    mov r4,#0                              @ display string result area\n    ldr r5,iAdrtbExtract\n1:\n    ldr r0,[r5,r4,lsl #2]\n    cmp r0,#0\n    beq 2f\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    add r4,#1\n    b 1b\n\n2:\n    mov r0,r9\n    bl xmlFreeDoc\n    bl xmlCleanupParser\n    ldr r0,iAdrszMessEndpgm\n    bl affichageMess\n    b 100f\n99:\n    @ error\n    ldr r0,iAdrszMessError\n    bl affichageMess       \n100:                                       @ standard end of the program \n    mov r0, #0                             @ return code\n    mov r7, #EXIT                          @ request to exit program\n    svc #0                                 @ perform the system call\n\niAdrszMessError:          .int szMessError\niAdrszMessEndpgm:         .int szMessEndpgm\niAdrszLibName:            .int szLibName\niAdrszLibPrice:           .int szLibPrice\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszFileName:           .int szFileName\niAdrszLibExtName:         .int szLibExtName\niAdrtbExtract:            .int tbExtract\niAdrszMessDisVal:          .int szMessDisVal\niAdrszMessDisArea:         .int szMessDisArea\n/******************************************************************/\n/*     extract value of set                                       */ \n/******************************************************************/\n/* r0 contains the doc address\n/* r1 contains the address of the libel to extract */\nextractValue:\n    push {r1-r10,lr}                     @ save  registres\n    mov r4,r1                            @ save address libel\n    mov r9,r0                            @ save doc\n    ldr r8,iAdrtbExtract\n    bl xmlXPathNewContext                @ create context\n    mov r10,r0\n    mov r1,r0\n    mov r0,r4\n    bl xmlXPathEvalExpression\n    mov r5,r0\n    mov r0,r10\n    bl xmlXPathFreeContext               @ free context\n    cmp r5,#0\n    beq 100f\n    ldr r4,[r5,#xmlPathObj_nodesetval]   @ values set\n    ldr r6,[r4,#xmlNodeSet_nodeNr]       @ set size\n    mov r7,#0                            @ index\n    ldr r4,[r4,#xmlNodeSet_nodeTab]      @ area of nods\n1:                                       @ start loop \n    ldr r3,[r4,r7,lsl #2]                @ load node\n    mov r0,r9\n    ldr r1,[r3,#xmlNode_children]        @ load string value\n    mov r2,#1\n    bl xmlNodeListGetString\n    str r0,[r8,r7,lsl #2]                @ store string pointer in area\n    bl affichageMess                     @ and display string result\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    add r7,#1\n    cmp r7,r6\n    blt 1b\n100:\n    pop {r1-r10,lr}                      @ restaur registers */ \n    bx lr                                @ return  \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                   @ save  registres\n    mov r2,#0                               @ counter length \n1:                                          @ loop length calculation \n    ldrb r1,[r0,r2]                         @ read octet start position + index \n    cmp r1,#0                               @ if 0 its over \n    addne r2,r2,#1                          @ else add 1 in the length \n    bne 1b                                  @ and loop \n                                            @ so here r2 contains the length of the message \n    mov r1,r0                               @ address message in r1 \n    mov r0,#STDOUT                          @ code to write to the standard output Linux \n    mov r7, #WRITE                          @ code call system \"write\" \n    svc #0                                  @ call systeme \n    pop {r0,r1,r2,r7,lr}                    @ restaur registers */ \n    bx lr                                   @ return\n\nOutput:\nInvisibility Cream\n\nDisplay set values.\n14.50\n23.99\n4.95\n3.56\nInvisibility Cream\nLevitation Salve\nBlork and Freen Instameal\nGrob winglets\n\nDisplay area values.\nInvisibility Cream\nLevitation Salve\nBlork and Freen Instameal\nGrob winglets\n\nNormal end of program.\n\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Delphi", "code": "\nprogram XMLXPath;\n\n{$APPTYPE CONSOLE}\n\nuses ActiveX, MSXML;\n\nconst\n  XML =\n    '<inventory title=\"OmniCorp Store #45x10^3\">' +\n    '  <section name=\"health\">' +\n    '    <item upc=\"123456789\" stock=\"12\">' +\n    '      <name>Invisibility Cream</name>' +\n    '      <price>14.50</price>' +\n    '      <description>Makes you invisible</description>' +\n    '    </item>' +\n    '    <item upc=\"445322344\" stock=\"18\">' +\n    '      <name>Levitation Salve</name>' +\n    '      <price>23.99</price>' +\n    '      <description>Levitate yourself for up to 3 hours per application</description>' +\n    '    </item>' +\n    '  </section>' +\n    '  <section name=\"food\">' +\n    '    <item upc=\"485672034\" stock=\"653\">' +\n    '      <name>Blork and Freen Instameal</name>' +\n    '      <price>4.95</price>' +\n    '      <description>A tasty meal in a tablet; just add water</description>' +\n    '    </item>' +\n    '    <item upc=\"132957764\" stock=\"44\">' +\n    '      <name>Grob winglets</name>' +\n    '      <price>3.56</price>' +\n    '      <description>Tender winglets of Grob. Just add water</description>' +\n    '    </item>' +\n    '  </section>' +\n    '</inventory>';\n\nvar\n  i: Integer;\n  s: string;\n  lXMLDoc: IXMLDOMDocument2;\n  lNodeList: IXMLDOMNodeList;\n  lNode: IXMLDOMNode;\n  lItemNames: array of string;\nbegin\n  CoInitialize(nil);\n  lXMLDoc := CoDOMDocument.Create;\n  lXMLDoc.setProperty('SelectionLanguage', 'XPath');\n  lXMLDoc.loadXML(XML);\n\n  Writeln('First item node:');\n  lNode := lXMLDoc.selectNodes('//item')[0];\n  Writeln(lNode.xml);\n  Writeln('');\n\n  lNodeList := lXMLDoc.selectNodes('//price');\n  for i := 0 to lNodeList.length - 1 do\n    Writeln('Price = ' + lNodeList[i].text);\n  Writeln('');\n\n  lNodeList := lXMLDoc.selectNodes('//item/name');\n  SetLength(lItemNames, lNodeList.length);\n  for i := 0 to lNodeList.length - 1 do\n    lItemNames[i] := lNodeList[i].text;\n  for s in lItemNames do\n    Writeln('Item name = ' + s);\nend.\n\n\nFirst item node:\n<item upc=\"123456789\" stock=\"12\">\n\t<name>Invisibility Cream</name>\n\t<price>14.50</price>\n\t<description>Makes you invisible</description>\n</item>\n\nPrice = 14.50\nPrice = 23.99\nPrice = 4.95\nPrice = 3.56\n\nItem name = Invisibility Cream\nItem name = Levitation Salve\nItem name = Blork and Freen Instameal\nItem name = Grob winglets\n\n", "explain": "Output:\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Ruby", "code": "\nLibrary: REXML\n#Example taken from the REXML tutorial (http://www.germane-software.com/software/rexml/docs/tutorial.html)\nrequire \"rexml/document\"\ninclude REXML\n#create the REXML Document from the string (%q is Ruby's multiline string, everything between the two @-characters is the string)\ndoc = Document.new(\n        %q@<inventory title=\"OmniCorp Store #45x10^3\">\n             ...\n           </inventory>\n          @\n                          )\n# The invisibility cream is the first <item>\ninvisibility = XPath.first( doc, \"//item\" ) \n# Prints out all of the prices\nXPath.each( doc, \"//price\") { |element| puts element.text }\n# Gets an array of all of the \"name\" elements in the document.\nnames = XPath.match( doc, \"//name\" )\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "R", "code": "\nLibrary: XML (R)\nlibrary(\"XML\")\ndoc <- xmlInternalTreeParse(\"test3.xml\")\n\n# Retrieve the first \"item\" element\ngetNodeSet(doc, \"//item\")[[1]]\n\n# Perform an action on each \"price\" element\nsapply(getNodeSet(doc, \"//price\"), xmlValue)\n\n# Get an array of all the \"name\" elements\nsapply(getNodeSet(doc, \"//name\"), xmlValue)\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Julia", "code": "\n\nusing LibExpat\n\nxdoc = raw\"\"\"<inventory title=\"OmniCorp Store #45x10^3\">\n  <section name=\"health\">\n    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\"445322344\" stock=\"18\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\"food\">\n    <item upc=\"485672034\" stock=\"653\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\"132957764\" stock=\"44\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>\n\"\"\"\n\ndebracket(s) = replace(s, r\".+\\>(.+)\\<.+\" => s\"\\1\") \n\netree = xp_parse(xdoc)\nfirstshow = LibExpat.find(etree, \"//item\")[1]\nprintln(\"The first item's node XML entry is:\\n\", firstshow, \"\\n\\n\")\n\nprices = LibExpat.find(etree, \"//price\")\nprintln(\"Prices:\")\nfor p in prices\n    println(\"\\t\", debracket(string(p)))\nend\nprintln(\"\\n\")\n\nnamearray = LibExpat.find(etree, \"//name\")\nprintln(\"Array of names of items:\\n\\t\", map(s -> debracket(string(s)), namearray))\n\nOutput:\n\nThe first item's node XML entry is:\n   <item upc=\"123456789\" stock=\"12\">\n     <name>Invisibility Cream</name>\n     <price>14.50</price>\n     <description>Makes you invisible</description>\n   </item>\n\n\n\nPrices:\n       14.50\n       23.99\n       4.95\n       3.56\n\n\n\nArray of names of items:\n       [\"Invisibility Cream\", \"Levitation Salve\", \"Blork and Freen Instameal\", \"Grob winglets\"]\n\n\n", "explain": "Uses the LibExpat module for XML pathing. The exercise description is very \nvague about output format, so this is varied in the solution below. The first \ntest prints the raw XML node, and the second and third are further processed.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Kotlin", "code": "\n// version 1.1.3\n\nimport javax.xml.parsers.DocumentBuilderFactory\nimport org.xml.sax.InputSource\nimport java.io.StringReader\nimport javax.xml.xpath.XPathFactory\nimport javax.xml.xpath.XPathConstants\nimport org.w3c.dom.Node\nimport org.w3c.dom.NodeList\n\nval xml = \n\"\"\"\n<inventory title=\"OmniCorp Store #45x10^3\">\n  <section name=\"health\">\n    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\"445322344\" stock=\"18\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\"food\">\n    <item upc=\"485672034\" stock=\"653\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\"132957764\" stock=\"44\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>\n\"\"\"\n\nfun main(args: Array<String>) {\n    val dbFactory = DocumentBuilderFactory.newInstance()\n    val dBuilder  = dbFactory.newDocumentBuilder()\n    val xmlInput = InputSource(StringReader(xml))\n    val doc = dBuilder.parse(xmlInput)\n    val xpFactory = XPathFactory.newInstance()\n    val xPath = xpFactory.newXPath()\n\n    val qNode = xPath.evaluate(\"/inventory/section/item[1]\", doc, XPathConstants.NODE) as Node\n    val upc = qNode.attributes.getNamedItem(\"upc\")\n    val stock = qNode.attributes.getNamedItem(\"stock\")\n    println(\"For the first item\u00a0:  upc = ${upc.textContent} and stock = ${stock.textContent}\")\n\n    val qNodes = xPath.evaluate(\"/inventory/section/item/price\", doc, XPathConstants.NODESET) as NodeList\n    print(\"\\nThe prices of each item are\u00a0: \")\n    for (i in 0 until qNodes.length) print(\"${qNodes.item(i).textContent}  \")\n    println()\n\n    val qNodes2 = xPath.evaluate(\"/inventory/section/item/name\", doc, XPathConstants.NODESET) as NodeList\n    val names = Array<String>(qNodes2.length) { qNodes2.item(it).textContent }\n    println(\"\\nThe names of each item are as follows\u00a0:\")\n    println(\"  ${names.joinToString(\"\\n  \")}\")\n}\n\n\nOutput:\nFor the first item\u00a0:  upc = 123456789 and stock = 12\n\nThe prices of each item are\u00a0: 14.50  23.99  4.95  3.56  \n\nThe names of each item are as follows\u00a0:\n  Invisibility Cream\n  Levitation Salve\n  Blork and Freen Instameal\n  Grob winglets\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Perl", "code": "\nLibrary: XML::XPathXPath\nuse XML::XPath qw();\n\nmy $x = XML::XPath->new('<inventory ... </inventory>');\n\n[$x->findnodes('//item[1]')->get_nodelist]->[0];\nprint $x->findnodes_as_string('//price');\n$x->findnodes('//name')->get_nodelist;\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Lua", "code": "\n\nrequire 'lxp'\ndata = [[<inventory title=\"OmniCorp Store #45x10^3\">\n  <section name=\"health\">\n    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\"445322344\" stock=\"18\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\"food\">\n    <item upc=\"485672034\" stock=\"653\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\"132957764\" stock=\"44\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>]]\nlocal first = true\nlocal names, prices = {}, {}\np = lxp.new({StartElement = function (parser, name)\n\tlocal a, b, c = parser:pos() --line, offset, pos\n\tif name == 'item' and first then \n\t\tprint(data:match('.-</item>', c - b + 1))\n\t\tfirst = false\n\tend\n\tif name == 'name' then names[#names+1] = data:match('>(.-)<', c) end\n\tif name == 'price' then prices[#prices+1] = data:match('>(.-)<', c) end\nend})\n\np:parse(data)\np:close()\n\nprint('Name: ', table.concat(names, ', '))\nprint('Price: ', table.concat(prices, ', '))\n\nOutput:    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\nName: \tInvisibility Cream, Levitation Salve, Blork and Freen Instameal, Grob winglets\nPrice: \t14.50, 23.99, 4.95, 3.56\n\n", "explain": "Requires LuaExpat\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Scala", "code": "\n\nscala> val xml: scala.xml.Elem =\n     | <inventory title=\"OmniCorp Store #45x10^3\">\n     |   <section name=\"health\">\n     |     <item upc=\"123456789\" stock=\"12\">\n     |       <name>Invisibility Cream</name>\n     |       <price>14.50</price>\n     |       <description>Makes you invisible</description>\n     |     </item>\n     |     <item upc=\"445322344\" stock=\"18\">\n     |       <name>Levitation Salve</name>\n     |       <price>23.99</price>\n     |       <description>Levitate yourself for up to 3 hours per application</description>\n     |     </item>\n     |   </section>\n     |   <section name=\"food\">\n     |     <item upc=\"485672034\" stock=\"653\">\n     |       <name>Blork and Freen Instameal</name>\n     |       <price>4.95</price>\n     |       <description>A tasty meal in a tablet; just add water</description>\n     |     </item>\n     |     <item upc=\"132957764\" stock=\"44\">\n     |       <name>Grob winglets</name>\n     |       <price>3.56</price>\n     |       <description>Tender winglets of Grob. Just add water</description>\n     |     </item>\n     |   </section>\n     | </inventory>\n\nscala> val firstItem = xml \\\\ \"item\" take 1\nfirstItem: scala.xml.NodeSeq =\nNodeSeq(<item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>)\n\nscala> xml \\\\ \"price\" map (_.text) foreach println\n14.50\n23.99\n4.95\n3.56\n\nscala> val names = (xml \\\\ \"name\").toArray\nnames: Array[scala.xml.Node] = Array(<name>Invisibility Cream</name>, <name>Levitation Salve</name>, <name>Blork and Freen Instameal</name>, <name>Grob winglets</name>)\n\n", "explain": "The code is entered in to Scala's REPL, to\nbetter show the results.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "D", "code": "\n\nLibrary: KXML\nimport kxml.xml;\nchar[]xmlinput =\n\"<inventory title=\\\"OmniCorp Store #45x10^3\\\">\n  <section name=\\\"health\\\">\n    <item upc=\\\"123456789\\\" stock=\\\"12\\\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\\\"445322344\\\" stock=\\\"18\\\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\\\"food\\\">\n    <item upc=\\\"485672034\\\" stock=\\\"653\\\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\\\"132957764\\\" stock=\\\"44\\\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>\n\";\nvoid main() {\n        auto root = readDocument(xmlinput);\n        auto firstitem = root.parseXPath(\"inventory/section/item\")[0];\n        foreach(price;root.parseXPath(\"inventory/section/item/price\")) {\n                std.stdio.writefln(\"%s\",price.getCData);\n        }\n        auto namearray = root.parseXPath(\"inventory/section/item/name\");\n}\n\n", "explain": "It is important to note that the KXML library currently only supports XPath minimally.\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Haskell", "code": "\nimport Data.List\nimport Control.Arrow\nimport Control.Monad\n\ntakeWhileIncl           :: (a -> Bool) -> [a] -> [a]\ntakeWhileIncl _ []      =  []\ntakeWhileIncl p (x:xs)\n            | p x       =  x : takeWhileIncl p xs\n            | otherwise =  [x] \n\ngetmultiLineItem n = takeWhileIncl(not.isInfixOf (\"</\" ++ n)). dropWhile(not.isInfixOf ('<': n))\ngetsingleLineItems n = map (takeWhile(/='<'). drop 1. dropWhile(/='>')). filter (isInfixOf ('<': n))\n\nmain = do\n  xml <- readFile \"./Rosetta/xmlpath.xml\"\n  let xmlText = lines xml\n      \n  putStrLn \"\\n== First item ==\\n\"\n  mapM_ putStrLn $ head $ unfoldr (Just. liftM2 (id &&&) (\\\\) (getmultiLineItem \"item\")) xmlText\n  \n  putStrLn \"\\n== Prices ==\\n\"\n  mapM_ putStrLn $ getsingleLineItems \"price\" xmlText\n  \n  putStrLn \"\\n== Names ==\\n\"\n  print $ getsingleLineItems \"name\" xmlText\n\n\n{-# LANGUAGE Arrows #-}\nimport Text.XML.HXT.Arrow\n{- For HXT version >= 9.0, use instead:\nimport Text.XML.HXT.Core\n-}\n\ndeepElem name = deep (isElem >>> hasName name)\n\nprocess = proc doc -> do\n  item <- single (deepElem \"item\") -< doc\n  _ <- listA (arrIO print <<< deepElem \"price\") -< doc\n  names <- listA (deepElem \"name\") -< doc\n  returnA -< (item, names)\n  \nmain = do\n  [(item, names)] <- runX (readDocument [] \"xmlpath.xml\" >>> process)\n  print item\n  print names\n\n", "explain": "Using the Haskell XML Toolkit (HXT):\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "VBScript", "code": "\nSet objXMLDoc = CreateObject(\"msxml2.domdocument\")\n\nobjXMLDoc.load(\"In.xml\")\n\nSet item_nodes = objXMLDoc.selectNodes(\"//item\")\ni = 1\nFor Each item In item_nodes\n\tIf i = 1 Then\n\t\tWScript.StdOut.Write item.xml\n\t\tWScript.StdOut.WriteBlankLines(2)\n\t\tExit For\n\tEnd If\nNext\n\nSet price_nodes = objXMLDoc.selectNodes(\"//price\")\nlist_price = \"\"\nFor Each price In price_nodes\n\tlist_price = list_price & price.text & \", \"\nNext\nWScript.StdOut.Write list_price\nWScript.StdOut.WriteBlankLines(2)\n\nSet name_nodes = objXMLDoc.selectNodes(\"//name\")\nlist_name = \"\"\nFor Each name In name_nodes\n\tlist_name = list_name & name.text & \", \"\nNext\nWScript.StdOut.Write list_name\nWScript.StdOut.WriteBlankLines(2)\n\n\nOutput:\n<item upc=\"123456789\" stock=\"12\">\n\t<name>Invisibility Cream</name>\n\t<price>14.50</price>\n\t<description>Makes you invisible</description>\n</item>\n\n14.50, 23.99, 4.95, 3.56, \n\nInvisibility Cream, Levitation Salve, Blork and Freen Instameal, Grob winglets, \n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "PowerShell", "code": "\n\n$document = [xml]@'\n<inventory title=\"OmniCorp Store #45x10^3\">\n  <section name=\"health\">\n    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\"445322344\" stock=\"18\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\"food\">\n    <item upc=\"485672034\" stock=\"653\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\"132957764\" stock=\"44\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>\n'@\n\n$query = \"/inventory/section/item\"\n$items = $document.SelectNodes($query)\n\n\n$items[0]\n\n\nOutput:\nupc        \u00a0: 123456789\nstock      \u00a0: 12\nname       \u00a0: Invisibility Cream\nprice      \u00a0: 14.50\ndescription\u00a0: Makes you invisible\n\n\n$namesAndPrices = $items | Select-Object -Property name, price\n$namesAndPrices\n\n\nOutput:\nname                      price\n----                      -----\nInvisibility Cream        14.50\nLevitation Salve          23.99\nBlork and Freen Instameal 4.95 \nGrob winglets             3.56 \n\n\n$items.price\n\n\nOutput:\n14.50\n23.99\n4.95\n3.56\n\n\n$items.name\n\n\nOutput:\nInvisibility Cream\nLevitation Salve\nBlork and Freen Instameal\nGrob winglets\n\n", "explain": "Cast the $document string as [xml] and you have access to .NET methods affecting XML.\nThe first item:\nGet some useful information:\nHere are the prices:\nHere are the names:\n"}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "ColdFusion", "code": "\n<cfsavecontent variable=\"xmlString\">\n<inventory\n...\n</inventory>\n</cfsavecontent>\n<cfset xml = xmlParse(xmlString)>\n<!--- First Task --->\n<cfset itemSearch = xmlSearch(xml, \"//item\")>\n<!--- item = the first Item (xml element object) --->\n<cfset item = itemSearch[1]>\n<!--- Second Task --->\n<cfset priceSearch = xmlSearch(xml, \"//price\")>\n<!--- loop and print each price --->\n<cfloop from=\"1\" to=\"#arrayLen(priceSearch)#\" index=\"i\">\n  #priceSearch[i].xmlText#<br/>\n</cfloop>\n<!--- Third Task --->\n<!--- array of all the name elements --->\n<cfset names = xmlSearch(xml, \"//name\")>\n<!--- visualize the results --->\n<cfdump var=\"#variables#\">\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "F#", "code": "\nopen System.IO\nopen System.Xml.XPath\n\nlet xml = new StringReader(\"\"\"\n<inventory title=\"OmniCorp Store #45x10^3\">\n  <section name=\"health\">\n    <item upc=\"123456789\" stock=\"12\">\n      <name>Invisibility Cream</name>\n      <price>14.50</price>\n      <description>Makes you invisible</description>\n    </item>\n    <item upc=\"445322344\" stock=\"18\">\n      <name>Levitation Salve</name>\n      <price>23.99</price>\n      <description>Levitate yourself for up to 3 hours per application</description>\n    </item>\n  </section>\n  <section name=\"food\">\n    <item upc=\"485672034\" stock=\"653\">\n      <name>Blork and Freen Instameal</name>\n      <price>4.95</price>\n      <description>A tasty meal in a tablet; just add water</description>\n    </item>\n    <item upc=\"132957764\" stock=\"44\">\n      <name>Grob winglets</name>\n      <price>3.56</price>\n      <description>Tender winglets of Grob. Just add water</description>\n    </item>\n  </section>\n</inventory>\n\"\"\")\n\nlet nav = XPathDocument(xml).CreateNavigator()\n\n// first \"item\"; throws if none exists\nlet item = nav.SelectSingleNode(@\"//item[1]\")\n\n// apply a operation (print text value) to all price elements\nfor price in nav.Select(@\"//price\") do\n    printfn \"%s\" (price.ToString())\n\n// array of all name elements\nlet names = seq { for name in nav.Select(@\"//name\") do yield name } |> Seq.toArray\n\n", "explain": ""}, {"task_name": "XML/XPath", "task_url": "https://rosettacode.org/wiki/XML/XPath", "task_cat": "XML", "lang": "Groovy", "code": "\ndef inventory = new XmlSlurper().parseText(\"<inventory...\")    //optionally parseText(new File(\"inv.xml\").text)\ndef firstItem = inventory.section.item[0]                      //1. first item\ninventory.section.item.price.each { println it }               //2. print each price\ndef allNamesArray = inventory.section.item.name.collect {it}   //3. collect item names into an array\n\n", "explain": ""}]