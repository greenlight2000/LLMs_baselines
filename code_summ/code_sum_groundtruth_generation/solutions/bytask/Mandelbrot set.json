[{"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Python", "code": "\n\n# Python 3.0+ and 2.5+\ntry:\n    from functools import reduce\nexcept:\n    pass\n\n\ndef mandelbrot(a):\n    return reduce(lambda z, _: z * z + a, range(50), 0)\n\ndef step(start, step, iterations):\n    return (start + (i * step) for i in range(iterations))\n\nrows = ((\"*\" if abs(mandelbrot(complex(x, y))) < 2 else \" \"\n        for x in step(-2.0, .0315, 80))\n        for y in step(1, -.05, 41))\n\nprint(\"\\n\".join(\"\".join(row) for row in rows))\n\nimport math\n\ndef mandelbrot(z , c , n=40):\n    if abs(z) > 1000:\n        return float(\"nan\")\n    elif n > 0:\n        return mandelbrot(z ** 2 + c, c, n - 1) \n    else:\n        return z ** 2 + c\n\nprint(\"\\n\".join([\"\".join([\"#\" if not math.isnan(mandelbrot(0, x + 1j * y).real) else \" \"\n                 for x in [a * 0.02 for a in range(-80, 30)]]) \n                 for y in [a * 0.05 for a in range(-20, 20)]])\n     )\n\nLibrary: matplotlib\nLibrary: NumPy\nfrom pylab import *\nfrom numpy import NaN\n\ndef m(a):\n\tz = 0\n\tfor n in range(1, 100):\n\t\tz = z**2 + a\n\t\tif abs(z) > 2:\n\t\t\treturn n\n\treturn NaN\n\nX = arange(-2, .5, .002)\nY = arange(-1,  1, .002)\nZ = zeros((len(Y), len(X)))\n\nfor iy, y in enumerate(Y):\n\tprint (iy, \"of\", len(Y))\n\tfor ix, x in enumerate(X):\n\t\tZ[iy,ix] = m(x + 1j * y)\n\nimshow(Z, cmap = plt.cm.prism, interpolation = 'none', extent = (X.min(), X.max(), Y.min(), Y.max()))\nxlabel(\"Re(c)\")\nylabel(\"Im(c)\")\nsavefig(\"mandelbrot_python.svg\")\nshow()\n\nimport matplotlib.pyplot as plt\nimport numpy as np\n\nnpts = 300\nmax_iter = 100\n\nX = np.linspace(-2, 1, 2 * npts)\nY = np.linspace(-1, 1, npts)\n\n#broadcast X to a square array\nC = X[:, None] + 1J * Y\n#initial value is always zero\nZ = np.zeros_like(C)\n\nexit_times = max_iter * np.ones(C.shape, np.int32)\nmask = exit_times > 0\n\nfor k in range(max_iter):\n    Z[mask] = Z[mask] * Z[mask] + C[mask]\n    mask, old_mask = abs(Z) < 2, mask\n    #use XOR to detect the area which has changed \n    exit_times[mask ^ old_mask] = k\n\nplt.imshow(exit_times.T,\n           cmap=plt.cm.prism,\n           extent=(X.min(), X.max(), Y.min(), Y.max()))\nplt.show()\nNormal Map Effect, Mercator Projection and Deep Zoom Images[edit]\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nd, h = 800, 500  # pixel density (= image width) and image height\nn, r = 200, 500  # number of iterations and escape radius (r > 2)\n\nx = np.linspace(0, 2, num=d+1)\ny = np.linspace(0, 2 * h / d, num=h+1)\n\nA, B = np.meshgrid(x - 1, y - h / d)\nC = 2.0 * (A + B * 1j) - 0.5\n\nZ, dZ = np.zeros_like(C), np.zeros_like(C)\nD, S, T = np.zeros(C.shape), np.zeros(C.shape), np.zeros(C.shape)\n\nfor k in range(n):\n    M = abs(Z) < r\n    S[M], T[M] = S[M] + np.exp(- abs(Z[M])), T[M] + 1\n    Z[M], dZ[M] = Z[M] ** 2 + C[M], 2 * Z[M] * dZ[M] + 1\n\nplt.imshow(S ** 0.1, cmap=plt.cm.twilight_shifted, origin=\"lower\")\nplt.savefig(\"Mandelbrot_set_1.png\", dpi=200)\n\nN = abs(Z) >= r  # normalized iteration count\nT[N] = T[N] - np.log2(np.log(np.abs(Z[N])) / np.log(r))\n\nplt.imshow(T ** 0.1, cmap=plt.cm.twilight_shifted, origin=\"lower\")\nplt.savefig(\"Mandelbrot_set_2.png\", dpi=200)\n\nN = abs(Z) > 2  # exterior distance estimation\nD[N] = np.log(abs(Z[N])) * abs(Z[N]) / abs(dZ[N])\n\nplt.imshow(D ** 0.1, cmap=plt.cm.twilight_shifted, origin=\"lower\")\nplt.savefig(\"Mandelbrot_set_3.png\", dpi=200)\n\nN, thickness = D > 0, 0.01  # boundary detection\nD[N] = np.maximum(1 - D[N] / thickness, 0)\n\nplt.imshow(D ** 2.0, cmap=plt.cm.binary, origin=\"lower\")\nplt.savefig(\"Mandelbrot_set_4.png\", dpi=200)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nd, h = 800, 500  # pixel density (= image width) and image height\nn, r = 200, 500  # number of iterations and escape radius (r > 2)\n\ndirection, height = 45, 1.5  # direction and height of the incoming light\nstripes, damping = 4.0, 2.0  # stripe density and damping parameter\n\nx = np.linspace(0, 2, num=d+1)\ny = np.linspace(0, 2 * h / d, num=h+1)\n\nA, B = np.meshgrid(x - 1, y - h / d)\nC = (2.0 + 1.0j) * (A + B * 1j) - 0.5\n\nZ, dZ, ddZ = np.zeros_like(C), np.zeros_like(C), np.zeros_like(C)\nD, S, T = np.zeros(C.shape), np.zeros(C.shape), np.zeros(C.shape)\n\nfor k in range(n):\n    M = abs(Z) < r\n    S[M], T[M] = S[M] + np.sin(stripes * np.angle(Z[M])), T[M] + 1\n    Z[M], dZ[M], ddZ[M] = Z[M] ** 2 + C[M], 2 * Z[M] * dZ[M] + 1, 2 * (dZ[M] ** 2 + Z[M] * ddZ[M])\n\nN = abs(Z) >= r  # basic normal map effect and stripe average coloring (potential function)\nP, Q = S[N] / T[N], (S[N] + np.sin(stripes * np.angle(Z[N]))) / (T[N] + 1)\nU, V = Z[N] / dZ[N], 1 + (np.log2(np.log(np.abs(Z[N])) / np.log(r)) * (P - Q) + Q) / damping\nU, v = U / abs(U), np.exp(direction / 180 * np.pi * 1j)  # unit normal vectors and light\nD[N] = np.maximum((U.real * v.real + U.imag * v.imag + V * height) / (1 + height), 0)\n\nplt.imshow(D ** 1.0, cmap=plt.cm.bone, origin=\"lower\")\nplt.savefig(\"Mandelbrot_normal_map_1.png\", dpi=200)\n\nN = abs(Z) > 2  # advanced normal map effect using higher derivatives (distance estimation)\nU = Z[N] * dZ[N] * ((1 + np.log(abs(Z[N]))) * np.conj(dZ[N] ** 2) - np.log(abs(Z[N])) * np.conj(Z[N] * ddZ[N]))\nU, v = U / abs(U), np.exp(direction / 180 * np.pi * 1j)  # unit normal vectors and light\nD[N] = np.maximum((U.real * v.real + U.imag * v.imag + height) / (1 + height), 0)\n\nplt.imshow(D ** 1.0, cmap=plt.cm.afmhot, origin=\"lower\")\nplt.savefig(\"Mandelbrot_normal_map_2.png\", dpi=200)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nd, h = 200, 1200  # pixel density (= image width) and image height\nn, r = 8000, 10000  # number of iterations and escape radius (r > 2)\n\na = -.743643887037158704752191506114774  # https://mathr.co.uk/web/m-location-analysis.html\nb = 0.131825904205311970493132056385139  # try: a, b, n = -1.748764520194788535, 3e-13, 800\n\nx = np.linspace(0, 2, num=d+1)\ny = np.linspace(0, 2 * h / d, num=h+1)\n\nA, B = np.meshgrid(x * np.pi, y * np.pi)\nC = 8.0 * np.exp((A + B * 1j) * 1j) + (a + b * 1j)\n\nZ, dZ = np.zeros_like(C), np.zeros_like(C)\nD = np.zeros(C.shape)\n\nfor k in range(n):\n    M = Z.real ** 2 + Z.imag ** 2 < r ** 2\n    Z[M], dZ[M] = Z[M] ** 2 + C[M], 2 * Z[M] * dZ[M] + 1\n\nN = abs(Z) > 2  # exterior distance estimation\nD[N] = np.log(abs(Z[N])) * abs(Z[N]) / abs(dZ[N])\n\nplt.imshow(D.T ** 0.05, cmap=plt.cm.nipy_spectral, origin=\"lower\")\nplt.savefig(\"Mercator_Mandelbrot_map.png\", dpi=200)\n\nX, Y = C.real, C.imag  # zoom images (adjust circle size 100 and zoom level 20 as needed)\nR, c, z = 100 * (2 / d) * np.pi * np.exp(- B), min(d, h) + 1, max(0, h - d) // 20\n\nfig, ax = plt.subplots(2, 2, figsize=(12, 12))\nax[0,0].scatter(X[1*z:1*z+c,0:d], Y[1*z:1*z+c,0:d], s=R[0:c,0:d]**2, c=D[1*z:1*z+c,0:d]**.5, cmap=plt.cm.nipy_spectral)\nax[0,1].scatter(X[2*z:2*z+c,0:d], Y[2*z:2*z+c,0:d], s=R[0:c,0:d]**2, c=D[2*z:2*z+c,0:d]**.4, cmap=plt.cm.nipy_spectral)\nax[1,0].scatter(X[3*z:3*z+c,0:d], Y[3*z:3*z+c,0:d], s=R[0:c,0:d]**2, c=D[3*z:3*z+c,0:d]**.3, cmap=plt.cm.nipy_spectral)\nax[1,1].scatter(X[4*z:4*z+c,0:d], Y[4*z:4*z+c,0:d], s=R[0:c,0:d]**2, c=D[4*z:4*z+c,0:d]**.2, cmap=plt.cm.nipy_spectral)\nplt.savefig(\"Mercator_Mandelbrot_zoom.png\", dpi=100)\n\nimport numpy as np\nimport matplotlib.pyplot as plt\n\nimport decimal as dc  # decimal floating point arithmetic with arbitrary precision\ndc.getcontext().prec = 80  # set precision to 80 digits (about 256 bits)\n\nd, h = 50, 1000  # pixel density (= image width) and image height\nn, r = 80000, 100000  # number of iterations and escape radius (r > 2)\n\na = dc.Decimal(\"-1.256827152259138864846434197797294538253477389787308085590211144291\")\nb = dc.Decimal(\".37933802890364143684096784819544060002129071484943239316486643285025\")\n\nS = np.zeros(n+1, dtype=np.complex128)\nu, v = dc.Decimal(0), dc.Decimal(0)\n\nfor k in range(n+1):\n    S[k] = float(u) + float(v) * 1j\n    if u ** 2 + v ** 2 < r ** 2:\n        u, v = u ** 2 - v ** 2 + a, 2 * u * v + b\n    else:\n        print(\"The reference sequence diverges within %s iterations.\"\u00a0% k)\n        break\n\nx = np.linspace(0, 2, num=d+1)\ny = np.linspace(0, 2 * h / d, num=h+1)\n\nA, B = np.meshgrid(x * np.pi, y * np.pi)\nC = 8.0 * np.exp((A + B * 1j) * 1j)\n\nE, Z, dZ = np.zeros_like(C), np.zeros_like(C), np.zeros_like(C)\nD, I, J = np.zeros(C.shape), np.zeros(C.shape, dtype=np.int64), np.zeros(C.shape, dtype=np.int64)\n\nfor k in range(n):\n    Z2 = Z.real ** 2 + Z.imag ** 2\n    M, R = Z2 < r ** 2, Z2 < E.real ** 2 + E.imag ** 2\n    E[R], I[R] = Z[R], J[R]  # rebase when z is closer to zero\n    E[M], I[M] = (2 * S[I[M]] + E[M]) * E[M] + C[M], I[M] + 1\n    Z[M], dZ[M] = S[I[M]] + E[M], 2 * Z[M] * dZ[M] + 1\n\nN = abs(Z) > 2  # exterior distance estimation\nD[N] = np.log(abs(Z[N])) * abs(Z[N]) / abs(dZ[N])\n\nplt.imshow(D.T ** 0.015, cmap=plt.cm.nipy_spectral, origin=\"lower\")\nplt.savefig(\"Mercator_Mandelbrot_deep_map.png\", dpi=200)\n\nPython - \"One liner\"[edit]\nprint(\n'\\n'.join(\n    ''.join(\n        ' *'[(z:=0, c:=x/50+y/50j, [z:=z*z+c for _ in range(99)], abs(z))[-1]<2]\n        for x in range(-100,25)\n    )\n    for y in range(-50,50)\n))\nPython - \"Functional\"[edit]\n\nfrom functools import reduce\n\ndef mandelbrot(x, y, c): return ' *'[abs(reduce(lambda z, _: z*z + c, range(99), 0)) < 2]\n\nprint('\\n'.join(''.join(mandelbrot(x, y, x/50 + y/50j) for x in range(-100, 25)) for y in range(-50, 50)))\n", "explain": "Translation of the ruby solution\nA more \"Pythonic\" version of the code:\nFinally, we can also use Matplotlib to visualize the Mandelbrot set with Python:\nAnother Numpy version using masks to avoid (explicit) nested loops. \nRuns about 16x faster for the same resolution.\nNormalization, Distance Estimation and Boundary Detection\nThe Mandelbrot set is printed with smooth colors. The e^(-|z|)-smoothing, normalized iteration count and exterior distance estimation algorithms are used with NumPy and complex matrices (see Javier Barrallo & Damien M. Jones: Coloring Algorithms for Dynamical Systems in the Complex Plane and Arnaud Ch\u00e9ritat: Boundary detection methods via distance estimators). Partial antialiasing is used for boundary detection.\nNormal Map Effect and Stripe Average Coloring\nThe Mandelbrot set is represented using Normal Maps and Stripe Average Coloring by Jussi H\u00e4rk\u00f6nen (cf. Arnaud Ch\u00e9ritat: Normal map effect). Note that the second derivative (ddZ) grows very fast, so the second method can only be used for small iteration numbers (n <= 400). See also the picture in section Mixing it all and Julia Stripes on Shadertoy. To get a stripe pattern similar to that of Arnaud Ch\u00e9ritat, one can increase the stripes, use cos instead of sin, and set the colormap to binary.\nMercator Mandelbrot Maps and Zoom Images\nA small change in the code above creates Mercator maps of the Mandelbrot set (see David Madore: Mandelbrot set images and videos and Anders Sandberg: Mercator Mandelbrot Maps). The maximum magnification is about \n\n\n\n\ne\n\n2\n\u03c0\n\u22c5\nh\n\n/\n\nd\n\n\n=\n\ne\n\n2\n\u03c0\n\u22c5\n5.5\n\n\n\u2248\n\n535.5\n\n5.5\n\n\n\u2248\n\n10\n\n15\n\n\n\n\n{\\displaystyle e ^ {2 \\pi \\cdot h / d} = e ^ {2 \\pi \\cdot 5.5} \\approx 535.5 ^ {5.5} \\approx 10 ^ {15}}\n\n, which is also the maximum for 64-bit arithmetic. Note that Anders Sandberg uses a different scaling. He uses \n\n\n\n\n10\n\n3\n\u22c5\nh\n\n/\n\nd\n\n\n=\n\n1000\n\nh\n\n/\n\nd\n\n\n\n\n{\\displaystyle 10 ^ {3 \\cdot h / d} = 1000 ^ {h / d}}\n\n instead of \n\n\n\n\ne\n\n2\n\u03c0\n\u22c5\nh\n\n/\n\nd\n\n\n\u2248\n\n535.5\n\nh\n\n/\n\nd\n\n\n\n\n{\\displaystyle e ^ {2 \\pi \\cdot h / d} \\approx 535.5 ^ {h / d}}\n\n, so his images appear somewhat compressed in comparison (but not much, because \n\n\n\n\n1000\n\n5.0\n\n\n\u2248\n\n535.5\n\n5.5\n\n\n\n\n{\\displaystyle 1000 ^ {5.0} \\approx 535.5 ^ {5.5}}\n\n). With the same pixel density and the same maximum magnification, the difference in height between the maps is only about 10 percent. By misusing a scatter plot, it is possible to create zoom images of the Mandelbrot set. See also Mandelbrot sequence new on Wikimedia for a zoom animation to the given coordinates.\nPerturbation Theory and Deep Mercator Maps\nFor deep zoom images it is sufficient to calculate a single point with high accuracy. A good approximation can then be found for all other points by means of a perturbation calculation with standard accuracy. Rebasing is used to reduce glitches. See Perturbation theory (Wikipedia) and Avoiding loss of precision (Fractalshades) for details. See also the image Deeper Mercator Mandelbrot by Anders Sandberg.\nYou can only rebase to the beginning of the reference sequence. If you want to change from current reference point \n\n\n\n\nS\ni\n\n\n\n{\\displaystyle S_i}\n\n to reference point \n\n\n\n\nS\nj\n\n\n\n{\\displaystyle S_j}\n\n, the difference \n\n\n\n\n\u03f5\nj\n\n=\nz\n\u2212\n\ns\nj\n\n\n\n{\\displaystyle \\epsilon_j = z - s_j}\n\n must be calculated. With this subtraction, however, the entire precision is lost due to catastrophic cancellation. Only at the first reference point \n\n\n\n\nS\n0\n\n=\n(\n0\n,\n0\n)\n\n\n{\\displaystyle S_0 = (0, 0)}\n\n there is no cancellation because \n\n\n\n\n\u03f5\n0\n\n=\nz\n\u2212\n\ns\n0\n\n=\nz\n\u2212\n0\n=\nz\n\n\n{\\displaystyle \\epsilon_0 = z - s_0 = z - 0 = z}\n\n. Therefore, the rebasing condition \n\n\n\n\n|\n\nz\n\n|\n\n<\n\n|\n\n\n\u03f5\ni\n\n\n|\n\n\n\n{\\displaystyle |z| < |\\epsilon_i|}\n\n can also be written as \n\n\n\n\n|\n\n\n\u03f5\n0\n\n\n|\n\n<\n\n|\n\n\n\u03f5\ni\n\n\n|\n\n\n\n{\\displaystyle |\\epsilon_0| < |\\epsilon_i|}\n\n or as \n\n\n\n\n|\n\nz\n\u2212\n\ns\n0\n\n\n|\n\n<\n\n|\n\nz\n\u2212\n\ns\ni\n\n\n|\n\n\n\n{\\displaystyle |z - s_0| < |z - s_i|}\n\n. This keeps the differences to the reference sequence as small as possible: rebasing occurs when the distance to reference point \n\n\n\n\nS\n0\n\n\n\n{\\displaystyle S_0}\n\n is smaller than the distance to the current reference point \n\n\n\n\nS\ni\n\n\n\n{\\displaystyle S_i}\n\n.\nBased on the \"One liner\" approach.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "C", "code": "\nPPM non interactive[edit]\n\n /* \n c program:\n --------------------------------\n  1. draws Mandelbrot set for Fc(z)=z*z +c\n  using Mandelbrot algorithm ( boolean escape time )\n -------------------------------         \n 2. technique of creating ppm file is  based on the code of Claudio Rocchini\n http://en.wikipedia.org/wiki/Image:Color_complex_plot.jpg\n create 24 bit color graphic file ,  portable pixmap file = PPM \n see http://en.wikipedia.org/wiki/Portable_pixmap\n to see the file use external application ( graphic viewer)\n  */\n #include <stdio.h>\n #include <math.h>\n int main()\n {\n          /* screen ( integer) coordinate */\n        int iX,iY;\n        const int iXmax = 800; \n        const int iYmax = 800;\n        /* world ( double) coordinate = parameter plane*/\n        double Cx,Cy;\n        const double CxMin=-2.5;\n        const double CxMax=1.5;\n        const double CyMin=-2.0;\n        const double CyMax=2.0;\n        /* */\n        double PixelWidth=(CxMax-CxMin)/iXmax;\n        double PixelHeight=(CyMax-CyMin)/iYmax;\n        /* color component ( R or G or B) is coded from 0 to 255 */\n        /* it is 24 bit color RGB file */\n        const int MaxColorComponentValue=255; \n        FILE * fp;\n        char *filename=\"new1.ppm\";\n        char *comment=\"# \";/* comment should start with # */\n        static unsigned char color[3];\n        /* Z=Zx+Zy*i \u00a0;   Z0 = 0 */\n        double Zx, Zy;\n        double Zx2, Zy2; /* Zx2=Zx*Zx;  Zy2=Zy*Zy  */\n        /*  */\n        int Iteration;\n        const int IterationMax=200;\n        /* bail-out value , radius of circle\u00a0;  */\n        const double EscapeRadius=2;\n        double ER2=EscapeRadius*EscapeRadius;\n        /*create new file,give it a name and open it in binary mode  */\n        fp= fopen(filename,\"wb\"); /* b -  binary mode */\n        /*write ASCII header to the file*/\n        fprintf(fp,\"P6\\n %s\\n %d\\n %d\\n %d\\n\",comment,iXmax,iYmax,MaxColorComponentValue);\n        /* compute and write image data bytes to the file*/\n        for(iY=0;iY<iYmax;iY++)\n        {\n             Cy=CyMin + iY*PixelHeight;\n             if (fabs(Cy)< PixelHeight/2) Cy=0.0; /* Main antenna */\n             for(iX=0;iX<iXmax;iX++)\n             {         \n                        Cx=CxMin + iX*PixelWidth;\n                        /* initial value of orbit = critical point Z= 0 */\n                        Zx=0.0;\n                        Zy=0.0;\n                        Zx2=Zx*Zx;\n                        Zy2=Zy*Zy;\n                        /* */\n                        for (Iteration=0;Iteration<IterationMax && ((Zx2+Zy2)<ER2);Iteration++)\n                        {\n                            Zy=2*Zx*Zy + Cy;\n                            Zx=Zx2-Zy2 +Cx;\n                            Zx2=Zx*Zx;\n                            Zy2=Zy*Zy;\n                        };\n                        /* compute  pixel color (24 bit = 3 bytes) */\n                        if (Iteration==IterationMax)\n                        { /*  interior of Mandelbrot set = black */\n                           color[0]=0;\n                           color[1]=0;\n                           color[2]=0;                           \n                        }\n                     else \n                        { /* exterior of Mandelbrot set = white */\n                             color[0]=255; /* Red*/\n                             color[1]=255;  /* Green */ \n                             color[2]=255;/* Blue */\n                        };\n                        /*write color to the file*/\n                        fwrite(color,1,3,fp);\n                }\n        }\n        fclose(fp);\n        return 0;\n }\n\nPPM Interactive[edit]\n\n\nOpenBSD users, install freeglut package, and compile with make mandelbrot CPPFLAGS='-I/usr/local/include `pkg-config glu --cflags`' LDLIBS='-L/usr/local/lib -lglut `pkg-config glu --libs` -lm'\nLibrary: GLUT\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <GL/glut.h>\n#include <GL/gl.h>\n#include <GL/glu.h>\n \nvoid set_texture();\n \ntypedef struct {unsigned char r, g, b;} rgb_t;\nrgb_t **tex = 0;\nint gwin;\nGLuint texture;\nint width, height;\nint tex_w, tex_h;\ndouble scale = 1./256;\ndouble cx = -.6, cy = 0;\nint color_rotate = 0;\nint saturation = 1;\nint invert = 0;\nint max_iter = 256;\n \nvoid render()\n{\n\tdouble\tx = (double)width /tex_w,\n\t\ty = (double)height/tex_h;\n \n\tglClear(GL_COLOR_BUFFER_BIT);\n\tglTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n \n\tglBindTexture(GL_TEXTURE_2D, texture);\n \n\tglBegin(GL_QUADS);\n \n\tglTexCoord2f(0, 0); glVertex2i(0, 0);\n\tglTexCoord2f(x, 0); glVertex2i(width, 0);\n\tglTexCoord2f(x, y); glVertex2i(width, height);\n\tglTexCoord2f(0, y); glVertex2i(0, height);\n \n\tglEnd();\n \n\tglFlush();\n\tglFinish();\n}\n \nint dump = 1;\nvoid screen_dump()\n{\n\tchar fn[100];\n\tint i;\n\tsprintf(fn, \"screen%03d.ppm\", dump++);\n\tFILE *fp = fopen(fn, \"w\");\n\tfprintf(fp, \"P6\\n%d %d\\n255\\n\", width, height);\n\tfor (i = height - 1; i >= 0; i--)\n\t\tfwrite(tex[i], 1, width * 3, fp);\n\tfclose(fp);\n\tprintf(\"%s written\\n\", fn);\n}\n \nvoid keypress(unsigned char key, int x, int y)\n{\n\tswitch(key) {\n\tcase 'q':\tglFinish();\n\t\t\tglutDestroyWindow(gwin);\n\t\t\treturn;\n\tcase 27:\tscale = 1./256; cx = -.6; cy = 0; break;\n \n\tcase 'r':\tcolor_rotate = (color_rotate + 1) % 6;\n\t\t\tbreak;\n \n\tcase '>': case '.':\n\t\t\tmax_iter += 128;\n\t\t\tif (max_iter > 1 << 15) max_iter = 1 << 15;\n\t\t\tprintf(\"max iter: %d\\n\", max_iter);\n\t\t\tbreak;\n \n\tcase '<': case ',':\n\t\t\tmax_iter -= 128;\n\t\t\tif (max_iter < 128) max_iter = 128;\n\t\t\tprintf(\"max iter: %d\\n\", max_iter);\n\t\t\tbreak;\n \n\tcase 'c':\tsaturation = 1 - saturation;\n\t\t\tbreak;\n \n\tcase 's':\tscreen_dump(); return;\n\tcase 'z':\tmax_iter = 4096; break;\n\tcase 'x':\tmax_iter = 128; break;\n\tcase ' ':\tinvert = !invert;\n\t}\n\tset_texture();\n}\n \nvoid hsv_to_rgb(int hue, int min, int max, rgb_t *p)\n{\n\tif (min == max) max = min + 1;\n\tif (invert) hue = max - (hue - min);\n\tif (!saturation) {\n\t\tp->r = p->g = p->b = 255 * (max - hue) / (max - min);\n\t\treturn;\n\t}\n\tdouble h = fmod(color_rotate + 1e-4 + 4.0 * (hue - min) / (max - min), 6);\n#\tdefine VAL 255\n\tdouble c = VAL * saturation;\n\tdouble X = c * (1 - fabs(fmod(h, 2) - 1));\n \n\tp->r = p->g = p->b = 0;\n \n\tswitch((int)h) {\n\tcase 0: p->r = c; p->g = X; return;\n\tcase 1:\tp->r = X; p->g = c; return;\n\tcase 2: p->g = c; p->b = X; return;\n\tcase 3: p->g = X; p->b = c; return;\n\tcase 4: p->r = X; p->b = c; return;\n\tdefault:p->r = c; p->b = X;\n\t}\n}\n \nvoid calc_mandel()\n{\n\tint i, j, iter, min, max;\n\trgb_t *px;\n\tdouble x, y, zx, zy, zx2, zy2;\n\tmin = max_iter; max = 0;\n\tfor (i = 0; i < height; i++) {\n\t\tpx = tex[i];\n\t\ty = (i - height/2) * scale + cy;\n\t\tfor (j = 0; j  < width; j++, px++) {\n\t\t\tx = (j - width/2) * scale + cx;\n\t\t\titer = 0;\n \n\t\t\tzx = hypot(x - .25, y);\n\t\t\tif (x < zx - 2 * zx * zx + .25) iter = max_iter;\n\t\t\tif ((x + 1)*(x + 1) + y * y < 1/16) iter = max_iter;\n \n\t\t\tzx = zy = zx2 = zy2 = 0;\n\t\t\tfor (; iter < max_iter && zx2 + zy2 < 4; iter++) {\n\t\t\t\tzy = 2 * zx * zy + y;\n\t\t\t\tzx = zx2 - zy2 + x;\n\t\t\t\tzx2 = zx * zx;\n\t\t\t\tzy2 = zy * zy;\n\t\t\t}\n\t\t\tif (iter < min) min = iter;\n\t\t\tif (iter > max) max = iter;\n\t\t\t*(unsigned short *)px = iter;\n\t\t}\n\t}\n \n\tfor (i = 0; i < height; i++)\n\t\tfor (j = 0, px = tex[i]; j  < width; j++, px++)\n\t\t\thsv_to_rgb(*(unsigned short*)px, min, max, px);\n}\n \nvoid alloc_tex()\n{\n\tint i, ow = tex_w, oh = tex_h;\n \n\tfor (tex_w = 1; tex_w < width;  tex_w <<= 1);\n\tfor (tex_h = 1; tex_h < height; tex_h <<= 1);\n \n\tif (tex_h != oh || tex_w != ow)\n\t\ttex = realloc(tex, tex_h * tex_w * 3 + tex_h * sizeof(rgb_t*));\n \n\tfor (tex[0] = (rgb_t *)(tex + tex_h), i = 1; i < tex_h; i++)\n\t\ttex[i] = tex[i - 1] + tex_w;\n}\n \nvoid set_texture()\n{\n\talloc_tex();\n\tcalc_mandel();\n \n\tglEnable(GL_TEXTURE_2D);\n\tglBindTexture(GL_TEXTURE_2D, texture);\n\tglTexImage2D(GL_TEXTURE_2D, 0, 3, tex_w, tex_h,\n\t\t0, GL_RGB, GL_UNSIGNED_BYTE, tex[0]);\n \n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n\tglTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\trender();\n}\n \nvoid mouseclick(int button, int state, int x, int y)\n{\n\tif (state != GLUT_UP) return;\n \n\tcx += (x - width / 2) * scale;\n\tcy -= (y - height/ 2) * scale;\n \n\tswitch(button) {\n\tcase GLUT_LEFT_BUTTON: /* zoom in */\n\t\tif (scale > fabs(x) * 1e-16 && scale > fabs(y) * 1e-16)\n\t\t\tscale /= 2;\n\t\tbreak;\n\tcase GLUT_RIGHT_BUTTON: /* zoom out */\n\t\tscale *= 2;\n\t\tbreak;\n\t/* any other button recenters */\n\t}\n\tset_texture();\n}\n \n \nvoid resize(int w, int h)\n{\n\tprintf(\"resize %d %d\\n\", w, h);\n\twidth = w;\n\theight = h;\n \n\tglViewport(0, 0, w, h);\n\tglOrtho(0, w, 0, h, -1, 1);\n \n\tset_texture();\n}\n \nvoid init_gfx(int *c, char **v)\n{\n\tglutInit(c, v);\n\tglutInitDisplayMode(GLUT_RGB);\n\tglutInitWindowSize(640, 480);\n\t\n\tgwin = glutCreateWindow(\"Mandelbrot\");\n\tglutDisplayFunc(render);\n \n\tglutKeyboardFunc(keypress);\n\tglutMouseFunc(mouseclick);\n\tglutReshapeFunc(resize);\n\tglGenTextures(1, &texture);\n\tset_texture();\n}\n \nint main(int c, char **v)\n{\n\tinit_gfx(&c, v);\n\tprintf(\"keys:\\n\\tr: color rotation\\n\\tc: monochrome\\n\\ts: screen dump\\n\\t\"\n\t\t\"<, >: decrease/increase max iteration\\n\\tq: quit\\n\\tmouse buttons to zoom\\n\");\n \n\tglutMainLoop();\n\treturn 0;\n}\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n#include <GL/glut.h>\n#include <GL/gl.h>\n#include <GL/glu.h>\n\nvoid set_texture();\n\nunsigned char *tex;\nint gwin;\nGLuint texture;\nint width, height;\nint old_width, old_height;\ndouble scale = 1. / 256;\ndouble cx = -.6, cy = 0;\nint color_rotate = 0;\nint saturation = 1;\nint invert = 0;\nint max_iter = 256;\n\nvoid render()\n{\n    glTexEnvi(GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_REPLACE);\n\n    glBindTexture(GL_TEXTURE_2D, texture);\n\n    glBegin(GL_QUADS);\n\n    glTexCoord2d(0, 0);\n    glVertex2i(0, 0);\n    glTexCoord2d(1, 0);\n    glVertex2i(width, 0);\n    glTexCoord2d(1, 1);\n    glVertex2i(width, height);\n    glTexCoord2d(0, 1);\n    glVertex2i(0, height);\n\n    glEnd();\n\n    glFlush();\n    glFinish();\n}\n\nint dump = 1;\nvoid screen_dump()\n{\n    char fn[100];\n    sprintf(fn, \"screen%03d.ppm\", dump++);\n    FILE *fp = fopen(fn, \"w\");\n    fprintf(fp, \"P6\\n%d %d\\n255\\n\", width, height);\n    for (int i = height - 1; i >= 0; i -= 1) {\n        for (int j = 0; j < width; j += 1) {\n            fwrite(&tex[((i * width) + j) * 4], 1, 3, fp);\n        }\n    }\n    fclose(fp);\n    printf(\"%s written\\n\", fn);\n}\n\nvoid keypress(unsigned char key,[[maybe_unused]]\n              int x,[[maybe_unused]]\n              int y)\n{\n    switch (key) {\n    case 'q':\n        glFinish();\n        glutDestroyWindow(gwin);\n        break;\n\n    case 27:\n        scale = 1. / 256;\n        cx = -.6;\n        cy = 0;\n        set_texture();\n        break;\n\n    case 'r':\n        color_rotate = (color_rotate + 1) % 6;\n        set_texture();\n        break;\n\n    case '>':\n    case '.':\n        max_iter += 128;\n        if (max_iter > 1 << 15)\n            max_iter = 1 << 15;\n        printf(\"max iter: %d\\n\", max_iter);\n        set_texture();\n        break;\n\n    case '<':\n    case ',':\n        max_iter -= 128;\n        if (max_iter < 128)\n            max_iter = 128;\n        printf(\"max iter: %d\\n\", max_iter);\n        set_texture();\n        break;\n\n    case 'c':\n        saturation = 1 - saturation;\n        set_texture();\n        break;\n\n    case 's':\n        screen_dump();\n        break;\n\n    case 'z':\n        max_iter = 4096;\n        set_texture();\n        break;\n\n    case 'x':\n        max_iter = 128;\n        set_texture();\n        break;\n\n    case ' ':\n        invert = !invert;\n        set_texture();\n        break;\n\n    default:\n        set_texture();\n        break;\n    }\n}\n\n#define VAL 255\n\nvoid hsv_to_rgba(int hue, int min, int max, unsigned char *px)\n{\n    unsigned char r;\n    unsigned char g;\n    unsigned char b;\n\n    if (min == max)\n        max = min + 1;\n    if (invert)\n        hue = max - (hue - min);\n    if (!saturation) {\n        r = 255 * (max - hue) / (max - min);\n        g = r;\n        b = r;\n    } else {\n        double h =\n            fmod(color_rotate + 1e-4 + 4.0 * (hue - min) / (max - min), 6);\n        double c = VAL * saturation;\n        double X = c * (1 - fabs(fmod(h, 2) - 1));\n\n        r = 0;\n        g = 0;\n        b = 0;\n\n        switch ((int) h) {\n        case 0:\n            r = c;\n            g = X;\n            break;\n        case 1:\n            r = X;\n            g = c;\n            break;\n        case 2:\n            g = c;\n            b = X;\n            break;\n        case 3:\n            g = X;\n            b = c;\n            break;\n        case 4:\n            r = X;\n            b = c;\n            break;\n        default:\n            r = c;\n            b = X;\n            break;\n        }\n    }\n\n    /* Using an alpha channel neatly solves the problem of aligning\n     * rows on 4-byte boundaries (at the expense of memory, of\n     * course). */\n    px[0] = r;\n    px[1] = g;\n    px[2] = b;\n    px[3] = 255;                /* Alpha channel. */\n}\n\nvoid calc_mandel()\n{\n    int i, j, iter, min, max;\n    double x, y, zx, zy, zx2, zy2;\n    unsigned short *hsv = malloc(width * height * sizeof(unsigned short));\n\n    min = max_iter;\n    max = 0;\n    for (i = 0; i < height; i++) {\n        y = (i - height / 2) * scale + cy;\n        for (j = 0; j < width; j++) {\n            x = (j - width / 2) * scale + cx;\n            iter = 0;\n\n            zx = hypot(x - .25, y);\n            if (x < zx - 2 * zx * zx + .25)\n                iter = max_iter;\n            if ((x + 1) * (x + 1) + y * y < 1 / 16)\n                iter = max_iter;\n\n            zx = 0;\n            zy = 0;\n            zx2 = 0;\n            zy2 = 0;\n            while (iter < max_iter && zx2 + zy2 < 4) {\n                zy = 2 * zx * zy + y;\n                zx = zx2 - zy2 + x;\n                zx2 = zx * zx;\n                zy2 = zy * zy;\n                iter += 1;\n            }\n            if (iter < min)\n                min = iter;\n            if (iter > max)\n                max = iter;\n            hsv[(i * width) + j] = iter;\n        }\n    }\n\n    for (i = 0; i < height; i += 1) {\n        for (j = 0; j < width; j += 1) {\n            unsigned char *px = tex + (((i * width) + j) * 4);\n            hsv_to_rgba(hsv[(i * width) + j], min, max, px);\n        }\n    }\n\n    free(hsv);\n}\n\nvoid alloc_tex()\n{\n    if (tex == NULL || width != old_width || height != old_height) {\n        free(tex);\n        tex = malloc(height * width * 4 * sizeof(unsigned char));\n        memset(tex, 0, height * width * 4 * sizeof(unsigned char));\n        old_width = width;\n        old_height = height;\n    }\n}\n\nvoid set_texture()\n{\n    alloc_tex();\n    calc_mandel();\n\n    glEnable(GL_TEXTURE_2D);\n    glBindTexture(GL_TEXTURE_2D, texture);\n    glTexImage2D(GL_TEXTURE_2D, 0, GL_RGBA, width, height,\n                 0, GL_RGBA, GL_UNSIGNED_BYTE, tex);\n\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n    glTexParameteri(GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n    render();\n}\n\nvoid mouseclick(int button, int state, int x, int y)\n{\n    if (state != GLUT_UP)\n        return;\n\n    cx += (x - width / 2) * scale;\n    cy -= (y - height / 2) * scale;\n\n    switch (button) {\n    case GLUT_LEFT_BUTTON:     /* zoom in */\n        if (scale > fabs((double) x) * 1e-16\n            && scale > fabs((double) y) * 1e-16)\n            scale /= 2;\n        break;\n    case GLUT_RIGHT_BUTTON:    /* zoom out */\n        scale *= 2;\n        break;\n        /* any other button recenters */\n    }\n    set_texture();\n}\n\n\nvoid resize(int w, int h)\n{\n    printf(\"resize %d %d\\n\", w, h);\n\n    width = w;\n    height = h;\n\n    glViewport(0, 0, w, h);\n    glOrtho(0, w, 0, h, -1, 1);\n\n    set_texture();\n}\n\nvoid init_gfx(int *c, char **v)\n{\n    glutInit(c, v);\n    glutInitDisplayMode(GLUT_RGBA);\n    glutInitWindowSize(640, 480);\n\n    gwin = glutCreateWindow(\"Mandelbrot\");\n    glutDisplayFunc(render);\n\n    glutKeyboardFunc(keypress);\n    glutMouseFunc(mouseclick);\n    glutReshapeFunc(resize);\n    glGenTextures(1, &texture);\n    set_texture();\n}\n\nint main(int c, char **v)\n{\n    tex = NULL;\n\n    init_gfx(&c, v);\n    printf\n        (\"keys:\\n\\tr: color rotation\\n\\tc: monochrome\\n\\ts: screen dump\\n\\t\"\n         \"<, >: decrease/increase max iteration\\n\\tq: quit\\n\\tmouse buttons to zoom\\n\");\n\n    glutMainLoop();\n    return 0;\n}\n\n// local variables:\n// mode: C\n// c-file-style: \"k&r\"\n// c-basic-offset: 4\n// end:\n\n\nASCII[edit]\n\nmain(k){float i,j,r,x,y=-16;while(puts(\"\"),y++<15)for(x\n=0;x++<84;putchar(\" .:-;!/>)|&IH%*#\"[k&15]))for(i=k=r=0;\nj=r*r-i*i-2+x/25,i=2*r*i+y/10,j*j+i*i<11&&k++<111;r=j);}\n\n\n.............::::::::::::::::::::::::::::::::::::::::::::::::.......................\n.........::::::::::::::::::::::::::::::::::::::::::::::::::::::::...................\n.....::::::::::::::::::::::::::::::::::-----------:::::::::::::::::::...............\n...:::::::::::::::::::::::::::::------------------------:::::::::::::::.............\n:::::::::::::::::::::::::::-------------;;;!:H!!;;;--------:::::::::::::::..........\n::::::::::::::::::::::::-------------;;;;!!/>&*|I\u00a0!;;;--------::::::::::::::........\n::::::::::::::::::::-------------;;;;;;!!/>)|.*#|>/!!;;;;-------::::::::::::::......\n::::::::::::::::-------------;;;;;;!!!!//>|:   \u00a0!:|//!!!;;;;-----::::::::::::::.....\n::::::::::::------------;;;;;;;!!/>)I>>)||I#     H&))>////*!;;-----:::::::::::::....\n::::::::----------;;;;;;;;;;!!!//)H:  #|              IH&*I#/;;-----:::::::::::::...\n:::::---------;;;;!!!!!!!!!!!//>|.H:                     #I>/!;;-----:::::::::::::..\n:----------;;;;!/||>//>>>>//>>)|%                        \u00a0%|&/!;;----::::::::::::::.\n--------;;;;;!!//)& .;I*-H#&||&/                           *)/!;;-----::::::::::::::\n-----;;;;;!!!//>)IH:-        ##                            #&!!;;-----::::::::::::::\n;;;;!!!!!///>)H%.**           *                            )/!;;;------:::::::::::::\n                                                         &)/!!;;;------:::::::::::::\n;;;;!!!!!///>)H%.**           *                            )/!;;;------:::::::::::::\n-----;;;;;!!!//>)IH:-        ##                            #&!!;;-----::::::::::::::\n--------;;;;;!!//)& .;I*-H#&||&/                           *)/!;;-----::::::::::::::\n:----------;;;;!/||>//>>>>//>>)|%                        \u00a0%|&/!;;----::::::::::::::.\n:::::---------;;;;!!!!!!!!!!!//>|.H:                     #I>/!;;-----:::::::::::::..\n::::::::----------;;;;;;;;;;!!!//)H:  #|              IH&*I#/;;-----:::::::::::::...\n::::::::::::------------;;;;;;;!!/>)I>>)||I#     H&))>////*!;;-----:::::::::::::....\n::::::::::::::::-------------;;;;;;!!!!//>|:   \u00a0!:|//!!!;;;;-----::::::::::::::.....\n::::::::::::::::::::-------------;;;;;;!!/>)|.*#|>/!!;;;;-------::::::::::::::......\n::::::::::::::::::::::::-------------;;;;!!/>&*|I\u00a0!;;;--------::::::::::::::........\n:::::::::::::::::::::::::::-------------;;;!:H!!;;;--------:::::::::::::::..........\n...:::::::::::::::::::::::::::::------------------------:::::::::::::::.............\n.....::::::::::::::::::::::::::::::::::-----------:::::::::::::::::::...............\n.........::::::::::::::::::::::::::::::::::::::::::::::::::::::::...................\n.............::::::::::::::::::::::::::::::::::::::::::::::::.......................\n\nFixed point 16 bit arithmetic[edit]\n/**\n  ascii Mandelbrot using 16 bits of fixed point integer maths with a selectable fractional precision in bits.\n\n  This is still only 16 bits mathc and allocating more than 6 bits of fractional precision leads to an overflow that adds noise to the plot..\n\n  This code frequently casts to short to ensure we're not accidentally benefitting from GCC promotion from short 16 bits to int.\n\n  gcc fixedPoint.c  -lm\n\n */\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <stdint.h>\n#include <string.h>\n\nshort s(short i);\nshort toPrec(double f, int bitsPrecision);\n\nint main(int argc, char* argv[])\n{\n  // chosen to match https://www.youtube.com/watch?v=DC5wi6iv9io\n  int width = 32; // basic width of a zx81\n  int height = 22; // basic width of a zx81\n  int zoom=3;  // bigger with finer detail ie a smaller step size - leave at 1 for 32x22\n\n  // params\n  short bitsPrecision = 6;\n  printf(\"PRECISION=%d\\n\", bitsPrecision);\n\n  short X1 = toPrec(3.5,bitsPrecision) / zoom;\n  short X2 = toPrec(2.25,bitsPrecision) ;\n  short Y1 = toPrec(3,bitsPrecision)/zoom ;   // horiz pos\n  short Y2 = toPrec(1.5,bitsPrecision) ; // vert pos\n  short LIMIT = toPrec(4,bitsPrecision);\n\n\n  // fractal\n  //char * chr = \".:-=X$#@.\";\n  char * chr = \"abcdefghijklmnopqr \";\n  //char * chr = \".,'~=+:;[/<&?oxOX#.\";\n  short maxIters = strlen(chr);\n\n  short py=0;\n  while (py < height*zoom) {\n    short px=0;\n    while (px < width*zoom) {\n\n      short x0 = s(s(px*X1) / width) - X2;\n      short y0 = s(s(py*Y1) / height) - Y2;\n\n      short x=0;\n      short y=0;\n\n      short i=0;\n\n      short xSqr;\n      short ySqr;\n      while (i < maxIters) {\n        xSqr = s(x * x) >> bitsPrecision;\n        ySqr = s(y * y) >> bitsPrecision;\n\n        // Breakout if sum is > the limit OR breakout also if sum is negative which indicates overflow of the addition has occurred\n        // The overflow check is only needed for precisions of over 6 bits because for 7 and above the sums come out overflowed and negative therefore we always run to maxIters and we see nothing.\n        // By including the overflow break out we can see the fractal again though with noise.\n        if ((xSqr + ySqr) >= LIMIT || (xSqr+ySqr) < 0) {\n          break;\n        }\n\n        short xt = xSqr - ySqr + x0;\n        y = s(s(s(x * y) >> bitsPrecision) * 2) + y0;\n        x=xt;\n\n        i = i + 1;\n      }\n      i = i - 1;\n\n      printf(\"%c\", chr[i]);\n\n      px = px + 1;\n    }\n\n    printf(\"\\n\");\n    py = py + 1;\n  }\n}\n\n// convert decimal value to a fixed point value in the given precision\nshort toPrec(double f, int bitsPrecision) {\n  short whole = ((short)floor(f) << (bitsPrecision));\n  short part = (f-floor(f))*(pow(2,bitsPrecision));\n  short ret = whole + part;\n  return ret;\n}\n\n// convenient casting\nshort s(short i) {\n  return i;\n}\n\n$ gcc fixedPoint.c  -lm && ./a.out\n\nPRECISION=6\naaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcdcccbbbbbb\naaaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccddcbbbbb\naaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbegfcdbbb\naaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdccedbb\naaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdcccb\naaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbcfdddcccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdded\naaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbcccccddfcccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccc\naaaaaaaaaaaaaaaaaabbbbbbbbbbbbbcccccdeccccccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbcc\naaaaaaaaaaaaaaaaabbbbbbbbbbfcccccddeccccccccccccccccdddddeeeddddccccccbbbbbbbbbbbbbbbbbbbbbbbbbe\naaaaaaaaaaaaaaaabbbbbbbbbbcccccdddccccccccccccccdeddddeefigeeeddddecccccbbbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaabbbbbbbecccccdddcccccccccccccdddddddddeefhmgfffddddedcccccbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaabbbbbbbcccccccdcccccccccccccccdgddddddfeefgjpijjfdddddedccccccbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaabbbbbccccccdedccccccccccccccdddddddddeeefgkj ojgfedddddeccccccbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaabbbbbcccccegeccccccccccccccdeedddddddeeeeghhkp hgheefddddecccccccbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaabbbbccccceddcccccccccccccccfddddddddeeeeefmlkr  ihheeeedddddgccccccbbbbbbbbbbbbbbbb\naaaaaaaaaaaaabbbccccddfcccccccccccccccedddddddddeeegffhnp    rpjffeeeiddddcccccccbbbbbbbbbbbbbbb\naaaaaaaaaaaabbbcccddecccccccccccccccddddddddddeeffffgghm       jgffeeeegdddccccccccbbbbbbbbbbbbb\naaaaaaaaaaabbbccdedccccccccccccccccdddddddddeefffffgghil       khggffffeeeddccccccccbbbbbbbbbbbb\naaaaaaaaaaabbccdeccccccccccccccccddddddddeeef ijjhhhkijlo     qkihjhgffgngeddcccccccbbbbbbbbbbbb\naaaaaaaaaabbcddccccccccccccccccdddddddfeeeefgjq  lkk p           n khhhiqifedcccccccdbbbbbbbbbbb\naaaaaaaaaabbccccccccccccccccccddddddefeeeeffgilq                   plk rrqgeddcccccccdbbbbbbbbbb\naaaaaaaaaabdccccccccccccccccdddhegeeeeeefffghiq                          mfeeddcccccccdbbbbbbbbb\naaaaaaaaaaccccccccccccccccdddeeeeeeeeeeffffhjklp                        phfeeddcccccccdcbbbbbbbb\naaaaaaaaabcccccccccccccddddegeeeeeeeeeffffhppp                          jgggedddccccccccbbbbbbbb\naaaaaaaaabccccccccccddddeefpifffffffffggggik                             hgfedddcccccccdcbbbbbbb\naaaaaaaaaccccccceddddddeeifl hgggjrhggggghj p                            qjnfdddcccccccdcbbbbbbb\naaaaaaaabccccddedddddefeefghqnokkloqiqhhhik                                ifdddcccccccdcbbbbbbb\naaaaaaaaccceddddddddgfeeffghir o n  qmjiijo                               igfedddcccccccccbbbbbb\naaaaaaaaccddedddddeeeeeefgghkq         lll                                lgfddddcccccccdcbbbbbb\naaaaaaaacddddddddeeeeeefhgjol           rn                                 geddddcccccccdcbbbbbb\naaaaaaaaedddddddeeeffggojjll                                              hfeddddeccccccdcbbbbbb\naaaaaaaaddddddefffffggmkopmop                                            ngfefdddfccccccdcbbbbbb\naaaaaaaaeeffgihggiihikk                                                  hfeefdddeccccccddbbbbbb\naaaaaaaa                                                               kigfgefdddecccccceebbbbbb\naaaaaaaaeeffhgjggghhhklqm                                              ligfhefdddeccccccddbbbbbb\naaaaaaaaddddddefffffgggirq                                               hffefdddeccccccdebbbbbb\naaaaaaaahdddddddeefgfggilkjk                                              hfeedddeccccccddbbbbbb\naaaaaaaacddddddddeeeeeefhhhkl                                             lfefdddeccccccdcbbbbbb\naaaaaaaaccddedddddefeeeeffgijo           on                                qfedddcccccccdcbbbbbb\naaaaaaaabcceddddddddegeeefggik       r  kko                               jhfedddcccccccdcbbbbbb\naaaaaaaabccccddddddddefeeefijmk jkp  kmiijlq                              qhfedddcccccccccbbbbbb\naaaaaaaaacccccccdddddddeeefh hhghi kjggghil                               r geddcccccccdcbbbbbbb\naaaaaaaaabccccccccccdddddefgnfgffghggggggghjm                            lj feddcccccccdcbbbbbbb\naaaaaaaaabccccccccccccccdddeffggeeeefffffggm                             igfefddcccccccdbbbbbbbb\naaaaaaaaaaccccccccccccccccdddeeeeeeeeeeffffhjm                           kgfeddcccccccdcbbbbbbbb\naaaaaaaaaabdccccccccccccccccdddfeeeeeeeegffgiikq                          feeddcccccccebbbbbbbbb\naaaaaaaaaabbccccccccccccccccccdddddegeeeegffgho                     p    nheeddcccccchfbbbbbbbbb\naaaaaaaaaabbbddcccccccccccccccccdddddeeeeeefhm     l                ki jlnjeddcccccccdbbbbbbbbbb\naaaaaaaaaaabbccecccccccccccccccccdddddddfeeefir  jii npm         k ohgggineedcccccccdbbbbbbbbbbb\naaaaaaaaaaabbbccdddccccccccccccccccddddddddeeefggggggiik       mjhhgfffffedddcccccccbbbbbbbbbbbb\naaaaaaaaaaaabbbcccedfcccccccccccccccdddddddddeegffffgghp        hgffgeeeedddccccccccbbbbbbbbbbbb\naaaaaaaaaaaabbbbccccdddcccccccccccccccgdddddddddeegffgil        ggfeeeeddddcccccccbbbbbbbbbbbbbb\naaaaaaaaaaaaabbbbbccccdddccccccccccccccfeddddddddeeeefgi l   nkqgeeegeddddcccccccbbbbbbbbbbbbbbb\naaaaaaaaaaaaabbbbbbcccccdedccccccccccccccdedddddddeeeeeghik  khhfeefdddddeccccccbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaabbbbbbccccccdddcccccccccccccddedddddddeeefigil jggfedddddddcccccbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaabbbbbbbcccccccdccccccccccccccdefdddddeeeffhlliimfdddddedccccccbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaabbbbbbbccccccdddccccccccccccccdddddddeeefg jggheddddedccccccbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaabbbbbbbbbccccccdddccccccccccccccdedddddefgiffeeddddeccccccbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaaabbbbbbbbbbecccccdeeccccccccccccccceddddeffegddddgcccccbbbbbbbbbbbbbbbbbbbbbbbbb\naaaaaaaaaaaaaaaaaabbbbbbbbbbbbcccccdddcccccccccccccccccddddddddccccccbbbbbbbbbbbbbbbbbbbbbbbbbbc\naaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbccccddeccccccccccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbed\naaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbccceddcccccccccccccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccd\naaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbdcccccccccbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbecccc\naaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbccdebb\naaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbdfccbbb\naaaaaaaaaaaaaaaaaaaaaaaaabbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbbcgdccbbbb\n\n", "explain": "Here is one file program. It directly creates ppm file.\nInfinitely zoomable OpenGL program.  Adjustable colors, max iteration, black and white, screen dump, etc. Compile with gcc mandelbrot.c -lglut -lGLU -lGL -lm\nThe following version should work on architectures (such as x86/x86-64) that allow unaligned pointers.\nHere is a variant that hopefully will work on a broader range of architectures, although it has been tested only on x86-64.\n(PLEASE FIXME: Does resizing work correctly, in either version?)\nNot mine, found it on Ken Perlin's homepage, this deserves a place here to illustrate how awesome C can be:\nThere may be warnings on compiling but disregard them, the output will be produced nevertheless. Such programs are called obfuscated and C excels when it comes to writing such cryptic programs. Google IOCCC for more.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "C++", "code": "\n\n#include <cstdlib>\n#include <complex>\n\n// get dimensions for arrays\ntemplate<typename ElementType, std::size_t dim1, std::size_t dim2>\n std::size_t get_first_dimension(ElementType (&a)[dim1][dim2])\n{\n  return dim1;\n}\n\ntemplate<typename ElementType, std::size_t dim1, std::size_t dim2>\n std::size_t get_second_dimension(ElementType (&a)[dim1][dim2])\n{\n  return dim2;\n}\n\n\ntemplate<typename ColorType, typename ImageType>\n void draw_Mandelbrot(ImageType& image,                                   //where to draw the image\n                      ColorType set_color, ColorType non_set_color,       //which colors to use for set/non-set points\n                      double cxmin, double cxmax, double cymin, double cymax,//the rect to draw in the complex plane\n                      unsigned int max_iterations)                          //the maximum number of iterations\n{\n  std::size_t const ixsize = get_first_dimension(image);\n  std::size_t const iysize = get_first_dimension(image);\n  for (std::size_t ix = 0; ix < ixsize; ++ix)\n    for (std::size_t iy = 0; iy < iysize; ++iy)\n    {\n      std::complex<double> c(cxmin + ix/(ixsize-1.0)*(cxmax-cxmin), cymin + iy/(iysize-1.0)*(cymax-cymin));\n      std::complex<double> z = 0;\n      unsigned int iterations;\n\n      for (iterations = 0; iterations < max_iterations && std::abs(z) < 2.0; ++iterations) \n        z = z*z + c;\n\n      image[ix][iy] = (iterations == max_iterations) ? set_color : non_set_color;\n\n    }\n}\n\n\n\n\n#include <stdio.h>\n\nint f(float X, float Y, float x, float y, int n){\nreturn (x*x+y*y<4 && n<100)?1+f(X, Y, x*x-y*y+X, 2*x*y+Y, n+1):0;\n}\n\nmain(){\nfor(float j=1; j>=-1; j-=.015)\nfor(float i=-2, x; i<=.5; i+=.015, x=f(i, j, 0, 0, 0))\nprintf(\"%c%s\", x<10?' ':x<20?'.':x<50?':':x<80?'*':'#', i>-2?\" \":\"\\n\");\n}\n\n", "explain": "This generic function assumes that the image can be accessed like a two-dimensional array of colors. It may be passed a true array (in which case the Mandelbrot set will simply be drawn into that array, which then might be saved as image file), or a class which maps the subscript operator to the pixel drawing routine of some graphics library. In the latter case, there must be functions get_first_dimension and get_second_dimension defined for that type, to be found by argument dependent lookup. The code provides those functions for built-in arrays.\nNote this code has not been executed.\n\nA Simple version in CPP. Definitely not as crazy good as the ASCII one in C above.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Java", "code": "\nLibrary: Swing Library: AWT\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\n\npublic class Mandelbrot extends JFrame {\n\n    private final int MAX_ITER = 570;\n    private final double ZOOM = 150;\n    private BufferedImage I;\n    private double zx, zy, cX, cY, tmp;\n\n    public Mandelbrot() {\n        super(\"Mandelbrot Set\");\n        setBounds(100, 100, 800, 600);\n        setResizable(false);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        I = new BufferedImage(getWidth(), getHeight(), BufferedImage.TYPE_INT_RGB);\n        for (int y = 0; y < getHeight(); y++) {\n            for (int x = 0; x < getWidth(); x++) {\n                zx = zy = 0;\n                cX = (x - 400) / ZOOM;\n                cY = (y - 300) / ZOOM;\n                int iter = MAX_ITER;\n                while (zx * zx + zy * zy < 4 && iter > 0) {\n                    tmp = zx * zx - zy * zy + cX;\n                    zy = 2.0 * zx * zy + cY;\n                    zx = tmp;\n                    iter--;\n                }\n                I.setRGB(x, y, iter | (iter << 8));\n            }\n        }\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.drawImage(I, 0, 0, this);\n    }\n\n    public static void main(String[] args) {\n        new Mandelbrot().setVisible(true);\n    }\n}\n\nInteractive[edit]\nLibrary: AWT Library: Swing\nimport static java.awt.Color.HSBtoRGB;\nimport static java.awt.Color.black;\nimport static java.awt.event.KeyEvent.VK_BACK_SLASH;\nimport static java.awt.event.KeyEvent.VK_ESCAPE;\nimport static java.awt.image.BufferedImage.TYPE_INT_RGB;\nimport static java.lang.Integer.signum;\nimport static java.lang.Math.abs;\nimport static java.lang.Math.max;\nimport static java.lang.Math.min;\nimport static java.lang.System.currentTimeMillis;\nimport static java.util.Locale.ROOT;\n\nimport java.awt.Dimension;\nimport java.awt.Graphics;\nimport java.awt.Insets;\nimport java.awt.event.KeyAdapter;\nimport java.awt.event.KeyEvent;\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.image.BufferedImage;\nimport java.util.function.Consumer;\nimport java.util.function.Predicate;\n\nimport javax.swing.JFrame;\n\n/* \n *      click: point to center\n * ctrl-click: point to origin\n *       drag: point to mouse release point\n *  ctrl-drag: point to origin + zoom\n * back-slash: back to previous point      \n *        esc: back to previous zoom point - zoom     \n */\n\npublic class Mandelbrot extends JFrame {\n\tprivate static final long serialVersionUID = 1L;\n\t\n\tprivate Insets insets;\n\tprivate int width, height;\n\tprivate double widthHeightRatio;\n\tprivate int minX, minY;\n\tprivate double Zoom;\n\t\t\n\tprivate int mpX, mpY, mdX, mdY;\n\tprivate boolean isCtrlDown, ctrl;\n\tprivate Stack stack = new Stack();\n\t\n\tprivate BufferedImage image;\n\tprivate boolean newImage = true;\n\t\n\tpublic static void main(String[] args) {\n\t\tnew Mandelbrot(800, 600); // (800, 600), (1024, 768), (1600, 900), (1920, 1080)\n\t\t//new Mandelbrot(800, 600, 4.5876514379235943e-09, -0.6092161175392330, -0.4525577210859453);\n\t\t//new Mandelbrot(800, 600, 5.9512354925205320e-10, -0.6092146769531246, -0.4525564820098262);\n\t\t//new Mandelbrot(800, 600, 6.7178527589983420e-08, -0.7819036465400592, -0.1298363433443265);\n\t\t//new Mandelbrot(800, 600, 4.9716091454775210e-09, -0.7818800036717134, -0.1298044093748981);\n\t\t//new Mandelbrot(800, 600, 7.9333341281639390e-06, -0.7238770725243187, -0.2321214232559487); \n\t\t/*\n\t\tnew Mandelbrot(800, 600, new double[][] {\n\t\t\t{5.0000000000000000e-03, -2.6100000000000000, -1.4350000000000000}, // done!\n\t\t\t{3.5894206549118390e-04, -0.7397795969773300, -0.4996473551637279}, // done!\n\t\t\t{3.3905106941862460e-05, -0.6270410477828043, -0.4587021918164572}, // done!\n\t\t\t{6.0636337351945460e-06, -0.6101531446039512, -0.4522561221394852}, // done!\n\t\t\t{1.5502741161769430e-06, -0.6077214060084073, -0.4503995886987711}, // done!\n\t\t});\n\t\t//*/\n\t}\n\t\n\tpublic Mandelbrot(int width, int height) {\n\t\tthis(width, height, .005, -2.61, -1.435);\n\t}\n\t\n\tpublic Mandelbrot(int width, int height, double Zoom, double r, double i) {\n\t\tthis(width, height, new double[] {Zoom, r, i});\n\t}\n\t\n\tpublic Mandelbrot(int width, int height, double[] ... points) {\n\t\tsuper(\"Mandelbrot Set\");\n\t\tsetResizable(false);\n\t\tsetDefaultCloseOperation(EXIT_ON_CLOSE);\n\t\tDimension screen = getToolkit().getScreenSize();\n\t\tsetBounds(\n\t\t\trint((screen.getWidth() - width) / 2),\n\t\t\trint((screen.getHeight() - height) / 2),\n\t\t\twidth,\n\t\t\theight\n\t\t);\n\t\taddMouseListener(mouseAdapter);\n\t\taddMouseMotionListener(mouseAdapter);\n\t\taddKeyListener(keyAdapter);\n\t\tPoint point = stack.push(points);\n\t\tthis.Zoom = point.Zoom;\n\t\tthis.minX = point.minX;\n\t\tthis.minY = point.minY;\n\t\tsetVisible(true);\n\t\tinsets = getInsets();\n\t\tthis.width = width -= insets.left + insets.right;\n\t\tthis.height = height -= insets.top + insets.bottom;\n\t\twidthHeightRatio = (double) width / height;\n\t}\n\t\n\tprivate int rint(double d) {\n\t\treturn (int) Math.rint(d); // half even\n\t}\n\n\tprivate void repaint(boolean newImage) {\n\t\tthis.newImage = newImage;\n\t\trepaint();\n\t}\n\n\tprivate MouseAdapter mouseAdapter = new MouseAdapter() {\n\t\tpublic void mouseClicked(MouseEvent e) {\n\t\t\tstack.push(false);\n\t\t\tif (!ctrl) {\n\t\t\t\tminX -= width / 2 ;\n\t\t\t\tminY -= height / 2;\n\t\t\t}\n\t\t\tminX += e.getX() - insets.left;\n\t\t\tminY += e.getY() - insets.top;\n\t\t\tctrl = false;\n\t\t\trepaint(true);\n\t \t}\n\t\tpublic void mousePressed(MouseEvent e) {\n\t\t\tmpX = e.getX();\n\t\t\tmpY = e.getY();\n\t\t\tctrl = isCtrlDown;\n\t\t}\n\t\tpublic void mouseDragged(MouseEvent e) {\n\t\t\tif (!ctrl) return;\n\t\t\tsetMdCoord(e);\n\t\t\trepaint();\n\t\t}\n\t\tprivate void setMdCoord(MouseEvent e) {\n\t\t\tint dx = e.getX() - mpX;\n\t\t\tint dy = e.getY() - mpY;\n\t\t\tmdX = mpX + max(abs(dx), rint(abs(dy) * widthHeightRatio) * signum(dx));\n\t\t\tmdY = mpY + max(abs(dy), rint(abs(dx) / widthHeightRatio) * signum(dy));\n\t\t\tacceptIf(insets.left, ge(mdX), setMdXY); \n\t\t\tacceptIf(insets.top,  ge(mdY), setMdYX);\n\t\t\tacceptIf(insets.left+width-1, le(mdX), setMdXY); \n\t\t\tacceptIf(insets.top+height-1, le(mdY), setMdYX);\n\t\t}\n\t\tprivate void acceptIf(int value, Predicate<Integer> p, Consumer<Integer> c) { if (p.test(value)) c.accept(value); }\n\t\tprivate Predicate<Integer> ge(int md) { return v-> v >= md; }\n\t\tprivate Predicate<Integer> le(int md) { return v-> v <= md; }\n\t\tprivate Consumer<Integer> setMdXY = v-> mdY = mpY + rint(abs((mdX=v)-mpX) / widthHeightRatio) * signum(mdY-mpY);\n\t\tprivate Consumer<Integer> setMdYX = v-> mdX = mpX + rint(abs((mdY=v)-mpY) * widthHeightRatio) * signum(mdX-mpX);\n\t\tpublic void mouseReleased(MouseEvent e) {\n\t\t\tif (e.getX() == mpX && e.getY() == mpY) return; \n\t\t\tstack.push(ctrl);\n\t\t\tif (!ctrl) {\n\t\t\t\tminX += mpX - (mdX = e.getX());\n\t\t\t\tminY += mpY - (mdY = e.getY());\n\t\t\t}\n\t\t\telse {\n\t\t\t\tsetMdCoord(e);\n\t\t\t\tif (mdX < mpX) { int t=mpX; mpX=mdX; mdX=t; } \n\t\t\t\tif (mdY < mpY) { int t=mpY; mpY=mdY; mdY=t; } \n\t\t\t\tminX += mpX - insets.left;\n\t\t\t\tminY += mpY - insets.top;\n\t\t\t\tdouble rZoom = (double) width / abs(mdX - mpX);\n\t\t\t\tminX *= rZoom;\n\t\t\t\tminY *= rZoom;\n\t\t\t\tZoom /= rZoom;\n\t\t\t}\n\t\t\tctrl = false;\n\t\t\trepaint(true);\t\t\n\t\t}\n\t};\n\t\n\tprivate KeyAdapter keyAdapter = new KeyAdapter() {\n\t\tpublic void keyPressed(KeyEvent e) {\n\t\t\tisCtrlDown = e.isControlDown();\n\t\t}\n\t\tpublic void keyReleased(KeyEvent e) {\n\t\t\tisCtrlDown = e.isControlDown();\n\t\t}\n\t\tpublic void keyTyped(KeyEvent e) {\n\t\t\tchar c = e.getKeyChar();\n\t\t\tboolean isEsc = c == VK_ESCAPE;\n\t\t\tif (!isEsc && c != VK_BACK_SLASH) return;\n\t\t\trepaint(stack.pop(isEsc));\n\t\t}\n\t};\n\t\n\tprivate class Point {\n\t\tpublic boolean type;\n\t\tpublic double Zoom;\n\t\tpublic int minX;\n\t\tpublic int minY;\n\t\tPoint(boolean type, double Zoom, int minX, int minY) {\n\t\t\tthis.type = type;\n\t\t\tthis.Zoom = Zoom;\n\t\t\tthis.minX = minX;\n\t\t\tthis.minY = minY;\n\t\t}\n\t}\n\tprivate class Stack extends java.util.Stack<Point> {\n\t\tprivate static final long serialVersionUID = 1L;\n\t\tpublic Point push(boolean type) {\n\t\t\treturn push(type, Zoom, minX, minY);\n\t\t}\n\t\tpublic Point push(boolean type, double ... point) {\n\t\t\tdouble Zoom = point[0];\n\t\t\treturn push(type, Zoom, rint(point[1]/Zoom), rint(point[2]/Zoom));\n\t\t}\n\t\tpublic Point push(boolean type, double Zoom, int minX, int minY) {\n\t\t\treturn push(new Point(type, Zoom, minX, minY));\n\t\t}\n\t\tpublic Point push(double[] ... points) {\n\t\t\tPoint lastPoint = push(false, points[0]);\n\t\t\tfor (int i=0, e=points.length-1; i<e; i+=1) {\n\t\t\t\tdouble[] point = points[i];\n\t\t\t\tlastPoint = push(point[0] != points[i+1][0], point);\n\t\t\t\tdone(printPoint(lastPoint));\n\t\t\t}\n\t\t\treturn lastPoint;\n\t\t}\n\t\tpublic boolean pop(boolean type) {\n\t\t\tfor (;;) {\n\t\t\t\tif (empty()) return false;\n\t\t\t\tPoint d = super.pop();\n\t\t\t\tZoom = d.Zoom;\n\t\t\t\tminX = d.minX;\n\t\t\t\tminY = d.minY;\n\t\t\t\tif (!type || d.type) return true;\n\t\t\t}\n\t\t}\n\t}\n\t\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tif (newImage) newImage();\n\t\tg.drawImage(image, insets.left, insets.top, this);\n\t\t//g.drawLine(insets.left+width/2, insets.top+0,        insets.left+width/2, insets.top+height);\n\t\t//g.drawLine(insets.left+0,       insets.top+height/2, insets.left+width,   insets.top+height/2);\n\t\tif (!ctrl) return;\n\t\tg.drawRect(min(mpX, mdX), min(mpY, mdY), abs(mpX - mdX), abs(mpY - mdY));\n\t}\n\n\tprivate void newImage() {\n\t\tlong milli = printPoint();\n\t\timage = new BufferedImage(width, height, TYPE_INT_RGB);\n\t\tint maxX = minX + width;\n\t\tint maxY = minY + height;\n\t\tfor (int x = minX; x < maxX; x+=1) {\n\t\t\tdouble r = x * Zoom;\n\t\t\tfor (int y = minY; y < maxY; y+=1) {\n\t\t\t\tdouble i = y * Zoom;\n\t\t\t\t//System.out.printf(\"%+f%+fi\\n\", r, i);\n\t\t\t\t//             0f    1/6f  1/3f 1/2f 2/3f    5/6f\n\t\t\t\t//straight -> red  yellow green cian blue magenta <- reverse \n\t\t\t\timage.setRGB(x-minX, y-minY, color(r, i, 360, false, 2/3f));\n\t\t\t}\n\t\t}\n\t\tnewImage = false;\n\t\tdone(milli);\n\t}\n\n\tprivate long printPoint() {\n\t\treturn printPoint(Zoom, minX, minY);\n\t}\n\tprivate long printPoint(Point point) {\n\t\treturn printPoint(point.Zoom, point.minX, point.minY);\n\t}\n\tprivate long printPoint(double Zoom, int minX, int minY) {\n\t\treturn printPoint(Zoom, minX*Zoom, minY*Zoom);\n\t}\n\tprivate long printPoint(Object ... point) {\n\t\tSystem.out.printf(ROOT,\t\"{%.16e,\u00a0%.16g,\u00a0%.16g},\", point);\n\t\treturn currentTimeMillis();\n\t}\n\t\n\tprivate void done(long milli) {\n\t\tmilli = currentTimeMillis() - milli;\n\t\tSystem.out.println(\" // \" + milli + \"ms done!\");\n\t}\n\n\tprivate int color(double r0, double i0, int max, boolean straight, float shift) {\n\t\tint n = -1;\n\t\tdouble r=0, i=0, r2=0, i2=0;\n\t\tdo {\n\t\t\ti = r*(i+i) + i0;\n\t\t\tr = r2-i2 + r0;\n\t\t\tr2 = r*r;\n\t\t\ti2 = i*i;\n\t\t}\n\t\twhile (++n < max && r2 + i2 < 4); \n\t\treturn n == max\n\t\t\t? black.getRGB()\n\t\t\t: HSBtoRGB(shift + (float) (straight ? n : max-n) / max * 11/12f + (straight ? 0f : 1/12f), 1, 1)\n\t\t;\t\t\n\t}\n}\n\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "C#", "code": "\nusing System;\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Threading;\nusing System.Windows.Forms;\n\n/// <summary>\n/// Generates bitmap of Mandelbrot Set and display it on the form.\n/// </summary>\npublic class MandelbrotSetForm : Form\n{\n    const double MaxValueExtent = 2.0;\n    Thread thread;\n\n    static double CalcMandelbrotSetColor(ComplexNumber c)\n    {\n        // from http://en.wikipedia.org/w/index.php?title=Mandelbrot_set\n        const int MaxIterations = 1000;\n        const double MaxNorm = MaxValueExtent * MaxValueExtent;\n\n        int iteration = 0;\n        ComplexNumber z = new ComplexNumber();\n        do\n        {\n            z = z * z + c;\n            iteration++;\n        } while (z.Norm() < MaxNorm && iteration < MaxIterations);\n        if (iteration < MaxIterations)\n            return (double)iteration / MaxIterations;\n        else\n            return 0; // black\n    }\n\n    static void GenerateBitmap(Bitmap bitmap)\n    {\n        double scale = 2 * MaxValueExtent / Math.Min(bitmap.Width, bitmap.Height);\n        for (int i = 0; i < bitmap.Height; i++)\n        {\n            double y = (bitmap.Height / 2 - i) * scale;\n            for (int j = 0; j < bitmap.Width; j++)\n            {\n                double x = (j - bitmap.Width / 2) * scale;\n                double color = CalcMandelbrotSetColor(new ComplexNumber(x, y));\n                bitmap.SetPixel(j, i, GetColor(color));\n            }\n        }\n    }\n\n    static Color GetColor(double value)\n    {\n        const double MaxColor = 256;\n        const double ContrastValue = 0.2;\n        return Color.FromArgb(0, 0,\n            (int)(MaxColor * Math.Pow(value, ContrastValue)));\n    }\n    \n    public MandelbrotSetForm()\n    {\n        // form creation\n        this.Text = \"Mandelbrot Set Drawing\";\n        this.BackColor = System.Drawing.Color.Black;\n        this.BackgroundImageLayout = System.Windows.Forms.ImageLayout.Stretch;\n        this.MaximizeBox = false;\n        this.StartPosition = FormStartPosition.CenterScreen;\n        this.FormBorderStyle = FormBorderStyle.FixedDialog;\n        this.ClientSize = new Size(640, 640);\n        this.Load += new System.EventHandler(this.MainForm_Load);\n    }\n\n    void MainForm_Load(object sender, EventArgs e)\n    {\n        thread = new Thread(thread_Proc);\n        thread.IsBackground = true;\n        thread.Start(this.ClientSize);\n    }\n\n    void thread_Proc(object args)\n    {\n        // start from small image to provide instant display for user\n        Size size = (Size)args;\n        int width = 16;\n        while (width * 2 < size.Width)\n        {\n            int height = width * size.Height / size.Width;\n            Bitmap bitmap = new Bitmap(width, height, PixelFormat.Format24bppRgb);\n            GenerateBitmap(bitmap);\n            this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), bitmap);\n            width *= 2;\n            Thread.Sleep(200);\n        }\n        // then generate final image\n        Bitmap finalBitmap = new Bitmap(size.Width, size.Height, PixelFormat.Format24bppRgb);\n        GenerateBitmap(finalBitmap);\n        this.BeginInvoke(new SetNewBitmapDelegate(SetNewBitmap), finalBitmap);\n    }\n\n    void SetNewBitmap(Bitmap image)\n    {\n        if (this.BackgroundImage != null)\n            this.BackgroundImage.Dispose();\n        this.BackgroundImage = image;\n    }\n\n    delegate void SetNewBitmapDelegate(Bitmap image);\n\n    static void Main()\n    {\n        Application.Run(new MandelbrotSetForm());\n    }\n}\n\nstruct ComplexNumber\n{\n    public double Re;\n    public double Im;\n\n    public ComplexNumber(double re, double im)\n    {\n        this.Re = re;\n        this.Im = im;\n    }\n\n    public static ComplexNumber operator +(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re + y.Re, x.Im + y.Im);\n    }\n\n    public static ComplexNumber operator *(ComplexNumber x, ComplexNumber y)\n    {\n        return new ComplexNumber(x.Re * y.Re - x.Im * y.Im,\n            x.Re * y.Im + x.Im * y.Re);\n    }\n\n    public double Norm()\n    {\n        return Re * Re + Im * Im;\n    }\n}\n\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nWorks with: Firefox version 3.5.11\n\nfunction mandelIter(cx, cy, maxIter) {\n  var x = 0.0;\n  var y = 0.0;\n  var xx = 0;\n  var yy = 0;\n  var xy = 0;\n\n  var i = maxIter;\n  while (i-- && xx + yy <= 4) {\n    xy = x * y;\n    xx = x * x;\n    yy = y * y;\n    x = xx - yy + cx;\n    y = xy + xy + cy;\n  }\n  return maxIter - i;\n}\n\nfunction mandelbrot(canvas, xmin, xmax, ymin, ymax, iterations) {\n  var width = canvas.width;\n  var height = canvas.height;\n\n  var ctx = canvas.getContext('2d');\n  var img = ctx.getImageData(0, 0, width, height);\n  var pix = img.data;\n  \n  for (var ix = 0; ix < width; ++ix) {\n    for (var iy = 0; iy < height; ++iy) {\n      var x = xmin + (xmax - xmin) * ix / (width - 1);\n      var y = ymin + (ymax - ymin) * iy / (height - 1);\n      var i = mandelIter(x, y, iterations);\n      var ppos = 4 * (width * iy + ix);\n      \n      if (i > iterations) {\n        pix[ppos] = 0;\n        pix[ppos + 1] = 0;\n        pix[ppos + 2] = 0;\n      } else {\n        var c = 3 * Math.log(i) / Math.log(iterations - 1.0);\n        \n        if (c < 1) {\n          pix[ppos] = 255 * c;\n          pix[ppos + 1] = 0;\n          pix[ppos + 2] = 0;\n        }\n        else if ( c < 2 ) {\n          pix[ppos] = 255;\n          pix[ppos + 1] = 255 * (c - 1);\n          pix[ppos + 2] = 0;\n        } else {\n          pix[ppos] = 255;\n          pix[ppos + 1] = 255;\n          pix[ppos + 2] = 255 * (c - 2);\n        }\n      }\n      pix[ppos + 3] = 255;\n    }\n  }\n  \n  ctx.putImageData(img, 0, 0);\n}\n\nvar canvas = document.createElement('canvas');\ncanvas.width = 900;\ncanvas.height = 600;\n\ndocument.body.insertBefore(canvas, document.body.childNodes[0]);\n\nmandelbrot(canvas, -2, 1, -1, 1, 1000);\n\n\nOutput: with default parameters\n\n\nES6/WebAssembly[edit]\n\nvar mandelIter;\nfetch(\"./mandelIter.wasm\")\n    .then(res => {\n        if (res.ok) return res.arrayBuffer();\n        throw new Error('Unable to fetch WASM.');\n    })\n    .then(bytes => { return WebAssembly.compile(bytes); })\n    .then(module => { return WebAssembly.instantiate(module); })\n    .then(instance => { WebAssembly.instance = instance; draw(); })\n\nfunction mandelbrot(canvas, xmin, xmax, ymin, ymax, iterations) {\n    // ...\n    var i = WebAssembly.instance.exports.mandelIter(x, y, iterations);\n    // ...\n}\n\nfunction draw() {\n    // canvas initialization if necessary\n    // ...\n    mandelbrot(canvas, -2, 1, -1, 1, 1000);\n    // ...\n}\n\n", "explain": "This needs the canvas tag of HTML 5 (it will not run on IE8 and lower or old browsers).\nThe code can be run directly from the Javascript console in modern browsers by copying and pasting it.\n\nWith ES6 and WebAssembly, the program can run faster.  Of course, this requires a compiled WASM file, but one can easily build\none for instance with the WebAssembly explorer\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "PHP", "code": "\nLibrary: GD Graphics Library\nWorks with: PHP version 5.3.5\nSample output\n$min_x=-2;\n$max_x=1;\n$min_y=-1;\n$max_y=1;\n\n$dim_x=400;\n$dim_y=300;\n\n$im = @imagecreate($dim_x, $dim_y)\n  or die(\"Cannot Initialize new GD image stream\");\nheader(\"Content-Type: image/png\");\n$black_color = imagecolorallocate($im, 0, 0, 0);\n$white_color = imagecolorallocate($im, 255, 255, 255);\n\nfor($y=0;$y<=$dim_y;$y++) {\n  for($x=0;$x<=$dim_x;$x++) {\n    $c1=$min_x+($max_x-$min_x)/$dim_x*$x;\n    $c2=$min_y+($max_y-$min_y)/$dim_y*$y;\n\n    $z1=0;\n    $z2=0;\n\n    for($i=0;$i<100;$i++) {\n      $new1=$z1*$z1-$z2*$z2+$c1;\n      $new2=2*$z1*$z2+$c2;\n      $z1=$new1;\n      $z2=$new2;\n      if($z1*$z1+$z2*$z2>=4) {\n        break;\n      }\n    }\n    if($i<100) {\n      imagesetpixel ($im, $x, $y, $white_color);\n    }\n  }\n}\n\nimagepng($im);\nimagedestroy($im);\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "MATLAB", "code": "\n\nfunction [theSet,realAxis,imaginaryAxis] = mandelbrotSet(start,gridSpacing,last,maxIteration)\n\n    %Define the escape time algorithm\n    function escapeTime = escapeTimeAlgorithm(z0)\n        \n        escapeTime = 0;\n        z = 0;\n        \n        while( (abs(z)<=2) && (escapeTime < maxIteration) )\n            z = (z + z0)^2;            \n            escapeTime = escapeTime + 1;\n        end\n                \n    end\n    \n    %Define the imaginary axis\n    imaginaryAxis = (imag(start):imag(gridSpacing):imag(last));\n    \n    %Define the real axis\n    realAxis = (real(start):real(gridSpacing):real(last));\n    \n    %Construct the complex plane from the real and imaginary axes\n    complexPlane = meshgrid(realAxis,imaginaryAxis) + meshgrid(imaginaryAxis(end:-1:1),realAxis)'.*i;\n    \n    %Apply the escape time algorithm to each point in the complex plane \n    theSet = arrayfun(@escapeTimeAlgorithm, complexPlane);\n    \n\n    %Draw the set\n    pcolor(realAxis,imaginaryAxis,theSet);\n    shading flat;\n    \nend\n\n\nlower left hand corner of the complex plane from which to start the image,  \n  the grid spacing in both the imaginary and real directions,\n  the upper right hand corner of the complex plane at which to end the image and\n  the maximum iterations for the escape time algorithm.\n\n\n\nLower Left Corner: -2.05-1.2i\n  Grid Spacing: 0.004+0.0004i\n  Upper Right Corner: 0.45+1.2i\n  Maximum Iterations: 500\n\n\nmandelbrotSet(-2.05-1.2i,0.004+0.0004i,0.45+1.2i,500);\n", "explain": "This solution uses the escape time algorithm to determine the coloring of the coordinates on the complex plane. The code can be reduced to a single line via vectorization after the Escape Time Algorithm function definition, but the code becomes unnecessarily obfuscated. Also, this code uses a lot of memory. You will need a computer with a lot of memory to compute the set with high resolution.\nTo use this function you must specify the:\nFor example:\nSample usage:\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram mandelbrot\n\n  implicit none\n  integer  , parameter :: rk       = selected_real_kind (9, 99)\n  integer  , parameter :: i_max    =  800\n  integer  , parameter :: j_max    =  600\n  integer  , parameter :: n_max    =  100\n  real (rk), parameter :: x_centre = -0.5_rk\n  real (rk), parameter :: y_centre =  0.0_rk\n  real (rk), parameter :: width    =  4.0_rk\n  real (rk), parameter :: height   =  3.0_rk\n  real (rk), parameter :: dx_di    =   width / i_max\n  real (rk), parameter :: dy_dj    = -height / j_max\n  real (rk), parameter :: x_offset = x_centre - 0.5_rk * (i_max + 1) * dx_di\n  real (rk), parameter :: y_offset = y_centre - 0.5_rk * (j_max + 1) * dy_dj\n  integer, dimension (i_max, j_max) :: image\n  integer   :: i\n  integer   :: j\n  integer   :: n\n  real (rk) :: x\n  real (rk) :: y\n  real (rk) :: x_0\n  real (rk) :: y_0\n  real (rk) :: x_sqr\n  real (rk) :: y_sqr\n\n  do j = 1, j_max\n    y_0 = y_offset + dy_dj * j\n    do i = 1, i_max\n      x_0 = x_offset + dx_di * i\n      x = 0.0_rk\n      y = 0.0_rk\n      n = 0\n      do\n        x_sqr = x ** 2\n        y_sqr = y ** 2\n        if (x_sqr + y_sqr > 4.0_rk) then\n          image (i, j) = 255\n          exit\n        end if\n        if (n == n_max) then\n          image (i, j) = 0\n          exit\n        end if\n        y = y_0 + 2.0_rk * x * y\n        x = x_0 + x_sqr - y_sqr\n        n = n + 1\n      end do\n    end do\n  end do\n  open  (10, file = 'out.pgm')\n  write (10, '(a/ i0, 1x, i0/ i0)') 'P2', i_max, j_max, 255\n  write (10, '(i0)') image\n  close (10)\n\nend program mandelbrot\nbs\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Scratch", "code": "\n\n", "explain": "\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Go", "code": "\nText\n\npackage main\n\nimport \"fmt\"\nimport \"math/cmplx\"\n\nfunc mandelbrot(a complex128) (z complex128) {\n    for i := 0; i < 50; i++ {\n        z = z*z + a\n    }\n    return\n}\n\nfunc main() {\n    for y := 1.0; y >= -1.0; y -= 0.05 {\n        for x := -2.0; x <= 0.5; x += 0.0315 {\n            if cmplx.Abs(mandelbrot(complex(x, y))) < 2 {\n                fmt.Print(\"*\")\n            } else {\n                fmt.Print(\" \")\n            }\n        }\n        fmt.Println(\"\")\n    }\n}\n\nGraphical\n.png image\npackage main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/draw\"\n    \"image/png\"\n    \"math/cmplx\"\n    \"os\"\n)\n\nconst (\n    maxEsc = 100\n    rMin   = -2.\n    rMax   = .5\n    iMin   = -1.\n    iMax   = 1.\n    width  = 750\n    red    = 230\n    green  = 235\n    blue   = 255\n)\n\nfunc mandelbrot(a complex128) float64 {\n    i := 0\n    for z := a; cmplx.Abs(z) < 2 && i < maxEsc; i++ {\n        z = z*z + a\n    }\n    return float64(maxEsc-i) / maxEsc\n}\n\nfunc main() {\n    scale := width / (rMax - rMin)\n    height := int(scale * (iMax - iMin))\n    bounds := image.Rect(0, 0, width, height)\n    b := image.NewNRGBA(bounds)\n    draw.Draw(b, bounds, image.NewUniform(color.Black), image.ZP, draw.Src)\n    for x := 0; x < width; x++ {\n        for y := 0; y < height; y++ {\n            fEsc := mandelbrot(complex(\n                float64(x)/scale+rMin,\n                float64(y)/scale+iMin))\n            b.Set(x, y, color.NRGBA{uint8(red * fEsc),\n                uint8(green * fEsc), uint8(blue * fEsc), 255})\n\n        }\n    }\n    f, err := os.Create(\"mandelbrot.png\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    if err = png.Encode(f, b); err != nil {\n        fmt.Println(err)\n    }\n    if err = f.Close(); err != nil {\n        fmt.Println(err)\n    }\n}\n\n\n", "explain": "Prints an 80-char by 41-line depiction.\n\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Ruby", "code": "\n\nrequire 'complex'\n\ndef mandelbrot(a)\n  Array.new(50).inject(0) { |z,c| z*z + a }\nend\n\n(1.0).step(-1,-0.05) do |y|\n  (-2.0).step(0.5,0.0315) do |x|\n    print mandelbrot(Complex(x,y)).abs < 2\u00a0? '*'\u00a0: ' '\n  end\n  puts\nend\nTranslation of: Tcl\n\n# frozen_string_literal: true\n\nrequire_relative 'raster_graphics'\n\nclass RGBColour\n  def self.mandel_colour(i)\n    self.new( 16*(i\u00a0% 15), 32*(i\u00a0% 7), 8*(i\u00a0% 31) )\n  end\nend\n\nclass Pixmap\n  def self.mandelbrot(width, height)\n    mandel = Pixmap.new(width,height)\n    pb = ProgressBar.new(width) if $DEBUG\n    width.times do |x|\n      height.times do |y|\n        x_ish = Float(x - width*11/15) / (width/3)\n        y_ish = Float(y - height/2) / (height*3/10)\n        mandel[x,y] = RGBColour.mandel_colour(mandel_iters(x_ish, y_ish))\n      end\n      pb.update(x) if $DEBUG\n    end\n    pb.close if $DEBUG\n    mandel\n  end\n\n  def self.mandel_iters(cx,cy)\n    x = y = 0.0\n    count = 0\n    while Math.hypot(x,y) < 2 and count < 255\n      x, y = (x**2 - y**2 + cx), (2*x*y + cy)\n      count += 1\n    end\n    count\n  end\nend\n\nPixmap.mandelbrot(300,300).save('mandel.ppm')\nLibrary: RubyGems\nLibrary: JRubyArt\n\n# frozen_string_literal: true\n\ndef setup\n  sketch_title 'Mandelbrot'\n  load_pixels\n  no_loop\nend\n\ndef draw\n  grid(900, 600) do |x, y|\n    const = Complex(\n      map1d(x, (0...900), (-3..1.5)), map1d(y, (0...600), (-1.5..1.5))\n    )\n    pixels[x + y * 900] = color(\n      constrained_map(mandel(const, 20), (5..20), (255..0))\n    )\n  end\n  update_pixels\nend\n\ndef mandel(z, max)\n  score = 0\n  const = z\n  while score < max\n    # z = z^2 + c\n    z *= z\n    z += const\n    break if z.abs > 2\n\n    score += 1\n  end\n  score\nend\n\ndef settings\n  size(900, 600)\nend\n", "explain": "Text only, prints an 80-char by 41-line depiction. Found here.\nUses Raster graphics operations/Ruby\nJRubyArt is a port of processing to ruby\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Rust", "code": "\n\nextern crate image;\nextern crate num_complex;\n\nuse num_complex::Complex;\n\nfn main() {\n    let max_iterations = 256u16;\n    let img_side = 800u32;\n    let cxmin = -2f32;\n    let cxmax = 1f32;\n    let cymin = -1.5f32;\n    let cymax = 1.5f32;\n    let scalex = (cxmax - cxmin) / img_side as f32;\n    let scaley = (cymax - cymin) / img_side as f32;\n\n    // Create a new ImgBuf\n    let mut imgbuf = image::ImageBuffer::new(img_side, img_side);\n\n    // Calculate for each pixel\n    for (x, y, pixel) in imgbuf.enumerate_pixels_mut() {\n        let cx = cxmin + x as f32 * scalex;\n        let cy = cymin + y as f32 * scaley;\n\n        let c = Complex::new(cx, cy);\n        let mut z = Complex::new(0f32, 0f32);\n\n        let mut i = 0;\n        for t in 0..max_iterations {\n            if z.norm() > 2.0 {\n                break;\n            }\n            z = z * z + c;\n            i = t;\n        }\n\n        *pixel = image::Luma([i as u8]);\n    }\n\n    // Save image\n    imgbuf.save(\"fractal.png\").unwrap();\n}\n", "explain": "Dependencies: image, num-complex\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Swift", "code": "\n\nimport Foundation\nimport Numerics\nimport QDBMP\n\npublic typealias Color = (red: UInt8, green: UInt8, blue: UInt8)\n\npublic class BitmapDrawer {\n  public let imageHeight: Int\n  public let imageWidth: Int\n\n  var grid: [[Color?]]\n\n  private let bmp: OpaquePointer\n\n  public init(height: Int, width: Int) {\n    self.imageHeight = height\n    self.imageWidth = width\n    self.grid = [[Color?]](repeating: [Color?](repeating: nil, count: height), count: width)\n    self.bmp = BMP_Create(UInt(width), UInt(height), 24)\n\n    checkError()\n  }\n\n  deinit {\n    BMP_Free(bmp)\n  }\n\n  private func checkError() {\n    let err = BMP_GetError()\n\n    guard err == BMP_STATUS(0) else {\n      fatalError(\"\\(err)\")\n    }\n  }\n\n  public func save(to path: String = \"~/Desktop/out.bmp\") {\n    for x in 0..<imageWidth {\n      for y in 0..<imageHeight {\n        guard let color = grid[x][y] else { continue }\n\n        BMP_SetPixelRGB(bmp, UInt(x), UInt(y), color.red, color.green, color.blue)\n        checkError()\n      }\n    }\n\n    (path as NSString).expandingTildeInPath.withCString {s in\n      BMP_WriteFile(bmp, s)\n    }\n  }\n\n  public func setPixel(x: Int, y: Int, to color: Color?) {\n    grid[x][y] = color\n  }\n}\n\nlet imageSize = 10_000\nlet canvas = BitmapDrawer(height: imageSize, width: imageSize)\nlet maxIterations = 256\nlet cxMin = -2.0\nlet cxMax = 1.0\nlet cyMin = -1.5\nlet cyMax = 1.5\nlet scaleX = (cxMax - cxMin) / Double(imageSize)\nlet scaleY = (cyMax - cyMin) / Double(imageSize)\n\nfor x in 0..<imageSize {\n  for y in 0..<imageSize {\n    let cx = cxMin + Double(x) * scaleX\n    let cy = cyMin + Double(y) * scaleY\n\n    let c = Complex(cx, cy)\n    var z = Complex(0.0, 0.0)\n    var i = 0\n\n    for t in 0..<maxIterations {\n      if z.magnitude > 2 {\n        break\n      }\n\n      z = z * z + c\n      i = t\n    }\n\n    canvas.setPixel(x: x, y: y, to: Color(red: UInt8(i), green: UInt8(i), blue: UInt8(i)))\n  }\n}\n\ncanvas.save()\n", "explain": "Using the Swift Numerics package, as well as the C library Quick 'N Dirty BMP imported in Swift.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "R", "code": "\niterate.until.escape <- function(z, c, trans, cond, max=50, response=dwell) {\n  #we iterate all active points in the same array operation,\n  #and keeping track of which points are still iterating.\n  active <- seq_along(z)\n  dwell <- z\n  dwell[] <- 0\n  for (i in 1:max) {\n    z[active] <- trans(z[active], c[active]);\n    survived <- cond(z[active])\n    dwell[active[!survived]] <- i\n    active <- active[survived]\n    if (length(active) == 0) break\n  }\n  eval(substitute(response))\n}\n\nre = seq(-2, 1, len=500)\nim = seq(-1.5, 1.5, len=500)\nc <- outer(re, im, function(x,y) complex(real=x, imaginary=y))\nx <- iterate.until.escape(array(0, dim(c)), c,\n                          function(z,c)z^2+c, function(z)abs(z) <= 2,\n                          max=100)\nimage(x)\nMandelbrot Set with R Animation[edit]\n\n#install.packages(\"caTools\") # install external package (if missing)\nlibrary(caTools)             # external package providing write.gif function\njet.colors <- colorRampPalette(c(\"red\", \"blue\", \"#007FFF\", \"cyan\", \"#7FFF7F\",\n                                 \"yellow\", \"#FF7F00\", \"red\", \"#7F0000\"))\ndx <- 800                    # define width\ndy <- 600                    # define height\nC  <- complex(real = rep(seq(-2.5, 1.5, length.out = dx), each = dy),\n              imag = rep(seq(-1.5, 1.5, length.out = dy), dx))\nC <- matrix(C, dy, dx)       # reshape as square matrix of complex numbers\nZ <- 0                       # initialize Z to zero\nX <- array(0, c(dy, dx, 20)) # initialize output 3D array\nfor (k in 1:20) {            # loop with 20 iterations\n  Z <- Z^2 + C               # the central difference equation\n  X[, , k] <- exp(-abs(Z))   # capture results\n}\nwrite.gif(X, \"Mandelbrot.gif\", col = jet.colors, delay = 100)\n", "explain": "Modified Mandelbrot set animation by Jarek Tuszynski, PhD. (see: Wikipedia: R (programming_language) and R Tricks: Mandelbrot Set with R Animation)\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "COBOL", "code": "\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. MANDELBROT-SET-PROGRAM.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  COMPLEX-ARITHMETIC.\n    05 X               PIC S9V9(9).\n    05 Y               PIC S9V9(9).\n    05 X-A             PIC S9V9(6).\n    05 X-B             PIC S9V9(6).\n    05 Y-A             PIC S9V9(6).\n    05 X-A-SQUARED     PIC S9V9(6).\n    05 Y-A-SQUARED     PIC S9V9(6).\n    05 SUM-OF-SQUARES  PIC S9V9(6).\n    05 ROOT            PIC S9V9(6).\n01  LOOP-COUNTERS.\n    05 I               PIC 99.\n    05 J               PIC 99.\n    05 K               PIC 999.\n77  PLOT-CHARACTER     PIC X.\nPROCEDURE DIVISION.\nCONTROL-PARAGRAPH.\n    PERFORM OUTER-LOOP-PARAGRAPH\n    VARYING I FROM 1 BY 1 UNTIL I IS GREATER THAN 24.\n    STOP RUN.\nOUTER-LOOP-PARAGRAPH.\n    PERFORM INNER-LOOP-PARAGRAPH\n    VARYING J FROM 1 BY 1 UNTIL J IS GREATER THAN 64.\n    DISPLAY ''.\nINNER-LOOP-PARAGRAPH.\n    MOVE SPACE TO PLOT-CHARACTER.\n    MOVE ZERO  TO X-A.\n    MOVE ZERO  TO Y-A.\n    MULTIPLY J   BY   0.0390625   GIVING X.\n    SUBTRACT 1.5 FROM X.\n    MULTIPLY I   BY   0.083333333 GIVING Y.\n    SUBTRACT 1 FROM Y.\n    PERFORM ITERATION-PARAGRAPH VARYING K FROM 1 BY 1\n    UNTIL K IS GREATER THAN 100 OR PLOT-CHARACTER IS EQUAL TO '#'.\n    DISPLAY PLOT-CHARACTER WITH NO ADVANCING.\nITERATION-PARAGRAPH.\n    MULTIPLY X-A BY X-A GIVING X-A-SQUARED.\n    MULTIPLY Y-A BY Y-A GIVING Y-A-SQUARED.\n    SUBTRACT Y-A-SQUARED FROM X-A-SQUARED GIVING X-B.\n    ADD      X   TO X-B.\n    MULTIPLY X-A BY Y-A GIVING Y-A.\n    MULTIPLY Y-A BY 2   GIVING Y-A.\n    SUBTRACT Y   FROM Y-A.\n    MOVE     X-B TO   X-A.\n    ADD X-A-SQUARED TO Y-A-SQUARED GIVING SUM-OF-SQUARES.\n    MOVE FUNCTION SQRT (SUM-OF-SQUARES) TO ROOT.\n    IF ROOT IS GREATER THAN 2 THEN MOVE '#' TO PLOT-CHARACTER.\n\n\nOutput:\n################################################################\n#################################   ############################\n################################     ###########################\n############################## ##   ############################\n########################  #               ######################\n########################                      ##################\n#####################                          #################\n####################                             ###############\n######## ##    #####                            ################\n#######           #                             ################\n######            #                            #################\n                                            ####################\n######            #                            #################\n#######           #                             ################\n######## ##    #####                            ################\n####################                             ###############\n#####################                          #################\n########################                      ##################\n########################  #               ######################\n############################## ##   ############################\n################################     ###########################\n#################################   ############################\n################################################################\n################################################################\n", "explain": "EBCDIC art.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Ada", "code": "\nLibrary: Lumen\n\nwith Lumen.Binary;\npackage body Mandelbrot is\n   function Create_Image (Width, Height : Natural) return Lumen.Image.Descriptor is\n      use type Lumen.Binary.Byte;\n      Result : Lumen.Image.Descriptor;\n      X0, Y0 : Float;\n      X, Y, Xtemp : Float;\n      Iteration   : Float;\n      Max_Iteration : constant Float := 1000.0;\n      Color : Lumen.Binary.Byte;\n   begin\n      Result.Width := Width;\n      Result.Height := Height;\n      Result.Complete := True;\n      Result.Values := new Lumen.Image.Pixel_Matrix (1 .. Width, 1 .. Height);\n      for Screen_X in 1 .. Width loop\n         for Screen_Y in 1 .. Height loop\n            X0 := -2.5 + (3.5 / Float (Width) * Float (Screen_X));\n            Y0 := -1.0 + (2.0 / Float (Height) * Float (Screen_Y));\n            X := 0.0;\n            Y := 0.0;\n            Iteration := 0.0;\n            while X * X + Y * Y <= 4.0 and then Iteration < Max_Iteration loop\n               Xtemp := X * X - Y * Y + X0;\n               Y := 2.0 * X * Y + Y0;\n               X := Xtemp;\n               Iteration := Iteration + 1.0;\n            end loop;\n            if Iteration = Max_Iteration then\n               Color := 255;\n            else\n               Color := 0;\n            end if;\n            Result.Values (Screen_X, Screen_Y) := (R => Color, G => Color, B => Color, A => 0);\n         end loop;\n      end loop;\n      return Result;\n   end Create_Image;\n\nend Mandelbrot;\n\n\nwith Lumen.Image;\n\npackage Mandelbrot is\n\n   function Create_Image (Width, Height : Natural) return Lumen.Image.Descriptor;\n\nend Mandelbrot;\n\n\nwith System.Address_To_Access_Conversions;\nwith Lumen.Window;\nwith Lumen.Image;\nwith Lumen.Events;\nwith GL;\nwith Mandelbrot;\n\nprocedure Test_Mandelbrot is\n\n   Program_End : exception;\n\n   Win : Lumen.Window.Handle;\n   Image : Lumen.Image.Descriptor;\n   Tx_Name : aliased GL.GLuint;\n   Wide, High : Natural := 400;\n\n   -- Create a texture and bind a 2D image to it\n   procedure Create_Texture is\n      use GL;\n\n      package GLB is new System.Address_To_Access_Conversions (GLubyte);\n\n      IP : GLpointer;\n   begin  -- Create_Texture\n      -- Allocate a texture name\n      glGenTextures (1, Tx_Name'Unchecked_Access);\n\n      -- Bind texture operations to the newly-created texture name\n      glBindTexture (GL_TEXTURE_2D, Tx_Name);\n\n      -- Select modulate to mix texture with color for shading\n      glTexEnvi (GL_TEXTURE_ENV, GL_TEXTURE_ENV_MODE, GL_MODULATE);\n\n      -- Wrap textures at both edges\n      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_S, GL_REPEAT);\n      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_WRAP_T, GL_REPEAT);\n\n      -- How the texture behaves when minified and magnified\n      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MIN_FILTER, GL_NEAREST);\n      glTexParameteri (GL_TEXTURE_2D, GL_TEXTURE_MAG_FILTER, GL_NEAREST);\n\n      -- Create a pointer to the image.  This sort of horror show is going to\n      -- be disappearing once Lumen includes its own OpenGL bindings.\n      IP := GLB.To_Pointer (Image.Values.all'Address).all'Unchecked_Access;\n\n      -- Build our texture from the image we loaded earlier\n      glTexImage2D (GL_TEXTURE_2D, 0, GL_RGBA, GLsizei (Image.Width), GLsizei (Image.Height), 0,\n                    GL_RGBA, GL_UNSIGNED_BYTE, IP);\n   end Create_Texture;\n\n   -- Set or reset the window view parameters\n   procedure Set_View (W, H : in Natural) is\n      use GL;\n   begin  -- Set_View\n      GL.glEnable (GL.GL_TEXTURE_2D);\n      glClearColor (0.8, 0.8, 0.8, 1.0);\n\n      glMatrixMode (GL_PROJECTION);\n      glLoadIdentity;\n      glViewport (0, 0, GLsizei (W), GLsizei (H));\n      glOrtho (0.0, GLdouble (W), GLdouble (H), 0.0, -1.0, 1.0);\n\n      glMatrixMode (GL_MODELVIEW);\n      glLoadIdentity;\n   end Set_View;\n\n   -- Draw our scene\n   procedure Draw is\n      use GL;\n   begin  -- Draw\n      -- clear the screen\n      glClear (GL_COLOR_BUFFER_BIT or GL_DEPTH_BUFFER_BIT);\n      GL.glBindTexture (GL.GL_TEXTURE_2D, Tx_Name);\n\n      -- fill with a single textured quad\n      glBegin (GL_QUADS);\n      begin\n         glTexCoord2f (1.0, 0.0);\n         glVertex2i (GLint (Wide), 0);\n\n         glTexCoord2f (0.0, 0.0);\n         glVertex2i (0, 0);\n\n         glTexCoord2f (0.0, 1.0);\n         glVertex2i (0, GLint (High));\n\n         glTexCoord2f (1.0, 1.0);\n         glVertex2i (GLint (Wide), GLint (High));\n      end;\n      glEnd;\n\n      -- flush rendering pipeline\n      glFlush;\n\n      -- Now show it\n      Lumen.Window.Swap (Win);\n   end Draw;\n\n   -- Simple event handler routine for keypresses and close-window events\n   procedure Quit_Handler (Event : in Lumen.Events.Event_Data) is\n   begin  -- Quit_Handler\n      raise Program_End;\n   end Quit_Handler;\n\n   -- Simple event handler routine for Exposed events\n   procedure Expose_Handler (Event : in Lumen.Events.Event_Data) is\n      pragma Unreferenced (Event);\n   begin  -- Expose_Handler\n      Draw;\n   end Expose_Handler;\n\n   -- Simple event handler routine for Resized events\n   procedure Resize_Handler (Event : in Lumen.Events.Event_Data) is\n   begin  -- Resize_Handler\n      Wide := Event.Resize_Data.Width;\n      High := Event.Resize_Data.Height;\n      Set_View (Wide, High);\n--        Image\u00a0:= Mandelbrot.Create_Image (Width => Wide, Height => High);\n--        Create_Texture;\n      Draw;\n   end Resize_Handler;\n\nbegin\n   -- Create Lumen window, accepting most defaults; turn double buffering off\n   -- for simplicity\n   Lumen.Window.Create (Win           => Win,\n                        Name          => \"Mandelbrot fractal\",\n                        Width         => Wide,\n                        Height        => High,\n                        Events        => (Lumen.Window.Want_Exposure  => True,\n                                          Lumen.Window.Want_Key_Press => True,\n                                          others                      => False));\n\n   -- Set up the viewport and scene parameters\n   Set_View (Wide, High);\n\n   -- Now create the texture and set up to use it\n   Image := Mandelbrot.Create_Image (Width => Wide, Height => High);\n   Create_Texture;\n\n   -- Enter the event loop\n   declare\n      use Lumen.Events;\n   begin\n      Select_Events (Win   => Win,\n                     Calls => (Key_Press    => Quit_Handler'Unrestricted_Access,\n                               Exposed      => Expose_Handler'Unrestricted_Access,\n                               Resized      => Resize_Handler'Unrestricted_Access,\n                               Close_Window => Quit_Handler'Unrestricted_Access,\n                               others       => No_Callback));\n   end;\nexception\n   when Program_End =>\n      null;\nend Test_Mandelbrot;\n\n\nOutput:\n\n", "explain": "mandelbrot.adb:\nmandelbrot.ads:\ntest_mandelbrot.adb:\n\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Julia", "code": "\n\nfunction mandelbrot(a)\n    z = 0\n    for i=1:50\n        z = z^2 + a\n    end\n    return z\nend\n\nfor y=1.0:-0.05:-1.0\n    for x=-2.0:0.0315:0.5\n        abs(mandelbrot(complex(x, y))) < 2 ? print(\"*\") : print(\" \")\n    end\n    println()\nend\n\n\nusing Images\n\n@inline function hsv2rgb(h, s, v)\n    c = v * s\n    x = c * (1 - abs(((h/60) % 2) - 1))\n    m = v - c\n    r,g,b = if     h < 60   (c, x, 0)\n            elseif h < 120  (x, c, 0)\n            elseif h < 180  (0, c, x)\n            elseif h < 240  (0, x, c)\n            elseif h < 300  (x, 0, c)\n            else            (c, 0, x) end\n    (r + m), (b + m), (g + m)\nend\n\nfunction mandelbrot()\n    w       = 1600\n    h       = 1200\n    zoom    = 0.5\n    moveX   = -0.5\n    moveY   = 0\n    maxIter = 30\n    img = Array{RGB{Float64},2}(undef,h,w)\n    for x in 1:w\n      for y in 1:h\n        i = maxIter\n        z = c = Complex( (2*x - w) / (w * zoom) + moveX,\n                         (2*y - h) / (h * zoom) + moveY )\n        while abs(z) < 2 && (i -= 1) > 0\n            z = z^2 + c\n        end\n        r,g,b = hsv2rgb(i / maxIter * 360, 1, i / maxIter)\n        img[y,x] = RGB{Float64}(r, g, b)\n      end\n    end\n    return img\nend\n\nimg = mandelbrot()\nsave(\"mandelbrot.png\", img)\n\nMandelbrot Set with Julia Animation[edit]\n\nusing Plots\ngr(aspect_ratio=:equal, legend=false, axis=false, ticks=false, dpi=100)\n\nd, h = 400, 300  # pixel density (= image width) and image height\nn, r = 40, 1000  # number of iterations and escape radius (r > 2)\n\nx = range(-1.0, 1.0, length=d+1)\ny = range(-h/d, h/d, length=h+1)\n\nC = 2.0 .* (x' .+ y .* im) .- 0.5\nZ, S = zero(C), zeros(size(C))\n\nanimation = Animation()\nsmoothing = Animation()\n\nfor k in 1:n\n    M = abs.(Z) .< r\n    S[M] = S[M] .+ exp.(.-abs.(Z[M]))\n    Z[M] = Z[M] .^ 2 .+ C[M]\n    heatmap(exp.(.-abs.(Z)), c=:jet)\n    frame(animation)\n    heatmap(S .+ exp.(.-abs.(Z)), c=:jet)\n    frame(smoothing)\nend\n\ngif(animation, \"Mandelbrot_animation.gif\", fps=2)\ngif(smoothing, \"Mandelbrot_smoothing.gif\", fps=2)\n\nNormal Map Effect, Mercator Projection and Perturbation Theory[edit]\n\nusing Plots\ngr(aspect_ratio=:equal, axis=true, ticks=true, legend=false, dpi=200)\n\nd, h = 800, 500  # pixel density (= image width) and image height\nn, r = 200, 500  # number of iterations and escape radius (r > 2)\n\nx = range(0, 2, length=d+1)\ny = range(0, 2 * h / d, length=h+1)\n\nA, B = collect(x) .- 1, collect(y) .- h / d\nC = 2.0 .* (A' .+ B .* im) .- 0.5\n\nZ, dZ = zero(C), zero(C)\nD, S, T = zeros(size(C)), zeros(size(C)), zeros(size(C))\n\nfor k in 1:n\n    M = abs.(Z) .< r\n    S[M], T[M] = S[M] .+ exp.(.- abs.(Z[M])), T[M] .+ 1\n    Z[M], dZ[M] = Z[M] .^ 2 .+ C[M], 2 .* Z[M] .* dZ[M] .+ 1\nend\n\nheatmap(S .^ 0.1, c=:balance)\nsavefig(\"Mandelbrot_set_1.png\")\n\nN = abs.(Z) .>= r  # normalized iteration count\nT[N] = T[N] .- log2.(log.(abs.(Z[N])) ./ log(r))\n\nheatmap(T .^ 0.1, c=:balance)\nsavefig(\"Mandelbrot_set_2.png\")\n\nN = abs.(Z) .> 2  # exterior distance estimation\nD[N] = log.(abs.(Z[N])) .* abs.(Z[N]) ./ abs.(dZ[N])\n\nheatmap(D .^ 0.1, c=:balance)\nsavefig(\"Mandelbrot_set_3.png\")\n\nN, thickness = D .> 0, 0.01  # boundary detection\nD[N] = max.(1 .- D[N] ./ thickness, 0)\n\nheatmap(D .^ 2.0, c=:binary)\nsavefig(\"Mandelbrot_set_4.png\")\n\n\nusing Plots\ngr(aspect_ratio=:equal, axis=true, ticks=true, legend=false, dpi=200)\n\nd, h = 800, 500  # pixel density (= image width) and image height\nn, r = 200, 500  # number of iterations and escape radius (r > 2)\n\ndirection, height = 45, 1.5  # direction and height of the incoming light\nstripes, damping = 4.0, 2.0  # stripe density and damping parameter\n\nx = range(0, 2, length=d+1)\ny = range(0, 2 * h / d, length=h+1)\n\nA, B = collect(x) .- 1, collect(y) .- h / d\nC = (2.0 + 1.0im) .* (A' .+ B .* im) .- 0.5\n\nZ, dZ, ddZ = zero(C), zero(C), zero(C)\nD, S, T = zeros(size(C)), zeros(size(C)), zeros(size(C))\n\nfor k in 1:n\n    M = abs.(Z) .< r\n    S[M], T[M] = S[M] .+ sin.(stripes .* angle.(Z[M])), T[M] .+ 1\n    Z[M], dZ[M], ddZ[M] = Z[M] .^ 2 .+ C[M], 2 .* Z[M] .* dZ[M] .+ 1, 2 .* (dZ[M] .^ 2 .+ Z[M] .* ddZ[M])\nend\n\nN = abs.(Z) .>= r  # basic normal map effect and stripe average coloring (potential function)\nP, Q = S[N] ./ T[N], (S[N] .+ sin.(stripes .* angle.(Z[N]))) ./ (T[N] .+ 1)\nU, V = Z[N] ./ dZ[N], 1 .+ (log2.(log.(abs.(Z[N])) ./ log(r)) .* (P .- Q) .+ Q) ./ damping\nU, v = U ./ abs.(U), exp(direction / 180 * pi * im)  # unit normal vectors and light\nD[N] = max.((real.(U) .* real(v) .+ imag.(U) .* imag(v) .+ V .* height) ./ (1 + height), 0)\n\nheatmap(D .^ 1.0, c=:bone_1)\nsavefig(\"Mandelbrot_normal_map_1.png\")\n\nN = abs.(Z) .> 2  # advanced normal map effect using higher derivatives (distance estimation)\nU = Z[N] .* dZ[N] .* ((1 .+ log.(abs.(Z[N]))) .* conj.(dZ[N] .^ 2) .- log.(abs.(Z[N])) .* conj.(Z[N] .* ddZ[N]))\nU, v = U ./ abs.(U), exp(direction / 180 * pi * im)  # unit normal vectors and light\nD[N] = max.((real.(U) .* real(v) .+ imag.(U) .* imag(v) .+ height) ./ (1 + height), 0)\n\nheatmap(D .^ 1.0, c=:afmhot)\nsavefig(\"Mandelbrot_normal_map_2.png\")\n\n\nusing Plots\ngr(aspect_ratio=:equal, axis=true, ticks=true, legend=false, dpi=200)\n\nd, h = 200, 1200  # pixel density (= image width) and image height\nn, r = 8000, 10000  # number of iterations and escape radius (r > 2)\n\na = -.743643887037158704752191506114774  # https://mathr.co.uk/web/m-location-analysis.html\nb = 0.131825904205311970493132056385139  # try: a, b, n = -1.748764520194788535, 3e-13, 800\n\nx = range(0, 2, length=d+1)\ny = range(0, 2 * h / d, length=h+1)\n\nA, B = collect(x) .* pi, collect(y) .* pi\nC = 8.0 .* exp.((A' .+ B .* im) .* im) .+ (a + b * im)\n\nZ, dZ = zero(C), zero(C)\nD = zeros(size(C))\n\nfor k in 1:n\n    M = abs2.(Z) .< abs2(r)\n    Z[M], dZ[M] = Z[M] .^ 2 .+ C[M], 2 .* Z[M] .* dZ[M] .+ 1\nend\n\nN = abs.(Z) .> 2  # exterior distance estimation\nD[N] = log.(abs.(Z[N])) .* abs.(Z[N]) ./ abs.(dZ[N])\n\nheatmap(D' .^ 0.05, c=:nipy_spectral)\nsavefig(\"Mercator_Mandelbrot_map.png\")\n\nX, Y = real(C), imag(C)  # zoom images (adjust circle size 50 and zoom level 20 as needed)\nR, c, z = 50 * (2 / d) * pi .* exp.(.- B), min(d, h) + 1, max(0, h - d) \u00f7 20\n\ngr(c=:nipy_spectral, axis=true, ticks=true, legend=false, markerstrokewidth=0)\np1 = scatter(X[1z+1:1z+c,1:d], Y[1z+1:1z+c,1:d], markersize=R[1:c].^.5, marker_z=D[1z+1:1z+c,1:d].^.5)\np2 = scatter(X[2z+1:2z+c,1:d], Y[2z+1:2z+c,1:d], markersize=R[1:c].^.5, marker_z=D[2z+1:2z+c,1:d].^.4)\np3 = scatter(X[3z+1:3z+c,1:d], Y[3z+1:3z+c,1:d], markersize=R[1:c].^.5, marker_z=D[3z+1:3z+c,1:d].^.3)\np4 = scatter(X[4z+1:4z+c,1:d], Y[4z+1:4z+c,1:d], markersize=R[1:c].^.5, marker_z=D[4z+1:4z+c,1:d].^.2)\nplot(p1, p2, p3, p4, layout=(2, 2))\nsavefig(\"Mercator_Mandelbrot_zoom.png\")\n\n\nusing Plots\ngr(aspect_ratio=:equal, axis=true, ticks=true, legend=false, dpi=200)\n\nsetprecision(BigFloat, 256)  # set precision to 256 bits (default)\nsetrounding(BigFloat, RoundNearest)  # set rounding mode (default)\n\nd, h = 50, 1000  # pixel density (= image width) and image height\nn, r = 80000, 100000  # number of iterations and escape radius (r > 2)\n\na = BigFloat(\"-1.256827152259138864846434197797294538253477389787308085590211144291\")\nb = BigFloat(\".37933802890364143684096784819544060002129071484943239316486643285025\")\n\nS = zeros(Complex{Float64}, n+1)\nlet c = a + b * im, z = zero(c)\n    for k in 1:n+1\n        S[k] = z\n        if abs2(z) < abs2(r)\n            z = z ^ 2 + c\n        else\n            println(\"The reference sequence diverges within $(k-1) iterations.\")\n            break\n        end\n    end\nend\n\nx = range(0, 2, length=d+1)\ny = range(0, 2 * h / d, length=h+1)\n\nA, B = collect(x) .* pi, collect(y) .* pi\nC = 8.0 .* exp.((A' .+ B .* im) .* im)\n\nE, Z, dZ = zero(C), zero(C), zero(C)\nD, I, J = zeros(size(C)), ones(Int64, size(C)), ones(Int64, size(C))\n\nfor k in 1:n\n    M, R = abs2.(Z) .< abs2(r), abs2.(Z) .< abs2.(E)\n    E[R], I[R] = Z[R], J[R]  # rebase when z is closer to zero\n    E[M], I[M] = (2 .* S[I[M]] .+ E[M]) .* E[M] .+ C[M], I[M] .+ 1\n    Z[M], dZ[M] = S[I[M]] .+ E[M], 2 .* Z[M] .* dZ[M] .+ 1\nend\n\nN = abs.(Z) .> 2  # exterior distance estimation\nD[N] = log.(abs.(Z[N])) .* abs.(Z[N]) ./ abs.(dZ[N])\n\nheatmap(D' .^ 0.015, c=:nipy_spectral)\nsavefig(\"Mercator_Mandelbrot_deep_map.png\")\n\n", "explain": "Generates an ASCII representation:\nThis generates a PNG image file:\nThis is an extension of the corresponding R section: e^(-|z|)-smoothing was added. See Javier Barrallo & Damien M. Jones: Coloring Algorithms for Dynamical Systems in the Complex Plane (II. Distance Estimators).\nNormalization, Distance Estimation and Boundary Detection\nThis is a translation of the corresponding Python section: see there for more explanations. The e^(-|z|)-smoothing, normalized iteration count and exterior distance estimation algorithms are used. Partial antialiasing is used for boundary detection.\nNormal Map Effect and Stripe Average Coloring\nThe Mandelbrot set is represented using Normal Maps and Stripe Average Coloring by Jussi H\u00e4rk\u00f6nen (cf. Arnaud Ch\u00e9ritat: Normal map effect). See also the picture in section Mixing it all and Julia Stripes on Shadertoy. To get a stripe pattern similar to that of Arnaud Ch\u00e9ritat, one can increase the stripes, use cos instead of sin, and set the colormap to binary.\nMercator Mandelbrot Maps and Zoom Images\nA small change in the code above creates Mercator maps and zoom images of the Mandelbrot set. See also the album Mercator Mandelbrot Maps by Anders Sandberg and Mandelbrot sequence new on Wikimedia for a zoom animation to the given coordinates.\nPerturbation Theory and Deep Mercator Maps\nFor deep zoom images it is sufficient to calculate a single point with high accuracy. A good approximation can then be found for all other points by means of a perturbation calculation with standard accuracy. Rebasing is used to reduce glitches. See Another solution to perturbation glitches (Fractalforums) for details. See also the image Deeper Mercator Mandelbrot by Anders Sandberg.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.2\n\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\nimport javax.swing.JFrame\n\nclass Mandelbrot: JFrame(\"Mandelbrot Set\") {\n    companion object {\n        private const val MAX_ITER = 570\n        private const val ZOOM = 150.0\n    }\n\n    private val img: BufferedImage\n\n    init {\n        setBounds(100, 100, 800, 600)\n        isResizable = false\n        defaultCloseOperation = EXIT_ON_CLOSE\n        img = BufferedImage(width, height, BufferedImage.TYPE_INT_RGB)\n        for (y in 0 until height) {\n            for (x in 0 until width) {\n                var zx = 0.0\n                var zy = 0.0\n                val cX = (x - 400) / ZOOM\n                val cY = (y - 300) / ZOOM\n                var iter = MAX_ITER\n                while (zx * zx + zy * zy < 4.0 && iter > 0) {\n                    val tmp = zx * zx - zy * zy + cX\n                    zy = 2.0 * zx * zy + cY\n                    zx = tmp\n                    iter--\n                }\n                img.setRGB(x, y, iter or (iter shl 7))\n            }\n        }\n    }\n\n    override fun paint(g: Graphics) {\n        g.drawImage(img, 0, 0, this)\n    }\n}\n\nfun main(args: Array<String>) {\n    Mandelbrot().isVisible = true\n}\n\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Perl", "code": "\n\nuse Math::Complex;\n\nsub mandelbrot {\n    my ($z, $c) = @_[0,0];\n    for (1 .. 20) {\n        $z = $z * $z + $c;\n        return $_ if abs $z > 2;\n    }\n}\n\nfor (my $y = 1; $y >= -1; $y -= 0.05) {\n    for (my $x = -2; $x <= 0.5; $x += 0.0315)\n        {print mandelbrot($x + $y * i)\u00a0? ' '\u00a0: '#'}\n    print \"\\n\"\n}\n", "explain": "translation / optimization of the ruby solution\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Prolog", "code": "\n\n:- use_module(library(pce)).\n\nmandelbrot\u00a0:-\n    new(D, window('Mandelbrot Set')),\n    send(D, size, size(700, 650)),\n    new(Img, image(@nil, width\u00a0:= 700, height\u00a0:= 650, kind\u00a0:= pixmap)),\n\n    forall(between(0,699, I),\n           (   forall(between(0,649, J),\n              (   get_RGB(I, J, R, G, B),\n                  R1 is (R * 256) mod 65536,\n                  G1 is (G * 256) mod 65536,\n                  B1 is (B * 256) mod 65536,\n                  send(Img, pixel(I, J, colour(@default, R1, G1, B1))))))),\n    new(Bmp, bitmap(Img)),\n    send(D, display, Bmp, point(0,0)),\n    send(D, open).\n\nget_RGB(X, Y, R, G, B)\u00a0:-\n    CX is (X - 350) / 150,\n    CY is (Y - 325) / 150,\n    Iter = 570,\n    compute_RGB(CX, CY, 0, 0, Iter, It),\n    IterF is It \\/ It << 15,\n    R is IterF >> 16,\n    Iter1 is IterF - R << 16,\n    G is Iter1 >> 8,\n    B  is Iter1 - G << 8.\n\ncompute_RGB(CX, CY, ZX, ZY, Iter, IterF)\u00a0:-\n    ZX * ZX + ZY * ZY < 4,\n    Iter > 0,\n   \u00a0!,\n    Tmp is  ZX * ZX - ZY * ZY + CX,\n    ZY1 is 2 * ZX * ZY + CY,\n    Iter1 is Iter - 1,\n    compute_RGB(CX, CY, Tmp, ZY1, Iter1, IterF).\n\ncompute_RGB(_CX, _CY, _ZX, _ZY, Iter, Iter).Example\u00a0:\n\n", "explain": "SWI-Prolog has a graphic interface XPCE\u00a0:\n\n\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Lua", "code": "\nGraphical[edit]\n\nlocal maxIterations = 250\nlocal minX, maxX, minY, maxY = -2.5, 2.5, -2.5, 2.5\nlocal miX, mxX, miY, mxY\nfunction remap( x, t1, t2, s1, s2 )\n    local f = ( x - t1 ) / ( t2 - t1 )\n    local g = f * ( s2 - s1 ) + s1\n    return g;\nend\nfunction drawMandelbrot()\n    local pts, a, as, za, b, bs, zb, cnt, clr = {}\n    for j = 0, hei - 1 do\n        for i = 0, wid - 1 do\n            a = remap( i, 0, wid, minX, maxX )\n            b = remap( j, 0, hei, minY, maxY )\n            cnt = 0; za = a; zb = b\n            while( cnt < maxIterations ) do\n                as = a * a - b * b; bs = 2 * a * b\n                a = za + as; b = zb + bs\n                if math.abs( a ) + math.abs( b ) > 16 then break end\n                cnt = cnt + 1\n            end\n            if cnt == maxIterations then clr = 0\n            else clr = remap( cnt, 0, maxIterations, 0, 255 )\n            end\n            pts[1] = { i, j, clr, clr, 0, 255 }\n            love.graphics.points( pts )\n        end\n    end\nend\nfunction startFractal()\n    love.graphics.setCanvas( canvas ); love.graphics.clear()\n    love.graphics.setColor( 255, 255, 255 )\n    drawMandelbrot(); love.graphics.setCanvas()\nend\nfunction love.load()\n    wid, hei = love.graphics.getWidth(), love.graphics.getHeight()\n    canvas = love.graphics.newCanvas( wid, hei )\n    startFractal()\nend\nfunction love.mousepressed( x, y, button, istouch )\n    if button ==  1 then\n        startDrag = true; miX = x; miY = y\n    else\n        minX = -2.5; maxX = 2.5; minY = minX; maxY = maxX\n        startFractal()\n        startDrag = false\n    end\nend\nfunction love.mousereleased( x, y, button, istouch )\n    if startDrag then\n        local l\n        if x > miX then mxX = x\n        else l = x; mxX = miX; miX = l\n        end\n        if y > miY then mxY = y\n        else l = y; mxY = miY; miY = l\n        end\n        miX = remap( miX, 0, wid, minX, maxX ) \n        mxX = remap( mxX, 0, wid, minX, maxX )\n        miY = remap( miY, 0, hei, minY, maxY ) \n        mxY = remap( mxY, 0, hei, minY, maxY )\n        minX = miX; maxX = mxX; minY = miY; maxY = mxY\n        startFractal()\n    end\nend\nfunction love.draw()\n    love.graphics.draw( canvas )\nend\nASCII[edit]\n-- Mandelbrot set in Lua 6/15/2020 db\nlocal charmap = { [0]=\" \", \".\", \":\", \"-\", \"=\", \"+\", \"*\", \"#\", \"%\", \"@\" }\nfor y = -1.3, 1.3, 0.1 do\n  for x = -2.1, 1.1, 0.04 do\n    local zi, zr, i = 0, 0, 0\n    while i < 100 do\n      if (zi*zi+zr*zr >= 4) then break end\n      zr, zi, i = zr*zr-zi*zi+x, 2*zr*zi+y, i+1\n    end\n    io.write(charmap[i%10])\n  end\n  print()\nend\n\nOutput:\n...............::::::::::::::::::---------------::::::::::::::::::::::::::::::::\n.............:::::::::::---------------------------------:::::::::::::::::::::::\n...........::::::::---------------------======+#@#++=====-----::::::::::::::::::\n..........::::::--------------------=======+++**@+@.@*+=====-----:::::::::::::::\n........:::::--------------------========++++*#@@#=:%#*++=====------::::::::::::\n.......:::--------------------========+++***#%:     .:#*+++++===-------:::::::::\n......:::------------------=======+++#%@%%%@@\u00a0:#   \u00a0%.@@%#***%*+==------::::::::\n.....::-----------------====++++++**# =  =%            \u00a0%-.*+=#%+==-------::::::\n.....:--------------==+++++++++****%:.*+                     *%*++==-------:::::\n....:--------=====+*#=%##########%%.**                        .@ +===-------::::\n....---========++++*#@:=*:-@+ .@@\u00a0:=                          @ #*===--------:::\n...--=======+++++*##%.=:        @+.                           @##+====--------::\n...=======****##% .-=%                                        *#*+====--------::\n...@.::  \u00a0::\u00a0%                                             \u00a0:@#*++====--------::\n...=======****##% .-=%                                        *#*+====--------::\n...--=======+++++*##%.=:        @+.                           @##+====--------::\n....---========++++*#@:=*:-@+ .@@\u00a0:=                          @ #*===--------:::\n....:--------=====+*#=%##########%%.**                        .@ +===-------::::\n.....:--------------==+++++++++****%:.*+                     *%*++==-------:::::\n.....::-----------------====++++++**# =  =%            \u00a0%-.*+=#%+==-------::::::\n......:::------------------=======+++#%@%%%@@\u00a0:#   \u00a0%.@@%#***%*+==------::::::::\n.......:::--------------------========+++***#%:     .:#*+++++===-------:::::::::\n........:::::--------------------========++++*#@@#=:%#*++=====------::::::::::::\n..........::::::--------------------=======+++**@+@.@*+=====-----:::::::::::::::\n...........::::::::---------------------======+#@#++=====-----::::::::::::::::::\n.............:::::::::::---------------------------------:::::::::::::::::::::::\n...............::::::::::::::::::---------------::::::::::::::::::::::::::::::::\nASCII (obfuscated)[edit]\n\nfor y=-12,12 do l=\"\"for x=-2,1,3/80 do a,b,n=0,0,-15 while n<9 and a*a+b*b<1e12\ndo a,b,n=a*a-b*b+x,2*a*b+y/8,n+1 end l=l..(\".,:;=$%# \"):sub(n,n)end print(l)end\n\nOutput:\n............................................,,,,,,,,............................\n.................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,...................\n.........................,,,,,,,,,,,,,,,,,,,,,,::::,,,,,,,,,,,,,,,..............\n...................,,,,,,,,,,,,,,,,,,,,,::::::;=$=;;::::::,,,,,,,,,,,,..........\n..............,,,,,,,,,,,,,,,,,,,,:::::::::;;;==%\u00a0:#=;;:::::,,,,,,,,,,,.......\n.........,,,,,,,,,,,,,,,,,,,,:::::::::;;;;;==$%;;  ,##==;;;::::::,,,,,,,,,.....\n.....,,,,,,,,,,,,,,,,,:::::::::::;;;;====$$$%#:      \u00a0%$$===;;;;::::,,,,,,,,...\n..,,,,,,,,,,,,,,::::::::::::;;;;;;==$     ,               .#% #=;:::,,,,,,,,,.\n,,,,,,,,,,,,::::::;;;;;;;;;;=====$$#:.                         $=;;::::,,,,,,,,\n,,,,,,,,:::::::;;;=%:%%%%%=%%%%%%#                            $  $;;:::,,,,,,,,\n,,,,:::::::;;;;===$%#:         ,..                             \u00a0:,=;;::::,,,,,,,\n::::;;;;;;====$#  ..#                                          \u00a0;$=;;::::,,,,,,,\n                                                            \u00a0;\u00a0%$=;;;::::,,,,,,,\n::::;;;;;;====$#  ..#                                          \u00a0;$=;;::::,,,,,,,\n,,,,:::::::;;;;===$%#:         ,..                             \u00a0:,=;;::::,,,,,,,\n,,,,,,,,:::::::;;;=%:%%%%%=%%%%%%#                            $  $;;:::,,,,,,,,\n,,,,,,,,,,,,::::::;;;;;;;;;;=====$$#:.                         $=;;::::,,,,,,,,\n..,,,,,,,,,,,,,,::::::::::::;;;;;;==$     ,               .#% #=;:::,,,,,,,,,.\n.....,,,,,,,,,,,,,,,,,:::::::::::;;;;====$$$%#:      \u00a0%$$===;;;;::::,,,,,,,,...\n.........,,,,,,,,,,,,,,,,,,,,:::::::::;;;;;==$%;;  ,##==;;;::::::,,,,,,,,,.....\n..............,,,,,,,,,,,,,,,,,,,,:::::::::;;;==%\u00a0:#=;;:::::,,,,,,,,,,,.......\n...................,,,,,,,,,,,,,,,,,,,,,::::::;=$=;;::::::,,,,,,,,,,,,..........\n.........................,,,,,,,,,,,,,,,,,,,,,,::::,,,,,,,,,,,,,,,..............\n.................................,,,,,,,,,,,,,,,,,,,,,,,,,,,,...................\n............................................,,,,,,,,............................\n", "explain": "Needs L\u00d6VE 2D EngineZoom in: drag the mouse; zoom out: right click\nProduces an 80x25 ASCII Mandelbrot set, using only two lines of code. The result isn't very high quality because there's only so many iterations you can cram into two lines of 80 columns. And this code cheats, because it starts the iteration count at -15 instead of 0, to avoid the need for an excessively long character lookup table.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Scala", "code": "\nWorks with: Scala version 2.8\n\nimport org.rosettacode.ArithmeticComplex._\nimport java.awt.Color\n\nobject Mandelbrot\n{\n   def generate(width:Int =600, height:Int =400)={\n      val bm=new RgbBitmap(width, height)\n\n      val maxIter=1000\n      val xMin = -2.0\n      val xMax =  1.0\n      val yMin = -1.0\n      val yMax =  1.0\n\n      val cx=(xMax-xMin)/width\n      val cy=(yMax-yMin)/height\n\n      for(y <- 0 until bm.height; x <- 0 until bm.width){\n         val c=Complex(xMin+x*cx, yMin+y*cy)\n         val iter=itMandel(c, maxIter, 4)\n         bm.setPixel(x, y, getColor(iter, maxIter))\n      }\n      bm\n   }\n\n   def itMandel(c:Complex, imax:Int, bailout:Int):Int={\n      var z=Complex()\n      for(i <- 0 until imax){\n         z=z*z+c;\n         if(z.abs > bailout) return i\n      }\n      imax;\n   }\n\n   def getColor(iter:Int, max:Int):Color={\n      if (iter==max) return Color.BLACK\n\n      var c=3*math.log(iter)/math.log(max-1.0)\n      if(c<1) new Color((255*c).toInt, 0, 0)\n      else if(c<2) new Color(255, (255*(c-1)).toInt, 0)\n      else new Color(255, 255, (255*(c-2)).toInt)\n   }\n}\n\nimport scala.swing._\nimport javax.swing.ImageIcon\nval imgMandel=Mandelbrot.generate()\nval mainframe=new MainFrame(){title=\"Test\"; visible=true\n   contents=new Label(){icon=new ImageIcon(imgMandel.image)}\n}\n", "explain": "Uses RgbBitmap from Basic Bitmap Storage task and Complex number class from this\nprogramming task.\nRead\u2013eval\u2013print loop\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Dart", "code": "\n\nclass Complex {\n  double _r,_i;\n\n  Complex(this._r,this._i);\n  double get r => _r;\n  double get i => _i;\n  String toString() => \"($r,$i)\";\n\n  Complex operator +(Complex other) => new Complex(r+other.r,i+other.i);\n  Complex operator *(Complex other) =>\n      new Complex(r*other.r-i*other.i,r*other.i+other.r*i);\n  double abs() => r*r+i*i;\n}\n\nvoid main() {\n  double start_x=-1.5;\n  double start_y=-1.0;\n  double step_x=0.03;\n  double step_y=0.1;\n\n  for(int y=0;y<20;y++) {\n    String line=\"\";\n    for(int x=0;x<70;x++) {\n      Complex c=new Complex(start_x+step_x*x,start_y+step_y*y);\n      Complex z=new Complex(0.0, 0.0);\n      for(int i=0;i<100;i++) {\n        z=z*(z)+c;\n        if(z.abs()>2) {\n          break;\n        }\n      }\n      line+=z.abs()>2 ? \" \" : \"*\";\n    }\n    print(line);\n  }\n}\n\n", "explain": "Implementation in Google Dart works on http://try.dartlang.org/ (as of 10/18/2011) since the language is very new, it may break in the future.\nThe implementation uses a incomplete Complex class supporting operator overloading.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "D", "code": "\nTextual Version[edit]\n\nvoid main() {\n    import std.stdio, std.complex;\n\n    for (real y = -1.2; y < 1.2; y += 0.05) {\n        for (real x = -2.05; x < 0.55; x += 0.03) {\n            auto z = 0.complex;\n            foreach (_; 0 .. 100)\n                z = z ^^ 2 + complex(x, y);\n            write(z.abs < 2 ? '#' : '.');\n        }\n        writeln;\n    }\n}\n\n\nOutput:\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n................................................................##.....................\n.............................................................######....................\n.............................................................#######...................\n..............................................................######...................\n..........................................................#.#.###..#.#.................\n...................................................##....################..............\n..................................................###.######################.###.......\n...................................................############################........\n................................................###############################........\n................................................################################.......\n.............................................#####################################.....\n..............................................###################################......\n..............................##.####.#......####################################......\n..............................###########....####################################......\n............................###############.######################################.....\n............................###############.#####################################......\n........................##.#####################################################.......\n......#.#####################################################################..........\n........................##.#####################################################.......\n............................###############.#####################################......\n............................###############.######################################.....\n..............................###########....####################################......\n..............................##.####.#......####################################......\n..............................................###################################......\n.............................................#####################################.....\n................................................################################.......\n................................................###############################........\n...................................................############################........\n..................................................###.######################.###.......\n...................................................##....################..............\n..........................................................#.#.###..#.#.................\n..............................................................######...................\n.............................................................#######...................\n.............................................................######....................\n................................................................##.....................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\n.......................................................................................\nMore Functional Textual Version[edit]\n\nvoid main() {\n    import std.stdio, std.complex, std.range, std.algorithm;\n\n    foreach (immutable y; iota(-1.2, 1.2, 0.05))\n        iota(-2.05, 0.55, 0.03).map!(x => 0.complex\n            .recurrence!((a, n) => a[n - 1] ^^ 2 + complex(x, y))\n            .drop(100).front.abs < 2 ? '#' : '.').writeln;\n}\n\nGraphical Version[edit]\nLibrary: QD Library: SDL Library: Phobos\nimport qd;\n\ndouble lensqr(cdouble c) { return c.re * c.re + c.im * c.im; }\n\nconst Limit = 150;\n\nvoid main() {\n  screen(640, 480);\n  for (int y = 0; y < screen.h; ++y) {\n    flip; events;\n    for (int x = 0; x < screen.w; ++x) {\n      auto\n        c_x = x * 1.0 / screen.w - 0.5,\n        c_y = y * 1.0 / screen.h - 0.5,\n        c = c_y * 2.0i + c_x * 3.0 - 1.0,\n        z = 0.0i + 0.0,\n        i = 0;\n      for (; i < Limit; ++i) {\n        z = z * z + c;\n        if (lensqr(z) > 4) break;\n      }\n      auto value = cast(ubyte) (i * 255.0 / Limit);\n      pset(x, y, rgb(value, value, value));\n    }\n  }\n  while (true) { flip; events; }\n}\n\n", "explain": "This uses std.complex because D built-in complex numbers are deprecated.\nThe output is similar.\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Haskell", "code": "\nTranslation of: Ruby\nimport Data.Bool ( bool )\nimport Data.Complex (Complex ((:+)), magnitude)\n\nmandelbrot :: RealFloat a => Complex a -> Complex a\nmandelbrot a = iterate ((a +) . (^ 2)) 0 !! 50\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ [ bool ' ' '*' (2 > magnitude (mandelbrot (x :+ y)))\n        | x <- [-2, -1.9685 .. 0.5]\n      ]\n      | y <- [1, 0.95 .. -1]\n    ]\n\n\nOutput:\n                            \n                                                           **                   \n                                                         ******                 \n                                                       ********                 \n                                                         ******                 \n                                                      ******** **   *           \n                                              ***   *****************           \n                                              ************************  ***     \n                                              ****************************      \n                                           ******************************       \n                                            ******************************      \n                                         ************************************   \n                                *         **********************************    \n                           ** ***** *     **********************************    \n                           ***********   ************************************   \n                         ************** ************************************    \n                         ***************************************************    \n                     *****************************************************      \n ***********************************************************************        \n                     *****************************************************      \n                         ***************************************************    \n                         ************** ************************************    \n                           ***********   ************************************   \n                           ** ***** *     **********************************    \n                                *         **********************************    \n                                         ************************************   \n                                            ******************************      \n                                           ******************************       \n                                              ****************************      \n                                              ************************  ***     \n                                              ***   *****************           \n                                                      ******** **   *           \n                                                         ******                 \n                                                       ********                 \n                                                         ******                 \n                                                           **  \n\n-- first attempt\n-- putStrLn $ foldr (++) \"\" [ if x==(-2) then \"\\n\" else let (a, b) = iterate (\\(x', y') -> (x'^2-y'^2+x, 2*x'*y'+y)) (0, 0)\u00a0!! 500 in (snd.head.filter (\\(v, c)->v) $ zip ([(<0.01), (<0.025), (<0.05), (<0.1), (<0.5), (<1), (<4), (\\_ -> True)] <*> [a^2 + b^2]) [\".\", \"\\'\", \":\", \"!\", \"|\", \"}\", \"#\", \" \"]) | y <- [1, 0.98 .. -1], x <- [-2, -1.98 .. 0.5]]\n\n-- replaced iterate with foldr, modified the snd.head part and a introduced a check to stop the magnitude from exploding\n-- foldr(>>)(return())[putStrLn[let(a,b)=foldr(\\_(u,w)->if(u^2+w^2<4)then(u^2-w^2+x,2*u*w+y)else(u,w))(0,0)[1..500]in snd.last$(filter(\\(f,v)->f)$zip(map(a^2+b^2>)[0,0.01,0.025,0.05,0.1,0.5,1,4])['.','\\'',':','!','|','}','#',' '])|x<-[-2,-1.98..0.5]]|y<-[1,0.98.. -1]]\n\n-- without different characters in the output\n-- foldr(>>)(return())[putStrLn[let(a,b)=foldr(\\_(u,w)->(u^2-w^2+x,2*u*w+y))(0,0)[1..500]in if a^2+b^2<4 then '*' else ' '|x<-[-2,-1.98..0.5]]|y<-[1,0.98.. -1]]\n\n-- using mapM_ instead of foldr, bind operator instead of list comprehension and replacing 'let' with a lambda function\n -- mapM_ putStrLn $[1,0.98.. -1]>>= \\y->return $[-2,-1.98..0.5]>>= \\x->return (if(\\(a,b)->a^2+b^2<4)(foldr(\\_(u,w)->(u^2-w^2+x,2*u*w+y))(0,0)[1..500]) then '*' else ' ')\n\n-- open GHCI > Copy and paste any of above one-liners > Hit enter\n\n\nmain :: IO ()\nmain =\n  putStrLn $\n    concat\n      [ go x y\n        | y <- [1, 0.98 .. -1],\n          x <- [-2, -1.98 .. 0.5]\n      ]\n  where\n    go x y\n      | x == (-2) = \"\\n\"\n      | otherwise =\n        let (a, b) =\n              iterate\n                (\\(x', y') -> (x' ^ 2 - y' ^ 2 + x, 2 * x' * y' + y))\n                (0, 0)\n                !! 500\n         in ( snd . head . filter fst $\n                zip\n                  ( [ (< 0.01),\n                      (< 0.025),\n                      (< 0.05),\n                      (< 0.1),\n                      (< 0.5),\n                      (< 1),\n                      (< 4),\n                      const True\n                    ]\n                      <*> [a ^ 2 + b ^ 2]\n                  )\n                  [\".\", \"\\'\", \":\", \"!\", \"|\", \"}\", \"#\", \" \"]\n            )\n\n\nOutput:\n                                                                                             #                               \n                                                                                             ##                              \n                                                                                             #                               \n                                                                                          }}}}}}}                            \n                                                                                        #}}}}}}}}                            \n                                                                                         }}}}}}}}}                           \n                                                                                         }}}}}}}}}                           \n                                                                                         }}}}}}}}}#                          \n                                                                                        }}}}}}}}}}                           \n                                                                                         }}}}}}}}                            \n                                                                                          }}}}}}}                            \n                                                                                           |||}}                             \n                                                                                      } |||||||||||                          \n                                                                                 } |||||||||||||||||||   |                   \n                                                                        . '      |||||||||||||||||||||||||                   \n                                                                         ..'   ||||||||||||||||||||||||||||                  \n                                                                        '... |||||||||||||||||||||||||||||||    '.':         \n                                                                         '':||||||||||||||||||||||||||||||||||\u00a0:...'         \n                                                                           ||||||||||||||||||||||||||||||||||||:'..'         \n                                                                         |||||||||||||||||||||||||||||||||||||||:''          \n                                                                       }|||||||||||||||||||||||||||||||||||||||||            \n                                                                       |||||||||||||||||||||||||||||||||||||||||||           \n                                                                   || ||||||||||||||||||||||||||||||||||||||||||||!          \n                                                                   ||}|||||||||||||||||||||||||||||||||||||||||||||          \n                                                                     |||||||||||||||||||||||||||||||||||||||||||||||         \n                                                                    |||||||||||||||||||||||||||||||||||||||||||||||||        \n                                                                   |||||||||||||||||||||||||||!!!!!||||||||||||||||||\u00a0:      \n                                                                 |||||||||||||||||||||||||!!!!!!!!!!!!|||||||||||||||'.'     \n                                                                  ||||||||||||||||||||||!!!!!!!!!!!!!!!!||||||||||||| .      \n                                                                 .||||||||||||||||||||!!!!!!!!!!!!!!!!!!!!||||||||||||       \n                                                 |              |||||||||||||||||||||!!!!!!!!!!!!!!!!!!!!!!|||||||||||       \n                                          |      |               |||||||||||||||||||!!!!!!!!!!!!!!!!!!!!!!!!||||||||||       \n                                         ||! .:::!!!!.         ||||||||||||||||||||!!!!!!!!!!!!!:::!!!!!!!!!||||||||||       \n                                         \u00a0!'::::::::!!!         ||||||||||||||||||!!!!!!!!!!!:::::::::!!!!!!!|||||||||||     \n                                         \u00a0::::::::::::!!!|     |||||||||||||||||||!!!!!!!!!:::::::::::::!!!!!!||||||||       \n                                       \u00a0!::::::::::::::!!!!    ||||||||||||||||||!!!!!!!!!:::::::::::::::!!!!!||||||||       \n                                      .\u00a0::::::''''::::::!!!    |||||||||||||||||!!!!!!!!!:::::::''''::::::!!!!||||||||       \n                                      \u00a0:::::'''''''''::::!!!   |||||||||||||||||!!!!!!!!::::::'''''''''::::!!!!||||||||      \n                                     \u00a0!::::''''''''''':::!!!  ||||||||||||||||||!!!!!!!::::::''''''''''':::!!!!||||||!       \n                                     \u00a0::::''''''..''''':::!!! |||||||||||||||||!!!!!!!!:::::''''''..''''':::!!!||||||}       \n                                     \u00a0:::'''''......''':::!!! |||||||||||||||||!!!!!!!:::::'''''......''':::!!!||||||        \n                                    \u00a0::::''''........'''::!!!||||||||||||||||||!!!!!!!:::::''''........'''::!!!|||||         \n                                ....\u00a0::::'''..........''::!!!||||||||||||||||||!!!!!!!:::::'''..........''::!!||||||         \n                               .....':::''''..........''::!!|||||||||||||||||||!!!!!!!::::''''..........''::!!||||           \n          ##             |  \u00a0::.....':::''''..........''::!!|||||||||||||||||||!!!!!!!::::''''..........''::!!||             \n                               .....':::''''..........''::!!|||||||||||||||||||!!!!!!!::::''''..........''::!!||||           \n                                ....\u00a0::::'''..........''::!!!||||||||||||||||||!!!!!!!:::::'''..........''::!!||||||         \n                                    \u00a0::::''''........'''::!!!||||||||||||||||||!!!!!!!:::::''''........'''::!!!|||||         \n                                     \u00a0:::'''''......''':::!!! |||||||||||||||||!!!!!!!:::::'''''......''':::!!!||||||        \n                                     \u00a0::::''''''..''''':::!!! |||||||||||||||||!!!!!!!!:::::''''''..''''':::!!!||||||}       \n                                     \u00a0!::::''''''''''':::!!!  ||||||||||||||||||!!!!!!!::::::''''''''''':::!!!!||||||!       \n                                      \u00a0:::::'''''''''::::!!!   |||||||||||||||||!!!!!!!!::::::'''''''''::::!!!!||||||||      \n                                      .\u00a0::::::''''::::::!!!    |||||||||||||||||!!!!!!!!!:::::::''''::::::!!!!||||||||       \n                                       \u00a0!::::::::::::::!!!!    ||||||||||||||||||!!!!!!!!!:::::::::::::::!!!!!||||||||       \n                                         \u00a0::::::::::::!!!|     |||||||||||||||||||!!!!!!!!!:::::::::::::!!!!!!||||||||       \n                                         \u00a0!'::::::::!!!         ||||||||||||||||||!!!!!!!!!!!:::::::::!!!!!!!|||||||||||     \n                                         ||! .:::!!!!.         ||||||||||||||||||||!!!!!!!!!!!!!:::!!!!!!!!!||||||||||       \n                                          |      |               |||||||||||||||||||!!!!!!!!!!!!!!!!!!!!!!!!||||||||||       \n                                                 |              |||||||||||||||||||||!!!!!!!!!!!!!!!!!!!!!!|||||||||||       \n                                                                 .||||||||||||||||||||!!!!!!!!!!!!!!!!!!!!||||||||||||       \n                                                                  ||||||||||||||||||||||!!!!!!!!!!!!!!!!||||||||||||| .      \n                                                                 |||||||||||||||||||||||||!!!!!!!!!!!!|||||||||||||||'.'     \n                                                                   |||||||||||||||||||||||||||!!!!|||||||||||||||||||\u00a0:      \n                                                                    |||||||||||||||||||||||||||||||||||||||||||||||||        \n                                                                     |||||||||||||||||||||||||||||||||||||||||||||||         \n                                                                   ||}|||||||||||||||||||||||||||||||||||||||||||||          \n                                                                   || ||||||||||||||||||||||||||||||||||||||||||||!          \n                                                                       |||||||||||||||||||||||||||||||||||||||||||           \n                                                                       }|||||||||||||||||||||||||||||||||||||||||            \n                                                                         |||||||||||||||||||||||||||||||||||||||:''          \n                                                                           ||||||||||||||||||||||||||||||||||||:'..'         \n                                                                         '':||||||||||||||||||||||||||||||||||\u00a0:...'         \n                                                                        '... |||||||||||||||||||||||||||||||    '.':         \n                                                                         ..'   ||||||||||||||||||||||||||||                  \n                                                                        . '      |||||||||||||||||||||||||                   \n                                                                                 } |||||||||||||||||||   |                   \n                                                                                      } |||||||||||                          \n                                                                                           |||}}                             \n                                                                                          }}}}}}}                            \n                                                                                         }}}}}}}}                            \n                                                                                        }}}}}}}}}}                           \n                                                                                         }}}}}}}}}#                          \n                                                                                         }}}}}}}}}                           \n                                                                                         }}}}}}}}}                           \n                                                                                        #}}}}}}}}                            \n                                                                                          }}}}}}}                            \n                                                                                             #                               \n                                                                                             ##                              \n                                                                                             #  \n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    $ [1, 0.98 .. -1]\n      >>= \\y ->\n        [ [-2, -1.98 .. 0.5]\n            >>= \\x ->\n              [ if (\\(a, b) -> a ^ 2 + b ^ 2 < 4)\n                  ( foldr\n                      ( \\_ (u, w) ->\n                          (u ^ 2 - w ^ 2 + x, 2 * u * w + y)\n                      )\n                      (0, 0)\n                      [1 .. 500]\n                  )\n                  then '*'\n                  else ' '\n              ]\n        ]\n\n", "explain": "haskell one-liners\u00a0:\nA legible variant of the first of the \"one-liner\" contributions above:\nand a legible variant of the last of the \"one-liner\" contributions above:\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "VBScript", "code": "\noption explicit\n\n' Raster graphics class in VBSCRIPT by Antoni Gual\n'--------------------------------------------\n' An array keeps the image allowing to set pixels, draw lines and boxes in it. \n' at class destroy a bmp file is saved to disk and the default viewer is called\n' The class can work with 8 and 24 bit bmp. With 8 bit uses a built-in palette or can import a custom one\n\n\n'Declaration\u00a0: \n' Set MyObj = (New ImgClass)(name,width,height, orient,bits_per_pixel,palette_array)\n' name:path and name of the file created\n' width, height of the canvas\n' orient is the way the coord increases, 1 to 4 think of the 4 cuadrants of the caterian plane\n'    1 X:l>r Y:b>t   2 X:r>l Y:b>t  3 X:r>l Y:t>b   4 X:l>r  Y:t>b \n' bits_per_pixel can bs only 8 and 24\n' palette array only to substitute the default palette for 8 bits, else put a 0\n' it sets the origin at the corner of the image (bottom left if orient=1) \n\nClass ImgClass\n  Private ImgL,ImgH,ImgDepth,bkclr,loc,tt\n  private xmini,xmaxi,ymini,ymaxi,dirx,diry\n  public ImgArray()  'rgb in 24 bit mode, indexes to palette in 8 bits\n  private filename   \n  private Palette,szpal \n  \n  Public Property Let depth (x) \n  if depth=8 or depth =24 then \n    Imgdepth=depth\n  else \n    Imgdepth=8\n  end if\n  bytepix=imgdepth/8\n  end property        \n  \n  Public Property Let Pixel (x,y,color)\n  If (x>=ImgL) or x<0 then exit property\n  if y>=ImgH or y<0 then exit property\n  ImgArray(x,y)=Color   \n  End Property\n  \n  Public Property Get Pixel (x,y)\n  If (x<ImgL) And (x>=0) And (y<ImgH) And (y>=0) Then\n    Pixel=ImgArray(x,y)\n  End If\n  End Property\n  \n  Public Property Get ImgWidth ()\n  ImgWidth=ImgL-1\n  End Property\n  \n  Public Property Get ImgHeight ()\n  ImgHeight=ImgH-1\n  End Property     \n  \n  'constructor (fn,w*2,h*2,32,0,0)\n  Public Default Function Init(name,w,h,orient,dep,bkg,mipal)\n  'offx, offy posicion de 0,0. si ofx+ , x se incrementa de izq a der, si offy+ y se incrementa de abajo arriba\n  dim i,j\n  ImgL=w\n  ImgH=h\n  tt=timer\n  set0 0,0   'origin blc positive up and right\n  redim imgArray(ImgL-1,ImgH-1)\n  bkclr=bkg\n  if bkg<>0 then \n    for i=0 to ImgL-1 \n      for j=0 to ImgH-1 \n        imgarray(i,j)=bkg\n      next\n    next  \n  end if \n  Select Case orient\n    Case 1: dirx=1\u00a0: diry=1   \n    Case 2: dirx=-1\u00a0: diry=1\n    Case 3: dirx=-1\u00a0: diry=-1\n    Case 4: dirx=1\u00a0: diry=-1\n  End select    \n  filename=name\n  ImgDepth =dep\n  'load user palette if provided  \n  if imgdepth=8 then  \n    loadpal(mipal)\n  end if       \n  set init=me\n  end function\n\n  private sub loadpal(mipale)\n    if isarray(mipale) Then\n      palette=mipale\n      szpal=UBound(mipale)+1\n    Else\n      szpal=256  \n    'Default palette recycled from ATARI\n  \n   End if  \n  End Sub\n  public sub set0 (x0,y0) 'origin can be changed during drawing\n    if x0<0 or x0>=imgl or y0<0 or y0>imgh then err.raise 9 \n    xmini=-x0\n    ymini=-y0\n    xmaxi=xmini+imgl-1\n    ymaxi=ymini+imgh-1 \n    \n  end sub\n\n    \n  Private Sub Class_Terminate\n  if err <>0 then wscript.echo \"Error \" & err.number\n  wscript.echo \"writing bmp to file\"\n    savebmp\n    wscript.echo \"opening \" & filename\n    CreateObject(\"Shell.Application\").ShellExecute filename\n  wscript.echo timer-tt & \" seconds\"\n  End Sub\n\n\n 'writes a 32bit integr value as binary to an utf16 string\n function long2wstr( x)  'falta muy poco!!!\n      dim k1,k2,x1\n      k1=  (x and &hffff&)' or (&H8000& And ((X And &h8000&)<>0)))\n      k2=((X And &h7fffffff&) \\ &h10000&) Or (&H8000& And (x<0))\n      long2wstr=chrw(k1) & chrw(k2)\n    end function \n    \n    function int2wstr(x)\n        int2wstr=ChrW((x and &h7fff) or (&H8000 And (X<0)))\n    End Function\n\n\n  Public Sub SaveBMP\n    'Save the picture to a bmp file\n    Dim s,ostream, x,y,loc\n   \n    const hdrs=54 '14+40 \n    dim bms:bms=ImgH* 4*(((ImgL*imgdepth\\8)+3)\\4)  'bitmap size including padding\n    dim palsize:if (imgdepth=8) then palsize=szpal*4 else palsize=0\n\n    with  CreateObject(\"ADODB.Stream\") 'auxiliary ostream, it creates an UNICODE with bom stream in memory\n      .Charset = \"UTF-16LE\"    'o \"UTF16-BE\" \n      .Type =  2' adTypeText  \n      .open \n      \n      'build a header\n      'bmp header: VBSCript does'nt have records nor writes binary values to files, so we use strings of unicode chars!! \n      'BMP header  \n      .writetext ChrW(&h4d42)                           ' 0 \"BM\" 4d42 \n      .writetext long2wstr(hdrs+palsize+bms)            ' 2 fiesize  \n      .writetext long2wstr(0)                           ' 6  reserved \n      .writetext long2wstr (hdrs+palsize)               '10 image offset \n       'InfoHeader \n      .writetext long2wstr(40)                          '14 infoheader size\n      .writetext long2wstr(Imgl)                        '18 image length  \n      .writetext long2wstr(imgh)                        '22 image width\n      .writetext int2wstr(1)                            '26 planes\n      .writetext int2wstr(imgdepth)                     '28 clr depth (bpp)\n      .writetext long2wstr(&H0)                         '30 compression used 0= NOCOMPR\n       \n      .writetext long2wstr(bms)                         '34 imgsize\n      .writetext long2wstr(&Hc4e)                       '38 bpp hor\n      .writetext long2wstr(&hc43)                       '42 bpp vert\n      .writetext long2wstr(szpal)                       '46  colors in palette\n      .writetext long2wstr(&H0)                         '50 important clrs 0=all\n     \n      'write bitmap\n      'precalc data for orientation\n       Dim x1,x2,y1,y2\n       If dirx=-1 Then x1=ImgL-1 :x2=0 Else x1=0:x2=ImgL-1\n       If diry=-1 Then y1=ImgH-1 :y2=0 Else y1=0:y2=ImgH-1 \n       \n      Select Case imgdepth\n      \n      Case 32\n        For y=y1 To y2  step diry   \n          For x=x1 To x2 Step dirx\n           'writelong fic, Pixel(x,y) \n           .writetext long2wstr(Imgarray(x,y))\n          Next\n        Next\n        \n      Case 8\n        'palette\n        For x=0 to szpal-1\n          .writetext long2wstr(palette(x))  '52\n        Next\n        'image\n        dim pad:pad=ImgL mod 4\n        For y=y1 to y2 step diry\n          For x=x1 To x2 step dirx*2\n             .writetext chrw((ImgArray(x,y) and 255)+ &h100& *(ImgArray(x+dirx,y) and 255))\n          Next\n          'line padding\n          if pad and 1 then .writetext  chrw(ImgArray(x2,y))\n          if pad >1 then .writetext  chrw(0)\n         Next\n         \n      Case Else\n        WScript.Echo \"ColorDepth not supported\u00a0: \" & ImgDepth & \" bits\"\n      End Select\n\n      'use a second stream to save to file starting past the BOM  the first ADODB.Stream has added\n      Dim outf:Set outf= CreateObject(\"ADODB.Stream\") \n      outf.Type    = 1 ' adTypeBinary  \n      outf.Open\n      .position=2              'remove bom (1 wchar) \n      .CopyTo outf\n      .close\n      outf.savetofile filename,2   'adSaveCreateOverWrite\n      outf.close\n    end with\n  End Sub\nEnd Class\n\nfunction mandelpx(x0,y0,maxit)\n   dim x,y,xt,i,x2,y2\n   i=0:x2=0:y2=0\n   Do While i< maxit\n     i=i+1\n     xt=x2-y2+x0\n     y=2*x*y+y0\n     x=xt \n     x2=x*x:y2=y*y \n     If (x2+y2)>=4 Then Exit do\n   loop \n   if i=maxit then\n      mandelpx=0\n   else   \n     mandelpx = i\n   end if  \nend function   \n\nSub domandel(x1,x2,y1,y2) \n Dim i,ii,j,jj,pix,xi,yi,ym\n ym=X.ImgHeight\\2\n 'get increments in the mandel plane\n xi=Abs((x1-x2)/X.ImgWidth)\n yi=Abs((y2-0)/(X.ImgHeight\\2))\n j=0\n For jj=0.  To y2 Step yi\n   i=0\n   For ii=x1 To x2 Step xi\n      pix=mandelpx(ii,jj,256)\n      'use simmetry\n      X.imgarray(i,ym-j)=pix\n      X.imgarray(i,ym+j)=pix\n      i=i+1   \n   Next\n   j=j+1   \n next\nEnd Sub\n\n'main------------------------------------\nDim i,x\n'custom palette\ndim pp(255)\nfor i=1 to 255\n   pp(i)=rgb(0,0,255*(i/255)^.25)  'VBS' RGB function is for the web, it's bgr for Windows BMP\u00a0!!\nnext  \n \ndim fn:fn=CreateObject(\"Scripting.FileSystemObject\").GetSpecialFolder(2)& \"\\mandel.bmp\"\nSet X = (New ImgClass)(fn,580,480,1,8,0,pp)\ndomandel -2.,1.,-1.2,1.2\nSet X = Nothing\n\nOutput:\n\n", "explain": "\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Scheme", "code": "\nA simple implementation for many Scheme implementations[edit]\n\n(define x-centre -0.5)\n(define y-centre 0.0)\n(define width 4.0)\n(define i-max 800)\n(define j-max 600)\n(define n 100)\n(define r-max 2.0)\n(define file \"out.pgm\")\n(define colour-max 255)\n(define pixel-size (/ width i-max))\n(define x-offset (- x-centre (* 0.5 pixel-size (+ i-max 1))))\n(define y-offset (+ y-centre (* 0.5 pixel-size (+ j-max 1))))\n\n(define (inside? z)\n  (define (*inside? z-0 z n)\n    (and (< (magnitude z) r-max)\n         (or (= n 0)\n             (*inside? z-0 (+ (* z z) z-0) (- n 1)))))\n  (*inside? z 0 n))\n\n(define (boolean->integer b)\n  (if b colour-max 0))\n\n(define (pixel i j)\n  (boolean->integer\n    (inside?\n      (make-rectangular (+ x-offset (* pixel-size i))\n                        (- y-offset (* pixel-size j))))))\n\n(define (plot)\n  (with-output-to-file file\n    (lambda ()\n      (begin (display \"P2\") (newline)\n             (display i-max) (newline)\n             (display j-max) (newline)\n             (display colour-max) (newline)\n             (do ((j 1 (+ j 1))) ((> j j-max))\n                 (do ((i 1 (+ i 1))) ((> i i-max))\n                     (begin (display (pixel i j)) (newline))))))))\n\n(plot)\nAn interactive program for CHICKEN Scheme[edit]\nTranslation of: ObjectIcon\nWorks with: CHICKEN Scheme version 5.3.0\n\n;; A program written for CHICKEN Scheme version 5.3.0 and various\n;; eggs.\n\n(import (r7rs))\n(import (scheme base))\n(import (scheme case-lambda))\n(import (scheme inexact))\n\n(import (prefix sdl2 \"sdl2:\"))\n(import (prefix imlib2 \"imlib2:\"))\n\n(import (format))\n(import (matchable))\n(import (simple-exceptions))\n\n(define sdl2-subsystems-used '(events video))\n\n;; ------------------------------\n;; Basics for using the sdl2 egg:\n(sdl2:set-main-ready!)\n(sdl2:init! sdl2-subsystems-used)\n(on-exit sdl2:quit!)\n(current-exception-handler\n (let ((original-handler (current-exception-handler)))\n   (lambda (exception)\n     (sdl2:quit!)\n     (original-handler exception))))\n;; ------------------------------\n\n(define-record-type <mandel-params>\n  (%%make-mandel-params)\n  mandel-params?\n  (window ref-window set-window!)\n  (xcenter ref-xcenter set-xcenter!)\n  (ycenter ref-ycenter set-ycenter!)\n  (pixels-per-unit ref-pixels-per-unit set-pixels-per-unit!)\n  (pixels-per-event-check ref-pixels-per-event-check\n                          set-pixels-per-event-check!)\n  (max-escape-time ref-max-escape-time set-max-escape-time!))\n\n(define initial-width                   400)\n(define initial-height                  400)\n(define initial-xcenter                -3/4)\n(define initial-ycenter                 0)\n(define initial-pixels-per-unit         150)\n(define initial-pixels-per-event-check  1000)\n(define initial-max-escape-time         1000)\n\n(define (make-mandel-params window)\n  (let ((params (%%make-mandel-params)))\n    (set-window! params window)\n    (set-xcenter! params initial-xcenter)\n    (set-ycenter! params initial-ycenter)\n    (set-pixels-per-unit! params initial-pixels-per-unit)\n    (set-pixels-per-event-check! params\n                                 initial-pixels-per-event-check)\n    (set-max-escape-time! params initial-max-escape-time)\n    params))\n\n(define window (sdl2:create-window! \"mandelbrot set task\"\n                                    'centered 'centered\n                                    initial-width initial-height\n                                    '()))\n(define params (make-mandel-params window))\n\n(define empty-color (sdl2:make-color 200 200 200))\n\n(define (clear-mandel!)\n  (sdl2:fill-rect! (sdl2:window-surface (ref-window params))\n                   #f empty-color)\n  (sdl2:update-window-surface! window))\n\n(define drawing? #t)\n(define redraw? #f)\n\n(define (draw-mandel! event-checker)\n  (clear-mandel!)\n  (let repeat ()\n    (let*-values\n        (((window) (ref-window params))\n         ((width height) (sdl2:window-size window)))\n      (let* ((xcenter (ref-xcenter params))\n             (ycenter (ref-ycenter params))\n             (pixels-per-unit (ref-pixels-per-unit params))\n             (pixels-per-event-check\n              (ref-pixels-per-event-check params))\n             (max-escape-time (ref-max-escape-time params))\n             (step (/ 1.0 pixels-per-unit))\n             (xleft (- xcenter (/ width (* 2.0 pixels-per-unit))))\n             (ytop (+ ycenter (/ height (* 2.0 pixels-per-unit))))\n             (pixel-count 0))\n        (do ((j 0 (+ j 1))\n             (cy ytop (- cy step)))\n            ((= j height))\n          (do ((i 0 (+ i 1))\n               (cx xleft (+ cx step)))\n              ((= i width))\n            (let* ((color (compute-color-by-escape-time-algorithm\n                           cx cy max-escape-time)))\n              (sdl2:surface-set! (sdl2:window-surface window)\n                                 i j color)\n              (if (= pixel-count pixels-per-event-check)\n                  (let ((event-checker (call/cc event-checker)))\n                    (cond (redraw?\n                           (set! redraw? #f)\n                           (clear-mandel!)\n                           (repeat)))\n                    (set! pixel-count 0))\n                  (set! pixel-count (+ pixel-count 1)))))\n         \u00a0;; Display a row.\n          (sdl2:update-window-surface! window))))\n    (set! drawing? #f)\n    (repeat)))  \n\n(define (compute-color-by-escape-time-algorithm\n         cx cy max-escape-time)\n  (escape-time->color (compute-escape-time cx cy max-escape-time)\n                      max-escape-time))\n\n(define (compute-escape-time cx cy max-escape-time)\n  (let loop ((x 0.0)\n             (y 0.0)\n             (iter 0))\n    (if (= iter max-escape-time)\n        iter\n        (let ((xsquared (* x x))\n              (ysquared (* y y)))\n          (if (< 4 (+ xsquared ysquared))\n              iter\n              (let ((x (+ cx (- xsquared ysquared)))\n                    (y (+ cy (* (+ x x) y))))\n                (loop x y (+ iter 1))))))))\n\n(define (escape-time->color escape-time max-escape-time)\n \u00a0;; This is a very naive and ad hoc algorithm for choosing colors,\n \u00a0;; but hopefully will suffice for the task. With this algorithm, at\n \u00a0;; least one can zoom in and see some of the fractal-like structures\n \u00a0;; out on the filaments.\n  (let* ((initial-ppu initial-pixels-per-unit)\n         (ppu (ref-pixels-per-unit params))\n         (fraction (* (/ (log escape-time) (log max-escape-time))))\n         (fraction (if (= fraction 1.0)\n                       fraction\n                       (* fraction\n                          (/ (log initial-ppu)\n                             (log (max initial-ppu (* 0.05 ppu)))))))\n         (value (- 255 (min 255 (exact-rounded (* fraction 255))))))\n    (sdl2:make-color value value value)))\n\n(define (exact-rounded x)\n  (exact (round x)))\n\n(define (event-loop)\n  (define event (sdl2:make-event))\n  (define painter draw-mandel!)\n  (define zoom-ratio 2)\n\n  (define (recenter! xcoord ycoord)\n    (let*-values\n        (((window) (ref-window params))\n         ((width height) (sdl2:window-size window))\n         ((ppu) (ref-pixels-per-unit params)))\n      (set-xcenter! params\n                    (+ (ref-xcenter params)\n                       (/ (- (* 2.0 xcoord) width) (* 2.0 ppu))))\n      (set-ycenter! params\n                    (+ (ref-ycenter params)\n                       (/ (- height (* 2.0 ycoord)) (* 2.0 ppu))))))\n\n  (define (zoom-in!)\n    (let* ((ppu (ref-pixels-per-unit params))\n           (ppu (* ppu zoom-ratio)))\n      (set-pixels-per-unit! params ppu)))\n\n  (define (zoom-out!)\n    (let* ((ppu (ref-pixels-per-unit params))\n           (ppu (* (/ 1.0 zoom-ratio) ppu)))\n      (set-pixels-per-unit! params (max 1 ppu))))\n\n  (define (restore-original-settings!)\n    (set-xcenter! params initial-xcenter)\n    (set-ycenter! params initial-ycenter)\n    (set-pixels-per-unit! params initial-pixels-per-unit)\n    (set-pixels-per-event-check!\n     params initial-pixels-per-event-check)\n    (set-max-escape-time! params initial-max-escape-time)\n    (set! zoom-ratio 2))\n\n  (define dump-image!           \u00a0; Really this should put up a dialog.\n    (let ((dump-number 1))\n      (lambda ()\n        (let*-values\n            (((window) (ref-window params))\n             ((width height) (sdl2:window-size window))\n             ((surface) (sdl2:window-surface window)))\n          (let ((filename (string-append \"mandelbrot-image-\"\n                                         (number->string dump-number)\n                                         \".png\"))\n                (img (imlib2:image-create width height)))\n            (do ((j 0 (+ j 1)))\n                ((= j height))\n              (do ((i 0 (+ i 1)))\n                  ((= i width))\n                (let-values\n                    (((r g b a) (sdl2:color->values\n                                 (sdl2:surface-ref surface i j))))\n                  (imlib2:image-draw-pixel\n                   img (imlib2:color/rgba r g b a) i j))))\n            (imlib2:image-alpha-set! img #f)\n            (imlib2:image-save img filename)\n            (format #t \"~a written~%\" filename)\n            (set! dump-number (+ dump-number 1)))))))\n    \n  (let loop ()\n    (when redraw?\n      (set! drawing? #t))\n    (when drawing?\n      (set! painter (call/cc painter)))\n    (set! redraw? #f)\n    (if (not (sdl2:poll-event! event))\n        (loop)\n        (begin\n          (match (sdl2:event-type event)\n            ('quit)                    \u00a0; Quit by leaving the loop.\n            ('window\n             (match (sdl2:window-event-event event)\n              \u00a0;; It should be possible to resize the window, but I\n              \u00a0;; have not yet figured out how to do this with SDL2\n              \u00a0;; and not crash sometimes.\n               ((or 'exposed 'restored)\n                (sdl2:update-window-surface! (ref-window params))\n                (loop))\n               (_ (loop))))\n            ('mouse-button-down\n             (recenter! (sdl2:mouse-button-event-x event)\n                        (sdl2:mouse-button-event-y event))\n             (set! redraw? #t)\n             (loop))\n            ('key-down\n             (match (sdl2:keyboard-event-sym event)\n               ('q 'quit-by-leaving-the-loop)\n               ((or 'plus 'kp-plus)\n                (zoom-in!)\n                (set! redraw? #t)\n                (loop))\n               ((or 'minus 'kp-minus)\n                (zoom-out!)\n                (set! redraw? #t)\n                (loop))\n               ((or 'n-2 'kp-2)\n                (set! zoom-ratio 2)\n                (loop))\n               ((or 'n-3 'kp-3)\n                (set! zoom-ratio 3)\n                (loop))\n               ((or 'n-4 'kp-4)\n                (set! zoom-ratio 4)\n                (loop))\n               ((or 'n-5 'kp-5)\n                (set! zoom-ratio 5)\n                (loop))\n               ((or 'n-6 'kp-6)\n                (set! zoom-ratio 6)\n                (loop))\n               ((or 'n-7 'kp-7)\n                (set! zoom-ratio 7)\n                (loop))\n               ((or 'n-8 'kp-8)\n                (set! zoom-ratio 8)\n                (loop))\n               ((or 'n-9 'kp-9)\n                (set! zoom-ratio 9)\n                (loop))\n               ('o\n                (restore-original-settings!)\n                (set! redraw? #t)\n                (loop))\n               ('p\n                (dump-image!)\n                (loop))\n               (some-key-in-which-we-are-not-interested\n                (loop))))\n            (some-event-in-which-we-are-not-interested\n             (loop)))))))\n\n;; At the least this legend should go in a window, but printing it to\n;; the terminal will, hopefully, suffice for the task.\n(format #t \"~%~8tACTIONS~%\")\n(format #t \"~8t-------~%\")\n(define fmt \"~2t~a~15t: ~a~%\")\n(format #t fmt \"Q key\" \"quit\")\n(format #t fmt \"mouse button\" \"recenter\")\n(format #t fmt \"+ key\" \"zoom in\")\n(format #t fmt \"- key\" \"zoom in\")\n(format #t fmt \"2 .. 9 key\" \"set zoom ratio\")\n(format #t fmt \"O key\" \"restore original\")\n(format #t fmt \"P key\" \"dump to a PNG\")\n(format #t \"~%\")\n\n(event-loop)\n\nOutput:\n\n\n", "explain": "This implementation writes an image of the Mandelbrot set to a plain pgm file. The set itself is drawn in white, while the exterior is drawn in black.\nYou will need several CHICKEN \"eggs\", which can be deduced from the imports.\nCompile with (for example) csc -O3 mandelbrot_task_CHICKEN.scm.\nAn example of a PNG dumped by the program while it was zoomed in:\n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "PowerShell", "code": "\n$x = $y = $i = $j = $r = -16\n$colors = [Enum]::GetValues([System.ConsoleColor])\n\nwhile(($y++) -lt 15)\n{\n    for($x=0; ($x++) -lt 84; Write-Host \" \" -BackgroundColor ($colors[$k -band 15]) -NoNewline)\n    {\n        $i = $k = $r = 0\n\n        do\n        {\n            $j = $r * $r - $i * $i -2 + $x / 25\n            $i = 2 * $r * $i + $y / 10\n            $r = $j\n        }\n        while (($j * $j + $i * $i) -lt 11 -band ($k++) -lt 111)\n    }\n\n    Write-Host\n}\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "Logo", "code": "\nWorks with: UCB Logo\nto mandelbrot :left :bottom :side :size\n  cs setpensize [1 1]\n  make \"inc :side/:size\n  make \"zr :left\n  repeat :size [\n    make \"zr :zr + :inc\n    make \"zi :bottom\n    pu\n    setxy repcount - :size/2  minus :size/2\n    pd\n    repeat :size [\n      make \"zi :zi + :inc\n      setpencolor count.color calc :zr :zi\n      fd 1 ] ]\nend\n\nto count.color :count\n  ;op (list :count :count :count)\n  if :count > 256 [op 0]\t; black\n  if :count > 128 [op 7]\t; white\n  if :count >  64 [op 5]\t; magenta\n  if :count >  32 [op 6]\t; yellow\n  if :count >  16 [op 4]\t; red\n  if :count >   8 [op 2]\t; green\n  if :count >   4 [op 1]\t; blue\n  op 3\t\t\t\t; cyan\nend\n\nto calc :zr :zi [:count 0] [:az 0] [:bz 0]\n  if :az*:az + :bz*:bz > 4 [op :count]\n  if :count > 256 [op :count]\n  op (calc :zr :zi (:count + 1) (:zr + :az*:az - :bz*:bz) (:zi + 2*:az*:bz))\nend\n\nmandelbrot -2 -1.25 2.5 400\n", "explain": ""}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "F#", "code": "\nopen System.Drawing \nopen System.Windows.Forms\ntype Complex =\n    { \n        re : float;\n        im : float\n    }\nlet cplus (x:Complex) (y:Complex) : Complex = \n    {\n        re = x.re + y.re;\n        im = x.im + y.im\n    }\nlet cmult (x:Complex) (y:Complex) : Complex = \n    {\n        re = x.re * y.re - x.im * y.im;\n        im = x.re * y.im + x.im * y.re;\n    }\n\nlet norm (x:Complex) : float =\n    x.re*x.re + x.im*x.im\n\ntype Mandel = class\n    inherit Form\n    static member xPixels = 500\n    static member yPixels = 500\n    val mutable bmp : Bitmap\n    member x.mandelbrot xMin xMax yMin yMax maxIter =\n        let rec mandelbrotIterator z c n =\n            if (norm z) > 2.0 then false else\n                match n with\n                    | 0 -> true\n                    | n -> let z' = cplus ( cmult z z ) c in\n                            mandelbrotIterator z' c (n-1)\n        let dx = (xMax - xMin) / (float (Mandel.xPixels))\n        let dy = (yMax - yMin) / (float (Mandel.yPixels))\n        in\n        for xi = 0 to Mandel.xPixels-1 do\n            for yi = 0 to Mandel.yPixels-1 do\n                let c = {re = xMin + (dx * float(xi) ) ;\n                         im = yMin + (dy * float(yi) )} in\n                if (mandelbrotIterator {re=0.;im=0.;} c maxIter) then\n                    x.bmp.SetPixel(xi,yi,Color.Azure)\n                else\n                    x.bmp.SetPixel(xi,yi,Color.Black)\n            done\n        done\n\n    member public x.generate () = x.mandelbrot (-1.5) 0.5 (-1.0) 1.0 200 ; x.Refresh()\n\n    new() as x = {bmp = new Bitmap(Mandel.xPixels , Mandel.yPixels)} then\n        x.Text <- \"Mandelbrot set\" ;\n        x.Width <- Mandel.xPixels ;\n        x.Height <- Mandel.yPixels ;\n        x.BackgroundImage <- x.bmp;\n        x.generate();\n        x.Show();   \nend\n\nlet f = new Mandel()\ndo Application.Run(f)\n\nAlternate version, applicable to text and GUI[edit]\n\nlet getMandelbrotValues width height maxIter ((xMin,xMax),(yMin,yMax)) =\n  let mandIter (cr:float,ci:float) =\n    let next (zr,zi) = (cr + (zr * zr - zi * zi)), (ci + (zr * zi + zi * zr))\n    let rec loop = function\n      | step,_ when step=maxIter->0\n      | step,(zr,zi) when ((zr * zr + zi * zi) > 2.0) -> step\n      | step,z -> loop ((step + 1), (next z))\n    loop (0,(0.0, 0.0))\n  let forPos =\n    let dx, dy = (xMax - xMin) / (float width), (yMax - yMin) / (float height)\n    fun y x -> mandIter ((xMin + dx * float(x)), (yMin + dy * float(y)))\n  [0..height-1] |> List.map(fun y->[0..width-1] |> List.map (forPos y))\n\n\ngetMandelbrotValues 80 25 50 ((-2.0,1.0),(-1.0,1.0))\n|> List.map(fun row-> row |> List.map (function | 0 ->\" \" |_->\".\") |> String.concat \"\")\n|> List.iter (printfn \"%s\")\n\n\n\nOutput:\n................................................................................\n................................................................................\n.................................................  .............................\n................................................     ...........................\n.................................................    ...........................\n.......................................   .               ......................\n........................................                       .................\n....................................                          ..................\n....................................                           .................\n..........................  ......                              ................\n.......................         ...                             ................\n.....................            .                              ................\n.................                                              .................\n.................                                              .................\n.....................            .                              ................\n.......................         ...                             ................\n..........................  ......                              ................\n....................................                           .................\n....................................                          ..................\n........................................                       .................\n.......................................   .               ......................\n.................................................    ...........................\n................................................     ...........................\n.................................................  .............................\n................................................................................\n\n\nopen System.Drawing \nopen System.Windows.Forms\n\nlet showGraphic (colorForIter: int -> Color) (width: int) (height:int) maxIter view =\n  new Form()\n  |> fun frm ->\n    frm.Width <- width\n    frm.Height <- height\n    frm.BackgroundImage <- \n      new Bitmap(width,height)\n      |> fun bmp ->\n        getMandelbrotValues width height maxIter view\n        |> List.mapi (fun y row->row |> List.mapi (fun x v->((x,y),v))) |> List.collect id\n        |> List.iter (fun ((x,y),v) -> bmp.SetPixel(x,y,(colorForIter v)))\n        bmp\n    frm.Show()\n\nlet toColor = (function | 0 -> (0,0,0) | n -> ((31 &&& n) |> fun x->(0, 18 + x * 5, 36 + x * 7))) >> Color.FromArgb\n\nshowGraphic toColor 640 480 5000 ((-2.0,1.0),(-1.0,1.0))\n\n", "explain": " Basic generation code \n Text display \nResults:\n Graphics display \n"}, {"task_name": "Mandelbrot set", "task_url": "https://rosettacode.org/wiki/Mandelbrot_set", "task_cat": "Geometry", "lang": "AWK", "code": "\nBEGIN {\n  XSize=59; YSize=21;\n  MinIm=-1.0; MaxIm=1.0;MinRe=-2.0; MaxRe=1.0;\n  StepX=(MaxRe-MinRe)/XSize; StepY=(MaxIm-MinIm)/YSize;\n  for(y=0;y<YSize;y++)\n  {\n    Im=MinIm+StepY*y;\n    for(x=0;x<XSize;x++)\n        {\n      Re=MinRe+StepX*x; Zr=Re; Zi=Im;\n      for(n=0;n<30;n++)\n          {\n        a=Zr*Zr; b=Zi*Zi;\n        if(a+b>4.0) break;\n        Zi=2*Zr*Zi+Im; Zr=a-b+Re;\n      }\n      printf \"%c\",62-n;\n    }\n    print \"\";\n  }\n  exit;\n}\n\n\nOutput:\n>>>>>>=====<<<<<<<<<<<<<<<;;;;;;:::96032:;;;;<<<<==========\n>>>>>===<<<<<<<<<<<<<<<<;;;;;;;:::873*079::;;;;<<<<<=======\n>>>>===<<<<<<<<<<<<<<<;;;;;;;::9974    (.9::::;;<<<<<======\n>>>==<<<<<<<<<<<<<<<;;;;;;:98888764     5789999:;;<<<<<====\n>>==<<<<<<<<<<<<<;;;;::::996. &2           45335:;<<<<<<===\n>>=<<<<<<<<<<<;;;::::::999752                 *79:;<<<<<<==\n>=<<<<<<<<;;;:599999999886                    %78:;;<<<<<<=\n><<<<;;;;;:::972456-567763                      +9;;<<<<<<<\n><;;;;;;::::9875&      .3                       *9;;;<<<<<<\n>;;;;;;::997564'        '                       8:;;;<<<<<<\n>::988897735/                                 &89:;;;<<<<<<\n>::988897735/                                 &89:;;;<<<<<<\n>;;;;;;::997564'        '                       8:;;;<<<<<<\n><;;;;;;::::9875&      .3                       *9;;;<<<<<<\n><<<<;;;;;:::972456-567763                      +9;;<<<<<<<\n>=<<<<<<<<;;;:599999999886                    %78:;;<<<<<<=\n>>=<<<<<<<<<<<;;;::::::999752                 *79:;<<<<<<==\n>>==<<<<<<<<<<<<<;;;;::::996. &2           45335:;<<<<<<===\n>>>==<<<<<<<<<<<<<<<;;;;;;:98888764     5789999:;;<<<<<====\n>>>>===<<<<<<<<<<<<<<<;;;;;;;::9974    (.9::::;;<<<<<======\n>>>>>===<<<<<<<<<<<<<<<<;;;;;;;:::873*079::;;;;<<<<<=======\n\n", "explain": ""}]