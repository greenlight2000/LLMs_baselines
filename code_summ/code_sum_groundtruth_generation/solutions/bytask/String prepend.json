[{"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Python", "code": "\n\n#!/usr/bin/env python\n# -*- coding: utf-8 -*-\n\ns = \"12345678\"\ns = \"0\" + s  # by concatenation\nprint(s)\n\n\nOutput:\n012345678\n\n", "explain": "File: string_prepend.py\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "C", "code": "\n#include<stdio.h>\n#include<string.h>\n#include<stdlib.h>\n\nint main()\n{\n    char str[100]=\"my String\";\n    char *cstr=\"Changed \";\n    char *dup;\n    sprintf(str,\"%s%s\",cstr,(dup=strdup(str)));\n    free(dup);\n    printf(\"%s\\n\",str);\n    return 0;\n}\n\n\nOutput:\nChanged my String\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "C++", "code": "\ninclude <vector>\n#include <algorithm>\n#include <string>\n#include <iostream>\n\nint main( ) {\n   std::vector<std::string> myStrings { \"prepended to\" , \"my string\" } ;\n   std::string prepended = std::accumulate( myStrings.begin( ) , \n\t myStrings.end( ) , std::string( \"\" ) , []( std::string a , \n\t    std::string b ) { return a + b ; } ) ;\n   std::cout << prepended << std::endl ;\n   return 0 ;\n}\n\n\nOutput:\nprepended tomy string\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Java", "code": "\n\nString string = \"def\";\nstring = \"abc\" + string;\n\n\nString string = \"def\";\nstring = \"abc\".concat(string);\n\n\nStringBuilder string = new StringBuilder();\nstring.append(\"def\");\nstring.insert(0, \"abc\");\n\n\nString string = \"def\";\nstring = String.format(\"abc%s\", string);\n\nString string = \"def\";\nstring = \"abc%s\".formatted(string);\n\n\nabcdef\n\n", "explain": "Java does not have a prepend method.\nThe most logical way to prepend a string value is with basic concatenation.\nYou could also use the String.concat method.\nYou could use the StringBuilder class which provides an insert method.\nAdditionally, you could use the String.format or String.formatted methods.\nAll of these will produce the following output.\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "C#", "code": "\nusing System;\n\nnamespace PrependString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string str = \"World\";\n            str = \"Hello \" + str;\n            Console.WriteLine(str);\n            Console.ReadKey();\n        }\n    }\n}\n\nHello World\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\n// No built-in prepend\nvar s=\", World\"\ns = \"Hello\" + s\nprint(s);\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nEarly inability[edit]\n\nInitial difficulty[edit]\nWith Fortran IV came the ability to use arrays of integers and the A1 format code in READ and WRITE statements for them. With sixteen-bit integers, one might use A2 and so forth, but the numerical values of the integers would not be convenient especially if the sign bit was involved. This would be even more difficult with floating-point variables. Still, the desire for good headings and annotations and flexible layout flogged one onwards. Following the Pascal \"Hello world!\" example, one might proceed somewhat as follows:      INTEGER*4 I,TEXT(66)\n      DATA TEXT(1),TEXT(2),TEXT(3)/\"Wo\",\"rl\",\"d!\"/\n\n      WRITE (6,1) (TEXT(I), I = 1,3)\n    1 FORMAT (\"Hello \",66A2)\n\n      DO 2 I = 1,3\n    2   TEXT(I + 3) = TEXT(I)\n      TEXT(1) = \"He\"\n      TEXT(2) = \"ll\"\n      TEXT(3) = \"o \"\n\n      WRITE (6,3) (TEXT(I), I = 1,6)\n    3 FORMAT (66A2)\n      END\n\n\nHaving made space, the next statements merely assign some bit patterns to elements of TEXT, and then the result is revealed, again using known constants instead of the associated variables of the more general approach. The result from the two WRITE statements is of course Hello world!\nHello world!\nCharacter facility[edit]\nWith F77 came the CHARACTER type...       CHARACTER*66 TEXT\n      TEXT = \"World!\"\n      TEXT = \"Hello \"//TEXT\n      WRITE (6,*) TEXT\n      END\n\n\nModern[edit]\n\n", "explain": "Early Fortran had almost no ability to manipulate text except via overwriting text literals in a FORMAT statement used in a READ, that would then appear when the same FORMAT statement was used in a WRITE (!) perhaps as a heading. \nThis old-style source is acceptable to the F90 compiler as it stands. By chance, two characters per integer fits nicely but in many cases having one character per variable is easier for manipulation. So, as usual with Fortran, it's all done with arrays. The DATA statement demonstrates that a quoted string is acceptable as a value for an integer; it is just a matter of bit patterns, and this type miscegnation will work with floating-point variables also though resulting in even stranger numerical values. Looking more closely, note that an INTEGER*4 variable can hold four eight-bit characters but only two-character text literals have been specified. Unlike integer constants, which might be considered to have leading zero digits, text literals are deemed to have trailing spaces as needed: \"Wo\" is deemed to be \"Wo  \" to make up to the recipient's capacity for four characters, and when format code A2 is specified, the leftmost two characters in the variable are taken. The strange ideas of \"little-endianism\" have never flourished on mainframes! Thus, if the format code were to be A4, then \"Wo  \" would appear, not \"  Wo\".\nThe first output (to standard output: unit 6) thus prepends the text \"Hello \" via the workings of the nominated FORMAT statement without a further mention of variable TEXT, itself not being modified in this action. Thus, this is an example of a single-mention possibility.\nSome versions of Fortran offered the ability to write to a variable such as an array rather than to a nominated output unit, via a statement like WRITE (TEXT,1) (TEXT(I),I = 1,3), which array could then itself be written to the actual output via normal statements. This would involve a working variable within the routines for formatted I/O to hold the output, and thus provides one of the reasons that Fortran I/O implementations seldom enable re-entrancy - as with a WRITE statement whose output expression list includes a function evaluation, which function itself attempts to WRITE something, say to a log file, with both WRITE statements employing formatting statements. More modern compilers now require the recipient for this sort of WRITE statement to be of type CHARACTER, so the older style is blocked - and re-entrancy is still a problem.\nStill another variant involved writing to unit number zero, which did not actually send anything to an output recipient. Instead, the scratchpad used by the formatted I/O system would retain whatever was produced, which could then be read back via unit number zero. Indeed, reading from unit zero would reveal whatever had been the last line of the previous I/O statement. This would be of interest if a format error had been reported on a READ during some mass data acquisition, so that the error message could show the problematic input that had been obtained rather than just complain. But this facility was not common, and did not become a part of the F90 standard. Perhaps a BACKSPACE and re-read to a text variable will work instead... \nRetreating from FORMAT usage to the case of manipulating a \"string\" variable so as to prepend a given text to the working variable, first the existing content must be moved right to make room (again, an even number of characters is involved) which is achieved via the DO-loop, using certain constants. If on the other hand, text were to be removed from the front, then a loop would be needed to shift the surviving content leftwards. In doing this, one must pay attention to any overlaps and the direction of the loop! By chance, this exercise starts the placement after the end of the existing text but if instead the shift were to be two units, then the first-placed unit would land atop the tail end of the existing text. Thus, for rightwards shifts, one should start with the end of the surviving text and work back to its start.\nThis means that variable TEXT has space for 66 characters, addressed as TEXT(first:last) starting with one. There is no associated string length facility, so the first assignment places the six characters of the supplied literal, followed by spaces all the way to the end of TEXT. Alternatively, TEXT(1:6) = \"World!\" would place only six characters, leaving the rest of TEXT to hold whatever it may. This would probably be unsuitable for the next statement, which prepends \"Hello \" to the content of TEXT (including positions past six) and assigns the result to TEXT, overwriting its previous content - with the aid of a temporary working area. Although in principle there could be cunning schemes that update the recipient \"in place\" with a minimum of character copying to and fro, this doesn't happen. Only characters up to the capacity of the recipient will be transferred from the expression's result, and if the result is shorter than the capacity of the recipient, trailing spaces will be added. All of this is extra effort! And when TEXT is written out, all 66 characters will be sent forth. It is useful to have a function that locates the last non-blank character!\nWith F90, and standardised in F2003, came extensions that enable a variable to be \"cut-to-fit\" on each usage. The first assignment would discard any storage associated with TEXT and re-assign space matching the size of the expression's result, so TEXT would have six characters. In the next statement, the expression would be evaluated and produce twelve characters (six from \"Hello \", and the six of the current size of TEXT), then the current storage for text would be discarded and TEXT re-allocated to be of size twelve. At some cost in overhead. On the other hand, rather than copy the result of an expression from the scratchpad to the recipient, with re-allocation, the recipient variable could be repointed to the result area: no copying needed.\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Go", "code": "\ns := \"world!\"\ns = \"Hello, \" + s\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nprogram String_preappend;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\ntype\n  TStringHelper = record helper for string\n    procedure Preappend(str: string);\n  end;\n\n{ TStringHelper }\n\nprocedure TStringHelper.Preappend(str: string);\nbegin\n  Self := str + self;\nend;\n\nbegin\n  var h: string;\n\n  // with + operator\n  h := 'World';\n  h := 'Hello ' + h;\n  writeln(h);\n\n  // with a function concat\n  h := 'World';\n  h := concat('Hello ', h);\n  writeln(h);\n\n  // with helper\n  h := 'World';\n  h.Preappend('Hello ');\n  writeln(h);\n  readln;\nend.\n\n\nOutput:\nHello World\nHello World\nHello World\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\nstr = \"llo world\"\nstr.prepend(\"He\")\np str #=> \"Hello world\"\n\n", "explain": "There is a method for prepending a string, aptly named \"prepend\".\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Rust", "code": "\nlet mut s = \"World\".to_string();\ns.insert_str(0, \"Hello \");\nprintln!(\"{}\", s);\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Swift", "code": "\nWorks with: Swift version 5\nvar str = \", World\"\nstr = \"Hello\" + str\nprint(str)\n\n\nOutput:\nHello, World!\n\nWorks with: Swift version 1\nvar str = \", World\"\nstr = \"Hello \\(str)\"\nprintln(str)\n\n\nOutput:\nHello, World!\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "COBOL", "code": "\n       identification division.\n       program-id. prepend.\n       data division.\n       working-storage section.\n       1 str pic x(30) value \"World!\".\n       1 binary.\n        2 len pic 9(4) value 0.\n        2 scratch pic 9(4) value 0.\n       procedure division.\n       begin.\n           perform rev-sub-str\n           move function reverse (\"Hello \") to str (len + 1:)\n           perform rev-sub-str\n           display str\n           stop run\n           .\n\n       rev-sub-str.\n           move 0 to len scratch\n           inspect function reverse (str)\n           tallying scratch for leading spaces\n               len for characters after space\n           move function reverse (str (1:len)) to str\n           .\n       end program prepend.\n\nHello World!\nWorks with: GNU Cobol version 2.0\n       >>SOURCE FREE\nPROGRAM-ID. prepend.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  str                                 PIC X(30) VALUE \"world!\".\n\nPROCEDURE DIVISION.\n    MOVE FUNCTION CONCATENATE(\"Hello, \", str) TO str\n    DISPLAY str\n    .\nEND PROGRAM prepend.\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Ada", "code": "\n\nwith Ada.Text_IO; with Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure Prepend_String is   \n   S: Unbounded_String := To_Unbounded_String(\"World!\"); \nbegin\n   S := \"Hello \" & S;-- this is the operation to prepend \"Hello \" to S. \n   Ada.Text_IO.Put_Line(To_String(S));\nend Prepend_String;\n\n\nOutput:\nHello World!\n", "explain": "In Ada, a variable of type String cannot change its length. So the variable S which we will change, need to be of the type Unbounded_String. Thus the need for conversions from String literal to Unbounded_String for initialization, and from Unbounded_String to String for printing. \n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Julia", "code": "\ns = \"world!\"\ns = \"Hello \" * s\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    var s = \"Obama\"\n    s = \"Barack \" + s\n    println(s)\n\n    // It's also possible to use this standard library function\n    // though this is not what it's really intended for\n    var t = \"Trump\"\n    t = t.prependIndent(\"Donald \")\n    println(t)\n}\n\n\nOutput:\nBarack Obama\nDonald Trump\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Perl", "code": "\nuse strict;\nuse warnings;\nuse feature ':all';\n\n# explicit concatentation\n$_ = 'bar';\n$_ = 'Foo' . $_;\nsay;\n\n\n# lvalue substr\n$_ = 'bar';\nsubstr $_, 0, 0, 'Foo';\nsay;\n\n\n# interpolation as concatenation\n# (NOT safe if concatenate sigils)\n$_ = 'bar';\n$_ = \"Foo$_\";\nsay;\n\n\nOutput:\nFoobar\nFoobar\nFoobar\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog\n\n:- op(200, xfx, user:(=+)).\n\n%% +Prepend =+ +Chars\n%\n%    Will destructively update Chars\n%    So that Chars = Prepend prefixed to Chars.\n%    eazar001 in ##prolog helped refine this approach.\n\n[X|Xs] =+ Chars :-\n  append(Xs, Chars, Rest),\n  nb_setarg(2, Chars, Rest),\n  nb_setarg(1, Chars, X).\n\n\n?- Str = `World!`, `Hello, ` =+ Str.\nStr = \"Hello, World!\".\n\n\n", "explain": "In its admirable wisdom, Prolog is generally unfriendly \nto state mutations and destructive assignment. However, it\nis also very flexible. Using the traditional representation\nof strings as lists of character codes, and the non-logical\npredicate `setarg/3`, we can destructively set the head and \ntail of the list to achieve a mutation of the variable holding\nthe string. I define an operator for the purpose: \nExample of this abomination in action:\nNote: I can't imagine when I would want to do this in Prolog.\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Lua", "code": "\n\ns = \"12345678\"\ns = \"0\" .. s\nprint(s)\n\n\ns = \"12345678\"\ns = string.format(\"%s%s\", \"0\", s)\nprint(s)\n\n\ns = \"12345678\"\ns = table.concat({\"0\", s})\nprint(s)\n\n\nOutput: of each solution\n\n    012345678\n\n", "explain": "By concatenation:\nBy string formatting:\nBy list joining:\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Scala", "code": "\n\n  val s = \"World\" // Immutables are recommended   //> s \u00a0: String = World\n  val f2 = () => \", \" //Function assigned to variable\n                                                  //> f2 \u00a0: () => String = <function0>\n  val s1 = \"Hello\" + f2() + s                     //> s1 \u00a0: String = Hello, World\n  println(s1);                                    //> Hello, World\n\n", "explain": "Evaluation in Scala worksheet\n"}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main() {\n    string s = \"world!\";\n    s = \"Hello \" ~ s; \n    writeln(s);\n}\n\n\nOutput:\nHello world!\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nPrelude> let f = (++\" World!\")\nPrelude> f \"Hello\"\n\n\nOutput:\n\"Hello world!\"\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "VBScript", "code": "\ns = \"bar\"\ns = \"foo\" & s\nWScript.Echo s\n\n\nOutput:\nfoobar\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n$str = \"World!\"\n$str = \"Hello, \" + $str\n$str\n\nHello, World!\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\nClassic tag based CFML[edit]\n<cfoutput>\n\t<cfset who = \"World!\">\n\t#\"Hello \" & who#\n</cfoutput>\n\n\nOutput:\nHello World! \n\nScript Based CFML[edit]\n<cfscript>\n\twho = \"World!\";\n\tgreeting = \"Hello \" & who;\n\twriteOutput( greeting );\n</cfscript>\n\n\nOutput:\nHello World! \n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "F#", "code": "\nlet mutable s = \"world!\"\ns <- \"Hello, \" + s\nprintfn \"%s\" s\n\n", "explain": ""}, {"task_name": "String prepend", "task_url": "https://rosettacode.org/wiki/String_prepend", "task_cat": "String manipulation", "lang": "AWK", "code": "\n# syntax: GAWK -f STRING_PREPEND.AWK\nBEGIN {\n    s = \"bar\"\n    s = \"foo\" s\n    print(s)\n    exit(0)\n}\n\n\nOutput:\nfoobar\n\n", "explain": ""}]