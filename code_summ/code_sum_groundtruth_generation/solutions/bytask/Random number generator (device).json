[{"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Python", "code": "\nimport random\nrand = random.SystemRandom()\nrand.randint(1,10)\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n\n#define RANDOM_PATH \"/dev/urandom\"\n\nint main(void)\n{\n        unsigned char buf[4];\n        unsigned long v;\n        FILE *fin;\n\n        if ((fin = fopen(RANDOM_PATH, \"r\")) == NULL) {\n                fprintf(stderr, \"%s: unable to open file\\n\", RANDOM_PATH);\n                return EXIT_FAILURE;\n        }\n        if (fread(buf, 1, sizeof buf, fin) != sizeof buf) {\n                fprintf(stderr, \"%s: not enough bytes (expected %u)\\n\",\n                        RANDOM_PATH, (unsigned) sizeof buf);\n                return EXIT_FAILURE;\n        }\n        fclose(fin);\n        v = buf[0] | buf[1] << 8UL | buf[2] << 16UL | buf[3] << 24UL;\n        printf(\"%lu\\n\", v);\n        return 0;\n}\n\nLibrary: BSD libc[edit]\n\n#include <inttypes.h> /* PRIu32 */\n#include <stdlib.h> /* arc4random */\n#include <stdio.h>  /* printf */\n\nint\nmain()\n{\n  printf(\"%\" PRIu32 \"\\n\", arc4random());\n  return 0;\n}\n\nLibrary: OpenSSL[edit]\n\n#include <inttypes.h>\n#include <stdio.h>\n\n#include <openssl/err.h>\n#include <openssl/rand.h>\n\nint\nmain()\n{\n  uint32_t v;\n\n  if (RAND_bytes((unsigned char *)&v, sizeof v) == 0) {\n    ERR_print_errors_fp(stderr);\n    return 1;\n  }\n  printf(\"%\" PRIu32 \"\\n\", v);\n  return 0;\n}\n\nWindows[edit]\nWorks with: MinGW\n#include <stdio.h>  /* printf */\n#include <windows.h>\n#include <wincrypt.h> /* CryptAcquireContext, CryptGenRandom */\n\nint\nmain()\n{\n  HCRYPTPROV p;\n  ULONG i;\n\n  if (CryptAcquireContext(&p, NULL, NULL,\n      PROV_RSA_FULL, CRYPT_VERIFYCONTEXT) == FALSE) {\n    fputs(\"CryptAcquireContext failed.\\n\", stderr);\n    return 1;\n  }\n  if (CryptGenRandom(p, sizeof i, (BYTE *)&i) == FALSE) {\n    fputs(\"CryptGenRandom failed.\\n\", stderr);\n    return 1;\n  }\n  printf(\"%lu\\n\", i);\n  CryptReleaseContext(p, 0);\n  return 0;\n}\n\ndebian/linux made from scratch[edit]\nWorks with: GCC\n#include <stdio.h> \n#include <stdlib.h>\n\n/*\n   (C) 2020 J.G.A. Debaere, all rights reserved 2020/10/29\n\n    Put into Public Domain for individuals only \n         \n    Tested with NIST, Diehard, Diehard 3.31\n    \n    gcc -lm ./jpsrand_f.c -o ./jpsrand_f.o\n\n    dieharder -a -f /tmp/tmp.bin\n\n\tI consider it TRNG, \n\t\n\tusing Time, Hardddisk and Memory as the hardware component\n\n\tNo warranty of any kind, \"AS IS\"\n\t \n\tLast time I tested  ( 2021/07/07 ) with dieharder:\n\t \n\trgb_bitdist\t\t|   8|    100000|     100|0.99716738|   WEAK \t\n\trgb_lagged_sum\t|   3|   1000000|     100|0.99661184|   WEAK \n\t \n\tOut of 114 tests, rest PASSED\n\n        Obviously, it changes per run\u00a0:)\n\t\n*/\n\nunsigned int  jps_rand()\n{\n    /* (C) 2020 J.G.A. Debaere, all rights reserved */\n    \n    #include   <dirent.h>\n\n    #include <sys/time.h>\n\n    struct timeval current_time ;\n    \n    DIR *folder ;\n    \n    struct dirent *en ;    \n    \n    folder = opendir ( \".\" ) ;\n\n    while ( ( folder ) && ( en = readdir ( folder ) ) != NULL )\n\n        asm ( \"nop\" ) ;\n        \n    closedir ( folder ) ;\n   \n    gettimeofday( &current_time, NULL ) ;\n        \n    unsigned int t = ( current_time.tv_sec * current_time.tv_usec / 17.17 ) ; \n    \n    return t ;\n}\n\nint main() \n{ \n    FILE * f1;\n\n    f1 = fopen(\"/tmp/tmp.bin\", \"wb\");\n\n\n    unsigned int t = ( unsigned int ) jps_rand() ;\n    \n    for ( unsigned int k = 0;  k < 40000000 ; k++ )\n    {\n        t = jps_rand () ;\n\n        fwrite ( &t, sizeof( unsigned int ),  1, f1 ) ;\n    }\n    \n    fflush(f1);\n    \n    fclose(f1);\n    \n    return 0; \n}\n\n\n   Random\n\n", "explain": "It works on systems having /dev/urandom, like GNU/Linux.\narc4random() appeared in OpenBSD 2.1 and has spread to many BSD systems. This function runs an ARC4 random number generator that takes entropy from a kernel device. (This kernel device is sysctl kern.arandom in OpenBSD, or /dev/urandom in some other systems.)\nOpenSSL can generate random numbers. The default generator uses SHA1. For Unix systems, OpenSSL will gather entropy by reading a kernel device like /dev/urandom, or by using EGD, the Entropy Gathering Daemon. For other systems, OpenSSL might use a different source of entropy.\nJPD 2021/07/07\nOutput:\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "C++", "code": "\n\nWorks with: C++11\n#include <iostream>\n#include <random>\n \nint main()\n{\n    std::random_device rd;\n    std::uniform_int_distribution<long> dist; // long is guaranteed to be 32 bits\n    \n    std::cout << \"Random Number: \" << dist(rd) << std::endl;\n}\n\n", "explain": "std::random_device is a uniformly-distributed integer random number generator that produces non-deterministic random numbers.\nNote that std::random_device may be implemented in terms of a pseudo-random number engine if a non-deterministic source (e.g. a hardware device) is not available to the implementation. \nSee the C++ section on Random number generator (included) for the list of pseudo-random number engines available.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Java", "code": "\nimport java.security.SecureRandom;\n\npublic class RandomExample {\n  public static void main(String[] args) {\n    SecureRandom rng = new SecureRandom();\n\n    /* Prints a random signed 32-bit integer. */\n    System.out.println(rng.nextInt());\n  }\n}\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "C#", "code": "\nusing System;\nusing System.Security.Cryptography;\n\nprivate static int GetRandomInt()\n{\n  int result = 0;\n  var rng = new RNGCryptoServiceProvider();\n  var buffer = new byte[4];\n\n  rng.GetBytes(buffer);\n  result = BitConverter.ToInt32(buffer, 0);\n\n  return result;\n}\n\n\nconst long m = 2147483647L;\nconst long a = 48271L;\nconst long q = 44488L;\nconst long r = 3399L;\nstatic long r_seed = 12345678L;\n\npublic static byte gen()\n{\n   long hi = r_seed / q;\n   long lo = r_seed - q * hi;\n   long t = a * lo - r * hi;\n       if (t > 0)\n           r_seed = t;\n       else\n           r_seed = t + m;\n       return (byte)r_seed;\n}\n\npublic static void ParkMiller(byte[] arr)\n{\n   byte[] arr = new byte[10900000];\n    for (int i = 0; i < arr.Length; i++)\n                {                       \n                       arr[i] = gen();\n                }\n}\n\n", "explain": "Park-Miller random number generator\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Fortran", "code": "\n\n!-----------------------------------------------------------------------\n! Test Linux urandom in Fortran\n!-----------------------------------------------------------------------\nprogram    urandom_test\n  use iso_c_binding, only : c_long\n  implicit none\n\n  character(len=*), parameter :: RANDOM_PATH = \"/dev/urandom\"\n  integer :: funit, ios\n  integer(c_long) :: buf\n\n  open(newunit=funit, file=RANDOM_PATH, access=\"stream\", form=\"UNFORMATTED\", &\n       iostat=ios, status=\"old\", action=\"read\")\n  if ( ios /= 0 ) stop \"Error opening file: \"//RANDOM_PATH\n\n  read(funit) buf\n\n  close(funit)\n\n  write(*,'(A,I64)') \"Integer:     \", buf\n  write(*,'(A,B64)') \"Binary:      \", buf\n  write(*,'(A,Z64)') \"Hexadecimal: \", buf\n\nend program urandom_test\n\n\n", "explain": "Using system /dev/urandom in GNU/Linux.\nHere's an example of the use of the latter:\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"crypto/rand\"\n    \"encoding/binary\"\n    \"fmt\"\n    \"io\"\n    \"os\"\n)\n\nfunc main() {\n    testRandom(\"crypto/rand\", rand.Reader)\n    testRandom(\"dev/random\", newDevRandom())\n}\n\nfunc newDevRandom() (f *os.File) {\n    var err error\n    if f, err = os.Open(\"/dev/random\"); err != nil {\n        panic(err)\n    }\n    return\n}\n\nfunc testRandom(label string, src io.Reader) {\n    fmt.Printf(\"%s:\\n\", label)\n    var r int32\n    for i := 0; i < 10; i++ {\n        if err := binary.Read(src, binary.LittleEndian, &r); err != nil {\n            panic(err)\n        }\n        fmt.Print(r, \" \")\n    }\n    fmt.Println()\n}\n\n", "explain": "In the Go library is crypto/rand, a source specified to use dev/urandom on Unix-like systems and the CryptGenRandom API on Windows.  Also implemented here is a source using dev/random, if you really want it.  On my system it would print a few numbers then hang until I moved the mouse or pressed some keys on the keyboard.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program urandom.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ READ,   3\n.equ WRITE,  4\n.equ OPEN,   5\n.equ CLOSE,  6\n\n.equ O_RDONLY, 0                         @ open for reading only\n\n.equ BUFFERSIZE,          4              @ random number 32 bits\n\n/* Initialized data */\n.data\nszFileName:              .asciz \"/dev/urandom\"      @ see linux doc \nszCarriageReturn:        .asciz \"\\n\"\n/* datas error display */\nszMessErreur:        .asciz \"Error detected.\\n\"\nszMessErr:           .ascii \"Error code hexa\u00a0: \"\nsHexa:               .space 9,' '\n                     .ascii \"  decimal\u00a0:  \"\nsDeci:               .space 15,' '\n                     .asciz \"\\n\"\n/* datas message display */\nszMessResult:        .ascii \"Random number\u00a0:\"\nsValue:              .space 12,' '\n                     .asciz \"\\n\"\n/* UnInitialized data */\n.bss \nsBuffer:             .skip BUFFERSIZE             @ buffer result\n\n/*  code section */\n.text\n.global main \nmain: \n    ldr r0,iAdrszFileName               @ File name\n    mov r1,#O_RDONLY                    @  flags\n    mov r2,#0                           @ mode\n    mov r7,#OPEN                        @ open file\n    svc #0 \n    cmp r0,#0                           @ error\u00a0?\n    ble error\n    mov r8,r0                           @ save FD\n    mov r4,#0                           @ loop counter\n1:\n    mov r0,r8                           @ File Descriptor\n    ldr r1,iAdrsBuffer                  @ buffer address\n    mov r2,#BUFFERSIZE                  @ buffer size\n    mov r7,#READ                        @ call system read file\n    svc 0 \n    cmp r0,#0                           @ read error\u00a0?\n    ble error\n    ldr r1,iAdrsBuffer                  @ buffer address\n    ldr r0,[r1]                         @ display buffer value\n    ldr r1,iAdrsValue\n    bl conversion10\n    ldr r0,iAdrszMessResult\n    bl affichageMess\n    add r4,#1                           @ increment counter\n    cmp r4,#10                          @ maxi\u00a0?\n    blt 1b                              @ no -> loop\n\n\nend:\n    mov r0,r8\n    mov r7, #CLOSE                      @ call system close file\n    svc #0 \n    cmp r0,#0\n    blt error\n    mov r0,#0                           @ return code\n    b 100f\nerror:\n    ldr r1,iAdrszMessErreur             @ error message\n    bl   displayError\n    mov r0,#1                           @ return error code\n100:                                    @ standard end of the program\n    mov r7, #EXIT                       @ request to exit program\n    svc 0                               @ perform system call\niAdrsBuffer:               .int sBuffer\niAdrsValue:                .int sValue\niAdrszMessResult:          .int szMessResult\niAdrszFileName:            .int szFileName\niAdrszMessErreur:          .int szMessErreur\niAdrszCarriageReturn:      .int szCarriageReturn\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n/***************************************************/\n/*   display error message                         */\n/***************************************************/\n/* r0 contains error code  r1\u00a0: message address */\ndisplayError:\n    push {r0-r2,lr}                         @ save registers\n    mov r2,r0                               @ save error code\n    mov r0,r1\n    bl affichageMess\n    mov r0,r2                               @ error code\n    ldr r1,iAdrsHexa\n    bl conversion16                         @ conversion hexa\n    mov r0,r2                               @ error code\n    ldr r1,iAdrsDeci                        @ result address\n    bl conversion10S                        @ conversion decimale\n    ldr r0,iAdrszMessErr                    @ display error message\n    bl affichageMess\n100:\n    pop {r0-r2,lr}                          @ restaur registers\n    bx lr                                   @ return \niAdrszMessErr:                 .int szMessErr\niAdrsHexa:                     .int sHexa\niAdrsDeci:                     .int sDeci\n/******************************************************************/\n/*     Converting a register to hexadecimal                      */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\nconversion16:\n    push {r1-r4,lr}                          @ save registers\n    mov r2,#28                               @ start bit position\n    mov r4,#0xF0000000                       @ mask\n    mov r3,r0                                @ save entry value\n1:                                           @ start loop\n    and r0,r3,r4                             @ value register and mask\n    lsr r0,r2                                @ move right \n    cmp r0,#10                               @ compare value\n    addlt r0,#48                             @ <10  ->digit\n    addge r0,#55                             @ >10  ->letter A-F\n    strb r0,[r1],#1                          @ store digit on area and + 1 in area address\n    lsr r4,#4                                @ shift mask 4 positions\n    subs r2,#4                               @ counter bits - 4 <= zero \u00a0?\n    bge 1b                                   @ no -> loop\n\n100:\n    pop {r1-r4,lr}                                     @ restaur registers \n    bx lr     \n/***************************************************/\n/*  Converting a register to a signed decimal      */\n/***************************************************/\n/* r0 contains value and r1 area address    */\nconversion10S:\n    push {r0-r4,lr}       @ save registers\n    mov r2,r1             @ debut zone stockage\n    mov r3,#'+'           @ par defaut le signe est +\n    cmp r0,#0             @ negative number\u00a0? \n    movlt r3,#'-'         @ yes\n    mvnlt r0,r0           @ number inversion\n    addlt r0,#1\n    mov r4,#10            @ length area\n1:                        @ start loop\n    bl divisionpar10U\n    add r1,#48            @ digit\n    strb r1,[r2,r4]       @ store digit on area\n    sub r4,r4,#1          @ previous position\n    cmp r0,#0             @ stop if quotient = 0\n    bne 1b\t\n\n    strb r3,[r2,r4]       @ store signe \n    subs r4,r4,#1         @ previous position\n    blt  100f             @ if r4 < 0 -> end\n\n    mov r1,#' '           @ space\n2:\n    strb r1,[r2,r4]       @store byte space\n    subs r4,r4,#1         @ previous position\n    bge 2b                @ loop if r4 > 0\n100: \n    pop {r0-r4,lr}        @ restaur registers\n    bx lr  \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient    */\n/* r1 remainder   */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    //mov r3,#0xCCCD                                   @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                  @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "X86_Assembly", "code": "\n\nL: rdrand eax\njnc L\n\n", "explain": "Processors supporting the new RDRAND feature can generate a random 32-bit integer in two instructions:\nRDRAND reads the CPU's cryptographically-secure hardware random number generator. The loop is needed because RDRAND can occasionally fail to retrieve a value \u2014 it sets the carry flag to indicate whether it succeeded.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Delphi", "code": "\nWindows[edit]\nLibrary:  System.SysUtils\nLibrary:  Winapi.WinCrypt[[1]]\nprogram Random_number_generator;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  Winapi.WinCrypt;\n\nvar\n  hCryptProv: NativeUInt;\n  i: Byte;\n  UserName: PChar;\n\nfunction Random: UInt64;\nvar\n  pbData: array[0..7] of byte;\n  i: integer;\nbegin\n  if not CryptGenRandom(hCryptProv, 8, @pbData[0]) then\n    exit(0);\n  Result := 0;\n  for i := 0 to 7 do\n    Result := Result + (pbData[i] shl (8 * i));\nend;\n\nprocedure Randomize;\nbegin\n  CryptAcquireContext(hCryptProv, UserName, nil, PROV_RSA_FULL, 0);\nend;\n\nbegin\n  Randomize;\n  for i := 0 to 9 do\n    Writeln(Random);\n  Readln;\nend.\n\n\nOutput:\n6246170830\n2020144138\n5469928375\n5580575688\n3947181392\n4671237100\n4269461866\n4842880207\n4217687233\n1714028876\nLinux[edit]\n\n", "explain": "See #Pascal.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Ruby", "code": "\n\nrequire 'securerandom'\nSecureRandom.random_number(1 << 32)\n\n#or specifying SecureRandom as the desired RNG:\np (1..10).to_a.sample(3, random: SecureRandom) # =>[1, 4, 5]\n\n", "explain": "Ruby 1.8.7 introduces the 'securerandom' library. For MRI users, this library tries to get random numbers by loading OpenSSL, or opening /dev/urandom, or calling CryptGenRandom.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Rust", "code": "\n\nextern crate rand;\n\nuse rand::{OsRng, Rng};\n\nfn main() {\n    // because `OsRng` opens files, it may fail\n    let mut rng = match OsRng::new() {\n        Ok(v) => v,\n        Err(e) => panic!(\"Failed to obtain OS RNG: {}\", e)\n    };\n\n    let rand_num: u32 = rng.gen();\n    println!(\"{}\", rand_num);\n}\n\n", "explain": "rand used to be part of Rust standard library but it was extracted as a 'crate' (https://crates.io/crates/rand).  OsRng uses the appropriate device for many platforms including Unix, Windows, BSD, and iOS (listed here).  Other methods like RDRAND can be found in other crates (https://crates.io/crates/rdrand).\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Ada", "code": "\n\nwith Ada.Streams.Stream_IO;\nwith Ada.Text_IO;\nprocedure Random is\n   Number : Integer;\n   Random_File : Ada.Streams.Stream_IO.File_Type;\nbegin\n   Ada.Streams.Stream_IO.Open (File => Random_File,\n                               Mode => Ada.Streams.Stream_IO.In_File,\n                               Name => \"/dev/random\");\n   Integer'Read (Ada.Streams.Stream_IO.Stream (Random_File), Number);\n   Ada.Streams.Stream_IO.Close (Random_File);\n   Ada.Text_IO.Put_Line (\"Number:\" & Integer'Image (Number));\nend Random;\n\n", "explain": "random.adb:\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Julia", "code": "\nWorks with: Linux\nconst rdev = \"/dev/random\"\nrstream = try\n    open(rdev, \"r\")\ncatch\n    false\nend\n\nif isa(rstream, IOStream)\n    b = readbytes(rstream, 4)\n    close(rstream)\n    i = reinterpret(Int32, b)[1]\n    println(\"A hardware random number is:  \", i)\nelse\n    println(\"The hardware random number stream, \", rdev, \", was unavailable.\")\nend\n\n\nOutput:\nA hardware random number is:  986109744\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nimport java.security.SecureRandom\n\nfun main(args: Array<String>) {\n    val rng = SecureRandom()\n    val rn1 = rng.nextInt()\n    val rn2 = rng.nextInt()\n    val newSeed = rn1.toLong() * rn2\n    rng.setSeed(newSeed)    // reseed using the previous 2 random numbers\n    println(rng.nextInt())  // get random 32-bit number and print it\n}\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Perl", "code": "\n\nuse Crypt::Random::Seed;\nmy $source = Crypt::Random::Seed->new( NonBlocking => 1 ); # Allow non-blocking sources like /dev/urandom\nprint \"$_\\n\" for $source->random_values(10);               # A method returning an array of 32-bit values\n\n\nuse Crypt::Random::Source qw/get_weak/;    # Alternately get_strong\nprint unpack('L*',get_weak(4)), \"\\n\" for 1..10;\n\n\nsub read_random {\n        my $device = '/dev/urandom';\n        open my $in, \"<:raw\", $device   # :raw because it's not unicode string\n                or die \"Can't open $device: $!\";\n\n        sysread $in, my $rand, 4 * shift;\n        unpack('L*', $rand);\n}\n\nprint \"$_\\n\" for read_random(10);\n\n\n", "explain": "Typically one would use a module as they will work on UNIX, Win32, and other O/S's.  Crypt::Random::Seed, for instance, will use Win32 sources, EGD/PRNGD, /dev/u?random, or if none of those exist for some reason, a userspace entropy method.\nor (similar but many more dependencies):\nOr we can read values from /dev/urandom ourselves:\nWhether /dev/urandom is good enough for cryptographic work is debated, though on most UNIX systems it is at least as good as the Win32 Crypto API.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Scala", "code": "\nimport java.security.SecureRandom\n\nobject RandomExample extends App {\n  new SecureRandom {\n    val newSeed: Long = this.nextInt().toLong * this.nextInt()\n    this.setSeed(newSeed) // reseed using the previous 2 random numbers\n    println(this.nextInt()) // get random 32-bit number and print it\n  }\n}\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "D", "code": "\n\nimport std.stdio;\nimport std.random;\n\nvoid main()\n{\n  Mt19937 gen;\n  gen.seed(unpredictableSeed);\n  auto n = gen.front;\n  writeln(n);\n}\n\n\nOutput:\nrun 1: 3500391376\nrun 2: 9537841895\nrun 3: 1588499117\nrun 4: ...\n\n", "explain": "Example of MersenneTwisterEngine for generating uniformly-distributed 32-bit numbers with a period of 2 to the power of 19937.\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Haskell", "code": "\nLibrary: Entropy\nWorks with: GHC version 7.4.1\n#!/usr/bin/env runhaskell\n\nimport System.Entropy\nimport Data.Binary.Get\nimport qualified Data.ByteString.Lazy as B\n\nmain = do\n  bytes <- getEntropy 4\n  print (runGet getWord32be $ B.fromChunks [bytes])\n\n", "explain": ""}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "PowerShell", "code": "\nfunction Get-RandomInteger\n{\n    Param\n    (\n        [Parameter(Mandatory=$false,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true, \n                   Position=0)]\n        [ValidateScript({$_ -ge 4})]\n        [int[]]\n        $InputObject = 64\n    )\n\n    Begin\n    {\n        $rng = New-Object -TypeName System.Security.Cryptography.RNGCryptoServiceProvider\n    }\n    Process\n    {\n        foreach($count in $InputObject)\n        {\n            $bytes = New-Object -TypeName Byte[] -Argument $count\n            $rng.GetBytes($bytes)\n            [System.BitConverter]::ToInt32($bytes,0)\n        }\n    }\n    End \n    {\n        Remove-Variable -Name rng -Scope Local\n    }\n}\n\n4,8,16,32,64,128 | Get-RandomInteger | Format-Wide {$_} -Column 6 -Force\n\n\nOutput:\n1402572656             432337086              413089699             1404567509            -82797202             -261009960\n\n\n4,8,16,32,64,128 | Get-RandomInteger | Format-Wide {\"0x{0:X}\" -f $_} -Column 6 -Force\n\n\nOutput:\n0x24305255             0x916002DD             0x9587046             0x5F236274            0xC0BAF6F0            0xC0B93118\n\n", "explain": "As hexadecimal:\n"}, {"task_name": "Random number generator (device)", "task_url": "https://rosettacode.org/wiki/Random_number_generator_(device)", "task_cat": "Randomness", "lang": "Groovy", "code": "\n\ndef rng = new java.security.SecureRandom()\n\n\n(0..4).each { println rng.nextInt() }\n\n\nOutput:\n380425053\n-1003791794\n-1972330603\n1152610574\n714616658\n", "explain": "Based, necessarily, on Java solution:\nTest:\n"}]