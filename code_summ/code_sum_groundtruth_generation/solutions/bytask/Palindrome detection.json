[{"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\ndef is_palindrome(s):\n  return s == s[::-1]\n\ndef is_palindrome(s):\n  low = 0\n  high = len(s) - 1\n  while low < high:\n    if not s[low].isalpha():\n      low += 1\n    elif not s[high].isalpha():\n      high -= 1\n    else:\n      if s[low].lower()\u00a0!= s[high].lower():\n        return False\n      else:\n        low += 1\n        high -= 1\n        return True\n\ndef is_palindrome_r(s):\n  if len(s) <= 1:\n    return True\n  elif s[0]\u00a0!= s[-1]:\n    return False\n  else:\n    return is_palindrome_r(s[1:-1])\n\ndef is_palindrome_r2(s):\n  return not s or s[0] == s[-1] and is_palindrome_r2(s[1:-1])\n\ndef test(f, good, bad):\n  assert all(f(x) for x in good)\n  assert not any(f(x) for x in bad)\n  print '%s passed all %d tests'\u00a0% (f.__name__, len(good)+len(bad))\n\npals = ('', 'a', 'aa', 'aba', 'abba')\nnotpals = ('aA', 'abA', 'abxBa', 'abxxBa')\nfor ispal in is_palindrome, is_palindrome_r, is_palindrome_r2:\n  test(ispal, pals, notpals)\n\ndef p_loop():\n  import re, string\n  re1=\"\"       # Beginning of Regex\n  re2=\"\"       # End of Regex\n  pal=raw_input(\"Please Enter a word or phrase: \")\n  pd = pal.replace(' ','')\n  for c in string.punctuation:\n     pd = pd.replace(c,\"\")\n  if pal == \"\"\u00a0:\n    return -1\n  c=len(pd)   # Count of chars.\n  loops = (c+1)/2 \n  for x in range(loops):\n    re1 = re1 + \"(\\w)\"\n    if (c%2 == 1 and x == 0):\n       continue \n    p = loops - x\n    re2 = re2 + \"\\\\\" + str(p)\n  regex= re1+re2+\"$\"   # regex is like \"(\\w)(\\w)(\\w)\\2\\1$\"\n  #print(regex)  # To test regex before re.search\n  m = re.search(r'^'+regex,pd,re.IGNORECASE)\n  if (m):\n     print(\"\\n   \"+'\"'+pal+'\"')\n     print(\"   is a Palindrome\\n\")\n     return 1\n  else:\n     print(\"Nope!\")\n     return 0\n\n'''Palindrome detection'''\n\n\n# isPalindrome\u00a0:: String -> Bool\ndef isPalindrome(s):\n    '''True if the string is unchanged under reversal.\n       (The left half is a reflection of the right half)\n    '''\n    d, m = divmod(len(s), 2)\n    return s[0:d] == s[d + m:][::-1]\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Test'''\n\n    print('\\n'.join(\n        f'{repr(s)} -> {isPalindrome(cleaned(s))}' for s in [\n            \"\",\n            \"a\",\n            \"ab\",\n            \"aba\",\n            \"abba\",\n            \"In girum imus nocte et consumimur igni\"\n        ]\n    ))\n\n\n# cleaned\u00a0:: String -> String\ndef cleaned(s):\n    '''A lower-case copy of s, with spaces pruned.'''\n    return [c.lower() for c in s if ' '\u00a0!= c]\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\n'' -> True\n'a' -> True\n'ab' -> False\n'aba' -> True\n'abba' -> True\n'In girum imus nocte et consumimur igni' -> True\n\n   Twiddle Indexing v. Negative Indexing\n\n     0  1  2  3  4   <-- index\n   [ a, b, c, d, e ] \n    ~4 ~3 ~2 ~1 ~0   <-- twiddle index\n\n     0  1  2  3  4   <-- index\n   [ a, b, c, d, e ] \n    -5 -4 -3 -2 -1   <-- negative index\ndef palindromic(str):\n    for i in range(len(str)//2):\n        if str[i]\u00a0!= str[~i]:\n            return(False)\n    return(True)\n", "explain": "Now that Python 2.7 and Python 3.4 are quite different, We should include the version IMHO.\nNon-recursive\nThis one uses the reversing the string technique \n(to reverse a string Python can use the odd \nbut right syntax string[::-1])\nNon-recursive, Ignoring Punctuation/Case/Spaces\nA word is a palindrome if the letters are the same forwards as backwards, but the other methods given here will return False for, e.g., an input of \"Go hang a salami, I'm a lasagna hog\" or \"A man, a plan, a canal: Panama.\" An implementation that traverses the string and ignores case differences, spaces, and non-alpha characters is pretty trivial.\nRecursive\nPython has short-circuit evaluation of Boolean operations \nso a shorter and still easy to understand recursive function is\nTesting\n Palindrome Using Regular Expressions  Python 2.7 \n\nChecking the left half against a reflection of the right half\nTwiddle Indexing\nI have no idea what this technique is called, so I'm going with \"Twiddle Indexing\".\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <string.h>\n\nint palindrome(const char *s)\n{\n   int i,l;\n   l = strlen(s);\n   for(i=0; i<l/2; i++)\n   {\n     if ( s[i] != s[l-i-1] ) return 0; \n   }\n   return 1;\n}\n\n\nint palindrome(const char *s)\n{\n   const char *t; /* t is a pointer that traverses backwards from the end */\n   for (t = s; *t != '\\0'; t++) ; t--; /* set t to point to last character */\n   while (s < t)\n   {\n     if ( *s++ != *t-- ) return 0; \n   }\n   return 1;\n}\n\n\nint palindrome_r(const char *s, int b, int e)\n{\n   if ( (e - 1) <= b ) return 1;\n   if ( s[b] != s[e-1] ) return 0;\n   return palindrome_r(s, b+1, e-1);\n}\n\n\n#include <stdio.h>\n#include <string.h>\n/* testing */\nint main()\n{\n   const char *t = \"ingirumimusnocteetconsumimurigni\";\n   const char *template = \"sequence \\\"%s\\\" is%s palindrome\\n\";\n   int l = strlen(t);\n   \n   printf(template,\n          t, palindrome(t) ? \"\" : \"n't\");\n   printf(template,\n          t, palindrome_r(t, 0, l) ? \"\" : \"n't\");\n   return 0;\n}\n\n", "explain": "Non-recursive\nThis function compares the first char with the last, the second with the one previous the last, and\nso on. The first different pair it finds, return 0 (false); if all the pairs were equal, then return 1 (true).\nYou only need to go up to (the length) / 2 because the second half just re-checks the same stuff as the first half;\nand if the length is odd, the middle doesn't need to be checked (so it's okay to do integer division by 2, which rounds down).\nMore idiomatic version:\nRecursive\nA single char is surely a palindrome; a string is a palindrome if first and last char are the same and the remaining string (the string starting from the second char and ending to the char preceding the last one) is\nitself a palindrome.\nTesting\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(std::string const& s)\n{\n  return std::equal(s.begin(), s.end(), s.rbegin());\n}\n\n\n#include <string>\n#include <algorithm>\n\nbool is_palindrome(std::string const& s)\n{\n  return std::equal(s.begin(), s.begin()+s.length()/2, s.rbegin());\n}\n\n", "explain": "The C solutions also work in C++, but C++ allows a simpler one:\nOr, checking half is sufficient (on odd-length strings, this will ignore the middle element):\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npublic static boolean pali(String testMe){\n\tStringBuilder sb = new StringBuilder(testMe);\n\treturn testMe.equals(sb.reverse().toString());\n}\n\n\npublic static boolean isPalindrome(String input) {\n\tfor (int i = 0, j = input.length() - 1; i < j; i++, j--) {\n\t\tchar startChar = input.charAt(i);\n\t\tchar endChar = input.charAt(j);\n\n\t\t// Handle surrogate pairs in UTF-16\n\t\tif (Character.isLowSurrogate(endChar)) {\n\t\t\tif (startChar\u00a0!= input.charAt(--j)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tif (input.charAt(++i)\u00a0!= endChar) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t} else if (startChar\u00a0!= endChar) {\n\t\t\treturn false;\n\t\t}\n\t}\n\treturn true;\n}\n\npublic static boolean rPali(String testMe){\n\tif(testMe.length()<=1){\n\t\treturn true;\n\t}\n\tif(!(testMe.charAt(0)+\"\").equals(testMe.charAt(testMe.length()-1)+\"\")){\n\t\treturn false;\n\t}\n\treturn rPali(testMe.substring(1, testMe.length()-1));\n}\n\npublic static boolean rPali(String testMe){\n\tint strLen = testMe.length();\n\treturn rPaliHelp(testMe, strLen-1, strLen/2, 0);\n}\n\npublic static boolean rPaliHelp(String testMe, int strLen, int testLen, int index){\n\tif(index > testLen){\n\t\treturn true;\n\t}\n\tif(testMe.charAt(index)\u00a0!= testMe.charAt(strLen-index)){\n\t\treturn false;\n\t}\n\treturn rPaliHelp(testMe, strLen, testLen, index + 1);\n}\n\npublic static boolean pali(String testMe){\n\treturn testMe.matches(\"|(?:(.)(?<=(?=^.*?(\\\\1\\\\2?)$).*))+(?<=(?=^\\\\2$).*)\");\n}\n", "explain": "Non-Recursive\nNon-Recursive using indexes (supports upper-plane Unicode)\nRecursive  (this version does not work correctly with upper-plane Unicode)\nRecursive using indexes (this version does not work correctly with upper-plane Unicode)\nRegular Expression\n(source)\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nusing System;\n\nclass Program\n{\n    static string Reverse(string value)\n    {\n        char[] chars = value.ToCharArray();\n        Array.Reverse(chars);\n        return new string(chars);\n    }\n\n    static bool IsPalindrome(string value)\n    {\n        return value == Reverse(value);\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n    }\n}\n\n\nusing System;\nusing System.Linq;\n\nclass Program\n{\n\tstatic bool IsPalindrome(string text)\n\t{\n\t\treturn text == new String(text.Reverse().ToArray());\n\t}\n\n\tstatic void Main(string[] args)\n\t{\n\t\tConsole.WriteLine(IsPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n\t}\n}\n\n\nusing System;\n\nstatic class Program\n{\n    //As an extension method (must be declared in a static class)\n    static bool IsPalindrome(this string sentence)\n    {\n        for (int l = 0, r = sentence.Length - 1; l < r; l++, r--)\n            if (sentence[l] != sentence[r]) return false;\n        return true;\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(\"ingirumimusnocteetconsumimurigni\".IsPalindrome());\n    }\n}\n\n", "explain": "Non-recursive\nUsing LINQ operators\nNo string reversal\nReversing a string is very slow. A much faster way is to simply compare characters.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nfunction isPalindrome(str) {\n  return str === str.split(\"\").reverse().join(\"\");\n}\n\nconsole.log(isPalindrome(\"ingirumimusnocteetconsumimurigni\"));\n\nvar isPal = str => str === str.split(\"\").reverse().join(\"\");\n\n(() => {\n\n    // isPalindrome\u00a0:: String -> Bool\n    const isPalindrome = s => {\n        const cs = filter(c => ' '\u00a0!== c, s.toLocaleLowerCase());\n        return cs.join('') === reverse(cs).join('');\n    };\n\n\n    // TEST -----------------------------------------------\n    const main = () =>\n        isPalindrome(\n            'In girum imus nocte et consumimur igni'\n        )\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // filter\u00a0:: (a -> Bool) -> [a] -> [a]\n    const filter = (f, xs) => (\n        'string'\u00a0!== typeof xs\u00a0? (\n            xs\n        )\u00a0: xs.split('')\n    ).filter(f);\n\n    // reverse\u00a0:: [a] -> [a]\n    const reverse = xs =>\n        'string'\u00a0!== typeof xs\u00a0? (\n            xs.slice(0).reverse()\n        )\u00a0: xs.split('').reverse().join('');\n\n    // MAIN ---\n    return main();\n})();\n\nOutput:\ntrue\n", "explain": "\nES6 implementation\nOr, ignoring spaces and variations in case:\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: VBA\nModule Module1\n\n    Function IsPalindrome(p As String) As Boolean\n        Dim temp = p.ToLower().Replace(\" \", \"\")\n        Return StrReverse(temp) = temp\n    End Function\n\n    Sub Main()\n        Console.WriteLine(IsPalindrome(\"In girum imus nocte et consumimur igni\"))\n    End Sub\n\nEnd Module\n\nOutput:\nTrue\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "SQL", "code": "\nSET @txt = REPLACE('In girum imus nocte et consumimur igni', ' ', '');\nSELECT REVERSE(@txt) = @txt;\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n<?php\nfunction is_palindrome($string) {\n  return $string == strrev($string);\n}\n?>\n\n<?php\nfunction is_palindrome($string) {\n  return preg_match('/^(?:(.)(?=.*(\\1(?(2)\\2|))$))*.?\\2?$/', $string);\n}\n?>\n", "explain": "Regular expression-based solution (source)\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\nfunction trueFalse = isPalindrome(string)\n    \n    trueFalse = all(string == fliplr(string)); %See if flipping the string produces the original string\n\n    if not(trueFalse) %If not a palindrome\n        string = lower(string); %Lower case everything\n        trueFalse = all(string == fliplr(string)); %Test again\n    end\n    \n    if not(trueFalse) %If still not a palindrome\n        string(isspace(string)) = []; %Strip all space characters out\n        trueFalse = all(string == fliplr(string)); %Test one last time\n    end\n    \nend\n\nSample Usage:\n>> isPalindrome('In girum imus nocte et consumimur igni')\n\nans =\n\n     1\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram palindro\n\n  implicit none\n\n  character(len=*), parameter :: p = \"ingirumimusnocteetconsumimurigni\"\n  \n  print *, is_palindro_r(p)\n  print *, is_palindro_r(\"anothertest\")\n  print *, is_palindro2(p)\n  print *, is_palindro2(\"test\")\n  print *, is_palindro(p)\n  print *, is_palindro(\"last test\")\n\ncontains\n\n\n! non-recursive\nfunction is_palindro(t)\n  logical :: is_palindro\n  character(len=*), intent(in) :: t\n\n  integer :: i, l\n\n  l = len(t)\n  is_palindro = .false.\n  do i=1, l/2\n     if ( t(i:i) /= t(l-i+1:l-i+1) ) return\n  end do\n  is_palindro = .true.\nend function is_palindro\n\n! non-recursive 2\nfunction is_palindro2(t) result(isp)\n  logical :: isp\n  character(len=*), intent(in) :: t\n\n  character(len=len(t)) :: s\n  integer :: i\n\n  forall(i=1:len(t)) s(len(t)-i+1:len(t)-i+1) = t(i:i)\n  isp = ( s == t )\nend function is_palindro2\n\n\n  recursive function is_palindro_r (t) result (isp)\n\n    implicit none\n    character (*), intent (in) :: t\n    logical :: isp\n\n    isp = len (t) == 0 .or. t (: 1) == t (len (t) :) .and. is_palindro_r (t (2 : len (t) - 1))\n\n  end function is_palindro_r\n\nend program palindro\n\n", "explain": "Non-recursive\nRecursive\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage pal\n\nfunc IsPal(s string) bool {\n    mid := len(s) / 2\n    last := len(s) - 1\n    for i := 0; i < mid; i++ {\n        if s[i] != s[last-i] {\n            return false\n        }\n    }\n    return true\n}\n\n\nfunc isPalindrome(s string) bool {\n\trunes := []rune(s)\n\tnumRunes := len(runes) - 1\n\tfor i := 0; i < len(runes)/2; i++ {\n\t\tif runes[i] != runes[numRunes-i] {\n\t\t\treturn false\n\t\t}\n\t}\n\treturn true\n}\n\n\nfunc isPalindrome(s string) bool {\n\trunes := []rune(s)\n\tfor len(runes) > 1 {\n\t\tif runes[0] != runes[len(runes)-1] {\n\t\t\treturn false\n\t\t}\n\t\trunes = runes[1 : len(runes)-1]\n\t}\n\treturn true\n}\n\n", "explain": "This version works with Unicode,\nOr using more slicing,\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\n@ Check whether the ASCII string in [r0] is a palindrome\n@ Returns with zero flag set if palindrome.\npalin:\tmov\tr1,r0\t\t@ Find end of string\n1:\tldrb\tr2,[r1],#1\t@ Grab character and increment pointer\n\ttst\tr2,r2\t\t@ Zero yet?\n\tbne\t1b\t\t@ If not try next byte\n\tsub\tr1,r1,#2\t@ Move R1 to last actual character.\n2:\tcmp\tr0,r1\t\t@ When R0 >= R1,\n\tcmpgt\tr2,r2\t\t@ make sure zero is set,\n\tbxeq\tlr\t\t@ and stop (the string is a palindrome).\n\tldrb\tr2,[r1],#-1\t@ Grab [R1] (end) and decrement.\n\tldrb\tr3,[r0],#1\t@ Grab [R0] (begin) and increment\n\tcmp\tr2,r3\t\t@ Are they equal?\n\tbxne\tlr\t\t@ If not, it's not a palindrome.\n\tb\t2b\t\t@ Otherwise, try next pair.\n\t\n@ Try the function on a couple of strings\n.global _start\n_start:\tldr\tr8,=words\t@ Word pointer\n1:\tldr\tr9,[r8],#4\t@ Grab word and move pointer\n\ttst\tr9,r9\t\t@ Null?\n\tmoveq\tr7,#1\t\t@ Then we're done; syscall 1 = exit\n\tswieq\t#0\n\tmov\tr1,r9\t\t@ Print the word\n\tbl\tprint\t\t\n\tmov\tr0,r9\t\t@ Test if the word is a palindrome\n\tbl\tpalin\n\tldreq\tr1,=yes\t\t@ \"Yes\" if it is a palindrome\n\tldrne\tr1,=no\t\t@ \"No\" if it's not a palindrome\n\tbl\tprint\n\tb\t1b\t\t@ Next word \n\n@ Print zero-terminated string [r1] using Linux syscall\nprint:\tpush\t{r7,lr}\t\t@ Keep R7 and link register\n\tmov\tr2,r1\t\t@ Find end of string\n1:\tldrb\tr0,[r2],#1\t@ Grab character and increment pointer\n\ttst\tr0,r0\t\t@ Zero yet?\n\tbne\t1b\t\t@ If not, keep going\n\tsub\tr2,r2,r1\t@ Calculate length of string (bytes to write)\n\tmov\tr0,#1\t\t@ Stdout = 1\n\tmov\tr7,#4\t\t@ Syscall 4 = write\n\tswi\t#0\t\t@ Make the syscall\n\tpop\t{r7,lr}\t\t@ Restore R7 and link register\n\tbx\tlr\n\t\n@ Strings\nyes:\t.asciz\t\": yes\\n\"\t@ Output yes or no\nno:\t.asciz\t\": no\\n\"\nw1:\t.asciz\t\"rotor\"\t\t@ Words to test\nw2:\t.asciz\t\"racecar\"\nw3:\t.asciz\t\"level\"\nw4:\t.asciz\t\"redder\"\nw5:\t.asciz\t\"rosetta\"\nwords:\t.word\tw1,w2,w3,w4,w5,0\n\n\nOutput:\nrotor: yes\nracecar: yes\nlevel: yes\nredder: yes\nrosetta: no\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "X86_Assembly", "code": "\n; x86_84 Linux nasm\nsection .text\n\nisPalindrome:\n  mov rsi, rax\n  mov rdi, rax\n\n  get_end:\n    cmp byte [rsi], 0\n    je get_result\n    inc rsi\n    jmp get_end\n\n  get_result:\n    mov rax, 0\n    dec rsi\n\n    compare:\n      mov cl, byte [rdi]\n      cmp byte [rsi], cl\n      jne not_palindrome\n      cmp rsi, rdi\n      je palindrome\n      inc rdi\n      cmp rdi, rsi\n      je palindrome\n      dec rsi\n      jmp compare\n\n  not_palindrome:\n    mov rax, 0\n    ret\n  palindrome:\n    mov rax, 1\n    ret\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nuses\n  SysUtils, StrUtils;\n\nfunction IsPalindrome(const aSrcString: string): Boolean;\nbegin\n  Result := SameText(aSrcString, ReverseString(aSrcString));\nend;\n\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\ndef palindrome?(s)\n  s == s.reverse\nend\n\ndef r_palindrome?(s)\n  if s.length <= 1\n    true\n  elsif s[0]\u00a0!= s[-1]\n    false\n  else\n    r_palindrome?(s[1..-2])\n  end\nend\n\nstr = \"A man, a plan, a caret, [...2110 chars deleted...] a canal--Panama.\".downcase.delete('^a-z')\nputs palindrome?(str)    # => true\nputs r_palindrome?(str)  # => true\n\nrequire 'benchmark'\nBenchmark.bm do |b|\n  b.report('iterative') {10000.times {palindrome?(str)}}\n  b.report('recursive') {10000.times {r_palindrome?(str)}}\nend\n\nOutput:\ntrue\ntrue\n               user     system      total        real\niterative  0.062000   0.000000   0.062000 (  0.055000)\nrecursive 16.516000   0.000000  16.516000 ( 16.562000)\n", "explain": "Non-recursive\nRecursive\nTesting\nNote that the recursive method is much slower -- using the 2151 character palindrome by Dan Hoey here, we have:\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nfn is_palindrome(string: &str) -> bool {\n    let half_len = string.len() / 2;\n    string\n        .chars()\n        .take(half_len)\n        .eq(string.chars().rev().take(half_len))\n}\n\nmacro_rules! test {\n    ( $( $x:tt ),* ) => { $( println!(\"'{}': {}\", $x, is_palindrome($x)); )* };\n}\n\nfn main() {\n    test!(\n        \"\",\n        \"a\",\n        \"ada\",\n        \"adad\",\n        \"ingirumimusnocteetconsumimurigni\",\n        \"\u4eba\u4eba\u70ba\u6211,\u6211\u70ba\u4eba\u4eba\",\n        \"\u042f \u0438\u0434\u0443 \u0441 \u043c\u0435\u0447\u0435\u043c, \u0441\u0443\u0434\u0438\u044f\",\n        \"\uc544\ub4e4\ub538\ub4e4\uc544\",\n        \"The quick brown fox\"\n    );\n}\n\nOutput:\n'': true\n'a': true\n'ada': true\n'adad': false\n'ingirumimusnocteetconsumimurigni': true\n'\u4eba\u4eba\u70ba\u6211,\u6211\u70ba\u4eba\u4eba': true\n'\u042f \u0438\u0434\u0443 \u0441 \u043c\u0435\u0447\u0435\u043c, \u0441\u0443\u0434\u0438\u044f': false\n'\uc544\ub4e4\ub538\ub4e4\uc544': true\n'The quick brown fox': false\n\n\nextern crate unicode_segmentation;\nuse unicode_segmentation::UnicodeSegmentation;\nfn is_palindrome(string: &str) -> bool {\n    string.graphemes(true).eq(string.graphemes(true).rev())\n}\n", "explain": "The above soluion checks if the codepoints form a pallindrome, but it is perhaps more correct to consider if the graphemes form a pallindrome. This can be accomplished with an external library and a slight modification to is_palindrome.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nWorks with: Swift version 1.2\nimport Foundation\n\n// Allow for easy character checking\nextension String {\n    subscript (i: Int) -> String {\n        return String(Array(self)[i])\n    }\n}\n\nfunc isPalindrome(str:String) -> Bool {\n    if (count(str) == 0 || count(str) == 1) {\n        return true\n    }\n    let removeRange = Range<String.Index>(start: advance(str.startIndex, 1), end: advance(str.endIndex, -1))\n    if (str[0] == str[count(str) - 1]) {\n        return isPalindrome(str.substringWithRange(removeRange))\n    }\n    return false\n}\nWorks with: Swift version 2.0\nfunc isPal(str: String) -> Bool {\n  let c = str.characters\n  return lazy(c).reverse()\n    .startsWith(c[c.startIndex...advance(c.startIndex, c.count / 2)])\n}\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\npalindro <- function(p) {\n  if ( nchar(p) == 1 ) {\n    return(TRUE)\n  } else if ( nchar(p) == 2 ) {\n    return(substr(p,1,1) == substr(p,2,2))\n  } else {\n    if ( substr(p,1,1) == substr(p, nchar(p), nchar(p)) ) {\n      return(palindro(substr(p, 2, nchar(p)-1)))\n    } else {\n      return(FALSE)\n    }\n  }\n}\n\npalindroi <- function(p) {\n  for(i in 1:floor(nchar(p)/2) ) {\n    r <- nchar(p) - i + 1\n    if ( substr(p, i, i)\u00a0!= substr(p, r, r) ) return(FALSE) \n  }\n  TRUE\n}\n\nrevstring <- function(stringtorev) {\n   return(\n      paste(\n           strsplit(stringtorev,\"\")[[1]][nchar(stringtorev):1]\n           ,collapse=\"\")\n           )\n}\npalindroc <- function(p) {return(revstring(p)==p)}\n\nis.Palindrome <- function(string)\n{\n  characters <- unlist(strsplit(string, \"\"))\n  all(characters == rev(characters))\n}\n\nOutput:\n\ntest <- \"ingirumimusnocteetconsumimurigni\"\ntester <- paste(rep(test,38),collapse=\"\")\n> test <- \"ingirumimusnocteetconsumimurigni\"\n> tester <- paste(rep(test,38),collapse=\"\")\n> system.time(palindro(tester))\n   user  system elapsed \n   0.04    0.00    0.04 \n> system.time(palindroi(tester))\n   user  system elapsed \n   0.01    0.00    0.02 \n> system.time(palindroc(tester))\n   user  system elapsed \n      0       0       0 \n\n", "explain": "Recursive\nNote that the recursive method will fail if the string length is too long. \nR will assume an infinite recursion if a recursion nests deeper than 5,000.  \nOptions may be set in the environment to increase this to 500,000.\nIterative\nComparative\nThis method is somewhat faster than the other two.\nNote that this method incorrectly regards an empty string as not a palindrome. \nPlease leave this bug in the code, and take a look a the Testing_a_Function page.\nRev\nR has a built-in function for reversing vectors, so we only have to coerce our input in to the proper form.\nUnicode is supported, but this ignores the \"inexact palindromes\" extra credit requirement because, without some sort of regex, supporting Unicode while stripping punctuation and white space is hard in R.\nThe rev solution is not benchmarked.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\nWorks with: GnuCOBOL\n       identification division.\n       function-id. palindromic-test.\n\n       data division.\n       linkage section.\n       01 test-text            pic x any length.\n       01 result               pic x.\n          88 palindromic       value high-value\n                               when set to false low-value.\n\n       procedure division using test-text returning result.\n\n       set palindromic to false\n       if test-text equal function reverse(test-text) then\n           set palindromic to true\n       end-if\n\n       goback.\n       end function palindromic-test.\n\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nfunction Palindrome (Text : String) return Boolean is\nbegin\n   for Offset in 0..Text'Length / 2 - 1 loop\n      if Text (Text'First + Offset) /= Text (Text'Last - Offset) then\n         return False;\n      end if;\n   end loop;\n   return True;\nend Palindrome;\n\n\n\nfunction Palindrome (Text : String) return Boolean is\n(for all i in Text'Range => Text(i)= Text(Text'Last-i+Text'First));\n\n", "explain": "Ada 2012 version: \n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\npalindrome(s) = s == reverse(s)\n\nfunction palindrome(s)\n    len = length(s)\n    for i = 1:(len/2)\n        if(s[len-i+1]!=s[i])\n            return false\n        end\n    end\n    return true\nend\n\nfunction palindrome(s)\n    len = length(s)\n    if(len==0 || len==1)\n        return true\n    end\n    if(s[1] == s[len])\n        return palindrome(SubString(s,2,len-1))\n    end\n    return false\nend\n", "explain": " Non-Recursive \n Recursive \n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\n\nThe macro \"palindro\" has two parameters: string and ignorewhitespace.\n  string is the expression to be checked.\n  ignorewhitespace, (Y/N), determines whether or not to ignore blanks and punctuation.\nThis macro was written in SAS 9.2.  If you use a version before SAS 9.1.3, \nthe compress function options will not work.\n\n \n%MACRO palindro(string, ignorewhitespace);\n  DATA _NULL_;\n    %IF %UPCASE(&ignorewhitespace)=Y %THEN %DO;\n/* The arguments of COMPRESS (sp) ignore blanks and puncutation */\n/* We take the string and record it in reverse order using the REVERSE function. */\n      %LET rev=%SYSFUNC(REVERSE(%SYSFUNC(COMPRESS(&string,,sp)))); \n      %LET string=%SYSFUNC(COMPRESS(&string.,,sp));\n    %END;\n\n    %ELSE %DO;\n      %LET rev=%SYSFUNC(REVERSE(&string));\n    %END;\n    /*%PUT rev=&rev.;*/\n    /*%PUT string=&string.;*/\n\n/* Here we determine if the string and its reverse are the same. */\n    %IF %UPCASE(&string)=%UPCASE(&rev.) %THEN %DO;\n      %PUT TRUE;\n    %END;\n    %ELSE %DO;\n      %PUT FALSE; \n    %END;\n  RUN;\n%MEND;\n\n%palindro(\"a man, a plan, a canal: panama\",y);\n\nTRUE\n\nNOTE: DATA statement used (Total process time):\n      real time           0.00 seconds\n      cpu time            0.00 seconds\n\n%palindro(\"a man, a plan, a canal: panama\",n);\n\nFALSE\n\nNOTE: DATA statement used (Total process time):\n      real time           0.00 seconds\n      cpu time            0.00 seconds\n", "explain": "Description\nCode\nExample macro call and output\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.1.2\n\n/* These functions deal automatically with Unicode as all strings are UTF-16 encoded in Kotlin */\n\nfun isExactPalindrome(s: String) = (s == s.reversed())\n\nfun isInexactPalindrome(s: String): Boolean {\n    var t = \"\"\n    for (c in s) if (c.isLetterOrDigit()) t += c\n    t = t.toLowerCase()\n    return t == t.reversed()\n}\n\nfun main(args: Array<String>) {\n    val candidates = arrayOf(\"rotor\", \"rosetta\", \"step on no pets\", \"\u00e9t\u00e9\")\n    for (candidate in candidates) {\n        println(\"'$candidate' is ${if (isExactPalindrome(candidate)) \"an\" else \"not an\"} exact palindrome\")\n    }\n    println()\n    val candidates2 = arrayOf(\n         \"In girum imus nocte et consumimur igni\",\n         \"Rise to vote, sir\",\n         \"A man, a plan, a canal - Panama!\",\n         \"Ce rep\u00e8re, Perec\"  // note: '\u00e8' considered a distinct character from 'e'\n    )\n    for (candidate in candidates2) {\n        println(\"'$candidate' is ${if (isInexactPalindrome(candidate)) \"an\" else \"not an\"} inexact palindrome\")\n    }\n}\n\nOutput:\n'rotor' is an exact palindrome\n'rosetta' is not an exact palindrome\n'step on no pets' is an exact palindrome\n'\u00e9t\u00e9' is an exact palindrome\n\n'In girum imus nocte et consumimur igni' is an inexact palindrome\n'Rise to vote, sir' is an inexact palindrome\n'A man, a plan, a canal - Panama!' is an inexact palindrome\n'Ce rep\u00e8re, Perec' is not an inexact palindrome\n\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\npalindrome uses the built-in function reverse().\npalindrome_c uses iteration; it is a translation of the C solution.\npalindrome_r uses recursion.\npalindrome_e uses a recursive regular expression.\n\n# Palindrome.pm\npackage Palindrome;\n\nuse strict;\nuse warnings;\n\nuse Exporter 'import';\nour @EXPORT = qw(palindrome palindrome_c palindrome_r palindrome_e);\n\nsub palindrome\n{\n    my $s = (@_\u00a0? shift\u00a0: $_);\n    return $s eq reverse $s;\n}\n\nsub palindrome_c\n{\n    my $s = (@_\u00a0? shift\u00a0: $_);\n    for my $i (0 .. length($s) >> 1)\n    {\n        return 0 unless substr($s, $i, 1) eq substr($s, -1 - $i, 1);\n    }\n    return 1;\n}\n\nsub palindrome_r\n{\n    my $s = (@_\u00a0? shift\u00a0: $_);\n    if (length $s <= 1) { return 1; }\n    elsif (substr($s, 0, 1) ne substr($s, -1, 1)) { return 0; }\n    else { return palindrome_r(substr($s, 1, -1)); }\n}\n\nsub palindrome_e\n{\n    (@_\u00a0? shift\u00a0: $_) =~ /^(.?|(.)(?1)\\2)$/ + 0\n}\n\n# pbench.pl\nuse strict;\nuse warnings;\n\nuse Benchmark qw(cmpthese);\nuse Palindrome;\n\nprintf(\"%d, %d, %d, %d: %s\\n\",\n       palindrome, palindrome_c, palindrome_r, palindrome_e, $_)\nfor\n    qw/a aa ab abba aBbA abca abba1 1abba\n    ingirumimusnocteetconsumimurigni/,\n    'ab cc ba',\t'ab ccb a';\n\nprintf \"\\n\";\n\nmy $latin = \"ingirumimusnocteetconsumimurigni\";\ncmpthese(100_000, {\n    palindrome => sub { palindrome $latin },\n    palindrome_c => sub { palindrome_c $latin },\n    palindrome_r => sub { palindrome_r $latin },\n    palindrome_e => sub { palindrome_e $latin },\n});\n\nOutput: on a machine running Perl 5.10.1 on amd64-openbsd\n\n$ perl pbench.pl\n1, 1, 1, 1: a\n1, 1, 1, 1: aa\n0, 0, 0, 0: ab\n1, 1, 1, 1: abba\n0, 0, 0, 0: aBbA\n0, 0, 0, 0: abca\n0, 0, 0, 0: abba1\n0, 0, 0, 0: 1abba\n1, 1, 1, 1: ingirumimusnocteetconsumimurigni\n1, 1, 1, 1: ab cc ba\n0, 0, 0, 0: ab ccb a\n\n            (warning: too few iterations for a reliable count)\n                  Rate palindrome_r palindrome_e palindrome_c   palindrome\npalindrome_r   51020/s           --         -50%         -70%         -97%\npalindrome_e  102041/s         100%           --         -41%         -94%\npalindrome_c  172414/s         238%          69%           --         -90%\npalindrome   1666667/s        3167%        1533%         867%           --\n\n", "explain": "There is more than one way to do this.\nAll of these functions take a parameter, \nor default to $_ if there is no parameter. \nNone of these functions ignore case or strip characters; \nif you want do that, you can use ($s = lc $s) =~ s/[\\W_]//g \nbefore you call these functions.\nThis example shows how to use the functions:\nWith this machine, palindrome() ran far faster than the alternatives \n(and too fast for a reliable count). \nThe Perl regular expression engine recursed twice as fast as the Perl interpreter.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\npalindrome(Word)\u00a0:- name(Word,List), reverse(List,List).\n\nWorks with: SWI Prolog\npali(Str)\u00a0:- sub_string(Str, 0, 1, _, X), string_concat(Str2, X, Str), string_concat(X, Mid, Str2), pali(Mid).\npali(Str)\u00a0:- string_length(Str, Len), Len < 2.\n\nWorks with: GNU Prolog\npali(Str)\u00a0:- sub_atom(Str, 0, 1, _, X), atom_concat(Str2, X, Str), atom_concat(X, Mid, Str2), pali(Mid).\npali(Str)\u00a0:- atom_length(Str, Len), Len < 2.\n", "explain": "Non-recursive\nFrom this tutorial.\nRecursive\nChanging string into atom makes the program run also on GNU Prolog. I.e.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction ispalindrome(s) return s == string.reverse(s) end\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nLibrary: Scala\nNon-recursive, robustified[edit]\n  def isPalindrome(s: String): Boolean = (s.size >= 2) && s == s.reverse\nBonus: Detect and account for odd space and punctuation[edit]\n  def isPalindromeSentence(s: String): Boolean =\n    (s.size >= 2) && {\n      val p = s.replaceAll(\"[^\\\\p{L}]\", \"\").toLowerCase\n      p == p.reverse\n    }\nRecursive[edit]\nimport scala.annotation.tailrec\n\n  def isPalindromeRec(s: String) = {\n    @tailrec\n    def inner(s: String): Boolean =\n      (s.length <= 1) || (s.head == s.last) && inner(s.tail.init)\n\n    (s.size >= 2) && inner(s)\n  }\n\n  // Testing\n  assert(!isPalindrome(\"\"))\n  assert(!isPalindrome(\"z\"))\n  assert(isPalindrome(\"amanaplanacanalpanama\"))\n  assert(!isPalindrome(\"Test 1,2,3\"))\n  assert(isPalindrome(\"1 2 1\"))\n  assert(!isPalindrome(\"A man a plan a canal Panama.\"))\n\n  assert(!isPalindromeSentence(\"\"))\n  assert(!isPalindromeSentence(\"z\"))\n  assert(isPalindromeSentence(\"amanaplanacanalpanama\"))\n  assert(!isPalindromeSentence(\"Test 1,2,3\"))\n  assert(isPalindromeSentence(\"1 2 1\"))\n  assert(isPalindromeSentence(\"A man a plan a canal Panama.\"))\n\n  assert(!isPalindromeRec(\"\"))\n  assert(!isPalindromeRec(\"z\"))\n  assert(isPalindromeRec(\"amanaplanacanalpanama\"))\n  assert(!isPalindromeRec(\"Test 1,2,3\"))\n  assert(isPalindromeRec(\"1 2 1\"))\n  assert(!isPalindromeRec(\"A man a plan a canal Panama.\"))\n\n  println(\"Successfully completed without errors.\")\n", "explain": "Testing\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nbool isPalindrome(String s){  \n  for(int i = 0; i < s.length/2;i++){\n    if(s[i]\u00a0!= s[(s.length-1) -i])\n      return false;        \n  }  \n  return true;  \n}\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nHigh-level 32-bit Unicode Version[edit]\nimport std.traits, std.algorithm;\n\nbool isPalindrome1(C)(in C[] s) pure /*nothrow*/\nif (isSomeChar!C) {\n    auto s2 = s.dup;\n    s2.reverse(); // works on Unicode too, not nothrow.\n    return s == s2;\n}\n\nvoid main() {\n    alias pali = isPalindrome1;\n    assert(pali(\"\"));\n    assert(pali(\"z\"));\n    assert(pali(\"aha\"));\n    assert(pali(\"sees\"));\n    assert(!pali(\"oofoe\"));\n    assert(pali(\"deified\"));\n    assert(!pali(\"Deified\"));\n    assert(pali(\"amanaplanacanalpanama\"));\n    assert(pali(\"ingirumimusnocteetconsumimurigni\"));\n    assert(pali(\"sal\u00c3\u00a0las\"));\n}\n\nMid-level 32-bit Unicode Version[edit]\nimport std.traits;\n\nbool isPalindrome2(C)(in C[] s) pure if (isSomeChar!C) {\n    dchar[] dstr;\n    foreach (dchar c; s) // not nothrow\n        dstr ~= c;\n\n    for (int i; i < dstr.length / 2; i++)\n        if (dstr[i] != dstr[$ - i - 1])\n            return false;\n    return true;\n}\n\nvoid main() {\n    alias isPalindrome2 pali;\n    assert(pali(\"\"));\n    assert(pali(\"z\"));\n    assert(pali(\"aha\"));\n    assert(pali(\"sees\"));\n    assert(!pali(\"oofoe\"));\n    assert(pali(\"deified\"));\n    assert(!pali(\"Deified\"));\n    assert(pali(\"amanaplanacanalpanama\"));\n    assert(pali(\"ingirumimusnocteetconsumimurigni\"));\n    assert(pali(\"sal\u00c3\u00a0las\"));\n}\n\nLow-level 32-bit Unicode Version[edit]\nimport std.stdio, core.exception, std.traits;\n\n// assume alloca() to be pure for this program\nextern(C) pure nothrow void* alloca(in size_t size);\n\nbool isPalindrome3(C)(in C[] s) pure if (isSomeChar!C) {\n    auto p = cast(dchar*)alloca(s.length * 4);\n    if (p == null)\n        // no fallback heap allocation used\n        throw new OutOfMemoryError();\n    dchar[] dstr = p[0 .. s.length];\n\n    // use std.utf.stride for an even lower level version\n    int i = 0;\n    foreach (dchar c; s) { // not nothrow\n        dstr[i] = c;\n        i++;\n    }\n    dstr = dstr[0 .. i];\n\n    foreach (j; 0 .. dstr.length / 2)\n        if (dstr[j] != dstr[$ - j - 1])\n            return false;\n    return true;\n}\n\nvoid main() {\n    alias isPalindrome3 pali;\n    assert(pali(\"\"));\n    assert(pali(\"z\"));\n    assert(pali(\"aha\"));\n    assert(pali(\"sees\"));\n    assert(!pali(\"oofoe\"));\n    assert(pali(\"deified\"));\n    assert(!pali(\"Deified\"));\n    assert(pali(\"amanaplanacanalpanama\"));\n    assert(pali(\"ingirumimusnocteetconsumimurigni\"));\n    assert(pali(\"sal\u00c3\u00a0las\"));\n}\n\nLow-level ASCII Version[edit]\nbool isPalindrome4(in string str) pure nothrow {\n    if (str.length == 0) return true;\n    immutable(char)* s = str.ptr;\n    immutable(char)* t = &(str[$ - 1]);\n    while (s < t)\n        if (*s++ != *t--) // ugly\n            return false;\n    return true;\n}\n\nvoid main() {\n    alias isPalindrome4 pali;\n    assert(pali(\"\"));\n    assert(pali(\"z\"));\n    assert(pali(\"aha\"));\n    assert(pali(\"sees\"));\n    assert(!pali(\"oofoe\"));\n    assert(pali(\"deified\"));\n    assert(!pali(\"Deified\"));\n    assert(pali(\"amanaplanacanalpanama\"));\n    assert(pali(\"ingirumimusnocteetconsumimurigni\"));\n    //assert(pali(\"sal\u00c3\u00a0las\"));\n}\n\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nis_palindrome x = x == reverse x\n\n\nimport Data.Bifunctor (second)\nimport Data.Char (toLower)\n\n------------------- PALINDROME DETECTION -----------------\n\nisPalindrome :: Eq a => [a] -> Bool\nisPalindrome = (==) <*> reverse\n\n-- Or, comparing just the leftward characters with\n-- with a reflection of just the rightward characters.\n\nisPal :: String -> Bool\nisPal s =\n  let (q, r) = quotRem (length s) 2\n   in uncurry (==) $\n        second (reverse . drop r) $ splitAt q s\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n    (showResult <$> [isPalindrome, isPal])\n      <*> fmap\n        prepared\n        [ \"\",\n          \"a\",\n          \"ab\",\n          \"aba\",\n          \"abba\",\n          \"In girum imus nocte et consumimur igni\"\n        ]\n\nprepared :: String -> String\nprepared cs = [toLower c | c <- cs, ' ' /= c]\n\nshowResult f s = (show s) <> \" -> \" <> show (f s)\n\n\nOutput:\n\"\" -> True\n\"a\" -> True\n\"ab\" -> False\n\"aba\" -> True\n\"abba\" -> True\n\"ingirumimusnocteetconsumimurigni\" -> True\n\"\" -> True\n\"a\" -> True\n\"ab\" -> False\n\"aba\" -> True\n\"abba\" -> True\n\"ingirumimusnocteetconsumimurigni\" -> True\n\nis_palindrome_r x | length x <= 1 = True\n                  | head x == last x = is_palindrome_r . tail. init $ x\n                  | otherwise = False\n\n", "explain": "Non-recursive\nA string is a palindrome if reversing it we obtain the same string.\nOr, applicative and point-free, with some pre-processing of data (shedding white space and upper case):\n\nRecursive\nSee the C palindrome_r code for an explanation of the concept used in this solution, \nthough it may be better suited to indexed arrays than to linked lists.\n(last is expensive, and entails multiplied recursions over the right hand side\nof the remaining list here).\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\nImplementation[edit]\nfunction Squish( s1 )\n\tdim sRes\n\tsRes = vbNullString\n\tdim i, c\n\tfor i = 1 to len( s1 )\n\t\tc = lcase( mid( s1, i, 1 ))\n\t\tif instr( \"abcdefghijklmnopqrstuvwxyz0123456789\", c ) then\n\t\t\tsRes = sRes & c\n\t\tend if\n\tnext\n\tSquish = sRes\nend function\n\t\t\nfunction isPalindrome( s1 )\n\tdim squished\n\tsquished = Squish( s1 )\n\tisPalindrome = ( squished = StrReverse( squished ) )\nend function\nInvocation[edit]\nwscript.echo isPalindrome( \"My dog has fleas\")\nwscript.echo isPalindrome( \"Madam, I'm Adam.\")\nwscript.echo isPalindrome( \"1 on 1\")\nwscript.echo isPalindrome( \"In girum imus nocte et consumimur igni\")\n\nOutput:\n0\n-1\n0\n-1\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n(define (palindrome? s)\n  (let ((chars (string->list s)))\n    (equal? chars (reverse chars))))\n\n(define (palindrome? s)\n  (let loop ((i 0)\n             (j (- (string-length s) 1)))\n    (or (>= i j)\n        (and (char=? (string-ref s i) (string-ref s j))\n             (loop (+ i 1) (- j 1))))))\n\n;; Or:\n(define (palindrome? s)\n  (let loop ((s (string->list s))\n             (r (reverse (string->list s))))\n    (or (null? s)\n        (and (char=? (car s) (car r))\n             (loop (cdr s) (cdr r))))))\n\n> (palindrome? \"ingirumimusnocteetconsumimurigni\")\n#t\n> (palindrome? \"This is not a palindrome\")\n#f\n>\n", "explain": "Non-recursive\nRecursive\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "TypeScript", "code": "\nconst detectNonLetterRegexp=/[^A-Z\u00c0-\u00de\u0400-\u042f]/g;\n\nfunction stripDiacritics(phrase:string){\n    return phrase.normalize('NFD').replace(/[\\u0300-\\u036f]/g, \"\")\n}\n\nfunction isPalindrome(phrase:string){\n    const TheLetters = stripDiacritics(phrase.toLocaleUpperCase().replace(detectNonLetterRegexp, ''));\n    const middlePosition = TheLetters.length/2;\n    const leftHalf = TheLetters.substr(0, middlePosition);\n    const rightReverseHalf = TheLetters.substr(-middlePosition).split('').reverse().join('');\n    return leftHalf == rightReverseHalf;\n}\n\nconsole.log(isPalindrome('Sue\u00f1o que esto no es un pal\u00edndromo'))\nconsole.log(isPalindrome('D\u00e1bale arroz a la zorra el abad!'))\nconsole.log(isPalindrome('\u042f \u0438\u0434\u0443 \u0441 \u043c\u0435\u0447\u0435\u043c \u0441\u0443\u0434\u0438\u044f'))\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\n\nFunction Test-Palindrome( [String] $Text ){\n    $CharArray = $Text.ToCharArray()\n    [Array]::Reverse($CharArray)\n    $Text -eq [string]::join('', $CharArray)\n}\nPowerShell (Regex Version)[edit]\n\nfunction Test-Palindrome\n{\n  <#\n    .SYNOPSIS\n        Tests if a string is a palindrome.\n    .DESCRIPTION\n        Tests if a string is a true palindrome or, optionally, an inexact palindrome.\n    .EXAMPLE\n        Test-Palindrome -Text \"racecar\"\n    .EXAMPLE\n        Test-Palindrome -Text '\"Deliver desserts,\" demanded Nemesis, \"emended, named, stressed, reviled.\"' -Inexact\n  #>\n    [CmdletBinding()]\n    [OutputType([bool])]\n    Param\n    (\n        # The string to test for palindrominity.\n        [Parameter(Mandatory=$true)]\n        [string]\n        $Text,\n\n        # When specified, detects an inexact palindrome.\n        [switch]\n        $Inexact\n    )\n\n    if ($Inexact)\n    {\n        # Strip all punctuation and spaces\n        $Text = [Regex]::Replace(\"$Text($7&\",\"[^1-9a-zA-Z]\",\"\")\n    }\n\n    $Text -match \"^(?'char'[a-z])+[a-z]?(?:\\k'char'(?'-char'))+(?(char)(?!))$\"\n}\nTest-Palindrome -Text 'radar'\n\nOutput:\nTrue\n\nTest-Palindrome -Text \"In girum imus nocte et consumimur igni.\"\n\nOutput:\nFalse\n\nTest-Palindrome -Text \"In girum imus nocte et consumimur igni.\" -Inexact\n\nOutput:\nTrue\n\nPowerShell (Unicode category aware, no string reverse)[edit]\n\nFunction Test-Palindrome {\n[CmdletBinding()]\nParam(\n    [Parameter(ValueFromPipeline)]\n    [string[]]$Text\n)\n\nprocess {\n    :stringLoop foreach ($T in $Text)\n    {\n        # Normalize Unicode combining characters,\n        # so character \u00e1 compares the same as (a+combining accent)\n        $T = $T.Normalize([Text.NormalizationForm]::FormC)\n        \n        # Remove anything from outside the Unicode category\n        # \"Letter from any language\"\n        $T = $T -replace '\\P{L}', ''\n\n        # Walk from each end of the string inwards, \n        # comparing a char at a time.\n        # Avoids string copy / reverse overheads.\n        $Left, $Right = 0, [math]::Max(0, ($T.Length - 1))\n        while ($Left -lt $Right)\n        {\n            if ($T[$Left] -ne $T[$Right])\n            {\n                # return early if string is not a palindrome\n                [PSCustomObject]@{\n                    Text = $T\n                    IsPalindrome = $False\n                }\n                continue stringLoop\n            }\n            else\n            {\n                $Left++\n                $Right--\n            }\n        }\n\n        # made it to here, then string is a palindrome\n        [PSCustomObject]@{\n            Text = $T\n            IsPalindrome = $True\n        }\n                \n    }\n}\n}\n'\u00e1nu-n\u00e1', 'nowt' | Test-Palindrome\n\nOutput:\nPS C:\\> '\u00e1nu-n\u00e1', 'nowt' | Test-Palindrome\n\nText  IsPalindrome\n----  ------------\n\u00e1nun\u00e1         True\nnow          False\n\n", "explain": "An exact version based on reversing the string:\nThis version is much faster because it does not manipulate arrays. [This is not clear; the above version was slowed down by using -join instead of [string]::join, and -like instead of -eq. After changing those it is similar, if not faster, than this version].\nAn inexact version can remove punctuation by looking at Unicode categories for each character, either using .Net methods or a regex.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto palindrome? :w\n  output equal? :w reverse :w\nend\n", "explain": ""}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nlet isPalindrome (s: string) =\n   let arr = s.ToCharArray()\n   arr = Array.rev arr\n\n\nisPalindrome \"abcba\"\nval it : bool = true\nisPalindrome (\"In girum imus nocte et consumimur igni\".Replace(\" \", \"\").ToLower());;\nval it : bool = true\nisPalindrome \"abcdef\"\nval it : bool = false\n\n", "explain": "Examples:\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\nTrivial[edit]\n\ndef isPalindrome = { String s ->\n    s == s?.reverse()\n}\n\n\nprintln isPalindrome(\"\")\nprintln isPalindrome(\"a\")\nprintln isPalindrome(\"abcdefgfedcba\")\nprintln isPalindrome(\"abcdeffedcba\")\nprintln isPalindrome(\"abcedfgfedcb\")\n\n\nOutput:\ntrue\ntrue\ntrue\ntrue\nfalse\n\nNon-recursive[edit]\n\ndef isPalindrome = { String s ->\n    def n = s.size()\n    n < 2 || s[0..<n/2] == s[-1..(-n/2)]\n}\n\n\nRecursive[edit]\n\ndef isPalindrome\nisPalindrome = { String s ->\n    def n = s.size()\n    n < 2 || (s[0] == s[n-1] && isPalindrome(s[1..<(n-1)]))\n}\n\n\n", "explain": "Solution:\nTest program:\nThis solution assumes nulls are palindromes.\nSolution:\nTest program and output are the same. \nThis solution does not handle nulls.\nSolution follows the C palindrome_r recursive solution:\nTest program and output are the same. \nThis solution does not handle nulls.\n"}, {"task_name": "Palindrome detection", "task_url": "https://rosettacode.org/wiki/Palindrome_detection", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\nfunction is_palindro(s)\n{\n  if ( s == reverse(s) ) return 1\n  return 0\n}\n\n\nfunction is_palindro_r(s)\n{\n  if ( length(s) < 2 ) return 1\n  if ( substr(s, 1, 1) != substr(s, length(s), 1) ) return 0\n  return is_palindro_r(substr(s, 2, length(s)-2))\n}\n\n\nBEGIN {\n  pal = \"ingirumimusnocteetconsumimurigni\"\n  print is_palindro(pal)\n  print is_palindro_r(pal)\n}\n\n", "explain": "Non-recursive\nSee Reversing a string.\nRecursive\nTesting\n"}]