[{"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Python", "code": "\nWorks with: Python version 2.6+Works with: Python version 3.0+\n>>> import json\n>>> data = json.loads('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> sample = { \"blue\": [1,2], \"ocean\": \"water\" }\n>>> json_string = json.dumps(sample)\n>>> json_string\n'{\"blue\": [1, 2], \"ocean\": \"water\"}'\n>>> sample\n{'blue': [1, 2], 'ocean': 'water'}\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n\n\n>>> true = True; false = False; null = None\n>>> data = eval('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\n>>> data\n{'foo': 1, 'bar': [10, 'apples']}\n\n", "explain": "Because most of JSON is valid Python syntax (except \"true\", \"false\", and \"null\", and a few obscure escape sequences), it is also possible (but not recommended) to parse JSON using eval():\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "C", "code": "\nLibrary: YAJL\nWorks with: YAJL version 2\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <yajl/yajl_tree.h>\n#include <yajl/yajl_gen.h>\n\nstatic void print_callback (void *ctx, const char *str, size_t len)\n{\n  FILE *f = (FILE *) ctx;\n  fwrite (str, 1, len, f);\n}\n\nstatic void check_status (yajl_gen_status status)\n{\n  if (status != yajl_gen_status_ok)\n    {\n      fprintf (stderr, \"yajl_gen_status was %d\\n\", (int) status);\n      exit (EXIT_FAILURE);\n    }\n}\n\nstatic void serialize_value (yajl_gen gen, yajl_val val, int parse_numbers)\n{\n  size_t i;\n\n  switch (val->type)\n    {\n    case yajl_t_string:\n      check_status (yajl_gen_string (gen,\n                                     (const unsigned char *) val->u.string,\n                                     strlen (val->u.string)));\n      break;\n    case yajl_t_number:\n      if (parse_numbers  &&  YAJL_IS_INTEGER (val))\n        check_status (yajl_gen_integer (gen, YAJL_GET_INTEGER (val)));\n      else if (parse_numbers  &&  YAJL_IS_DOUBLE (val))\n        check_status (yajl_gen_double (gen, YAJL_GET_DOUBLE (val)));\n      else\n        check_status (yajl_gen_number (gen, YAJL_GET_NUMBER (val),\n                                       strlen (YAJL_GET_NUMBER (val))));\n      break;\n    case yajl_t_object:\n      check_status (yajl_gen_map_open (gen));\n      for (i = 0  ;  i < val->u.object.len  ;  i++)\n        {\n          check_status (yajl_gen_string (gen,\n                                         (const unsigned char *) val->u.object.keys[i],\n                                         strlen (val->u.object.keys[i])));\n          serialize_value (gen, val->u.object.values[i], parse_numbers);\n        }\n      check_status (yajl_gen_map_close (gen));\n      break;\n    case yajl_t_array:\n      check_status (yajl_gen_array_open (gen));\n      for (i = 0  ;  i < val->u.array.len  ;  i++)\n        serialize_value (gen, val->u.array.values[i], parse_numbers);\n      check_status (yajl_gen_array_close (gen));\n      break;\n    case yajl_t_true:\n      check_status (yajl_gen_bool (gen, 1));\n      break;\n    case yajl_t_false:\n      check_status (yajl_gen_bool (gen, 0));\n      break;\n    case yajl_t_null:\n      check_status (yajl_gen_null (gen));\n      break;\n    default:\n      fprintf (stderr, \"unexpectedly got type %d\\n\", (int) val->type);\n      exit (EXIT_FAILURE);\n    }\n}\n\nstatic void print_tree (FILE *f, yajl_val tree, int parse_numbers)\n{\n  yajl_gen gen;\n\n  gen = yajl_gen_alloc (NULL);\n  if (! gen)\n    {\n      fprintf (stderr, \"yajl_gen_alloc failed\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  if (0 == yajl_gen_config (gen, yajl_gen_beautify, 1)  ||\n      0 == yajl_gen_config (gen, yajl_gen_validate_utf8, 1)  ||\n      0 == yajl_gen_config (gen, yajl_gen_print_callback, print_callback, f))\n    {\n      fprintf (stderr, \"yajl_gen_config failed\\n\");\n      exit (EXIT_FAILURE);\n    }\n\n  serialize_value (gen, tree, parse_numbers);\n  yajl_gen_free (gen);\n}\n\nint main (int argc, char **argv)\n{\n  char err_buf[200];\n  const char *json =\n    \"{\\\"pi\\\": 3.14, \\\"large number\\\": 123456789123456789123456789, \"\n    \"\\\"an array\\\": [-1, true, false, null, \\\"foo\\\"]}\";\n  yajl_val tree;\n\n  tree = yajl_tree_parse (json, err_buf, sizeof (err_buf));\n  if (! tree)\n    {\n      fprintf (stderr, \"parsing failed because: %s\\n\", err_buf);\n      return EXIT_FAILURE;\n    }\n\n  printf (\"Treating numbers as strings...\\n\");\n  print_tree (stdout, tree, 0);\n  printf (\"Parsing numbers to long long or double...\\n\");\n  print_tree (stdout, tree, 1);\n\n  yajl_tree_free (tree);\n\n  return EXIT_SUCCESS;\n}\n\n\nOutput:\nTreating numbers as strings...\n{\n    \"pi\": 3.14,\n    \"large number\": 123456789123456789123456789,\n    \"an array\": [\n        -1,\n        true,\n        false,\n        null,\n        \"foo\"\n    ]\n}\nParsing numbers to long long or double...\n{\n    \"pi\": 3.1400000000000001243,\n    \"large number\": 1.2345678912345679134e+26,\n    \"an array\": [\n        -1,\n        true,\n        false,\n        null,\n        \"foo\"\n    ]\n}\n", "explain": "Reads a snippet of JSON into YAJL's tree format, then walks the tree to print it back out again.  The tree contains numbers both in an unparsed, string form, and also converted to long long or double when possible.  The example below demonstrates both ways of dealing with numbers.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "C++", "code": "\nLibrary: U++\n#include \"Core/Core.h\"\n\nusing namespace Upp;\n\nCONSOLE_APP_MAIN\n{\n\tJsonArray a;\n\ta << Json(\"name\", \"John\")(\"phone\", \"1234567\") << Json(\"name\", \"Susan\")(\"phone\", \"654321\");\n\tString txt = ~a;\n\tCout() << txt << '\\n';\n\tValue v = ParseJSON(txt);\n\tfor(int i = 0; i < v.GetCount(); i++)\n\t\tCout() << v[i][\"name\"] << ' ' << v[i][\"phone\"] << '\\n';\n}\n\nC++11 Library: nlohmann::json\n#include <iostream>\n#include <iomanip> // std::setw\n#include <sstream>\n#include <cassert>\n\n#include \"json.hpp\"\n\nusing json = nlohmann::json;\n\nint main( int argc, char* argv[] )\n{\n        std::string const expected =\nR\"delim123({\n    \"answer\": {\n        \"everything\": 42\n    },\n    \"happy\": true,\n    \"list\": [\n        1,\n        0,\n        2\n    ],\n    \"name\": \"Niels\",\n    \"nothing\": null,\n    \"object\": {\n        \"currency\": \"USD\",\n        \"value\": 42.99\n    },\n    \"pi\": 3.141\n})delim123\";\n\n    json const jexpected = json::parse( expected );\n\n    assert( jexpected[\"list\"][1].get<int>() == 0 );\n    assert( jexpected[\"object\"][\"currency\"] == \"USD\" );\n\n    json jhandmade = {\n        {\"pi\", 3.141},\n        {\"happy\", true},\n        {\"name\", \"Niels\"},\n        {\"nothing\", nullptr},\n        {\"answer\", {\n             {\"everything\", 42}\n         }\n        },\n        {\"list\", {1, 0, 2}},\n        {\"object\", {\n             {\"currency\", \"USD\"},\n             {\"value\", 42.99}\n         }\n        }\n    };\n\n    assert( jexpected == jhandmade );\n\n    std::stringstream jhandmade_stream;\n    jhandmade_stream << std::setw(4) << jhandmade;\n\n    std::string jhandmade_string = jhandmade.dump(4);\n\n    assert( jhandmade_string == expected );\n    assert( jhandmade_stream.str() == expected );\n    \n    return 0;    \n}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Java", "code": "\n//  Parse JSON\n//\n//  Nigel Galloway - April 27th., 2012\n//\ngrammar JSON ;\n@members {\nString Indent = \"\";\n}\nNumber\t:\t(('0')|('-'? ('1'..'9') ('0'..'9')*)) ('.' ('0'..'9')+)? (('e'|'E') ('+'|'-')? ('0'..'9')+)?;\nWS\t:\t(' ' | '\\t' | '\\r' |'\\n') {skip();};\nTz\t:\t' ' .. '!' | '#' .. '[' | ']' .. '~';\nControl\t:\t'\\\\' ('\"'|'\\\\'|'/'|'b'|'f'|'n'|'r'|'t'|UCode);\nUCode\t:\t'u' ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F') ('0'..'9'|'a'..'f'|'A'..'F');\nKeyword\t:\t'true' | 'false' | 'null';\nString\t:\t'\"' (Control? Tz)* '\"';\nobject\t:       '{' {System.out.println(Indent + \"{Object}\"); Indent += \"    \";} (pair (',' pair*)*)? '}' {Indent = Indent.substring(4);};\npair\t:\te = String {System.out.println(Indent + \"{Property}\\t\" + $e.text);} ':' value;\nvalue\t:\tNumber             {System.out.println(Indent + \"{Number}  \\t\" + $Number.text);}\n\t|\tobject\n\t|\tString             {System.out.println(Indent + \"{String}  \\t\" + $String.text);}\n\t|\tKeyword            {System.out.println(Indent + \"{Keyword} \\t\" + $Keyword.text);}\n\t|\tarray;\narray\t:\t'[' {System.out.println(Indent + \"Array\"); Indent += \"    \";} (value (',' value)*)? ']' {Indent = Indent.substring(4);};\n\n\n>java Test\n{\n  \"Nigel\"\n \u00a0:\n  -110.2e-13\n  ,\n  \"Fred\"\n \u00a0:\n  {\n    \"Joe\"\n   \u00a0:\n    [3,true,\"Nigel\"]\n  }\n  \"Harry\"\n \u00a0:\n  [23,\"Hello\"]\n}\n^Z\n{Object}\n    {Property}  \"Nigel\"\n    {Number}    -110.2e-13\n    {Property}  \"Fred\"\n    {Object}\n        {Property}      \"Joe\"\n        Array\n            {Number}    3\n            {Keyword}   true\n            {String}    \"Nigel\"\n    {Property}  \"Harry\"\n    Array\n        {Number}        23\n        {String}        \"Hello\"\n\n", "explain": "Produces:\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "C#", "code": "\nWorks with: C sharp version 3.0\n\nusing System;\nusing System.Collections.Generic;\nusing System.Web.Script.Serialization;\n\nclass Program\n{\n    static void Main()\n    {\n        var people = new Dictionary<string, object> {{\"1\", \"John\"}, {\"2\", \"Susan\"}};\n        var serializer = new JavaScriptSerializer();\n        \n        var json = serializer.Serialize(people);\n        Console.WriteLine(json);\n\n        var deserialized = serializer.Deserialize<Dictionary<string, object>>(json);\n        Console.WriteLine(deserialized[\"2\"]);\n\n        var jsonObject = serializer.DeserializeObject(@\"{ \"\"foo\"\": 1, \"\"bar\"\": [10, \"\"apples\"\"] }\");\n        var data = jsonObject as Dictionary<string, object>;\n        var array = data[\"bar\"] as object[];\n        Console.WriteLine(array[1]);\n    }\n}\n\n", "explain": "This uses the JavaScriptSerializer class which was shipped with .NET 3.5.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\n\nvar data = JSON.parse('{ \"foo\": 1, \"bar\": [10, \"apples\"] }');\n\nvar sample = { \"blue\": [1,2], \"ocean\": \"water\" };\nvar json_string = JSON.stringify(sample);\n\n\n", "explain": "Requires JSON library, now present in all major browsers.\nJSON is called JavaScript Object Notation, but JSON differs form JavaScript object literal. cf. MDN/JSON\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "PHP", "code": "\n<?php\n$data = json_decode('{ \"foo\": 1, \"bar\": [10, \"apples\"] }'); // dictionaries will be returned as objects\n$data2 = json_decode('{ \"foo\": 1, \"bar\": [10, \"apples\"] }', true); // dictionaries will be returned as arrays\n\n$sample = array( \"blue\" => array(1,2), \"ocean\" => \"water\" );\n$json_string = json_encode($sample);\n?>\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Fortran", "code": "\n\n{\n  \"PhoneBook\": [\n    {\n      \"name\": \"Adam\",\n      \"phone\": \"0000001\"\n    },\n    {\n      \"name\": \"Eve\",\n      \"phone\": \"0000002\"\n    },\n    {\n      \"name\": \"Julia\",\n      \"phone\": \"6666666\"\n    }\n  ]\n}\n\nprogram json_fortran\n   use json_module\n   implicit none\n\n   type phonebook_type\n      character(len=:),allocatable :: name\n      character(len=:),allocatable :: phone\n   end type phonebook_type\n\n   type(phonebook_type), dimension(3) :: PhoneBook\n   integer :: i\n   type(json_value),pointer :: json_phonebook,p,e\n   type(json_file) :: json\n\n   PhoneBook(1) % name = 'Adam'\n   PhoneBook(2) % name = 'Eve'\n   PhoneBook(3) % name = 'Julia'\n   PhoneBook(1) % phone = '0000001'\n   PhoneBook(2) % phone = '0000002'\n   PhoneBook(3) % phone = '6666666'\n\n   call json_initialize()\n\n   !create the root structure:\n   call json_create_object(json_phonebook,'')\n\n   !create and populate the phonebook array:\n   call json_create_array(p,'PhoneBook')\n   do i=1,3\n      call json_create_object(e,'')\n      call json_add(e,'name',PhoneBook(i)%name)\n      call json_add(e,'phone',PhoneBook(i)%phone)\n      call json_add(p,e) !add this element to array\n      nullify(e) !cleanup for next loop\n   end do\n   call json_add(json_phonebook,p) !add p to json_phonebook\n   nullify(p) !no longer need this\n\n   !write it to a file:\n   call json_print(json_phonebook,'phonebook.json')\n\n   ! read directly from a character string\n   call json%load_from_string('{ \"PhoneBook\": [ { \"name\": \"Adam\", \"phone\": \"0000001\" },&\n   { \"name\": \"Eve\", \"phone\": \"0000002\" }, { \"name\": \"Julia\", \"phone\": \"6666666\" } ]}')\n   ! print it to the console\n   call json%print_file()\n\nend program json_fortran\n\n", "explain": "Using json-fortran library. Creating the json example file / reading a JSON string.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Go", "code": "\n\npackage main\n\nimport \"encoding/json\"\nimport \"fmt\"\n\nfunc main() {\n    var data interface{}\n    err := json.Unmarshal([]byte(`{\"foo\":1, \"bar\":[10, \"apples\"]}`), &data)\n    if err == nil {\n        fmt.Println(data)\n    } else {\n        fmt.Println(err)\n    }\n\n    sample := map[string]interface{}{\n        \"blue\":  []interface{}{1, 2},\n        \"ocean\": \"water\",\n    }\n    json_string, err := json.Marshal(sample)\n    if err == nil {\n        fmt.Println(string(json_string))\n    } else {\n        fmt.Println(err)\n    }\n}\n\n\nOutput:\nmap[bar:[10 apples] foo:1]\n{\"blue\":[1,2],\"ocean\":\"water\"}\n\n\npackage main\n\nimport \"encoding/json\"\nimport \"fmt\"\n\ntype Person struct {\n    Name string   `json:\"name\"`\n    Age  int      `json:\"age,omitempty\"`\n    Addr *Address `json:\"address,omitempty\"`\n    Ph   []string `json:\"phone,omitempty\"`\n}\n\ntype Address struct {\n    Street string `json:\"street\"`\n    City   string `json:\"city\"`\n    State  string `json:\"state\"`\n    Zip    string `json:\"zip\"`\n}\n\nfunc main() {\n    // compare with output, note apt field ignored, missing fields\n    // have zero values.\n    jData := []byte(`{\n        \"name\": \"Smith\",\n        \"address\": {\n            \"street\": \"21 2nd Street\",\n            \"apt\": \"507\",\n            \"city\": \"New York\",\n            \"state\": \"NY\",\n            \"zip\": \"10021\"\n        }\n    }`)\n    var p Person\n    err := json.Unmarshal(jData, &p)\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Printf(\"%+v\\n \u00a0%+v\\n\\n\", p, p.Addr)\n    }\n\n    // compare with output, note empty fields omitted.\n    pList := []Person{\n        {\n            Name: \"Jones\",\n            Age:  21,\n        },\n        {\n            Name: \"Smith\",\n            Addr: &Address{\"21 2nd Street\", \"New York\", \"NY\", \"10021\"},\n            Ph:   []string{\"212 555-1234\", \"646 555-4567\"},\n        },\n    }\n    jData, err = json.MarshalIndent(pList, \"\", \"    \")\n    if err != nil {\n        fmt.Println(err)\n    } else {\n        fmt.Println(string(jData))\n    }\n}\n\n\nOutput:\n{Name:Smith Age:0 Addr:0xf840026080 Ph:[]}\n  &{Street:21 2nd Street City:New York State:NY Zip:10021}\n\n[\n    {\n        \"name\": \"Jones\",\n        \"age\": 21\n    },\n    {\n        \"name\": \"Smith\",\n        \"address\": {\n            \"street\": \"21 2nd Street\",\n            \"city\": \"New York\",\n            \"state\": \"NY\",\n            \"zip\": \"10021\"\n        },\n        \"phone\": [\n            \"212 555-1234\",\n            \"646 555-4567\"\n        ]\n    }\n]\n\n\n", "explain": "Example below shows simple correspondence between JSON objects and Go maps, and shows that you don't have to know anything about the structure of the JSON data to read it in.\nExample below demonstrates more typical case where you have an expected correspondence between JSON data and some composite data types in your program, and shows how the correspondence doesn't have to be exact.\n\n\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Delphi", "code": "\nTranslation of: C#\nprogram JsonTest;\n\n{$APPTYPE CONSOLE}\n\n{$R *.res}\n\nuses\n  System.SysUtils,\n  Json;\n\ntype\n  TJsonObjectHelper = class helper for TJsonObject\n  public\n    class function Deserialize(data: string): TJsonObject; static;\n    function Serialize: string;\n  end;\n\n{ TJsonObjectHelper }\n\nclass function TJsonObjectHelper.Deserialize(data: string): TJsonObject;\nbegin\n  Result := TJSONObject.ParseJSONValue(data) as TJsonObject;\nend;\n\nfunction TJsonObjectHelper.Serialize: string;\nbegin\n  Result := ToJson;\nend;\n\nvar\n  people, deserialized: TJsonObject;\n  bar: TJsonArray;\n  _json: string;\n\nbegin\n  people := TJsonObject.Create();\n  people.AddPair(TJsonPair.Create('1', 'John'));\n  people.AddPair(TJsonPair.Create('2', 'Susan'));\n\n  _json := people.Serialize;\n  Writeln(_json);\n\n  deserialized := TJSONObject.Deserialize(_json);\n  Writeln(deserialized.Values['2'].Value);\n\n  deserialized := TJSONObject.Deserialize('{\"foo\":1 , \"bar\":[10,\"apples\"]}');\n\n  bar := deserialized.Values['bar'] as TJSONArray;\n  Writeln(bar.Items[1].Value);\n\n  deserialized.Free;\n  people.Free;\n\n  Readln;\nend.\n\n\nOutput:\n{\"1\":\"John\",\"2\":\"Susan\"}\nSusan\napples\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Ruby", "code": "\nrequire 'json'\n\nruby_obj = JSON.parse('{\"blue\": [1, 2], \"ocean\": \"water\"}')\nputs ruby_obj\n\nruby_obj[\"ocean\"] = { \"water\" => [\"fishy\", \"salty\"] }\nputs JSON.generate(ruby_obj)\nputs JSON.pretty_generate(ruby_obj)\n\n\nOutput:\n{\"blue\"=>[1, 2], \"ocean\"=>\"water\"}\n{\"blue\":[1,2],\"ocean\":{\"water\":[\"fishy\",\"salty\"]}}\n{\n  \"blue\": [\n    1,\n    2\n  ],\n  \"ocean\": {\n    \"water\": [\n      \"fishy\",\n      \"salty\"\n    ]\n  }\n}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Rust", "code": "\n\nWorks with: Rust version 1.31\nLibrary: Serde\u00a0version 1.0\n[dependencies]\nserde = { version = \"1.0\", features = [\"derive\"] }\nserde_json = \"1.0\"\n\n\nuse serde::{Serialize, Deserialize};\n\n#[derive(Serialize, Deserialize, Debug)]\nstruct Point {\n    x: i32,\n    y: i32,\n}\n\n\nfn main() {\n    let point = Point { x: 1, y: 2 };\n\n    let serialized = serde_json::to_string(&point).unwrap();\n    let deserialized: Point = serde_json::from_str(&serialized).unwrap();\n\n    println!(\"serialized = {}\", serialized);\n    println!(\"deserialized = {:?}\", deserialized);\n}\n\n\n\nOutput:\nserialized = {\"x\":1,\"y\":2}\ndeserialized = Point { x: 1, y: 2 }\n\n#[derive(Serialize, Deserialize)]\nstruct W { a: i32, b: i32 }  // => { \"a\": 0, \"b\": 0 }\n\n#[derive(Serialize, Deserialize)]\nstruct X(i32, i32);          // => [0, 0]\n\n#[derive(Serialize, Deserialize)]\nstruct Y(i32);               // => 0\n\n#[derive(Serialize, Deserialize)]\nstruct Z;                    // => null\n\n#[derive(Serialize, Deserialize)]\nenum E {\n    W { a: i32, b: i32 },    // => { \"W\": { \"a\": 0, \"b\": 0 } }\n    X(i32, i32),             // => { \"X\": [0, 0] }\n    Y(i32),                  // => { \"Y\": 0 }\n    Z,                       // => { \"Z\" }\n}\n\n\nuse std::collections::HashMap;\nuse serde_json::Value;\n\n#[derive(Serialize, Deserialize)]\nstruct Data {\n    points: Vec<Points>,\n\n    #[serde(flatten)]\n    metadata: HashMap<String, Value>,\n}\n\n\nfn main() {\n    let data = {\n        let mut metadata = HashMap::new();\n        metadata.insert(\"triangle\".to_string(), Value::Number(3.into()));\n        metadata.insert(\"square\".to_string(), Value::Bool(false));\n        \n        Data {\n            points: vec![Point { x: 1, y: 2 }, Point { x: 15, y: 32 }],\n            metadata,\n        }\n    };\n\n    let serialized = serde_json::to_string(&data).unwrap();\n    let deserialized: Data = serde_json::from_str(&serialized).unwrap();\n\n    println!(\"serialized = {}\", serialized);\n    println!(\"deserialized = {:?}\", deserialized);\n}\n\n\nOutput:\nserialized = {\"points\":[{\"x\":1,\"y\":2},{\"x\":15,\"y\":32}],\"square\":false,\"triangle\":3}\ndeserialized = Data { points: [Point { x: 1, y: 2 }, Point { x: 15, y: 32 }], metadata: {\"triangle\": Number(3), \"square\": Bool(false)} }\n\n", "explain": "Serializing and deserializing JSON in Rust is done by libraries.\nSerde is a general serialization/deserialization library. Serde-JSON implements JSON serialization for Serde. \nUsing said library is quite straight forward, one simply derives Serialize/Deserialize onto the types they want to convert into and from JSON strings.\nSaid type could then be used as such:\nThe result of which is type-checked JSON (where extra entries get ignored), without need of a key-value container.\nIt also handles more Rust specific types like enums, tuples, struct tuples, and zero-sized types.\nThe traits are also implemented for HashMap and Vec which can be used as conventional objects/arrays, on top of macros and serde_json::Value to handle all other potentially weird edge cases.\nIn this example metadata would simply capture all other additional entries, for example:\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Swift", "code": "\nimport Foundation\n\nlet jsonString = \"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\"\nif let jsonData = jsonString.data(using: .utf8) {\n\tif let jsonObject: Any = try? JSONSerialization.jsonObject(with: jsonData, options: .allowFragments) {\n\t\tprint(\"Dictionary: \\(jsonObject)\")\n\t}\n}\n\nlet obj = [\n\t\"foo\": [1, \"Orange\"],\n\t\"bar\": 1\n] as [String\u00a0: Any]\n\nif let objData = try? JSONSerialization.data(withJSONObject: obj, options: .prettyPrinted) {\n\tif let jsonString2 = String(data: objData, encoding: .utf8) {\n\t\tprint(\"JSON: \\(jsonString2)\")\n\t}\n}\n\nOutput:\nDictionary: {\n    bar =     (\n        10,\n        apples\n    );\n    foo = 1;\n}\nJSON: {\n  \"foo\"\u00a0: [\n    1,\n    \"Orange\"\n  ],\n  \"bar\"\u00a0: 1\n}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "R", "code": "\nlibrary(rjson)\ndata <- fromJSON('{ \"foo\": 1, \"bar\": [10, \"apples\"] }')\ndata\n\ndata\n$foo\n[1] 1\n\n$bar\n$bar[[1]]\n[1] 10\n\n$bar[[2]]\n[1] \"apples\"\n\ncat(toJSON(data))\n\n{\"foo\":1,\"bar\":[10,\"apples\"]}\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Ada", "code": "\nAlternative using GNATCOLL[edit]\nwith Ada.Text_IO;\nwith GNATCOLL.JSON;\n \nprocedure JSON_Test is\n   use Ada.Text_IO;\n   use GNATCOLL.JSON;\n \n   JSON_String : constant String := \"{\"\"name\"\":\"\"Pingu\"\",\"\"born\"\":1986}\";\n   \n   Penguin : JSON_Value := Create_Object;\n   Parents : JSON_Array;\nbegin\n   Penguin.Set_Field (Field_Name => \"name\", \n                      Field      => \"Linux\");\n   \n   Penguin.Set_Field (Field_Name => \"born\",\n                      Field      => 1992);\n   \n   Append (Parents, Create (\"Linus Torvalds\"));\n   Append (Parents, Create (\"Alan Cox\"));\n   Append (Parents, Create (\"Greg Kroah-Hartman\"));\n \n   Penguin.Set_Field (Field_Name => \"parents\",\n                      Field      => Parents);\n   \n   Put_Line (Penguin.Write);\n\n   Penguin := Read (JSON_String, \"json.errors\");\n   \n   Penguin.Set_Field (Field_Name => \"born\",\n                      Field      => 1986);\n   \n   Parents := Empty_Array;\n   Append (Parents, Create (\"Otmar Gutmann\"));\n   Append (Parents, Create (\"Silvio Mazzola\"));  \n   \n   Penguin.Set_Field (Field_Name => \"parents\",\n                      Field      => Parents);\n   \n   Put_Line (Penguin.Write);\nend JSON_Test;\n\n\nOutput:\n{\"parents\":[\"Linus Torvalds\", \"Alan Cox\", \"Greg Kroah-Hartman\"], \"name\":\"Linux\", \"born\":1992}\n{\"parents\":[\"Otmar Gutmann\", \"Silvio Mazzola\"], \"name\":\"Pingu\", \"born\":1986}\n\nAlternative using Matreshka[edit]\nwith Ada.Wide_Wide_Text_IO; use Ada.Wide_Wide_Text_IO;\nwith League.JSON.Arrays;    use League.JSON.Arrays;\nwith League.JSON.Documents; use League.JSON.Documents;\nwith League.JSON.Objects;   use League.JSON.Objects;\nwith League.JSON.Values;    use League.JSON.Values;\nwith League.Strings;        use League.Strings;\n\nprocedure Main is\n\n   function \"+\" (Item : Wide_Wide_String) return Universal_String\n     renames To_Universal_String;\n\n   JSON_String : constant Universal_String\n     := +\"{\"\"name\"\":\"\"Pingu\"\",\"\"born\"\":1986}\";\n\n   Penguin : JSON_Object;\n   Parents : JSON_Array;\n\nbegin\n   Penguin.Insert (+\"name\", To_JSON_Value (+\"Linux\"));\n   Penguin.Insert (+\"born\", To_JSON_Value (1992));\n\n   Parents.Append (To_JSON_Value (+\"Linus Torvalds\"));\n   Parents.Append (To_JSON_Value (+\"Alan Cox\"));\n   Parents.Append (To_JSON_Value (+\"Greg Kroah-Hartman\"));\n\n   Penguin.Insert (+\"parents\", To_JSON_Value (Parents));\n\n   Put_Line (To_JSON_Document (Penguin).To_JSON.To_Wide_Wide_String);\n\n   Penguin := From_JSON (JSON_String).To_JSON_Object;\n\n   Parents := Empty_JSON_Array;\n\n   Parents.Append (To_JSON_Value (+\"Otmar Gutmann\"));\n   Parents.Append (To_JSON_Value (+\"Silvio Mazzola\"));\n\n   Penguin.Insert (+\"parents\", To_JSON_Value (Parents));\n\n   Put_Line (To_JSON_Document (Penguin).To_JSON.To_Wide_Wide_String);\nend Main;\n\n\nOutput:\n{\"parents\":[\"Linus Torvalds\",\"Alan Cox\",\"Greg Kroah-Hartman\"],\"name\":\"Linux\",\"born\":1992}\n{\"parents\":[\"Otmar Gutmann\",\"Silvio Mazzola\"],\"name\":\"Pingu\",\"born\":1986}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n# Pkg.add(\"JSON\") ... an external library http://docs.julialang.org/en/latest/packages/packagelist/\nusing JSON\n\nsample = Dict()\nsample[\"blue\"] = [1, 2]\nsample[\"ocean\"] = \"water\"\n\n@show sample jsonstring = json(sample)\n@show jsonobj = JSON.parse(jsonstring)\n\n@assert jsonstring == \"{\\\"ocean\\\":\\\"water\\\",\\\"blue\\\":[1,2]}\"\n@assert jsonobj == Dict(\"ocean\" => \"water\", \"blue\" => [1, 2])\n@assert typeof(jsonobj) == Dict{String, Any}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\n\n// version 1.2.21\n\ndata class JsonObject(val foo: Int, val bar: Array<String>)\n\ndata class JsonObject2(val ocean: String, val blue: Array<Int>)\n\nfun main(args: Array<String>) {\n    // JSON to object\n    val data: JsonObject = JSON.parse(\"\"\"{ \"foo\": 1, \"bar\": [\"10\", \"apples\"] }\"\"\")\n    println(JSON.stringify(data))\n\n    // object to JSON\n    val data2 = JsonObject2(\"water\", arrayOf(1, 2))\n    println(JSON.stringify(data2))\n}\n\n\nOutput:\n{\"foo\":1,\"bar\":[\"10\",\"apples\"]}\n{\"ocean\":\"water\",\"blue\":[1,2]}\n\n", "explain": "We use Kotlin JS here to obtain access to the JavaScript JSON object:\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Perl", "code": "\nLibrary: JSON\nuse JSON;\n\nmy $data = decode_json('{ \"foo\": 1, \"bar\": [10, \"apples\"] }');\n\nmy $sample = { blue => [1,2], ocean => \"water\" };\nmy $json_string = encode_json($sample);\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\nWorks with: 10.7+ version Xcode 4.4+\nNSString *jsonString = @\"{ \\\"foo\\\": 1, \\\"bar\\\": [10, \\\"apples\\\"] }\";\nid obj = [NSJSONSerialization \n    JSONObjectWithData: [jsonString dataUsingEncoding: NSUTF8StringEncoding]\n               options: 0\n                 error: NULL];\nNSLog(@\"%@\", obj);\n\nNSDictionary *dict = @{ @\"blue\": @[@1, @2], @\"ocean\": @\"water\"};\nNSData *jsonData = [NSJSONSerialization dataWithJSONObject: dict\n                                                   options: 0\n                                                     error: NULL];\nNSString *jsonString2 = [[NSString alloc] initWithData: jsonData\n                                              encoding: NSUTF8StringEncoding];\nNSLog(@\"%@\", jsonString2);\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Prolog", "code": "\n\n:- use_module([ library(http/json),\n                library(func) ]).\n\ntest_json('{\"widget\": { \"debug\": \"on\", \"window\": { \"title\": \"Sample Konfabulator Widget\", \"name\": \"main_window\", \"width\": 500, \"height\": 500 }, \"image\": { \"src\": \"Images/Sun.png\", \"name\": \"sun1\", \"hOffset\": 250, \"vOffset\": 250, \"alignment\": \"center\" }, \"text\": { \"data\": \"Click Here\", \"size\": 36, \"style\": \"bold\", \"name\": \"text1\", \"hOffset\": 250, \"vOffset\": 100, \"alignment\": \"center\", \"onMouseUp\": \"sun1.opacity = (sun1.opacity / 100) * 90;\" }}}').\n\nreading_JSON_term :-\n    atom_json_dict(test_json(~), Dict, []), %% This accomplishes reading in the JSON data\n    writeln( 'JSON as Prolog dict: ~w~n'\n           $ Dict),\n    writeln( 'Access field \"widget.text.data\": ~s~n'\n           $ Dict.widget.text.data),\n    writeln( 'Alter field \"widget\": ~w~n'\n           $ Dict.put(widget, \"Altered\")).\n\nsearalize_a_JSON_term :-\n    Dict = _{book:_{title:\"To Mock a Mocking Bird\",\n                    author:_{first_name:\"Ramond\",\n                             last_name:\"Smullyan\"},\n                    publisher:\"Alfred A. Knopf\",\n                    year:1985\n                   }},\n    json_write(current_output, Dict). %% This accomplishes serializing the JSON object.\n\n\nOutput: from these two example predicates\n\n?- reading_JSON_term.\nJSON as Prolog dict: _G5217{widget:_G5207{debug:on,image:_G5123{alignment:center,hOffset:250,name:sun1,src:Images/Sun.png,vOffset:250},text:_G5189{alignment:center,data:Click Here,hOffset:250,name:text1,onMouseUp:sun1.opacity = (sun1.opacity / 100) * 90;,size:36,style:bold,vOffset:100},window:_G5077{height:500,name:main_window,title:Sample Konfabulator Widget,width:500}}}\n\nAccess field \"widget.text.data\": Click Here\n\nAlter field \"widget\": _G5217{widget:Altered}\n\ntrue.\n\n?- searalize_a_JSON_term.\n{\n  \"book\": {\n    \"author\": {\"first_name\":\"Ramond\", \"last_name\":\"Smullyan\"},\n    \"publisher\":\"Alfred A. Knopf\",\n    \"title\":\"To Mock a Mocking Bird\",\n    \"year\":1985\n  }\n}\ntrue.\n\n", "explain": "Using SWI-Prolog 7's library(http/json), and the new dict datatype, there is nearly transparent handling of JSON objects. All of the serialization and parsing in the following code is accomplished with two predicates. The rest of the code is for the sake of example.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Lua", "code": "\n\nlocal json = require(\"json\")\n\nlocal json_data = [=[[\n    42,\n    3.14159,\n    [ 2, 4, 8, 16, 32, 64, \"apples\", \"bananas\", \"cherries\" ],\n    { \"H\": 1, \"He\": 2, \"X\": null, \"Li\": 3 },\n    null,\n    true,\n    false\n]]=]\n\nprint(\"Original JSON: \" .. json_data)\nlocal data = json.decode(json_data)\njson.util.printValue(data, 'Lua')\nprint(\"JSON re-encoded: \" .. json.encode(data))\n\nlocal data = {\n    42,\n    3.14159,\n    {\n        2, 4, 8, 16, 32, 64,\n        \"apples\",\n        \"bananas\",\n        \"cherries\"\n    },\n    {\n        H = 1,\n        He = 2,\n        X = json.util.null(),\n        Li = 3\n    },\n    json.util.null(),\n    true,\n    false\n}\n\nprint(\"JSON from new Lua data: \" .. json.encode(data))\n\n\n\nOutput:\n   Original JSON: [\n       42,\n       3.14159,\n       [ 2, 4, 8, 16, 32, 64, \"apples\", \"bananas\", \"cherries\" ],\n       { \"H\": 1, \"He\": 2, \"X\": null, \"Li\": 3 },\n       null,\n       true,\n       false\n   ]\n   Lua= {\n    1=42\n    2=3.14159\n    3= {\n     1=2\n     2=4\n     3=8\n     4=16\n     5=32\n     6=64\n     7=apples\n     8=bananas\n     9=cherries\n    4= {\n     Li=3\n     He=2\n     H=1\n     X=function: 0x8f6f00\n    5=function: 0x8f6f00\n    6=true\n    7=false\n   JSON re-encoded: [42,3.14159,[2,4,8,16,32,64,\"apples\",\"bananas\",\"cherries\"],{\"Li\":3,\"He\":2,\"H\":1,\"X\":null},null,true,false]\n   JSON from new Lua data: [42,3.14159,[2,4,8,16,32,64,\"apples\",\"bananas\",\"cherries\"],{\"Li\":3,\"He\":2,\"H\":1,\"X\":null},null,true,false]\n\n", "explain": "Using the luajson library:\nSince in Lua, a variable or table entry with nil is treated as the same as an undefined variable or non-existing table entry, a null value in JSON is decoded to a special function value, which ensures that it can be re-encoded properly to null again. \nTo manually insert a null value in the JSON output, \nuse the json.util.null function.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Scala", "code": "\n\nscala> import scala.util.parsing.json.{JSON, JSONObject}\nimport scala.util.parsing.json.{JSON, JSONObject}\n\nscala> JSON.parseFull(\"\"\"{\"foo\": \"bar\"}\"\"\")\nres0: Option[Any] = Some(Map(foo -> bar))\n\nscala> JSONObject(Map(\"foo\" -> \"bar\")).toString()\nres1: String = {\"foo\" : \"bar\"}\n\n", "explain": "Using the builtin parsing lib (debatably slower than third-party libs such as lift-json from Liftweb).\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Dart", "code": "\nimport 'dart:convert' show jsonDecode, jsonEncode;\n\nmain(){\n\tvar json_string = '''\n\t{\n\t\t\"rosetta_code\": {\n\t\t\t\"task\": \"json\",\n\t\t\t\"language\": \"dart\",\n\t\t\t\"descriptions\": [ \"fun!\", \"easy to learn!\", \"awesome!\" ]\n\t\t}\n\t}\n\t''';\n\t\n\t// decode string into Map<String, dynamic>\n\tvar json_object = jsonDecode(json_string);\n\t\n\tfor ( var description in json_object[\"rosetta_code\"][\"descriptions\"] )\n\t\tprint( \"dart is $description\" );\n\n\tvar dart = {\n\t\t\"compiled\": true,\n\t\t\"interpreted\": true,\n\t\t\"creator(s)\":[ \"Lars Bak\", \"Kasper Lund\"],\n\t\t\"development company\": \"Google\"\n\t};\n\n\tvar as_json_text = jsonEncode(dart);\n\n\tassert(as_json_text == '{\"compiled\":true,\"interpreted\":true,\"creator(s)\":[\"Lars Bak\",\"Kasper Lund\"],\"development company\":\"Google\"}');\n}\n\n\nOutput:\ndart is fun!\ndart is easy to learn!\ndart is awesome!\n\nTranslation of: JavaScript\nimport 'dart:convert';\n\nmain(){\n\tvar data = jsonDecode('{ \"foo\": 1, \"bar\": [10, \"apples\"] }');\n \n\tvar sample = { \"blue\": [1,2], \"ocean\": \"water\" };\n\n\tvar json_string = jsonEncode(sample);\n}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "D", "code": "\nimport std.stdio, std.json;\n    \nvoid main() {\n    auto j = parseJSON(`{ \"foo\": 1, \"bar\": [10, \"apples\"] }`);\n    writeln(toJSON(&j)); \n}\n\n{\"foo\":1,\"bar\":[10,\"apples\"]}\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Data.Aeson\nimport Data.Attoparsec (parseOnly)\nimport Data.Text\nimport qualified Data.ByteString.Lazy.Char8 as B\nimport qualified Data.ByteString.Char8 as S\n\ntestdoc = object [\n    \"foo\"   .= (1 :: Int),\n    \"bar\"   .= ([1.3, 1.6, 1.9] :: [Double]),\n    \"baz\"   .= (\"some string\" :: Text),\n    \"other\" .= object [\n        \"yes\" .= (\"sir\" :: Text)\n        ]\n    ]\n\nmain = do\n    let out = encode testdoc\n    B.putStrLn out\n    case parseOnly json (S.concat $ B.toChunks out) of\n        Left e -> error $ \"strange error re-parsing json: \" ++ (show e)\n        Right v | v /= testdoc -> error \"documents not equal!\"\n        Right v | otherwise    -> print v\n\n\n{-# LANGUAGE TemplateHaskell, OverloadedStrings #-}\nimport Data.Aeson\nimport Data.Aeson.TH\n\ndata Person = Person { firstName :: String\n                     , lastName  :: String\n                     , age :: Maybe Int\n                     } deriving (Show, Eq)\n\n$(deriveJSON defaultOptions ''Person)\n\nmain = do\n    let test1 = \"{\\\"firstName\\\":\\\"Bob\\\", \\\"lastName\\\":\\\"Smith\\\"}\"\n        test2 = \"{\\\"firstName\\\":\\\"Miles\\\", \\\"lastName\\\":\\\"Davis\\\", \\\"age\\\": 45}\"\n    print (decode test1 :: Maybe Person)\n    print (decode test2 :: Maybe Person)\n\n\n{-# LANGUAGE DeriveGeneric, OverloadedStrings #-}\nimport Data.Aeson\nimport GHC.Generics\n\ndata Person = Person { firstName :: String\n                     , lastName  :: String\n                     , age :: Maybe Int\n                     } deriving (Show, Eq, Generic)\n\ninstance FromJSON Person\ninstance ToJSON Person\n\nmain = do\n    let test1 = \"{\\\"firstName\\\":\\\"Bob\\\", \\\"lastName\\\":\\\"Smith\\\"}\"\n        test2 = \"{\\\"firstName\\\":\\\"Miles\\\", \\\"lastName\\\":\\\"Davis\\\", \\\"age\\\": 45}\"\n    print (decode test1 :: Maybe Person)\n    print (decode test2 :: Maybe Person)\n\n", "explain": "Uses the Aeson library from hackage (http://hackage.haskell.org/package/aeson).\nAn example using Aeson and TemplateHaskell. Note that it can handle the absence of keys.\nAn example using Aeson and GHC.Generics. Note that it can handle the absence of keys.\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Scheme", "code": "\nWorks with: Chicken Scheme\nUsing the json egg: (use json)\n(define object-example\n  (with-input-from-string \"{\\\"foo\\\": \\\"bar\\\", \\\"baz\\\": [1, 2, 3]}\"\n                          json-read))\n(pp object-example)\n; this prints #((\"foo\" . \"bar\") (\"baz\" 1 2 3))\n\n(json-write #([foo . bar]\n              [baz   1 2 3]\n              [qux . #((rosetta . code))]))\n; this writes the following:\n; {\"foo\": \"bar\", \"baz\": [1, 2, 3], \"qux\": {\"foo\": \"bar\"}}\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Apex", "code": "\n\nclass TestClass{\n    String foo {get;set;}\n    Integer bar {get;set;}\n}\n\nTestClass testObj = new TestClass();\ntestObj.foo = 'ABC';\ntestObj.bar = 123;\n\nString serializedString = JSON.serialize(testObj);\nTestClass deserializedObject = (TestClass)JSON.deserialize(serializedString, TestClass.class);\n\n//\"testObj.foo == deserializedObject.foo\" is true\n//\"testObj.bar == deserializedObject.bar\" is true\n", "explain": "JSON serialization and deserialization is built in\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "PowerShell", "code": "\n# JSON input is being stored in ordered hashtable.\n# Ordered hashtable is available in PowerShell v3 and higher.\n[ordered]@{ \"foo\"= 1; \"bar\"= 10, \"apples\" } | ConvertTo-Json\n\n# ConvertFrom-Json converts a JSON-formatted string to a custom object.\n# If you use the Invoke-RestMethod cmdlet there is not need for the ConvertFrom-Json cmdlet\nInvoke-WebRequest -Uri \"http://date.jsontest.com\" | ConvertFrom-Json\n\n\nOutput:\n{\n    \"foo\":  1,\n    \"bar\":  [\n                10,\n                \"apples\"\n            ]\n}\n\ntime                                                                  milliseconds_since_epoch date                                          \n----                                                                  ------------------------ ----                                          \n12:25:25 PM                                                                      1414326325923 10-26-2014\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "ColdFusion", "code": "\n<!--- Create sample JSON structure --->\n<cfset json = {\n  string: \"Hello\",\n  number: 42,\n  arrayOfNumbers: [1, 2, 3, 4],\n  arrayOfStrings: [\"One\", \"Two\", \"Three\", \"Four\"],\n  arrayOfAnything: [1, \"One\", [1, \"One\"], { one: 1 }],\n  object: {\n    key: \"value\"\n  }\n} />\n\n<!--- Convert to JSON string --->\n<cfset jsonSerialized = serializeJSON(json) />\n<!--- Convert back to ColdFusion --->\n<cfset jsonDeserialized = deserializeJSON(jsonSerialized) />\n\n<!--- Output examples --->\n<cfdump var=\"#jsonSerialized#\" />\n<cfdump var=\"#jsonDeserialized#\" />\n\n", "explain": ""}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "F#", "code": "\n\nopen Newtonsoft.Json\ntype Person = {ID: int; Name:string}\nlet xs = [{ID = 1; Name = \"First\"} ; { ID = 2; Name = \"Second\"}]\n\nlet json = JsonConvert.SerializeObject(xs)\njson |> printfn \"%s\"\n\nlet xs1 = JsonConvert.DeserializeObject<Person list>(json)\nxs1 |> List.iter(fun x -> printfn \"%i  %s\" x.ID x.Name)\n\n\n[{\"ID\":1,\"Name\":\"First\"},{\"ID\":2,\"Name\":\"Second\"}]\n1  First\n2  Second\n\n\nopen FSharp.Data\nopen FSharp.Data.JsonExtensions\n\ntype Person = {ID: int; Name:string}\nlet xs = [{ID = 1; Name = \"First\"} ; { ID = 2; Name = \"Second\"}]\n\nlet infos = xs |> List.map(fun x -> JsonValue.Record([| \"ID\", JsonValue.Number(decimal x.ID); \"Name\", JsonValue.String(x.Name) |]))\n            |> Array.ofList |> JsonValue.Array\n\ninfos |> printfn \"%A\"\nmatch JsonValue.Parse(infos.ToString()) with\n| JsonValue.Array(x) -> x |> Array.map(fun x -> {ID = System.Int32.Parse(string x?ID); Name = (string x?Name)})\n| _ -> failwith \"fail json\"\n|> Array.iter(fun x -> printfn \"%i  %s\" x.ID x.Name)\n\n\n[\n  {\n    \"ID\": 1,\n    \"Name\": \"First\"\n  },\n  {\n    \"ID\": 2,\n    \"Name\": \"Second\"\n  }\n]\n1  \"First\"\n2  \"Second\"\n\n\nopen FSharp.Data\ntype Person = {ID: int; Name:string}\ntype People = JsonProvider<\"\"\" [{\"ID\":1,\"Name\":\"First\"},{\"ID\":2,\"Name\":\"Second\"}] \"\"\">\n\nPeople.GetSamples()\n|> Array.map(fun x -> {ID = x.Id; Name = x.Name} )\n|> Array.iter(fun x -> printfn \"%i  %s\" x.ID x.Name)\n\nPrint:1  First\n2  Second\n\n", "explain": "There are several ways:\n1. Using Json.Net\nPrint:\n2. Using FSharp.Data\nPrint:\n3. Alternative way of parsing: JsonProvider\n"}, {"task_name": "JSON", "task_url": "https://rosettacode.org/wiki/JSON", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\ndef slurper = new groovy.json.JsonSlurper()\ndef result = slurper.parseText('''\n{\n    \"people\":[\n        {\"name\":{\"family\":\"Flintstone\",\"given\":\"Frederick\"},\"age\":35,\"relationships\":{\"wife\":\"people[1]\",\"child\":\"people[4]\"}},\n        {\"name\":{\"family\":\"Flintstone\",\"given\":\"Wilma\"},\"age\":32,\"relationships\":{\"husband\":\"people[0]\",\"child\":\"people[4]\"}},\n        {\"name\":{\"family\":\"Rubble\",\"given\":\"Barnard\"},\"age\":30,\"relationships\":{\"wife\":\"people[3]\",\"child\":\"people[5]\"}},\n        {\"name\":{\"family\":\"Rubble\",\"given\":\"Elisabeth\"},\"age\":32,\"relationships\":{\"husband\":\"people[2]\",\"child\":\"people[5]\"}},\n        {\"name\":{\"family\":\"Flintstone\",\"given\":\"Pebbles\"},\"age\":1,\"relationships\":{\"mother\":\"people[1]\",\"father\":\"people[0]\"}},\n        {\"name\":{\"family\":\"Rubble\",\"given\":\"Bam-Bam\"},\"age\":1,\"relationships\":{\"mother\":\"people[3]\",\"father\":\"people[2]\"}},\n    ]\n}\n''')\n\n\nresult.each { println it.key; it.value.each {person -> println person} }\n\nassert result.people[0].name == [family:'Flintstone', given:'Frederick']\nassert result.people[4].age == 1\nassert result.people[2].relationships.wife == 'people[3]'\nassert result.people[3].name == [family:'Rubble', given:'Elisabeth']\nassert Eval.x(result, 'x.' + result.people[2].relationships.wife + '.name') == [family:'Rubble', given:'Elisabeth']\nassert Eval.x(result, 'x.' + result.people[1].relationships.husband + '.name') == [family:'Flintstone', given:'Frederick']\n\n\nOutput:\npeople\n[age:35, name:[given:Frederick, family:Flintstone], relationships:[child:people[4], wife:people[1]]]\n[age:32, name:[given:Wilma, family:Flintstone], relationships:[child:people[4], husband:people[0]]]\n[age:30, name:[given:Barnard, family:Rubble], relationships:[child:people[5], wife:people[3]]]\n[age:32, name:[given:Elisabeth, family:Rubble], relationships:[child:people[5], husband:people[2]]]\n[age:1, name:[given:Pebbles, family:Flintstone], relationships:[mother:people[1], father:people[0]]]\n[age:1, name:[given:Bam-Bam, family:Rubble], relationships:[mother:people[3], father:people[2]]]\n", "explain": "Solution requires Groovy 1.8 or later.\nNote that JsonSlurper accepts an extra comma such as [1,2,3,].  This is an extension to the [JSON grammar].\nTest:\n"}]