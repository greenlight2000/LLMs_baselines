[{"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Python", "code": "\n\ndata = [\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.10',\n    '1.3.6.1.4.1.11.2.17.5.2.0.79',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.4',\n    '1.3.6.1.4.1.11150.3.4.0.1',\n    '1.3.6.1.4.1.11.2.17.19.3.4.0.1',\n    '1.3.6.1.4.1.11150.3.4.0'\n]\n\nfor s in sorted(data, key=lambda x: list(map(int, x.split('.')))):\n    print(s)\n\n", "explain": "We need to split the input and map each part to int otherwise elements gets compared as a string\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\ntypedef struct oid_tag {\n    char* str_;\n    int* numbers_;\n    int length_;\n} oid;\n\n// free memory, no-op if p is null\nvoid oid_destroy(oid* p) {\n    if (p != 0) {\n        free(p->str_);\n        free(p->numbers_);\n        free(p);\n    }\n}\n\nint char_count(const char* str, char ch) {\n    int count = 0;\n    for (const char* p = str; *p; ++p) {\n        if (*p == ch)\n            ++count;\n    }\n    return count;\n}\n\n// construct an OID from a string\n// returns 0 on memory allocation failure or parse error\noid* oid_create(const char* str) {\n    oid* ptr = calloc(1, sizeof(oid));\n    if (ptr == 0)\n        return 0;\n    ptr->str_ = strdup(str);\n    if (ptr->str_ == 0) {\n        oid_destroy(ptr);\n        return 0;\n    }\n    int dots = char_count(str, '.');\n    ptr->numbers_ = malloc(sizeof(int) * (dots + 1));\n    if (ptr->numbers_ == 0) {\n        oid_destroy(ptr);\n        return 0;\n    }\n    ptr->length_ = dots + 1;\n    const char* p = str;\n    for (int i = 0; i <= dots && *p;) {\n        char* eptr = 0;\n        int num = strtol(p, &eptr, 10);\n        if (*eptr != 0 && *eptr != '.') {\n            // TODO: check for overflow/underflow\n            oid_destroy(ptr);\n            return 0;\n        }\n        ptr->numbers_[i++] = num;\n        p = eptr;\n        if (*p)\n            ++p;\n    }\n    return ptr;\n}\n\n// compare two OIDs\nint oid_compare(const void* p1, const void* p2) {\n    const oid* o1 = *(oid* const*)p1;\n    const oid* o2 = *(oid* const*)p2;\n    int i1 = 0, i2 = 0;\n    for (; i1 < o1->length_ && i2 < o2->length_; ++i1, ++i2) {\n        if (o1->numbers_[i1] < o2->numbers_[i2])\n            return -1;\n        if (o1->numbers_[i1] > o2->numbers_[i2])\n            return 1;\n    }\n    if (o1->length_ < o2->length_)\n        return -1;\n    if (o1->length_ > o2->length_)\n        return 1;\n    return 0;\n}\n\nint main() {\n    const char* input[] = {\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n        \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n        \"1.3.6.1.4.1.11150.3.4.0.1\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n        \"1.3.6.1.4.1.11150.3.4.0\"\n    };\n    const int len = sizeof(input)/sizeof(input[0]);\n    oid* oids[len];\n    memset(oids, 0, sizeof(oids));\n    int i;\n    for (i = 0; i < len; ++i) {\n        oids[i] = oid_create(input[i]);\n        if (oids[i] == 0)\n        {\n            fprintf(stderr, \"Out of memory\\n\");\n            goto cleanup;\n        }\n    }\n    qsort(oids, len, sizeof(oid*), oid_compare);\n    for (i = 0; i < len; ++i)\n        puts(oids[i]->str_);\ncleanup:\n    for (i = 0; i < len; ++i)\n        oid_destroy(oids[i]);\n    return 0;\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": "A C99 (or later) compiler is required.\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "C++", "code": "\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <boost/tokenizer.hpp>\n#include <iostream>\n\nstd::vector<std::string> splitOnChar ( std::string & s , const char c ) {\n   typedef boost::tokenizer<boost::char_separator<char>> tokenizer ;\n   std::vector<std::string> parts ;\n   boost::char_separator<char> sep( &c ) ;\n   tokenizer tokens( s , sep ) ;\n   for ( auto it = tokens.begin( ) ; it != tokens.end( ) ; it++ ) \n      parts.push_back( *it ) ;\n   return parts ;\n}\n\nbool myCompare ( const std::string & s1 , const std::string & s2 ) {\n   std::string firstcopy( s1 ) ;\n   std::string secondcopy ( s2 ) ;\n   std::vector<std::string> firstparts( splitOnChar ( firstcopy, '.' ) ) ;\n   std::vector<std::string> secondparts( splitOnChar ( secondcopy, '.' ) ) ;\n   std::vector<int> numbers1( firstparts.size( ) ) ;\n   std::vector<int> numbers2( secondparts.size( ) ) ;\n   std::transform( firstparts.begin( ) , firstparts.end( ) , numbers1.begin( ) ,\n\t []( std::string st ) { return std::stoi( st , nullptr ) ; } ) ;\n   std::transform( secondparts.begin( ) , secondparts.end( ) , numbers2.begin( ) ,\n\t []( std::string st ) { return std::stoi( st , nullptr ) ; } ) ;\n   auto it1 = numbers1.begin( ) ;\n   auto it2 = numbers2.begin( ) ;\n   while ( *it1 == *it2 ) {\n      it1++ ;\n      it2++ ;\n   }\n   if ( it1 == numbers1.end( )  || it2 == numbers2.end( )  )\n      return std::lexicographical_compare( s1.begin( ) , s1.end( ) , s2.begin( ) , s2.end( ) ) ;\n   return *it1 < *it2 ;\n}\n\nint main( ) {\n   std::vector<std::string> arrayOID { \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\" ,\n      \"1.3.6.1.4.1.11.2.17.5.2.0.79\" ,\n      \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\" ,\n      \"1.3.6.1.4.1.11150.3.4.0.1\" ,\n      \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\" ,\n      \"1.3.6.1.4.1.11150.3.4.0\" } ;\n   std::sort( arrayOID.begin( ) , arrayOID.end( ) , myCompare ) ;\n   for ( std::string s : arrayOID ) \n      std::cout << s << '\\n' ;\n   return 0 ;\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n\n", "explain": "\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Java", "code": "\nWorks with: Java version 8 or higher\npackage com.rosettacode;\n\nimport java.util.Comparator;\nimport java.util.stream.Stream;\n\npublic class OIDListSorting {\n\n    public static void main(String[] args) {\n\n        final String dot = \"\\\\.\";\n\n        final Comparator<String> oids_comparator = (o1, o2) -> {\n            final String[] o1Numbers = o1.split(dot), o2Numbers = o2.split(dot);\n            for (int i = 0; ; i++) {\n                if (i == o1Numbers.length && i == o2Numbers.length)\n                    return 0;\n                if (i == o1Numbers.length)\n                    return -1;\n                if (i == o2Numbers.length)\n                    return 1;\n                final int nextO1Number = Integer.valueOf(o1Numbers[i]), nextO2Number = Integer.valueOf(o2Numbers[i]);\n                final int result = Integer.compare(nextO1Number, nextO2Number);\n                if (result != 0)\n                    return result;\n            }\n        };\n\n        Stream.of(\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n                  \"1.3.6.1.4.1.11150.3.4.0.1\", \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \"1.3.6.1.4.1.11150.3.4.0\")\n                .sorted(oids_comparator)\n                .forEach(System.out::println);\n    }\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "C#", "code": "\nusing System;\nusing System.Linq;\nusing System.Collections.Generic;\n\npublic class Program\n{\n    public static void Main() {\n        var oids = new [] {\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n            \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n            \"1.3.6.1.4.1.11150.3.4.0.1\",\n            \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n            \"1.3.6.1.4.1.11150.3.4.0\"\n        };\n\n        var comparer = Comparer<string>.Create((a, b) => {\n            int c = a.Split('.').Select(int.Parse)\n\t        .Zip(b.Split('.').Select(int.Parse),\n                    (i, j) => i.CompareTo(j)).FirstOrDefault(x => x != 0);\n            return c != 0 ? c : a.Length.CompareTo(b.Length);\n        });\n\n        Array.Sort(oids, comparer);\n\n        Console.WriteLine(string.Join(Environment.NewLine, oids));\n    }\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"log\"\n    \"math/big\"\n    \"sort\"\n    \"strings\"\n)\n\nvar testCases = []string{\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n    \"1.3.6.1.4.1.11150.3.4.0.1\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n    \"1.3.6.1.4.1.11150.3.4.0\",\n}\n\n// a parsed representation\ntype oid []big.Int\n\n// \"constructor\" parses string representation\nfunc newOid(s string) oid {\n    ns := strings.Split(s, \".\")\n    os := make(oid, len(ns))\n    for i, n := range ns {\n        if _, ok := os[i].SetString(n, 10); !ok || os[i].Sign() < 0 {\n            return nil\n        }\n    }\n    return os\n}\n\n// \"stringer\" formats into string representation\nfunc (o oid) String() string {\n    s := make([]string, len(o))\n    for i, n := range o {\n        s[i] = n.String()\n    }\n    return strings.Join(s, \".\")\n}\n\nfunc main() {\n    // parse test cases\n    os := make([]oid, len(testCases))\n    for i, s := range testCases {\n        os[i] = newOid(s)\n        if os[i] == nil {\n            log.Fatal(\"invalid OID\")\n        }\n    }\n    // sort\n    sort.Slice(os, func(i, j int) bool {\n        // \"less\" function must return true if os[i] < os[j]\n        oi := os[i]\n        for x, v := range os[j] {\n            // lexicographic defintion: less if prefix or if element is <\n            if x == len(oi) || oi[x].Cmp(&v) < 0 {\n                return true\n            }\n            if oi[x].Cmp(&v) > 0 {\n                break\n            }\n        }\n        return false\n    })\n    // output sorted list\n    for _, o := range os {\n        fmt.Println(o)\n    }\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Ruby", "code": "\n%w[\n  1.3.6.1.4.1.11.2.17.19.3.4.0.10\n  1.3.6.1.4.1.11.2.17.5.2.0.79\n  1.3.6.1.4.1.11.2.17.19.3.4.0.4\n  1.3.6.1.4.1.11150.3.4.0.1\n  1.3.6.1.4.1.11.2.17.19.3.4.0.1\n  1.3.6.1.4.1.11150.3.4.0\n]\n.sort_by{|oid| oid.split(\".\").map(&:to_i)}\n.each{|oid| puts oid}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n\nputs %w[\n  1.3.6.1.4.1.11.2.17.19.3.4.0.10\n  1.3.6.1.4.1.11.2.17.5.2.0.79\n  1.3.6.1.4.1.11.2.17.19.3.4.0.4\n  1.3.6.1.4.1.11150.3.4.0.1\n  1.3.6.1.4.1.11.2.17.19.3.4.0.1\n  1.3.6.1.4.1.11150.3.4.0\n].sort_by{|oid| Gem::Version.new(oid) }\n\n\n", "explain": "Or, using the Gem module (which knows about versions):\nwith identical output.\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Rust", "code": "\nfn split(s: &str) -> impl Iterator<Item = u64> + '_ {\n    s.split('.').map(|x| x.parse().unwrap())\n}\n\nfn main() {\n    let mut oids = vec![\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n        \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n        \"1.3.6.1.4.1.11150.3.4.0.1\",\n        \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n        \"1.3.6.1.4.1.11150.3.4.0\",\n    ];\n\n    oids.sort_by(|a, b| Iterator::cmp(split(a), split(b)));\n    \n    println!(\"{:#?}\", oids);\n}\n\n\nOutput:\n[\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n    \"1.3.6.1.4.1.11150.3.4.0\",\n    \"1.3.6.1.4.1.11150.3.4.0.1\"\n]\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Swift", "code": "\nimport Foundation\n\npublic struct OID {\n  public var val: String\n\n  public init(_ val: String) {\n    self.val = val\n  }\n}\n\nextension OID: CustomStringConvertible {\n  public var description: String {\n    return val\n  }\n}\n\nextension OID: Comparable {\n  public static func < (lhs: OID, rhs: OID) -> Bool {\n    let split1 = lhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let split2 = rhs.val.components(separatedBy: \".\").compactMap(Int.init)\n    let minSize = min(split1.count, split2.count)\n\n    for i in 0..<minSize {\n      if split1[i] < split2[i] {\n        return true\n      } else if split1[i] > split2[i] {\n        return false\n      }\n    }\n\n    return split1.count < split2.count\n  }\n\n  public static func == (lhs: OID, rhs: OID) -> Bool {\n    return lhs.val == rhs.val\n  }\n}\n\nlet ids = [\n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", \n  \"1.3.6.1.4.1.11.2.17.5.2.0.79\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\", \n  \"1.3.6.1.4.1.11150.3.4.0.1\", \n  \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", \n  \"1.3.6.1.4.1.11150.3.4.0\"\n].map(OID.init)\n\nfor id in ids.sorted() {\n  print(id)\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Ada", "code": "\nWorks with: Ada version 2012\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Strings.Fixed;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;\nwith Ada.Unchecked_Deallocation;\n\nprocedure Sort_List_Identifiers is\n   type Natural_Array is array (Positive range <>) of Natural;\n   type Unbounded_String_Array is array(Positive range <>) of Unbounded_String;\n\n   function To_Natural_Array(input : in String) return Natural_Array\n   is\n      target : Natural_Array(1 .. Ada.Strings.Fixed.Count(input, \".\") + 1);\n      from : Natural := input'First;\n      to : Natural := Ada.Strings.Fixed.Index(input, \".\");\n      index : Positive := target'First;\n   begin\n      while to /= 0 loop\n         target(index) := Natural'Value(input(from .. to - 1));\n         from := to + 1;\n         index := index + 1;\n         to := Ada.Strings.Fixed.Index(input, \".\", from);\n      end loop;\n      target(index) := Natural'Value(input(from .. input'Last));\n      return target;\n   end To_Natural_Array;\n\n   function Lesser(Left, Right : in Unbounded_String) return Boolean is\n   begin\n      return To_Natural_Array(To_String(Left)) < To_Natural_Array(To_String(Right));\n   end Lesser;\n\n   procedure Sort is new Ada.Containers.Generic_Array_Sort\n     (Index_Type   => Positive,\n      Element_Type => Unbounded_String,\n      Array_Type   => Unbounded_String_Array,\n      \"<\"          => Lesser);\n\n   table : Unbounded_String_Array :=\n     (To_Unbounded_String(\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\"),\n      To_Unbounded_String(\"1.3.6.1.4.1.11.2.17.5.2.0.79\"),\n      To_Unbounded_String(\"1.3.6.1.4.1.11.2.17.19.3.4.0.4\"),\n      To_Unbounded_String(\"1.3.6.1.4.1.11150.3.4.0.1\"),\n      To_Unbounded_String(\"1.3.6.1.4.1.11.2.17.19.3.4.0.1\"),\n      To_Unbounded_String(\"1.3.6.1.4.1.11150.3.4.0\"));\nbegin\n   Sort(table);\n   for element of table loop\n      Ada.Text_IO.Put_Line(To_String(element));\n   end loop;\nend Sort_List_Identifiers;\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\noidlist = [\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n           \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n           \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n           \"1.3.6.1.4.1.11150.3.4.0.1\",\n           \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n           \"1.3.6.1.4.1.11150.3.4.0\"]\n\nsort!(oidlist; lt=lexless,\n    by=x -> parse.(Int, String.(split(x, \".\"))))\nprintln.(oidlist)\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nclass Oid(val id: String): Comparable<Oid> {\n    override fun compareTo(other: Oid): Int {\n        val splits1 = this.id.split('.')\n        val splits2 = other.id.split('.')\n        val minSize = if (splits1.size < splits2.size) splits1.size else splits2.size\n        for (i in 0 until minSize) {\n            if (splits1[i].toInt() < splits2[i].toInt()) return -1\n            else if (splits1[i].toInt() > splits2[i].toInt()) return 1\n        }\n        return splits1.size.compareTo(splits2.size)\n    }\n\n    override fun toString() = id\n}\n\nfun main(args: Array<String>) {\n    val oids = arrayOf(\n        Oid(\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\"),\n        Oid(\"1.3.6.1.4.1.11.2.17.5.2.0.79\"),\n        Oid(\"1.3.6.1.4.1.11.2.17.19.3.4.0.4\"),\n        Oid(\"1.3.6.1.4.1.11150.3.4.0.1\"),\n        Oid(\"1.3.6.1.4.1.11.2.17.19.3.4.0.1\"),\n        Oid(\"1.3.6.1.4.1.11150.3.4.0\")\n    )\n    println(oids.sorted().joinToString(\"\\n\"))\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Perl", "code": "\nmy @OIDs = qw(\n    1.3.6.1.4.1.11.2.17.19.3.4.0.10\n    1.3.6.1.4.1.11.2.17.5.2.0.79\n    1.3.6.1.4.1.11.2.17.19.3.4.0.4\n    1.3.6.1.4.1.11150.3.4.0.1\n    1.3.6.1.4.1.11.2.17.19.3.4.0.1\n    1.3.6.1.4.1.11150.3.4.0\n);\n\nmy @sorted =\n    map { $_->[0] }\n    sort { $a->[1] cmp $b->[1] }\n    map { [$_, join '', map { sprintf \"%8d\", $_ } split /\\./, $_] }\n    @OIDs;\n\nprint \"$_\\n\" for @sorted;\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n\nmy @sorted =\n    map { $_->[0] }\n    sort { $a->[1] cmp $b->[1] }\n    map { [$_, eval \"v$_\"] }\n    @OIDs;\n\n", "explain": "Alternately, you can sort them as \"version strings\", which is a Perl syntax allowing you to specify a character string in the source code with the characters' codes specified as a dot-delimited sequence of integers.\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nmain:-\n    sort_oid_list([\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n    \"1.3.6.1.4.1.11150.3.4.0.1\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n    \"1.3.6.1.4.1.11150.3.4.0\"], Sorted_list),\n    foreach(member(oid(_, Oid), Sorted_list), writeln(Oid)).\n\nsort_oid_list(Oid_list, Sorted_list):-\n    parse_oid_list(Oid_list, Parsed),\n    sort(1, @=<, Parsed, Sorted_list).\n\nparse_oid_list([], []):-!.\nparse_oid_list([Oid|Oid_list], [oid(Numbers, Oid)|Parsed]):-\n    parse_oid(Oid, Numbers),\n    parse_oid_list(Oid_list, Parsed).\n\nparse_oid(Oid, Numbers):-\n    split_string(Oid, \".\", \".\", Strings),\n    number_strings(Numbers, Strings).\n\nnumber_strings([], []):-!.\nnumber_strings([Number|Numbers], [String|Strings]):-\n    number_string(Number, String),\n    number_strings(Numbers, Strings).\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Lua", "code": "\n\nlocal OIDs = {\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n    \"1.3.6.1.4.1.11150.3.4.0.1\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n    \"1.3.6.1.4.1.11150.3.4.0\"\n}\n \nfunction compare (a, b)\n    local aList, bList, Na, Nb = {}, {}\n    for num in a:gmatch(\"%d+\") do table.insert(aList, num) end\n    for num in b:gmatch(\"%d+\") do table.insert(bList, num) end\n    for i = 1, math.max(#aList, #bList) do\n        Na, Nb = tonumber(aList[i]) or 0, tonumber(bList[i]) or 0\n        if Na ~= Nb then return Na < Nb end\n    end\nend\n \ntable.sort(OIDs, compare)\nfor _, oid in pairs(OIDs) do print(oid) end\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\nUsing Coroutine[edit]\nlocal function oidGen(s)\n  local wrap, yield = coroutine.wrap, coroutine.yield\n  return wrap(function()\n    for n in s:gmatch\"%d+\"do yield(tonumber(n))end\n  end)\nend\n\nlocal function oidCmp(a,b)\n  local agen,bgen = oidGen(a),oidGen(b)\n  local n,m = agen(),bgen()\n  while n and m do\n    if n~=m then return n<m end\n    n,m = agen(),bgen()\n  end\n  return m and true or false -- bgen longer with previous equal\nend\n\nlocal OIDs = {\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\",\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\",\n    \"1.3.6.1.4.1.11150.3.4.0.1\",\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\",\n    \"1.3.6.1.4.1.11150.3.4.0\"\n}\n \ntable.sort(OIDs, oidCmp)\nfor _, oid in pairs(OIDs) do print(oid) end\n\n", "explain": "Using the in-built table.sort with a custom compare function.\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "Haskell", "code": "\nData.List[edit]\nimport Data.List ( sort , intercalate ) \n\nsplitString :: Eq a => (a) -> [a] -> [[a]]\nsplitString c [] = []\nsplitString c s = let ( item , rest ) = break ( == c ) s\n                      ( _ , next ) = break ( /= c ) rest\n\t\t  in item : splitString c next\n\nconvertIntListToString :: [Int] -> String\nconvertIntListToString = intercalate \".\" . map show\n\norderOID :: [String] -> [String]\norderOID = map convertIntListToString . sort . map ( map read . splitString '.' )\n\noid :: [String]\noid = [\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\" ,\n    \"1.3.6.1.4.1.11.2.17.5.2.0.79\" ,\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\" ,\n    \"1.3.6.1.4.1.11150.3.4.0.1\" ,\n    \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\" ,\n    \"1.3.6.1.4.1.11150.3.4.0\"]\n\nmain :: IO ( )\nmain = do\n   mapM_ putStrLn $ orderOID oid\n\n\nOutput:\n3.6.1.4.1.11.2.17.5.2.0.79\n3.6.1.4.1.11.2.17.19.3.4.0.1\n3.6.1.4.1.11.2.17.19.3.4.0.4\n3.6.1.4.1.11.2.17.19.3.4.0.10\n3.6.1.4.1.11150.3.4.0\n3.6.1.4.1.11150.3.4.0.1\n\nData.Text[edit]\n\nimport Data.Text (pack, split, unpack)\nimport Data.List (sort, intercalate)\n\n-- SORTING OBJECT IDENTIFIERS ------------------------------------------------\noidSort :: [String] -> [String]\noidSort =\n  fmap (intercalate \".\" . fmap show) .\n  sort . fmap (fmap readInt . splitString '.')\n\n-- GENERIC FUNCTIONS ---------------------------------------------------------\nsplitString :: Char -> String -> [String]\nsplitString c s = unpack <$> split (c ==) (pack s)\n\nreadInt :: String -> Int\nreadInt xs = read xs :: Int\n\n-- TEST ----------------------------------------------------------------------\nmain :: IO ()\nmain =\n  mapM_ putStrLn $\n  oidSort\n    [ \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\"\n    , \"1.3.6.1.4.1.11.2.17.5.2.0.79\"\n    , \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\"\n    , \"1.3.6.1.4.1.11150.3.4.0.1\"\n    , \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\"\n    , \"1.3.6.1.4.1.11150.3.4.0\"\n    ]\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\nimport Data.List.Split (splitOn)\nimport Data.List (sort, intercalate)\n\n-- SORTING OBJECT IDENTIFIERS ------------------------------------------------\noidSort :: [String] -> [String]\noidSort =\n  fmap (intercalate \".\" . fmap show) . sort . fmap (fmap readInt . splitOn \".\")\n\nreadInt :: String -> Int\nreadInt x = read x :: Int\n\n", "explain": "(To use split\u00a0:: (Char -> Bool) -> Text -> [Text] in the standard libraries, we would have to temporarily convert the strings from [Char] to Text with pack and unpack)\nWhere Data.List.Split is available (https://hackage.haskell.org/package/split-0.2.3.1/docs/Data-List-Split.html)\nwe can alternatively write:\n"}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "VBScript", "code": "\n' Sort a list of object identifiers - VBScript\nfunction myCompare(x,y)\n\tdim i,b\n\tsx=split(x,\".\")\n\tsy=split(y,\".\")\n\tb=false\n\tfor i=0 to ubound(sx)\n\t\tif i > ubound(sy) then b=true: exit for\n\t\tselect case sgn(int(sx(i))-int(sy(i)))\n\t\t\tcase  1: b=true:  exit for\n\t\t\tcase -1: b=false: exit for\n\t\tend select\n\tnext\n\tmyCompare=b\nend function\n\nfunction bubbleSort(t)\n\tdim i,n\n\tn=ubound(t) \n\tdo\n\t\tchanged=false\n\t\tn= n-1\n\t\tfor i=0 to n\n\t\t\tif myCompare(t(i),t(i+1)) then\n\t\t\t\ttmp=t(i): t(i)=t(i+1): t(i+1)=tmp\n\t\t\t\tchanged=true\n\t\t\tend if\n\t\tnext\n\tloop until not changed\n\tbubbleSort=t\nend function\n \na=array( _\n\t\"1.3.6.1.4.1.11.2.17.19.3.4.0.10\", _\n\t\"1.3.6.1.4.1.11.2.17.5.2.0.79\", _\n\t\"1.3.6.1.4.1.11.2.17.19.3.4.0.4\", _\n\t\"1.3.6.1.4.1.11150.3.4.0.1\", _\n\t\"1.3.6.1.4.1.11.2.17.19.3.4.0.1\", _\n\t\"1.3.6.1.4.1.11150.3.4.0\")\nbubbleSort a\nwscript.echo join(a,vbCrlf)\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}, {"task_name": "Sort a list of object identifiers", "task_url": "https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers", "task_cat": "Sorting", "lang": "AWK", "code": "\n# syntax: GAWK -f SORT_A_LIST_OF_OBJECT_IDENTIFIERS.AWK\n#\n# sorting:\n#   PROCINFO[\"sorted_in\"] is used by GAWK\n#   SORTTYPE is used by Thompson Automation's TAWK\n#\nBEGIN {\n    width = 10\n    oid_arr[++n] = \"1.3.6.1.4.1.11.2.17.19.3.4.0.10\"\n    oid_arr[++n] = \"1.3.6.1.4.1.11.2.17.5.2.0.79\"\n    oid_arr[++n] = \"1.3.6.1.4.1.11.2.17.19.3.4.0.4\"\n    oid_arr[++n] = \"1.3.6.1.4.1.11150.3.4.0.1\"\n    oid_arr[++n] = \"1.3.6.1.4.1.11.2.17.19.3.4.0.1\"\n    oid_arr[++n] = \"1.3.6.1.4.1.11150.3.4.0\"\n#   oid_arr[++n] = \"1.11111111111.1\" # un-comment to test error\n    for (i=1; i<=n; i++) {\n      str = \"\"\n      for (j=1; j<=split(oid_arr[i],arr2,\".\"); j++) {\n        str = sprintf(\"%s%*s.\",str,width,arr2[j])\n        if ((leng = length(arr2[j])) > width) {\n          printf(\"error: increase sort key width from %d to %d for entry %s\\n\",width,leng,oid_arr[i])\n          exit(1)\n        }\n      }\n      arr3[str] = \"\"\n    }\n    PROCINFO[\"sorted_in\"] = \"@ind_str_asc\" ; SORTTYPE = 1\n    for (i in arr3) {\n      str = i\n      gsub(/ /,\"\",str)\n      sub(/\\.$/,\"\",str)\n      printf(\"%s\\n\",str)\n    }\n    exit(0)\n}\n\n\nOutput:\n1.3.6.1.4.1.11.2.17.5.2.0.79\n1.3.6.1.4.1.11.2.17.19.3.4.0.1\n1.3.6.1.4.1.11.2.17.19.3.4.0.4\n1.3.6.1.4.1.11.2.17.19.3.4.0.10\n1.3.6.1.4.1.11150.3.4.0\n1.3.6.1.4.1.11150.3.4.0.1\n\n", "explain": ""}]