[{"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Python", "code": "\n\nimport shutil\nshutil.copyfile('input.txt', 'output.txt')\n\ninfile = open('input.txt', 'r')\noutfile = open('output.txt', 'w')\nfor line in infile:\n   outfile.write(line)\noutfile.close()\ninfile.close()\n\nimport sys\ntry:\n    infile = open('input.txt', 'r')\nexcept IOError:\n    print >> sys.stderr, \"Unable to open input.txt for input\"\n    sys.exit(1)\ntry:\n    outfile = open('output.txt', 'w')\nexcept IOError:\n    print >> sys.stderr, \"Unable to open output.txt for output\"\n    sys.exit(1)\ntry:  # for finally\n    try: # for I/O\n        for line in infile:\n            outfile.write(line)\n    except IOError, e:\n        print >> sys.stderr, \"Some I/O Error occurred (reading from input.txt or writing to output.txt)\"\nfinally:\n    infile.close()\n    outfile.close()\n\nimport sys\ntry:\n    with open('input.txt') as infile:\n        with open('output.txt', 'w') as outfile:\n            for line in infile:\n                outfile.write(line)\nexcept IOError:\n    print >> sys.stderr, \"Some I/O Error occurred\"\n    sys.exit(1)\n\n", "explain": "The following use of the standard libraries shutil.copyfile is to be preferred. (Current source code ensures that failure to open files raises appropriate exceptions, a restricted buffer is used to copy the files using binary mode, and any used file descriptors are always closed).\nHowever the following example shows how one would do file I/O of other sorts:\nThis does no error checking.  A more robust program would wrap each open with exception handling blocks:\nIn Python 2.6 (or 2.5 if we use from __future__ import with_statement) we can more simply write:\nThe files will automatically be closed on exit of their with: blocks.  (Thus even if an I/O error occurred while reading the middle of the input file we are assured that the .close() method will have been called on each of the two files.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "C", "code": "\n#include <stdio.h>\n\nint main(int argc, char **argv) {\n  FILE *in, *out;\n  int c;\n\n  in = fopen(\"input.txt\", \"r\");\n  if (!in) {\n    fprintf(stderr, \"Error opening input.txt for reading.\\n\");\n    return 1;\n  }\n\n  out = fopen(\"output.txt\", \"w\");\n  if (!out) {\n    fprintf(stderr, \"Error opening output.txt for writing.\\n\");\n    fclose(in);\n    return 1;\n  }\n\n  while ((c = fgetc(in)) != EOF) {\n    fputc(c, out);\n  }\n\n  fclose(out);\n  fclose(in);\n  return 0;\n}\n\n\nWorks with: POSIX\n#include <unistd.h>\n#include <fcntl.h>\n#include <sys/types.h>\n#include <sys/stat.h>\n\n/* we just return a yes/no status; caller can check errno */\nint copy_file(const char *in, const char *out)\n{\n\tint ret = 0;\n\tint fin, fout;\n\tssize_t len;\n\tchar *buf[4096]; /* buffer size, some multiple of block size preferred */\n\tstruct stat st;\n\n\tif ((fin  = open(in,  O_RDONLY)) == -1) return 0;\n\tif (fstat(fin, &st)) goto bail;\n\n\t/* open output with same permission */\n\tfout = open(out, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777);\n\tif (fout == -1) goto bail;\n\n\twhile ((len = read(fin, buf, 4096)) > 0)\n\t\twrite(fout, buf, len);\n\n\tret = len ? 0 : 1; /* last read should be 0 */\n\nbail:\tif (fin != -1)  close(fin);\n\tif (fout != -1) close(fout);\n\treturn ret;\n}\n\nint main()\n{\n\tcopy_file(\"infile\", \"outfile\");\n\treturn 0;\n}\n\nIf it's certain that mapping the whole input file into memory poses no problem (there can be all kinds of problems), this may be the most efficient:int copy_file(const char *in, const char *out)\n{\n\tint ret = 0;\n\tint fin, fout;\n\tchar *bi;\n\tstruct stat st;\n\n\tif ((fin  = open(in,  O_RDONLY)) == -1) return 0;\n\tif (fstat(fin, &st)) goto bail;\n\n\tfout = open(out, O_WRONLY|O_CREAT|O_TRUNC, st.st_mode & 0777);\n\tif (fout == -1) goto bail;\n\n\tbi = mmap(0, st.st_size, PROT_READ, MAP_PRIVATE, fin,  0);\n\n\tret = (bi == (void*)-1)\n\t\t? 0 : (write(fout, bi, st.st_size) == st.st_size);\n\nbail:\tif (fin != -1)  close(fin);\n\tif (fout != -1) close(fout);\n\tif (bi != (void*)-1) munmap(bi, st.st_size);\n\treturn ret;\n}\n\n", "explain": "A couple of remarks on the preceding example:\nIt uses fgetc to read one character at a time. Each character is visited, even though there's nothing to do with it. Copying bigger blocks of data is much more efficient.\nThe following example addresses those issues. To avoid buffered I/O, it uses open(), read(), write() and close(), which are part of POSIX.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "C++", "code": "\nWorks with: g++ version 3.4.2\n#include <iostream>\n#include <fstream>\n#include <string>\n\nusing namespace std;\n\nint main() {\n    string line;\n    ifstream input ( \"input.txt\" );\n    ofstream output (\"output.txt\");\n    \n    if (output.is_open()) {\n        if (input.is_open()){\n            while (getline (input,line)) {\n                output << line << endl;\n            }\n            input.close(); // Not necessary - will be closed when variable goes out of scope.\n        }\n        else {\n            cout << \"input.txt cannot be opened!\\n\";\n        }\n        output.close(); // Not necessary - will be closed when variable goes out of scope.\n    }\n    else {\n        cout << \"output.txt cannot be written to!\\n\";\n    }\n    return 0;\n}\n\n\n#include <iostream>\n#include <fstream>\n#include <cstdlib>\n\nint main()\n{\n  std::ifstream input(\"input.txt\");\n  if (!input.is_open())\n  {\n    std::cerr << \"could not open input.txt for reading.\\n\";\n    return EXIT_FAILURE;\n  }\n  \n  std::ofstream output(\"output.txt\");\n  if (!output.is_open())\n  {\n    std::cerr << \"could not open output.txt for writing.\\n\";\n    return EXIT_FAILURE;\n  }\n  \n  output << input.rdbuf();\n  if (!output)\n  {\n    std::cerr << \"error copying the data.\\n\";\n    return EXIT_FAILURE;\n  }\n  \n  return EXIT_SUCCESS;\n}\n\n\n# include <algorithm>\n# include <fstream>\n\nint main() {\n  std::ifstream ifile(\"input.txt\");\n  std::ofstream ofile(\"output.txt\");\n  std::copy(std::istreambuf_iterator<char>(ifile),\n            std::istreambuf_iterator<char>(),\n            std::ostreambuf_iterator<char>(ofile));\n}\n\n\n#include <fstream>\n\nint main()\n{\n  std::ifstream input(\"input.txt\");\n  std::ofstream output(\"output.txt\");\n  output << input.rdbuf();\n}\n\n", "explain": "Simpler version:\nUsing istream- and ostream- iterators:\nEven simpler way:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Java", "code": "\nWorks with: GCJ version 4.1.2\n\nimport java.io.*;\n\npublic class FileIODemo {\n  public static void main(String[] args) {\n    try {\n      FileInputStream in = new FileInputStream(\"input.txt\");\n      FileOutputStream out = new FileOutputStream(\"ouput.txt\");\n      int c;\n      while ((c = in.read()) != -1) {\n        out.write(c);\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n\n\nimport java.io.*;\n\npublic class FileIODemo2 {\n  public static void main(String args[]) {\n    try {\n      // Probably should wrap with a BufferedInputStream\n      final InputStream in = new FileInputStream(\"input.txt\");\n      try {\n        // Probably should wrap with a BufferedOutputStream\n        final OutputStream out = new FileOutputStream(\"output.txt\");\n        try {\n          int c;\n          while ((c = in.read()) != -1) {\n            out.write(c);\n          }\n        }\n        finally {\n          out.close();\n        }\n      }\n      finally {\n        in.close();\n      }\n    } catch (FileNotFoundException e) {\n      e.printStackTrace();\n    } catch (IOException e){\n      e.printStackTrace();\n    }\n  }\n}\n\nWorks with: Java version 1.4\n\nimport java.io.*;\nimport java.nio.channels.*;\n\npublic class FileIODemo3 {\n  public static void main(String args[]) {\n    try {\n      final FileChannel in = new FileInputStream(\"input.txt\").getChannel();\n      try {\n        final FileChannel out = new FileOutputStream(\"output.txt\").getChannel();\n        try {\n          out.transferFrom(in, 0, in.size());\n        }\n        finally {\n          out.close();\n        }\n      }\n      finally {\n        in.close();\n      }\n    }\n    catch (Exception e) {\n      System.err.println(\"Exception while trying to copy: \"+e);\n      e.printStackTrace(); // stack trace of place where it happened\n    }\n  }\n}\n\n\nimport java.io.*;\npublic class Test {\n  public static void main (String[] args) throws IOException {\n    BufferedReader br = new BufferedReader(new FileReader(\"input.txt\"));\n    BufferedWriter bw = new BufferedWriter(new FileWriter(\"output.txt\"));\n    String line;\n    while ((line = br.readLine()) != null) {\n      bw.write(line);\n      bw.newLine();\n    }\n    br.close();\n    bw.close();\n  }\n}\n\nWorks with: Java version 7+\nimport java.nio.file.*;\npublic class Copy{\n   public static void main(String[] args) throws Exception{\n      FileSystem fs = FileSystems.getDefault();\n      Path in = fs.getPath(\"input.txt\");\n      Path out = fs.getPath(\"output.txt\");\n      Files.copy(in, out, StandardCopyOption.REPLACE_EXISTING);\n   }\n}\n\n", "explain": "Simple version; Files may be closed automatically by OS, on some systems.\nThis version closes both files after without OS intervention.\nPackage nio\nThis version is more in line with the other languages' implementations: it assumes simple text files, and doesn't worry too much about errors (just throws them out to the caller, the console in this case). It's shorter and simpler and shows that simple programs can be simple to write, in Java as well.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "C#", "code": "\n\nusing System.IO;\n\nusing (var reader = new StreamReader(\"input.txt\"))\nusing (var writer = new StreamWriter(\"output.txt\"))\n{\n    var text = reader.ReadToEnd();\n    writer.Write(text);\n}\n\n\nusing System.IO;\n\nvar text = File.ReadAllText(\"input.txt\");\nFile.WriteAllText(\"output.txt\", text);\n\n", "explain": "The long way:\nThe short way:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "JavaScript", "code": "\nWorks with: JScript\nvar fso = new ActiveXObject(\"Scripting.FileSystemObject\");\nvar ForReading = 1, ForWriting = 2;\nvar f_in = fso.OpenTextFile('input.txt', ForReading);\nvar f_out = fso.OpenTextFile('output.txt', ForWriting, true);\n\n// for small files: \n// f_out.Write( f_in.ReadAll() );\n\nwhile ( ! f_in.AtEndOfStream) {\n    // ReadLine() does not include the newline char\n    f_out.WriteLine( f_in.ReadLine() );\n}\n\nf_in.Close();\nf_out.Close();\n\n\nWorks with: Node.js\nvar fs = require('fs');\nrequire('util').pump(fs.createReadStream('input.txt', {flags:'r'}), fs.createWriteStream('output.txt', {flags:'w+'}));\n\n", "explain": "\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "PHP", "code": "\nWorks with: PHP version 4\n<?php\n\nif (!$in = fopen('input.txt', 'r')) {\n    die('Could not open input file.');\n}\n\nif (!$out = fopen('output.txt', 'w')) {\n    die('Could not open output file.');\n}\n\nwhile (!feof($in)) {\n    $data = fread($in, 512);\n    fwrite($out, $data);\n}\n\nfclose($out);\nfclose($in);\n?>\nWorks with: PHP version 5\n<?php\nif ($contents = file_get_contents('input.txt')) {\n    if (!file_put_contents('output.txt', $contents)) {\n        echo('Could not write output file.');\n    }\n} else {\n    echo('Could not open input file.');\n}\n?>\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Fortran", "code": "\nWorks with: Fortran version 2003\n\nprogram FileIO\n\n  integer, parameter :: out = 123, in = 124\n  integer :: err\n  character :: c\n\n  open(out, file=\"output.txt\", status=\"new\", action=\"write\", access=\"stream\", iostat=err)\n  if (err == 0) then\n     open(in, file=\"input.txt\", status=\"old\", action=\"read\", access=\"stream\", iostat=err)\n     if (err == 0) then\n        err = 0\n        do while (err == 0)\n           read(unit=in, iostat=err) c\n           if (err == 0) write(out) c\n        end do\n        close(in)\n     end if\n     close(out)\n  end if\n\nend program FileIO\n\n", "explain": "It uses the access=\"stream\" which is defined in Fortran 2003 standard and should allow to \"copy\" also binary data easily.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n)\n\nfunc main() {\n    b, err := ioutil.ReadFile(\"input.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    if err = ioutil.WriteFile(\"output.txt\", b, 0666); err != nil {\n        fmt.Println(err)\n    }\n}\n\n\npackage main\n\nimport (\n    \"io\"\n    \"log\"\n    \"os\"\n)\n\nfunc CopyFile(out, in string) (err error) {\n    var inf, outf *os.File\n    inf, err = os.Open(in)\n    if err != nil {\n        return\n    }\n    defer func() {\n        cErr := inf.Close()\n        if err == nil {\n            err = cErr\n        }\n    }()\n    outf, err = os.Create(out)\n    if err != nil {\n        return\n    }\n    _, err = io.Copy(outf, inf)\n    cErr := outf.Close()\n    if err == nil {\n        err = cErr\n    }\n    return\n}\n\nfunc main() {\n    if err := CopyFile(\"output.txt\", \"input.txt\"); err != nil {\n        log.Fatal(err)\n    }\n}\n\n", "explain": "Alternative solution is not a one-liner, but is one of \"secondary interest\" that copies data from one file to another without an intermediate variable.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program readwrtfile.s   */\n\n/*********************************************/\n/*constantes                                */\n/********************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ READ,   3\n.equ WRITE,  4\n.equ OPEN,   5\n.equ CLOSE,  6\n.equ CREATE,  8\n/*  file */\n.equ O_RDWR,\t0x0002\t\t@ open for reading and writing \n\n.equ TAILLEBUF,  1000\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessErreur: .asciz \"Erreur ouverture fichier input.\\n\"\nszMessErreur4: .asciz \"Erreur cr\u00e9ation fichier output.\\n\"\nszMessErreur1: .asciz \"Erreur fermeture fichier.\\n\"\nszMessErreur2: .asciz \"Erreur lecture fichier.\\n\"\nszMessErreur3: .asciz \"Erreur d'\u00e9criture dans fichier de sortie.\\n\"\nszRetourligne: .asciz  \"\\n\"\nszMessErr: .ascii\t\"Error code\u00a0: \"\nsDeci: .space 15,' '\n         .asciz \"\\n\"\n\nszNameFileInput:\t.asciz \"input.txt\"\nszNameFileOutput:\t.asciz \"output.txt\"\n\n/*******************************************/\n/* DONNEES NON INITIALISEES                */\n/*******************************************/ \n.bss\nsBuffer:  .skip TAILLEBUF \n\n/**********************************************/\n/* -- Code section                            */\n/**********************************************/\n.text            \n.global main    \nmain:\n    push {fp,lr}    /* save registers */\n\n    ldr r0,iAdrszNameFileInput   @ file name\n    mov r1,#O_RDWR                   @  flags   \n    mov r2,#0                         @ mode \n    mov r7,#OPEN                     @ call system OPEN\n    swi #0 \n    cmp r0,#0        @ open error\u00a0?\n    ble erreur\n    mov r8,r0               @ save File Descriptor\n    ldr r1,iAdrsBuffer   @ buffer address \n    mov r2,#TAILLEBUF     @ buffer size\n    mov r7, #READ          @ call system  READ\n    swi 0 \n    cmp r0,#0            @ read error\u00a0?\n    ble erreur2\n    mov r2,r0            @ length read characters\n\n    /* close imput file */\n    mov r0,r8     @ Fd  \n    mov r7, #CLOSE      @ call system CLOSE\n    swi 0 \n    cmp r0,#0            @ close error\u00a0?\n    blt erreur1\n\n    @ create output file \n    ldr r0,iAdrszNameFileOutput   @ file name\n    ldr r1,iFicMask1                 @ flags \n    mov r7, #CREATE                  @ call system create file\n    swi 0 \n    cmp r0,#0                         @ create error\u00a0?\n    ble erreur4\n    mov r0,r8                       @ file descriptor\n    ldr r1,iAdrsBuffer\n    @ et r2 contains the length to write \n    mov r7, #WRITE                 @ select system call 'write'\n    swi #0                        @ perform the system call \n    cmp r0,#0                      @ error write\u00a0?\n    blt erreur3\n\n    @ close output file \n    mov r0,r8    @ Fd  fichier \n    mov r7, #CLOSE    @  call system CLOSE\n    swi #0 \n    cmp r0,#0      @ error close\u00a0?\n    blt erreur1\n    mov r0,#0     @ return code OK\n    b 100f\nerreur:\n    ldr r1,iAdrszMessErreur \n    bl   afficheerreur   \n    mov r0,#1       @ error return code\n    b 100f\nerreur1:\t\n    ldr r1,iAdrszMessErreur1   \n    bl   afficheerreur  \n    mov r0,#1       @ error return code\n    b 100f\nerreur2:\n    ldr r1,iAdrszMessErreur2   \n    bl   afficheerreur  \n    mov r0,#1       @ error return code\n    b 100f\nerreur3:\n    ldr r1,iAdrszMessErreur3   \n    bl   afficheerreur  \n    mov r0,#1       @ error return code\n    b 100f\nerreur4:\n    ldr r1,iAdrszMessErreur4\n    bl   afficheerreur   \n    mov r0,#1       @ error return code\n    b 100f\n\n100:\t\t@ end program\n    pop {fp,lr}   /* restaur des  2 registres */\n    mov r7, #EXIT /* appel fonction systeme pour terminer */\n    swi 0 \niAdrszNameFileInput:\t.int szNameFileInput\niAdrszNameFileOutput:\t.int szNameFileOutput\niAdrszMessErreur:\t\t.int szMessErreur\niAdrszMessErreur1:\t\t.int szMessErreur1\niAdrszMessErreur2:\t\t.int szMessErreur2\niAdrszMessErreur3:\t\t.int szMessErreur3\niAdrszMessErreur4:\t\t.int szMessErreur4\niAdrsBuffer:\t\t\t\t.int sBuffer\niFicMask1: \t\t\t\t.octa 0644\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}    \t\t\t/* save  registres */ \n    mov r2,#0   \t\t\t\t/* counter length */\n1:      /* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7,lr}    \t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n/***************************************************/\n/*   display error message                         */\n/***************************************************/\n/* r0 contains error code  r1  address error message */\nafficheerreur:\n   push {r1-r2,lr}    @ save registers\n    mov r2,r0         @ save error code\n    mov r0,r1         @ address error message\n    bl affichageMess   @ display error message\n    mov r0,r2         @ error code\n    ldr r1,iAdrsDeci    @ result address\n    bl conversion10S\n    ldr r0,iAdrszMessErr @ display error code\n    bl affichageMess\n    pop {r1-r2,lr}    @ restaur registers \n    bx lr              @ return function\niAdrszMessErr:   .int szMessErr\niAdrsDeci:\t\t.int sDeci\n\n/***************************************************/\n/*  Converting a register to a signed decimal      */\n/***************************************************/\n/* r0 contains value and r1 area address    */\nconversion10S:\n    push {r0-r4,lr}    @ save registers\n    mov r2,r1       /* debut zone stockage */\n    mov r3,#'+'     /* par defaut le signe est + */\n    cmp r0,#0       @ negative number\u00a0? \n    movlt r3,#'-'   @ yes\n    mvnlt r0,r0     @ number inversion\n    addlt r0,#1   \n    mov r4,#10       @ length area\n1:  @ start loop\n    bl divisionPar10R \n    add r1,#48   @ digit\n    strb r1,[r2,r4]  @ store digit on area\n    sub r4,r4,#1      @ previous position\n    cmp r0,#0          @ stop if quotient = 0\n    bne 1b\t\n\n    strb r3,[r2,r4]  @ store signe \n    subs r4,r4,#1    @ previous position\n    blt  100f        @ if r4 < 0 -> end\n\n    mov r1,#' '   @ space\t\n2:\n    strb r1,[r2,r4]  @store byte space\n    subs r4,r4,#1    @ previous position\n    bge 2b           @ loop if r4 > 0\n100: \n    pop {r0-r4,lr}   @ restaur registers\n    bx lr  \n\n/***************************************************/\n/*   division for 10 fast unsigned                 */\n/***************************************************/\n@ r0 contient le dividende\n@ r0 retourne le quotient\n@ r1 retourne le reste\ndivisionPar10R:\n    push {r2,lr}         @ save  registers\n    sub r1, r0, #10        @ calcul de r0 - 10 \n    sub r0, r0, r0, lsr #2  @ calcul de r0 - (r0 /4)\n    add r0, r0, r0, lsr #4  @ calcul de (r0-(r0/4))+ ((r0-(r0/4))/16\n    add r0, r0, r0, lsr #8  @ etc ...\n    add r0, r0, r0, lsr #16\n    mov r0, r0, lsr #3\n    add r2, r0, r0, asl #2\n    subs r1, r1, r2, asl #1    @ calcul (N-10) - (N/10)*10\n    addpl r0, r0, #1          @ regul quotient\n    addmi r1, r1, #10         @ regul reste\n    pop {r2,lr}\n    bx lr\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Delphi", "code": "\n\n- Read(F,V1..Vn)\n- ReadLn(F,V1..Vn)\n- Write(F,V1[,V2..Vn])\n- WriteLn(f,V1[,V2..Vn])\n- BlockRead(F,Buff,BytesToRead[,BytesRead])\n- BlockWrite(F,Buff,BytesToRead[,BytesWritten])\n\n\n\n\n\n\nvar\n  f : TextFile ;\n  s : string ;\nbegin\n  AssignFile(f,[fully qualified file name);\n  Reset(f);\n  writeln(f,s);\n  Reset(f);\n  ReadLn(F,S);  \n  CloseFile(\nend;\n\n\nvar\n  f         : File ;\n  buff      : array[1.1024] of byte ;\n  BytesRead : Integer ;\nbegin\n  AssignFile(f,fully qualified file name);  \n  Reset(f,1);\n  Blockread(f,Buff,SizeOf(Buff),BytesRead); \n  CloseFile(f);\nend;\n\n\ntype \n\n  tAddressBook = Record\n                  FName   : string[20];\n                  LName   : string[30];\n                  Address : string[30];\n                  City    : string[30];\n                  State   : string[2];\n                  Zip5    : string[5];\n                  Zip4    : string[4];\n                  Phone   : string[14];\n                  Deleted : boolean ;\n                end;\n\nvar\n  f     : file of tAddressBook ;\n  v     : tAddressBook ;\n  bytes : integer ;\nbegin\n  AssignFile(f,fully qualified file name);  \n  Reset(f);\n  Blockread(f,V,1,Bytes);\n  Edit(v);\n  Seek(F,FilePos(f)-1);\n  BlockWrite(f,v,1,bytes);\n  CloseFile(f);\nend;\n\n", "explain": "Delphi supports both typed and untyped as well as a textfile type for files. Delphi provides a default 128 byte buffer for text files. This may be enlarged via a call to SetTextBuff(Var F: Text; Var Buf [Size\u00a0: integer]) procedure. All other files have no buffer at all and it is the programmers option to do buffering.\nThe following file I/O procedures have existed since Turbo Pascal V-3.\nFiles are opened using:\nAssignFile(f,{fully qualified path and file name})\nAssigns the file name to the file structure in preparation for opening.\nReset(f)\nOpens and existing file. If it does not exist EIOError is raised.\nRewrite(f)\nCreates a new file and opens it for I/O. If the files exists is is overwritten.\nDelphi implemented Streams of which a variant is TFileStream and are very closely related to the Windows API for file handling. \n- Text File I/O -\n\n- Untyped File I/O -\nThis is perhaps one of the most powerful I/O functions built into Pascal. This will allow you to open and read a file of ANY type, regardless of structure, size or content. Note the usage of Reset(). This is using the optional size parameter that instructs the record size of file I/O. This could have been called with SizeOf(Buff) as the optional parameter but that would have limited flexibility. Calling it with a size of ONE byte allows you to adjust the buffer size on the fly, as conditions warrant. Also note the use of the BytesRead parameter. When included in the BlockRead() function it will return the number of bytes actually read. If this is not included, then if your directive to read n bytes is greater then the size of the file, the EOF will be encountered unexpectedly and EIOError will be raised.\n- Typed File I/O -\nTyped file I/O is very useful when reading and writing structures. An Address List is quiet easy to write when using this type of I/O.  The same file procedures are used with some subtle differences. Bite below in the blockread and blockwrite procedures that the bytes to read or write are 1. Also note that the reset procedure is not called with a buffer size. When performing Typed File I/O the size of the type definition is the buffer size. In the BlockRead() and BlockWrite() procedures I elected to read one record. Had I declared a very large buffer of type tAddressBook of say 500 records, I could have set bytes to read as SizeOf(Buffer) thereby reading a minimum of 500 records.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Object_Pascal", "code": "\n\nuses\n  classes;\nbegin\n  with TFileStream.Create('input.txt', fmOpenRead) do \n  try\n    SaveToFile('output.txt');\n  finally\n    Free;\n  end;\nend;\n", "explain": "For procedural code see the  Delphi code, which is perfectly fine in ObjectPascal.\nFor a more object oriented style one can use a TFilestream:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Ruby", "code": "\n\nstr = File.open('input.txt', 'rb') {|f| f.read}\nFile.open('output.txt', 'wb') {|f| f.write str}\n\n# Only if 'input.txt' is a text file!\n# Only if pipe '|' is not first character of path!\nstr = IO.read('input.txt')\nopen('output.txt', 'w') {|f| f.write str}\n\nrequire 'fileutils'\nFileUtils.copy_file 'input.txt', 'output.txt'\nRun BASIC[edit]\nWorks with: Just BASIC\nopen \"input.txt\" for input as #in\nfileLen   = LOF(#in)\t\t    'Length Of File\nfileData$ = input$(#in, fileLen)    'read entire file\nclose #in\n\nopen \"output.txt\" for output as #out\nprint #out, fileData$               'write entire fie\nclose #out \nend\n\nWorks with: Just BASIC\nopen \"input.txt\"  for input  as #in\nopen \"output.txt\" for output as #out\nfileLen   = LOF(#in)\t\t    'Length Of File\nprint #out, input$(#in, fileLen)    'entire file\nclose #in\nclose #out\n", "explain": "In general, open both files in binary mode.\nIf 'input.txt' is a text file, we may forget binary mode.  If no pathname begins with a pipe '|', then we may use IO::read and Kernel#open.  (The pipe is a problem, because IO.read('| uname') or open('| sh', 'w') would open a subprocess and not a file.)\nTo copy a file block by block, use FileUtils from the standard library.\nOr directly with no intermediate fileData$\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Rust", "code": "\nuse std::fs::File;\nuse std::io::{Read, Write};\n\nfn main() {\n    let mut file = File::open(\"input.txt\").unwrap();\n    let mut data = Vec::new();\n    file.read_to_end(&mut data).unwrap();\n    let mut file = File::create(\"output.txt\").unwrap();\n    file.write_all(&data).unwrap();\n}\n\nuse std::fs::File;\nuse std::io::{self, Read,  Write};\nuse std::path::Path;\nuse std::{env, fmt, process};\n\nfn main() {\n    let files: Vec<_> = env::args_os().skip(1).take(2).collect();\n\n    if files.len()\u00a0!= 2 {\n        exit_err(\"Both an input file and output file are required\", 1);\n    }\n\n    copy(&files[0], &files[1]).unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n}\n\nfn copy<P: AsRef<Path>>(infile: P, outfile: P) -> io::Result<()> {\n    let mut vec = Vec::new();\n\n    Ok(try!(File::open(infile)\n         .and_then(|mut i| i.read_to_end(&mut vec))\n         .and_then(|_| File::create(outfile))\n         .and_then(|mut o| o.write_all(&vec))))\n}\n\nfn exit_err<T: fmt::Display>(msg: T, code: i32) ->\u00a0! {\n    writeln!(&mut io::stderr(), \"ERROR: {}\", msg).expect(\"Could not write to stdout\");\n    process::exit(code);\n}\n", "explain": "The above program will panic with any sort of error. The following shows proper error handling:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "R", "code": "\n\nsrc <- file(\"input.txt\", \"r\")\ndest <- file(\"output.txt\", \"w\")\n\nfc <- readLines(src, -1)\nwriteLines(fc, dest)\nclose(src); close(dest)\n\nsrc <- file(\"input.txt\", \"rb\")\ndest <- file(\"output.txt\", \"wb\")\n\nwhile( length(v <- readBin(src, \"raw\")) > 0 ) {\n  writeBin(v, dest) \n}\nclose(src); close(dest)\n\nfile.copy(\"input.txt\", \"output.txt\", overwrite = FALSE)\n", "explain": "If files are textual we can use readLines (\"-1\" means \"read until the end\")\nIf the files are not textual but \"generic\":\nAnother simpler way is to use file.copy\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "COBOL", "code": "\nCOBOL 85[edit]\nWorks with: COBOL 85 standard\n\n     $set ans85 flag\"ans85\" flagas\"s\" sequential\"line\"\n\n       identification division.\n       program-id. copyfile.\n       environment division.\n       input-output section.\n       file-control.\n           select input-file assign to \"input.txt\"\n               organization sequential\n           .\n           select output-file assign to \"output.txt\"\n               organization sequential\n           .\n       data division.\n       file section.\n       fd input-file.\n       1 input-record pic x(80).\n       fd output-file.\n       1 output-record pic x(80).\n       working-storage section.\n       1 end-of-file-flag pic 9 value 0.\n         88 eof value 1.\n       1 text-line pic x(80).\n       procedure division.\n       begin.\n           open input input-file\n               output output-file\n           perform read-input\n           perform until eof\n               write output-record from text-line\n               perform read-input\n           end-perform\n           close input-file output-file\n           stop run\n           .\n       read-input.\n           read input-file into text-line\n           at end\n               set eof to true\n           end-read\n           .\n       end program copyfile.\n\nImplementation[edit]\nWorks with: OpenCOBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. file-io.\n\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT in-file ASSIGN \"input.txt\"\n               ORGANIZATION LINE SEQUENTIAL.\n             \n           SELECT OPTIONAL out-file ASSIGN \"output.txt\"\n               ORGANIZATION LINE SEQUENTIAL.\n\n       DATA DIVISION.\n       FILE SECTION.\n       FD  in-file.\n       01  in-line                 PIC X(256).\n\n       FD  out-file.\n       01  out-line                PIC X(256).\n       \n       PROCEDURE DIVISION.\n       DECLARATIVES.\n       in-file-error SECTION.\n           USE AFTER ERROR ON in-file.\n           DISPLAY \"An error occurred while using input.txt.\"\n           GOBACK\n           .\n       out-file-error SECTION.\n           USE AFTER ERROR ON out-file.\n           DISPLAY \"An error occurred while using output.txt.\"\n           GOBACK\n           .\n       END DECLARATIVES.\n\n       mainline.\n           OPEN INPUT in-file\n           OPEN OUTPUT out-file\n\n           PERFORM FOREVER\n               READ in-file\n                   AT END\n                       EXIT PERFORM\n               END-READ\n               WRITE out-line FROM in-line\n           END-PERFORM\n\n           CLOSE in-file, out-file\n           .\n\nBuilt-in Subroutines[edit]\nWorks with: OpenCOBOL\nWorks with: Visual COBOL\n*> Originally from ACUCOBOL-GT\nCALL \"C$COPY\" USING \"input.txt\", \"output.txt\", 0\n\n*> Originally from Micro Focus COBOL\nCALL \"CBL_COPY_FILE\" USING \"input.txt\", \"output.txt\"\n\n", "explain": "Flags used for Micro Focus COBOL:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Ada", "code": "\nLine by line[edit]\n\nwith Ada.Text_IO; use Ada.Text_IO;\n \nprocedure Read_And_Write_File_Line_By_Line is\n   Input, Output : File_Type;\nbegin\n   Open (File => Input,\n         Mode => In_File,\n         Name => \"input.txt\");\n   Create (File => Output,\n           Mode => Out_File,\n           Name => \"output.txt\");\n   loop\n      declare\n         Line : String := Get_Line (Input);\n      begin\n         -- You can process the contents of Line here.\n         Put_Line (Output, Line);\n      end;\n   end loop;\n   Close (Input);\n   Close (Output);\nexception\n   when End_Error =>\n      if Is_Open(Input) then \n         Close (Input);\n      end if;\n      if Is_Open(Output) then \n         Close (Output);\n      end if;\nend Read_And_Write_File_Line_By_Line;\n\n\nwith Ada.Command_Line, Ada.Text_IO; use Ada.Command_Line, Ada.Text_IO;\n \nprocedure Read_And_Write_File_Line_By_Line is\n   Read_From : constant String := \"input.txt\";\n   Write_To  : constant String := \"output.txt\";\n \n   Input, Output : File_Type;\nbegin\n   begin\n      Open (File => Input,\n            Mode => In_File,\n            Name => Read_From);\n   exception\n      when others =>\n         Put_Line (Standard_Error,\n                   \"Can not open the file '\" & Read_From & \"'. Does it exist?\");\n         Set_Exit_Status (Failure);\n         return;\n   end;\n \n   begin\n      Create (File => Output,\n              Mode => Out_File,\n              Name => Write_To);\n   exception\n      when others =>\n         Put_Line (Standard_Error,\n                   \"Can not create a file named '\" & Write_To & \"'.\");\n         Set_Exit_Status (Failure);\n         return;\n   end;\n \n   loop\n      declare\n         Line : String := Get_Line (Input);\n      begin\n         -- You can process the contents of Line here.\n         Put_Line (Output, Line);\n      end;\n   end loop;\n   Close (Input);\n   Close (Output);\nexception\n   when End_Error =>\n      if Is_Open(Input) then \n         Close (Input);\n      end if;\n      if Is_Open(Output) then \n         Close (Output);\n      end if;\nend Read_And_Write_File_Line_By_Line;\n\nCharacter by character[edit]\n\nwith Ada.Sequential_IO;\n\nprocedure Read_And_Write_File_Character_By_Character is\n   package Char_IO is new Ada.Sequential_IO (Character);\n   use Char_IO;\n\n   Input, Output : File_Type;\n   Buffer        : Character;\nbegin\n   Open   (File => Input,  Mode => In_File,  Name => \"input.txt\");\n   Create (File => Output, Mode => Out_File, Name => \"output.txt\");\n   loop\n      Read  (File => Input,  Item => Buffer);\n      Write (File => Output, Item => Buffer);\n   end loop;\n   Close (Input);\n   Close (Output);\nexception\n   when End_Error =>\n      if Is_Open(Input) then\n         Close (Input);\n      end if;\n      if Is_Open(Output) then\n         Close (Output);\n      end if;\nend Read_And_Write_File_Character_By_Character;\n\nUsing Ada.Text_IO.Text_Streams[edit]\n\nwith Ada.Text_IO;               use Ada.Text_IO; \nwith Ada.Text_IO.Text_Streams;  use Ada.Text_IO.Text_Streams;\n \nprocedure Using_Text_Streams is\n   Input, Output : File_Type;\n   Buffer        : Character;\nbegin\n   Open   (File => Input,  Mode => In_File,  Name => \"input.txt\");\n   Create (File => Output, Mode => Out_File, Name => \"output.txt\");\n   loop\n      Buffer := Character'Input (Stream (Input));\n      Character'Write (Stream (Output), Buffer);\n   end loop;\n   Close (Input);\n   Close (Output);\nexception\n   when End_Error =>\n      if Is_Open(Input) then\n         Close (Input);\n      end if;\n      if Is_Open(Output) then\n         Close (Output);\n      end if;\nend Using_Text_Streams;\n\n", "explain": "Assuming everything is fine and no error handling is required, this solution is sufficient:\nExpanded with proper error handling and reporting it reads:\nThe following example reads and writes each file one character at a time.  (You should of course add error reporting as in the example above.)\nThe following solution uses stream I/O. Any file of Ada.Text_IO can be used to obtain a corresponding stream. Reading and writing streams is more efficient than reading text files directly, because it skips formatting.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Julia", "code": "\n\nmystring = read(\"file1\", String)\nopen(io->write(io, mystring), \"file2\", \"w\")\n\n\ncp(\"file1\",\"file2\")\n\n\ninfile = open(\"file1\", \"r\")\noutfile = open(\"file2\", \"w\")\nwrite(outfile, read(infile, String))\nclose(outfile)\nclose(infile)\n\n\nopen(IO ->write(IO, read(\"file1\", String)), \"file2\", \"w\")\n\n", "explain": "Here we read the content of file1 into the variable mystring. Then we write the content of string to file2.\nNote however that Julia has a `cp` function to copy the content of a file to another file.\nWe can also open and close the file handles manually.\nHere is a one-liner that guarantees that the file handle is closed\neven if something goes wrong during the read/write phase.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nimport java.io.File\n\nfun main(args: Array<String>) {\n    val text = File(\"input.txt\").readText()\n    File(\"output.txt\").writeText(text)\n}\n\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Perl", "code": "\nWorks with: Perl version 5.8.8\n#!/usr/bin/perl\n\nopen my $fh_in, '<', 'input.txt' or die \"could not open <input.txt> for reading: $!\";\nopen my $fh_out, '>', 'output.txt' or die \"could not open <output.txt> for writing: $!\";\n# '>' overwrites file, '>>' appends to file, just like in the shell\n\nbinmode $fh_out; # marks filehandle for binary content on systems where that matters\n\nprint $fh_out $_ while <$fh_in>;\n# prints current line to file associated with $fh_out filehandle\n\n# the same, less concise\n#while (<$fh_in>) {\n#  print $fh_out $_;\n#};\n\nclose $fh_in;\nclose $fh_out;\n\n", "explain": "Perl has also a powerful mechanism in conjunction with opening files called IO disciplines. It allows you to automatically apply chainable transformations on the input and output. Mangling newlines, gzip (de)compression and character encoding are the most used examples.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Objective-C", "code": "\n\n[[NSFileManager defaultManager] copyItemAtPath:@\"input.txt\" toPath:@\"output.txt\" error:NULL];\n\nNSData *data = [NSData dataWithContentsOfFile:@\"input.txt\"];\n\n[data writeToFile:@\"output.txt\" atomically:YES];\n\n", "explain": "For copying files, using NSFileManager is preferred:\nIf you want to do it manually:\nDisplayed without error checking to make it more clear. In real code you will need to add lot of error checking code, and maybe use dataWithContentsOfFile:error: if you want to get error information on failure. However, this code will mostly work correctly even if input does not exist or is not accessible. dataWithContentsOfFile: will return nil, and sending nil the message writeTofile:atomically: does nothing\u00a0:-)\nThe second argument (atomically:YES) write the content to a temporary file, and rename the temporary file to the destination file, replacing existing file.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Lua", "code": "\ninFile  = io.open(\"input.txt\", \"r\")\ndata = inFile:read(\"*all\") -- may be abbreviated to \"*a\";\n                           -- other options are \"*line\", \n                           -- or the number of characters to read.\ninFile:close()\n\noutFile = io.open(\"output.txt\", \"w\")\noutfile:write(data)\noutfile:close()\n\n-- Oneliner version:\nio.open(\"output.txt\", \"w\"):write(io.open(\"input.txt\", \"r\"):read(\"*a\"))\n\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Scala", "code": "\nLibrary: Scala\nimport java.io.{ FileNotFoundException, PrintWriter }\n\nobject FileIO extends App {\n  try {\n    val MyFileTxtTarget = new PrintWriter(\"output.txt\")\n\n    scala.io.Source.fromFile(\"input.txt\").getLines().foreach(MyFileTxtTarget.println)\n    MyFileTxtTarget.close()\n  } catch {\n    case e: FileNotFoundException => println(e.getLocalizedMessage())\n    case e: Throwable => {\n      println(\"Some other exception type:\")\n      e.printStackTrace()\n    }\n  }\n}\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "D", "code": "\nLibrary: Phobos\nWorks with: D version 2\nimport std.file: copy;\n\nvoid main() {\n    copy(\"input.txt\", \"output.txt\");\n}\n\n\nvoid main() {\nimport std.file;\nauto data = std.file.read(\"input.txt\");\nstd.file.write(\"output.txt\", data);\n}\n\n\nimport std.stdio;\n\nint main() {\n    auto from = File(\"input.txt\", \"rb\");\n    scope(exit) from.close();\n\n    auto to = File(\"output.txt\", \"wb\");\n    scope(exit) to.close();\n\n    foreach(buffer; from.byChunk(new ubyte[4096*1024])) {\n        to.rawWrite(buffer);\n    }\n\n    return 0;\n}\n\nLibrary: Tango\nWorks with: D version 1\n\nimport tango.io.device.File;\n\nvoid main()\n{\n    auto from = new File(\"input.txt\");\n    auto to = new File(\"output.txt\", File.WriteCreate);\n    to.copy(from).close;\n    from.close;\n}\n\n\nimport tango.io.device.File;\n\nvoid main()\n{\n    auto to = new File(\"output.txt\", File.WriteCreate);\n    to.copy(new File(\"input.txt\")).close;\n}\n\n", "explain": "very plainly, with an intermediate variable:\nvia an intermediate buffer variable:\nCopy the content from one file to another (exceptions are handled by Tango):\nOr a shorter example without explicitly closing the output file:\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Haskell", "code": "\n\nmain = readFile \"input.txt\" >>= writeFile \"output.txt\"\n\n", "explain": "Note: this doesn't keep the file in memory. Buffering is provided by lazy evaluation.\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Scheme", "code": "\nCharacter by character copy; Open ports for the input and output files\n(define in-file (open-input-file \"input.txt\"))\n(define out-file (open-output-file \"output.txt\"))\n\n; Read and write characters from the input file\n; to the output file one by one until end of file\n(do ((c (read-char in-file) (read-char in-file)))\n        ((eof-object? c))\n        (write-char c out-file))\n\n; Close the ports\n(close-input-port in-file)\n(close-output-port out-file)\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "PowerShell", "code": "\n\nGet-Content $PWD\\input.txt | Out-File $PWD\\output.txt\n\nGet-Content $PWD\\input.txt | Set-Content $PWD\\output.txt\n", "explain": "Read the input file then pipe it's contents to output file.\nAssumes that the files are in the same folder that the script is executing in.\nUsing an alternate cmdlet to write the file\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Logo", "code": "\nWorks with: UCB Logo\nto copy :from :to \n  openread :from\n  openwrite :to\n  setread :from   \n  setwrite :to\n  until [eof?] [print readrawline]\n  closeall\nend\n\ncopy \"input.txt \"output.txt\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "ColdFusion", "code": "\n<cfif fileExists(expandPath(\"input.txt\"))>\n  <cffile action=\"read\" file=\"#expandPath('input.txt')#\" variable=\"inputContents\">\n  <cffile action=\"write\" file=\"#expandPath('output.txt')#\" output=\"#inputContents#\">\n</cfif>\n\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "F#", "code": "\n\nopen System.IO\n\nlet copyFile fromTextFileName toTextFileName =\n    let inputContent = File.ReadAllText fromTextFileName\n    inputContent |> fun text -> File.WriteAllText(toTextFileName, text)\n\n[<EntryPoint>]\nlet main argv =\n    copyFile \"input.txt\" \"output.txt\"\n    0\n\n", "explain": "Using an intermediate variable for the input file content is not ideomatic in functional programming. Nevertheless...\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Groovy", "code": "\n\ncontent = new File('input.txt').text\nnew File('output.txt').write(content)\n\n\nnew AntBuilder().copy(file:'input.txt', toFile:'output.txt', overwrite:true)\n\n\nnew File('output.txt').withWriter( w ->\n  new File('input.txt').withReader( r -> w << r }\n}\n\n", "explain": "Using File\nUsing Ant\nBuffered\n"}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var in = try std.fs.cwd().openFile(\"input.txt\", .{});\n    defer in.close();\n    var out = try std.fs.cwd().openFile(\"output.txt\", .{ .mode = .write_only });\n    defer out.close();\n    var file_reader = in.reader();\n    var file_writer = out.writer();\n    var buf: [100]u8 = undefined;\n    var read: usize = 1;\n    while (read > 0) {\n        read = try file_reader.readAll(&buf);\n        try file_writer.writeAll(buf[0..read]);\n    }\n}\n\n\n\n", "explain": ""}, {"task_name": "File input/output", "task_url": "https://rosettacode.org/wiki/File_input/output", "task_cat": "File handling", "lang": "AWK", "code": "\n\nBEGIN {\n  while ( (getline <\"input.txt\") > 0 ) {\n    print >\"output.txt\"\n  }\n}\n\n", "explain": "(This does not handle properly binary files)\n"}]