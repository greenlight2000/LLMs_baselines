[{"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Python", "code": "\n>>> def j(n, k):\n\tp, i, seq = list(range(n)), 0, []\n\twhile p:\n\t\ti = (i+k-1) % len(p)\n\t\tseq.append(p.pop(i))\n\treturn 'Prisoner killing order: %s.\\nSurvivor: %i' % (', '.join(str(i) for i in seq[:-1]), seq[-1])\n\n>>> print(j(5, 2))\nPrisoner killing order: 1, 3, 0, 4.\nSurvivor: 2\n>>> print(j(41, 3))\nPrisoner killing order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivor: 30\n>>>\n\nFaster way[edit]\n\n>>>def josephus(n, k):\n        r = 0\n        for i in xrange(1, n+1):\n            r = (r+k)%i\n        return 'Survivor: %d' %r\n\n>>> print(josephus(5, 2))\nSurvivor: 2\n>>> print(josephus(41, 3))\nSurvivor: 30\n>>>\n\nAlternate solution with a circular linked list[edit]\n\ndef josephus(n, k):\n    a = list(range(1, n + 1))\n    a[n - 1] = 0\n    p = 0\n    v = []\n    while a[p] != p:\n        for i in range(k - 2):\n            p = a[p]\n        v.append(a[p])\n        a[p] = a[a[p]]\n        p = a[p]\n    v.append(p)\n    return v\n\njosephus(10, 2)\n[1, 3, 5, 7, 9, 2, 6, 0, 8, 4]\n\njosephus(41, 3)[-1]\n30\n\nlearning iter in python[edit]\nfrom itertools import compress, cycle\ndef josephus(prisoner, kill, surviver):\n    p = range(prisoner)\n    k = [0] * kill\n    k[kill-1] = 1\n    s = [1] * kill\n    s[kill -1] = 0\n    queue = p\n    \n    queue = compress(queue, cycle(s))\n    try:\n        while True:\n            p.append(queue.next())        \n    except StopIteration:\n        pass \n\n    kil=[]\n    killed = compress(p, cycle(k))\n    try:\n        while True:\n            kil.append(killed.next())\n    except StopIteration:\n        pass \n        \n    print 'The surviver is: ', kil[-surviver:]\n    print 'The kill sequence is ', kil[:prisoner-surviver]\n\njosephus(41,3,2)\nThe surviver is:  [15, 30]\nThe kill sequence is  [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34]\njosephus(5,2,1)\nThe surviver is:  [2]\nThe kill sequence is  [1, 3, 0, 4]\n\n", "explain": "Does not show the killing order.\nThe function returns the killing order. The last in the list stays alive. Notice that the result is a permutation of [0, 1, ... n - 1].\nIn the program, a[p] is the index of the next living prisoner after 'p'. The program stops when p = a[p], that is, when there remains only one living prisoner.\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "C", "code": "\n#include <stdio.h>\n\n// m-th on the reversed kill list; m = 0 is final survivor\nint jos(int n, int k, int m) {\n\tint a;\n\tfor (a = m + 1; a <= n; a++)\n\t\tm = (m + k) % a;\n\treturn m;\n}\n\ntypedef unsigned long long xint;\n\n// same as jos(), useful if n is large and k is not\nxint jos_large(xint n, xint k, xint m) {\n\tif (k <= 1) return n - m - 1;\n\n\txint a = m;\n\twhile (a < n) {\n\t\txint q = (a - m + k - 2) / (k - 1);\n\n\t\tif (a + q > n)\tq = n - a;\n\t\telse if (!q)\tq = 1;\n\n\t\tm = (m + q * k) % (a += q);\n\t}\n\n\treturn m;\n}\n\nint main(void) {\n\txint n, k, i;\n\n\tn = 41;\n\tk = 3;\n\tprintf(\"n = %llu, k = %llu, final survivor: %d\\n\", n, k, jos(n, k, 0));\n\n\tn = 9876543210987654321ULL;\n\tk = 12031;\n\tprintf(\"n = %llu, k = %llu, three survivors:\", n, k);\n\n\tfor (i = 3; i--; )\n\t\tprintf(\" %llu\", jos_large(n, k, i));\n\tputchar('\\n');\n\n\treturn 0;\n}\n\n\nOutput:\nn = 41, k = 3, final survivor: 30\nn = 9876543210987654321, k = 12031, three survivors: 6892710366467541051 1946357796579138992 3554846299321782413\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "C++", "code": "\n#include <iostream>\n#include <vector>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\ntypedef unsigned long long bigint;\n\n//--------------------------------------------------------------------------------------------------\nclass josephus\n{\npublic:\n    bigint findSurvivors( bigint n, bigint k, bigint s = 0 )\n    {\n\tbigint i = s + 1;\n\tfor( bigint x = i; x <= n; x++, i++ )\n\t    s = ( s + k ) % i;\n\n\treturn s;\n    }\n\n    void getExecutionList( bigint n, bigint k, bigint s = 1 )\n    {\n\tcout << endl << endl << \"Execution list: \" << endl;\n\n\tprisoners.clear();\n\tfor( bigint x = 0; x < n; x++ )\n\t    prisoners.push_back( x );\n\n\tbigint index = 0;\n\twhile( prisoners.size() > s )\n\t{\n\t    index += k - 1;\n\t    if( index >= prisoners.size() ) index %= prisoners.size();\n\t    cout << prisoners[static_cast<unsigned int>( index )] << \", \";\n\n\t    vector<bigint>::iterator it = prisoners.begin() + static_cast<unsigned int>( index );\n\t    prisoners.erase( it );\n\t}\n    }\n\nprivate:\n    vector<bigint> prisoners;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    josephus jo;\n    bigint n, k, s;\n    while( true )\n    {\n\tsystem( \"cls\" );\n\tcout << \"Number of prisoners( 0 to QUIT ): \"; cin >> n;\n\tif( !n ) return 0;\n\tcout << \"Execution step: \"; cin >> k;\n\tcout << \"How many survivors: \"; cin >> s;\n\t\t\n\tcout << endl << \"Survivor\";\n\tif( s == 1 )\n\t{\n\t    cout << \": \" << jo.findSurvivors( n, k );\n\t    jo.getExecutionList( n, k );\n\t}\n\telse\n\t{\n\t    cout << \"s: \";\n\t    for( bigint x = 0; x < s; x++ )\n\t\tcout << jo.findSurvivors( n, k, x ) << \", \";\n\n\t    jo.getExecutionList( n, k, s );\n\t}\n\n\tcout << endl << endl;\n\tsystem( \"pause\" );\n    }\n    return 0;\n}\n//--------------------------------------------------------------------------------------------------\n\n\nOutput:\nNumber of prisoners( 0 to QUIT ): 41\nExecution step: 3\nHow many survivors: 1\n\nSurvivor: 30\n\nExecution list:\n2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36\n, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15,\n\n\nNumber of prisoners( 0 to QUIT ): 41\nExecution step: 3\nHow many survivors: 3\n\nSurvivors: 30, 15, 34,\n\nExecution list:\n2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36\n, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3,\n\n\nNumber of prisoners( 0 to QUIT ): 71\nExecution step: 47\nHow many survivors: 11\n\nSurvivors: 29, 58, 41, 14, 39, 28, 35, 45, 64, 49, 27,\n\nExecution list:\n46, 22, 70, 48, 26, 5, 56, 36, 17, 0, 54, 38, 23, 9, 66, 55, 43, 33, 25, 16, 11,\n6, 2, 69, 68, 1, 4, 10, 15, 24, 32, 42, 53, 65, 20, 40, 60, 19, 47, 8, 44, 13,\n52, 31, 12, 62, 57, 50, 51, 61, 7, 30, 59, 34, 18, 3, 21, 37, 67, 63,\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Java", "code": "\nWorks with: Java version 1.5+\nimport java.util.ArrayList;\n\npublic class Josephus {\n    public static int execute(int n, int k){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > 1){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners.get(0);\n    }\n    \n    public static ArrayList<Integer> executeAllButM(int n, int k, int m){\n        int killIdx = 0;\n        ArrayList<Integer> prisoners = new ArrayList<Integer>(n);\n        for(int i = 0;i < n;i++){\n            prisoners.add(i);\n        }\n        System.out.println(\"Prisoners executed in order:\");\n        while(prisoners.size() > m){\n            killIdx = (killIdx + k - 1) % prisoners.size();\n            System.out.print(prisoners.get(killIdx) + \" \");\n            prisoners.remove(killIdx);\n        }\n        System.out.println();\n        return prisoners;\n    }\n    \n    public static void main(String[] args){\n        System.out.println(\"Survivor: \" + execute(41, 3));\n        System.out.println(\"Survivors: \" + executeAllButM(41, 3, 3));\n    }\n}\n\n\nOutput:\nPrisoners executed in order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15 \nSurvivor: 30\nPrisoners executed in order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 \nSurvivors: [15, 30, 34]\nTranslation of: Javascript\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class Josephus {\n\n\tpublic static void main(String[] args) {\n\t\texecute(5, 1);\n\t\texecute(41, 2);\n\t\texecute(23482, 3342, 3);\n\t}\n\n\tpublic static int[][] execute(int n, int k) {\n\t\treturn execute(n, k, 1);\n\t}\n\n\tpublic static int[][] execute(int n, int k, int s) {\n\t\tList<Integer> ps = new ArrayList<Integer>(n);\n\t\tfor (int i=0; i<n; i+=1) ps.add(i);\n\t\tList<Integer> ks = new ArrayList<Integer>(n-s);\n\t\tfor (int i=k; ps.size()>s; i=(i+k)%ps.size()) ks.add(ps.remove(i));\n\t\tSystem.out.printf(\"Josephus(%d,%d,%d) -> %s / %s\\n\", n, k, s, toString(ps), toString(ks));\n\t\treturn new int[][] {\n\t\t\tps.stream().mapToInt(Integer::intValue).toArray(),\n\t\t\tks.stream().mapToInt(Integer::intValue).toArray()\n\t\t};\n\t}\n\t\n\tprivate static String toString(List <Integer> ls) {\n\t\tString dot = \"\";\n\t\tif (ls.size() >= 45) {\n\t\t\tdot = \", ...\";\n\t\t\tls = ls.subList(0, 45);\n\t\t}\n\t\tString s = ls.toString();\n\t\treturn s.substring(1, s.length()-1) + dot;\n\t}\n}\n\n\nOutput:\nJosephus(5,1,1) -> 2 / 1, 3, 0, 4\nJosephus(41,2,1) -> 30 / 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15\nJosephus(23482,3342,3) -> 1087, 1335, 13317 / 3342, 6685, 10028, 13371, 16714, 20057, 23400, 3261, 6605, 9949, 13293, 16637, 19981, 23325, 3187, 6532, 9877, 13222, 16567, 19912, 23257, 3120, 6466, 9812, 13158, 16504, 19850, 23196, 3060, 6407, 9754, 13101, 16448, 19795, 23142, 3007, 6355, 9703, 13051, 16399, 19747, 23095, 2961, 6310, 9659, ...\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "C#", "code": "\nnamespace Josephus\n{\n    using System;\n    using System.Collections;\n    using System.Collections.Generic;\n\n    public class Program\n    {\n        public static int[] JosephusProblem(int n, int m)\n        {\n            var circle = new List<int>();\n            var order = new int[n];\n\n            for (var i = 0; i < n; ++i)\n            {\n                circle.Add(i);\n            }\n\n            var l = 0;\n            var j = 0;\n            var k = 0;\n\n            while (circle.Count != 0)\n            {\n                j++;\n                if (j == m)\n                {\n                    order[k] = circle[l];\n                    circle.RemoveAt(l);\n\n                    k++;\n                    l--;\n                    j = 0;\n                }\n\n                if (k == n - 1)\n                {\n                    order[k] = circle[0];\n                    circle.RemoveAt(0);\n                }\n\n                if (l == circle.Count - 1)\n                {\n                    l = 0;\n                }\n                else\n                {\n                    l++;\n                }\n            }\n\n            return order;\n        }\n\n        static void Main(string[] args)\n        {\n            try\n            {\n                var n = 7;\n                var m = 2;\n\n                var result = JosephusProblem(n, m);\n\n               for (var i = 0; i < result.Length; i++)\n               {\n                   Console.WriteLine(result[i]);//1 3 5 0 4 2 6\n               }\n            }\n            catch (Exception e)\n            {\n                Console.WriteLine(e);\n            }\n            finally\n            {\n                Console.ReadLine();\n            }\n        }\n\n    }\n}\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\n\nvar Josephus = {\n  init: function(n) {\n    this.head = {};\n    var current = this.head;\n    for (var i = 0; i < n-1; i++) {\n      current.label = i+1;\n      current.next = {prev: current};\n      current = current.next;\n    }\n    current.label = n;\n    current.next = this.head;\n    this.head.prev = current;\n    return this;\n  },\n  kill: function(spacing) {\n    var current = this.head;\n    while (current.next !== current) {\n      for (var i = 0; i < spacing-1; i++) {\n        current = current.next;\n      }\n      current.prev.next = current.next;\n      current.next.prev = current.prev;\n      current = current.next;\n    }\n    return current.label;\n  }\n}\n\n\nOutput:\n> Josephus.init(30).kill(2)\n29\n\n\nfunction Josephus(n, k, s) {\n\ts = s | 1\n\tfor (var ps=[], i=n; i--; ) ps[i]=i\n\tfor (var ks=[], i=--k; ps.length>s; i=(i+k)%ps.length) ks.push(ps.splice(i, 1))\n\tdocument.write((arguments.callee+'').split(/\\s|\\(/)[1], '(', [].slice.call(arguments, 0), ') -> ', ps, ' / ', ks.length<45?ks:ks.slice(0,45)+',...' , '<br>')\n\treturn [ps, ks]\n}\n\n\nOutput:\nJosephus(5,1) -> 2 / 1,3,0,4\nJosephus(41,2) -> 30 / 2,5,8,11,14,17,20,23,26,29,32,35,38,0,4,9,13,18,22,27,31,36,40,6,12,19,25,33,39,7,16,28,37,10,24,1,21,3,34,15\nJosephus(23482,3342,3) -> 1087,1335,13317 / 3342,6685,10028,13371,16714,20057,23400,3261,6605,9949,13293,16637,19981,23325,3187,6532,9877,13222,16567,19912,23257,3120,6466,9812,13158,16504,19850,23196,3060,6407,9754,13101,16448,19795,23142,3007,6355,9703,13051,16399,19747,23095,2961,6310,9659,...\n\n", "explain": "Labels are 1-based, executioner's solution:\nWith Array methods:\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "PHP", "code": "\n<?php //Josephus.php\nfunction Jotapata($n=41,$k=3,$m=1){$m--;\n\t$prisoners=array_fill(0,$n,false);//make a circle of n prisoners, store false ie: dead=false\n\t$deadpool=1;//count to next execution\n\t$order=0;//death order and *dead* flag, ie. deadpool\n\twhile((array_sum(array_count_values($prisoners))<$n)){//while sum of count of unique values dead times < n (they start as all false)\n\t\tforeach($prisoners as $thisPrisoner=>$dead){\n\t\t\tif(!$dead){//so yeah...if not dead...\n\t\t\t\tif($deadpool==$k){//if their time is up in the deadpool...\n\t\t\t\t\t$order++;\n\t\t\t\t\t//set the deadpool value or enumerate as survivor\n\t\t\t\t\t$prisoners[$thisPrisoner]=((($n-$m)>($order)?$order:(($n)==$order?'Call me *Titus Flavius* Josephus':'Joe\\'s friend '.(($order)-($n-$m-1)))));\n\t\t\t\t\t$deadpool=1;//reset count to next execution\n\t\t\t\t}else{$duckpool++;}\n\t\t\t}\n\t\t}\n\t}\n\treturn $prisoners;\n}\necho '<pre>'.print_r(Jotapata(41,3,5),true).'<pre>';\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "MATLAB", "code": "\nfunction [indAlive] = josephus(numPeople,count)\n% Josephus: Given a circle of numPeople individuals, with a count of count,\n% find the index (starting at 1) of the survivor [see Josephus Problem]\n\n%% Definitions:\n%   0 = dead position\n%   1 = alive position\n%   index = # of person\n\n%% Setting up\narrPeople = ones(1, numPeople);\ncurrInd = 0;\n\n%% Counting\nwhile (length(arrPeople(arrPeople == 1)) > 1)     % While more than 1 person is alive\n    counter = 0;\n    while counter ~= count                       % Counting until we hit the count\n        currInd = currInd + 1;                  % Move to the next person\n        \n        if currInd > numPeople                  % If overflow, wraparound\n            currInd = currInd - numPeople;\n        end\n        \n        if arrPeople(currInd)                   % If the current person is alive\n            counter = counter + 1;                % Add 1 person to the count\n            %fprintf(\"Index: %d \\t| Counter: %d\\n\", currInd, counter)          \u00a0% Uncomment to display index and counter location\n        end\n\n    end\n    \n    arrPeople(currInd) = 0;                     % Kill the person we reached\n    %fprintf(\"Killed person %d \\n\", currInd)                                  \u00a0% Uncomment to display order of killing\n    %disp(arrPeople)                                                          \u00a0% Uncomment to display current status of people\nend\n\nindAlive = find(arrPeople);\n\nend\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Fortran", "code": "\n\nprogram josephus\n   implicit none\n   integer :: n, i, k, p\n   integer, allocatable :: next(:)\n   read *, n, k\n   allocate(next(0:n - 1))\n   do i = 0, n - 2\n      next(i) = i + 1\n   end do\n   next(n - 1) = 0\n   p = 0\n   do while(next(p) /= p)\n      do i = 1, k - 2\n         p = next(p)\n      end do\n      print *, \"Kill\", next(p)\n      next(p) = next(next(p))\n      p = next(p)\n   end do\n   print *, \"Alive\", p\n   deallocate(next)\nend program\n\n", "explain": "Naive approach: prisonners are put in a \"linked buffer\" (implemented as an array giving number of \"next living prisonner\"). Then we iterate, killing one after each loop, until there is only one left.\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\n// basic task function\nfunc finalSurvivor(n, k int) int {\n    // argument validation omitted\n    circle := make([]int, n)\n    for i := range circle {\n        circle[i] = i\n    }\n    k--\n    exPos := 0\n    for len(circle) > 1 {\n        exPos = (exPos + k) % len(circle)\n        circle = append(circle[:exPos], circle[exPos+1:]...)\n    }\n    return circle[0]\n}\n\n// extra\nfunc position(n, k, pos int) int {\n    // argument validation omitted\n    circle := make([]int, n)\n    for i := range circle {\n        circle[i] = i\n    }\n    k--\n    exPos := 0\n    for len(circle) > 1 {\n        exPos = (exPos + k) % len(circle)\n        if pos == 0 {\n            return circle[exPos]\n        }\n        pos--\n        circle = append(circle[:exPos], circle[exPos+1:]...)\n    }\n    return circle[0]\n}\n\nfunc main() {\n    // show basic task function on given test case\n    fmt.Println(finalSurvivor(41, 3))\n    // show extra function on all positions of given test case\n    fmt.Println(\"Position  Prisoner\")\n    for i := 0; i < 41; i++ {\n        fmt.Printf(\"%5d%10d\\n\", i, position(41, 3, i))\n    }\n}\n\n\nOutput:\n30\nPosition  Prisoner\n    0         2\n    1         5\n    2         8\n    3        11\n    4        14\n    5        17\n    6        20\n    7        23\n    8        26\n    9        29\n   10        32\n   11        35\n   12        38\n   13         0\n   14         4\n   15         9\n   16        13\n   17        18\n   18        22\n   19        27\n   20        31\n   21        36\n   22        40\n   23         6\n   24        12\n   25        19\n   26        25\n   27        33\n   28        39\n   29         7\n   30        16\n   31        28\n   32        37\n   33        10\n   34        24\n   35         1\n   36        21\n   37         3\n   38        34\n   39        15\n   40        30\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly AARCH64 Raspberry PI 3B */\n/* ARM assembly Raspberry PI  */\n/*  program josephus.s   */\n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n\n/*******************************************/\n/* Constantes                              */\n/*******************************************/\n.equ STDOUT, 1           @ Linux output console\n.equ EXIT,   1           @ Linux syscall\n.equ WRITE,  4           @ Linux syscall\n.equ BRK,    0x2d        @ Linux syscall\n.equ CHARPOS,     '@'\n\n.equ FIRSTNODE,        0              //identification first node \n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure linkedlist*/\n    .struct  0\nllist_next:                            // next element\n    .struct  llist_next + 4\nllist_value:                           // element value\n    .struct  llist_value + 4\nllist_fin:\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessDebutPgm:          .asciz \"Start program.\\n\"\nszMessFinPgm:            .asciz \"Program End ok.\\n\"\nszRetourLigne:            .asciz \"\\n\"\nszMessValElement:        .asciz \"Value\u00a0: @ \\n\"\nszMessListeVide:         .asciz \"List empty.\\n\"\nszMessImpElement:        .asciz \"Node display: @ Value\u00a0: @ Next @ \\n\"\nszMessErrComm:           .asciz \"Incomplete Command line \u00a0: josephus <maxi> <intervalle>\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \nsZoneConv:         .skip 24\n.align 4\nqDebutListe1:      .skip llist_fin\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                   // entry of program \n    mov fp,sp                           // copy stack address  register r29 fp\n    ldr r0,iAdrszMessDebutPgm\n    bl affichageMess\n    ldr r0,[fp]                        // parameter number command line\n    cmp r0,#2                          // correct\u00a0?\n    ble erreurCommande                 // error\n\n    add r0,fp,#8                       // address parameter 2\n    ldr r0,[r0]\n    bl conversionAtoD\n    add r2,r0,#FIRSTNODE               // save maxi\n    add r0,fp,#12                      // address parameter 3\n    ldr r0,[r0]\n    bl conversionAtoD\n    mov r8,r0                          // save gap\n\n    mov r0,#FIRSTNODE                  // create first node\n    mov r1,#0\n    bl createNode\n    mov r5,r0                          // first node address\n    mov r6,r0\n    mov r4,#FIRSTNODE + 1\n    mov r3,#1\n1:                                     // loop create others nodes\n    mov r0,r4                          // key value\n    mov r1,#0\n    bl createNode\n    str r0,[r6,#llist_next]             // store current node address in prev node\n    mov r6,r0\n    add r4,r4,#1\n    add r3,r3,#1\n    cmp r3,r2                          // maxi\u00a0?\n    blt 1b\n    str r5,[r6,#llist_next]            // store first node address in last pointer\n    mov r4,r6\n2:\n    mov r2,#1                          // counter for gap\n3:\n    ldr r4,[r4,#llist_next]\n    add r2,r2,#1\n    cmp r2,r8                          // intervalle\u00a0?\n    blt 3b\n    ldr r5,[r4,#llist_next]            // removing the node from the list\n    ldr r2,[r5,#llist_value]\n    ldr r7,[r5,#llist_next]            // load pointer next\n    str r7,[r4,#llist_next]            // ans store in prev node\n    //mov r0,r25\n    //bl displayNode\n    cmp r7,r4\n    moveq r4,r7\n    bne 2b                              // and loop\n \n    mov r0,r4\n    bl displayNode                      // display last node\n\n    b 100f\nerreurCommande:\n    ldr r0,iAdrszMessErrComm\n    bl affichageMess\n    mov r0,#1                          // error code\n    b 100f\n100:                                   // program end standard \n    ldr r0,iAdrszMessFinPgm\n    bl affichageMess\n    mov r0,#0                          // return code Ok\n    mov r7,#EXIT                       // system call \"Exit\"\n    svc #0\n\niAdrszMessDebutPgm:      .int szMessDebutPgm\niAdrszMessFinPgm:        .int szMessFinPgm\niAdrszRetourLigne:       .int szRetourLigne\niAdrqDebutListe1:        .int qDebutListe1\niAdrszMessErrComm:       .int szMessErrComm\n\n/******************************************************************/\n/*     create node                                             */ \n/******************************************************************/\n/* r0 contains key   */\n/* r1 contains zero or address next node */\n/* r0 returns address heap node  */\ncreateNode:\n    push {r1-r11,lr}            // save  registers \n    mov r9,r0                   // save key\n    mov r10,r1                  // save key\n    mov r0,#0                   // allocation place heap\n    mov r7,#BRK                 // call system 'brk'\n    svc #0\n    mov r11,r0                  // save address heap for node\n    add r0,r0,#llist_fin        // reservation place node length\n    mov r7,#BRK                 // call system 'brk'\n    svc #0\n    cmp r0,#-1                  // allocation error\n    beq 100f\n\n    str r9,[r11,#llist_value]\n    str r10,[r11,#llist_next]\n    mov r0,r11\n100:\n    pop {r1-r11,lr}            // restaur registers\n    bx lr                      // return\n\n/******************************************************************/\n/*     display infos node                                     */ \n/******************************************************************/\n/* r0 contains node address */\ndisplayNode:\n    push {r1-r4,lr}           // save  registers \n    mov r2,r0\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,r0]           // store zero final\n    ldr r0,iAdrszMessImpElement\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#llist_value]\n    ldr r1,iAdrsZoneConv\n    bl conversion10S\n    mov r4,#0\n    strb r4,[r1,r0]           // store zero final\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#llist_next]\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,#8]           // store zero final\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    bl affichageMess\n\n100:\n    pop {r1-r4,lr}            // restaur registers\n    bx lr                     // return\niAdrsZoneConv:               .int sZoneConv\niAdrszMessImpElement:        .int szMessImpElement\n/***************************************************/\n/*      ROUTINES INCLUDE                 */\n/***************************************************/\n.include \"../affichage.inc\"\npi@raspberrypi:~/asm32/rosetta32/ass6 $ josephus 41 3\nStart program.\nNode display: 00F880F0 Value\u00a0:         +30 Next 00F880F0\nProgram End ok.\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,Classes,StdCtrls,ExtCtrl\n\ntype TIntArray = array of integer;\n\nprocedure GetJosephusSequence(N,K: integer; var IA: TIntArray);\n{Analyze sequence of deleting every K of N numbers}\n{Retrun result in Integer Array}\nvar LS: TList;\nvar I,J: integer;\nbegin\nSetLength(IA,N);\nLS:=TList.Create;\ntry\n{Store number 0..N-1 in list}\nfor I:=0 to N-1 do LS.Add(Pointer(I));\nJ:=0;\nfor I:=0 to N-1 do\n\tbegin\n\t{Advance J by K-1 because iterms are deleted}\n\t{And wrapping around if it J exceed the count }\n        J:=(J+K-1) mod LS.Count;\n        {Caption the sequence}\n        IA[I]:=Integer(LS[J]);\n        {Delete (kill) one item}\n        LS.Delete(J);\n\tend;\nfinally LS.Free; end;\nend;\n\nprocedure ShowJosephusProblem(Memo: TMemo; N,K: integer);\n{Analyze and display one Josephus Problem}\nvar IA: TIntArray;\nvar I: integer;\nvar S: string;\nconst CRLF = #$0D#$0A;\nbegin\nGetJosephusSequence(N,K,IA);\nS:='';\nfor I:=0 to High(IA) do\n\tbegin\n\tif I>0 then S:=S+',';\n\tif (I mod 12)=11 then S:=S+CRLF+'           ';\n\tS:=S+IntToStr(IA[I]);\n\tend;\nMemo.Lines.Add('N='+IntToStr(N)+' K='+IntToStr(K));\nMemo.Lines.Add('Sequence: ['+S+']');\nMemo.Lines.Add('Survivor: '+IntToStr(IA[High(IA)]));\nMemo.Lines.Add('');\nend;\n\nprocedure TestJosephusProblem(Memo: TMemo);\n{Test suite of Josephus Problems}\nbegin\nShowJosephusProblem(Memo,5,2);\nShowJosephusProblem(Memo,41,3);\nend;\n\n\nOutput:\nN=5 K=2\nSequence: [1,3,0,4,2]\nSurvivor: 2\n\nN=41 K=3\nSequence: [2,5,8,11,14,17,20,23,26,29,32,\n           35,38,0,4,9,13,18,22,27,31,36,40,\n           6,12,19,25,33,39,7,16,28,37,10,24,\n           1,21,3,34,15,30]\nSurvivor: 30\n\nTranslation of: Javascript\nimport std.stdio, std.algorithm, std.range;\n \nint[][] Josephus(in int n, int k, int s=1) {\n    int[] ks, ps = n.iota.array;\n    for (int i=--k; ps.length>s; i=(i+k)%ps.length) {\n        ks ~= ps[i];\n        ps = remove(ps, i);\n    }\n    writefln(\"Josephus(%d,%d,%d) ->\u00a0%(%d\u00a0%) /\u00a0%(%d\u00a0%)%s\", n, k, s, ps, ks[0..min($,45)], ks.length<45 ? \"\" : \" ...\" );\n    return [ps, ks];\n}\n \nvoid main() {\n    Josephus(5, 2);\n    Josephus(41, 3);\n    Josephus(23482, 3343, 3);\n}}\n\n\nOutput:\nJosephus(5,1,1) -> 2 / 1 3 0 4\nJosephus(41,2,1) -> 30 / 2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15\nJosephus(23482,3342,3) -> 1087 1335 13317 / 3342 6685 10028 13371 16714 20057 23400 3261 6605 9949 13293 16637 19981 23325 3187 6532 9877 13222 16567 19912 23257 3120 6466 9812 13158 16504 19850 23196 3060 6407 9754 13101 16448 19795 23142 3007 6355 9703 13051 16399 19747 23095 2961 6310 9659 ...\n", "explain": "Uses standard Delphi TList to hold and delete numbers as it analyzes the data. \n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Ruby", "code": "\nn = (ARGV[0] || 41).to_i\nk = (ARGV[1] || 3).to_i\n\nprisoners = (0...n).to_a\nprisoners.rotate!(k-1).shift  while prisoners.length > 1\nputs prisoners.first\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Rust", "code": "\nconst N: usize = 41;\nconst K: usize = 3;\nconst M: usize = 3;\nconst POSITION: usize = 5;\n\nfn main() {\n    let mut prisoners: Vec<usize> = Vec::new();\n    let mut executed: Vec<usize> = Vec::new();\n    for pos in 0..N {\n        prisoners.push(pos);\n    }\n\n    let mut to_kill: usize = 0;\n    let mut len: usize = prisoners.len();\n\n    while len > M {\n        to_kill = (to_kill + K - 1) % len;\n        executed.push(prisoners.remove(to_kill));\n        len -= 1;\n    }\n\n    println!(\"JOSEPHUS n={}, k={}, m={}\", N, K, M);\n    println!(\"Executed: {:?}\", executed);\n    println!(\"Executed position number {}: {}\", POSITION, executed[POSITION - 1]);\n    println!(\"Survivors: {:?}\", prisoners);\n}\n\n\nOutput:\nJOSEPHUS n=41, k=3, m=3\nExecuted: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3]\nExecuted position number 5: 14\nSurvivors: [15, 30, 34]\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Swift", "code": "\nclass Josephus {\n    \n    class func lineUp(#numberOfPeople:Int) -> [Int] {\n        var people = [Int]()\n        for (var i = 0; i < numberOfPeople; i++) {\n            people.append(i)\n        }\n        return people\n    }\n    \n    class func execute(#numberOfPeople:Int, spacing:Int) -> Int {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > 1) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people[0]\n    }\n    \n    class func executeAndRemove(inout people:[Int], killIndex:Int) {\n        print(\"\\(people[killIndex]) \")\n        people.removeAtIndex(killIndex)\n    }\n\n    class func execucteAllButM(#numberOfPeople:Int, spacing:Int, save:Int) -> [Int] {\n        var killIndex = 0\n        var people = self.lineUp(numberOfPeople: numberOfPeople)\n        \n        println(\"Prisoners executed in order:\")\n        while (people.count > save) {\n            killIndex = (killIndex + spacing - 1) % people.count\n            executeAndRemove(&people, killIndex: killIndex)\n        }\n        println()\n        return people\n    }\n}\n\nprintln(\"Josephus is number: \\(Josephus.execute(numberOfPeople: 41, spacing: 3))\")\nprintln()\nprintln(\"Survivors: \\(Josephus.execucteAllButM(numberOfPeople: 41, spacing: 3, save: 3))\")\n\n\nOutput:\nPrisoners executed in order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15 \nJosephus is number: 30\n\nPrisoners executed in order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 \nSurvivors: [15, 30, 34]\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "R", "code": "\nGrowing circle solution[edit]\njose <-function(s, r,n){\ny <- 0:(r-1)\n for (i in (r+1):n)\n  y <- (y + s) %% i \n return(y)\n}\n> jose(3,1,41) # r is the number of remained prisoner.\n[1] 30\n\nIterative solution[edit]\n\nIt is 1-indexed, meaning that we will have a tough time using most solutions that exploit modular arithmetic.\nIt lacks any concept of a linked list, meaning that we can't take a circular list approach.\nThe idiomatic way to roll an array in R (e.g. as the Ruby solution has) is to exploit the head and tail functions, but those break if we are rolling by more than the length of the array (see https://stackoverflow.com/q/18791212 for a few tricks for this).\n\njosephusProblem <- function(n, k, m)\n{\n  prisoners <- 0:(n - 1)\n  exPos <- countToK <- 1\n  dead <- integer(0)\n  while(length(prisoners) > m)\n  {\n    if(countToK == k)\n    {\n      dead <- c(dead, prisoners[exPos])\n      prisoners <- prisoners[-exPos]\n      exPos <- exPos - 1\n    }\n    exPos <- exPos + 1\n    countToK <- countToK + 1\n  if(exPos > length(prisoners)) exPos <- 1\n  if(countToK > k) countToK <- 1\n  }\n  print(paste0(\"Execution order: \", paste0(dead, collapse = \", \"), \".\"))\n  paste0(\"Survivors: \", paste0(prisoners, collapse = \", \"), \".\")\n}\n\n\nOutput:\n> josephusProblem(5, 2, 1)\n[1] \"Execution order: 1, 3, 0, 4.\"\n[1] \"Survivors: 2.\"\n> josephusProblem(41, 3, 1)\n[1] \"Execution order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\"\n[1] \"Survivors: 30.\"\n> josephusProblem(41, 3, 3)\n[1] \"Execution order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3.\"\n[1] \"Survivors: 15, 30, 34.\"\n", "explain": "I hope to be proven wrong, but R seems to be the wrong tool for this problem:\nRegardless, it is still solvable. The following adapts a great deal of the Lua solution. The arguments n, k, and m are as in the task description.\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Ada", "code": "\n\nwith Ada.Command_Line, Ada.Text_IO;\n\nprocedure Josephus is\n\n   function Arg(Idx, Default: Positive) return Positive is -- read Argument(Idx)\n      (if Ada.Command_Line.Argument_Count >= Index\n         then Positive'Value(Ada.Command_Line.Argument(Index)) else Default);\n\n   Prisoners:  constant Positive := Arg(Idx => 1, Default => 41);\n   Steps:      constant Positive := Arg(Idx => 2, Default =>  3);\n   Survivors:  constant Positive := Arg(Idx => 3, Default =>  1);\n   Print:               Boolean := (Arg(Idx => 4, Default =>  1) = 1);\n\n   subtype Index_Type is Natural range 0 .. Prisoners-1;\n   Next: array(Index_Type) of Index_Type;\n   X: Index_Type := (Steps-2) mod Prisoners;\n\nbegin\n   Ada.Text_IO.Put_Line\n     (\"N =\" & Positive'Image(Prisoners) & \",  K =\" & Positive'Image(Steps) &\n        (if Survivors > 1 then \",  #survivors =\" & Positive'Image(Survivors)\n        else \"\"));\n   for Idx in Next'Range loop -- initialize Next\n      Next(Idx) := (Idx+1) mod Prisoners;\n   end loop;\n   if Print then\n      Ada.Text_IO.Put(\"Executed: \");\n   end if;\n   for Execution in reverse 1 .. Prisoners loop\n      if Execution = Survivors then\n         Ada.Text_IO.New_Line;\n         Ada.Text_IO.Put(\"Surviving: \");\n         Print := True;\n      end if;\n      if Print then\n         Ada.Text_IO.Put(Positive'Image(Next(X)));\n      end if;\n      Next(X) := Next(Next(X)); -- \"delete\" a prisoner\n      for Prisoner in 1 .. Steps-1 loop\n         X := Next(X);\n      end loop;\n   end loop;\nend Josephus;\n\n\nOutput:\n$ ./josephus\nN = 41,  K = 3\nExecuted:  2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15\nSurviving:  30\n\n$ ./josephus 23482 3343 3 0\nN = 23482,  K = 3343,  #survivors = 3\n\nSurviving:  13317 1087 1335\n", "explain": "The procedure reads up to 4 parameters from the command line: the number N of prisoners, the step size K, the number M of survivors, and an indicator whether the executions shall be printed (\"1\") or only surviving prisoners (any other input). The defaults are 41, 3, 1, 1. The prison cells are numbered from 0 to N-1. \n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nusing Memoize\n@memoize josephus(n::Integer, k::Integer, m::Integer=1) = n == m ? collect(0:m .- 1) : mod.(josephus(n - 1, k, m) + k, n)\n\n@show josephus(41, 3)\n@show josephus(41, 3, 5)\n\n\nOutput:\njosephus(41, 3) = [30]\njosephus(41, 3, 5) = [3, 15, 21, 30, 34]\n\nfunction josephus(n::Integer, k::Integer, m::Integer=1)\n    p, i, seq = collect(0:n-1), 0, Vector{typeof(n)}(0)\n    while length(p) > m\n        i = (i + k - 1) % length(p)\n        push!(seq, splice!(p, i + 1))\n    end\n    return seq, p\nend\n\nseq, surv = josephus(41, 3)\nprintln(\"Prisoner killing in order: $seq\\nSurvivor: $surv\")\n\nseq, surv = josephus(41, 3, 3)\nprintln(\"Prisoner killing in order: $seq\\nSurvivor: $surv\")\n\n\nOutput:\nPrisoner killing in order: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15]\nSurvivor: [30]\nPrisoner killing in order: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3]\nSurvivor: [15, 30, 34]\n", "explain": "Recursive (with Memoize):\nIterative:\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\n// version 1.1.3\n\nfun josephus(n: Int, k: Int, m: Int): Pair<List<Int>, List<Int>> {\n    require(k > 0 && m > 0 && n > k && n > m)\n    val killed = mutableListOf<Int>()\n    val survived = MutableList(n) { it }\n    var start = k - 1\n    outer@ while (true) {\n        val end = survived.size - 1\n        var i = start\n        var deleted = 0\n        while (i <= end) {\n            killed.add(survived.removeAt(i - deleted))\n            if (survived.size == m) break@outer\n            deleted++\n            i += k\n        } \n        start = i - end - 1\n    }\n    return Pair(survived, killed)\n}\n \nfun main(args: Array<String>) {\n    val triples = listOf(Triple(5, 2, 1), Triple(41, 3, 1), Triple(41, 3, 3))\n    for (triple in triples) {\n        val(n, k, m) = triple \n        println(\"Prisoners = $n, Step = $m, Survivors = $m\")\n        val (survived, killed)  = josephus(n, k, m)\n        println(\"Survived  \u00a0: $survived\")\n        println(\"Kill order\u00a0: $killed\")\n        println()\n    }\n}\n\n\nOutput:\nPrisoners = 5, Step = 1, Survivors = 1\nSurvived  \u00a0: [2]\nKill order\u00a0: [1, 3, 0, 4]\n\nPrisoners = 41, Step = 1, Survivors = 1\nSurvived  \u00a0: [30]\nKill order\u00a0: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15]\n\nPrisoners = 41, Step = 3, Survivors = 3\nSurvived  \u00a0: [15, 30, 34]\nKill order\u00a0: [2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3]\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Perl", "code": "\nTranslation of: Raku\nmy @prisoner = 0 .. 40;\nmy $k = 3;\nuntil (@prisoner == 1) {\n    push @prisoner, shift @prisoner for 1 .. $k-1;\n    shift @prisoner;\n}\n\nprint \"Prisoner @prisoner survived.\\n\"\n\n\nOutput:\nPrisoner 30 survived.\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Lua", "code": "\n\nfunction josephus(n, k, m)\n    local positions={}\n    for i=1,n do\n        table.insert(positions, i-1)\n    end\n    local i,j=1,1\n    local s='Execution order: '\n    while #positions>m do\n        if j==k then\n            s=s .. positions[i] .. ', '\n            table.remove(positions, i)\n            i=i-1\n        end\n        i=i+1\n        j=j+1\n        if i>#positions then i=1 end\n        if j>k then j=1 end\n    end\n    print(s:sub(1,#s-2) .. '.')\n    local s='Survivors: '\n    for _,v in pairs(positions) do s=s .. v .. ', ' end\n    print(s:sub(1,#s-2) .. '.')\nend\njosephus(41,3, 1)\n\n\nOutput:\nExecution order: 2, 5, 8, 11, 14, 17, 20, 23, 26, 29, 32, 35, 38, 0, 4, 9, 13, 18, 22, 27, 31, 36, 40, 6, 12, 19, 25, 33, 39, 7, 16, 28, 37, 10, 24, 1, 21, 3, 34, 15.\nSurvivors: 30.\n\n", "explain": "Lua indexes tables starting at 1. Positions are stored from 0,n-1.\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Scala", "code": "\n\ndef executed( prisonerCount:Int, step:Int ) = {\n\n  val prisoners = ((0 until prisonerCount) map (_.toString)).toList\n\n  def behead( dead:Seq[String], alive:Seq[String] )(countOff:Int) : (Seq[String], Seq[String]) = {\n    val group = if( alive.size < countOff ) countOff - alive.size else countOff\n\t\n    (dead ++ alive.take(group).drop(group-1), alive.drop(group) ++ alive.take(group-1))\n  }\n\n  def beheadN( dead:Seq[String], alive:Seq[String] ) : (Seq[String], Seq[String]) =\n    behead(dead,alive)(step)\n\n  def execute( t:(Seq[String], Seq[String]) ) : (Seq[String], Seq[String]) = t._2 match {\n    case x :: Nil => (t._1, Seq(x))\n    case x :: xs => execute(beheadN(t._1,t._2))\n  }\n\n  execute((List(),prisoners))\n}\n\nval (dead,alive) = executed(41,3)\n  \nprintln( \"Prisoners executed in order:\" )\nprint( dead.mkString(\" \") )\n\t\nprintln( \"\\n\\nJosephus is prisoner \" + alive(0) )\n\n\nOutput:\nPrisoners executed in order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15\n\nJosephus is prisoner 30\n", "explain": "Executioner's Solution, not Josephus'\n(Prisoners labeled 0 to n-1)\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "D", "code": "\nTranslation of: Python\nimport std.stdio, std.algorithm, std.array, std.string, std.range;\n\nT pop(T)(ref T[] items, in size_t i) pure /*nothrow*/ @safe /*@nogc*/ {\n    auto aux = items[i];\n    items = items.remove(i);\n    return aux;\n}\n\nstring josephus(in int n, in int k) pure /*nothrow*/ @safe {\n    auto p = n.iota.array;\n    int i;\n    immutable(int)[] seq;\n    while (!p.empty) {\n        i = (i + k - 1) % p.length;\n        seq ~= p.pop(i);\n    }\n\n    return format(\"Prisoner killing order:\\n%(%(%d\u00a0%)\\n%).\" ~\n                  \"\\nSurvivor: %d\",\n                  seq[0 .. $ - 1].chunks(20), seq[$ - 1]);\n}\n\nvoid main() /*@safe*/ {\n    josephus(5, 2).writeln;\n    writeln;\n    josephus(41, 3).writeln;\n}\n\n\nOutput:\nPrisoner killing order:\n1 3 0 4.\nSurvivor: 2\n\nPrisoner killing order:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27\n31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15.\nSurvivor: 30\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Haskell", "code": "\n\nimport Data.List ((\\\\))\nimport System.Environment (getArgs)\n\nprisoners :: Int -> [Int]\nprisoners n = [0 .. n - 1]\n\ncounter :: Int -> [Int]\ncounter k = cycle [k, k-1 .. 1]\n\nkillList :: [Int] -> [Int] -> ([Int], [Int], [Int])\nkillList xs cs = (killed, survivors, newCs)\n    where\n        (killed, newCs) = kill xs cs []\n        survivors = xs \\\\ killed\n        kill [] cs rs = (rs, cs)\n        kill (x:xs) (c:cs) rs\n            | c == 1 =\n                let ts = rs ++ [x]\n                in  kill xs cs ts\n            | otherwise =\n                kill xs cs rs\n\nkillRecursive :: [Int] -> [Int] -> Int -> ([Int], [Int])\nkillRecursive xs cs m = killR ([], xs, cs)\n    where\n        killR (killed, remaining, counter)\n            | length remaining <= m = (killed, remaining)\n            | otherwise =\n                let (newKilled, newRemaining, newCounter) =\n                        killList remaining counter\n                    allKilled = killed ++ newKilled\n                in  killR (allKilled, newRemaining, newCounter)\n\nmain :: IO ()\nmain = do\n    args <- getArgs\n    case args of\n        [n, k, m] -> print $ snd $ killRecursive (prisoners (read n))\n                        (counter (read k)) (read m)\n        _         -> print $ snd $ killRecursive (prisoners 41) (counter 3) 1\n\n\njseq :: Int -> Int -> [Int]\njseq n k = f n [1 .. n]\n  where\n    f 0 _ = []\n    f m s = x : f (m - 1) (right ++ left)\n      where\n        (left, x:right) = splitAt (mod (k - 1) m) s\n\n-- the final survivor is ((k + ...((k + ((k + 0)`mod` 1)) `mod` 2) ... ) `mod` n)\njos :: Int -> Int -> Int\njos n k = 1 + foldl (mod . (k +)) 0 [2 .. n]\n\nmain :: IO ()\nmain = do\n  print $ jseq 41 3\n  print $ jos 10000 100\n\n", "explain": "Shows only the surviving prisoners. Change \"print $ snd\" to just \"print\" to show the killed prisoners, too.\nThe arguments to the \"main\" function are: n = number of prisoners, k = kill every kth prisoner,\nm = show at most m survivors\nUsing modulo and list split, indices are 1-based. This is much faster than cycled list for larger numbers:\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "TypeScript", "code": "\nfunction josephus(n: number, k: number): number {\n  if (!n) {\n    return 1;\n  }\n\n  return ((josephus(n - 1, k) + k - 1)\u00a0% n) + 1;\n}\n\nOutput:\n> josephus(41, 3);\n31\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 2\n\nfunction Get-JosephusPrisoners ( [int]$N, [int]$K )\n    {\n    #  Just for convenience\n    $End = $N - 1\n \n    #  Create circle of prisoners\n    $Prisoners = New-Object System.Collections.ArrayList ( , (0..$End) )\n \n    #  For each starting point of the reducing circle...\n    ForEach ( $Start in 0..($End - 1) )\n        {\n        #  We subtract one from K for the one we advanced by incrementing $Start\n        #  Then take K modulus the length of the remaining circle\n        $RoundK = ( $K - 1 ) % ( $End - $Start + 1 )\n       \n        #  Rotate the remaining prisoners K places around the remaining circle\n        $Prisoners.SetRange( $Start, $Prisoners[ $Start..$End ][ ( $RoundK + $Start - $End - 1 )..( $RoundK - 1 ) ] )\n        }\n    return $Prisoners\n    }\n\n#  Get the prisoner order for a circle of 41 prisoners, selecting every third\n$Prisoners = Get-JosephusPrisoners -N 41 -K 3\n \n#  Display the prisoner order\n$Prisoners -join \" \"\n \n#  Display the last remaining prisoner\n\"Last prisoner remmaining: \" + $Prisoners[-1]\n \n#  Display the last three remaining prisoners\n$S = 3\n\"Last $S remaining: \" + $Prisoners[-$S..-1]\n\n\nOutput:\n2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15 30\nLast prisoner remmaining: 30\nLast 3 remaining: 34 15 30\n\n", "explain": "Adapted from the iterative algorithm in Sidef.\nRotating the circle K prisoners is equivalent to the executioner walking around the circle K prisoners.\nWe rotate the circle to bring the next selectee to the \"front\" of the circle, then \"select\" him\nby moving past him to the remaining circle. After repeating through the entire prisoner population, we\nare left with the prisoners sorted into the order in which they are selected.\nThe lonely comma in the line where we create the $Prisoners arraylist is to prevent PowerShell from being too helpful.\nNormally when we present the PowerShell parser with an array within an array, it treats it as a cast, and\nwe end up with the single array of elements. In those cases where we need an array to be treated as a single element of a parent array, we can use the unary comma to force PowerShell to treat it as an element.\n"}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "Groovy", "code": "\nint[] Josephus (int size, int kill, int survivors) {\n    // init user pool\n    def users = new int[size];\n    \n    // give initial values such that [0] = 1 (first person) [1] = 2 (second person) etc\n    users.eachWithIndex() {obj, i -> users[i] = i + 1};\n    \n    // keep track of which person we are on (ranging from 1 to kill)\n    def person = 1;\n    \n    // keep going until we have the desired number of survivors\n    while (users.size() > survivors)\n    {\n        // for each person, if they are the kill'th person, set them to -1 to show eliminated\n        users.eachWithIndex() {obj, i ->\n            if (person++ % kill == 0) {\n                users[i] = -1;\n            }\n            \n            // if person overflowed kill then reset back to 1\n            if (person > kill) {person = 1;}\n        }\n        \n        // clear out all eliminated persons\n        users = users.findAll{w -> w >= 0};\n    }\n    \n    // resulting set is the safe positions\n    return users;\n}\n\n// Run some test cases\n\nprintln \"Final survivor for n = 10201 and k = 17: \" + Josephus(10201,17,1)[0];\n\nprintln \"4 safe spots for n = 10201 and k = 17: \" + Josephus(10201,17,4);\n\n\nOutput:\nFinal survivor for n = 10201 and k = 17: 7450\n4 safe spots for n = 10201 and k = 17: [3413, 7244, 7450, 7605]\n\n", "explain": ""}, {"task_name": "Josephus problem", "task_url": "https://rosettacode.org/wiki/Josephus_problem", "task_cat": "Puzzles", "lang": "AWK", "code": "\n# syntax: GAWK -f JOSEPHUS_PROBLEM.AWK\n# converted from PL/I\nBEGIN {\n    main(5,2,1)\n    main(41,3,1)\n    main(41,3,3)\n    exit(0)\n}\nfunction main(n,k,s,  dead,errors,found,i,killed,nn,p,survived) {\n# n - number of prisoners\n# k - kill every k'th prisoner\n# s - number of survivors\n    printf(\"\\nn=%d k=%d s=%d\\n\",n,k,s) # show arguments\n    if (s > n) { print(\"s>n\"); errors++ }\n    if (k <= 0) { print(\"k<=0\"); errors++ }\n    if (errors > 0) { return(0) }\n    nn = n                             # wrap around boundary\n    p = -1                             # start here\n    while (n != s) {                   # until survivor count is met\n      found = 0                        # start looking\n      while (found != k) {             # until we have the k-th prisoner\n        if (++p == nn) { p = 0 }       # wrap around\n        if (dead[p] != 1) { found++ }  # if prisoner is alive increment found\n      }\n      dead[p] = 1                      # kill the unlucky one\n      killed = killed p \" \"            # build killed list\n      n--                              # reduce size of circle\n    }\n    for (i=0; i<=nn-1; i++) {\n      if (dead[i] != 1) {\n        survived = survived i \" \"      # build survivor list\n      }\n    }\n    printf(\"killed: %s\\n\",killed)\n    printf(\"survived: %s\\n\",survived)\n    return(1)\n}\n\n\nOutput:\nn=5 k=2 s=1\nkilled: 1 3 0 4\nsurvived: 2\n\nn=41 k=3 s=1\nkilled: 2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3 34 15\nsurvived: 30\n\nn=41 k=3 s=3\nkilled: 2 5 8 11 14 17 20 23 26 29 32 35 38 0 4 9 13 18 22 27 31 36 40 6 12 19 25 33 39 7 16 28 37 10 24 1 21 3\nsurvived: 15 30 34\n\n", "explain": ""}]