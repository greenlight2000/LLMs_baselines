[{"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Python", "code": "\nWorks with: Python version 3\nTranslation of: Haskell\n'''Vigenere encryption and decryption'''\n\nfrom itertools import starmap, cycle\n\n\ndef encrypt(message, key):\n    '''Vigenere encryption of message using key.'''\n\n    # Converted to uppercase.\n    # Non-alpha characters stripped out.\n    message = filter(str.isalpha, message.upper())\n\n    def enc(c, k):\n        '''Single letter encryption.'''\n\n        return chr(((ord(k) + ord(c) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(enc, zip(message, cycle(key))))\n\n\ndef decrypt(message, key):\n    '''Vigenere decryption of message using key.'''\n\n    def dec(c, k):\n        '''Single letter decryption.'''\n\n        return chr(((ord(c) - ord(k) - 2 * ord('A')) % 26) + ord('A'))\n\n    return ''.join(starmap(dec, zip(message, cycle(key))))\n\n\ndef main():\n    '''Demonstration'''\n\n    text = 'Beware the Jabberwock, my son! The jaws that bite, ' + (\n           'the claws that catch!'\n    )\n    key = 'VIGENERECIPHER'\n\n    encr = encrypt(text, key)\n    decr = decrypt(encr, key)\n\n    print(text)\n    print(encr)\n    print(decr)\n\n\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": "\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <stdbool.h>\n#include <ctype.h>\n#include <getopt.h>\n\n#define NUMLETTERS 26\n#define BUFSIZE 4096\n\nchar *get_input(void);\n\nint main(int argc, char *argv[])\n{\n    char const usage[] = \"Usage: vinigere [-d] key\";\n    char sign = 1; \n    char const plainmsg[] = \"Plain text:  \";\n    char const cryptmsg[] = \"Cipher text: \";\n    bool encrypt = true;\n    int opt;\n\n    while ((opt = getopt(argc, argv, \"d\")) != -1) {\n        switch (opt) {\n        case 'd': \n            sign = -1;\n            encrypt = false;\n            break;\n        default: \n            fprintf(stderr, \"Unrecogized command line argument:'-%i'\\n\", opt);\n            fprintf(stderr, \"\\n%s\\n\", usage);\n            return 1;\n        }\n    }\n\n    if (argc - optind != 1) {\n        fprintf(stderr, \"%s requires one argument and one only\\n\", argv[0]);\n        fprintf(stderr, \"\\n%s\\n\", usage);\n        return 1;\n    }\n\n\n    // Convert argument into array of shifts\n    char const *const restrict key = argv[optind];\n    size_t const keylen = strlen(key);\n    char shifts[keylen];\n\n    char const *restrict plaintext = NULL; \n    for (size_t i = 0; i < keylen; i++) {\n        if (!(isalpha(key[i]))) {\n            fprintf(stderr, \"Invalid key\\n\");\n            return 2;\n        }\n        char const charcase = (isupper(key[i])) ? 'A' : 'a';\n        // If decrypting, shifts will be negative.\n        // This line would turn \"bacon\" into {1, 0, 2, 14, 13}\n        shifts[i] = (key[i] - charcase) * sign;\n    }\n\n    do {\n        fflush(stdout);\n        // Print \"Plain text: \" if encrypting and \"Cipher text:  \" if\n        // decrypting\n        printf(\"%s\", (encrypt) ? plainmsg : cryptmsg);\n        plaintext = get_input();\n        if (plaintext == NULL) {\n            fprintf(stderr, \"Error getting input\\n\");\n            return 4;\n        }\n    } while (strcmp(plaintext, \"\") == 0); // Reprompt if entry is empty\n\n    size_t const plainlen = strlen(plaintext);\n\n    char* const restrict ciphertext = calloc(plainlen + 1, sizeof *ciphertext);\n    if (ciphertext == NULL) {\n        fprintf(stderr, \"Memory error\\n\");\n        return 5;\n    }\n\n    for (size_t i = 0, j = 0; i < plainlen; i++) {\n        // Skip non-alphabetical characters\n        if (!(isalpha(plaintext[i]))) {\n            ciphertext[i] = plaintext[i];\n            continue;\n        }\n        // Check case\n        char const charcase = (isupper(plaintext[i])) ? 'A' : 'a';\n        // Wrapping conversion algorithm\n        ciphertext[i] = ((plaintext[i] + shifts[j] - charcase + NUMLETTERS) % NUMLETTERS) + charcase;\n        j = (j+1) % keylen;\n    }\n    ciphertext[plainlen] = '\\0';\n    printf(\"%s%s\\n\", (encrypt) ? cryptmsg : plainmsg, ciphertext);\n\n    free(ciphertext);\n    // Silence warnings about const not being maintained in cast to void*\n    free((char*) plaintext);\n    return 0;\n}\nchar *get_input(void) {\n\n    char *const restrict buf = malloc(BUFSIZE * sizeof (char));\n    if (buf == NULL) {\n        return NULL;\n    }\n\n    fgets(buf, BUFSIZE, stdin);\n\n    // Get rid of newline\n    size_t const len = strlen(buf);\n    if (buf[len - 1] == '\\n') buf[len - 1] = '\\0';\n\n    return buf;\n}\n\n\nOutput:\n$ ./vigenere VIGENERECIPHER\nPlain text:  Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\nCipher text: Wmceei klg Rpifvmeugx, qp wqv! Ioi avey xuek fkbt, alv xtgaf xyev kpagy!\n\n$ ./vigenere -d VIGENERECIPHER\nCipher text: Wmceei klg Rpifvmeugx, qp wqv! Ioi avey xuek fkbt, alv xtgaf xyev kpagy!\nPlain text:  Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\n", "explain": "This program skips non-alphabetical characters, preserves case, and when run with the -d command line flag, decrypts the message rather than encrypting.\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "C++", "code": "\n#include <iostream>\n#include <string>\nusing namespace std;\n\nclass Vigenere\n{\npublic:\n  string key;\n\n  Vigenere(string key)\n  {\n    for(int i = 0; i < key.size(); ++i)\n    {\n      if(key[i] >= 'A' && key[i] <= 'Z')\n        this->key += key[i];\n      else if(key[i] >= 'a' && key[i] <= 'z')\n        this->key += key[i] + 'A' - 'a';\n    }\n  }\n\n  string encrypt(string text)\n  {\n    string out;\n\n    for(int i = 0, j = 0; i < text.length(); ++i)\n    {\n      char c = text[i];\n      \n      if(c >= 'a' && c <= 'z')\n        c += 'A' - 'a';\n      else if(c < 'A' || c > 'Z')\n        continue;\n\n      out += (c + key[j] - 2*'A') % 26 + 'A'; \n      j = (j + 1) % key.length();\n    }\n\n    return out;\n  }\n\n  string decrypt(string text)\n  {\n    string out;\n\n    for(int i = 0, j = 0; i < text.length(); ++i)\n    {\n      char c = text[i];\n      \n      if(c >= 'a' && c <= 'z')\n        c += 'A' - 'a';\n      else if(c < 'A' || c > 'Z')\n        continue;\n\n      out += (c - key[j] + 26) % 26 + 'A'; \n      j = (j + 1) % key.length();\n    }\n\n    return out;\n  }\n};\n\nint main()\n{\n  Vigenere cipher(\"VIGENERECIPHER\");\n\n  string original = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n  string encrypted = cipher.encrypt(original);\n  string decrypted = cipher.decrypt(encrypted);\n\n  cout << original << endl;\n  cout << \"Encrypted: \" << encrypted << endl;\n  cout << \"Decrypted: \" << decrypted << endl;\n}\n\n\nOutput:\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Java", "code": "\nTranslation of: D\npublic class VigenereCipher {\n    public static void main(String[] args) {\n        String key = \"VIGENERECIPHER\";\n        String ori = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n        String enc = encrypt(ori, key);\n        System.out.println(enc);\n        System.out.println(decrypt(enc, key));\n    }\n\n    static String encrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c + key.charAt(j) - 2 * 'A') % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n\n    static String decrypt(String text, final String key) {\n        String res = \"\";\n        text = text.toUpperCase();\n        for (int i = 0, j = 0; i < text.length(); i++) {\n            char c = text.charAt(i);\n            if (c < 'A' || c > 'Z') continue;\n            res += (char)((c - key.charAt(j) + 26) % 26 + 'A');\n            j = ++j % key.length();\n        }\n        return res;\n    }\n}\n\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\nAlternative Version[edit]\nimport com.google.common.collect.Streams;\nimport java.util.function.Supplier;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\nimport static java.nio.charset.StandardCharsets.US_ASCII;\n\npublic class VigenereCipher {\n    private final static int LOWER = 'A';\n    private final static int UPPER = 'Z';\n    private final static int SIZE = UPPER - LOWER + 1;\n    private final Supplier<Stream<Character>> maskStream;\n\n    public VigenereCipher(final String key) {\n        final String mask = new String(key.getBytes(US_ASCII)).toUpperCase();\n        maskStream = () ->\n                Stream.iterate(0, i -> (i+1) % mask.length()).map(mask::charAt);\n    }\n\n    private String transform(final String text, final boolean encode) {\n        final Stream<Integer> textStream = text.toUpperCase().chars().boxed()\n                .filter(i -> i >= LOWER && i <= UPPER);\n        return Streams.zip(textStream, maskStream.get(), (c, m) ->\n                encode ? c + m - 2 * LOWER : c - m + SIZE)\n            .map(c -> Character.toString(c % SIZE + LOWER))\n            .collect(Collectors.joining());\n    }\n\n    public String encrypt(final String plaintext) {\n        return transform(plaintext,true);\n    }\n\n    public String decrypt(final String ciphertext) {\n        return transform(ciphertext,false);\n    }\n}\n\nimport org.junit.jupiter.api.DisplayName;\nimport org.junit.jupiter.api.Test;\nimport static org.junit.jupiter.api.Assertions.assertEquals;\n\nclass VigenereCipherTest {\n    private static final VigenereCipher Vigenere = new VigenereCipher(\"VIGENERECIPHER\");\n\n    @Test\n    @DisplayName(\"encipher/decipher round-trip succeeds\")\n    void vigenereCipherTest() {\n        final String input = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n        final String expectEncrypted = \"WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\";\n        final String expectDecrypted = \"BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\";\n\n        final String ciphertext = Vigenere.encrypt(input);\n        assertEquals(expectEncrypted, ciphertext);\n\n        final String plaintext = Vigenere.decrypt(ciphertext);\n        assertEquals(expectDecrypted, plaintext);\n    }\n\n}\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "C#", "code": "\nusing System;\n\nnamespace VigenereCipher\n{\n    class VCipher\n    {\n        public string encrypt(string txt, string pw, int d)\n        {\n            int pwi = 0, tmp;\n            string ns = \"\";\n            txt = txt.ToUpper();\n            pw = pw.ToUpper();\n            foreach (char t in txt)\n            {\n                if (t < 65) continue;\n                tmp = t - 65 + d * (pw[pwi] - 65);\n                if (tmp < 0) tmp += 26;\n                ns += Convert.ToChar(65 + ( tmp % 26) );\n                if (++pwi == pw.Length) pwi = 0;\n            }\n\n            return ns;\n        }\n    };\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            VCipher v = new VCipher();\n\n            string s0 = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\",\n                   pw = \"VIGENERECIPHER\";\n\n            Console.WriteLine(s0 + \"\\n\" + pw + \"\\n\");\n            string s1 = v.encrypt(s0, pw, 1);\n            Console.WriteLine(\"Encrypted: \" + s1);\n            s1 = v.encrypt(s1, \"VIGENERECIPHER\", -1);\n            Console.WriteLine(\"Decrypted: \" + s1);\n            Console.WriteLine(\"\\nPress any key to continue...\");\n            Console.ReadKey();\n        }\n    }\n}\n\n\nOutput:\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\nVIGENERECIPHER\n\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "JavaScript", "code": "\n// helpers\n// helper\nfunction ordA(a) {\n  return a.charCodeAt(0) - 65;\n}\n\n// vigenere\nfunction vigenere(text, key, decode) {\n  var i = 0, b;\n  key = key.toUpperCase().replace(/[^A-Z]/g, '');\n  return text.toUpperCase().replace(/[^A-Z]/g, '').replace(/[A-Z]/g, function(a) {\n    b = key[i++ % key.length];\n    return String.fromCharCode(((ordA(a) + (decode ? 26 - ordA(b) : ordA(b))) % 26 + 65));\n  });\n}\n\n// example\nvar text = \"The quick brown fox Jumped over the lazy Dog the lazy dog lazy dog dog\";\nvar key = 'alex';\nvar enc = vigenere(text,key);\nvar dec = vigenere(enc,key,true);\n\nconsole.log(enc);\nconsole.log(dec);\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "PHP", "code": "\nTranslation of: C\n<?php\n\n$str = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n$key = \"VIGENERECIPHER\";\n\nprintf(\"Text: %s\\n\", $str);\nprintf(\"key:  %s\\n\", $key);\n\n$cod = encipher($str, $key, true); printf(\"Code: %s\\n\", $cod);\n$dec = encipher($cod, $key, false); printf(\"Back: %s\\n\", $dec);\n\nfunction encipher($src, $key, $is_encode)\n{\n    $key = strtoupper($key);\n    $src = strtoupper($src);\n    $dest = '';\n\n    /* strip out non-letters */\n    for($i = 0; $i <= strlen($src); $i++) {\n        $char = substr($src, $i, 1);\n        if(ctype_upper($char)) {\n            $dest .= $char;\n        }\n    }\n\n    for($i = 0; $i <= strlen($dest); $i++) {\n        $char = substr($dest, $i, 1);\n        if(!ctype_upper($char)) {\n            continue;\n        }\n        $dest = substr_replace($dest,\n            chr (\n                ord('A') +\n                ($is_encode\n                   ? ord($char) - ord('A') + ord($key[$i % strlen($key)]) - ord('A')\n                   : ord($char) - ord($key[$i % strlen($key)]) + 26\n                ) % 26\n            )\n        , $i, 1);\n    }\n\n    return $dest;\n}\n\n?>\n\n\nOutput:\nText: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\nkey:  VIGENERECIPHER\nCode: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBack: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Fortran", "code": "\nWorks with: Fortran version 95 and later\nprogram vigenere_cipher\n  implicit none\n  \n  character(80) :: plaintext = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\", &\n                   ciphertext = \"\"\n  character(14) :: key = \"VIGENERECIPHER\"\n\n\n  call encrypt(plaintext, ciphertext, key)\n  write(*,*) plaintext\n  write(*,*) ciphertext\n  call decrypt(ciphertext, plaintext, key)\n  write(*,*) plaintext\n\ncontains\n\nsubroutine encrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    select case(intxt(i:i))\n      case (\"A\":\"Z\", \"a\":\"z\")\n        select case(intxt(i:i))\n          case(\"a\":\"z\")\n            chrn = iachar(intxt(i:i)) - 32\n   \n          case default\n            chrn = iachar(intxt(i:i))\n                         \n        end select\n     \n        outtxt(cp:cp) = achar(modulo(chrn + iachar(k(kp:kp)), 26) + 65)\n        cp = cp + 1\n        kp = kp + 1\n        if(kp > len(k)) kp = kp - len(k)\n \n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(intxt, outtxt, k)\n  character(*), intent(in)  :: intxt, k\n  character(*), intent(out) :: outtxt\n  integer :: chrn\n  integer :: cp = 1, kp = 1\n  integer :: i\n  \n  outtxt = \"\"\n  do i = 1, len(trim(intxt))\n    chrn = iachar(intxt(i:i))\n    outtxt(cp:cp) = achar(modulo(chrn - iachar(k(kp:kp)), 26) + 65)\n    cp = cp + 1\n    kp = kp + 1\n    if(kp > len(k)) kp = kp - len(k)\n   end do\nend subroutine\nend program\n\n\nOutput:\n Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\n WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\n BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": "\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\ntype vkey string\n\nfunc newVigen\u00e8re(key string) (vkey, bool) {\n    v := vkey(upperOnly(key))\n    return v, len(v) > 0 // key length 0 invalid\n}\n\nfunc (k vkey) encipher(pt string) string {\n    ct := upperOnly(pt)\n    for i, c := range ct {\n        ct[i] = 'A' + (c-'A'+k[i%len(k)]-'A')%26\n    }\n    return string(ct)\n}\n\nfunc (k vkey) decipher(ct string) (string, bool) {\n    pt := make([]byte, len(ct))\n    for i := range pt {\n        c := ct[i]\n        if c < 'A' || c > 'Z' {\n            return \"\", false // invalid ciphertext\n        }\n        pt[i] = 'A' + (c-k[i%len(k)]+26)%26\n    }\n    return string(pt), true\n}\n\n// upperOnly extracts letters A-Z, a-z from a string and\n// returns them all upper case in a byte slice.\n// Useful for vkey constructor and encipher function.\nfunc upperOnly(s string) []byte {\n    u := make([]byte, 0, len(s))\n    for i := 0; i < len(s); i++ {\n        c := s[i]\n        if c >= 'A' && c <= 'Z' {\n            u = append(u, c)\n        } else if c >= 'a' && c <= 'z' {\n            u = append(u, c-32)\n        }\n    }\n    return u\n}\n\nconst testKey = \"Vigen\u00e8re Cipher\"\nconst testPT = `Beware the Jabberwock, my son!\n    The jaws that bite, the claws that catch!`\n\nfunc main() {\n    fmt.Println(\"Supplied key: \", testKey)\n    v, ok := newVigen\u00e8re(testKey)\n    if !ok {\n        fmt.Println(\"Invalid key\")\n        return\n    }\n    fmt.Println(\"Effective key:\", v)\n    fmt.Println(\"Plain text:\", testPT)\n    ct := v.encipher(testPT)\n    fmt.Println(\"Enciphered:\", ct)\n    dt, ok := v.decipher(ct)\n    if !ok {\n        fmt.Println(\"Invalid ciphertext\")\n        return\n    }\n    fmt.Println(\"Deciphered:\", dt)\n}\n\n\nOutput:\nSupplied key:  Vigen\u00e8re Cipher\nEffective key: VIGENRECIPHER\nPlain text: Beware the Jabberwock, my son!\n        The jaws that bite, the claws that catch!\nEnciphered: WMCEEVXJMYHFSZZCSPBQAADUXYZRGAFKLCBQPXVOPKGYRAUBWHXTVBIL\nDeciphered: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\nfunction UpperAlphaOnly(S: string): string;\n{Remove all }\nvar I: integer;\nbegin\nResult:='';\nS:=UpperCase(S);\nfor I:=1 to Length(S) do\nif S[I] in ['A'..'Z'] then Result:=Result+S[I];\nend;\n\n\nfunction VigenereEncrypt(Text, Key: string): string;\n{Encrypt Text using specified key}\nvar KInx,TInx,I: integer;\nvar TC: byte;\nbegin\nResult:='';\n{Force Text and Key upper case}\nText:=UpperAlphaOnly(Text);\nKey:=UpperAlphaOnly(Key);\n{Point to first Key-character}\nKInx:=1;\nfor I:=1 to Length(Text) do\n\tbegin\n\t{Offset Text-char by key-char amount}\n\tTC:=byte(Text[I])-byte('A')+Byte(Key[KInx]);\n\t{if it is shifted past \"Z\", wrap back around past \"A\"}\n\tif TC>Byte('Z') then TC:=byte('@')+(TC-Byte('Z'));\n\t{Store in output string}\n\tResult:=Result+Char(TC);\n\t{Point to next Key-char}\n\tInc(Kinx);\n\t{If index post end of key, start over}\n\tif KInx>Length(Key) then KInx:=1;\n\tend;\nend;\n\n\nfunction VigenereDecrypt(Text, Key: string): string;\n{Encrypt Text using specified key}\nvar KInx,TInx,I: integer;\nvar TC: byte;\nbegin\nResult:='';\n{For Key and text uppercase}\nText:=UpperAlphaOnly(Text);\nKey:=UpperAlphaOnly(Key);\nKInx:=1;\nfor I:=1 to Length(Text) do\n\tbegin\n\t{subtrack key-char from text-char}\n\tTC:=byte(Text[I])-Byte(Key[Kinx])+Byte('A');\n\t{if result below \"A\" wrap back around to \"Z\"}\n\tif TC<Byte('A') then TC:=(byte('Z')-((Byte('A')-TC)))+1;\n\t{store in result}\n\tResult:=Result+Char(TC);\n\t{Point to next key char}\n\tInc(Kinx);\n\t{Past the end, start over}\n\tif KInx>Length(Key) then KInx:=1;\n\tend;\nend;\n\nconst TestKey = 'VIGENERECIPHER';\nconst TestStr = 'Beware the Jabberwock, my son! The jaws that bite, the claws that catch!';\n\n\nprocedure VigenereCipher(Memo: TMemo);\nvar S: string;\nbegin\n{Show plain text}\nMemo.Lines.Add(TestStr);\nS:=VigenereEncrypt(TestStr, TestKey);\n{Show encrypted text}\nMemo.Lines.Add(S);\nS:=VigenereDecrypt(S, TestKey);\n{Show decrypted text}\nMemo.Lines.Add(S);\nend;\n\n\nOutput:\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\nElapsed Time: 4.549 ms.\n\n\n\n", "explain": "\n\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Ruby", "code": "\nmodule VigenereCipher\n  \n  BASE = 'A'.ord\n  SIZE = 'Z'.ord - BASE + 1\n  \n  def encrypt(text, key)\n    crypt(text, key, :+)\n  end\n  \n  def decrypt(text, key)\n    crypt(text, key, :-)\n  end\n  \n  def crypt(text, key, dir)\n    text = text.upcase.gsub(/[^A-Z]/, '')\n    key_iterator = key.upcase.gsub(/[^A-Z]/, '').chars.map{|c| c.ord - BASE}.cycle\n    text.each_char.inject('') do |ciphertext, char|\n      offset = key_iterator.next\n      ciphertext << ((char.ord - BASE).send(dir, offset) % SIZE + BASE).chr\n    end\n  end\n  \nend\n\n\ninclude VigenereCipher\n\nplaintext = 'Beware the Jabberwock, my son! The jaws that bite, the claws that catch!'\nkey = 'Vigenere cipher'\nciphertext = VigenereCipher.encrypt(plaintext, key)\nrecovered  = VigenereCipher.decrypt(ciphertext, key)\n\nputs \"Original: #{plaintext}\"\nputs \"Encrypted: #{ciphertext}\"\nputs \"Decrypted: #{recovered}\"\n\n\nOutput:\nOriginal: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": "Demonstration:\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Rust", "code": "\nuse std::ascii::AsciiExt;\n\nstatic A: u8 = 'A' as u8;\n\nfn uppercase_and_filter(input: &str) -> Vec<u8> {\n    let alphabet = b\"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n    let mut result = Vec::new();\n\n    for c in input.chars() {\n        // Ignore anything that is not in our short list of chars. We can then safely cast to u8.\n        if alphabet.iter().any(|&x| x as char == c) {\n            result.push(c.to_ascii_uppercase() as u8);\n        }\n    }\n\n    return result;\n}\n\nfn vigenere(key: &str, text: &str, is_encoding: bool) -> String {\n\n    let key_bytes = uppercase_and_filter(key);\n    let text_bytes = uppercase_and_filter(text);\n\n    let mut result_bytes = Vec::new();\n\n    for (i, c) in text_bytes.iter().enumerate() {\n        let c2 = if is_encoding {\n            (c + key_bytes[i % key_bytes.len()] - 2 * A) % 26 + A\n        } else {\n            (c + 26 - key_bytes[i % key_bytes.len()]) % 26 + A\n        };\n        result_bytes.push(c2);\n    }\n\n    String::from_utf8(result_bytes).unwrap()\n}\n\nfn main() {\n    let text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n    let key = \"VIGENERECIPHER\";\n\n    println!(\"Text: {}\", text);\n    println!(\"Key:  {}\", key);\n\n    let encoded = vigenere(key, text, true);\n    println!(\"Code: {}\", encoded);\n    let decoded = vigenere(key, &encoded, false);\n    println!(\"Back: {}\", decoded);\n}\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Swift", "code": "\n\npublic func convertToUnicodeScalars(\n  str: String,\n  minChar: UInt32,\n  maxChar: UInt32\n) -> [UInt32] {\n  var scalars = [UInt32]()\n\n  for scalar in str.unicodeScalars {\n    let val = scalar.value\n\n    guard val >= minChar && val <= maxChar else {\n      continue\n    }\n\n    scalars.append(val)\n  }\n\n  return scalars\n}\n\npublic struct Vigenere {\n  private let keyScalars: [UInt32]\n  private let smallestScalar: UInt32\n  private let largestScalar: UInt32\n  private let sizeAlphabet: UInt32\n\n  public init?(key: String, smallestCharacter: Character = \"A\", largestCharacter:  Character = \"Z\") {\n    let smallScalars = smallestCharacter.unicodeScalars\n    let largeScalars = largestCharacter.unicodeScalars\n\n    guard smallScalars.count == 1, largeScalars.count == 1 else {\n      return nil\n    }\n\n    self.smallestScalar = smallScalars.first!.value\n    self.largestScalar = largeScalars.first!.value\n    self.sizeAlphabet = (largestScalar - smallestScalar) + 1\n\n    let scalars = convertToUnicodeScalars(str: key, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !scalars.isEmpty else {\n      return nil\n    }\n\n    self.keyScalars = scalars\n\n  }\n\n  public func decrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ sizeAlphabet &- keyScalars[i % keyScalars.count]) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n\n  public func encrypt(_ str: String) -> String? {\n    let txtBytes = convertToUnicodeScalars(str: str, minChar: smallestScalar, maxChar: largestScalar)\n\n    guard !txtBytes.isEmpty else {\n      return nil\n    }\n\n    var res = \"\"\n\n    for (i, c) in txtBytes.enumerated() where c >= smallestScalar && c <= largestScalar {\n      guard let char =\n        UnicodeScalar((c &+ keyScalars[i % keyScalars.count] &- 2 &* smallestScalar) % sizeAlphabet &+ smallestScalar)\n      else {\n        return nil\n      }\n\n      res += String(char)\n    }\n\n    return res\n  }\n}\n\nlet text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\nlet key = \"VIGENERECIPHER\";\nlet cipher = Vigenere(key: key)!\n\nprint(\"Key: \\(key)\")\nprint(\"Plain Text: \\(text)\")\n\nlet encoded = cipher.encrypt(text.uppercased())!\n\nprint(\"Cipher Text: \\(encoded)\")\n\nlet decoded = cipher.decrypt(encoded)!\n\nprint(\"Decoded: \\(decoded)\")\n\nprint(\"\\nLarger set:\")\n\nlet key2 = \"Vigen\u00e8re cipher\"\nlet text2 = \"This is a \u00fcnicode string \ud83d\ude03\"\n\nlet cipher2 = Vigenere(key: key2, smallestCharacter: \" \", largestCharacter: \"\ud83d\udef9\")!\n\nprint(\"Key: \\(key2)\")\nprint(\"Plain Text: \\(text2)\")\n\nlet encoded2 = cipher2.encrypt(text2)!\n\nprint(\"Cipher Text: \\(encoded2)\")\n\nlet decoded2 = cipher2.decrypt(encoded2)!\n\nprint(\"Decoded: \\(decoded2)\")\n\n\nOutput:\nKey: VIGENERECIPHER\nPlain Text: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\nCipher Text: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecoded: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\nLarger set:\nKey: Vigen\u00e8re cipher\nPlain Text: This is a \u00fcnicode string \ud83d\ude03\nCipher Text: \ufffd\u00b1\u00b0\u00b8n\u0131\u00c5eac\u0145\u00be\u00b1\u00a8\u00c1\ufffd\u00aeg\u00b8\u00c2\u013a\u00bb\u00b3gc\ud83d\ude4c\nDecoded: This is a \u00fcnicode string \ud83d\ude03\n", "explain": "Can support a larger range of characters, if desired\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "R", "code": "\nmod1 = function(v, n)\n# mod1(1:20, 6)   =>   1 2 3 4 5 6 1 2 3 4 5 6 1 2 3 4 5 6 1 2\n    ((v - 1) %% n) + 1\n\nstr2ints = function(s)\n    as.integer(Filter(Negate(is.na),\n        factor(levels = LETTERS, strsplit(toupper(s), \"\")[[1]])))\n\nvigen = function(input, key, decrypt = F)\n   {input = str2ints(input)\n    key = rep(str2ints(key), len = length(input)) - 1\n    paste(collapse = \"\", LETTERS[\n        mod1(input + (if (decrypt) -1 else 1)*key, length(LETTERS))])}\n\nmessage(vigen(\"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\", \"vigenerecipher\"))\n  # WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nmessage(vigen(\"WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\", \"vigenerecipher\", decrypt = T))\n  # BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Ada", "code": "\nWITH Ada.Text_IO, Ada.Characters.Handling;\nUSE Ada.Text_IO, Ada.Characters.Handling;\n\nPROCEDURE Main IS\n   SUBTYPE Alpha IS Character RANGE 'A' .. 'Z';\n   TYPE Ring IS MOD (Alpha'Range_length);\n   TYPE Seq IS ARRAY (Integer RANGE <>) OF Ring;\n   \n   FUNCTION \"+\" (S, Key : Seq) RETURN Seq IS\n      R : Seq (S'Range);\n   BEGIN\n      FOR I IN R'Range LOOP\n         R (I) := S (I) + Key (Key'First + (I - R'First) MOD Key'Length);\n      END LOOP;\n      RETURN R;\n   END \"+\";\n   \n   FUNCTION \"-\" (S : Seq) RETURN Seq IS\n      R : Seq (S'Range);\n   BEGIN\n      FOR I IN R'Range LOOP\n         R (I) := - S (I);\n      END LOOP; \n      RETURN R;\n   END \"-\";\n   \n   FUNCTION To_Seq (S : String) RETURN Seq IS\n      R  : Seq (S'Range);\n      I  : Integer := R'First;\n   BEGIN\n      FOR C OF To_Upper (S) LOOP\n         IF C IN Alpha THEN\n            R (I) := Ring'Mod (Alpha'Pos (C) - Alpha'Pos (Alpha'First));\n            I := I + 1;\n         END IF;\n      END LOOP;\n      RETURN R (R'First .. I - 1);\n   END To_Seq;\n   \n   FUNCTION To_String (S : Seq ) RETURN String IS\n      R : String (S'Range);\n   BEGIN\n      FOR I IN R'Range LOOP\n         R (I) := Alpha'Val ( Integer (S (I)) + Alpha'Pos (Alpha'First));\n      END LOOP;\n      RETURN R;\n   END To_String;\n   \n   Input : Seq := To_Seq (Get_Line);\n   Key : Seq := To_Seq (Get_Line);\n   Crypt : Seq := Input + Key;\nBEGIN\n   Put_Line (\"Encrypted: \" & To_String (Crypt));\n   Put_Line (\"Decrypted: \" & To_String (Crypt + (-Key)));\nEND Main;\n\n\nOutput:\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\nVIGENERECIPHER\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Julia", "code": "\nWorks with: Julia version 1.5\n\u2192(a::Char, b::Char, \u00b1 = +) = 'A'+((a-'A')\u00b1(b-'A')+26)%26\n\u2190(a::Char, b::Char) = \u2192(a,b,-)\n\ncleanup(str) = filter(a-> a in 'A':'Z', collect(uppercase.(str)))\nmatch_length(word, len) = repeat(word,len)[1:len]\n\nfunction \u2192(message::String, codeword::String, \u2194 = \u2192)\n    plaintext = cleanup(message)\n    key = match_length(cleanup(codeword),length(plaintext))\n    return String(plaintext .\u2194 key)\nend\n\u2190(message::String, codeword::String) = \u2192(message,codeword,\u2190)\n\ncyphertext = \"I want spearmint gum\" \u2192 \"Gimme!\"\nprintln(cyphertext)\nprintln(cyphertext \u2190 \"Gimme!\")\n\n\nOutput:\n\"OEMZXYXQMVSQZFKAU\"\n\"IWANTSPEARMINTGUM\"\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Kotlin", "code": "\n// version 1.1.3\n\nfun vigenere(text: String, key: String, encrypt: Boolean = true): String {\n    val t = if (encrypt) text.toUpperCase() else text\n    val sb = StringBuilder()\n    var ki = 0\n    for (c in t) {\n        if (c !in 'A'..'Z') continue\n        val ci = if (encrypt)\n            (c.toInt() + key[ki].toInt() - 130) % 26\n        else\n            (c.toInt() - key[ki].toInt() +  26) % 26\n        sb.append((ci + 65).toChar())\n        ki = (ki + 1) % key.length\n    }\n    return sb.toString()\n}\n\nfun main(args: Array<String>) {\n    val key = \"VIGENERECIPHER\"\n    val text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\"\n    val encoded = vigenere(text, key)\n    println(encoded)\n    val decoded = vigenere(encoded, key, false)\n    println(decoded)\n}\n\n\nOutput:\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Perl", "code": "\nif( @ARGV != 3 ){\n  printHelp();\n}\n\n  # translate to upper-case, remove anything else\nmap( (tr/a-z/A-Z/, s/[^A-Z]//g), @ARGV );\n\nmy $cipher_decipher = $ARGV[ 0 ];\n\nif( $cipher_decipher !~ /ENC|DEC/ ){\n  printHelp();  # user should say what to do\n}\n\nprint \"Key: \" . (my $key = $ARGV[ 2 ]) . \"\\n\";\n\nif( $cipher_decipher =~ /ENC/ ){\n  print \"Plain-text: \" . (my $plain = $ARGV[ 1 ]) . \"\\n\";\n  print \"Encrypted: \" . Vigenere( 1, $key, $plain ) . \"\\n\";\n}elsif( $cipher_decipher =~ /DEC/ ){\n  print \"Cipher-text: \" . (my $cipher = $ARGV[ 1 ]) . \"\\n\";\n  print \"Decrypted: \" . Vigenere( -1, $key, $cipher ) . \"\\n\";\n}\n\nsub printHelp{\n  print \"Usage:\\n\" .\n        \"Encrypting:\\n perl cipher.pl ENC (plain text) (key)\\n\" .\n        \"Decrypting:\\n perl cipher.pl DEC (cipher text) (key)\\n\";\n  exit -1;\n}\n\nsub Vigenere{\n  my ($direction, $key, $text) = @_;\n  for( my $count = 0; $count < length $text; $count ++ ){\n    $key_offset = $direction * ord substr( $key, $count % length $key, 1);\n    $char_offset = ord substr( $text, $count, 1 );\n    $cipher .= chr 65 + ((($char_offset % 26) + ($key_offset % 26)) % 26);\n      # 65 is the ASCII character code for 'A'\n  }\n  return $cipher;\n}\n\n\n$ perl cipher.pl ENC 'Beware the Jabberwock, my son! The jaws that bite, the claws that catch!' VIGENERECIPHER\nKey: VIGENERECIPHER\nPlain-text: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\n\n$ perl cipher.pl DEC WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY VIGENERECIPHER\nKey: VIGENERECIPHER\nCipher-text: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n$ perl cipher.pl FOO WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY VIGENERECIPHER\nUsage:\nEncrypting:\n perl cipher.pl ENC (plain text) (key)\nDecrypting:\n perl cipher.pl DEC (cipher text) (key)\n", "explain": "Demonstration:\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Lua", "code": "\nfunction Encrypt( _msg, _key )    \n    local msg = { _msg:upper():byte( 1, -1 ) }\n    local key = { _key:upper():byte( 1, -1 ) }    \n    local enc = {}\n\n    local j, k = 1, 1\n    for i = 1, #msg do    \n        if msg[i] >= string.byte('A') and msg[i] <= string.byte('Z') then\n            enc[k] = ( msg[i] + key[j] - 2*string.byte('A') ) % 26 + string.byte('A')\n            \n            k = k + 1\n            if j == #key then j = 1 else j = j + 1 end\n        end\n    end\n    \n    return string.char( unpack(enc) )\nend\n\nfunction Decrypt( _msg, _key )\n    local msg = { _msg:byte( 1, -1 ) }\n    local key = { _key:upper():byte( 1, -1 ) }      \n    local dec = {}\n\n    local j = 1\n    for i = 1, #msg do            \n       dec[i] = ( msg[i] - key[j] + 26 ) % 26 + string.byte('A')\n            \n       if j == #key then j = 1 else j = j + 1 end\n    end    \n    \n    return string.char( unpack(dec) )\nend\n\n\noriginal = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\"\nkey = \"VIGENERECIPHER\";\n\nencrypted = Encrypt( original, key )\ndecrypted = Decrypt( encrypted, key )\n\nprint( encrypted )\nprint( decrypted )\n\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Scala", "code": "\n\nobject Vigenere {\n  def encrypt(msg: String, key: String) : String = {\n    var result: String = \"\"\n    var j = 0\n\n    for (i <- 0 to msg.length - 1) {\n      val c = msg.charAt(i)\n      if (c >= 'A' && c <= 'Z') {\n        result += ((c + key.charAt(j) - 2 * 'A') % 26 + 'A').toChar\n        j = (j + 1) % key.length\n      }\n    }\n\n    return result\n  }\n\n  def decrypt(msg: String, key: String) : String = {\n    var result: String = \"\"\n    var j = 0\n\n    for (i <- 0 to msg.length - 1) {\n      val c = msg.charAt(i)\n      if (c >= 'A' && c <= 'Z') {\n        result += ((c - key.charAt(j) + 26) % 26 + 'A').toChar\n        j = (j + 1) % key.length\n      }\n    }\n\n    return result\n  }\n}\n\nprintln(\"Encrypt text ABC => \" + Vigenere.encrypt(\"ABC\", \"KEY\"))\nprintln(\"Decrypt text KFA => \" + Vigenere.decrypt(\"KFA\", \"KEY\"))\n\n\nOutput:\nscala> Encrypt text ABC => KFA\nscala> Decrypt text KFA => ABC\n", "explain": "Valid characters for messages: A through Z, zero, 1 to 9, and full-stop (.)\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "D", "code": "\nimport std.stdio, std.string;\n\nstring encrypt(in string txt, in string key) pure @safe\nin {\n    assert(key.removechars(\"^A-Z\") == key);\n} body {\n    string res;\n    foreach (immutable i, immutable c; txt.toUpper.removechars(\"^A-Z\"))\n        res ~= (c + key[i % $] - 2 * 'A') % 26 + 'A';\n    return res;\n}\n\nstring decrypt(in string txt, in string key) pure @safe\nin {\n    assert(key.removechars(\"^A-Z\") == key);\n} body {\n    string res;\n    foreach (immutable i, immutable c; txt.toUpper.removechars(\"^A-Z\"))\n       res ~= (c - key[i % $] + 26) % 26 + 'A';\n    return res;\n}\n\nvoid main() {\n    immutable key = \"VIGENERECIPHER\";\n    immutable original = \"Beware the Jabberwock, my son!\" ~\n                         \" The jaws that bite, the claws that catch!\";\n    immutable encoded = original.encrypt(key);\n    writeln(encoded, \"\\n\", encoded.decrypt(key));\n}\n\n\nOutput:\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\nAlternative Version[edit]\nTranslation of: Raku\nimport std.stdio, std.range, std.ascii, std.string, std.algorithm,\n       std.conv;\n\nimmutable mod = (in int m, in int n) pure nothrow @safe @nogc =>\n    ((m % n) + n) % n;\n\nimmutable _s2v = (in string s) pure /*nothrow*/ @safe =>\n    s.toUpper.removechars(\"^A-Z\").map!q{ a - 'A' };\n\nstring _v2s(R)(R v) pure /*nothrow*/ @safe {\n    return v.map!(x => uppercase[x.mod(26)]).text;\n}\n\nimmutable encrypt = (in string txt, in string key) pure /*nothrow*/ @safe =>\n    txt._s2v.zip(key._s2v.cycle).map!q{ a[0] + a[1] }._v2s;\n\nimmutable decrypt = (in string txt, in string key) pure /*nothrow*/ @safe =>\n    txt._s2v.zip(key._s2v.cycle).map!q{ a[0] - a[1] }._v2s;\n\nvoid main() {\n    immutable key = \"Vigenere Cipher!!!\";\n    immutable original = \"Beware the Jabberwock, my son!\" ~\n                         \" The jaws that bite, the claws that catch!\";\n    immutable encoded = original.encrypt(key);\n    writeln(encoded, \"\\n\", encoded.decrypt(key));\n}\n\n\n", "explain": "The output is the same.\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Haskell", "code": "\nimport Data.Char\nimport Text.Printf\n\n-- Perform encryption or decryption, depending on f.\ncrypt f key = map toLetter . zipWith f (cycle key)\n  where toLetter = chr . (+) (ord 'A')\n\n-- Encrypt or decrypt one letter.\nenc k c = (ord k + ord c) `mod` 26\ndec k c = (ord c - ord k) `mod` 26\n\n-- Given a key, encrypt or decrypt an input string.\nencrypt = crypt enc\ndecrypt = crypt dec\n\n-- Convert a string to have only upper case letters.\nconvert = map toUpper . filter isLetter\n\nmain :: IO ()\nmain = do\n  let key  = \"VIGENERECIPHER\"\n      text = \"Beware the Jabberwock, my son! The jaws that bite, \"\n             ++ \"the claws that catch!\"\n      encr = encrypt key $ convert text\n      decr = decrypt key encr\n  printf \"    Input: %s\\n      Key: %s\\nEncrypted: %s\\nDecrypted: %s\\n\"\n    text key encr decr\n\n\nOutput:\n    Input: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\n      Key: VIGENERECIPHER\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "VBScript", "code": "\nTranslation of: Liberty BASIC\nFunction Encrypt(text,key)\n\ttext = OnlyCaps(text) \n\tkey = OnlyCaps(key)\n\tj = 1\n\tFor i = 1 To Len(text)\n\t\tms = Mid(text,i,1)\n\t\tm = Asc(ms) - Asc(\"A\")\n\t\tks = Mid(key,j,1)\n\t\tk = Asc(ks) - Asc(\"A\")\n\t\tj = (j Mod Len(key)) + 1\n\t\tc = (m + k) Mod 26\n\t\tc = Chr(Asc(\"A\")+c)\n\t\tEncrypt = Encrypt & c\n\tNext\nEnd Function\n\nFunction Decrypt(text,key)\n\tkey = OnlyCaps(key)\n\tj = 1\n\tFor i = 1 To Len(text)\n\t\tms = Mid(text,i,1)\n\t\tm = Asc(ms) - Asc(\"A\")\n\t\tks = Mid(key,j,1)\n\t\tk = Asc(ks) - Asc(\"A\")\n\t\tj = (j Mod Len(key)) + 1\n\t\tc = (m - k + 26) Mod 26\n\t\tc = Chr(Asc(\"A\")+c)\n\t\tDecrypt = Decrypt & c\n\tNext\nEnd Function\n\nFunction OnlyCaps(s)\n\tFor i = 1 To Len(s)\n\t\tchar = UCase(Mid(s,i,1))\n\t\tIf Asc(char) >= 65 And Asc(char) <= 90 Then\n\t\t\tOnlyCaps = OnlyCaps & char\n\t\tEnd If\n\tNext\nEnd Function\n\n'testing the functions\norig_text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\"\norig_key = \"vigenerecipher\"\nWScript.StdOut.WriteLine \"Original: \" & orig_text\nWScript.StdOut.WriteLine \"Key: \" & orig_key\nWScript.StdOut.WriteLine \"Encrypted: \" & Encrypt(orig_text,orig_key)\nWScript.StdOut.WriteLine \"Decrypted: \" & Decrypt(Encrypt(orig_text,orig_key),orig_key)\n\n\nOutput:\nOriginal: Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\nKey: vigenerecipher\nEncrypted: WMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nDecrypted: BEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n\n'vigenere cypher\noption explicit\nconst asca =65  'ascii(a)\n\nfunction filter(s)\n    with new regexp\n      .pattern=\"[^A-Z]\"\n      .global=1 \n      filter=.replace(ucase(s),\"\") \n     end with      \nend function\n\nfunction vigenere (s,k,sign)\ndim s1,i,a,b \n  for i=0 to len(s)-1 \n    a=asc(mid(s,i+1,1))-asca \n    b=sign * (asc(mid(k,(i mod len(k))+1,1))-asca) \n    s1=s1 & chr(((a+b+26) mod 26) +asca)\n  next\n  vigenere=s1\nend function \n\nfunction encrypt(s,k): encrypt=vigenere(s,k,1) :end function\nfunction decrypt(s,k): decrypt=vigenere(s,k,-1) :end function\n\n'test--------------------------\ndim plaintext,filtered,key,encoded\nkey=\"VIGENERECYPHER\"\nplaintext = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\" \nfiltered= filter(plaintext)\nwscript.echo filtered\nencoded=encrypt(filtered,key)\nwscript.echo encoded\nwscript.echo decrypt(encoded,key)\n\n", "explain": "An alternate implementation using RegExp to filter the input\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "TypeScript", "code": "\nclass Vigenere {\n\n    key: string\n\n    /** Create new cipher based on key */\n    constructor(key: string) {\n        this.key = Vigenere.formatText(key)\n    }\n\n    /** Enrypt a given text using key */\n    encrypt(plainText: string): string {\n        return Array.prototype.map.call(Vigenere.formatText(plainText), (letter: string, index: number): string => {\n            return String.fromCharCode((letter.charCodeAt(0) + this.key.charCodeAt(index % this.key.length) - 130) % 26 + 65)\n        }).join('')\n    }\n\n    /** Decrypt ciphertext based on key */\n    decrypt(cipherText: string): string {\n        return Array.prototype.map.call(Vigenere.formatText(cipherText), (letter: string, index: number): string => {\n            return String.fromCharCode((letter.charCodeAt(0) - this.key.charCodeAt(index % this.key.length) + 26) % 26 + 65)\n        }).join('')\n    }\n\n    /** Converts to uppercase and removes non characters */\n    private static formatText(text: string): string {\n        return text.toUpperCase().replace(/[^A-Z]/g, \"\")\n    }\n\n}\n\n/** Example usage */\n(() => {\n    let original: string = \"Lorem Ipsum is simply dummy text of the printing and typesetting industry. Lorem Ipsum has been the industry's standard dummy text ever since the 1500s, when an unknown printer took a galley of type and scrambled it to make a type specimen book.\"\n\n    console.log(`Original: ${original}`)\n\n    let vig: Vigenere = new Vigenere(\"vigenere\")\n\n    let encoded: string = vig.encrypt(original)\n\n    console.log(`After encryption: ${encoded}`)\n\n    let back: string = vig.decrypt(encoded)\n\n    console.log(`After decryption: ${back}`)\n\n})()\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "PowerShell", "code": "\n# Author: D. Cudnohufsky\nfunction Get-VigenereCipher\n{\n    Param\n    (\n        [Parameter(Mandatory=$true)]\n        [string] $Text,\n \n        [Parameter(Mandatory=$true)]\n        [string] $Key,\n \n        [switch] $Decode\n    )\n \n    begin\n    {    \n        $map = [char]'A'..[char]'Z'\n    }\n \n    process\n    {\n        $Key = $Key -replace '[^a-zA-Z]',''\n        $Text = $Text -replace '[^a-zA-Z]',''\n\n        $keyChars = $Key.toUpper().ToCharArray()\n        $Chars = $Text.toUpper().ToCharArray()\n \n        function encode\n        {\n\n            param\n            (\n                $Char,\n                $keyChar,\n                $Alpha = [char]'A'..[char]'Z'\n            )\n\n            $charIndex = $Alpha.IndexOf([int]$Char)\n            $keyIndex = $Alpha.IndexOf([int]$keyChar)\n            $NewIndex = ($charIndex + $KeyIndex) - $Alpha.Length\n            $Alpha[$NewIndex]\n\n        }\n \n        function decode\n        {\n\n            param\n            (\n                $Char,\n                $keyChar,\n                $Alpha = [char]'A'..[char]'Z'\n            )\n\n            $charIndex = $Alpha.IndexOf([int]$Char)\n            $keyIndex = $Alpha.IndexOf([int]$keyChar)\n            $int = $charIndex - $keyIndex\n            if ($int -lt 0) { $NewIndex = $int + $Alpha.Length }\n            else { $NewIndex = $int }\n            $Alpha[$NewIndex]\n        }\n\n        while ( $keyChars.Length -lt $Chars.Length ) \n        {\n            $keyChars = $keyChars + $keyChars\n        }\n\n        for ( $i = 0; $i -lt $Chars.Length; $i++ )\n        {\n\n            if ( [int]$Chars[$i] -in $map -and [int]$keyChars[$i] -in $map )\n            {\n                if ($Decode) {$Chars[$i] = decode $Chars[$i] $keyChars[$i] $map}\n                else {$Chars[$i] = encode $Chars[$i] $keyChars[$i] $map}\n\n                $Chars[$i] = [char]$Chars[$i]\n                [string]$OutText += $Chars[$i]\n            }\n\n        }\n \n        $OutText\n        $OutText = $null\n    }\n}\n\n\nEncode:\nPS C:\\> Get-VigenereCipher 'We attack at dawn.' 'lemon'\nHIMHGLGWOGOEIB\n\nDecode:\nPS C:\\> Get-VigenereCipher 'HIMHGLGWOGOEIB' 'lemon' -Decode\nWEATTACKATDAWN\n\n", "explain": "Usage examples:\n"}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "F#", "code": "\nmodule vigenere =\n    let keyschedule (key:string) =\n        let s = key.ToUpper().ToCharArray() |> Array.filter System.Char.IsLetter\n        let l = Array.length s\n        (fun n -> int s.[n % l])\n\n    let enc k c = ((c + k - 130) % 26) + 65\n    let dec k c = ((c - k + 130) % 26) + 65\n    let crypt f key = Array.mapi (fun n c -> f (key n) c |> char)\n\n    let encrypt key (plaintext:string) =\n        plaintext.ToUpper().ToCharArray()\n        |> Array.filter System.Char.IsLetter\n        |> Array.map int\n        |> crypt enc (keyschedule key)\n        |> (fun a -> new string(a))\n\n    let decrypt key (ciphertext:string) =\n        ciphertext.ToUpper().ToCharArray()\n        |> Array.map int\n        |> crypt dec (keyschedule key)\n        |> (fun a -> new string(a))\n\nlet passwd = \"Vigenere Cipher\"\nlet cipher = vigenere.encrypt passwd \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\"\nlet plain = vigenere.decrypt passwd cipher\nprintfn \"%s\\n%s\" cipher plain\n\nC:\\src\\fsharp>fsi vigenere.fsx\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": ""}, {"task_name": "Vigen\u00e8re cipher", "task_url": "https://rosettacode.org/wiki/Vigen%C3%A8re_cipher", "task_cat": "Encryption", "lang": "Zig", "code": "\nWorks with: Zig version 0.11.0dev\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\n\n/// Caller owns the returned slice memory.\nfn vigenere(allocator: Allocator, text: []const u8, key: []const u8, encrypt: bool) Allocator.Error![]u8 {\n    var dynamic_string = std.ArrayList(u8).init(allocator);\n    var key_index: usize = 0;\n    for (text) |letter| {\n        const c = if (std.ascii.isLower(letter)) std.ascii.toUpper(letter) else letter;\n        if (std.ascii.isUpper(c)) {\n            const k = key[key_index];\n            const n = if (encrypt) ((c - 'A') + (k - 'A')) else 26 + c - k;\n            try dynamic_string.append(n % 26 + 'A'); // A-Z\n            key_index += 1;\n            key_index %= key.len;\n        }\n    }\n    return dynamic_string.toOwnedSlice();\n}\n\npub fn main() anyerror!void {\n    // allocator\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        const ok = gpa.deinit();\n        std.debug.assert(ok == .ok);\n    }\n    const allocator = gpa.allocator();\n    //\n    const stdout = std.io.getStdOut().writer();\n    //\n    const key = \"VIGENERECIPHER\";\n    const text = \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\";\n\n    const encoded = try vigenere(allocator, text, key, true);\n    defer allocator.free(encoded);\n    try stdout.print(\"{s}\\n\", .{encoded});\n\n    const decoded = try vigenere(allocator, encoded, key, false);\n    defer allocator.free(decoded);\n    try stdout.print(\"{s}\\n\", .{decoded});\n}\n\n\nOutput:\nWMCEEIKLGRPIFVMEUGXQPWQVIOIAVEYXUEKFKBTALVXTGAFXYEVKPAGY\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n", "explain": ""}]