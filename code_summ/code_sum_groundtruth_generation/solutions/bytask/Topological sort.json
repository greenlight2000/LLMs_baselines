[{"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Python", "code": "\nPython 3[edit]\ntry:\n    from functools import reduce\nexcept:\n    pass\n\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n\ndef toposort2(data):\n    for k, v in data.items():\n        v.discard(k) # Ignore self dependencies\n    extra_items_in_deps = reduce(set.union, data.values()) - set(data.keys())\n    data.update({item:set() for item in extra_items_in_deps})\n    while True:\n        ordered = set(item for item,dep in data.items() if not dep)\n        if not ordered:\n            break\n        yield ' '.join(sorted(ordered))\n        data = {item: (dep - ordered) for item,dep in data.items()\n                if item not in ordered}\n    assert not data, \"A cyclic dependency exists amongst %r\" % data\n\nprint ('\\n'.join( toposort2(data) ))\n\n\nieee std synopsys\ndware gtech ramlib std_cell_lib\ndw01 dw02 dw05 dw06 dw07\ndes_system_lib dw03 dw04\n\nTraceback (most recent call last):\n  File \"C:\\Documents and Settings\\All Users\\Documents\\Paddys\\topological_sort.py\", line 115, in <module>\n    print ('\\n'.join( toposort2(data) ))\n  File \"C:\\Documents and Settings\\All Users\\Documents\\Paddys\\topological_sort.py\", line 113, in toposort2\n    assert not data, \"A cyclic dependency exists amongst %r\"\u00a0% data\nAssertionError: A cyclic dependency exists amongst {'dw04': {'dw01'}, 'dw03': {'dw01'}, 'dw01': {'dw04'}, 'des_system_lib': {'dw01'}}\nPython 3.9 graphlib[edit]\nfrom graphlib import TopologicalSorter\n\n#   LIBRARY     mapped_to   LIBRARY DEPENDENCIES\ndata = {\n    'des_system_lib':   set('std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee'.split()),\n    'dw01':             set('ieee dw01 dware gtech'.split()),\n    'dw02':             set('ieee dw02 dware'.split()),\n    'dw03':             set('std synopsys dware dw03 dw02 dw01 ieee gtech'.split()),\n    'dw04':             set('dw04 ieee dw01 dware gtech'.split()),\n    'dw05':             set('dw05 ieee dware'.split()),\n    'dw06':             set('dw06 ieee dware'.split()),\n    'dw07':             set('ieee dware'.split()),\n    'dware':            set('ieee dware'.split()),\n    'gtech':            set('ieee gtech'.split()),\n    'ramlib':           set('std ieee'.split()),\n    'std_cell_lib':     set('ieee std_cell_lib'.split()),\n    'synopsys':         set(),\n    }\n# Ignore self dependencies\nfor k, v in data.items():\n    v.discard(k)   \n\nts = TopologicalSorter(data)\nprint(tuple(ts.static_order()))\n\n\nOutput:\n('synopsys', 'std', 'ieee', 'dware', 'gtech', 'ramlib', 'std_cell_lib', 'dw02', 'dw05', 'dw06', 'dw07', 'dw01', 'des_system_lib', 'dw03', 'dw04')\n", "explain": "Ordered output\nitems on a line could be processed in any sub-order or, indeed, in parallel:\nIf dw04 is added to the set of dependencies of dw01 to make the data un-orderable, an exception is raised:\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\nchar input[] =\n\t\"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\"\n\t\"dw01             ieee dw01 dware gtech\\n\"\n\t\"dw02             ieee dw02 dware\\n\"\n\t\"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\"\n\t\"dw04             dw04 ieee dw01 dware gtech\\n\"\n\t\"dw05             dw05 ieee dware\\n\"\n\t\"dw06             dw06 ieee dware\\n\"\n\t\"dw07             ieee dware\\n\"\n\t\"dware            ieee dware\\n\"\n\t\"gtech            ieee gtech\\n\"\n\t\"ramlib           std ieee\\n\"\n\t\"std_cell_lib     ieee std_cell_lib\\n\"\n\t\"synopsys\\n\"\n\t\"cycle_11\t  cycle_12\\n\"\n\t\"cycle_12\t  cycle_11\\n\"\n\t\"cycle_21\t  dw01 cycle_22 dw02 dw03\\n\"\n\t\"cycle_22\t  cycle_21 dw01 dw04\";\n\ntypedef struct item_t item_t, *item;\nstruct item_t { const char *name; int *deps, n_deps, idx, depth; };\n\nint get_item(item *list, int *len, const char *name)\n{\n\tint i;\n\titem lst = *list;\n\n\tfor (i = 0; i < *len; i++)\n\t\tif (!strcmp(lst[i].name, name)) return i;\n\n\tlst = *list = realloc(lst, ++*len * sizeof(item_t));\n\ti = *len - 1;\n\tmemset(lst + i, 0, sizeof(item_t));\n\tlst[i].idx = i;\n\tlst[i].name = name;\n\treturn i;\n}\n\nvoid add_dep(item it, int i)\n{\n\tif (it->idx == i) return;\n\tit->deps = realloc(it->deps, (it->n_deps + 1) * sizeof(int));\n\tit->deps[it->n_deps++] = i;\n}\n\nint parse_input(item *ret)\n{\n\tint n_items = 0;\n\tint i, parent, idx;\n\titem list = 0;\n\n\tchar *s, *e, *word, *we;\n\tfor (s = input; ; s = 0) {\n\t\tif (!(s = strtok_r(s, \"\\n\", &e))) break;\n\n\t\tfor (i = 0, word = s; ; i++, word = 0) {\n\t\t\tif (!(word = strtok_r(word, \" \\t\", &we))) break;\n\t\t\tidx = get_item(&list, &n_items, word);\n\n\t\t\tif (!i) parent = idx;\n\t\t\telse    add_dep(list + parent, idx);\n\t\t}\n\t}\n\n\t*ret = list;\n\treturn n_items;\n}\n\n/* recursively resolve compile order; negative means loop */\nint get_depth(item list, int idx, int bad)\n{\n\tint max, i, t;\n\n\tif (!list[idx].deps)\n\t\treturn list[idx].depth = 1;\n\n\tif ((t = list[idx].depth) < 0) return t;\n\n\tlist[idx].depth = bad;\n\tfor (max = i = 0; i < list[idx].n_deps; i++) {\n\t\tif ((t = get_depth(list, list[idx].deps[i], bad)) < 0) {\n\t\t\tmax = t;\n\t\t\tbreak;\n\t\t}\n\t\tif (max < t + 1) max = t + 1;\n\t}\n\treturn list[idx].depth = max;\n}\n\nint main()\n{\n\tint i, j, n, bad = -1, max, min;\n\titem items;\n\tn = parse_input(&items);\n\n\tfor (i = 0; i < n; i++)\n\t\tif (!items[i].depth && get_depth(items, i, bad) < 0) bad--;\n\n\tfor (i = 0, max = min = 0; i < n; i++) {\n\t\tif (items[i].depth > max) max = items[i].depth;\n\t\tif (items[i].depth < min) min = items[i].depth;\n\t}\n\n\tprintf(\"Compile order:\\n\");\n\tfor (i = min; i <= max; i++) {\n\t\tif (!i) continue;\n\n\t\tif (i < 0) printf(\"   [unorderable]\");\n\t\telse\t   printf(\"%d:\", i);\n\n\t\tfor (j = 0; j < n || !putchar('\\n'); j++)\n\t\t\tif (items[j].depth == i)\n\t\t\t\tprintf(\" %s\", items[j].name);\n\t}\n\n\treturn 0;\n}\n\n\nOutput: (items on the same row can be compiled together)Compile order:\n   [unorderable] cycle_21 cycle_22\n   [unorderable] cycle_11 cycle_12\n1: std synopsys ieee\n2: std_cell_lib ramlib dware gtech\n3: dw02 dw01 dw05 dw06 dw07\n4: des_system_lib dw03 dw04\n\n", "explain": "Parses a multiline string and show the compile order.  Note that four lines were added to the example input to form two separate cycles.  Code is a little ugly.\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "C++", "code": "\nC++11[edit]\n#include <map>\n#include <set>\n\ntemplate<typename Goal>\nclass topological_sorter {\nprotected:\n    struct relations {\n        std::size_t dependencies;\n        std::set<Goal> dependents;\n    };\n    std::map<Goal, relations> map;\npublic:\n    void add_goal(Goal const &goal) {\n        map[goal];\n    }\n    void add_dependency(Goal const &goal, Goal const &dependency) {\n        if (dependency == goal)\n            return;\n        auto &dependents = map[dependency].dependents;\n        if (dependents.find(goal) == dependents.end()) {\n            dependents.insert(goal);\n            ++map[goal].dependencies;\n        }\n    }\n    template<typename Container>\n    void add_dependencies(Goal const &goal, Container const &dependencies) {\n        for (auto const &dependency : dependencies)\n            add_dependency(goal, dependency);\n    }\n    template<typename ResultContainer, typename CyclicContainer>\n    void destructive_sort(ResultContainer &sorted, CyclicContainer &unsortable) {\n        sorted.clear();\n        unsortable.clear();\n        for (auto const &lookup : map) {\n            auto const &goal = lookup.first;\n            auto const &relations = lookup.second;\n            if (relations.dependencies == 0)\n                sorted.push_back(goal);\n        }\n        for (std::size_t index = 0; index < sorted.size(); ++index)\n            for (auto const &goal : map[sorted[index]].dependents)\n                if (--map[goal].dependencies == 0)\n                    sorted.push_back(goal);\n        for (auto const &lookup : map) {\n            auto const &goal = lookup.first;\n            auto const &relations = lookup.second;\n            if (relations.dependencies != 0)\n                unsortable.push_back(goal);\n        }\n    }\n    template<typename ResultContainer, typename CyclicContainer>\n    void sort(ResultContainer &sorted, CyclicContainer &unsortable) {\n        topological_sorter<Goal> temporary = *this;\n        temporary.destructive_sort(sorted, unsortable);\n    }\n    void clear() {\n        map.clear();\n    }\n};\n\n/*\n Example usage with text strings\n */\n\n#include <fstream>\n#include <sstream>\n#include <iostream>\n#include <string>\n#include <vector>\n\nusing namespace std;\n\nvoid display_heading(string const &message) {\n    cout << endl << \"~ \" << message << \" ~\" << endl;\n}\nvoid display_results(string const &input) {\n    topological_sorter<string> sorter;\n    vector<string> sorted, unsortable;\n    stringstream lines(input);\n    string line;\n    while (getline(lines, line)) {\n        stringstream buffer(line);\n        string goal, dependency;\n        buffer >> goal;\n        sorter.add_goal(goal);\n        while (buffer >> dependency)\n            sorter.add_dependency(goal, dependency);\n    }\n    sorter.destructive_sort(sorted, unsortable);\n    if (sorted.size() == 0)\n        display_heading(\"Error: no independent variables found!\");\n    else {\n        display_heading(\"Result\");\n        for (auto const &goal : sorted)\n            cout << goal << endl;\n    }\n    if (unsortable.size() != 0) {\n        display_heading(\"Error: cyclic dependencies detected!\");\n        for (auto const &goal : unsortable)\n            cout << goal << endl;\n    }\n}\nint main(int argc, char **argv) {\n    if (argc == 1) {\n        string example = \"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\"\n                \"dw01             ieee dw01 dware gtech\\n\"\n                \"dw02             ieee dw02 dware\\n\"\n                \"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\"\n                \"dw04             dw04 ieee dw01 dware gtech\\n\"\n                \"dw05             dw05 ieee dware\\n\"\n                \"dw06             dw06 ieee dware\\n\"\n                \"dw07             ieee dware\\n\"\n                \"dware            ieee dware\\n\"\n                \"gtech            ieee gtech\\n\"\n                \"ramlib           std ieee\\n\"\n                \"std_cell_lib     ieee std_cell_lib\\n\"\n                \"synopsys\\n\"\n                \"cycle_11     cycle_12\\n\"\n                \"cycle_12     cycle_11\\n\"\n                \"cycle_21     dw01 cycle_22 dw02 dw03\\n\"\n                \"cycle_22     cycle_21 dw01 dw04\";\n        display_heading(\"Example: each line starts with a goal followed by it's dependencies\");\n        cout << example << endl;\n        display_results(example);\n        display_heading(\"Enter lines of data (press enter when finished)\");\n        string line, data;\n        while (getline(cin, line) && !line.empty())\n            data += line + '\\n';\n        if (!data.empty())\n            display_results(data);\n    } else\n        while (*(++argv)) {\n            ifstream file(*argv);\n            typedef istreambuf_iterator<char> iterator;\n            display_results(string(iterator(file), iterator()));\n        }\n}\n\nC++17[edit]\n#include <unordered_map>\n#include <unordered_set>\n#include <vector>\n\ntemplate <typename ValueType>\nclass topological_sorter\n{\npublic:\n    using value_type = ValueType;\n\nprotected:\n    struct relations\n    {\n        std::size_t dependencies { 0 };\n        std::unordered_set<value_type> dependents {};\n    };\n\n    std::unordered_map<value_type, relations> _map {};\n\npublic:\n    void add(const value_type &object)\n    {\n        _map.try_emplace(object, relations {});\n    }\n\n    void add(const value_type &object, const value_type &dependency)\n    {\n        if (dependency == object) return;\n\n        auto &dependents = _map[dependency].dependents;\n\n        if (dependents.find(object) == std::end(dependents))\n        {\n            dependents.insert(object);\n\n            ++_map[object].dependencies;\n        }\n    }\n\n    template <typename Container>\n    void add(const value_type &object, const Container &dependencies)\n    {\n        for (auto const &dependency : dependencies) add(object, dependency);\n    }\n\n    void add(const value_type &object, const std::initializer_list<value_type> &dependencies)\n    {\n        add<std::initializer_list<value_type>>(object, dependencies);\n    }\n\n    template<typename... Args>\n    void add(const value_type &object, const Args&... dependencies)\n    {\n        (add(object, dependencies), ...);\n    }\n\n    auto sort()\n    {\n        std::vector<value_type> sorted, cycled;\n        auto map { _map };\n\n        for (const auto &[object, relations] : map) if (!relations.dependencies) sorted.emplace_back(object);\n\n        for (decltype(std::size(sorted)) idx = 0; idx < std::size(sorted); ++idx)\n            for (auto const& object : map[sorted[idx]].dependents)\n                if (!--map[object].dependencies) sorted.emplace_back(object);\n\n        for (const auto &[object, relations] : map) if (relations.dependencies) cycled.emplace_back(std::move(object));\n\n        return std::pair(std::move(sorted), std::move(cycled));\n    }\n\n    void clear()\n    {\n        _map.clear();\n    }\n};\n\n/*\n\tExample usage with shared_ptr to class\n*/\n#include <iostream>\n#include <memory>\n\nint main()\n{\n    using namespace std::string_literals;\n\n    struct task\n    {\n        std::string message;\n\n        task(const std::string &v) : message { v } {}\n        ~task() { std::cout << message[0] << \" - destroyed\" << std::endl; }\n    };\n\n    using task_ptr = std::shared_ptr<task>;\n\n    std::vector<task_ptr> tasks\n    {\n        // defining simple tasks\n        std::make_shared<task>(\"A - depends on B and C\"s),    //0\n        std::make_shared<task>(\"B - depends on none\"s),       //1\n        std::make_shared<task>(\"C - depends on D and E\"s),    //2\n        std::make_shared<task>(\"D - depends on none\"s),       //3\n        std::make_shared<task>(\"E - depends on F, G and H\"s), //4\n        std::make_shared<task>(\"F - depends on I\"s),          //5\n        std::make_shared<task>(\"G - depends on none\"s),       //6\n        std::make_shared<task>(\"H - depends on none\"s),       //7\n        std::make_shared<task>(\"I - depends on none\"s),       //8\n    };\n\n    topological_sorter<task_ptr> resolver;\n\n    // now setting relations between them as described above\n    resolver.add(tasks[0], { tasks[1], tasks[2] });\n    //resolver.add(tasks[1]); // no need for this since the task was already mentioned as a dependency\n    resolver.add(tasks[2], { tasks[3], tasks[4] });\n    //resolver.add(tasks[3]); // no need for this since the task was already mentioned as a dependency\n    resolver.add(tasks[4], tasks[5], tasks[6], tasks[7]); // using templated add with fold expression\n    resolver.add(tasks[5], tasks[8]);\n    //resolver.add(tasks[6]); // no need for this since the task was already mentioned as a dependency\n    //resolver.add(tasks[7]); // no need for this since the task was already mentioned as a dependency\n\n    //resolver.add(tasks[3], tasks[0]); // uncomment this line to test cycled dependency\n\n    const auto &[sorted, cycled] = resolver.sort();\n\n    if (std::empty(cycled))\n    {\n        for (auto const& d: sorted)\n            std::cout << d->message << std::endl;\n    }\n    else\n    {\n        std::cout << \"Cycled dependencies detected: \";\n\n        for (auto const& d: cycled)\n            std::cout << d->message[0] << \" \";\n\n        std::cout << std::endl;\n    }\n\n    //tasks.clear(); // uncomment this line to destroy all tasks in sorted order.\n\n    std::cout << \"exiting...\" << std::endl;\n\n    return 0;\n}\n\n\nOutput:I - depends on none\nH - depends on none\nG - depends on none\nD - depends on none\nB - depends on none\nF - depends on I\nE - depends on F, G and H\nC - depends on D and E\nA - depends on B and C\nexiting...\nA - destroyed\nB - destroyed\nC - destroyed\nD - destroyed\nE - destroyed\nF - destroyed\nG - destroyed\nH - destroyed\nI - destroyed\n\n\nOutput:(with cycled dependency)Cycled dependencies detected: A D C\nexiting...\nA - destroyed\nB - destroyed\nC - destroyed\nD - destroyed\nE - destroyed\nF - destroyed\nG - destroyed\nH - destroyed\nI - destroyed\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Java", "code": "\nWorks with: Java version 7\nimport java.util.*;\n\npublic class TopologicalSort {\n\n    public static void main(String[] args) {\n        String s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05,\"\n                + \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\";\n\n        Graph g = new Graph(s, new int[][]{\n            {2, 0}, {2, 14}, {2, 13}, {2, 4}, {2, 3}, {2, 12}, {2, 1},\n            {3, 1}, {3, 10}, {3, 11},\n            {4, 1}, {4, 10},\n            {5, 0}, {5, 14}, {5, 10}, {5, 4}, {5, 3}, {5, 1}, {5, 11},\n            {6, 1}, {6, 3}, {6, 10}, {6, 11},\n            {7, 1}, {7, 10},\n            {8, 1}, {8, 10},\n            {9, 1}, {9, 10},\n            {10, 1},\n            {11, 1},\n            {12, 0}, {12, 1},\n            {13, 1}\n        });\n\n        System.out.println(\"Topologically sorted order: \");\n        System.out.println(g.topoSort());\n    }\n}\n\nclass Graph {\n    String[] vertices;\n    boolean[][] adjacency;\n    int numVertices;\n\n    public Graph(String s, int[][] edges) {\n        vertices = s.split(\",\");\n        numVertices = vertices.length;\n        adjacency = new boolean[numVertices][numVertices];\n\n        for (int[] edge : edges)\n            adjacency[edge[0]][edge[1]] = true;\n    }\n\n    List<String> topoSort() {\n        List<String> result = new ArrayList<>();\n        List<Integer> todo = new LinkedList<>();\n\n        for (int i = 0; i < numVertices; i++)\n            todo.add(i);\n\n        try {\n            outer:\n            while (!todo.isEmpty()) {\n                for (Integer r : todo) {\n                    if (!hasDependency(r, todo)) {\n                        todo.remove(r);\n                        result.add(vertices[r]);\n                         // no need to worry about concurrent modification\n                        continue outer;\n                    }\n                }\n                throw new Exception(\"Graph has cycles\");\n            }\n        } catch (Exception e) {\n            System.out.println(e);\n            return null;\n        }\n        return result;\n    }\n\n    boolean hasDependency(Integer r, List<Integer> todo) {\n        for (Integer c : todo) {\n            if (adjacency[r][c])\n                return true;\n        }\n        return false;\n    }\n}\n\n[std,  ieee,  dware,  dw02,  dw05, dw06,  dw07,  gtech,  dw01,  dw04,  ramlib,  std_cell_lib,  synopsys,  des_system_lib,  dw03]\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "C#", "code": "\nnamespace Algorithms\n{\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class TopologicalSorter<ValueType>\n    {\n        private class Relations\n        {\n            public int Dependencies = 0;\n            public HashSet<ValueType> Dependents = new HashSet<ValueType>();\n        }\n\n        private Dictionary<ValueType, Relations> _map = new Dictionary<ValueType, Relations>();\n\n        public void Add(ValueType obj)\n        {\n            if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n        }\n\n        public void Add(ValueType obj, ValueType dependency)\n        {\n            if (dependency.Equals(obj)) return;\n\n            if (!_map.ContainsKey(dependency)) _map.Add(dependency, new Relations());\n\n            var dependents = _map[dependency].Dependents;\n\n            if (!dependents.Contains(obj))\n            {\n                dependents.Add(obj);\n\n                if (!_map.ContainsKey(obj)) _map.Add(obj, new Relations());\n\n                ++_map[obj].Dependencies;\n            }\n        }\n\n        public void Add(ValueType obj, IEnumerable<ValueType> dependencies)\n        {\n            foreach (var dependency in dependencies) Add(obj, dependency);\n        }\n\n        public void Add(ValueType obj, params ValueType[] dependencies)\n        {\n            Add(obj, dependencies as IEnumerable<ValueType>);\n        }\n\n        public Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>> Sort()\n        {\n            List<ValueType> sorted = new List<ValueType>(), cycled = new List<ValueType>();\n            var map = _map.ToDictionary(kvp => kvp.Key, kvp => kvp.Value);\n\n            sorted.AddRange(map.Where(kvp => kvp.Value.Dependencies == 0).Select(kvp => kvp.Key));\n\n            for (int idx = 0; idx < sorted.Count; ++idx) sorted.AddRange(map[sorted[idx]].Dependents.Where(k => --map[k].Dependencies == 0));\n\n            cycled.AddRange(map.Where(kvp => kvp.Value.Dependencies != 0).Select(kvp => kvp.Key));\n\n            return new Tuple<IEnumerable<ValueType>, IEnumerable<ValueType>>(sorted, cycled);\n        }\n\n        public void Clear()\n        {\n            _map.Clear();\n        }\n    }\n\n}\n\n/*\n\tExample usage with Task object\n*/\n\nnamespace ExampleApplication\n{\n    using Algorithms;\n    using System;\n    using System.Collections.Generic;\n    using System.Linq;\n\n    public class Task\n    {\n        public string Message;\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            List<Task> tasks = new List<Task>\n            {\n                new Task{ Message = \"A - depends on B and C\" },    //0\n                new Task{ Message = \"B - depends on none\" },       //1\n                new Task{ Message = \"C - depends on D and E\" },    //2\n                new Task{ Message = \"D - depends on none\" },       //3\n                new Task{ Message = \"E - depends on F, G and H\" }, //4\n                new Task{ Message = \"F - depends on I\" },          //5\n                new Task{ Message = \"G - depends on none\" },       //6\n                new Task{ Message = \"H - depends on none\" },       //7\n                new Task{ Message = \"I - depends on none\" },       //8\n            };\n\n            TopologicalSorter<Task> resolver = new TopologicalSorter<Task>();\n\n            // now setting relations between them as described above\n            resolver.Add(tasks[0], new[] { tasks[1], tasks[2] });\n            //resolver.Add(tasks[1]); // no need for this since the task was already mentioned as a dependency\n            resolver.Add(tasks[2], new[] { tasks[3], tasks[4] });\n            //resolver.Add(tasks[3]); // no need for this since the task was already mentioned as a dependency\n            resolver.Add(tasks[4], tasks[5], tasks[6], tasks[7]);\n            resolver.Add(tasks[5], tasks[8]);\n            //resolver.Add(tasks[6]); // no need for this since the task was already mentioned as a dependency\n            //resolver.Add(tasks[7]); // no need for this since the task was already mentioned as a dependency\n\n            //resolver.Add(tasks[3], tasks[0]); // uncomment this line to test cycled dependency\n\n            var result = resolver.Sort();\n            var sorted = result.Item1;\n            var cycled = result.Item2;\n\n            if (!cycled.Any())\n            {\n                foreach (var d in sorted) Console.WriteLine(d.Message);\n            }\n            else\n            {\n                Console.Write(\"Cycled dependencies detected: \");\n\n                foreach (var d in cycled) Console.Write($\"{d.Message[0]} \");\n\n                Console.WriteLine();\n            }\n\n            Console.WriteLine(\"exiting...\");\n        }\n    }\n}\n\n\nOutput:B - depends on none\nD - depends on none\nG - depends on none\nH - depends on none\nI - depends on none\nF - depends on I\nE - depends on F, G and H\nC - depends on D and E\nA - depends on B and C\nexiting...\n\n\nOutput:(with cycled dependency)Cycled dependencies detected: A C D\nexiting...\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nES6[edit]\nconst libs =\n  `des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\n  dw01             ieee dw01 dware gtech\n  dw02             ieee dw02 dware\n  dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\n  dw04             dw04 ieee dw01 dware gtech\n  dw05             dw05 ieee dware\n  dw06             dw06 ieee dware\n  dw07             ieee dware\n  dware            ieee dware\n  gtech            ieee gtech\n  ramlib           std ieee\n  std_cell_lib     ieee std_cell_lib\n  synopsys`;\n\n// A map of the input data, with the keys as the packages, and the values as\n// and array of packages on which it depends.\nconst D = libs\n  .split('\\n')\n  .map(e => e.split(' ').filter(e => e != ''))\n  .reduce((p, c) =>\n    p.set(c[0], c.filter((e, i) => i > 0 && e !== c[0] ? e : null)), new Map());\n[].concat(...D.values()).forEach(e => {\n  D.set(e, D.get(e) || [])\n});\n\n// The above map rotated so that it represents a DAG of the form\n// Map {\n//    A => [ A, B, C],\n//    B => [C],\n//    C => []\n// }\n// where each key represents a node, and the array contains the edges.\nconst G = [...D.keys()].reduce((p, c) =>\n  p.set(\n    c,\n    [...D.keys()].filter(e => D.get(e).includes(c))),\n  new Map()\n);\n\n// An array of leaf nodes; nodes with 0 in degrees.\nconst Q = [...D.keys()].filter(e => D.get(e).length == 0);\n\n// The result array.\nconst S = [];\nwhile (Q.length) {\n  const u = Q.pop();\n  S.push(u);\n  G.get(u).forEach(v => {\n    D.set(v, D.get(v).filter(e => e !== u));\n    if (D.get(v).length == 0) {\n      Q.push(v);\n    }\n  });\n}\n\nconsole.log('Solution:', S);\n\n\nSolution: [\n  'ieee',\n  'std_cell_lib',\n  'gtech',\n  'dware',\n  'dw07',\n  'dw06',\n  'dw05',\n  'dw02',\n  'dw01',\n  'dw04',\n  'std',\n  'ramlib',\n  'synopsys',\n  'dw03',\n  'des_system_lib' ]\n\n", "explain": "Output:\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Visual_Basic_.NET", "code": "\n\n' Adapted from:\n' http://tawani.blogspot.com/2009/02/topological-sorting-and-cyclic.html\n' added/changed:\n' - conversion to VB.Net (.Net 2 framework)\n' - added Rosetta Code dependency format parsing\n' - check & removal of self-dependencies before sorting\nModule Program\n\tSub Main()\n\t\tDim Fields As New List(Of Field)()\n\t\t' You can also add Dependson using code like:\n\t\t' .DependsOn = New String() {\"ieee\", \"dw01\", \"dware\"} _\n\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"des_system_lib\", _\n\t\t\t.DependsOn = Split(\"std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\", \" \") _\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw01\", _\n\t\t\t.DependsOn = Split(\"ieee dw01 dware gtech\", \" \") _\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw02\", _\n\t\t\t.DependsOn = Split(\"ieee dw02 dware\", \" \") _\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw03\", _\n\t\t\t.DependsOn = Split(\"std synopsys dware dw03 dw02 dw01 ieee gtech\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw04\", _\n\t\t\t.DependsOn = Split(\"dw04 ieee dw01 dware gtech\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw05\", _\n\t\t\t.DependsOn = Split(\"dw05 ieee dware\", \" \") _\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw06\", _\n\t\t\t.DependsOn = Split(\"dw06 ieee dware\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dw07\", _\n\t\t\t.DependsOn = Split(\"ieee dware\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"dware\", _\n\t\t\t.DependsOn = Split(\"ieee dware\", \" \") _\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"gtech\", _\n\t\t\t.DependsOn = Split(\"ieee gtech\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"ramlib\", _\n\t\t\t.DependsOn = Split(\"std ieee\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"std_cell_lib\", _\n\t\t\t.DependsOn = Split(\"ieee std_cell_lib\", \" \") _\t\t\t\n\t\t})\n\t\tfields.Add(New Field() With { _\n\t\t\t.Name = \"synopsys\" _\n\t\t})\t\t\n\t\tConsole.WriteLine(\"Input:\")\n\t\tFor Each ThisField As field In fields\n\t\t\tConsole.WriteLine(ThisField.Name)\n\t\t\tIf ThisField.DependsOn IsNot Nothing Then\n\t\t\t\tFor Each item As String In ThisField.DependsOn\n\t\t\t\t\tConsole.WriteLine(\" -{0}\", item)\n\t\t\t\tNext\n\t\t\tEnd If\n\t\tNext\n\n\t\tConsole.WriteLine(vbLf & \"...Sorting...\" & vbLf)\n\n\t\tDim sortOrder As Integer() = getTopologicalSortOrder(fields)\n\n\t\tFor i As Integer = 0 To sortOrder.Length - 1\n\t\t\tDim field = fields(sortOrder(i))\n\t\t\tConsole.WriteLine(field.Name)\n\t\t\t' Write up dependencies, too:\n\t\t\t'If field.DependsOn IsNot Nothing Then\n\t\t\t'\tFor Each item As String In field.DependsOn\n\t\t\t'\t\tConsole.WriteLine(\" -{0}\", item)\n\t\t\t'\tNext\n\t\t\t'End If\n\t\tNext\n\t\tConsole.Write(\"Press any key to continue . . . \")\n\t\tConsole.ReadKey(True)\n\tEnd Sub\n\t\n\tPrivate Sub CheckDependencies (ByRef Fields As List(Of Field))\n\t\t' Make sure all objects we depend on are part of the field list\n\t\t' themselves, as there may be dependencies that are not specified as fields themselves.\n\t\t' Remove dependencies on fields themselves.Y\t\t\t\n\t\tDim AField As Field, ADependency As String\n\t\t\n\t\tFor i As Integer = Fields.Count - 1 To 0 Step -1\n\t\t\tAField=fields(i)\n\t\t\tIf AField.DependsOn IsNot Nothing  then\n\t\t\t\tFor j As Integer = 0 To Ubound(AField.DependsOn)\n\t\t\t\t\tADependency = Afield.DependsOn(j)\n\t\t\t\t\t' We ignore fields that depends on themselves:\n\t\t\t\t\tIf AField.Name <> ADependency then\n\t\t\t\t\t\tIf ListContainsVertex(fields, ADependency) = False Then\n\t\t\t\t\t\t\t' Add the dependent object to the field list, as it\n\t\t\t\t\t\t\t' needs to be there, without any dependencies\n\t\t\t\t\t\t\tFields.Add(New Field() With { _\n\t\t\t\t\t\t\t\t.Name = ADependency _\n\t\t\t\t\t\t\t})\n\t\t\t\t\t\tEnd If\n\t\t\t\t\tEnd If\n\t\t\t\tNext j\n\t\t\tEnd If\n\t\tNext i\t\n\tEnd Sub\n\t\n\tPrivate Sub RemoveSelfDependencies (ByRef Fields As List(Of Field))\n\t\t' Make sure our fields don't depend on themselves.\n\t\t' If they do, remove the dependency.\n\t\tDim InitialUbound as Integer\n\t\tFor Each AField As Field In Fields\t\t\t\n\t\t\tIf AField.DependsOn IsNot Nothing Then\n\t\t\t\tInitialUbound = Ubound(AField.DependsOn)\n\t\t\t\tFor i As Integer = InitialUbound to 0 Step - 1\n\t\t\t\t\tIf Afield.DependsOn(i) = Afield.Name Then\n\t\t\t\t\t\t' This field depends on itself, so remove\n\t\t\t\t\t\tFor j as Integer = i To UBound(AField.DependsOn)-1\n\t\t\t\t\t\t\tAfield.DependsOn(j)=Afield.DependsOn(j+1)\n\t\t\t\t\t\tNext\n\t\t\t\t\t\tReDim Preserve Afield.DependsOn(UBound(Afield.DependsOn)-1)\n\t\t\t\t\tEnd If\n\t\t\t\tNext\n\t\t\tEnd If\t\t\t\n\t\tNext\n\tEnd Sub\t\n\t\t\t\n\tPrivate Function ListContainsVertex(Fields As List(Of Field), VertexName As String) As Boolean\n\t' Check to see if the list of Fields already contains a vertext called VertexName\n\tDim Found As Boolean = False\n\t\tFor i As Integer = 0 To fields.Count - 1\n\t\t\tIf Fields(i).Name = VertexName Then\n\t\t\t\tFound = True\n\t\t\t\tExit For\n\t\t\tEnd If\n\t\tNext\n\t\tReturn Found\n\tEnd Function\n\n\tPrivate Function getTopologicalSortOrder(ByRef Fields As List(Of Field)) As Integer()\n\t\t' Gets sort order. Will also add required dependencies to\n\t\t' Fields.\n\t\t\n\t\t' Make sure we don't have dependencies on ourselves.\n\t\t' We'll just get rid of them.\n\t\tRemoveSelfDependencies(Fields)\n\t\t\n\t\t'First check depencies, add them to Fields if required:\n\t\tCheckDependencies(Fields)\n\t\t' Now we have the correct Fields list, so we can proceed:\n\t\tDim g As New TopologicalSorter(fields.Count)\n\t\tDim _indexes As New Dictionary(Of String, Integer)(fields.count)\n\n\t\t'add vertex names to our lookup dictionaey\n\t\tFor i As Integer = 0 To fields.Count - 1\n\t\t\t_indexes(fields(i).Name.ToLower()) = g.AddVertex(i)\n\t\tNext\n\n\t\t'add edges\n\t\tFor i As Integer = 0 To fields.Count - 1\n\t\t\tIf fields(i).DependsOn IsNot Nothing Then\n\t\t\t\tFor j As Integer = 0 To fields(i).DependsOn.Length - 1\n\t\t\t\t\tg.AddEdge(i, _indexes(fields(i).DependsOn(j).ToLower()))\n\t\t\t\tNext\n\t\t\tEnd If\n\t\tNext\n\n\t\tDim result As Integer() = g.Sort()\n\t\tReturn result\n\tEnd Function\n\n\tPrivate Class Field\n\t\tPublic Property Name() As String\n\t\t\tGet\n\t\t\t\tReturn m_Name\n\t\t\tEnd Get\n\t\t\tSet\n\t\t\t\tm_Name = Value\n\t\t\tEnd Set\n\t\tEnd Property\n\t\tPrivate m_Name As String\n\t\tPublic Property DependsOn() As String()\n\t\t\tGet\n\t\t\t\tReturn m_DependsOn\n\t\t\tEnd Get\n\t\t\tSet\n\t\t\t\tm_DependsOn = Value\n\t\t\tEnd Set\n\t\tEnd Property\n\t\tPrivate m_DependsOn As String()\n\tEnd Class\nEnd Module\nClass TopologicalSorter\n\t''source adapted from:\n\t''http://tawani.blogspot.com/2009/02/topological-sorting-and-cyclic.html\n\t''which was adapted from:\n\t''http://www.java2s.com/Code/Java/Collections-Data-Structure/Topologicalsorting.htm\n\t#Region \"- Private Members -\"\n\n\tPrivate ReadOnly _vertices As Integer()\n\t' list of vertices\n\tPrivate ReadOnly _matrix As Integer(,)\n\t' adjacency matrix\n\tPrivate _numVerts As Integer\n\t' current number of vertices\n\tPrivate ReadOnly _sortedArray As Integer()\n\t' Sorted vertex labels\n\n\t#End Region\n\n\t#Region \"- CTors -\"\n\n\tPublic Sub New(size As Integer)\n\t\t_vertices = New Integer(size - 1) {}\n\t\t_matrix = New Integer(size - 1, size - 1) {}\n\t\t_numVerts = 0\n\t\tFor i As Integer = 0 To size - 1\n\t\t\tFor j As Integer = 0 To size - 1\n\t\t\t\t_matrix(i, j) = 0\n\t\t\tNext\n\t\tNext\n\t\t\t' sorted vert labels\n\t\t_sortedArray = New Integer(size - 1) {}\n\tEnd Sub\n\n\t#End Region\n\n\t#Region \"- Public Methods -\"\n\n\tPublic Function AddVertex(vertex As Integer) As Integer\n\t\t_vertices(System.Threading.Interlocked.Increment(_numVerts)-1) = vertex\n\t\tReturn _numVerts - 1\n\tEnd Function\n\n\tPublic Sub AddEdge(start As Integer, [end] As Integer)\n\t\t_matrix(start, [end]) = 1\n\tEnd Sub\n\n\tPublic Function Sort() As Integer()\n\t' Topological sort\n\t\tWhile _numVerts > 0\n\t\t\t' while vertices remain,\n\t\t\t' get a vertex with no successors, or -1\n\t\t\tDim currentVertex As Integer = noSuccessors()\n\t\t\tIf currentVertex = -1 Then\n\t\t\t\t' must be a cycle\n\t\t\t\tThrow New Exception(\"Graph has cycles\")\n\t\t\tEnd If\n\n\t\t\t' insert vertex label in sorted array (start at end)\n\t\t\t_sortedArray(_numVerts - 1) = _vertices(currentVertex)\n\n\t\t\t\t' delete vertex\n\t\t\tdeleteVertex(currentVertex)\n\t\tEnd While\n\n\t\t' vertices all gone; return sortedArray\n\t\tReturn _sortedArray\n\tEnd Function\n\n\t#End Region\n\n\t#Region \"- Private Helper Methods -\"\n\n\t' returns vert with no successors (or -1 if no such verts)\n\tPrivate Function noSuccessors() As Integer\n\t\tFor row As Integer = 0 To _numVerts - 1\n\t\t\tDim isEdge As Boolean = False\n\t\t\t' edge from row to column in adjMat\n\t\t\tFor col As Integer = 0 To _numVerts - 1\n\t\t\t\tIf _matrix(row, col) > 0 Then\n\t\t\t\t\t' if edge to another,\n\t\t\t\t\tisEdge = True\n\t\t\t\t\t\t' this vertex has a successor try another\n\t\t\t\t\tExit For\n\t\t\t\tEnd If\n\t\t\tNext\n\t\t\tIf Not isEdge Then\n\t\t\t\t' if no edges, has no successors\n\t\t\t\tReturn row\n\t\t\tEnd If\n\t\tNext\n\t\tReturn -1\n\t\t' no\n\tEnd Function\n\n\tPrivate Sub deleteVertex(delVert As Integer)\n\t\t' if not last vertex, delete from vertexList\n\t\tIf delVert <> _numVerts - 1 Then\n\t\t\tFor j As Integer = delVert To _numVerts - 2\n\t\t\t\t_vertices(j) = _vertices(j + 1)\n\t\t\tNext\n\n\t\t\tFor row As Integer = delVert To _numVerts - 2\n\t\t\t\tmoveRowUp(row, _numVerts)\n\t\t\tNext\n\n\t\t\tFor col As Integer = delVert To _numVerts - 2\n\t\t\t\tmoveColLeft(col, _numVerts - 1)\n\t\t\tNext\n\t\tEnd If\n\t\t_numVerts -= 1\n\t\t' one less vertex\n\tEnd Sub\n\n\tPrivate Sub moveRowUp(row As Integer, length As Integer)\n\t\tFor col As Integer = 0 To length - 1\n\t\t\t_matrix(row, col) = _matrix(row + 1, col)\n\t\tNext\n\tEnd Sub\n\n\tPrivate Sub moveColLeft(col As Integer, length As Integer)\n\t\tFor row As Integer = 0 To length - 1\n\t\t\t_matrix(row, col) = _matrix(row, col + 1)\n\t\tNext\n\tEnd Sub\n\n\t#End Region\nEnd Class\n\nOutput[edit]\nInput:\ndes_system_lib\n -std\n -synopsys\n -std_cell_lib\n -des_system_lib\n -dw02\n -dw01\n -ramlib\n -ieee\ndw01\n -ieee\n -dw01\n -dware\n -gtech\ndw02\n -ieee\n -dw02\n -dware\ndw03\n -std\n -synopsys\n -dware\n -dw03\n -dw02\n -dw01\n -ieee\n -gtech\ndw04\n -dw04\n -ieee\n -dw01\n -dware\n -gtech\ndw05\n -dw05\n -ieee\n -dware\ndw06\n -dw06\n -ieee\n -dware\ndw07\n -ieee\n -dware\ndware\n -ieee\n -dware\ngtech\n -ieee\n -gtech\nramlib\n -std\n -ieee\nstd_cell_lib\n -ieee\n -std_cell_lib\nsynopsys\n\n...Sorting...\n\ndes_system_lib\nramlib\ndw03\nstd\nstd_cell_lib\ndw04\ndw01\ngtech\ndw07\ndw06\ndw05\ndw02\ndware\nieee\nsynopsys\nPress any key to continue . . .\n\n", "explain": "Adapted from http://tawani.blogspot.com/2009/02/topological-sorting-and-cyclic.html which was itself an adaptation of Java code. I added the Rosetta code specific format of dependencies, as well as checks for references to self.\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Fortran", "code": "\nFORTRAN 77[edit]\n\n      SUBROUTINE TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n      IMPLICIT NONE\n      INTEGER NL,ND,NO,IDEP(ND,2),IORD(NL),IPOS(NL),I,J,K,IL,IR,IPL,IPR\n      DO 10 I=1,NL\n      IORD(I)=I\n   10 IPOS(I)=I\n      K=1\n   20 J=K\n      K=NL+1\n      DO 30 I=1,ND\n      IL=IDEP(I,1)\n      IR=IDEP(I,2)\n      IPL=IPOS(IL)\n      IPR=IPOS(IR)\n      IF(IL.EQ.IR .OR. IPL.GE.K .OR. IPL.LT.J .OR. IPR.LT.J) GO TO 30\n      K=K-1\n      IPOS(IORD(K))=IPL\n      IPOS(IL)=K\n      IORD(IPL)=IORD(K)\n      IORD(K)=IL\n   30 CONTINUE\n      IF(K.GT.J) GO TO 20\n      NO=J-1\n      END\n\n\n      PROGRAM EX_TSORT\n      IMPLICIT NONE\n      INTEGER NL,ND,NC,NO,IDEP,IORD,IPOS,ICODE,I,J,IL,IR\n      PARAMETER(NL=15,ND=44,NC=69)\n      CHARACTER*(20) LABEL\n      DIMENSION IDEP(ND,2),LABEL(NL),IORD(NL),IPOS(NL),ICODE(NC)\n      DATA LABEL/'DES_SYSTEM_LIB','DW01','DW02','DW03','DW04','DW05',\n     1 'DW06','DW07','DWARE','GTECH','RAMLIB','STD_CELL_LIB','SYNOPSYS',\n     2 'STD','IEEE'/\n      DATA ICODE/1,14,13,12,1,3,2,11,15,0,2,15,2,9,10,0,3,15,3,9,0,4,14,\n     213,9,4,3,2,15,10,0,5,5,15,2,9,10,0,6,6,15,9,0,7,7,15,9,0,8,15,9,0,\n     39,15,9,0,10,15,10,0,11,14,15,0,12,15,12,0,0/\n\nC DECODE DEPENDENCIES AND BUILD IDEP ARRAY\n      I=0\n      J=0\n   10 I=I+1\n      IL=ICODE(I)\n      IF(IL.EQ.0) GO TO 30\n   20 I=I+1\n      IR=ICODE(I)\n      IF(IR.EQ.0) GO TO 10\n      J=J+1\n      IDEP(J,1)=IL\n      IDEP(J,2)=IR\n      GO TO 20\n   30 CONTINUE\n\nC SORT LIBRARIES ACCORDING TO DEPENDENCIES (TOPOLOGICAL SORT)\n      CALL TSORT(NL,ND,IDEP,IORD,IPOS,NO)\n\n      PRINT*,'COMPILE ORDER'\n      DO 40 I=1,NO\n   40 PRINT*,LABEL(IORD(I))\n      PRINT*,'UNORDERED LIBRARIES'\n      DO 50 I=NO+1,NL\n   50 PRINT*,LABEL(IORD(I))\n      END\n\n\nOutput:\n COMPILE ORDER\n IEEE\n STD\n SYNOPSYS\n STD_CELL_LIB\n RAMLIB\n GTECH\n DWARE\n DW07\n DW06\n DW05\n DW02\n DW01\n DW04\n DW03\n DES_SYSTEM_LIB\n UNORDERED LIBRARIES\n\n\nOutput: with alternate input (DW01 depends also on DW04)\n\n COMPILE ORDER\n IEEE                \n STD                 \n SYNOPSYS            \n STD_CELL_LIB        \n RAMLIB              \n GTECH               \n DWARE               \n DW07                \n DW06                \n DW05                \n DW02                \n UNORDERED LIBRARIES\n DW04                \n DW03                \n DW01                \n DES_SYSTEM_LIB      \n\nModern Fortran[edit]\n\nsubroutine tsort(nl,nd,idep,iord,no)\n\n  implicit none\n  \n  integer,intent(in) :: nl\n  integer,intent(in) :: nd\n  integer,dimension(nd,2),intent(in) :: idep\n  integer,dimension(nl),intent(out) :: iord\n  integer,intent(out) :: no\n  \n  integer :: i,j,k,il,ir,ipl,ipr,ipos(nl)\n  \n  do i=1,nl\n    iord(i)=i\n    ipos(i)=i\n  end do\n  k=1\n  do\n    j=k\n    k=nl+1\n    do i=1,nd\n      il=idep(i,1)\n      ir=idep(i,2)\n      ipl=ipos(il)\n      ipr=ipos(ir)\n      if (il==ir .or. ipl>=k .or. ipl<j .or. ipr<j) cycle\n      k=k-1\n      ipos(iord(k))=ipl\n      ipos(il)=k\n      iord(ipl)=iord(k)\n      iord(k)=il\n    end do\n    if (k<=j) exit\n  end do\n  no=j-1\n\nend subroutine tsort\n\n", "explain": "Main routine for topological sort.\nInput\u00a0: IDEP is an array ND x 2 of dependencies, with IDEP(I,1) depending on IDEP(I,2).\nNL is the number of libraries to sort, ND the number of dependencies, one for each pair of ordered libraries.\nArray IPOS is used internally by the routine, to maintain a list of positions of libraries in IORD.\nOutput\u00a0: IORD(1:NO) is the compile order, and IORD(NO+1:NL) contains unordered libraries.\nThis implementation is not optimal: for each level of dependency (for example A -> B -> C counts as three levels), there is a loop through all dependencies in IDEP. \nIt would be possible to optimize a bit, without changing the main idea, by first sorting IDEP according to first column, and using more temporary space, keeping track of where is located data in IDEP for each library (all dependencies of a same library being grouped).\nAn example. Dependencies are encoded to make program shorter (in array ICODE).\nA modern Fortran (95-2008) version of the TSORT subroutine is shown here (note that the IPOS array is not an input). \n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Go", "code": "\nKahn[edit]\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nvar data = `\nLIBRARY          LIBRARY DEPENDENCIES\n=======          ====================\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys         `\n\nfunc main() {\n    g, in, err := parseLibComp(data)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    order, cyclic := topSortKahn(g, in)\n    if cyclic != nil {\n        fmt.Println(\"Cyclic:\", cyclic)\n        return\n    }\n    fmt.Println(\"Order:\", order)\n}\n\ntype graph map[string][]string\ntype inDegree map[string]int\n\n// parseLibComp parses the text format of the task and returns a graph\n// representation and a list of the in-degrees of each node.  The returned graph\n// represents compile order rather than dependency order.  That is, for each map\n// map key n, the map elements are libraries that depend on n being compiled\n// first.\nfunc parseLibComp(data string) (g graph, in inDegree, err error) {\n    // small sanity check on input\n    lines := strings.Split(data, \"\\n\")\n    if len(lines) < 3 || !strings.HasPrefix(lines[2], \"=\") {\n        return nil, nil, fmt.Errorf(\"data format\")\n    }\n    // toss header lines\n    lines = lines[3:]\n    // scan and interpret input, build graph\n    g = graph{}\n    in = inDegree{}\n    for _, line := range lines {\n        libs := strings.Fields(line)\n        if len(libs) == 0 {\n            continue // allow blank lines\n        }\n        lib := libs[0]\n        g[lib] = g[lib]\n        for _, dep := range libs[1:] {\n            in[dep] = in[dep]\n            if dep == lib {\n                continue // ignore self dependencies\n            }\n            successors := g[dep]\n            for i := 0; ; i++ {\n                if i == len(successors) {\n                    g[dep] = append(successors, lib)\n                    in[lib]++\n                    break\n                }\n                if dep == successors[i] {\n                    break // ignore duplicate dependencies\n                }\n            }\n        }\n    }\n    return g, in, nil\n}\n\n// General purpose topological sort, not specific to the application of\n// library dependencies.  Adapted from Wikipedia pseudo code, one main\n// difference here is that this function does not consume the input graph.\n// WP refers to incoming edges, but does not really need them fully represented.\n// A count of incoming edges, or the in-degree of each node is enough.  Also,\n// WP stops at cycle detection and doesn't output information about the cycle.\n// A little extra code at the end of this function recovers the cyclic nodes.\nfunc topSortKahn(g graph, in inDegree) (order, cyclic []string) {\n    var L, S []string\n    // rem for \"remaining edges,\" this function makes a local copy of the\n    // in-degrees and consumes that instead of consuming an input.\n    rem := inDegree{}\n    for n, d := range in {\n        if d == 0 {\n            // accumulate \"set of all nodes with no incoming edges\"\n            S = append(S, n)\n        } else {\n            // initialize rem from in-degree\n            rem[n] = d\n        }\n    }\n    for len(S) > 0 {\n        last := len(S) - 1 // \"remove a node n from S\"\n        n := S[last]\n        S = S[:last]\n        L = append(L, n) // \"add n to tail of L\"\n        for _, m := range g[n] {\n            // WP pseudo code reads \"for each node m...\" but it means for each\n            // node m *remaining in the graph.*  We consume rem rather than\n            // the graph, so \"remaining in the graph\" for us means rem[m] > 0.\n            if rem[m] > 0 {\n                rem[m]--         // \"remove edge from the graph\"\n                if rem[m] == 0 { // if \"m has no other incoming edges\"\n                    S = append(S, m) // \"insert m into S\"\n                }\n            }\n        }\n    }\n    // \"If graph has edges,\" for us means a value in rem is > 0.\n    for c, in := range rem {\n        if in > 0 {\n            // recover cyclic nodes\n            for _, nb := range g[c] {\n                if rem[nb] > 0 {\n                    cyclic = append(cyclic, c)\n                    break\n                }\n            }\n        }\n    }\n    if len(cyclic) > 0 {\n        return nil, cyclic\n    }\n    return L, nil\n}\n\n\nOutput:\nOrder: [std ieee std_cell_lib ramlib gtech dware dw07 dw06 dw05 dw02 dw01 dw04 synopsys dw03 des_system_lib]\n\n\nCyclic: [dw01 dw04]\n\nDepth First[edit]\n\n// General purpose topological sort, not specific to the application of\n// library dependencies.  Also adapted from Wikipedia pseudo code.\nfunc topSortDFS(g graph) (order, cyclic []string) {\n    L := make([]string, len(g))\n    i := len(L)\n    temp := map[string]bool{}\n    perm := map[string]bool{}\n    var cycleFound bool\n    var cycleStart string\n    var visit func(string)\n    visit = func(n string) {\n        switch {\n        case temp[n]:\n            cycleFound = true\n            cycleStart = n\n            return\n        case perm[n]:\n            return\n        }\n        temp[n] = true\n        for _, m := range g[n] {\n            visit(m)\n            if cycleFound {\n                if cycleStart > \"\" {\n                    cyclic = append(cyclic, n)\n                    if n == cycleStart {\n                        cycleStart = \"\"\n                    }\n                }\n                return\n            }\n        }\n        delete(temp, n)\n        perm[n] = true\n        i--\n        L[i] = n\n    }\n    for n := range g {\n        if perm[n] {\n            continue\n        }\n        visit(n)\n        if cycleFound {\n            return nil, cyclic\n        }\n    }\n    return L, nil\n}\n\n\nOutput:\n\nOrder: [ieee gtech synopsys dware dw07 dw06 dw02 dw01 dw04 std_cell_lib dw05 std ramlib dw03 des_system_lib]\n\n\nCyclic: [dw04 dw01]\n\n", "explain": "Cycle detection demonstrated with the example in the task description:\nTopological sort only, this function can replace topSortKahn in above program.  The\nin-degree list is not needed.\n(when used in program of Kahn example.)\nAnd with the cycle added,\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Object_Pascal", "code": "\n\nprogram topologicalsortrosetta;\n\n{*\nTopological sorter to parse e.g. dependencies.\nWritten for FreePascal 2.4.x/2.5.1. Probably works in Delphi, but you'd have to\nchange some units.\n*}\n{$IFDEF FPC}\n// FreePascal-specific setup\n{$mode objfpc}\nuses {$IFDEF UNIX}\n  cwstring, {* widestring support for unix *} {$IFDEF UseCThreads}\n  cthreads, {$ENDIF UseCThreads} {$ENDIF UNIX}\n  Classes,\n  SysUtils;\n{$ENDIF}\n\ntype\n  RNodeIndex = record\n    NodeName: WideString; //Name of the node\n    //Index: integer; //Index number used in DepGraph. For now, we can distill the index from the array index. If we want to use a TList or similar, we'd need an index property\n    Order: integer;  //Order when sorted\n  end;\n\n  RDepGraph = record\n    Node: integer;  //Refers to Index in NodeIndex\n    DependsOn: integer; //The Node depends on this other Node.\n  end;\n\n  { TTopologicalSort }\n\n  TTopologicalSort = class(TObject)\n  private\n    Nodes: array of RNodeIndex;\n    DependencyGraph: array of RDepGraph;\n    FCanBeSorted: boolean;\n    function SearchNode(NodeName: WideString): integer;\n    function SearchIndex(NodeID: integer): WideString;\n    function DepFromNodeID(NodeID: integer): integer;\n    function DepFromDepID(DepID: integer): integer;\n    function DepFromNodeIDDepID(NodeID, DepID: integer): integer;\n    procedure DelDependency(const Index: integer);\n  public\n    constructor Create;\n    destructor Destroy; override;\n    procedure SortOrder(var Output: TStringList);\n    procedure AddNode(NodeName: WideString);\n    procedure AddDependency(NodeName, DependsOn: WideString);\n    procedure AddNodeDependencies(NodeAndDependencies: TStringList);\n    //Each string has node, and the nodes it depends on. This allows insertion of an entire dependency graph at once\n    //procedure DelNode(NodeName: Widestring);\n    procedure DelDependency(NodeName, DependsOn: WideString);\n\n    property CanBeSorted: boolean read FCanBeSorted;\n\n  end;\n\nconst\n  INVALID = -1;\n  // index not found for index search functions, no sort order defined, or record invalid/deleted\n\n  function TTopologicalSort.SearchNode(NodeName: WideString): integer;\n  var\n    Counter: integer;\n  begin\n    // Return -1 if node not found. If node found, return index in array\n    Result := INVALID;\n    for Counter := 0 to High(Nodes) do\n    begin\n      if Nodes[Counter].NodeName = NodeName then\n      begin\n        Result := Counter;\n        break;\n      end;\n    end;\n  end;\n\n  function TTopologicalSort.SearchIndex(NodeID: integer): WideString;\n    //Look up name for the index\n  begin\n    if (NodeID > 0) and (NodeID <= High(Nodes)) then\n    begin\n      Result := Nodes[NodeID].NodeName;\n    end\n    else\n    begin\n      Result := 'ERROR'; //something's fishy, this shouldn't happen\n    end;\n  end;\n\n  function TTopologicalSort.DepFromNodeID(NodeID: integer): integer;\n    // Look for Node index number in the dependency graph\n    // and return the first node found. If nothing found, return -1\n  var\n    Counter: integer;\n  begin\n    Result := INVALID;\n    for Counter := 0 to High(DependencyGraph) do\n    begin\n      if DependencyGraph[Counter].Node = NodeID then\n      begin\n        Result := Counter;\n        break;\n      end;\n    end;\n  end;\n\n  function TTopologicalSort.DepFromDepID(DepID: integer): integer;\n    // Look for dependency index number in the dependency graph\n    // and return the index for the first one found. If nothing found, return -1\n  var\n    Counter: integer;\n  begin\n    Result := INVALID;\n    for Counter := 0 to High(DependencyGraph) do\n    begin\n      if DependencyGraph[Counter].DependsOn = DepID then\n      begin\n        Result := Counter;\n        break;\n      end;\n    end;\n  end;\n\n  function TTopologicalSort.DepFromNodeIDDepID(NodeID, DepID: integer): integer;\n    // Shows index for the dependency from NodeID on DepID, or INVALID if not found\n  var\n    Counter: integer;\n  begin\n    Result := INVALID;\n    for Counter := 0 to High(DependencyGraph) do\n    begin\n      if DependencyGraph[Counter].Node = NodeID then\n        if DependencyGraph[Counter].DependsOn = DepID then\n        begin\n          Result := Counter;\n          break;\n        end;\n    end;\n  end;\n\n  procedure TTopologicalSort.DelDependency(const Index: integer);\n  // Removes dependency from array.\n  // Is fastest when the dependency is near the top of the array\n  // as we're copying the remaining elements.\n  var\n    Counter: integer;\n    OriginalLength: integer;\n  begin\n    OriginalLength := Length(DependencyGraph);\n    if Index = OriginalLength - 1 then\n    begin\n      SetLength(DependencyGraph, OriginalLength - 1);\n    end;\n    if Index < OriginalLength - 1 then\n    begin\n      for Counter := Index to OriginalLength - 2 do\n      begin\n        DependencyGraph[Counter] := DependencyGraph[Counter + 1];\n      end;\n      SetLength(DependencyGraph, OriginalLength - 1);\n    end;\n    if Index > OriginalLength - 1 then\n    begin\n      // This could happen when deleting on an empty array:\n      raise Exception.Create('Tried to delete index ' + IntToStr(Index) +\n        ' while the maximum index was ' + IntToStr(OriginalLength - 1));\n    end;\n  end;\n\n  constructor TTopologicalSort.Create;\n  begin\n    inherited Create;\n  end;\n\n  destructor TTopologicalSort.Destroy;\n  begin\n    // Clear up data just to make sure:\n    Finalize(DependencyGraph);\n    Finalize(Nodes);\n    inherited;\n  end;\n\n  procedure TTopologicalSort.SortOrder(var Output: TStringList);\n  var\n    Counter: integer;\n    NodeCounter: integer;\n    OutputSortOrder: integer;\n    DidSomething: boolean; //used to detect cycles (circular references)\n    Node: integer;\n  begin\n    OutputSortOrder := 0;\n    DidSomething := True; // prime the loop below\n    FCanBeSorted := True; //hope for the best.\n    while (DidSomething = True) do\n    begin\n      // 1. Find all nodes (now) without dependencies, output them first and remove the dependencies:\n      // 1.1 Nodes that are not present in the dependency graph at all:\n      for Counter := 0 to High(Nodes) do\n      begin\n        if DepFromNodeID(Counter) = INVALID then\n        begin\n          if DepFromDepID(Counter) = INVALID then\n          begin\n            // Node doesn't occur in either side of the dependency graph, so it has sort order 0:\n            DidSomething := True;\n            if (Nodes[Counter].Order = INVALID) or\n              (Nodes[Counter].Order > OutputSortOrder) then\n            begin\n              // Enter sort order if the node doesn't have a lower valid order already.\n              Nodes[Counter].Order := OutputSortOrder;\n            end;\n          end; //Invalid Dep\n        end; //Invalid Node\n      end; //Count\n      // Done with the first batch, so we can increase the sort order:\n      OutputSortOrder := OutputSortOrder + 1;\n      // 1.2 Nodes that are only present on the right hand side of the dep graph:\n      DidSomething := False;\n      // reverse order so we can delete dependencies without passing upper array\n      for Counter := High(DependencyGraph) downto 0 do\n      begin\n        Node := DependencyGraph[Counter].DependsOn; //the depended node\n        if (DepFromNodeID(Node) = INVALID) then\n        begin\n          DidSomething := True;\n          //Delete dependency so we don't hit it again:\n          DelDependency(Counter);\n          if (Nodes[Node].Order = INVALID) or (Nodes[Node].Order > OutputSortOrder) then\n          begin\n            // Enter sort order if the node doesn't have a lower valid order already.\n            Nodes[Node].Order := OutputSortOrder;\n          end;\n        end;\n        OutputSortOrder := OutputSortOrder + 1; //next iteration\n      end;\n      // 2. Go back to 1 until we can't do more work, and do some bookkeeping:\n      OutputSortOrder := OutputSortOrder + 1;\n    end; //outer loop for 1 to 2\n    OutputSortOrder := OutputSortOrder - 1; //fix unused last loop.\n\n    // 2. If we have dependencies left, we have a cycle; exit.\n    if (High(DependencyGraph) > 0) then\n    begin\n      FCanBeSorted := False; //indicate we have a cycle\n      Output.Add('Cycle (circular dependency) detected, cannot sort further. Dependencies left:');\n      for Counter := 0 to High(DependencyGraph) do\n      begin\n        Output.Add(SearchIndex(DependencyGraph[Counter].Node) +\n          ' depends on: ' + SearchIndex(DependencyGraph[Counter].DependsOn));\n      end;\n    end\n    else\n    begin\n      // No cycle:\n      // Now parse results, if we have them\n      for Counter := 0 to OutputSortOrder do\n      begin\n        for NodeCounter := 0 to High(Nodes) do\n        begin\n          if Nodes[NodeCounter].Order = Counter then\n          begin\n            Output.Add(Nodes[NodeCounter].NodeName);\n          end;\n        end; //output each result\n      end; //order iteration\n    end; //cycle detection\n  end;\n\n  procedure TTopologicalSort.AddNode(NodeName: WideString);\n  var\n    NodesNewLength: integer;\n  begin\n    // Adds node; make sure we don't add duplicate entries\n    if SearchNode(NodeName) = INVALID then\n    begin\n      NodesNewLength := Length(Nodes) + 1;\n      SetLength(Nodes, NodesNewLength);\n      Nodes[NodesNewLength - 1].NodeName := NodeName; //Arrays are 0 based\n      //Nodes[NodesNewLength -1].Index\u00a0:=  //If we change the object to a tlist or something, we already have an index property\n      Nodes[NodesNewLength - 1].Order := INVALID; //default value\n    end;\n  end;\n\n  procedure TTopologicalSort.AddDependency(NodeName, DependsOn: WideString);\n  begin\n    // Make sure both nodes in the dependency exist as a node\n    if SearchNode(NodeName) = INVALID then\n    begin\n      Self.AddNode(NodeName);\n    end;\n    if SearchNode(DependsOn) = INVALID then\n    begin\n      Self.AddNode(DependsOn);\n    end;\n    // Add the dependency, only if we don't depend on ourselves:\n    if NodeName <> DependsOn then\n    begin\n      SetLength(DependencyGraph, Length(DependencyGraph) + 1);\n      DependencyGraph[High(DependencyGraph)].Node := SearchNode(NodeName);\n      DependencyGraph[High(DependencyGraph)].DependsOn := SearchNode(DependsOn);\n    end;\n  end;\n\n  procedure TTopologicalSort.AddNodeDependencies(NodeAndDependencies: TStringList);\n  // Takes a stringlist containing a list of strings. Each string contains node names\n  // separated by spaces. The first node depends on the others. It is permissible to have\n  // only one node name, which doesn't depend on anything.\n  // This procedure will add the dependencies and the nodes in one go.\n  var\n    Deplist: TStringList;\n    StringCounter: integer;\n    NodeCounter: integer;\n  begin\n    if Assigned(NodeAndDependencies) then\n    begin\n      DepList := TStringList.Create;\n      try\n        for StringCounter := 0 to NodeAndDependencies.Count - 1 do\n        begin\n          // For each string in the argument: split into names, and process:\n          DepList.Delimiter := ' '; //use space to separate the entries\n          DepList.StrictDelimiter := False; //allows us to ignore double spaces in input.\n          DepList.DelimitedText := NodeAndDependencies[StringCounter];\n          for NodeCounter := 0 to DepList.Count - 1 do\n          begin\n            if NodeCounter = 0 then\n            begin\n              // Add the first node, which might be the only one.\n              Self.AddNode(Deplist[0]);\n            end;\n\n            if NodeCounter > 0 then\n            begin\n              // Only add dependency from the second item onwards\n              // The AddDependency code will automatically add Deplist[0] to the Nodes, if required\n              Self.AddDependency(DepList[0], DepList[NodeCounter]);\n            end;\n          end;\n        end;\n      finally\n        DepList.Free;\n      end;\n    end;\n  end;\n\n  procedure TTopologicalSort.DelDependency(NodeName, DependsOn: WideString);\n  // Delete the record.\n  var\n    NodeID: integer;\n    DependsID: integer;\n    Dependency: integer;\n  begin\n    NodeID := Self.SearchNode(NodeName);\n    DependsID := Self.SearchNode(DependsOn);\n    if (NodeID <> INVALID) and (DependsID <> INVALID) then\n    begin\n      // Look up dependency and delete it.\n      Dependency := Self.DepFromNodeIDDepID(NodeID, DependsID);\n      if (Dependency <> INVALID) then\n      begin\n        Self.DelDependency(Dependency);\n      end;\n    end;\n  end;\n\n  // Main program:\nvar\n  InputList: TStringList; //Lines of dependencies\n  TopSort: TTopologicalSort; //Topological sort object\n  OutputList: TStringList; //Sorted dependencies\n  Counter: integer;\nbegin\n\n  //Actual sort\n  InputList := TStringList.Create;\n  // Add rosetta code sample input separated by at least one space in the lines\n  InputList.Add(\n    'des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee');\n  InputList.Add('dw01             ieee dw01 dware gtech');\n  InputList.Add('dw02             ieee dw02 dware');\n  InputList.Add('dw03             std synopsys dware dw03 dw02 dw01 ieee gtech');\n  InputList.Add('dw04             dw04 ieee dw01 dware gtech');\n  InputList.Add('dw05             dw05 ieee dware');\n  InputList.Add('dw06             dw06 ieee dware');\n  InputList.Add('dw07             ieee dware');\n  InputList.Add('dware            ieee dware');\n  InputList.Add('gtech            ieee gtech');\n  InputList.Add('ramlib           std ieee');\n  InputList.Add('std_cell_lib     ieee std_cell_lib');\n  InputList.Add('synopsys');\n  TopSort := TTopologicalSort.Create;\n  OutputList := TStringList.Create;\n  try\n    TopSort.AddNodeDependencies(InputList); //read in nodes\n    TopSort.SortOrder(OutputList); //perform the sort\n    for Counter := 0 to OutputList.Count - 1 do\n    begin\n      writeln(OutputList[Counter]);\n    end;\n  except\n    on E: Exception do\n    begin\n      Writeln(stderr, 'Error: ', DateTimeToStr(Now),\n        ': Error sorting. Technical details: ',\n        E.ClassName, '/', E.Message);\n    end;\n  end; //try\n  OutputList.Free;\n  TopSort.Free;\n  InputList.Free;\nend.\n\n", "explain": "Written for Free Pascal, but will probably work in Delphi if you change the required units.\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Ruby", "code": "\n\nrequire 'tsort'\nclass Hash\n  include TSort\n  alias tsort_each_node each_key\n  def tsort_each_child(node, &block)\n    fetch(node).each(&block)\n  end\nend\n\ndepends = {}\nDATA.each do |line|\n  key, *libs = line.split\n  depends[key] = libs\n  libs.each {|lib| depends[lib] ||= []}\nend\n\nbegin\n  p depends.tsort\n  depends[\"dw01\"] << \"dw04\"\n  p depends.tsort\nrescue TSort::Cyclic => e\n  puts \"\\ncycle detected: #{e}\"\nend\n\n__END__\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys\n\n\nOutput:\n[\"std\", \"synopsys\", \"ieee\", \"std_cell_lib\", \"dware\", \"dw02\", \"gtech\", \"dw01\", \"ramlib\", \"des_system_lib\", \"dw03\", \"dw04\", \"dw05\", \"dw06\", \"dw07\"]\n\ncycle detected: topological sort failed: [\"dw01\", \"dw04\"]\n\n", "explain": "Uses the TSort module from the Ruby stdlib.\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Rust", "code": "\nuse std::boxed::Box;\nuse std::collections::{HashMap, HashSet};\n\n#[derive(Debug, PartialEq, Eq, Hash)]\nstruct Library<'a> {\n    name: &'a str,\n    children: Vec<&'a str>,\n    num_parents: usize,\n}\n\nfn build_libraries(input: Vec<&str>) -> HashMap<&str, Box<Library>> {\n    let mut libraries: HashMap<&str, Box<Library>> = HashMap::new();\n\n    for input_line in input {\n        let line_split = input_line.split_whitespace().collect::<Vec<&str>>();\n        let name = line_split.get(0).unwrap();\n        let mut num_parents: usize = 0;\n        for parent in line_split.iter().skip(1) {\n            if parent == name {\n                continue;\n            }\n            if !libraries.contains_key(parent) {\n                libraries.insert(\n                    parent,\n                    Box::new(Library {\n                        name: parent,\n                        children: vec![name],\n                        num_parents: 0,\n                    }),\n                );\n            } else {\n                libraries.get_mut(parent).unwrap().children.push(name);\n            }\n            num_parents += 1;\n        }\n\n        if !libraries.contains_key(name) {\n            libraries.insert(\n                name,\n                Box::new(Library {\n                    name,\n                    children: Vec::new(),\n                    num_parents,\n                }),\n            );\n        } else {\n            libraries.get_mut(name).unwrap().num_parents = num_parents;\n        }\n    }\n    libraries\n}\n\nfn topological_sort<'a>(\n    mut libraries: HashMap<&'a str, Box<Library<'a>>>,\n) -> Result<Vec<&'a str>, String> {\n    let mut needs_processing = libraries\n        .iter()\n        .map(|(k, _v)| k.clone())\n        .collect::<HashSet<&str>>();\n    let mut options: Vec<&str> = libraries\n        .iter()\n        .filter(|(_k, v)| v.num_parents == 0)\n        .map(|(k, _v)| *k)\n        .collect();\n    let mut sorted: Vec<&str> = Vec::new();\n    while !options.is_empty() {\n        let cur = options.pop().unwrap();\n        for children in libraries\n            .get_mut(cur)\n            .unwrap()\n            .children\n            .drain(0..)\n            .collect::<Vec<&str>>()\n        {\n            let child = libraries.get_mut(children).unwrap();\n            child.num_parents -= 1;\n            if child.num_parents == 0 {\n                options.push(child.name)\n            }\n        }\n        sorted.push(cur);\n        needs_processing.remove(cur);\n    }\n    match needs_processing.is_empty() {\n        true => Ok(sorted),\n        false => Err(format!(\"Cycle detected among {:?}\", needs_processing)),\n    }\n}\n\nfn main() {\n    let input: Vec<&str> = vec![\n        \"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\",\n        \"dw01             ieee dw01 dware gtech dw04\\n\",\n        \"dw02             ieee dw02 dware\\n\",\n        \"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\",\n        \"dw04             dw04 ieee dw01 dware gtech\\n\",\n        \"dw05             dw05 ieee dware\\n\",\n        \"dw06             dw06 ieee dware\\n\",\n        \"dw07             ieee dware\\n\",\n        \"dware            ieee dware\\n\",\n        \"gtech            ieee gtech\\n\",\n        \"ramlib           std ieee\\n\",\n        \"std_cell_lib     ieee std_cell_lib\\n\",\n        \"synopsys\\n\",\n    ];\n\n    let libraries = build_libraries(input);\n    match topological_sort(libraries) {\n        Ok(sorted) => println!(\"{:?}\", sorted),\n        Err(msg) => println!(\"{:?}\", msg),\n    }\n}\n\n\n[\"std\", \"synopsys\", \"ieee\", \"std_cell_lib\", \"ramlib\", \"gtech\", \"dware\", \"dw07\", \"dw06\", \"dw05\", \"dw02\", \"dw01\", \"dw04\", \"dw03\", \"des_system_lib\"]\n\n\n\"des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\\n\",\n        \"dw01             ieee dw01 dware gtech dw04\\n\",\n        \"dw02             ieee dw02 dware\\n\",\n        \"dw03             std synopsys dware dw03 dw02 dw01 ieee gtech\\n\",\n        \"dw04             dw04 ieee dw01 dware gtech\\n\",\n        \"dw05             dw05 ieee dware\\n\",\n        \"dw06             dw06 ieee dware\\n\",\n        \"dw07             ieee dware\\n\",\n        \"dware            ieee dware\\n\",\n        \"gtech            ieee gtech\\n\",\n        \"ramlib           std ieee\\n\",\n        \"std_cell_lib     ieee std_cell_lib\\n\",\n        \"synopsys\\n\",\n\n\"Cycle detected among {\\\"dw03\\\", \\\"des_system_lib\\\", \\\"dw04\\\", \\\"dw01\\\"}\"\n\n", "explain": "Output:\nOutput if we make dw01 depend on dw04 by changing input to\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Swift", "code": "\nTranslation of: Rust\nlet libs = [\n  (\"des_system_lib\", [\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"]),\n  (\"dw01\", [\"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw02\", [\"ieee\", \"dw02\", \"dware\"]),\n  (\"dw03\", [\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"]),\n  (\"dw04\", [\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"]),\n  (\"dw05\", [\"dw05\", \"ieee\", \"dware\"]),\n  (\"dw06\", [\"dw06\", \"ieee\", \"dware\"]),\n  (\"dw07\", [\"ieee\", \"dware\"]),\n  (\"dware\", [\"ieee\", \"dware\"]),\n  (\"gtech\", [\"ieee\", \"gtech\"]),\n  (\"ramlib\", [\"std\", \"ieee\"]),\n  (\"std_cell_lib\", [\"ieee\", \"std_cell_lib\"]),\n  (\"synopsys\", [])\n]\n\nstruct Library {\n  var name: String\n  var children: [String]\n  var numParents: Int\n}\n\nfunc buildLibraries(_ input: [(String, [String])]) -> [String: Library] {\n  var libraries = [String: Library]()\n\n  for (name, parents) in input {\n    var numParents = 0\n\n    for parent in parents where parent != name {\n      numParents += 1\n\n      libraries[parent, default: Library(name: parent, children: [], numParents: 0)].children.append(name)\n    }\n\n    libraries[name, default: Library(name: name, children: [], numParents: numParents)].numParents = numParents\n  }\n\n  return libraries\n}\n\nfunc topologicalSort(libs: [String: Library]) -> [String]? {\n  var libs = libs\n  var needsProcessing = Set(libs.keys)\n  var options = libs.compactMap({ $0.value.numParents == 0 ? $0.key : nil })\n  var sorted = [String]()\n\n  while let cur = options.popLast() {\n    for children in libs[cur]?.children ?? [] {\n      libs[children]?.numParents -= 1\n\n      if libs[children]?.numParents == 0 {\n        options.append(libs[children]!.name)\n      }\n    }\n\n    libs[cur]?.children.removeAll()\n\n    sorted.append(cur)\n    needsProcessing.remove(cur)\n  }\n\n  guard needsProcessing.isEmpty else {\n    return nil\n  }\n\n  return sorted\n}\n\nprint(topologicalSort(libs: buildLibraries(libs))!)\n\n\nOutput:\n[\"ieee\", \"std_cell_lib\", \"gtech\", \"dware\", \"dw07\", \"dw06\", \"dw05\", \"dw02\", \"dw01\", \"dw04\", \"std\", \"ramlib\", \"synopsys\", \"dw03\", \"des_system_lib\"]\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "R", "code": "\n\ndeps <- list(\n\"des_system_lib\" = c(\"std\", \"synopsys\", \"std_cell_lib\", \"des_system_lib\", \"dw02\", \"dw01\", \"ramlib\", \"ieee\"),\n\"dw01\" = c(\"ieee\", \"dw01\", \"dware\", \"gtech\", \"dw04\"),\n\"dw02\" = c(\"ieee\", \"dw02\", \"dware\"),\n\"dw03\" = c(\"std\", \"synopsys\", \"dware\", \"dw03\", \"dw02\", \"dw01\", \"ieee\", \"gtech\"),\n\"dw04\" = c(\"dw04\", \"ieee\", \"dw01\", \"dware\", \"gtech\"),\n\"dw05\" = c(\"dw05\", \"ieee\", \"dware\"),\n\"dw06\" = c(\"dw06\", \"ieee\", \"dware\"),\n\"dw07\" = c(\"ieee\", \"dware\"),\n\"dware\" = c(\"ieee\", \"dware\"),\n\"gtech\" = c(\"ieee\", \"gtech\"),\n\"ramlib\" = c(\"std\", \"ieee\"),\n\"std_cell_lib\" = c(\"ieee\", \"std_cell_lib\"),\n\"synopsys\" = c())\n\n\ntsort <- function(deps) {\n\tnm <- names(deps)\n\tlibs <- union(as.vector(unlist(deps)), nm)\n\t\n\ts <- c()\n\t# first libs that depend on nothing\n\tfor(x in libs) {\n\t\tif(!(x %in% nm)) {\n\t\t\ts <- c(s, x)\n\t\t}\n\t}\n\t\n\tk <- 1\n\twhile(k > 0) {\n\t\tk <- 0\n\t\tfor(x in setdiff(nm, s)) {\n\t\t\tr <- c(s, x)\n\t\t\tif(length(setdiff(deps[[x]], r)) == 0) {\n\t\t\t\ts <- r\n\t\t\t\tk <- 1\n\t\t\t}\n\t\t}\n\t}\n\t\n\tif(length(s) < length(libs)) {\n\t\tv <- setdiff(libs, s)\n\t\tstop(sprintf(\"Unorderable items\u00a0:\\n%s\", paste(\"\", v, sep=\"\", collapse=\"\\n\")))\n\t}\n\t\n\ts\n}\n\n\ntsort(deps)\n# [1] \"std\"            \"ieee\"           \"dware\"          \"gtech\"          \"ramlib\"        \n# [6] \"std_cell_lib\"   \"synopsys\"       \"dw01\"           \"dw02\"           \"dw03\"          \n#[11] \"dw04\"           \"dw05\"           \"dw06\"           \"dw07\"           \"des_system_lib\"\n\n\nUnorderable items :\ndes_system_lib\ndw01\ndw04\ndw03\n\n", "explain": "First make the list\nTopological sort function. It will throw an error if it cannot complete, printing the list of items which cannot be ordered.\nIf it succeeds, returns the list of items in topological order.\nOn the given example\u00a0:\nIf dw01 depends on dw04 as well\u00a0:\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Ada", "code": "\n\nwith Ada.Containers.Vectors; use Ada.Containers;\n\npackage Digraphs is\n\n   type Node_Idx_With_Null is new Natural;\n   subtype Node_Index is Node_Idx_With_Null range 1 .. Node_Idx_With_Null'Last;\n   -- a Node_Index is a number from 1, 2, 3, ... and the representative of a node\n\n   type Graph_Type is tagged private;\n\n   -- make sure Node is in Graph (possibly without connections)\n   procedure Add_Node\n     (Graph: in out Graph_Type'Class; Node: Node_Index);\n\n   -- insert an edge From->To into Graph; do nothing if already there\n   procedure Add_Connection\n     (Graph: in out Graph_Type'Class; From, To: Node_Index);\n\n   -- get the largest Node_Index used in any Add_Node or Add_Connection op.\n   -- iterate over all nodes of Graph: \"for I in 1 .. Graph.Node_Count loop ...\"\n   function Node_Count(Graph: Graph_Type) return Node_Idx_With_Null;\n\n   -- remove an edge From->To from Fraph; do nothing if not there\n   -- Graph.Node_Count is not changed\n   procedure Del_Connection\n     (Graph: in out Graph_Type'Class; From, To: Node_Index);\n\n   -- check if an edge From->to exists in Graph\n   function Connected\n     (Graph: Graph_Type; From, To: Node_Index) return Boolean;\n\n   -- data structure to store a list of nodes\n   package Node_Vec is new Vectors(Positive, Node_Index);\n\n   -- get a list of all nodes From->Somewhere in Graph\n   function All_Connections\n     (Graph: Graph_Type; From: Node_Index) return Node_Vec.Vector;\n\n   Graph_Is_Cyclic: exception;\n\n   -- a depth-first search to find a topological sorting of the nodes\n   -- raises Graph_Is_Cyclic if no topological sorting is possible\n   function Top_Sort\n     (Graph: Graph_Type) return Node_Vec.Vector;\n\nprivate\n\n   package Conn_Vec is new Vectors(Node_Index, Node_Vec.Vector, Node_Vec.\"=\");\n\n   type Graph_Type is new Conn_Vec.Vector with null record;\n\nend Digraphs;\n\n\npackage body Digraphs is\n\n   function Node_Count(Graph: Graph_Type) return Node_Idx_With_Null is\n   begin\n      return Node_Idx_With_Null(Graph.Length);\n   end Node_Count;\n\n   procedure Add_Node(Graph: in out Graph_Type'Class; Node: Node_Index) is\n   begin\n      for I in Node_Index range Graph.Node_Count+1 .. Node loop\n         Graph.Append(Node_Vec.Empty_Vector);\n      end loop;\n   end Add_Node;\n\n   procedure Add_Connection\n     (Graph: in out Graph_Type'Class; From, To: Node_Index) is\n   begin\n      Graph.Add_Node(Node_Index'Max(From, To));\n      declare\n         Connection_List: Node_Vec.Vector := Graph.Element(From);\n      begin\n         for I in Connection_List.First_Index .. Connection_List.Last_Index loop\n            if Connection_List.Element(I) >= To then\n               if Connection_List.Element(I) = To then\n                  return; -- if To is already there, don't add it a second time\n               else -- I is the first index with Element(I)>To, insert To here\n                  Connection_List.Insert(Before => I, New_Item => To);\n                  Graph.Replace_Element(From, Connection_List);\n                  return;\n               end if;\n            end if;\n         end loop;\n         -- there was  no I with no Element(I) > To, so insert To at the end\n         Connection_List.Append(To);\n         Graph.Replace_Element(From, Connection_List);\n         return;\n      end;\n   end Add_Connection;\n\n   procedure Del_Connection\n     (Graph: in out Graph_Type'Class; From, To: Node_Index) is\n      Connection_List: Node_Vec.Vector := Graph.Element(From);\n   begin\n      for I in Connection_List.First_Index .. Connection_List.Last_Index loop\n         if Connection_List.Element(I) = To then\n            Connection_List.Delete(I);\n            Graph.Replace_Element(From, Connection_List);\n            return; -- we are done\n         end if;\n      end loop;\n   end Del_Connection;\n\n   function Connected\n     (Graph: Graph_Type; From, To: Node_Index) return Boolean is\n      Connection_List: Node_Vec.Vector renames Graph.Element(From);\n   begin\n      for I in Connection_List.First_Index .. Connection_List.Last_Index loop\n         if Connection_List.Element(I) = To then\n            return True;\n         end if;\n      end loop;\n      return False;\n   end Connected;\n\n   function All_Connections\n     (Graph: Graph_Type; From: Node_Index) return Node_Vec.Vector is\n   begin\n      return Graph.Element(From);\n   end All_Connections;\n\n   function Top_Sort\n     (Graph: Graph_Type) return Node_Vec.Vector is\n\n      Result: Node_Vec.Vector;\n      Visited: array(1 .. Graph.Node_Count) of Boolean := (others => False);\n      Active:  array(1 .. Graph.Node_Count) of Boolean := (others => False);\n\n      procedure Visit(Node: Node_Index) is\n      begin\n         if not Visited(Node) then\n            Visited(Node) := True;\n            Active(Node)  := True;\n            declare\n               Cons: Node_Vec.Vector := All_Connections(Graph, Node);\n            begin\n               for Idx in Cons.First_Index .. Cons.Last_Index loop\n                  Visit(Cons.Element(Idx));\n               end loop;\n            end;\n            Active(Node) := False;\n            Result.Append(Node);\n         else\n            if Active(Node) then\n               raise Constraint_Error with \"Graph is Cyclic\";\n            end if;\n         end if;\n      end Visit;\n\n   begin\n      for Some_Node in Visited'Range loop\n         Visit(Some_Node);\n      end loop;\n      return Result;\n   end Top_Sort;\n\nend Digraphs;\n\n\nprivate with Ada.Containers.Indefinite_Vectors;\n\ngeneric\n   type Index_Type_With_Null is new Natural;\npackage Set_Of_Names is\n   subtype Index_Type is Index_Type_With_Null\n       range 1 .. Index_Type_With_Null'Last;\n   -- manage a set of strings;\n   -- each string in the set is assigned a unique index of type Index_Type\n\n   type Set is tagged private;\n\n   -- inserts Name into Names; do nothing if already there;\n   procedure Add(Names: in out Set; Name: String);\n\n   -- Same operation, additionally emiting Index=Names.Idx(Name)\n   procedure Add(Names: in out Set; Name: String; Index: out Index_Type);\n\n   -- remove Name from Names; do nothing if not found\n   -- the removal may change the index of other strings in Names\n   procedure Sub(Names: in out Set; Name: String);\n\n   -- returns the unique index of Name in Set; or 0 if Name is not there\n   function Idx(Names: Set; Name: String) return Index_Type_With_Null;\n\n   -- returns the unique name of Index;\n   function Name(Names: Set; Index: Index_Type) return String;\n\n   -- first index, last index and total number of names in set\n   -- to iterate over Names, use \"for I in Names.Start .. Names.Stop loop ...\n   function Start(Names: Set) return Index_Type;\n   function Stop(Names: Set) return Index_Type_With_Null;\n   function Size(Names: Set) return Index_Type_With_Null;\n\nprivate\n\n   package Vecs is new Ada.Containers.Indefinite_Vectors\n     (Index_Type => Index_Type, Element_Type => String);\n\n   type Set is new Vecs.Vector with null record;\n\nend Set_Of_Names;\n\n\npackage body Set_Of_Names is\n\n   use type Ada.Containers.Count_Type, Vecs.Cursor;\n\n   function Start(Names: Set) return Index_Type is\n   begin\n      if Names.Length = 0 then\n         return 1;\n      else\n         return Names.First_Index;\n      end if;\n   end Start;\n\n   function Stop(Names: Set) return Index_Type_With_Null is\n   begin\n      if Names.Length=0 then\n         return 0;\n      else\n         return Names.Last_Index;\n      end if;\n   end Stop;\n\n   function Size(Names: Set) return Index_Type_With_Null is\n   begin\n      return Index_Type_With_Null(Names.Length);\n   end Size;\n\n   procedure Add(Names: in out Set; Name: String; Index: out Index_Type) is\n      I: Index_Type_With_Null := Names.Idx(Name);\n   begin\n      if I = 0 then -- Name is not yet in Set\n         Names.Append(Name);\n         Index := Names.Stop;\n      else\n        Index := I;\n      end if;\n   end Add;\n\n   procedure Add(Names: in out Set; Name: String) is\n      I: Index_Type;\n   begin\n      Names.Add(Name, I);\n   end Add;\n\n   procedure Sub(Names: in out Set; Name: String) is\n      I: Index_Type_With_Null := Names.Idx(Name);\n   begin\n      if I /= 0 then -- Name is in set\n         Names.Delete(I);\n      end if;\n   end Sub;\n\n   function Idx(Names: Set; Name: String) return Index_Type_With_Null is\n   begin\n      for I in Names.First_Index .. Names.Last_Index loop\n         if Names.Element(I) = Name then\n            return I;\n         end if;\n      end loop;\n      return 0;\n   end Idx;\n\n   function Name(Names: Set; Index: Index_Type) return String is\n   begin\n      return Names.Element(Index);\n   end Name;\n\nend Set_Of_Names;\n\n\nwith Ada.Text_IO, Digraphs, Set_Of_Names, Ada.Command_Line;\n\nprocedure Toposort is\n\n   -- shortcuts for package names, intantiation of generic package\n   package TIO renames Ada.Text_IO;\n   package DG renames Digraphs;\n   package SN is new Set_Of_Names(DG.Node_Idx_With_Null);\n\n   -- reat the graph from the file with the given Filename\n   procedure Read(Filename: String; G: out DG.Graph_Type; N: out SN.Set) is\n\n      -- finds the first word in S(Start .. S'Last), delimited by spaces\n      procedure Find_Token(S: String; Start: Positive;\n                           First: out Positive; Last: out Natural) is\n\n      begin\n         First := Start;\n         while First <= S'Last and then S(First)= ' ' loop\n            First := First + 1;\n         end loop;\n         Last := First-1;\n         while Last < S'Last and then S(Last+1) /= ' ' loop\n            Last := Last + 1;\n         end loop;\n      end Find_Token;\n\n      File: TIO.File_Type;\n   begin\n      TIO.Open(File, TIO.In_File, Filename);\n      TIO.Skip_Line(File, 2);\n      -- the first two lines contain header and \"===...===\"\n      while not TIO.End_Of_File(File) loop\n         declare\n            Line: String := TIO.Get_Line(File);\n            First: Positive;\n            Last: Natural;\n            To, From: DG.Node_Index;\n         begin\n            Find_Token(Line, Line'First, First, Last);\n            if Last >= First then\n               N.Add(Line(First .. Last), From);\n               G.Add_Node(From);\n               loop\n                  Find_Token(Line, Last+1, First, Last);\n                  exit when Last < First;\n                     N.Add(Line(First .. Last), To);\n                     G.Add_Connection(From, To);\n                  end loop;\n            end if;\n         end;\n      end loop;\n      TIO.Close(File);\n   end Read;\n\n   Graph: DG.Graph_Type;\n   Names: SN.Set;\n\nbegin\n   Read(Ada.Command_Line.Argument(1), Graph, Names);\n\n   -- eliminat self-cycles\n   for Start in 1 .. Graph.Node_Count loop\n      Graph.Del_Connection(Start, Start);\n   end loop;\n\n   -- perform the topological sort and output the result\n   declare\n      Result:  DG.Node_Vec.Vector;\n   begin\n      Result := Graph.Top_Sort;\n      for Index in Result.First_Index .. Result.Last_Index loop\n         TIO.Put(Names.Name(Result.Element(Index)));\n         if Index < Result.Last_Index then\n            TIO.Put(\" -> \");\n         end if;\n      end loop;\n      TIO.New_Line;\n   exception\n      when DG.Graph_Is_Cyclic =>\n         TIO.Put_Line(\"There is no topological sorting -- the Graph is cyclic!\");\n   end;\nend Toposort;\n\n\nOutput:\n\nstd -> synopsys -> ieee -> std_cell_lib -> dware -> dw02 -> gtech -> dw01 -> ramlib ->  des_system_lib -> dw03 -> dw04 -> dw05 -> dw06 -> dw07\n\nThere is no topological sorting -- the Graph is cyclic!\n", "explain": "Digraphs: A package for directed graphs, representing nodes as positive numbers\nThe specification:\nThe implementation:\nSet_of_Names: Translating strings into numbers and vice versa\nThe specification:\nThe implementation\nToposort: Putting things together for the main program\nGiven the name of the file with the dependencies as the parameter, \nToposort generates the following output:\nIf the dependencies is circular, the the Toposort tells that:\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nTranslation of: Python\nfunction toposort(data::Dict{T,Set{T}}) where T\n    data = copy(data)\n    for (k, v) in data\n        delete!(v, k)\n    end\n    extraitems = setdiff(reduce(\u222a, values(data)), keys(data))\n    for item in extraitems\n        data[item] = Set{T}()\n    end\n    rst = Vector{T}()\n    while true\n        ordered = Set(item for (item, dep) in data if isempty(dep))\n        if isempty(ordered) break end\n        append!(rst, ordered)\n        data = Dict{T,Set{T}}(item => setdiff(dep, ordered) for (item, dep) in data if item \u2209 ordered)\n    end\n    @assert isempty(data) \"a cyclic dependency exists amongst $(keys(data))\"\n    return rst\nend\n\ndata = Dict{String,Set{String}}(\n    \"des_system_lib\" => Set(split(\"std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\")),\n    \"dw01\" =>           Set(split(\"ieee dw01 dware gtech\")),\n    \"dw02\" =>           Set(split(\"ieee dw02 dware\")),\n    \"dw03\" =>           Set(split(\"std synopsys dware dw03 dw02 dw01 ieee gtech\")),\n    \"dw04\" =>           Set(split(\"dw04 ieee dw01 dware gtech\")),\n    \"dw05\" =>           Set(split(\"dw05 ieee dware\")),\n    \"dw06\" =>           Set(split(\"dw06 ieee dware\")),\n    \"dw07\" =>           Set(split(\"ieee dware\")),\n    \"dware\" =>          Set(split(\"ieee dware\")),\n    \"gtech\" =>          Set(split(\"ieee gtech\")),\n    \"ramlib\" =>         Set(split(\"std ieee\")),\n    \"std_cell_lib\" =>   Set(split(\"ieee std_cell_lib\")),\n    \"synopsys\" =>       Set(),\n    )\n\nprintln(\"# Topologically sorted:\\n - \", join(toposort(data), \"\\n - \"))\n\n\nOutput:\n# Topologically sorted:\n - synopsys\n - ieee\n - std\n - ramlib\n - dware\n - gtech\n - std_cell_lib\n - dw07\n - dw05\n - dw02\n - dw01\n - dw06\n - des_system_lib\n - dw03\n - dw04\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.51\n\nval s = \"std, ieee, des_system_lib, dw01, dw02, dw03, dw04, dw05, \" +\n        \"dw06, dw07, dware, gtech, ramlib, std_cell_lib, synopsys\"\n\nval deps = mutableListOf(\n     2 to 0, 2 to 14, 2 to 13, 2 to 4, 2 to 3, 2 to 12, 2 to 1,\n     3 to 1, 3 to 10, 3 to 11,\n     4 to 1, 4 to 10,\n     5 to 0, 5 to 14, 5 to 10, 5 to 4, 5 to 3, 5 to 1, 5 to 11,\n     6 to 1, 6 to 3, 6 to 10, 6 to 11,\n     7 to 1, 7 to 10,\n     8 to 1, 8 to 10,\n     9 to 1, 9 to 10,\n     10 to 1,\n     11 to 1,\n     12 to 0, 12 to 1,\n     13 to 1\n)\n\nclass Graph(s: String, edges: List<Pair<Int,Int>>) {\n\n    val vertices = s.split(\", \")\n    val numVertices = vertices.size\n    val adjacency = List(numVertices) { BooleanArray(numVertices) }\n\n    init {\n        for (edge in edges) adjacency[edge.first][edge.second] = true\n    }\n\n    fun hasDependency(r: Int, todo: List<Int>): Boolean {\n        return todo.any { adjacency[r][it] }\n    }\n\n    fun topoSort(): List<String>? {\n        val result = mutableListOf<String>()\n        val todo = MutableList<Int>(numVertices) { it }\n        try {\n            outer@ while(!todo.isEmpty()) {\n                for ((i, r) in todo.withIndex()) {\n                    if (!hasDependency(r, todo)) {\n                        todo.removeAt(i)\n                        result.add(vertices[r])\n                        continue@outer\n                     }\n                }\n                throw Exception(\"Graph has cycles\")\n            }\n        }\n        catch (e: Exception) {\n            println(e)\n            return null\n        }\n        return result\n    }\n}\n\nfun main(args: Array<String>) {\n    val g = Graph(s, deps)\n    println(\"Topologically sorted order:\")\n    println(g.topoSort())\n    println()\n    // now insert 3 to 6 at index 10 of deps\n    deps.add(10, 3 to 6)\n    val g2 = Graph(s, deps)\n    println(\"Following the addition of dw04 to the dependencies of dw01:\")\n    println(g2.topoSort())\n}\n\n\nOutput:\nTopologically sorted order:\n[std, ieee, dware, dw02, dw05, dw06, dw07, gtech, dw01, dw04, ramlib, std_cell_lib, synopsys, des_system_lib, dw03]\n\nFollowing the addition of dw04 to the dependencies of dw01:\njava.lang.Exception: Graph has cycles\nnull\n\nTranslation of: Python\nThis version follows python implementation and returns List of Lists which is useful for parallel execution for example\n\nval graph = mapOf(\n    \"des_system_lib\" to \"std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\".split(\" \").toSet(),\n    \"dw01\" to \"ieee dw01 dware gtech\".split(\" \").toSet(),\n    \"dw02\" to \"ieee dw02 dware\".split(\" \").toSet(),\n    \"dw03\" to \"std synopsys dware dw03 dw02 dw01 ieee gtech\".split(\" \").toSet(),\n    \"dw04\" to \"dw04 ieee dw01 dware gtech\".split(\" \").toSet(),\n    \"dw05\" to \"dw05 ieee dware\".split(\" \").toSet(),\n    \"dw06\" to \"dw06 ieee dware\".split(\" \").toSet(),\n    \"dw07\" to \"ieee dware\".split(\" \").toSet(),\n    \"dware\" to \"ieee dware\".split(\" \").toSet(),\n    \"gtech\" to \"ieee gtech\".split(\" \").toSet(),\n    \"ramlib\" to \"std ieee\".split(\" \").toSet(),\n    \"std_cell_lib\" to \"ieee std_cell_lib\".split(\" \").toSet(),\n    \"synopsys\" to setOf()\n)\n\nfun toposort( graph: Map<String,Set<String>> ): List<List<String>> {\n    var data = graph.map { (k,v) -> k to v.toMutableSet() }.toMap().toMutableMap()\n\n    // ignore self dependancies\n    data = data.map { (k,v) -> v.remove(k); k to v }.toMap().toMutableMap()\n\n    val extraItemsInDeps = data.values.reduce { a,b -> a.union( b ).toMutableSet() } - data.keys.toSet()\n\n    data.putAll( extraItemsInDeps.map { it to mutableSetOf<String>() }.toMap() )\n\n    val res = mutableListOf<List<String>>()\n    mainloop@ while( true ) {\n        innerloop@ while( true ) {\n            val ordered = data.filter{ (_,v) -> v.isEmpty() }.map { (k,_) -> k }\n            if( ordered.isEmpty() )\n                break@innerloop\n\n            res.add( ordered )\n            data = data.filter { (k,_) -> !ordered.contains(k) }.map { (k,v) -> v.removeAll(ordered); k to v }.toMap().toMutableMap()\n        }\n\n        if( data.isNotEmpty() )\n            throw Exception( \"A cyclic dependency exists amongst: ${data.toList().joinToString { \",\" }}\" )\n        else\n            break@mainloop\n    }\n\n    return res\n}\n\n\nfun main( args: Array<String> ) {\n    val result = toposort( graph )\n    println( \"sorted dependencies:[\\n${result.joinToString( \",\\n\")}\\n]\" )\n}\n\n\nOutput:\nsorted dependencies:[\n[synopsys, std, ieee],\n[dware, gtech, ramlib, std_cell_lib],\n[dw01, dw02, dw05, dw06, dw07],\n[des_system_lib, dw03, dw04]\n]\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Perl", "code": "\n\nsub print_topo_sort {\n    my %deps = @_;\n\n    my %ba;\n    while ( my ( $before, $afters_aref ) = each %deps ) {\n        for my $after ( @{ $afters_aref } ) {\n            $ba{$before}{$after} = 1 if $before ne $after;\n            $ba{$after} ||= {};\n        }\n    }\n\n    while ( my @afters = sort grep { ! %{ $ba{$_} } } keys %ba ) {\n        print \"@afters\\n\";\n        delete @ba{@afters};\n        delete @{$_}{@afters} for values %ba;\n    }\n\n    print !!%ba ? \"Cycle found! \". join( ' ', sort keys %ba ). \"\\n\" : \"---\\n\";\n}\n\nmy %deps = (\n    des_system_lib => [qw( std synopsys std_cell_lib des_system_lib dw02\n                                                        dw01 ramlib ieee )],\n    dw01           => [qw( ieee dw01 dware gtech                         )],\n    dw02           => [qw( ieee dw02 dware                               )],\n    dw03           => [qw( std synopsys dware dw03 dw02 dw01 ieee gtech  )],\n    dw04           => [qw( dw04 ieee dw01 dware gtech                    )],\n    dw05           => [qw( dw05 ieee dware                               )],\n    dw06           => [qw( dw06 ieee dware                               )],\n    dw07           => [qw( ieee dware                                    )],\n    dware          => [qw( ieee dware                                    )],\n    gtech          => [qw( ieee gtech                                    )],\n    ramlib         => [qw( std ieee                                      )],\n    std_cell_lib   => [qw( ieee std_cell_lib                             )],\n    synopsys       => [qw(                                               )],\n);\nprint_topo_sort(%deps);\npush @{ $deps{'dw01'} }, 'dw04'; # Add unresolvable dependency\nprint_topo_sort(%deps);\n\nOutput:ieee std synopsys\ndware gtech ramlib std_cell_lib\ndw01 dw02 dw05 dw06 dw07\ndes_system_lib dw03 dw04\n---\nieee std synopsys\ndware gtech ramlib std_cell_lib\ndw02 dw05 dw06 dw07\nCycle found! des_system_lib dw01 dw03 dw04\n", "explain": "In July 2002, Topological Sort was the monthly Perl Golf course. The post-mortem contains many solutions. This code was adapted from the solution that scored 144.39.\nThe algorithm used allows the output to be clustered; libraries on the same line are all independent (given the building of any previous lines of libraries), and so could be built in parallel.\n"}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "D", "code": "\nTranslation of: Python\nimport std.stdio, std.string, std.algorithm, std.range;\n\nfinal class ArgumentException : Exception {\n    this(string text) pure nothrow @safe /*@nogc*/ {\n        super(text);\n    }\n}\n\nalias TDependencies = string[][string];\n\nstring[][] topoSort(TDependencies d) pure /*nothrow @safe*/ {\n    foreach (immutable k, v; d)\n        d[k] = v.sort().uniq.filter!(s => s != k).array;\n    foreach (immutable s; d.byValue.join.sort().uniq)\n        if (s !in d)\n            d[s] = [];\n\n    string[][] sorted;\n    while (true) {\n        string[] ordered;\n\n        foreach (immutable item, const dep; d)\n            if (dep.empty)\n                ordered ~= item;\n        if (!ordered.empty)\n            sorted ~= ordered.sort().release;\n        else\n            break;\n\n        TDependencies dd;\n        foreach (immutable item, const dep; d)\n            if (!ordered.canFind(item))\n                dd[item] = dep.dup.filter!(s => !ordered.canFind(s)).array;\n        d = dd;\n    }\n\n    //if (!d.empty)\n    if (d.length > 0)\n        throw new ArgumentException(format(\n            \"A cyclic dependency exists amongst:\\n%s\", d));\n\n    return sorted;\n}\n\nvoid main() {\n    immutable data =\n\"des_system_lib std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01           ieee dw01 dware gtech\ndw02           ieee dw02 dware\ndw03           std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04           dw04 ieee dw01 dware gtech\ndw05           dw05 ieee dware\ndw06           dw06 ieee dware\ndw07           ieee dware\ndware          ieee dware\ngtech          ieee gtech\nramlib         std ieee\nstd_cell_lib   ieee std_cell_lib\nsynopsys\";\n\n    TDependencies deps;\n    foreach (immutable line; data.splitLines)\n        deps[line.split[0]] = line.split[1 .. $];\n\n    auto depw = deps.dup;\n    foreach (immutable idx, const subOrder; depw.topoSort)\n        writefln(\"#%d\u00a0: %s\", idx + 1,  subOrder);\n\n    writeln;\n    depw = deps.dup;\n    depw[\"dw01\"] ~= \"dw04\";\n    foreach (const subOrder; depw.topoSort) // Should throw.\n        subOrder.writeln;\n}\n\n\nOutput:\n#1\u00a0: [\"ieee\", \"std\", \"synopsys\"]\n#2\u00a0: [\"dware\", \"gtech\", \"ramlib\", \"std_cell_lib\"]\n#3\u00a0: [\"dw01\", \"dw02\", \"dw05\", \"dw06\", \"dw07\"]\n#4\u00a0: [\"des_system_lib\", \"dw03\", \"dw04\"]\ntopo.ArgumentException@topo.d(7): A cyclic dependency exists amongst:\n[dw01:[dw04],des_system_lib:[dw01],dw03:[dw01],dw04:[dw01]]\n----------------\n...\\topo.d(71): _Dmain\n----------------\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Haskell", "code": "\nimport Data.List ((\\\\), elemIndex, intersect, nub)\nimport Data.Bifunctor (bimap, first)\n\ncombs 0 _ = [[]]\ncombs _ [] = []\ncombs k (x:xs) = ((x :) <$> combs (k - 1) xs) ++ combs k xs\n\ndepLibs :: [(String, String)]\ndepLibs =\n  [ ( \"des_system_lib\"\n    , \"std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\")\n  , (\"dw01\", \"ieee dw01 dware gtech\")\n  , (\"dw02\", \"ieee dw02 dware\")\n  , (\"dw03\", \"std synopsys dware dw03 dw02 dw01 ieee gtech\")\n  , (\"dw04\", \"dw04 ieee dw01 dware gtech\")\n  , (\"dw05\", \"dw05 ieee dware\")\n  , (\"dw06\", \"dw06 ieee dware\")\n  , (\"dw07\", \"ieee dware\")\n  , (\"dware\", \"ieee dware\")\n  , (\"gtech\", \"ieee gtech\")\n  , (\"ramlib\", \"std ieee\")\n  , (\"std_cell_lib\", \"ieee std_cell_lib\")\n  , (\"synopsys\", [])\n  ]\n\ntoposort :: [(String, String)] -> [String]\ntoposort xs\n  | (not . null) cycleDetect =\n    error $ \"Dependency cycle detected for libs \" ++ show cycleDetect\n  | otherwise = foldl makePrecede [] dB\n  where\n    dB = (\\(x, y) -> (x, y \\\\ x)) . bimap return words <$> xs\n    makePrecede ts ([x], xs) =\n      nub $\n      case elemIndex x ts of\n        Just i -> uncurry (++) $ first (++ xs) $ splitAt i ts\n        _ -> ts ++ xs ++ [x]\n    cycleDetect =\n      filter ((> 1) . length) $\n      (\\[(a, as), (b, bs)] -> (a `intersect` bs) ++ (b `intersect` as)) <$>\n      combs 2 dB\n\nmain :: IO ()\nmain = print $ toposort depLibs\n\n\nOutput:\n*Main> toposort depLibs\n[\"std\",\"synopsys\",\"ieee\",\"std_cell_lib\",\"dware\",\"dw02\",\"gtech\",\"dw01\",\"ramlib\",\"des_system_lib\",\"dw03\",\"dw04\",\"dw05\",\"dw06\",\"dw07\"]\n\n*Main> toposort $ (\\(xs,(k,ks):ys) -> xs++ (k,ks++\" dw04\"):ys) $ splitAt 1  depLibs\n*** Exception: Dependency cycle detected for libs [[\"dw01\",\"dw04\"]]\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "VBScript", "code": "\nImplementation[edit]\nclass topological\n\tdim dictDependencies\n\tdim dictReported\n\tdim depth\n\t\n\tsub class_initialize\n\t\tset dictDependencies = createobject(\"Scripting.Dictionary\")\n\t\tset dictReported = createobject(\"Scripting.Dictionary\")\n\t\tdepth = 0\n\tend sub\n\t\n\tsub reset\n\t\tdictReported.removeall\n\tend sub\n\t\n\tproperty let dependencies( s )\n\t\t'assuming token tab token-list newline\n\t\tdim i, j ,k\n\t\tdim aList\n\t\tdim dep\n\t\tdim a1\n\t\taList = Split( s, vbNewLine )\n\t\t'~ remove empty lines at end\n\t\tdo while aList( UBound( aList ) ) = vbnullstring\n\t\t\tredim preserve aList( UBound( aList ) - 1 )\n\t\tloop\n\n\t\tfor i = lbound( aList ) to ubound( aList )\n\t\t\taList( i ) = Split( aList( i ), vbTab, 2 )\n\t\t\ta1 = Split( aList( i )( 1 ), \" \" )\n\t\t\tk = 0\n\t\t\tfor j = lbound( a1) to ubound(a1)\n\t\t\t\tif a1(j) <> aList(i)(0) then\n\t\t\t\t\ta1(k) = a1(j)\n\t\t\t\t\tk = k + 1\n\t\t\t\tend if\n\t\t\tnext\n\t\t\tredim preserve a1(k-1)\n\t\t\taList(i)(1) = a1\n\t\tnext\n\t\tfor i = lbound( aList ) to ubound( aList )\n\t\t\tdep = aList(i)(0)\n\t\t\tif not dictDependencies.Exists( dep ) then\n\t\t\t\tdictDependencies.add dep, aList(i)(1)\n\t\t\tend if\n\t\tnext\n\t\t\n\tend property\n\t\n\tsub resolve( s )\n\t\tdim i \n\t\tdim deps\n\t\t'~ wscript.echo string(depth,\"!\"),s\n\t\tdepth = depth + 1\n\t\tif dictDependencies.Exists(s) then\n\t\t\tdeps = dictDependencies(s)\n\t\t\tfor i = lbound(deps) to ubound(deps)\n\t\t\t\tresolve deps(i)\n\t\t\tnext\n\t\tend if\n\t\tif not seen(s) then\n\t\t\twscript.echo s\n\t\t\tsee s\n\t\tend if\n\t\tdepth = depth - 1\n\tend sub\n\n\tfunction seen( key )\n\t\tseen = dictReported.Exists( key )\n\tend function\n\t\n\tsub see( key )\n\t\tdictReported.add key, \"\"\n\tend sub\n\t\n\tproperty get keys\n\t\tkeys = dictDependencies.keys\n\tend property\nend class\n\nInvocation[edit]\ndim toposort\nset toposort = new topological\ntoposort.dependencies = \"des_system_lib\tstd synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\" & vbNewLine & _\n\t\"dw01\tieee dw01 dware gtech\" & vbNewLine & _\n\t\"dw02\tieee dw02 dware\" & vbNewLine & _\n\t\"dw03\tstd synopsys dware dw03 dw02 dw01 ieee gtech\" & vbNewLine & _\n\t\"dw04\tdw04 ieee dw01 dware gtech\" & vbNewLine & _\n\t\"dw05\tdw05 ieee dware\" & vbNewLine & _\n\t\"dw06\tdw06 ieee dware\" & vbNewLine & _\n\t\"dw07\tieee dware\" & vbNewLine & _\n\t\"dware\tieee dware\" & vbNewLine & _\n\t\"gtech\tieee gtech\" & vbNewLine & _\n\t\"ramlib\tstd ieee\" & vbNewLine & _\n\t\"std_cell_lib\tieee std_cell_lib\" & vbNewLine & _\n\t\"synopsys\t\"\n\ndim k\nfor each k in toposort.keys\n\twscript.echo \"----- \" & k\n\ttoposort.resolve k\n\twscript.echo \"-----\"\n\ttoposort.reset\nnext\n\nOutput[edit]\n----- des_system_lib\nstd\nsynopsys\nieee\nstd_cell_lib\ndware\ndw02\ngtech\ndw01\nramlib\ndes_system_lib\n-----\n----- dw01\nieee\ndware\ngtech\ndw01\n-----\n----- dw02\nieee\ndware\ndw02\n-----\n----- dw03\nstd\nsynopsys\nieee\ndware\ndw02\ngtech\ndw01\ndw03\n-----\n----- dw04\nieee\ndware\ngtech\ndw01\ndw04\n-----\n----- dw05\nieee\ndware\ndw05\n-----\n----- dw06\nieee\ndware\ndw06\n-----\n----- dw07\nieee\ndware\ndw07\n-----\n----- dware\nieee\ndware\n-----\n----- gtech\nieee\ngtech\n-----\n----- ramlib\nstd\nieee\nramlib\n-----\n----- std_cell_lib\nieee\nstd_cell_lib\n-----\n----- synopsys\nsynopsys\n-----\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "Scheme", "code": "\nTranslation of: Python\n(import (chezscheme))\n(import (srfi srfi-1))\n\n\n(define (remove-self-dependency pair)\n  (let ((key (car pair))\n        (value (cdr pair)))\n    (cons key (remq key value))))w\n\n(define (remove-self-dependencies alist)\n  (map remove-self-dependency alist))\n\n(define (add-missing-items dependencies)\n  (let loop ((items (delete-duplicates (append-map cdr dependencies) eq?))\n             (out dependencies))\n    (if (null? items)\n        out\n        (let ((item (car items)))\n          (if (assq item out)\n              (loop (cdr items) out)\n              (loop (cdr items) (cons (cons item '()) out)))))))\n\n(define (lift dependencies batch)\n  (let loop ((dependencies dependencies)\n             (out '()))\n    (if (null? dependencies)\n        out\n        (let ((key (caar dependencies))\n              (value (cdar dependencies)))\n          (if (null? value)\n              (loop (cdr dependencies) out)\n              (loop (cdr dependencies)\n                    (cons (cons key (lset-difference eq? value batch))\n                          out)))))))\n\n(define (topological-sort dependencies)\n  (let* ((dependencies (remove-self-dependencies dependencies))\n         (dependencies (add-missing-items dependencies)))\n    (let loop ((out '())\n               (dependencies dependencies))\n      (if (null? dependencies)\n          (reverse out)\n          (let ((batch (map car (filter (lambda (pair) (null? (cdr pair))) dependencies))))\n            (if (null? batch)\n                #f\n                (loop (cons batch out) (lift dependencies batch))))))))\n\n\n(define example\n  '((des_system_lib . (std synopsys std_cell_lib des_system_lib dw02\n                           dw01 ramlib ieee))\n    (dw01           . (ieee dw01 dware gtech))\n    (dw02           . (ieee dw02 dware))\n    (dw03           . (std synopsys dware dw03 dw02 dw01 ieee gtech))\n    (dw04           . (dw04 ieee dw01 dware gtech))\n    (dw05           . (dw05 ieee dware))\n    (dw06           . (dw06 ieee dware))\n    (dw07           . (ieee dware))\n    (dware          . (ieee dware))\n    (gtech          . (ieee gtech))\n    (ramlib         . (std ieee))\n    (std_cell_lib   . (ieee std_cell_lib))\n    (synopsys       . ())))\n\n(write (topological-sort example))\n\n\n(define unsortable\n  '((des_system_lib . (std synopsys std_cell_lib des_system_lib dw02\n                           dw01 ramlib ieee))\n    (dw01           . (ieee dw01 dware gtech dw04))\n    (dw02           . (ieee dw02 dware))\n    (dw03           . (std synopsys dware dw03 dw02 dw01 ieee gtech))\n    (dw04           . (dw04 ieee dw01 dware gtech))\n    (dw05           . (dw05 ieee dware))\n    (dw06           . (dw06 ieee dware))\n    (dw07           . (ieee dware))\n    (dware          . (ieee dware))\n    (gtech          . (ieee gtech))\n    (ramlib         . (std ieee))\n    (std_cell_lib   . (ieee std_cell_lib))\n    (synopsys       . ())))\n\n(newline)\n(write (topological-sort unsortable))\n\n", "explain": ""}, {"task_name": "Topological sort", "task_url": "https://rosettacode.org/wiki/Topological_sort", "task_cat": "Sorting", "lang": "PowerShell", "code": "\n#Input Data\n$a=@\"\ndes_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee\ndw01             ieee dw01 dware gtech\ndw02             ieee dw02 dware\ndw03             std synopsys dware dw03 dw02 dw01 ieee gtech\ndw04             dw04 ieee dw01 dware gtech\ndw05             dw05 ieee dware\ndw06             dw06 ieee dware\ndw07             ieee dware\ndware            ieee dware\ngtech            ieee gtech\nramlib           std ieee\nstd_cell_lib     ieee std_cell_lib\nsynopsys         \n\"@\n#Convert to Object[]\n$c = switch ( $a.split([char] 10) ) { \n    $_ {\n        $b=$_.split(' ')\n        New-Object PSObject -Property @{\n            Library = $b[0]\n            \"Library Dependencies\" = @( $( $b[1..($b.length-1)] | Where-Object { $_ -match '\\w' } ) )\n        } \n    }\n}\n#Add pure dependencies\n$c | ForEach-Object {\n    $_.\"Library Dependencies\" | Where-Object {\n        $d=$_\n        $(:andl foreach($i in $c) {\n            if($d -match $i.Library) {\n                $false\n                break andl\n            }\n        }) -eq $null\n    } | ForEach-Object {\n        $c+=New-Object PSObject -Property @{\n            Library=$_\n            \"Library Dependencies\"=@()\n        }\n    }\n}\n#Associate with a dependency value\n##Initial Dependency Value\n$d = $c | Sort Library | Select-Object Library,\"Library Dependencies\",@{\n    Name=\"Dep Value\"\n    Expression={\n        1\n    }\n}\n##Modify Dependency Value, perform check for incorrect dependency\n##Dep Value is determined by a parent child relationship, if a library is a parent, all libraries dependant on it are children\nfor( $i=0; $i -lt $d.count; $i++ ) {\n    $errmsg=\"\"\n    foreach( $j in ( 0..( $d.count - 1 ) | Where-Object { $_ -ne $i } ) ) {\n        #Foreach other Child Library where this is a dependency, increase the Dep Value of the Child\n        if( $( :orl foreach( $k in $d[$j].\"Library Dependencies\" ) {\n            if( $k -match $d[$i].Library ) {\n                foreach( $n in $d[$i].\"Library Dependencies\" ) {\n                    if( $n -match $d[$j].Library ) {\n                        $errmsg=\"Error Cyclic Dependency {0}<->{1}\" -f $d[$i].Library, $d[$j].Library\n                        break\n                    }\n                }\n                $true\n                break orl\n            }\n        } ) ) {\n            #If the child has already been processed, increase the Dep Value of its children\n            if( $j -lt $i ) {\n                foreach( $l in ( 0..( $d.count - 1 ) | Where-Object { $_ -ne $j } ) ) {\n                    if( $( :orl2 foreach( $m in $d[$l].\"Library Dependencies\" ) {\n                        if( $m -match $d[$j].Library ) {\n                            $true\n                            break orl2\n                        }\n                    } ) ) {\n                        $d[$l].\"Dep Value\"+=$d[$i].\"Dep Value\"\n                    }\n                }\n            }\n            $d[$j].\"Dep Value\"+=$d[$i].\"Dep Value\"\n        }\n        if( $errmsg -ne \"\" ) {\n            $errmsg\n            $d=$null\n            break\n        }\n    }\n}\n#Sort and Display\nif( $d ) {\n    $d | Sort \"Dep Value\",Library | ForEach-Object { \n        \"{0,-14} LIBRARY DEPENDENCIES`n{1,-14} ====================\" -f \"LIBRARY\", \"=======\"\n    } {\n        \"{0,-14} $($_.\"Library Dependencies\")\" -f $_.Library\n    }\n}\n\n", "explain": ""}]