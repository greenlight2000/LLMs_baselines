[{"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Python", "code": "\nLibrary: NumPy\n\n#!/usr/bin/env python3\n\nimport numpy as np\n\ndef qr(A):\n    m, n = A.shape\n    Q = np.eye(m)\n    for i in range(n - (m == n)):\n        H = np.eye(m)\n        H[i:, i:] = make_householder(A[i:, i])\n        Q = np.dot(Q, H)\n        A = np.dot(H, A)\n    return Q, A\n\ndef make_householder(a):\n    v = a / (a[0] + np.copysign(np.linalg.norm(a), a[0]))\n    v[0] = 1\n    H = np.eye(a.shape[0])\n    H -= (2 / np.dot(v, v)) * np.dot(v[:, None], v[None, :])\n    return H\n\n# task 1: show qr decomp of wp example\na = np.array(((\n    (12, -51,   4),\n    ( 6, 167, -68),\n    (-4,  24, -41),\n)))\n\nq, r = qr(a)\nprint('q:\\n', q.round(6))\nprint('r:\\n', r.round(6))\n\n# task 2: use qr decomp for polynomial regression example\ndef polyfit(x, y, n):\n    return lsqr(x[:, None]**np.arange(n + 1), y.T)\n\ndef lsqr(a, b):\n    q, r = qr(a)\n    _, n = r.shape\n    return np.linalg.solve(r[:n, :], np.dot(q.T, b)[:n])\n\nx = np.array((0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10))\ny = np.array((1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321))\n\nprint('\\npolyfit:\\n', polyfit(x, y, 2))\n\n\nOutput:\nq:\n [[-0.857143  0.394286  0.331429]\n [-0.428571 -0.902857 -0.034286]\n [ 0.285714 -0.171429  0.942857]]\nr:\n [[ -14.  -21.   14.]\n [   0. -175.   70.]\n [   0.    0.  -35.]]\n\npolyfit:\n [ 1.  2.  3.]\n\n", "explain": "Numpy has a qr function but here is a reimplementation to show construction and use of the Householder reflections.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\ntypedef struct {\n\tint m, n;\n\tdouble ** v;\n} mat_t, *mat;\n\nmat matrix_new(int m, int n)\n{\n\tmat x = malloc(sizeof(mat_t));\n\tx->v = malloc(sizeof(double*) * m);\n\tx->v[0] = calloc(sizeof(double), m * n);\n\tfor (int i = 0; i < m; i++)\n\t\tx->v[i] = x->v[0] + n * i;\n\tx->m = m;\n\tx->n = n;\n\treturn x;\n}\n\nvoid matrix_delete(mat m)\n{\n\tfree(m->v[0]);\n\tfree(m->v);\n\tfree(m);\n}\n\nvoid matrix_transpose(mat m)\n{\n\tfor (int i = 0; i < m->m; i++) {\n\t\tfor (int j = 0; j < i; j++) {\n\t\t\tdouble t = m->v[i][j];\n\t\t\tm->v[i][j] = m->v[j][i];\n\t\t\tm->v[j][i] = t;\n\t\t}\n\t}\n}\n\nmat matrix_copy(int n, double a[][n], int m)\n{\n\tmat x = matrix_new(m, n);\n\tfor (int i = 0; i < m; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tx->v[i][j] = a[i][j];\n\treturn x;\n}\n\nmat matrix_mul(mat x, mat y)\n{\n\tif (x->n != y->m) return 0;\n\tmat r = matrix_new(x->m, y->n);\n\tfor (int i = 0; i < x->m; i++)\n\t\tfor (int j = 0; j < y->n; j++)\n\t\t\tfor (int k = 0; k < x->n; k++)\n\t\t\t\tr->v[i][j] += x->v[i][k] * y->v[k][j];\n\treturn r;\n}\n\nmat matrix_minor(mat x, int d)\n{\n\tmat m = matrix_new(x->m, x->n);\n\tfor (int i = 0; i < d; i++)\n\t\tm->v[i][i] = 1;\n\tfor (int i = d; i < x->m; i++)\n\t\tfor (int j = d; j < x->n; j++)\n\t\t\tm->v[i][j] = x->v[i][j];\n\treturn m;\n}\n\n/* c = a + b * s */\ndouble *vmadd(double a[], double b[], double s, double c[], int n)\n{\n\tfor (int i = 0; i < n; i++)\n\t\tc[i] = a[i] + s * b[i];\n\treturn c;\n}\n\n/* m = I - v v^T */\nmat vmul(double v[], int n)\n{\n\tmat x = matrix_new(n, n);\n\tfor (int i = 0; i < n; i++)\n\t\tfor (int j = 0; j < n; j++)\n\t\t\tx->v[i][j] = -2 *  v[i] * v[j];\n\tfor (int i = 0; i < n; i++)\n\t\tx->v[i][i] += 1;\n\n\treturn x;\n}\n\n/* ||x|| */\ndouble vnorm(double x[], int n)\n{\n\tdouble sum = 0;\n\tfor (int i = 0; i < n; i++) sum += x[i] * x[i];\n\treturn sqrt(sum);\n}\n\n/* y = x / d */\ndouble* vdiv(double x[], double d, double y[], int n)\n{\n\tfor (int i = 0; i < n; i++) y[i] = x[i] / d;\n\treturn y;\n}\n\n/* take c-th column of m, put in v */\ndouble* mcol(mat m, double *v, int c)\n{\n\tfor (int i = 0; i < m->m; i++)\n\t\tv[i] = m->v[i][c];\n\treturn v;\n}\n\nvoid matrix_show(mat m)\n{\n\tfor(int i = 0; i < m->m; i++) {\n\t\tfor (int j = 0; j < m->n; j++) {\n\t\t\tprintf(\" %8.3f\", m->v[i][j]);\n\t\t}\n\t\tprintf(\"\\n\");\n\t}\n\tprintf(\"\\n\");\n}\n\nvoid householder(mat m, mat *R, mat *Q)\n{\n\tmat q[m->m];\n\tmat z = m, z1;\n\tfor (int k = 0; k < m->n && k < m->m - 1; k++) {\n\t\tdouble e[m->m], x[m->m], a;\n\t\tz1 = matrix_minor(z, k);\n\t\tif (z != m) matrix_delete(z);\n\t\tz = z1;\n\n\t\tmcol(z, x, k);\n\t\ta = vnorm(x, m->m);\n\t\tif (m->v[k][k] > 0) a = -a;\n\n\t\tfor (int i = 0; i < m->m; i++)\n\t\t\te[i] = (i == k) ? 1 : 0;\n\n\t\tvmadd(x, e, a, e, m->m);\n\t\tvdiv(e, vnorm(e, m->m), e, m->m);\n\t\tq[k] = vmul(e, m->m);\n\t\tz1 = matrix_mul(q[k], z);\n\t\tif (z != m) matrix_delete(z);\n\t\tz = z1;\n\t}\n\tmatrix_delete(z);\n\t*Q = q[0];\n\t*R = matrix_mul(q[0], m);\n\tfor (int i = 1; i < m->n && i < m->m - 1; i++) {\n\t\tz1 = matrix_mul(q[i], *Q);\n\t\tif (i > 1) matrix_delete(*Q);\n\t\t*Q = z1;\n\t\tmatrix_delete(q[i]);\n\t}\n\tmatrix_delete(q[0]);\n\tz = matrix_mul(*Q, m);\n\tmatrix_delete(*R);\n\t*R = z;\n\tmatrix_transpose(*Q);\n}\n\ndouble in[][3] = {\n\t{ 12, -51,   4},\n\t{  6, 167, -68},\n\t{ -4,  24, -41},\n\t{ -1, 1, 0},\n\t{ 2, 0, 3},\n};\n\nint main()\n{\n\tmat R, Q;\n\tmat x = matrix_copy(3, in, 5);\n\thouseholder(x, &R, &Q);\n\n\tputs(\"Q\"); matrix_show(Q);\n\tputs(\"R\"); matrix_show(R);\n\n\t// to show their product is the input matrix\n\tmat m = matrix_mul(Q, R);\n\tputs(\"Q * R\"); matrix_show(m);\n\n\tmatrix_delete(x);\n\tmatrix_delete(R);\n\tmatrix_delete(Q);\n\tmatrix_delete(m);\n\treturn 0;\n}\n\n\nOutput:\nQ\n    0.846   -0.391    0.343    0.082    0.078\n    0.423    0.904   -0.029    0.026    0.045\n   -0.282    0.170    0.933   -0.047   -0.137\n   -0.071    0.014   -0.001    0.980   -0.184\n    0.141   -0.017   -0.106   -0.171   -0.969\n\nR\n   14.177   20.667  -13.402\n   -0.000  175.043  -70.080\n    0.000    0.000  -35.202\n   -0.000   -0.000   -0.000\n    0.000    0.000   -0.000\n\nQ * R\n   12.000  -51.000    4.000\n    6.000  167.000  -68.000\n   -4.000   24.000  -41.000\n   -1.000    1.000   -0.000\n    2.000   -0.000    3.000\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "C++", "code": "\n/*\n * g++ -O3 -Wall --std=c++11 qr_standalone.cpp -o qr_standalone\n */\n#include <cstdio>\n#include <cstdlib>\n#include <cstring> // for memset\n#include <limits>\n#include <iostream>\n#include <vector>\n\n#include <math.h>\n\nclass Vector;\n\nclass Matrix {\n\npublic:\n  // default constructor (don't allocate)\n  Matrix() : m(0), n(0), data(nullptr) {}\n  \n  // constructor with memory allocation, initialized to zero\n  Matrix(int m_, int n_) : Matrix() {\n    m = m_;\n    n = n_;\n    allocate(m_,n_);\n  }\n\n  // copy constructor\n  Matrix(const Matrix& mat) : Matrix(mat.m,mat.n) {\n\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++)\n\t(*this)(i,j) = mat(i,j);\n  }\n  \n  // constructor from array\n  template<int rows, int cols>\n  Matrix(double (&a)[rows][cols]) : Matrix(rows,cols) {\n\n    for (int i = 0; i < m; i++)\n      for (int j = 0; j < n; j++)\n\t(*this)(i,j) = a[i][j];\n  }\n\n  // destructor\n  ~Matrix() {\n    deallocate();\n  }\n\n\n  // access data operators\n  double& operator() (int i, int j) {\n    return data[i+m*j]; }\n  double  operator() (int i, int j) const {\n    return data[i+m*j]; }\n\n  // operator assignment\n  Matrix& operator=(const Matrix& source) {\n    \n    // self-assignment check\n    if (this != &source) { \n      if ( (m*n) != (source.m * source.n) ) { // storage cannot be reused\n\tallocate(source.m,source.n);          // re-allocate storage\n      }\n      // storage can be used, copy data\n      std::copy(source.data, source.data + source.m*source.n, data);\n    }\n    return *this;\n  }\n  \n  // compute minor\n  void compute_minor(const Matrix& mat, int d) {\n\n    allocate(mat.m, mat.n);\n    \n    for (int i = 0; i < d; i++)\n      (*this)(i,i) = 1.0;\n    for (int i = d; i < mat.m; i++)\n      for (int j = d; j < mat.n; j++)\n\t(*this)(i,j) = mat(i,j);\n    \n  }\n\n  // Matrix multiplication\n  // c = a * b\n  // c will be re-allocated here\n  void mult(const Matrix& a, const Matrix& b) {\n\n    if (a.n != b.m) {\n      std::cerr << \"Matrix multiplication not possible, sizes don't match\u00a0!\\n\";\n      return;\n    }\n\n    // reallocate ourself if necessary i.e. current Matrix has not valid sizes\n    if (a.m != m or b.n != n)\n      allocate(a.m, b.n);\n\n    memset(data,0,m*n*sizeof(double));\n    \n    for (int i = 0; i < a.m; i++)\n      for (int j = 0; j < b.n; j++)\n\tfor (int k = 0; k < a.n; k++)\n\t  (*this)(i,j) += a(i,k) * b(k,j);\n    \n  }\n\n  void transpose() {\n    for (int i = 0; i < m; i++) {\n      for (int j = 0; j < i; j++) {\n\tdouble t = (*this)(i,j);\n\t(*this)(i,j) = (*this)(j,i);\n\t(*this)(j,i) = t;\n      }\n    }\n  }\n\n  // take c-th column of m, put in v\n  void extract_column(Vector& v, int c);  \n\n  // memory allocation\n  void allocate(int m_, int n_) {\n\n    // if already allocated, memory is freed\n    deallocate();\n    \n    // new sizes\n    m = m_;\n    n = n_;\n    \n    data = new double[m_*n_];\n    memset(data,0,m_*n_*sizeof(double));\n\n  } // allocate\n\n  // memory free\n  void deallocate() {\n\n    if (data)\n      delete[] data;\n\n    data = nullptr;\n\n  }    \n  \n  int m, n;\n  \nprivate:\n  double* data;\n  \n}; // struct Matrix\n\n// column vector\nclass Vector {\n\npublic:\n  // default constructor (don't allocate)\n  Vector() : size(0), data(nullptr) {}\n  \n  // constructor with memory allocation, initialized to zero\n  Vector(int size_) : Vector() {\n    size = size_;\n    allocate(size_);\n  }\n\n  // destructor\n  ~Vector() {\n    deallocate();\n  }\n\n  // access data operators\n  double& operator() (int i) {\n    return data[i]; }\n  double  operator() (int i) const {\n    return data[i]; }\n\n  // operator assignment\n  Vector& operator=(const Vector& source) {\n    \n    // self-assignment check\n    if (this != &source) { \n      if ( size != (source.size) ) {   // storage cannot be reused\n\tallocate(source.size);         // re-allocate storage\n      }\n      // storage can be used, copy data\n      std::copy(source.data, source.data + source.size, data);\n    }\n    return *this;\n  }\n\n  // memory allocation\n  void allocate(int size_) {\n\n    deallocate();\n    \n    // new sizes\n    size = size_;\n    \n    data = new double[size_];\n    memset(data,0,size_*sizeof(double));\n\n  } // allocate\n\n  // memory free\n  void deallocate() {\n\n    if (data)\n      delete[] data;\n\n    data = nullptr;\n\n  }    \n\n  //   ||x||\n  double norm() {\n    double sum = 0;\n    for (int i = 0; i < size; i++) sum += (*this)(i) * (*this)(i);\n    return sqrt(sum);\n  }\n\n  // divide data by factor\n  void rescale(double factor) {\n    for (int i = 0; i < size; i++) (*this)(i) /= factor;\n  }\n\n  void rescale_unit() {\n    double factor = norm();\n    rescale(factor);\n  }\n  \n  int size;\n  \nprivate:\n  double* data;\n\n}; // class Vector\n\n// c = a + b * s\nvoid vmadd(const Vector& a, const Vector& b, double s, Vector& c)\n{\n  if (c.size != a.size or c.size != b.size) {\n    std::cerr << \"[vmadd]: vector sizes don't match\\n\";\n    return;\n  }\n  \n  for (int i = 0; i < c.size; i++)\n    c(i) = a(i) + s * b(i);\n}\n\n// mat = I - 2*v*v^T\n//\u00a0!!! m is allocated here\u00a0!!!\nvoid compute_householder_factor(Matrix& mat, const Vector& v)\n{\n\n  int n = v.size;\n  mat.allocate(n,n);\n  for (int i = 0; i < n; i++)\n    for (int j = 0; j < n; j++)\n      mat(i,j) = -2 *  v(i) * v(j);\n  for (int i = 0; i < n; i++)\n    mat(i,i) += 1;  \n}\n\n// take c-th column of a matrix, put results in Vector v\nvoid Matrix::extract_column(Vector& v, int c) {\n  if (m != v.size) {\n    std::cerr << \"[Matrix::extract_column]: Matrix and Vector sizes don't match\\n\";\n    return;\n  }\n  \n  for (int i = 0; i < m; i++)\n    v(i) = (*this)(i,c);\n}\n\nvoid matrix_show(const Matrix&  m, const std::string& str=\"\")\n{\n  std::cout << str << \"\\n\";\n  for(int i = 0; i < m.m; i++) {\n    for (int j = 0; j < m.n; j++) {\n      printf(\" %8.3f\", m(i,j));\n    }\n    printf(\"\\n\");\n  }\n  printf(\"\\n\");\n}\n\n// L2-norm ||A-B||^2\ndouble matrix_compare(const Matrix& A, const Matrix& B) {\n  // matrices must have same size\n  if (A.m != B.m or  A.n != B.n)\n    return std::numeric_limits<double>::max();\n\n  double res=0;\n  for(int i = 0; i < A.m; i++) {\n    for (int j = 0; j < A.n; j++) {\n      res += (A(i,j)-B(i,j)) * (A(i,j)-B(i,j));\n    }\n  }\n\n  res /= A.m*A.n;\n  return res;\n}\n\nvoid householder(Matrix& mat,\n\t\t Matrix& R,\n\t\t Matrix& Q)\n{\n\n  int m = mat.m;\n  int n = mat.n;\n\n  // array of factor Q1, Q2, ... Qm\n  std::vector<Matrix> qv(m);\n\n  // temp array\n  Matrix z(mat);\n  Matrix z1;\n  \n  for (int k = 0; k < n && k < m - 1; k++) {\n\n    Vector e(m), x(m);\n    double a;\n    \n    // compute minor\n    z1.compute_minor(z, k);\n    \n    // extract k-th column into x\n    z1.extract_column(x, k);\n    \n    a = x.norm();\n    if (mat(k,k) > 0) a = -a;\n    \n    for (int i = 0; i < e.size; i++)\n      e(i) = (i == k) ? 1 : 0;\n\n    // e = x + a*e\n    vmadd(x, e, a, e);\n\n    // e = e / ||e||\n    e.rescale_unit();\n    \n    // qv[k] = I - 2 *e*e^T\n    compute_householder_factor(qv[k], e);\n\n    // z = qv[k] * z1\n    z.mult(qv[k], z1);\n\n  }\n  \n  Q = qv[0];\n\n  // after this loop, we will obtain Q (up to a transpose operation)\n  for (int i = 1; i < n && i < m - 1; i++) {\n\n    z1.mult(qv[i], Q);\n    Q = z1;\n    \n  }\n  \n  R.mult(Q, mat);\n  Q.transpose();\n}\n \ndouble in[][3] = {\n  { 12, -51,   4},\n  {  6, 167, -68},\n  { -4,  24, -41},\n  { -1,   1,   0},\n  {  2,   0,   3},\n};\n \nint main()\n{\n  Matrix A(in); \n  Matrix Q, R;\n\n  matrix_show(A,\"A\");  \n\n  // compute QR decompostion\n  householder(A, R, Q);\n  \n  matrix_show(Q,\"Q\");\n  matrix_show(R,\"R\");\n \n  // compare Q*R to the original matrix A\n  Matrix A_check;\n  A_check.mult(Q, R);\n\n  // compute L2 norm ||A-A_check||^2\n  double l2 = matrix_compare(A,A_check);\n\n  // display Q*R\n  matrix_show(A_check, l2 < 1e-12 ? \"A == Q * R\u00a0? yes\" : \"A == Q * R\u00a0? no\");\n \n  return EXIT_SUCCESS;\n}\n\n\nOutput:\nA\n   12.000  -51.000    4.000\n    6.000  167.000  -68.000\n   -4.000   24.000  -41.000\n   -1.000    1.000    0.000\n    2.000    0.000    3.000\n\nQ\n    0.846   -0.391    0.343    0.082    0.078\n    0.423    0.904   -0.029    0.026    0.045\n   -0.282    0.170    0.933   -0.047   -0.137\n   -0.071    0.014   -0.001    0.980   -0.184\n    0.141   -0.017   -0.106   -0.171   -0.969\n\nR\n   14.177   20.667  -13.402\n   -0.000  175.043  -70.080\n    0.000    0.000  -35.202\n   -0.000   -0.000   -0.000\n    0.000    0.000   -0.000\n\nA == Q * R\u00a0? yes\n   12.000  -51.000    4.000\n    6.000  167.000  -68.000\n   -4.000   24.000  -41.000\n   -1.000    1.000   -0.000\n    2.000   -0.000    3.000\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Java", "code": "\nJAMA[edit]\n\nimport Jama.Matrix;\nimport Jama.QRDecomposition;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var matrix = new Matrix(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41},\n        });\n\n        var qr = new QRDecomposition(matrix);\n        qr.getQ().print(10, 4);\n        qr.getR().print(10, 4);\n    }\n}\n\n\nOutput:\n     -0.8571      0.3943     -0.3314\n     -0.4286     -0.9029      0.0343\n      0.2857     -0.1714     -0.9429\n\n\n    -14.0000    -21.0000     14.0000\n      0.0000   -175.0000     70.0000\n      0.0000      0.0000     35.0000\nColt[edit]\n\nimport cern.colt.matrix.impl.DenseDoubleMatrix2D;\nimport cern.colt.matrix.linalg.QRDecomposition;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var a = new DenseDoubleMatrix2D(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41}\n        });\n        var qr = new QRDecomposition(a);\n        System.out.println(qr.getQ());\n        System.out.println();\n        System.out.println(qr.getR());\n    }\n}\n\n\nOutput:\n3 x 3 matrix\n-0.857143  0.394286 -0.331429\n-0.428571 -0.902857  0.034286\n 0.285714 -0.171429 -0.942857\n\n3 x 3 matrix\n-14  -21 14\n  0 -175 70\n  0    0 35\nApache Commons Math[edit]\n\nimport java.util.Locale;\n\nimport org.apache.commons.math3.linear.Array2DRowRealMatrix;\nimport org.apache.commons.math3.linear.QRDecomposition;\nimport org.apache.commons.math3.linear.RealMatrix;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var a = new Array2DRowRealMatrix(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41}\n        });\n                                                         \n        var qr = new QRDecomposition(a);\n        print(qr.getQ());\n        System.out.println();\n        print(qr.getR());\n    }\n    \n    public static void print(RealMatrix a) {\n        for (double[] u: a.getData()) {\n            System.out.print(\"[ \");\n            for (double x: u) {\n                System.out.printf(Locale.ROOT, \"%10.4f \", x);\n            }\n            System.out.println(\"]\");\n        }\n    }\n}\n\n\nOutput:\n[    -0.8571     0.3943    -0.3314 ]\n[    -0.4286    -0.9029     0.0343 ]\n[     0.2857    -0.1714    -0.9429 ]\n\n[   -14.0000   -21.0000    14.0000 ]\n[     0.0000  -175.0000    70.0000 ]\n[     0.0000     0.0000    35.0000 ]\nla4j[edit]\n\nimport org.la4j.Matrix;\nimport org.la4j.decomposition.QRDecompositor;\n\npublic class Decompose {\n    public static void main(String[] args) {\n        var a = Matrix.from2DArray(new double[][] {\n            {12, -51,   4},\n            { 6, 167, -68},\n            {-4,  24, -41},\n        });\n        \n        Matrix[] qr = new QRDecompositor(a).decompose();\n        System.out.println(qr[0]);\n        System.out.println(qr[1]);\n    }\n}\n\n\nOutput:\n-0,857  0,394 -0,331\n-0,429 -0,903  0,034\n 0,286 -0,171 -0,943\n\n-14,000  -21,000 14,000\n  0,000 -175,000 70,000\n  0,000    0,000 35,000\n", "explain": "Using the JAMA library. Compile with: javac -cp Jama-1.0.3.jar Decompose.java.\nUsing the Colt library. Compile with: javac -cp colt.jar Decompose.java.\nUsing the Apache Commons Math library.\nCompile with: javac -cp commons-math3-3.6.1.jar Decompose.java.\nUsing the la4j library. Compile with: javac -cp la4j-0.6.0.jar Decompose.java.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "C#", "code": "\nLibrary: Math.Net\nusing System;\nusing MathNet.Numerics.LinearAlgebra;\nusing MathNet.Numerics.LinearAlgebra.Double;\n\n\nclass Program\n{\n\n    static void Main(string[] args)\n    {\n        Matrix<double> A = DenseMatrix.OfArray(new double[,]\n        {\n                {  12,  -51,    4 },\n                {   6,  167,  -68 },\n                {  -4,   24,  -41 }\n        });\n        Console.WriteLine(\"A:\");\n        Console.WriteLine(A);\n        var qr = A.QR();\n        Console.WriteLine();\n        Console.WriteLine(\"Q:\");\n        Console.WriteLine(qr.Q);\n        Console.WriteLine();\n        Console.WriteLine(\"R:\");\n        Console.WriteLine(qr.R);\n    }\n}\n\n\nOutput:\nA:\nDenseMatrix 3x3-Double\n12  -51    4\n 6  167  -68\n-4   24  -41\n\n\nQ:\nDenseMatrix 3x3-Double\n-0.857143   0.394286  -0.331429\n-0.428571  -0.902857  0.0342857\n 0.285714  -0.171429  -0.942857\n\n\nR:\nDenseMatrix 3x3-Double\n-14   -21  14\n  0  -175  70\n  0     0  35\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Fortran", "code": "\nLibrary: LAPACK\n\nprogram qrtask\n    implicit none\n    integer, parameter :: n = 4\n    real(8) :: durer(n, n) = reshape(dble([ &\n        16,  5,  9,  4, &\n         3, 10,  6, 15, &\n         2, 11,  7, 14, &\n        13,  8, 12,  1  &\n    ]), [n, n])\n    real(8) :: q(n, n), r(n, n), qr(n, n), id(n, n), tau(n)\n    integer, parameter :: lwork = 1024\n    real(8) :: work(lwork)\n    integer :: info, i, j\n \n    q = durer\n    call dgeqrf(n, n, q, n, tau, work, lwork, info)\n \n    r = 0d0\n    forall (i = 1:n, j = 1:n, j >= i) r(i, j) = q(i, j)\n \n    call dorgqr(n, n, n, q, n, tau, work, lwork, info)\n \n    qr = matmul(q, r)\n    id = matmul(q, transpose(q))\n \n    call show(4, durer, \"A\")\n    call show(4, q, \"Q\")\n    call show(4, r, \"R\")\n    call show(4, qr, \"Q*R\")\n    call show(4, id, \"Q*Q'\")\ncontains\n    subroutine show(n, a, s)\n        character(*) :: s\n        integer :: n, i\n        real(8) :: a(n, n)\n \n        print *, s\n        do i = 1, n\n            print 1, a(i, :)\n          1 format (*(f12.6,:,' '))\n        end do\n    end subroutine\nend program\n\n\nOutput:\n A\n   16.000000     3.000000     2.000000    13.000000\n    5.000000    10.000000    11.000000     8.000000\n    9.000000     6.000000     7.000000    12.000000\n    4.000000    15.000000    14.000000     1.000000\n Q\n   -0.822951     0.376971     0.361447    -0.223607\n   -0.257172    -0.454102    -0.526929    -0.670820\n   -0.462910    -0.060102    -0.576283     0.670820\n   -0.205738    -0.805029     0.509510     0.223607\n R\n  -19.442222   -10.904103   -10.595497   -18.516402\n    0.000000   -15.846152   -15.932298    -0.258437\n    0.000000     0.000000    -1.974168    -5.922505\n    0.000000     0.000000     0.000000    -0.000000\n Q*R\n   16.000000     3.000000     2.000000    13.000000\n    5.000000    10.000000    11.000000     8.000000\n    9.000000     6.000000     7.000000    12.000000\n    4.000000    15.000000    14.000000     1.000000\n Q*Q'\n    1.000000    -0.000000    -0.000000     0.000000\n   -0.000000     1.000000     0.000000     0.000000\n   -0.000000     0.000000     1.000000    -0.000000\n    0.000000     0.000000    -0.000000     1.000000\n", "explain": "See the documentation for the DGEQRF and DORGQR routines. Here the example matrix is the magic square from Albrecht D\u00fcrer's Melencolia I.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Go", "code": "\nMethod of task description, library go.matrix[edit]\nTranslation of: Common Lisp\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n\n    \"github.com/skelterjohn/go.matrix\"\n)\n\nfunc sign(s float64) float64 {\n    if s > 0 {\n        return 1\n    } else if s < 0 {\n        return -1\n    }\n    return 0\n}\n\nfunc unitVector(n int) *matrix.DenseMatrix {\n    vec := matrix.Zeros(n, 1)\n    vec.Set(0, 0, 1)\n    return vec\n}\n\nfunc householder(a *matrix.DenseMatrix) *matrix.DenseMatrix {\n    m := a.Rows()\n    s := sign(a.Get(0, 0))\n    e := unitVector(m)\n    u := matrix.Sum(a, matrix.Scaled(e, a.TwoNorm()*s))\n    v := matrix.Scaled(u, 1/u.Get(0, 0))\n    // (error checking skipped in this solution)\n    prod, _ := v.Transpose().TimesDense(v)\n    \u03b2 := 2 / prod.Get(0, 0)\n\n    prod, _ = v.TimesDense(v.Transpose())\n    return matrix.Difference(matrix.Eye(m), matrix.Scaled(prod, \u03b2))\n}\n\nfunc qr(a *matrix.DenseMatrix) (q, r *matrix.DenseMatrix) {\n    m := a.Rows()\n    n := a.Cols()\n    q = matrix.Eye(m)\n\n    last := n - 1\n    if m == n {\n        last--\n    }\n    for i := 0; i <= last; i++ {\n        // (copy is only for compatibility with an older version of gomatrix)\n        b := a.GetMatrix(i, i, m-i, n-i).Copy()\n        x := b.GetColVector(0)\n        h := matrix.Eye(m)\n        h.SetMatrix(i, i, householder(x))\n        q, _ = q.TimesDense(h)\n        a, _ = h.TimesDense(a)\n    }\n    return q, a\n}\n\nfunc main() {\n    // task 1: show qr decomp of wp example\n    a := matrix.MakeDenseMatrixStacked([][]float64{\n        {12, -51, 4},\n        {6, 167, -68},\n        {-4, 24, -41}})\n    q, r := qr(a)\n    fmt.Println(\"q:\\n\", q)\n    fmt.Println(\"r:\\n\", r)\n\n    // task 2: use qr decomp for polynomial regression example\n    x := matrix.MakeDenseMatrixStacked([][]float64{\n        {0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}})\n    y := matrix.MakeDenseMatrixStacked([][]float64{\n        {1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321}})\n    fmt.Println(\"\\npolyfit:\\n\", polyfit(x, y, 2))\n}\n\nfunc polyfit(x, y *matrix.DenseMatrix, n int) *matrix.DenseMatrix {\n    m := x.Cols()\n    a := matrix.Zeros(m, n+1)\n    for i := 0; i < m; i++ {\n        for j := 0; j <= n; j++ {\n            a.Set(i, j, math.Pow(x.Get(0, i), float64(j)))\n        }\n    }\n    return lsqr(a, y.Transpose())\n}\n\nfunc lsqr(a, b *matrix.DenseMatrix) *matrix.DenseMatrix {\n    q, r := qr(a)\n    n := r.Cols()\n    prod, _ := q.Transpose().TimesDense(b)\n    return solveUT(r.GetMatrix(0, 0, n, n), prod.GetMatrix(0, 0, n, 1))\n}\n\nfunc solveUT(r, b *matrix.DenseMatrix) *matrix.DenseMatrix {\n    n := r.Cols()\n    x := matrix.Zeros(n, 1)\n    for k := n - 1; k >= 0; k-- {\n        sum := 0.\n        for j := k + 1; j < n; j++ {\n            sum += r.Get(k, j) * x.Get(j, 0)\n        }\n        x.Set(k, 0, (b.Get(k, 0)-sum)/r.Get(k, k))\n    }\n    return x\n}\n\n\nq:\n {-0.857143,  0.394286,  0.331429,\n -0.428571, -0.902857, -0.034286,\n  0.285714, -0.171429,  0.942857}\nr:\n { -14,  -21,   14,\n    0, -175,   70,\n    0,    0,  -35}\n\npolyfit:\n {1,\n 2,\n 3}\n\nLibrary QR, gonum/matrix[edit]\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/gonum/matrix/mat64\"\n)\n\nfunc main() {\n    // task 1: show qr decomp of wp example\n    a := mat64.NewDense(3, 3, []float64{\n        12, -51, 4,\n        6, 167, -68,\n        -4, 24, -41,\n    })\n    var qr mat64.QR\n    qr.Factorize(a)\n    var q, r mat64.Dense\n    q.QFromQR(&qr)\n    r.RFromQR(&qr)\n    fmt.Printf(\"q:\u00a0%.3f\\n\\n\", mat64.Formatted(&q, mat64.Prefix(\"   \")))\n    fmt.Printf(\"r:\u00a0%.3f\\n\\n\", mat64.Formatted(&r, mat64.Prefix(\"   \")))\n\n    // task 2: use qr decomp for polynomial regression example\n    x := []float64{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n    y := []float64{1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321}\n    a = Vandermonde(x, 2)\n    b := mat64.NewDense(11, 1, y)\n    qr.Factorize(a)\n    var f mat64.Dense\n    f.SolveQR(&qr, false, b)\n    fmt.Printf(\"polyfit:\u00a0%.3f\\n\",\n        mat64.Formatted(&f, mat64.Prefix(\"         \")))\n}\n\nfunc Vandermonde(a []float64, degree int) *mat64.Dense {\n    x := mat64.NewDense(len(a), degree+1, nil)\n    for i := range a {\n        for j, p := 0, 1.; j <= degree; j, p = j+1, p*a[i] {\n            x.Set(i, j, p)\n        }\n    }\n    return x\n}\n\n\nOutput:\nq: \u23a1-0.857   0.394   0.331\u23a4\n   \u23a2-0.429  -0.903  -0.034\u23a5\n   \u23a3 0.286  -0.171   0.943\u23a6\n\nr: \u23a1 -14.000   -21.000    14.000\u23a4\n   \u23a2   0.000  -175.000    70.000\u23a5\n   \u23a3   0.000     0.000   -35.000\u23a6\n\npolyfit: \u23a11.000\u23a4\n         \u23a22.000\u23a5\n         \u23a33.000\u23a6\n\n", "explain": "A fairly close port of the Common Lisp solution, this solution uses the go.matrix library for supporting functions.  Note though, that go.matrix has QR decomposition, as shown in the Go solution to Polynomial regression.  The solution there is coded more directly than by following the CL example here.  Similarly, examination of the go.matrix QR source shows that it computes the decomposition more directly.\nOutput:\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "R", "code": "\n# R has QR decomposition built-in (using LAPACK or LINPACK)\n\na <- matrix(c(12, -51, 4, 6, 167, -68, -4, 24, -41), nrow=3, ncol=3, byrow=T)\nd <- qr(a)\nqr.Q(d)\nqr.R(d)\n\n# now fitting a polynomial\nx <- 0:10\ny <- 3*x^2 + 2*x + 1\n\n# using QR decomposition directly\na <- cbind(1, x, x^2)\nqr.coef(qr(a), y)\n\n# using least squares\na <- cbind(x, x^2)\nlsfit(a, y)$coefficients\n\n# using a linear model\nxx <- x*x\nm <- lm(y ~ x + xx)\ncoef(m)\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Ada", "code": "\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Numerics.Real_Arrays; use Ada.Numerics.Real_Arrays;\nwith Ada.Numerics.Generic_Elementary_Functions;\nprocedure QR is\n\n   procedure Show (mat : Real_Matrix) is\n      package FIO is new Ada.Text_IO.Float_IO (Float);\n   begin\n      for row in mat'Range (1) loop\n         for col in mat'Range (2) loop\n            FIO.Put (mat (row, col), Exp => 0, Aft => 4, Fore => 5);\n         end loop;\n         New_Line;\n      end loop;\n   end Show;\n\n   function GetCol (mat : Real_Matrix; n : Integer) return Real_Matrix is\n      column : Real_Matrix (mat'Range (1), 1 .. 1);\n   begin\n      for row in mat'Range (1) loop\n         column (row, 1) := mat (row, n);\n      end loop;\n      return column;\n   end GetCol;\n\n   function Mag (mat : Real_Matrix) return Float is\n      sum : Real_Matrix := Transpose (mat) * mat;\n      package Math is new Ada.Numerics.Generic_Elementary_Functions\n         (Float);\n   begin\n      return Math.Sqrt (sum (1, 1));\n   end Mag;\n\n   function eVect (col : Real_Matrix; n : Integer) return Real_Matrix is\n      vect : Real_Matrix (col'Range (1), 1 .. 1);\n   begin\n      for row in col'Range (1) loop\n         if row /= n then vect (row, 1) := 0.0;\n         else vect (row, 1) := 1.0; end if;\n      end loop;\n      return vect;\n   end eVect;\n\n   function Identity (n : Integer) return Real_Matrix is\n      mat : Real_Matrix (1 .. n, 1 .. n) := (1 .. n => (others => 0.0));\n   begin\n      for i in Integer range 1 .. n loop mat (i, i) := 1.0; end loop;\n      return mat;\n   end Identity;\n\n   function Chop (mat : Real_Matrix; n : Integer) return Real_Matrix is\n      small : Real_Matrix (n .. mat'Length (1), n .. mat'Length (2));\n   begin\n      for row in small'Range (1) loop\n         for col in small'Range (2) loop\n            small (row, col) := mat (row, col);\n         end loop;\n      end loop;\n      return small;\n   end Chop;\n\n   function H_n (inmat : Real_Matrix; n : Integer)\n      return Real_Matrix is\n      mat : Real_Matrix := Chop (inmat, n);\n      col : Real_Matrix := GetCol (mat, n);\n      colT : Real_Matrix (1 .. 1, mat'Range (1));\n      H : Real_Matrix := Identity (mat'Length (1));\n      Hall : Real_Matrix := Identity (inmat'Length (1));\n   begin\n      col := col - Mag (col) * eVect (col, n);\n      col := col / Mag (col);\n      colT := Transpose (col);\n      H := H - 2.0 * (col * colT);\n      for row in H'Range (1) loop\n         for col in H'Range (2) loop\n            Hall (n - 1 + row, n - 1 + col) := H (row, col);\n         end loop;\n      end loop;\n      return Hall;\n   end H_n;\n\n   A : constant Real_Matrix (1 .. 3, 1 .. 3) := (\n      (12.0, -51.0, 4.0),\n      (6.0, 167.0, -68.0),\n      (-4.0, 24.0, -41.0));\n   Q1, Q2, Q3, Q, R: Real_Matrix (1 .. 3, 1 .. 3);\nbegin\n   Q1 := H_n (A, 1);\n   Q2 := H_n (Q1 * A, 2);\n   Q3 := H_n (Q2 * Q1* A, 3);\n   Q := Transpose (Q1) * Transpose (Q2) * TransPose(Q3);\n   R := Q3 * Q2 * Q1 * A;\n   Put_Line (\"Q:\"); Show (Q);\n   Put_Line (\"R:\"); Show (R);\nend QR;\n\n\nOutput:\nQ:\n    0.8571   -0.3943   -0.3314\n    0.4286    0.9029    0.0343\n   -0.2857    0.1714   -0.9429\nR:\n   14.0000   21.0000  -14.0000\n   -0.0000  175.0000  -70.0000\n   -0.0000    0.0000   35.0000\n", "explain": "Output matches that of Matlab solution, not tested with other matrices.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Julia", "code": "\n\nQ, R = qr([12 -51 4; 6 167 -68; -4 24 -41])\n\n\nOutput:\n(\n3x3 Array{Float64,2}:\n -0.857143   0.394286   0.331429 \n -0.428571  -0.902857  -0.0342857\n  0.285714  -0.171429   0.942857 ,\n\n3x3 Array{Float64,2}:\n -14.0   -21.0   14.0\n   0.0  -175.0   70.0\n   0.0     0.0  -35.0)\n\n", "explain": "Built-in function\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "SAS", "code": "\n/* See http://support.sas.com/documentation/cdl/en/imlug/63541/HTML/default/viewer.htm#imlug_langref_sect229.htm */\n\nproc iml;\na={12 -51 4,6 167 -68,-4 24 -41};\nprint(a);\ncall qr(q,r,p,d,a);\nprint(q);\nprint(r);\nquit;\n\n/*\n                  a\n\n           12       -51         4\n            6       167       -68\n           -4        24       -41\n\n\n                  q\n\n    -0.857143 0.3942857 -0.331429\n    -0.428571 -0.902857 0.0342857\n    0.2857143 -0.171429 -0.942857\n\n\n                  r\n\n          -14       -21        14\n            0      -175        70\n            0         0        35\n*/\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Perl", "code": "\n\nuse strict;\nuse warnings;\n\nuse PDL;\nuse PDL::LinearAlgebra qw(mqr);\n\nmy $a = pdl(\n      [12, -51,   4],\n      [ 6, 167, -68],\n      [-4,  24, -41],\n      [-1,   1,   0],\n      [ 2,   0,   3]\n);\n\nmy ($q, $r) = mqr($a);\nprint $q, $r, $q x $r;\n\n\nOutput:\n[\n [ -0.84641474   0.39129081  -0.34312406]\n [ -0.42320737  -0.90408727  0.029270162]\n [  0.28213825  -0.17042055  -0.93285599]\n [ 0.070534562 -0.014040652  0.001099372]\n [ -0.14106912  0.016655511   0.10577161]\n]\n\n[\n [-14.177447 -20.666627  13.401567]\n [         0 -175.04254  70.080307]\n [         0          0  35.201543]\n]\n\n[\n [           12           -51             4]\n [            6           167           -68]\n [           -4            24           -41]\n [           -1             1             0]\n [            2             0             3]\n]\n", "explain": "Letting the PDL module do all the work.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Scala", "code": "\n\nOutput:Best seen running in your browser Scastie (remote JVM).\nimport java.io.{PrintWriter, StringWriter}\n\nimport Jama.{Matrix, QRDecomposition}\n\nobject QRDecomposition extends App {\n  val matrix =\n    new Matrix(\n      Array[Array[Double]](Array(12, -51, 4),\n        Array(6, 167, -68),\n        Array(-4, 24, -41)))\n  val d = new QRDecomposition(matrix)\n\n  def toString(m: Matrix): String = {\n    val sw = new StringWriter\n    m.print(new PrintWriter(sw, true), 8, 6)\n    sw.toString\n  }\n\n  print(toString(d.getQ))\n  print(toString(d.getR))\n\n}\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "D", "code": "\nTranslation of: Common Lisp\n\nimport std.stdio, std.math, std.algorithm, std.traits,\n       std.typecons, std.numeric, std.range, std.conv;\n\ntemplate elementwiseMat(string op) {\n    T[][] elementwiseMat(T)(in T[][] A, in T B) pure nothrow {\n        if (A.empty)\n            return null;\n        auto R = new typeof(return)(A.length, A[0].length);\n        foreach (immutable r, const row; A)\n            R[r][] = mixin(\"row[] \" ~ op ~ \"B\");\n        return R;\n    }\n\n    T[][] elementwiseMat(T, U)(in T[][] A, in U[][] B)\n    pure nothrow if (is(Unqual!T == Unqual!U)) {\n        assert(A.length == B.length);\n        if (A.empty)\n            return null;\n        auto R = new typeof(return)(A.length, A[0].length);\n        foreach (immutable r, const row; A) {\n            assert(row.length == B[r].length);\n            R[r][] = mixin(\"row[] \" ~ op ~ \"B[r][]\");\n        }\n        return R;\n    }\n}\n\nalias mSum = elementwiseMat!q{ + },\n      mSub = elementwiseMat!q{ - },\n      pMul = elementwiseMat!q{ * },\n      pDiv = elementwiseMat!q{ / };\n\nbool isRectangular(T)(in T[][] mat) pure nothrow {\n    return mat.all!(r => r.length == mat[0].length);\n}\n\nT[][] matMul(T)(in T[][] a, in T[][] b) pure nothrow\nin {\n    assert(a.isRectangular && b.isRectangular &&\n           a[0].length == b.length);\n} body {\n    auto result = new T[][](a.length, b[0].length);\n    auto aux = new T[b.length];\n    foreach (immutable j; 0 .. b[0].length) {\n        foreach (immutable k; 0 .. b.length)\n            aux[k] = b[k][j];\n        foreach (immutable i; 0 .. a.length)\n            result[i][j] = a[i].dotProduct(aux);\n    }\n    return result;\n}\n\nUnqual!T[][] transpose(T)(in T[][] m) pure nothrow {\n    auto r = new Unqual!T[][](m[0].length, m.length);\n    foreach (immutable nr, row; m)\n        foreach (immutable nc, immutable c; row)\n            r[nc][nr] = c;\n    return r;\n}\n\nT norm(T)(in T[][] m) pure nothrow {\n    return transversal(m, 0).map!q{ a ^^ 2 }.sum.sqrt;\n}\n\nUnqual!T[][] makeUnitVector(T)(in size_t dim) pure nothrow {\n    auto result = new Unqual!T[][](dim, 1);\n    foreach (row; result)\n        row[] = 0;\n    result[0][0] = 1;\n    return result;\n}\n\n/// Return a nxn identity matrix.\nUnqual!T[][] matId(T)(in size_t n) pure nothrow {\n    auto Id = new Unqual!T[][](n, n);\n    foreach (immutable r, row; Id) {\n        row[] = 0;\n        row[r] = 1;\n    }\n    return Id;\n}\n\nT[][] slice2D(T)(in T[][] A,\n                 in size_t ma, in size_t mb,\n                 in size_t na, in size_t nb) pure nothrow {\n    auto B = new T[][](mb - ma + 1, nb - na + 1);\n    foreach (immutable i, brow; B)\n        brow[] = A[ma + i][na .. na + brow.length];\n    return B;\n}\n\nsize_t rows(T)(in T[][] A) pure nothrow { return A.length; }\n\nsize_t cols(T)(in T[][] A) pure nothrow {\n    return A.length ? A[0].length : 0;\n}\n\nT[][] mcol(T)(in T[][] A, in size_t n) pure nothrow {\n    return slice2D(A, 0, A.rows - 1, n, n);\n}\n\nT[][] matEmbed(T)(in T[][] A, in T[][] B,\n                  in size_t row, in size_t col) pure nothrow {\n    auto C = new T[][](rows(A), cols(A));\n    foreach (immutable i, const arow; A)\n        C[i][] = arow[]; // Some wasted copies.\n    foreach (immutable i, const brow; B)\n        C[row + i][col .. col + brow.length] = brow[];\n    return C;\n}\n\n// Main routines ---------------\n\nT[][] makeHouseholder(T)(in T[][] a) {\n    immutable m = a.rows;\n    immutable T s = a[0][0].sgn;\n    immutable e = makeUnitVector!T(m);\n    immutable u = mSum(a, pMul(e, a.norm * s));\n    immutable v = pDiv(u, u[0][0]);\n    immutable beta = 2.0 / v.transpose.matMul(v)[0][0];\n    return mSub(matId!T(m), pMul(v.matMul(v.transpose), beta));\n}\n\nTuple!(T[][],\"Q\", T[][],\"R\") QRdecomposition(T)(T[][] A) {\n    immutable m = A.rows;\n    immutable n = A.cols;\n    auto Q = matId!T(m);\n\n    // Work on n columns of A.\n    foreach (immutable i; 0 .. (m == n ? n - 1 : n)) {\n        // Select the i-th submatrix. For i=0 this means the original\n        // matrix A.\n        immutable B = slice2D(A, i, m - 1, i, n - 1);\n\n        // Take the first column of the current submatrix B.\n        immutable x = mcol(B, 0);\n\n        // Create the Householder matrix for the column and embed it\n        // into an mxm identity.\n        immutable H = matEmbed(matId!T(m), x.makeHouseholder, i, i);\n\n        // The product of all H matrices from the right hand side is\n        // the orthogonal matrix Q.\n        Q = Q.matMul(H);\n\n        // The product of all H matrices with A from the LHS is the\n        // upper triangular matrix R.\n        A  = H.matMul(A);\n    }\n\n    // Return Q and R.\n    return typeof(return)(Q, A);\n}\n\n// Polynomial regression ---------------\n\n/// Solve an upper triangular system by back substitution.\nT[][] solveUpperTriangular(T)(in T[][] R, in T[][] b) pure nothrow {\n    immutable n = R.cols;\n    auto x = new T[][](n, 1);\n\n    foreach_reverse (immutable k; 0 .. n) {\n        T tot = 0;\n        foreach (immutable j; k + 1 .. n)\n            tot += R[k][j] * x[j][0];\n        x[k][0] = (b[k][0] - tot) / R[k][k];\n    }\n\n    return x;\n}\n\n/// Solve a linear least squares problem by QR decomposition.\nT[][] lsqr(T)(T[][] A, in T[][] b) pure nothrow {\n    const qr = A.QRdecomposition;\n    immutable n = qr.R.cols;\n    return solveUpperTriangular(\n        slice2D(qr.R, 0, n - 1, 0, n - 1),\n        slice2D(qr.Q.transpose.matMul(b), 0, n - 1, 0, 0));\n}\n\nT[][] polyFit(T)(in T[][] x, in T[][] y, in size_t n) pure nothrow {\n    immutable size_t m = x.cols;\n    auto A = new T[][](m, n + 1);\n    foreach (immutable i, row; A)\n        foreach (immutable j, ref item; row)\n            item = x[0][i] ^^ j;\n    return lsqr(A, y.transpose);\n}\n\nvoid main() {\n    // immutable (Q, R) = QRdecomposition([[12.0, -51,   4],\n    immutable qr = QRdecomposition([[12.0, -51,   4],\n                                    [ 6.0, 167, -68],\n                                    [-4.0,  24, -41]]);\n    immutable form = \"[%([%(%2.3f,\u00a0%)]%|,\\n\u00a0%)]\\n\";\n    writefln(form, qr.Q);\n    writefln(form, qr.R);\n\n    immutable x = [[0.0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10]];\n    immutable y = [[1.0, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321]];\n    polyFit(x, y, 2).writeln;\n}\n\n\nOutput:\n[[-0.857, 0.394, 0.331],\n [-0.429, -0.903, -0.034],\n [0.286, -0.171, 0.943]]\n\n[[-14.000, -21.000, 14.000],\n [0.000, -175.000, 70.000],\n [0.000, -0.000, -35.000]]\n\n[[1], [2], [3]]\n", "explain": "Uses the functions copied from Element-wise_operations, Matrix multiplication, and Matrix transposition.\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "Haskell", "code": "\n\nimport Data.List\nimport Text.Printf (printf)\n\neps = 1e-6 :: Double\n\n-- a matrix is represented as a list of columns\nmmult :: Num a => [[a]] -> [[a]] -> [[a]] \nnth :: Num a => [[a]] -> Int -> Int -> a\nmmult_num :: Num a => [[a]] -> a -> [[a]]\nmadd :: Num a => [[a]] -> [[a]] -> [[a]]\nidMatrix :: Num a => Int -> Int -> [[a]]\n\nadjustWithE :: [[Double]] -> Int -> [[Double]]\n\nmmult a b = [ [ sum $ zipWith (*) ak bj | ak <- (transpose a) ] | bj <- b ]\nnth mA i j = (mA !! j) !! i\nmmult_num mA n = map (\\c -> map (*n) c) mA\nmadd mA mB = zipWith (\\c1 c2 -> zipWith (+) c1 c2) mA mB\nidMatrix n m = [ [if (i==j) then 1 else 0 | i <- [1..n]] | j <- [1..m]]\n\nadjustWithE mA n = let lA = length mA in\n    (idMatrix n (n - lA)) ++ (map (\\c -> (take (n - lA) (repeat 0.0)) ++ c ) mA)\n\n-- auxiliary functions\nsqsum :: Floating a => [a] -> a\nnorm :: Floating a => [a] -> a\nepsilonize :: [[Double]] -> [[Double]]\n\nsqsum a = foldl (\\x y -> x + y*y) 0 a\nnorm a = sqrt $! sqsum a\nepsilonize mA = map (\\c -> map (\\x -> if abs x <= eps then 0 else x) c) mA\n\n-- Householder transformation; householder A = (Q, R)\nuTransform :: [Double] -> [Double]\nhMatrix :: [Double] -> Int -> Int -> [[Double]]\nhouseholder :: [[Double]] -> ([[Double]], [[Double]])\n\n-- householder_rec Q R A\nhouseholder_rec :: [[Double]] -> [[Double]] -> Int -> ([[Double]], [[Double]])\n\nuTransform a = let t = (head a) + (signum (head a))*(norm a) in\n    1 : map (\\x -> x/t) (tail a)\n\nhMatrix a n i = let u = uTransform (drop i a) in\n    madd\n        (idMatrix (n-i) (n-i))\n        (mmult_num\n            (mmult [u] (transpose [u]))\n            ((/) (-2) (sqsum u)))\n\nhouseholder_rec mQ mR 0 = (mQ, mR)\nhouseholder_rec mQ mR n = let mSize = length mR in\n    let mH = adjustWithE (hMatrix (mR!!(mSize - n)) mSize (mSize - n)) mSize in\n        householder_rec (mmult mQ mH) (mmult mH mR) (n - 1)\n\nhouseholder mA = let mSize = length mA in\n    let (mQ, mR) = householder_rec (idMatrix mSize mSize) mA mSize in\n        (epsilonize mQ, epsilonize mR)\n\nbackSubstitution :: [[Double]] -> [Double] -> [Double] -> [Double]\nbackSubstitution mR [] res = res\nbackSubstitution mR@(hR:tR) q@(h:t) res =\n    let x = (h / (head hR)) in\n        backSubstitution\n            (map tail tR)\n            (tail (zipWith (-) q (map (*x) hR)))\n            (x : res)\n\nshowMatrix :: [[Double]] -> String\nshowMatrix mA =\n    concat $ intersperse \"\\n\"\n        (map (\\x -> unwords $ printf \"%10.4f\" <$> (x::[Double])) (transpose mA))\n\nmY = [[12, 6, -4], [-51, 167, 24], [4, -68, -41]] :: [[Double]]\nq = [21, 245, 35] :: [Double]\nmain = let (mQ, mR) = householder mY in\n    putStrLn (\"Q: \\n\" ++ showMatrix mQ) >>\n    putStrLn (\"R: \\n\" ++ showMatrix mR) >>\n    putStrLn (\"q: \\n\" ++ show q) >>\n    putStrLn (\"x: \\n\" ++ show (backSubstitution (reverse (map reverse mR)) (reverse q) []))\n\n\nOutput:\nQ: \n   -0.8571     0.3943    -0.3314\n   -0.4286    -0.9029     0.0343\n    0.2857    -0.1714    -0.9429\nR: \n  -14.0000   -21.0000    14.0000\n    0.0000  -175.0000    70.0000\n    0.0000     0.0000    35.0000\nq: \n[21.0,245.0,35.0]\nx: \n[1.0000000000000004,-0.9999999999999999,1.0]\n\nQR decomposition with Numeric.LinearAlgebra[edit]\nimport Numeric.LinearAlgebra\n\na :: Matrix R\na = (3><3) \n  [ 12, -51,   4\n  ,  6, 167, -68\n  , -4,  24, -41]\n\nmain = do\n  print $ qr a\n\n\nOutput:\n((3><3)\n [ -0.8571428571428572,   0.3942857142857143,   0.33142857142857146\n , -0.4285714285714286,  -0.9028571428571428, -3.428571428571427e-2\n , 0.28571428571428575, -0.17142857142857137,    0.9428571428571428 ],(3><3)\n [ -14.0,               -21.0, 14.000000000000002\n ,   0.0, -175.00000000000003,  70.00000000000001\n ,   0.0, \n\n", "explain": "Square matrices only; decompose A and solve Rx = q by back substitution\n"}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "PowerShell", "code": "\nfunction qr([double[][]]$A) {\n    $m,$n = $A.count, $A[0].count\n    $pm,$pn = ($m-1), ($n-1)\n    [double[][]]$Q = 0..($m-1) | foreach{$row = @(0) * $m; $row[$_] = 1; ,$row} \n    [double[][]]$R = $A | foreach{$row = $_; ,@(0..$pn | foreach{$row[$_]})}\n    foreach ($h in 0..$pn) { \n        [double[]]$u = $R[$h..$pm] | foreach{$_[$h]} \n        [double]$nu = $u | foreach {[double]$sq = 0} {$sq += $_*$_} {[Math]::Sqrt($sq)} \n        $u[0] -= if ($u[0] -lt 0) {$nu} else {-$nu}\n        [double]$nu = $u | foreach {$sq = 0} {$sq += $_*$_} {[Math]::Sqrt($sq)} \n        [double[]]$u = $u | foreach { $_/$nu}\n        [double[][]]$v = 0..($u.Count - 1) | foreach{$i = $_; ,($u | foreach{2*$u[$i]*$_})}\n        [double[][]]$CR = $R | foreach{$row = $_; ,@(0..$pn | foreach{$row[$_]})}\n        [double[][]]$CQ = $Q | foreach{$row = $_; ,@(0..$pm | foreach{$row[$_]})}\n        foreach ($i in  $h..$pm) {\n            foreach ($j in  $h..$pn) {\n                $R[$i][$j] -=  $h..$pm | foreach {[double]$sum = 0} {$sum += $v[$i-$h][$_-$h]*$CR[$_][$j]} {$sum}\n            }\n        }\n        if (0 -eq $h)  {\n            foreach ($i in  $h..$pm) {\n                foreach ($j in  $h..$pm) {\n                    $Q[$i][$j] -=  $h..$pm | foreach {$sum = 0} {$sum += $v[$i][$_]*$CQ[$_][$j]} {$sum}\n                }\n            }\n        } else  {\n            $p = $h-1\n            foreach ($i in  $h..$pm) {\n                foreach ($j in  0..$p) {\n                    $Q[$i][$j] -=  $h..$pm | foreach {$sum = 0} {$sum += $v[$i-$h][$_-$h]*$CQ[$_][$j]} {$sum}\n                }\n                foreach ($j in  $h..$pm) {\n                    $Q[$i][$j] -=  $h..$pm | foreach {$sum = 0} {$sum += $v[$i-$h][$_-$h]*$CQ[$_][$j]} {$sum}\n                }\n            }\n        }\n    }\n    foreach ($i in  0..$pm) {\n        foreach ($j in  $i..$pm) {$Q[$i][$j],$Q[$j][$i] = $Q[$j][$i],$Q[$i][$j]}\n    }\n    [PSCustomObject]@{\"Q\" = $Q; \"R\" = $R}\n}\n\nfunction leastsquares([Double[][]]$A,[Double[]]$y) {\n    $QR = qr $A\n    [Double[][]]$Q = $QR.Q\n    [Double[][]]$R = $QR.R\n    $m,$n = $A.count, $A[0].count\n    [Double[]]$z = foreach ($j in  0..($m-1)) { \n            0..($m-1) | foreach {$sum = 0} {$sum += $Q[$_][$j]*$y[$_]} {$sum}\n    }\n    [Double[]]$x = @(0)*$n\n    for ($i = $n-1; $i -ge 0; $i--) {\n        for ($j = $i+1; $j -lt $n; $j++) {\n            $z[$i] -= $x[$j]*$R[$i][$j]\n        }\n        $x[$i] = $z[$i]/$R[$i][$i]\n    }\n    $x\n}\n\nfunction polyfit([Double[]]$x,[Double[]]$y,$n) {\n    $m = $x.Count \n    [Double[][]]$A = 0..($m-1) | foreach{$row = @(1) * ($n+1); ,$row} \n    for ($i = 0; $i -lt $m; $i++) {\n        for ($j = $n-1; 0 -le $j; $j--) {\n            $A[$i][$j] = $A[$i][$j+1]*$x[$i]\n        }\n    }\n    leastsquares $A $y\n}\n\nfunction show($m) {$m | foreach {write-host \"$_\"}}\n\n$A = @(@(12,-51,4), @(6,167,-68), @(-4,24,-41))\n$x = @(0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n$y = @(1, 6, 17, 34, 57, 86, 121, 162, 209, 262, 321)\n$QR = qr $A\n$ps = (polyfit $x $y 2)\n\"Q = \"\nshow $QR.Q\n\"R = \"\nshow $QR.R\n\"polyfit \"\n\"X^2 X constant\"\n\"$(polyfit $x $y 2)\"\n\n\nOutput:\nQ = \n-0.857142857142857 0.394285714285714 -0.331428571428571\n-0.428571428571429 -0.902857142857143 0.0342857142857143\n0.285714285714286 -0.171428571428571 -0.942857142857143\nR = \n-14 -21 14\n8.88178419700125E-16 -175 70\n-4.44089209850063E-16 0 35\npolyfit \nX^2 X constant\n3 1.99999999999998 1.00000000000005\n\n", "explain": ""}, {"task_name": "QR decomposition", "task_url": "https://rosettacode.org/wiki/QR_decomposition", "task_cat": "Mathematics", "lang": "F#", "code": "\n// QR decomposition. Nigel Galloway: January 11th., 2022\nlet n=[[12.0;-51.0;4.0];[6.0;167.0;-68.0];[-4.0;24.0;-41.0]]|>MathNet.Numerics.LinearAlgebra.MatrixExtensions.matrix\nlet g=n|>MathNet.Numerics.LinearAlgebra.Matrix.qr\nprintfn $\"Matrix\\n------\\n%A{n}\\nQ\\n-\\n%A{g.Q}\\nR\\n-\\n%A{g.R}\"\n\n\nOutput:\nMatrix\n------\nDenseMatrix 3x3-Double\n12  -51    4\n 6  167  -68\n-4   24  -41\n\nQ\n-\nDenseMatrix 3x3-Double\n-0.857143   0.394286  -0.331429\n-0.428571  -0.902857  0.0342857\n 0.285714  -0.171429  -0.942857\n\nR\n-\nDenseMatrix 3x3-Double\n-14   -21  14\n  0  -175  70\n  0     0  35\n\n", "explain": ""}]