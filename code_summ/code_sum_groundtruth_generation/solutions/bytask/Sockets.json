[{"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Python", "code": "\nimport socket\nsock = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\nsock.connect((\"localhost\", 256))\nsock.sendall(\"hello socket world\") \nsock.close()\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "C", "code": "\nWorks with: POSIX version .1-2001\nWorks with: gcc version 4.2.2\n\n#include <stdio.h>\n#include <string.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n\nconst char *msg = \"hello socket world\";\n\nint main()\n{\n   int i, sock, len, slen;\n\n   struct addrinfo hints, *addrs;  \n   memset(&hints, 0, sizeof(struct addrinfo));\n   hints.ai_family = AF_UNSPEC;\n   hints.ai_socktype = SOCK_STREAM;\n   \n   if (0 == getaddrinfo(\"localhost\", \"256\", &hints, &addrs))\n   {\n       sock = socket(addrs->ai_family, addrs->ai_socktype, addrs->ai_protocol);\n       if ( sock >= 0 )\n       {\n           if ( connect(sock, addrs->ai_addr, addrs->ai_addrlen) >= 0 )\n           {\n               const char *pm = msg;\n               do\n               {\n                  len = strlen(pm);\n                  slen = send(sock, pm, len, 0);\n                  pm += slen;\n               } while ((0 <= slen) && (slen < len));\n           }\n           close(sock);\n       }\n       freeaddrinfo(addrs);\n   }\n}\n\n", "explain": "With little changes it could work on MS Windows (without Cygwin) too. But I don't know exactly how. I have tested it using nc -l -p 256.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "C++", "code": "\n\n//compile with g++ main.cpp -lboost_system -pthread \n\n#include <boost/asio.hpp>\n\nint main()\n{\n  boost::asio::io_context io_context;\n  boost::asio::ip::tcp::socket sock(io_context);\n  boost::asio::ip::tcp::resolver resolver(io_context);\n  boost::asio::ip::tcp::resolver::query query(\"localhost\", \"4321\");\n\n  boost::asio::connect(sock, resolver.resolve(query));\n  boost::asio::write(sock, boost::asio::buffer(\"Hello world socket\\r\\n\"));\n\n  return 0;\n}\n\n", "explain": "I have tested it using nc -vlp 4321.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Java", "code": "\nimport java.io.IOException;\nimport java.net.*;\npublic class SocketSend {\n  public static void main(String args[]) throws IOException {\n    sendData(\"localhost\", \"hello socket world\");\n  }\n\n  public static void sendData(String host, String msg) throws IOException {\n    Socket sock = new Socket( host, 256 );\n    sock.getOutputStream().write(msg.getBytes());\n    sock.getOutputStream().flush();\n    sock.close();\n  }\n}\n\n\n", "explain": "Encapsulating the Socket's OutputStream in a PrintStream (for data) or PrintWriter (for text) may be easier in more complex programs for their auto-flush abilities, encoding management, and their overloaded print and println methods. The write method from the original OutputStream will still be available.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "C#", "code": "\nusing System;\nusing System.IO;\nusing System.Net.Sockets;\n\nclass Program {\n    static void Main(string[] args) {\n        TcpClient tcp = new TcpClient(\"localhost\", 256);\n        StreamWriter writer = new StreamWriter(tcp.GetStream());\n\n        writer.Write(\"hello socket world\");\n        writer.Flush();\n\n        tcp.Close();\n    }\n}\n\n\nusing System.Text;\nusing System.Net.Sockets;\n\nnamespace SocketClient\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var sock = new Socket(AddressFamily.InterNetwork, SocketType.Stream, ProtocolType.Tcp);\n            sock.Connect(\"127.0.0.1\", 1000);\n            sock.Send(Encoding.ASCII.GetBytes(\"Hell, world!\"));\n            sock.Close();\n        }\n    }\n}\n\n", "explain": "Clean Socket alternative:\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Visual_Basic_.NET", "code": "\nImports System\nImports System.IO\nImports System.Net.Sockets\n\nPublic Class Program \n    Public Shared Sub Main(ByVal args As String[])\n        Dim tcp As New TcpClient(\"localhost\", 256)\n        Dim writer As New StreamWriter(tcp.GetStream())\n\n        writer.Write(\"hello socket world\")\n        writer.Flush()\n\n        tcp.Close()\n    End Sub\nEnd Class\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "PHP", "code": "\n$socket = fsockopen('localhost', 256);\nfputs($socket, 'hello socket world');\nfclose($socket);\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Go", "code": "\npackage main\n \nimport (\n    \"fmt\"\n    \"net\"\n)\n \nfunc main() {\n    conn, err := net.Dial(\"tcp\", \"localhost:256\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    defer conn.Close()\n    _, err = conn.Write([]byte(\"hello socket world\"))\n    if err != nil {\n        fmt.Println(err)\n    }\n}\n\n\nTest with nc:\n$ sudo nc -l 256 & go run sock.go\n[2] 19754\nhello socket world[2]+  Done                    sudo nc -l 256\n$ \n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "X86_Assembly", "code": "\nWorks with: nasm version Linux\n;using sockets on linux with the 0x80 inturrprets.\n;\n;assemble\n;  nasm -o socket.o -f elf32 -g socket.asm\n;link\n;  ld -o socket socket.o\n;\n;\n;Just some assigns for better readability\n\n%assign SOCK_STREAM         1\n%assign AF_INET             2\n%assign SYS_socketcall      102\n%assign SYS_SOCKET          1\n%assign SYS_CONNECT         3\n%assign SYS_SEND            9\n%assign SYS_RECV            10\n\nsection .text\n  global _start\n  \n;--------------------------------------------------\n;Functions to make things easier.\u00a0:]\n;--------------------------------------------------\n_socket:\n  mov [cArray+0], dword AF_INET\n  mov [cArray+4], dword SOCK_STREAM\n  mov [cArray+8], dword 0\n  mov eax, SYS_socketcall\n  mov ebx, SYS_SOCKET\n  mov ecx, cArray\n  int 0x80\n  ret\n\n_connect:\n  call _socket\n  mov dword [sock], eax\n  mov dx, si\n  mov byte [edi+3], dl\n  mov byte [edi+2], dh\n  mov [cArray+0], eax     ;sock;\n  mov [cArray+4], edi     ;&sockaddr_in;\n  mov edx, 16\n  mov [cArray+8], edx   ;sizeof(sockaddr_in);\n  mov eax, SYS_socketcall\n  mov ebx, SYS_CONNECT\n  mov ecx, cArray\n  int 0x80\n  ret\n\n_send:\n  mov edx, [sock]\n  mov [sArray+0],edx\n  mov [sArray+4],eax\n  mov [sArray+8],ecx\n  mov [sArray+12], dword 0\n  mov eax, SYS_socketcall\n  mov ebx, SYS_SEND\n  mov ecx, sArray\n  int 0x80\n  ret\n\n_exit:\n  push 0x1\n  mov eax, 1\n  push eax\n  int 0x80\n  \n_print:\n  mov ebx, 1\n  mov eax, 4  \n  int 0x80   \n  ret         \n;--------------------------------------------------\n;Main code body\n;--------------------------------------------------\n \n_start:\n  mov esi, szIp    \n  mov edi, sockaddr_in\n  xor eax,eax\n  xor ecx,ecx\n  xor edx,edx\n  .cc:\n    xor   ebx,ebx\n  .c:\n    lodsb\n    inc   edx\n    sub   al,'0'\n    jb   .next\n    imul ebx,byte 10\n    add   ebx,eax\n    jmp   short .c\n  .next:\n    mov   [edi+ecx+4],bl\n    inc   ecx\n    cmp   ecx,byte 4\n    jne   .cc\n\n  mov word [edi], AF_INET \n  mov esi, szPort \n  xor eax,eax\n  xor ebx,ebx\n  .nextstr1:   \n    lodsb      \n    test al,al\n    jz .ret1\n    sub   al,'0'\n    imul ebx,10\n    add   ebx,eax   \n    jmp   .nextstr1\n  .ret1:\n    xchg ebx,eax   \n    mov [sport], eax\n  \n  mov si, [sport]  \n  call _connect\n  cmp eax, 0\n  jnz short _fail\n  mov eax, msg\n  mov ecx, msglen\n  call _send\n  call _exit\n\n_fail:\n  mov edx, cerrlen\n  mov ecx, cerrmsg\n  call _print\n  call _exit\n\n\n_recverr: \n  call _exit\n_dced: \n  call _exit\n\nsection .data\ncerrmsg      db 'failed to connect :(',0xa\ncerrlen      equ $-cerrmsg\nmsg          db 'Hello socket world!',0xa\nmsglen       equ $-msg\n\nszIp         db '127.0.0.1',0\nszPort       db '256',0\n\nsection .bss\nsock         resd 1\n;general 'array' for syscall_socketcall argument arg.\ncArray       resd 1\n             resd 1\n\t     resd 1\n             resd 1\n\t     \n;send 'array'.\nsArray      resd 1\n            resd 1\n            resd 1\n            resd 1\n;duh?\nsockaddr_in resb 16\n;..\nsport       resb 2\nbuff        resb 1024\n\nWorks with: MASM\n\n.586\n.model flat,stdcall\noption casemap:none\n\ninclude /masm32/include/windows.inc\ninclude /masm32/include/user32.inc\ninclude /masm32/include/kernel32.inc\ninclude /masm32/include/ws2_32.inc\n   \nincludelib /masm32/lib/user32.lib\nincludelib /masm32/lib/kernel32.lib\nincludelib /masm32/lib/ws2_32.lib\n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD\n\n\n.data\n   \tClassName \tdb \"MainWinClass\",0\n   \tAppName  \tdb \"Async Sockets\",0\n   \tszSockStr\tdb \"Hello socket world!\",13,10,0\n   \tszIp\t\tdb \"127.0.0.1\",0\n   \tport\t\tdd 256\n   \t\n   \twsa\t\t\tWSADATA <>\n   \tsa\t\t\tsockaddr_in <>\n   \t\n.data?\n   \thInstance \tdd ?\n   \tCommandLine dd ?\n   \tsock\t\tdd ?\n   \t\n.const\nWM_SOCK\t\t\tequ WM_USER+100\n\n.code\nstart:\n\tinvoke WSAStartup, 200h, addr wsa\n\t.if eax!=NULL\n\t\tinvoke ExitProcess, eax \n\t.else\n\t\tinvoke GetModuleHandle, NULL\n\t\tmov    hInstance,eax\n\t\tinvoke GetCommandLine\n\t\tmov    CommandLine,eax\n\t\tinvoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT\n\t\tinvoke ExitProcess,eax\n\t.endif\n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD\n\tLOCAL wc:WNDCLASSEX\n\tLOCAL msg:MSG\n\tLOCAL hwnd:HWND\n\t\n\tmov   wc.cbSize,SIZEOF WNDCLASSEX\n\tmov   wc.style, CS_HREDRAW or CS_VREDRAW\n\tmov   wc.lpfnWndProc, OFFSET WndProc\n\tmov   wc.cbClsExtra,NULL\n\tmov   wc.cbWndExtra,NULL\n\tpush  hInstance\n\tpop   wc.hInstance\n\tmov   wc.hbrBackground,COLOR_BTNFACE+1\n\tmov   wc.lpszMenuName,NULL\n\tmov   wc.lpszClassName,OFFSET ClassName\n\t\n\tinvoke LoadIcon,NULL,IDI_APPLICATION\n\tmov   wc.hIcon,eax\n\tmov   wc.hIconSm,eax\n\t\n\tinvoke LoadCursor,NULL,IDC_ARROW\n\tmov   wc.hCursor,eax\n\t\n\tinvoke RegisterClassEx, addr wc\n\tINVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\\n           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\\\n           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\\\n           hInst,NULL\n\tmov   hwnd,eax\n\t\n\tinvoke ShowWindow, hwnd,SW_SHOWNORMAL\n\tinvoke UpdateWindow, hwnd\n\t\n\t.WHILE TRUE\n\t\tinvoke GetMessage, ADDR msg,NULL,0,0\n\t\t.BREAK .IF (!eax)\n\t\tinvoke TranslateMessage, ADDR msg\n\t\tinvoke DispatchMessage, ADDR msg\n\t.ENDW\n\t\n\tmov     eax,msg.wParam\n\tret\nWinMain endp\n\nWndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM\n\t\n\t.IF uMsg==WM_DESTROY\n\t\tinvoke PostQuitMessage,NULL\n\t.ELSEIF uMsg==WM_CREATE\n\t\tinvoke socket, AF_INET,SOCK_STREAM, 0\n\t\t.if eax==INVALID_SOCKET\n\t\t\t;error\n\t\t.endif\n\t\tmov sock, eax\n\t\tinvoke WSAAsyncSelect, sock, hWnd, WM_SOCK, FD_CONNECT or FD_CLOSE\n\t\t.if eax==INVALID_SOCKET\n\t\t\t;error!\n\t\t.endif\n\t\tmov sa.sin_family, AF_INET\n\t\tinvoke inet_addr, addr szIp\n\t\tmov sa.sin_addr, eax\n\t\tinvoke htons, port\n\t\tmov sa.sin_port, ax\n\t\tinvoke connect, sock, addr sa, sizeof sa\n\t\t.if eax==SOCKET_ERROR\n\t\t\tinvoke WSAGetLastError\n\t\t\t.if eax!=WSAEWOULDBLOCK\n\t\t\t\t;real error.\n\t\t\t.endif\n\t\t.endif\n\t.elseif uMsg==WM_SOCK\n\t\tmov edx, lParam\n\t\t.if dx==FD_CONNECT\n\t\t\tshr edx, 16\n\t\t\t.if dx==NULL\n\t\t\t\tinvoke lstrlen, addr szSockStr\n\t\t\t\tinvoke send, sock, addr szSockStr, eax, 0\n\t\t\t.else\n\t\t\t\t;error\n\t\t\t.endif\n\t\t.elseif dx==FD_CLOSE\n\t\t\tshr edx, 16\n\t\t\t.if dx==NULL\n\t\t\t\tinvoke SendMessage, hWnd, WM_DESTROY, 0, 0\n\t\t\t.endif\n\t\t.endif\n\t.ELSE\n\t\tinvoke DefWindowProc,hWnd,uMsg,wParam,lParam\t\t\n\t\tret\n\t.ENDIF\n\t\n\txor eax,eax\n\tret\nWndProc endp\n\n\nend start\n\nWorks with: MASM\n\n.586\n.model flat,stdcall\noption casemap:none\n\ninclude /masm32/include/windows.inc\ninclude /masm32/include/user32.inc\ninclude /masm32/include/kernel32.inc\ninclude /masm32/include/ws2_32.inc\n   \nincludelib /masm32/lib/user32.lib\nincludelib /masm32/lib/kernel32.lib\nincludelib /masm32/lib/ws2_32.lib\n\nWinMain proto :DWORD,:DWORD,:DWORD,:DWORD\n\n\n.data\n   \tClassName \tdb \"MainWinClass\",0\n   \tAppName  \tdb \"Blocking Sockets\",0\n   \tszSockStr\tdb \"Hello socket world!\",13,10,0\n   \tszIp\t\tdb \"127.0.0.1\",0\n   \tport\t\tdd 256\n   \t\n   \twsa\t\t\tWSADATA <>\n   \tsa\t\t\tsockaddr_in <>\n   \t\n.data?\n   \thInstance \tdd ?\n   \tCommandLine dd ?\n   \tsock\t\tdd ?\n\n.code\nstart:\n\tinvoke WSAStartup, 200h, addr wsa\n\t.if eax!=NULL\n\t\tinvoke ExitProcess, eax \n\t.else\n\t\tinvoke GetModuleHandle, NULL\n\t\tmov    hInstance,eax\n\t\tinvoke GetCommandLine\n\t\tmov    CommandLine,eax\n\t\tinvoke WinMain, hInstance,NULL,CommandLine, SW_SHOWDEFAULT\n\t\tinvoke ExitProcess,eax\n\t.endif\n\nWinMain proc hInst:HINSTANCE,hPrevInst:HINSTANCE,CmdLine:LPSTR,CmdShow:DWORD\n\tLOCAL wc:WNDCLASSEX\n\tLOCAL msg:MSG\n\tLOCAL hwnd:HWND\n\t\n\tmov   wc.cbSize,SIZEOF WNDCLASSEX\n\tmov   wc.style, CS_HREDRAW or CS_VREDRAW\n\tmov   wc.lpfnWndProc, OFFSET WndProc\n\tmov   wc.cbClsExtra,NULL\n\tmov   wc.cbWndExtra,NULL\n\tpush  hInstance\n\tpop   wc.hInstance\n\tmov   wc.hbrBackground,COLOR_BTNFACE+1\n\tmov   wc.lpszMenuName,NULL\n\tmov   wc.lpszClassName,OFFSET ClassName\n\t\n\tinvoke LoadIcon,NULL,IDI_APPLICATION\n\tmov   wc.hIcon,eax\n\tmov   wc.hIconSm,eax\n\t\n\tinvoke LoadCursor,NULL,IDC_ARROW\n\tmov   wc.hCursor,eax\n\t\n\tinvoke RegisterClassEx, addr wc\n\tINVOKE CreateWindowEx,NULL,ADDR ClassName,ADDR AppName,\\\n           WS_OVERLAPPEDWINDOW,CW_USEDEFAULT,\\\n           CW_USEDEFAULT,CW_USEDEFAULT,CW_USEDEFAULT,NULL,NULL,\\\n           hInst,NULL\n\tmov   hwnd,eax\n\t\n\tinvoke ShowWindow, hwnd,SW_SHOWNORMAL\n\tinvoke UpdateWindow, hwnd\n\t\n\t.WHILE TRUE\n\t\tinvoke GetMessage, ADDR msg,NULL,0,0\n\t\t.BREAK .IF (!eax)\n\t\tinvoke TranslateMessage, ADDR msg\n\t\tinvoke DispatchMessage, ADDR msg\n\t.ENDW\n\t\n\tmov     eax,msg.wParam\n\tret\nWinMain endp\n\nWndProc proc hWnd:HWND, uMsg:UINT, wParam:WPARAM, lParam:LPARAM\n\t\n\t.IF uMsg==WM_DESTROY\n\t\tinvoke PostQuitMessage,NULL\n\t.ELSEIF uMsg==WM_CREATE\n\t\tinvoke socket, AF_INET,SOCK_STREAM, 0\n\t\t.if eax==INVALID_SOCKET\n\t\t\t;error\n\t\t.endif\n\t\tmov sock, eax\n\t\tmov sa.sin_family, AF_INET\n\t\tinvoke inet_addr, addr szIp\n\t\tmov sa.sin_addr, eax\n\t\tinvoke htons, port\n\t\tmov sa.sin_port, ax\n\t\tinvoke connect, sock, addr sa, sizeof sa\n\t\tinvoke lstrlen, addr szSockStr\n\t\tinvoke send, sock, addr szSockStr, eax, 0\n\t.ELSE\n\t\tinvoke DefWindowProc,hWnd,uMsg,wParam,lParam\t\t\n\t\tret\n\t.ENDIF\n\t\n\txor eax,eax\n\tret\nWndProc endp\n\n\nend start\n\n", "explain": "Operates in non-blocking mode.\nThis example works in blocking mode.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Delphi", "code": "\nprogram Sockets;\n\n{$APPTYPE CONSOLE}\n\nuses IdTCPClient;\n\nvar\n  lTCPClient: TIdTCPClient;\nbegin\n  lTCPClient := TIdTCPClient.Create(nil);\n  try\n    lTCPClient.Host := '127.0.0.1';\n    lTCPClient.Port := 256;\n    lTCPClient.Connect;\n    lTCPClient.IOHandler.WriteLn('hello socket world');\n  finally\n    lTCPClient.Free;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Ruby", "code": "\nrequire 'socket'\nsock = TCPSocket.open(\"localhost\", 256)\nsock.write(\"hello socket world\")\nsock.close\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Rust", "code": "\nWorks with: Rust 1.0 stable\nuse std::io::prelude::*;\nuse std::net::TcpStream;\n\nfn main() {\n    // Open a tcp socket connecting to 127.0.0.1:256, no error handling (unwrap)\n    let mut my_stream = TcpStream::connect(\"127.0.0.1:256\").unwrap();\n\n    // Write 'hello socket world' to the stream, ignoring the result of write\n    let _ = my_stream.write(b\"hello socket world\");\n\n} // <- my_stream's drop function gets called, which closes the socket\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "R", "code": "\ns <- make.socket(port = 256)\nwrite.socket(s, \"hello socket world\")\nclose.socket(s)\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Ada", "code": "\nLibrary: GNAT RTL\nwith GNAT.Sockets;  use GNAT.Sockets;\n\nprocedure Socket_Send is\n   Client : Socket_Type;\nbegin\n   Initialize;\n   Create_Socket  (Socket => Client);\n   Connect_Socket (Socket => Client,\n                   Server => (Family => Family_Inet,\n                              Addr   => Inet_Addr (\"127.0.0.1\"),\n                              Port   => 256));\n   String'Write (Stream (Client), \"hello socket world\");\n   Close_Socket (Client);\nend Socket_Send;\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Julia", "code": "\nsocket = connect(\"localhost\",256)\nwrite(socket, \"hello socket world\")\nclose(socket)\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Kotlin", "code": "\n// version 1.2.21\n\nimport java.net.Socket\n\nfun main(args: Array<String>) {\n    val sock = Socket(\"localhost\", 256)\n    sock.use {\n        it.outputStream.write(\"hello socket world\".toByteArray())\n    }\n}\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Perl", "code": "\nuse Socket;\n\n$host = gethostbyname('localhost');\n$in = sockaddr_in(256, $host);\n$proto = getprotobyname('tcp');\nsocket(Socket_Handle, AF_INET, SOCK_STREAM, $proto);\nconnect(Socket_Handle, $in);\nsend(Socket_Handle, 'hello socket world', 0, $in);\nclose(Socket_Handle);\n\n\nuse Socket::Class;\n\n$sock = Socket::Class->new(\n  'remote_port' => 256,\n) || die Socket::Class->error;\n$sock->send('hello socket world');\n$sock->free;\n\n", "explain": "Object oriented version.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Objective-C", "code": "\n\n// declare the class to conform to NSStreamDelegate protocol\n\n// in some method\nNSOutputStream *oStream;\n[NSStream getStreamsToHost:[NSHost hostWithName:@\"localhost\"] port:256 inputStream:NULL outputStream:&oStream];\n[oStream setDelegate:self];\n[oStream scheduleInRunLoop:[NSRunLoop currentRunLoop] forMode:NSDefaultRunLoopMode];\n[oStream open];\n\n\n// later, in the same class:\n- (void)stream:(NSStream *)aStream handleEvent:(NSStreamEvent)streamEvent {\n    NSOutputStream *oStream = (NSOutputStream *)aStream;\n    if (streamEvent == NSStreamEventHasBytesAvailable) {\n        NSString *str = @\"hello socket world\";\n        const char *rawstring = [str UTF8String];\n        [oStream write:rawstring maxLength:strlen(rawstring)];\n        [oStream close];\n    }\n}\n\n", "explain": "(untested)\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Prolog", "code": "\n\nstart(Port) :- socket('AF_INET',Socket),\n               socket_connect(Socket, 'AF_INET'(localhost,Port), Input, Output),\n               write(Output, 'hello socket world'),\n               flush_output(Output),\n               close(Output),\n               close(Input).\n\n", "explain": "This works with Gnu Prolog. Other implementations will have different predicates.\n"}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Lua", "code": "\nLibrary: LuaSocket\nsocket = require \"socket\"\nhost, port = \"127.0.0.1\", 256\n\nsid = socket.udp()\nsid:sendto( \"hello socket world\", host, port )\nsid:close()\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Scala", "code": "\nLibrary: Scala\nimport java.net.Socket\n\nobject sendSocketData {\n\n  def sendData(host: String, msg: String) {\n    val sock = new Socket(host, 256)\n    sock.getOutputStream().write(msg.getBytes())\n    sock.getOutputStream().flush()\n    sock.close()\n  }\n\n  sendData(\"localhost\", \"hello socket world\")\n}\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "D", "code": "\nmodule socket ;\nimport std.stdio ;\nimport std.socket ;\nversion(Win32) {\n  // For Win32 systems, need to link with ws2_32.lib. \n  pragma(lib, \"ws2_32.lib\") ; \n}\nvoid main() {\n  long res;\n  auto socket = new Socket(AddressFamily.INET, SocketType.STREAM) ;\n  socket.connect(new InternetAddress(\"localhost\",256)) ;\n  res = socket.send(cast(void[])\"hello socket world\") ;\n  writefln(\"Socket %d bytes sent.\", res) ;\n  socket.close() ;\n}\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Haskell", "code": "\nimport Network\n\nmain = withSocketsDo $ sendTo \"localhost\" (PortNumber $ toEnum 256) \"hello socket world\"\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Scheme", "code": "\nWorks with: Guile version 1.8.8Works with: Chicken Scheme version 4.6.0\n(let ((s (socket PF_INET SOCK_STREAM 0)))\n    (connect s AF_INET (inet-pton AF_INET \"127.0.0.1\") 256)\n    (display \"hello socket world\" s))\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "Groovy", "code": "\ns = new java.net.Socket(\"localhost\", 256)\ns << \"hello socket world\"\ns.close()\n\n", "explain": ""}, {"task_name": "Sockets", "task_url": "https://rosettacode.org/wiki/Sockets", "task_cat": "Networking and Web Interaction", "lang": "AWK", "code": "\nWorks with: GAWK\n\nBEGIN { \n    s=\"/inet/tcp/256/0/0\"\n    print strftime() |& s\n    close(s)\n}\n\n\nBEGIN {\n    s=\"/inet/tcp/0/localhost/256\"\n    s |& getline\n    print $0\n    close(s)\n}\n\n", "explain": "Note: |& is gawk's two way pipe operator.\nServer:\nTest client:\n"}]