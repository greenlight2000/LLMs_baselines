[{"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Python", "code": "\n2.x[edit]\n\nByte Length[edit]\nWorks with: Python version 2.x\n\nprint len('ascii')\n# 5\n\n# The letter Alef\nprint len(u'\\u05d0'.encode('utf-8'))\n# 2\nprint len(u'\\u05d0'.encode('iso-8859-8'))\n# 1\n\n#!/bin/env python\n# -*- coding: UTF-8 -*-\ns = u\"m\u00f8\u00f8se\"\nassert len(s) == 5\nassert len(s.encode('UTF-8')) == 7\nassert len(s.encode('UTF-16-BE')) == 10 # There are 3 different UTF-16 encodings: LE and BE are little endian and big endian respectively, the third one (without suffix) adds 2 extra leading bytes: the byte-order mark (BOM).\nCharacter Length[edit]\nWorks with: Python version 2.4\n\nimport sys\nsys.maxunicode # 1114111 on a wide build, 65535 on a narrow build\n\nprint len('ascii')\n# 5\nprint len(u'\\u05d0') # the letter Alef as unicode literal\n# 1\nprint len('\\xd7\\x90'.decode('utf-8')) # Same encoded as utf-8 string\n# 1\nprint hex(sys.maxunicode), len(unichr(0x1F4A9))\n# ('0x10ffff', 1)\n\nprint hex(sys.maxunicode), len(unichr(0x1F4A9))\n# ('0xffff', 2)\n3.x[edit]\n\nByte Length[edit]\n\nprint(len(b'Hello, World!'))\n# 13\n\n# The letter Alef\nprint(len('\\u05d0'.encode())) # the default encoding is utf-8 in Python3\n# 2\nprint(len('\\u05d0'.encode('iso-8859-8')))\n# 1\n\n#!/bin/env python\n# -*- coding: UTF-8 -*-\ns = \"m\u00f8\u00f8se\"\nassert len(s) == 5\nassert len(s.encode('UTF-8')) == 7\nassert len(s.encode('UTF-16-BE')) == 10 # There are 3 different UTF-16 encodings: LE and BE are little endian and big endian respectively, the third one (without suffix) adds 2 extra leading bytes: the byte-order mark (BOM).\nu=\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\"\nassert len(u.encode()) == 28\nassert len(u.encode('UTF-16-BE')) == 28\nCharacter Length[edit]\n\nprint(len(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\")) \n# 7\n\nimport sys\nsys.maxunicode # 1114111 on a wide build, 65535 on a narrow build\nprint(len('ascii'))\n# 5\nprint(len('\\u05d0')) # the letter Alef as unicode literal\n# 1\n\nprint(len(b'\\xd7\\x90'.decode('utf-8'))) # Alef encoded as utf-8 byte sequence\n# 1\nprint(hex(sys.maxunicode), len(unichr(0x1F4A9)))\n# ('0x10ffff', 1)\n\nprint(hex(sys.maxunicode), len(unichr(0x1F4A9)))\n# ('0xffff', 2)\n", "explain": "In Python 2.x, there are two types of strings: regular (8-bit) strings, and Unicode strings. Unicode string literals are prefixed with \"u\".\nFor 8-bit strings, the byte length is the same as the character length:\nFor Unicode strings, length depends on the internal encoding. Since version 2.2 Python shipped with two build options: it either uses 2 or 4 bytes per character. The internal representation is not interesting for the user.\nExample from the problem statement:\nlen() returns the number of code units (not code points!) in a Unicode string or plain ASCII string. On a wide build, this is the same as the number of  code points, but on a narrow one it is not. Most linux distributions install the wide build by default, you can check the build at runtime with:\nTo get the length of encoded string, you have to decode it first:\nOn a narrow build, len() gives the wrong answer for non-BMP chars\nIn Python 3.x, strings are Unicode strings and a bytes type if available for storing an immutable sequence of bytes (there's also available a bytearray type, which is mutable)\nYou can use len() to get the length of a byte sequence.\nTo get a byte sequence from a string, you have to encode it with the desired encoding:\nExample from the problem statement:\nSince Python3.3 the internal storage of unicode strings has been optimized: strings that don't contain characters outside the latin-1 set, are stored with 8 bits for each character, strings that don't contain codepoints outside the BMP (lone surrogates aren't allowed) are stored as UCS-2, while all the others use UCS-4. \nThus Python is able to avoid memory overhead when dealing with only ASCII strings, while handling correctly all codepoints in Unicode. len() returns the number of characters/codepoints:\nUntil Python 3.2 instead, length depended on the internal encoding, since it shipped with two build options: it either used 2 or 4 bytes per character.\nlen() returned the number of code units in a string, which could be different from the number of characters. In a narrow build, this is not a reliable way to get the number of characters. You can only easily count code points in a wide build. Most linux distributions install the wide build by default, you can check the build at runtime with:\nTo get the length of an encoded byte sequence, you have to decode it first:\nOn a narrow build, len() gives the wrong answer for non-BMP chars\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "C", "code": "\nByte Length[edit]\nWorks with: ANSI C\nWorks with: GCC version 3.3.3\n#include <string.h>\n\nint main(void) \n{\n  const char *string = \"Hello, world!\";\n  size_t length = strlen(string);\n         \n  return 0;\n}\n\n\nint main(void) \n{\n  const char *string = \"Hello, world!\";\n  size_t length = 0;\n  \n  const char *p = string;\n  while (*p++ != '\\0') length++;                                         \n  \n  return 0;\n}\n\n\n#include <stdlib.h>\n\nint main(void)\n{\n  char s[] = \"Hello, world!\";\n  size_t length = sizeof s - 1;\n  \n  return 0;\n}\n\nCharacter Length[edit]\n\n#include <stdio.h>\n#include <wchar.h>\n\nint main(void) \n{\n   wchar_t *s = L\"\\x304A\\x306F\\x3088\\x3046\"; /* Japanese hiragana ohayou */\n   size_t length;\n\n   length = wcslen(s);\n   printf(\"Length in characters = %d\\n\", length);\n   printf(\"Length in bytes      = %d\\n\", sizeof(s) * sizeof(wchar_t));\n   \n   return 0;\n}\n\nDealing with raw multibyte string[edit]\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <locale.h>\n\nint main()\n{\n\tsetlocale(LC_CTYPE, \"\");\n\tchar moose[] = \"m\u00f8\u00f8se\";\n\tprintf(\"bytes: %d\\n\", sizeof(moose) - 1);\n\tprintf(\"chars: %d\\n\", (int)mbstowcs(0, moose, 0));\n\n\treturn 0;\n}\noutputbytes: 7\nchars: 5\n", "explain": "or by hand:\nor (for arrays of char only)\nFor wide character strings (usually Unicode uniform-width encodings such as UCS-2 or UCS-4):\nFollowing code is written in UTF-8, and environment locale is assumed to be UTF-8 too.  Note that \"m\u00f8\u00f8se\" is here directly written in the source code for clarity, which is not a good idea in general.  mbstowcs(), when passed NULL as the first argument, effectively counts the number of chars in given string under current locale.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "C++", "code": "\nByte Length[edit]\nWorks with: ISO C++\nWorks with: g++ version 4.0.2\n#include <string> // (not <string.h>!)\nusing std::string;\n\nint main()\n{\n  string s = \"Hello, world!\";\n  string::size_type length = s.length(); // option 1: In Characters/Bytes\n  string::size_type size = s.size();     // option 2: In Characters/Bytes\n  // In bytes same as above since sizeof(char) == 1\n  string::size_type bytes = s.length() * sizeof(string::value_type); \n}\n\n\n#include <string>\nusing std::wstring;\n  \nint main()\n{\n  wstring s = L\"\\u304A\\u306F\\u3088\\u3046\";\n  wstring::size_type length = s.length() * sizeof(wstring::value_type); // in bytes\n}\n\nCharacter Length[edit]\nWorks with: C++98\nWorks with: g++ version 4.0.2\n\n#include <string>\nusing std::wstring;\n\nint main()\n{\n  wstring s = L\"\\u304A\\u306F\\u3088\\u3046\";\n  wstring::size_type length = s.length();\n}\n\n\nWorks with: C++11\nWorks with: clang++ version 3.0\n#include <iostream>\n#include <codecvt>\nint main()\n{\n    std::string utf8 = \"\\x7a\\xc3\\x9f\\xe6\\xb0\\xb4\\xf0\\x9d\\x84\\x8b\"; // U+007a, U+00df, U+6c34, U+1d10b\n    std::cout << \"Byte length: \" << utf8.size() << '\\n';\n    std::wstring_convert<std::codecvt_utf8<char32_t>, char32_t> conv;\n    std::cout << \"Character length: \" << conv.from_bytes(utf8).size() << '\\n';\n}\n\nWorks with: C++98\nWorks with: g++ version 4.1.2 20061115 (prerelease) (SUSE Linux)\n#include <cwchar>  // for mbstate_t\n#include <locale>\n\n// give the character length for a given named locale\nstd::size_t char_length(std::string const& text, char const* locale_name)\n{\n  // locales work on pointers; get length and data from string and\n  // then don't touch the original string any more, to avoid\n  // invalidating the data pointer\n  std::size_t len = text.length();\n  char const* input = text.data();\n\n  // get the named locale\n  std::locale loc(locale_name);\n\n  // get the conversion facet of the locale\n  typedef std::codecvt<wchar_t, char, std::mbstate_t> cvt_type;\n  cvt_type const& cvt = std::use_facet<cvt_type>(loc);\n\n  // allocate buffer for conversion destination\n  std::size_t bufsize = cvt.max_length()*len;\n  wchar_t* destbuf = new wchar_t[bufsize];\n  wchar_t* dest_end;\n\n  // do the conversion\n  mbstate_t state = mbstate_t();\n  cvt.in(state, input, input+len, input, destbuf, destbuf+bufsize, dest_end);\n\n  // determine the length of the converted sequence\n  std::size_t length = dest_end - destbuf;\n\n  // get rid of the buffer\n  delete[] destbuf;\n\n  // return the result\n  return length;\n}\n\n\n#include <iostream>\n\nint main()\n{\n  // T\u00fcr (German for door) in UTF8\n  std::cout << char_length(\"\\x54\\xc3\\xbc\\x72\", \"de_DE.utf8\") << \"\\n\"; // outputs 3\n\n  // T\u00fcr in ISO-8859-1\n  std::cout << char_length(\"\\x54\\xfc\\x72\", \"de_DE\") << \"\\n\"; // outputs 3\n}\n\n\n", "explain": "For wide character strings:\nFor wide character strings:\nFor narrow character strings:\nExample usage (note that the locale names are OS specific):\nNote that the strings are given as explicit hex sequences, so that the encoding used for the source code won't matter.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Java", "code": "\nByte Length[edit]\n\nString s = \"Hello, world!\"; \nint byteCountUTF16 = s.getBytes(\"UTF-16\").length; // Incorrect: it yields 28 (that is with the BOM)\nint byteCountUTF16LE = s.getBytes(\"UTF-16LE\").length; // Correct: it yields 26\nint byteCountUTF8  = s.getBytes(\"UTF-8\").length; // yields 13\n\nCharacter Length[edit]\n\nString s = \"Hello, world!\";\nint not_really_the_length = s.length(); // XXX: does not (always) count Unicode characters (code points)!\n\n\nString str = \"\\uD834\\uDD2A\"; //U+1D12A\nint not_really__the_length = str.length(); // value is 2, which is not the length in characters\nint actual_length = str.codePointCount(0, str.length()); // value is 1, which is the length in characters\n\nGrapheme Length[edit]\n\nimport java.text.BreakIterator;\n\npublic class Grapheme {\n  public static void main(String[] args) {\n    printLength(\"m\u00f8\u00f8se\");\n    printLength(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\");\n    printLength(\"J\u0332o\u0332s\u0332\u00e9\u0332\");\n  }\n  \n  public static void printLength(String s) {\n    BreakIterator it = BreakIterator.getCharacterInstance();\n    it.setText(s);\n    int count = 0;\n    while (it.next() != BreakIterator.DONE) {\n      count++;\n    }\n    System.out.println(\"Grapheme length: \" + count+ \" \" + s);\n  }\n}\n\n\nGrapheme length: 5 m\u00f8\u00f8se\nGrapheme length: 7 \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\nGrapheme length: 4 J\u0332o\u0332s\u0332\u00e9\u0332\n\n", "explain": "Java encodes strings in UTF-16, which represents each character with one or two 16-bit values.\nAnother way to know the byte length of a string -who cares- is to explicitly specify the charset we desire.\nJava encodes strings in UTF-16, which represents each character (code point) with one or two 16-bit code units. This is a variable-length encoding scheme. The most commonly used characters are represented by one 16-bit code unit, while rarer ones like some mathematical symbols are represented by two.\nThe length method of String objects is not the length of that String in characters.  Instead, it only gives the number of 16-bit code units used to encode a string. This is not (always) the number of Unicode characters (code points) in the string.\nSince Java 1.5, the actual number of characters (code points) can be determined by calling the codePointCount method.\nSince JDK 20[1]. \nOutput:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "C#", "code": "\n\nWorks with: C # version 1.0+\nCharacter Length[edit]\nstring s = \"Hello, world!\";\nint characterLength = s.Length;\n\nByte Length[edit]\n\nusing System.Text;\n\nstring s = \"Hello, world!\";\nint byteLength = Encoding.Unicode.GetByteCount(s);\n\n\nint utf8ByteLength = Encoding.UTF8.GetByteCount(s);\n\n", "explain": "Platform: .NET\nStrings in .NET are stored in Unicode.\nTo get the number of bytes that the string would require in a different encoding, e.g., UTF8:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nByte length[edit]\n\nvar s = \"Hello, world!\";\nvar byteCount = s.length * 2; // 26\n\n\na = '\ud83d\udc69\u200d\u2764\ufe0f\u200d\ud83d\udc69'\nBuffer.byteLength(a, 'utf16le'); // 16\nBuffer.byteLength(a, 'utf8'); // 20\nBuffer.byteLength(s, 'utf16le'); // 26\nBuffer.byteLength(s, 'utf8'); // 13\n\n\n(new TextEncoder().encode(a)).length; // 20\n(new TextEncoder().encode(s)).length; // 13\n\nUnicode codepoint length[edit]\n\nvar str1 = \"Hello, world!\";\nvar len1 = str1.length; // 13\n\nvar str2 = \"\\uD834\\uDD2A\"; // U+1D12A represented by a UTF-16 surrogate pair\nvar len2 = str2.length; // 2\n\n\n[...str2].length // 1\n\nUnicode grapheme length[edit]\n\n[...new Intl.Segmenter().segment(a)].length; // 1\nES6 destructuring/iterators[edit]\n\nlet\n  str='A\u00f6\u0416\u20ac\ud834\udd1e'\n ,countofcodeunits=str.length // 6\n ,cparr=[...str],\n ,countofcodepoints=cparr.length; // 5\n{ let\n    count=0\n  for(let codepoint of str)\n    count++\n  countofcodepoints=count // 5\n}\n{ let\n    count=0,\n    it=str[Symbol.iterator]()\n  while(!it.next().done)\n    count++\n  countofcodepoints=count // 5\n}\n{ cparr=Array.from(str)\n  countofcodepoints=cparr.length // 5\n}\n", "explain": "JavaScript encodes strings in UTF-16, which represents each character with one or two 16-bit values. The length property of string objects gives the number of 16-bit values used to encode a string, so the number of bytes can be determined by doubling that number.\nIt's easier to use Buffer.byteLength (Node.JS specific, not ECMAScript).\nIn pure ECMAScript, TextEncoder() can be used to return the UTF-8 byte size:\nJavaScript encodes strings in UTF-16, which represents each character with one or two 16-bit values. The most commonly used characters are represented by one 16-bit value, while rarer ones like some mathematical symbols are represented by two.\nIf the string only contains commonly used characters, the number of characters will be equal to the number of 16-bit values used to represent the characters.\nMore generally, the expansion operator in an array can be used to enumerate Unicode code points:\nCounting Unicode codepoints when using combining characters such as joining sequences or diacritics will return the wrong size, so we must count graphemes instead. Intl.Segmenter() default granularity is grapheme.\nES6 provides several ways to get a string split into an array of code points instead of UTF-16 code units:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Visual_Basic_.NET", "code": "\n\nByte Length[edit]\n\nModule ByteLength\n    Function GetByteLength(s As String, encoding As Text.Encoding) As Integer\n        Return encoding.GetByteCount(s)\n    End Function\nEnd Module\nCharacter Length[edit]\n\nModule CharacterLength\n    Function GetUTF16CodeUnitsLength(s As String) As Integer\n        Return s.Length\n    End Function\n\n    Private Function GetUTF16SurrogatePairCount(s As String) As Integer\n        GetUTF16SurrogatePairCount = 0\n        For i = 1 To s.Length - 1\n            If Char.IsSurrogatePair(s(i - 1), s(i)) Then GetUTF16SurrogatePairCount += 1\n        Next\n    End Function\n\n    Function GetCharacterLength_FromUTF16(s As String) As Integer\n        Return GetUTF16CodeUnitsLength(s) - GetUTF16SurrogatePairCount(s)\n    End Function\n\n    Function GetCharacterLength_FromUTF32(s As String) As Integer\n        Return GetByteLength(s, Text.Encoding.UTF32) \\ 4\n    End Function\nEnd Module\nGrapheme Length[edit]\n\nModule GraphemeLength\n    ' Wraps an IEnumerator, allowing it to be used as an IEnumerable.\n    Private Iterator Function AsEnumerable(enumerator As IEnumerator) As IEnumerable\n        Do While enumerator.MoveNext()\n            Yield enumerator.Current\n        Loop\n    End Function\n\n    Function GraphemeCount(s As String) As Integer\n        Dim elements = Globalization.StringInfo.GetTextElementEnumerator(s)\n        Return AsEnumerable(elements).OfType(Of String).Count()\n    End Function\nEnd Module\nTest Code[edit]\n\n#Const PRINT_TESTCASE = True\n\nModule Program\n    ReadOnly TestCases As String() =\n    {\n        \"Hello, world!\",\n        \"m\u00f8\u00f8se\",\n        \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\", ' String normalization of the file makes the e and diacritic in \u00e9\u0332 one character, so use VB's char \"escapes\"\n        $\"J{ChrW(&H332)}o{ChrW(&H332)}s{ChrW(&H332)}e{ChrW(&H301)}{ChrW(&H332)}\"\n    }\n\n    Sub Main()\n        Const INDENT = \"    \"\n        Console.OutputEncoding = Text.Encoding.Unicode\n\n        Dim writeResult = Sub(s As String, result As Integer) Console.WriteLine(\"{0}{1,-20}{2}\", INDENT, s, result)\n\n        For i = 0 To TestCases.Length - 1\n            Dim c = TestCases(i)\n\n            Console.Write(\"Test case \" & i)\n#If PRINT_TESTCASE Then\n            Console.WriteLine(\": \" & c)\n#Else\n            Console.WriteLine()\n#End If\n            writeResult(\"graphemes\", GraphemeCount(c))\n            writeResult(\"UTF-16 units\", GetUTF16CodeUnitsLength(c))\n            writeResult(\"Cd pts from UTF-16\", GetCharacterLength_FromUTF16(c))\n            writeResult(\"Cd pts from UTF-32\", GetCharacterLength_FromUTF32(c))\n            Console.WriteLine()\n            writeResult(\"bytes (UTF-8)\", GetByteLength(c, Text.Encoding.UTF8))\n            writeResult(\"bytes (UTF-16)\", GetByteLength(c, Text.Encoding.Unicode))\n            writeResult(\"bytes (UTF-32)\", GetByteLength(c, Text.Encoding.UTF32))\n            Console.WriteLine()\n        Next\n\n    End Sub\nEnd Module\n\nOutput:\n\nTest case 0: Hello, world!\n    graphemes           13\n    UTF-16 units        13\n    Cd pts from UTF-16  13\n    Cd pts from UTF-32  13\n\n    bytes (UTF-8)       13\n    bytes (UTF-16)      26\n    bytes (UTF-32)      52\n\nTest case 1: m\u00f8\u00f8se\n    graphemes           5\n    UTF-16 units        5\n    Cd pts from UTF-16  5\n    Cd pts from UTF-32  5\n\n    bytes (UTF-8)       7\n    bytes (UTF-16)      10\n    bytes (UTF-32)      20\n\nTest case 2: \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\n    graphemes           7\n    UTF-16 units        14\n    Cd pts from UTF-16  7\n    Cd pts from UTF-32  7\n\n    bytes (UTF-8)       28\n    bytes (UTF-16)      28\n    bytes (UTF-32)      28\n\nTest case 3: J\u0332o\u0332s\u0332\u00e9\u0332\n    graphemes           4\n    UTF-16 units        9\n    Cd pts from UTF-16  9\n    Cd pts from UTF-32  9\n\n    bytes (UTF-8)       14\n    bytes (UTF-16)      18\n    bytes (UTF-32)      36\n+\n", "explain": "Compiler: Roslyn Visual Basic (language version >=15.5)\nStrings in .NET are immutable wrappers around arrays of the Char type, which represents a UTF-16 code unit (with a size of two bytes). Classes for encoding and decoding strings to and from byte arrays in various encodings are located in the System.Text namespace, with System.Text.Encoding representing different string encodings (and providing means of encoding and decoding strings to raw byte arrays). The Length property of a string returns the number of Chars it contains, and is thus the number of UTF-16 code units in that string.\nOne method of Encoding returns the number of bytes required to encode a .NET string in that encoding (encoding objects can be obtained through readonly static [Shared in VB.NET] properties of the Encoding class).\nThere is no intended means of obtaining the number of code points in a string in .NET, though a straightforward implementation is to take one fourth of the string's byte length in UTF-32 (as UTF-32 is a fixed-length encoding where each code point is four bytes).\nAn alternative implementation is to count the number of UTF-16 surrogate pairs in a string and subtract that number from the number of UTF-16 code units in the string.\nSystem.Globalization.StringInfo provides a means of enumerating the text elements of a string, where each \"text element\" is a Unicode grapheme.\nThe compiler constant PRINT_TESTCASE toggles whether to write the contents of each test case to the console; disable for inputs that may mess with the console.\ngraphemes corresponds to Grapheme Length in the task description, and either Cd pts value corresponds with Character Length. Byte lengths are given for three Unicode encodings.\nNote that the byte length in UTF-16 is always twice the length of a string due to .NET strings using UTF-16.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "SQL", "code": "\nByte length[edit]\n\nCharacter length[edit]\n\n", "explain": "SELECT LENGTH(CAST('m\u00f8\u00f8se' AS BLOB));\nSELECT LENGTH('m\u00f8\u00f8se');\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "PHP", "code": "\n\n<?php\nforeach (array('m\u00f8\u00f8se', '\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22', 'J\u0332o\u0332s\u0332\u00e9\u0332') as $s1) { \n   printf('String \"%s\" measured with strlen: %d mb_strlen: %s grapheme_strlen %s%s', \n                  $s1, strlen($s1),mb_strlen($s1), grapheme_strlen($s1), PHP_EOL);\n}\n\nString \"m\u00f8\u00f8se\" measured with strlen: 7 mb_strlen: 7 grapheme_strlen 5\nString \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\" measured with strlen: 28 mb_strlen: 28 grapheme_strlen 7\nString \"J\u0332o\u0332s\u0332\u00e9\u0332\" measured with strlen: 13 mb_strlen: 13 grapheme_strlen 4\n\n", "explain": "Program in a UTF8 linux:\nyields the result:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "MATLAB", "code": "\nCharacter Length[edit]\n>> length('m\u00f8\u00f8se')\n\nans =\n\n     5\nByte Length[edit]\n\n>> numel(dec2hex('m\u00f8\u00f8se'))\n\nans =\n\n    10\n", "explain": "MATLAB apparently encodes strings using UTF-16.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Fortran", "code": "\n\nByte Length[edit]\n\nCharacter Length[edit]\n\n", "explain": "Fortran 77 introduced variables of type CHARACTER and associated syntax. These are fixed-size entities, declared at compile time as in CHARACTER*66 TEXT, however a subroutine (or function) receiving such a variable could declare it as CHARACTER*(*) TEXT so that any size may be supplied to the routine, and with F90 came the ability within subroutines (or functions) to declare items of a size determined at run time. There is no associated length variable, as with strings that have both a content and a length, nor is there a special character value (such as zero) deemed to mark the end-of-text in such a variable to give string-like facilities. However, with F90 came facilities, standardised in F2003 whereby a CHARACTER variable could be re-allocated exactly the right amount of storage whenever it was assigned to. So, TEXT = \"this\" would cause TEXT to become a CHARACTER variable of length four, adjusted so at run time. Again, the length information is not associated with the variable itself, for instance as the content of a character zero prefixing the content to enable strings of a length up to 255. The length information must be stored somewhere...\nPreviously, character data would be stored in arithmetic variables, using format codes such as A1 to store one character per variable, which might be an integer or a floating-point variable of much larger size. Format A2 would store two such characters, and so on. Code A1 would give ease of manipulation, while A8 (say for a REAL*8 variable) would save space. Numerical values would be strange, and word sizes may not be a multiple of eight bits nor character encodements require eight bits, especially on a decimal computer such as the IBM1620 where storage usage was counted in digits, and a character required two.\nAn intrinsic function LEN(text) reports the number of characters in the variable (with no consideration of any storage needed anywhere to hold the length), while SIZE(array) reports the number of elements in an array and SIZEOF(x) may be available to report the number of bytes of storage of x. Since these days, everyone uses computers with eight-bit characters and this is deemed universal, the result from LEN will be equivalent to both a byte and a character count. \nThere is no facility for fancy Unicode schemes, other than by writing suitable routines. In that regard, plotting packages often supply a special function that returns the length of a text string, as it would appear on the plot, in plotting units, especially useful when the plotter's rendition of text employs a proportionally-spaced typeface and interprets superscripts and subscripts and so forth, so that the programmer can prepare code to juggle with the layout, perhaps of mathematical expressions. This is of course not in any standard.\nLEN(text)\nLEN(text)\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Go", "code": "\nByte Length[edit]\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    m := \"m\u00f8\u00f8se\"\n    u := \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\"\n    j := \"J\u0332o\u0332s\u0332\u00e9\u0332\"\n    fmt.Printf(\"%d %s\u00a0% x\\n\", len(m), m, m)\n    fmt.Printf(\"%d %s\u00a0% x\\n\", len(u), u, u)\n    fmt.Printf(\"%d %s\u00a0% x\\n\", len(j), j, j)\n}\n\n\n7 m\u00f8\u00f8se\u00a06d c3 b8 c3 b8 73 65\n28 \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22 f0 9d 94 98 f0 9d 94 ab f0 9d 94 a6 f0 9d 94 a0 f0 9d 94 ac f0 9d 94 a1 f0 9d 94 a2\n13 J\u0332o\u0332s\u0332\u00e9\u0332\u00a04a cc b2 6f cc b2 73 cc b2 c3 a9 cc b2\n\nCharacter Length[edit]\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    m := \"m\u00f8\u00f8se\"\n    u := \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\"\n    j := \"J\u0332o\u0332s\u0332\u00e9\u0332\"\n    fmt.Printf(\"%d %s %x\\n\", utf8.RuneCountInString(m), m, []rune(m))\n    fmt.Printf(\"%d %s %x\\n\", utf8.RuneCountInString(u), u, []rune(u))\n    fmt.Printf(\"%d %s %x\\n\", utf8.RuneCountInString(j), j, []rune(j))\n}\n\n\n5 m\u00f8\u00f8se [6d f8 f8 73 65]\n7 \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22 [1d518 1d52b 1d526 1d520 1d52c 1d521 1d522]\n9 J\u0332o\u0332s\u0332\u00e9\u0332 [4a 332 6f 332 73 332 65 301 332]\n\nGrapheme Length[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    m := \"m\u00f8\u00f8se\"\n    u := \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\"\n    j := \"J\u0332o\u0332s\u0332\u00e9\u0332\"\n    fmt.Printf(\"%d %s %x\\n\", grLen(m), m, []rune(m))\n    fmt.Printf(\"%d %s %x\\n\", grLen(u), u, []rune(u))\n    fmt.Printf(\"%d %s %x\\n\", grLen(j), j, []rune(j))\n}\n\nfunc grLen(s string) int {\n    if len(s) == 0 {\n        return 0\n    }\n    gr := 1\n    _, s1 := utf8.DecodeRuneInString(s)\n    for _, r := range s[s1:] {\n        if !unicode.Is(unicode.Mn, r) {\n            gr++\n        }\n    }\n    return gr\n}\n\n\n5 m\u00f8\u00f8se [6d f8 f8 73 65]\n7 \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22 [1d518 1d52b 1d526 1d520 1d52c 1d521 1d522]\n4 J\u0332o\u0332s\u0332\u00e9\u0332 [4a 332 6f 332 73 332 65 301 332]\n\n", "explain": "Output:\nOutput:\nGo does not have language or library features to recognize graphemes directly.  For example, it does not provide functions implementing Unicode Standard Annex #29, Unicode Text Segmentation.  It does however have convenient functions for recognizing Unicode character categories, and so an expected subset of grapheme possibilites is easy to recognize.  Here is a solution recognizing the category \"Mn\", which includes the combining characters used in the task example.\nOutput:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program stringLength.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResultByte:        .asciz \"===Byte Length===\u00a0: @ \\n\"\nsMessResultChar:        .asciz \"===Character Length===\u00a0: @ \\n\"\nszString1:          .asciz \"m\u00f8\u00f8se\u20ac\"\nszCarriageReturn:   .asciz \"\\n\"\n \n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                 @ entry of program \n    ldr r0,iAdrszString1\n    bl affichageMess                  @ display string\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    \n    ldr r0,iAdrszString1\n    mov r1,#0\n1:                                    @ loop compute length bytes\n    ldrb r2,[r0,r1]\n    cmp r2,#0\n    addne r1,#1\n    bne 1b\n    \n    mov r0,r1                         @ result display\n    ldr r1,iAdrsZoneConv\n    bl conversion10                   @ call decimal conversion\n    ldr r0,iAdrsMessResultByte\n    ldr r1,iAdrsZoneConv              @ insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n\n    ldr r0,iAdrszString1\n    mov r1,#0\n    mov r3,#0\n2:                                    @ loop compute length characters\n    ldrb r2,[r0,r1]\n    cmp r2,#0\n    beq 6f\n    and r2,#0b11100000                @ 3 bytes\u00a0?\n    cmp r2,#0b11100000\n    bne 3f\n    add r3,#1\n    add r1,#3\n    b 2b\n3:\n    and r2,#0b11000000                @ 2 bytes\u00a0?\n    cmp r2,#0b11000000\n    bne 4f\n    add r3,#1\n    add r1,#2\n    b 2b\n4:                                    @ else 1 byte\n    add r3,#1\n    add r1,#1\n    b 2b\n\n6:\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl conversion10                   @ call decimal conversion\n    ldr r0,iAdrsMessResultChar\n    ldr r1,iAdrsZoneConv              @ insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n100:                                  @ standard end of the program \n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResultByte:      .int sMessResultByte\niAdrsMessResultChar:      .int sMessResultChar\niAdrszString1:            .int szString1\niAdrsZoneConv:            .int sZoneConv\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nm\u00f8\u00f8se\u20ac\n===Byte Length===\u00a0: 10\n===Character Length===\u00a0: 6\n\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n\n.data \n\t#.asciiz automatically adds the NULL terminator character, \\0 for us.\n\tstring: .asciiz \"Nice string you got there!\"\n\n.text\nmain:\n\tla $a1,string           #load the beginning address of the string.\n\t\nloop:\n\tlb $a2,($a1)            #load byte (i.e. the char) at $a1 into $a2\n\taddi $a1,$a1,1          #increment $a1\n\tbeqz $a2,exit_procedure #see if we've hit the NULL char yet\n\taddi $a0,$a0,1          #increment counter\n\tj loop                  #back to start\n\t\nexit_procedure:\n\tli $v0,1                #set syscall to print integer\n\tsyscall                 \n\t\n\tli $v0,10               #set syscall to cleanly exit EXIT_SUCCESS\n\tsyscall\n", "explain": "This only supports ASCII encoding, so it'll return both byte length and char length.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\nByte Length[edit]\n\"J\u0332o\u0332s\u0332\u00e9\u0332\".bytesize\nCharacter Length[edit]\n\"J\u0332o\u0332s\u0332\u00e9\u0332\".chars.length\nGrapheme Length[edit]\n\"J\u0332o\u0332s\u0332\u00e9\u0332\".grapheme_clusters.length\nCode Set Independence[edit]\n\n\nTo run these programs, you must convert them to different encodings.\n\nIf you use Emacs: Paste each program into Emacs. The magic comment, like -*- coding: iso-8859-1 -*-, will tell Emacs to save with that encoding.\nIf your text editor saves UTF-8: Convert the file before running it. For example:$ ruby -pe '$_.encode!(\"iso-8859-1\", \"utf-8\")' scratch.rb | ruby\n\nWorks with: Ruby version 1.9\n\n\nProgram\n\nOutput\n\n\n# -*- coding: iso-8859-1 -*-\ns = \"m\u00f8\u00f8se\"\nputs \"Byte length: %d\"\u00a0% s.bytesize\nputs \"Character length: %d\"\u00a0% s.length\n\nByte length: 5\nCharacter length: 5\n\n\n# -*- coding: utf-8 -*-\ns = \"m\u00f8\u00f8se\"\nputs \"Byte length: %d\"\u00a0% s.bytesize\nputs \"Character length: %d\"\u00a0% s.length\n\nByte length: 7\nCharacter length: 5\n\n\n# -*- coding: gb18030 -*-\ns = \"m\u00f8\u00f8se\"\nputs \"Byte length: %d\"\u00a0% s.bytesize\nputs \"Character length: %d\"\u00a0% s.length\n\nByte length: 11\nCharacter length: 5\n\nRuby 1.8[edit]\n\n/./n uses no multibyte encoding.\n/./e uses EUC-JP.\n/./s uses Shift-JIS or Windows-31J.\n/./u uses UTF-8.\n\n# -*- coding: utf-8 -*-\n\nclass String\n  # Define String#bytesize for Ruby 1.8.6.\n  unless method_defined?(:bytesize)\n    alias bytesize length\n  end\nend\n\ns = \"\u6587\u5b57\u5316\u3051\"\nputs \"Byte length: %d\"\u00a0% s.bytesize\nputs \"Character length: %d\"\u00a0% s.gsub(/./u, ' ').size\n", "explain": "UTF8 is the default encoding in Ruby.\nThe next examples show the byte length and character length of \"m\u00f8\u00f8se\" in different encodings.\nThe next example works with both Ruby 1.8 and Ruby 1.9. In Ruby 1.8, the strings have no encodings, and String#length is the byte length. In Ruby 1.8, the regular expressions knows three Japanese encodings.\nThen either string.scan(/./u).size or string.gsub(/./u, ' ').size counts the UTF-8 characters in string.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Rust", "code": "\nByte Length[edit]\nfn main() {\n    let s = \"\u6587\u5b57\u5316\u3051\";  // UTF-8\n    println!(\"Byte Length: {}\", s.len());\n}\nCharacter Length[edit]\nfn main() {\n    let s = \"\u6587\u5b57\u5316\u3051\";  // UTF-8\n    println!(\"Character length: {}\", s.chars().count());\n}\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Swift", "code": "\nGrapheme Length[edit]\n\nWorks with: Swift version 2.x\nlet numberOfCharacters = \"m\u00f8\u00f8se\".characters.count  // 5\nWorks with: Swift version 1.2\nlet numberOfCharacters = count(\"m\u00f8\u00f8se\")            // 5\nWorks with: Swift version 1.0-1.1\nlet numberOfCharacters = countElements(\"m\u00f8\u00f8se\")    // 5\nCharacter Length[edit]\n\nWorks with: Swift version 2.x\nlet numberOfCodePoints = \"m\u00f8\u00f8se\".unicodeScalars.count           // 5\nWorks with: Swift version 1.2\nlet numberOfCodePoints = count(\"m\u00f8\u00f8se\".unicodeScalars)          // 5\nWorks with: Swift version 1.0-1.1\nlet numberOfCodePoints = countElements(\"m\u00f8\u00f8se\".unicodeScalars)  // 5\nByte Length[edit]\n\nWorks with: Swift version 2.x\nlet numberOfBytesUTF8 = \"m\u00f8\u00f8se\".utf8.count           // 7\nWorks with: Swift version 1.2\nlet numberOfBytesUTF8 = count(\"m\u00f8\u00f8se\".utf8)          // 7\nWorks with: Swift version 1.0-1.1\nlet numberOfBytesUTF8 = countElements(\"m\u00f8\u00f8se\".utf8)  // 7\n\nWorks with: Swift version 2.x\nlet numberOfBytesUTF16 = \"m\u00f8\u00f8se\".utf16.count * 2           // 10\nWorks with: Swift version 1.2\nlet numberOfBytesUTF16 = count(\"m\u00f8\u00f8se\".utf16) * 2          // 10\nWorks with: Swift version 1.0-1.1\nlet numberOfBytesUTF16 = countElements(\"m\u00f8\u00f8se\".utf16) * 2  // 10\n", "explain": "Swift has a concept of \"character\" that goes beyond Unicode code points. A Character is a \"Unicode grapheme cluster\", which can consist of one or more Unicode code points.\nTo count \"characters\" (Unicode grapheme clusters):\nTo count Unicode code points:\nThis depends on which encoding you want to use.\nFor length in UTF-8, count the number of UTF-8 code units:\nFor length in UTF-16, count the number of UTF-16 code units, and multiply by 2:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "R", "code": "\nByte length[edit]\na <- \"m\\u00f8\\u00f8se\"\nprint(nchar(a, type=\"bytes\"))  # print 7\nCharacter length[edit]\nprint(nchar(a, type=\"chars\"))  # print 5\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "COBOL", "code": "\nByte Length[edit]\nFUNCTION BYTE-LENGTH(str)\n\n\nWorks with: GNU Cobol\nLENGTH OF str\n\nWorks with: GNU Cobol\nWorks with: Visual COBOL\nFUNCTION LENGTH-AN(str)\n\nCharacter Length[edit]\nFUNCTION LENGTH(str)\n\n", "explain": "Alternative, non-standard extensions:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\n\n", "explain": "same as #VBScript.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Ada", "code": "\nWorks with: GCC version 4.1.2\nByte Length[edit]\nStr    : String := \"Hello World\";\nLength : constant Natural := Str'Size / 8;\n\n\nCharacter Length[edit]\nLatin_1_Str    : String           := \"Hello World\";\nUCS_16_Str     : Wide_String      := \"Hello World\";\nUnicode_Str    : Wide_Wide_String := \"Hello World\";\nLatin_1_Length : constant Natural := Latin_1_Str'Length;\nUCS_16_Length  : constant Natural := UCS_16_Str'Length;\nUnicode_Length : constant Natural := Unicode_Str'Length;\n\n\n", "explain": "The 'Size attribute returns the size of an object in bits. Provided that under \"byte\" one understands an octet of bits, the length in \"bytes\" will be 'Size divided to 8. Note that this  is not necessarily the machine storage unit. In order to make the program portable, System.Storage_Unit should be used instead of \"magic number\" 8. System.Storage_Unit yields the number of bits in a storage unit on the current machine. Further, the length of a string object is not the length of what the string contains in whatever measurement units. String as an object may have a \"dope\" to keep the array bounds. In fact the object length can even be 0, if the compiler optimized the object away. So in most cases \"byte length\" makes no sense in Ada.\nThe attribute 'Length yields the number of elements of an array. Since strings in Ada are arrays of characters, 'Length is the string length. Ada supports strings of Latin-1, UCS-16 and full Unicode characters. In the example above character length of all three strings is 11. The length of the objects in bits will differ.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Julia", "code": "\n\nByte Length[edit]\nsizeof(\"m\u00f8\u00f8se\") # 7\nsizeof(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\") # 28\nsizeof(\"J\u0332o\u0332s\u0332\u00e9\u0332\") # 13\nCharacter Length[edit]\nlength(\"m\u00f8\u00f8se\") # 5\nlength(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\") # 7\nlength(\"J\u0332o\u0332s\u0332\u00e9\u0332\") # 8\nGrapheme Length[edit]\nimport Unicode\nlength(Unicode.graphemes(\"m\u00f8\u00f8se\")) # 5\nlength(Unicode.graphemes(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\")) # 7\nlength(Unicode.graphemes(\"J\u0332o\u0332s\u0332\u00e9\u0332\")) # 4\n", "explain": "Julia encodes strings as UTF-8, so the byte length (via sizeof) will be different from the string length (via length) only if the string contains non-ASCII characters.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "SAS", "code": "\ndata _null_;\n   a=\"Hello, World!\";\n   b=length(c);\n   put _all_;\nrun;\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n\nfun main() {\n    val s = \"Jos\u00e9\"\n    println(\"The char length is ${s.length}\")\n    println(\"The byte length is ${Char.SIZE_BYTES * s.length}\")\n}\n\nOutput:\nThe char length is 4\nThe byte length is 8\n\n", "explain": "As in Java, a string in Kotlin is essentially a sequence of UTF-16 encoded characters and the 'length' property simply returns the number of such characters in the string. Surrogates or graphemes are not treated specially for this purpose - they are just represented by the appropriate number of UTF-16 characters. \nAs each UTF-16 character occupies 2 bytes, it follows that the number of bytes occupied by the string will be twice the length:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Perl", "code": "\nByte Length[edit]\nWorks with: Perl version 5.8\n\nuse utf8; # so we can use literal characters like \u263a in source\nuse Encode qw(encode);\n\nprint length encode 'UTF-8', \"Hello, world! \u263a\";\n# 17. The last character takes 3 bytes, the others 1 byte each.\n\nprint length encode 'UTF-16', \"Hello, world! \u263a\";\n# 32. 2 bytes for the BOM, then 15 byte pairs for each character.\nCharacter Length[edit]\nWorks with: Perl version 5.X\nmy $length = length \"Hello, world!\";\nGrapheme Length[edit]\n\nWorks with: Perl version 5.12\nuse v5.12;\nmy $string = \"\\x{1112}\\x{1161}\\x{11ab}\\x{1100}\\x{1173}\\x{11af}\";  # \ud55c\uae00\nmy $len;\n$len++ while ($string =~ /\\X/g);\nprintf \"Grapheme length: %d\\n\", $len;\n\nOutput:\nGrapheme length: 2\n", "explain": "Strings in Perl consist of characters. Measuring the byte length therefore requires conversion to some binary representation (called encoding, both noun and verb).\nSince Perl 5.12, /\\X/ matches an extended grapheme cluster. See \"Unicode overhaul\" in perl5120delta and also UAX #29.\nPerl understands that \"\\x{1112}\\x{1161}\\x{11ab}\\x{1100}\\x{1173}\\x{11af}\" (\ud55c\uae00) contains 2 graphemes, just like \"\\x{d55c}\\x{ae00}\" (\ud55c\uae00). The longer string uses Korean combining jamo characters.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Objective-C", "code": "\n\nCharacter Length[edit]\n\n// Return the length in characters\n// XXX: does not (always) count Unicode characters (code points)! \nunsigned int numberOfCharacters = [@\"m\u00f8\u00f8se\" length];  // 5\n\nint realCharacterCount = [s lengthOfBytesUsingEncoding: NSUTF32StringEncoding] / 4;\nByte Length[edit]\n\nint byteCount = [@\"m\u00f8\u00f8se\" length] * 2; // 10\n\n// Return the number of bytes depending on the encoding,\n// here explicitly UTF-8\nunsigned numberOfBytes =\n   [@\"m\u00f8\u00f8se\" lengthOfBytesUsingEncoding: NSUTF8StringEncoding]; // 7\n", "explain": "In order to be not ambiguous about the encoding used in the string, we explicitly provide\nit in UTF-8 encoding. The string is \"m\u00f8\u00f8se\" (\u00f8 UTF-8 encoded is in hexadecimal C3 B8).\nObjective-C encodes strings in UTF-16, which represents each character (code point) with one or two 16-bit code units. This is a variable-length encoding scheme. The most commonly used characters are represented by one 16-bit code unit, while \"supplementary characters\" are represented by two (called a \"surrogate pair\").\nThe length method of NSString objects is not the length of that string in characters.  Instead, it only gives the number of 16-bit code units used to encode a string. This is not (always) the number of Unicode characters (code points) in the string.\nSince Mac OS X 10.6, CFString has methods for converting between supplementary characters and surrogate pair. However, the easiest way to get the number of characters is probably to encode it in UTF-32 (which is a fixed-length encoding) and divide by 4:\nObjective-C encodes strings in UTF-16, which represents each character with one or two 16-bit values. The length method of NSString objects returns the number of 16-bit values used to encode a string, so the number of bytes can be determined by doubling that number.\nAnother way to know the byte length of a string is to explicitly specify the charset we desire.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Lua", "code": "\nWorks with: Lua version 5.0+\n\nByte Length[edit]\n\nstr = \"Hello world\"\nlength = #str\n\nstr = \"Hello world\"\nlength = string.len(str)\nCharacter Length[edit]\n\nstr = \"Hello world\"\nlength = #str\n\nstr = \"Hello world\"\nlength = string.len(str)\n\nutf8.len(\"m\u00f8\u00f8se\")\nutf8.len(\"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\")\nutf8.len(\"J\u0332o\u0332s\u0332\u00e9\u0332\")\n\nOutput:\n5\n7\n8\n\n", "explain": "In Lua, a character is always the size of one byte so there is no difference between byte length and character length.\nByte length in UTF-8:\nor\nOnly valid for ASCII:\nor\nFor Unicode string, use utf8 module:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Scala", "code": "\nLibrary: Scala\nobject StringLength extends App {\n  val s1 = \"m\u00f8\u00f8se\"\n  val s3 = List(\"\\uD835\\uDD18\", \"\\uD835\\uDD2B\", \"\\uD835\\uDD26\",\n    \"\\uD835\\uDD20\", \"\\uD835\\uDD2C\", \"\\uD835\\uDD21\", \"\\uD835\\uDD22\").mkString\n  val s4 = \"J\\u0332o\\u0332s\\u0332e\\u0301\\u0332\"\n\n    List(s1, s3, s4).foreach(s => println(\n        s\"The string: $s, characterlength= ${s.length} UTF8bytes= ${\n      s.getBytes(\"UTF-8\").size\n    } UTF16bytes= ${s.getBytes(\"UTF-16LE\").size}\"))\n}\n\nOutput:\nThe string: m\u00f8\u00f8se, characterlength= 5 UTF8bytes= 7 UTF16bytes= 10\nThe string: \ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22, characterlength= 14 UTF8bytes= 28 UTF16bytes= 28\nThe string: J\u0332o\u0332s\u0332\u00e9\u0332, characterlength= 9 UTF8bytes= 14 UTF16bytes= 18\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "D", "code": "\nByte Length[edit]\nimport std.stdio;\n\nvoid showByteLen(T)(T[] str) {\n    writefln(\"Byte length: %2d -\u00a0%(%02x%)\",\n             str.length * T.sizeof, cast(ubyte[])str);\n}\n\nvoid main() {\n    string s1a = \"m\u00f8\u00f8se\"; // UTF-8\n    showByteLen(s1a);\n    wstring s1b = \"m\u00f8\u00f8se\"; // UTF-16\n    showByteLen(s1b);\n    dstring s1c = \"m\u00f8\u00f8se\"; // UTF-32\n    showByteLen(s1c);\n    writeln();\n\n    string s2a = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showByteLen(s2a);\n    wstring s2b = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showByteLen(s2b);\n    dstring s2c = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showByteLen(s2c);\n    writeln();\n\n    string s3a = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showByteLen(s3a);\n    wstring s3b = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showByteLen(s3b);\n    dstring s3c = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showByteLen(s3c);\n}\n\n\nOutput:\nByte length:  7 - 6dc3b8c3b87365\nByte length: 10 - 6d00f800f80073006500\nByte length: 20 - 6d000000f8000000f80000007300000065000000\n\nByte length: 28 - f09d9498f09d94abf09d94a6f09d94a0f09d94acf09d94a1f09d94a2\nByte length: 28 - 35d818dd35d82bdd35d826dd35d820dd35d82cdd35d821dd35d822dd\nByte length: 28 - 18d501002bd5010026d5010020d501002cd5010021d5010022d50100\n\nByte length: 14 - 4accb26fccb273ccb265cc81ccb2\nByte length: 18 - 4a0032036f00320373003203650001033203\nByte length: 36 - 4a000000320300006f000000320300007300000032030000650000000103000032030000\nCharacter Length[edit]\nimport std.stdio, std.range, std.conv;\n\nvoid showCodePointsLen(T)(T[] str) {\n    writefln(\"Character length: %2d -\u00a0%(%x\u00a0%)\",\n             str.walkLength(), cast(uint[])to!(dchar[])(str));\n}\n\nvoid main() {\n    string s1a = \"m\u00f8\u00f8se\"; // UTF-8\n    showCodePointsLen(s1a);\n    wstring s1b = \"m\u00f8\u00f8se\"; // UTF-16\n    showCodePointsLen(s1b);\n    dstring s1c = \"m\u00f8\u00f8se\"; // UTF-32\n    showCodePointsLen(s1c);\n    writeln();\n\n    string s2a = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showCodePointsLen(s2a);\n    wstring s2b = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showCodePointsLen(s2b);\n    dstring s2c = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    showCodePointsLen(s2c);\n    writeln();\n\n    string s3a = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showCodePointsLen(s3a);\n    wstring s3b = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showCodePointsLen(s3b);\n    dstring s3c = \"J\u0332o\u0332s\u0332\u00e9\u0332\";\n    showCodePointsLen(s3c);\n}\n\n\nOutput:\nCharacter length:  5 - 6d f8 f8 73 65\nCharacter length:  5 - 6d f8 f8 73 65\nCharacter length:  5 - 6d f8 f8 73 65\n\nCharacter length:  7 - 1d518 1d52b 1d526 1d520 1d52c 1d521 1d522\nCharacter length:  7 - 1d518 1d52b 1d526 1d520 1d52c 1d521 1d522\nCharacter length:  7 - 1d518 1d52b 1d526 1d520 1d52c 1d521 1d522\n\nCharacter length:  9 - 4a 332 6f 332 73 332 65 301 332\nCharacter length:  9 - 4a 332 6f 332 73 332 65 301 332\nCharacter length:  9 - 4a 332 6f 332 73 332 65 301 332\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nByte Length[edit]\n\nimport Data.Encoding\nimport Data.ByteString as B\n\nstrUTF8  :: ByteString \nstrUTF8  = encode UTF8  \"Hello World!\"\n\nstrUTF32 :: ByteString \nstrUTF32 = encode UTF32 \"Hello World!\"\n\nstrlenUTF8  = B.length strUTF8\nstrlenUTF32 = B.length strUTF32\n\nCharacter Length[edit]\nWorks with: GHCi version 6.6\nWorks with: Hugs\n\nstrlen = length \"Hello, world!\"\n\n", "explain": "It is not possible to determine the \"byte length\" of an ordinary string, because in Haskell, a string is a boxed list of unicode characters. So each character in a string is represented as whatever the compiler considers as the most efficient representation of a cons-cell and a unicode character, and not as a byte.\nFor efficient storage of sequences of bytes, there's Data.ByteString, which uses Word8 as a base type. Byte strings have an additional Data.ByteString.Char8 interface, which will truncate each Unicode Char to 8 bits as soon as it is converted to a byte string. However, this is not adequate for the task, because truncation simple will garble characters other than Latin-1, instead of encoding them into UTF-8, say.\nThere are several (non-standard, so far) Unicode encoding libraries available on Hackage. As an example, we'll use encoding-0.2, as Data.Encoding:\nThe base type Char defined by the standard is already intended for (plain) Unicode characters. \n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "PL/SQL", "code": "\n\nByte Length[edit]\nDECLARE\n  string VARCHAR2(50)\u00a0:= 'Hello, world!';\n  stringlength NUMBER;\nBEGIN\n  stringlength\u00a0:= LENGTHB(string);\nEND;\nCharacter Length[edit]\nDECLARE\n  string VARCHAR2(50)\u00a0:= 'Hello, world!';\n  stringlength NUMBER;\n  unicodelength NUMBER;\n  ucs2length NUMBER;\n  ucs4length NUMBER;\nBEGIN\n  stringlength\u00a0:= LENGTH(string);\n  unicodelength\u00a0:= LENGTHC(string);\n  ucs2length\u00a0:= LENGTH2(string);\n  ucs4length\u00a0:= LENGTH4(string);\nEND;\n", "explain": "LENGTH calculates length using characters as defined by the input character set.\nLENGTHB uses bytes instead of characters.\nLENGTHC uses Unicode complete characters. \nLENGTH2 uses UCS2 code points.\nLENGTH4 uses UCS4 code points.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nByte Length[edit]\nLenB(string|varname)\n\nCharacter Length[edit]\nLen(string|varname)\n\n", "explain": "Returns the number of bytes required to store a string in memory. Returns null if string|varname is null.\nReturns the length of the string|varname . Returns null if string|varname is null.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Scheme", "code": "\nByte Length[edit]\nWorks with: Gauche version 0.8.7 [utf-8,pthreads]\n\n(string-size \"Hello world\")\nWorks with: PLT Scheme version 4.2.4\n(bytes-length #\"Hello world\")\nCharacter Length[edit]\nWorks with: Gauche version 0.8.7 [utf-8,pthreads]\n\n  (string-length \"Hello world\")\n", "explain": "string-size function is only Gauche function.\nstring-length function is in R5RS, R6RS.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Apex", "code": "\nString myString = 'abcd';\nSystem.debug('Size of String', myString.length());\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\nCharacter Length[edit]\n$s = \"H\u00ebll\u00f3 W\u00f8r\u0142\u00f0\"\n$s.Length\nByte Length[edit]\nTranslation of: C#\n\n$s = \"H\u00ebll\u00f3 W\u00f8r\u0142\u00f0\"\n[System.Text.Encoding]::Unicode.GetByteCount($s)\n\n[System.Text.Encoding]::UTF8.GetByteCount($s)\n", "explain": "For UTF-16, which is the default in .NET and therefore PowerShell:\nFor UTF-8:\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Logo", "code": "\n\nprint count \"|Hello World| \u00a0; 11\nprint count \"m\u00f8\u00f8se           \u00a0; 5\nprint char 248  \u00a0; \u00f8 - implies ISO-Latin character set\n", "explain": "Logo is so old that only ASCII encoding is supported. Modern versions of Logo may have enhanced character set support.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\nByte Length[edit]\n<cfoutput>\n<cfset str = \"Hello World\">\n<cfset j = createObject(\"java\",\"java.lang.String\").init(str)>\n<cfset t = j.getBytes()>\n<p>#arrayLen(t)#</p>\n</cfoutput>\n\nCharacter Length[edit]\n#len(\"Hello World\")#\n\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "F#", "code": "\n\nByte Length[edit]\nopen System.Text\nlet byte_length str = Encoding.UTF8.GetByteCount(str)\n\nCharacter Length[edit]\n\"Hello, World\".Length\n\n", "explain": "This is delegated to the standard .Net framework string and encoding functions.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\nCharacter Length[edit]\nprintln \"Hello World!\".size()\nprintln \"m\u00f8\u00f8se\".size()\nprintln \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\".size()\nprintln \"J\u0332o\u0332s\u0332\u00e9\u0332\".size()\n\n\n12\n5\n14\n8\n\n\n", "explain": "Calculating \"Byte-length\" (by which one typically means \"in-memory storage size in bytes\") is not possible through the facilities of the Groovy language alone. Calculating \"Character length\" is built into the Groovy extensions to java.lang.String.\nOutput:\nNote: The Java \"String.length()\" method also works in Groovy, but \"size()\" is consistent with usage in other sequential or composite types.\n"}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\nfn printResults(alloc: std.mem.Allocator, string: []const u8) !void {\n    const cnt_codepts_utf8 = try std.unicode.utf8CountCodepoints(string);\n    // There is no sane and portable extended ascii, so the best\n    // we get is counting the bytes and assume regular ascii.\n    const cnt_bytes_utf8 = string.len;\n    const stdout_wr = std.io.getStdOut().writer();\n    try stdout_wr.print(\"utf8  codepoints = {d}, bytes = {d}\\n\", .{ cnt_codepts_utf8, cnt_bytes_utf8 });\n\n    const utf16str = try std.unicode.utf8ToUtf16LeWithNull(alloc, string);\n    const cnt_codepts_utf16 = try std.unicode.utf16CountCodepoints(utf16str);\n    const cnt_2bytes_utf16 = try std.unicode.calcUtf16LeLen(string);\n    try stdout_wr.print(\"utf16 codepoints = {d}, bytes = {d}\\n\", .{ cnt_codepts_utf16, 2 * cnt_2bytes_utf16 });\n}\n\npub fn main() !void {\n    var arena_instance = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n    defer arena_instance.deinit();\n    const arena = arena_instance.allocator();\n    const string1: []const u8 = \"Hello, world!\";\n    try printResults(arena, string1);\n    const string2: []const u8 = \"m\u00f8\u00f8se\";\n    try printResults(arena, string2);\n    const string3: []const u8 = \"\ud835\udd18\ud835\udd2b\ud835\udd26\ud835\udd20\ud835\udd2c\ud835\udd21\ud835\udd22\";\n    try printResults(arena, string3);\n    // \\u{332} is underscore of previous character, which the browser may not\n    // copy correctly\n    const string4: []const u8 = \"J\\u{332}o\\u{332}s\\u{332}e\\u{301}\\u{332}\";\n    try printResults(arena, string4);\n}\n\nOutput:\nutf8  codepoints = 13, bytes = 13\nutf16 codepoints = 13, bytes = 26\nutf8  codepoints = 5, bytes = 7\nutf16 codepoints = 5, bytes = 10\nutf8  codepoints = 7, bytes = 28\nutf16 codepoints = 7, bytes = 28\nutf8  codepoints = 9, bytes = 14\nutf16 codepoints = 9, bytes = 18\n\n\n\u2191 https://bugs.openjdk.org/browse/JDK-8291660\n\n\n\n\n\n", "explain": ""}, {"task_name": "String length", "task_url": "https://rosettacode.org/wiki/String_length", "task_cat": "String manipulation", "lang": "AWK", "code": "\nByte Length[edit]\n\nw=length(\"Hello, world!\")      # static string example\nx=length(\"Hello,\" s \" world!\") # dynamic string example\ny=length($1)                   # input field example\nz=length(s)                    # variable name example\n\n\n echo \"Hello, w\u00f8rld!\" | awk '{print length($0)}'   # 14\n\n#!/usr/bin/awk -f\n{print\"The length of this line is \"length($0)}\n\n", "explain": "From within any code block:\nAd hoc program from command line:\nFrom executable script: (prints for every line arriving on stdin)\n"}]