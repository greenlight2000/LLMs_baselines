[{"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Python", "code": "\nfrom calendar import weekday, SUNDAY\n\n[year for year in range(2008, 2122) if weekday(year, 12, 25) == SUNDAY]\n\nOutput:\n[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\n\nWorks with: Python version 3.7\n'''Days of the week'''\n\nfrom datetime import date\nfrom itertools import islice\n\n\n# xmasIsSunday\u00a0:: Int -> Bool\ndef xmasIsSunday(y):\n    '''True if Dec 25 in the given year is a Sunday.'''\n    return 6 == date(y, 12, 25).weekday()\n\n\n# main\u00a0:: IO ()\ndef main():\n    '''Years between 2008 and 2121 with 25 Dec on a Sunday'''\n\n    xs = list(filter(\n        xmasIsSunday,\n        enumFromTo(2008)(2121)\n    ))\n    total = len(xs)\n    print(\n        fTable(main.__doc__ + ':\\n\\n' + '(Total ' + str(total) + ')\\n')(\n            lambda i: str(1 + i)\n        )(str)(index(xs))(\n            enumFromTo(0)(total - 1)\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# index (!!)\u00a0:: [a] -> Int -> a\ndef index(xs):\n    '''Item at given (zero-based) index.'''\n    return lambda n: None if 0 > n else (\n        xs[n] if (\n            hasattr(xs, \"__getitem__\")\n        ) else next(islice(xs, n, None))\n    )\n\n\n\n#  FORMATTING ---------------------------------------------\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN --\nif __name__ == '__main__':\n    main()\n\nOutput:\nYears between 2008 and 2121 with 25 Dec on a Sunday:\n\n(Total 17)\n\n 1 -> 2011\n 2 -> 2016\n 3 -> 2022\n 4 -> 2033\n 5 -> 2039\n 6 -> 2044\n 7 -> 2050\n 8 -> 2061\n 9 -> 2067\n10 -> 2072\n11 -> 2078\n12 -> 2089\n13 -> 2095\n14 -> 2101\n15 -> 2107\n16 -> 2112\n17 -> 2118\n", "explain": "The function calendar.weekday accepts all dates between 1/1/1 and 9999/12/31, and uses the proleptic Gregorian calendar before adoption of the Gregorian calendar in 1582. There is no gap between 1582/10/4 and 1582/10/15, as can be seen with print(calendar.calendar(1582)).\n\nOr, in terms of datetime:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "C", "code": "\n\n#include <stdio.h>\n\n/* Calculate day of week in proleptic Gregorian calendar. Sunday == 0. */\nint wday(int year, int month, int day)\n{\n\tint adjustment, mm, yy;\n\n\tadjustment = (14 - month) / 12;\n\tmm = month + 12 * adjustment - 2;\n\tyy = year - adjustment;\n\treturn (day + (13 * mm - 1) / 5 +\n\t\tyy + yy / 4 - yy / 100 + yy / 400) % 7;\n}\n\nint main()\n{\n\tint y;\n\n\tfor (y = 2008; y <= 2121; y++) {\n\t\tif (wday(y, 12, 25) == 0) printf(\"%04d-12-25\\n\", y);\n\t}\n\n\treturn 0;\n}\n\n", "explain": "Because of problems with various C libraries (such as time_t overflowing during 2038, or strptime() or mktime() not filling in tm_wday), this program uses Zeller's Rule to calculate day of week.\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "C++", "code": "\n#include <chrono>\n#include <ranges>\n#include <iostream>\n\nint main() {\n    std::cout << \"Yuletide holidays must be allowed in the following years:\\n\";\n    for (int year : std::views::iota(2008, 2121)\n               | std::views::filter([](auto year) {\n                    if (std::chrono::weekday{\n                            std::chrono::year{year}/std::chrono::December/25}\n                            == std::chrono::Sunday) {\n                        return true;\n                    }\n                    return false;\n                })) {\n        std::cout << year << '\\n';\n    }\n}\n\n\nOutput:\nYuletide holidays must be allowed in the following years:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Java", "code": "\nimport static java.util.Calendar.*;\nimport java.util.Calendar;\nimport java.util.Date;\nimport java.util.GregorianCalendar;\n\npublic class Yuletide{\n\tpublic static void main(String[] args) {\n\t\tCalendar calendar;\n        int count = 1;\n        for (int year = 2008; year <= 2121; year++) {\n            calendar = new GregorianCalendar(year, DECEMBER, 25);\n            if (calendar.get(DAY_OF_WEEK) == SUNDAY) {\n                if (count != 1)\n                    System.out.print(\", \");\n                System.out.printf(\"%d\", calendar.get(YEAR));\n                count++;\n            }\n        }\n\t}\n}\n\n\nOutput:\n2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 2008; i <= 2121; i++)\n        {\n            DateTime date = new DateTime(i, 12, 25);\n            if (date.DayOfWeek == DayOfWeek.Sunday)\n            {\n                Console.WriteLine(date.ToString(\"dd MMM yyyy\"));\n            }\n        }\n    }\n}\n\n\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string[] days = Enumerable.Range(2008, 2121 - 2007)\n            .Select(year => new DateTime(year, 12, 25))\n            .Where(day => day.DayOfWeek == DayOfWeek.Sunday)\n            .Select(day => day.ToString(\"dd MMM yyyy\")).ToArray();\n\n        foreach (string day in days) Console.WriteLine(day);\n    }\n}\nLambda expressions FTW:\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Enumerable.Range(2008, 113).ToList()\n        .ConvertAll(ent => new DateTime(ent, 12, 25))\n        .Where(ent => ent.DayOfWeek.Equals(DayOfWeek.Sunday)).ToList()\n        .ForEach(ent => Console.WriteLine(ent.ToString(\"dd MMM yyyy\")));\n    }\n}\n\n\nOutput:\n25 Dec 2011\n25 Dec 2016\n25 Dec 2022\n25 Dec 2033\n25 Dec 2039\n25 Dec 2044\n25 Dec 2050\n25 Dec 2061\n25 Dec 2067\n25 Dec 2072\n25 Dec 2078\n25 Dec 2089\n25 Dec 2095\n25 Dec 2101\n25 Dec 2107\n25 Dec 2112\n25 Dec 2118\n", "explain": "Using LINQ:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "JavaScript", "code": "\nES5[edit]\nIteration[edit]\nfor (var year = 2008; year <= 2121; year++){\n    var xmas = new Date(year, 11, 25)\n    if ( xmas.getDay() === 0 )\n        console.log(year)\n}\n\n\nOutput:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\nFunctional composition[edit]\n(function () {\n    'use strict';\n\n    // isXmasSunday\u00a0:: Integer -> Bool\n    function isXmasSunday(year) {\n        return (new Date(year, 11, 25))\n            .getDay() === 0;\n    }\n\n    // range\u00a0:: Int -> Int -> [Int]\n    function range(m, n) {\n        return Array.apply(null, Array(n - m + 1))\n            .map(function (_, i) {\n                return m + i;\n            });\n    }\n\n    return range(2008, 2121)\n        .filter(isXmasSunday);\n\n})();\n\n\nOutput:\n[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, \n2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\nES6[edit]\n(() => {\n    \"use strict\";\n\n    // main\u00a0:: IO ()\n    const main = () => {\n        const\n            xs = enumFromTo(2008)(2121)\n            .filter(xmasIsSunday);\n\n        return (\n            console.log(xs),\n            xs\n        );\n    };\n\n\n    // xmasIsSunday\u00a0:: Int -> Bool\n    const xmasIsSunday = year =>\n        (new Date(year, 11, 25))\n        .getDay() === 0;\n\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = m =>\n        n => Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "SQL", "code": "\nOracle[edit]\n\nselect extract(year from dt) as year_with_xmas_on_sunday\nfrom   ( \n         select  add_months(date '2008-12-25', 12 * (level - 1)) as dt\n         from    dual\n         connect by level <= 2121 - 2008 + 1\n       ) \nwhere  to_char(dt, 'Dy', 'nls_date_language=English') = 'Sun'\norder  by 1\n;\n\n\nOutput:\nYEAR_WITH_XMAS_ON_SUNDAY\n------------------------\n                    2011\n                    2016\n                    2022\n                    2033\n                    2039\n                    2044\n                    2050\n                    2061\n                    2067\n                    2072\n                    2078\n                    2089\n                    2095\n                    2101\n                    2107\n                    2112\n                    2118\n\n17 rows selected.\n\nwhere dt - trunc(dt, 'iw') = 6\nSQLite3[edit]\nWITH RECURSIVE cte AS (\n    SELECT DATE('2008-12-25', '+'||(12*0)||' months') as dt, 1 AS level\n    UNION  ALL\n    SELECT DATE('2008-12-25', '+'||(12*level)||' months') as dt, c.level + 1\n    FROM   cte c\n    WHERE c.level <= 2121 - 2008 + 1\n    )\n SELECT strftime('%Y', dt)\n FROM   cte\n where  strftime('%w', dt) = '0';\nPostgreSQL[edit]\n WITH RECURSIVE cte AS (\n    SELECT  date '2008-12-25' + interval '12 month' * 0 as dt, 1 AS level\n    UNION  ALL\n    SELECT date '2008-12-25' + interval '12 month' * level as dt, c.level + 1\n    FROM   cte c\n    WHERE c.level <= 2121 - 2008 + 1\n    )\n SELECT dt\n FROM   cte\n where  to_char(dt, 'Dy') = 'Sun';\n", "explain": "SQL has good support for date functions; care must be taken with NLS settings (globalization support), in the code below the date format language is passed in as an argument to the relevant function. (Or, see a variation that does not depend on language settings, after the output shown below.)\n\nAlternatively, the WHERE clause can be written in a way that avoids the complication of language settings. The (overloaded) TRUNC function, as applied to dates, takes a second argument indicating \"to what\" we must truncate. One option is 'iw' for \"ISO week\"; this truncates to the most recent Monday (the beginning of the ISO standard week, which is Monday through Sunday by definition). Like so (replace in the query above):\n\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "PHP", "code": "\n<?php\nfor($i=2008; $i<2121; $i++)\n{\n  $datetime = new DateTime(\"$i-12-25 00:00:00\");\n  if ( $datetime->format(\"w\") == 0 )\n  {\n     echo \"25 Dec $i is Sunday\\n\";\n  }\n}\n?>\n\nOutput:\n25 Dec 2011 is Sunday\n25 Dec 2016 is Sunday\n25 Dec 2022 is Sunday\n25 Dec 2033 is Sunday\n25 Dec 2039 is Sunday\n25 Dec 2044 is Sunday\n25 Dec 2050 is Sunday\n25 Dec 2061 is Sunday\n25 Dec 2067 is Sunday\n25 Dec 2072 is Sunday\n25 Dec 2078 is Sunday\n25 Dec 2089 is Sunday\n25 Dec 2095 is Sunday\n25 Dec 2101 is Sunday\n25 Dec 2107 is Sunday\n25 Dec 2112 is Sunday\n25 Dec 2118 is Sunday\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nPROGRAM YULETIDE\n \nIMPLICIT NONE\n  \nINTEGER :: day, year\n \nWRITE(*, \"(A)\", ADVANCE=\"NO\") \"25th of December is a Sunday in\"\nDO year = 2008, 2121\n   day = Day_of_week(25, 12, year)\n   IF (day == 1) WRITE(*, \"(I5)\", ADVANCE=\"NO\") year\nEND DO\n  \nCONTAINS\n \nFUNCTION Day_of_week(d, m, y)\n   INTEGER :: Day_of_week, j, k, mm, yy\n   INTEGER, INTENT(IN) :: d, m, y\n  \n   mm=m\n   yy=y\n   IF(mm.le.2) THEN\n      mm=mm+12\n      yy=yy-1\n   END IF\n   j = yy / 100\n   k = MOD(yy, 100)\n   Day_of_week = MOD(d + ((mm+1)*26)/10 + k + k/4 + j/4 + 5*j, 7)\nEND FUNCTION Day_of_week\n  \nEND PROGRAM YULETIDE\n\n\nOutput:\n 25th of December is a Sunday in 2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118\n\n", "explain": "Based on Forth example\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\nimport \"time\"\n\nfunc main() {\n    for year := 2008; year <= 2121; year++ {\n        if time.Date(year, 12, 25, 0, 0, 0, 0, time.UTC).Weekday() ==\n            time.Sunday {\n            fmt.Printf(\"25 December %d is Sunday\\n\", year)\n        }\n    }\n}\n\n\nOutput:\n25 December 2011 is Sunday\n25 December 2016 is Sunday\n25 December 2022 is Sunday\n25 December 2033 is Sunday\n25 December 2039 is Sunday\n25 December 2044 is Sunday\n25 December 2050 is Sunday\n25 December 2061 is Sunday\n25 December 2067 is Sunday\n25 December 2072 is Sunday\n25 December 2078 is Sunday\n25 December 2089 is Sunday\n25 December 2095 is Sunday\n25 December 2101 is Sunday\n25 December 2107 is Sunday\n25 December 2112 is Sunday\n25 December 2118 is Sunday\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Delphi", "code": "\nLibrary: sysutils always in uses clause in Delphi\nprocedure IsXmasSunday(fromyear, toyear: integer);\nvar\ni: integer;\nTestDate: TDateTime;\noutputyears: string;\nbegin\noutputyears := '';\n  for i:= fromyear to toyear do\n  begin\n    TestDate := EncodeDate(i,12,25);\n    if dayofweek(TestDate) = 1 then\n    begin\n      outputyears := outputyears + inttostr(i) + ' ';\n    end;\n  end;\n  //CONSOLE\n  //writeln(outputyears);\n  //GUI \n  form1.label1.caption := outputyears;\nend;\n\n\n\nOutput:\n2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118\n\n", "explain": "Procedure called with year range to test and outputs a space-delimited array of years to a label. There is no error check that fromyear < toyear, but this is easily added.\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Ruby", "code": "\nrequire 'date'\n\n(2008..2121).each {|year| puts \"25 Dec #{year}\" if Date.new(year, 12, 25).sunday? }\n\nOutput:\n25 Dec 2011\n25 Dec 2016\n25 Dec 2022\n25 Dec 2033\n25 Dec 2039\n25 Dec 2044\n25 Dec 2050\n25 Dec 2061\n25 Dec 2067\n25 Dec 2072\n25 Dec 2078\n25 Dec 2089\n25 Dec 2095\n25 Dec 2101\n25 Dec 2107\n25 Dec 2112\n25 Dec 2118\n\n\n(2008..2121).each {|year| puts \"25 Dec #{year}\" if Time.local(year, 12, 25).sunday?}\n\nOutput:\n25 Dec 2011\n25 Dec 2016\n25 Dec 2022\n25 Dec 2033\n25 Dec 2039\n25 Dec 2044\n25 Dec 2050\n25 Dec 2061\n25 Dec 2067\n25 Dec 2072\n25 Dec 2078\n25 Dec 2089\n25 Dec 2095\n25 Dec 2101\n25 Dec 2107\n25 Dec 2112\n25 Dec 2118\n\n", "explain": "Or using the Time class\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Rust", "code": "\nextern crate chrono;\n\nuse chrono::prelude::*;\n\nfn main() {\n    let years = (2008..2121).filter(|&y| Local.ymd(y, 12, 25).weekday() == Weekday::Sun).collect::<Vec<i32>>();\n    println!(\"Years = {:?}\", years);\n}\n\nYears = [2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\n\n", "explain": "Output:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Swift", "code": "\nimport Cocoa\n\nvar year=2008\nlet formatter=DateFormatter()\nformatter.dateFormat = \"yyyy-MM-dd\"\n\nlet gregorian:NSCalendar! = NSCalendar(calendarIdentifier: NSCalendar.Identifier.gregorian)\nwhile (year<2122){\n    var date:NSDate!=formatter.date(from: String(year)+\"-12-25\") as NSDate?\n    var components=gregorian.components(NSCalendar.Unit.weekday, from: date as Date)\n    var dayOfWeek:NSInteger=components.weekday!\n    if(dayOfWeek==1){\n        print(year)\n    }\n    year+=1 \n}\n\nOutput:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "R", "code": "\nyears <- 2008:2121\nxmas <- as.POSIXlt(paste0(years, '/12/25'))\nyears[xmas$wday==0]\n# 2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118\n\n# Also:\nxmas=seq(as.Date(\"2008/12/25\"), as.Date(\"2121/12/25\"), by=\"year\")\nas.numeric(format(xmas[weekdays(xmas)== 'Sunday'], \"%Y\"))\n\n# Still another solution, using ISOdate and weekdays\nwith(list(years=2008:2121), years[weekdays(ISOdate(years, 12, 25)) == \"Sunday\"])\n\n# Or with \"subset\"\nsubset(data.frame(years=2008:2121), weekdays(ISOdate(years, 12, 25)) == \"Sunday\")$years\n\n# Simply replace \"Sunday\" with whatever it's named in your country,\n# or set locale first, with\nSys.setlocale(cat=\"LC_ALL\", \"en\")\n\n# Under MS Windows, write instead\nSys.setlocale(\"LC_ALL\", \"English\")\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "COBOL", "code": "\n\n       program-id. dec25.\n       data division.\n       working-storage section.\n       1 work-date.\n        2 yr pic 9(4) value 2008.\n        2 mo-da pic 9(4) value 1225. *> Dec 25\n       1 wk-date redefines work-date pic 9(8).\n       1 binary.\n        2 int-date pic 9(8).\n        2 dow pic 9(4).\n       procedure division.\n           perform varying yr from 2008 by 1\n           until yr > 2121\n               compute int-date = function integer-of-date (wk-date)\n               compute dow = function mod ((int-date - 1) 7) + 1\n               if dow = 7  *> Sunday = 7 per ISO 8601 and ISO 1989\n                   display yr\n               end-if\n           end-perform\n           stop run\n           .\n       end program dec25.\n\n\nOutput:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n\n\n       identification division.            \n       program-id. dowtest.                \n       data division.                      \n       working-storage section.            \n       01  ws-inp-date   pic x(08).        \n       01  filler redefines ws-inp-date.   \n         03  ws-inp-year  pic 9(04).       \n       01  ws-dow        pic 9(05).              \n       procedure division.                       \n           move '00001225' to ws-inp-date        \n           perform test before                   \n           varying ws-inp-year from 2008 by +1   \n           until ws-inp-year > 2121            \n             call \"todow\" using                  \n                 by reference ws-inp-date        \n                 by reference ws-dow             \n                 if ws-dow = 1 then                  \n                   display 'year=' ws-inp-year \n                 end-if                              \n           end-perform                           \n           stop run.                             \n                                                 \n       end program dowtest.                      \n                                                 \n       identification division.                  \n       program-id.  todow.                       \n       environment division.                         \n       input-output section.                         \n       file-control.                                 \n       data division.                                \n       file section.                                 \n       working-storage section.  \n       01 tally pic 9(05).\n       01  wms-work-area.                            \n         03  wms-year       pic 9(04).               \n         03  wms-month      pic 9(02).               \n         03  wms-csys       pic 9(01) value 1.  \n         03  wms-sum        pic 9(05).\n       linkage section.                              \n       01  lkip-date.                                \n         03  lkip-date-year     pic 9(04).           \n         03  lkip-date-month    pic 9(02).           \n         03  lkip-date-day      pic 9(02).           \n       01  lkop-dow             pic 9(05).           \n         88  lkop-sunday                   value 1.  \n       procedure division using                      \n           by reference lkip-date                    \n           by reference lkop-dow                     \n           .                                                            \n                                                                        \n           if lkip-date-month < 3                                       \n             compute wms-month = lkip-date-month + 12                   \n             compute wms-year  = lkip-date-year - 1                     \n           else                                                         \n             compute wms-month = lkip-date-month                        \n             compute wms-year  = lkip-date-year                         \n           end-if                                                       \n                                                                        \n          compute wms-sum    =                           \n                          ( lkip-date-day + 2 * wms-month + wms-year    \n                          + function integer (6 * (wms-month + 1) / 10) \n                          + function integer ( wms-year / 4   )         \n                          - function integer ( wms-year / 100 )         \n                          + function integer ( wms-year / 400 )         \n                          + wms-csys )                             \n         compute lkop-dow = function mod (wms-sum, 7) + 1\n                          .                                             \n       end program todow.\n\n\nOutput:\nyear=2011\nyear=2016\nyear=2022\nyear=2033\nyear=2039\nyear=2044\nyear=2050\nyear=2061\nyear=2067\nyear=2072\nyear=2078\nyear=2089\nyear=2095\nyear=2101\nyear=2107\nyear=2112\nyear=2118\n\n", "explain": "Using Date Intrinsic Functions\nWithout Date Intrinsic Functions\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Ada", "code": "\nwith Ada.Calendar.Formatting;  use Ada.Calendar.Formatting;\nwith Ada.Text_IO;              use Ada.Text_IO;\n \nprocedure Yuletide is\nbegin\n   for Year in 2008..2121 loop\n      if Day_Of_Week (Time_Of (Year, 12, 25)) = Sunday then\n         Put_Line (Image (Time_Of (Year, 12, 25)));\n      end if;\n   end loop;\nend Yuletide;\n\n\nOutput:\n2011-12-25 00:00:00\n2016-12-25 00:00:00\n2022-12-25 00:00:00\n2033-12-25 00:00:00\n2039-12-25 00:00:00\n2044-12-25 00:00:00\n2050-12-25 00:00:00\n2061-12-25 00:00:00\n2067-12-25 00:00:00\n2072-12-25 00:00:00\n2078-12-25 00:00:00\n2089-12-25 00:00:00\n2095-12-25 00:00:00\n2101-12-25 00:00:00\n2107-12-25 00:00:00\n2112-12-25 00:00:00\n2118-12-25 00:00:00\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Julia", "code": "\nusing Dates\n\nlo, hi = 2008, 2121\nxmas = collect(Date(lo, 12, 25):Year(1):Date(hi, 12, 25))\nfilter!(xmas) do dt\n    dayofweek(dt) == Dates.Sunday\nend\n\nprintln(\"Years from $lo to $hi having Christmas on Sunday: \")\nforeach(println, year.(xmas))\n\n\nOutput:\nYears from 2008 to 2121 having Christmas on Sunday: \n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "SAS", "code": "\ndata _null_;\ndo y=2008 to 2121;\n    a=mdy(12,25,y);\n    if weekday(a)=1 then put y;\nend;\nrun;\n\n/* 2011 2016 2022 2033 2039 2044 2050 2061 2067\n   2072 2078 2089 2095 2101 2107 2112 2118 */\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nimport java.util.*\n\nfun main(args: Array<String>) {\n    println(\"Christmas day in the following years falls on a Sunday:\\n\")\n    val calendar = GregorianCalendar(2008, Calendar.DECEMBER, 25)\n    for (year in 2008..2121) {\n        if (Calendar.SUNDAY == calendar[Calendar.DAY_OF_WEEK]) println(year)\n        calendar.add(Calendar.YEAR, 1)\n    }\n}\n\n\nOutput:\nChristmas day in the following years falls on a Sunday:\n\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Perl", "code": "\n#! /usr/bin/perl -w\n\nuse Time::Local;\nuse strict;\n\nforeach my $i (2008 .. 2121)\n{\n  my $time = timelocal(0,0,0,25,11,$i);\n  my ($s,$m,$h,$md,$mon,$y,$wd,$yd,$is) = localtime($time);\n  if ( $wd == 0 )\n  {\n    print \"25 Dec $i is Sunday\\n\";\n  }\n}\n\nexit 0;\n\nOutput:\n25 Dec 2011 is Sunday\n25 Dec 2016 is Sunday\n25 Dec 2022 is Sunday\n25 Dec 2033 is Sunday\nDay too big - 25195 > 24855\nSec too small - 25195 < 78352\nSec too big - 25195 > 15247\nCannot handle date (0, 0, 0, 25, 11, 2038) at ./ydate.pl line 8\n\n\n#! /usr/bin/perl -w\n\nuse DateTime;\nuse strict;\n\nforeach my $i (2008 .. 2121)\n{\n  my $dt = DateTime->new( year   => $i,\n                          month  => 12,\n                          day    => 25\n                        );\n  if ( $dt->day_of_week == 7 )\n  {\n    print \"25 Dec $i is Sunday\\n\";\n  }\n}\n\nexit 0;\n\n#! /usr/bin/perl -w\n\nuse DateTime;\nuse strict;\n \nfor (2008 .. 2121) {\n  print \"25 Dec $_ is Sunday\\n\"\n    if DateTime->new(year => $_, month => 12, day => 25)->day_of_week == 7;\n}\n\nexit 0;\n\nOutput:\n25 Dec 2011 is Sunday\n25 Dec 2016 is Sunday\n25 Dec 2022 is Sunday\n25 Dec 2033 is Sunday\n25 Dec 2039 is Sunday\n25 Dec 2044 is Sunday\n25 Dec 2050 is Sunday\n25 Dec 2061 is Sunday\n25 Dec 2067 is Sunday\n25 Dec 2072 is Sunday\n25 Dec 2078 is Sunday\n25 Dec 2089 is Sunday\n25 Dec 2095 is Sunday\n25 Dec 2101 is Sunday\n25 Dec 2107 is Sunday\n25 Dec 2112 is Sunday\n25 Dec 2118 is Sunday\n\n\n#! /usr/bin/perl -w\n\nuse DateTime;\nuse strict;\n\nprint join \" \", grep { DateTime->new(year => $_, month => 12, day => 25)->day_of_week == 7 } (2008 .. 2121);\n\n0;\n\nOutput:\n2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118\n", "explain": "Using the DateTime module from CPAN:\nor shorter:\nAlternatively in one line using grep (read from right to left):\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Objective-C", "code": "\nWorks with: GNUstep\nWorks with: Cocoa\n#import <Foundation/Foundation.h>\n\nint main()\n{\n   @autoreleasepool {\n      for(NSUInteger i=2008; i<2121; i++)\n      {\n         NSCalendarDate *d = [[NSCalendarDate alloc] \n                              initWithYear: i\n                              month: 12\n                              day: 25\n                              hour: 0 minute: 0 second:0 \n                              timeZone: [NSTimeZone timeZoneWithAbbreviation:@\"CET\"] ];\n         if ( [d dayOfWeek] == 0 )\n         {  \n            printf(\"25 Dec %u is Sunday\\n\", i);\n         }\n      }\n   \n   }\n   return 0;\n}\n\nOutput:\n25 Dec 2011 is Sunday\n25 Dec 2016 is Sunday\n25 Dec 2022 is Sunday\n25 Dec 2033 is Sunday\n25 Dec 2039 is Sunday\n25 Dec 2044 is Sunday\n25 Dec 2050 is Sunday\n25 Dec 2061 is Sunday\n25 Dec 2067 is Sunday\n25 Dec 2072 is Sunday\n25 Dec 2078 is Sunday\n25 Dec 2089 is Sunday\n25 Dec 2095 is Sunday\n25 Dec 2101 is Sunday\n25 Dec 2107 is Sunday\n25 Dec 2112 is Sunday\n25 Dec 2118 is Sunday\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Prolog", "code": "\n\nmain()\u00a0:-\n    christmas_days_falling_on_sunday(2011, 2121, SundayList),\n    writeln(SundayList).\n\nchristmas_days_falling_on_sunday(StartYear, EndYear, SundayList)\u00a0:-\n    numlist(StartYear, EndYear, YearRangeList),\n    include(is_christmas_day_a_sunday, YearRangeList, SundayList).\n    \nis_christmas_day_a_sunday(Year)\u00a0:-\n    Date = date(Year, 12, 25),\n    day_of_the_week(Date, DayOfTheWeek),\n    DayOfTheWeek == 7.\n\nOutput:\n?- main.\n[2011,2016,2022,2033,2039,2044,2050,2061,2067,2072,2078,2089,2095,2101,2107,2112,2118]\ntrue.\n", "explain": "Works with SWI-Prolog;\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Lua", "code": "\n\nrequire(\"date\")\n\nfor year=2008,2121 do\n   if date(year, 12, 25):getweekday() == 1 then\n      print(year)\n   end\nend\n\n\nOutput:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n\nWithout external modules[edit]\n\nlocal dTab = {day = 25, month = 12}\nfor year = 2008, 2121 do\n    dTab.year = year\n    if os.date(\"%A\", os.time(dTab)) == \"Sunday\" then\n        print(year)\n    end\nend\n\n", "explain": "Library: LuaDate\nSame output as above\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Scala", "code": "\nLibrary: Scala\nJDK (discouraged)[edit]\nimport java.util.{ Calendar, GregorianCalendar }\nimport Calendar.{ DAY_OF_WEEK, DECEMBER, SUNDAY }\n\nobject DayOfTheWeek extends App {\n  val years = 2008 to 2121\n\n  val yuletide =\n    years.filter(year => (new GregorianCalendar(year, DECEMBER, 25)).get(DAY_OF_WEEK) == SUNDAY)\n\n  // If you want a test: (optional)\n  assert(yuletide ==\n    Seq(2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061,\n      2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118))\n\n  println(yuletide.mkString(\n    s\"${yuletide.length} Years between ${years.head} and ${years.last}\" +\n      \" including where Christmas is observed on Sunday:\\n\", \", \", \".\"))\n}\nJDK >= 8 (recommended)[edit]\nNaive programming[edit]\nimport java.time.{ DayOfWeek, LocalDate }\n\nobject DayOfTheWeek1 extends App {\n  val years = 2008 to 2121\n  val yuletide = for {\n    year <- years\n    if LocalDate.of(year, 12, 25).getDayOfWeek() == DayOfWeek.SUNDAY\n  } yield year\n\n  println(yuletide.mkString(\n    s\"${yuletide.count(p => true)} Years between ${years.head} and ${years.last}\" +\n      \" including where Christmas is observed on Sunday:\\n\", \", \", \".\"))\n}\nIdiomatic programming[edit]\nimport java.time.{ DayOfWeek, LocalDate }\n\nobject DayOfTheWeek1 extends App {\n  val years = 2008 to 2121\n  val yuletide =\n    years.filter(year => (LocalDate.of(year, 12, 25).getDayOfWeek() == DayOfWeek.SUNDAY))\n\n  // If you want a test: (optional)\n  assert(yuletide ==\n    Seq(2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061,\n      2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118))\n\n  println(yuletide.mkString(\n    s\"${yuletide.length} Years between ${years.head} and ${years.last}\" +\n      \" including where Christmas is observed on Sunday:\\n\", \", \", \".\"))\n}\nTail recursion[edit]\nimport java.time.{ DayOfWeek, LocalDate }\nimport scala.annotation.tailrec\n\nobject DayOfTheWeek3 extends App {\n  val years = 2008 to 2121\n  val yuletide = {\n    @tailrec\n    def inner(anni: List[Int], accu: List[Int]): List[Int] = {\n      if (anni == Nil) accu\n      else inner(anni.tail, accu ++\n        (if (LocalDate.of(anni.head, 12, 25).getDayOfWeek() == DayOfWeek.SUNDAY) List(anni.head)\n        else Nil))\n    }\n    inner(years.toList, Nil)\n  }\n\n  // If you want a test: (optional)\n  assert(yuletide ==\n    Seq(2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061,\n      2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118))\n\n  println(yuletide.mkString(\n    s\"${yuletide.length} Years between ${years.head} and ${years.last}\" +\n      \" including where Christmas is observed on Sunday:\\n\", \", \", \".\"))\n}\n\nOutput of all solutions:\nYears between 2008 and 2121 including when Christmas is observed on Sunday:\n2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118.\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.range, std.algorithm, std.datetime;\n\n    writeln(\"Christmas comes on a Sunday in the years:\\n\",\n            iota(2008, 2122)\n            .filter!(y => Date(y, 12, 25).dayOfWeek == DayOfWeek.sun));\n}\n\n\nOutput:\nChristmas comes on a Sunday in the years:\n[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Haskell", "code": "\n\nimport Data.Time (fromGregorian)\nimport Data.Time.Calendar.WeekDate (toWeekDate)\n\n--------------------- DAY OF THE WEEK --------------------\n\nisXmasSunday :: Integer -> Bool\nisXmasSunday year = 7 == weekDay\n  where\n    (_, _, weekDay) = toWeekDate $ fromGregorian year 12 25\n\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"Sunday 25 December \" <> show year\n      | year <- [2008 .. 2121],\n        isXmasSunday year\n    ]\n\n\nOutput:\nSunday 25 December 2011\nSunday 25 December 2016\nSunday 25 December 2022\nSunday 25 December 2033\nSunday 25 December 2039\nSunday 25 December 2044\nSunday 25 December 2050\nSunday 25 December 2061\nSunday 25 December 2067\nSunday 25 December 2072\nSunday 25 December 2078\nSunday 25 December 2089\nSunday 25 December 2095\nSunday 25 December 2101\nSunday 25 December 2107\nSunday 25 December 2112\nSunday 25 December 2118\n\nimport System.Time\n \nisXmasSunday :: Int -> Bool\nisXmasSunday year = ctWDay cal == Sunday\n  where\n    cal = toUTCTime $ toClockTime cal'\n    cal' =\n      CalendarTime\n      { ctYear = year\n      , ctMonth = December\n      , ctDay = 25\n      , ctHour = 0\n      , ctMin = 0\n      , ctSec = 0\n      , ctPicosec = 0\n      , ctWDay = Friday\n      , ctYDay = 0\n      , ctTZName = \"\"\n      , ctTZ = 0\n      , ctIsDST = False\n      }\n\nmain :: IO ()\nmain =\n  mapM_\n    putStrLn\n    [ \"25 December \" ++ show year ++ \" is Sunday\"\n    | year <- [2008 .. 2121] \n    , isXmasSunday year ]\n\n\nOutput: on 32-bit machine\n\n25 December 2011 is Sunday\n25 December 2016 is Sunday\n25 December 2022 is Sunday\n25 December 2033 is Sunday\n*** Exception: user error (Time.toClockTime: invalid input)\n\n\n25 December 2011 is Sunday\n25 December 2016 is Sunday\n25 December 2022 is Sunday\n25 December 2033 is Sunday\n25 December 2039 is Sunday\n25 December 2044 is Sunday\n25 December 2050 is Sunday\n25 December 2061 is Sunday\n25 December 2067 is Sunday\n25 December 2072 is Sunday\n25 December 2078 is Sunday\n25 December 2089 is Sunday\n25 December 2095 is Sunday\n25 December 2101 is Sunday\n25 December 2107 is Sunday\n25 December 2112 is Sunday\n25 December 2118 is Sunday\n", "explain": "Using the time library:\nThe built-in System.Time module can overflow at the Unix epoch in 2038:\nbut with 64 bit systems, running current versions of GHC:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Scheme", "code": "\n(define (day-of-week year month day)\n(if (< month 3)\n    (begin (set! month (+ month 12)) (set! year (- year 1))))\n(+ 1\n   (remainder (+ 5 day (quotient (* (+ 1 month) 13) 5)\n                 year (quotient year 4) (* (quotient year 100) 6) (quotient year 400))\n              7)))\n\n(define (task)\n(let loop ((y 2121) (v '()))\n(if (< y 2008)\n    v\n    (loop (- y 1)\n          (if (= 7 (day-of-week y 12 25))\n              (cons y v)\n              v)))))\n\n(task)\n; (2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118)\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "TypeScript", "code": "\nTranslation of: Minimal BASIC\n// Find years with Sunday Christmas\nvar f = 2008;\nvar t = 2121;\nconsole.log(`Sunday Christmases ${f} - ${t}`);\nfor (y = f; y <= t; y++) {\n  var x = (y * 365) + Math.floor(y / 4) - Math.floor(y / 100) + Math.floor(y / 400) - 6;\n  if (x\u00a0% 7 == 0)\n    process.stdout.write(`${y}\\t`);\n}\nprocess.stdout.write(\"\\n\");\n\nOutput:\nSunday Christmases 2008 - 2121\n2011\t2016\t2022\t2033\t2039\t2044\t2050\t2061\t2067\t2072\t2078\t2089\t2095\t2101\t2107\t2112\t2118\t\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "PowerShell", "code": "\n2008..2121 | Where-Object { (Get-Date $_-12-25).DayOfWeek -eq \"Sunday\" }\nFind Christmas holiday for any day and/or year[edit]\nfunction Get-ChristmasHoliday\n{\n    [CmdletBinding()]\n    [OutputType([PSCustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$false,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true,\n                   Position=0)]\n        [ValidateRange(1,9999)]\n        [int[]]\n        $Year = (Get-Date).Year\n    )\n\n    Process\n    {\n        [datetime]$christmas = Get-Date $Year/12/25\n\n        switch ($christmas.DayOfWeek)\n        {\n            \"Sunday\"   {[datetime[]]$dates = 1..5 | ForEach-Object {$christmas.AddDays($_)}}\n            \"Monday\"   {[datetime[]]$dates = $christmas, $christmas.AddDays(1)}\n            \"Saturday\" {[datetime[]]$dates = $christmas.AddDays(-2), $christmas.AddDays(-1)}\n            Default    {[datetime[]]$dates = $christmas.AddDays(-1), $christmas}\n        }\n\n        $dates | Group-Object  -Property Year |\n                 Select-Object -Property @{Name=\"Year\"    \u00a0; Expression={$_.Name}},\n                                         @{Name=\"DayOfWeek\"; Expression={$christmas.DayOfWeek}},\n                                         @{Name=\"Christmas\"; Expression={$christmas.ToString(\"MM/dd/yyyy\")}},\n                                         @{Name=\"DaysOff\" \u00a0; Expression={$_.Group | ForEach-Object {$_.ToString(\"MM/dd/yyyy\")}}}\n    }\n}\n\n2008..2121 | Get-ChristmasHoliday | where DayOfWeek -match Su\n\nOutput:\nYear DayOfWeek Christmas  DaysOff                                            \n---- --------- ---------  -------                                            \n2011    Sunday 12/25/2011 {12/26/2011, 12/27/2011, 12/28/2011, 12/29/2011...}\n2016    Sunday 12/25/2016 {12/26/2016, 12/27/2016, 12/28/2016, 12/29/2016...}\n2022    Sunday 12/25/2022 {12/26/2022, 12/27/2022, 12/28/2022, 12/29/2022...}\n2033    Sunday 12/25/2033 {12/26/2033, 12/27/2033, 12/28/2033, 12/29/2033...}\n2039    Sunday 12/25/2039 {12/26/2039, 12/27/2039, 12/28/2039, 12/29/2039...}\n2044    Sunday 12/25/2044 {12/26/2044, 12/27/2044, 12/28/2044, 12/29/2044...}\n2050    Sunday 12/25/2050 {12/26/2050, 12/27/2050, 12/28/2050, 12/29/2050...}\n2061    Sunday 12/25/2061 {12/26/2061, 12/27/2061, 12/28/2061, 12/29/2061...}\n2067    Sunday 12/25/2067 {12/26/2067, 12/27/2067, 12/28/2067, 12/29/2067...}\n2072    Sunday 12/25/2072 {12/26/2072, 12/27/2072, 12/28/2072, 12/29/2072...}\n2078    Sunday 12/25/2078 {12/26/2078, 12/27/2078, 12/28/2078, 12/29/2078...}\n2089    Sunday 12/25/2089 {12/26/2089, 12/27/2089, 12/28/2089, 12/29/2089...}\n2095    Sunday 12/25/2095 {12/26/2095, 12/27/2095, 12/28/2095, 12/29/2095...}\n2101    Sunday 12/25/2101 {12/26/2101, 12/27/2101, 12/28/2101, 12/29/2101...}\n2107    Sunday 12/25/2107 {12/26/2107, 12/27/2107, 12/28/2107, 12/29/2107...}\n2112    Sunday 12/25/2112 {12/26/2112, 12/27/2112, 12/28/2112, 12/29/2112...}\n2118    Sunday 12/25/2118 {12/26/2118, 12/27/2118, 12/28/2118, 12/29/2118...}\n\n\nGet-ChristmasHoliday -Year (2008..2121 | Get-Random)\n\nOutput:\nYear DayOfWeek Christmas  DaysOff                 \n---- --------- ---------  -------                 \n2110  Thursday 12/25/2110 {12/24/2110, 12/25/2110}\n\n\n(Get-Date | Get-ChristmasHoliday).DaysOff\n\nOutput:\n12/26/2016\n12/27/2016\n12/28/2016\n12/29/2016\n12/30/2016\n\n\n(Get-Date | Get-ChristmasHoliday).DaysOff | Get-Date\n\nOutput:\nMonday, December 26, 2016 12:00:00 AM\nTuesday, December 27, 2016 12:00:00 AM\nWednesday, December 28, 2016 12:00:00 AM\nThursday, December 29, 2016 12:00:00 AM\nFriday, December 30, 2016 12:00:00 AM\n\n", "explain": "Satisfy the task requirement:\nGet days off for a random year:\nGet days off for the current year using the Year property returned by Get-Date:\nGet days off for the current year as [DateTime] objects:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Logo", "code": "\n; Determine if a Gregorian calendar year is leap \nto leap? :year\n  output (and \n    equal? 0 modulo :year 4\n    not member? modulo :year 400 [100 200 300]\n  )\nend\n\n; Convert Gregorian calendar date to a simple day count from \n; day 1 = January 1, 1 CE \nto day_number :year :month :day\n  local \"elapsed make \"elapsed difference :year 1\n  output (sum  product 365 :elapsed\n              int quotient :elapsed 4\n              minus int quotient :elapsed 100\n              int quotient :elapsed 400\n              int quotient difference product 367 :month 362 12\n              ifelse lessequal? :month 2 0 ifelse leap? :year -1 -2\n              :day)\nend\n\n; Find the day of the week from a day number; 0 = Sunday through 6 = Saturday\nto day_of_week :day_number\n  output modulo :day_number 7\nend\n\n; True if the given day is a Sunday\nto sunday? :year :month :day\n  output equal? 0 day_of_week day_number :year :month :day\nend\n\n; Put it all together to answer the question posed in the problem\nprint filter [sunday?\u00a0? 12 25] iseq 2008 2121\nbye\n\nOutput:\n2011 2016 2022 2033 2039 2044 2050 2061 2067 2072 2078 2089 2095 2101 2107 2112 2118\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "ColdFusion", "code": "\n<cfloop from = \"2008\" to = \"2121\" index = \"i\">\n    <cfset myDate = createDate(i, 12, 25) />\n    <cfif dayOfWeek(myDate) eq 1>\n        December 25th falls on a Sunday in <cfoutput>#i#</cfoutput><br />\n    </cfif>\n</cfloop>\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "ABAP", "code": "\nreport zday_of_week\ndata: lv_start type i value 2007,\n      lv_n type i value 114,\n      lv_date type sy-datum,\n      lv_weekday type string,\n      lv_day type c,\n      lv_year type n length 4.\n\nwrite 'December 25 is a Sunday in: '.\ndo lv_n times.\n   lv_year = lv_start + sy-index.\n   concatenate lv_year '12' '25' into lv_date.\n   call function 'DATE_COMPUTE_DAY'\n    exporting date = lv_date\n    importing day  = lv_day.\n\n   select single langt from t246 into lv_weekday\n     where sprsl = sy-langu and\n     wotnr = lv_day.\n\n   if lv_weekday eq 'Sunday'.\n     write / lv_year.\n   endif.\nenddo.\n\n\nOutput:\nDecember 25 is a Sunday in:\n2011\n2016\n2022\n2033\n2039\n2044\n2050\n2061\n2067\n2072\n2078\n2089\n2095\n2101\n2107\n2112\n2118\n\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "F#", "code": "\nopen System\n\n[ 2008 .. 2121 ]\n|> List.choose (fun y -> if DateTime(y,12,25).DayOfWeek = DayOfWeek.Sunday then Some(y) else None)\n|> printfn \"%A\"\n\n\nOutput:\n[2011; 2016; 2022; 2033; 2039; 2044; 2050; 2061; 2067; 2072; 2078; 2089; 2095;\n 2101; 2107; 2112; 2118]\n", "explain": ""}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "Groovy", "code": "\n\ndef yuletide = { start, stop -> (start..stop).findAll { Date.parse(\"yyyy-MM-dd\", \"${it}-12-25\").format(\"EEE\") == \"Sun\" } }\n\n\nprintln yuletide(2008, 2121)\n\n\nOutput:\n[2011, 2016, 2022, 2033, 2039, 2044, 2050, 2061, 2067, 2072, 2078, 2089, 2095, 2101, 2107, 2112, 2118]\n", "explain": "Solution:\nTest program:\n"}, {"task_name": "Day of the week", "task_url": "https://rosettacode.org/wiki/Day_of_the_week", "task_cat": "Date and time", "lang": "AWK", "code": "\n# syntax: GAWK -f DAY_OF_THE_WEEK.AWK\n# runtime does not support years > 2037 on my 32-bit Windows XP O/S\nBEGIN {\n    for (i=2008; i<=2121; i++) {\n      x = strftime(\"%Y/%m/%d %a\",mktime(sprintf(\"%d 12 25 0 0 0\",i)))\n      if (x ~ /Sun/) { print(x) }\n    }\n}\n\n", "explain": ""}]