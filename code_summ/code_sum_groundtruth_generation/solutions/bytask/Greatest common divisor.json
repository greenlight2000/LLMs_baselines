[{"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Python", "code": "\nBuilt-in[edit]\nWorks with: Python version 2.6+\nfrom fractions import gcd\nWorks with: Python version 3.7\n\nfrom math import gcd\nIterative Euclid algorithm[edit]\ndef gcd_iter(u, v):\n    while v:\n        u, v = v, u\u00a0% v\n    return abs(u)\nRecursive Euclid algorithm[edit]\n\ndef gcd(u, v):\n    return gcd(v, u\u00a0% v) if v else abs(u)\nTests[edit]\n>>> gcd(0,0)\n0\n>>> gcd(0, 10) == gcd(10, 0) == gcd(-10, 0) == gcd(0, -10) == 10\nTrue\n>>> gcd(9, 6) == gcd(6, 9) == gcd(-6, 9) == gcd(9, -6) == gcd(6, -9) == gcd(-9, 6) == 3\nTrue\n>>> gcd(8, 45) == gcd(45, 8) == gcd(-45, 8) == gcd(8, -45) == gcd(-8, 45) == gcd(45, -8) == 1\nTrue\n>>> gcd(40902, 24140) # check Knuth\u00a0:)\n34\n\nIterative binary algorithm[edit]\n\ndef gcd_bin(u, v):\n    u, v = abs(u), abs(v) # u >= 0, v >= 0\n    if u < v:\n        u, v = v, u # u >= v >= 0\n    if v == 0:\n        return u\n   \n    # u >= v > 0\n    k = 1\n    while u & 1 == 0 and v & 1 == 0: # u, v - even\n        u >>= 1; v >>= 1\n        k <<= 1\n       \n    t = -v if u & 1 else u\n    while t:\n        while t & 1 == 0:\n            t >>= 1\n        if t > 0:\n            u = t\n        else:\n            v = -t\n        t = u - v\n    return u * k\nNotes on performance[edit]\n\n", "explain": "(Note that fractions.gcd is now deprecated in Python 3)\nInterpreter: Python 2.5\nSee The Art of Computer Programming by Knuth (Vol.2)\ngcd(40902, 24140)      takes us about 17 \u00b5sec (Euclid, not built-in)\ngcd_iter(40902, 24140) takes us about 11 \u00b5sec\ngcd_bin(40902, 24140)  takes us about 41 \u00b5sec\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "C", "code": "\nIterative Euclid algorithm[edit]\nint\ngcd_iter(int u, int v) {\n  if (u < 0) u = -u;\n  if (v < 0) v = -v;\n  if (v) while ((u %= v) && (v %= u));\n  return (u + v);\n}\n\nRecursive Euclid algorithm[edit]\nint gcd(int u, int v) {\nreturn (v != 0)?gcd(v, u%v):u;\n}\n\nIterative binary algorithm[edit]\nint gcd_bin(int u, int v) {\n  int t, k;\n\n  u = u < 0 ? -u : u; /* abs(u) */\n  v = v < 0 ? -v : v; \n  if (u < v) {\n    t = u;\n    u = v;\n    v = t;\n  }\n  if (v == 0)\n    return u;\n\n  k = 1;\n  while ((u & 1) == 0 && (v & 1) == 0) { /* u, v - even */\n    u >>= 1; v >>= 1;\n    k <<= 1;\n  }\n\n  t = (u & 1) ? -v : u;\n  while (t) {\n    while ((t & 1) == 0) \n      t >>= 1;\n\n    if (t > 0)\n      u = t;\n    else\n      v = -t;\n\n    t = u - v;\n  }\n  return u * k;        \n}\n\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "C++", "code": "\n#include <iostream>\n#include <numeric>\n\nint main() {\n    std::cout << \"The greatest common divisor of 12 and 18 is \" << std::gcd(12, 18) << \"\u00a0!\\n\";\n}\n\nLibrary: Boost\n#include <boost/math/common_factor.hpp>\n#include <iostream>\n\nint main() {\n   std::cout << \"The greatest common divisor of 12 and 18 is \" << boost::math::gcd(12, 18) << \"!\\n\";\n}\n\n\nOutput:\nThe greatest common divisor of 12 and 18 is 6!\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Java", "code": "\n\n/* recursive */\nint gcd(int a, int b) {\n    return (b == 0) ? a : gcd(b, a % b);\n}\n\nIterative[edit]\npublic static long gcd(long a, long b){\n   long factor= Math.min(a, b);\n   for(long loop= factor;loop > 1;loop--){\n      if(a % loop == 0 && b % loop == 0){\n         return loop;\n      }\n   }\n   return 1;\n}\n\nIterative Euclid's Algorithm[edit]\npublic static int gcd(int a, int b) //valid for positive integers.\n{\n\twhile(b > 0)\n\t{\n\t\tint c = a % b;\n\t\ta = b;\n\t\tb = c;\n\t}\n\treturn a;\n}\n\nOptimized Iterative[edit]\nstatic int gcd(int a,int b)\n\t{\n\t\tint min=a>b?b:a,max=a+b-min, div=min;\n\t\tfor(int i=1;i<min;div=min/++i)\n\t\t\tif(min%div==0&&max%div==0)\n\t\t\t\treturn div;\n\t\treturn 1;\n\t}\n\nIterative binary algorithm[edit]\nTranslation of: C/C++\npublic static long gcd(long u, long v){\n  long t, k;\n \n  if (v == 0) return u;\n  \n  u = Math.abs(u);\n  v = Math.abs(v); \n  if (u < v){\n    t = u;\n    u = v;\n    v = t;\n  }\n \n  for(k = 1; (u & 1) == 0 && (v & 1) == 0; k <<= 1){\n    u >>= 1; v >>= 1;\n  }\n \n  t = (u & 1) != 0 ? -v : u;\n  while (t != 0){\n    while ((t & 1) == 0) t >>= 1;\n \n    if (t > 0)\n      u = t;\n    else\n      v = -t;\n \n    t = u - v;\n  }\n  return u * k;\n}\n\nRecursive[edit]\npublic static long gcd(long a, long b){\n   if(a == 0) return b;\n   if(b == 0) return a;\n   if(a > b) return gcd(b, a % b);\n   return gcd(a, b % a);\n}\n\nBuilt-in[edit]\nimport java.math.BigInteger;\n\npublic static long gcd(long a, long b){\n   return BigInteger.valueOf(a).gcd(BigInteger.valueOf(b)).longValue();\n}\n\n", "explain": "From javax.swing.table.DefaultTableModel\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "C#", "code": "\nIterative[edit]\nstatic void Main()\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n/// <summary>\n/// Greatest Common Denominator using Euclidian Algorithm\n/// </summary>\nstatic int gcd(int a, int b)\n{\n    while (b != 0) b = a % (a = b);\n    return a;\n}\n\n\nGCD of 1 and 1 is 1\nGCD of 1 and 10 is 1\nGCD of 10 and 100 is 10\nGCD of 5 and 50 is 5\nGCD of 8 and 24 is 8\nGCD of 36 and 1 is 1\nGCD of 36 and 2 is 2\n..\nGCD of 36 and 16 is 4\nGCD of 36 and 17 is 1\nGCD of 36 and 18 is 18\n..\n..\nGCD of 36 and 33 is 3\nGCD of 36 and 34 is 2\nGCD of 36 and 35 is 1\n\nRecursive[edit]\nstatic void Main(string[] args)\n{\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 1, gcd(1, 1));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 1, 10, gcd(1, 10));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 10, 100, gcd(10, 100));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 5, 50, gcd(5, 50));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 8, 24, gcd(8, 24));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 17, gcd(36, 17));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 18, gcd(36, 18));\n\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, 19, gcd(36, 19));\n\tfor (int x = 1; x < 36; x++)\n\t{\n\t\tConsole.WriteLine(\"GCD of {0} and {1} is {2}\", 36, x, gcd(36, x));\n\t}\n\tConsole.Read();\n}\n \n// Greatest Common Denominator using Euclidian Algorithm\n// Gist: https://gist.github.com/SecretDeveloper/6c426f8993873f1a05f7\nstatic int gcd(int a, int b)\n{\t\n\treturn b==0 ? a : gcd(b, a % b);\n}\n\n\nGCD of 1 and 1 is 1\nGCD of 1 and 10 is 1\nGCD of 10 and 100 is 10\nGCD of 5 and 50 is 5\nGCD of 8 and 24 is 8\nGCD of 36 and 1 is 1\nGCD of 36 and 2 is 2\n..\nGCD of 36 and 16 is 4\nGCD of 36 and 17 is 1\nGCD of 36 and 18 is 18\n..\n..\nGCD of 36 and 33 is 3\nGCD of 36 and 34 is 2\nGCD of 36 and 35 is 1\n\n", "explain": "Example output:\nExample output:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "JavaScript", "code": "\n\nfunction gcd(a,b) {\n  a = Math.abs(a);\n  b = Math.abs(b);\n\n  if (b > a) {\n    var temp = a;\n    a = b;\n    b = temp; \n  }\n\n  while (true) {\n    a %= b;\n    if (a === 0) { return b; }\n    b %= a;\n    if (b === 0) { return a; }\n  }\n}\n\n\nfunction gcd_rec(a, b) {\n  return b ? gcd_rec(b, a % b) : Math.abs(a);\n}\n\n\nfunction GCD(arr) {\n  var i, y,\n      n = arr.length,\n      x = Math.abs(arr[0]);\n\n  for (i = 1; i < n; i++) {\n    y = Math.abs(arr[i]);\n\n    while (x && y) {\n      (x > y)\u00a0? x\u00a0%= y\u00a0: y\u00a0%= x;\n    }\n    x += y;\n  }\n  return x;\n}\n\n//For example:\nGCD([57,0,-45,-18,90,447]); //=> 3\n", "explain": "Iterative implementation\nRecursive.\nImplementation that works on an array of integers.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "SQL", "code": "\n\ndrop table tbl;\ncreate table tbl\n(\n        u       number,\n        v       number\n);\n\ninsert into tbl ( u, v ) values ( 20, 50 );\ninsert into tbl ( u, v ) values ( 21, 50 );\ninsert into tbl ( u, v ) values ( 21, 51 );\ninsert into tbl ( u, v ) values ( 22, 50 );\ninsert into tbl ( u, v ) values ( 22, 55 );\n\ncommit;\n\nwith\n        function gcd ( ui in number, vi in number )\n        return number\n        is\n                u number\u00a0:= ui;\n                v number\u00a0:= vi;\n                t number;\n        begin\n                while v > 0\n                loop\n                        t\u00a0:= u;\n                        u\u00a0:= v;\n                        v:= mod(t, v );\n                end loop;\n                return abs(u);\n        end gcd;\n        select u, v, gcd ( u, v )\n        from tbl\n/\n\nOutput:\nTable dropped.\n\n\nTable created.\n\n\n1 row created.\n\n\n1 row created.\n\n\n1 row created.\n\n\n1 row created.\n\n\n1 row created.\n\n\nCommit complete.\n\n\n         U          V   GCD(U,V)\n---------- ---------- ----------\n        20         50         10\n        21         50          1\n        21         51          3\n        22         50          2\n        22         55         11\n\n\nCREATE FUNCTION gcd (\n  @ui INT,\n  @vi INT\n) RETURNS INT\n\nAS\n\nBEGIN\n    DECLARE @t INT\n    DECLARE @u INT\n    DECLARE @v INT\n\t\n    SET @u = @ui\n    SET @v = @vi\n\n    WHILE @v > 0\n    BEGIN\n        SET @t = @u;\n        SET @u = @v;\n        SET @v = @t\u00a0% @v;\n    END;\n    RETURN abs( @u );\nEND\n\nGO\n\nCREATE TABLE tbl (\n  u INT,\n  v INT\n);\n \nINSERT INTO tbl ( u, v ) VALUES ( 20, 50 );\nINSERT INTO tbl ( u, v ) VALUES ( 21, 50 );\nINSERT INTO tbl ( u, v ) VALUES ( 21, 51 );\nINSERT INTO tbl ( u, v ) VALUES ( 22, 50 );\nINSERT INTO tbl ( u, v ) VALUES ( 22, 55 );\n\nSELECT u, v, dbo.gcd ( u, v )\n  FROM tbl;\n\nDROP TABLE tbl;\n\nDROP FUNCTION gcd;\n\nCREATE FUNCTION gcd(integer, integer)\nRETURNS integer\nLANGUAGE sql\nAS $function$\nWITH RECURSIVE x (u, v) AS (\n  SELECT ABS($1), ABS($2)\n  UNION\n  SELECT v, u\u00a0% v FROM x WHERE v > 0\n)\nSELECT min(u) FROM x;\n$function$\n\nOutput:\npostgres> select gcd(40902, 24140);\ngcd\n-----\n34\nSELECT 1\nTime: 0.012s\n\n", "explain": "Demonstration of Oracle 12c WITH Clause Enhancements\nDemonstration of SQL Server 2008\nPostgreSQL function using a recursive common table expression\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "PHP", "code": "\nIterative[edit]\nfunction gcdIter($n, $m) {\n    while(true) {\n        if($n == $m) {\n            return $m;\n        }\n        if($n > $m) {\n            $n -= $m;\n        } else {\n            $m -= $n;\n        }\n    }\n}\nRecursive[edit]\nfunction gcdRec($n, $m)\n{\n    if($m > 0)\n        return gcdRec($m, $n\u00a0% $m);\n    else\n        return abs($n);\n}\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "MATLAB", "code": "\nfunction [gcdValue] = greatestcommondivisor(integer1, integer2)\n   gcdValue = gcd(integer1, integer2);\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Fortran", "code": "\nWorks with: Fortran version 95 and later\nRecursive Euclid algorithm[edit]\nrecursive function gcd_rec(u, v) result(gcd)\n    integer             :: gcd\n    integer, intent(in) :: u, v\n    \n    if (mod(u, v) /= 0) then\n        gcd = gcd_rec(v, mod(u, v))\n    else\n        gcd = v\n    end if\nend function gcd_rec\n\nIterative Euclid algorithm[edit]\nsubroutine gcd_iter(value, u, v)\n  integer, intent(out) :: value\n  integer, intent(inout) :: u, v\n  integer :: t\n\n  do while( v /= 0 )\n     t = u\n     u = v\n     v = mod(t, v)\n  enddo\n  value = abs(u)\nend subroutine gcd_iter\n\n\nfunction gcd(v, t)\n  integer :: gcd\n  integer, intent(in) :: v, t\n  integer :: c, b, a\n\n  b = t\n  a = v\n  do\n     c = mod(a, b)\n     if ( c == 0) exit\n     a = b\n     b = c\n  end do\n  gcd = b ! abs(b)\nend function gcd\n\nIterative binary algorithm[edit]\nsubroutine gcd_bin(value, u, v)\n  integer, intent(out) :: value\n  integer, intent(inout) :: u, v\n  integer :: k, t\n\n  u = abs(u)\n  v = abs(v)\n  if( u < v ) then\n     t = u\n     u = v\n     v = t\n  endif\n  if( v == 0 ) then\n     value = u\n     return\n  endif\n  k = 1\n  do while( (mod(u, 2) == 0).and.(mod(v, 2) == 0) )\n     u = u / 2\n     v = v / 2\n     k = k * 2\n  enddo\n  if( (mod(u, 2) == 0) ) then\n     t = u\n  else\n     t = -v\n  endif\n  do while( t /= 0 )\n     do while( (mod(t, 2) == 0) )\n        t = t / 2\n     enddo\n     if( t > 0 ) then\n        u = t\n     else\n        v = -t\n     endif\n     t = u - v\n  enddo\n  value = u * k\nend subroutine gcd_bin\n\nNotes on performance[edit]\n\nIterative binary algorithm in Fortran 2008[edit]\nWorks with: Fortran version 2008\nWorks with: Fortran version 2018\nTranslation of: ATS\n\n! Stein\u2019s algorithm implemented in Fortran 2008.\n! Translated from my implementation for ATS/Postiats.\n\nelemental function gcd (u, v) result (d)\n  implicit none\n  integer, intent(in) :: u, v\n  integer :: d\n\n  integer :: x, y\n\n  ! gcd(x,y) = gcd(u,v), but x and y are non-negative and x <= y.\n  x = min (abs (u), abs (v))\n  y = max (abs (u), abs (v))\n\n  if (x == 0) then\n     d = y\n  else\n     d = gcd_pos_pos (x, y)\n  end if\n\ncontains\n\n  elemental function gcd_pos_pos (u, v) result (d)\n    integer, intent(in) :: u, v\n    integer :: d\n\n    integer :: n\n    integer :: x, y\n    integer :: p, q\n\n    ! n = the number of common factors of two in u and v.\n    n = trailz (ior (u, v))\n\n    ! Remove the common twos from u and v, giving x and y.\n    x = ishft (u, -n)\n    y = ishft (v, -n)\n\n    ! Make both numbers odd. One of the numbers already was odd.\n    ! There is no effect on the value of their gcd.\n    x = ishft (x, -trailz (x))\n    y = ishft (y, -trailz (y))\n\n    do while (x /= y)\n       ! If x > y then swap x and y, renaming them p\n       ! and q. Thus p <= q, and gcd(p,q) = gcd(x,y).\n       p = min (x, y)\n       q = max (x, y)\n\n       x = p                    ! x remains odd.\n       q = q - p\n       y = ishft (q, -trailz (q)) ! Make y odd again.\n    end do\n\n    ! Put the common twos back in.\n    d = ishft (x, n)\n  end function gcd_pos_pos\n\nend function gcd\n\nprogram test_gcd\n  implicit none\n\n  interface\n     elemental function gcd (u, v) result (d)\n       integer, intent(in) :: u, v\n       integer :: d\n     end function gcd\n  end interface\n\n  write (*, '(\"gcd (0, 0) = \", I0)') gcd (0, 0)\n  write (*, '(\"gcd (0, 10) = \", I0)') gcd (0, 10)\n  write (*, '(\"gcd (-6, -9) = \", I0)') gcd (-6, -9)\n  write (*, '(\"gcd (64 * 5, -16 * 3) = \", I0)') gcd (64 * 5, -16 * 3)\n  write (*, '(\"gcd (40902, 24140) = \", I0)') gcd (40902, 24140)\n  write (*, '(\"gcd (-40902, 24140) = \", I0)') gcd (-40902, 24140)\n  write (*, '(\"gcd (40902, -24140) = \", I0)') gcd (40902, -24140)\n  write (*, '(\"gcd (-40902, -24140) = \", I0)') gcd (-40902, -24140)\n  write (*, '(\"gcd (24140, 40902) = \", I0)') gcd (24140, 40902)\n\nend program test_gcd\n\n\nOutput:\ngcd (0, 0) = 0\ngcd (0, 10) = 10\ngcd (-6, -9) = 3\ngcd (64 * 5, -16 * 3) = 16\ngcd (40902, 24140) = 34\ngcd (-40902, 24140) = 34\ngcd (40902, -24140) = 34\ngcd (-40902, -24140) = 34\ngcd (24140, 40902) = 34\n", "explain": "A different version, and implemented as function\ngcd_iter(40902, 24140) takes us about 2.8 \u00b5sec\ngcd_bin(40902, 24140) takes us about 2.5 \u00b5sec\nFortran 2008 introduces new intrinsic functions for integer operations that nowadays usually have hardware support, such as TRAILZ to count trailing zeros.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Go", "code": "\nBinary Euclidian[edit]\npackage main\n\nimport \"fmt\"\n\nfunc gcd(a, b int) int {\n    var bgcd func(a, b, res int) int\n\n    bgcd = func(a, b, res int) int {\n\tswitch {\n\tcase a == b:\n\t    return res * a\n\tcase a % 2 == 0 && b % 2 == 0:\n\t    return bgcd(a/2, b/2, 2*res)\n\tcase a % 2 == 0:\n\t    return bgcd(a/2, b, res)\n\tcase b % 2 == 0:\n\t    return bgcd(a, b/2, res)\n\tcase a > b:\n\t    return bgcd(a-b, b, res)\n\tdefault:\n\t    return bgcd(a, b-a, res)\n\t}\n    }\n\n    return bgcd(a, b, 1)\n}\n\nfunc main() {\n    type pair struct {\n\ta int\n\tb int\n    }\n\n    var testdata []pair = []pair{\n\tpair{33, 77},\n\tpair{49865, 69811},\n    }\n\n    for _, v := range testdata {\n\tfmt.Printf(\"gcd(%d, %d) = %d\\n\", v.a, v.b, gcd(v.a, v.b))\n    }\n}\n\n\nOutput for Binary Euclidian algorithm:\ngcd(33, 77) = 11\ngcd(49865, 69811) = 9973\n\nIterative[edit]\npackage main\n\nimport \"fmt\"\n\nfunc gcd(x, y int) int {\n    for y != 0 {\n        x, y = y, x%y\n    }\n    return x\n}\n\nfunc main() {\n    fmt.Println(gcd(33, 77))\n    fmt.Println(gcd(49865, 69811))\n}\n\nBuiltin[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc gcd(x, y int64) int64 {\n    return new(big.Int).GCD(nil, nil, big.NewInt(x), big.NewInt(y)).Int64()\n}\n\nfunc main() {\n    fmt.Println(gcd(33, 77))\n    fmt.Println(gcd(49865, 69811))\n}\n\n\nOutput in either case:\n11\n9973\n\n", "explain": "(This is just a wrapper for big.GCD)\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "MIPS_Assembly", "code": "\ngcd:\n  # a0 and a1 are the two integer parameters\n  # return value is in v0\n  move $t0, $a0\n  move $t1, $a1\nloop:\n  beq $t1, $0, done\n  div $t0, $t1\n  move $t0, $t1\n  mfhi $t1\n  j loop\ndone:\n  move $v0, $t0\n  jr $ra\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Delphi", "code": "\n\n", "explain": "See #Pascal / Delphi / Free Pascal.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Ruby", "code": "\n\n40902.gcd(24140)  # => 34\n\ndef gcd(u, v)\n  u, v = u.abs, v.abs\n  while v > 0\n    u, v = v, u\u00a0% v\n  end\n  u\nend\n", "explain": "That is already available as the gcd method of integers:\nHere's an implementation:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Rust", "code": "\nnum crate[edit]\nextern crate num;\nuse num::integer::gcd;\nIterative Euclid algorithm[edit]\nfn gcd(mut m: i32, mut n: i32) -> i32 {\n   while m\u00a0!= 0 {\n       let old_m = m;\n       m = n\u00a0% m;\n       n = old_m;\n   }\n   n.abs()\n}\nRecursive Euclid algorithm[edit]\nfn gcd(m: i32, n: i32) -> i32 {\n   if m == 0 {\n      n.abs()\n   } else {\n      gcd(n\u00a0% m, m)\n   }\n}\nStein's Algorithm[edit]\n\nuse std::cmp::{min, max};\nfn gcd(a: usize, b: usize) -> usize {\n    match ((a, b), (a & 1, b & 1)) {\n        ((x, y), _) if x == y               => y,\n        ((0, x), _) | ((x, 0), _)           => x,\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\n        ((x, y), (0, 0))                    => gcd(x >> 1, y >> 1) << 1,\n        ((x, y), (1, 1))                    => { let (x, y) = (min(x, y), max(x, y)); \n                                                 gcd((y - x) >> 1, x) \n                                               }\n        _                                   => unreachable!(),\n    }\n}\nTests[edit]\n   println!(\"{}\",gcd(399,-3999));\n   println!(\"{}\",gcd(0,3999));\n   println!(\"{}\",gcd(13*13,13*29));\n\n3\n3999\n13\n", "explain": "Stein's algorithm is very much like Euclid's except that it uses bitwise operators (and consequently slightly more performant) and the integers must be unsigned. The following is a recursive implementation that leverages Rust's pattern matching.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Swift", "code": "\n// Iterative\n\nfunc gcd(a: Int, b: Int) -> Int {\n    \n    var a = abs(a)\n    var b = abs(b)\n    \n    if (b > a) { swap(&a, &b) }\n\n    while (b > 0) { (a, b) = (b, a\u00a0% b) }\n    \n    return a\n}\n\n// Recursive\n\nfunc gcdr (a: Int, b: Int) -> Int {\n    \n    var a = abs(a)\n    var b = abs(b)\n\n    if (b > a) { swap(&a, &b) }\n    \n    return gcd_rec(a,b)\n}\n\n\nprivate func gcd_rec(a: Int, b: Int) -> Int {\n    \n    return b == 0\u00a0? a\u00a0: gcd_rec(b, a\u00a0% b)\n}\n\n\nfor (a,b) in [(1,1), (100, -10), (10, -100), (-36, -17), (27, 18), (30, -42)] {\n    \n    println(\"Iterative: GCD of \\(a) and \\(b) is \\(gcd(a, b))\")\n    println(\"Recursive: GCD of \\(a) and \\(b) is \\(gcdr(a, b))\")\n}\n\nOutput:\nIterative: GCD of 1 and 1 is 1\nRecursive: GCD of 1 and 1 is 1\nIterative: GCD of 100 and -10 is 10\nRecursive: GCD of 100 and -10 is 10\nIterative: GCD of 10 and -100 is 10\nRecursive: GCD of 10 and -100 is 10\nIterative: GCD of -36 and -17 is 1\nRecursive: GCD of -36 and -17 is 1\nIterative: GCD of 27 and 18 is 9\nRecursive: GCD of 27 and 18 is 9\nIterative: GCD of 30 and -42 is 6\nRecursive: GCD of 30 and -42 is 6\n\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "R", "code": "\n\n\"%gcd%\" <- function(u, v) {\n  ifelse(u\u00a0%% v\u00a0!= 0, v %gcd% (u%%v), v)\n}\n\n\"%gcd%\" <- function(v, t) {\n  while ( (c <- v%%t)\u00a0!= 0 ) {\n    v <- t\n    t <- c\n  }\n  t\n}\n\nOutput:\n\n> print(50 %gcd% 75)\n[1] 25\n\n", "explain": "Recursive:\nIterative:\nSame either way.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. GCD.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01 A        PIC 9(10)   VALUE ZEROES.\n       01 B        PIC 9(10)   VALUE ZEROES.\n       01 TEMP     PIC 9(10)   VALUE ZEROES.\n\n       PROCEDURE DIVISION.\n       Begin.\n           DISPLAY \"Enter first number, max 10 digits.\"\n           ACCEPT A\n           DISPLAY \"Enter second number, max 10 digits.\"\n           ACCEPT B\n           IF A < B\n             MOVE B TO TEMP\n             MOVE A TO B\n             MOVE TEMP TO B\n           END-IF\n\n           PERFORM UNTIL B = 0\n             MOVE A TO TEMP\n             MOVE B TO A\n             DIVIDE TEMP BY B GIVING TEMP REMAINDER B\n           END-PERFORM\n           DISPLAY \"The gcd is \" A\n           STOP RUN.\n\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Ada", "code": "\nwith Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Gcd_Test is\n   function Gcd (A, B : Integer) return Integer is\n      M : Integer := A;\n      N : Integer := B;\n      T : Integer;\n   begin\n      while N /= 0 loop\n         T := M;\n         M := N;\n         N := T mod N;\n      end loop;\n      return M;\n   end Gcd;\n   \nbegin\n   Put_Line(\"GCD of 100, 5 is\" & Integer'Image(Gcd(100, 5)));\n   Put_Line(\"GCD of 5, 100 is\" & Integer'Image(Gcd(5, 100)));\n   Put_Line(\"GCD of 7, 23 is\" & Integer'Image(Gcd(7, 23)));\nend Gcd_Test;\n\n\nGCD of 100, 5 is 5\nGCD of 5, 100 is 5\nGCD of 7, 23 is 1\n\n", "explain": "Output:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Julia", "code": "\n\njulia> gcd(4,12)\n4\njulia> gcd(6,12)\n6\njulia> gcd(7,12)\n1\n\nfunction gcd{T<:Integer}(a::T, b::T)\n    neg = a < 0\n    while b\u00a0!= 0\n        t = b\n        b = rem(a, b)\n        a = t\n    end\n    g = abs(a)\n    neg\u00a0? -g\u00a0: g\nend\n\n", "explain": "Julia includes a built-in gcd function:\nThe actual implementation of this function in Julia 0.2's standard library is reproduced here:\n(For arbitrary-precision integers, Julia calls a different implementation from the GMP library.)\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Kotlin", "code": "\n\ntailrec fun gcd(a: Int, b: Int): Int = if (b == 0) kotlin.math.abs(a) else gcd(b, a\u00a0% b)\n", "explain": "Recursive one line solution:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Perl", "code": "\nIterative Euclid algorithm[edit]\nsub gcd_iter($$) {\n  my ($u, $v) = @_;\n  while ($v) {\n    ($u, $v) = ($v, $u\u00a0% $v);\n  }\n  return abs($u);\n}\nRecursive Euclid algorithm[edit]\nsub gcd($$) {\n  my ($u, $v) = @_;\n  if ($v) {\n    return gcd($v, $u\u00a0% $v);\n  } else {\n    return abs($u);\n  }\n}\nIterative binary algorithm[edit]\nsub gcd_bin($$) {\n  my ($u, $v) = @_;\n  $u = abs($u);\n  $v = abs($v);\n  if ($u < $v) {\n    ($u, $v) = ($v, $u);\n  }\n  if ($v == 0) {\n    return $u;\n  }\n  my $k = 1;\n  while ($u & 1 == 0 && $v & 1 == 0) {\n    $u >>= 1;\n    $v >>= 1;\n    $k <<= 1;\n  }\n  my $t = ($u & 1)\u00a0? -$v\u00a0: $u;\n  while ($t) {\n    while ($t & 1 == 0) {\n      $t >>= 1;\n    }\n    if ($t > 0) {\n      $u = $t;\n    } else {\n      $v = -$t;\n    }\n    $t = $u - $v;\n  }\n  return $u * $k;\n}\nModules[edit]\n\n# Fastest, takes multiple inputs\nuse Math::Prime::Util \"gcd\";\n$gcd = gcd(49865, 69811);\n\n# In CORE.  Slowest, takes multiple inputs, result is a Math::BigInt unless converted\nuse Math::BigInt;\n$gcd = Math::BigInt::bgcd(49865, 69811)->numify;\n\n# Result is a Math::Pari object unless converted\nuse Math::Pari \"gcd\";\n$gcd = gcd(49865, 69811)->pari2iv\nNotes on performance[edit]\nuse Benchmark qw(cmpthese);\nuse Math::BigInt;\nuse Math::Pari;\nuse Math::Prime::Util;\n\nmy $u = 40902;\nmy $v = 24140;\ncmpthese(-5, {\n  'gcd_rec' => sub { gcd($u, $v); },\n  'gcd_iter' => sub { gcd_iter($u, $v); },\n  'gcd_bin' => sub { gcd_bin($u, $v); },\n  'gcd_bigint' => sub { Math::BigInt::bgcd($u,$v)->numify(); },\n  'gcd_pari' => sub { Math::Pari::gcd($u,$v)->pari2iv(); },\n  'gcd_mpu' => sub { Math::Prime::Util::gcd($u,$v); },\n});\n\n                Rate gcd_bigint   gcd_bin   gcd_rec  gcd_iter gcd_pari   gcd_mpu\ngcd_bigint   39939/s         --      -83%      -94%      -95%     -98%      -99%\ngcd_bin     234790/s       488%        --      -62%      -70%     -88%      -97%\ngcd_rec     614750/s      1439%      162%        --      -23%     -68%      -91%\ngcd_iter    793422/s      1887%      238%       29%        --     -58%      -89%\ngcd_pari   1896544/s      4649%      708%      209%      139%       --      -73%\ngcd_mpu    7114798/s     17714%     2930%     1057%      797%     275%        --\n\n", "explain": "All three modules will take large integers as input, e.g.\ngcd(\"68095260063025322303723429387\", \"51306142182612010300800963053\").  Other possibilities are Math::Cephes euclid, Math::GMPz gcd and gcd_ui.\nOutput on 'Intel i3930k 4.2GHz' / Linux / Perl 5.20:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Prolog", "code": "\nRecursive Euclid Algorithm[edit]\ngcd(X, 0, X):-\u00a0!.\ngcd(0, X, X):-\u00a0!.\ngcd(X, Y, D):- X > Y,\u00a0!, Z is X mod Y, gcd(Y, Z, D).\ngcd(X, Y, D):- Z is Y mod X, gcd(X, Z, D).\nRepeated Subtraction[edit]\ngcd(X, 0, X):-\u00a0!.\ngcd(0, X, X):-\u00a0!.\ngcd(X, Y, D):- X =< Y,\u00a0!, Z is Y - X, gcd(X, Z, D).\ngcd(X, Y, D):- gcd(Y, X, D).\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Lua", "code": "\nTranslation of: C\nfunction gcd(a,b)\n\tif b ~= 0 then\n\t\treturn gcd(b, a\u00a0% b)\n\telse\n\t\treturn math.abs(a)\n\tend\nend\n\nfunction demo(a,b)\n\tprint(\"GCD of \" .. a .. \" and \" .. b .. \" is \" .. gcd(a, b))\nend\n\ndemo(100, 5)\ndemo(5, 100)\ndemo(7, 23)\n\nGCD of 100 and 5 is 5\nGCD of 5 and 100 is 5\nGCD of 7 and 23 is 1\n\n\nfunction gcd(a,b)\n    while b~=0 do \n        a,b=b,a%b\n    end\n    return math.abs(a)\nend\n", "explain": "Output:\nFaster iterative solution of Euclid:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Scala", "code": "\ndef gcd(a: Int, b: Int): Int = if (b == 0) a.abs else gcd(b, a\u00a0% b)\n\n@tailrec\ndef gcd(a: Int, b: Int): Int = {\n  b match {\n    case 0 => a\n    case _ => gcd(b, (a\u00a0% b))\n  }\n}\n", "explain": "Using pattern matching\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Transact-SQL", "code": "\nCREATE OR ALTER FUNCTION [dbo].[PGCD]\n    (    @a BigInt\n    ,    @b BigInt\n    )\nRETURNS BigInt\nWITH RETURNS NULL ON NULL INPUT\n-- Calculates the Greatest Common Denominator of two numbers (1 if they are coprime).\nBEGIN\nDECLARE @PGCD BigInt;\n\nWITH    Vars(A, B)\nAs  (   SELECT  Max(V.N) As A\n            ,   Min(V.N) As B\n        FROM (  VALUES  ( Abs(@a) , Abs(@b)) ) Params(A, B)\n        -- First, get absolute value\n        Cross APPLY (   VALUES (Params.A) , (Params.B) ) V(N)\n        -- Then, order parameters without Greatest/Least functions\n        WHERE Params.A > 0\n            And Params.B > 0 -- If 0 passed in, NULL shall be the output\n    )\n    ,   Calc(A, B)\nAs  (   SELECT  A\n            ,   B\n        FROM    Vars\n\n        UNION ALL\n\n        SELECT  B As A\n            ,   A\u00a0% B As B -- Self-ordering\n        FROM    Calc\n        WHERE   Calc.A > 0\n            And Calc.B > 0\n    )\nSELECT  @PGCD = Min(A)\nFROM    Calc\nWHERE   Calc.B = 0\n;\n\nRETURN @PGCD;\n\nEND\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "D", "code": "\nimport std.stdio, std.numeric;\n\nlong myGCD(in long x, in long y) pure nothrow @nogc {\n    if (y == 0)\n        return x;\n    return myGCD(y, x % y);\n}\n\nvoid main() {\n    gcd(15, 10).writeln; // From Phobos.\n    myGCD(15, 10).writeln;\n}\n\n\nOutput:\n5\n5\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Haskell", "code": "\n\ngcd :: (Integral a) => a -> a -> a\ngcd x y = gcd_ (abs x) (abs y)\n  where\n    gcd_ a 0 = a\n    gcd_ a b = gcd_ b (a `rem` b)\n\n", "explain": "That is already available as the function gcd in the Prelude. Here's the implementation, with one name adjusted to avoid a Wiki formatting glitch:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Scheme", "code": "\n(define (gcd a b)\n  (if (= b 0)\n      a\n      (gcd b (modulo a b))))\n\n(gcd a b)\n", "explain": "or using the standard function included with Scheme (takes any number of arguments):\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "TypeScript", "code": "\n\nfunction gcd(a: number, b: number) {\n  a = Math.abs(a);\n  b = Math.abs(b);\n\n  if (b > a) {\n    let temp = a;\n    a = b;\n    b = temp; \n  }\n\n  while (true) {\n    a\u00a0%= b;\n    if (a === 0) { return b; }\n    b\u00a0%= a;\n    if (b === 0) { return a; }\n  }\n}\n\nfunction gcd_rec(a: number, b: number) {\n  return b\u00a0? gcd_rec(b, a\u00a0% b)\u00a0: Math.abs(a);\n}\n", "explain": "Iterative implementation\nRecursive.\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "PowerShell", "code": "\nRecursive Euclid Algorithm[edit]\nfunction Get-GCD ($x, $y)\n{\n  if ($x -eq $y) { return $y }\n  if ($x -gt $y) {\n    $a = $x\n    $b = $y\n  }\n  else {\n    $a = $y\n    $b = $x\n  }\n  while ($a\u00a0% $b -ne 0) {\n    $tmp = $a\u00a0% $b\n    $a = $b\n    $b = $tmp\n  }\n  return $b\n}\n\nfunction Get-GCD ($x, $y) {\n  if ($y -eq 0) { $x } else { Get-GCD $y ($x%$y) }\n}\nIterative Euclid Algorithm[edit]\n\nFunction Get-GCD( $x, $y ) {\n    while ($y -ne 0) {\n        $x, $y = $y, ($x\u00a0% $y)\n    }\n    [Math]::abs($x)\n}\n", "explain": "or shorter (taken from Python implementation)\nbased on Python implementation\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Logo", "code": "\nto gcd :a :b\n  if :b = 0 [output :a]\n  output gcd :b  modulo :a :b\nend\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "F#", "code": "\nlet rec gcd a b =\n  if b = 0 \n    then abs a\n  else gcd b (a % b)\n \n>gcd 400 600\nval it : int = 200\n\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Groovy", "code": "\nRecursive[edit]\ndef gcdR\ngcdR = { m, n -> m = m.abs(); n = n.abs(); n == 0 ? m : m%n == 0 ? n : gcdR(n, m%n) }\n\nIterative[edit]\ndef gcdI = { m, n -> m = m.abs(); n = n.abs(); n == 0 ? m : { while(m%n != 0) { t=n; n=m%n; m=t }; n }() }\n\n\nprintln \"                R     I\"\nprintln \"gcd(28, 0)   = ${gcdR(28, 0)} == ${gcdI(28, 0)}\"\nprintln \"gcd(0, 28)   = ${gcdR(0, 28)} == ${gcdI(0, 28)}\"\nprintln \"gcd(0, -28)  = ${gcdR(0, -28)} == ${gcdI(0, -28)}\"\nprintln \"gcd(70, -28) = ${gcdR(70, -28)} == ${gcdI(70, -28)}\"\nprintln \"gcd(70, 28)  = ${gcdR(70, 28)} == ${gcdI(70, 28)}\"\nprintln \"gcd(28, 70)  = ${gcdR(28, 70)} == ${gcdI(28, 70)}\"\nprintln \"gcd(800, 70) = ${gcdR(800, 70)} == ${gcdI(800, 70)}\"\nprintln \"gcd(27, -70) =  ${gcdR(27, -70)} ==  ${gcdI(27, -70)}\"\n\n\n                R     I\ngcd(28, 0)   = 28 == 28\ngcd(0, 28)   = 28 == 28\ngcd(0, -28)  = 28 == 28\ngcd(70, -28) = 14 == 14\ngcd(70, 28)  = 14 == 14\ngcd(28, 70)  = 14 == 14\ngcd(800, 70) = 10 == 10\ngcd(27, -70) =  1 ==  1\n", "explain": "Test program:\nOutput:\n"}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "Zig", "code": "\npub fn gcd(u: anytype, v: anytype) @TypeOf(u) {\n  if (@typeInfo(@TypeOf(u))\u00a0!= .Int) {\n    @compileError(\"non-integer type used on gcd: \" ++ @typeName(@TypeOf(u)));\n  }\n  if (@typeInfo(@TypeOf(v))\u00a0!= .Int) {\n    @compileError(\"non-integer type used on gcd: \" ++ @typeName(@TypeOf(v)));\n  }\n  return if (v\u00a0!= 0) gcd(v, @mod(u,v)) else u;\n}\n", "explain": ""}, {"task_name": "Greatest common divisor", "task_url": "https://rosettacode.org/wiki/Greatest_common_divisor", "task_cat": "Recursion", "lang": "AWK", "code": "\n\n$ awk 'function gcd(p,q){return(q?gcd(q,(p%q)):p)}{print gcd($1,$2)}'\n12 16\n4\n22 33\n11\n45 67\n1\n\n", "explain": "The following scriptlet defines the gcd() function, then reads pairs of numbers from stdin, and reports their gcd on stdout.\n"}]