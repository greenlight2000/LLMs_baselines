[{"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Python", "code": "\n\narr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2\nassert arr4 == [1, 2, 3, 4, 5, 6]\narr4.extend(arr3)\nassert arr4 == [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\narr5 = [4, 5, 6]\narr6 = [7, 8, 9]\narr6 += arr5\nassert arr6 == [7, 8, 9, 4, 5, 6]\n", "explain": "The + operator concatenates two lists and returns a new list.  \nThe list.extend method appends elements of another list to the receiver.\nNote: list.extend is normally accomplished using the += operator like this:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "C", "code": "\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n\n#define ARRAY_CONCAT(TYPE, A, An, B, Bn) \\\n  (TYPE *)array_concat((const void *)(A), (An), (const void *)(B), (Bn), sizeof(TYPE));\n\nvoid *array_concat(const void *a, size_t an,\n                   const void *b, size_t bn, size_t s)\n{\n  char *p = malloc(s * (an + bn));\n  memcpy(p, a, an*s);\n  memcpy(p + an*s, b, bn*s);\n  return p;\n}\n\n// testing\nconst int a[] = { 1, 2, 3, 4, 5 };\nconst int b[] = { 6, 7, 8, 9, 0 };\n\nint main(void)\n{\n  unsigned int i;\n\n  int *c = ARRAY_CONCAT(int, a, 5, b, 5);\n\n  for(i = 0; i < 10; i++)\n    printf(\"%d\\n\", c[i]);\n\n  free(c);\n  return EXIT_SUCCCESS;\n}\n\n", "explain": "A way to concatenate two C arrays when you know their size (and usually so it is)\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "C++", "code": "\n#include <vector>\n#include <iostream>\n\nint main()\n{\n  std::vector<int> a(3), b(4);\n  a[0] = 11; a[1] = 12; a[2] = 13;\n  b[0] = 21; b[1] = 22; b[2] = 23; b[3] = 24;\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for (int i = 0; i < a.size(); ++i)\n    std::cout << \"a[\" << i << \"] = \" << a[i] << \"\\n\";\n}\n\nWorks with: C++11\n\n#include <vector>                                                                                                       \n#include <iostream>\n\nint main() {\n  std::vector<int> a {1, 2, 3, 4};\n  std::vector<int> b {5, 6, 7, 8, 9};\n\n  a.insert(a.end(), b.begin(), b.end());\n\n  for(int& i: a) std::cout << i << \" \";\n  std::cout << std::endl;\n  return 0;\n}\n\n\n#include <iostream>\n\nusing namespace std;\n\ntemplate <typename T1, typename T2>\nint* concatArrays( T1& array_1, T2& array_2) {\n  int arrayCount_1 = sizeof(array_1) / sizeof(array_1[0]);\n  int arrayCount_2 = sizeof(array_2) / sizeof(array_2[0]);\n  int newArraySize = arrayCount_1 + arrayCount_2;\n\n  int *p = new int[newArraySize];\n\n  for (int i = 0; i < arrayCount_1; i++) {\n    p[i] = array_1[i];\n  }\n\n  for (int i = arrayCount_1; i < newArraySize; i++) {\n    int newIndex = i-arrayCount_2;\n\n    if (newArraySize % 2 == 1)\n\tnewIndex--;\n\n    p[i] = array_2[newIndex];\n    cout << \"i: \" << i << endl;\n    cout << \"array_2[i]: \" << array_2[newIndex] << endl;\n    cout << endl;\n  }\n\n  return p;\n}\n\nint main() {\n  \n  int ary[4] = {1, 2, 3, 123};\n  int anotherAry[3] = {4, 5, 6};\n  \n  int *r = concatArrays(ary, anotherAry);\n\n  cout << *(r + 0) << endl;\n  cout << *(r + 1) << endl;\n  cout << *(r + 2) << endl;\n  cout << *(r + 3) << endl;\n  cout << *(r + 4) << endl;\n  cout << *(r + 5) << endl;\n  cout << *(r + 6) << endl;\n\n  delete r;\n\n  return 0;\n}\n\n", "explain": "Similar to above but using initialization schematics. \nThis is another solution with function level templates and pointers.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Java", "code": "\n\nint[] concat(int[] arrayA, int[] arrayB) {\n    int[] array = new int[arrayA.length + arrayB.length];\n    System.arraycopy(arrayA, 0, array, 0, arrayA.length);\n    System.arraycopy(arrayB, 0, array, arrayA.length, arrayB.length);\n    return array;\n}\n\n\nint[] concat(int[] arrayA, int[] arrayB) {\n    int[] array = new int[arrayA.length + arrayB.length];\n    for (int index = 0; index < arrayA.length; index++)\n        array[index] = arrayA[index];\n    for (int index = 0; index < arrayB.length; index++)\n        array[index + arrayA.length] = arrayB[index];\n    return array;\n}\n\n\nint[] concat(int[] arrayA, int[] arrayB) {\n    List<Integer> list = new ArrayList<>();\n    for (int value : arrayA) list.add(value);\n    for (int value : arrayB) list.add(value);\n    int[] array = new int[list.size()];\n    for (int index = 0; index < list.size(); index++)\n        array[index] = list.get(index);\n    return array;\n}\n\n", "explain": "In Java, arrays are immutable, so you'll have to create a new array, and copy the contents of the two arrays into it.\nLuckily, Java offers the System.arraycopy method, which will save you the effort of creating the for-loops.\nIf you wanted to use for-loops, possibly to mutate the data as it's concatenated, you can use the following.\nA less idiomatic approach would be to use a List, which is a mutable array, similar to a \"vector\" in other languages.\nI have used both arrays and Lists extensively and have not noticed any sort of performance degradation, they appear to work equally as fast.\nIt's worth noting that the Java Collections Framework, which contains the List class, is built specifically for Objects and not necessarily primitive data-types.  Despite this, it's still worth using for primitives, although the conversion to and from arrays is somewhat abstruse.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "C#", "code": "\nusing System;\n\nnamespace RosettaCode\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int[] a = { 1, 2, 3 };\n            int[] b = { 4, 5, 6 };\n\n            int[] c = new int[a.Length + b.Length];\n            a.CopyTo(c, 0);\n            b.CopyTo(c, a.Length);\n\n            foreach(int n in c)\n            {\n                Console.WriteLine(n.ToString());\n            }\n        }\n    }\n}\n\n\nWorks with: C# version 3\nusing System.Linq;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int[] a = { 1, 2, 3 };\n        int[] b = { 4, 5, 6 };\n\n        int[] c = a.Concat(b).ToArray();\n    }\n}\n\n", "explain": "Alternatively, using LINQ extension methods:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\n\nvar a = [1,2,3],\n    b = [4,5,6],\n    c = a.concat(b); //=> [1,2,3,4,5,6]\n\n\nTranslation of: Haskell\n\n(function () {\n    'use strict';\n\n    // concat\u00a0:: [[a]] -> [a]\n    function concat(xs) {\n        return [].concat.apply([], xs);\n    }\n\n\n   return concat(\n      [[\"alpha\", \"beta\", \"gamma\"], \n      [\"delta\", \"epsilon\", \"zeta\"], \n      [\"eta\", \"theta\", \"iota\"]]\n  );\n\n})();\n\n\nOutput:\n[\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\", \"iota\"]\n", "explain": "The Array.concat() method returns a new array comprised of this array joined with other array(s) and/or value(s). \n\nOr, if we consider the concatenation of two arrays as a particular instance of the more general problem of concatenating 2 or more arrays, we can write a generic function:\nSee, for a function with an analogous type signature, concat in the Haskell Prelude.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Visual_Basic_.NET", "code": "\n    Dim iArray1() As Integer = {1, 2, 3}\n    Dim iArray2() As Integer = {4, 5, 6}\n    Dim iArray3() As Integer = Nothing\n\n    iArray3 = iArray1.Concat(iArray2).ToArray\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "PHP", "code": "\n$arr1 = array(1, 2, 3);\n$arr2 = array(4, 5, 6);\n$arr3 = array_merge($arr1, $arr2);\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram Concat_Arrays\n  implicit none\n\n  ! Note: in Fortran 90 you must use the old array delimiters (/ , /)\n  integer, dimension(3) :: a = [1, 2, 3] ! (/1, 2, 3/)\n  integer, dimension(3) :: b = [4, 5, 6] ! (/4, 5, 6/)\n  integer, dimension(:), allocatable :: c, d\n  \n  allocate(c(size(a)+size(b)))\n  c(1 : size(a)) = a\n  c(size(a)+1 : size(a)+size(b)) = b\n  print*, c\n\n  ! alternative\n  d = [a, b] ! (/a, b/)\n  print*, d\nend program Concat_Arrays\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    // Example 1:  Idiomatic in Go is use of the append function.\n    // Elements must be of identical type.\n    a := []int{1, 2, 3}\n    b := []int{7, 12, 60} // these are technically slices, not arrays\n    c := append(a, b...)\n    fmt.Println(c)\n\n    // Example 2:  Polymorphism.\n    // interface{} is a type too, one that can reference values of any type.\n    // This allows a sort of polymorphic list.\n    i := []interface{}{1, 2, 3}\n    j := []interface{}{\"Crosby\", \"Stills\", \"Nash\", \"Young\"}\n    k := append(i, j...) // append will allocate as needed\n    fmt.Println(k)\n\n    // Example 3:  Arrays, not slices.\n    // A word like \"array\" on RC often means \"whatever array means in your\n    // language.\"  In Go, the common role of \"array\" is usually filled by\n    // Go slices, as in examples 1 and 2.  If by \"array\" you really mean\n    // \"Go array,\" then you have to do a little extra work.  The best\n    // technique is almost always to create slices on the arrays and then\n    // use the copy function.\n    l := [...]int{1, 2, 3}\n    m := [...]int{7, 12, 60} // arrays have constant size set at compile time\n    var n [len(l) + len(m)]int\n    copy(n[:], l[:]) // [:] creates a slice that references the entire array\n    copy(n[len(l):], m[:])\n    fmt.Println(n)\n\n}\n\n\nOutput:\n[1 2 3 7 12 60]\n[1 2 3 Crosby Stills Nash Young]\n[1 2 3 7 12 60]\n\n\npackage main\n\nimport (\n  \"reflect\"\n  \"fmt\"\n)\n\n// Generic version\n// Easier to make the generic version accept any number of arguments,\n// and loop trough them. Otherwise there will be lots of code duplication.\nfunc ArrayConcat(arrays ...interface{}) interface{} {\n  if len(arrays) == 0 {\n    panic(\"Need at least one arguemnt\")\n  }\n  var vals = make([]*reflect.SliceValue, len(arrays))\n  var arrtype *reflect.SliceType\n  var totalsize int\n  for i,a := range arrays {\n    v := reflect.NewValue(a)\n    switch t := v.Type().(type) {\n    case *reflect.SliceType:\n      if arrtype == nil {\n        arrtype = t\n      } else if t != arrtype {\n        panic(\"Unequal types\")\n      }\n      vals[i] = v.(*reflect.SliceValue)\n      totalsize += vals[i].Len()\n    default: panic(\"not a slice\")\n    }\n  }\n  ret := reflect.MakeSlice(arrtype,totalsize,totalsize)\n  targ := ret\n  for _,v := range vals {\n    reflect.Copy(targ, v)\n    targ = targ.Slice(v.Len(),targ.Len())\n  }\n  return ret.Interface()\n}\n\n// Type specific version\nfunc ArrayConcatInts(a, b []int) []int {\n  ret := make([]int, len(a) + len(b))\n  copy(ret, a)\n  copy(ret[len(a):], b)\n  return ret\n}\n\nfunc main() {\n  test1_a, test1_b := []int{1,2,3}, []int{4,5,6}\n  test1_c := ArrayConcatInts(test1_a, test1_b)\n  fmt.Println(test1_a, \" + \", test1_b, \" = \", test1_c)\n\n  test2_a, test2_b := []string{\"a\",\"b\",\"c\"}, []string{\"d\",\"e\",\"f\"}\n  test2_c := ArrayConcat(test2_a, test2_b).([]string)\n  fmt.Println(test2_a, \" + \", test2_b, \" = \", test2_c)\n}\n\n\nOutput:\n[1 2 3]  +  [4 5 6]  =  [1 2 3 4 5 6]\n[a b c]  +  [d e f]  =  [a b c d e f]\n\n", "explain": "Array concatenation needs can vary.  Here is another set of examples that illustrate different techniques.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program concAreaString.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n.equ NBMAXITEMS,  20   @ \n/* Initialized data */\n.data\nszMessLenArea: .ascii \"The length of area 3  is\u00a0: \"\nsZoneconv:\t\t .fill 12,1,' '\nszCarriageReturn:  .asciz \"\\n\"\n\n/* areas strings  */\nszString1:  .asciz \"Apples\"\nszString2:  .asciz \"Oranges\"\nszString3:  .asciz \"Pommes\"\nszString4:  .asciz \"Raisins\"\nszString5:  .asciz \"Abricots\"\n\n/* pointer items area 1*/\ntablesPoi1:\npt1_1:\t\t.int szString1\npt1_2:   .int szString2\nptVoid_1:\t\t.int 0\n\n/* pointer items area 2*/\ntablesPoi2:\npt2_1:\t\t.int szString3\npt2_2:   \t.int szString4\npt2_3:   \t.int szString5\nptVoid_2:\t\t.int 0\n\n/* UnInitialized data */\n.bss \ntablesPoi3:    .skip   4 * NBMAXITEMS\n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* saves 2 registers */\n\n    @ copy area 1 ->  area 3\n    ldr r1,iAdrtablesPoi1  @ begin pointer area 1\n    ldr r3,iAdrtablesPoi3  @ begin pointer area 3\n    mov r0,#0    @ counter\n1:\n    ldr r2,[r1,r0,lsl #2]    @ read string pointer address item r0 (4 bytes by pointer)\n    cmp r2,#0                @ is null\u00a0?\n    strne r2,[r3,r0,lsl #2]    @ no store pointer in area 3\n    addne r0,#1             @ increment counter\n    bne 1b                  @ and loop\n    @ copy area 2 ->  area 3\n    ldr r1,iAdrtablesPoi2  @ begin pointer area 2\n    ldr r3,iAdrtablesPoi3  @ begin pointer area 3\n    mov r4,#0    @ counter area 2\n2:        @ r0 contains the first void item in area 3\n    ldr r2,[r1,r4,lsl #2]    @ read string pointer address item r0 (4 bytes by pointer)\n    cmp r2,#0                @ is null\u00a0?\n    strne r2,[r3,r0,lsl #2]    @ no store pointer in area 3\n    addne r0,#1             @ increment counter\n    addne r4,#1             @ increment counter\n    bne 2b                  @ and loop\n\t\n\t@ count items number in area 3 \n    ldr r1,iAdrtablesPoi3  @ begin pointer table \n    mov r0,#0    @ counter\n3:              @ begin loop\n    ldr r2,[r1,r0,lsl #2]    @ read string pointer address item r0 (4 bytes by pointer)\n    cmp r2,#0                @ is null\u00a0?\n    addne r0,#1             @ no increment counter\n    bne 3b                  @ and loop\n \n    ldr r1,iAdrsZoneconv   @ conversion decimal\n    bl conversion10S\n    ldr r0,iAdrszMessLenArea\n    bl affichageMess\n\n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\niAdrtablesPoi1:\t\t.int tablesPoi1\niAdrtablesPoi2:\t\t.int tablesPoi2\niAdrtablesPoi3:\t\t.int tablesPoi3\niAdrszMessLenArea:  .int szMessLenArea\niAdrsZoneconv:\t\t.int  sZoneconv\niAdrszCarriageReturn:  .int  szCarriageReturn\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n\n/***************************************************/\n/*   conversion register signed d\u00e9cimal     */\n/***************************************************/\n/* r0 contient le registre   */\n/* r1 contient l adresse de la zone de conversion */\nconversion10S:\n    push {r0-r5,lr}    /* save des registres */\n    mov r2,r1       /* debut zone stockage */\n    mov r5,#'+'     /* par defaut le signe est + */\n    cmp r0,#0       /* nombre n\u00e9gatif\u00a0? */\n    movlt r5,#'-'     /* oui le signe est - */\n    mvnlt r0,r0       /* et inversion en valeur positive */\n    addlt r0,#1\n    mov r4,#10   /* longueur de la zone */\n1: /* debut de boucle de conversion */\n    bl divisionpar10 /* division  */\n    add r1,#48        /* ajout de 48 au reste pour conversion ascii */\t\n    strb r1,[r2,r4]  /* stockage du byte en d\u00e9but de zone r5 + la position r4 */\n    sub r4,r4,#1      /* position pr\u00e9cedente */\n    cmp r0,#0     \n    bne 1b\t       /* boucle si quotient different de z\u00e9ro */\n    strb r5,[r2,r4]  /* stockage du signe \u00e0 la position courante */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    blt  100f         /* si r4 < 0  fin  */\n    /* sinon il faut completer le debut de la zone avec des blancs */\n    mov r3,#' '   /* caractere espace */\t\n2:\n    strb r3,[r2,r4]  /* stockage du byte  */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    bge 2b        /* boucle si r4 plus grand ou egal a zero */\n100:  /* fin standard de la fonction  */\n    pop {r0-r5,lr}   /*restaur desregistres */\n    bx lr   \n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 contient le dividende   */\n/* r0 retourne le quotient */\t\n/* r1 retourne le reste  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n   push {r2-r4}   /* save registers  */\n   mov r4,r0 \n   ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n   smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n   mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n   mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n   add r0, r2, r1         /* r0 <- r2 + r1 */\n   add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n   sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n   pop {r2-r4}\n   bx lr                  /* leave function */\n   bx lr                  /* leave function */\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Delphi", "code": "\n\n// This example works on stuff as old as Delphi 5 (maybe older)\n// Modern Delphi / Object Pascal has both \n//   \u2022 generic types\n//   \u2022 the ability to concatenate arrays with the '+' operator\n// So I could just say:\n//   myarray\u00a0:= [1] + [2, 3];\n// But if you do not have access to the latest/greatest, then:\n{$apptype console}\n\ntype \n  // Array types must be declared in order to return them from functions\n  // They can also be used with open array parameters.\n  TArrayOfString = array of string;\n\nfunction Concat( a, b : array of string ): TArrayOfString; overload;\n{\n  Every array type needs its own 'Concat' function:\n    function Concat( a, b\u00a0: array of integer ): TArrayOfInteger; overload;\n    function Concat( a, b\u00a0: array of double  ): TArrayOfDouble;  overload;\n    etc\n  Also, dynamic and open array types ALWAYS start at 0. No need to complicate indexing here.\n}\nvar\n  n : Integer;\nbegin\n  SetLength( result, Length(a)+Length(b) );\n  for n := 0 to High(a) do result[          n] := a[n];\n  for n := 0 to High(b) do result[Length(a)+n] := b[n]\nend;\n\n// Example time!\nfunction Join( a : array of string; sep : string = ' ' ): string;\nvar\n  n : integer;\nbegin\n  if Length(a) > 0 then result := a[0];\n  for n := 1 to High(a) do result := result + sep + a[n]\nend;\n\nvar\n  names : TArrayOfString;\nbegin\n  // Here we use the open array parameter constructor as a convenience\n  names := Concat( ['Korra', 'Asami'], ['Bolin', 'Mako'] );\n  WriteLn( Join(names) );\n\n  // Also convenient: open array parameters are assignment-compatible with our array type!\n  names := Concat( names, ['Varrick', 'Zhu Li'] );\n  WriteLn( #13#10, Join(names, ', ') );\n  \n  names := Concat( ['Tenzin'], names );\n  Writeln( #13#10, Join(names, #13#10 ) );\nend.\n\n\nKorra Asami Bolin Mako\n\nKorra, Asami, Bolin, Mako, Varrick, Zhu Li\n\nTenzin\nKorra\nAsami\nBolin\nMako\nVarrick\nZhu Li\n\n\ntype\n  TReturnArray = array of integer; //you need to define a type to be able to return it\n\nfunction ConcatArray(a1,a2:array of integer):TReturnArray;\nvar\n  i,r:integer;\nbegin\n  { Low(array) is not necessarily 0 }\n  SetLength(result,High(a1)-Low(a1)+High(a2)-Low(a2)+2); //BAD idea to set a length you won't release, just to show the idea!\n  r:=0; //index on the result may be different to indexes on the sources\n  for i := Low(a1) to High(a1) do begin\n    result[r] := a1[i];\n    Inc(r);\n  end;\n  for i := Low(a2) to High(a2) do begin\n    result[r] := a2[i];\n    Inc(r);\n  end;\nend;\n\nprocedure TForm1.Button1Click(Sender: TObject);\nvar\n  a1,a2:array of integer;\n  r1:array of integer;\n  i:integer;\nbegin\n  SetLength(a1,4);\n  SetLength(a2,3);\n  for i := Low(a1) to High(a1) do\n    a1[i] := i;\n  for i := Low(a2) to High(a2) do\n    a2[i] := i;\n  TReturnArray(r1) := ConcatArray(a1,a2);\n  for i := Low(r1) to High(r1) do\n    showMessage(IntToStr(r1[i]));\n  Finalize(r1); //IMPORTANT!\n  ShowMessage(IntToStr(High(r1)));\nend;\n\n", "explain": "2022/07/13\nOutput:\n\nWhat follows is older content found on this page.\nIt has running commentary about memory management that isn\u2019t exactly correct.\nDelphi handles dynamic array memory very well.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Ruby", "code": "\n\narr1 = [1, 2, 3]\narr2 = [4, 5, 6]\narr3 = [7, 8, 9]\narr4 = arr1 + arr2  # => [1, 2, 3, 4, 5, 6]\narr4.concat(arr3)  # => [1, 2, 3, 4, 5, 6, 7, 8, 9]\n\n# concat multiple arrays:\n[arr1,arr2,arr3].flatten(1)\n# ignore nil:\n[arr1,arr2,arr3].compact.flatten(1)\n", "explain": "The Array#+ method concatenates two arrays and returns a new array.  The Array#concat method appends elements of another array to the receiver.\nOr use flatten(1):\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Rust", "code": "\nfn main() {\n    let a_vec = vec![1, 2, 3, 4, 5];\n    let b_vec = vec![6; 5];\n\n    let c_vec = concatenate_arrays(&a_vec, &b_vec);\n\n    println!(\"{:?} ~ {:?} => {:?}\", a_vec, b_vec, c_vec);\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    let mut concat = x.to_vec();\n    concat.extend_from_slice(y);\n\n    concat\n}\n\nfn concatenate_arrays<T: Clone>(x: &[T], y: &[T]) -> Vec<T> {\n    x.iter().chain(y).cloned().collect()\n}\n", "explain": "Or, with iterators:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Swift", "code": "\nlet array1 = [1,2,3]\nlet array2 = [4,5,6]\nlet array3 = array1 + array2\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "R", "code": "\na1 <- c(1, 2, 3)\na2 <- c(3, 4, 5)\na3 <- c(a1, a2)\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "COBOL", "code": "\n       identification division.\n       program-id. array-concat.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 table-one.\n          05 int-field pic 999 occurs 0 to 5 depending on t1.\n       01 table-two.\n          05 int-field pic 9(4) occurs 0 to 10 depending on t2.\n\n       77 t1           pic 99.\n       77 t2           pic 99.\n\n       77 show         pic z(4).\n\n       procedure division.\n       array-concat-main.\n       perform initialize-tables\n       perform concatenate-tables\n       perform display-result\n       goback.\n\n       initialize-tables.\n           move 4 to t1\n           perform varying tally from 1 by 1 until tally > t1\n               compute int-field of table-one(tally) = tally * 3\n           end-perform\n\n           move 3 to t2\n           perform varying tally from 1 by 1 until tally > t2\n               compute int-field of table-two(tally) = tally * 6\n           end-perform\n       .\n\n       concatenate-tables.\n           perform varying tally from 1 by 1 until tally > t1\n               add 1 to t2\n               move int-field of table-one(tally)\n                 to int-field of table-two(t2)\n           end-perform\n       .\n\n       display-result.\n           perform varying tally from 1 by 1 until tally = t2\n               move int-field of table-two(tally) to show\n               display trim(show) \", \" with no advancing\n           end-perform\n           move int-field of table-two(tally) to show\n           display trim(show)\n       .\n\n       end program array-concat.\n\n\nOutput:\nprompt$ cobc -xjd array-concatenation.cob\n6, 12, 18, 3, 6, 9, 12\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Ada", "code": "\n\ntype T is array (Positive range <>) of Integer;\nX : T := (1, 2, 3);\nY : T := X & (4, 5, 6); -- Concatenate X and (4, 5, 6)\n\n", "explain": "In Ada arrays are concatenated using the operation &. It works with any one dimensioned array:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Julia", "code": "\na = [1,2,3]\nb = [4,5,6]\nab = [a;b]\n# the above bracket notation simply generates a call to vcat\nab = vcat(a,b)\n# hcat is short for `horizontal concatenation`\nab = hcat(a,b) \t#ab -> 3x2 matrix\n# the append!(a,b) method is mutating, appending `b` to `a`\nappend!(a,b)\t# a now equals [1,2,3,4,5,6]\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\nfun main() {\n    val a = intArrayOf(1, 2, 3)\n    val b = intArrayOf(4, 5, 6)\n    val c = a + b // [1, 2, 3, 4, 5, 6]\n    println(c.contentToString())\n}\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Perl", "code": "\n\nmy @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\nmy @arr3 = (@arr1, @arr2);\n\nmy @arr1 = (1, 2, 3);\nmy @arr2 = (4, 5, 6);\npush @arr1, @arr2;\nprint \"@arr1\\n\"; # prints \"1 2 3 4 5 6\"\n", "explain": "In Perl, arrays placed into list context are flattened: \nThe push function appends elements onto an existing array:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\n\nNSArray *arr1 = @[@1, @2, @3];\nNSArray *arr2 = @[@4, @5, @6];\nNSArray *arr3 = [arr1 arrayByAddingObjectsFromArray:arr2];\n\nNSArray *arr1 = @[@1, @2, @3];\nNSArray *arr2 = @[@4, @5, @6];\nNSMutableArray *arr3 = [NSMutableArray arrayWithArray:arr1];\n[arr3 addObjectsFromArray:arr2];\n", "explain": "with immutable arrays:\nor adding onto a mutable array:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Prolog", "code": "\n?- append([1,2,3],[4,5,6],R).\nR = [1, 2, 3, 4, 5, 6].\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Lua", "code": "\na = {1, 2, 3}\nb = {4, 5, 6}\n\nfor _, v in pairs(b) do\n    table.insert(a, v)\nend\n\nprint(table.concat(a, \", \"))\n\n\nOutput:\n1, 2, 3, 4, 5, 6\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Scala", "code": "\nval arr1 = Array( 1, 2, 3 )\nval arr2 = Array( 4, 5, 6 )\nval arr3 = Array( 7, 8, 9 )\n\narr1 ++ arr2 ++ arr3\n//or:\nArray concat ( arr1, arr2, arr3 )\n// res0: Array[Int] = Array(1, 2, 3, 4, 5, 6, 7, 8, 9)\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "D", "code": "\nimport std.stdio: writeln;\n \nvoid main() {\n    int[] a = [1, 2];\n    int[] b = [4, 5, 6];\n \n    writeln(a, \" ~ \", b, \" = \", a ~ b);\n}\n\n\nOutput:\n[1, 2] ~ [4, 5, 6] = [1, 2, 4, 5, 6]\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\n(++) :: [a] -> [a] -> [a]\n\nAppend two lists, i.e.: \n[x1, ..., xm] ++ [y1, ..., yn] == [x1, ..., xm, y1, ..., yn]\n[x1, ..., xm] ++ [y1, ...] == [x1, ..., xm, y1, ...]\n\n[] ++ x = x\n(h:t) ++ y = h : (t ++ y)\n\n\nx ++ y = foldr (:) y x\n\n", "explain": "A list is in Haskell one of the most common composite data types (constructed from other types). In the documentation we read for the append operation ++:\nIf the first list is not finite, the result is the first list.\nThis operator could be defined from the scratch using explicit recursion:\nor folding\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "VBScript", "code": "\nFunction ArrayConcat(arr1, arr2)\n    ReDim ret(UBound(arr1) + UBound(arr2) + 1)\n    For i = 0 To UBound(arr1)\n        ret(i) = arr1(i)\n    Next\n    offset = Ubound(arr1) + 1\n    For i = 0 To UBound(arr2)\n        ret(i + offset) = arr2(i)\n    Next\n    ArrayConcat = ret\nEnd Function\n\narr1 = array(10,20,30)\narr2 = array(40,50,60)\nWScript.Echo \"arr1 = array(\" & Join(arr1,\", \") & \")\"\nWScript.Echo \"arr2 = array(\" & Join(arr2,\", \") & \")\"\narr3 = ArrayConcat(arr1, arr2)\nWScript.Echo \"arr1 + arr2 = array(\" & Join(arr3,\", \") & \")\"\n\nOutput:\narr1 = array(10, 20, 30)\narr2 = array(40, 50, 60)\narr1 + arr2 = array(10, 20, 30, 40, 50, 60)\n\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Scheme", "code": "\n; in r5rs, there is append for lists, but we'll need to define vector-append\n(define (vector-append . arg) (list->vector (apply append (map vector->list arg))))\n\n(vector-append #(1 2 3 4) #(5 6 7) #(8 9 10))\n; #(1 2 3 4 5 6 7 8 9 10)\n\nConcatening two-dimensional arrays[edit]\nWorks with: Gauche Scheme\n(use gauche.array)\n\n(define (print-matrix m)\n  (define row-num #f)\n  (array-for-each-index m\n    (lambda (row col)\n      (when (and row-num (not (= row-num row))) (newline))\n      (format #t \"~a \" (array-ref m row col))\n      (set! row-num row)))\n  (newline))\n\n(define a\n  #,(<array> (0 3 0 2)\n      a b\n      c d\n      e f))\n\n(define b\n  #,(<array> (0 3 0 2)\n      1 2\n      3 4\n      5 6))\n\n(print-matrix (array-concatenate a b))\n(print-matrix (array-concatenate a b 1))\n\nOutput:\na b\nc d\ne f\n1 2\n3 4\n5 6\n\na b 1 2\nc d 3 4\ne f 5 6\n\n", "explain": "Note\u00a0: vector-append is also defined in SRFI-43.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Apex", "code": "\nList<String> listA = new List<String> { 'apple' };\nList<String> listB = new List<String> { 'banana' };\nlistA.addAll(listB);\nSystem.debug(listA); // Prints (apple, banana)\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "PowerShell", "code": "\n$a = 1,2,3\n$b = 4,5,6\n\n$c = $a + $b\nWrite-Host $c\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Logo", "code": "\n\nto combine-arrays :a1 :a2        \n  output listtoarray sentence arraytolist :a1 arraytolist :a2\nend\nshow combine-arrays {1 2 3} {4 5 6}  \u00a0; {1 2 3 4 5 6}\n", "explain": "COMBINE is used to combine lists or words. SENTENCE is used to combine lists and words into a single list.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "ABAP", "code": "\n\nreport z_array_concatenation.\n\ndata(itab1) = value int4_table( ( 1 ) ( 2 ) ( 3 ) ).\ndata(itab2) = value int4_table( ( 4 ) ( 5 ) ( 6 ) ).\n\nappend lines of itab2 to itab1.\n\nloop at itab1 assigning field-symbol(<line>).\n    write <line>.\nendloop.\n\n\nOutput:\n         1           2           3           4           5           6\n\n", "explain": "The concept of arrays does not exist in ABAP, instead internal tables are used. This works in ABAP version 7.40 and above.\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "F#", "code": "\n\nlet a = [|1; 2; 3|]\nlet b = [|4; 5; 6;|]\nlet c = Array.append a b\n\n\nlet x = [1; 2; 3]\nlet y = [4; 5; 6]\nlet z1 = x @ y\nlet z2 = List.append x y\n\n", "explain": "Array concatenation.\nList concatenation (@ and List.append are equivalent).\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\ndef list = [1, 2, 3] + [\"Crosby\", \"Stills\", \"Nash\", \"Young\"]\n\n\nprintln list\n\n\nOutput:\n[1, 2, 3, Crosby, Stills, Nash, Young]\n", "explain": "Solution:\nTest:\n"}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "Zig", "code": "\nconst std = @import(\"std\");\nfn concat(allocator: std.mem.Allocator, a: []const u32, b: []const u32)\u00a0![]u32 {\n  const result = try allocator.alloc(u32, a.len + b.len);\n  std.mem.copy(u32, result, a);\n  std.mem.copy(u32, result[a.len..], b);\n  return result;\n}\n\npub fn main() void {\n  var general_purpose_allocator = std.heap.GeneralPurposeAllocator(.{}){};\n  const gpa = general_purpose_allocator.allocator();\n  var array1 = [_]u32{ 1, 2, 3, 4, 5 };\n  var array2 = [_]u32{ 6, 7, 8, 9, 10, 11, 12 };\n  const array3 = concat(gpa, &array1, &array2);\n  std.debug.print(\"Array 1: {any}\\nArray 2: {any}\\nArray 3: {any}\", .{ array1, array2, array3 });\n}\n", "explain": ""}, {"task_name": "Array concatenation", "task_url": "https://rosettacode.org/wiki/Array_concatenation", "task_cat": "Data Structures", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\nBEGIN {\n    split(\"cul-de-sac\",a,\"-\")\n    split(\"1-2-3\",b,\"-\")\n    concat_array(a,b,c)\n\n    for (i in c) {\n        print i,c[i]\n    }\n}\n\nfunction concat_array(a,b,c, nc) {\n    for (i in a) {\n        c[++nc]=a[i]\t\n    }\n    for (i in b) {\n       c[++nc]=b[i]\t\n    }\n}\n\n", "explain": ""}]