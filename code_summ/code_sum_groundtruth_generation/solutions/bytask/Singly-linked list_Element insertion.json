[{"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Python", "code": "\ndef chain_insert(lst, at, item):\n    while lst is not None:\n        if lst[0] == at:\n            lst[1] = [item, lst[1]]\n            return\n        else:\n            lst = lst[1]\n    raise ValueError(str(at) + \" not found\")\n\nchain = ['A', ['B', None]]\nchain_insert(chain, 'A', 'C')\nprint chain\n\n\n['A', ['C', ['B', None]]]\n\n", "explain": "Output:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "C", "code": "\n\nvoid insert_append (struct link *anchor, struct link *newlink) {\n  newlink->next = anchor->next;\n  anchor->next = newlink;\n}\n\n\nstruct link *a, *b, *c;\na = malloc(sizeof(link));\nb = malloc(sizeof(link));\nc = malloc(sizeof(link));\na->data = 1;\nb->data = 2;\nc->data = 3;\n\n\n insert_append (a, b);\n\n\n insert_append (a, c);\n\n\n free (a);\n free (b);\n free (c);\n\n", "explain": "Define the method:\nNote that in a production implementation, one should check anchor and newlink to ensure they're valid values. (I.e., not NULL.)\nAnd now on to the code.\nCreate our links.\nPrepare our initial list\nInsert element c after element a\nRemember to free the memory once we're done.\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "C++", "code": "\n\ntemplate<typename T> void insert_after(link<T>* list_node, link<T>* new_node)\n{\n  new_node->next = list_node->next;\n  list_node->next = new_node;\n};\n\n\nlink<int>* a = new link<int>('A', new link<int>('B'));\nlink<int>* c = new link<int>('C');\n\n\n insert_after(a, c);\n\n\nwhile (a)\n{\n  link<int>* tmp = a;\n  a = a->next;\n  delete tmp;\n}\n\n", "explain": "This uses the generic version of the link node. Of course, normally this would be just some implementation detail inside some list class, not to be used directly by client code.\nHere's the example code using that method:\nThe following code creates the links. As numeric values I've just taken the corresponding character values.\nNow insert c after a:\nFinally destroy the list:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Java", "code": "\n\nvoid insertNode(Node<T> anchor_node, Node<T> new_node)\n{\n    new_node.next = anchor_node.next;\n    anchor_node.next = new_node;\n}\n\nWorks with: Java version 1.5+\n\n", "explain": "Extending Singly-Linked_List_(element)#Java\nJava allows the use of generics to allow the data type to be determined at compile time. This will only work on reference types, not primitive types like int or float (wrapper classes like Integer and Float are available).\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "C#", "code": "\n\nstatic void InsertAfter<T>(LinkedListNode<T> prev, T value)\n{\n    prev.Next = new Link() { Value = value, Next = prev.Next };\n}\n\nstatic void Main()\n{\n    //Create A(5)->B(7)\n    var A = new LinkedListNode<int>() { Value = 5 };\n    InsertAfter(A, 7);\n    //Insert C between A and B\n    InsertAfter(A, 15);\n}\n\n", "explain": "Uses the generic version of the node type located here.\nCreates nodes and inserts them from the data passed.\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\n\nLinkedList.prototype.insertAfter = function(searchValue, nodeToInsert) {\n    if (this._value == searchValue) {\n        nodeToInsert.next(this.next());\n        this.next(nodeToInsert);\n    }\n    else if (this.next() == null) \n        throw new Error(0, \"value '\" + searchValue + \"' not found in linked list.\")\n    else\n        this.next().insertAfter(searchValue, nodeToInsert);\n}\nvar list = createLinkedListFromArray(['A','B']);\nlist.insertAfter('A', new LinkedList('C', null));\n\n", "explain": "Extending Singly-Linked_List_(element)#JavaScript\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Fortran", "code": "\n\nelemental subroutine addAfter(nodeBefore,value)\n   type (node), intent(inout) :: nodeBefore\n   real, intent(in)           :: value\n   type (node), pointer       :: newNode\n   \n   allocate(newNode)\n   newNode%data = value\n   newNode%next => nodeBefore%next\n   nodeBefore%next => newNode\nend subroutine addAfter\n\n", "explain": "In ISO Fortran 95 or later:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\ntype Ele struct {\n    Data interface{}\n    Next *Ele\n}\n\nfunc (e *Ele) insert(data interface{}) {\n    if e == nil {\n        panic(\"attept to modify nil\")\n    }\n    e.Next = &Ele{data, e.Next}\n}\n\nfunc (e *Ele) printList() {\n    if e == nil {\n        fmt.Println(nil)\n        return\n    }\n    fmt.Printf(\"(%v\", e.Data)\n    for {\n        e = e.Next\n        if e == nil {\n            fmt.Println(\")\")\n            return\n        }\n        fmt.Print(\" \", e.Data)\n    }\n}\n\nfunc main() {\n    h := &Ele{\"A\", &Ele{\"B\", nil}}\n    h.printList()\n    h.insert(\"C\")\n    h.printList()\n}\n\n\n(A B)\n(A C B)\n\n", "explain": "Output:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program insertList.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ READ,   3\n.equ WRITE,  4\n\n.equ NBELEMENTS,      100                @ list size\n\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure linkedlist*/\n    .struct  0\nllist_next:                               @ next element\n    .struct  llist_next + 4 \nllist_value:                              @ element value\n    .struct  llist_value + 4 \nllist_fin:\n/* Initialized data */\n.data\nszMessInitListe:         .asciz \"List initialized.\\n\"\nszCarriageReturn:        .asciz \"\\n\"\n/* datas error display */\nszMessErreur:            .asciz \"Error detected.\\n\"\n/* datas message display */\nszMessResult:            .ascii \"Element No\u00a0:\"\nsNumElement:             .space 12,' '\n                         .ascii \" value\u00a0:  \"\nsValue:                  .space 12,' '\n                         .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \nlList1:              .skip llist_fin * NBELEMENTS    @ list memory place \n/*  code section */\n.text\n.global main \nmain: \n    ldr r0,iAdrlList1\n    mov r1,#0                           @ list init\n    str r1,[r0,#llist_next]\n    ldr r0,iAdrszMessInitListe\n    bl affichageMess\n    ldr r0,iAdrlList1\n    mov r1,#2\n    bl insertElement                    @ add element value 2\n    ldr r0,iAdrlList1\n    mov r1,#5\n    bl insertElement                    @ add element value 5\n    ldr r3,iAdrlList1\n    mov r2,#0                           @ ident element\n1:\n    ldr r0,[r3,#llist_next]             @ end list\u00a0?\n    cmp r0,#0\n    beq 100f                            @ yes\n    add r2,#1\n    mov r0,r2                           @ display No element and value\n    ldr r1,iAdrsNumElement\n    bl conversion10S\n    ldr r0,[r3,#llist_value]\n    ldr r1,iAdrsValue\n    bl conversion10S\n    ldr r0,iAdrszMessResult\n    bl affichageMess\n    ldr r3,[r3,#llist_next]             @ next element\n    b 1b                                @ and loop\n100:                                    @ standard end of the program\n    mov r7, #EXIT                       @ request to exit program\n    svc 0                               @ perform system call\niAdrszMessInitListe:       .int szMessInitListe\niAdrszMessErreur:          .int szMessErreur\niAdrszCarriageReturn:      .int szCarriageReturn\niAdrlList1:                .int lList1\niAdrszMessResult:          .int szMessResult\niAdrsNumElement:           .int sNumElement\niAdrsValue:                .int sValue\n\n/******************************************************************/\n/*     insert element at end of list                          */ \n/******************************************************************/\n/* r0 contains the address of the list */\n/* r1 contains the value of element  */\n/* r0 returns address of element or - 1 if error */\ninsertElement:\n    push {r1-r3,lr}                       @ save  registers \n    mov r2,#llist_fin * NBELEMENTS\n    add r2,r0                             @ compute address end list\n1:                                        @ start loop \n    ldr r3,[r0,#llist_next]               @ load next pointer\n    cmp r3,#0                             @ = zero\n    movne r0,r3                           @ no -> loop with pointer\n    bne 1b\n    add r3,r0,#llist_fin                  @ yes -> compute next free address\n    cmp r3,r2                             @ > list end \n    movge r0,#-1                          @ yes -> error\n    bge 100f\n    str r3,[r0,#llist_next]               @ store next address in current pointer\n    str r1,[r0,#llist_value]              @ store element value\n    mov r1,#0\n    str r1,[r3,#llist_next]               @ init next pointer in next address\n\n100:\n    pop {r1-r3,lr}                        @ restaur registers\n    bx lr                                 @ return\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n/***************************************************/\n/*  Converting a register to a signed decimal      */\n/***************************************************/\n/* r0 contains value and r1 area address    */\nconversion10S:\n    push {r0-r4,lr}       @ save registers\n    mov r2,r1             @ debut zone stockage\n    mov r3,#'+'           @ par defaut le signe est +\n    cmp r0,#0             @ negative number\u00a0? \n    movlt r3,#'-'         @ yes\n    mvnlt r0,r0           @ number inversion\n    addlt r0,#1\n    mov r4,#10            @ length area\n1:                        @ start loop\n    bl divisionpar10U\n    add r1,#48            @ digit\n    strb r1,[r2,r4]       @ store digit on area\n    sub r4,r4,#1          @ previous position\n    cmp r0,#0             @ stop if quotient = 0\n    bne 1b\t\n\n    strb r3,[r2,r4]       @ store signe \n    subs r4,r4,#1         @ previous position\n    blt  100f             @ if r4 < 0 -> end\n\n    mov r1,#' '           @ space\n2:\n    strb r1,[r2,r4]       @store byte space\n    subs r4,r4,#1         @ previous position\n    bge 2b                @ loop if r4 > 0\n100: \n    pop {r0-r4,lr}        @ restaur registers\n    bx lr  \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient    */\n/* r1 remainder   */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    //mov r3,#0xCCCD                                   @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                  @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "X86_Assembly", "code": "\n; x86_64 Linux NASM\n; Linked_List_Insert.asm\n\n%ifndef INSERT\n%define INSERT\n\n%include \"Linked_List_Definition.asm\"\u00a0; see LL def task\n%include \"Heap_Alloc.asm\"\u00a0; see memory allocation task\n\nsection .text\n\n; rdi - link to insert after\n; rsi - value that the new link will hold\nInsert_After:\n  push rdi\n  push rsi\n  mov rdi, linkSize\n  call alloc\n  cmp rax, 0\n  je Memory_Allocation_Failure_Exception\n  pop rdi\n  mov dword [rax + value], edi\n  pop rdi\n  mov rsi, qword [rdi + next]\n  mov qword [rax + next], rsi\n  mov qword [rdi + next], rax\n  ret\n\n%endif\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Delphi", "code": "\n\n// Using the same type defs from the one way list example.\n\nType\n\n  // The pointer to the list structure\n  pOneWayList = ^OneWayList;\n\n  // The list structure\n  OneWayList = record\n                 pData : pointer ;\n                 Next  : pOneWayList ;\n               end;\n\n// I will illustrate a simple function that will return a pointer to the \n// new node or it will return NIL.  In this example I will always insert\n// right, to keep the code clear.  Since I am using a function all operations\n// for the new node will be conducted on the functions result.  This seems\n// somewhat counter intuitive, but it is the simplest way to accomplish this.\n\nFunction InsertNode(VAR CurrentNode:pOneWayList): pOneWayList\nbegin\n\n    // I try not to introduce different parts of the language, and keep each\n    // example to just the code required.  in this case it is important to use\n    // a try/except block.  In any OS that is multi-threaded and has many apps\n    // running at the same time, you cannot rely on a call to check memory available\n    // and then attempting to allocate.  In the time between the two, another \n    // program may have grabbed the memory you were trying to get.\n\n    Try\n      // Try to allocate enough memory for a variable the size of OneWayList\n      GetMem(Result,SizeOf(OneWayList));\n    Except\n      On EOutOfMemoryError do\n         begin\n           Result := NIL\n           exit;\n         end;\n    end;\n\n    // Initialize the variable.\n    Result.Next  := NIL ;\n    Reuslt.pdata := NIL ;\n\n    // Ok now we will insert to the right.\n\n    // Is the Next pointer of CurrentNode Nil?  If it is we are just tacking\n    // on to the end of the list.\n\n    if CurrentNode.Next = NIL then\n       CurrentNode.Next := Result\n    else\n      // We are inserting into the middle of this list\n      Begin\n         Result.Next      := CurrentNode.Next ;\n         CurrentNode.Next := result ;\n      end;\nend;\n\n", "explain": "A simple insertion into a one way list. I use a generic pointer for the data that way it can point to any structure, individual variable or whatever. NOTE: For original versions of Turbo Pascal, substitute the MemAvail Function for the Try Except block as this does not exist in this version of the pascal language. Also, Turbo Pascal doesn't have C++-style comments, therefore those have to be replaced with Pascal style comments, i.e. { ... } or (* ... *).\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Ruby", "code": "\nclass ListNode\n  def insert_after(search_value, new_value)\n    if search_value == value\n      self.succ = self.class.new(new_value, succ)\n    elsif self.succ.nil?\n      raise StandardError, \"value #{search_value} not found in list\"\n    else\n      self.succ.insert_after(search_value, new_value)\n    end\n  end\nend\n\nlist = ListNode.new(:a, ListNode.new(:b))\nlist.insert_after(:a, :c)\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Rust", "code": "\n\nimpl<T> List<T> {\n    pub fn new() -> Self {\n        List { head: None }\n    }\n\n    pub fn push(&mut self, elem: T) {\n    let new_node = Box::new(Node {\n        elem: elem,\n        next: self.head.take(),\n    });\n    self.head = Some(new_node);\n}\n\n", "explain": "Extending Singly-Linked List (element)#Rust. Please see that page for the Linked List struct declarations. \n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Ada", "code": "\n\nwith Ada.Unchecked_Deallocation;\n-- Define the link type\nprocedure Singly_Linked is\n   \n   type Link;\n   type Link_Access is access Link;\n   type Link is record\n      Data : Integer;\n      Next : Link_Access := null;\n   end record;\n   -- Instantiate the generic deallocator for the link type\n   procedure Free is new Ada.Unchecked_Deallocation(Link, Link_Access);\n\n   -- Define the procedure\n   procedure Insert_Append(Anchor : Link_Access; Newbie : Link_Access) is\n   begin\n      if Anchor /= null and Newbie /= null then\n         Newbie.Next := Anchor.Next;\n         Anchor.Next := Newbie;\n      end if;\n   end Insert_Append;\n\n   -- Create the link elements\n   A : Link_Access := new Link'(1, null);\n   B : Link_Access := new Link'(2, null);\n   C : Link_Access := new Link'(3, null);  \n-- Execute the program\nbegin\n   Insert_Append(A, B);\n   Insert_Append(A, C);\n   Free(A);\n   Free(B);\n   Free(C);\nend Singly_Linked;\n\n", "explain": "We must create a context clause making the predefined generic procedure Ada.Unchecked_Deallocation visible to this program.\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nfunction Base.insert!(ll::LinkedList{T}, index::Integer, item::T) where T\n    if index == 1\n        if isempty(ll)\n            return push!(ll, item)\n        else\n            ll.head = Node{T}(item, ll.head)\n        end\n    else\n        nd = ll.head\n        while index > 2\n            if nd.next isa EmptyNode\n                throw(BoundsError())\n            else\n                nd = nd.next\n                index -= 1\n            end\n        end\n        nd.next = Node{T}(item, nd.next)\n    end\n    return ll\nend\n\n", "explain": "See the LinkedList implemented at Singly-linked_list/Element_definition#Julia.\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nclass Node<T: Number>(var data: T, var next: Node<T>? = null) {\n    override fun toString(): String {\n        val sb = StringBuilder(this.data.toString())\n        var node = this.next\n        while (node != null) {\n            sb.append(\" -> \", node.data.toString())\n            node = node.next\n        }\n        return sb.toString()\n    }\n}\n\nfun <T: Number> insertAfter(prev: Node<T>, new: Node<T>) {\n    new.next = prev.next\n    prev.next = new\n}\n\nfun main(args: Array<String>) {\n    val b = Node(3)\n    val a = Node(1, b)\n    println(\"Before insertion\u00a0: $a\")\n    val c = Node(2)\n    insertAfter(a, c)\n    println(\"After  insertion\u00a0: $a\")\n}\n\n\nOutput:\nBefore insertion\u00a0: 1 -> 3\nAfter  insertion\u00a0: 1 -> 2 -> 3\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Perl", "code": "\n\nmy @l  = ($A, $B);\npush @l, $C, splice @l, 1;\n\n\nsub insert_after {\n  # first argument: node to insert after\n  # second argument: node to insert\n  $_[1]{next} = $_[0]{next};\n  $_[0]{next} = $_[1];\n}\n\nmy %B = (\n    data => 3,\n    next => undef, # not a circular list\n);\nmy %A = (\n    data => 1,\n    next => \\%B,\n);\nmy %C = (\n    data => 2,\n);\ninsert_after \\%A, \\%C;\n\n\n insert_after \\%A, { data => 2 };\n\n\nsub insert_after {\n  my $node = $_[0];\n  my $next = $node->{next};\n  shift;\n  while (defined $_[0]) {\n    $node->{next} = $_[0];\n    $node = $node->{next};\n    shift;\n  }\n  $node->{next} = $next;\n}\n\n\nmy %list = ( data => 'A' );\ninsert_after \\%list, { data => 'B' }, { data => 'C' };\n\n\nmy $list2;\n\n# create a new list ('A'. 'B', 'C') and store it in $list2\ninsert_after $list2 = { data => 'A' }, { data => 'B' }, { data => 'C' };\n\n# append two new nodes ('D', 'E') after the first element\ninsert_after $list2, { data => 'A2' }, { data => 'A3' };\n\n# append new nodes ('A2a', 'A2b') after the second element (which now is 'A2')\ninsert_after $list2->{next}, { data => 'A2a' }, { data => 'A2b' };\n\n", "explain": "If you don't really need the constant-time insertion property of singly linked lists, just use an array. You can traverse and splice it any way.\nHowever, if you really need a linked list, or all you got is an algorithm in a foreign language, you can use references to accomplish the translation.\nNote that you don't have to name your new nodes. The following works just as well:\nNote the curly braces instead of round parentheses.\nIt is straightforward to extend the function to take an arbitrary number of list nodes to insert:\nWith this, it's rather easy to build a list:\nList handling is simplified if the variables themselves contain references. For example:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Scala", "code": "\n\n/*\nHere is a basic list definition\n\nsealed trait List[+A]\ncase class Cons[+A](head: A, tail: List[A]) extends List[A]\ncase object Nil extends List[Nothing]\n*/\n\nobject List {\n  def add[A](as: List[A], a: A): List[A] = Cons(a, as)\n}\n\n", "explain": "In Scala (and functional programming) we create a new list instead of modifying existing one.\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "D", "code": "\nstruct SLinkedNode(T) {\n    T data;\n    typeof(this)* next;\n}\n\nvoid insertAfter(T)(SLinkedNode!T* listNode, SLinkedNode!T* newNode) {\n    newNode.next = listNode.next;\n    listNode.next = newNode;\n}\n\nvoid main() {\n    alias N = SLinkedNode!char;\n\n    auto lh = new N('A', new N('B'));\n    auto c = new N('C');\n\n    // Inserts C after A, creating the (A C B) list:\n    insertAfter(lh, c);\n\n    // The GC will collect the memory.\n}\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\ninsertAfter a b (c:cs) | a==c = a : b : cs\n                       | otherwise = c : insertAfter a b cs\ninsertAfter _ _ [] = error \"Can't insert\"\n\n", "explain": "This kind of list manipulation is unidiomatic Haskell. But you can try the following:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Scheme", "code": "\n\n(define (insert-after a b lst)\n  (if (null? lst)\n      lst       ; This should be an error, but we will just return the list untouched\n      (let ((c (car lst))\n            (cs (cdr lst)))\n        (if (equal? a c)\n            (cons a (cons b cs))\n            (cons c (insert-after a b cs))))))\n\n\n(define (insert-after! a b lst)\n  (let ((pos (member a lst)))\n    (if pos\n        (set-cdr! pos (cons b (cdr pos))))))\n\n", "explain": "Non-mutating:\nMutating:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Logo", "code": "\nto insert :after :list :value\n  localmake \"tail member :after :list\n  if not empty? :tail [.setbf :tail fput :value bf :tail]\n  output :list\nend\n\nshow insert 5 [3 5 1 8] 2\n[3 5 2 1 8]\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\nclass NodeList {\n    private enum Flag { FRONT }\n    private ListNode head\n    void insert(value, insertionPoint=Flag.FRONT) {\n        if (insertionPoint == Flag.FRONT) {\n            head = new ListNode(payload: value, next: head)\n        } else {\n            def node = head\n            while (node.payload != insertionPoint) {\n                node = node.next\n                if (node == null) {\n                    throw new IllegalArgumentException(\n                        \"Insertion point ${afterValue} not already contained in list\")\n                }\n            }\n            node.next = new ListNode(payload:value, next:node.next)\n        }\n    }\n    String toString() { \"${head}\" }\n}\n\n\ndef list = new NodeList()\nlist.insert('B')\nlist.insert('A')\nprintln list\n\nlist.insert('C', 'A')\nprintln list\n\n\nA -> B -> null\nA -> C -> B -> null\n", "explain": "Solution (uses ListNode from Singly-Linked List (element)#Groovy):\nTest:\nOutput:\n"}, {"task_name": "Singly-linked list/Element insertion", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_insertion", "task_cat": "Data Structures", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n\nconst allocator = arena.allocator();\n\npub fn LinkedList(comptime Value: type) type {\n    return struct {\n        const This = @This();\n\n        const Node = struct {\n            value: Value,\n            next: ?*Node,\n        };\n\n        head: ?*Node,\n        tail: ?*Node,\n\n        pub fn init() This {\n            return LinkedList(Value) {\n                .head = null,\n                .tail = null,\n            };\n        }\n\n        pub fn add(this: *This, value: Value) !void {\n            var newNode = try allocator.create(Node);\n\n            newNode.* = .{ .value = value, .next = null };\n\n            if (this.tail) |tail| {\n                tail.next = newNode;\n                this.tail = newNode;\n            } else if (this.head) |head| {\n                head.next = newNode;\n                this.tail = newNode;\n            } else {\n                this.head = newNode;\n            }\n        }\n    };\n}\n\n\nvar l1 = LinkedList(i32).init();\n\n\ntry list.add(1);\n\n\n\n\n", "explain": "Create a new list:\nAdd element:\n"}]