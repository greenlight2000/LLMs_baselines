[{"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Python", "code": "\n>>> import platform, sys, socket\n>>> platform.architecture()\n('64bit', 'ELF')\n>>> platform.machine()\n'x86_64'\n>>> platform.node()\n'yourhostname'\n>>> platform.system()\n'Linux'\n>>> sys.byteorder\nlittle\n>>> socket.gethostname()\n'yourhostname'\n>>>\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "C", "code": "\n#include <stdio.h>\n#include <stddef.h> /* for size_t */\n#include <limits.h> /* for CHAR_BIT */\n\nint main() {\n    int one = 1;\n\n    /*\n     * Best bet: size_t typically is exactly one word.\n     */\n    printf(\"word size = %d bits\\n\", (int)(CHAR_BIT * sizeof(size_t)));\n\n    /*\n     * Check if the least significant bit is located\n     * in the lowest-address byte.\n     */\n    if (*(char *)&one)\n        printf(\"little endian\\n\");\n    else\n        printf(\"big endian\\n\");\n    return 0;\n}\n\n\n#include <stdio.h>\n#include <arpa/inet.h>\n\nint main()\n{\n  if (htonl(1) == 1)\n    printf(\"big endian\\n\");\n  else\n    printf(\"little endian\\n\");\n}\n\n", "explain": "On POSIX-compatible systems, the following also tests the endianness (this makes use of the fact that network order is big endian):\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "C++", "code": "\n#include <bit>\n#include <iostream>\n\nint main()\n{\n    std::cout << \"int is \" << sizeof(int) << \" bytes\\n\";\n    std::cout << \"a pointer is \" << sizeof(int*) << \" bytes\\n\\n\";\n\n    if (std::endian::native == std::endian::big)\n    {\n        std::cout << \"platform is big-endian\\n\";\n    }\n    else\n    {\n        std::cout << \"host is little-endian\\n\";\n    }\n}\n\n\nOutput:\nint is 4 bytes\na pointer is 8 bytes\n\nhost is little-endian\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Java", "code": "\n\nWorks with: Java version 1.4\nimport java.nio.ByteOrder;\n\npublic class ShowByteOrder {\n    public static void main(String[] args) {\n        // Print \"BIG_ENDIAN\" or \"LITTLE_ENDIAN\".\n        System.out.println(ByteOrder.nativeOrder());\n    }\n}\n\n\nSystem.out.println(\"word size: \"+System.getProperty(\"sun.arch.data.model\"));\nSystem.out.println(\"endianness: \"+System.getProperty(\"sun.cpu.endian\"));\n\n", "explain": "Java conceals the byte order of its integers, but reports the native byte order through java.nio.ByteOrder.nativeOrder().\nSome JVMs also have system properties for the word size and byte order.\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "C#", "code": "\nstatic void Main()\n{\n  Console.WriteLine(\"Word size = {0} bytes,\",sizeof(int));\n\n  if (BitConverter.IsLittleEndian)\n    Console.WriteLine(\"Little-endian.\");\n  else\n    Console.WriteLine(\"Big-endian.\");\n}\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and < 2018\n   integer :: i\n   character(len=1) :: c(20)\n   equivalence (c, i)\n\n   WRITE(*,*) bit_size(1)  ! number of bits in the default integer type\n                           ! which may (or may not!) equal the word size\n   i = 1\n\n   IF (ichar(c(1)) == 0) THEN\n      WRITE(*,*) \"Big Endian\"\n   ELSE\n     WRITE(*,*) \"Little Endian\"\n   END IF\n\nWorks with: Fortran version  77 and later\n      PROGRAM endianness\n      IMPLICIT NONE\n      INTEGER(KIND=4)  :: i = 1\n\n      !ISHFT(INTEGER, SHIFT)\u00a0: Left shift if SHIFT > 0\n      !ISHFT(INTEGER, SHIFT)\u00a0: Right shift if SHIFT < 0\n      IF (ISHFT(i,1) .EQ. 0) THEN\n        WRITE(*,FMT='(A)') 'Architechture is Big Endian'\n      ELSE\n        WRITE(*,FMT='(A)') 'Architecture is Little Endian'\n      END IF\n\n      RETURN\n\n      STOP\n      END PROGRAM endianness\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"runtime\"\n\t\"strconv\"\n\t\"strings\"\n\t\"unsafe\"\n)\n\nfunc main() {\n\tfmt.Println(runtime.Version(), runtime.GOOS, runtime.GOARCH)\n\n\t// Inspect a uint32 variable to determine endianness.\n\tx := uint32(0x01020304)\n\tswitch *(*byte)(unsafe.Pointer(&x)) {\n\tcase 0x01:\n\t\tfmt.Println(\"big endian\")\n\tcase 0x04:\n\t\tfmt.Println(\"little endian\")\n\tdefault:\n\t\tfmt.Println(\"mixed endian?\")\n\t}\n\n\t// Usually one cares about the size the executible was compiled for\n\t// rather than the actual underlying host's size.\n\n\t// There are several ways of determining the size of an int/uint.\n\tfmt.Println(\"         strconv.IntSize =\", strconv.IntSize)\n\t// That uses the following definition we can also be done by hand\n\tintSize := 32 << uint(^uint(0)>>63)\n\tfmt.Println(\"32 << uint(^uint(0)>>63) =\", intSize)\n\n\t// With Go\u00a01.0, 64-bit architectures had 32-bit int and 64-bit\n\t// uintptr. This was changed in Go\u00a01.1. In general it would\n\t// still be possible that int and uintptr (the type large enough\n\t// to hold the bit pattern of any pointer) are of different sizes.\n\tconst bitsPerByte = 8\n\tfmt.Println(\"  sizeof(int)     in bits:\", unsafe.Sizeof(int(0))*bitsPerByte)\n\tfmt.Println(\"  sizeof(uintptr) in bits:\", unsafe.Sizeof(uintptr(0))*bitsPerByte)\n\t// If we really want to know the architecture size the executable was\n\t// compiled for and not the size of int it safest to take the max of those.\n\tarchSize := unsafe.Sizeof(int(0))\n\tif psize := unsafe.Sizeof(uintptr(0)); psize > archSize {\n\t\tarchSize = psize\n\t}\n\tfmt.Println(\"  compiled with word size:\", archSize*bitsPerByte)\n\n\t// There are some *very* unportable ways to attempt to get the actual\n\t// underlying hosts' word size.\n\t// Inspect cpuinfo to determine word size (some unix-like OS' only).\n\tc, err := ioutil.ReadFile(\"/proc/cpuinfo\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\treturn\n\t}\n\tls := strings.Split(string(c), \"\\n\")\n\tfor _, l := range ls {\n\t\tif strings.HasPrefix(l, \"flags\") {\n\t\t\tfor _, f := range strings.Fields(l) {\n\t\t\t\tif f == \"lm\" { // \"long mode\"\n\t\t\t\t\tfmt.Println(\"64 bit word size\")\n\t\t\t\t\treturn\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Println(\"32 bit word size\")\n\t\t\treturn\n\t\t}\n\t}\n}\n\n\nOutput:\ngo1.3.1 freebsd amd64\nlittle endian\n         strconv.IntSize = 64\n32 << uint(^uint(0)>>63) = 64\n  sizeof(int)     in bits: 64\n  sizeof(uintptr) in bits: 64\n  compiled with word size: 64\nopen /proc/cpuinfo: no such file or directory\n\ngo1.3.1 freebsd 386\nlittle endian\n         strconv.IntSize = 32\n32 << uint(^uint(0)>>63) = 32\n  sizeof(int)     in bits: 32\n  sizeof(uintptr) in bits: 32\n  compiled with word size: 32\nopen /proc/cpuinfo: no such file or directory\n\ngo1.3.1 nacl amd64p32\nlittle endian\n         strconv.IntSize = 32\n32 << uint(^uint(0)>>63) = 32\n  sizeof(int)     in bits: 32\n  sizeof(uintptr) in bits: 32\n  compiled with word size: 32\nopen /proc/cpuinfo: No such file or directory\n\n\npackage main\n\nimport (\n    \"debug/elf\"\n    \"fmt\"\n    \"os\"\n)\n\nfunc main() {\n    f, err := elf.Open(os.Args[0])\n    if err != nil {\n        fmt.Println(\"  \", err)\n        return\n    }\n    fmt.Println(f.FileHeader.ByteOrder)\n    f.Close()\n}\n\n\nOutput:\nLittleEndian\n\n", "explain": "Alternative technique:\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "ARM_Assembly", "code": "\n\nEndianTest:\nmov r0,#0xFF\nmov r1,#0x02000000   ;an arbitrary memory location on the Game Boy Advance. \n                    \u00a0;(The GBA is always little-endian but this test doesn't use that knowledge to prove it.)\nstr r0,[r1]          ;on a little-endian CPU a hexdump of 0x02000000 would be: FF 00 00 00\n                     ;on a big-endian CPU it would be:                         00 00 00 FF\nldrB r0,[r1]         ;load just the byte at 0x02000000. If the machine is big-endian this will load 00; if little-endian, 0xFF.\ncmp r0,#0\nbeq isBigEndian\n;else, do whatever is needed to display \"little-endian\" to the screen. This part isn't implemented.\n", "explain": "The word size of the ARM is 32-bit, which can't really be proven without knowing it ahead of time. \nThe ARM CPU's endianness can be set to either little-endian or big-endian. Not all ARM CPUs have this feature, but this test will work regardless of whether the endian switch features exist on any particular model or not. The easiest way to test endianness is to write a word to RAM, then read the 0th byte from that memory location and see what it is. (The example below uses VASM syntax.)\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "MIPS_Assembly", "code": "\n\n\tjal Cls\t ;Zero Graphics cursor position\n\tnop      ;on the PlayStation, the instruction AFTER a branch gets executed BEFORE the branch actually occurs. \n                 ;The Nintendo 64 didn't have this \"feature\" but for compatibility's sake \n                \u00a0;      it's staying in regardless of which version of the code I'm using.\n\n\tla a2,TestData\t\t;Load address of TestData\n\t\n\tlw a0,(a2)\t\t;Load Word into A0 from address in A2\n\t\n\taddiu a2,4              ;pointer arithmetic to load the next word.\n\tlw a1,(a2) \n        \n        move t6,ra\n        jal MonitorA0A1RAPC\n        nop\n        \n\tli t6,2\t\t        ;Line Count - 2 lines = 16 bytes\n\tjal MemDump\t        ;Dump Ram to screen\n\tnop\n\t\nhalt:\t\n\tj halt                  ;loop forever\n\tnop\n\n\n\n\nTestData:\n\t.byte 0xF3,0xF2,0xF1,0xF0   ;this will load as F0F1F2F3 on little-endian machines, and as-is on big-endian\n\t.word 0xF0F1F2F3            ;this will load as F0F1F2F3 regardless of endianness.\n\nOutput:\n\na0:F0F1F2F3 a1:F0F1F2F3\n\na0:F3F2F1F0 a1:F0F1F2F3\n\n", "explain": "This uses Keith S.'s tutorial at Chibialiens.com to print memory and show register contents.\nAs I've come to find out, MIPS is a bi-endian architecture (meaning its endianness is implementation-defined rather than a constant trait of the CPU.) In particular, the PlayStation 1 is little-endian, and the Nintendo 64 is big-endian. This can be proven with the test below. (Hardware-specific routines MonitorA0A1RAPC and MemDump are omitted just to keep things brief.)\nRegister Dump of PlayStation 1:\nRegister Dump of Nintendo 64:\nIt also seems the registers are 32-bit even on the N64. I wouldn't have expected that to be honest...\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Delphi", "code": "\nprogram HostIntrospection ;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nbegin\n  Writeln('word size: ', SizeOf(Integer));\n  Writeln('endianness: little endian'); // Windows is always little endian\nend.\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Ruby", "code": "\n# We assume that a Fixnum occupies one machine word.\n# Fixnum#size returns bytes (1 byte = 8 bits).\nword_size = 42.size * 8\nputs \"Word size: #{word_size} bits\"\n\n# Array#pack knows the native byte order. We pack 1 as a 16-bit integer,\n# then unpack bytes: [0, 1] is big endian, [1, 0] is little endian.\nbytes = [1].pack('S').unpack('C*')\nbyte_order = (bytes[0] == 0 ? 'big' : 'little') + ' endian'\nputs \"Byte order: #{byte_order}\"\n\n\n", "explain": "With MRI, ri Fixnum states, \"A Fixnum holds Integer values that can be represented in a native machine word (minus 1 bit).\" This bases our claim that a Fixnum occupies one machine word.\nSome other implementations of Ruby are different. With JRuby, a Fixnum is always 64 bits, because it is a Java long (1). JRuby uses the correct native byte order by calling java.nio.ByteOrder.nativeOrder() (2).\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Rust", "code": "\n#[derive(Copy, Clone, Debug)]\nenum Endianness {\n    Big, Little,\n}\n\nimpl Endianness {\n    fn target() -> Self {\n        #[cfg(target_endian = \"big\")]\n        {\n            Endianness::Big\n        }\n        #[cfg(not(target_endian = \"big\"))]\n        {\n            Endianness::Little\n        }\n    }\n}\n\nfn main() {\n    println!(\"Word size: {} bytes\", std::mem::size_of::<usize>());\n    println!(\"Endianness: {:?}\", Endianness::target());\n}\n\n\nOutput:\nWord size: 8 bytes\nEndianness: Little\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "R", "code": "\n\n8 * .Machine$sizeof.long # e.g. 32\n\n\n.Platform$endian         # e.g. \"little\"\n\n", "explain": "Word size\nEndianness\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\nwith System;       use System;\n\nprocedure Host_Introspection is\nbegin\n   Put_Line (\"Word size\" & Integer'Image (Word_Size));\n   Put_Line (\"Endianness \" & Bit_Order'Image (Default_Bit_Order));\nend Host_Introspection;\n\n\nSample output on a Pentium machine:\nWord size 32\nEndianness LOW_ORDER_FIRST\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Julia", "code": "\n\nprint(\"This host's word size is \", WORD_SIZE, \".\")\nif ENDIAN_BOM == 0x04030201\n    println(\"And it is a little-endian machine.\")\nelseif ENDIAN_BOM == 0x01020304\n    println(\"And it is a big-endian machine.\")\nelse\n    println(\"ENDIAN_BOM = \", ENDIAN_BOM, \", which is confusing\")\nend\n\n\nOutput:\nThis host's word size is 64.And it is a little-endian machine.\n\n", "explain": "Julia creates ENDIAN_BOM a 32 bit unsigned integer out of an array of 4 8 bit unsigned integers to serve as an endianness marker.\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Kotlin", "code": "\n\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    println(\"Word size\u00a0: ${System.getProperty(\"sun.arch.data.model\")} bits\")\n    println(\"Endianness: ${System.getProperty(\"sun.cpu.endian\")}-endian\")\n}\n\n\nOutput:\nWord size\u00a0: 64 bits\nEndianness: little-endian\n\n", "explain": "The following is not guaranteed to work on all JVMs but is working fine on my x64 Windows 10 machine:\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Perl", "code": "\n\nuse Config;\nprint \"UV size: $Config{uvsize}, byte order: $Config{byteorder}\\n\";\n\n\nOutput:\nUV size: 4, byte order: 1234\n\n\nuse 5.010;\nuse Config;\nmy ($size, $order, $end) = @Config{qw(uvsize byteorder)};\ngiven ($order) {\n    when (join '', sort split '') { $end = 'little' }\n    when (join '', reverse sort split '') { $end = 'big' }\n    default { $end = 'mixed' }\n}\nsay \"UV size: $size, byte order: $order ($end-endian)\";\n\n\nOutput:\nUV size: 4, byte order: 1234 (little-endian)\n\nUV size: 4, byte order: 3412 (mixed-endian)\n\nUV size: 8, byte order: 87654321 (big-endian)\n\n", "explain": "Most basic example:\nMore verbose example:\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Objective-C", "code": "\n\nswitch (NSHostByteOrder()) {\n  case NS_BigEndian:\n    NSLog(@\"%@\", @\"Big Endian\");\n    break;\n  case NS_LittleEndian:\n    NSLog(@\"%@\", @\"Little Endian\");\n    break;\n  case NS_UnknownByteOrder:\n    NSLog(@\"%@\", @\"endianness unknown\");\n    break;\n}\n\n\nswitch ([NSRunningApplication currentApplication].executableArchitecture) {\n  case NSBundleExecutableArchitectureI386:\n    NSLog(@\"%@\", @\"i386 32-bit\");\n    break;\n\n  case NSBundleExecutableArchitectureX86_64:\n    NSLog(@\"%@\", @\"x86_64 64-bit\");\n    break;\n\n  case NSBundleExecutableArchitecturePPC:\n    NSLog(@\"%@\", @\"PPC 32-bit\");\n    break;\n\n  case NSBundleExecutableArchitecturePPC64:\n    NSLog(@\"%@\", @\"PPC64 64-bit\");\n    break;\n\n  default:\n    NSLog(@\"%@\", @\"Unknown\");\n    break;\n}\n\n", "explain": "Endianness:\nArchitecture:\n(works on Mac OS X 10.6+)\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Lua", "code": "\n\nffi = require(\"ffi\")\nprint(\"size of int (in bytes):  \" .. ffi.sizeof(ffi.new(\"int\")))\nprint(\"size of pointer (in bytes):  \" .. ffi.sizeof(ffi.new(\"int*\")))\nprint((ffi.abi(\"le\") and \"little\" or \"big\") .. \" endian\")\n\n\nOutput:\nsize of int (in bytes):  4\nsize of pointer (in bytes):  8\nlittle endian\n", "explain": "Pure/native Lua can't do this (and essentially doesn't care).  However, Lua is often used in a scripting environment, where such issues may be important, and any needed support would be expected to be provided by the host or some other external library.  Here using ffi:\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Scala", "code": "\nLibrary: Scalaimport java.nio.ByteOrder\n\nobject ShowByteOrder extends App {\n  println(ByteOrder.nativeOrder())\n  println(s\"Word size: ${System.getProperty(\"sun.arch.data.model\")}\")\n  println(s\"Endianness: ${System.getProperty(\"sun.cpu.endian\")}\")\n}\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "D", "code": "\nvoid main() {\n  import std.stdio, std.system;\n\n  writeln(\"Word size = \", size_t.sizeof * 8, \" bits.\");\n  writeln(endian == Endian.littleEndian ? \"Little\" : \"Big\", \" endian.\");\n}\n\n\nOutput:\nWord size = 64 bits.\nLittle endian.\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Haskell", "code": "\nimport Data.Bits\nimport ADNS.Endian -- http://hackage.haskell.org/package/hsdns\n\nmain = do\n  putStrLn $ \"Word size: \" ++ bitsize\n  putStrLn $ \"Endianness: \" ++ show endian\n      where\n        bitsize = show $ bitSize (undefined :: Int)\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Scheme", "code": "\nWorks with: Chicken Scheme(define host-info\n  (begin\n    (display \"Endianness: \")\n    (display (machine-byte-order))\n    (newline)\n    (display \"Word Size: \")\n    (display (if (fixnum? (expt 2 33)) 64 32))\n    (newline)))\n\n\nOutput:\nEndianness: little-endian\nWord Size: 32\n\n", "explain": ""}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "PowerShell", "code": "\nWrite-Host Word Size: ((Get-WMIObject Win32_Processor).DataWidth)\nWrite-Host -NoNewLine \"Endianness: \"\nif ([BitConverter]::IsLittleEndian) {\n    Write-Host Little-Endian\n} else {\n    Write-Host Big-Endian\n}\n\n\n", "explain": "Note that endianness is essentially a moot point with PowerShell, \nas there is only a Windows implementation currently \nand current Windows versions don't run on big-endian systems. \nBut in theory this check should work.\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "F#", "code": "\n\nopen System\nopen System.Runtime.InteropServices\nopen System.Diagnostics\n\n[<DllImport(\"kernel32.dll\", SetLastError = true, CallingConvention = CallingConvention.Winapi)>]\nextern bool IsWow64Process(nativeint hProcess, bool &wow64Process);\n\nlet answerHostInfo =\n    let Is64Bit() =\n        let mutable f64Bit = false;\n        IsWow64Process(Process.GetCurrentProcess().Handle, &f64Bit) |> ignore\n        f64Bit\n    let IsLittleEndian() = BitConverter.IsLittleEndian\n    (IsLittleEndian(), Is64Bit())\n\n", "explain": "A lot of research before I finally came up with an answer to this that isn't dependent on the machine it was compiled on.  Works on Win32 machines only (obviously, due to the interop).  I think that strictly speaking, I should be double checking the OS version before making the call to wow64Process, but I'm not worrying about it.\n"}, {"task_name": "Host introspection", "task_url": "https://rosettacode.org/wiki/Host_introspection", "task_cat": "Programming environment operations", "lang": "Groovy", "code": "\n\nprintln \"word size:  ${System.getProperty('sun.arch.data.model')}\"\nprintln \"endianness: ${System.getProperty('sun.cpu.endian')}\"\n\n\nOutput:\nword size:  64\nendianness: little\n", "explain": "Solution follows Java:\n"}]