[{"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Python", "code": "\nPython: Raymond Hettingers permutations based solution[edit]\n\nfrom itertools import permutations\n\nn = 8\ncols = range(n)\nfor vec in permutations(cols):\n    if n == len(set(vec[i]+i for i in cols)) \\\n         == len(set(vec[i]-i for i in cols)):\n        print ( vec )\n\ndef board(vec):\n    print (\"\\n\".join('.' * i + 'Q' + '.' * (n-i-1) for i in vec) + \"\\n===\\n\")\n\nWith the solution represented as a vector with one queen in each row, we don't have to check to see if two queens are on the same row. By using a permutation generator, we know that no value in the vector is repeated, so we don't have to check to see if two queens are on the same column. Since rook moves don't need to be checked, we only need to check bishop moves.\nThe technique for checking the diagonals is to add or subtract the column number from each entry, so any two entries on the same diagonal will have the same value (in other words, the sum or difference is unique for each diagonal). Now all we have to do is make sure that the diagonals for each of the eight queens are distinct. So, we put them in a set (which eliminates duplicates) and check that the set length is eight (no duplicates were removed).\nAny permutation with non-overlapping diagonals is a solution. So, we print it and continue checking other permutations.\n\nPython: Alternative Solution[edit]\n\nWorks with: Python version 2.6, 3.x\n# From: http://wiki.python.org/moin/SimplePrograms, with permission from the author, Steve Howell\nBOARD_SIZE = 8\n\ndef under_attack(col, queens):\n    return col in queens or \\\n           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens))\n\ndef solve(n):\n    solutions = [[]]\n    for row in range(n):\n        solutions = [solution+[i+1]\n                       for solution in solutions\n                       for i in range(BOARD_SIZE)\n                       if not under_attack(i+1, solution)]\n    return solutions\n\nfor answer in solve(BOARD_SIZE): print(list(enumerate(answer, start=1)))\nPython: Simple Backtracking Solution[edit]\n\nWorks with: Python version 2.6, 3.x\nBOARD_SIZE = 8\n\ndef under_attack(col, queens):\n    return col in queens or \\\n           any(abs(col - x) == len(queens)-i for i,x in enumerate(queens))\n\ndef solve(n):\n    solutions = [[]]\n    for row in range(n):\n        solutions = (solution+[i+1]\n                       for solution in solutions # first for clause is evaluated immediately,\n                                                 # so \"solutions\" is correctly captured\n                       for i in range(BOARD_SIZE)\n                       if not under_attack(i+1, solution))\n    return solutions\n\nanswers = solve(BOARD_SIZE)\nfirst_answer = next(answers)\nprint(list(enumerate(first_answer, start=1)))\nPython: Simple Backtracking Solution (Niklaus Wirth Algorithm)[edit]\n\ndef queens(n, i, a, b, c):\n    if i < n:\n        for j in range(n):\n            if j not in a and i + j not in b and i - j not in c:\n                yield from queens(n, i + 1, a + [j], b + [i + j], c + [i - j])\n    else:\n        yield a\n\nfor solution in queens(8, 0, [], [], []):\n    print(solution)\n\ndef queens(x, i, a, b, c):\n    if a:  # a is not empty\n        for j in a:\n            if i + j not in b and i - j not in c:\n                yield from queens(x + [j], i + 1, a - {j}, b | {i + j}, c | {i - j})\n    else:\n        yield x\n\nfor solution in queens([], 0, set(range(8)), set(), set()):\n    print(solution)\nPython: backtracking on permutations[edit]\n\ndef queens(n):\n    a = list(range(n))\n    up = [True]*(2*n - 1)\n    down = [True]*(2*n - 1)\n    def sub(i):\n        if i == n:\n            yield tuple(a)\n        else:\n            for k in range(i, n):\n                j = a[k]\n                p = i + j\n                q = i - j + n - 1\n                if up[p] and down[q]:\n                    up[p] = down[q] = False\n                    a[i], a[k] = a[k], a[i]\n                    yield from sub(i + 1)\n                    up[p] = down[q] = True\n                    a[i], a[k] = a[k], a[i]\n    yield from sub(0)\n\n#Count solutions for n=8:\nsum(1 for p in queens(8))\n92\n\ndef queens_lex(n):\n    a = list(range(n))\n    up = [True]*(2*n - 1)\n    down = [True]*(2*n - 1)\n    def sub(i):\n        if i == n:\n            yield tuple(a)\n        else:\n            for k in range(i, n):\n                a[i], a[k] = a[k], a[i]\n                j = a[i]\n                p = i + j\n                q = i - j + n - 1\n                if up[p] and down[q]:\n                    up[p] = down[q] = False\n                    yield from sub(i + 1)\n                    up[p] = down[q] = True\n            x = a[i]\n            for k in range(i + 1, n):\n                a[k - 1] = a[k]\n            a[n - 1] = x\n    yield from sub(0)\n\nnext(queens(31))\n(0, 2, 4, 1, 3, 8, 10, 12, 14, 6, 17, 21, 26, 28, 25, 27, 24, 30, 7, 5, 29, 15, 13, 11, 9, 18, 22, 19, 23, 16, 20)\n\nnext(queens_lex(31))\n(0, 2, 4, 1, 3, 8, 10, 12, 14, 5, 17, 22, 25, 27, 30, 24, 26, 29, 6, 16, 28, 13, 9, 7, 19, 11, 15, 18, 21, 23, 20)\n\n#Compare to A065188\n#1, 3, 5, 2, 4, 9, 11, 13, 15, 6, 8, 19, 7, 22, 10, 25, 27, 29, 31, 12, 14, 35, 37, ...\nPython: fold/reduce[edit]\n\nWorks with: Python version 3.7\n'''N Queens problem'''\n\nfrom functools import reduce\nfrom itertools import chain\n\n\n# queenPuzzle\u00a0:: Int -> Int -> [[Int]]\ndef queenPuzzle(nCols):\n    '''All board patterns of this dimension\n       in which no two Queens share a row,\n       column, or diagonal.\n    '''\n    def go(nRows):\n        lessRows = nRows - 1\n        return reduce(\n            lambda a, xys: a + reduce(\n                lambda b, iCol: b + [xys + [iCol]] if (\n                    safe(lessRows, iCol, xys)\n                ) else b,\n                enumFromTo(1)(nCols),\n                []\n            ),\n            go(lessRows),\n            []\n        ) if 0 < nRows else [[]]\n    return go\n\n\n# safe\u00a0:: Int -> Int -> [Int] -> Bool\ndef safe(iRow, iCol, pattern):\n    '''True if no two queens in the pattern\n       share a row, column or diagonal.\n    '''\n    def p(sc, sr):\n        return (iCol == sc) or (\n            sc + sr == (iCol + iRow)\n        ) or (sc - sr == (iCol - iRow))\n    return not any(map(p, pattern, range(0, iRow)))\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Number of solutions for boards of various sizes'''\n\n    n = 5\n    xs = queenPuzzle(n)(n)\n\n    print(\n        str(len(xs)) + ' solutions for a {n} * {n} board:\\n'.format(n=n)\n    )\n    print(showBoards(10)(xs))\n\n    print(\n        fTable(\n            '\\n\\n' + main.__doc__ + ':\\n'\n        )(str)(lambda n: str(n).rjust(3, ' '))(\n            lambda n: len(queenPuzzle(n)(n))\n        )(enumFromTo(1)(10))\n    )\n\n\n# ---------------------- FORMATTING ----------------------\n\n# showBoards\u00a0:: Int -> [[Int]] -> String\ndef showBoards(nCols):\n    '''String representation, with N columns\n       of a set of board patterns.\n    '''\n    def showBlock(b):\n        return '\\n'.join(map(intercalate('  '), zip(*b)))\n\n    def go(bs):\n        return '\\n\\n'.join(map(\n            showBlock,\n            chunksOf(nCols)([\n                showBoard(b) for b in bs\n            ])\n        ))\n    return go\n\n\n# showBoard\u00a0:: [Int] -> String\ndef showBoard(xs):\n    '''String representation of a Queens board.'''\n    lng = len(xs)\n\n    def showLine(n):\n        return ('.' * (n - 1)) + '\u265b' + ('.' * (lng - n))\n    return map(showLine, xs)\n\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: range(m, 1 + n)\n\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n, subdividing the\n       contents of xs. Where the length of xs is not evenly\n       divible, the final list will be shorter than n.\n    '''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# intercalate\u00a0:: [a] -> [[a]] -> [a]\n# intercalate\u00a0:: String -> [String] -> String\ndef intercalate(x):\n    '''The concatenation of xs\n       interspersed with copies of x.\n    '''\n    return lambda xs: x.join(xs) if isinstance(x, str) else list(\n        chain.from_iterable(\n            reduce(lambda a, v: a + [x, v], xs[1:], [xs[0]])\n        )\n    ) if xs else []\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\n10 solutions for a 5 * 5 board:\n\n\u265b....  \u265b....  .\u265b...  .\u265b...  ..\u265b..  ..\u265b..  ...\u265b.  ...\u265b.  ....\u265b  ....\u265b\n..\u265b..  ...\u265b.  ...\u265b.  ....\u265b  \u265b....  ....\u265b  \u265b....  .\u265b...  .\u265b...  ..\u265b..\n....\u265b  .\u265b...  \u265b....  ..\u265b..  ...\u265b.  .\u265b...  ..\u265b..  ....\u265b  ...\u265b.  \u265b....\n.\u265b...  ....\u265b  ..\u265b..  \u265b....  .\u265b...  ...\u265b.  ....\u265b  ..\u265b..  \u265b....  ...\u265b.\n...\u265b.  ..\u265b..  ....\u265b  ...\u265b.  ....\u265b  \u265b....  .\u265b...  \u265b....  ..\u265b..  .\u265b...\n\nNumber of solutions for boards of various sizes:\n\n 1 ->   1\n 2 ->   0\n 3 ->   0\n 4 ->   2\n 5 ->  10\n 6 ->   4\n 7 ->  40\n 8 ->  92\n 9 -> 352\n10 -> 724\n", "explain": "This solution, originally by Raymond Hettinger for demonstrating the power of the itertools module, generates all solutions. On a regular 8x8 board only 40,320 possible queen positions are examined.\nThe output is presented in vector form (each number represents the column position of a queen on consecutive rows). \nThe vector can be pretty printed by substituting a call to board instead of print, with the same argument, and where board is pre-defined as:\nRaymond's description is:\nOne disadvantage with this solution is that we can't simply \"skip\" all the permutations that start with a certain prefix, after discovering that that prefix is incompatible. \nFor example, it is easy to verify that no permutation of the form (1,2,...) could ever be a solution, but since we don't have control over the generation of the permutations, we can't just tell it to \"skip\" all the ones that start with (1,2).\nOn a regular 8x8 board only 15,720 possible queen positions are examined.\nA surprisingly simple change to the above code (changing the list comprehension \nto a generator expression) produces a backtracking solution. On a regular 8x8 board only 15,720 possible queen positions are examined.\nThe following program is a translation of Niklaus Wirth's solution into the Python programming language, but does without the index arithmetic used in the original and uses simple lists instead, which means that the array x for recording the solution can be omitted. A generator replaces the procedure (see Algorithms and Data Structures, pages 114 to 118). On a regular 8x8 board only 15,720 possible queen positions are examined.\nThe algorithm can be slightly improved by using sets instead of lists (cf. backtracking on permutations). But this makes the algorithm a bit harder to read, since the list x has to be added to record the solution. On a regular 8x8 board only 5,508 possible queen positions are examined. However, since these two solutions are intended for educational purposes, they are neither resource-friendly nor optimized for speed. The next program (backtracking on permutations) shows a much faster solution that also uses less space on the stack.\nQueens positions on a n x n board are encoded as permutations of [0, 1, ..., n]. The algorithms consists in building a permutation from left to right, by swapping elements of the initial [0, 1, ..., n], recursively calling itself unless the current position is not possible. The test is done by checking only diagonals, since rows/columns have by definition of a permutation, only one queen.\nThis is initially a translation of the Fortran 77 solution. On a regular 8x8 board only 5,508 possible queen positions are examined.\nThe solutions are returned as a generator, using the \"yield from\" functionality of Python 3.3, described in PEP-380.\nThe preceding function does not enumerate solutions in lexicographic order, see Permutations#Recursive implementation for an explanation. The following does, but is almost 50% slower, because the exchange is always made (otherwise the loop to shift the array a by one place would not work). On a regular 8x8 board only 5,508 possible queen positions are examined.\nHowever, it may be interesting to look at the first solution in lexicographic order: for growing n, and apart from a +1 offset, it gets closer and closer to the sequence A065188 at OEIS. The first n for which the first solutions differ is n=26.\nExpressed in terms of nested folds, allowing for graphic display of results, and listing the number of solutions found for boards of various sizes. On a regular 8x8 board only 15,720 possible queen positions are examined.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "C", "code": "\nC99, compiled with gcc -std=c99 -Wall.  Take one commandline argument: size of board, or default to 8. Shows the board layout for each solution.#include <stdio.h>\n#include <stdlib.h>\n\nint count = 0;\nvoid solve(int n, int col, int *hist)\n{\n\tif (col == n) {\n\t\tprintf(\"\\nNo. %d\\n-----\\n\", ++count);\n\t\tfor (int i = 0; i < n; i++, putchar('\\n'))\n\t\t\tfor (int j = 0; j < n; j++)\n\t\t\t\tputchar(j == hist[i] ? 'Q' : ((i + j) & 1) ? ' ' : '.');\n\n\t\treturn;\n\t}\n\n#\tdefine attack(i, j) (hist[j] == i || abs(hist[j] - i) == col - j)\n\tfor (int i = 0, j = 0; i < n; i++) {\n\t\tfor (j = 0; j < col && !attack(i, j); j++);\n\t\tif (j < col) continue;\n\n\t\thist[col] = i;\n\t\tsolve(n, col + 1, hist);\n\t}\n}\n\nint main(int n, char **argv)\n{\n\tif (n <= 1 || (n = atoi(argv[1])) <= 0) n = 8;\n\tint hist[n];\n\tsolve(n, 0, hist);\n}\n\nSimiliar to above, but using bits to save board configurations and quite a bit faster:#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\ntypedef uint32_t uint;\nuint full, *qs, count = 0, nn;\n\nvoid solve(uint d, uint c, uint l, uint r)\n{\n\tuint b, a, *s;\n\tif (!d) {\n\t\tcount++;\n#if 0\n\t\tprintf(\"\\nNo. %d\\n===========\\n\", count);\n\t\tfor (a = 0; a < nn; a++, putchar('\\n'))\n\t\t\tfor (b = 0; b < nn; b++, putchar(' '))\n\t\t\t\tputchar(\" -QQ\"[((b == qs[a])<<1)|((a + b)&1)]);\n#endif\n\t\treturn;\n\t}\n\n\ta = (c | (l <<= 1) | (r >>= 1)) & full;\n\tif (a != full)\n\t\tfor (*(s = qs + --d) = 0, b = 1; b <= full; (*s)++, b <<= 1)\n\t\t\tif (!(b & a)) solve(d, b|c, b|l, b|r);\n}\n\nint main(int n, char **argv)\n{\n\tif (n <= 1 || (nn = atoi(argv[1])) <= 0) nn = 8;\n\n\tqs = calloc(nn, sizeof(int));\n\tfull = (1U << nn) - 1;\n\n\tsolve(nn, 0, 0, 0);\n\tprintf(\"\\nSolutions: %d\\n\", count);\n\treturn 0;\n}\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef unsigned int uint;\nuint count = 0;\n\n#define ulen sizeof(uint) * 8\n\n/* could have defined as int solve(...), but void may have less\n   chance to confuse poor optimizer */\nvoid solve(int n)\n{\n\tint cnt = 0;\n\tconst uint full = -(int)(1 << (ulen - n));\n\tregister uint bits, pos, *m, d, e;\n\n\tuint b0, b1, l[32], r[32], c[32], mm[33] = {0};\n\tn -= 3;\n\t/* require second queen to be left of the first queen, so\n\t   we ever only test half of the possible solutions. This\n\t   is why we can't handle n=1 here */\n\tfor (b0 = 1U << (ulen - n - 3); b0; b0 <<= 1) {\n\t\tfor (b1 = b0 << 2; b1; b1 <<= 1) {\n\t\t\td = n;\n\t\t\t/* c: columns occupied by previous queens.\n\t\t\t   l: columns attacked by left diagonals\n\t\t\t   r: by right diagnoals */\n\t\t\tc[n] = b0 | b1;\n\t\t\tl[n] = (b0 << 2) | (b1 << 1);\n\t\t\tr[n] = (b0 >> 2) | (b1 >> 1);\n\n\t\t\t/* availabe columns on current row. m is stack */\n\t\t\tbits = *(m = mm + 1) = full & ~(l[n] | r[n] | c[n]);\n\n\t\t\twhile (bits) {\n\t\t\t\t/* d: depth, aka row. counting backwards\n\t\t\t\t   because !d is often faster than d\u00a0!= n */\n\t\t\t\twhile (d) {\n\t\t\t\t\t/* pos is right most nonzero bit */\n\t\t\t\t\tpos = -(int)bits & bits;\n\n\t\t\t\t\t/* mark bit used. only put current bits\n\t\t\t\t\t   on stack if not zero, so backtracking\n\t\t\t\t\t   will skip exhausted rows (because reading\n\t\t\t\t\t   stack variable is sloooow compared to\n\t\t\t\t\t   registers) */\n\t\t\t\t\tif ((bits &= ~pos))\n\t\t\t\t\t\t*m++ = bits | d;\n\n\t\t\t\t\t/* faster than l[d+1] = l[d]... */\n\t\t\t\t\te = d--;\n\t\t\t\t\tl[d] = (l[e] | pos) << 1;\n\t\t\t\t\tr[d] = (r[e] | pos) >> 1;\n\t\t\t\t\tc[d] =  c[e] | pos;\n\n\t\t\t\t\tbits = full & ~(l[d] | r[d] | c[d]);\n\n\t\t\t\t\tif (!bits) break;\n\t\t\t\t\tif (!d) { cnt++; break; }\n\t\t\t\t}\n\t\t\t\t/* Bottom of stack m is a zero'd field acting\n\t\t\t\t   as sentinel.  When saving to stack, left\n\t\t\t\t   27 bits are the available columns, while\n\t\t\t\t   right 5 bits is the depth. Hence solution\n\t\t\t\t   is limited to size 27 board -- not that it\n\t\t\t\t   matters in foreseeable future. */\n\t\t\t\td = (bits = *--m) & 31U;\n\t\t\t\tbits &= ~31U;\n\t\t\t}\n\t\t}\n\t}\n\tcount = cnt * 2;\n}\n\nint main(int c, char **v)\n{\n\tint nn;\n\tif (c <= 1 || (nn = atoi(v[1])) <= 0) nn = 8;\n\n\tif (nn > 27) {\n\t\tfprintf(stderr, \"Value too large, abort\\n\");\n\t\texit(1);\n\t}\n\n\t/* Can't solve size 1 board; might as well skip 2 and 3 */\n\tif (nn < 4) count = nn == 1;\n\telse\t    solve(nn);\n\n\tprintf(\"\\nSolutions: %d\\n\", count);\n\treturn 0;\n}\n\n\n#include <stdio.h>\n#define MAXN 31\n\nint nqueens(int n)\n{\n  int q0,q1;\n  int cols[MAXN], diagl[MAXN], diagr[MAXN], posibs[MAXN]; // Our backtracking 'stack' \n  int num=0;\n  //\n  // The top level is two fors, to save one bit of symmetry in the enumeration by forcing second queen to\n  // be AFTER the first queen.\n  //\n  for (q0=0; q0<n-2; q0++) {\n    for (q1=q0+2; q1<n; q1++){\n      int bit0 = 1<<q0;\n      int bit1 = 1<<q1;\n      int d=0; // d is our depth in the backtrack stack \n      cols[0] = bit0 | bit1 | (-1<<n); // The -1 here is used to fill all 'coloumn' bits after n ...\n      diagl[0]= (bit0<<1 | bit1)<<1;\n      diagr[0]= (bit0>>1 | bit1)>>1;\n\n      //  The variable posib contains the bitmask of possibilities we still have to try in a given row ...\n      int posib = ~(cols[0] | diagl[0] | diagr[0]);\n\n      while (d >= 0) {\n        while(posib) {\n          int bit = posib & -posib; // The standard trick for getting the rightmost bit in the mask\n          int ncols= cols[d] | bit;\n          int ndiagl = (diagl[d] | bit) << 1;\n          int ndiagr = (diagr[d] | bit) >> 1;\n          int nposib = ~(ncols | ndiagl | ndiagr);\n          posib^=bit; // Eliminate the tried possibility.\n\n          // The following is the main additional trick here, as recognizing solution can not be done using stack level (d),\n          // since we save the depth+backtrack time at the end of the enumeration loop. However by noticing all coloumns are\n          // filled (comparison to -1) we know a solution was reached ...\n          // Notice also that avoiding an if on the ncols==-1 comparison is more efficient!\n          num += ncols==-1; \n\n          if (nposib) {\n            if (posib) { // This if saves stack depth + backtrack operations when we passed the last possibility in a row.\n              posibs[d++] = posib; // Go lower in stack ..\n            }\n            cols[d] = ncols;\n            diagl[d] = ndiagl;\n            diagr[d] = ndiagr;\n            posib = nposib;\n          }\n        }\n        posib = posibs[--d]; // backtrack ...\n      }\n    }\n  }\n  return num*2;\n}\n\n\nmain(int ac , char **av) \n{\n  if(ac != 2) {\n    printf(\"usage: nq n\\n\");\n    return 1;\n  }\n  int n = atoi(av[1]);\n  if(n<1 || n > MAXN) {\n    printf(\"n must be between 2 and 31!\\n\");\n  }\n  printf(\"Number of solution for %d is %d\\n\",n,nqueens(n));\n}\n\n", "explain": "Take that and unwrap the recursion, plus some heavy optimizations, and we have a very fast and very unreadable solution:\nA slightly cleaned up version of the code above where some optimizations were redundant. This version is also further optimized, and runs about 15% faster than the one above on modern compilers:\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "C++", "code": "\n// Much shorter than the version below;\n// uses C++11 threads to parallelize the computation; also uses backtracking\n// Outputs all solutions for any table size\n#include <vector>\n#include <iostream>\n#include <iomanip>\n#include <thread>\n#include <future>\n\n// Print table. 'pos' is a vector of positions \u2013 the index in pos is the row,\n// and the number at that index is the column where the queen is placed.\nstatic void print(const std::vector<int> &pos)\n{\n\t// print table header\n\tfor (int i = 0; i < pos.size(); i++) {\n\t\tstd::cout << std::setw(3) << char('a' + i);\n\t}\n\n\tstd::cout << '\\n';\n\n\tfor (int row = 0; row < pos.size(); row++) {\n\t\tint col = pos[row];\n\t\tstd::cout << row + 1 << std::setw(3 * col + 3) << \" # \";\n\t\tstd::cout << '\\n';\n\t}\n\n\tstd::cout << \"\\n\\n\";\n}\n\nstatic bool threatens(int row_a, int col_a, int row_b, int col_b)\n{\n\treturn row_a == row_b // same row\n\t\tor col_a == col_b // same column\n\t\tor std::abs(row_a - row_b) == std::abs(col_a - col_b); // diagonal\n}\n\n// the i-th queen is in the i-th row\n// we only check rows up to end_idx\n// so that the same function can be used for backtracking and checking the final solution\nstatic bool good(const std::vector<int> &pos, int end_idx)\n{\n\tfor (int row_a = 0; row_a < end_idx; row_a++) {\n\t\tfor (int row_b = row_a + 1; row_b < end_idx; row_b++) {\n\t\t\tint col_a = pos[row_a];\n\t\t\tint col_b = pos[row_b];\n\t\t\tif (threatens(row_a, col_a, row_b, col_b)) {\n\t\t\t\treturn false;\n\t\t\t}\n\t\t}\n\t}\n\n\treturn true;\n}\n\nstatic std::mutex print_count_mutex; // mutex protecting 'n_sols'\nstatic int n_sols = 0; // number of solutions\n\n// recursive DFS backtracking solver\nstatic void n_queens(std::vector<int> &pos, int index)\n{\n\t// if we have placed a queen in each row (i. e. we are at a leaf of the search tree), check solution and return\n\tif (index >= pos.size()) {\n\t\tif (good(pos, index)) {\n\t\t\tstd::lock_guard<std::mutex> lock(print_count_mutex);\n\t\t\tprint(pos);\n\t\t\tn_sols++;\n\t\t}\n\n\t\treturn;\n\t}\n\n\t// backtracking step\n\tif (not good(pos, index)) {\n\t\treturn;\n\t}\n\n\t// optimization: the first level of the search tree is parallelized\n\tif (index == 0) {\n\t\tstd::vector<std::future<void>> fts;\n\t\tfor (int col = 0; col < pos.size(); col++) {\n\t\t\tpos[index] = col;\n\t\t\tauto ft = std::async(std::launch::async, [=]{ auto cpos(pos); n_queens(cpos, index + 1); });\n\t\t\tfts.push_back(std::move(ft));\n\t\t}\n\n\t\tfor (const auto &ft : fts) {\n\t\t\tft.wait();\n\t\t}\n\t} else { // deeper levels are not\n\t\tfor (int col = 0; col < pos.size(); col++) {\n\t\t\tpos[index] = col;\n\t\t\tn_queens(pos, index + 1);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tstd::vector<int> start(12); // 12: table size\n\tn_queens(start, 0);\n\tstd::cout << n_sols << \" solutions found.\\n\";\n\treturn 0;\n}\n\n\nOutput:Output for N = 4\n\n  a  b  c  d                                                                                                  \n1    #                                                                                                        \n2          #                                                                                                  \n3 #                                                                                                           \n4       #                                                                                                     \n                                                                                                              \n                                                                                                              \n  a  b  c  d                                                                                                  \n1       #                                                                                                     \n2 #                                                                                                           \n3          #                                                                                                  \n4    #       \n// A straight-forward brute-force C++ version with formatted output,\n// eschewing obfuscation and C-isms, producing ALL solutions, which\n// works on any OS with a text terminal.\n//\n// Two basic optimizations are applied:\n//\n//   It uses backtracking to only construct potentially valid solutions.\n//\n//   It only computes half the solutions by brute -- once we get the\n//   queen halfway across the top row, any remaining solutions must be\n//   reflections of the ones already computed.\n//\n// This is a bare-bones example, without any progress feedback or output\n// formatting controls, which a more complete program might provide.\n//\n// Beware that computing anything larger than N=14 might take a while.\n// (Time gets exponentially worse the higher the number.)\n\n// Copyright 2014 Michael Thomas Greer\n// Distributed under the Boost Software License, Version 1.0.\n// http://www.boost.org/LICENSE_1_0.txt\n\n#include <algorithm>\n#include <ciso646>\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <sstream>\n#include <stdexcept>\n#include <string>\n#include <vector>\n\n\n// ///////////////////////////////////////////////////////////////////////////\nstruct queens\n/////////////////////////////////////////////////////////////////////////// //\n{\n  // TYPES -------------------------------------------------------------------\n\n  // A row or column index. (May be signed or unsigned.)\n  //\n  typedef signed char index_type;\n\n  // A 'solution' is a row --> column lookup of queens on the board.\n  //\n  // It has lexicographical order and can be transformed with a variety of\n  // reflections, which, when properly combined, produce all possible\n  // orientations of a solution.\n  //\n  struct solution_type: std::vector <index_type>\n  {\n    typedef std::vector <index_type> base_type;\n\n    // constructors  . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    solution_type( std::size_t N          ): base_type( N, -1 ) { }\n    solution_type( const solution_type& s ): base_type( s     ) { }\n\n    // compare . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    bool operator < ( const solution_type& s ) const\n    {\n      auto mm = std::mismatch( begin(), end(), s.begin() );\n      return (mm.first != end()) and (*mm.first < *mm.second);\n    }\n\n    // transformations . . . . . . . . . . . . . . . . . . . . . . . . . . . .\n    void vflip() { std::reverse( begin(), end() ); }\n\n    void hflip() { for (auto& x : *this) x = size() - 1 - x; }\n\n    void transpose()\n    {\n      solution_type result( size() );\n      for (index_type y = 0; (std::size_t)y < size(); y++)\n        result[ (*this)[ y ] ] = y;\n      swap( result );\n    }\n  };\n\n  // MEMBER VALUES -----------------------------------------------------------\n\n  const int                N;\n  std::set <solution_type> solutions;\n\n  // SOLVER ------------------------------------------------------------------\n\n  queens( int N = 8 ):\n    N( (N < 0) ? 0 : N )\n  {\n    // Row by row we create a potentially valid solution.\n    // If a queen can be placed in a valid spot by the time\n    // we get to the last row, then we've found a solution.\n\n    solution_type solution( N );\n    index_type row = 0;\n    while (true)\n    {\n      // Advance the queen along the row\n      ++solution[ row ];\n\n      // (If we get past halfway through the first row, we're done.)\n      if ((row == 0) and (solution[ 0 ] > N/2)) break;\n\n      if (solution[ row ] < N)\n      {\n        // If the queen is in a good spot...\n        if (ok( solution, row, solution[ row ] ))\n        {\n          // ...and we're on the last row\n          if (row == N-1)\n          {\n            // Add the solution we found plus all it's reflections\n            solution_type\n            s = solution;  solutions.insert( s );\n            s.vflip();     solutions.insert( s );\n            s.hflip();     solutions.insert( s );\n            s.vflip();     solutions.insert( s );\n            s.transpose(); solutions.insert( s );\n            s.vflip();     solutions.insert( s );\n            s.hflip();     solutions.insert( s );\n            s.vflip();     solutions.insert( s );\n          }\n          // otherwise begin marching a queen along the next row\n          else solution[ ++row ] = -1;\n        }\n\n      // When we get to the end of a row's columns then\n      // we need to backup a row and continue from there.\n      }\n      else --row;\n    }\n  }\n\n  // HELPER ------------------------------------------------------------------\n  // This routine helps the solver by identifying column locations\n  // that do not conflict with queens already placed in prior rows.\n\n  bool ok( const solution_type& columns, index_type row, index_type column )\n  {\n    for (index_type r = 0; r < row; r++)\n    {\n      index_type c         = columns[ r ];\n      index_type delta_row = row - r;\n      index_type delta_col = (c < column) ? (column - c) : (c - column);\n\n      if ((c == column) or (delta_row == delta_col))\n        return false;\n    }\n    return true;\n  }\n\n  // OUTPUT A SINGLE SOLUTION ------------------------------------------------\n  //\n  // Formatted as (for example):\n  //\n  //   d1 b2 g3 c4 f5 h6 e7 a8\n  //   Q - - - - - - -\n  //   - - - - Q - - -\n  //   - - - - - - - Q\n  //   - - - - - Q - -\n  //   - - Q - - - - -\n  //   - - - - - - Q -\n  //   - Q - - - - - -\n  //   - - - Q - - - -\n  //\n  friend\n  std::ostream&\n  operator << ( std::ostream& outs, const queens::solution_type& solution )\n  {\n    static const char* squares[] = { \"- \", \"Q \" };\n    index_type N = solution.size();\n\n    // Display the queen positions\n    for (auto n = N; n--; )\n      outs << (char)('a' + solution[ n ]) << (N - n) << \" \";\n\n    // Display the board\n    for (auto queen : solution)\n    {\n      outs << \"\\n\";\n      for (index_type col = 0; col < N; col++)\n        outs << squares[ col == queen ];\n    }\n    return outs;\n  }\n\n  // OUTPUT ALL SOLUTIONS ----------------------------------------------------\n  //\n  // Display \"no solutions\" or \"N solutions\" followed by\n  // each individual solution, separated by blank lines.\n\n  friend\n  std::ostream&\n  operator << ( std::ostream& outs, const queens& q )\n  {\n    if (q.solutions.empty()) outs << \"no\";\n    else                     outs << q.solutions.size();\n    outs << \" solutions\";\n\n    std::size_t n = 1;\n    for (auto solution : q.solutions)\n    {\n      outs << \"\\n\\n#\" << n++ << \"\\n\" << solution;\n    }\n\n    return outs;\n  }\n};\n\n\n/* ///////////////////////////////////////////////////////////////////////////\nstring_to <type> ( x )\n/////////////////////////////////////////////////////////////////////////// */\n\ntemplate <typename T>\nT string_to( const std::string& s )\n{\n  T result;\n  std::istringstream ss( s );\n  ss >> result;\n  if (!ss.eof()) throw std::runtime_error( \"to_string(): invalid conversion\" );\n  return result;\n}\n\ntemplate <typename T, T default_value>\nT string_to( const std::string& s )\n{\n  try { return string_to <T> ( s ); }\n  catch (...) { return default_value; }\n}\n\n\n/* ///////////////////////////////////////////////////////////////////////////\nmain program\n/////////////////////////////////////////////////////////////////////////// */\n\nint usage( const std::string& name )\n{\n  std::cerr <<\n    \"usage:\\n  \" << name << \" 8\\n\\n\"\n    \"\"\n    \"Solve the N-Queens problem, brute-force,\\n\"\n    \"and show all solutions for an 8x8 board.\\n\\n\"\n    \"\"\n    \"(Specify a value other than 8 for the board size you want.)\\n\";\n  return 1;\n}\n\nint main( int argc, char** argv )\n{\n  signed N =\n    (argc < 2) ? 8 :\n    (argc > 2) ? 0 : string_to <signed, 0> ( argv[ 1 ] );\n\n  if (N <= 0) return usage( argv[ 0 ] );\n\n  std::cout << queens( N ) << \"\\n\";\n}\n\n\nOutput: for N=4\n\n2 solutions\n\n#1\nc1 a2 d3 b4\n- Q - -\n- - - Q\nQ - - -\n- - Q -\n\n#2\nb1 d2 a3 c4\n- - Q -\nQ - - -\n- - - Q\n- Q - -\n\nAlternate version[edit]\n\n#include <windows.h>\n#include <iostream>\n#include <string>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nclass point\n{\npublic:\n    int x, y;\n    point(){ x = y = 0; }\n    void set( int a, int b ){ x = a; y = b; }\n};\n//--------------------------------------------------------------------------------------------------\nclass nQueens\n{\npublic:\n    void solve( int c )\n    {\n        _count = c; int len = ( c + 1 ) * ( c + 1 ); _queens = new bool[len]; memset( _queens, 0, len );\n\t_cl = new bool[c]; memset( _cl, 0, c ); _ln = new bool[c]; memset( _ln, 0, c );\n\tpoint pt; pt.set( rand() % c, rand() % c ); putQueens( pt, c ); displayBoard();\n\tdelete [] _queens; delete [] _ln; delete [] _cl;\n    }\n\nprivate:\n    void displayBoard()\n    {\n\tsystem( \"cls\" ); string t = \"+---+\", q = \"| Q |\", s = \"|   |\";\n\tCOORD c = { 0, 0 }; HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE );\n\tfor( int y = 0, cy = 0; y < _count; y++ )\n\t{\n\t    int yy = y * _count;\n\t    for( int x = 0; x < _count; x++ )\n\t    {\n\t\tSetConsoleCursorPosition( h, c ); cout << t;\n\t\tc.Y++; SetConsoleCursorPosition( h, c );\n\t\tif( _queens[x + yy] ) cout << q; else cout << s;\n\t\tc.Y++; SetConsoleCursorPosition( h, c );\n\t\tcout << t; c.Y = cy; c.X += 4;\n\t    }\n\t    cy += 2; c.X = 0; c.Y = cy;\n        }\n    }\n\n    bool checkD( int x, int y, int a, int b )\n    {\n\tif( x < 0 || y < 0 || x >= _count || y >= _count ) return true;\n\tif( _queens[x + y * _count] ) return false;\n\tif( checkD( x + a, y + b, a, b ) ) return true;\n\treturn false;\n    }\n\n    bool check( int x, int y )\n    {\n\tif( _ln[y] || _cl[x] )        return false;\n\tif( !checkD( x, y, -1, -1 ) ) return false;\n\tif( !checkD( x, y,  1, -1 ) ) return false;\n\tif( !checkD( x, y, -1,  1 ) ) return false;\n\tif( !checkD( x, y,  1,  1 ) ) return false;\n\treturn true;\n    }\n\n    bool putQueens( point pt, int cnt )\n    {\n\tint it = _count;\n\twhile( it )\n\t{\n\t    if( !cnt ) return true;\n\t    if( check( pt.x, pt.y ) )\n\t    {\n\t\t_queens[pt.x + pt.y * _count] = _cl[pt.x] = _ln[pt.y] = true;\n\t\tpoint tmp = pt; if( ++tmp.x >= _count ) tmp.x = 0; if( ++tmp.y >= _count ) tmp.y = 0;\n\t\tif( putQueens( tmp, cnt - 1 ) ) return true;\n\t\t_queens[pt.x + pt.y * _count] = _cl[pt.x] = _ln[pt.y] = false;\n\t    }\n\t    if( ++pt.x >= _count ) pt.x = 0;\n\t    it--;\n\t}\n\treturn false;\n    }\n\n    int          _count;\n    bool*        _queens, *_ln, *_cl;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    nQueens n; int nq;\n    while( true )\n    {\n\tsystem( \"cls\" ); cout << \"Enter board size bigger than 3 (0 - 3 to QUIT): \"; cin >> nq;\n\tif( nq < 4 ) return 0; n.solve( nq ); cout << endl << endl;\n\tsystem( \"pause\" );\n    }\n    return  0;\n}\n//--------------------------------------------------------------------------------------------------\n\n\nOutput:\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n| Q |   |   |   |   |   |   |   |   | Q |   |   |   |   |   |   |   |   |   |   |   |   | Q |   |   |   |\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n|   |   | Q |   |   |   |   | Q |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | Q |   |\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n|   |   |   |   | Q |   |   |   |   |   |   |   |   | Q |   |   |   |   | Q |   |   |   |   |   |   |   |\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n|   | Q |   |   |   |   |   |   |   |   |   | Q |   |   |   |   | Q |   |   |   |   |   |   |   |   |   |\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n|   |   |   | Q |   |   | Q |   |   |   |   |   |   |   |   |   |   |   |   | Q |   |   |   |   |   |   |\n+---+---+---+---+---+   +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n                        |   |   | Q |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   |   | Q |\n                        +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n                        |   |   |   |   | Q |   |   |   |   | Q |   |   |   |   |   |   |   |   |   |   |\n                        +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n                        |   |   |   |   |   |   | Q |   |   |   |   | Q |   |   |   |   |   |   |   |   |\n                        +---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+---+---+\n                                                            |   |   |   |   |   | Q |   |   |   |   |   |\n                                                            +---+---+---+---+---+---+---+---+---+---+---+\n                                                            |   |   |   |   |   |   |   |   | Q |   |   |\n                                                            +---+---+---+---+---+---+---+---+---+---+---+\n                                                            |   |   |   |   |   |   | Q |   |   |   |   |\n\t\t\t\t\t\t\t    +---+---+---+---+---+---+---+---+---+---+---+\n\n\n#include <windows.h>\n#include <iostream>\n#include <string>\n#include <vector>\n#include <algorithm>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\ntypedef unsigned int uint;\n\n//--------------------------------------------------------------------------------------------------\nclass nQueens_Heuristic\n{\npublic:\n    void solve( uint n ) { makeList( n ); drawBoard( n ); }\n\nprivate:\n    void drawBoard( uint n )\n    {\n\tsystem( \"cls\" ); string t = \"+---+\", q = \"| Q |\", s = \"|   |\";\n\tCOORD c = { 0, 0 }; HANDLE h = GetStdHandle( STD_OUTPUT_HANDLE );\n\tuint w = 0;\n\tfor( uint y = 0, cy = 0; y < n; y++ )\n\t{\n\t    for( uint x = 0; x < n; x++ )\n\t    {\n\t\tSetConsoleCursorPosition( h, c ); cout << t;\n\t\tc.Y++; SetConsoleCursorPosition( h, c );\n\t\tif( x + 1 == solution[w] ) cout << q; else cout << s;\n\t\tc.Y++; SetConsoleCursorPosition( h, c );\n\t\tcout << t; c.Y = cy; c.X += 4;\n\t    }\n\t    cy += 2; c.X = 0; c.Y = cy; w++;\n\t}\n\tsolution.clear(); odd.clear(); evn.clear();\n    }\n\n    void makeList( uint n )\n    {\n\tuint r = n % 6;\n\tfor( uint x = 1; x <= n; x++ )\n\t{\n\t    if( x & 1 ) odd.push_back( x );\n\t    else evn.push_back( x );\n\t}\n\tif( r == 2 )\n\t{\n\t    swap( odd[0], odd[1] );\n\t    odd.erase( find( odd.begin(), odd.end(), 5 ) );\n\t    odd.push_back( 5 );\n\t}\n\telse if( r == 3 )\n\t{\n\t    odd.erase( odd.begin() ); odd.erase( odd.begin() );\n\t    odd.push_back( 1 ); odd.push_back( 3 );\n\t    evn.erase( evn.begin() ); evn.push_back( 2 );\n\t}\n\tvector<uint>::iterator it = evn.begin();\n\twhile( it != evn.end() ) \n\t{\n\t    solution.push_back( ( *it ) );\n\t    it++;\n\t}\n\tit = odd.begin();\n\twhile( it != odd.end() ) \n\t{\n\t    solution.push_back( ( *it ) );\n\t    it++;\n\t}\n    }\n\n    vector<uint> odd, evn, solution;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    uint n; nQueens_Heuristic nQH;\n    while( true )\n    {\n\tcout << \"Enter board size bigger than 3 (0 - 3 to QUIT): \"; cin >> n;\n\tif( n < 4 ) return 0;\n\tnQH.solve( n ); cout << endl << endl;\n    }\n    return 0;\n}\n//--------------------------------------------------------------------------------------------------\n\n", "explain": "Windows-only\nVersion using Heuristics - explained here: Solution_construction\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Java", "code": "\npublic class NQueens {\n\n  private static int[] b = new int[8];\n  private static int s = 0;\n\n  static boolean unsafe(int y) {\n    int x = b[y];\n    for (int i = 1; i <= y; i++) {\n      int t = b[y - i];\n      if (t == x ||\n          t == x - i ||\n          t == x + i) {\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  public static void putboard() {\n    System.out.println(\"\\n\\nSolution \" + (++s));\n    for (int y = 0; y < 8; y++) {\n      for (int x = 0; x < 8; x++) {\n        System.out.print((b[y] == x) ? \"|Q\" : \"|_\");\n      }\n      System.out.println(\"|\");\n    }\n  }\n\n  public static void main(String[] args) {\n    int y = 0;\n    b[0] = -1;\n    while (y >= 0) {\n      do {\n        b[y]++;\n      } while ((b[y] < 8) && unsafe(y));\n      if (b[y] < 8) {\n        if (y < 7) {\n          b[++y] = -1;\n        } else {\n          putboard();\n        }\n      } else {\n        y--;\n      }\n    }\n  }\n}\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "C#", "code": "\nRoger Hui (1981) Algorithm[edit]\n\nTranslation of: J\nWorks with: C# version 7\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var combs = cols.Combinations(2).Select(pairs=> pairs.ToArray());\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where combs.All(c => Abs(v[c[0]] - v[c[1]]) != Abs(c[0] - c[1]))\n                         select v;\n            \n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        //Helpers \n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq) =>\n            seq.Aggregate(Empty<T>().ToSingleton(), (a, b) => a.Concat(a.Select(x => x.Append(b))));\n\n        public static IEnumerable<IEnumerable<T>> Combinations<T>(this IEnumerable<T> seq, int numItems) =>\n            seq.Combinations().Where(s => s.Count() == numItems);\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n\n\n8-queens has 92 solutions\nPosition is row, value is column:-\nFirst Solution: 0 4 7 5 2 6 1 3\n\nHettinger Algorithm[edit]\n\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing static System.Math;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var cols = Range(0, n);\n            var solved = from v in cols.Permutations().Select(p => p.ToArray())\n                         where n == (from i in cols select v[i]+i).Distinct().Count()\n                         where n == (from i in cols select v[i]-i).Distinct().Count()\n                         select v;\n\n            WriteLine($\"{n}-queens has {solved.Count()} solutions\");\n            WriteLine(\"Position is row, value is column:-\");\n            var first = string.Join(\" \", solved.First());\n            WriteLine($\"First Solution: {first}\");\n            Read();\n        }\n\n        //Helpers from https://gist.github.com/martinfreedman/139dd0ec7df4737651482241e48b062f\n\n        public static IEnumerable<IEnumerable<T>> Permutations<T>(this IEnumerable<T> values)\n        {\n            if (values.Count() == 1)\n                return values.ToSingleton();\n\n            return values.SelectMany(v => Permutations(values.Except(v.ToSingleton())), (v, p) => p.Prepend(v));\n        }\n\n        public static IEnumerable<T> ToSingleton<T>(this T item) { yield return item; }\n    }\n}\n\nAmb solution[edit]\n\nWorks with: C# version 7.1\nusing static System.Linq.Enumerable;\nusing static System.Console;\n\nnamespace N_Queens\n{\n    static class Program\n    {\n        static void Main(string[] args)\n        {\n            var n = 8;\n            var domain = Range(0, n).ToArray();\n\n            var amb = new Amb.Amb();\n            var queens = domain.Select(_ => amb.Choose(domain)).ToArray();\n            amb.Require(() => n == queens.Select(q=> q.Value).Distinct().Count());\n            amb.Require(() => n == domain.Select(i=> i + queens[i].Value).Distinct().Count());\n            amb.Require(() => n == domain.Select(i=> i - queens[i].Value).Distinct().Count());\n\n            if (amb.Disambiguate())\n            {\n                WriteLine(\"Position is row, value is column:-\");\n                WriteLine(string.Join(\" \", queens.AsEnumerable()));\n            }\n            else\n                WriteLine(\"amb is angry\");\n            Read();\n        }\n    }\n}\n\n", "explain": "From Hui, Roger, The N Queens Problem, APL Quote-Quad, Volume 11, Number 3, 1981-03:-\n\"In a solution, each possible row (column) index must appear exactly once: an index occurring more than once means that two queens are on the same row (column); and the absence of an index means that some other index must occur more than once. Hence, we can specify an arrangement as a permutation of \u2373n , which are the column indices, with the row indices understood to be \u2373n . With this, the number of possibilities is reduced from n!n\u00d7n to !n . It remains to eliminate arrangements having two queens on the same diagonal.\nIf two queens occupy the same diagonal, the line connecting them has slope 1 or \u00af1 . Conversely, if the line connecting two queens has slope 1 or \u00af1 , the two queens share a diagonal. Therefore, we seek to eliminate all permutations specifying a pair of queens where\n((change in y) \u00f7 (change in x)) \u220a 1 \u00af1 , or (|change in y) = (|change in x)\"\nOutput\nCompare this to the Hettinger solution used in the first Python answer. The logic is similar but the diagonal calculation is different and more expensive computationally (Both suffer from being unable to eliminate permutation prefixes that are invalid e.g.  0 1 ...)\nThis uses the second version of the Amb C# class in the Amb challenge. Really that is not McCarthy's Amb (Ambiguous function) and here it is used just as a simple general interface by lambdas to a standalone backtrack algorithm. Due to the specification of the Amb challenge, this, ironically (given the notion of ambiguous functions), only produces one solution not 92. It is trivial to update Amb (might be better called a backtracker rather than Amb too) but here it is just used to show how easy it is to go from a generate and prune Linq solution to a backtrack solution. The Linq filters becoming \"amb\" requirements.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\nES5[edit]\n\nfunction queenPuzzle(rows, columns) {\n    if (rows <= 0) {\n        return [[]];\n    } else {\n        return addQueen(rows - 1, columns);\n    }\n}\n\nfunction addQueen(newRow, columns, prevSolution) {\n    var newSolutions = [];\n    var prev = queenPuzzle(newRow, columns);\n    for (var i = 0; i < prev.length; i++) {\n        var solution = prev[i];\n        for (var newColumn = 0; newColumn < columns; newColumn++) {\n            if (!hasConflict(newRow, newColumn, solution))\n                newSolutions.push(solution.concat([newColumn]))\n        }\n    }\n    return newSolutions;\n}\n\nfunction hasConflict(newRow, newColumn, solution) {\n    for (var i = 0; i < newRow; i++) {\n        if (solution[i]     == newColumn          ||\n            solution[i] + i == newColumn + newRow || \n            solution[i] - i == newColumn - newRow) {\n                return true;\n        }\n    }\n    return false;\n}\n\nconsole.log(queenPuzzle(8,8));\n\nES6[edit]\n\n(() => {\n    \"use strict\";\n\n    // ---------------- N QUEENS PROBLEM -----------------\n\n    // queenPuzzle\u00a0:: Int -> Int -> [[Int]]\n    const queenPuzzle = intCols => {\n        // All solutions for a given number\n        // of columns and rows.\n        const go = nRows =>\n            nRows <= 0 ? [\n                []\n            ] : go(nRows - 1).reduce(\n                (a, solution) => [\n                    ...a, ...(\n                        enumFromTo(0)(intCols - 1)\n                        .reduce((b, iCol) =>\n                            safe(\n                                nRows - 1, iCol, solution\n                            ) ? (\n                                [...b, [...solution, iCol]]\n                            ) : b, [])\n                    )\n                ], []\n            );\n\n\n        return go;\n    };\n\n    // safe\u00a0: Int -> Int -> [Int] -> Bool\n    const safe = (iRow, iCol, solution) =>\n        !zip(solution)(\n            enumFromTo(0)(iRow - 1)\n        )\n        .some(\n            ([sc, sr]) => (iCol === sc) || (\n                sc + sr === iCol + iRow\n            ) || (sc - sr === iCol - iRow)\n        );\n\n    // ---------------------- TEST -----------------------\n    // Ten columns of solutions to the 7*7 board\n\n    // main\u00a0:: IO ()\n    const main = () =>\n        // eslint-disable-next-line no-console\n        console.log(\n            showSolutions(10)(7)\n        );\n\n    // --------------------- DISPLAY ---------------------\n\n    // showSolutions\u00a0:: Int -> Int -> String\n    const showSolutions = nCols =>\n        // Display of solutions, in nCols columns\n        // for a board of size N * N.\n        n => chunksOf(nCols)(\n            queenPuzzle(n)(n)\n        )\n        .map(xs => transpose(\n                xs.map(\n                    rows => rows.map(\n                        r => enumFromTo(1)(rows.length)\n                        .flatMap(\n                            x => r === x ? (\n                                \"\u265b\"\n                            ) : \".\"\n                        )\n                        .join(\"\")\n                    )\n                )\n            )\n            .map(cells => cells.join(\"  \"))\n        )\n        .map(x => x.join(\"\\n\"))\n        .join(\"\\n\\n\");\n\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // chunksOf\u00a0:: Int -> [a] -> [[a]]\n    const chunksOf = n => {\n        // xs split into sublists of length n.\n        // The last sublist will be short if n\n        // does not evenly divide the length of xs .\n        const go = xs => {\n            const chunk = xs.slice(0, n);\n\n            return Boolean(chunk.length) ? [\n                chunk, ...go(xs.slice(n))\n            ] : [];\n        };\n\n        return go;\n    };\n\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = m =>\n        n => Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n\n    // transpose_\u00a0:: [[a]] -> [[a]]\n    const transpose = rows =>\n        // The columns of the input transposed\n        // into new rows.\n        // Simpler version of transpose, assuming input\n        // rows of even length.\n        Boolean(rows.length) ? rows[0].map(\n            (_, i) => rows.flatMap(\n                v => v[i]\n            )\n        ) : [];\n\n\n    // zip\u00a0:: [a] -> [b] -> [(a, b)]\n    const zip = xs =>\n        // The paired members of xs and ys, up to\n        // the length of the shorter of the two lists.\n        ys => Array.from({\n            length: Math.min(xs.length, ys.length)\n        }, (_, i) => [xs[i], ys[i]]);\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n.......  .......  .......  .......  \u265b......  \u265b......  \u265b......  \u265b......  \u265b......  \u265b......\n.\u265b.....  ..\u265b....  ...\u265b...  ....\u265b..  ..\u265b....  ..\u265b....  ...\u265b...  ...\u265b...  ...\u265b...  ....\u265b..\n...\u265b...  .....\u265b.  \u265b......  ..\u265b....  .......  ....\u265b..  .......  .\u265b.....  .....\u265b.  .\u265b.....\n.....\u265b.  .\u265b.....  ....\u265b..  \u265b......  .....\u265b.  .......  ..\u265b....  .......  ..\u265b....  .....\u265b.\n\u265b......  ....\u265b..  .\u265b.....  .....\u265b.  ...\u265b...  .\u265b.....  .....\u265b.  .....\u265b.  .......  ..\u265b....\n..\u265b....  \u265b......  .....\u265b.  ...\u265b...  .\u265b.....  ...\u265b...  .\u265b.....  ..\u265b....  .\u265b.....  .......\n....\u265b..  ...\u265b...  ..\u265b....  .\u265b.....  ....\u265b..  .....\u265b.  ....\u265b..  ....\u265b..  ....\u265b..  ...\u265b...\n\n\u265b......  .\u265b.....  .\u265b.....  .\u265b.....  .\u265b.....  .\u265b.....  .\u265b.....  ..\u265b....  ..\u265b....  ..\u265b....\n.....\u265b.  .......  .......  ...\u265b...  ....\u265b..  .....\u265b.  .....\u265b.  .......  .......  \u265b......\n...\u265b...  ....\u265b..  ....\u265b..  .....\u265b.  \u265b......  \u265b......  ..\u265b....  .\u265b.....  ...\u265b...  .....\u265b.\n.\u265b.....  \u265b......  ..\u265b....  \u265b......  ...\u265b...  ..\u265b....  .......  ....\u265b..  \u265b......  ...\u265b...\n.......  ...\u265b...  \u265b......  ..\u265b....  .......  ....\u265b..  ...\u265b...  \u265b......  ....\u265b..  .\u265b.....\n....\u265b..  .....\u265b.  .....\u265b.  ....\u265b..  ..\u265b....  .......  \u265b......  .....\u265b.  .\u265b.....  .......\n..\u265b....  ..\u265b....  ...\u265b...  .......  .....\u265b.  ...\u265b...  ....\u265b..  ...\u265b...  .....\u265b.  ....\u265b..\n\n..\u265b....  ..\u265b....  ..\u265b....  ...\u265b...  ...\u265b...  ...\u265b...  ...\u265b...  ...\u265b...  ...\u265b...  ....\u265b..\n....\u265b..  .....\u265b.  .....\u265b.  .......  .......  \u265b......  .\u265b.....  .....\u265b.  .....\u265b.  .......\n.......  .\u265b.....  ...\u265b...  ..\u265b....  ....\u265b..  ....\u265b..  .......  \u265b......  \u265b......  .\u265b.....\n.\u265b.....  ....\u265b..  \u265b......  .....\u265b.  ..\u265b....  .\u265b.....  ....\u265b..  ..\u265b....  ....\u265b..  ...\u265b...\n...\u265b...  \u265b......  ....\u265b..  .\u265b.....  \u265b......  .....\u265b.  ..\u265b....  ....\u265b..  .\u265b.....  .....\u265b.\n.....\u265b.  ...\u265b...  .......  ....\u265b..  .....\u265b.  ..\u265b....  \u265b......  .......  .......  \u265b......\n\u265b......  .......  .\u265b.....  \u265b......  .\u265b.....  .......  .....\u265b.  .\u265b.....  ..\u265b....  ..\u265b....\n\n....\u265b..  ....\u265b..  ....\u265b..  ....\u265b..  ....\u265b..  ....\u265b..  .....\u265b.  .....\u265b.  .....\u265b.  .....\u265b.\n\u265b......  .\u265b.....  .\u265b.....  .\u265b.....  ..\u265b....  ..\u265b....  \u265b......  .\u265b.....  ..\u265b....  ...\u265b...\n...\u265b...  .......  ...\u265b...  .....\u265b.  \u265b......  .....\u265b.  ..\u265b....  ....\u265b..  .......  .\u265b.....\n.......  ..\u265b....  .....\u265b.  ..\u265b....  .....\u265b.  .......  ....\u265b..  \u265b......  ...\u265b...  .......\n..\u265b....  .....\u265b.  .......  .......  ...\u265b...  .\u265b.....  .......  ...\u265b...  \u265b......  ....\u265b..\n.....\u265b.  ...\u265b...  ..\u265b....  ...\u265b...  .\u265b.....  ...\u265b...  .\u265b.....  .......  ....\u265b..  ..\u265b....\n.\u265b.....  \u265b......  \u265b......  \u265b......  .......  \u265b......  ...\u265b...  ..\u265b....  .\u265b.....  \u265b......\n", "explain": "Algorithm uses recursive Backtracking. Checks for correct position on subfields, whichs saves a lot position checks. Needs 15.720 position checks for a 8x8 field.\nTranslating the ES5 version, and adding a function to display columns of solutions.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: BBC BASIC\n'N-queens problem - non recursive & structured - vb.net - 26/02/2017\nModule Mod_n_queens\n    Sub n_queens()\n        Const l = 15  'number of queens\n        Const b = False  'print option\n        Dim a(l), s(l), u(4 * l - 2)\n        Dim n, m, i, j, p, q, r, k, t, z\n        Dim w As String\n        For i = 1 To UBound(a)\u00a0: a(i) = i\u00a0: Next i\n        For n = 1 To l\n            m = 0\n            i = 1\n            j = 0\n            r = 2 * n - 1\n            Do\n                i = i - 1\n                j = j + 1\n                p = 0\n                q = -r\n                Do\n                    i = i + 1\n                    u(p) = 1\n                    u(q + r) = 1\n                    z = a(j)\u00a0: a(j) = a(i)\u00a0: a(i) = z  'Swap a(i), a(j)\n                    p = i - a(i) + n\n                    q = i + a(i) - 1\n                    s(i) = j\n                    j = i + 1\n                Loop Until j > n Or u(p) Or u(q + r)\n                If u(p) = 0 Then\n                    If u(q + r) = 0 Then\n                        m = m + 1  'm: number of solutions\n                        If b Then\n                            Debug.Print(\"n=\" & n & \" m=\" & m)\u00a0: w = \"\"\n                            For k = 1 To n\n                                For t = 1 To n\n                                    w = w & If(a(n - k + 1) = t, \"Q\", \".\")\n                                Next t\n                                Debug.Print(w)\n                            Next k\n                        End If\n                    End If\n                End If\n                j = s(i)\n                Do While j >= n And i <> 0\n                    Do\n                        z = a(j)\u00a0: a(j) = a(i)\u00a0: a(i) = z  'Swap a(i), a(j)\n                        j = j - 1\n                    Loop Until j < i\n                    i = i - 1\n                    p = i - a(i) + n\n                    q = i + a(i) - 1\n                    j = s(i)\n                    u(p) = 0\n                    u(q + r) = 0\n                Loop\n            Loop Until i = 0\n            Debug.Print(n & vbTab & m)  'number of queens, number of solutions\n        Next n\n    End Sub 'n_queens\nEnd Module\n\nOutput:\n1   1\n2   0\n3   0\n4   2\n5   10\n6   4\n7   40\n8   92\n9   352\n10  724\n11  2680\n12  14200\n13  73712\n14  365596\n15  2279184 \n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "SQL", "code": "\n\nWITH RECURSIVE\n  positions(i) as (\n    VALUES(0)\n    UNION SELECT ALL\n    i+1 FROM positions WHERE i < 63\n    ),\n  solutions(board, n_queens) AS (\n    SELECT '----------------------------------------------------------------', cast(0 AS bigint) \n      FROM positions\n    UNION\n    SELECT\n      substr(board, 1, i) || '*' || substr(board, i+2),n_queens + 1 as n_queens\n      FROM positions AS ps, solutions \n    WHERE n_queens < 8\n      AND substr(board,1,i)\u00a0!= '*'\n      AND NOT EXISTS (\n        SELECT 1 FROM positions WHERE\n          substr(board,i+1,1) = '*' AND\n            (\n                i\u00a0% 8 = ps.i %8 OR\n                cast(i / 8 AS INT) = cast(ps.i / 8 AS INT) OR\n                cast(i / 8 AS INT) + (i\u00a0% 8) = cast(ps.i / 8 AS INT) + (ps.i\u00a0% 8) OR\n                cast(i / 8 AS INT) - (i\u00a0% 8) = cast(ps.i / 8 AS INT) - (ps.i\u00a0% 8)\n            )\n        LIMIT 1\n        ) \n   ORDER BY n_queens DESC -- remove this when using Postgres (they don't support ORDER BY in CTEs)\n  )\nSELECT board,n_queens FROM solutions WHERE n_queens = 8;\n", "explain": "This implementation, which solves the problem for n=8, makes use of Common Table Expressions and has been tested with SQLite (>=3.8.3) and Postgres (please note the related comment in the code). It might be compatible with other SQL dialects as well. A gist with the SQL file and a Python script that runs it using SQLite is available on Github: https://gist.github.com/adewes/5e5397b693eb50e67f07\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "PHP", "code": "\n<html>\n<head>\n<title>\nn x n Queen solving program\n</title>\n</head>\n<body>\n<?php\necho \"<h1>n x n Queen solving program</h1>\";\n \n//Get the size of the board\n$boardX = $_POST['boardX'];\n$boardY = $_POST['boardX'];\n \n// Function to rotate a board 90 degrees\nfunction rotateBoard($p, $boardX) {\n    $a=0;\n    while ($a < count($p)) {\n        $b = strlen(decbin($p[$a]))-1;\n        $tmp[$b] = 1 << ($boardX - $a - 1);\n        ++$a;\n    }\n    ksort($tmp);\n    return $tmp;\n}\n \n// This function will find rotations of a solution\nfunction findRotation($p, $boardX,$solutions){\n    $tmp = rotateBoard($p,$boardX);\n    // Rotated 90\n    if (in_array($tmp,$solutions)) {}\n    else {$solutions[] = $tmp;}\n    \n    $tmp = rotateBoard($tmp,$boardX);\n    // Rotated 180\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    \n    $tmp = rotateBoard($tmp,$boardX);\n    // Rotated 270\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    \n    // Reflected\n    $tmp = array_reverse($p);\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    \n    $tmp = rotateBoard($tmp,$boardX);\n    // Reflected and Rotated 90\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    \n    $tmp = rotateBoard($tmp,$boardX);\n    // Reflected and Rotated 180\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    \n    $tmp = rotateBoard($tmp,$boardX);\n    // Reflected and Rotated 270\n    if (in_array($tmp,$solutions)){}\n    else {$solutions[] = $tmp;}\n    return $solutions;\n}\n \n// This is a function which will render the board\nfunction renderBoard($p,$boardX) {\n$img = 'data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAAC0AAAAtCAYAAAA6GuKaAAAABmJLR0QA/wD/AP+gvaeTAAAGFUlEQVRYhe2YXWibVRjHf2lqP9JmaRi4YW1IalY3rbZsaddMgsquBm676b6KyNDhLiaUeSEMvPNCcNuNyJjgLiboCnoxKFlv6lcHy7AtMhhaWTVZWhisjDTEtEuW5PHiPWnfvH2TvNk6vekfDm/O+Z/zPP/3PM/5eAMb2MAG/nfYn4LNVuBj4ENgB/Ar8Ogp+KkJbwLfqvKGgbMBPwKiK+Oq3aqNdcebQEEnqAC8ruO7KBVcLF012KiKuhpFv0/prNlU239qw0x0pdBJFXt30NJDjx9Uu1Ub1TSYdq4UutcNfI61oW0Bflb8T6quRzUbNafPFdbm4zcmTucV91kZO18o/osy/GeKnzcRVFWDMT2shO4X4IL6/UqZPv2GpxHFcReUvVo1lMAYunKh+UTxeeB5A/cMkFF8RtX1eF6NE2XHTIN+ltekoHGmf0HLqe9V3Qb8ZWK4Xjf+HQP3KtCgfjeouh7v6PzWsxZ6f98De1kbjbIovumoCfcp2gzkgb8p3cJOUjpTJ3WcTfXPq/Gfmtge1Y01RaV9+jv1fAsYMnAu3XgfENJxfUoU6tmn40Kqf9Gvi1IMKX96/zWJnlLP4i7wrIEvzkQeeFfXvltnt07Vi3iX1RcyzuSzrO46ev81YS+rYcqjbUVFfIl2CSryS4ATcKCF3biQHIpf0rU/UnaKuMLqAhXlv2a4Dc4FOKi4bwyiBTgBvGYyRlT7CUPbI1b334MmY9zlhFVKjwQQ09ULaDNTNKYPbx54j9L81aNP8XldW3G8W9kt6LiY8m8Ksy1Hj0mgA+3eXYeWd2eBRkpf2A4MoO3JOYPdHPA2sMtgu07ZOavsFnegvPL72PiItWEroB0axtwtmPStxOeUHbNxH1USVe1qOm3SVkA7NIwX+1phU3YKJpyZX8swW4y1FOMsVotG1UUI1mbrH9ZeL/UQi3b0C7dS/2W0LbIsqi1E0K6PL5oRdrudHTt22Px+Pz6fD6/XS3NzM21tbSt9FhcXWVpaIhqN2mKxGLOzs8zMzJDP581MQukHw2OLPgt8VRQZDAbZv38/wWCQnTt30tKyGoRUKsWDBw/IZrOkUimcTicNDQ1s3rwZp9O50i+dTjM9Pc2NGzcIh8NEIhH9S3xuQVNV2IArp06dkoWFBRERefjwoUxMTMi5c+fk8OHD0tPTIy6Xq2Keulwu6enpkSNHjsj58+dlYmJCMpmMiIgsLCzIxYsXBe1UfNIFvoL6M2fO/Hn58uXC4OCgtLa2PsniXClOp1MGBwfl0qVLhdOnT/+BtcjX9FYe4Pe+vj6Hy+Vat9lIJpMyOTm5BLwExNfL7gpCodAFeQoIhUIXqntfhaVwFHH9+nXp7+8vuFyuWv8vKYtkMlmYnJwse+F/Urzi9/ulqanJ6gFhqTQ1NeW7u7sF6Fx3xd3d3bdERNLptITDYRkeHpZgMCgOh6MmkQ6HQ/bs2SPDw8MSDoclnU6LiMju3buvlHG9BlYX1F5gfGhoiEAgwL59+9i+fTsAuVyOWCxGPB4nHo+TSCTIZrMkEgncbjeNjY243W46OjrweDx4vV7q67WsnJmZYWxsjGvXrjE+Pm5Zj1XRX3d2dg7Nz8/bs9ksAFu2bGHXrl0EAgG2bduG1+vF4/HgdDrZtGkTdrudXC5HKpUilUpx9+5dYrEYd+7cYXp6mqmpKe7fvw9AQ0MDXV1d3L59+2Xgd4uaKqO3t/cnEZFkMikjIyNy9OhRaW9vf6Jcbm9vl2PHjsnIyIgkk0kRETl06NAHVvRYnenA8ePHJ4PBIAcOHGDr1q0AxONxbt68yezsLNFolLm5ORKJBMvLy6TTaVpaWmhubl5JD5/Ph9/vZ2BgAI/HA8C9e/cYHR3l6tWry2NjY88Bi+slGqAHOFVXVxfq7e3tGhgYqAsGgwQCAfH5fLbGxsaqBjKZDNFoVKampmyRSIRIJFK4devWn4VC4TpwEfjNipDHPdlagADaf3X9NpvthY6Ojk6Px+Mq3vLsdjv5fJ7FxUWWl5eJx+OJubm5mIjMon1O/Yr2N0G6VufrdhwrtAJtaN9+bWihzqB9pNYsbgMbeAz8C3N/JQD4H5KCAAAAAElFTkSuQmCC';\necho \"<table border=1 cellspacing=0 style='text-align:center;display:inline'>\";\nfor ($y = 0; $y < $boardX; ++$y) {\n\techo '<tr>';\n\tfor ($x = 0; $x < $boardX; ++$x){\n\tif (($x+$y) & 1) { $cellCol = '#9C661F';}\n\telse {$cellCol = '#FCE6C9';}\n \n\tif ($p[$y] == 1 << $x) { echo \"<td bgcolor=\".$cellCol.\"><img width=30 height=30 src='\".$img.\"'></td>\";}\n\telse { echo \"<td bgcolor=\".$cellCol.\"> </td>\";}\n\t}\n\techo '<tr>';\n}\necho '<tr></tr></table>&nbsp';\n \n}\n \n//This function allows me to generate the next order of rows.\nfunction pc_next_permutation($p) {\n    $size = count($p) - 1;\n    // slide down the array looking for where we're smaller than the next guy \n    \n    for ($i = $size - 1; $p[$i] >= $p[$i+1]; --$i) { } \n    \n    // if this doesn't occur, we've finished our permutations \n    // the array is reversed: (1, 2, 3, 4) => (4, 3, 2, 1) \n    if ($i == -1) { return false; } \n    \n    // slide down the array looking for a bigger number than what we found before \n    for ($j = $size; $p[$j] <= $p[$i]; --$j) { } \n    // swap them \n    $tmp = $p[$i]; $p[$i] = $p[$j]; $p[$j] = $tmp; \n    // now reverse the elements in between by swapping the ends \n    for (++$i, $j = $size; $i < $j; ++$i, --$j) \n    { $tmp = $p[$i]; $p[$i] = $p[$j]; $p[$j] = $tmp; } \n    return $p; \n}\n \n//This function needs to check the current state to see if there are any \nfunction checkBoard($p,$boardX) {\n\t$a = 0; //this is the row being checked\n\twhile ($a < count($p)) { \n\t\t$b = 1;\n\t\twhile ($b < ($boardX - $a)){\n            $x = $p[$a+$b] << $b;\n            $y = $p[$a+$b] >> $b;\n            if ($p[$a] == $x | $p[$a] == $y) { \n                return false;\n            }\t\t\n            ++$b;\n\t\t}\n\t++$a; \n\t}\n\treturn true;\n}\n \n \nif (isset($_POST['process']) && isset($_POST['boardX']))\n{\n//Within here is the code that needs to be run if process is clicked.\n \n \n//First I need to create the different possible rows\nfor ($x = 0; $x < $boardX; ++$x){\n\t$row[$x] = 1 << $x;\n}\n \n//Now I need to create all the possible orders of rows, will be equal to [boardY]!\n$solcount = 0;\n$solutions = array();\nwhile ($row != false) {\n\tif (checkBoard($row,$boardX)){\n\tif(!in_array($row,$solutions)){\n\t\t$solutions[] = $row;\n\t\t\trenderBoard($row,$boardX);\n\t\t\t$solutions = findRotation($row,$boardX,$solutions);\n\t\t\t++$solcount;\n\t\t}\n \n\t}\n\t$row = pc_next_permutation($row);\t\n}\necho \"<br><br>&nbsp&nbsp&nbsp&nbspRows/Columns: \".$boardX.\"<br>&nbsp&nbsp&nbsp&nbspUnique Solutions: \".$solcount.\"<br>&nbsp&nbsp&nbsp&nbspTotal Solutions: \".count($solutions).\"  - Note: This includes symmetrical solutions<br>\";\n//print_r($solutions);\n}\n \n//This code collects the starting parameters\necho <<<_END\n<form name=\"input\" action=\"index.php\" method=\"post\">\n&nbsp&nbsp&nbsp&nbspNumber of columns/rows <select name=\"boardX\" />\n<option value=\"1\">One</option>\n<option value=\"2\">Two</option>\n<option value=\"3\">Three</option>\n<option value=\"4\" >Four</option>\n<option value=\"5\">Five</option>\n<option value=\"6\">Six</option>\n<option value=\"7\">Seven</option>\n<option value=\"8\" selected=\"selected\">Eight</option>\n<option value=\"9\">Nine</option>\n<option value=\"10\">Ten</option>\n</select>\n    <input type=\"hidden\" name=\"process\" value=\"yes\" />\n&nbsp<input type=\"submit\" value=\"Process\" />\n</form>\n \n_END;\n \n?>\n</body>\n</html>\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "MATLAB", "code": "\n\nn=8;\nsolutions=[[]];\nv = 1:n;\nP = perms(v);\nfor i=1:length(P)\n    for j=1:n\n        sub(j)=P(i,j)-j;\n        add(j)=P(i,j)+j;\n    end\n    if n==length(unique(sub)) && n==length(unique(add))\n        solutions(end+1,:)=P(i,:);\n    end\nend\n\nfprintf('Number of solutions with %i queens: %i', n, length(solutions));\n\nif ~isempty(solutions)\n    %Print first possible solution\n    board=solutions(1,:);\n    s = repmat('-',n);\n    for k=1:length(board)\n        s(k,board(k)) = 'Q';\n    end\n    s\nend\n\n\nOutput:\nNumber of solutions with 8 queens: 92\n\n    '-------Q'\n    '---Q----'\n    'Q-------'\n    '--Q-----'\n    '-----Q--'\n    '-Q------'\n    '------Q-'\n    '----Q---'\n\n", "explain": "This solution is inspired by Raymond Hettinger's permutations based solution which was made in Python: https://code.activestate.com/recipes/576647/\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Fortran", "code": "\nWorks with: Fortran version 95 and later\n\nprogram Nqueens\n  implicit none\n\n  integer, parameter :: n = 8  ! size of board\n  integer :: file = 1, rank = 1, queens = 0\n  integer :: i\n  logical :: board(n,n) = .false.\n\n  do while (queens < n)\n    board(file, rank) = .true.\n    if(is_safe(board, file, rank)) then\n      queens = queens + 1\n      file = 1\n      rank = rank + 1\n    else\n      board(file, rank) = .false.\n      file = file + 1\n      do while(file > n)\n         rank = rank - 1\n         if (rank < 1) then\n           write(*, \"(a,i0)\") \"No solution for n = \", n\n           stop\n         end if  \n         do i = 1, n\n           if (board(i, rank)) then\n             file = i\n             board(file, rank) = .false.\n             queens = queens - 1\n             file = i + 1\n             exit\n           end if\n         end do\n       end do\n    end if\n  end do\n\n  call Printboard(board)\n  \ncontains\n\nfunction is_safe(board, file, rank)\n  logical :: is_safe\n  logical, intent(in) :: board(:,:)\n  integer, intent(in) :: file, rank\n  integer :: i, f, r\n  \n  is_safe = .true.\n  do i = rank-1, 1, -1\n    if(board(file, i)) then\n      is_safe = .false.\n      return\n    end if\n  end do\n  \n  f = file - 1\n  r = rank - 1\n  do while(f > 0 .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f - 1\n    r = r - 1\n  end do\n\n  f = file + 1\n  r = rank - 1\n  do while(f <= n .and. r > 0)\n    if(board(f, r)) then\n      is_safe = .false.\n      return\n    end if\n    f = f + 1\n    r = r - 1\n  end do\nend function    \n\nsubroutine Printboard(board)\n  logical, intent(in) :: board(:,:)\n  character(n*4+1) :: line\n  integer :: f, r\n  \n  write(*, \"(a, i0)\") \"n = \", n\n  line = repeat(\"+---\", n) // \"+\"\n  do r = 1, n\n    write(*, \"(a)\") line\n    do f = 1, n\n      write(*, \"(a)\", advance=\"no\") \"|\"\n      if(board(f, r)) then\n        write(*, \"(a)\", advance=\"no\") \" Q \"\n      else if(mod(f+r, 2) == 0) then\n        write(*, \"(a)\", advance=\"no\") \"   \"\n      else\n        write(*, \"(a)\", advance=\"no\") \"###\"\n      end if\n    end do\n    write(*, \"(a)\") \"|\"\n  end do\n  write(*, \"(a)\") line\nend subroutine\nend program\n\n\nOutput: for 8, 16 and 32 queens\nn = 8\n+---+---+---+---+---+---+---+---+\n| Q |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+\n|###|   |###|   | Q |   |###|   |\n+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   | Q |\n+---+---+---+---+---+---+---+---+\n|###|   |###|   |###| Q |###|   |\n+---+---+---+---+---+---+---+---+\n|   |###| Q |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   | Q |   |\n+---+---+---+---+---+---+---+---+\n|   | Q |   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+\n|###|   |###| Q |###|   |###|   |\n+---+---+---+---+---+---+---+---+\n\nn = 16\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\nn = 32\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   | Q |   |###|   |###|   |###|   |###|   |###|   |###|\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###|   |###| Q |###|   |###|   |###|   |###|   |###|   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\nAlternate Fortran 77 solution[edit]\nC This one implements depth-first backtracking.\nC See the 2nd program for Scheme on the \"Permutations\" page for the\nC main idea.\nC As is, the program only prints the number of n-queens configurations.\nC To print also the configurations, uncomment the line after label 80.\n      program queens\n      implicit integer(a-z)\n      parameter(l=18)\n      dimension a(l),s(l),u(4*l-2)\n      do 10 i=1,l\n   10 a(i)=i\n      do 20 i=1,4*l-2\n   20 u(i)=0\n      do 110 n=1,l\n      m=0\n      i=1\n      r=2*n-1\n      go to 40\n   30 s(i)=j\n      u(p)=1\n      u(q+r)=1\n      i=i+1\n   40 if(i.gt.n) go to 80\n      j=i\n   50 z=a(i)\n      y=a(j)\n      p=i-y+n\n      q=i+y-1\n      a(i)=y\n      a(j)=z\n      if((u(p).eq.0).and.(u(q+r).eq.0)) goto 30\n   60 j=j+1\n      if(j.le.n) go to 50\n   70 j=j-1\n      if(j.eq.i) go to 90\n      z=a(i)\n      a(i)=a(j)\n      a(j)=z\n      go to 70\n   80 m=m+1\nC     print *,(a(k),k=1,n)\n   90 i=i-1\n      if(i.eq.0) go to 100\n      p=i-a(i)+n\n      q=i+a(i)-1\n      j=s(i)\n      u(p)=0\n      u(q+r)=0\n      go to 60\n  100 print *,n,m\n  110 continue\n      end\n \nC Output\nC          1           1\nC          2           0\nC          3           0\nC          4           2\nC          5          10\nC          6           4\nC          7          40\nC          8          92\nC          9         352\nC         10         724\nC         11        2680\nC         12       14200\nC         13       73712\nC         14      365596\nC         15     2279184\nC         16    14772512\nC         17    95815104\nC         18   666090624\n\n!The preceding program implements recursion using arrays, since Fortran 77 does not allow recursive\n!functions. The same algorithm is much easier to follow in Fortran 90, using the RECURSIVE keyword.\n!Like previously, the program only counts solutions. It's pretty straightforward to adapt it to print\n!them too: one has to replace the 'm = m + 1' instruction with a PRINT statement.\n\nfunction numq(n)\n    implicit none\n    integer :: i, n, m, a(n), numq\n    logical :: up(2*n - 1), down(2*n - 1)\n    do i = 1, n\n        a(i) = i\n    end do\n    up = .true.\n    down = .true.\n    m = 0\n    call sub(1)\n    numq = m\ncontains\n    recursive subroutine sub(i)\n        integer :: i, j, k, p, q, s\n        do k = i, n\n            j = a(k)\n            p = i + j - 1\n            q = i - j + n\n            if(up(p) .and. down(q)) then\n                if(i == n) then\n                    m = m + 1\n                else\n                    up(p) = .false.\n                    down(q) = .false.\n                    s = a(i)\n                    a(i) = a(k)\n                    a(k) = s\n                    call sub(i + 1)\n                    up(p) = .true.\n                    down(q) = .true.\n                    s = a(i)\n                    a(i) = a(k)\n                    a(k) = s\n                end if\n            end if\n        end do\n    end subroutine\nend function\n\nprogram queens\n    implicit none\n    integer :: numq, n, m\n    do n = 4, 16\n        m = numq(n)\n        print *, n, m\n    end do\nend program\n\nAlternate Fortran 95 solution with OpenMP[edit]\n\nprogram queens\n    use omp_lib\n    implicit none\n    integer, parameter :: long = selected_int_kind(17)\n    integer, parameter :: l = 18\n    integer, parameter :: nthreads = 16    ! Change to suit your processor\n    integer :: n, i, j, a(l*l, 2), k, p, q\n    integer(long) :: s, b(l*l)\n    real(kind(1d0)) :: t1, t2\n! Edit\u00a0: Added OPEN MP calls to set number of threads\n    CALL OMP_SET_DYNAMIC(.TRUE.)\n    CALL OMP_SET_NUM_THREADS(nthreads)\n    do n = 6, l\n        k = 0\n        p = n/2\n        q = mod(n, 2)*(p + 1)\n        do i = 1, n\n            do j = 1, n\n                if ((abs(i - j) > 1) .and. ((i <= p) .or. ((i == q) .and. (j < i)))) then\n                    k = k + 1\n                    a(k, 1) = i\n                    a(k, 2) = j\n                end if\n            end do\n        end do\n        s = 0\n        t1 = omp_get_wtime()\n        !$omp parallel do schedule(dynamic)\n        do i = 1, k\n            b(i) = pqueens(n, a(i, 1), a(i, 2))\n        end do\n        !$omp end parallel do\n        t2 = omp_get_wtime()\n        print \"(I4, I12, F12.3)\", n, 2*sum(b(1:k)), t2 - t1\n    end do\n    \ncontains\n    function pqueens(n, k1, k2) result(m)\n        implicit none\n        integer(long) :: m\n        integer, intent(in) :: n, k1, k2\n        integer, parameter :: l = 20\n        integer :: a(l), s(l), u(4*l - 2)\n        integer :: i, j, y, z, p, q, r\n\n        do i = 1, n\n            a(i) = i\n        end do\n        \n        do i = 1, 4*n - 2\n            u(i) = 0\n        end do\n        \n        m = 0\n        r = 2*n - 1\n        if (k1 == k2) return\n\n        p = 1 - k1 + n\n        q = 1 + k1 - 1\n        if ((u(p) /= 0) .or. (u(q + r) /= 0)) return\n\n        u(p) = 1\n        u(q + r) = 1\n        z = a(1)\n        a(1) = a(k1)\n        a(k1) = z\n        p = 2 - k2 + n\n        q = 2 + k2 - 1\n        if ((u(p) /= 0) .or. (u(q + r) /= 0)) return\n\n        u(p) = 1\n        u(q + r) = 1\n        if (k2 /= 1) then\n            z = a(2)\n            a(2) = a(k2)\n            a(k2) = z\n        else\n            z = a(2)\n            a(2) = a(k1)\n            a(k1) = z\n        end if\n        i = 3\n        go to 40\n\n     30 s(i) = j\n        u(p) = 1\n        u(q + r) = 1\n        i = i + 1\n     40 if (i > n) go to 80\n \n        j = i\n\n     50 z = a(i)\n        y = a(j)\n        p = i - y + n\n        q = i + y - 1\n        a(i) = y\n        a(j) = z\n        if ((u(p) == 0) .and. (u(q + r) == 0)) go to 30\n        \n     60 j = j + 1\n        if (j <= n) go to 50\n        \n     70 j = j - 1\n        if (j == i) go to 90\n        \n        z = a(i)\n        a(i) = a(j)\n        a(j) = z\n        go to 70\n        \n        !valid queens position found\n     80 m = m + 1\n     \n     90 i = i - 1\n        if (i == 2) return\n        \n        p = i - a(i) + n\n        q = i + a(i) - 1\n        j = s(i)\n        u(p) = 0\n        u(q + r) = 0\n        go to 60\n    end function\nend program\n\nFortran 2008 in a Lisp-like fashion[edit]\nWorks with: Fortran version 2008 and later\n\nprogram example__n_queens\n\n  use, intrinsic :: iso_fortran_env, only: output_unit\n\n  use, non_intrinsic :: garbage_collector\n  use, non_intrinsic :: cons_pairs\n\n  implicit none\n\n  ! .true. is good for testing that necessary values are rooted.\n  ! .false. to collect garbage only when the heap reaches a limit.\n  logical :: aggressive_garbage_collection = .true.\n\n  integer :: arg_count\n  integer :: stat\n  character(80) :: arg\n\n  type(gcroot_t) :: board_sizes\n\n  arg_count = command_argument_count ()\n  if (arg_count < 1) then\n     call print_usage (output_unit)\n  else\n     board_sizes = nil\n     block\n       integer :: i\n       integer :: board_size\n       do i = 1, arg_count\n          call get_command_argument (i, arg)\n          read (arg, *, iostat = stat) board_size\n          if (stat /= 0 .or. board_size < 1) then\n             board_size = -1\n          end if\n          board_sizes = cons (board_size, board_sizes)\n       end do\n       board_sizes = reversex (board_sizes)\n     end block\n\n     if (is_member (int_eq, -1, board_sizes)) then\n        call print_usage (output_unit)\n     else\n        ! Use pair_for_each as a way to distinguish the last\n        ! BOARD_SIZE from the others. The last entry will be the final\n        ! pair, and so its CDR will *not* be a pair.\n        call pair_for_each (find_and_print_all_solutions, &\n             &              circular_list (output_unit), &\n             &              board_sizes)\n     end if\n  end if\n\ncontains\n\n  subroutine print_usage (outp)\n    integer, intent(in) :: outp\n\n    write (outp, '(\"Usage: example__n_queens BOARD_SIZE [BOARD_SIZE...]\")')\n    write (outp, '(\"Each BOARD_SIZE must be at least 1.\")')\n    write (outp, '(\"For each BOARD_SIZE, all solutions are computed before any is printed.\")')\n  end subroutine print_usage\n\n  subroutine find_and_print_all_solutions (outp_pair, board_sizes)\n    class(*), intent(in) :: outp_pair\n    class(*), intent(in) :: board_sizes\n\n    integer :: n_outp\n    type(gcroot_t) :: all_solutions\n\n    n_outp = int_cast (car (outp_pair))\n\n    all_solutions = find_all_solutions (car (board_sizes))\n    call check_garbage\n    call print_all_solutions (n_outp, car (board_sizes), all_solutions)\n    call check_garbage\n    if (is_pair (cdr (board_sizes))) then\n       ! Space between one BOARD_SIZE and another.\n       write (n_outp, '()')\n    end if\n  end subroutine find_and_print_all_solutions\n\n  function find_all_solutions (board_size) result (all_solutions)\n    class(*), intent(in) :: board_size\n    type(cons_t) :: all_solutions\n\n    class(*), allocatable :: solutions\n\n    call find_solutions_from_ranks_so_far (board_size, nil, solutions)\n    all_solutions = solutions\n  end function find_all_solutions\n\n  recursive subroutine find_solutions_from_ranks_so_far (board_size, ranks_so_far, solutions)\n    class(*), intent(in) :: board_size\n    class(*), intent(in) :: ranks_so_far\n    class(*), allocatable, intent(out) :: solutions\n\n    type(cons_t) :: ranks\n\n    if (length (ranks_so_far) == int_cast (board_size)) then\n       solutions = list (ranks_so_far)\n    else\n       ranks = find_legal_ranks_for_file (int_cast (board_size), ranks_so_far)\n       solutions = concatenatex (map (find_solutions_from_ranks_so_far,                  &\n            &                         circular_list (board_size),                        &\n            &                         map (kons, ranks, circular_list (ranks_so_far))))\n    end if\n  end subroutine find_solutions_from_ranks_so_far\n\n  function find_legal_ranks_for_file (board_size, ranks_so_far) result (ranks)\n    !\n    ! Return a list of all the ranks in the next file, under the\n    ! constraint that a queen placed in the position not be under\n    ! attack.\n    !\n    integer, intent(in) :: board_size\n    class(*), intent(in) :: ranks_so_far\n    type(cons_t) :: ranks\n\n    ranks = iota (board_size, 1) ! All the possible ranks.\n    ranks = remove_illegal_ranks (ranks, ranks_so_far)\n  end function find_legal_ranks_for_file\n\n  function remove_illegal_ranks (new_ranks, ranks_so_far) result (legal_ranks)\n    class(*), intent(in) :: new_ranks\n    class(*), intent(in) :: ranks_so_far\n    type(cons_t) :: legal_ranks\n\n    legal_ranks = filter_map (keep_legal_rank, new_ranks, &\n         &                    circular_list (ranks_so_far))\n  end function remove_illegal_ranks\n\n  subroutine keep_legal_rank (rank, ranks_so_far, retval)\n    class(*), intent(in) :: rank\n    class(*), intent(in) :: ranks_so_far\n    class(*), allocatable, intent(out) :: retval\n\n    if (rank_is_legal (rank, ranks_so_far)) then\n       retval = rank\n    else\n       retval = .false.\n    end if\n  end subroutine keep_legal_rank\n\n  function rank_is_legal (new_rank, ranks_so_far) result (bool)\n    class(*), intent(in) :: new_rank\n    class(*), intent(in) :: ranks_so_far\n    logical :: bool\n\n    integer :: new_file\n    type(cons_t) :: files_so_far\n\n    new_file = int (length (ranks_so_far)) + 1\n    files_so_far = iota (new_file - 1, new_file - 1, -1)\n    bool = every (these_two_queens_are_nonattacking, &\n         &        circular_list (new_file),          &\n         &        circular_list (new_rank),          &\n         &        files_so_far,                      &\n         &        ranks_so_far)\n  end function rank_is_legal\n\n  function these_two_queens_are_nonattacking (file1, rank1, file2, rank2) result (bool)\n    class(*), intent(in) :: file1, rank1\n    class(*), intent(in) :: file2, rank2\n    logical :: bool\n\n    integer :: f1, r1\n    integer :: f2, r2\n\n    ! The rank and the two diagonals must not be the same. (The files\n    ! are known to be different.)\n\n    f1 = int_cast (file1)\n    r1 = int_cast (rank1)\n    f2 = int_cast (file2)\n    r2 = int_cast (rank2)\n\n    bool = (r1 /= r2 .and. r1 + f1 /= r2 + f2 .and. r1 - f1 /= r2 - f2)\n  end function these_two_queens_are_nonattacking\n\n  subroutine print_all_solutions (outp, board_size, all_solutions)\n    class(*), intent(in) :: outp\n    class(*), intent(in) :: board_size\n    class(*), intent(in) :: all_solutions\n\n    integer(size_kind) :: n\n\n    n = length (all_solutions)\n    write (int_cast (outp), '(\"For a board \", I0, \" by \", I0, \", \")', advance = 'no') &\n         &    int_cast (board_size), int_cast (board_size)\n    if (n == 1) then\n       write (int_cast (outp), '(\"there is \", I0, \" solution.\")') n\n    else\n       write (int_cast (outp), '(\"there are \", I0, \" solutions.\")') n\n    end if\n    call for_each (print_spaced_solution, circular_list (outp), &\n         &         circular_list (board_size), all_solutions)\n  end subroutine print_all_solutions\n\n  subroutine print_spaced_solution (outp, board_size, solution)\n    class(*), intent(in) :: outp\n    class(*), intent(in) :: board_size\n    class(*), intent(in) :: solution\n\n    write (int_cast (outp), '()', advance = 'yes')\n    call print_solution (outp, board_size, solution)\n  end subroutine print_spaced_solution\n\n  subroutine print_solution (outp, board_size, solution)\n    class(*), intent(in) :: outp\n    class(*), intent(in) :: board_size\n    class(*), intent(in) :: solution\n\n    integer :: n_outp\n    integer :: n_board_size\n    integer :: rank\n    integer :: file\n    integer :: file_of_queen\n\n    n_outp = int_cast (outp)\n    n_board_size = int_cast (board_size)\n\n    do rank = n_board_size, 1, -1\n       do file = 1, n_board_size\n          write (n_outp, '(\"----\")', advance = 'no')\n       end do\n       write (n_outp, '(\"-\")', advance = 'yes')\n\n       file_of_queen = n_board_size - int (list_index0 (int_eq, circular_list (rank), solution))\n\n       do file = 1, n_board_size\n          if (file == file_of_queen) then\n             write (n_outp, '(\"| Q \")', advance = 'no')\n          else\n             write (n_outp, '(\"|   \")', advance = 'no')\n          end if\n       end do\n       write (n_outp, '(\"|\")', advance = 'yes')       \n    end do\n\n    do file = 1, n_board_size\n       write (n_outp, '(\"----\")', advance = 'no')\n    end do\n    write (n_outp, '(\"-\")', advance = 'yes')\n  end subroutine print_solution\n\n  subroutine kons (x, y, xy)\n    class(*), intent(in) :: x\n    class(*), intent(in) :: y\n    class(*), allocatable, intent(out) :: xy\n\n    xy = cons (x, y)\n  end subroutine kons\n\n  pure function int_cast (x) result (val)\n    class(*), intent(in) :: x\n    integer :: val\n\n    select type (x)\n    type is (integer)\n       val = x\n    class default\n       error stop\n    end select\n  end function int_cast\n\n  pure function int_eq (x, y) result (bool)\n    class(*), intent(in) :: x\n    class(*), intent(in) :: y\n    logical :: bool\n\n    bool = (int_cast (x) == int_cast (y))\n  end function int_eq\n\n  subroutine check_garbage\n    if (aggressive_garbage_collection) then\n       call collect_garbage_now\n    else\n       call check_heap_size\n    end if\n  end subroutine check_garbage\n\nend program example__n_queens\n\n\nOutput:$ ./example__n_queens 1 2 3 4\nFor a board 1 by 1, there is 1 solution.\n\n-----\n| Q |\n-----\n\nFor a board 2 by 2, there are 0 solutions.\n\nFor a board 3 by 3, there are 0 solutions.\n\nFor a board 4 by 4, there are 2 solutions.\n\n-----------------\n|   | Q |   |   |\n-----------------\n|   |   |   | Q |\n-----------------\n| Q |   |   |   |\n-----------------\n|   |   | Q |   |\n-----------------\n\n-----------------\n|   |   | Q |   |\n-----------------\n| Q |   |   |   |\n-----------------\n|   |   |   | Q |\n-----------------\n|   | Q |   |   |\n-----------------\n\n", "explain": "Using a back tracking method to find one solution\nThis code is useful mainly for counting solutions. Here we use the same algorithm as with Fortran 77,\nwith an optimization: because of symmetry of the chess board, computations are divided by two.\nThe remaining is parallelized with OpenMP. The loop is done on the valid combinations of queens\nin the first two columns. The original algorithm is slightly changed to start backtracking from\ncolumn three.\nIf using GCC, compile with gfortran -O2 -fopenmp queens.f90. With Absoft Pro Fortran, af90 -O2 -openmp queens.f90, and with Intel Fortran, ifort /fast /Qopenmp queens.f90.\nWith some versions of GCC the function OMP_GET_WTIME is not known, which seems to be a bug. Then it's enough to comment out the two calls, and the program won't display timings.\nThe following program solves, stores, and prints all solutions to the n-queens problem, for board sizes given on the command line. To compile it, you need my modules that employ Fortran 2008\u2019s type polymorphism to support Lisp-like CONS-pairs. The modules (and this program) are available at https://sourceforge.net/p/chemoelectric/fortran-modules along with a GNU makefile, all under a permissive free software license. The makefile is written for GNU Fortran; compiler version 11.2.1 works. The programming style is essentially functional programming, and solutions are stored as a linked list of linked lists. One might notice how circular lists are used within the code to overcome Fortran\u2019s limited ability to do closures.\nPart of the intent here is to show that Fortran can do quite a few things people would not think it could, if it is given adequate library support.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Go", "code": "\nNiklaus Wirth algorithm (Wikipedia)[edit]\n// A fairly literal translation of the example program on the referenced\n// WP page.  Well, it happened to be the example program the day I completed\n// the task.  It seems from the WP history that there has been some churn\n// in the posted example program.  The example program of the day was in\n// Pascal and was credited to Niklaus Wirth, from his \"Algorithms +\n// Data Structures = Programs.\"\npackage main\n \nimport \"fmt\"\n \nvar (\n    i int\n    q bool\n    a [9]bool\n    b [17]bool\n    c [15]bool // offset by 7 relative to the Pascal version\n    x [9]int\n)\n \nfunc try(i int) {\n    for j := 1; ; j++ {\n        q = false\n        if a[j] && b[i+j] && c[i-j+7] {\n            x[i] = j\n            a[j] = false\n            b[i+j] = false\n            c[i-j+7] = false\n            if i < 8 {\n                try(i + 1)\n                if !q {\n                    a[j] = true\n                    b[i+j] = true\n                    c[i-j+7] = true\n                }\n            } else {\n                q = true\n            }\n        }\n        if q || j == 8 {\n            break\n        }\n    }\n}\n \nfunc main() {\n    for i := 1; i <= 8; i++ {\n        a[i] = true\n    }\n    for i := 2; i <= 16; i++ {\n        b[i] = true\n    }\n    for i := 0; i <= 14; i++ {\n        c[i] = true\n    }\n    try(1)\n    if q {\n        for i := 1; i <= 8; i++ {\n            fmt.Println(i, x[i])\n        }\n    }\n}\n\n\nOutput:\n1 1\n2 5\n3 8\n4 6\n5 3\n6 7\n7 2\n8 4\n\nRefactored Niklaus Wirth algorithm (clearer/Go friendly solution)[edit]\n/*\n * N-Queens Problem\n *\n * For an NxN chess board, 'safely' place a chess queen in every column and row such that none can attack another.\n * This solution is based Wirth Pascal solution, although a tad cleaner, thus easier to understand as it uses Go/C\n * style indexing and naming, and also prints the Queen using a Unicode 'rune' (which other languages do not handle natively).\n *\n * N rows by N columns are number left to right top to bottom 0 - 7\n *\n * There are 2N-1 diagonals (showing an 8x8)\n *  the upper-right to lower-left are numbered row + col that is:\n *    0   1   2   3   4   5   6   7\n *    1   2   3   4   5   6   7   8\n *    2   3   4   5   6   7   8   9\n *    3   4   5   6   7   8   9  10\n *    4   5   6   7   8   9  10  11\n *    5   6   7   8   9  10  11  12\n *    6   7   8   9  10  11  12  13\n *    7   8   9  10  11  12  13  14\n * \n *\tthe upper-left to lower-right are numbered N-1 + row - col\n *    7   6   5   4   3   2   1   0\n *    8   7   6   5   4   3   2   1\n *    9   8   7   6   5   4   3   2\n *   10   9   8   7   6   5   4   3\n *   11  10   9   8   7   6   5   4\n *   12  11  10   9   8   7   6   5\n *   13  12  11  10   9   8   7   6\n *   14  13  12  11  10   9   8   7\n */\n\npackage main\n\nimport \"fmt\"\n\nconst\tN\t= 8\nconst\tHAS_QUEEN  = false\nconst\tEMPTY  = true\nconst\tUNASSIGNED = -1\nconst   white_queen = '\\u2655'\n\n\nvar\trow_num[N]int\t// results, indexed by row will be the column where the queen lives (UNASSIGNED) is empty\nvar\tright_2_left_diag[(2*N-1)]bool\t// T if no queen in diag[idx]: row i, column col is diag i+col\nvar\tleft_2_right_diag[(2*N-1)]bool //  T is no queen in diag[idx], row i, column col is N-1 + i-col\n\n\nfunc printresults() {\n    for col := 0; col < N; col++ {\n\tif col != 0 {\n\t    fmt.Printf(\" \");\n\t}\n\tfmt.Printf(\"%d,%d\", col, row_num[col])\n    }\n    fmt.Printf(\"\\n\");\n    for  row := 0; row < N; row++ {\n\tfor col := 0; col < N; col++ {\n\t    if col == row_num[row] {\n\t\tfmt.Printf(\" %c \", white_queen)\n\t    } else {\n\t\tfmt.Printf(\" . \")\n\t    }\n\t}\n\tfmt.Printf(\"\\n\")\n    }\n}\n\n/*\n * save a queen on the board by saving where we think it should go, and marking the diagonals as occupied\n */\n \nfunc savequeen(row int, col int) {\n    row_num[row] = col\t// save queen column for this row\n    right_2_left_diag[row+col] = HAS_QUEEN \t// mark forward diags as occupied\n    left_2_right_diag[row-col+(N-1)] = HAS_QUEEN\t// mark backward diags as occupied\n}\n\n/*\n * backout a previously saved queen by clearing where we put it, and marking the diagonals as empty\n */\n\nfunc clearqueen(row int, col int) {\n    row_num[row] = UNASSIGNED\n    right_2_left_diag[row+col] = EMPTY \n    left_2_right_diag[row-col+(N-1)] = EMPTY\n}\n\n/*\n * for each column try the solutions\n */\nfunc trycol(col int)  bool {\n\t// check each row to look for the first empty row that does not have a diagonal in use too\n\tfor row := 0; row < N; row++ {\n            if row_num[row] == UNASSIGNED &&\t// has the row been used yet?\n\t\t    right_2_left_diag[row+col] == EMPTY &&\t// check for the forward diags\n\t\t    left_2_right_diag[row-col+(N-1)] == EMPTY {\t// check for the backwards diags\n\t        savequeen(row, col)\t// this is a possible solution\n\t        // Tricky part here:  going forward thru the col up to but not including the rightmost one\n                // if this fails, we are done, no need to search any more\n                if col < N-1 && !trycol(col+1) {\n\t\t    // ok this did not work - we need to try a different row, so undo the guess\n\t\t    clearqueen(row, col)\n\t        } else {\n\t\t    // we have a solution on this row/col, start popping the stack.\n\t\t    return true\n\t\t} \n\t    }\n\t}\n\treturn false // not a solution for this col, pop the stack, undo the last guess, and try the next one\n}\n\nfunc main() {\n    for i := 0; i < N ; i++ {\n\trow_num[i] = UNASSIGNED\n    }\n    for i := 0; i < 2*N-1 ; i++ {\n\tright_2_left_diag[i] = EMPTY\n    }\n    for i := 0; i < 2*N-1 ; i++ {\n\tleft_2_right_diag[i] = EMPTY\n    }\n    trycol(0)\n    printresults()\n}\n\n\nOutput:\n0,0 1,6 2,4 3,7 4,1 5,3 6,5 7,2\n \u2655  .  .  .  .  .  .  .\n .  .  .  .  .  .  \u2655  .\n .  .  .  .  \u2655  .  .  .\n .  .  .  .  .  .  .  \u2655\n .  \u2655  .  .  .  .  .  .\n .  .  .  \u2655  .  .  .  .\n .  .  .  .  .  \u2655  .  .\n .  .  \u2655  .  .  .  .  .\n\nDancing Links / Algorithm X[edit]\n\npackage main\n\nimport (\n\t\"flag\"\n\t\"fmt\"\n\t\"log\"\n\t\"os\"\n\t\"time\"\n\n\t\"rosettacode.org/dlx\" // or where ever you put the dlx package\n)\n\nfunc main() {\n\tlog.SetPrefix(\"N-queens: \")\n\tlog.SetFlags(0)\n\tprofile := flag.Bool(\"profile\", false, \"show DLX profile\")\n\tflag.Parse()\n\n\tfor N := 2; N <= 18; N++ {\n\t\terr := nqueens(N, N == 8, *profile)\n\t\tif err != nil {\n\t\t\tlog.Fatal(err)\n\t\t}\n\t}\n}\n\nfunc nqueens(N int, printFirst, profile bool) error {\n\t// Build a new DLX matrix with 2N primary columns and 4N-6 secondary\n\t// columns: R0..R(N-1), F0..F(N-1), A1..A(2N-3), B1..B(2N-3).\n\t// We also know the number of cells and solution rows required.\n\tm := dlx.NewWithHint(2*N, 4*N-6, N*N*4-4, 8)\n\n\ts := solution{\n\t\tN:          N,\n\t\trenumFwd:   make([]int, 0, 2*N),\n\t\trenumBack:  make([]int, 2*N),\n\t\tprintFirst: printFirst,\n\t}\n\n\t// column indexes\n\tiR0 := 0\n\tiF0 := iR0 + N\n\tiA1 := iF0 + N\n\tiB1 := iA1 + 2*N - 3\n\n\t// Use \"organ-pipe\" ordering. E.g.\u00a0for N=8:\n\t// R4 F4 R3 F3 R5 F5 R2 F2 R6 F6 R1 F1 R7 F7 R0 F0\n\t// This can reduce the number of link updates required by\n\t// almost half for large N; see Knuth's paper for details.\n\tmid := N / 2\n\tfor off := 0; off <= N-mid; off++ {\n\t\ti := mid - off\n\t\tif i >= 0 {\n\t\t\ts.renumBack[iR0+i] = len(s.renumFwd)\n\t\t\ts.renumBack[iF0+i] = len(s.renumFwd) + 1\n\t\t\ts.renumFwd = append(s.renumFwd, iR0+i, iF0+i)\n\t\t}\n\t\tif i = mid + off; off != 0 && i < N {\n\t\t\ts.renumBack[iR0+i] = len(s.renumFwd)\n\t\t\ts.renumBack[iF0+i] = len(s.renumFwd) + 1\n\t\t\ts.renumFwd = append(s.renumFwd, iR0+i, iF0+i)\n\t\t}\n\t}\n\n\t// Add constraint rows.\n\t// TODO: pre-eliminate symetrical possibilities.\n\tcols := make([]int, 4)\n\tfor i := 0; i < N; i++ {\n\t\tfor j := 0; j < N; j++ {\n\t\t\tcols[0] = iR0 + i    // Ri,         rank i\n\t\t\tcols[1] = iF0 + j    // Fj,         file j\n\t\t\ta := (i + j)         // A(i+j),     diagonals\n\t\t\tb := (N - 1 - i + j) // B(N-1-i+j), reverse diagonals\n\t\t\tcols = cols[:2]\n\t\t\t// Do organ-pipe reordering for R and F.\n\t\t\tfor i, c := range cols {\n\t\t\t\tcols[i] = s.renumBack[c]\n\t\t\t}\n\n\t\t\t// Only add diagonals with more than one space; that\n\t\t\t// is we omit the corners: A0, A(2N-2), B0, and B(2N-2)\n\t\t\tif 0 < a && a < 2*N-2 {\n\t\t\t\tcols = append(cols, iA1+a-1)\n\t\t\t}\n\t\t\tif 0 < b && b < 2*N-2 {\n\t\t\t\tcols = append(cols, iB1+b-1)\n\t\t\t}\n\n\t\t\tm.AddRow(cols)\n\t\t}\n\t}\n\n\t// Search for solutions.\n\tstart := time.Now()\n\terr := m.Search(s.found)\n\tif err != nil {\n\t\treturn err\n\t}\n\telapsed := time.Since(start)\n\tfmt.Printf(\"%d\u00d7%d queens has %2d solutions, found in %v\\n\", N, N, s.count, elapsed)\n\tif profile {\n\t\tm.ProfileWrite(os.Stderr)\n\t}\n\treturn nil\n}\n\ntype solution struct {\n\tN          int\n\tcount      int\n\trenumFwd   []int // for \"organ-pipe\" column ordering\n\trenumBack  []int\n\tprintFirst bool\n}\n\nfunc (s *solution) found(m *dlx.Matrix) error {\n\ts.count++\n\tif s.printFirst && s.count == 1 {\n\t\tfmt.Printf(\"First %d\u00d7%d queens solution:\\n\", s.N, s.N)\n\t\tfor _, cols := range m.SolutionIDs(nil) {\n\t\t\tvar r, f int\n\t\t\tfor _, c := range cols {\n\t\t\t\t// Undo organ-pipe reodering\n\t\t\t\tif c < len(s.renumFwd) {\n\t\t\t\t\tc = s.renumFwd[c]\n\t\t\t\t}\n\t\t\t\tif c < s.N {\n\t\t\t\t\tr = c + 1\n\t\t\t\t} else if c < 2*s.N {\n\t\t\t\t\tf = c - s.N + 1\n\t\t\t\t}\n\t\t\t}\n\t\t\tfmt.Printf(\"    R%d F%d\\n\", r, f)\n\t\t}\n\t}\n\treturn nil\n}\n\n\nOutput:\n2\u00d72 queens has  0 solutions, found in 1.915\u00b5s\n3\u00d73 queens has  0 solutions, found in 1.22\u00b5s\n4\u00d74 queens has  2 solutions, found in 3.095\u00b5s\n5\u00d75 queens has 10 solutions, found in 7.15\u00b5s\n6\u00d76 queens has  4 solutions, found in 17.663\u00b5s\n7\u00d77 queens has 40 solutions, found in 54.08\u00b5s\nFirst 8\u00d78 queens solution:\n    R5 F1\n    R1 F4\n    R3 F5\n    R4 F3\n    R6 F6\n    R2 F7\n    R7 F8\n    R8 F2\n8\u00d78 queens has 92 solutions, found in 186.991\u00b5s\n9\u00d79 queens has 352 solutions, found in 580.225\u00b5s\n10\u00d710 queens has 724 solutions, found in 2.078235ms\n11\u00d711 queens has 2680 solutions, found in 8.186708ms\n12\u00d712 queens has 14200 solutions, found in 38.037841ms\n13\u00d713 queens has 73712 solutions, found in 183.846653ms\n14\u00d714 queens has 365596 solutions, found in 961.249859ms\n15\u00d715 queens has 2279184 solutions, found in 5.491853276s\n16\u00d716 queens has 14772512 solutions, found in 33.286561009s\n17\u00d717 queens has 95815104 solutions, found in 3m34.643824374s\n18\u00d718 queens has 666090624 solutions, found in 24m22.30241617s\n\n", "explain": "Using Knuth's\ndancing links technique to implement his \nKnuth's Algorithm X.\nThe Go code for this technique is in the\ndlx packge.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nTranslation of: Go\nprogram N_queens_problem;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\nvar\n  i: Integer;\n  q: boolean;\n  a: array[0..8] of boolean;\n  b: array[0..16] of boolean;\n  c: array[0..14] of boolean;\n  x: array[0..8] of Integer;\n\nprocedure TryMove(i: Integer);\nbegin\n  var j := 1;\n  while True do\n  begin\n    q := false;\n    if a[j] and b[i + j] and c[i - j + 7] then\n    begin\n      x[i] := j;\n      a[j] := false;\n      b[i + j] := false;\n      c[i - j + 7] := false;\n\n      if i < 8 then\n      begin\n        TryMove(i + 1);\n        if not q then\n        begin\n          a[j] := true;\n          b[i + j] := true;\n          c[i - j + 7] := true;\n        end;\n      end\n      else\n        q := true;\n    end;\n    if q or (j = 8) then\n      Break;\n    inc(j);\n  end;\nend;\n\nbegin\n  for i := 1 to 8 do\n    a[i] := true;\n\n  for i := 2 to 16 do\n    b[i] := true;\n\n  for i := 0 to 14 do\n    c[i] := true;\n\n  TryMove(1);\n\n  if q then\n    for i := 1 to 8 do\n      writeln(i, ' ', x[i]);\n  readln;\nend.\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Ruby", "code": "\n\n# 1. Divide n by 12. Remember the remainder (n is 8 for the eight queens\n#    puzzle).\n# 2. Write a list of the even numbers from 2 to n in order.\n# 3. If the remainder is 3 or 9, move 2 to the end of the list.\n# 4. Append the odd numbers from 1 to n in order, but, if the remainder is 8,\n#    switch pairs (i.e. 3, 1, 7, 5, 11, 9, \u2026).\n# 5. If the remainder is 2, switch the places of 1 and 3, then move 5 to the\n#    end of the list.\n# 6. If the remainder is 3 or 9, move 1 and 3 to the end of the list.\n# 7. Place the first-column queen in the row with the first number in the\n#    list, place the second-column queen in the row with the second number in\n#    the list, etc.\n\n\ndef n_queens(n)\n  if n == 1\n    return \"Q\"\n  elsif n < 4\n    puts \"no solutions for n=#{n}\"\n    return \"\"\n  end\n \n  evens = (2..n).step(2).to_a\n  odds = (1..n).step(2).to_a\n \n  rem = n\u00a0% 12  # (1)\n  nums = evens  # (2)\n \n  nums.rotate if rem == 3 or rem == 9  # (3)\n \n  # (4)\n  if rem == 8\n    odds = odds.each_slice(2).flat_map(&:reverse)\n  end\n  nums.concat(odds)\n \n  # (5)\n  if rem == 2\n    nums[nums.index(1)], nums[nums.index(3)] = nums[nums.index(3)], nums[nums.index(1)]\n    nums << nums.delete(5)\n  end\n \n  # (6)\n  if rem == 3 or rem == 9\n    nums << nums.delete(1)\n    nums << nums.delete(3)\n  end\n \n  # (7)\n  nums.map do |q|\n    a = Array.new(n,\".\")\n    a[q-1] = \"Q\"\n    a*(\" \")\n  end\nend\n \n(1 .. 15).each {|n| puts \"n=#{n}\"; puts n_queens(n); puts}\n\nOutput:\nn=1\nQ\n\nn=2\nno solutions for n=2\n\n\nn=3\nno solutions for n=3\n\n\nn=4\n. Q . .\n. . . Q\nQ . . .\n. . Q .\n\nn=5\n. Q . . .\n. . . Q .\nQ . . . .\n. . Q . .\n. . . . Q\n\nn=6\n. Q . . . .\n. . . Q . .\n. . . . . Q\nQ . . . . .\n. . Q . . .\n. . . . Q .\n\nn=7\n. Q . . . . .\n. . . Q . . .\n. . . . . Q .\nQ . . . . . .\n. . Q . . . .\n. . . . Q . .\n. . . . . . Q\n\nn=8\n. Q . . . . . .\n. . . Q . . . .\n. . . . . Q . .\n. . . . . . . Q\n. . Q . . . . .\nQ . . . . . . .\n. . . . . . Q .\n. . . . Q . . .\n\nn=9\n. . . Q . . . . .\n. . . . . Q . . .\n. . . . . . . Q .\n. Q . . . . . . .\n. . . . Q . . . .\n. . . . . . Q . .\n. . . . . . . . Q\nQ . . . . . . . .\n. . Q . . . . . .\n\nn=10\n. Q . . . . . . . .\n. . . Q . . . . . .\n. . . . . Q . . . .\n. . . . . . . Q . .\n. . . . . . . . . Q\nQ . . . . . . . . .\n. . Q . . . . . . .\n. . . . Q . . . . .\n. . . . . . Q . . .\n. . . . . . . . Q .\n\nn=11\n. Q . . . . . . . . .\n. . . Q . . . . . . .\n. . . . . Q . . . . .\n. . . . . . . Q . . .\n. . . . . . . . . Q .\nQ . . . . . . . . . .\n. . Q . . . . . . . .\n. . . . Q . . . . . .\n. . . . . . Q . . . .\n. . . . . . . . Q . .\n. . . . . . . . . . Q\n\nn=12\n. Q . . . . . . . . . .\n. . . Q . . . . . . . .\n. . . . . Q . . . . . .\n. . . . . . . Q . . . .\n. . . . . . . . . Q . .\n. . . . . . . . . . . Q\nQ . . . . . . . . . . .\n. . Q . . . . . . . . .\n. . . . Q . . . . . . .\n. . . . . . Q . . . . .\n. . . . . . . . Q . . .\n. . . . . . . . . . Q .\n\nn=13\n. Q . . . . . . . . . . .\n. . . Q . . . . . . . . .\n. . . . . Q . . . . . . .\n. . . . . . . Q . . . . .\n. . . . . . . . . Q . . .\n. . . . . . . . . . . Q .\nQ . . . . . . . . . . . .\n. . Q . . . . . . . . . .\n. . . . Q . . . . . . . .\n. . . . . . Q . . . . . .\n. . . . . . . . Q . . . .\n. . . . . . . . . . Q . .\n. . . . . . . . . . . . Q\n\nn=14\n. Q . . . . . . . . . . . .\n. . . Q . . . . . . . . . .\n. . . . . Q . . . . . . . .\n. . . . . . . Q . . . . . .\n. . . . . . . . . Q . . . .\n. . . . . . . . . . . Q . .\n. . . . . . . . . . . . . Q\n. . Q . . . . . . . . . . .\nQ . . . . . . . . . . . . .\n. . . . . . Q . . . . . . .\n. . . . . . . . Q . . . . .\n. . . . . . . . . . Q . . .\n. . . . . . . . . . . . Q .\n. . . . Q . . . . . . . . .\n\nn=15\n. . . Q . . . . . . . . . . .\n. . . . . Q . . . . . . . . .\n. . . . . . . Q . . . . . . .\n. . . . . . . . . Q . . . . .\n. . . . . . . . . . . Q . . .\n. . . . . . . . . . . . . Q .\n. Q . . . . . . . . . . . . .\n. . . . Q . . . . . . . . . .\n. . . . . . Q . . . . . . . .\n. . . . . . . . Q . . . . . .\n. . . . . . . . . . Q . . . .\n. . . . . . . . . . . . Q . .\n. . . . . . . . . . . . . . Q\nQ . . . . . . . . . . . . . .\n. . Q . . . . . . . . . . . .\nAlternate solution[edit]\n\nclass Queen\n  attr_reader :count\n  \n  def initialize(num=8, out=true)\n    @num   = num\n    @out   = out\n    @row   = *0...@num\n    @frame = \"+-\" + \"--\" * @num + \"+\"\n    @count = 0\n    add = Array.new(2 * @num - 1, true)       # \\ direction check\n    sub = Array.new(2 * @num - 1, true)       # / direction check\n    solve([], add, sub)\n  end\n  \n  private\n  def solve(row, add, sub)\n    y = row.size\n    if y == @num\n      print_out(row) if @out\n      @count += 1\n    else\n      (@row-row).each do |x|\n        next unless add[x+y] and sub[x-y]\n        add[x+y] = sub[x-y] = false\n        solve(row+[x], add, sub)\n        add[x+y] = sub[x-y] = true\n      end\n    end\n  end\n  \n  def print_out(row)\n    puts @frame\n    row.each do |i|\n      line = @num.times.map {|j| j==i\u00a0? \"Q \"\u00a0: \". \"}.join\n      puts \"| #{line}|\"\n    end\n    puts @frame\n  end\nend\n\n(1..6).each do |n|\n  puzzle = Queen.new(n)\n  puts \" #{n} Queen\u00a0: #{puzzle.count}\"\nend\n\n(7..12).each do |n|\n  puzzle = Queen.new(n, false)                # do not display\n  puts \" #{n} Queen\u00a0: #{puzzle.count}\"\nend\n\nOutput:\n+---+\n| Q |\n+---+\n 1 Queen\u00a0: 1\n 2 Queen\u00a0: 0\n 3 Queen\u00a0: 0\n+---------+\n| . Q . . |\n| . . . Q |\n| Q . . . |\n| . . Q . |\n+---------+\n+---------+\n| . . Q . |\n| Q . . . |\n| . . . Q |\n| . Q . . |\n+---------+\n 4 Queen\u00a0: 2\n+-----------+\n| Q . . . . |\n| . . Q . . |\n| . . . . Q |\n| . Q . . . |\n| . . . Q . |\n+-----------+\n+-----------+\n| Q . . . . |\n| . . . Q . |\n| . Q . . . |\n| . . . . Q |\n| . . Q . . |\n+-----------+\n+-----------+\n| . Q . . . |\n| . . . Q . |\n| Q . . . . |\n| . . Q . . |\n| . . . . Q |\n+-----------+\n+-----------+\n| . Q . . . |\n| . . . . Q |\n| . . Q . . |\n| Q . . . . |\n| . . . Q . |\n+-----------+\n+-----------+\n| . . Q . . |\n| Q . . . . |\n| . . . Q . |\n| . Q . . . |\n| . . . . Q |\n+-----------+\n+-----------+\n| . . Q . . |\n| . . . . Q |\n| . Q . . . |\n| . . . Q . |\n| Q . . . . |\n+-----------+\n+-----------+\n| . . . Q . |\n| Q . . . . |\n| . . Q . . |\n| . . . . Q |\n| . Q . . . |\n+-----------+\n+-----------+\n| . . . Q . |\n| . Q . . . |\n| . . . . Q |\n| . . Q . . |\n| Q . . . . |\n+-----------+\n+-----------+\n| . . . . Q |\n| . Q . . . |\n| . . . Q . |\n| Q . . . . |\n| . . Q . . |\n+-----------+\n+-----------+\n| . . . . Q |\n| . . Q . . |\n| Q . . . . |\n| . . . Q . |\n| . Q . . . |\n+-----------+\n 5 Queen\u00a0: 10\n+-------------+\n| . Q . . . . |\n| . . . Q . . |\n| . . . . . Q |\n| Q . . . . . |\n| . . Q . . . |\n| . . . . Q . |\n+-------------+\n+-------------+\n| . . Q . . . |\n| . . . . . Q |\n| . Q . . . . |\n| . . . . Q . |\n| Q . . . . . |\n| . . . Q . . |\n+-------------+\n+-------------+\n| . . . Q . . |\n| Q . . . . . |\n| . . . . Q . |\n| . Q . . . . |\n| . . . . . Q |\n| . . Q . . . |\n+-------------+\n+-------------+\n| . . . . Q . |\n| . . Q . . . |\n| Q . . . . . |\n| . . . . . Q |\n| . . . Q . . |\n| . Q . . . . |\n+-------------+\n 6 Queen\u00a0: 4\n 7 Queen\u00a0: 40\n 8 Queen\u00a0: 92\n 9 Queen\u00a0: 352\n 10 Queen\u00a0: 724\n 11 Queen\u00a0: 2680\n 12 Queen\u00a0: 14200\n\n", "explain": "This implements the heuristics found on the wikipedia page to return just one solution\nIf there is not specification, it outputs all solutions.\nExample:\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Rust", "code": "\nconst N: usize = 8;\n\nfn try(mut board: &mut [[bool; N]; N], row: usize, mut count: &mut i64) {\n   if row == N {\n       *count += 1;\n       for r in board.iter() {\n           println!(\"{}\", r.iter().map(|&x| if x {\"x\"} else {\".\"}.to_string()).collect::<Vec<String>>().join(\" \"))\n       }\n       println!(\"\");\n       return\n   }\n   for i in 0..N {\n       let mut ok: bool = true;\n       for j in 0..row {\n           if board[j][i]\n               || i+j >= row && board[j][i+j-row]\n               || i+row < N+j && board[j][i+row-j]\n           { ok = false }\n       }\n       if ok {\n           board[row][i] = true;\n           try(&mut board, row+1, &mut count);\n           board[row][i] = false;\n       }\n   }\n}\n\nfn main() {\n   let mut board: [[bool; N]; N] = [[false; N]; N];\n   let mut count: i64 = 0;\n   try (&mut board, 0, &mut count);\n   println!(\"Found {} solutions\", count)\n}\nUsing Iterators[edit]\n\nuse std::collections::LinkedList;\nuse std::iter::IntoIterator;\n\nfn main() {\n    for (n, s) in NQueens::new(8).enumerate() {\n        println!(\"Solution #{}:\\n{}\\n\", n + 1, s.to_string());\n    }\n}\n\nfn permutations<'a, T, I>(collection: I) -> Box<Iterator<Item=LinkedList<T>> + 'a>\n    where I: 'a + IntoIterator<Item=T> + Clone,\n          T: 'a + PartialEq + Copy + Clone {\n    if collection.clone().into_iter().count() == 0 {\n        Box::new(vec![LinkedList::new()].into_iter())\n    }\n    else { \n        Box::new(\n            collection.clone().into_iter().flat_map(move |i| {\n                permutations(collection.clone().into_iter()\n                    .filter(move |&i0| i\u00a0!= i0)\n                    .collect::<Vec<_>>())\n                    .map(move |mut l| {l.push_front(i); l})\n            })\n        )\n    }\n}\n\npub struct NQueens {\n    iterator: Box<Iterator<Item=NQueensSolution>>\n}\n\nimpl NQueens {\n    pub fn new(n: u32) -> NQueens {\n        NQueens {\n            iterator: Box::new(permutations(0..n)\n                .filter(|vec| {\n                    let iter = vec.iter().enumerate();\n                    iter.clone().all(|(col, &row)| {\n                        iter.clone().filter(|&(c,_)| c\u00a0!= col)\n                            .all(|(ocol, &orow)| {\n                            col as i32 - row as i32\u00a0!= \n                                ocol as i32 - orow as i32 &&\n                            col as u32 + row\u00a0!= ocol as u32 + orow \n                        })\n                    })\n                })\n                .map(|vec| NQueensSolution(vec))\n            )\n        }\n    }\n}\n\nimpl Iterator for NQueens {\n    type Item = NQueensSolution;\n    fn next(&mut self) -> Option<NQueensSolution> {\n        self.iterator.next()\n    }\n}\n\npub struct NQueensSolution(LinkedList<u32>);\n\nimpl ToString for NQueensSolution {\n    fn to_string(&self) -> String {\n        let mut str = String::new();\n        for &row in self.0.iter() {\n            for r in 0..self.0.len() as u32 {\n                if r == row {\n                    str.push_str(\"Q \");\n                } else {\n                    str.push_str(\"- \");\n                }\n            }\n            str.push('\\n');\n        }\n        str\n    }\n}\n", "explain": "Solution to the puzzle using an iterator that yields the 92 solutions for 8 queens.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Swift", "code": "\n\n\tlet maxn = 31\n\n\tfunc nq(n: Int) -> Int {\n\t    var cols = Array(repeating: 0, count: maxn)\n\t    var diagl = Array(repeating: 0, count: maxn)\n\t    var diagr = Array(repeating: 0, count: maxn)\n\t    var posibs = Array(repeating: 0, count: maxn)\n\t    var num = 0\n\t    for q0 in 0...n-3 {\n\t\tfor q1 in q0+2...n-1 {\n\t\t    let bit0: Int = 1<<q0\n\t\t    let bit1: Int = 1<<q1\n\t\t    var d: Int = 0\n\t\t    cols[0] = bit0 | bit1 | (-1<<n)\n\t\t    diagl[0] = (bit0<<1|bit1)<<1\n\t\t    diagr[0] = (bit0>>1|bit1)>>1\n\n\t\t    var posib: Int = ~(cols[0] | diagl[0] | diagr[0])\n\n\t\t    while (d >= 0) {\n\t\t\twhile(posib\u00a0!= 0) {\n\t\t\t    let bit: Int = posib & -posib\n\t\t\t    let ncols: Int = cols[d] | bit\n\t\t\t    let ndiagl: Int = (diagl[d] | bit) << 1;\n\t\t\t    let ndiagr: Int = (diagr[d] | bit) >> 1;\n\t\t\t    let nposib: Int = ~(ncols | ndiagl | ndiagr);\n\t\t\t    posib^=bit\n\t\t\t    num += (ncols == -1\u00a0? 1\u00a0: 0)\n\t\t\t    if (nposib\u00a0!= 0){\n\t\t\t\tif(posib\u00a0!= 0) {\n\t\t\t\t    posibs[d] = posib\n\t\t\t\t    d += 1\n\t\t\t\t}\n\t\t\t\tcols[d] = ncols\n\t\t\t\tdiagl[d] = ndiagl\n\t\t\t\tdiagr[d] = ndiagr\n\t\t\t\tposib = nposib\n\t\t\t    }\n\t\t\t}\n\t\t\td -= 1\n\t\t\tposib = d<0\u00a0? n\u00a0: posibs[d]\n\n\t\t    }\n\t\t}\n\n\t    }\n\t    return num*2\n\t}\n\tif(CommandLine.arguments.count == 2) {\n\n\t    let board_size: Int = Int(CommandLine.arguments[1])!\n\t    print (\"Number of solutions for board size \\(board_size) is: \\(nq(n:board_size))\")\n\n\t} else {\n\t    print(\"Usage: 8q <n>\")\n\t}\n", "explain": "Port of the optimized C code above\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "R", "code": "\nTranslation of: Stata\n\nqueens <- function(n) {\n  a <- seq(n)\n  u <- rep(T, 2 * n - 1)\n  v <- rep(T, 2 * n - 1)\n  m <- NULL\n  aux <- function(i) {\n    if (i > n) {\n      m <<- cbind(m, a)\n    } else {\n      for (j in seq(i, n)) {\n        k <- a[[j]]\n        p <- i - k + n\n        q <- i + k - 1\n        if (u[[p]] && v[[q]]) {\n          u[[p]] <<- v[[q]] <<- F\n          a[[j]] <<- a[[i]]\n          a[[i]] <<- k\n          aux(i + 1)\n          u[[p]] <<- v[[q]] <<- T\n          a[[i]] <<- a[[j]]\n          a[[j]] <<- k\n        }\n      }\n    }\n  }\n  aux(1)\n  m\n}\n\nlibrary(Matrix)\na <- queens(8)\nas(a[, 1], \"pMatrix\")\n\nOutput:\n8 x 8 sparse Matrix of class \"pMatrix\"\n                    \n[1,] | . . . . . . .\n[2,] . . . . | . . .\n[3,] . . . . . . . |\n[4,] . . . . . | . .\n[5,] . . | . . . . .\n[6,] . . . . . . | .\n[7,] . | . . . . . .\n[8,] . . . | . . . .\n\nsapply(4:12, function(n) ncol(queens(n)))\n\nOutput:\n[1]     2    10     4    40    92   352   724  2680 14200\n", "explain": "This solution uses recursive backtracking.\nShow the first solution found for size 8 as a permutation matrix.\nCount solutions for board size 4 to 12.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\nTranslation of: BBC BASIC\n'N-queens problem - non recursive & structured - vb6 - 25/02/2017\nSub n_queens()\n    Const l = 15  'number of queens\n    Const b = False  'print option\n    Dim a(l), s(l), u(4 * l - 2)\n    Dim n, m, i, j, p, q, r, k, t, z\n    For i = 1 To UBound(a): a(i) = i: Next i\n    For n = 1 To l\n        m = 0\n        i = 1\n        j = 0\n        r = 2 * n - 1\n        Do\n            i = i - 1\n            j = j + 1\n            p = 0\n            q = -r\n            Do\n                i = i + 1\n                u(p) = 1\n                u(q + r) = 1\n                z = a(j): a(j) = a(i): a(i) = z  'Swap a(i), a(j)\n                p = i - a(i) + n\n                q = i + a(i) - 1\n                s(i) = j\n                j = i + 1\n            Loop Until j > n Or u(p) Or u(q + r)\n            If u(p) = 0 Then\n                If u(q + r) = 0 Then\n                    m = m + 1  'm: number of solutions\n                    If b Then\n                        Debug.Print \"n=\"; n; \"m=\"; m\n                        For k = 1 To n\n                            For t = 1 To n\n                                Debug.Print IIf(a(n - k + 1) = t, \"Q\", \".\");\n                            Next t\n                            Debug.Print\n                        Next k\n                    End If\n                End If\n            End If\n            j = s(i)\n            Do While j >= n And i <> 0\n                Do\n                    z = a(j): a(j) = a(i): a(i) = z  'Swap a(i), a(j)\n                    j = j - 1\n                Loop Until j < i\n                i = i - 1\n                p = i - a(i) + n\n                q = i + a(i) - 1\n                j = s(i)\n                u(p) = 0\n                u(q + r) = 0\n            Loop\n        Loop Until i = 0\n        Debug.Print n, m  'number of queens, number of solutions\n    Next n\nEnd Sub 'n_queens\n\nOutput:\n 1             1 \n 2             0 \n 3             0 \n 4             2 \n 5             10 \n 6             4 \n 7             40 \n 8             92 \n 9             352 \n 10            724 \n 11            2680 \n 12            14200 \n 13            73712\n 14            365596\n 15            2279184\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Queens is\n   Board : array (1..8, 1..8) of Boolean := (others => (others => False));\n   function Test (Row, Column : Integer) return Boolean is\n   begin\n      for J in 1..Column - 1 loop\n         if (  Board (Row, J)\n            or else\n               (Row > J and then Board (Row - J, Column - J))\n            or else\n               (Row + J <= 8 and then Board (Row + J, Column - J))\n            )  then\n            return False;\n         end if;\n      end loop;\n      return True;\n   end Test;\n   function Fill (Column : Integer) return Boolean is\n   begin\n      for Row in Board'Range (1) loop\n         if Test (Row, Column) then\n            Board (Row, Column) := True;\n            if Column = 8 or else Fill (Column + 1) then\n               return True;\n            end if;\n            Board (Row, Column) := False;\n         end if;\n      end loop;\n      return False;\n   end Fill;\nbegin\n   if not Fill (1) then\n      raise Program_Error;\n   end if;\n   for I in Board'Range (1) loop\n      Put (Integer'Image (9 - I));\n      for J in Board'Range (2) loop\n         if Board (I, J) then\n            Put (\"|Q\");\n         elsif (I + J) mod 2 = 1 then\n            Put (\"|/\");\n         else\n            Put (\"| \");\n         end if;\n      end loop;\n      Put_Line (\"|\");\n   end loop;\n   Put_Line (\"   A B C D E F G H\");\nend Queens;\n\n\nOutput:\n 8|Q|/| |/| |/| |/|\n 7|/| |/| |/| |Q| |\n 6| |/| |/|Q|/| |/|\n 5|/| |/| |/| |/|Q|\n 4| |Q| |/| |/| |/|\n 3|/| |/|Q|/| |/| |\n 2| |/| |/| |Q| |/|\n 1|/| |Q| |/| |/| |\n   A B C D E F G H\n\nAlternate solution[edit]\nTranslation of: Fortran\n\nwith Ada.Text_IO;\nuse Ada.Text_IO;\n\nprocedure CountQueens is\n    function Queens (N : Integer) return Long_Integer is\n        A : array (0 .. N) of Integer;\n        U : array (0 .. 2 * N - 1) of Boolean := (others => true);\n        V : array (0 .. 2 * N - 1) of Boolean := (others => true);\n        M : Long_Integer := 0;\n        \n        procedure Sub (I: Integer) is\n            K, P, Q: Integer;\n        begin\n            if N = I then\n                M := M + 1;\n            else\n                for J in I .. N - 1 loop\n                    P := I + A (J);\n                    Q := I + N - 1 - A (J);\n                    if U (P) and then V (Q) then\n                        U (P) := false;\n                        V (Q) := false;\n                        K := A (I);\n                        A (I) := A (J);\n                        A (J) := K;\n                        Sub (I + 1);\n                        U (P) := true;\n                        V (Q) := true;\n                        K := A (I);\n                        A (I) := A (J);\n                        A (J) := K;\n                    end if;\n                end loop;\n            end if;\n        end Sub;\n    begin\n        for I in 0 .. N - 1 loop\n            A (I) := I;\n        end loop;\n        Sub (0);\n        return M;\n    end Queens;\nbegin\n    for N in 1 .. 16 loop\n        Put (Integer'Image (N));\n        Put (\" \");\n        Put_Line (Long_Integer'Image (Queens (N)));\n    end loop;\nend CountQueens;\n\n", "explain": "This one only counts solutions, though it's easy to do something else with each one (instead of the M\u00a0:= M + 1; line).\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Julia", "code": "\n\"\"\"\n# EightQueensPuzzle\n\nPorted to **Julia** from examples in several languages from\nhere: https://hbfs.wordpress.com/2009/11/10/is-python-slow\n\"\"\"\nmodule EightQueensPuzzle\n\nexport Board, solve!\n\nmutable struct Board\n    cols::Int\n    nodes::Int\n    diag45::Int\n    diag135::Int\n    solutions::Int\n\n    Board() = new(0, 0, 0, 0, 0)\nend\n\n\"Marks occupancy.\"\nfunction mark!(b::Board, k::Int, j::Int)\n    b.cols    \u22bb= (1 << j)\n    b.diag135 \u22bb= (1 << (j+k))\n    b.diag45  \u22bb= (1 << (32+j-k))\nend\n\n\"Tests if a square is menaced.\"\nfunction test(b::Board, k::Int, j::Int)\n    b.cols    & (1 << j)        +\n    b.diag135 & (1 << (j+k))    +\n    b.diag45  & (1 << (32+j-k)) == 0\nend\n\n\"Backtracking solver.\"\nfunction solve!(b::Board, niv::Int, dx::Int)\n    if niv > 0\n        for i in 0:dx-1\n            if test(b, niv, i) == true\n                mark!(b, niv, i)\n                solve!(b, niv-1, dx)\n                mark!(b, niv, i)\n            end\n        end\n    else\n        for i in 0:dx-1\n            if test(b, 0, i) == true\n                b.solutions += 1\n            end\n        end\n    end\n    b.nodes += 1\n    b.solutions\nend\n\nend # module\n\nusing  .EightQueensPuzzle\n\nfor n = 1:17\n    b = Board()\n    @show n\n    print(\"elapsed:\")\n    solutions = @time solve!(b, n-1, n)\n    @show solutions\n    println()\nend\n \nOutput:\nn = 1\nelapsed:  0.000001 seconds\nsolutions = 1\n\nn = 2\nelapsed:  0.000001 seconds\nsolutions = 0\n\nn = 3\nelapsed:  0.000001 seconds\nsolutions = 0\n\nn = 4\nelapsed:  0.000001 seconds\nsolutions = 2\n\nn = 5\nelapsed:  0.000002 seconds\nsolutions = 10\n\nn = 6\nelapsed:  0.000006 seconds\nsolutions = 4\n\nn = 7\nelapsed:  0.000032 seconds\nsolutions = 40\n\nn = 8\nelapsed:  0.000168 seconds\nsolutions = 92\n\nn = 9\nelapsed:  0.000554 seconds\nsolutions = 352\n\nn = 10\nelapsed:  0.001804 seconds\nsolutions = 724\n\nn = 11\nelapsed:  0.008528 seconds\nsolutions = 2680\n\nn = 12\nelapsed:  0.049349 seconds\nsolutions = 14200\n\nn = 13\nelapsed:  0.292637 seconds\nsolutions = 73712\n\nn = 14\nelapsed:  1.734187 seconds\nsolutions = 365596\n\nn = 15\nelapsed: 10.550665 seconds\nsolutions = 2279184\n\nn = 16\nelapsed: 78.840067 seconds\nsolutions = 14772512\n\nn = 17\nelapsed:550.816089 seconds\nsolutions = 95815104\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "SAS", "code": "\n/* Store all 92 permutations in a SAS dataset. Translation of Fortran 77 */\ndata queens;\narray a{8} p1-p8;\narray s{8};\narray u{30};\nn=8;\ndo i=1 to n;\na(i)=i;\nend;\ndo i=1 to 4*n-2;\nu(i)=0;\nend;\nm=0;\ni=1;\nr=2*n-1;\ngoto L40;\nL30:\ns(i)=j;\nu(p)=1;\nu(q+r)=1;\ni=i+1;\nL40:\nif i>n then goto L80;\nj=i;\nL50:\nz=a(i);\ny=a(j);\np=i-y+n;\nq=i+y-1;\na(i)=y;\na(j)=z;\nif u(p)=0 and u(q+r)=0 then goto L30;\nL60:\nj=j+1;\nif j<=n then goto L50;\nL70:\nj=j-1;\nif j=i then goto L90;\nz=a(i);\na(i)=a(j);\na(j)=z;\ngoto L70;\nL80:\nm=m+1;\noutput;\nL90:\ni=i-1;\nif i=0 then goto L100;\np=i-a(i)+n;\nq=i+a(i)-1;\nj=s(i);\nu(p)=0;\nu(q+r)=0;\ngoto L60;\nL100:\nput n m;\nkeep p1-p8;\nrun;\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\nTranslation of: FreeBASIC\n// version 1.1.3\n\nvar count = 0\nvar c = IntArray(0)\nvar f = \"\" \n\nfun nQueens(row: Int, n: Int) {\n    outer@ for (x in 1..n) {\n        for (y in 1..row - 1) {\n            if (c[y] == x) continue@outer\n            if (row - y == Math.abs(x - c[y])) continue@outer           \n        }\n        c[row] = x\n        if (row < n) nQueens(row + 1, n)\n        else if (++count == 1) f = c.drop(1).map { it - 1 }.toString()\n    }\n}\n\nfun main(args: Array<String>) {\n   for (n in 1..14) { \n       count = 0\n       c = IntArray(n + 1)\n       f = \"\"\n       nQueens(1, n)\n       println(\"For a $n x $n board:\")\n       println(\"  Solutions = $count\")\n       if (count > 0) println(\"  First is $f\")\n       println()\n   }\n}\n\n\nOutput:\nFor a 1 x 1 board:\n  Solutions = 1\n  First is [0]\n\nFor a 2 x 2 board:\n  Solutions = 0\n\nFor a 3 x 3 board:\n  Solutions = 0\n\nFor a 4 x 4 board:\n  Solutions = 2\n  First is [1, 3, 0, 2]\n\nFor a 5 x 5 board:\n  Solutions = 10\n  First is [0, 2, 4, 1, 3]\n\nFor a 6 x 6 board:\n  Solutions = 4\n  First is [1, 3, 5, 0, 2, 4]\n\nFor a 7 x 7 board:\n  Solutions = 40\n  First is [0, 2, 4, 6, 1, 3, 5]\n\nFor a 8 x 8 board:\n  Solutions = 92\n  First is [0, 4, 7, 5, 2, 6, 1, 3]\n\nFor a 9 x 9 board:\n  Solutions = 352\n  First is [0, 2, 5, 7, 1, 3, 8, 6, 4]\n\nFor a 10 x 10 board:\n  Solutions = 724\n  First is [0, 2, 5, 7, 9, 4, 8, 1, 3, 6]\n\nFor a 11 x 11 board:\n  Solutions = 2680\n  First is [0, 2, 4, 6, 8, 10, 1, 3, 5, 7, 9]\n\nFor a 12 x 12 board:\n  Solutions = 14200\n  First is [0, 2, 4, 7, 9, 11, 5, 10, 1, 6, 8, 3]\n\nFor a 13 x 13 board:\n  Solutions = 73712\n  First is [0, 2, 4, 1, 8, 11, 9, 12, 3, 5, 7, 10, 6]\n\nFor a 14 x 14 board:\n  Solutions = 365596\n  First is [0, 2, 4, 6, 11, 9, 12, 3, 13, 8, 1, 5, 7, 10]\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Perl", "code": "\nmy ($board_size, @occupied, @past, @solutions);\n\nsub try_column {\n        my ($depth, @diag) = shift;\n        if ($depth == $board_size) {\n                push @solutions, \"@past\\n\";\n                return;\n        }\n\n        # @diag: marks cells diagonally attackable by any previous queens.\n        #        Here it's pre-allocated to double size just so we don't need\n        #        to worry about negative indices.\n        $#diag = 2 * $board_size;\n        for (0 .. $#past) {\n                $diag[ $past[$_] + $depth - $_ ] = 1;\n                $diag[ $past[$_] - $depth + $_ ] = 1;\n        }\n\n        for my $row (0 .. $board_size - 1) {\n                next if $occupied[$row] || $diag[$row];\n\n                # @past:     row numbers of previous queens\n                # @occupied: rows already used. This gets inherited by each\n                #            recursion so we don't need to repeatedly look them up\n                push @past, $row;\n                $occupied[$row] = 1;\n\n                try_column($depth + 1);\n\n                # clean up, for next recursion\n                $occupied[$row] = 0;\n                pop @past;\n        }\n}\n\n$board_size = 12;\ntry_column(0);\n\n#print for @solutions; # un-comment to see all solutions\nprint \"total \" . @solutions . \" solutions\\n\";\n\n\nOutput:\ntotal 14200 solutions\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Prolog", "code": "\n\nsolution([]).\n \nsolution([X/Y|Others]) :-\n solution(Others),\n member(Y, [1,2,3,4,5,6,7,8]),\n noattack(X/Y, Others).\n \nnoattack(_,[]).\n \nnoattack(X/Y,[X1/Y1|Others]) :-\n Y =\\= Y1,\n Y1 - Y =\\= X1 - X,\n Y1 - Y =\\= X - X1,\n noattack(X/Y,Others).\n \nmember(Item,[Item|Rest]).\n \nmember(Item,[First|Rest]) :-\n member(Item,Rest).\n \ntemplate([1/Y1,2/Y2,3/Y3,4/Y4,5/Y5,6/Y6,7/Y7,8/Y8]).\n\n\nsolution(Queens)\u00a0:-\n permutation([1,2,3,4,5,6,7,8], Queens),\n safe(Queens).\n \npermutation([],[]).\n \npermutation([Head|Tail],PermList)\u00a0:-\n permutation(Tail,PermTail),\n del(Head,PermList,PermTail).\n \ndel(Item,[Item|List],List).\n \ndel(Item,[First|List],[First|List1])\u00a0:-\n del(Item,List,List1).\n \nsafe([]).\n \nsafe([Queen|Others])\u00a0:-\n safe(Others),\n noattack(Queen,Others,1).\n \nnoattack(_,[],_).\n \nnoattack(Y,[Y1|Ylist],Xdist)\u00a0:-\n Y1-Y=\\=Xdist,\n Y-Y1=\\=Xdist,\n Dist1 is Xdist + 1,\n noattack(Y,Ylist,Dist1).\n\nsolution(Ylist)\u00a0:-\n sol(Ylist,[1,2,3,4,5,6,7,8],\n    [1,2,3,4,5,6,7,8],\n    [-7,-6,-5,-4,-3,-2,-1,0,1,2,3,4,5,6,7],\n    [2,3,4,5,6,7,8,9,10,11,12,13,14,15,16]).\n \nsol([],[],[],Du,Dv).\n \nsol([Y|Ylist],[X|Dx1],Dy,Du,Dv)\u00a0:-\n del(Y,Dy,Dy1),\n U is X-Y,\n del(U,Du,Du1),\n V is X+Y,\n del(V,Dv,Dv1),\n sol(Ylist,Dx1, Dy1,Du1,Dv1).\n \ndel(Item,[Item|List],List).\n \ndel(Item,[First|List],[First|List1])\u00a0:-\n del(Item,List,List1).\n\n\u00a0\u00a0?- findall(S, solution(S), LS), length(LS,N), write(N).\n\u00a0 92\n\nAlternative version[edit]\n\n:- initialization(main).\n\n\nqueens(N,Qs)\u00a0:- bagof(X, between(1,N,X), Xs), place(Xs,[],Qs).\n\nplace(Xs,Qs,Res)\u00a0:-\n    Xs = [] -> Res = Qs\n \u00a0; select(Q,Xs,Ys), not_diag(Q,Qs,1), place(Ys,[Q|Qs],Res)\n  .\n\nnot_diag(_, []     , _).\nnot_diag(Q, [Qh|Qs], D)\u00a0:-\n     abs(Q - Qh) =\\= D, D1 is D + 1, not_diag(Q,Qs,D1).\n\n\nmain\u00a0:- findall(Qs, (queens(8,Qs), write(Qs), nl), _), halt.\n\nAlternative Solution[edit]\n\nWorks with: SWI Prolog version version 6.2.6 by Jan Wielemaker, University of Amsterdam\n% 8 queens problem.\n%  q(Row) represents a queen, allocated one per row. No rows ever clash.\n%  The columns are chosen iteratively from available columns held in a\n%  list, reduced with each allocation, so we need never check verticals.\n%  For diagonals, we check prior to allocation whether each newly placed\n%  queen will clash with any of the prior placements. This prevents\n%  most invalid permutations from ever being attempted.\ncan_place(_, [])\u00a0:-\u00a0!.\t  \u00a0% success for empty board\ncan_place(q(R,C),Board)\u00a0:-\u00a0% check diagonals against allocated queens\n\tmember(q(Ra,Ca), Board), abs(Ra-R) =:= abs(Ca-C),\u00a0!, fail.\ncan_place(_,_).           \u00a0% succeed if no diagonals failed\n\nqueens([], [], Board, Board).                           \u00a0% found a solution\nqueens([q(R)|Queens], Columns, Board, Solution)\u00a0:-\n\tnth0(_,Columns,C,Free), can_place(q(R,C),Board),\u00a0% find all solutions\n\tqueens(Queens,Free,[q(R,C)|Board], Solution).   \u00a0% recursively\n\nqueens\u00a0:-\n  findall(q(N), between(0,7,N), Queens), findall(N, between(0,7,N), Columns),\n  findall(B, queens(Queens, Columns, [], B), Boards),    \u00a0% backtrack over all\n  length(Boards, Len), writef('%w solutions:\\n', [Len]), \u00a0% Output solutions\n  member(R,Boards), reverse(R,Board), writef('  - %w\\n', [Board]), fail.\nqueens.\n\nOutput:\n?- queens.\n92 solutions:\n  - [q(0,0),q(1,4),q(2,7),q(3,5),q(4,2),q(5,6),q(6,1),q(7,3)]\n  - [q(0,0),q(1,5),q(2,7),q(3,2),q(4,6),q(5,3),q(6,1),q(7,4)]\n  - [q(0,0),q(1,6),q(2,3),q(3,5),q(4,7),q(5,1),q(6,4),q(7,2)]\n  - [q(0,0),q(1,6),q(2,4),q(3,7),q(4,1),q(5,3),q(6,5),q(7,2)]\n...\n  - [q(0,7),q(1,1),q(2,4),q(3,2),q(4,0),q(5,6),q(6,3),q(7,5)]\n  - [q(0,7),q(1,2),q(2,0),q(3,5),q(4,1),q(5,4),q(6,6),q(7,3)]\n  - [q(0,7),q(1,3),q(2,0),q(3,2),q(4,5),q(5,1),q(6,6),q(7,4)]\ntrue.\n\nShort version[edit]\n\nnot_diagonal(X, N)\u00a0:-\n  maplist(plus, X, N, Z1), maplist(plus, X, Z2, N), is_set(Z1), is_set(Z2).\n\nqueens(N, Qs)\u00a0:-\n  numlist(1, N, P), findall(Q, (permutation(P, Q), not_diagonal(Q, P)), Qs).\n\nOutput:\n?- queens(8, X), length(X, L).\nX = [[1, 5, 8, 6, 3, 7, 2, 4], [1, 6, 8, 3, 7, 4, 2|...], [1, 7, 4, 6, 8, 2|...], [1, 7, 5, 8, 2|...], [2, 4, 6, 8|...], [2, 5, 7|...], [2, 5|...], [2|...], [...|...]|...],\nL = 92.\n\nSWISH Prolog version[edit]\n% John Devou: 26-Nov-2021\n% Short solution to use on https://swish.swi-prolog.org/.\n% Works fast for n \u2264 17.\n\n:- use_rendering(chess).\n\nq(_,0,[],[]).\nq(N,R,[(R,C)|Qs],[C|Cs]):- R > 0, S is R-1, q(N,S,Qs,Cs), between(1,N,C),\n\tnot((member((U,V),Qs), (V =:= C; R-U =:= abs(C-V)))).\nq(N,X):- q(N,N,_,X).\nCLP(FD): Constraint Logic Programming over Finite Domains Version[edit]\n\n\n `nqueens()` creates a 2D array datastructure, representing the board coordinates of each queen\n `applyConstraints()` recursively iterates through each queen on the board\n `checkConstraints()` applies the constraints: no two queens on same row/column/diagonal; and recurses through the list of remaining queens\n `optimizeQueens()` hardcodes each queen to live in a named row, this greatly reduces the computational complixity of the problem\n   Note: it is not possible to pass `Index + 1` into a prolog function, instead it must be declared and solved first as its own varaiable: `NextIndex is Index + 1`\n `print_board()` + print_line() render the ASCII graphics in a functional manner\n `all_nqueens()` uses `findall()` to solve `nqueens()` whilst repeatedly adding previous solutions as future constraints\n `print_nqueens_all(N)` is the main display/execution function\n\n\n\nSource: https://github.com/JamesMcGuigan/ecosystem-research/blob/master/prolog/nqueens.prolog\nFull Output: https://github.com/JamesMcGuigan/ecosystem-research/blob/master/prolog/nqueens.txt\n\n\n:- use_module(library(clpfd)).\n\n% DOC: http://www.pathwayslms.com/swipltuts/clpfd/clpfd.html\nlength_(Length, List)\u00a0:- length(List, Length).\n\napplyConstraints([]).\napplyConstraints([ Q | Queens ])\u00a0:-\n    checkConstraints(Q, Queens),\n    applyConstraints(Queens).\n\ncheckConstraints(_, []).\ncheckConstraints([Row0, Col0], [ [Row1, Col1] | Queens])\u00a0:-\n    Row0 #\\= Row1,                \u00a0% No two queens on same row\n    Col0 #\\= Col1,                \u00a0% No two queens on same columns\n    Row0 + Col0 #\\= Row1 + Col1,  \u00a0% Down diagonals: [8,1], [7,2], [6,3]\n    Row0 - Col0 #\\= Row1 - Col1,  \u00a0% Up   diagonals: [1,1], [2,2], [3,3]\n    checkConstraints([Row0,Col0], Queens).\n\n\n% Optimization: pre-assign each queen to a named row\noptimizeQueens(Queens)\u00a0:- optimizeQueens(Queens, 1).\noptimizeQueens([],_).\noptimizeQueens([[Row,_] | Queens], Index)\u00a0:-\n    Row #= Index,\n    NextIndex is Index + 1,\n    optimizeQueens(Queens, NextIndex).\n\n\nnqueens(N, Queens)\u00a0:-\n   \u00a0% Function Preconditions\n    N > 0,\n\n   \u00a0% Create 2D Datastructure for Queens\n    length(Queens, N), maplist(length_(2), Queens),\n    flatten(Queens, QueenArray),\n\n   \u00a0% Queens coords must be in range\n    QueenArray ins 1..N,\n\n   \u00a0% Apply Constraints\n    optimizeQueens(Queens),\n    applyConstraints(Queens),\n\n   \u00a0% Solve\n    label(QueenArray),\n    true.\n\n\nall_nqueens(N)\u00a0:- all_nqueens(N, _).\nall_nqueens(N, Solutions)\u00a0:-\n    findall(Queens, (nqueens(N,Queens), write(Queens), nl), Solutions),\n    length(Solutions,Count),\n    write(Count), write(' solutions'), nl,\n    Count #>= 1.\n\n\nprint_nqueens_all(N)                \u00a0:- all_nqueens(N, Solutions), print_nqueens(N, Solutions).\nprint_nqueens(N)                    \u00a0:- nqueens(N, Queens),        print_board(N, Queens).\nprint_nqueens(N, [Queens|Remaining])\u00a0:- print_count(Remaining),    print_board(N, Queens),    print_nqueens(N, Remaining).\nprint_nqueens(_, []).\n\nprint_count(Remaining)\u00a0:- length(Remaining, Count), Count1 is Count + 1, nl, write('# '), write(Count1), nl.\nprint_board(N, [[_,Q] | Queens])\u00a0:- print_line(N, '-'), print_line(N, '|', Q), print_board(N, Queens).\nprint_board(N, []) \u00a0:- print_line(N, '-').\nprint_line(0,'-')  \u00a0:- write('-'), nl.\nprint_line(N,'-')  \u00a0:- write('----'), N1 is N-1, print_line(N1,'-').\nprint_line(0,'|',_)\u00a0:- write('|'), nl.\nprint_line(N,'|',Q)\u00a0:- write('|'), (( Q == N ) -> write(' Q ')\u00a0; write('   ')), N1 is N-1, print_line(N1,'|',Q).\n\n%:- initialization main.\nmain\u00a0:-\n    print_nqueens_all(8).\n\nOutput:\n92 solutions\n\n# 92\n---------------------------------\n|   |   |   |   |   |   |   | Q |\n---------------------------------\n|   |   |   | Q |   |   |   |   |\n---------------------------------\n| Q |   |   |   |   |   |   |   |\n---------------------------------\n|   |   | Q |   |   |   |   |   |\n---------------------------------\n|   |   |   |   |   | Q |   |   |\n---------------------------------\n|   | Q |   |   |   |   |   |   |\n---------------------------------\n|   |   |   |   |   |   | Q |   |\n---------------------------------\n|   |   |   |   | Q |   |   |   |\n---------------------------------\n\n", "explain": "The code for these samples is taken from [1].\nSolution #1:\nSolution #2:\nSolution #3:\nOutput:\nUses non-ISO predicates between/3 and select/3 (available in SWI Prolog and GNU Prolog).\nRuns in: time: 0.02 memory: 68352\nUses backtracking- a highly efficient mechanism in Prolog to find all solutions.\n\nSWI-Prolog 7.2.3\nN-Queens - 92 Solutions In SWI-Prolog v8.0.2 \nThis code solves the N-Queens problem in Prolog using the CLP(FD): Constraint Logic Programming over Finite Domain Library\n\n\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Lua", "code": "\nN = 8\n\n-- We'll use nil to indicate no queen is present.\ngrid = {}\nfor i = 0, N do\n  grid[i] = {}\nend\n\nfunction can_find_solution(x0, y0)\n  local x0, y0 = x0 or 0, y0 or 1  -- Set default vals (0, 1).\n  for x = 1, x0 - 1 do\n    if grid[x][y0] or grid[x][y0 - x0 + x] or grid[x][y0 + x0 - x] then\n      return false\n    end\n  end\n  grid[x0][y0] = true\n  if x0 == N then return true end\n  for y0 = 1, N do\n    if can_find_solution(x0 + 1, y0) then return true end\n  end\n  grid[x0][y0] = nil\n  return false\nend\n\nif can_find_solution() then\n  for y = 1, N do\n    for x = 1, N do\n      -- Print \"|Q\" if grid[x][y] is true; \"|_\" otherwise.\n      io.write(grid[x][y] and \"|Q\" or \"|_\")\n    end\n    print(\"|\")\n  end\nelse\n  print(string.format(\"No solution for %d queens.\\n\", N))\nend\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Scala", "code": "\n\nobject NQueens {\n\n  private implicit class RichPair[T](\n    pair: (T,T))(\n    implicit num: Numeric[T]\n  ) {\n    import num._\n\n    def safe(x: T, y: T): Boolean =\n      pair._1 - pair._2\u00a0!= abs(x - y)\n  }\n  \n  def solve(n: Int): Iterator[Seq[Int]] = {\n    (0 to n-1)\n      .permutations\n      .filter { v =>\n        (0 to n-1).forall { y =>\n          (y+1 to n-1).forall { x =>\n            (x,y).safe(v(x),v(y))\n          }\n        }\n      }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val n = args.headOption.getOrElse(\"8\").toInt\n    val (solns1, solns2) = solve(n).duplicate\n    solns1\n      .zipWithIndex\n      .foreach { case (soln, i) =>\n        Console.out.println(s\"Solution #${i+1}\")\n        output(n)(soln)\n      }\n    val n_solns = solns2.size\n    if (n_solns == 1) {\n      Console.out.println(\"Found 1 solution\")\n    } else {\n      Console.out.println(s\"Found $n_solns solutions\")\n    }\n  }\n\n  def output(n: Int)(board: Seq[Int]): Unit = {\n    board.foreach { queen =>\n      val row = \n        \"_|\" * queen + \"Q\" + \"|_\" * (n-queen-1)\n      Console.out.println(row)\n    }\n  }\n}\nscala> NQueens.main(Array(\"8\"))\nSolution #1\nQ|_|_|_|_|_|_|_\n_|_|_|_|Q|_|_|_\n_|_|_|_|_|_|_|Q\n_|_|_|_|_|Q|_|_\n_|_|Q|_|_|_|_|_\n_|_|_|_|_|_|Q|_\n_|Q|_|_|_|_|_|_\n_|_|_|Q|_|_|_|_\n\nSolution #2\nQ|_|_|_|_|_|_|_\n_|_|_|_|_|Q|_|_\n_|_|_|_|_|_|_|Q\n_|_|Q|_|_|_|_|_\n_|_|_|_|_|_|Q|_\n_|_|_|Q|_|_|_|_\n_|Q|_|_|_|_|_|_\n_|_|_|_|Q|_|_|_\n...\nFound 92 solutions\n\n", "explain": "Extends a Tuple2[T,T] (also represented as (T, T)) using an enriched implicit class to define check that positions are safe or threatened.\nLazily generates permutations with an Iterator.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Dart", "code": "\n/**\nReturn true if queen placement q[n] does not conflict with\nother queens q[0] through q[n-1]\n*/\nisConsistent(List q, int n) {\n  for (int i=0; i<n; i++) {\n    if (q[i] == q[n]) {\n      return false; // Same column\n    }\n    \n    if ((q[i] - q[n]) == (n - i)) {\n      return false; // Same major diagonal\n    }\n    \n    if ((q[n] - q[i]) == (n - i)) {\n      return false; // Same minor diagonal\n    }\n  }\n  \n  return true;\n}\n\n/**\nPrint out N-by-N placement of queens from permutation q in ASCII. \n*/\nprintQueens(List q) {\n  int N = q.length;\n  for (int i=0; i<N; i++) {\n    StringBuffer sb = new StringBuffer();\n    for (int j=0; j<N; j++) {\n      if (q[i] == j) {\n        sb.write(\"Q \");\n      } else {\n        sb.write(\"* \");\n      }\n    }\n    print(sb.toString());\n  }\n  print(\"\");\n}\n\n/**\nTry all permutations using backtracking\n*/\nenumerate(int N) {\n  var a = new List(N);\n  _enumerate(a, 0);\n}\n\n_enumerate(List q, int n) {\n  if (n == q.length) {\n    printQueens(q);\n  } else {\n    for (int i = 0; i < q.length; i++) {\n      q[n] = i;\n      if (isConsistent(q, n)){\n        _enumerate(q, n+1);\n      }\n    } \n  }\n}\n\nvoid main() {\n  enumerate(4);\n}\n\n\nOutput:\n* Q * * \n* * * Q \nQ * * * \n* * Q * \n\n* * Q * \nQ * * * \n* * * Q \n* Q * * \n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "D", "code": "\nShort Version[edit]\n\nvoid main() {\n    import std.stdio, std.algorithm, std.range, permutations2;\n\n    enum n = 8;\n    n.iota.array.permutations.filter!(p =>\n        n.iota.map!(i => p[i] + i).array.sort().uniq.count == n &&\n        n.iota.map!(i => p[i] - i).array.sort().uniq.count == n)\n    .count.writeln;\n}\n\n\nOutput:\n92\nIntermediate Version[edit]\n\nTranslation of: C\nenum side = 8;\n__gshared int[side] board;\n\nbool isUnsafe(in int y) nothrow @nogc {\n    immutable int x = board[y];\n    foreach (immutable i; 1 .. y + 1) {\n        immutable int t = board[y - i];\n        if (t == x || t == x - i || t == x + i)\n            return true;\n    }\n\n    return false;\n}\n\nvoid showBoard() nothrow @nogc {\n    import core.stdc.stdio;\n\n    static int s = 1;\n    printf(\"\\nSolution #%d:\\n\", s++);\n    foreach (immutable y; 0 .. side) {\n        foreach (immutable x; 0 .. side)\n            putchar(board[y] == x ? 'Q' : '.');\n        putchar('\\n');\n    }\n}\n\nvoid main() nothrow @nogc {\n    int y = 0;\n    board[0] = -1;\n\n    while (y >= 0) {\n        do {\n            board[y]++;\n        } while (board[y] < side && y.isUnsafe);\n\n        if (board[y] < side) {\n            if (y < (side - 1))\n                board[++y] = -1;\n            else\n                showBoard;\n        } else\n            y--;\n    }\n}\n\n\nOutput:\nSolution #1:\nQ.......\n....Q...\n.......Q\n.....Q..\n..Q.....\n......Q.\n.Q......\n...Q....\n\n[...]\n\nSolution #91:\n.......Q\n..Q.....\nQ.......\n.....Q..\n.Q......\n....Q...\n......Q.\n...Q....\n\nSolution #92:\n.......Q\n...Q....\nQ.......\n..Q.....\n.....Q..\n.Q......\n......Q.\n....Q...\nFast Version[edit]\nTranslation of: C\nulong nQueens(in uint nn) pure nothrow @nogc @safe\nin {\n    assert(nn > 0 && nn <= 27,\n           \"'side' value must be in 1 .. 27.\");\n} body {\n    if (nn < 4)\n        return nn == 1;\n\n    enum uint ulen = uint.sizeof * 8;\n    immutable uint full = uint.max - ((1 << (ulen - nn)) - 1);\n    immutable n = nn - 3;\n\n    typeof(return) count;\n    uint[32] l=void, r=void, c=void;\n    uint[33] mm; // mm and mmi are a stack.\n\n    // Require second queen to be left of the first queen, so\n    // we ever only test half of the possible solutions. This\n    // is why we can't handle n=1 here.\n    for (uint b0 = 1U << (ulen - n - 3); b0; b0 <<= 1) {\n        for (uint b1 = b0 << 2; b1; b1 <<= 1) {\n            uint d = n;\n            // c: columns occupied by previous queens.\n            c[n] = b0 | b1;\n            // l: columns attacked by left diagonals.\n            l[n] = (b0 << 2) | (b1 << 1);\n            // r: by right diagnoals.\n            r[n] = (b0 >> 2) | (b1 >> 1);\n\n            // Availabe columns on current row.\n            uint bits = full & ~(l[n] | r[n] | c[n]);\n\n            uint mmi = 1;\n            mm[mmi] = bits;\n\n            while (bits) {\n                // d: depth, aka row. counting backwards.\n                // Because !d is often faster than d\u00a0!= n.\n                while (d) {\n                    // immutable uint pos = 1U << bits.bsf; // Slower.\n                    immutable uint pos = -int(bits) & bits;\n\n                    // Mark bit used. Only put current bits on\n                    // stack if not zero, so backtracking will\n                    // skip exhausted rows (because reading stack\n                    // variable is slow compared to registers).\n                    bits &= ~pos;\n                    if (bits) {\n                        mm[mmi] = bits | d;\n                        mmi++;\n                    }\n\n                    d--;\n                    l[d] = (l[d + 1] | pos) << 1;\n                    r[d] = (r[d + 1] | pos) >> 1;\n                    c[d] =  c[d + 1] | pos;\n\n                    bits = full & ~(l[d] | r[d] | c[d]);\n\n                    if (!bits)\n                        break;\n                    if (!d) {\n                        count++;\n                        break;\n                    }\n                }\n\n                // Bottom of stack m is a zero'd field acting as\n                // sentinel.  When saving to stack, left 27 bits\n                // are the available columns, while right 5 bits\n                // is the depth. Hence solution is limited to size\n                // 27 board -- not that it matters in foreseeable\n                // future.\n                mmi--;\n                bits = mm[mmi];\n                d = bits & 31U;\n                bits &= ~31U;\n            }\n        }\n    }\n\n    return count * 2;\n}\n\nvoid main(in string[] args) {\n    import std.stdio, std.conv;\n\n    immutable uint side = (args.length >= 2) ? args[1].to!uint : 8;\n    writefln(\"N-queens(%d) = %d solutions.\", side, side.nQueens);\n}\n\n\nOutput:\nN-queens(8) = 92 solutions.\n\nN-queens(17) = 95815104 solutions.\n\nN-queens(19) = 4968057848 solutions.\n", "explain": "This high-level version uses the second solution of the Permutations task.\nThis version shows all the solutions.\nWith side = 17:\nRun-time for side = 17 compiled with ldc2 is about 49.5 seconds.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Haskell", "code": "\nimport Control.Monad\nimport Data.List\n\n-- given n, \"queens n\" solves the n-queens problem, returning a list of all the\n-- safe arrangements. each solution is a list of the columns where the queens are\n-- located for each row\nqueens :: Int -> [[Int]]\nqueens n = map fst $ foldM oneMoreQueen ([],[1..n]) [1..n]  where \n\n  -- foldM\u00a0:: (Monad m) => (a -> b -> m a) -> a -> [b] -> m a\n  -- foldM folds (from left to right) in the list monad, which is convenient for \n  -- \"nondeterminstically\" finding \"all possible solutions\" of something. the \n  -- initial value [] corresponds to the only safe arrangement of queens in 0 rows\n\n  -- given a safe arrangement y of queens in the first i rows, and a list of \n  -- possible choices, \"oneMoreQueen y _\" returns a list of all the safe \n  -- arrangements of queens in the first (i+1) rows along with remaining choices \n  oneMoreQueen (y,d) _ = [(x:y, delete x d) | x <- d, safe x]  where\n\n    -- \"safe x\" tests whether a queen at column x is safe from previous queens\n    safe x = and [x /= c + n && x /= c - n | (n,c) <- zip [1..] y]\n\n-- prints what the board looks like for a solution; with an extra newline\nprintSolution y = do\n     let n = length y\n     mapM_ (\\x -> putStrLn [if z == x then 'Q' else '.' | z <- [1..n]]) y\n     putStrLn \"\"\n\n-- prints all the solutions for 6 queens\nmain = mapM_ printSolution $ queens 6\n\n\nAlternative version[edit]\nimport Control.Monad (foldM)\nimport Data.List ((\\\\))\n\nmain :: IO ()\nmain = mapM_ print $ queens 8\n\nqueens :: Int -> [[Int]]\nqueens n = foldM f [] [1..n]\n    where\n      f qs _ = [q:qs | q <- [1..n] \\\\ qs, q `notDiag` qs]\n      q `notDiag` qs = and [abs (q - qi) /= i | (qi,i) <- qs `zip` [1..]]\n\nUsing permutations[edit]\n\nimport Data.List (nub, permutations)\n\n-- checks if queens are on the same diagonal\n-- with [0..] we place each queen on her own row\ncheck f = length . nub . zipWith f [0..]\n\n-- filters out results where 2 or more queens are on the same diagonal\n-- with [0..n-1] we place each queeen on her own column\ngenerate n = filter (\\x -> check (+) x == n && check (-) x == n) $ permutations [0..n-1]\n\n-- 8 is for \"8 queens\"\nmain = print $ generate 8\n\nIn terms of foldr[edit]\n\nTranslation of: JavaScript\nimport Data.List (intercalate, transpose)\n\n--------------------- N QUEENS PROBLEM -------------------\n\nqueenPuzzle :: Int -> Int -> [[Int]]\nqueenPuzzle nRows nCols\n  | nRows <= 0 = [[]]\n  | otherwise =\n      foldr\n        (\\x y -> y <> foldr (go x) [] [1 .. nCols])\n        []\n        $ queenPuzzle (pred nRows) nCols\n  where\n    go qs iCol b\n      | safe (nRows - 1) iCol qs = b <> [qs <> [iCol]]\n      | otherwise = b\n\nsafe :: Int -> Int -> [Int] -> Bool\nsafe iRow iCol qs =\n  (not . or) $\n    zipWith\n      ( \\sc sr ->\n          (iCol == sc) || (sc + sr == (iCol + iRow))\n            || (sc - sr == (iCol - iRow))\n      )\n      qs\n      [0 .. iRow - 1]\n\n--------------------------- TEST -------------------------\n-- 10 columns of solutions for the 7*7 board:\nshowSolutions :: Int -> Int -> [String]\nshowSolutions nCols nSize =\n  unlines\n    . fmap (intercalate \"   \")\n    . transpose\n    . map boardLines\n    <$> chunksOf nCols (queenPuzzle nSize nSize)\n  where\n    go r x\n      | r == x = '\u265b'\n      | otherwise = '.'\n    boardLines rows =\n      [ go r <$> [1 .. (length rows)]\n        | r <- rows\n      ]\n\nchunksOf :: Int -> [a] -> [[a]]\nchunksOf i = splits\n  where\n    splits [] = []\n    splits l = take i l : splits (drop i l)\n\nmain :: IO ()\nmain = (putStrLn . unlines) $ showSolutions 10 7\n\n\nOutput:\n......\u265b   ......\u265b   ......\u265b   ......\u265b   .....\u265b.   .....\u265b.   .....\u265b.   .....\u265b.   .....\u265b.   .....\u265b.\n.\u265b.....   ..\u265b....   ...\u265b...   ....\u265b..   \u265b......   .\u265b.....   ..\u265b....   ..\u265b....   ..\u265b....   ...\u265b...\n...\u265b...   .....\u265b.   \u265b......   ..\u265b....   ..\u265b....   ....\u265b..   ......\u265b   ....\u265b..   \u265b......   ......\u265b\n.....\u265b.   .\u265b.....   ....\u265b..   \u265b......   ....\u265b..   \u265b......   ...\u265b...   ......\u265b   ...\u265b...   \u265b......\n\u265b......   ....\u265b..   .\u265b.....   .....\u265b.   ......\u265b   ...\u265b...   \u265b......   \u265b......   ......\u265b   ..\u265b....\n..\u265b....   \u265b......   .....\u265b.   ...\u265b...   .\u265b.....   ......\u265b   ....\u265b..   ...\u265b...   ....\u265b..   ....\u265b..\n....\u265b..   ...\u265b...   ..\u265b....   .\u265b.....   ...\u265b...   ..\u265b....   .\u265b.....   .\u265b.....   .\u265b.....   .\u265b.....\n\n.....\u265b.   ....\u265b..   ....\u265b..   ....\u265b..   ....\u265b..   ....\u265b..   ....\u265b..   ...\u265b...   ...\u265b...   ...\u265b...\n...\u265b...   \u265b......   \u265b......   .\u265b.....   ..\u265b....   ......\u265b   ......\u265b   \u265b......   \u265b......   .\u265b.....\n.\u265b.....   .....\u265b.   ...\u265b...   .....\u265b.   \u265b......   .\u265b.....   .\u265b.....   ....\u265b..   ..\u265b....   ......\u265b\n......\u265b   ...\u265b...   ......\u265b   ..\u265b....   .....\u265b.   ...\u265b...   .....\u265b.   .\u265b.....   .....\u265b.   ....\u265b..\n....\u265b..   .\u265b.....   ..\u265b....   ......\u265b   ...\u265b...   .....\u265b.   ..\u265b....   .....\u265b.   .\u265b.....   ..\u265b....\n..\u265b....   ......\u265b   .....\u265b.   ...\u265b...   .\u265b.....   \u265b......   \u265b......   ..\u265b....   ......\u265b   \u265b......\n\u265b......   ..\u265b....   .\u265b.....   \u265b......   ......\u265b   ..\u265b....   ...\u265b...   ......\u265b   ....\u265b..   .....\u265b.\n\n...\u265b...   ...\u265b...   ...\u265b...   ..\u265b....   ..\u265b....   ..\u265b....   ..\u265b....   ..\u265b....   ..\u265b....   .\u265b.....\n.....\u265b.   ......\u265b   ......\u265b   \u265b......   \u265b......   ....\u265b..   .....\u265b.   ......\u265b   ......\u265b   ...\u265b...\n\u265b......   ....\u265b..   ..\u265b....   .....\u265b.   .....\u265b.   ......\u265b   .\u265b.....   ...\u265b...   .\u265b.....   .....\u265b.\n..\u265b....   .\u265b.....   .....\u265b.   .\u265b.....   ...\u265b...   .\u265b.....   ....\u265b..   \u265b......   ...\u265b...   \u265b......\n....\u265b..   .....\u265b.   .\u265b.....   ....\u265b..   .\u265b.....   ...\u265b...   \u265b......   ....\u265b..   .....\u265b.   ..\u265b....\n......\u265b   \u265b......   ....\u265b..   ......\u265b   ......\u265b   .....\u265b.   ...\u265b...   .\u265b.....   \u265b......   ....\u265b..\n.\u265b.....   ..\u265b....   \u265b......   ...\u265b...   ....\u265b..   \u265b......   ......\u265b   .....\u265b.   ....\u265b..   ......\u265b\n\n.\u265b.....   .\u265b.....   .\u265b.....   .\u265b.....   .\u265b.....   .\u265b.....   \u265b......   \u265b......   \u265b......   \u265b......\n...\u265b...   ....\u265b..   ....\u265b..   ....\u265b..   .....\u265b.   ......\u265b   ..\u265b....   ...\u265b...   ....\u265b..   .....\u265b.\n\u265b......   ......\u265b   ..\u265b....   \u265b......   ..\u265b....   ....\u265b..   ....\u265b..   ......\u265b   .\u265b.....   ...\u265b...\n......\u265b   ...\u265b...   \u265b......   ...\u265b...   ......\u265b   ..\u265b....   ......\u265b   ..\u265b....   .....\u265b.   .\u265b.....\n....\u265b..   \u265b......   ......\u265b   ......\u265b   ...\u265b...   \u265b......   .\u265b.....   .....\u265b.   ..\u265b....   ......\u265b\n..\u265b....   ..\u265b....   ...\u265b...   ..\u265b....   \u265b......   .....\u265b.   ...\u265b...   .\u265b.....   ......\u265b   ....\u265b..\n.....\u265b.   .....\u265b.   .....\u265b.   .....\u265b.   ....\u265b..   ...\u265b...   .....\u265b.   ....\u265b..   ...\u265b...   ..\u265b....\nBreadth-first search and Depth-first search[edit]\nimport Control.Monad\nimport System.Environment\n\n-- | data types for the puzzle\ntype Row    = Int\ntype State  = [Row]\ntype Thread = [Row]\n\n-- | utility functions\nempty = null\n\n-- | Check for infeasible states\ninfeasible :: Int -> (State, Thread) -> Bool\ninfeasible n ([], _)    = False\ninfeasible n ((r:rs),t) = length rs >= n || attack r rs || infeasible n (rs, t)\n\nfeasible n st = not $ infeasible n st\n\n-- | Check if a row is attacking another row of a state\nattack :: Row -> [Row] -> Bool\nattack r rs = r `elem` rs\n            || r `elem` (upperDiag rs)\n            || r `elem` (lowerDiag rs)\n  where \n    upperDiag xs = zipWith (-) xs [1..]\n    lowerDiag xs = zipWith (+) xs [1..]\n\n-- | Check if it is a goal state\nisGoal :: Int -> (State, Thread) -> Bool\nisGoal n (rs,t) = (feasible n (rs,t)) && (length rs == n)\n\n-- | Perform a move\nmove :: Int -> (State, Thread) -> (State, Thread)\nmove x (s,t)  = (x:s, x:t)\n\nchoices n = [1..n]\nmoves n   = pure move <*> choices n\n\nemptySt = ([],[])\n\n-- | Breadth-first search\nbfs :: Int -> [(State, Thread)] -> (State, Thread)\nbfs n []                     = error \"Could not find a feasible solution\"\nbfs n sts | (not.empty) goal = head goal\n          | otherwise        = bfs n sts2\n  where \n    goal = filter (isGoal n) sts2\n    sts2 = filter (feasible n) $ (moves n) <*> sts\n\n-- | Depth-first search\ndfs :: Int -> (State, Thread) -> [(State, Thread)]\ndfs n st | isGoal n st     = [st]\n         | infeasible n st = [emptySt]\n         | otherwise       = do x   <- [1..n]\n                                st2 <- dfs n $ move x st\n                                guard $ st2 /= emptySt\n                                return st2\n\nmain = do\n  [narg] <- getArgs\n  let n = read narg :: Int\n  print (bfs n [emptySt])\n  print (head $ dfs n emptySt)\n\n\nOutput:\n([1,5,8,6,3,7,2,4],[1,5,8,6,3,7,2,4])\n([4,2,7,3,6,8,5,1],[4,2,7,3,6,8,5,1])\n", "explain": "If you just want one solution, simply take the head of the result of queens n; since Haskell is lazy, it will only do as much work as needed to find one solution and stop.\nThis version uses permutations to generate unique horizontal and vertical position for each queen. Thus, we only need to check diagonals. However, it is less efficient than the previous version because it does not prune out prefixes that are found to be unsuitable.\nA back-tracking variant using the Prelude's plain foldr:\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "VBScript", "code": "\nTranslation of: BBC BASIC\n\n'N-queens problem - non recursive & structured - vbs - 24/02/2017\nconst l=15\ndim a(),s(),u(): redim a(l),s(l),u(4*l-2)\nfor i=1 to l: a(i)=i: next\nfor n=1 to l\n    m=0\n    i=1\n    j=0\n    r=2*n-1\n    Do\n        i=i-1\n        j=j+1\n        p=0\n        q=-r\n        Do\n            i=i+1\n            u(p)=1\n            u(q+r)=1\n            z=a(j): a(j)=a(i): a(i)=z  'swap a(i),a(j)\n            p=i-a(i)+n\n            q=i+a(i)-1\n            s(i)=j\n            j=i+1\n        Loop Until j>n Or u(p)<>0 Or u(q+r)<>0\n        If u(p)=0 Then\n            If u(q+r)=0 Then\n                m=m+1  'm: number of solutions\n                'x=\"\": for k=1 to n: x=x&\" \"&a(k): next: msgbox x,,m\n             End If\n        End If\n        j=s(i)\n        Do While j>=n And i<>0\n            Do\n                z=a(j): a(j)=a(i): a(i)=z  'swap a(i),a(j)\n                j=j-1\n            Loop Until j<i\n            i=i-1\n            p=i-a(i)+n\n            q=i+a(i)-1\n            j=s(i)\n            u(p)=0\n            u(q+r)=0\n        Loop\n    Loop Until i=0\n    wscript.echo n &\":\"& m\nnext 'n\n\nOutput:\n1\u00a0: 1\n2\u00a0: 0\n3\u00a0: 0\n4\u00a0: 2\n5\u00a0: 10\n6\u00a0: 4\n7\u00a0: 40\n8\u00a0: 92\n9\u00a0: 352\n10\u00a0: 724\n11\u00a0: 2680\n12\u00a0: 14200\n13\u00a0: 73712\n14\u00a0: 365596\n15\u00a0: 2279184\n\n", "explain": "To have the solutions printed (raw format) uncomment the ad hoc statement.\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Scheme", "code": "\n\n(import (scheme base)\n        (scheme write)\n        (srfi 1))\n\n;; return list of solutions to n-queens problem\n(define (n-queens n)\u00a0; breadth-first solution\n  (define (place-initial-row)\u00a0; puts a queen on each column of row 0\n    (list-tabulate n (lambda (col) (list (cons 0 col)))))\n  (define (place-on-row soln-so-far row)\n    (define (invalid? col)\n      (any (lambda (posn) \n             (or (= col (cdr posn))\u00a0; on same column\n                 (= (abs (- row (car posn)))\u00a0; on same diagonal\n                    (abs (- col (cdr posn))))))\n           soln-so-far))\n   \u00a0;\n    (do ((col 0 (+ 1 col))\n         (res '() (if (invalid? col)\n                    res\n                    (cons (cons (cons row col) soln-so-far)\n                          res))))\n      ((= col n) res)))\n \u00a0;\n  (do ((res (place-initial-row) \n            (apply append \n                   (map (lambda (soln-so-far) (place-on-row soln-so-far row))\n                        res)))\n       (row 1 (+ 1 row)))\n    ((= row n) res)))\n\n;; display solutions in 2-d array form\n(define (pretty-print solutions n)\n  (define (posn->index posn)\n    (+ (* n (cdr posn))\n       (car posn)))\n  (define (pp solution)\n    (let ((board (make-vector (square n) \".\")))\n      (for-each (lambda (queen) (vector-set! board \n                                             (posn->index queen)\n                                             \"Q\"))\n                solution)\n      (let loop ((row 0)\n                 (col 0))\n        (cond ((= row n) \n               (newline))\n              ((= col n) \n               (newline)\n               (loop (+ 1 row) 0))\n              (else\n                (display (vector-ref board (posn->index (cons row col))))\n                (loop row (+ 1 col)))))))\n \u00a0;\n  (display (string-append \"Found \"\n                          (number->string (length solutions))\n                          \" solutions for n=\"\n                          (number->string n)\n                          \"\\n\\n\"))\n  (for-each pp solutions))\n\n;; create table of number of solutions\n(do ((n 1 (+ 1 n)))\n  ((> n 10) )\n  (display n)\n  (display \" \")\n  (display (length (n-queens n)))\n  (newline))\n\n;; show some examples\n(pretty-print (n-queens 1) 1)\n(pretty-print (n-queens 2) 2)\n(pretty-print (n-queens 3) 3)\n(pretty-print (n-queens 4) 4)\n(pretty-print (n-queens 5) 5)\n(pretty-print (n-queens 8) 8)\n\nOutput:\n1 1\n2 0\n3 0\n4 2\n5 10\n6 4\n7 40\n8 92\n9 352\n10 724\nFound 1 solutions for n=1\n\nQ\n\nFound 0 solutions for n=2\n\nFound 0 solutions for n=3\n\nFound 2 solutions for n=4\n\n.Q..\n...Q\nQ...\n..Q.\n\n..Q.\nQ...\n...Q\n.Q..\n\nFound 10 solutions for n=5\n\nQ....\n...Q.\n.Q...\n....Q\n..Q..\n\nQ....\n..Q..\n....Q\n.Q...\n...Q.\n\n[[ etc ]]\nFound 92 solutions for n=8\n\nQ.......\n......Q.\n....Q...\n.......Q\n.Q......\n...Q....\n.....Q..\n..Q.....\n\nQ.......\n......Q.\n...Q....\n.....Q..\n.......Q\n.Q......\n....Q...\n..Q.....\n\n[[ etc ]]\n\n", "explain": "This is a simple breadth-first technique to retrieve all solutions. \n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 2\nfunction PlaceQueen ( [ref]$Board, $Row, $N )\n    {\n    #  For the current row, start with the first column\n    $Board.Value[$Row] = 0\n\n    #  While haven't exhausted all columns in the current row...\n    While ( $Board.Value[$Row] -lt $N )\n        {\n        #  If not the first row, check for conflicts\n        $Conflict = $Row -and\n                    (   (0..($Row-1)).Where{ $Board.Value[$_] -eq $Board.Value[$Row] }.Count -or\n                        (0..($Row-1)).Where{ $Board.Value[$_] -eq $Board.Value[$Row] - $Row + $_ }.Count -or\n                        (0..($Row-1)).Where{ $Board.Value[$_] -eq $Board.Value[$Row] + $Row - $_ }.Count )\n \n        #  If no conflicts and the current column is a valid column...\n        If ( -not $Conflict -and $Board.Value[$Row] -lt $N )\n            {\n\n            #  If this is the last row\n            #    Board completed successfully\n            If ( $Row -eq ( $N - 1 ) )\n                {\n                return $True\n                }\n\n            #  Recurse\n            #  If all nested recursions were successful\n            #    Board completed successfully\n            If ( PlaceQueen $Board ( $Row + 1 ) $N )\n                {\n                return $True\n                }\n            }\n        \n        #  Try the next column\n        $Board.Value[$Row]++\n        }\n\n    #  Everything was tried, nothing worked\n    Return $False\n    }\n \nfunction Get-NQueensBoard ( $N )\n    {\n    #  Start with a default board (array of column positions for each row)\n    $Board = @( 0 ) * $N\n\n    #  Place queens on board\n    #  If successful...\n    If ( PlaceQueen -Board ([ref]$Board) -Row 0 -N $N )\n        {\n        #  Convert board to strings for display\n        $Board | ForEach { ( @( \"\" ) + @(\" \") * $_ + \"Q\" + @(\" \") * ( $N - $_ ) ) -join \"|\" }\n        }\n    Else\n        {\n        \"There is no solution for N = $N\"\n        }\n    }\n\nGet-NQueensBoard 8\n''\nGet-NQueensBoard 3\n''\nGet-NQueensBoard 4\n''\nGet-NQueensBoard 14\n\n\nOutput:\n|Q| | | | | | | | \n| | | | |Q| | | | \n| | | | | | | |Q| \n| | | | | |Q| | | \n| | |Q| | | | | | \n| | | | | | |Q| | \n| |Q| | | | | | | \n| | | |Q| | | | | \n\nThere is no solution for N = 3\n\n| |Q| | | \n| | | |Q| \n|Q| | | | \n| | |Q| | \n\n|Q| | | | | | | | | | | | | | \n| | |Q| | | | | | | | | | | | \n| | | | |Q| | | | | | | | | | \n| | | | | | |Q| | | | | | | | \n| | | | | | | | | | | |Q| | | \n| | | | | | | | | |Q| | | | | \n| | | | | | | | | | | | |Q| | \n| | | |Q| | | | | | | | | | | \n| | | | | | | | | | | | | |Q| \n| | | | | | | | |Q| | | | | | \n| |Q| | | | | | | | | | | | | \n| | | | | |Q| | | | | | | | | \n| | | | | | | |Q| | | | | | | \n| | | | | | | | | | |Q| | | |\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Logo", "code": "\nto try :files :diag1 :diag2 :tried\n  if :files = 0 [make \"solutions :solutions+1  show :tried  stop]\n  localmake \"safe (bitand :files :diag1 :diag2)\n  until [:safe = 0] [\n    localmake \"f bitnot bitand :safe minus :safe\n    try bitand :files :f  ashift bitand :diag1 :f -1  (ashift bitand :diag2 :f 1)+1  fput bitnot :f :tried\n    localmake \"safe bitand :safe :safe-1\n  ]\nend\n\nto queens :n\n  make \"solutions 0\n  try (lshift 1 :n)-1 -1 -1 []\n  output :solutions\nend\n\nprint queens 8 \u00a0; 92\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "ABAP", "code": "\nTYPES: BEGIN OF gty_matrix,\n         1  TYPE c,\n         2  TYPE c,\n         3  TYPE c,\n         4  TYPE c,\n         5  TYPE c,\n         6  TYPE c,\n         7  TYPE c,\n         8  TYPE c,\n         9  TYPE c,\n         10 TYPE c,\n       END OF gty_matrix,\n       gty_t_matrix TYPE STANDARD TABLE OF gty_matrix INITIAL SIZE 8.\n\nDATA: gt_matrix TYPE gty_t_matrix,\n      gs_matrix TYPE gty_matrix,\n      gv_count  TYPE i VALUE 0,\n      gv_solut  TYPE i VALUE 0.\n\n\nSELECTION-SCREEN BEGIN OF BLOCK b01 WITH FRAME TITLE text-b01.\nPARAMETERS: p_number TYPE i OBLIGATORY DEFAULT 8.\nSELECTION-SCREEN END OF BLOCK b01.\n\n\" Filling empty table\nSTART-OF-SELECTION.\n  DO p_number TIMES.\n    APPEND gs_matrix TO gt_matrix.\n  ENDDO.\n\n\" Recursive Function\n  PERFORM fill_matrix USING gv_count 1 1 CHANGING gt_matrix.\n  BREAK-POINT.\n*&---------------------------------------------------------------------*\n*&      Form  FILL_MATRIX\n*----------------------------------------------------------------------*\nFORM fill_matrix  USING    p_count TYPE i\n                           p_i     TYPE i\n                           p_j     TYPE i\n                  CHANGING p_matrix TYPE gty_t_matrix.\n\n  DATA: lv_i      TYPE i,\n        lv_j      TYPE i,\n        lv_result TYPE c LENGTH 1,\n        lt_matrix TYPE gty_t_matrix,\n        lv_count  TYPE i,\n        lv_value  TYPE c.\n\n  lt_matrix[] = p_matrix[].\n  lv_count = p_count.\n  lv_i = p_i.\n  lv_j = p_j.\n\n  WHILE lv_i LE p_number.\n    WHILE lv_j LE p_number.\n      CLEAR lv_result.\n      PERFORM check_position USING lv_i lv_j CHANGING lv_result lt_matrix.\n      IF lv_result NE 'X'.\n        MOVE 'X' TO lv_value.\n        PERFORM get_position USING lv_i lv_j 'U' CHANGING lv_value lt_matrix.\n        ADD 1 TO lv_count.\n        IF lv_count EQ p_number.\n          PERFORM show_matrix USING lt_matrix.\n        ELSE.\n          PERFORM fill_matrix USING lv_count lv_i lv_j CHANGING lt_matrix.\n        ENDIF.\n        lv_value = space.\n        PERFORM get_position USING lv_i lv_j 'U' CHANGING lv_value lt_matrix.\n        SUBTRACT 1 FROM lv_count.\n      ENDIF.\n      ADD 1 TO lv_j.\n    ENDWHILE.\n    ADD 1 TO lv_i.\n    lv_j = 1.\n  ENDWHILE.\nENDFORM.                    \" FILL_MATRIX\n\n*&---------------------------------------------------------------------*\n*&      Form  CHECK_POSITION\n*&---------------------------------------------------------------------*\nFORM check_position  USING value(p_i)  TYPE i\n                           value(p_j)  TYPE i\n                     CHANGING p_result TYPE c\n                              p_matrix TYPE gty_t_matrix.\n\n  PERFORM get_position USING p_i p_j 'R' CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n  PERFORM check_horizontal USING p_i p_j CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n  PERFORM check_vertical USING p_i p_j CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n  PERFORM check_diagonals USING p_i p_j CHANGING p_result p_matrix.\n\nENDFORM.                    \" CHECK_POSITION\n\n*&---------------------------------------------------------------------*\n*&      Form  GET_POSITION\n*&---------------------------------------------------------------------*\nFORM get_position  USING value(p_i)      TYPE i\n                         value(p_j)      TYPE i\n                         value(p_action) TYPE c\n                      CHANGING p_result  TYPE c\n                               p_matrix  TYPE gty_t_matrix.\n\n  FIELD-SYMBOLS: <fs_lmatrix> TYPE gty_matrix,\n                 <fs_lfield> TYPE any.\n\n  READ TABLE p_matrix ASSIGNING <fs_lmatrix> INDEX p_i.\n  ASSIGN COMPONENT p_j OF STRUCTURE <fs_lmatrix> TO <fs_lfield>.\n\n  CASE p_action.\n    WHEN 'U'.\n      <fs_lfield> = p_result.\n    WHEN 'R'.\n      p_result = <fs_lfield>.\n    WHEN OTHERS.\n  ENDCASE.\n\nENDFORM.                    \" GET_POSITION\n\n*&---------------------------------------------------------------------*\n*&      Form  CHECK_HORIZONTAL\n*&---------------------------------------------------------------------*\nFORM check_horizontal  USING value(p_i)      TYPE i\n                             value(p_j)      TYPE i\n                          CHANGING p_result  TYPE c\n                                   p_matrix  TYPE gty_t_matrix.\n  DATA: lv_j TYPE i,\n        ls_matrix TYPE gty_matrix.\n\n  FIELD-SYMBOLS <fs> TYPE c.\n\n  lv_j = 1.\n  READ TABLE p_matrix INTO ls_matrix INDEX p_i.\n  WHILE lv_j LE p_number.\n    ASSIGN COMPONENT lv_j OF STRUCTURE ls_matrix TO <fs>.\n    IF <fs> EQ 'X'.\n      p_result = 'X'.\n      RETURN.\n    ENDIF.\n    ADD 1 TO lv_j.\n  ENDWHILE.\nENDFORM.                    \" CHECK_HORIZONTAL\n\n*&---------------------------------------------------------------------*\n*&      Form  CHECK_VERTICAL\n*&---------------------------------------------------------------------*\nFORM check_vertical  USING value(p_i)      TYPE i\n                           value(p_j)      TYPE i\n                        CHANGING p_result  TYPE c\n                                 p_matrix  TYPE gty_t_matrix.\n  DATA: lv_i TYPE i,\n        ls_matrix TYPE gty_matrix.\n\n  FIELD-SYMBOLS <fs> TYPE c.\n\n  lv_i = 1.\n  WHILE lv_i LE p_number.\n    READ TABLE p_matrix INTO ls_matrix INDEX lv_i.\n    ASSIGN COMPONENT p_j OF STRUCTURE ls_matrix TO <fs>.\n    IF <fs> EQ 'X'.\n      p_result = 'X'.\n      RETURN.\n    ENDIF.\n    ADD 1 TO lv_i.\n  ENDWHILE.\nENDFORM.                    \" CHECK_VERTICAL\n\n*&---------------------------------------------------------------------*\n*&      Form  CHECK_DIAGONALS\n*&---------------------------------------------------------------------*\nFORM check_diagonals  USING value(p_i)      TYPE i\n                            value(p_j)      TYPE i\n                         CHANGING p_result  TYPE c\n                                  p_matrix  TYPE gty_t_matrix.\n  DATA: lv_dx TYPE i,\n        lv_dy TYPE i.\n\n* I++ J++ (Up Right)\n  lv_dx = 1.\n  lv_dy = 1.\n  PERFORM check_diagonal USING p_i p_j lv_dx lv_dy CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n* I-- J-- (Left Down)\n  lv_dx = -1.\n  lv_dy = -1.\n  PERFORM check_diagonal USING p_i p_j lv_dx lv_dy CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n* I++ J-- (Right Down)\n  lv_dx = 1.\n  lv_dy = -1.\n  PERFORM check_diagonal USING p_i p_j lv_dx lv_dy CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\n\n* I-- J++ (Left Up)\n  lv_dx = -1.\n  lv_dy = 1.\n  PERFORM check_diagonal USING p_i p_j lv_dx lv_dy CHANGING p_result p_matrix.\n  CHECK p_result NE 'X'.\nENDFORM.                    \" CHECK_DIAGONALS\n\n*&---------------------------------------------------------------------*\n*&      Form  CHECK_DIAGONAL\n*&---------------------------------------------------------------------*\nFORM check_diagonal  USING value(p_i)      TYPE i\n                            value(p_j)      TYPE i\n                            value(p_dx)      TYPE i\n                            value(p_dy)      TYPE i\n                         CHANGING p_result  TYPE c\n                                  p_matrix  TYPE gty_t_matrix.\n  DATA: lv_i TYPE i,\n        lv_j TYPE i,\n        ls_matrix TYPE gty_matrix.\n\n  FIELD-SYMBOLS <fs> TYPE c.\n\n  lv_i = p_i.\n  lv_j = p_j.\n  WHILE 1 EQ 1.\n    ADD: p_dx TO lv_i, p_dy TO lv_j.\n\n    IF p_dx EQ 1.\n      IF lv_i GT p_number. EXIT. ENDIF.\n    ELSE.\n      IF lv_i LT 1. EXIT. ENDIF.\n    ENDIF.\n\n    IF p_dy EQ 1.\n      IF lv_j GT p_number. EXIT. ENDIF.\n    ELSE.\n      IF lv_j LT 1. EXIT. ENDIF.\n    ENDIF.\n\n    READ TABLE p_matrix INTO ls_matrix INDEX lv_i.\n    ASSIGN COMPONENT lv_j OF STRUCTURE ls_matrix TO <fs>.\n    IF <fs> EQ 'X'.\n      p_result = 'X'.\n      RETURN.\n    ENDIF.\n  ENDWHILE.\nENDFORM.                    \" CHECK_DIAGONAL\n*&---------------------------------------------------------------------*\n*&      Form  SHOW_MATRIX\n*----------------------------------------------------------------------*\nFORM show_matrix USING p_matrix TYPE gty_t_matrix.\n  DATA: lt_matrix TYPE gty_t_matrix,\n        lv_j      TYPE i VALUE 1,\n        lv_colum  TYPE string VALUE '-'.\n\n  FIELD-SYMBOLS: <fs_matrix> TYPE gty_matrix,\n                 <fs_field>  TYPE c.\n\n  ADD 1 TO gv_solut.\n\n  WRITE:/ 'Solution: ', gv_solut.\n\n  DO p_number TIMES.\n    CONCATENATE lv_colum '----' INTO lv_colum.\n  ENDDO.\n\n  LOOP AT p_matrix ASSIGNING <fs_matrix>.\n    IF sy-tabix EQ 1.\n      WRITE:/ lv_colum.\n    ENDIF.\n    WRITE:/ '|'.\n    DO p_number TIMES.\n      ASSIGN COMPONENT lv_j OF STRUCTURE <fs_matrix> TO <fs_field>.\n      IF <fs_field> EQ space.\n        WRITE: <fs_field> ,'|'.\n      ELSE.\n        WRITE: <fs_field> COLOR 2 HOTSPOT ON,'|'.\n      ENDIF.\n      ADD 1 TO lv_j.\n    ENDDO.\n    lv_j = 1.\n    WRITE: / lv_colum.\n  ENDLOOP.\n\n  SKIP 1.\nENDFORM.                    \" SHOW_MATRIX\n\n", "explain": ""}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "F#", "code": "\nlet rec iterate f value = seq { \n    yield value\n    yield! iterate f (f value) }\n\nlet up i = i + 1\nlet right i = i\nlet down i = i - 1\n\nlet noCollisionGivenDir solution number dir =\n    Seq.forall2 (<>) solution (Seq.skip 1 (iterate dir number))\n\nlet goodAddition solution number =\n    List.forall (noCollisionGivenDir solution number) [ up; right; down ]\n\nlet rec extendSolution n ps =\n    [0..n - 1]\n    |> List.filter (goodAddition ps)\n    |> List.map (fun num -> num :: ps)\n\nlet allSolutions n =\n    iterate (List.collect (extendSolution n)) [[]]\n\n// Print one solution for the 8x8 case\nlet printOneSolution () =\n    allSolutions 8\n    |> Seq.item 8\n    |> Seq.head\n    |> List.iter (fun rowIndex ->\n        printf \"|\"\n        [0..8] |> List.iter (fun i -> printf (if i = rowIndex then \"X|\" else \" |\"))\n        printfn \"\")\n\n// Print number of solution for the other cases\nlet printNumberOfSolutions () =\n    printfn \"Size\\tNr of solutions\"\n    [1..11]\n    |> List.map ((fun i -> Seq.item i (allSolutions i)) >> List.length)\n    |> List.iteri (fun i cnt -> printfn \"%d\\t%d\" (i+1) cnt)\n\nprintOneSolution()\n\nprintNumberOfSolutions()\n\n\n| | | |X| | | | | |\n| |X| | | | | | | |\n| | | | | | |X| | |\n| | |X| | | | | | |\n| | | | | |X| | | |\n| | | | | | | |X| |\n| | | | |X| | | | |\n|X| | | | | | | | |\n\nSize    Nr of solutions\n1       1\n2       0\n3       0\n4       2\n5       10\n6       4\n7       40\n8       92\n9       352\n10      724\n11      2680\n\n", "explain": "The output:\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Groovy", "code": "\nDistinct Solutions[edit]\n\ndef listOrder = { a, b ->\n    def k = [a.size(), b.size()].min()\n    def i = (0..<k).find { a[it] != b[it] }\n    (i != null) ? a[i] <=> b[i] : a.size() <=> b.size()\n}\n\ndef orderedPermutations = { list ->\n    def n = list.size()\n    (0..<n).permutations().sort(listOrder)\n}\n\ndef diagonalSafe = { list ->\n    def n = list.size()\n    n == 1 || (0..<(n-1)).every{ i ->\n        ((i+1)..<n).every{ j ->\n            !([list[i]+j-i, list[i]+i-j].contains(list[j]))\n        }\n    }\n}\n\ndef queensDistinctSolutions = { n ->\n    // each permutation is an N-Rooks solution\n    orderedPermutations((0..<n)).findAll (diagonalSafe)\n}\n\nUnique Solutions[edit]\n\nclass Reflect {\n    public static final diag = { list ->\n        final n = list.size()\n        def tList = [0] * n\n        (0..<n).each { tList[list[it]] = it }\n        tList\n    }\n    \n    public static final vert = { list ->\n        list.reverse()\n    }\n    \n    public static final horiz = { list ->\n        final n = list.size()\n        list.collect { n - it - 1 }\n    }\n}\n\nenum Rotations {\n    r0([]),\n    r90([Reflect.vert, Reflect.diag]),\n    r180([Reflect.vert, Reflect.diag, Reflect.vert, Reflect.diag]),\n    r270([Reflect.diag, Reflect.vert]);\n    \n    private final List operations\n    \n    private Rotations(List ops) {\n        operations = ops ?: []\n    }\n    \n    public static void eliminateDups(primary, solutions) {\n        (r0..r270).each { rot -> rot.eliminateDuplicates(primary, solutions) }\n    }\n    \n    private void eliminateDuplicates(primary, solutions) {\n        def rotated = [] + primary\n        operations.each { rotated = it(rotated) }\n        solutions.removeAll([rotated, Reflect.vert(rotated)])\n    }\n}\n\ndef queensUniqueSolutions = { start ->\n    assert start instanceof Number || start instanceof List\n    def qus = (start instanceof Number) \\\n                ? queensDistinctSolutions(start) \\\n                : [] + start\n    for (def i = 0; i < qus.size()-1; i++) {\n        Rotations.eliminateDups(qus[i], qus[(i+1)..<(qus.size())])\n    }\n    qus\n}\n\nTest and Results[edit]\n\n(1..9).each { n ->\n    def qds = queensDistinctSolutions(n)\n    def qus = queensUniqueSolutions(qds)\n    println ([boardSize:n, \"number of distinct solutions\":qds.size(), \"number of unique solutions\":qus.size()])\n    if(n < 9) { qus.each { println it } }\n    else { println \"first:${qus[0]}\"; println \"last:${qus[-1]}\" }\n    println()\n}\n\n\n[1, 3, 0, 2]\n\nrow 0 has a queen in column 1\nrow 1 has a queen in column 3\nrow 2 has a queen in column 0\nrow 3 has a queen in column 2\n\n   ---- ---- ---- ---- \n3 |    |////| \u265b |////|\n   ---- ---- ---- ---- \n2 |/\u265b/|    |////|    |\n   ---- ---- ---- ---- \n1 |    |////|    |/\u265b/|\n   ---- ---- ---- ----\n0 |////| \u265b |////|    |\n   ---- ---- ---- ---- \n    0    1    2    3\n\n[boardSize:1, number of distinct solutions:1, number of unique solutions:1]\n[0]\n\n[boardSize:2, number of distinct solutions:0, number of unique solutions:0]\n\n[boardSize:3, number of distinct solutions:0, number of unique solutions:0]\n\n[boardSize:4, number of distinct solutions:2, number of unique solutions:1]\n[1, 3, 0, 2]\n\n[boardSize:5, number of distinct solutions:10, number of unique solutions:2]\n[0, 2, 4, 1, 3]\n[1, 4, 2, 0, 3]\n\n[boardSize:6, number of distinct solutions:4, number of unique solutions:1]\n[1, 3, 5, 0, 2, 4]\n\n[boardSize:7, number of distinct solutions:40, number of unique solutions:6]\n[0, 2, 4, 6, 1, 3, 5]\n[0, 3, 6, 2, 5, 1, 4]\n[1, 3, 0, 6, 4, 2, 5]\n[1, 4, 0, 3, 6, 2, 5]\n[1, 4, 6, 3, 0, 2, 5]\n[1, 5, 2, 6, 3, 0, 4]\n\n[boardSize:8, number of distinct solutions:92, number of unique solutions:12]\n[0, 4, 7, 5, 2, 6, 1, 3]\n[0, 5, 7, 2, 6, 3, 1, 4]\n[1, 3, 5, 7, 2, 0, 6, 4]\n[1, 4, 6, 0, 2, 7, 5, 3]\n[1, 4, 6, 3, 0, 7, 5, 2]\n[1, 5, 0, 6, 3, 7, 2, 4]\n[1, 5, 7, 2, 0, 3, 6, 4]\n[1, 6, 2, 5, 7, 4, 0, 3]\n[1, 6, 4, 7, 0, 3, 5, 2]\n[2, 4, 1, 7, 0, 6, 3, 5]\n[2, 4, 7, 3, 0, 6, 1, 5]\n[2, 5, 1, 4, 7, 0, 6, 3]\n\n[boardSize:9, number of distinct solutions:352, number of unique solutions:46]\nfirst:[0, 2, 5, 7, 1, 3, 8, 6, 4]\nlast:[3, 1, 6, 8, 0, 7, 4, 2, 5]\n", "explain": "This solver starts with the N! distinct solutions to the N-Rooks problem and then keeps only the candidates in which all Queens are mutually diagonal-safe.\nUnique solutions are equivalence classes of distinct solutions, factoring out all reflections and rotations of a given solution. See the Wikipedia page  for more details.\nThis script tests both distinct and unique solution lists.\nInterpreting the Results:\nEach individual result is given as a list of N numbers. Each number represents a column number within the list-indexed row. So, the following 4-queens solution:\nshould be interpreted as follows:\nIn other words, this:\nResults:\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "Zig", "code": "\n\nconst std = @import(\"std\");\nconst stdout = std.io.getStdOut().outStream();\n\nvar board = [_]i8{-1} ** 8;\n\ninline fn abs(x: var) @TypeOf(x) {\n    return if (x < 0) -x else x;\n}\n\nfn safe(c: i32, r: i32) bool {\n    var i: i32 = 0;\n    return while (i < c)\u00a0: (i += 1) {\n        const q = board[@intCast(u3, i)];\n        if (r == q or c == i + abs(q - r))\n            break false;\n    } else true;\n}\n\npub fn main() !void {\n    var i: i32 = 0;\n    while (i >= 0) {\n        var j = board[@intCast(u3, i)] + 1;\n        while (j < 8)\u00a0: (j += 1) {\n            if (safe(i, j)) {\n                board[@intCast(u3, i)] = j;\n                i += 1;\n                break;\n            }\n        } else {\n            board[@intCast(u3, i)] = -1;\n            i -= 1;\n        }\n        if (i == 8) { // found a solution\n            for (board) |q|\n                try stdout.print(\"{} \", .{q + 1});\n            try stdout.print(\"\\n\", .{});\n            i -= 1; // create a failure to try new solutions.\n        }\n    }\n}\n\nOutput:\n$ zig run 8q.zig | head -n 4\n1 5 8 6 3 7 2 4 \n1 6 8 3 7 4 2 5 \n1 7 4 6 8 2 5 3 \n1 7 5 8 2 4 6 3 \n\n\n", "explain": "Outputs all 92 solutions.\n\n"}, {"task_name": "N-queens problem", "task_url": "https://rosettacode.org/wiki/N-queens_problem", "task_cat": "Puzzles", "lang": "AWK", "code": "\n\n#!/usr/bin/gawk -f\n# Solve the Eight Queens Puzzle\n#    Inspired by Raymond Hettinger [https://code.activestate.com/recipes/576647/]\n#    Just the vector of row positions per column is kept,\n#    and filled with all possibilities from left to right recursively,\n#    then checked against the columns left from the current one:\n#    - is a queen in the same row\n#    - is a queen in the digonal\n#    - is a queen in the reverse diagonal\nBEGIN {\n    dim = ARGC < 2 ? 8 : ARGV[1]\n    # make vec an array\n    vec[1] = 0\n    # scan for a solution\n    if (tryqueen(1, vec, dim))\n        result(vec, dim)\n    else \n        print \"No solution with \" dim \" queens.\"\n}\n    \n# try if a queen can be set in column (col)\nfunction tryqueen(col, vec, dim,        new)  {\n    for (new = 1; new <= dim; ++new) {\n        # check all previous columns\n        if (noconflict(new, col, vec, dim)) {\n            vec[col] = new\n            if (col == dim)\n                return 1        \n            # must try next column(s)\n           if (tryqueen(col+1, vec, dim))\n                return 1\n        }\n    }\n    # all tested, failed\n    return 0   \n}\n\n#  check if setting the queen (new) in column (col) is ok\n#  by checking the previous colums conflicts\nfunction noconflict(new, col, vec, dim,    j) {\n    for (j = 1; j < col; j++) {\n        if (vec[j] == new)\n            return 0    # same row\n        if (vec[j] == new - col + j) \n            return 0        # diagonal conflict\n        if (vec[j] == new + col - j)\n            return 0        # reverse diagonal conflict\n    }\n    # no test failed, no conflict\n    return 1   \n}\n\n# print matrix\nfunction result(vec, dim,    row, col, sep, lne) {\n    # print the solution vector\n    for (row  = 1; row <= dim; ++row)\n        printf \" %d\", vec[row] \n    print\n    \n    # print a board matrix\n    for (row = 1; row <= dim; ++row) {\n        lne = \"|\"\n        for (col = 1; col <= dim; ++col) {\n            if (row == vec[col])\n                lne = lne \"Q|\" \n            else\n                lne = lne \"_|\"\n        }\n        print lne\n    }\n}\n\n\nOutput:\n 1 5 8 6 3 7 2 4\n|Q|_|_|_|_|_|_|_|\n|_|_|_|_|_|_|Q|_|\n|_|_|_|_|Q|_|_|_|\n|_|_|_|_|_|_|_|Q|\n|_|Q|_|_|_|_|_|_|\n|_|_|_|Q|_|_|_|_|\n|_|_|_|_|_|Q|_|_|\n|_|_|Q|_|_|_|_|_|\n\n", "explain": "Inspired by Raymond Hettinger's Python solution, but builds the vector incrementally.\n"}]