[{"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n>>> from random import randrange\n>>> def sattoloCycle(items):\n\tfor i in range(len(items) - 1, 0, -1):\n\t\tj = randrange(i)  # 0 <= j <= i-1\n\t\titems[j], items[i] = items[i], items[j]\n\n\t\t\n>>> # Tests\n>>> for _ in range(10):\n\tlst = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n\tsattoloCycle(lst)\n\tprint(lst)\n\n\t\n[5, 8, 1, 2, 6, 4, 3, 9, 10, 7]\n[5, 9, 8, 10, 4, 3, 6, 2, 1, 7]\n[10, 5, 8, 3, 9, 1, 4, 2, 6, 7]\n[10, 5, 2, 6, 9, 7, 8, 3, 1, 4]\n[7, 4, 8, 5, 10, 3, 2, 9, 1, 6]\n[2, 3, 10, 9, 4, 5, 8, 1, 7, 6]\n[5, 7, 4, 6, 2, 9, 3, 10, 8, 1]\n[3, 10, 7, 2, 9, 5, 8, 4, 1, 6]\n[2, 6, 5, 3, 9, 8, 10, 7, 1, 4]\n[3, 6, 2, 5, 10, 4, 1, 9, 7, 8]\n>>>\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\nInteractive and without hardcoded inputs[edit]\n#include<stdlib.h>\n#include<stdio.h>\n#include<time.h>\n\nvoid sattoloCycle(void** arr,int count){\n\tint i,j;\n\tvoid* temp;\n\t\n\tif(count<2)\n\t\treturn;\n\tfor(i=count-1;i>=1;i--){\n\t\tj = rand()%i;\n\t\ttemp = arr[j];\n\t\tarr[j] = arr[i];\n\t\tarr[i] = temp;\n\t}\n}\n\nint main(int argC,char* argV[])\n{\n\tint i;\n\t\n\tif(argC==1)\n\t\tprintf(\"Usage\u00a0: %s <array elements separated by a space each>\",argV[0]);\n\telse{\n                srand((unsigned)time(NULL));\n\t\tsattoloCycle((void*)(argV + 1),argC-1);\n\t\t\n\t\tfor(i=1;i<argC;i++)\n\t\t\tprintf(\"%s \",argV[i]);\n\t}\n\treturn 0;\n}\n\n\nC:\\rosettaCode>sattoloCycle.exe \"\"\n\nC:\\rosettaCode>sattoloCycle.exe 10\n10\nC:\\rosettaCode>sattoloCycle.exe 10 20\n20 10\nC:\\rosettaCode>sattoloCycle.exe 10 20 30\n30 10 20\nC:\\rosettaCode>sattoloCycle.exe 11 12 13 14 15 16 17 18 19 20 21 22\n16 17 11 12 13 20 22 14 15 21 18 19\nC:\\rosettaCode>sattoloCycle.exe s a t t o l o C y c l e\nl o s a t c e t o l C y\nC:\\rosettaCode>sattoloCycle.exe 1 2.3 4.2 1 3 e r q t 2 1 oo 2.1 eds\n1 2.1 2.3 q r eds 1 e 3 t 1 2 oo 4.2\nC:\\rosettaCode>sattoloCycle.exe totally mixed up random string ( 1 2.3 2 ) which will get even more { a 2 q.1 } mixed up.\nmixed q.1 a 1 up ) 2 even { will ( } 2 more totally random get which string up. 2.3 mixed\n\nNon Interactive and with hardcoded inputs[edit]\n\n#include<stdlib.h>\n#include<stdio.h>\n#include<time.h>\n\nvoid sattoloCycle(void** arr,int count){\n\tint i,j;\n\tvoid* temp;\n\t\n\tif(count<2)\n\t\treturn;\n\tfor(i=count-1;i>=1;i--){\n\t\tj = rand()%i;\n\t\ttemp = arr[j];\n\t\tarr[j] = arr[i];\n\t\tarr[i] = temp;\n\t}\n}\n\nint main()\n{\n\tint i;\n\t\n\tint a[] = {};\n\tint b[] = {10};\n\tint c[] = {10, 20};\n\tint d[] = {10, 20, 30};\n\tint e[] = {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22};\n\n\tsrand((unsigned)time(NULL));\n\tsattoloCycle((void*)a,0);\n\t\t\n\tprintf(\"\\nShuffled a = \");\n\tfor(i=0;i<0;i++)\n\t\tprintf(\"%d \",a[i]);\n\t\t\n\tsattoloCycle((void*)b,1);\n\t\t\n\tprintf(\"\\nShuffled b = \");\n\tfor(i=0;i<1;i++)\n\t\tprintf(\"%d \",b[i]);\n\t\t\t\n\tsattoloCycle((void*)c,2);\n\t\t\n\tprintf(\"\\nShuffled c = \");\n\tfor(i=0;i<2;i++)\n\t\tprintf(\"%d \",c[i]);\n\t\n\tsattoloCycle((void*)d,3);\n\t\t\n\tprintf(\"\\nShuffled d = \");\n\tfor(i=0;i<3;i++)\n\t\tprintf(\"%d \",d[i]);\n\t\t\n\tsattoloCycle((void*)e,12);\n\t\t\n\tprintf(\"\\nShuffled e = \");\n\tfor(i=0;i<12;i++)\n\t\tprintf(\"%d \",e[i]);\n\n\treturn 0;\n}\n\n\nShuffled a =\nShuffled b = 10\nShuffled c = 20 10\nShuffled d = 20 30 10\nShuffled e = 13 18 14 20 17 15 21 19 16 12 22 11\n\n", "explain": "This is generic to the extreme, although the function is technically being fed strings, it can handle any type, as shown in the outputs below\u00a0:\nOutput:\nSame code but with hardcoded integer arrays as in the task to show that the function can handle any type.\nOutput:\n"}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include <ctime>\n#include <string>\n#include <iostream>\n#include <algorithm>\n\nclass cycle{\npublic:\n    template <class T>\n    void cy( T* a, int len ) {\n        int i, j;\n        show( \"original: \", a, len );\n        std::srand( unsigned( time( 0 ) ) );\n\n        for( int i = len - 1; i > 0; i-- ) {\n            do {\n                j = std::rand() % i;\n            } while( j >= i );\n            std::swap( a[i], a[j] );\n        }\n\n        show( \"  cycled: \", a, len ); std::cout << \"\\n\";\n    }\nprivate:\n    template <class T>\n    void show( std::string s, T* a, int len ) {\n        std::cout << s;\n        for( int i = 0; i < len; i++ ) {\n            std::cout << a[i] << \" \";\n        }\n        std::cout << \"\\n\";\n    }\n};\nint main( int argc, char* argv[] ) {\n    std::string d0[] = { \"\" },\n                d1[] = { \"10\" },\n                d2[] = { \"10\", \"20\" };\n    int         d3[] = { 10, 20, 30 },\n                d4[] = { 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22 };\n    cycle c;\n    c.cy( d0, sizeof( d0 ) / sizeof( d0[0] ) );\n    c.cy( d1, sizeof( d1 ) / sizeof( d1[0] ) );\n    c.cy( d2, sizeof( d2 ) / sizeof( d2[0] ) );\n    c.cy( d3, sizeof( d3 ) / sizeof( d3[0] ) );\n    c.cy( d4, sizeof( d4 ) / sizeof( d4[0] ) );\n\n    return 0;\n}\n\n\nOutput:\noriginal:\n  cycled:\n\noriginal: 10\n  cycled: 10\n\noriginal: 10 20\n  cycled: 20 10\n\noriginal: 10 20 30\n  cycled: 30 10 20\n\noriginal: 11 12 13 14 15 16 17 18 19 20 21 22\n  cycled: 13 17 14 22 11 18 20 12 21 19 15 16\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nprivate static final Random rng = new Random();\n\nvoid sattoloCycle(Object[] items) {\n    for (int i = items.length-1; i > 0; i--) {\n        int j = rng.nextInt(i);\n        Object tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nprivate static readonly Random Rand = new Random();\n\nvoid sattoloCycle<T>(IList<T> items) {\n    for (var i = items.Count; i-- > 1;) {\n        int j = Rand.Next(i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nfunction sattoloCycle(items) {\n    for (var i = items.length-1; i > 0; i--) {\n        var j = Math.floor(Math.random() * i);\n        var tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nfunction sattoloCycle($items) {\n   for ($i = 0; $i < count($items); $i++) {\n        $j = floor((mt_rand() / mt_getrandmax()) * $i);\n        $tmp = $items[$i];\n        $items[$i] = $items[$j];\n        $items[$j] = $tmp;\n    } \n    return $items;\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"math/rand\"\n\t\"fmt\"\n)\n\nfunc main() {\n\tlist := []int{1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\n\tfor i := 1; i <= 10; i++ {\n\t\tsattoloCycle(list)\n\t\tfmt.Println(list)\n\t}\n}\n\nfunc sattoloCycle(list []int) {\n\tfor x := len(list) -1; x > 0; x-- {\n\t\tj := rand.Intn(x)\n\t\tlist[x], list[j] = list[j], list[x]\n\t}\n}\n\n\nOutput:\n[4 5 1 7 3 9 10 2 8 6]\n[7 9 5 1 2 3 4 8 6 10]\n[2 3 9 4 6 8 7 1 10 5]\n[6 2 10 1 8 4 5 9 7 3]\n[8 3 7 2 10 1 6 4 9 5]\n[7 5 1 4 9 2 3 10 6 8]\n[6 8 3 10 2 4 7 1 5 9]\n[1 6 8 7 9 5 4 2 3 10]\n[9 5 10 6 2 8 1 7 4 3]\n[7 3 1 10 4 2 8 6 5 9]\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program sattolo.s   */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:      .ascii \"Value \u00a0: \"\nsMessValeur:       .fill 11, 1, ' '            @ size => 11\nszCarriageReturn: .asciz \"\\n\"\n\n.align 4\niGraine:  .int 123456\n.equ NBELEMENTS,      9\nTableNumber:\t     .int   4,6,7,10,11,15,22,30,35\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                           @ entry of program \n    ldr r0,iAdrTableNumber                      @ address number table\n    mov r1,#NBELEMENTS                          @ number of \u00e9lements \n    bl satShuffle\n    ldr r2,iAdrTableNumber\n    mov r3,#0\n1:                                              @ loop display table\n\tldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 1b\n\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess   \n    /*    2e shuffle             */\n    ldr r0,iAdrTableNumber                     @ address number table\n    mov r1,#NBELEMENTS                         @ number of \u00e9lements \n    bl satShuffle\n    ldr r2,iAdrTableNumber\n    mov r3,#0\n2:                                             @ loop display table\n    ldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                     @ display value\n    bl conversion10                            @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                           @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 2b\n\n100:                                           @ standard end of the program \n    mov r0, #0                                 @ return code\n    mov r7, #EXIT                              @ request to exit program\n    svc #0                                     @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrTableNumber:          .int TableNumber\n\n/******************************************************************/\n/*     Sattolo Shuffle                                  */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains the number of elements */\nsatShuffle:\n    push {r2-r6,lr}                                    @ save registers\n    mov r5,r0                                          @ save table address\n    mov r2,#1                                          @ start index\n    mov r4,r1                                          @ last index + 1\n1:\n    sub r1,r2,#1                                       @ index - 1\n    mov r0,r1                                          @ generate aleas\n    bl genereraleas\n    ldr r3,[r5,r1,lsl #2]                              @ swap number on the table\n    ldr r6,[r5,r0,lsl #2]\n    str r6,[r5,r1,lsl #2]\n    str r3,[r5,r0,lsl #2]\n    add r2,#1                                           @ next number\n    cmp r2,r4                                           @ end\u00a0?\n    ble 1b                                              @ no -> loop\n\n100:\n    pop {r2-r6,lr}\n    bx lr                                               @ return \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n\n1:\t                                            @ start loop\n    bl divisionpar10U                               @unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b\t                                    @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                    @ and move spaces in end on area\n    mov r0,r4                                       @ result length \n    mov r1,#' '                                     @ space\n3:\n    strb r1,[r3,r4]                                 @ store space in area\n    add r4,#1                                       @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                          @ loop if r4 <= area size\n\n100:\n    pop {r1-r4,lr}                                  @ restaur registres \n    bx lr                                           @return\n\n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                       @ save value\n    //mov r3,#0xCCCD                                @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                               @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                             @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                            @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                              @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                            @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                            @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                           @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* r0 contains limit  */\ngenereraleas:\n    push {r1-r4,lr}                                  @ save registers \n    ldr r4,iAdriGraine\n    ldr r2,[r4]\n    ldr r3,iNbDep1\n    mul r2,r3,r2\n    ldr r3,iNbDep1\n    add r2,r2,r3\n    str r2,[r4]                                      @ maj de la graine pour l appel suivant \n    cmp r0,#0\n    beq 100f\n    mov r1,r0                                        @ divisor\n    mov r0,r2                                        @ dividende\n    bl division\n    mov r0,r3                                        @ r\u00e9sult = remainder\n  \n100:                                                 @ end function\n    pop {r1-r4,lr}                                   @ restaur registers\n    bx lr                                            @ return\n/*****************************************************/\niAdriGraine: .int iGraine\t\niNbDep1: .int 0x343FD\niNbDep2: .int 0x269EC3 \n/***************************************************/\n/* integer division unsigned                       */\n/***************************************************/\ndivision:\n    /* r0 contains dividend */\n    /* r1 contains divisor */\n    /* r2 returns quotient */\n    /* r3 returns remainder */\n    push {r4, lr}\n    mov r2, #0                                         @ init quotient\n    mov r3, #0                                         @ init remainder\n    mov r4, #32                                        @ init counter bits\n    b 2f\n1:                                                     @ loop \n    movs r0, r0, LSL #1                                @ r0 <- r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1)\n    adc r3, r3, r3                                     @ r3 <- r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C \n    cmp r3, r1                                         @ compute r3 - r1 and update cpsr \n    subhs r3, r3, r1                                   @ if r3 >= r1 (C=1) then r3 <- r3 - r1 \n    adc r2, r2, r2                                     @ r2 <- r2 + r2 + C. This is equivalent to r2 <- (r2 << 1) + C \n2:\n    subs r4, r4, #1                                    @ r4 <- r4 - 1 \n    bpl 1b                                             @ if r4 >= 0 (N=0) then loop\n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\nprocedure DoSattoloCycle(var IA: array of integer);\n{Shuffle integers in array using Sattolo cycle}\nvar I,J,T: integer;\nbegin\n{Make sure random number generator is random}\nRandomize;\n{Randomly shuffle every item in the array}\nfor I:=High(IA) downto 0 do\n\tbegin\n\tJ:=Random(I);\n\tT:=IA[I]; IA[I]:=IA[J]; IA[J]:=T;\n\tend;\nend;\n\n{Test data specified in problem}\n\nvar SatTest1: array of integer;\nvar SatTest2: array [0..0] of integer = (10);\nvar SatTest3: array [0..1] of integer = (10, 20);\nvar SatTest4: array [0..2] of integer = (10, 20, 30);\nvar SatTest5: array [0..11] of integer = (11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22);\n\n\nprocedure ShowSattoloCycle(Memo: TMemo);\n\n\tprocedure ShowIntArray(Title: string; IA: array of integer);\n\t{Display title and array}\n\tvar I: integer;\n\tvar S: string;\n\tbegin\n\tS:=Title+' [';\n\tfor I:=0 to High(IA) do\n\t\tbegin\n\t\tif I<>0 then S:=S+' ';\n\t\tS:=S+IntToStr(IA[I]);\n\t\tend;\n\tS:=S+']';\n\tMemo.Lines.Add(S);\n\tend;\n\n\n\tprocedure ShowShuffleData(var IA: array of integer);\n\t{Shuffle and display specified array}\n\tbegin\n\tShowIntArray('Original data:', IA);\n\tDoSattoloCycle(IA);\n\tShowIntArray('Shuffled data:',IA);\n\tend;\n\n\nbegin\n{Shuffle and display all data items}\nShowShuffleData(SatTest1);\nShowShuffleData(SatTest2);\nShowShuffleData(SatTest3);\nShowShuffleData(SatTest4);\nShowShuffleData(SatTest5);\nend;\n\n\nOutput:\nOriginal data: []\nShuffled data: []\nOriginal data: [10]\nShuffled data: [10]\nOriginal data: [10 20]\nShuffled data: [20 10]\nOriginal data: [10 20 30]\nShuffled data: [20 30 10]\nOriginal data: [11 12 13 14 15 16 17 18 19 20 21 22]\nShuffled data: [18 11 16 15 22 17 20 21 12 19 14 13]\nElapsed Time: 11.480 ms.\n\n\n", "explain": "\n"}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n> class Array\n>   def sattolo_cycle!\n>     (length - 1).downto(1) do |i|\n*       j = rand(i)\n>       self[i], self[j] = self[j], self[i]\n>     end\n>     self\n>   end\n> end\n=> :sattolo_cycle!\n\n> # Tests\n> 10.times do\n*   p [1, 2, 3, 4, 5, 6, 7, 8, 9, 10].sattolo_cycle!\n> end\n[10, 6, 9, 7, 8, 1, 3, 2, 5, 4]\n[3, 7, 5, 10, 4, 8, 1, 2, 6, 9]\n[10, 3, 4, 8, 9, 7, 1, 5, 6, 2]\n[8, 7, 4, 2, 6, 9, 1, 5, 10, 3]\n[2, 7, 5, 10, 8, 3, 6, 9, 4, 1]\n[2, 10, 8, 6, 1, 3, 5, 9, 7, 4]\n[8, 5, 6, 1, 4, 9, 2, 10, 7, 3]\n[5, 4, 10, 7, 2, 1, 8, 9, 3, 6]\n[9, 8, 4, 2, 6, 1, 5, 10, 3, 7]\n[9, 4, 2, 7, 6, 1, 10, 3, 8, 5]\n=> 10\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nextension Array {\n  public mutating func satalloShuffle() {\n    for i in stride(from: index(before: endIndex), through: 1, by: -1) {\n      swapAt(i, .random(in: 0..<i))\n    }\n  }\n\n  public func satalloShuffled() -> [Element] {\n    var arr = Array(self)\n\n    arr.satalloShuffle()\n\n    return arr\n  }\n}\n\nlet testCases = [\n  [],\n  [10, 20],\n  [10, 20, 30],\n  [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]\n]\n\nfor testCase in testCases {\n  let shuffled = testCase.satalloShuffled()\n\n  guard zip(testCase, shuffled).allSatisfy(!=) else {\n    fatalError(\"satallo shuffle failed\")\n  }\n\n  print(\"\\(testCase) shuffled = \\(shuffled)\")\n}\n\n\nOutput:\n[] shuffled = []\n[10, 20] shuffled = [20, 10]\n[10, 20, 30] shuffled = [20, 30, 10]\n[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] shuffled = [20, 22, 17, 12, 19, 14, 15, 13, 21, 16, 11, 18]\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nsattolo <- function(vec)\n{\n  last <- length(vec)\n  if(last >= 2)\n  {\n    for(i in last:2)\n    {\n      j <- sample(seq_len(i - 1), size = 1)\n      vec[c(i, j)] <- vec[c(j, i)]\n    } \n  }\n  vec\n}\n#Demonstration:\nsattolo(integer(0))\nsattolo(c(10))\nreplicate(10, sattolo(c(10, 20)))\nreplicate(10, sattolo(c(10, 20, 30)))\nsattolo(c(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))\nsattolo(c(\"Also\", \"works\", \"for\", \"strings\"))\n\n\nOutput:\n> sattolo(integer(0))\ninteger(0)\n> sattolo(c(10))\n[1] 10\n> replicate(10, sattolo(c(10, 20)))\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]   20   20   20   20   20   20   20   20   20    20\n[2,]   10   10   10   10   10   10   10   10   10    10\n> replicate(10, sattolo(c(10, 20, 30)))\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]   30   30   20   20   30   20   20   20   20    20\n[2,]   10   10   30   30   10   30   30   30   30    30\n[3,]   20   20   10   10   20   10   10   10   10    10\n> sattolo(c(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22))\n [1] 12 13 15 16 20 11 22 17 14 21 18 19\n> sattolo(c(\"Also\", \"works\", \"for\", \"strings\"))\n[1] \"strings\" \"for\"     \"Also\"    \"works\" \n", "explain": "Basically identical to https://rosettacode.org/wiki/Knuth_shuffle#Short_version We've only changed an i to an i-1, changed the function names, and added the [11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22] test.\n"}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction sattolocycle!(arr::Array, last::Int=length(arr))\n    for i in last:-1:2\n        j = rand(1:i-1)\n        arr[i], arr[j] = arr[j], arr[i]\n    end\n    return arr\nend\n\n@show sattolocycle!([])\n@show sattolocycle!([10])\n@show sattolocycle!([10, 20, 30])\n@show sattolocycle!([11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22])\n\n\nOutput:\nsattolocycle!([]) = Any[]\nsattolocycle!([10]) = [10]\nsattolocycle!([10, 20, 30]) = [30, 10, 20]\nsattolocycle!([11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]) = [19, 20, 15, 11, 17, 18, 21, 22, 13, 16, 12, 14]\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun <T> sattolo(items: Array<T>) {\n    for (i in items.size - 1 downTo 1) {\n        val j = (Math.random() * i).toInt()\n        val t = items[i]\n        items[i] = items[j]\n        items[j] = t\n    }\n}\n\nfun main(args: Array<String>) {\n    val items = arrayOf(11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22)\n    println(items.joinToString())\n    sattolo(items)\n    println(items.joinToString())\n}\n\n\n\nOutput:\n11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22\n22, 11, 19, 12, 21, 14, 18, 20, 17, 16, 13, 15\n\n\n", "explain": "Sample output:\n"}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n@a = 0..30;\n\nprintf \"%2d \", $_ for @a; print \"\\n\";\nsattolo_cycle(\\@a);\nprintf \"%2d \", $_ for @a; print \"\\n\";\n\nsub sattolo_cycle {\n    my($array) = @_;\n    for $i (reverse 0 .. -1+@$array) {\n        my $j = int rand $i;\n        @$array[$j, $i] = @$array[$i, $j];\n    }\n}\n\n\nOutput:\n 0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24 25 26 27 28 29 30\n18  5  9 25  3 23 12  2 26 21 16  4 11 15 20  1 27 10 29  7  6 28 24  8 13 17 19  0 14 30 22\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\n@interface NSMutableArray (SattoloCycle)\n- (void)sattoloCycle;\n@end\n@implementation NSMutableArray (SattoloCycle)\n- (void)sattoloCycle {\n  for (NSUInteger i = self.count-1; i > 0; i--) {\n    NSUInteger j = arc4random_uniform(i);\n    [self exchangeObjectAtIndex:i withObjectAtIndex:j];\n  }\n}\n@end\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction sattolo (items)\n    local j\n    for i = #items, 2, -1 do\n        j = math.random(i - 1)\n        items[i], items[j] = items[j], items[i]\n    end\nend\n\nmath.randomseed(os.time())\nlocal testCases = {\n    {},\n    {10},\n    {10, 20},\n    {10, 20, 30},\n    {11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22}\n}\nfor _, array in pairs(testCases) do\n    sattolo(array)\n    print(\"[\" .. table.concat(array, \", \") .. \"]\")\nend\n\n\nOutput:\n[]\n[10]\n[20, 10]\n[30, 10, 20]\n[15, 17, 22, 18, 16, 19, 21, 11, 12, 13, 20, 14]\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef shuffle[T](a: Array[T]): Array[T] = {\n  scala.util.Random.shuffle(a)\n  a\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main() {\n    auto items = [0,1,2,3,4,5];\n    sattoloCycle(items);\n    items.writeln;\n}\n\n/// The Sattolo cycle is an algorithm for randomly shuffling an array in such a way that each element ends up in a new position.\nvoid sattoloCycle(R)(R items) {\n    import std.algorithm : swapAt;\n    import std.random : uniform;\n\n    for (int i=items.length; i-- > 1;) {\n        int j = uniform(0, i);\n        items.swapAt(i, j);\n    }\n}\n\nunittest {\n    import std.range : lockstep;\n    auto o = ['a', 'b', 'c', 'd', 'e'];\n\n    auto s = o.dup;\n    sattoloCycle(s);\n    foreach (a, b; lockstep(o, s)) {\n        assert(a != b, \"An element stayed in place unexpectedly.\");\n    }\n}\n\n\nOutput:\n\n[2, 4, 1, 5, 3, 0]\n[3, 0, 4, 5, 1, 2]\n[3, 5, 4, 1, 0, 2]\n[5, 4, 3, 0, 2, 1]\n\n", "explain": "Several runs shown\n"}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nimport Control.Monad ((>=>), (>>=), forM_)\nimport Control.Monad.Primitive\nimport qualified Data.Vector as V\nimport qualified Data.Vector.Mutable as M\nimport System.Random.MWC\n\ntype MutVec m a = M.MVector (PrimState m) a\n\n-- Perform an in-place shuffle of the vector, making it a single random cyclic\n-- permutation of its initial value.  The vector is also returned for\n-- convenience.\ncyclicPermM :: PrimMonad m => Gen (PrimState m) -> MutVec m a -> m (MutVec m a)\ncyclicPermM rand vec = forM_ [1..M.length vec-1] upd >> return vec\n  where upd i = uniformR (0, i-1) rand >>= M.swap vec i\n\n-- Return a vector that is a single random cyclic permutation of the argument.\ncyclicPerm :: PrimMonad m => Gen (PrimState m) -> V.Vector a -> m (V.Vector a)\ncyclicPerm rand = V.thaw >=> cyclicPermM rand >=> V.unsafeFreeze\n\n--------------------------------------------------------------------------------\n\ntest :: Show a => [a] -> IO ()\ntest xs = do\n  let orig = V.fromList xs\n  cyc <- withSystemRandom . asGenIO $ \\rand -> cyclicPerm rand orig\n  putStrLn $ \"original: \" ++ show orig\n  putStrLn $ \"  cycled: \" ++ show cyc\n\nmain :: IO ()\nmain = do\n  test ([] :: [()])\n  test [10 :: Int]\n  test [10, 20 :: Int]\n  test [10, 20, 30 :: Int]\n  test [11..22 :: Int]\n  -- Also works for other types.\n  test \"abcdef\"\n\n\nOutput:\n$ ./sattolo \noriginal: []\n  cycled: []\noriginal: [10]\n  cycled: [10]\noriginal: [10,20]\n  cycled: [20,10]\noriginal: [10,20,30]\n  cycled: [20,30,10]\noriginal: [11,12,13,14,15,16,17,18,19,20,21,22]\n  cycled: [13,14,16,11,17,20,18,21,22,15,19,12]\noriginal: \"abcdef\"\n  cycled: \"cfeabd\"\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "TypeScript", "code": "\nfunction sattoloCycle<T>(items: Array<T>): void {\n    for (let i = items.length; i -= 1;) {\n        const j = Math.floor(Math.random() * i);\n        const tmp = items[i];\n        items[i] = items[j];\n        items[j] = tmp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Sattolo cycle", "task_url": "https://rosettacode.org/wiki/Sattolo_cycle", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nlet rnd=System.Random()\nlet sottolo(n:int[])=let rec fN g=match g with -1|0->() |_->let e=rnd.Next(g-1) in let l=n.[g] in n.[g]<-n.[e]; n.[e]<-l; fN (g-1) in fN((Array.length n)-1)\n[[||];[|10|];[|10;20|];[|10;20;30|];[|11..22|]]|>List.iter(fun n->printf \"%A->\" n; sottolo n; printfn \"%A\" n)\n\n\nOutput:\n[||]->[||]\n[|10|]->[|10|]\n[|10; 20|]->[|20; 10|]\n[|10; 20; 30|]->[|20; 30; 10|]\n[|11; 12; 13; 14; 15; 16; 17; 18; 19; 20; 21; 22|]->[|17; 20; 16; 15; 18; 11; 14; 21; 12; 13; 22; 19|]\n\n", "explain": ""}]