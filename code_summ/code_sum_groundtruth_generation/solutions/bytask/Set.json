[{"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Python", "code": "\n\nWorks with: Python version 2.7+ and 3.0+\n>>> s1, s2 = {1, 2, 3, 4}, {3, 4, 5, 6}\n>>> s1 | s2 # Union\n{1, 2, 3, 4, 5, 6}\n>>> s1 & s2 # Intersection\n{3, 4}\n>>> s1 - s2 # Difference\n{1, 2}\n>>> s1 < s1 # True subset\nFalse\n>>> {3, 1} < s1 # True subset\nTrue\n>>> s1 <= s1 # Subset\nTrue\n>>> {3, 1} <= s1 # Subset\nTrue\n>>> {3, 2, 4, 1} == s1 # Equality\nTrue\n>>> s1 == s2 # Equality\nFalse\n>>> 2 in s1 # Membership\nTrue\n>>> 10 not in s1 # Non-membership\nTrue\n>>> {1, 2, 3, 4, 5} > s1 # True superset\nTrue\n>>> {1, 2, 3, 4} > s1 # True superset\nFalse\n>>> {1, 2, 3, 4} >= s1 # Superset\nTrue\n>>> s1 ^ s2 # Symmetric difference\n{1, 2, 5, 6}\n>>> len(s1) # Cardinality\n4\n>>> s1.add(99) # Mutability\n>>> s1\n{99, 1, 2, 3, 4}\n>>> s1.discard(99) # Mutability\n>>> s1\n{1, 2, 3, 4}\n>>> s1 |= s2 # Mutability\n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>> s1 -= s2 # Mutability\n>>> s1\n{1, 2}\n>>> s1 ^= s2 # Mutability\n>>> s1\n{1, 2, 3, 4, 5, 6}\n>>>\n\n", "explain": "In Python, set is a standard type since Python 2.4. \nThere is also frozenset which is an immutable version of set. (In Python 2.3, they were provided as Set and ImmutableSet types in the module sets.)\nLanguage syntax for set literals is supported starting in Python 3.0 and 2.7. \n(For versions prior to 2.7, use set([1, 2, 3, 4]) instead of {1, 2, 3, 4}. Even in Python 2.7+ and 3.0+, it is necessary to write set() to express the empty set.)\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "C", "code": "\n\n#include <stdio.h>\n\ntypedef unsigned int set_t; /* probably 32 bits; change according to need */\n\nvoid show_set(set_t x, const char *name)\n{\n\tint i;\n\tprintf(\"%s is:\", name);\n\tfor (i = 0; (1U << i) <= x; i++)\n\t\tif (x & (1U << i))\n\t\t\tprintf(\" %d\", i);\n\tputchar('\\n');\n}\n\nint main(void)\n{\n\tint i;\n\tset_t a, b, c;\n\t\n\ta = 0; /* empty set */\n\tfor (i = 0; i < 10; i += 3) /* add 0 3 6 9 to set a */\n\t\ta |= (1U << i);\n\tshow_set(a, \"a\");\n\n\tfor (i = 0; i < 5; i++)\n\t\tprintf(\"\\t%d%s in set a\\n\", i, (a & (1U << i)) ? \"\":\" not\");\n\n\tb = a;\n\tb |= (1U << 5); b |= (1U << 10); /* b is a plus 5, 10 */\n\tb &= ~(1U << 0);\t/* sans 0 */\n\tshow_set(b, \"b\");\n\n\tshow_set(a | b, \"union(a, b)\");\n\tshow_set(c = a & b, \"c = common(a, b)\");\n\tshow_set(a & ~b, \"a - b\"); /* diff, not arithmetic minus */\n\tshow_set(b & ~a, \"b - a\");\n\tprintf(\"b is%s a subset of a\\n\", !(b & ~a) ? \"\" : \" not\");\n\tprintf(\"c is%s a subset of a\\n\", !(c & ~a) ? \"\" : \" not\");\n\n\tprintf(\"union(a, b) - common(a, b) %s union(a - b, b - a)\\n\",\n\t\t((a | b) & ~(a & b)) == ((a & ~b) | (b & ~a))\n\t\t\t? \"equals\" : \"does not equal\");\n\n\treturn 0;\n}\n\n", "explain": "Building a set highly depends on the datatype and use case.  For example, a set of string could be implemented by hash table, sort tree or trie, but if all sets are known to have very few number of elements, it might be best to use just flat arrays.  There isn't, and shouldn't be, an all-purpose set type for C.\nA frequent use of set is that of small, non-negative integers, implemented as a bit field as shown below.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "C++", "code": "\n\n#include <set>\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\nnamespace set_display {\ntemplate <class T>\nstd::ostream& operator<<(std::ostream& os, const std::set<T>& set)\n{\n    os << '[';\n    if (!set.empty()) {\n        std::copy(set.begin(), --set.end(), std::ostream_iterator<T>(os, \", \"));\n        os << *--set.end();\n    }\n    return os << ']';\n}\n}\n\ntemplate <class T>\nbool contains(const std::set<T>& set, const T& key)\n{\n    return set.count(key) != 0;\n}\n\ntemplate <class T>\nstd::set<T> set_union(const std::set<T>& a, const std::set<T>& b)\n{\n    std::set<T> result;\n    std::set_union(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));\n    return result;\n}\n\ntemplate <class T>\nstd::set<T> set_intersection(const std::set<T>& a, const std::set<T>& b)\n{\n    std::set<T> result;\n    std::set_intersection(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));\n    return result;\n}\n\ntemplate <class T>\nstd::set<T> set_difference(const std::set<T>& a, const std::set<T>& b)\n{\n    std::set<T> result;\n    std::set_difference(a.begin(), a.end(), b.begin(), b.end(), std::inserter(result, result.end()));\n    return result;\n}\n\ntemplate <class T>\nbool is_subset(const std::set<T>& set, const std::set<T>& subset)\n{\n    return std::includes(set.begin(), set.end(), subset.begin(), subset.end());\n}\n\nint main()\n{\n    using namespace set_display;\n    std::set<int> a{2, 5, 7, 5, 9, 2}; //C++11 initialization syntax\n    std::set<int> b{1, 5, 9, 7, 4 };\n    std::cout << \"a = \" << a << '\\n';\n    std::cout << \"b = \" << b << '\\n';\n\n    int value1 = 8, value2 = 5;\n    std::cout << \"Set a \" << (contains(a, value1) ? \"contains \" : \"does not contain \") << value1 << '\\n';\n    std::cout << \"Set a \" << (contains(a, value2) ? \"contains \" : \"does not contain \") << value2 << '\\n';\n\n    std::cout << \"Union of a and b: \" << set_union(a, b) << '\\n';\n    std::cout << \"Intersection of a and b: \" << set_intersection(a, b) << '\\n';\n    std::cout << \"Difference of a and b: \" << set_difference(a, b) << '\\n';\n\n    std::set<int> sub{5, 9};\n    std::cout << \"Set b \" << (is_subset(a, b) ? \"is\" : \"is not\") << \" a subset of a\\n\";\n    std::cout << \"Set \" << sub << ' ' << (is_subset(a, sub) ? \"is\" : \"is not\") << \" a subset of a\\n\";\n\n    std::set<int> copy = a;\n    std::cout << \"a \" << (a == copy ? \"equals \" : \"does not equal \") << copy << '\\n';\n\n    return 0;\n}\n\n", "explain": "C++ standard library contains a set class, which is a sorted container without duplicates and implemented as a binary tree. Additional set functionality can be implemented in terms of standard library algorithms.\nC++11 standard library also contains unordered_set based on a hash table. However, algorithms like std::set_intersection etc take sorted ranges, so set-specific functions should be hand-rolled.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Java", "code": "\nWorks with: Java version 7+\n\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.Set;\nimport java.util.TreeSet;\n\npublic class Sets {\n    public static void main(String[] args){\n        Set<Integer> a = new TreeSet<>();\n        //TreeSet sorts on natural ordering (or an optional comparator)\n        //other options: HashSet (hashcode)\n        //               LinkedHashSet (insertion order)\n        //               EnumSet (optimized for enum values)\n        //others at: http://download.oracle.com/javase/7/docs/api/java/util/Set.html\n        Set<Integer> b = new TreeSet<>();\n        Set<Integer> c = new TreeSet<>();\n        Set<Integer> d = new TreeSet<>();\n        \n        a.addAll(Arrays.asList(1, 2, 3, 4, 5));\n        b.addAll(Arrays.asList(2, 3, 4, 5, 6, 8));\n        c.addAll(Arrays.asList(2, 3, 4));\n        d.addAll(Arrays.asList(2, 3, 4));\n        System.out.println(\"a: \" + a);\n        System.out.println(\"b: \" + b);\n        System.out.println(\"c: \" + c);\n        System.out.println(\"d: \" + d);\n        \n        System.out.println(\"2 in a: \" + a.contains(2));\n        System.out.println(\"6 in a: \" + a.contains(6));\n        \n        Set<Integer> ab = new TreeSet<>();\n        ab.addAll(a);\n        ab.addAll(b);\n        System.out.println(\"a union b: \" + ab);\n        \n        Set<Integer> a_b = new TreeSet<>();\n        a_b.addAll(a);\n        a_b.removeAll(b);\n        System.out.println(\"a - b: \" + a_b);\n        \n        System.out.println(\"c subset of a: \" + a.containsAll(c));\n        //use a.conatins() for single elements\n        \n        System.out.println(\"c = d: \" + c.equals(d));\n        System.out.println(\"d = c: \" + d.equals(c));\n        \n        Set<Integer> aib = new TreeSet<>();\n        aib.addAll(a);\n        aib.retainAll(b);\n        System.out.println(\"a intersect b: \" + aib);\n        \n        System.out.println(\"add 7 to a: \" + a.add(7));\n        System.out.println(\"add 2 to a again: \" + a.add(2));\n        \n        //other noteworthy things related to sets:\n        Set<Integer> empty = Collections.EMPTY_SET; //immutable empty set\n        //empty.add(2);  would fail\n        empty.isEmpty(); //test if a set is empty\n        empty.size();\n        Collections.disjoint(a, b); //returns true if the sets have no common elems (based on their .equals() methods)\n        Collections.unmodifiableSet(a); //returns an immutable copy of a\n    }\n}\n\n\nOutput:\na: [1, 2, 3, 4, 5]\nb: [2, 3, 4, 5, 6, 8]\nc: [2, 3, 4]\nd: [2, 3, 4]\n2 in a: true\n6 in a: false\na union b: [1, 2, 3, 4, 5, 6, 8]\na - b: [1]\nc subset of a: true\nc = d: true\nd = c: true\na intersect b: [2, 3, 4, 5]\nadd 7 to a: true\nadd 2 to a again: false\n", "explain": "To use this in Java 5 replace all \"<>\" with \"<Integer>\".\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "C#", "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nclass Program\n{\n    static void PrintCollection(IEnumerable<int> x)\n    {\n        Console.WriteLine(string.Join(\" \", x));\n    }\n    static void Main(string[] args)\n    {\n        Console.OutputEncoding = Encoding.UTF8;\n        Console.WriteLine(\"Set creation\");\n        var A = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        var B = new HashSet<int> { 2, 5, 8, 11, 12, 13, 17, 18, 20 };\n\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.WriteLine(\"Test m \u2208 S -- \\\"m is an element in set S\\\"\");\n        Console.WriteLine(\"14 is an element in set A: {0}\", A.Contains(14));\n        Console.WriteLine(\"15 is an element in set A: {0}\", A.Contains(15));\n\n        Console.WriteLine(\"A \u222a B -- union; a set of all elements either in set A or in set B.\");\n        var aUb = A.Union(B);\n        PrintCollection(aUb);\n\n        Console.WriteLine(\"A \u2216 B -- difference; a set of all elements in set A, except those in set B.\");\n        var aDb = A.Except(B);\n        PrintCollection(aDb);\n\n        Console.WriteLine(\"A \u2286 B -- subset; true if every element in set A is also in set B.\");\n        Console.WriteLine(A.IsSubsetOf(B));\n        var C = new HashSet<int> { 14, 17, 18 };\n        Console.WriteLine(C.IsSubsetOf(A));\n\n        Console.WriteLine(\"A = B -- equality; true if every element of set A is in set B and vice versa.\");\n        Console.WriteLine(A.SetEquals(B));\n        var D = new HashSet<int> { 4, 12, 14, 17, 18, 19, 20 };\n        Console.WriteLine(A.SetEquals(D));\n\n        Console.WriteLine(\"If A \u2286 B, but A \u2260 B, then A is called a true or proper subset of B, written A \u2282 B or A \u228a B\");\n        Console.WriteLine(A.IsProperSubsetOf(B));\n        Console.WriteLine(C.IsProperSubsetOf(A));\n\n        Console.WriteLine(\"Modify a mutable set.  (Add 10 to A; remove 12 from B).\");\n        A.Add(10);\n        B.Remove(12);\n        PrintCollection(A);\n        PrintCollection(B);\n\n        Console.ReadKey();\n    }\n}\n\n\nOutput:\nSet creation\n4 12 14 17 18 19 20\n2 5 8 11 12 13 17 18 20\nTest m \u2208 S -- \"m is an element in set S\"\n14 is an element in set A: True\n15 is an element in set A: False\nA \u222a B -- union; a set of all elements either in set A or in set B.\n4 12 14 17 18 19 20 2 5 8 11 13\nA \u2216 B -- difference; a set of all elements in set A, except those in set B.\n4 14 19\nA \u2286 B -- subset; true if every element in set A is also in set B.\nFalse\nTrue\nA = B -- equality; true if every element of set A is in set B and vice versa.\nFalse\nTrue\nIf A \u2286 B, but A \u2260 B, then A is called a true or proper subset of B, written A \u2282 B or A \u228a B\nFalse\nTrue\nModify a mutable set.  (Add 10 to A; remove 12 from B).\n4 12 14 17 18 19 20 10\n2 5 8 11 13 17 18 20\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\n\nvar set = new Set();\n\nset.add(0);\nset.add(1);\nset.add('two');\nset.add('three');\n\nset.has(0); //=> true\nset.has(3); //=> false\nset.has('two'); // true\nset.has(Math.sqrt(4)); //=> false\nset.has('TWO'.toLowerCase()); //=> true\n\nset.size; //=> 4\n\nset.delete('two');\nset.has('two'); //==> false\nset.size; //=> 3\n\n//iterating set using ES6 for..of\n//Set order is preserved in order items are added.\nfor (var item of set) {\n  console.log('item is ' + item);\n}\n\n", "explain": "JavaScript does not support native sets before ECMAScript 6. \n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "SQL", "code": "\nWorks with: Oracle\n-- set of numbers is a table\n-- create one set with 3 elements\n\ncreate table myset1 (element number);\n\ninsert into myset1 values (1);\ninsert into myset1 values (2);\ninsert into myset1 values (3);\n        \ncommit;\n\n-- check if 1 is an element\n\nselect 'TRUE' BOOL from dual\nwhere 1 in \n(select element from myset1);\n\n-- create second set with 3 elements\n\ncreate table myset2 (element number);\n\ninsert into myset2 values (1);\ninsert into myset2 values (5);\ninsert into myset2 values (6);\n        \ncommit;\n\n-- union sets\n\nselect element from myset1\nunion\nselect element from myset2;\n\n-- intersection\n\nselect element from myset1\nintersect\nselect element from myset2;\n\n-- difference\n\nselect element from myset1\nminus\nselect element from myset2;\n\n-- subset\n\n-- change myset2 to only have 1 as element\n\ndelete from myset2 where not element = 1;\n\ncommit;\n\n-- check if myset2 subset of myset1\n\nselect 'TRUE' BOOL from dual\nwhere 0 =  (select count(*) from \n(select element from myset2\nminus\nselect element from myset1));\n\n-- equality\n\n-- change myset1 to only have 1 as element\n\ndelete from myset1 where not element = 1;\n\ncommit;\n\n -- check if myset2 subset of myset1 and\n -- check if myset1 subset of myset2 and\n \nselect 'TRUE' BOOL from dual\nwhere \n0 =  (select count(*) from \n(select element from myset2\nminus\nselect element from myset1)) and\n0 =\n(select count(*) from \n(select element from myset1\nminus\nselect element from myset2));\n\nSQL> \nSQL> -- set of numbers is a table\nSQL> -- create one set with 3 elements\nSQL> \nSQL> create table myset1 (element number);\n\nTable created.\n\nSQL> \nSQL> insert into myset1 values (1);\n\n1 row created.\n\nSQL> insert into myset1 values (2);\n\n1 row created.\n\nSQL> insert into myset1 values (3);\n\n1 row created.\n\nSQL> \nSQL> commit;\n\nCommit complete.\n\nSQL> \nSQL> -- check if 1 is an element\nSQL> \nSQL> select 'TRUE' BOOL from dual\n  2  where 1 in\n  3  (select element from myset1);\n\nBOOL                                                                            \n----                                                                            \nTRUE                                                                            \n\nSQL> \nSQL> -- create second set with 3 elements\nSQL> \nSQL> create table myset2 (element number);\n\nTable created.\n\nSQL> \nSQL> insert into myset2 values (1);\n\n1 row created.\n\nSQL> insert into myset2 values (5);\n\n1 row created.\n\nSQL> insert into myset2 values (6);\n\n1 row created.\n\nSQL> \nSQL> commit;\n\nCommit complete.\n\nSQL> \nSQL> -- union sets\nSQL> \nSQL> select element from myset1\n  2  union\n  3  select element from myset2;\n\n   ELEMENT                                                                      \n----------                                                                      \n         1                                                                      \n         2                                                                      \n         3                                                                      \n         5                                                                      \n         6                                                                      \n\nSQL> \nSQL> -- intersection\nSQL> \nSQL> select element from myset1\n  2  intersect\n  3  select element from myset2;\n\n   ELEMENT                                                                      \n----------                                                                      \n         1                                                                      \n\nSQL> \nSQL> -- difference\nSQL> \nSQL> select element from myset1\n  2  minus\n  3  select element from myset2;\n\n   ELEMENT                                                                      \n----------                                                                      \n         2                                                                      \n         3                                                                      \n\nSQL> \nSQL> -- subset\nSQL> \nSQL> -- change myset2 to only have 1 as element\nSQL> \nSQL> delete from myset2 where not element = 1;\n\n2 rows deleted.\n\nSQL> \nSQL> commit;\n\nCommit complete.\n\nSQL> \nSQL> -- check if myset2 subset of myset1\nSQL> \nSQL> select 'TRUE' BOOL from dual\n  2  where 0 =  (select count(*) from\n  3  (select element from myset2\n  4  minus\n  5  select element from myset1));\n\nBOOL                                                                            \n----                                                                            \nTRUE                                                                            \n\nSQL> \nSQL> -- equality\nSQL> \nSQL> -- change myset1 to only have 1 as element\nSQL> \nSQL> delete from myset1 where not element = 1;\n\n2 rows deleted.\n\nSQL> \nSQL> commit;\n\nCommit complete.\n\nSQL> \nSQL>  -- check if myset2 subset of myset1 and\nSQL>  -- check if myset1 subset of myset2 and\nSQL> \nSQL> select 'TRUE' BOOL from dual\n  2  where\n  3  0 =  (select count(*) from\n  4  (select element from myset2\n  5  minus\n  6  select element from myset1)) and\n  7  0 =\n  8  (select count(*) from\n  9  (select element from myset1\n 10  minus\n 11  select element from myset2));\n\nBOOL                                                                            \n----                                                                            \nTRUE            \n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Go", "code": "\n\nMaps[edit]\n\npackage main\n\nimport \"fmt\"\n\n// Define set as a type to hold a set of complex numbers.  A type\n// could be defined similarly to hold other types of elements.  A common\n// variation is to make a map of interface{} to represent a set of\n// mixed types.  Also here the map value is a bool.  By always storing\n// true, the code is nicely readable.  A variation to use less memory\n// is to make the map value an empty struct.  The relative advantages\n// can be debated.\ntype set map[complex128]bool\n\nfunc main() {\n    // task: set creation\n    s0 := make(set)             // create empty set\n    s1 := set{3: true}          // create set with one element\n    s2 := set{3: true, 1: true} // create set with two elements\n\n    // option: another way to create a set\n    s3 := newSet(3, 1, 4, 1, 5, 9)\n\n    // option: output!\n    fmt.Println(\"s0:\", s0)\n    fmt.Println(\"s1:\", s1)\n    fmt.Println(\"s2:\", s2)\n    fmt.Println(\"s3:\", s3)\n\n    // task: element predicate\n    fmt.Printf(\"%v \u2208 s0: %t\\n\", 3, s0.hasElement(3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 3, s3.hasElement(3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 2, s3.hasElement(2))\n\n    // task: union\n    b := set{4: true, 2: true}\n    fmt.Printf(\"s3 \u222a %v: %v\\n\", b, union(s3, b))\n\n    // task: intersection\n    fmt.Printf(\"s3 \u2229 %v: %v\\n\", b, intersection(s3, b))\n\n    // task: difference\n    fmt.Printf(\"s3 \\\\ %v: %v\\n\", b, difference(s3, b))\n\n    // task: subset predicate\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", b, subset(b, s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", s2, subset(s2, s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", s0, subset(s0, s3))\n\n    // task: equality\n    s2Same := set{1: true, 3: true}\n    fmt.Printf(\"%v = s2: %t\\n\", s2Same, equal(s2Same, s2))\n\n    // option: proper subset\n    fmt.Printf(\"%v \u2282 s2: %t\\n\", s2Same, properSubset(s2Same, s2))\n    fmt.Printf(\"%v \u2282 s3: %t\\n\", s2Same, properSubset(s2Same, s3))\n\n    // option: delete.  it's built in.\n    delete(s3, 3)\n    fmt.Println(\"s3, 3 deleted:\", s3)\n}\n\nfunc newSet(ms ...complex128) set {\n    s := make(set)\n    for _, m := range ms {\n        s[m] = true\n    }\n    return s\n}\n\nfunc (s set) String() string {\n    if len(s) == 0 {\n        return \"\u2205\"\n    }\n    r := \"{\"\n    for e := range s {\n        r = fmt.Sprintf(\"%s%v, \", r, e)\n    }\n    return r[:len(r)-2] + \"}\"\n}\n\nfunc (s set) hasElement(m complex128) bool {\n    return s[m]\n}\n\nfunc union(a, b set) set {\n    s := make(set)\n    for e := range a {\n        s[e] = true\n    }\n    for e := range b {\n        s[e] = true\n    }\n    return s\n}\n\nfunc intersection(a, b set) set {\n    s := make(set)\n    for e := range a {\n        if b[e] {\n            s[e] = true\n        }\n    }\n    return s\n}\n\nfunc difference(a, b set) set {\n    s := make(set)\n    for e := range a {\n        if !b[e] {\n            s[e] = true\n        }\n    }\n    return s\n}\n\nfunc subset(a, b set) bool {\n    for e := range a {\n        if !b[e] {\n            return false\n        }\n    }\n    return true\n}\n\nfunc equal(a, b set) bool {\n    return len(a) == len(b) && subset(a, b)\n}\n\nfunc properSubset(a, b set) bool {\n    return len(a) < len(b) && subset(a, b)\n}\n\n\nOutput:\ns0: \u2205\ns1: {(3+0i)}\ns2: {(3+0i), (1+0i)}\ns3: {(3+0i), (1+0i), (4+0i), (5+0i), (9+0i)}\n3 \u2208 s0: false\n3 \u2208 s3: true\n2 \u2208 s3: false\ns3 \u222a {(4+0i), (2+0i)}: {(5+0i), (9+0i), (2+0i), (3+0i), (1+0i), (4+0i)}\ns3 \u2229 {(2+0i), (4+0i)}: {(4+0i)}\ns3 \\ {(4+0i), (2+0i)}: {(5+0i), (9+0i), (3+0i), (1+0i)}\n{(2+0i), (4+0i)} \u2286 s3: false\n{(3+0i), (1+0i)} \u2286 s3: true\n\u2205 \u2286 s3: true\n{(1+0i), (3+0i)} = s2: true\n{(1+0i), (3+0i)} \u2282 s2: false\n{(1+0i), (3+0i)} \u2282 s3: true\ns3, 3 deleted: {(5+0i), (9+0i), (1+0i), (4+0i)}\n\nBig.Int[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc main() {\n    // create an empty set\n    var s0 big.Int\n\n    // create sets with elements\n    s1 := newSet(3)\n    s2 := newSet(3, 1)\n    s3 := newSet(3, 1, 4, 1, 5, 9)\n\n    // output\n    fmt.Println(\"s0:\", format(s0))\n    fmt.Println(\"s1:\", format(s1))\n    fmt.Println(\"s2:\", format(s2))\n    fmt.Println(\"s3:\", format(s3))\n\n    // element predicate\n    fmt.Printf(\"%v \u2208 s0: %t\\n\", 3, hasElement(s0, 3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 3, hasElement(s3, 3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 2, hasElement(s3, 2))\n\n    // union\n    b := newSet(4, 2)\n    fmt.Printf(\"s3 \u222a %v: %v\\n\", format(b), format(union(s3, b)))\n\n    // intersection\n    fmt.Printf(\"s3 \u2229 %v: %v\\n\", format(b), format(intersection(s3, b)))\n\n    // difference\n    fmt.Printf(\"s3 \\\\ %v: %v\\n\", format(b), format(difference(s3, b)))\n\n    // subset predicate\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", format(b), subset(b, s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", format(s2), subset(s2, s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", format(s0), subset(s0, s3))\n\n    // equality\n    s2Same := newSet(1, 3)\n    fmt.Printf(\"%v = s2: %t\\n\", format(s2Same), equal(s2Same, s2))\n\n    // proper subset\n    fmt.Printf(\"%v \u2282 s2: %t\\n\", format(s2Same), properSubset(s2Same, s2))\n    fmt.Printf(\"%v \u2282 s3: %t\\n\", format(s2Same), properSubset(s2Same, s3))\n\n    // delete\n    remove(&s3, 3)\n    fmt.Println(\"s3, 3 removed:\", format(s3))\n}\n\nfunc newSet(ms ...int) (set big.Int) {\n    for _, m := range ms {\n        set.SetBit(&set, m, 1)\n    }\n    return\n}\n\nfunc remove(set *big.Int, m int) {\n    set.SetBit(set, m, 0)\n}\n\nfunc format(set big.Int) string {\n    if len(set.Bits()) == 0 {\n        return \"\u2205\"\n    }\n    r := \"{\"\n    for e, l := 0, set.BitLen(); e < l; e++ {\n        if set.Bit(e) == 1 {\n            r = fmt.Sprintf(\"%s%v, \", r, e)\n        }\n    }\n    return r[:len(r)-2] + \"}\"\n}\n\nfunc hasElement(set big.Int, m int) bool {\n    return set.Bit(m) == 1\n}\n\nfunc union(a, b big.Int) (set big.Int) {\n    set.Or(&a, &b)\n    return\n}\n\nfunc intersection(a, b big.Int) (set big.Int) {\n    set.And(&a, &b)\n    return\n}\n\nfunc difference(a, b big.Int) (set big.Int) {\n    set.AndNot(&a, &b)\n    return\n}\n\nfunc subset(a, b big.Int) bool {\n    ab := a.Bits()\n    bb := b.Bits()\n    if len(ab) > len(bb) {\n        return false\n    }\n    for i, aw := range ab {\n        if aw&^bb[i] != 0 {\n            return false\n        }\n    }\n    return true\n}\n\nfunc equal(a, b big.Int) bool {\n    return a.Cmp(&b) == 0\n}\n\nfunc properSubset(a, b big.Int) (p bool) {\n    ab := a.Bits()\n    bb := b.Bits()\n    if len(ab) > len(bb) {\n        return false\n    }\n    for i, aw := range ab {\n        bw := bb[i]\n        if aw&^bw != 0 {\n            return false\n        }\n        if aw != bw {\n            p = true\n        }\n    }\n    return\n}\n\n\nOutput:\ns0: \u2205\ns1: {3}\ns2: {1, 3}\ns3: {1, 3, 4, 5, 9}\n3 \u2208 s0: false\n3 \u2208 s3: true\n2 \u2208 s3: false\ns3 \u222a {2, 4}: {1, 2, 3, 4, 5, 9}\ns3 \u2229 {2, 4}: {4}\ns3 \\ {2, 4}: {1, 3, 5, 9}\n{2, 4} \u2286 s3: false\n{1, 3} \u2286 s3: true\n\u2205 \u2286 s3: true\n{1, 3} = s2: true\n{1, 3} \u2282 s2: false\n{1, 3} \u2282 s3: true\ns3, 3 removed: {1, 4, 5, 9}\n\nIntsets[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n\n    \"golang.org/x/tools/container/intsets\"\n)\n\nfunc main() {\n    var s0, s1 intsets.Sparse // create some empty sets\n    s1.Insert(3)              // insert an element\n    s2 := newSet(3, 1)        // create sets with elements\n    s3 := newSet(3, 1, 4, 1, 5, 9)\n\n    // output\n    fmt.Println(\"s0:\", &s0)\n    fmt.Println(\"s1:\", &s1)\n    fmt.Println(\"s2:\", s2)\n    fmt.Println(\"s3:\", s3)\n\n    // element predicate\n    fmt.Printf(\"%v \u2208 s0: %t\\n\", 3, s0.Has(3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 3, s3.Has(3))\n    fmt.Printf(\"%v \u2208 s3: %t\\n\", 2, s3.Has(2))\n\n    // union\n    b := newSet(4, 2)\n    var s intsets.Sparse\n    s.Union(s3, b)\n    fmt.Printf(\"s3 \u222a %v: %v\\n\", b, &s)\n\n    // intersection\n    s.Intersection(s3, b)\n    fmt.Printf(\"s3 \u2229 %v: %v\\n\", b, &s)\n\n    // difference\n    s.Difference(s3, b)\n    fmt.Printf(\"s3 \\\\ %v: %v\\n\", b, &s)\n\n    // subset predicate\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", b, b.SubsetOf(s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", s2, s2.SubsetOf(s3))\n    fmt.Printf(\"%v \u2286 s3: %t\\n\", &s0, s0.SubsetOf(s3))\n\n    // equality\n    s2Same := newSet(1, 3)\n    fmt.Printf(\"%v = s2: %t\\n\", s2Same, s2Same.Equals(s2))\n\n    // delete\n    s3.Remove(3)\n    fmt.Println(\"s3, 3 removed:\", s3)\n}\n\nfunc newSet(ms ...int) *intsets.Sparse {\n    var set intsets.Sparse\n    for _, m := range ms {\n        set.Insert(m)\n    }\n    return &set\n}\n\n\nOutput:\ns0: {}\ns1: {3}\ns2: {1 3}\ns3: {1 3 4 5 9}\n3 \u2208 s0: false\n3 \u2208 s3: true\n2 \u2208 s3: false\ns3 \u222a {2 4}: {1 2 3 4 5 9}\ns3 \u2229 {2 4}: {4}\ns3 \\ {2 4}: {1 3 5 9}\n{2 4} \u2286 s3: false\n{1 3} \u2286 s3: true\n{} \u2286 s3: true\n{1 3} = s2: true\ns3, 3 removed: {1 4 5 9}\n\n", "explain": "A common complaint is that Go has no native set type and so there are a number of third-party libraries offering to fill this perceived gap.  Yet Go has good native support for most applications for sets.\nGo maps meet the task description in that they do not require orderable elements.  To demonstrate that, a set of complex numbers is shown here.  Complex numbers can be compared for equality but are not ordered.\nIf elements of your set are integers or can be indexed by integers, are zero based and relatively \"dense\", then the big.Int type in the standard library can serve efficiently as a set.  The solution here doesn't even bother to define a set type, it just defines functions that use big.Ints directly as sets.\nNote that the elements here, being integers, are of course ordered and so might not meet a strict reading of the task requirements.\nNot quite in the stanard library but still in the official \"sub repository\", intsets are a sparse bit set.  Like big.Int they use a single bit to represent a possible element, but the sparse representation efficiently allows for large \"holes\" in the element sequence.  Also the intsets API provides a more set-like terminology so the RC task can be coded more directly.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  Boost.Generics.Collection\n\nprogram Set_task;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  Boost.Generics.Collection;\n\nbegin\n  var s1 := TSet<Integer>.Create([1, 2, 3, 4, 5, 6]);\n  var s2 := TSet<Integer>.Create([2, 5, 6, 3, 4, 8]);\n  var s3 := TSet<Integer>.Create([1, 2, 5]);\n\n  Writeln('S1 ', s1.ToString);\n  Writeln('S2 ', s2.ToString);\n  Writeln('S3 ', s3.ToString, #10);\n\n  Writeln('4 is in S1? ', s1.Has(4));\n  Writeln('S1 union S2 ', (s1 + S2).ToString);\n  Writeln('S1 intersection S2 ', (s1 * S2).ToString);\n  Writeln('S1 difference S2 ', (s1 - S2).ToString);\n  Writeln('S3 is subset S2 ', s1.IsSubSet(s3));\n  Writeln('S1 equality S2? ', s1 = s2);\n  readln;\nend.\n\n\nOutput:\nS1 { 1, 2, 3, 4, 5, 6 }\nS2 { 2, 3, 4, 5, 6, 8 }\nS3 { 1, 2, 5 }\n\n4 is in S1? TRUE\nS1 union S2 { 1, 2, 3, 4, 5, 6, 8 }\nS1 intersection S2 { 2, 3, 4, 5, 6 }\nS1 difference S2 { 1 }\nS3 is subset S2 TRUE\nS1 equality S2? FALSE\n", "explain": "The library Boost.Generics.Collection.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Ruby", "code": "\n\n>> require 'set'\n=> true\n>> s1, s2 = Set[1, 2, 3, 4], [3, 4, 5, 6].to_set # different ways of creating a set\n=> [#<Set: {1, 2, 3, 4}>, #<Set: {5, 6, 3, 4}>]\n>> s1 | s2 # Union\n=> #<Set: {5, 6, 1, 2, 3, 4}>\n>> s1 & s2 # Intersection\n=> #<Set: {3, 4}>\n>> s1 - s2 # Difference\n=> #<Set: {1, 2}>\n>> s1.proper_subset?(s1) # Proper subset\n=> false\n>> Set[3, 1].proper_subset?(s1) # Proper subset\n=> true\n>> s1.subset?(s1) # Subset\n=> true\n>> Set[3, 1].subset?(s1) # Subset\n=> true\n>> Set[3, 2, 4, 1] == s1 # Equality\n=> true\n>> s1 == s2 # Equality\n=> false\n>> s1.include?(2) # Membership\n=> true\n>> Set[1, 2, 3, 4, 5].proper_superset?(s1) # Proper superset\n=> true\n>> Set[1, 2, 3, 4].proper_superset?(s1) # Proper superset\n=> false\n>> Set[1, 2, 3, 4].superset?(s1) # Superset\n=> true\n>> s1 ^ s2 # Symmetric difference\n=> #<Set: {5, 6, 1, 2}>\n>> s1.size # Cardinality\n=> 4\n>> s1 << 99 # Mutability (or s1.add(99) )\n=> #<Set: {99, 1, 2, 3, 4}>\n>> s1.delete(99) # Mutability\n=> #<Set: {1, 2, 3, 4}>\n>> s1.merge(s2) # Mutability\n=> #<Set: {5, 6, 1, 2, 3, 4}>\n>> s1.subtract(s2) # Mutability\n=> #<Set: {1, 2}>\n>>\n\n", "explain": "Ruby's standard library contains a \"set\" package, which provides Set and SortedSet classes.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Rust", "code": "\nuse std::collections::HashSet;\n\nfn main() {\n  let a = vec![1, 3, 4].into_iter().collect::<HashSet<i32>>();\n  let b = vec![3, 5, 6].into_iter().collect::<HashSet<i32>>();\n\n  println!(\"Set A: {:?}\", a.iter().collect::<Vec<_>>());\n  println!(\"Set B: {:?}\", b.iter().collect::<Vec<_>>());\n  println!(\"Does A contain 4? {}\", a.contains(&4));\n  println!(\"Union: {:?}\", a.union(&b).collect::<Vec<_>>());\n  println!(\"Intersection: {:?}\", a.intersection(&b).collect::<Vec<_>>());\n  println!(\"Difference: {:?}\", a.difference(&b).collect::<Vec<_>>());\n  println!(\"Is A a subset of B? {}\", a.is_subset(&b));\n  println!(\"Is A equal to B? {}\", a == b);\n}\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Swift", "code": "\nWorks with: Swift version 1.2+\nvar s1 : Set<Int> = [1, 2, 3, 4]\nlet s2 : Set<Int> = [3, 4, 5, 6]\nprintln(s1.union(s2)) // union; prints \"[5, 6, 2, 3, 1, 4]\"\nprintln(s1.intersect(s2)) // intersection; prints \"[3, 4]\"\nprintln(s1.subtract(s2)) // difference; prints \"[2, 1]\"\nprintln(s1.isSubsetOf(s1)) // subset; prints \"true\"\nprintln(Set<Int>([3, 1]).isSubsetOf(s1)) // subset; prints \"true\"\nprintln(s1.isStrictSubsetOf(s1)) // proper subset; prints \"false\"\nprintln(Set<Int>([3, 1]).isStrictSubsetOf(s1)) // proper subset; prints \"true\"\nprintln(Set<Int>([3, 2, 4, 1]) == s1) // equality; prints \"true\"\nprintln(s1 == s2) // equality; prints \"false\"\nprintln(s1.contains(2)) // membership; prints \"true\"\nprintln(Set<Int>([1, 2, 3, 4]).isSupersetOf(s1)) // superset; prints \"true\"\nprintln(Set<Int>([1, 2, 3, 4]).isStrictSupersetOf(s1)) // proper superset; prints \"false\"\nprintln(Set<Int>([1, 2, 3, 4, 5]).isStrictSupersetOf(s1)) // proper superset; prints \"true\"\nprintln(s1.exclusiveOr(s2)) // symmetric difference; prints \"[5, 6, 2, 1]\"\nprintln(s1.count) // cardinality; prints \"4\"\ns1.insert(99) // mutability\nprintln(s1) // prints \"[99, 2, 3, 1, 4]\"\ns1.remove(99) // mutability\nprintln(s1) // prints \"[2, 3, 1, 4]\"\ns1.unionInPlace(s2) // mutability\nprintln(s1) // prints \"[5, 6, 2, 3, 1, 4]\"\ns1.subtractInPlace(s2) // mutability\nprintln(s1) // prints \"[2, 1]\"\ns1.exclusiveOrInPlace(s2) // mutability\nprintln(s1) // prints \"[5, 6, 2, 3, 1, 4]\"\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Ada", "code": "\n\nwith ada.containers.ordered_sets, ada.text_io;\nuse ada.text_io;\n\nprocedure set_demo is\n\tpackage cs is new ada.containers.ordered_sets (character); use cs;\n\n\tfunction \"+\" (s : string) return set is\n\t(if s = \"\" then empty_set else Union(+ s(s'first..s'last - 1), To_Set (s(s'last))));\n\n\tfunction \"-\" (s : Set) return string is\n\t(if s = empty_set then \"\" else - (s - To_Set (s.last_element)) & s.last_element);\n\ts1, s2 : set;\nbegin\n\tloop\n\t\tput (\"s1= \");\n\t\ts1 := + get_line;\t\t\n\t\texit when s1 = +\"Quit!\";\n\t\tput (\"s2= \");\n\t\ts2 := + get_line;\n\t\tPut_Line(\"Sets [\" & (-s1) & \"], [\" & (-s2) & \"] of size\"\n                & S1.Length'img & \" and\" & s2.Length'img & \".\");\n  \t\tPut_Line(\"Intersection:   [\" & (-(Intersection(S1, S2))) & \"],\");\n  \t\tPut_Line(\"Union:          [\" & (-(Union(s1, s2)))        & \"],\");\n  \t\tPut_Line(\"Difference:     [\" & (-(Difference(s1, s2)))   & \"],\");\n  \t\tPut_Line(\"Symmetric Diff: [\" & (-(s1 xor s2)) & \"],\");\n  \t\tPut_Line(\"Subset: \"  & Boolean'Image(s1.Is_Subset(s2))\n              & \", Equal: \" & Boolean'Image(s1 = s2) & \".\");\n\tend loop;\nend set_demo;\n\n\nOutput:\nset\ndemo\nSets [est], [demo] of size 3 and 4.\nIntersection:   [e],\nUnion:          [demost],\nDifference:     [st],\nSymmetric Diff: [dmost],\nSubset: FALSE, Equal: FALSE.\nquit!\n\n", "explain": "This solution uses the generic Ordered_Sets package from the Ada.Containers standard library, which internally is based on red-black trees. \nAn alternative hash-based solution could use the Hashed_Maps package from Ada.Containers. \n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Julia", "code": "\njulia> S1 = Set(1:4)\u00a0; S2 = Set(3:6)\u00a0; println(S1,\"\\n\",S2)\nSet{Int64}({4,2,3,1})\nSet{Int64}({5,4,6,3})\n\njulia> 5 in S1 , 5 in S2\n(false,true)\n\njulia> intersect(S1,S2)\nSet{Int64}({4,3})\n\njulia> union(S1,S2)\nSet{Int64}({5,4,6,2,3,1})\n\njulia> setdiff(S1,S2)\nSet{Int64}({2,1})\n\njulia> issubset(S1,S2)\nfalse\n\njulia> isequal(S1,S2)\nfalse\n\njulia> symdiff(S1,S2)\nSet{Int64}({5,6,2,1})\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n   val fruits  = setOf(\"apple\", \"pear\", \"orange\", \"banana\")\n   println(\"fruits \u00a0: $fruits\")\n   val fruits2 = setOf(\"melon\", \"orange\", \"lemon\", \"gooseberry\")\n   println(\"fruits2\u00a0: $fruits2\\n\")\n\n   println(\"fruits  contains 'banana'    \u00a0: ${\"banana\" in fruits}\")\n   println(\"fruits2 contains 'elderberry'\u00a0: ${\"elderbury\" in fruits2}\\n\")\n\n   println(\"Union       \u00a0: ${fruits.union(fruits2)}\")\n   println(\"Intersection\u00a0: ${fruits.intersect(fruits2)}\")\n   println(\"Difference  \u00a0: ${fruits.minus(fruits2)}\\n\")\n\n   println(\"fruits2 is a subset of fruits\u00a0: ${fruits.containsAll(fruits2)}\\n\")\n   val fruits3 = fruits\n   println(\"fruits3\u00a0: $fruits3\\n\")\n   var areEqual = fruits.containsAll(fruits2) && fruits3.containsAll(fruits)\n   println(\"fruits2 and fruits are equal \u00a0: $areEqual\")\n   areEqual = fruits.containsAll(fruits3) && fruits3.containsAll(fruits)\n   println(\"fruits3 and fruits are equal \u00a0: $areEqual\\n\")\n\n   val fruits4 = setOf(\"apple\", \"orange\")\n   println(\"fruits4\u00a0: $fruits4\\n\")\n   var isProperSubset = fruits.containsAll(fruits3) && !fruits3.containsAll(fruits)\n   println(\"fruits3 is a proper subset of fruits\u00a0: $isProperSubset\")\n   isProperSubset = fruits.containsAll(fruits4) && !fruits4.containsAll(fruits)\n   println(\"fruits4 is a proper subset of fruits\u00a0: $isProperSubset\\n\")\n\n   val fruits5 = mutableSetOf(\"cherry\", \"blueberry\", \"raspberry\")\n   println(\"fruits5\u00a0: $fruits5\\n\")\n   fruits5 += \"guava\"\n   println(\"fruits5 + 'guava' \u00a0: $fruits5\")\n   println(\"fruits5 - 'cherry'\u00a0: ${fruits5 - \"cherry\"}\")\n}\n\n\nOutput:\nfruits \u00a0: [apple, pear, orange, banana]\nfruits2\u00a0: [melon, orange, lemon, gooseberry]\n\nfruits  contains 'banana'    \u00a0: true\nfruits2 contains 'elderberry'\u00a0: false\n\nUnion       \u00a0: [apple, pear, orange, banana, melon, lemon, gooseberry]\nIntersection\u00a0: [orange]\nDifference  \u00a0: [apple, pear, banana]\n\nfruits2 is a subset of fruits\u00a0: false\n\nfruits3\u00a0: [apple, pear, orange, banana]\n\nfruits2 and fruits are equal \u00a0: false\nfruits3 and fruits are equal \u00a0: true\n\nfruits4\u00a0: [apple, orange]\n\nfruits3 is a proper subset of fruits\u00a0: false\nfruits4 is a proper subset of fruits\u00a0: true\n\nfruits5\u00a0: [cherry, blueberry, raspberry]\n\nfruits5 + 'guava' \u00a0: [cherry, blueberry, raspberry, guava]\nfruits5 - 'cherry'\u00a0: [blueberry, raspberry, guava]\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Perl", "code": "\n\nuse strict;\n\npackage Set; # likely will conflict with stuff on CPAN\nuse overload\n\t'\"\"'\t=> \\&str,\n\t'bool'\t=> \\&count,\n\t'+='\t=> \\&add,\n\t'-='\t=> \\&del,\n\t'-'\t=> \\&diff,\n\t'=='\t=> \\&eq,\n\t'&'\t=> \\&intersection,\n\t'|'\t=> \\&union,\n\t'^'\t=> \\&xdiff;\n\nsub str {\n\tmy $set = shift;\n\t# This has drawbacks: stringification is used as set key\n\t# if the set is added to another set as an element, which\n\t# may cause inconsistencies if the element set is modified\n\t# later.  In general, a hash key loses its object identity\n\t# anyway, so it's not unique to us.\n\t\"Set{ \".  join(\", \" => sort map(\"$_\", values %$set)) . \" }\"\n}\n\nsub new {\n\tmy $pkg = shift;\n\tmy $h = bless {};\n\t$h->add($_) for @_;\n\t$h\n}\n\nsub add {\n\tmy ($set, $elem) = @_;\n\t$set->{$elem} = $elem;\n\t$set\n}\n\nsub del {\n\tmy ($set, $elem) = @_;\n\tdelete $set->{$elem};\n\t$set\n}\n\nsub has { # set has element\n\tmy ($set, $elem) = @_;\n\texists $set->{$elem}\n}\n\nsub union {\n\tmy ($this, $that) = @_;\n\tbless { %$this, %$that }\n}\n\nsub intersection {\n\tmy ($this, $that) = @_;\n\tmy $s = new Set;\n\tfor (keys %$this) {\n\t\t$s->{$_} = $this->{$_} if exists $that->{$_}\n\t}\n\t$s\n}\n\nsub diff {\n\tmy ($this, $that) = @_;\n\tmy $s = Set->new;\n\tfor (keys %$this) {\n\t\t$s += $this->{$_} unless exists $that->{$_}\n\t}\n\t$s\n}\n\nsub xdiff { # xor, symmetric diff\n\tmy ($this, $that) = @_;\n\tmy $s = new Set;\n\tbless { %{ ($this - $that) | ($that - $this) } }\n}\n\nsub count { scalar(keys %{+shift}) }\n\nsub eq {\n\tmy ($this, $that) = @_;\n\t!($this - $that) && !($that - $this);\n}\n\nsub contains { # this is a superset of that\n\tmy ($this, $that) = @_;\n\tfor (keys %$that) {\n\t\treturn 0 unless $this->has($_)\n\t}\n\treturn 1\n}\n\npackage main;\nmy ($x, $y, $z, $w);\n\n$x = Set->new(1, 2, 3);\n$x += $_ for (5 .. 7);\n$y = Set->new(1, 2, 4, $x); # not the brightest idea\n\nprint \"set x is: $x\\nset y is: $y\\n\";\nfor (1 .. 4, $x) {\n\tprint \"$_ is\", $y->has($_) ? \"\" : \" not\", \" in y\\n\";\n}\n\nprint \"union: \", $x | $y, \"\\n\";\nprint \"intersect: \", $x & $y, \"\\n\";\nprint \"z = x - y = \", $z = $x - $y, \"\\n\";\nprint \"y is \", $x->contains($y) ? \"\" : \"not \", \"a subset of x\\n\";\nprint \"z is \", $x->contains($z) ? \"\" : \"not \", \"a subset of x\\n\";\nprint \"z = (x | y) - (x & y) = \", $z = ($x | $y) - ($x & $y), \"\\n\";\nprint \"w = x ^ y = \", $w = ($x ^ $y), \"\\n\";\nprint \"w is \", ($w == $z) ? \"\" : \"not \", \"equal to z\\n\";\nprint \"w is \", ($w == $x) ? \"\" : \"not \", \"equal to x\\n\";\n\n", "explain": "For real code, try Set::Object from CPAN. Here we provide a primitive implementation using hashes.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\nint main (int argc, const char *argv[]) {\n  @autoreleasepool {\n  \n    NSSet *s1 = [NSSet setWithObjects:@\"a\", @\"b\", @\"c\", @\"d\", @\"e\", nil];\n    NSSet *s2 = [NSSet setWithObjects:@\"b\", @\"c\", @\"d\", @\"e\", @\"f\", @\"h\", nil];\n    NSSet *s3 = [NSSet setWithObjects:@\"b\", @\"c\", @\"d\", nil];\n    NSSet *s4 = [NSSet setWithObjects:@\"b\", @\"c\", @\"d\", nil];\n    NSLog(@\"s1:\u00a0%@\", s1);\n    NSLog(@\"s2:\u00a0%@\", s2);\n    NSLog(@\"s3:\u00a0%@\", s3);\n    NSLog(@\"s4:\u00a0%@\", s4);\n  \n    // Membership\n    NSLog(@\"b in s1: %d\", [s1 containsObject:@\"b\"]);\n    NSLog(@\"f in s1: %d\", [s1 containsObject:@\"f\"]);\n  \n    // Union\n    NSMutableSet *s12 = [NSMutableSet setWithSet:s1];\n    [s12 unionSet:s2];\n    NSLog(@\"s1 union s2:\u00a0%@\", s12);\n  \n    // Intersection\n    NSMutableSet *s1i2 = [NSMutableSet setWithSet:s1];\n    [s1i2 intersectSet:s2];\n    NSLog(@\"s1 intersect s2:\u00a0%@\", s1i2);\n  \n    // Difference\n    NSMutableSet *s1_2 = [NSMutableSet setWithSet:s1];\n    [s1_2 minusSet:s2];\n    NSLog(@\"s1 - s2:\u00a0%@\", s1_2);\n  \n    // Subset of\n    NSLog(@\"s3 subset of s1: %d\", [s3 isSubsetOfSet:s1]);\n  \n    // Equality\n    NSLog(@\"s3 = s4: %d\", [s3 isEqualToSet:s4]);\n  \n    // Cardinality\n    NSLog(@\"size of s1: %lu\", [s1 count]);\n  \n    // Has intersection (not disjoint)\n    NSLog(@\"does s1 intersect s2? %d\", [s1 intersectsSet:s2]);\n  \n    // Adding and removing elements from a mutable set\n    NSMutableSet *mut_s1 = [NSMutableSet setWithSet:s1];\n    [mut_s1 addObject:@\"g\"];\n    NSLog(@\"mut_s1 after adding g:\u00a0%@\", mut_s1);\n    [mut_s1 addObject:@\"b\"];\n    NSLog(@\"mut_s1 after adding b again:\u00a0%@\", mut_s1);\n    [mut_s1 removeObject:@\"c\"];\n    NSLog(@\"mut_s1 after removing c:\u00a0%@\", mut_s1);\n  \n  }\n  return 0;\n}\n\n\nOutput:\ns1: {(\n    d,\n    b,\n    e,\n    c,\n    a\n)}\ns2: {(\n    d,\n    b,\n    e,\n    c,\n    h,\n    f\n)}\ns3: {(\n    b,\n    c,\n    d\n)}\ns4: {(\n    b,\n    c,\n    d\n)}\nb in s1: 1\nf in s1: 0\ns1 union s2: {(\n    c,\n    h,\n    d,\n    e,\n    a,\n    f,\n    b\n)}\ns1 intersect s2: {(\n    d,\n    b,\n    e,\n    c\n)}\ns1 - s2: {(\n    a\n)}\ns3 subset of s1: 1\ns3 = s4: 1\nsize of s1: 5\ndoes s1 intersect s2? 1\nmut_s1 after adding g: {(\n    d,\n    b,\n    g,\n    e,\n    c,\n    a\n)}\nmut_s1 after adding b again: {(\n    d,\n    b,\n    g,\n    e,\n    c,\n    a\n)}\nmut_s1 after removing c: {(\n    d,\n    b,\n    g,\n    e,\n    a\n)}\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Prolog", "code": "\n\n:- use_module(library(lists)).\n\nset :-\n\tA = [2, 4, 1, 3],\n\tB = [5, 2, 3, 2],\n\t(   is_set(A) -> format('~w is a set~n', [A])\n\t;   format('~w is not a set~n', [A])),\n\t(   is_set(B) -> format('~w is a set~n', [B])\n\t;   format('~w is not a set~n', [B])),\n\n\t% create a set from a list\n\n\tlist_to_set(B, BS),\n\t(   is_set(BS) -> format('~nCreate a set from a list~n~w is a set~n', [BS])\n\t;   format('~w is not a set~n', [BS])),\n\n\tintersection(A, BS, I),\n\tformat('~n~w intersection ~w => ~w~n', [A, BS, I]),\n\tunion(A, BS, U),\n\tformat('~w union ~w => ~w~n', [A, BS, U]),\n\tdifference(A, BS, D),\n\tformat('~w difference ~w => ~w~n', [A, BS, D]),\n\n\tX = [1,2],\n\t(   subset(X, A) -> format('~n~w is a subset of ~w~n', [X, A])\n\t;   format('~w is not a subset of ~w~n', [X, A])),\n\tY = [1,5],\n\t(   subset(Y, A) -> format('~w is a subset of ~w~n', [Y, A])\n\t;   format('~w is not a subset of ~w~n', [Y, A])),\n\tZ = [1, 2, 3, 4],\n\t(  equal(Z, A) -> format('~n~w is equal to ~w~n', [Z, A])\n\t;   format('~w is not equal to ~w~n', [Z, A])),\n\tT = [1, 2, 3],\n\t(  equal(T, A) -> format('~w is equal to ~w~n', [T, A])\n\t;   format('~w is not equal to ~w~n', [T, A])).\n\n\n\n% compute difference of sets\ndifference(A, B, D) :-\n\texclude(member_(B), A, D).\n\nmember_(L, X) :-\n\tmember(X, L).\n\nequal([], []).\nequal([H1 | T1], B) :-\n\tselect(H1, B, B1),\n\tequal(T1, B1).\n\n\nOutput:\n\u00a0?- set.\n[2,4,1,3] is a set\n[5,2,3,2] is not a set\n\nCreate a set from a list\n[5,2,3] is a set\n\n[2,4,1,3] intersection [5,2,3] => [2,3]\n[2,4,1,3] union [5,2,3] => [4,1,5,2,3]\n[2,4,1,3] difference [5,2,3] => [4,1]\n\n[1,2] is a subset of [2,4,1,3]\n[1,5] is not a subset of [2,4,1,3]\n\n[1,2,3,4] is equal to [2,4,1,3]\n[1,2,3] is not equal to [2,4,1,3]\ntrue.\n\n\nWorks with: SWI-Prolog version library(ordset)\n\n%%  Set creation\n\n?- list_to_ord_set([1,2,3,4], A), list_to_ord_set([2,4,6,8], B).\nA = [1, 2, 3, 4],\nB = [2, 4, 6, 8].\n\n%% Test m \u2208 S -- \"m is an element in set S\"\n\n?- ord_memberchk(2, $A).\ntrue.\n\n%% A \u222a B -- union; a set of all elements either in set A or in set B.\n\n?- ord_union($A, $B, Union).\nUnion = [1, 2, 3, 4, 6, 8].\n\n%% A \u2229 B -- intersection; a set of all elements in both set A and set B.\n\n?- ord_intersection($A, $B, Intersection).\nIntersection = [2, 4].\n\n%% A \u2216 B -- difference; a set of all elements in set A, except those in set B.\n\n?- ord_subtract($A, $B, Diff).\nDiff = [1, 3].\n\n%% A \u2286 B -- subset; true if every element in set A is also in set B.\n\n?- ord_subset($A, $B).\nfalse.\n\n?- ord_subset([2,4], $B).\ntrue.\n\n%% A = B -- equality; true if every element of set A is in set B and vice-versa. \n\n?- $A == $B.\nfalse.\n\n?- $A == [1,2,3,4].\ntrue.\n\n%% Definition of a proper subset:\n\nord_propsubset(A, B) :-\n    ord_subset(A, B),\n    \\+(A == B).\n\n%% add/remove elements\n\n?- ord_add_element($A, 19, NewA).\nNewA = [1, 2, 3, 4, 19].\n\n?- ord_del_element($NewA, 3, NewerA).\nNewerA = [1, 2, 4, 19].\n\n", "explain": "Works with SWI-Prolog, library(lists).\n\nSWI-Prolog provides a standard library(ordsets).\nIt is loaded by default. I demonstrate almost all of these predicates in the interactive top-level (`?-` is the prompt).\nVariables prefixed with `$` refer back to the value of the last instantiation. \nIt treats sets as ordered lists of unique elements:\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Lua", "code": "\nWorks with: lua version 5.1\nfunction emptySet()         return { }  end\nfunction insert(set, item)  set[item] = true  end\nfunction remove(set, item)  set[item] = nil  end\nfunction member(set, item)  return set[item]  end\nfunction size(set)\n\tlocal result = 0\n\tfor _ in pairs(set) do result = result + 1 end\n\treturn result\nend\nfunction fromTable(tbl) -- ignore the keys of tbl\n\tlocal result = { }\n\tfor _, val in pairs(tbl) do\n\t\tresult[val] = true\n\tend\n\treturn result\nend\nfunction toArray(set)\n\tlocal result = { }\n\tfor key in pairs(set) do\n\t\ttable.insert(result, key)\n\tend\n\treturn result\nend\nfunction printSet(set)\n\tprint(table.concat(toArray(set), \", \"))\nend\nfunction union(setA, setB)\n\tlocal result = { }\n\tfor key, _ in pairs(setA) do\n\t\tresult[key] = true\n\tend\n\tfor key, _ in pairs(setB) do\n\t\tresult[key] = true\n\tend\n\treturn result\nend\nfunction intersection(setA, setB)\n\tlocal result = { }\n\tfor key, _ in pairs(setA) do\n\t\tif setB[key] then\n\t\t\tresult[key] = true\n\t\tend\n\tend\n\treturn result\nend\nfunction difference(setA, setB)\n\tlocal result = { }\n\tfor key, _ in pairs(setA) do\n\t\tif not setB[key] then\n\t\t\tresult[key] = true\n\t\tend\n\tend\n\treturn result\nend\nfunction subset(setA, setB)\n\tfor key, _ in pairs(setA) do\n\t\tif not setB[key] then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn true\nend\nfunction properSubset(setA, setB)\n\treturn subset(setA, setB) and (size(setA) ~= size(setB))\nend\nfunction equals(setA, setB)\n\treturn subset(setA, setB) and (size(setA) == size(setB))\nend\n\nWorks with: lua version 5.3\n\nlocal function new(_, ...)\n  local r = {}\n  local s = setmetatable({}, {\n    -- API operations\n    __index = {\n\n      -- single value insertion\n      insert = function(s, v)\n        if not r[v] then\n          table.insert(s, v)\n          r[v] = #s\n        end\n        return s\n      end,\n\n      -- single value removal\n      remove = function(s, v)\n        local i = r[v]\n        if i then\n          r[v] = nil\n          local t = table.remove(s)\n          if t ~= v then\n            r[t] = i\n            s[i] = t\n          end\n        end\n        return s\n      end,\n\n      -- multi-value insertion\n      batch_insert = function(s, ...)\n        for _,v in pairs {...} do\n          s:insert(v)\n        end\n        return s\n      end,\n\n      -- multi-value removal\n      batch_remove = function(s, ...)\n        for _,v in pairs {...} do\n          s:remove(v)\n        end\n        return s\n      end,\n\n      -- membership test\n      has = function(s, e)\n        return r[e] ~= nil\n      end\n    },\n\n    -- set manipulation operators\n\n    -- union\n    __add = function(s1, s2)\n      r = set()\n      r:batch_insert(table.unpack(s1))\n      r:batch_insert(table.unpack(s2))\n      return r\n    end,\n\n    -- subtraction\n    __sub = function(s1, s2)\n      r = set()\n      r:batch_insert(table.unpack(s1))\n      r:batch_remove(table.unpack(s2))\n      return r\n    end,\n\n    -- intersection\n    __mul = function(s1, s2)\n      r = set()\n      for _,v in ipairs(s1) do\n        if s2:has(v) then\n          r:insert(v)\n        end\n      end\n      return r\n    end,\n\n    -- equality\n    __eq = function(s1, s2)\n      if #s1 ~= #s2 then return false end\n      for _,v in ipairs(s1) do\n        if not s2:has(v) then return false end\n      end\n      return true\n    end,\n\n    -- proper subset\n    __lt = function(s1, s2)\n      if s1 == s2 then return false end\n      for _,v in ipairs(s1) do\n        if not s2:has(v) then return false end\n      end\n      return true\n    end,\n\n    -- subset\n    __lte = function(s1, s2)\n      return (s1 == s2) or (s1 < s2)\n    end,\n\n    -- metatable type tag\n    __type__ = 'set'\n  })\n  s:batch_insert(...)\n  return s\nend\n\nreturn setmetatable({}, { __call = new })\n\n", "explain": "(May work with earlier versions but not tested on those.)\nThis implementation creates, in effect, a set type with operators for comparisons (subset, equality, true subset), and set operations like unions, differences, and intersections.  It is a mutable set type, so primitives exist for insertion and removal of elements.  Elements can be tested for presence O(1) with the has() method or can be iterated over as an array-flavoured table since this is what the type presents as.  (All of its functionality is buried in metatables.)\nThe code is intended to be placed into a file and accessed as a module.  E.g. if placed into the file \"set.lua\" it would be accessed with set = require 'set'.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Scala", "code": "\nobject sets {\n  val set1 = Set(1,2,3,4,5)\n  val set2 = Set(3,5,7,9)\n  println(set1 contains 3)\n  println(set1 | set2)\n  println(set1 & set2)\n  println(set1 diff set2)\n  println(set1 subsetOf set2)\n  println(set1 == set2)\n}\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Dart", "code": "\nvoid main(){\n  //Set Creation\n  Set A = new Set.from([1,2,3]);\n  Set B = new Set.from([1,2,3,4,5]);\n  Set C = new Set.from([1,2,4,5]);\n\t\n  print('Set A = $A');\n  print('Set B = $B');\n  print('Set C = $C');\n  print('');\n  //Test if element is in set\n  int m = 3;\n  print('m = 5');\n  print('m in A = ${A.contains(m)}');\n  print('m in B = ${B.contains(m)}');\n  print('m in C = ${C.contains(m)}');\n  print('');\n  //Union of two sets\n  Set AC = A.union(C);\n  print('Set AC = Union of A and C = $AC');\n  print('');\n  //Intersection of two sets\n  Set A_C = A.intersection(C);\n  print('Set A_C = Intersection of A and C = $A_C');\n  print('');\n  //Difference of two sets\n  Set A_diff_C = A.difference(C);\n  print('Set A_diff_C = Difference between A and C = $A_diff_C');\n  print('');\n  //Test if set is subset of another set\n  print('A is a subset of B = ${B.containsAll(A)}');\n  print('C is a subset of B = ${B.containsAll(C)}');\n  print('A is a subset of C = ${C.containsAll(A)}');\n  print('');\n  //Test if two sets are equal\n  print('A is equal to B  = ${B.containsAll(A) && A.containsAll(B)}');\n  print('B is equal to AC = ${B.containsAll(AC) && AC.containsAll(B)}');\n}\n\n\nOutput:\nSet A = {1, 2, 3}\nSet B = {1, 2, 3, 4, 5}\nSet C = {1, 2, 4, 5}\n\nm = 5\nm in A = true\nm in B = true\nm in C = false\n\nSet AC = Union of A and C = {1, 2, 3, 4, 5}\n\nSet A_C = Intersection of A and C = {1, 2}\n\nSet A_diff_C = Difference between A and C = {3}\n\nA is a subset of B = true\nC is a subset of B = true\nA is a subset of C = false\n\nA is equal to B  = false\nB is equal to AC = true\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.algorithm, std.range;\n\n    // Not true sets, items can be repeated, but must be sorted.\n    auto s1 = [1, 2, 3, 4, 5, 6].assumeSorted;\n    auto s2 = [2, 5, 6, 3, 4, 8].sort(); // [2,3,4,5,6,8].\n    auto s3 = [1, 2, 5].assumeSorted;\n\n    assert(s1.canFind(4)); // Linear search.\n    assert(s1.contains(4)); // Binary search.\n    assert(s1.setUnion(s2).equal([1,2,2,3,3,4,4,5,5,6,6,8]));\n    assert(s1.setIntersection(s2).equal([2, 3, 4, 5, 6]));\n    assert(s1.setDifference(s2).equal([1]));\n    assert(s1.setSymmetricDifference(s2).equal([1, 8]));\n    assert(s3.setDifference(s1).empty); // It's a subset.\n    assert(!s1.equal(s2));\n\n    auto s4 = [[1, 4, 7, 8], [1, 7], [1, 7, 8], [4], [7]];\n    const s5 = [1, 1, 1, 4, 4, 7, 7, 7, 7, 8, 8];\n    assert(s4.nWayUnion.equal(s5));\n}\n ==D==\nmodule set;\nimport std.typecons : Tuple, tuple;\nstruct Set(V) { // Limited set of V-type elements                                        // here 'this' is named A, s is B, v V-type item\n\nprotected V[] array;\n\n\tthis(const Set s) {                                                              // construct A by copy of B\n\t\tarray = s.array.dup;\n\t}\n\n\tthis(V[] arg...){                                                                // construct A with items\n\t\tforeach(v; arg) if (v.isNotIn(array)) array ~= v;\n\t}\n\n\tenum : Set { empty = Set() }                                                     // \u2205\n\n\tref Set opAssign()(const Set s) {                                                // A = B\n\t\tarray = s.array.dup;\n\t\treturn this;\n\t}\n\n\tbool opBinaryRight(string op : \"in\")(const V v) const {                          // v \u2208 A\n\t\treturn v.isIn(array);\n\t}\n\n\tref Set opOpAssign(string op)(const V v) if (op == \"+\" || op == \"|\") {           // A += {v}          // + = \u222a = |\n\t\tif (v.isIn(array)) return this;\n\t\tarray ~= v;\n\t\treturn this;\n\t}\n\n\tref Set opOpAssign(string op)(const Set s) if (op == \"+\" || op == \"|\") {         // A += B\n\t\tforeach(x; s.array) if (x.isNotIn(array)) array ~= x;\n\t\treturn this;\n\t}\n\n\tSet opBinary(string op)(const V v) const if (op == \"+\" || op == \"|\"){            // A + {v}\n\t\tSet result = this;\n\t\tresult += v;\n\t\treturn result;\n\t}\n\n\tSet opBinaryRight(string op)(const V v) const if (op == \"+\" || op == \"|\") {      // {v} + A\n\t\tSet result = this;\n\t\tresult += v;\n\t\treturn result;\n\t}\n\n\tSet opBinary(string op)(const Set s) const if (op == \"+\" || op == \"|\") {         // A + B\n\t\tSet result = this;\n\t\tresult += s;\n\t\treturn result;\n\t}\n\n\tSet opBinary(string op : \"&\")(const Set s) const{                                // A \u2229 B               // \u2229 = &\n\t\tSet result;\n\t\tforeach(x; array) if(x.isIn(s.array)) result += x;\n\t\treturn result;\n\t}\n\n\tref Set opOpAssign(string op : \"&\")(const Set s) {                               // A \u2229= B\n\t\treturn this(this & s);\n\t}\n\n\tSet opBinary(string op : \"^\")(const Set s) const {                               // (A \u222a B) - (A \u2229 B)    //  = A ^ B\n\t\tSet result;\n\t\tforeach(x; array) if (x.isNotIn(s.array)) result += x;\n\t\tforeach(x; s.array) if(x.isNotIn(array)) result += x;\n\t\treturn result;\n\t}\n\n\tref opOpAssign(string op : \"^\")(const Set s) {\n\t\treturn this = this ^ s;\n\t}\n\n\tSet opBinary(string op : \"-\")(const Set s) const {                                // A - B\n\t\tSet r;\n\t\tforeach(x; array) if(x.isNot(s.array)) r += x;\n\t\treturn r;\n\t}\n\n\tref Set opOpAssign(string op : \"-\")(const Set s) {                                // A -= B\n\t\treturn this = this - s;\n\t}\n\n\tSet!(Tuple!(V,U)) opBinary(U, string op : \"*\")(const Set!U s) const {             // A \u00d7 B = { (x, y) | \u2200x \u2208 A \u2227 \u2200y \u2208 B }\n\t\tSet!(Tuple!(V, U)) r;\n\t\tforeach(x; array) foreach(y; s.array) r += tuple(x, y);\n\t\treturn r;\n\t}\n\n\tbool isEmpty() const { return !array.length;}                                     // A \u225f \u2205\n\n\tbool opBinary(string op : \"in\")(const Set s) const {                              // A \u2282 s\n\t\tforeach(v; array) if(v.isNotIn(s.array)) return false;\n\t\treturn true;\n\t}\n\n\tbool opEquals(const Set s) const {                                                // A \u225f B\n\t\tif (array.length != s.array.length) return false;\n\t\treturn this in s;\n\t}\n\n\tT[] array() const @property { return array.dup;}\n\n}\n\nSet!(Tuple!(T, T)) sqr(T)(const Set!T s) { return s * s; }                                 // A\u00b2\n\nauto pow(T, uint n : 0)(const Set!T s) {                                                   // A ^ 0\n\treturn Set!T.empty;\n}\n\nauto pow(T, uint n : 1)(const Set!T s) {                                                   // A ^ 1 = A\n\treturn s;\n}\n\nauto pow(T, uint n : 2)(const Set!T s) {                                                   // A ^\u00a02 (=A\u00b2)\n\treturn sqr!T(s);\n}\n\nauto pow(T, uint n)(const Set!T s) if(n % 2) {                                             // if n Odd,  A^n = A * (A^(n/2))\u00b2\t\n        return s * sqr!T(pow!(T, n/2)(s));\n}\n\nauto pow(T, uint n)(const Set!T s) if(!(n % 2)) {                                           // if n Even, A^n = (A^(n/2))\u00b2\n\treturn sqr!T(pow!(T, n/2)(s));\n}\n\nsize_t Card(T)(const Set!T s) {return s.length; }                                           // Card(A)\n\nSet!(Set!T) power(T)(Set!T s) {                                                             // \u2200B \u2208 P(A) \u21d2 B \u2282 A \n\tSet!(Set!T) ret;\n\tforeach(e; s.array) {\n\t\tSet!(Set!T) rs;\n\t\tforeach(x; ret.array) {\n\t\t\tx += e;\n\t\t\trs += x;\n\t\t}\n\t\tret += rs;\n\t}\n\treturn ret;\n}\n\nbool isIn(T)(T x, T[] array){\n\tforeach(a; array) if(a == x) return true;\n\treturn false;\n}\nbool isNotIn(T)(T x, T[] array){\n\tforeachj(a; array) if(a == x) return false;\n\treturn true;\n}\n\n", "explain": ""}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Haskell", "code": "\nWorks with: GHC\n\nPrelude> import Data.Set\nPrelude Data.Set> empty :: Set Integer -- Empty set\nfromList []\nPrelude Data.Set> let s1 = fromList [1,2,3,4,3] -- Convert list into set\nPrelude Data.Set> s1\nfromList [1,2,3,4]\nPrelude Data.Set> let s2 = fromList [3,4,5,6] \nPrelude Data.Set> union s1 s2 -- Union\nfromList [1,2,3,4,5,6]\nPrelude Data.Set> intersection s1 s2 -- Intersection\nfromList [3,4]\nPrelude Data.Set> s1 \\\\ s2 -- Difference\nfromList [1,2]\nPrelude Data.Set> s1 `isSubsetOf` s1 -- Subset\nTrue\nPrelude Data.Set> fromList [3,1] `isSubsetOf` s1\nTrue\nPrelude Data.Set> s1 `isProperSubsetOf` s1 -- Proper subset\nFalse\nPrelude Data.Set> fromList [3,1] `isProperSubsetOf` s1\nTrue\nPrelude Data.Set> fromList [3,2,4,1] == s1 -- Equality\nTrue\nPrelude Data.Set> s1 == s2\nFalse\nPrelude Data.Set> 2 `member` s1 -- Membership\nTrue\nPrelude Data.Set> 10 `notMember` s1\nTrue\nPrelude Data.Set> size s1 -- Cardinality\n4\nPrelude Data.Set> insert 99 s1 -- Create a new set by inserting\nfromList [1,2,3,4,99]\nPrelude Data.Set> delete 3 s1 -- Create a new set by deleting\nfromList [1,2,4]\n\n\nPrelude> import Data.List\nPrelude Data.List> let s3 = nub [1,2,3,4,3] -- Remove duplicates from list\nPrelude Data.List> s3\n[1,2,3,4]\nPrelude Data.List> let s4 = [3,4,5,6]\nPrelude Data.List> union s3 s4 -- Union\n[1,2,3,4,5,6]\nPrelude Data.List> intersect s3 s4 -- Intersection\n[3,4]\nPrelude Data.List> s3 \\\\ s4 -- Difference\n[1,2]\nPrelude Data.List> 42 : s3 -- Return new list with element inserted at the beginning\n[42,1,2,3,4]\nPrelude Data.List> delete 3 s3 -- Return new list with first occurrence of element removed\n[1,2,4]\n\n", "explain": "GHC offers a functional, persistent set data structure in its Data.Set module. It is implemented using a binary search tree. Elements must be of an orderable type (instance of Ord).\nRegular lists can also be used as sets. Haskell has some functions to help with using lists as sets. No requirement is made of element type. However, these are not very efficient because they require linear time to find an element.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Scheme", "code": "\n\n(define (element? a lst)\n  (and (not (null? lst))\n       (or (eq? a (car lst))\n\t   (element? a (cdr lst)))))\n\n; util, not strictly needed\n(define (uniq lst)\n  (if (null? lst) lst\n    (let ((a (car lst)) (b (cdr lst)))\n      (if (element? a b)\n\t(uniq b)\n\t(cons a (uniq b))))))\n\n(define (intersection a b)\n  (cond ((null? a) '())\n\t((null? b) '())\n\t(else\n\t  (append (intersection (cdr a) b)\n\t\t  (if (element? (car a) b)\n\t\t    (list (car a))\n\t\t    '())))))\n\n(define (union a b)\n  (if (null? a) b\n    (union (cdr a)\n\t   (if (element? (car a) b)\n\t     b\n\t     (cons (car a) b)))))\n\n(define (diff a b) ; a - b\n  (if (null? a) '()\n    (if (element? (car a) b)\n      (diff (cdr a) b)\n      (cons (car a) (diff (cdr a) b)))))\n\n(define (subset? a b) ; A \u2286 B\n  (if (null? a) #t\n    (and (element? (car a) b)\n\t (subset? (cdr a) b))))\n\n(define (set-eq? a b)\n  (and (subset? a b)\n       (subset? b a)))\n\n", "explain": "Implemented based on lists.  Not efficient on large sets.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Apex", "code": "\n\npublic class MySetController{\n    public Set<String> strSet {get; private set; }\n    public Set<Id> idSet {get; private set; }\n    \n    public MySetController(){\n        //Initialize to an already known collection.  Results in a set of abc,def.\n        this.strSet = new Set<String>{'abc','abc','def'};\n        \n        //Initialize to empty set and add in entries.\n        this.strSet = new Set<String>();\n        this.strSet.add('abc');\n        this.strSet.add('def');\n        this.strSet.add('abc');\n        //Results in {'abc','def'}\n\n        //You can also get a set from a map in Apex. In this case, the account ids are fetched from a SOQL query.\n        Map<Id,Account> accountMap = new Map<Id,Account>([Select Id,Name From Account Limit 10]);\n        Set<Id> accountIds = accountMap.keySet();\n\n        //If you have a set, you can also use it with the bind variable syntax in SOQL:\n        List<Account> accounts = [Select Name From Account Where Id in :accountIds];\n\n        //Like other collections in Apex, you can use a for loop to iterate over sets:\n        for(Id accountId\u00a0: accountIds){\n            Account a = accountMap.get(accountId);\n            //Do account stuffs here.\n        }\n    }\n}\n", "explain": "In Apex, Sets are unordered collections of elements.  Although elements can be anything including primitives, Ids, Apex classes, or sObjects, typically they are used with primitives and Ids.\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "PowerShell", "code": "\n\n[System.Collections.Generic.HashSet[object]]$set1 = 1..4\n[System.Collections.Generic.HashSet[object]]$set2 = 3..6\n\n#            Operation           +     Definition      +          Result\n#--------------------------------+---------------------+-------------------------\n$set1.UnionWith($set2)           # Union                 $set1 = 1, 2, 3, 4, 5, 6\n$set1.IntersectWith($set2)       # Intersection          $set1 = 3, 4\n$set1.ExceptWith($set2)          # Difference            $set1 = 1, 2\n$set1.SymmetricExceptWith($set2) # Symmetric difference  $set1 = 1, 2, 6, 5\n$set1.IsSupersetOf($set2)        # Test superset         False\n$set1.IsSubsetOf($set2)          # Test subset           False\n$set1.Equals($set2)              # Test equality         False\n$set1.IsProperSupersetOf($set2)  # Test proper superset  False\n$set1.IsProperSubsetOf($set2)    # Test proper subset    False\n\n5 -in $set1                      # Test membership       False\n7 -notin $set1                   # Test non-membership   True\n\n", "explain": ".NET offers the HashSet type which seems to act in most ways like a set.\nWhen used in PowerShell, the syntax is clumsy.  In addition, the \"reference\" set ($set1) is modified in place to become the result.\n(All examples assume the variable $set1 contains the value @(1,2,3,4))\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "F#", "code": "\n\n[<EntryPoint>]\nlet main args =\n    // Create some sets (of int):\n    let s1 = Set.ofList [1;2;3;4;3]\n    let s2 = Set.ofArray [|3;4;5;6|]\n\n    printfn \"Some sets (of int):\"\n    printfn \"s1 = %A\" s1\n    printfn \"s2 = %A\" s2\n    printfn \"Set operations:\"\n    printfn \"2 \u2208 s1? %A\" (s1.Contains 2)\n    printfn \"10 \u2208 s1? %A\" (s1.Contains 10)\n    printfn \"s1 \u222a s2 = %A\" (Set.union s1 s2)\n    printfn \"s1 \u2229 s2 = %A\" (Set.intersect s1 s2)\n    printfn \"s1 \u2216 s2 = %A\" (Set.difference s1 s2)\n    printfn \"s1 \u2286 s2? %A\" (Set.isSubset s1 s1)\n    printfn \"{3, 1} \u2286 s1? %A\" (Set.isSubset (Set.ofList [3;1]) s1)\n    printfn \"{3, 2, 4, 1} = s1? %A\" ((Set.ofList [3;2;4;1]) = s1)\n    printfn \"s1 = s2? %A\" (s1 = s2)\n    printfn \"More set operations:\"\n    printfn \"#s1 = %A\" s1.Count\n    printfn \"s1 \u222a {99} = %A\" (s1.Add 99)\n    printfn \"s1 \u2216 {3} = %A\" (s1.Remove 3)\n    printfn \"s1 \u2282 s1? %A\" (Set.isProperSubset s1 s1)\n    printfn \"s1 \u2282 s2? %A\" (Set.isProperSubset s1 s2)\n    0\n\n\nOutput:\nSome sets (of int):\ns1 = set [1; 2; 3; 4]\ns2 = set [3; 4; 5; 6]\nSet operations:\n2 \u2208 s1? true\n10 \u2208 s1? false\ns1 \u222a s2 = set [1; 2; 3; 4; 5; 6]\ns1 \u2229 s2 = set [3; 4]\ns1 \u2216 s2 = set [1; 2]\ns1 \u2286 s2? true\n{3, 1} \u2286 s1? true\n{3, 2, 4, 1} = s1? true\ns1 = s2? false\nMore set operations:\n#s1 = 4\ns1 \u222a {99} = set [1; 2; 3; 4; 99]\ns1 \u2216 {3} = set [1; 2; 4]\ns1 \u2282 s1? false\ns1 \u2282 s2? false\n", "explain": "The Collections.Set<'T> class implements \"Immutable sets based on binary trees, where comparison is the F# structural comparison function, potentially using implementations of the IComparable interface on key values.\" (http://msdn.microsoft.com/en-us/library/ee353619.aspx)\n"}, {"task_name": "Set", "task_url": "https://rosettacode.org/wiki/Set", "task_cat": "Data Structures", "lang": "Groovy", "code": "\ndef s1 = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10] as Set\ndef m1 = 6\ndef m2 = 7\ndef s2 = [0, 2, 4, 6, 8] as Set\nassert m1 in s1                                        : 'member'\nassert ! (m2 in s2)                                    : 'not a member'\ndef su = s1 + s2\nassert su == [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10] as Set : 'union'\ndef si = s1.intersect(s2)\nassert si == [8, 6, 4, 2] as Set                       : 'intersection'\ndef sd = s1 - s2\nassert sd == [1, 3, 5, 7, 9, 10] as Set                : 'difference'\nassert s1.containsAll(si)                              : 'subset'\nassert ! s1.containsAll(s2)                            : 'not a subset'\nassert (si + sd) == s1                                 : 'equality'\nassert (s2 + sd) != s1                                 : 'inequality'\nassert s1 != su && su.containsAll(s1)                  : 'proper subset'\ns1 << 0\nassert s1 == su                                        : 'added element 0 to s1'\n\n", "explain": ""}]