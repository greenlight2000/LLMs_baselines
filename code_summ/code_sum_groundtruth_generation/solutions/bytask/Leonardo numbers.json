[{"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nFinite iteration[edit]\ndef Leonardo(L_Zero, L_One, Add, Amount):\n    terms = [L_Zero,L_One]\n    while len(terms) < Amount:\n        new = terms[-1] + terms[-2]\n        new += Add\n        terms.append(new)\n    return terms\n\nout = \"\"\nprint \"First 25 Leonardo numbers:\"\nfor term in Leonardo(1,1,1,25):\n    out += str(term) + \" \"\nprint out\n\nout = \"\"\nprint \"Leonardo numbers with fibonacci parameters:\"\nfor term in Leonardo(0,1,0,25):\n    out += str(term) + \" \"\nprint out\n\n\nOutput:\nFirst 25 Leonardo numbers:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049 \nLeonardo numbers with fibonacci parameters:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 \n\nNon-finite generation[edit]\n\nWorks with: Python version 3\n'''Leonardo numbers'''\n\nfrom functools import (reduce)\nfrom itertools import (islice)\n\n\n# leo\u00a0:: Int -> Int -> Int -> Generator [Int]\ndef leo(L0, L1, delta):\n    '''A number series of the\n       Leonardo and Fibonacci pattern,\n       where L0 and L1 are the first two terms,\n       and delta = 1 for (L0, L1) == (1, 1)\n       yields the Leonardo series, while\n       delta = 0 defines the Fibonacci series.'''\n    (x, y) = (L0, L1)\n    while True:\n        yield x\n        (x, y) = (y, x + y + delta)\n\n\n# main\u00a0:: IO()\ndef main():\n    '''Tests.'''\n\n    print('\\n'.join([\n        'First 25 Leonardo numbers:',\n        folded(16)(take(25)(\n            leo(1, 1, 1)\n        )),\n        '',\n        'First 25 Fibonacci numbers:',\n        folded(16)(take(25)(\n            leo(0, 1, 0)\n        ))\n    ]))\n\n\n# FORMATTING ----------------------------------------------\n\n# folded\u00a0:: Int -> [a] -> String\ndef folded(n):\n    '''Long list folded to rows of n terms each.'''\n    return lambda xs: '[' + ('\\n '.join(\n        str(ns)[1:-1] for ns in chunksOf(n)(xs)\n    ) + ']')\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# take\u00a0:: Int -> [a] -> [a]\n# take\u00a0:: Int -> String -> String\ndef take(n):\n    '''The prefix of xs of length n,\n       or xs itself if n > length xs.'''\n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, list)\n        else list(islice(xs, n))\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nFirst 25 Leonardo numbers:\n[1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973\n 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049]\n\nFirst 25 Fibonacci numbers:\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610\n 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]\n", "explain": "Or, for a non-finite stream of Leonardos, we can use a Python generator:\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include<stdio.h>\n\nvoid leonardo(int a,int b,int step,int num){\n\t\n\tint i,temp;\n\t\n\tprintf(\"First 25 Leonardo numbers\u00a0: \\n\");\n\t\n\tfor(i=1;i<=num;i++){\n\t\tif(i==1)\n\t\t\tprintf(\" %d\",a);\n\t\telse if(i==2)\n\t\t\tprintf(\" %d\",b);\n\t\telse{\n\t\t\tprintf(\" %d\",a+b+step);\n\t\t\ttemp = a;\n\t\t\ta = b;\n\t\t\tb = temp+b+step;\n\t\t}\n\t}\n}\n\nint main()\n{\n\tint a,b,step;\n\t\n\tprintf(\"Enter first two Leonardo numbers and increment step\u00a0: \");\n\t\n\tscanf(\"%d%d%d\",&a,&b,&step);\n\t\n\tleonardo(a,b,step,25);\n\t\n\treturn 0;\n}\n\n\nEnter first two Leonardo numbers and increment step\u00a0: 1 1 1\nFirst 25 Leonardo numbers\u00a0:\n 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n\n\nEnter first two Leonardo numbers and increment step\u00a0: 0 1 0\nFirst 25 Leonardo numbers\u00a0:\n 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": "This implementation fulfills the task requirements which state that the first 2 terms and the step increment should be specified. Many other implementations on this page only print out the first 25 numbers.\nOutput\u00a0:\nNormal Leonardo Series\u00a0:\nFibonacci Series\u00a0:\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include <iostream>\n\nvoid leoN( int cnt, int l0 = 1, int l1 = 1, int add = 1 ) {\n    int t;\n    for( int i = 0; i < cnt; i++ ) {\n        std::cout << l0 << \" \";\n        t = l0 + l1 + add; l0 = l1; l1 = t;\n    }\n}\nint main( int argc, char* argv[] ) {\n    std::cout << \"Leonardo Numbers: \"; leoN( 25 );\n    std::cout << \"\\n\\nFibonacci Numbers: \"; leoN( 25, 0, 1, 0 );\n    return 0;\n}\n\n\nOutput:\n\nLeonardo Numbers: 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nFibonacci Numbers: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nTranslation of: Kotlin\nimport java.util.Arrays;\nimport java.util.List;\n\n@SuppressWarnings(\"SameParameterValue\")\npublic class LeonardoNumbers {\n    private static List<Integer> leonardo(int n) {\n        return leonardo(n, 1, 1, 1);\n    }\n\n    private static List<Integer> leonardo(int n, int l0, int l1, int add) {\n        Integer[] leo = new Integer[n];\n        leo[0] = l0;\n        leo[1] = l1;\n        for (int i = 2; i < n; i++) {\n            leo[i] = leo[i - 1] + leo[i - 2] + add;\n        }\n        return Arrays.asList(leo);\n    }\n\n    public static void main(String[] args) {\n        System.out.println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\");\n        System.out.println(leonardo(25));\n        System.out.println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\");\n        System.out.println(leonardo(25, 0, 1, 0));\n    }\n}\n\n\nOutput:\nThe first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\n[1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049]\n\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nWorks with: C sharp version 7\nusing System;\nusing System.Linq;\n\npublic class Program\n{\n    public static void Main() {\n        Console.WriteLine(string.Join(\" \", Leonardo().Take(25)));\n        Console.WriteLine(string.Join(\" \", Leonardo(L0: 0, L1: 1, add: 0).Take(25)));\n    }\n\n    public static IEnumerable<int> Leonardo(int L0 = 1, int L1 = 1, int add = 1) {\n        while (true) {\n            yield return L0;\n            (L0, L1) = (L1, L0 + L1 + add);\n        }\n    }\n}\n\n\nOutput:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES6[edit]\nconst leoNum = (c, l0 = 1, l1 = 1, add = 1) =>\n    new Array(c).fill(add).reduce(\n        (p, c, i) => i > 1 ? (\n            p.push(p[i - 1] + p[i - 2] + c) && p\n        ) : p, [l0, l1]\n    );\n    \nconsole.log(leoNum(25));\nconsole.log(leoNum(25, 0, 1, 0));\n\n[1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]\n\nTranslation of: Python\n(() => {\n    'use strict';\n\n    // leo\u00a0:: Int -> Int -> Int -> Generator [Int]\n    function* leo(L0, L1, delta) {\n        let [x, y] = [L0, L1];\n        while (true) {\n            yield x;\n            [x, y] = [y, delta + x + y];\n        }\n    }\n\n    // ----------------------- TEST ------------------------\n    // main\u00a0:: IO ()\n    const main = () => {\n        const\n            leonardo = leo(1, 1, 1),\n            fibonacci = leo(0, 1, 0);\n\n        return unlines([\n            'First 25 Leonardo numbers:',\n            indentWrapped(take(25)(leonardo)),\n            '',\n            'First 25 Fibonacci numbers:',\n            indentWrapped(take(25)(fibonacci))\n        ]);\n    };\n\n    // -------------------- FORMATTING ---------------------\n\n    // indentWrapped\u00a0:: [Int] -> String\n    const indentWrapped = xs =>\n        unlines(\n            map(x => '\\t' + x.join(','))(\n                chunksOf(16)(\n                    map(str)(xs)\n                )\n            )\n        );\n\n    // ----------------- GENERIC FUNCTIONS -----------------\n\n    // chunksOf\u00a0:: Int -> [a] -> [[a]]\n    const chunksOf = n =>\n        xs => enumFromThenTo(0)(n)(\n            xs.length - 1\n        ).reduce(\n            (a, i) => a.concat([xs.slice(i, (n + i))]),\n            []\n        );\n\n    // enumFromThenTo\u00a0:: Int -> Int -> Int -> [Int]\n    const enumFromThenTo = x1 =>\n        x2 => y => {\n            const d = x2 - x1;\n            return Array.from({\n                length: Math.floor(y - x2) / d + 2\n            }, (_, i) => x1 + (d * i));\n        };\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => [...xs].map(f);\n\n    // str\u00a0:: a -> String\n    const str = x =>\n        x.toString();\n\n    // take\u00a0:: Int -> [a] -> [a]\n    // take\u00a0:: Int -> String -> String\n    const take = n =>\n        // The first n elements of a list,\n        // string of characters, or stream.\n        xs => 'GeneratorFunction' !== xs\n        .constructor.constructor.name ? (\n            xs.slice(0, n)\n        ) : [].concat.apply([], Array.from({\n            length: n\n        }, () => {\n            const x = xs.next();\n            return x.done ? [] : [x.value];\n        }));\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\nFirst 25 Leonardo numbers:\n    1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973\n    3193,5167,8361,13529,21891,35421,57313,92735,150049\n\nFirst 25 Fibonacci numbers:\n    0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610\n    987,1597,2584,4181,6765,10946,17711,28657,46368\n", "explain": "\nOr, taking N terms from a non-finite Javascript generator:\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Module1\n\n    Iterator Function Leonardo(Optional L0 = 1, Optional L1 = 1, Optional add = 1) As IEnumerable(Of Integer)\n        While True\n            Yield L0\n            Dim t = L0 + L1 + add\n            L0 = L1\n            L1 = t\n        End While\n    End Function\n\n    Sub Main()\n        Console.WriteLine(String.Join(\" \", Leonardo().Take(25)))\n        Console.WriteLine(String.Join(\" \", Leonardo(0, 1, 0).Take(25)))\n    End Sub\n\nEnd Module\n\n\nOutput:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\n\nThe method relies on producing a sequence of values, rather than calculating L(n) from the start each time a value from the sequence is required.       SUBROUTINE LEONARDO(LAST,L0,L1,AF)\t!Show the first LAST values of the sequence.\n       INTEGER LAST\t!Limit to show.\n       INTEGER L0,L1\t!Starting values.\n       INTEGER AF\t!The \"Add factor\" to deviate from Fibonacci numbers.\n       OPTIONAL AF\t!Indicate that this parameter may be omitted.\n       INTEGER EMBOLISM\t!The bloat to employ.\n       INTEGER N,LN,LNL1,LNL2\t!Assistants to the calculation.\n        IF (PRESENT(AF)) THEN\t!Perhaps the last parameter has not been given.\n          EMBOLISM = AF\t\t\t!It has. Take its value.\n         ELSE\t\t\t!But if not,\n          EMBOLISM = 1\t\t\t!This is the specified default.\n        END IF\t\t\t!Perhaps there should be some report on this?\n        WRITE (6,1) LAST,L0,L1,EMBOLISM\t!Announce.\n    1   FORMAT (\"The first \",I0,\t!The I0 format code avoids excessive spacing.\n     1   \" numbers in the Leonardo sequence defined by L(0) = \",I0,\n     2   \" and L(1) = \",I0,\" with L(n) = L(n - 1) + L(n - 2) + \",I0)\n        IF (LAST .GE. 1) WRITE (6,2) L0\t!In principle, LAST may be small.\n        IF (LAST .GE. 2) WRITE (6,2) L1\t!!So, suspicion rules.\n    2   FORMAT (I0,\", \",$)\t!Obviously, the $ sez \"don't finish the line\".\n        LNL1 = L0\t!Syncopation for the sequence's initial values.\n        LN = L1\t\t!Since the parameters ought not be damaged.\n        DO N = 3,LAST\t!Step away.\n          LNL2 = LNL1\t\t!Advance the two state variables one step.\n          LNL1 = LN\t\t!Ready to make a step forward.\n          LN = LNL1 + LNL2 + EMBOLISM\t!Thus.\n          WRITE (6,2) LN\t!Reveal the value. Overflow is distant...\n        END DO\t\t!On to the next step.\n        WRITE (6,*)\t!Finish the line.\n      END SUBROUTINE LEONARDO\t!Only speedy for the sequential production of values.\n\n      PROGRAM POKE\n\n      CALL LEONARDO(25,1,1,1)\t!The first 25 Leonardo numbers.\n      CALL LEONARDO(25,0,1,0)\t!Deviates to give the Fibonacci sequence.\n      END\n\n\nThe first 25 numbers in the Leonardo sequence defined by L(0) = 1 and L(1) = 1 with L(n) = L(n - 1) + L(n - 2) + 1\n1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049,\nThe first 25 numbers in the Leonardo sequence defined by L(0) = 0 and L(1) = 1 with L(n) = L(n - 1) + L(n - 2) + 0\n0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368,\n\n", "explain": "Happily, no monster values result for the trial run, so ordinary 32-bit integers suffice. The source style uses the F90 facilities only to name the subroutine being ended (i.e. END SUBROUTINE LEONARDO rather than just END) and the I0 format code that shows an integer without a fixed space allowance, convenient in produced well-formed messages. The \"$\" format code signifies that the end of output from its WRITE statement should not trigger the starting of a new line for the next WRITE statement, convenient when rolling a sequence of values to a line of output one-by-one as they are concocted. Otherwise, the values would have to be accumulated in a suitable array and then written in one go. \nMany versions of Fortran have enabled parameters to be optionally supplied and F90 has standardised a protocol, also introducing a declaration syntax that can specify multiple attributes in one statement which in this case would be INTEGER, OPTIONAL:: AF rather than two statements concerning AF. However, in a test run with CALL LEONARDO(25,1,1) the Compaq F90/95 compiler rejected this attempt because there was another invocation with four parameters, not three, in the same program unit. By adding the rigmarole for declaring a MODULE containing the subroutine LEONARDO, its worries would be assuaged. Many compilers (and linkers, for separately-compiled routines) would check neither the number nor the type of parameters so no such complaint would be made - but when run, the code might produce wrong results or crash.\nOutput:\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc leonardo(n, l0, l1, add int) []int {\n    leo := make([]int, n)\n    leo[0] = l0\n    leo[1] = l1\n    for i := 2; i < n; i++ {\n        leo[i] = leo[i - 1] + leo[i - 2] + add\n    }\n    return leo\n}\n\nfunc main() {\n    fmt.Println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\")\n    fmt.Println(leonardo(25, 1, 1, 1))\n    fmt.Println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\")\n    fmt.Println(leonardo(25, 0, 1, 0))\n}\n\n\nOutput:\nThe first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\n[1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049]\n\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\n[0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368]\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\ntype TIntArray = array of integer;\n\nfunction GetLeonardoNumbers(Cnt,SN1,SN2,Add: integer): TIntArray;\nvar N: integer;\nbegin\nSetLength(Result,Cnt);\nResult[0]:=SN1; Result[1]:=SN2;\nfor N:=2 to Cnt-1 do\n\tbegin\n\tResult[N]:=Result[N-1] + Result[N-2] + Add;\n\tend;\nend;\n\n\nprocedure TestLeonardoNumbers(Memo: TMemo);\nvar IA: TIntArray;\nvar S: string;\nvar I: integer;\nbegin\nMemo.Lines.Add('Leonardo Numbers:');\nIA:=GetLeonardoNumbers(25,1,1,1);\nS:='';\nfor I:=0 to High(IA) do\n\tbegin\n\tS:=S+' '+Format('%6d',[IA[I]]);\n\tif I mod 5 = 4 then S:=S+#$0D#$0A;\n\tend;\nMemo.Lines.Add(S);\nMemo.Lines.Add('Fibonacci Numbers:');\nIA:=GetLeonardoNumbers(25,0,1,0);\nS:='';\nfor I:=0 to High(IA) do\n\tbegin\n\tS:=S+' '+Format('%6d',[IA[I]]);\n\tif I mod 5 = 4 then S:=S+#$0D#$0A;\n\tend;\nMemo.Lines.Add(S);\nend;\n\n\nOutput:\nLeonardo Numbers:\n      1      1      3      5      9\n     15     25     41     67    109\n    177    287    465    753   1219\n   1973   3193   5167   8361  13529\n  21891  35421  57313  92735 150049\n\nFibonacci Numbers:\n      0      1      1      2      3\n      5      8     13     21     34\n     55     89    144    233    377\n    610    987   1597   2584   4181\n   6765  10946  17711  28657  46368\n\n", "explain": "\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\ndef leonardo(l0=1, l1=1, add=1)\n  return to_enum(__method__,l0,l1,add) unless block_given?\n  loop do  \n    yield l0\n    l0, l1 = l1, l0+l1+add\n  end\nend\n\np leonardo.take(25)\np leonardo(0,1,0).take(25)\n\n\nOutput:\n[1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049]\n[0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368]\n\n", "explain": "Enumerators are nice for this.\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nfn leonardo(mut n0: u32, mut n1: u32, add: u32) -> impl std::iter::Iterator<Item = u32> {\n    std::iter::from_fn(move || {\n        let n = n0;\n        n0 = n1;\n        n1 += n + add;\n        Some(n)\n    })\n}\n\nfn main() {\n    println!(\"First 25 Leonardo numbers:\");\n    for i in leonardo(1, 1, 1).take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n    println!(\"First 25 Fibonacci numbers:\");\n    for i in leonardo(0, 1, 0).take(25) {\n        print!(\"{} \", i);\n    }\n    println!();\n}\n\n\nOutput:\nFirst 25 Leonardo numbers:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049 \nFirst 25 Fibonacci numbers:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 \n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nstruct Leonardo: Sequence, IteratorProtocol {\n    private let add : Int\n    private var n0: Int\n    private var n1: Int\n    \n    init(n0: Int = 1, n1: Int = 1, add: Int = 1) {\n        self.n0 = n0\n        self.n1 = n1\n        self.add = add\n    }\n    \n    mutating func next() -> Int? {\n        let n = n0\n        n0 = n1\n        n1 += n + add\n        return n\n    }\n}\n\nprint(\"First 25 Leonardo numbers:\")\nprint(Leonardo().prefix(25).map{String($0)}.joined(separator: \" \"))\n\nprint(\"First 25 Fibonacci numbers:\")\nprint(Leonardo(n0: 0, add: 0).prefix(25).map{String($0)}.joined(separator: \" \"))\n\n\nOutput:\nFirst 25 Leonardo numbers:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nFirst 25 Fibonacci numbers:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nleonardo_numbers <- function(add = 1, l0 = 1, l1 = 1, how_many = 25) {\n\tresult <- c(l0, l1)\n\tfor (i in 3:how_many) \n\t\tresult <- append(result, result[[i - 1]] + result[[i - 2]] + add)\n\tresult\n}\ncat(\"First 25 Leonardo numbers\\n\")\ncat(leonardo_numbers(), \"\\n\")\n\ncat(\"First 25 Leonardo numbers from 0, 1 with add number = 0\\n\")\ncat(leonardo_numbers(0, 0, 1), \"\\n\")\n\n\nOutput:\nFirst 25 Leonardo numbers\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049 \nFirst 25 Leonardo numbers from 0, 1 with add number = 0\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368 \n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Leonardo is\n\n   function Leo\n     (N      : Natural;\n      Step   : Natural := 1;\n      First  : Natural := 1;\n      Second : Natural := 1) return Natural   is \n      L : array (0..1) of Natural := (First, Second);\n\tbegin\n\t\tfor i in 1 .. N loop\n\t\t\tL := (L(1), L(0)+L(1)+Step);\n\t\tend loop;\n\t\treturn L (0);\n\tend Leo;\n\nbegin\n   Put_Line (\"First 25 Leonardo numbers:\");\n   for I in 0 .. 24 loop\n      Put (Integer'Image (Leo (I)));\n   end loop;\n   New_Line;\n   Put_Line (\"First 25 Leonardo numbers with L(0) = 0, L(1) = 1, \" &\n             \"step = 0 (fibonacci numbers):\");\n   for I in 0 .. 24 loop\n      Put (Integer'Image (Leo (I, 0, 0, 1)));\n   end loop;\n   New_Line;\nend Leonardo;\n\n\nOutput:\nFirst 25 Leonardo numbers:\n 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nFirst 25 Leonardo numbers with L(0) = 0, L(1) = 1, step = 0 (fibonacci numbers):\n 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction L(n, add::Int=1, firsts::Vector=[1, 1])\n    l = max(maximum(n) .+ 1, length(firsts))\n    r = Vector{Int}(l)\n    r[1:length(firsts)] = firsts\n    for i in 3:l\n        r[i] = r[i - 1] + r[i - 2] + add\n    end\n    return r[n .+ 1]\nend\n\n# Task 1\nprintln(\"First 25 Leonardo numbers: \", join(L(0:24), \", \"))\n\n# Task 2\n@show L(0) L(1)\n\n# Task 4\nprintln(\"First 25 Leonardo numbers starting with [0, 1]: \", join(L(0:24, 0, [0, 1]), \", \"))\n\n\nOutput:\nFirst 25 Leonardo numbers: 1, 1, 3, 5, 9, 15, 25, 41, 67, 109, 177, 287, 465, 753, 1219, 1973, 3193, 5167, 8361, 13529, 21891, 35421, 57313, 92735, 150049\nL(0) = 1\nL(1) = 1\nFirst 25 Leonardo numbers starting with 0, 1: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, 144, 233, 377, 610, 987, 1597, 2584, 4181, 6765, 10946, 17711, 28657, 46368\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nfun leonardo(n: Int, l0: Int = 1, l1: Int = 1, add: Int = 1): IntArray {\n    val leo = IntArray(n)\n    leo[0] = l0\n    leo[1] = l1\n    for (i in 2 until n) leo[i] = leo[i - 1] + leo[i - 2] + add\n    return leo\n}\n\nfun main(args: Array<String>) {\n    println(\"The first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\")\n    println(leonardo(25).joinToString(\" \"))\n    println(\"\\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\")\n    println(leonardo(25, 0, 1, 0).joinToString(\" \"))\n}\n\n\nOutput:\nThe first 25 Leonardo numbers with L[0] = 1, L[1] = 1 and add number = 1 are:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n\nThe first 25 Leonardo numbers with L[0] = 0, L[1] = 1 and add number = 0 are:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nno warnings 'experimental::signatures';\nuse feature 'signatures';\n\nsub leonardo ($n, $l0 = 1, $l1 = 1, $add = 1) {\n  ($l0, $l1) = ($l1, $l0+$l1+$add)  for 1..$n;\n  $l0;\n}\n\nmy @L = map { leonardo($_) } 0..24;\nprint \"Leonardo[1,1,1]: @L\\n\";\nmy @F = map { leonardo($_,0,1,0) } 0..24;\nprint \"Leonardo[0,1,0]: @F\\n\";\n\n\nOutput:\nLeonardo[1,1,1]: 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nLeonardo[0,1,0]: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction leoNums (n, L0, L1, add)\n  local L0, L1, add = L0 or 1, L1 or 1, add or 1\n  local lNums, nextNum = {L0, L1}\n  while #lNums < n do\n    nextNum = lNums[#lNums] + lNums[#lNums - 1] + add\n    table.insert(lNums, nextNum)\n  end\n  return lNums\nend\n\nfunction show (msg, t)\n  print(msg .. \":\")\n  for i, x in ipairs(t) do\n    io.write(x .. \" \")\n  end\n  print(\"\\n\")\nend\n\nshow(\"Leonardo numbers\", leoNums(25))\nshow(\"Fibonacci numbers\", leoNums(25, 0, 1, 0))\n\n\nOutput:\nLeonardo numbers:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n\nFibonacci numbers:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef leo( n:Int, n1:Int=1, n2:Int=1, addnum:Int=1 ) : BigInt = n match {\n  case 0 => n1\n  case 1 => n2\n  case n => leo(n - 1, n1, n2, addnum) + leo(n - 2, n1, n2, addnum) + addnum\n}\n\n{\nprintln( \"The first 25 Leonardo Numbers:\")\n(0 until 25) foreach { n => print( leo(n) + \" \" ) }\n\nprintln( \"\\n\\nThe first 25 Fibonacci Numbers:\")\n(0 until 25) foreach { n => print( leo(n, n1=0, n2=1, addnum=0) + \" \" ) }\n}\n\n\nOutput:\nThe first 25 Leonardo Numbers:\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\n\nThe first 25 Fibonacci Numbers:\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nTranslation of: C++\nimport std.stdio;\n\nvoid main() {\n    write(\"Leonardo Numbers: \");\n    leonardoNumbers( 25 );\n\n    write(\"Fibonacci Numbers: \");\n    leonardoNumbers( 25, 0, 1, 0 );\n}\n\nvoid leonardoNumbers(int count, int l0=1, int l1=1, int add=1) {\n    int t;\n    for (int i=0; i<count; ++i) {\n        write(l0, \" \");\n        t = l0 + l1 + add;\n        l0 = l1;\n        l1 = t;\n    }\n    writeln();\n}\n\n\nOutput:\n\nLeonardo Numbers: 1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nFibonacci Numbers: 0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nimport Data.List (intercalate, unfoldr)\nimport Data.List.Split (chunksOf)\n\n--------------------- LEONARDO NUMBERS ---------------------\n-- L0 -> L1 -> Add number -> Series (infinite)\nleo :: Integer -> Integer -> Integer -> [Integer]\nleo l0 l1 d = unfoldr (\\(x, y) -> Just (x, (y, x + y + d))) (l0, l1)\n\nleonardo :: [Integer]\nleonardo = leo 1 1 1\n\nfibonacci :: [Integer]\nfibonacci = leo 0 1 0\n\n--------------------------- TEST ---------------------------\nmain :: IO ()\nmain =\n  (putStrLn . unlines)\n    [ \"First 25 default (1, 1, 1) Leonardo numbers:\\n\"\n    , f $ take 25 leonardo\n    , \"First 25 of the (0, 1, 0) Leonardo numbers (= Fibonacci numbers):\\n\"\n    , f $ take 25 fibonacci\n    ]\n  where\n    f = unlines . fmap (('\\t' :) . intercalate \",\") . chunksOf 16 . fmap show\n\n\nOutput:\nFirst 25 default (1, 1, 1) Leonardo numbers:\n\n    1,1,3,5,9,15,25,41,67,109,177,287,465,753,1219,1973\n    3193,5167,8361,13529,21891,35421,57313,92735,150049\n\nFirst 25 of the (0, 1, 0) Leonardo numbers (= Fibonacci numbers):\n\n    0,1,1,2,3,5,8,13,21,34,55,89,144,233,377,610\n    987,1597,2584,4181,6765,10946,17711,28657,46368\n\nleo :: Integer -> Integer -> Integer -> [Integer]\nleo l0 l1 d = s where\n  s = l0 : l1 : zipWith (\\x y -> x + y + d) s (tail s)\n\n", "explain": "Alternately, defining the list self-referentially instead of using unfoldr:\n"}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nTranslation of: Haskell\nopen System\n\nlet leo l0 l1 d =\n    Seq.unfold (fun (x, y) -> Some (x, (y, x + y + d))) (l0, l1)\n\nlet leonardo = leo 1 1 1\nlet fibonacci = leo 0 1 0\n\n[<EntryPoint>]\nlet main _ = \n    let leoNums = Seq.take 25 leonardo |> Seq.chunkBySize 16\n    printfn \"First 25 of the (1, 1, 1) Leonardo numbers:\\n%A\" leoNums\n    Console.WriteLine()\n\n    let fibNums = Seq.take 25 fibonacci |> Seq.chunkBySize 16\n    printfn \"First 25 of the (0, 1, 0) Leonardo numbers (= Fibonacci number):\\n%A\" fibNums\n\n    0 // return an integer exit code\n\n\nOutput:\nFirst 25 of the (1, 1, 1) Leonardo numbers:\nseq\n  [[|1; 1; 3; 5; 9; 15; 25; 41; 67; 109; 177; 287; 465; 753; 1219; 1973|];\n   [|3193; 5167; 8361; 13529; 21891; 35421; 57313; 92735; 150049|]]\n\nFirst 25 of the (0, 1, 0) Leonardo numbers (= Fibonacci number):\nseq\n  [[|0; 1; 1; 2; 3; 5; 8; 13; 21; 34; 55; 89; 144; 233; 377; 610|];\n   [|987; 1597; 2584; 4181; 6765; 10946; 17711; 28657; 46368|]]\n", "explain": ""}, {"task_name": "Leonardo numbers", "task_url": "https://rosettacode.org/wiki/Leonardo_numbers", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f LEONARDO_NUMBERS.AWK\nBEGIN {\n    leonardo(1,1,1,\"Leonardo\")\n    leonardo(0,1,0,\"Fibonacci\")\n    exit(0)\n}\nfunction leonardo(L0,L1,step,text,  i,tmp) {\n    printf(\"%s numbers (%d,%d,%d):\\n\",text,L0,L1,step)\n    for (i=1; i<=25; i++) {\n      if (i == 1) {\n        printf(\"%d \",L0)\n      }\n      else if (i == 2) {\n        printf(\"%d \",L1)\n      }\n      else {\n        printf(\"%d \",L0+L1+step)\n        tmp = L0\n        L0 = L1\n        L1 = tmp + L1 + step\n      }\n    }\n    printf(\"\\n\")\n}\n\n\nOutput:\nLeonardo numbers (1,1,1):\n1 1 3 5 9 15 25 41 67 109 177 287 465 753 1219 1973 3193 5167 8361 13529 21891 35421 57313 92735 150049\nFibonacci numbers (0,1,0):\n0 1 1 2 3 5 8 13 21 34 55 89 144 233 377 610 987 1597 2584 4181 6765 10946 17711 28657 46368\n\n", "explain": ""}]