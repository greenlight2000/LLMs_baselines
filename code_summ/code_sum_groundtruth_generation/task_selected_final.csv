task_name,task_url,task_cat,select,comments,task_description,Python,C,C++,Java,C sharp,JavaScript,Visual Basic .NET,SQL,PHP,MATLAB,Fortran,Scratch,Go,ARM Assembly,MIPS Assembly,X86 Assembly,Delphi,Object Pascal,Ruby,Rust,Swift,R,COBOL,Visual FoxPro,Visual Basic,Ada,Julia,SAS,Kotlin,Perl,Objective-C,Lisp,Prolog,Lua,Scala,Dart,Transact-SQL,D,Haskell,PL/SQL,VBScript,Scheme,Apex,TypeScript,PowerShell,Logo,ColdFusion,ABAP,F Sharp,Groovy,RPG,Zig,AWK,impl_lang_sum
Guess the number,https://rosettacode.org/wiki/Guess_the_number,Randomness,True,,"
Task

Write a program where the program chooses a number between   1   and   10. 
A player is then prompted to enter a guess.   If the player guesses wrong,   then the prompt appears again until the guess is correct. 
When the player has made a successful guess the computer will issue a   ""Well guessed!""   message,   and the program exits.
A   conditional loop   may be used to repeat the guessing until the user is correct.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,36.0
Letter frequency,https://rosettacode.org/wiki/Letter_frequency,Randomness,True,,"
Task

Open a text file and count the occurrences of each letter.
Some of these programs count all characters (including punctuation), 
but some only count letters A to Z.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,31.0
Pick random element,https://rosettacode.org/wiki/Pick_random_element,Randomness,True,maybe too simple?,"
Demonstrate how to pick a random element from a list.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,32.0
Random numbers,https://rosettacode.org/wiki/Random_numbers,Randomness,True,task description contains 'if' statement about language feature,"
Task

Generate a collection filled with   1000   normally distributed random (or pseudo-random) numbers 
with a mean of   1.0   and a   standard deviation   of   0.5
Many libraries only generate uniformly distributed random numbers. If so, you may use one of these algorithms.

Related task

  Standard deviation


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Ackermann function,https://rosettacode.org/wiki/Ackermann_function,Classic CS problems and programs,True,contains knowledge of classic algorithm that is hard to describe,"
The Ackermann function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. It grows very quickly in value, as does the size of its call tree. 

The Ackermann function is usually defined as follows:






A
(
m
,
n
)
=

{



n
+
1



if 

m
=
0




A
(
m
−
1
,
1
)



if 

m
>
0

 and 

n
=
0




A
(
m
−
1
,
A
(
m
,
n
−
1
)
)



if 

m
>
0

 and 

n
>
0.







{\displaystyle  A(m, n) =
 \begin{cases}
 n+1 & \mbox{if } m = 0 \\
 A(m-1, 1) & \mbox{if } m > 0 \mbox{ and } n = 0 \\
 A(m-1, A(m, n-1)) & \mbox{if } m > 0 \mbox{ and } n > 0.
 \end{cases}
}




Its arguments are never negative and it always terminates.


Task

Write a function which returns the value of 



A
(
m
,
n
)


{\displaystyle A(m, n)}

. Arbitrary precision is preferred (since the function grows so quickly), but not required.


See also

Conway chained arrow notation for the Ackermann function.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,39.0
Binary search,https://rosettacode.org/wiki/Binary_search,Classic CS problems and programs,True,,"
A binary search divides a range of values into halves, and continues to narrow down the field of search until the unknown value is found. It is the classic example of a ""divide and conquer"" algorithm.
As an analogy, consider the children's game ""guess a number.""  The scorer has a secret number, and will only tell the player if their guessed number is higher than, lower than, or equal to the secret number. The player then uses this information to guess a new number.
As the player, an optimal strategy for the general case is to start by choosing the range's midpoint as the guess, and then asking whether the guess was higher, lower, or equal to the secret number. If the guess was too high, one would select the point exactly between the range midpoint and the beginning of the range. If the original guess was too low, one would ask about the point exactly between the range midpoint and the end of the range. This process repeats until one has reached the secret number.


Task

Given the starting point of a range, the ending point of a range, and the ""secret value"", implement a binary search through a sorted integer array for a certain number. Implementations can be recursive or iterative (both if you can). Print out whether or not the number was in the array afterwards. If it was, print the index also.
There are several binary search algorithms commonly seen. They differ by how they treat multiple values equal to the given value, and whether they indicate whether the element was found or not. For completeness we will present pseudocode for all of them.
All of the following code examples use an ""inclusive"" upper bound (i.e. high = N-1 initially). Any of the examples can be converted into an equivalent example using ""exclusive"" upper bound (i.e. high = N initially) by making the following simple changes (which simply increase high by 1):

change high = N-1 to high = N
change high = mid-1 to high = mid
(for recursive algorithm) change if (high < low) to if (high <= low)
(for iterative algorithm) change while (low <= high) to while (low < high)
Traditional algorithm
The algorithms are as follows (from Wikipedia). The algorithms return the index of some element that equals the given value (if there are multiple such elements, it returns some arbitrary one). It is also possible, when the element is not found, to return the ""insertion point"" for it (the index that the value would have if it were inserted into the array).
Recursive Pseudocode:

  // initially called with low = 0, high = N-1
  BinarySearch(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return not_found // value would be inserted at index ""low""
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch(A, value, low, mid-1)
      else if (A[mid] < value)
          return BinarySearch(A, value, mid+1, high)
      else
          return mid
  }

Iterative Pseudocode:

  BinarySearch(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else if (A[mid] < value)
              low = mid + 1
          else
              return mid
      }
      return not_found // value would be inserted at index ""low""
  }

Leftmost insertion point
The following algorithms return the leftmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the lower (inclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than or equal to the given value (since if it were any lower, it would violate the ordering), or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level.
Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Left(A[0..N-1], value, low, high) {
      // invariants: value > A[i] for all i < low
                     value <= A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] >= value)
          return BinarySearch_Left(A, value, low, mid-1)
      else
          return BinarySearch_Left(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Left(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value > A[i] for all i < low
                         value <= A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] >= value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Rightmost insertion point
The following algorithms return the rightmost place where the given element can be correctly inserted (and still maintain the sorted order). This is the upper (exclusive) bound of the range of elements that are equal to the given value (if any). Equivalently, this is the lowest index where the element is greater than the given value, or 1 past the last index if such an element does not exist. This algorithm does not determine if the element is actually found. This algorithm only requires one comparison per level. Note that these algorithms are almost exactly the same as the leftmost-insertion-point algorithms, except for how the inequality treats equal values.
Recursive Pseudocode:

  // initially called with low = 0, high = N - 1
  BinarySearch_Right(A[0..N-1], value, low, high) {
      // invariants: value >= A[i] for all i < low
                     value < A[i] for all i > high
      if (high < low)
          return low
      mid = (low + high) / 2
      if (A[mid] > value)
          return BinarySearch_Right(A, value, low, mid-1)
      else
          return BinarySearch_Right(A, value, mid+1, high)
  }

Iterative Pseudocode:

  BinarySearch_Right(A[0..N-1], value) {
      low = 0
      high = N - 1
      while (low <= high) {
          // invariants: value >= A[i] for all i < low
                         value < A[i] for all i > high
          mid = (low + high) / 2
          if (A[mid] > value)
              high = mid - 1
          else
              low = mid + 1
      }
      return low
  }

Extra credit
Make sure it does not have overflow bugs.
The line in the pseudo-code above to calculate the mean of two integers:

mid = (low + high) / 2
could produce the wrong result in some programming languages when used with a bounded integer type, if the addition causes an overflow. (This can occur if the array size is greater than half the maximum integer value.) If signed integers are used, and low + high overflows, it becomes a negative number, and dividing by 2 will still result in a negative number. Indexing an array with a negative number could produce an out-of-bounds exception, or other undefined behavior. If unsigned integers are used, an overflow will result in losing the largest bit, which will produce the wrong result.
One way to fix it is to manually add half the range to the low number:

mid = low + (high - low) / 2
Even though this is mathematically equivalent to the above, it is not susceptible to overflow.
Another way for signed integers, possibly faster, is the following:

mid = (low + high) >>> 1
where  >>>  is the logical right shift operator. The reason why this works is that, for signed integers, even though it overflows, when viewed as an unsigned number, the value is still the correct sum. To divide an unsigned number by 2, simply do a logical right shift.


Related task

Guess the number/With Feedback (Player)


See also

wp:Binary search algorithm
Extra, Extra - Read All About It: Nearly All Binary Searches and Mergesorts are Broken.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Closest-pair problem,https://rosettacode.org/wiki/Closest-pair_problem,Classic CS problems and programs,True,,"


This page uses content from Wikipedia. The original article was at Closest pair of points problem. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Provide a function to find the closest two points among a set of given points in two dimensions,   i.e. to solve the   Closest pair of points problem   in the   planar   case.
The straightforward solution is a   O(n2)   algorithm   (which we can call brute-force algorithm);   the pseudo-code (using indexes) could be simply:

bruteForceClosestPair of P(1), P(2), ... P(N)
if N < 2 then
  return ∞
else
  minDistance ← |P(1) - P(2)|
  minPoints ← { P(1), P(2) }
  foreach i ∈ [1, N-1]
    foreach j ∈ [i+1, N]
      if |P(i) - P(j)| < minDistance then
        minDistance ← |P(i) - P(j)|
        minPoints ← { P(i), P(j) } 
      endif
    endfor
  endfor
  return minDistance, minPoints
 endif

A better algorithm is based on the recursive divide&conquer approach,   as explained also at   Wikipedia's Closest pair of points problem,   which is   O(n log n);   a pseudo-code could be:

closestPair of (xP, yP)
               where xP is P(1) .. P(N) sorted by x coordinate, and
                     yP is P(1) .. P(N) sorted by y coordinate (ascending order)
if N ≤ 3 then
  return closest points of xP using brute-force algorithm
else
  xL ← points of xP from 1 to ⌈N/2⌉
  xR ← points of xP from ⌈N/2⌉+1 to N
  xm ← xP(⌈N/2⌉)x
  yL ← { p ∈ yP : px ≤ xm }
  yR ← { p ∈ yP : px > xm }
  (dL, pairL) ← closestPair of (xL, yL)
  (dR, pairR) ← closestPair of (xR, yR)
  (dmin, pairMin) ← (dR, pairR)
  if dL < dR then
    (dmin, pairMin) ← (dL, pairL)
  endif
  yS ← { p ∈ yP : |xm - px| < dmin }
  nS ← number of points in yS
  (closest, closestPair) ← (dmin, pairMin)
  for i from 1 to nS - 1
    k ← i + 1
    while k ≤ nS and yS(k)y - yS(i)y < dmin
      if |yS(k) - yS(i)| < closest then
        (closest, closestPair) ← (|yS(k) - yS(i)|, {yS(k), yS(i)})
      endif
      k ← k + 1
    endwhile
  endfor
  return closest, closestPair
endif



References and further readings

  Closest pair of points problem
  Closest Pair (McGill)
  Closest Pair (UCSB)
  Closest pair (WUStL)
  Closest pair (IUPUI)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,27.0
Factorial,https://rosettacode.org/wiki/Factorial,Classic CS problems and programs,True,,"
Definitions

  The factorial of   0   (zero)   is defined as being   1   (unity).
  The   Factorial Function   of a positive integer,    n,    is defined as the product of the sequence:
                 n,   n-1,   n-2,   ...   1 



Task

Write a function to return the factorial of a number. 
Solutions can be iterative or recursive. 
Support for trapping negative    n    errors is optional.


Related task

  Primorial numbers


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,38.0
Fibonacci sequence,https://rosettacode.org/wiki/Fibonacci_sequence,Classic CS problems and programs,True,,"
The Fibonacci sequence is a sequence    Fn     of natural numbers defined recursively: 

      F0 = 0 
      F1 = 1 
      Fn = Fn-1 + Fn-2, if n>1 



Task

Write a function to generate the    nth    Fibonacci number. 
Solutions can be iterative or recursive (though recursive solutions are generally considered too slow and are mostly used as an exercise in recursion).
The sequence is sometimes extended into negative numbers by using a straightforward inverse of the positive definition:

      Fn = Fn+2 - Fn+1, if n<0   

support for negative      n      in the solution is optional.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,40.0
FizzBuzz,https://rosettacode.org/wiki/FizzBuzz,Classic CS problems and programs,True,,"
Task

Write a program that prints the integers from   1   to   100   (inclusive). 

But:

  for multiples of three,   print   Fizz     instead of the number;
  for multiples of five,   print   Buzz     instead of the number;
  for multiples of both three and five,   print   FizzBuzz     instead of the number.

The   FizzBuzz   problem was presented as the lowest level of comprehension required to illustrate adequacy.


Also see

  (a blog)   dont-overthink-fizzbuzz
  (a blog)   fizzbuzz-the-programmers-stairway-to-heaven


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,44.0
General FizzBuzz,https://rosettacode.org/wiki/General_FizzBuzz,Classic CS problems and programs,True,,"
Task

Write a generalized version of FizzBuzz that works for any list of factors, along with their words. 
This is basically a ""fizzbuzz"" implementation where the user supplies the parameters. 
The user will enter the max number, then they will enter the factors to be calculated along with the corresponding word to be printed.
For simplicity's sake, assume the user will input an integer as the max number and 3 factors, each with a word associated with them.

For example, given:

>20      #This is the maximum number, supplied by the user
>3 Fizz  #The user now enters the starting factor (3) and the word they want associated with it (Fizz)
>5 Buzz  #The user now enters the next factor (5) and the word they want associated with it (Buzz)
>7 Baxx  #The user now enters the next factor (7) and the word they want associated with it (Baxx)

In other words: For this example, print the numbers 1 through 20, replacing every multiple of 3 with ""Fizz"", every multiple of 5 with ""Buzz"", and every multiple of 7 with ""Baxx"". 
In the case where a number is a multiple of at least two factors, print each of the words associated with those factors in the order of least to greatest factor. 
For instance, the number 15 is a multiple of both 3 and 5; print ""FizzBuzz"".
If the max number was 105 instead of 20, you would print ""FizzBuzzBaxx"" because it's a multiple of 3, 5, and 7.


Output:
1
2
Fizz
4
Buzz
Fizz
Baxx
8
Fizz
Buzz
11
Fizz
13
Baxx
FizzBuzz
16
17
Fizz
19
Buzz



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,27.0
Jensen's Device,https://rosettacode.org/wiki/Jensen%27s_Device,Classic CS problems and programs,True,don't understand,"

This page uses content from Wikipedia. The original article was at Jensen's Device. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


This task is an exercise in call by name.
Jensen's Device is a computer programming technique devised by Danish computer scientist Jørn Jensen after studying the ALGOL 60 Report.
The following program was proposed to illustrate the technique. It computes the 100th harmonic number:

begin
   integer i;
   real procedure sum (i, lo, hi, term);
      value lo, hi;
      integer i, lo, hi;
      real term;
      comment term is passed by-name, and so is i;
   begin
      real temp;
      temp := 0;
      for i := lo step 1 until hi do
         temp := temp + term;
      sum := temp
   end;
   comment note the correspondence between the mathematical notation and the call to sum;
   print (sum (i, 1, 100, 1/i))
end

The above exploits call by name to produce the correct answer (5.187...). It depends on the assumption that an expression passed as an actual parameter to a procedure would be re-evaluated in the caller's context every time the corresponding formal parameter's value was required. If the last parameter to sum had been passed by value, and assuming the initial value of i were 1, the result would have been 100 × 1/1 = 100.
Moreover, the first parameter to sum, representing the ""bound"" variable of the summation, must also be passed by name (or at least by reference), otherwise changes to it (made within sum) would not be visible in the caller's context when computing each of the values to be added.
(On the other hand, the global variable does not have to use the same identifier, in this case i, as the formal parameter.)
Donald Knuth later proposed the Man or Boy Test as a more rigorous exercise.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,27.0
Knapsack problem/0-1,https://rosettacode.org/wiki/Knapsack_problem/0-1,Classic CS problems and programs,True,"hard, need semantic/scenario understanding for code","
A tourist wants to make a good trip at the weekend with his friends. 
They will go to the mountains to see the wonders of nature, so he needs to pack well for the trip. 
He has a good knapsack for carrying things, but knows that he can carry a maximum of only 4kg in it,    and it will have to last the whole day. 
He creates a list of what he wants to bring for the trip but the total weight of all items is too much. 
He then decides to add columns to his initial list detailing their weights and a numerical value representing how important the item is for the trip.

Here is the list:


Table of potential knapsack items


item
weight (dag)
value


map
9
150


compass
13
35


water
153
200


sandwich
50
160


glucose
15
60


tin
68
45


banana
27
60


apple
39
40


cheese
23
30


beer
52
10


suntan cream
11
70


camera
32
30


T-shirt
24
15


trousers
48
10


umbrella
73
40


waterproof trousers
42
70


waterproof overclothes
43
75


note-case
22
80


sunglasses
7
20


towel
18
12


socks
4
50


book
30
10


knapsack
≤400 dag
?


The tourist can choose to take any combination of items from the list, 
but only one of each item is available. 
He may not cut or diminish the items, so he can only take whole units of any item.


Task

Show which items the tourist can carry in his knapsack so that their total weight does not 
exceed 400 dag [4 kg],   and their total value is maximized.
[dag = decagram = 10 grams]


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,31.0
Knapsack problem/Continuous,https://rosettacode.org/wiki/Knapsack_problem/Continuous,Classic CS problems and programs,True,"hard, need semantic/scenario understanding for code","

A thief burgles a butcher's shop, where he can select from some items.
The thief knows the weights and prices of each items.   Because he has a knapsack with 15 kg maximal capacity, he wants to select the items such that he would have his profit maximized.   He may cut the items;   the item has a reduced price after cutting that is proportional to the original price by the ratio of masses.   That means:   half of an item has half the price of the original.

This is the item list in the butcher's shop:


Table of potential knapsack items


Item
Weight (kg)
Price (Value)


beef
3.8
36


pork
5.4
43


ham
3.6
90


greaves
2.4
45


flitch
4.0
30


brawn
2.5
56


welt
3.7
67


salami
3.0
95


sausage
5.9
98


Knapsack
<=15 kg
?




Task

Show which items the thief carries in his knapsack so that their total weight does not exceed 15 kg, and their total value is maximized.


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,24.0
Knuth shuffle,https://rosettacode.org/wiki/Knuth_shuffle,Classic CS problems and programs,True,contains knowledge of classic algorithm,"
The   Knuth shuffle   (a.k.a. the Fisher-Yates shuffle)   is an algorithm for randomly shuffling the elements of an array.


Task

Implement the Knuth shuffle for an integer array (or, if possible, an array of any type).


Specification

Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

       for i from last downto 1 do:
           let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq}
  
 j 
  
    
      
        ≤
      
    
    {\displaystyle \leq}
  
 i
           swap items[i] with items[j]

Notes

  It modifies the input array in-place.
  If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
  The algorithm can also be amended to iterate from left to right, if that is more convenient.


Test cases



Input array

Possible output arrays


[]

[]


[10]

[10]


[10, 20]

[10, 20][20, 10]


[10, 20, 30]

[10, 20, 30][10, 30, 20][20, 10, 30][20, 30, 10][30, 10, 20][30, 20, 10]

(These are listed here just for your convenience; no need to demonstrate them on the page.)


Related task

Sattolo cycle



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,34.0
Leonardo numbers,https://rosettacode.org/wiki/Leonardo_numbers,Classic CS problems and programs,True,contains knowledge of classic algorithm,"

Leonardo numbers   are also known as the   Leonardo series.

The   Leonardo numbers   are a sequence of numbers defined by:

       L(0) = 1                                          [1st equation]  
       L(1) = 1                                          [2nd equation]  
       L(n) = L(n-1)  +    L(n-2)   +  1                 [3rd equation]  
                    ─── also ───
       L(n) =      2  *  Fib(n+1)   -  1                 [4th equation]  

  where the   + 1   will herein be known as the   add   number.
  where the   FIB   is the   Fibonacci numbers.

This task will be using the 3rd equation (above) to calculate the Leonardo numbers.

Edsger W. Dijkstra   used   Leonardo numbers   as an integral part of
his   smoothsort   algorithm.

The first few Leonardo numbers are:

    1   1   3   5   9   15   25   41   67   109   177   287   465   753   1219   1973   3193   5167   8361  ··· 



Task

  show the 1st   25   Leonardo numbers, starting at L(0).
  allow the first two Leonardo numbers to be specified   [for L(0) and L(1)].
  allow the   add   number to be specified   (1 is the default).
  show the 1st   25   Leonardo numbers, specifying 0 and 1 for L(0) and L(1), and 0 for the add number.
(The last task requirement will produce the Fibonacci numbers.)

Show all output here on this page.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,24.0
Nth root,https://rosettacode.org/wiki/Nth_root,Classic CS problems and programs,True,,"
Task

Implement the algorithm to compute the principal   nth   root   




A
n



{\displaystyle \sqrt[n]A}

   of a positive real number   A,   as explained at the   Wikipedia page.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Order two numerical lists,https://rosettacode.org/wiki/Order_two_numerical_lists,Classic CS problems and programs,True,,"Tasks in this category have to do with sorting collections of objects.

Write a function that orders two lists or arrays filled with numbers.
The function should accept two lists as arguments and return true if the first list should be ordered before the second, and false otherwise.
The order is determined by lexicographic order: Comparing the first element of each list. 
If the first elements are equal, then the second elements should be compared, and so on, until one of the list has no more elements. 
If the first list runs out of elements the result is true. 
If the second list or both run out of elements the result is false.
Note: further clarification of lexicographical ordering is expounded on the talk page here and here.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,26.0
Palindrome detection,https://rosettacode.org/wiki/Palindrome_detection,Classic CS problems and programs,True,,"
A palindrome is a phrase which reads the same backward and forward.

Task[|_}}%20*%2F%20 edit]
Write a function or program that checks whether a given sequence of characters (or, if you prefer, bytes) 
is a palindrome.
For extra credit:

Support Unicode characters.
Write a second function (possibly as a wrapper to the first) which detects inexact palindromes, i.e. phrases that are palindromes if white-space and punctuation is ignored and case-insensitive comparison is used.
Hints
It might be useful for this task to know how to reverse a string.
This task's entries might also form the subjects of the task Test a function.
",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,39.0
Stack,https://rosettacode.org/wiki/Stack,Classic CS problems and programs,True,,"

A stack is a container of elements with   last in, first out    access policy.   Sometimes it also called LIFO. 
The stack is accessed through its top. 
The basic stack operations are:

  push   stores a new element onto the stack top;
  pop   returns the last pushed stack element, while removing it from the stack;
  empty   tests if the stack contains no elements.

Sometimes the last pushed stack element is made accessible for immutable access (for read) or mutable access (for write):

  top   (sometimes called peek to keep with the p theme) returns the topmost element without modifying the stack.

Stacks allow a very simple hardware implementation.
They are common in almost all processors.
In programming, stacks are also very popular for their way (LIFO) of resource management, usually memory. 
Nested scopes of language objects are naturally implemented by a stack (sometimes by multiple stacks). 
This is a classical way to implement local variables of a re-entrant or recursive subprogram. Stacks are also used to describe a formal computational framework. 
See stack machine. 
Many algorithms in pattern matching, compiler construction (e.g. recursive descent parsers), and machine learning (e.g. based on tree traversal) have a natural representation in terms of stacks.


Task

Create a stack supporting the basic operations: push, pop, empty.


See also

Array
Associative array: Creation, Iteration
Collections
Compound data type
Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
Linked list
Queue: Definition, Usage
Set
Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
Stack


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,36.0
Sudan function,https://rosettacode.org/wiki/Sudan_function,Classic CS problems and programs,True,implement classic function,"
The Sudan function is a classic example of a recursive function, notable especially because it is not a primitive recursive function. This is also true of the better-known Ackermann function. The Sudan function was the first function having this property to be published.
The Sudan function is usually defined as follows (svg):








F
0

(
x
,
y
)


=
x
+
y





F

n
+
1


(
x
,
0
)


=
x


if 
n
≥
0





F

n
+
1


(
x
,
y
+
1
)


=

F
n

(

F

n
+
1


(
x
,
y
)
,

F

n
+
1


(
x
,
y
)
+
y
+
1
)


if 
n
≥
0





{\displaystyle \begin{array}{lll}
      F_0 (x, y) & = x+y \\
      F_{n+1} (x, 0) & = x & \text{if } n \ge 0 \\
      F_{n+1} (x, y+1) & = F_n (F_{n+1} (x, y), F_{n+1} (x, y) + y + 1) & \text{if } n\ge 0 \\
      \end{array}
    }



Task

Write a function which returns the value of F(x, y).

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,20.0
Towers of Hanoi,https://rosettacode.org/wiki/Towers_of_Hanoi,Classic CS problems and programs,True,,"
Task

Solve the   Towers of Hanoi   problem with recursion.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,38.0
Munching squares,https://rosettacode.org/wiki/Munching_squares,Graphics algorithms,True,graphic algorithm,"
Render a graphical pattern where each pixel is colored by the value of 'x xor y' from an arbitrary color table.

",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,21.0
Averages/Median,https://rosettacode.org/wiki/Averages/Median,Sorting,True,,"
Task
Write a program to find the   median   value of a vector of floating-point numbers. 
The program need not handle the case where the vector is empty, but must handle the case where there are an even number of elements.   In that case, return the average of the two middle values.
There are several approaches to this.   One is to sort the elements, and then pick the element(s) in the middle. 
Sorting would take at least   O(n logn).   Another approach would be to build a priority queue from the elements, and then extract half of the elements to get to the middle element(s).   This would also take   O(n logn).   The best solution is to use the   selection algorithm   to find the median in   O(n)   time.

See also
Quickselect_algorithm

Tasks for calculating statistical measures



in one go
moving (sliding window)
moving (cumulative)

Mean
Arithmetic

Statistics/Basic
Averages/Arithmetic mean
Averages/Pythagorean means


Averages/Simple moving average




Geometric

Averages/Pythagorean means




Harmonic

Averages/Pythagorean means




Quadratic

Averages/Root mean square




Circular

Averages/Mean angle
Averages/Mean time of day




Median

Averages/Median




Mode

Averages/Mode




Standard deviation

Statistics/Basic



Cumulative standard deviation




",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,30.0
Common sorted list,https://rosettacode.org/wiki/Common_sorted_list,Sorting,True,,"

Given an integer array nums, the goal is create common sorted list with unique elements.


Example

nums = [5,1,3,8,9,4,8,7], [3,5,9,8,4], [1,3,7,9]
output = [1,3,4,5,7,8,9]


",1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,12.0
Ranking methods,https://rosettacode.org/wiki/Ranking_methods,Sorting,True,,"

The numerical rank of competitors in a competition shows if one is better than, equal to, or worse than another based on their results in a competition.
The numerical rank of a competitor can be assigned in several different ways.


Task

The following scores are accrued for all competitors of a competition (in best-first order):

44 Solomon
42 Jason
42 Errol
41 Garry
41 Bernard
41 Barry
39 Stephen
For each of the following ranking methods, create a function/method/procedure/subroutine... that applies the ranking method to an ordered list of scores with scorers:

Standard. (Ties share what would have been their first ordinal number).
Modified. (Ties share what would have been their last ordinal number).
Dense. (Ties share the next available integer).
Ordinal. ((Competitors take the next available integer. Ties are not treated otherwise).
Fractional. (Ties share the mean of what would have been their ordinal numbers).

See the wikipedia article for a fuller description.
Show here, on this page, the ranking of the test scores under each of the numbered ranking methods.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,17.0
Remove duplicate elements,https://rosettacode.org/wiki/Remove_duplicate_elements,Sorting,True,,"

Given an Array, derive a sequence of elements in which all duplicates are removed.
There are basically three approaches seen here:

Put the elements into a hash table which does not allow duplicates. The complexity is O(n) on average, and O(n2) worst case. This approach requires a hash function for your type (which is compatible with equality), either built-in to your language, or provided by the user.
Sort the elements and remove consecutive duplicate elements. The complexity of the best sorting algorithms is O(n log n). This approach requires that your type be ""comparable"", i.e., have an ordering. Putting the elements into a self-balancing binary search tree is a special case of sorting.
Go through the list, and for each element, check the rest of the list to see if it appears again, and discard it if it does. The complexity is O(n2). The up-shot is that this always works on any type (provided that you can test for equality).


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Rosetta Code/Rank languages by popularity,https://rosettacode.org/wiki/Rosetta_Code/Rank_languages_by_popularity,Sorting,True,,"


Task

Sort the most popular computer programming languages based in number of members in Rosetta Code categories.
Sample output on 02 August 2022 at 09:50 +02

Rank:  1 (1,565 entries) Phix
Rank:  2 (1,558 entries) Wren
Rank:  3 (1,531 entries) Julia
Rank:  4 (1,507 entries) Raku
Rank:  5 (1,500 entries) Go
Rank:  6 (1,466 entries) Perl
Rank:  7 (1,409 entries) Python
Rank:  8 (1,402 entries) Nim
Rank:  9 (1,254 entries) J
Rank: 10 (1,211 entries) C
...


Notes

  Each language typically demonstrates one or two methods of accessing the data:
  with web scraping   (via http://www.rosettacode.org/mw/index.php?title=Special:Categories&limit=5000)
  with the API method   (examples below for Awk, Perl, Ruby, Tcl, etc).
  The scraping and API solutions can be separate subsections, see the Tcl example.
  Filtering wrong results is optional.   You can check against Special:MostLinkedCategories (if using web scraping)
If you use the API, and do elect to filter, you may check your results against this  complete, accurate, sortable, wikitable listing of all 916 programming languages, updated periodically, typically weekly.
  A complete ranked listing of all                                 813                              languages (from the REXX example) is included here   ──►   output from the REXX program.


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,21.0
Sort a list of object identifiers,https://rosettacode.org/wiki/Sort_a_list_of_object_identifiers,Sorting,True,network data processing,"

Object identifiers (OID) are strings used to identify objects in network data.


Task

Show how to sort a list of OIDs, in their natural sort order.

Details
An OID consists of one or more non-negative integers in base 10, separated by dots. It starts and ends with a number.
Their natural sort order is lexicographical with regard to the dot-separated fields, using numeric comparison between fields.
Test case


Input (list of strings)

Output (list of strings)



1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11150.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11150.3.4.0



1.3.6.1.4.1.11.2.17.5.2.0.79
1.3.6.1.4.1.11.2.17.19.3.4.0.1
1.3.6.1.4.1.11.2.17.19.3.4.0.4
1.3.6.1.4.1.11.2.17.19.3.4.0.10
1.3.6.1.4.1.11150.3.4.0
1.3.6.1.4.1.11150.3.4.0.1


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,18.0
Sort an array of composite structures,https://rosettacode.org/wiki/Sort_an_array_of_composite_structures,Sorting,True,,"

Sort an array of composite structures by a key. 

For example, if you define a composite structure that presents a name-value pair (in pseudo-code):

Define structure pair such that: 
   name as a string
   value as a string

and an array of such pairs:

   x: array of pairs

then define a sort routine that sorts the array x by the key name.
This task can always be accomplished with Sorting Using a Custom Comparator. 
If your language is not listed here, please see the other article.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,28.0
Rot-13,https://rosettacode.org/wiki/Rot-13,Encryption,True,,"


Task

Implement a   rot-13   function   (or procedure, class, subroutine, or other ""callable"" object as appropriate to your programming environment). 
Optionally wrap this function in a utility program   (like tr,   which acts like a common UNIX utility, performing a line-by-line rot-13 encoding of every line of input contained in each file listed on its command line,   or (if no filenames are passed thereon) acting as a filter on its   ""standard input."" 

(A number of UNIX scripting languages and utilities, such as   awk   and   sed   either default to processing files in this way or have command line switches or modules to easily implement these wrapper semantics, e.g.,   Perl   and   Python).
The   rot-13   encoding is commonly known from the early days of Usenet ""Netnews"" as a way of obfuscating text to prevent casual reading of   spoiler   or potentially offensive material. 
Many news reader and mail user agent programs have built-in rot-13 encoder/decoders or have the ability to feed a message through any external utility script for performing this (or other) actions.
The definition of the rot-13 function is to simply replace every letter of the ASCII alphabet with the letter which is ""rotated"" 13 characters ""around"" the 26 letter alphabet from its normal cardinal position   (wrapping around from   z   to   a   as necessary). 
Thus the letters   abc   become   nop   and so on. 
Technically rot-13 is a   ""mono-alphabetic substitution cipher""   with a trivial   ""key"". 
A proper implementation should work on upper and lower case letters, preserve case, and pass all non-alphabetic characters 
in the input stream through without alteration.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,39.0
Vigenère cipher,https://rosettacode.org/wiki/Vigen%C3%A8re_cipher,Encryption,True,contains knowledge of classic algorithm that is hard to describe,"
Task

Implement a   Vigenère cypher,   both encryption and decryption. 
The program should handle keys and text of unequal length, 
and should capitalize everything and discard non-alphabetic characters. 
(If your program handles non-alphabetic characters in another way, 
make a note of it.)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,27.0
Huffman coding,https://rosettacode.org/wiki/Huffman_coding,Compression,True,,"
Huffman encoding is a way to assign binary codes to symbols that reduces the overall number of bits used to encode a typical string of those symbols.
For example, if you use letters as symbols and have details of the frequency of occurrence of those letters in typical strings, then you could just encode each letter with a fixed number of bits, such as in ASCII codes. You can do better than this by encoding more frequently occurring letters such as e and a, with smaller bit strings; and  less frequently occurring letters such as q and x with longer bit strings.
Any string of letters will be encoded as a string of bits that are no-longer of the same length per letter. To successfully decode such as string, the  smaller codes assigned to letters such as 'e' cannot occur as a prefix in the larger codes such as that for 'x'.

If you were to assign a code 01 for 'e' and code 011 for 'x', then if the bits to decode started as 011... then you would not know if you should decode an 'e' or an 'x'.
The Huffman coding scheme takes each symbol and its weight (or frequency of occurrence), and generates proper encodings for each symbol taking account of the weights of each symbol, so that higher weighted symbols have fewer bits in their encoding. (See the WP article for more information).
A Huffman encoding can be computed by first creating a tree of nodes:


Create a leaf node for each symbol and add it to the priority queue.
While there is more than one node in the queue:
Remove the node of highest priority (lowest probability) twice to get two nodes.
Create a new internal node with these two nodes as children and with probability equal to the sum of the two nodes' probabilities.
Add the new node to the queue.
The remaining node is the root node and the tree is complete.

Traverse the constructed binary tree from root to leaves assigning and accumulating a '0' for one branch and a '1' for the other at each node. The accumulated  zeros and ones at each leaf constitute a Huffman encoding for those symbols and weights:


Task

Using the characters and their frequency from the string:

    this is an example for huffman encoding  
create a program to generate a Huffman encoding for each character as a table.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,27.0
Run-length encoding,https://rosettacode.org/wiki/Run-length_encoding,Compression,True,,"

This page uses content from Wikipedia. The original article was at Run-length_encoding. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Given a string containing uppercase characters (A-Z), compress repeated 'runs' of the same character by storing the length of that run, and provide a function to reverse the compression. 
The output can be anything, as long as you can recreate the input with it.


Example

Input:  WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW
Output: 12W1B12W3B24W1B14W

Note: the encoding step in the above example is the same as a step of the Look-and-say sequence.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,33.0
Draw a cuboid,https://rosettacode.org/wiki/Draw_a_cuboid,3D,True,,"
Task

Draw a   cuboid   with relative dimensions of    2 × 3 × 4. 

The cuboid can be represented graphically, or in   ASCII art,   depending on the language capabilities. 
To fulfill the criteria of being a cuboid, three faces must be visible. 
Either static or rotational projection is acceptable for this task.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,23.0
Draw a sphere,https://rosettacode.org/wiki/Draw_a_sphere,3D,True,,"
Task

Draw a sphere. 
The sphere can be represented graphically, or in ASCII art, depending on the language capabilities. 
Either static or rotational projection is acceptable for this task.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,24.0
4-rings or 4-squares puzzle,https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle,Puzzles,True,,"


Task

Replace       a, b, c, d, e, f,   and
  g        with the decimal
digits   LOW   ───►   HIGH
such that the sum of the letters inside of each of the four large squares add up to
the same sum.

            ╔══════════════╗      ╔══════════════╗
            ║              ║      ║              ║
            ║      a       ║      ║      e       ║
            ║              ║      ║              ║
            ║          ┌───╫──────╫───┐      ┌───╫─────────┐
            ║          │   ║      ║   │      │   ║         │
            ║          │ b ║      ║ d │      │ f ║         │
            ║          │   ║      ║   │      │   ║         │
            ║          │   ║      ║   │      │   ║         │
            ╚══════════╪═══╝      ╚═══╪══════╪═══╝         │
                       │       c      │      │      g      │
                       │              │      │             │
                       │              │      │             │
                       └──────────────┘      └─────────────┘

Show all output here.


  Show all solutions for each letter being unique with
        LOW=1     HIGH=7

  Show all solutions for each letter being unique with
        LOW=3     HIGH=9

  Show only the   number   of solutions when each letter can be non-unique
        LOW=0     HIGH=9



Related task

Solve the no connection puzzle


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,30.0
Department numbers,https://rosettacode.org/wiki/Department_numbers,Puzzles,True,,"
There is a highly organized city that has decided to assign a number to each of their departments:

  police department
  sanitation department
  fire department

Each department can have a number between   1   and   7   (inclusive).
The three department numbers are to be unique (different from each other) and must add up to   12.
The Chief of the Police doesn't like odd numbers and wants to have an even number for his department.


Task

Write a computer program which outputs all valid combinations.

Possible output   (for the 1st and 14th solutions):

 --police--  --sanitation--  --fire-- 
     2             3            7 
     6             5            1



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,30.0
N-queens problem,https://rosettacode.org/wiki/N-queens_problem,Puzzles,True,implement algorithm with external knowledge,"


Solve the eight queens puzzle. 

You can extend the problem to solve the puzzle with a board of size   NxN.
For the number of solutions for small values of   N,   see   OEIS: A000170.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,38.0
Copy a string,https://rosettacode.org/wiki/Copy_a_string,String manipulation,True,,"
This task is about copying a string. 


Task

Where it is relevant, distinguish between copying the contents of a string 
versus making an additional reference to an existing string.



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,40.0
Generate lower case ASCII alphabet,https://rosettacode.org/wiki/Generate_lower_case_ASCII_alphabet,String manipulation,True,,"
Task

Generate an array, list, lazy sequence, or even an indexable string of all the lower case ASCII characters, from  a  to  z. If the standard library contains such a sequence, show how to access it, but don't fail to show how to generate a similar sequence. 
For this basic task use a reliable style of coding, a style fit for a very large program, and use strong typing if available. It's bug prone to enumerate all the lowercase characters manually in the code. 
During code review it's not immediate obvious to spot the bug in a Tcl line like this contained in a page of code:

set alpha {a b c d e f g h i j k m n o p q r s t u v w x y z}




",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,38.0
Reverse a string,https://rosettacode.org/wiki/Reverse_a_string,String manipulation,True,,"
Task

Take a string and reverse it.
For example, ""asdf"" becomes ""fdsa"".


Extra credit

Preserve Unicode combining characters. 
For example, ""as⃝df̅"" becomes ""f̅ds⃝a"", not ""̅fd⃝sa"".



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,42.0
String case,https://rosettacode.org/wiki/String_case,String manipulation,True,,"
Task

Take the string     alphaBETA     and demonstrate how to convert it to:

  upper-case     and
  lower-case

Use the default encoding of a string literal or plain ASCII if there is no string literal in your language.
Note: In some languages alphabets toLower and toUpper is not reversable.
Show any additional case conversion functions   (e.g. swapping case, capitalizing the first letter, etc.)   that may be included in the library of your language.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,37.0
String concatenation,https://rosettacode.org/wiki/String_concatenation,String manipulation,True,simple,"

Task

Create a string variable equal to any text value. 
Create another string variable whose value is the original variable concatenated with another string literal.
To illustrate the operation, show the content of the variables.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,39.0
String length,https://rosettacode.org/wiki/String_length,String manipulation,True,,"
Task

Find the character and byte length of a string.
This means encodings like UTF-8 need to be handled properly, as there is not necessarily a one-to-one relationship between bytes and characters. 
By character, we mean an individual Unicode code point, not a user-visible grapheme containing combining characters. 
For example, the character length of ""møøse"" is 5 but the byte length is 7 in UTF-8 and 10 in UTF-16.
Non-BMP code points (those between 0x10000 and 0x10FFFF) must also be handled correctly: answers should produce actual character counts in code points, not in code unit counts. 
Therefore a string like ""𝔘𝔫𝔦𝔠𝔬𝔡𝔢"" (consisting of the 7 Unicode characters U+1D518  U+1D52B U+1D526 U+1D520 U+1D52C U+1D521 U+1D522) is 7 characters long, not 14 UTF-16 code units; and it is 28 bytes long whether encoded in UTF-8 or in  UTF-16.  
Please mark your examples with ===Character Length=== or ===Byte Length===. 
If your language is capable of providing the string length in graphemes, mark those examples with ===Grapheme Length===.  
For example, the string ""J̲o̲s̲é̲"" (""J\x{332}o\x{332}s\x{332}e\x{301}\x{332}"") has 4 user-visible graphemes, 9 characters (code points), and 14 bytes when encoded in UTF-8.



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,42.0
Tokenize a string,https://rosettacode.org/wiki/Tokenize_a_string,String manipulation,True,,"
Separate the string ""Hello,How,Are,You,Today"" by commas into an array (or list) so that each element of it stores a different word. 
Display the words to the 'user', in the simplest manner possible, separated by a period. 
To simplify, you may display a trailing period.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,35.0
Animate a pendulum,https://rosettacode.org/wiki/Animate_a_pendulum,Temporal media,True,,"

One good way of making an animation is by simulating a physical system and illustrating the variables in that system using a dynamically changing graphical display. 
The classic such physical system is a simple gravity pendulum.


Task

Create a simple physical model of a pendulum and animate it.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,27.0
Evaluate binomial coefficients,https://rosettacode.org/wiki/Evaluate_binomial_coefficients,Mathematical operations,True,,"
This programming task, is to calculate ANY binomial coefficient.
However, it has to be able to output   





(


5
3


)




{\displaystyle \binom{5}{3}}

,   which is   10.
This formula is recommended:








(


n
k


)


=


n
!


(
n
−
k
)
!
k
!


=


n
(
n
−
1
)
(
n
−
2
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
(
k
−
2
)
…
1




{\displaystyle \binom{n}{k} = \frac{n!}{(n-k)!k!} = \frac{n(n-1)(n-2)\ldots(n-k+1)}{k(k-1)(k-2)\ldots 1}}




See Also:

Combinations and permutations
Pascal's triangle

The number of samples of size k from n objects.
With   combinations and permutations   generation tasks. 




Order Unimportant

Order Important


Without replacement







(


n
k


)



=
n


C
k

=


n
(
n
−
1
)
…
(
n
−
k
+
1
)


k
(
k
−
1
)
…
1




{\displaystyle  \binom nk = ^n\operatorname C_k = \frac{n(n-1)\ldots(n-k+1)}{k(k-1)\dots1} }









n


P
k

=
n
⋅
(
n
−
1
)
⋅
(
n
−
2
)
⋯
(
n
−
k
+
1
)


{\displaystyle ^n\operatorname P_k = n\cdot(n-1)\cdot(n-2)\cdots(n-k+1)}




Task: Combinations

Task: Permutations


With replacement







(



n
+
k
−
1

k


)



=

n
+
k
−
1



C
k

=



(
n
+
k
−
1
)
!


(
n
−
1
)
!
k
!





{\displaystyle  \binom {n+k-1}k = ^{n+k-1}\operatorname C_k = {(n+k-1)! \over (n-1)!k!}}








n
k



{\displaystyle n^k}




Task: Combinations with repetitions

Task: Permutations with repetitions



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,31.0
Greatest common divisor,https://rosettacode.org/wiki/Greatest_common_divisor,Recursion,True,,"


Task

Find the greatest common divisor   (GCD)   of two integers.

Greatest common divisor   is also known as   greatest common factor (gcf)   and   greatest common measure.


Related task

  least common multiple.


See also

  MathWorld entry:          greatest common divisor.
  Wikipedia entry:     greatest common divisor.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,36.0
Loops/Do-while,https://rosettacode.org/wiki/Loops/Do-while,Conditional loops,True,simple,"
Start with a value at 0. Loop while value mod 6 is not equal to 0. 
Each time through the loop, add 1 to the value then print it. 
The loop must execute at least once.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,37.0
Leap year,https://rosettacode.org/wiki/Leap_year,Date and time,True,,"
Task

Determine whether a given year is a leap year in the Gregorian calendar.


See also

Leap year (wiki)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,34.0
CUSIP,https://rosettacode.org/wiki/CUSIP,Checksums,True,tanslation from pseudo-code,"


This page uses content from Wikipedia. The original article was at CUSIP. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


A   CUSIP   is a nine-character alphanumeric code that identifies a North American financial security for the purposes of facilitating clearing and settlement of trades. The CUSIP was adopted as an American National Standard under Accredited Standards X9.6.


Task

Ensure the last digit   (i.e., the   check digit)   of the CUSIP code (the 1st column) is correct, against the following:

   037833100           Apple Incorporated
   17275R102           Cisco Systems
   38259P508           Google Incorporated
   594918104           Microsoft Corporation
   68389X106           Oracle Corporation   (incorrect)
   68389X105           Oracle Corporation


Example pseudo-code below.
algorithm Cusip-Check-Digit(cusip) is
   Input: an 8-character CUSIP

   sum := 0
   for 1 ≤ i ≤ 8 do
      c := the ith character of cusip
      if c is a digit then
         v := numeric value of the digit c
      else if c is a letter then
         p := ordinal position of c in the alphabet (A=1, B=2...)
         v := p + 9
      else if c = ""*"" then
         v := 36
      else if c = ""@"" then
         v := 37
      else if' c = ""#"" then
         v := 38
      end if
      if i is even then
         v := v × 2
      end if

      sum := sum + int ( v div 10 ) + v mod 10
   repeat
   
   return (10 - (sum mod 10)) mod 10
end function

See related tasks

SEDOL
ISIN


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,26.0
Loops/Break,https://rosettacode.org/wiki/Loops/Break,Iteration,True,,"
Task

Show a loop which prints random numbers (each number newly generated each loop) from 0 to 19 (inclusive). 
If a number is 10, stop the loop after printing it, and do not generate any further numbers.  
Otherwise, generate and print a second random number before restarting the loop.  
If the number 10 is never generated as the first number in a loop, loop forever.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,35.0
Loops/Downward for,https://rosettacode.org/wiki/Loops/Downward_for,Iteration,True,simple,"
Task

Write a    for    loop which writes a countdown from   10   to   0.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,34.0
Loops/For,https://rosettacode.org/wiki/Loops/For,Iteration,True,simple,"
“For”   loops are used to make some block of code be iterated a number of times, setting a variable or parameter to a monotonically increasing integer value for each execution of the block of code. 
Common extensions of this allow other counting patterns or iterating over abstract structures other than the integers.


Task

Show how two loops may be nested within each other, with the number of iterations performed by the inner for loop being controlled by the outer for loop. 
Specifically print out the following pattern by using one for loop nested in another:

*
**
***
****
*****


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,39.0
Substring,https://rosettacode.org/wiki/Substring,String manipulation,True,,"



Task

Display a substring:

  starting from   n   characters in and of   m   length;
  starting from   n   characters in,   up to the end of the string;
  whole string minus the last character;
  starting from a known   character   within the string and of   m   length;
  starting from a known   substring   within the string and of   m   length.

If the program uses UTF-8 or UTF-16,   it must work on any valid Unicode code point, 
whether in the   Basic Multilingual Plane   or above it. 
The program must reference logical characters (code points),   not 8-bit code units for UTF-8 or 16-bit code units for UTF-16. 
Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,35.0
MD5,https://rosettacode.org/wiki/MD5,Checksums,True,,"
Task

Encode a string using an MD5 algorithm.   The algorithm can be found on   Wikipedia.

Optionally, validate your implementation by running all of the test values in   IETF RFC (1321)   for MD5. 
Additionally,   RFC 1321   provides more precise information on the algorithm than the Wikipedia article.



Warning:   MD5 has known weaknesses, including collisions and forged signatures.   Users may consider a stronger alternative when doing production-grade cryptography, such as SHA-256 (from the SHA-2 family), or the upcoming SHA-3.

If the solution on this page is a library solution, see   MD5/Implementation   for an implementation from scratch.


",1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,30.0
MD5/Implementation,https://rosettacode.org/wiki/MD5/Implementation,Checksums,True,,"
The purpose of this task to code and validate an implementation of the MD5 Message Digest Algorithm by coding the algorithm directly (not using a call to a built-in or external hashing library).  For details of the algorithm refer to MD5 on Wikipedia or the MD5 definition in IETF RFC (1321). 

The implementation needs to implement the key functionality namely producing a correct message digest for an input string.  It is not necessary to mimic all of the calling modes such as adding to a digest one block at a time over subsequent calls.
In addition to coding and verifying your implementation, note any challenges your language presented implementing the solution, implementation choices made, or limitations of your solution.
Solutions on this page should implement MD5 directly and NOT use built in (MD5) functions, call outs to operating system calls or library routines written in other languages as is common in the original MD5 task.
The following are acceptable:
An original implementation from the specification, reference implementation, or pseudo-code
A translation of a correct implementation from another language
A library routine in the same language; however, the source must be included here.

The solutions shown here will provide practical illustrations of bit manipulation, unsigned integers, working with little-endian data.  Additionally, the task requires an attention to details such as boundary conditions since being out by even 1 bit will produce dramatically different results.  Subtle implementation bugs can result in some hashes being correct while others are wrong.  Not only is it critical to get the individual sub functions working correctly, even small errors in padding, endianness, or data layout will result in failure.

The following verification strings and hashes come from RFC 1321:                            hash code <== string 
   0xd41d8cd98f00b204e9800998ecf8427e <== """"  
   0x0cc175b9c0f1b6a831c399e269772661 <== ""a""
   0x900150983cd24fb0d6963f7d28e17f72 <== ""abc""
   0xf96b697d7cb7938d525a2f31aaf161d0 <== ""message digest""
   0xc3fcd3d76192e4007dfb496cca67e13b <== ""abcdefghijklmnopqrstuvwxyz""
   0xd174ab98d277d9f5a5611c2c9f419d9f <== ""ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789""
   0x57edf4a22be3c955ac49da2e2107b67a <== ""12345678901234567890123456789012345678901234567890123456789012345678901234567890""
In addition, intermediate outputs to aid in developing an implementation can be found here.
The MD5 Message-Digest Algorithm was developed by RSA Data Security, Inc. in 1991.



WarningRosetta Code is not a place you should rely on for examples of code in critical roles, including security.Also, note that MD5 has been broken and should not be used in applications requiring security.  For these consider SHA2 or the upcoming SHA3.

",1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,19.0
Arrays,https://rosettacode.org/wiki/Arrays,Basic language learning,True,for assembly,"
This task is about arrays.
For hashes or associative arrays, please see Creating an Associative Array. 
For a definition and in-depth discussion of what an array is, see Array.


Task

Show basic array syntax in your language. 
Basically, create an array, assign a value to it, and retrieve an element   (if available, show both fixed-length arrays and
dynamic arrays, pushing a value into it).
Please discuss at Village Pump:   Arrays.  
Please merge code in from these obsolete tasks:

  Creating an Array
  Assigning Values to an Array
  Retrieving an Element of an Array


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,42.0
Sorting algorithms/Quicksort,https://rosettacode.org/wiki/Sorting_algorithms/Quicksort,Sorting,True,,"



This page uses content from Wikipedia. The original article was at Quicksort. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)



Task

Sort an array (or list) elements using the   quicksort   algorithm. 
The elements must have a   strict weak order   and the index of the array can be of any discrete type. 
For languages where this is not possible, sort an array of integers.

Quicksort, also known as   partition-exchange sort,   uses these steps.

  Choose any element of the array to be the pivot.
  Divide all other elements (except the pivot) into two partitions.
  All elements less than the pivot must be in the first partition.
  All elements greater than the pivot must be in the second partition.
  Use recursion to sort both partitions.
  Join the first sorted partition, the pivot, and the second sorted partition.

The best pivot creates partitions of equal length (or lengths differing by   1). 
The worst pivot creates an empty partition (for example, if the pivot is the first or last element of a sorted array). 
The run-time of Quicksort ranges from    O(n log n)    with the best pivots, to    O(n2)    with the worst pivots, where    n    is the number of elements in the array.

This is a simple quicksort algorithm, adapted from Wikipedia.

function quicksort(array)
    less, equal, greater := three empty arrays
    if length(array) > 1  
        pivot := select any element of array
        for each x in array
            if x < pivot then add x to less
            if x = pivot then add x to equal
            if x > pivot then add x to greater
        quicksort(less)
        quicksort(greater)
        array := concatenate(less, equal, greater)

A better quicksort algorithm works in place, by swapping elements within the array, to avoid the memory allocation of more arrays.

function quicksort(array)
    if length(array) > 1
        pivot := select any element of array
        left := first index of array
        right := last index of array
        while left ≤ right
            while array[left] < pivot
                left := left + 1
            while array[right] > pivot
                right := right - 1
            if left ≤ right
                swap array[left] with array[right]
                left := left + 1
                right := right - 1
        quicksort(array from first index to right)
        quicksort(array from left to last index)

Quicksort has a reputation as the fastest sort. Optimized variants of quicksort are common features of many languages and libraries. One often contrasts quicksort with   merge sort,   because both sorts have an average time of    O(n log n). 

""On average, mergesort does fewer comparisons than quicksort, so it may be better when complicated comparison routines are used. Mergesort also takes advantage of pre-existing order, so it would be favored for using sort() to merge several sorted arrays. On the other hand, quicksort is often faster for small arrays, and on arrays of a few distinct values, repeated many times."" — http://perldoc.perl.org/sort.html
Quicksort is at one end of the spectrum of divide-and-conquer algorithms, with merge sort at the opposite end.

Quicksort is a conquer-then-divide algorithm, which does most of the work during the partitioning and the recursive calls. The subsequent reassembly of the sorted partitions involves trivial effort.
Merge sort is a divide-then-conquer algorithm. The partioning happens in a trivial way, by splitting the input array in half. Most of the work happens during the recursive calls and the merge phase.

With quicksort, every element in the first partition is less than or equal to every element in the second partition. Therefore, the merge phase of quicksort is so trivial that it needs no mention!
This task has not specified whether to allocate new arrays, or sort in place. This task also has not specified how to choose the pivot element. (Common ways to are to choose the first element, the middle element, or the median of three elements.) Thus there is a variety among the following implementations.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,37.0
24 game,https://rosettacode.org/wiki/24_game,Puzzles,True,,"
The 24 Game tests one's mental arithmetic. 


Task
Write a program that randomly chooses and displays four digits, each from 1 ──► 9 (inclusive) with repetitions allowed.
The program should prompt for the player to enter an arithmetic expression using just those, and all of those four digits, used exactly once each. The program should check then evaluate the expression. 
The goal is for the player to enter an expression that (numerically) evaluates to 24.

Only the following operators/functions are allowed: multiplication, division, addition, subtraction
Division should use floating point or rational arithmetic, etc, to preserve remainders.
Brackets are allowed, if using an infix expression evaluator.
Forming multiple digit numbers from the supplied digits is disallowed. (So an answer of 12+12 when given 1, 2, 2, and 1 is wrong).
The order of the digits when given does not have to be preserved.


Notes
The type of expression evaluator used is not mandated. An RPN evaluator is equally acceptable for example.
The task is not for the program to generate the expression, or test whether an expression is even possible.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,31.0
24 game/Solve,https://rosettacode.org/wiki/24_game/Solve,Puzzles,True,,"
task

Write a program that takes four digits, either from user input or by random generation, and computes arithmetic expressions following the rules of the 24 game.
Show examples of solutions generated by the program.


Related task

  Arithmetic Evaluator


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,25.0
ABC problem,https://rosettacode.org/wiki/ABC_problem,Puzzles,True,,"


You are given a collection of ABC blocks   (maybe like the ones you had when you were a kid).  
There are twenty blocks with two letters on each block. 
A complete alphabet is guaranteed amongst all sides of the blocks. 
The sample collection of blocks: 

 (B O)
 (X K)
 (D Q)
 (C P)
 (N A)
 (G T)
 (R E)
 (T G)
 (Q D)
 (F S)
 (J W)
 (H U)
 (V I)
 (A N)
 (O B)
 (E R)
 (F S)
 (L Y)
 (P C)
 (Z M)



Task

Write a function that takes a string (word) and determines whether the word can be spelled with the given collection of blocks. 

The rules are simple:

  Once a letter on a block is used that block cannot be used again
  The function should be case-insensitive
  Show the output on this page for the following 7 words in the following example


Example

    >>> can_make_word(""A"")
    True
    >>> can_make_word(""BARK"")
    True
    >>> can_make_word(""BOOK"")
    False
    >>> can_make_word(""TREAT"")
    True
    >>> can_make_word(""COMMON"")
    False
    >>> can_make_word(""SQUAD"")
    True
    >>> can_make_word(""CONFUSE"")
    True


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,32.0
Align columns,https://rosettacode.org/wiki/Align_columns,Text processing,True,,"
Given a text file of many lines, where fields within a line 
are delineated by a single 'dollar' character, write a program
that aligns each column of fields by ensuring that words in each 
column are separated by at least one space.
Further, allow for each word in a column to be either left 
justified, right justified, or center justified within its column.
Use the following text to test your programs:

Given$a$text$file$of$many$lines,$where$fields$within$a$line$
are$delineated$by$a$single$'dollar'$character,$write$a$program
that$aligns$each$column$of$fields$by$ensuring$that$words$in$each$
column$are$separated$by$at$least$one$space.
Further,$allow$for$each$word$in$a$column$to$be$either$left$
justified,$right$justified,$or$center$justified$within$its$column.

Note that:

  The example input texts lines may, or may not, have trailing dollar characters.
  All columns should share the same alignment.
  Consecutive space characters produced adjacent to the end of lines are insignificant for the purposes of the task.
  Output text will be viewed in a mono-spaced font on a plain text editor or basic terminal.
  The minimum space between columns should be computed from the text and not hard-coded.
  It is not a requirement to add separating characters between or around columns.



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,34.0
Anagrams,https://rosettacode.org/wiki/Anagrams,Text processing,True,,"
When two or more words are composed of the same characters, but in a different order, they are called anagrams. 

Task
Using the word list at   http://wiki.puzzlers.org/pub/wordlists/unixdict.txt, 
find the sets of words that share the same characters that contain the most words in them.

",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,33.0
Date format,https://rosettacode.org/wiki/Date_format,Text processing,True,,"
This task has been clarified.  Its programming examples are in need of review to ensure that they still fit the requirements of the task.


Task

Display the   current date   in the formats of:

   2007-11-23     and
   Friday, November 23, 2007


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,37.0
Increment a numerical string,https://rosettacode.org/wiki/Increment_a_numerical_string,Text processing,True,,"
Task

Increment a numerical string.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,37.0
Regular expressions,https://rosettacode.org/wiki/Regular_expressions,Text processing,True,,"


Task

  match a string against a regular expression
  substitute part of a string using a regular expression


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,29.0
Repeat a string,https://rosettacode.org/wiki/Repeat_a_string,String manipulation,True,,"
Take a string and repeat it some number of times.  
Example: repeat(""ha"", 5)   =>   ""hahahahaha""
If there is a simpler/more efficient way to repeat a single “character” (i.e. creating a string filled with a certain character), you might want to show that as well (i.e. repeat-char(""*"", 5) => ""*****"").



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,40.0
URL decoding,https://rosettacode.org/wiki/URL_decoding,String manipulation,True,,"
This task   (the reverse of   URL encoding   and distinct from   URL parser)   is to provide a function 
or mechanism to convert an URL-encoded string into its original unencoded form.


Test cases

  The encoded string   ""http%3A%2F%2Ffoo%20bar%2F""   should be reverted to the unencoded form   ""http://foo bar/"".
  The encoded string   ""google.com/search?q=%60Abdu%27l-Bah%C3%A1""   should revert to the unencoded form   ""google.com/search?q=`Abdu'l-Bahá"".
  The encoded string   ""%25%32%35""   should revert to the unencoded form   ""%25"" and not ""%"".


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,29.0
Arithmetic/Integer,https://rosettacode.org/wiki/Arithmetic/Integer,Arithmetic,True,simple,"

Task

Get two integers from the user,    and then (for those two integers), display their:

  sum
  difference
  product
  integer quotient
  remainder
  exponentiation   (if the operator exists)

Don't include error handling. 
For quotient, indicate how it rounds   (e.g. towards zero, towards negative infinity, etc.). 
For remainder, indicate whether its sign matches the sign of the first operand or of the second operand, if they are different.

Bonus: Include an example of the integer `divmod` operator. For example: as in #Haskell, #Python and #ALGOL 68

",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,35.0
Morse code,https://rosettacode.org/wiki/Morse_code,Temporal media,True,,"
Morse code is one of the simplest and most versatile methods of telecommunication in existence. 
It has been in use for more than 175 years — longer than any other electronic encoding system.


Task

Send a string as audible Morse code to an audio device   (e.g., the PC speaker).

As the standard Morse code does not contain all possible characters, 
you may either ignore unknown characters in the file, 
or indicate them somehow   (e.g. with a different pitch).


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,26.0
Mutual recursion,https://rosettacode.org/wiki/Mutual_recursion,Recursion,True,,"
Two functions are said to be mutually recursive if the first calls the second, 
and in turn the second calls the first.
Write two mutually recursive functions that compute members of the Hofstadter Female and Male sequences defined as:









F
(
0
)



=
1
 
;
 
M
(
0
)
=
0




F
(
n
)



=
n
−
M
(
F
(
n
−
1
)
)
,

n
>
0




M
(
n
)



=
n
−
F
(
M
(
n
−
1
)
)
,

n
>
0.





{\displaystyle 
\begin{align}
F(0)&=1\ ;\ M(0)=0 \\
F(n)&=n-M(F(n-1)), \quad n>0 \\
M(n)&=n-F(M(n-1)), \quad n>0.
\end{align}
}



(If a language does not allow for a solution using mutually recursive functions 
then state this rather than give a solution by other means).


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,34.0
Power set,https://rosettacode.org/wiki/Power_set,Recursion,True,,"
A   set   is a collection (container) of certain values, 
without any particular order, and no repeated values. 
It corresponds with a finite set in mathematics. 
A set can be implemented as an associative array (partial mapping) 
in which the value of each key-value pair is ignored.
Given a set S, the power set (or powerset) of S, written P(S), or 2S, is the set of all subsets of S.


Task

By using a library or built-in set type, or by defining a set type with necessary operations, write a function with a set S as input that yields the power set 2S of S.

For example, the power set of     {1,2,3,4}     is 

{{}, {1}, {2}, {1,2}, {3}, {1,3}, {2,3}, {1,2,3}, {4}, {1,4}, {2,4}, {1,2,4}, {3,4}, {1,3,4}, {2,3,4}, {1,2,3,4}}.
For a set which contains n elements, the corresponding power set has 2n elements, including the edge cases of empty set.
The power set of the empty set is the set which contains itself (20 = 1):






P



{\displaystyle \mathcal{P}}

(



∅


{\displaystyle \varnothing}

) = { 



∅


{\displaystyle \varnothing}

 }
And the power set of the set which contains only the empty set, has two subsets, the empty set and the set which contains the empty set (21 = 2):






P



{\displaystyle \mathcal{P}}

({



∅


{\displaystyle \varnothing}

}) = { 



∅


{\displaystyle \varnothing}

,  { 



∅


{\displaystyle \varnothing}

 } }

Extra credit:  Demonstrate that your language supports these last two powersets.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,34.0
HTTP,https://rosettacode.org/wiki/HTTP,Programming environment operations,True,,"
Task

Access and print a URL's content (the located resource) to the console.
There is a separate task for HTTPS Requests.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,35.0
System time,https://rosettacode.org/wiki/System_time,Programming environment operations,True,assembly only,"
Task

Output the system time   (any units will do as long as they are noted) either by a system command or one built into the language. 
The system time can be used for debugging, network information, random number seeds, or something as simple as program performance.


Related task

  Date format


See also

  Retrieving system time (wiki)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,35.0
XML/DOM serialization,https://rosettacode.org/wiki/XML/DOM_serialization,XML,True,,"
Create a simple DOM and having it serialize to:

 <?xml version=""1.0"" ?>
 <root>
     <element>
         Some text here
     </element>
 </root>

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,22.0
Stable marriage problem,https://rosettacode.org/wiki/Stable_marriage_problem,Classic CS problems and programs,True,,"
Solve the Stable marriage problem using the Gale/Shapley algorithm.

Problem description
Given an equal number of men and women to be paired for marriage, each man ranks all the women in order of his preference and each woman ranks all the men in order of her preference. 
A stable set of engagements for marriage is one where no man prefers a woman over the one he is engaged to, where that other woman also prefers that man over the one she is engaged to. I.e. with consulting marriages, there would be no reason for the engagements between the people to change.
Gale and Shapley proved that there is a stable set of engagements for any set of preferences and the first link above gives their algorithm for finding a set of stable engagements.

Task Specifics
Given ten males:

   abe, bob, col, dan, ed, fred, gav, hal, ian, jon

And ten females:

   abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan

And a complete list of ranked preferences, where the most liked is to the left:

  abe: abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay
  bob: cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay
  col: hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan
  dan: ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi
   ed: jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay
 fred: bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay
  gav: gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay
  hal: abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee
  ian: hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve
  jon: abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope
   
  abi: bob, fred, jon, gav, ian, abe, dan, ed, col, hal
  bea: bob, abe, col, fred, gav, dan, ian, ed, jon, hal
 cath: fred, bob, ed, gav, hal, col, ian, abe, dan, jon
  dee: fred, jon, col, abe, ian, hal, gav, dan, bob, ed
  eve: jon, hal, fred, dan, abe, gav, col, ed, ian, bob
  fay: bob, abe, ed, ian, jon, dan, fred, gav, col, hal
  gay: jon, gav, hal, fred, bob, abe, col, ed, dan, ian
 hope: gav, jon, bob, abe, ian, dan, hal, ed, col, fred
  ivy: ian, col, hal, gav, fred, bob, abe, ed, jon, dan
  jan: ed, hal, gav, abe, bob, jon, col, ian, fred, dan

Use the Gale Shapley algorithm to find a stable set of engagements
Perturb this set of engagements to form an unstable set of engagements then check this new set for stability.

References

The Stable Marriage Problem. (Eloquent description and background information).
Gale-Shapley Algorithm Demonstration.
Another Gale-Shapley Algorithm Demonstration.
Stable Marriage Problem - Numberphile (Video).
Stable Marriage Problem (the math bit) (Video).
The Stable Marriage Problem and School Choice. (Excellent exposition)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,22.0
Determine if a string is numeric,https://rosettacode.org/wiki/Determine_if_a_string_is_numeric,Text processing,True,,"
Task

Create a boolean function which takes in a string and tells whether it is a numeric string (floating point and negative numbers included) in the syntax the language uses for numeric literals or numbers converted from strings.



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,40.0
String prepend,https://rosettacode.org/wiki/String_prepend,String manipulation,True,,"

Task

Create a string variable equal to any text value. 
Prepend the string variable with another string literal.
If your language supports any idiomatic ways to do this without referring to the variable twice in one expression, include such solutions.

To illustrate the operation, show the content of the variable.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,27.0
Strip a set of characters from a string,https://rosettacode.org/wiki/Strip_a_set_of_characters_from_a_string,String manipulation,True,,"
Task

Create a function that strips a set of characters from a string. 

The function should take two arguments: 

  a string to be stripped
  a string containing the set of characters to be stripped

The returned string should contain the first string, stripped of any characters in the second argument:

 print stripchars(""She was a soul stripper. She took my heart!"",""aei"")
Sh ws  soul strppr. Sh took my hrt!



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
URL encoding,https://rosettacode.org/wiki/URL_encoding,String manipulation,True,,"
Task

Provide a function or mechanism to convert a provided string into URL encoding representation.
In URL encoding, special characters, control characters and extended characters 
are converted into a percent symbol followed by a two digit hexadecimal code, 
So a space character encodes into %20 within the string.
For the purposes of this task, every character except 0-9, A-Z and a-z requires conversion, so the following characters all require conversion by default:

ASCII control codes (Character ranges 00-1F hex (0-31 decimal) and 7F (127 decimal).
ASCII symbols (Character ranges 32-47 decimal (20-2F hex))
ASCII symbols (Character ranges 58-64 decimal (3A-40 hex))
ASCII symbols (Character ranges 91-96 decimal (5B-60 hex))
ASCII symbols (Character ranges 123-126 decimal (7B-7E hex))
Extended characters with character codes of 128 decimal (80 hex) and above.


Example

The string ""http://foo bar/"" would be encoded as ""http%3A%2F%2Ffoo%20bar%2F"".


Variations

Lowercase escapes are legal, as in ""http%3a%2f%2ffoo%20bar%2f"".
Special characters have different encodings for different standards:
RFC 3986, Uniform Resource Identifier (URI): Generic Syntax, section 2.3, says to preserve ""-._~"".
HTML 5, section 4.10.22.5 URL-encoded form data, says to preserve ""-._*"", and to encode space "" "" to ""+"".
encodeURI function in Javascript will preserve ""-._~"" (RFC 3986) and "";,/?:@&=+$!*'()#"".
Options

It is permissible to use an exception string (containing a set of symbols 
that do not need to be converted). 
However, this is an optional feature and is not a requirement of this task.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,27.0
Ethiopian multiplication,https://rosettacode.org/wiki/Ethiopian_multiplication,Arithmetic,True,,"
Ethiopian multiplication is a method of multiplying integers using only addition, doubling, and halving.

Method: 

Take two numbers to be multiplied and write them down at the top of two columns.
In the left-hand column repeatedly halve the last number, discarding any remainders, and write the result below the last in the same column, until you write a value of 1.
In the right-hand column repeatedly double the last number and write the result below. stop when you add a result in the same row as where the left hand column shows 1.
Examine the table produced and discard any row where the value in the left column is even.
Sum the values in the right-hand column that remain to produce the result of multiplying the original two numbers together

For example:   17 × 34

       17    34

Halving the first column:

       17    34
        8
        4
        2
        1

Doubling the second column:

       17    34
        8    68
        4   136 
        2   272
        1   544

Strike-out rows whose first cell is even:

       17    34
        8    68 
        4   136 
        2   272 
        1   544

Sum the remaining numbers in the right-hand column:

       17    34
        8    -- 
        4   --- 
        2   --- 
        1   544
           ====
            578

So 17 multiplied by 34, by the Ethiopian method is 578.


Task

The task is to define three named functions/methods/procedures/subroutines:

one to halve an integer,
one to double an integer, and
one to state if an integer is even.

Use these functions to create a function that does Ethiopian multiplication.


References

Ethiopian multiplication explained (BBC Video clip)
A Night Of Numbers - Go Forth And Multiply (Video)
Russian Peasant Multiplication
Programming Praxis: Russian Peasant Multiplication


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,37.0
Active Directory/Connect,https://rosettacode.org/wiki/Active_Directory/Connect,Programming environment operations,True,network,"

The task is to establish a connection to an Active Directory or Lightweight Directory Access Protocol server.

",1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,17.0
XML/XPath,https://rosettacode.org/wiki/XML/XPath,XML,True,,"
Perform the following three XPath queries on the XML Document below:

//item[1]: Retrieve the first ""item"" element
//price/text(): Perform an action on each ""price"" element (print it out)
//name: Get an array of all the ""name"" elements
XML Document:

<inventory title=""OmniCorp Store #45x10^3"">
  
    <item upc=""123456789"" stock=""12"">
      <name>Invisibility Cream</name>
      <price>14.50</price>
      <description>Makes you invisible</description>
    </item>
    <item upc=""445322344"" stock=""18"">
      <name>Levitation Salve</name>
      <price>23.99</price>
      <description>Levitate yourself for up to 3 hours per application</description>
    </item>
  
  
    <item upc=""485672034"" stock=""653"">
      <name>Blork and Freen Instameal</name>
      <price>4.95</price>
      <description>A tasty meal in a tablet; just add water</description>
    </item>
    <item upc=""132957764"" stock=""44"">
      <name>Grob winglets</name>
      <price>3.56</price>
      <description>Tender winglets of Grob. Just add water</description>
    </item>
  
</inventory>

",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,25.0
Day of the week,https://rosettacode.org/wiki/Day_of_the_week,Date and time,True,,"
A company decides that whenever Xmas falls on a Sunday they will give their workers all extra paid holidays so that, together with any public holidays, workers will not have to work the following week (between the 25th of December and the first of January).


Task

In what years between 2008 and 2121 will the 25th of December be a Sunday?
Using any standard date handling libraries of your programming language; 
compare the dates calculated with the output of other languages to discover any anomalies in the handling of dates which may be due to, for example, overflow in types used to represent dates/times similar to   y2k   type problems.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,36.0
SOAP,https://rosettacode.org/wiki/SOAP,Networking and Web Interaction,True,network,"
In this task, the goal is to create a SOAP client which accesses functions defined at http://example.com/soap/wsdl, and calls the functions soapFunc( ) and anotherSoapFunc( ).

This task has been flagged for clarification. Code on this page in its current state may be flagged incorrect once this task has been clarified.  See this page's Talk page for discussion.


",1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,11.0
Loops/For with a specified step,https://rosettacode.org/wiki/Loops/For_with_a_specified_step,Iteration,True,simple,"


Task

Demonstrate a   for-loop   where the step-value is greater than one.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,36.0
Loops/Foreach,https://rosettacode.org/wiki/Loops/Foreach,Iteration,True,simple,"
Loop through and print each element in a collection in order. 
Use your language's ""for each"" loop if it has one, otherwise iterate through the collection in order with some other loop.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,35.0
Loops/N plus one half,https://rosettacode.org/wiki/Loops/N_plus_one_half,Iteration,True,simple,"
Quite often one needs loops which, in the last iteration, execute only part of the loop body.


Goal

Demonstrate the best way to do this.


Task

Write a loop which writes the comma-separated list

1, 2, 3, 4, 5, 6, 7, 8, 9, 10

using separate output statements for the number 
and the comma from within the body of the loop.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,34.0
Sattolo cycle,https://rosettacode.org/wiki/Sattolo_cycle,Classic CS problems and programs,True,,"
The   Sattolo cycle   is an algorithm for randomly shuffling an array in such a way that each element ends up in a new position.

Task[|_}}%20*%2F%20 edit]
Implement the Sattolo cycle for an integer array (or, if possible, an array of any type). 

Specification
Given an array items with indices ranging from 0 to last, the algorithm can be defined as follows (pseudo-code):

for i from last downto 1 do:
    let j = random integer in range 0 
  
    
      
        ≤
      
    
    {\displaystyle \leq}
  
 j < i
    swap items[i] with items[j]

Notes:

It modifies the input array in-place. If that is unreasonable in your programming language, you may amend the algorithm to return the shuffled items as a new array instead.
The algorithm can also be amended to iterate from left to right, if that is more convenient.
The only difference between this and the Knuth shuffle, is that 



j


{\displaystyle j}

 is chosen from the range 0 



≤


{\displaystyle \leq}

 j < i, rather than 0 



≤


{\displaystyle \leq}

 j 



≤


{\displaystyle \leq}

 i. This is what ensures that every element ends up in a new position, as long as there are at least two elements.
Test cases


Input array

Possible output arrays


[]

[]


[10]

[10]


[10, 20]

[20, 10]


[10, 20, 30]

[20, 30, 10][30, 10, 20]


[11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22]

39,916,800 possibilities. You'll know you have a correct one if it has the same elements as the input array, but none in their original place.

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,23.0
Sutherland-Hodgman polygon clipping,https://rosettacode.org/wiki/Sutherland-Hodgman_polygon_clipping,Graphics algorithms,True,,"
The   Sutherland-Hodgman clipping algorithm   finds the polygon that is the intersection between an arbitrary polygon (the “subject polygon”) and a convex polygon (the “clip polygon”). 
It is used in computer graphics (especially 2D graphics) to reduce the complexity of a scene being displayed by eliminating parts of a polygon that do not need to be displayed.


Task

Take the closed polygon defined by the points:





[
(
50
,
150
)
,
(
200
,
50
)
,
(
350
,
150
)
,
(
350
,
300
)
,
(
250
,
300
)
,
(
200
,
250
)
,
(
150
,
350
)
,
(
100
,
250
)
,
(
100
,
200
)
]


{\displaystyle [(50, 150), (200, 50), (350, 150), (350, 300), (250, 300), (200, 250), (150, 350), (100, 250), (100, 200)]}


and clip it by the rectangle defined by the points:





[
(
100
,
100
)
,
(
300
,
100
)
,
(
300
,
300
)
,
(
100
,
300
)
]


{\displaystyle [(100, 100), (300, 100), (300, 300), (100, 300)]}


Print the sequence of points that define the resulting clipped polygon.


Extra credit

Display all three polygons on a graphical surface, using a different color for each polygon and filling the resulting polygon. 
(When displaying you may use either a north-west or a south-west origin, whichever is more convenient for your display mechanism.)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,22.0
Caesar cipher,https://rosettacode.org/wiki/Caesar_cipher,Encryption,True,,"


Task

Implement a Caesar cipher, both encoding and decoding. 
The key is an integer from 1 to 25. 
This cipher rotates (either towards left or right) the letters of the alphabet (A to Z). 
The encoding replaces each letter with the 1st to 25th next letter in the alphabet (wrapping Z to A).
So key 2 encrypts ""HI"" to ""JK"", but key 20 encrypts ""HI"" to ""BC"". 
This simple ""mono-alphabetic substitution cipher"" provides almost no security, because an attacker who has the encoded message can either use frequency analysis to guess the key, or just try all 25 keys.
Caesar cipher is identical to Vigenère cipher with a key of length 1. 
Also, Rot-13 is identical to Caesar cipher with key 13.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,36.0
One-time pad,https://rosettacode.org/wiki/One-time_pad,Encryption,True,,"
Implement a One-time pad, for encrypting and decrypting messages.
To keep it simple, we will be using letters only.

Sub-Tasks

Generate the data for a One-time pad (user needs to specify a filename and length)
The important part is to get ""true random"" numbers, e.g. from /dev/random
encryption / decryption ( basically the same operation, much like Rot-13 )
For this step, much of Vigenère cipher could be reused,with the key to be read from the file containing the One-time pad.
optional: management of One-time pads: list, mark as used, delete, etc.
Somehow, the users needs to keep track which pad to use for which partner.
To support the management of pad-files:

Such files have a file-extension "".1tp""
Lines starting with ""#"" may contain arbitary meta-data (i.e. comments)
Lines starting with ""-"" count as ""used""
Whitespace within the otp-data is ignored

For example, here is the data from Wikipedia:

# Example data - Wikipedia - 2014-11-13
-ZDXWWW EJKAWO FECIFE WSNZIP PXPKIY URMZHI JZTLBC YLGDYJ 
-HTSVTV RRYYEG EXNCGA GGQVRF FHZCIB EWLGGR BZXQDQ DGGIAK 
 YHJYEQ TDLCQT HZBSIZ IRZDYS RBYJFZ AIRCWI UCVXTW YKPQMK 
 CKHVEX VXYVCS WOGAAZ OUVVON GCNEVR LMBLYB SBDCDC PCGVJX 
 QXAUIP PXZQIJ JIUWYH COVWMJ UZOJHL DWHPER UBSRUJ HGAAPR 
 CRWVHI FRNTQW AJVWRT ACAKRD OZKIIB VIQGBK IJCWHF GTTSSE 
 EXFIPJ KICASQ IOUQTP ZSGXGH YTYCTI BAZSTN JKMFXI RERYWE 



See also
one time pad encryption in Python
snapfractalpop -  One-Time-Pad Command-Line-Utility (C).
Crypt-OTP-2.00 on CPAN (Perl)


",1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,8.0
Josephus problem,https://rosettacode.org/wiki/Josephus_problem,Puzzles,True,,"
Josephus problem is a math puzzle with a grim description: 



n


{\displaystyle n}

 prisoners are standing on a circle, sequentially numbered from 



0


{\displaystyle 0}

 to 



n
−
1


{\displaystyle n-1}

.  
An executioner walks along the circle, starting from prisoner 



0


{\displaystyle 0}

, 
removing every 



k


{\displaystyle k}

-th prisoner and killing him.  
As the process goes on, the circle becomes smaller and smaller, until only one prisoner remains, who is then freed. >
For example, if there are 



n
=
5


{\displaystyle n=5}

 prisoners and 



k
=
2


{\displaystyle k=2}

, the order the prisoners are killed in (let's call it the ""killing sequence"") will be 1, 3, 0, and 4, and the survivor will be #2.


Task

Given any   



n
,
k
>
0


{\displaystyle n, k > 0}

,   find out which prisoner will be the final survivor.  
In one such incident, there were 41 prisoners and every 3rd prisoner was being killed   (



k
=
3


{\displaystyle k=3}

).  
Among them was a clever chap name Josephus who worked out the problem, stood at the surviving position, and lived on to tell the tale. 
Which number was he?


Extra

The captors may be especially kind and let 



m


{\displaystyle m}

 survivors free, 
and Josephus might just have   



m
−
1


{\displaystyle m-1}

   friends to save.  
Provide a way to calculate which prisoner is at any given position on the killing sequence.


Notes

You can always play the executioner and follow the procedure exactly as described, walking around the circle, counting (and cutting off) heads along the way.  This would yield the complete killing sequence and answer the above questions, with a complexity of probably 



O
(
k
n
)


{\displaystyle O(kn)}

.  However, individually it takes no more than 



O
(
m
)


{\displaystyle O(m)}

 to find out which prisoner is the 



m


{\displaystyle m}

-th to die.
If it's more convenient, you can number prisoners from   



1


{\displaystyle 1}

 to 



n


{\displaystyle n}

   instead.   If you choose to do so, please state it clearly.
An alternative description has the people committing assisted suicide instead of being executed, and the last person simply walks away. These details are not relevant, at least not mathematically.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,28.0
Input loop,https://rosettacode.org/wiki/Input_loop,Streams,True,,"

Task

Read from a text stream either word-by-word or line-by-line until the stream runs out of data. 
The stream will have an unknown amount of data on it.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,31.0
N'th,https://rosettacode.org/wiki/N%27th,String manipulation,True,,"
Write a function/method/subroutine/... that when given an integer greater than or equal to zero returns a string of the number followed by an apostrophe then the ordinal suffix.


Example

Returns would include 1'st 2'nd 3'rd 11'th 111'th 1001'st 1012'th


Task

Use your routine to show here the output for at least the following (inclusive) ranges of integer inputs:
0..25, 250..265, 1000..1025

Note: apostrophes are now optional to allow correct apostrophe-less English.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,30.0
Roman numerals/Encode,https://rosettacode.org/wiki/Roman_numerals/Encode,String manipulation,True,,"
Task

Create a function taking a positive integer as its parameter and returning a string containing the Roman numeral representation of that integer. Modern Roman numerals are written by expressing each digit separately, starting with the left most digit and skipping any digit with a value of zero. 

In Roman numerals:

1990  is rendered: 1000=M, 900=CM, 90=XC; resulting in MCMXC
2008  is written as 2000=MM, 8=VIII; or MMVIII
1666  uses each Roman symbol in descending order: MDCLXVI


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Fractal tree,https://rosettacode.org/wiki/Fractal_tree,Recursion,True,,"
Generate and draw a fractal tree.

Draw the trunk
At the end of the trunk, split by some angle and draw two branches
Repeat at the end of each branch until a sufficient level of branching is reached


",1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,25.0
Least common multiple,https://rosettacode.org/wiki/Least_common_multiple,Recursion,True,,"


Task

Compute the   least common multiple   (LCM)   of two integers.
Given   m   and   n,   the least common multiple is the smallest positive integer that has both   m   and   n   as factors. 


Example

The least common multiple of   12   and   18   is   36,       because:

  12   is a factor     (12 × 3 = 36),     and
  18   is a factor     (18 × 2 = 36),     and
  there is no positive integer less than   36   that has both factors.

As a special case,   if either   m   or   n   is zero,   then the least common multiple is zero.

One way to calculate the least common multiple is to iterate all the multiples of   m,   until you find one that is also a multiple of   n.
If you already have   gcd   for greatest common divisor,   then this formula calculates   lcm.






lcm
⁡
(
m
,
n
)
=



|

m
×
n

|



gcd
⁡
(
m
,
n
)




{\displaystyle \operatorname{lcm}(m, n) = \frac{|m \times n|}{\operatorname{gcd}(m, n)}}



One can also find   lcm   by merging the prime decompositions of both   m   and   n.


Related task

  greatest common divisor.


See also

  MathWorld entry:   Least Common Multiple.
  Wikipedia entry:   Least common multiple.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Maze generation,https://rosettacode.org/wiki/Maze_generation,Games,True,,"


This page uses content from Wikipedia. The original article was at Maze generation algorithm. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Generate and show a maze, using the simple Depth-first search algorithm.

Start at a random cell.
Mark the current cell as visited, and get a list of its neighbors. For each neighbor, starting with a randomly selected neighbor:
If that neighbor hasn't been visited, remove the wall between this cell and that neighbor, and then recurse with that neighbor as the current cell.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,24.0
Haversine formula,https://rosettacode.org/wiki/Haversine_formula,Geometry,True,,"


This page uses content from Wikipedia. The original article was at Haversine formula. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


The haversine formula is an equation important in navigation, giving great-circle distances between two points on a sphere from their longitudes and latitudes. 
It is a special case of a more general formula  in spherical trigonometry, the law of haversines, relating the sides and angles of spherical ""triangles"".


Task

Implement a great-circle distance function, or use a library function, 
to show the great-circle distance between:

Nashville International Airport (BNA)   in Nashville, TN, USA,   which is:
   N 36°7.2',   W 86°40.2'     (36.12,   -86.67)           -and-

Los Angeles International Airport (LAX)  in Los Angeles, CA, USA,   which is:
   N 33°56.4',  W 118°24.0'    (33.94,  -118.40)   



User Kaimbridge clarified on the Talk page:

 -- 6371.0 km is the authalic radius based on/extracted from surface area;
 -- 6372.8 km is an approximation of the radius of the average circumference
    (i.e., the average great-elliptic or great-circle radius), where the
     boundaries are the meridian (6367.45 km) and the equator (6378.14 km).

Using either of these values results, of course, in differing distances:

 6371.0 km -> 2886.44444283798329974715782394574671655 km;
 6372.8 km -> 2887.25995060711033944886005029688505340 km;
 (results extended for accuracy check:  Given that the radii are only
  approximations anyways, .01' ≈ 1.0621333 km and .001"" ≈ .00177 km,
  practical precision required is certainly no greater than about
  .0000001——i.e., .1 mm!)

As distances are segments of great circles/circumferences, it is
recommended that the latter value (r = 6372.8 km) be used (which
most of the given solutions have already adopted, anyways). 

Most of the examples below adopted Kaimbridge's recommended value of
6372.8 km for the earth radius.  However, the derivation of this
ellipsoidal quadratic mean radius
is wrong (the averaging over azimuth is biased).  When applying these
examples in real applications, it is better to use the
mean earth radius,
6371 km.  This value is recommended by the International Union of
Geodesy and Geophysics and it minimizes the RMS relative error between the
great circle and geodesic distance.



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,36.0
Pi,https://rosettacode.org/wiki/Pi,Geometry,True,,"

Create a program to continually calculate and output the next decimal digit of   



π


{\displaystyle \pi}

   (pi). 
The program should continue forever (until it is aborted by the user) calculating and outputting each decimal digit in succession. 
The output should be a decimal sequence beginning   3.14159265 ...

Note: this task is about   calculating   pi.   For information on built-in pi constants see Real constants and functions.

Related Task Arithmetic-geometric mean/Calculate Pi


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,29.0
AVL tree,https://rosettacode.org/wiki/AVL_tree,Data Structures,True,,"


This page uses content from Wikipedia. The original article was at AVL tree. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)


In computer science, an AVL tree is a self-balancing binary search tree. In an AVL tree, the heights of the two child subtrees of any node differ by at most one; at no time do they differ by more than one because rebalancing is done ensure this is the case. Lookup, insertion, and deletion all take O(log n) time in both the average and worst cases, where n is the number of nodes in the tree prior to the operation. Insertions and deletions may require the tree to be rebalanced by one or more tree rotations. Note the tree of nodes comprise a set, so duplicate node keys are not allowed.
AVL trees are often compared with red-black trees because they support the same set of operations and because red-black trees also take O(log n) time for the basic operations.  Because AVL trees are more rigidly balanced, they are faster than red-black trees for lookup-intensive applications. Similar to red-black trees, AVL trees are height-balanced, but in general not weight-balanced nor μ-balanced; that is, sibling nodes can have hugely differing numbers of descendants.


Task

Implement an AVL tree in the language of choice, and provide at least basic operations.


Related task
Red_black_tree_sort


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,20.0
Count occurrences of a substring,https://rosettacode.org/wiki/Count_occurrences_of_a_substring,String manipulation,True,,"
Task

Create a function,   or show a built-in function,   to count the number of non-overlapping occurrences of a substring inside a string.
The function should take two arguments: 

  the first argument being the string to search,   and
  the second a substring to be searched for.

It should return an integer count.

print countSubstring(""the three truths"",""th"")
3

// do not count substrings that overlap with previously-counted substrings:
print countSubstring(""ababababab"",""abab"")
2
The matching should yield the highest number of non-overlapping matches. 
In general, this essentially means matching from left-to-right or right-to-left   (see proof on talk page).



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Substring/Top and tail,https://rosettacode.org/wiki/Substring/Top_and_tail,String manipulation,True,,"
The task is to demonstrate how to remove the first and last characters from a string. 
The solution should demonstrate how to obtain the following results:

String with first character removed
String with last character removed
String with both the first and last characters removed

If the program uses UTF-8 or UTF-16, it must work on any valid Unicode code point, whether in the Basic Multilingual Plane or above it. 
The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16. 
Programs for other encodings (such as 8-bit ASCII, or EUC-JP) are not required to handle all Unicode characters.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Filter,https://rosettacode.org/wiki/Filter,Iteration,True,,"
Task

Select certain elements from an Array into a new Array in a generic way.

To demonstrate, select all even numbers from an Array.
As an option, give a second solution which filters destructively,
by modifying the original Array rather than creating a new Array.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,36.0
Array concatenation,https://rosettacode.org/wiki/Array_concatenation,Data Structures,True,,"
Task

Show how to concatenate two arrays in your language. 

If this is as simple as array1 + array2, so be it.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,37.0
Associative array/Creation,https://rosettacode.org/wiki/Associative_array/Creation,Data Structures,True,,"
Task

The goal is to create an associative array (also known as a dictionary, map, or hash).

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,36.0
Collections,https://rosettacode.org/wiki/Collections,Data Structures,True,,"
This task has been clarified.  Its programming examples are in need of review to ensure that they still fit the requirements of the task.

Collections are abstractions to represent sets of values.  
In statically-typed languages, the values are typically of a common data type.


Task

Create a collection, and add a few values to it.


See also

Array
Associative array: Creation, Iteration
Collections
Compound data type
Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
Linked list
Queue: Definition, Usage
Set
Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
Stack


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,33.0
JSON,https://rosettacode.org/wiki/JSON,Data Structures,True,,"
Load a JSON string into a data structure.  
Also, create a new data structure and serialize it into JSON.
Use objects and arrays (as appropriate for your language) 
and make sure your JSON is valid (https://jsonformatter.org).

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,31.0
Set,https://rosettacode.org/wiki/Set,Data Structures,True,,"

A   set  is a collection of elements, without duplicates and without order.


Task

Show each of these set operations:

Set creation
Test m ∈ S -- ""m is an element in set S""
A ∪ B -- union; a set of all elements either in set A or in set B.
A ∩ B -- intersection; a set of all elements in both set A and set B.
A ∖ B -- difference; a set of all elements in set A, except those in set B.
A ⊆ B -- subset; true if every element in set A is also in set B.
A = B -- equality; true if every element of set A is in set B and vice versa.

As an option, show some other set operations.
(If A ⊆ B, but A ≠ B, then A is called a true or proper subset of B, written A ⊂ B or A ⊊ B.) 
As another option, show how to modify a mutable set.

One might implement a set using an associative array (with set elements as array keys and some dummy value as the values). 
One might also implement a set with a binary search tree, or with a hash table, or with an ordered array of binary bits (operated on with bit-wise binary operators). 
The basic test, m ∈ S, is O(n) with a sequential list of elements, O(log n) with a balanced binary search tree, or (O(1) average-case, O(n) worst case) with a hash table.


See also

Array
Associative array: Creation, Iteration
Collections
Compound data type
Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
Linked list
Queue: Definition, Usage
Set
Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
Stack


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,28.0
Hostname,https://rosettacode.org/wiki/Hostname,Programming environment operations,True,simple,"
Task

Find the name of the host on which the routine is running.


",1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Luhn test of credit card numbers,https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers,Checksums,True,,"
The Luhn test is used by some credit card companies to distinguish valid credit card numbers from what could be a random selection of digits.
Those companies using credit card numbers that can be validated by the Luhn test have numbers that pass the following test:

Reverse the order of the digits in the number.
Take the first, third, ... and every other odd digit in the reversed digits and sum them to form the partial sum s1
Taking the second, fourth ... and every other even digit in the reversed digits:
Multiply each digit by two and sum the digits if the answer is greater than nine to form partial sums for the even digits
Sum the partial sums of the even digits to form s2
If s1 + s2 ends in zero then the original number is in the form of a valid credit card number as verified by the Luhn test.

For example, if the trial number is 49927398716:

Reverse the digits:
  61789372994
Sum the odd digits:
  6 + 7 + 9 + 7 + 9 + 4 = 42 = s1
The even digits:
    1,  8,  3,  2,  9
  Two times each even digit:
    2, 16,  6,  4, 18
  Sum the digits of each multiplication:
    2,  7,  6,  4,  9
  Sum the last:
    2 + 7 + 6 + 4 + 9 = 28 = s2

s1 + s2 = 70 which ends in zero which means that 49927398716 passes the Luhn test


Task

Write a function/method/procedure/subroutine that will validate a number with the Luhn test, and 
use it to validate the following numbers:

   49927398716
   49927398717
   1234567812345678
   1234567812345670



",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,38.0
Trigonometric functions,https://rosettacode.org/wiki/Trigonometric_functions,Geometry,True,simple,"
Task

If your language has a library or built-in functions for trigonometry, show examples of:

  sine
  cosine
  tangent
  inverses   (of the above)
using the same angle in radians and degrees. 
For the non-inverse functions,   each radian/degree pair should use arguments that evaluate to the same angle   (that is, it's not necessary to use the same angle for all three regular functions as long as the two sine calls use the same angle). 
For the inverse functions,   use the same number and convert its answer to radians and degrees. 
If your language does not have trigonometric functions available or only has some available,   write functions to calculate the functions based on any   known approximation or identity.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
SEDOLs,https://rosettacode.org/wiki/SEDOLs,Checksums,True,,"
Task

For each number list of 6-digit SEDOLs, calculate and append the checksum digit.  

That is, given this input:

710889
B0YBKJ
406566
B0YBLH
228276
B0YBKL
557910
B0YBKR
585284
B0YBKT
B00030

Produce this output:

7108899
B0YBKJ7
4065663
B0YBLH2
2282765
B0YBKL9
5579107
B0YBKR5
5852842
B0YBKT7
B000300

Extra credit

Check each input is correctly formed, especially with respect to valid characters allowed in a SEDOL string.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,28.0
Hello world/Newline omission,https://rosettacode.org/wiki/Hello_world/Newline_omission,Basic language learning,True,,"
Some languages automatically insert a newline after outputting a string, unless measures are taken to prevent its output. 


Task

Display the string   Goodbye, World!   without a trailing newline.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,32.0
Knapsack problem/Bounded,https://rosettacode.org/wiki/Knapsack_problem/Bounded,Classic CS problems and programs,True,,"
A tourist wants to make a good trip at the weekend with his friends. 
They will go to the mountains to see the wonders of nature.   So he needs some items during the trip.   Food, clothing, etc.   He has a good knapsack for carrying the things, but he knows that he can carry only 4 kg weight in his knapsack, because they will make the trip from morning to evening. 
He creates a list of what he wants to bring for the trip, but the total weight of all items is too much.   He adds a value to each item.   The value represents how important the thing for the tourist. 
The list contains which items are the wanted things for the trip, what is the weight and value of an item, and how many units does he have from each items.

This is the list:


Table of potential knapsack items


item
weight (dag) (each)
value (each)
piece(s)


map
9
150
1


compass
13
35
1


water
153
200
2


sandwich
50
60
2


glucose
15
60
2


tin
68
45
3


banana
27
60
3


apple
39
40
3


cheese
23
30
1


beer
52
10
3


suntan cream
11
70
1


camera
32
30
1


T-shirt
24
15
2


trousers
48
10
2


umbrella
73
40
1


waterproof trousers
42
70
1


waterproof overclothes
43
75
1


note-case
22
80
1


sunglasses
7
20
1


towel
18
12
2


socks
4
50
1


book
30
10
2


knapsack
≤400 dag
?
?


The tourist can choose to take any combination of items from the list, and some number of each item is available   (see the column   piece(s)   in the list above). 
He may not cut the items, so he can only take whole units of any item. 


Task

Show which items does the tourist carry in his knapsack so that their total weight does not exceed 4 kg, and their total value is maximized.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,18.0
Knapsack problem/Unbounded,https://rosettacode.org/wiki/Knapsack_problem/Unbounded,Classic CS problems and programs,True,,"
A traveler gets diverted and has to make an unscheduled stop in what turns out to be Shangri La.   Opting to leave, he is allowed to take as much as he likes of the following items, so long as it will fit in his knapsack, and he can carry it.
He knows that he can carry no more than   25   'weights' in total;   and that the capacity of his knapsack is   0.25   'cubic lengths'.
Looking just above the bar codes on the items he finds their weights and volumes.   He digs out his recent copy of a  financial paper and gets the value of each item.

ItemExplanationValue (each)weightVolume (each)panacea
(vials of)Incredible healing properties30000.30.025ichor
(ampules of)Vampires blood18000.20.015gold
(bars)Shiney shiney25002.00.002KnapsackFor the carrying of-<=25<=0.25 


He can only take whole units of any item, but there is much more of any item than he could ever carry


Task

Show how many of each item does he take to maximize the value of items he is carrying away with him.


Note

  There are four solutions that maximize the value taken.   Only one need be given.


",1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,22.0
Table creation/Postal addresses,https://rosettacode.org/wiki/Table_creation/Postal_addresses,Database operations,True,,"
Task

Create a table to store addresses. 
You may assume that all the addresses to be stored will be located in the USA.   As such, you will need (in addition to a field holding a unique identifier) a field holding the street address, a field holding the city, a field holding the state code, and a field holding the zipcode.   Choose appropriate types for each field.
For non-database languages, show how you would open a connection to a database (your choice of which) and create an address table in it. You should follow the existing models here for how you would structure the table.


",0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,13.0
Dijkstra's algorithm,https://rosettacode.org/wiki/Dijkstra%27s_algorithm,Routing algorithms,True,,"
This task has been clarified.  Its programming examples are in need of review to ensure that they still fit the requirements of the task.

Dijkstra's algorithm, conceived by Dutch computer scientist Edsger Dijkstra in 1956 and published in 1959, is a graph search algorithm that solves the single-source shortest path problem for a graph with non-negative edge path costs, producing a shortest path tree.  
This algorithm is often used in routing and as a subroutine in other graph algorithms.

For a given source vertex (node) in the graph, the algorithm finds the path with lowest cost (i.e. the shortest path) between that vertex and every other vertex. 


For instance

If the vertices of the graph represent cities and edge path costs represent driving distances between pairs of cities connected by a direct road,   Dijkstra's algorithm can be used to find the shortest route between one city and all other cities.  
As a result, the shortest path first is widely used in network  routing protocols, most notably:

  IS-IS   (Intermediate System to Intermediate System)   and
  OSPF   (Open Shortest Path First).


Important note

The inputs to Dijkstra's algorithm are a directed and weighted graph consisting of 2 or more nodes, generally represented by:

  an adjacency matrix or list,   and
  a start node.

A destination node is not specified. 
The output is a set of edges depicting the shortest path to each destination node.


An example, starting with

                                         a──►b,  cost=7,   lastNode=a  
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=NA,  lastNode=a
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a

    The lowest cost is    a──►b    so    a──►b    is added to the output. 

    There is a connection from   b──►d   so the input is updated to: 
                                         a──►c,  cost=9,   lastNode=a 
                                         a──►d,  cost=22,  lastNode=b 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=14,  lastNode=a

    The lowest cost is    a──►c    so    a──►c    is added to the output. 

    Paths to    d    and    f    are cheaper via    c    so the input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a 
                                         a──►f,  cost=11,  lastNode=c

    The lowest cost is    a──►f    so    c──►f    is added to the output. 

    The input is updated to:
                                         a──►d,  cost=20,  lastNode=c 
                                         a──►e,  cost=NA,  lastNode=a

    The lowest cost is    a──►d    so    c──►d    is added to the output. 

    There is a connection from    d──►e    so the input is updated to:
                                         a──►e,  cost=26,  lastNode=d

    Which just leaves adding    d──►e    to the output.

    The output should now be:
                                       [ d──►e
                                         c──►d
                                         c──►f
                                         a──►c
                                         a──►b ]



Task

Implement a version of Dijkstra's algorithm that outputs a set of edges depicting the shortest path to each reachable node from an origin.
Run your program with the following directed graph starting at node    a.
Write a program which interprets the output from the above and use it to output the shortest path from node    a    to nodes    e    and  f. 

Vertices


Number
Name


1
a


2
b


3
c


4
d


5
e


6
f


Edges


Start
End
Cost


a
b
7


a
c
9


a
f
14


b
c
10


b
d
15


c
d
11


c
f
2


d
e
6


e
f
9


You can use numbers or names to identify vertices in your program.


See also
Dijkstra's Algorithm vs. A* Search vs. Concurrent Dijkstra's Algorithm (youtube)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,24.0
Send email,https://rosettacode.org/wiki/Send_email,Networking and Web Interaction,True,,"
Task

Write a function to send an email. 
The function should have parameters for setting From, To and Cc addresses; the Subject, and the message text, and optionally fields for the server name and login details.

If appropriate, explain what notifications of problems/success are given.
Solutions using libraries or functions from the language are preferred, but failing that, external programs can be used with an explanation.
Note how portable the solution given is between operating systems when multi-OS languages are used.

(Remember to obfuscate any sensitive data used in examples)


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,23.0
Sum and product of an array,https://rosettacode.org/wiki/Sum_and_product_of_an_array,Iteration,True,,"
Task

Compute the sum and product of an array of integers.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,38.0
Sudoku,https://rosettacode.org/wiki/Sudoku,Games,True,,"
Task

Solve a partially filled-in normal   9x9   Sudoku grid   and display the result in a human-readable format. 

references

Algorithmics of Sudoku   may help implement this.
Python Sudoku Solver Computerphile video.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,29.0
Merge and aggregate datasets,https://rosettacode.org/wiki/Merge_and_aggregate_datasets,Data Structures,True,,"
Merge and aggregate datasets


Task

Merge and aggregate two datasets as provided in   .csv   files into a new resulting dataset.
Use the appropriate methods and data structures depending on the programming language. 
Use the most common libraries only when built-in functionality is not sufficient.


Note

Either load the data from the   .csv   files or create the required data structures hard-coded.

patients.csv   file contents:

PATIENT_ID,LASTNAME
1001,Hopper
4004,Wirth
3003,Kemeny
2002,Gosling
5005,Kurtz


visits.csv   file contents:

PATIENT_ID,VISIT_DATE,SCORE
2002,2020-09-10,6.8
1001,2020-09-17,5.5
4004,2020-09-24,8.4
2002,2020-10-08,
1001,,6.6
3003,2020-11-12,
4004,2020-11-05,7.0
1001,2020-11-19,5.3


Create a resulting dataset in-memory or output it to screen or file, whichever is appropriate for the programming language at hand.
Merge and group per patient id and last name,   get the maximum visit date,   and get the sum and average of the scores per patient to get the resulting dataset.

Note that the visit date is purposefully provided as ISO format,   so that it could also be processed as text and sorted alphabetically to determine the maximum date.

| PATIENT_ID | LASTNAME | LAST_VISIT |  SCORE_SUM | SCORE_AVG |
| 1001       |  Hopper  | 2020-11-19 |  17.4      | 5.80      |
| 2002       |  Gosling | 2020-10-08 |   6.8      | 6.80      |
| 3003       |  Kemeny  | 2020-11-12 |            |           |
| 4004       |  Wirth   | 2020-11-05 |  15.4      | 7.70      |
| 5005       |  Kurtz   |            |            |           |



Note

This task is aimed in particular at programming languages that are used in data science and data processing, such as F#, Python, R, SPSS, MATLAB etc.


",1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,14.0
QR decomposition,https://rosettacode.org/wiki/QR_decomposition,Mathematics,True,,"
Any rectangular 



m
×
n


{\displaystyle m \times n}

 matrix 




A



{\displaystyle \mathit A}

 can be decomposed to a product of an orthogonal matrix 




Q



{\displaystyle \mathit Q}

 and an upper (right) triangular matrix 




R



{\displaystyle \mathit R}

, as described in QR decomposition. 
Task
Demonstrate the QR decomposition on the example matrix from the Wikipedia article:





A
=

(



12


−
51


4




6


167


−
68




−
4


24


−
41



)



{\displaystyle A = \begin{pmatrix}
12 & -51 & 4 \\
6 & 167 & -68 \\
-4 & 24 & -41 \end{pmatrix}}


and the usage for linear least squares problems on the example from Polynomial regression. The method of Householder reflections should be used:
Method
Multiplying a given vector 




a



{\displaystyle \mathit a}

, for example the first column of matrix 




A



{\displaystyle \mathit A}

, with the Householder matrix 




H



{\displaystyle \mathit H}

, which is given as





H
=
I
−

2


u
T

u


u

u
T



{\displaystyle H = I - \frac {2} {u^T u} u u^T}


reflects 




a



{\displaystyle \mathit a}

 about a plane given by its normal vector 




u



{\displaystyle \mathit u}

. When the normal vector of the plane 




u



{\displaystyle \mathit u}

 is given as





u
=
a
−
‖
a

‖
2



e
1



{\displaystyle u = a - \|a\|_2 \; e_1}


then the transformation reflects 




a



{\displaystyle \mathit a}

 onto the first standard basis vector 






e
1

=
[
1

0

0

.
.
.

]
T



{\displaystyle e_1 = [1 \; 0 \; 0 \; ...]^T}


which means that all entries but the first become zero. To avoid numerical cancellation errors, we should take the opposite sign of 




a
1



{\displaystyle a_1}

:





u
=
a
+

sign

(

a
1

)
‖
a

‖
2



e
1



{\displaystyle u = a + \textrm{sign}(a_1)\|a\|_2 \; e_1}


and normalize with respect to the first element:





v
=

u

u
1




{\displaystyle v = \frac{u}{u_1}}


The equation for 



H


{\displaystyle H}

 thus becomes:





H
=
I
−

2


v
T

v


v

v
T



{\displaystyle H = I - \frac {2} {v^T v} v v^T}


or, in another form





H
=
I
−
β
v

v
T



{\displaystyle H = I - \beta v v^T}


with





β
=

2


v
T

v




{\displaystyle \beta = \frac {2} {v^T v}}


Applying 




H



{\displaystyle \mathit H}

 on 




a



{\displaystyle \mathit a}

 then gives





H

a
=
−

sign

(

a
1

)

‖
a

‖
2



e
1



{\displaystyle H \; a = -\textrm{sign}(a_1) \; \|a\|_2 \; e_1}


and applying 




H



{\displaystyle \mathit H}

 on the matrix 




A



{\displaystyle \mathit A}

 zeroes all subdiagonal elements of the first column:






H
1


A
=

(




r

11





r

12





r

13






0


∗


∗




0


∗


∗



)



{\displaystyle H_1 \; A = \begin{pmatrix}
r_{11} & r_{12} & r_{13} \\
0    & *    & * \\
0    & *    & * \end{pmatrix}}


In the second step, the second column of 




A



{\displaystyle \mathit A}

, we want to zero all elements but the first two, which means that we have to calculate 




H



{\displaystyle \mathit H}

 with the first column of the submatrix (denoted *), not on the whole second column of 




A



{\displaystyle \mathit A}

.
To get 




H
2



{\displaystyle H_2}

, we then embed the new 




H



{\displaystyle \mathit H}

 into an 



m
×
n


{\displaystyle m \times n}

 identity:






H
2

=

(



1


0


0




0


H





0





)



{\displaystyle H_2 = \begin{pmatrix}
1 & 0 & 0 \\
0 & H & \\
0 &   & \end{pmatrix}}


This is how we can, column by column, remove all subdiagonal elements of 




A



{\displaystyle \mathit A}

 and thus transform it into 




R



{\displaystyle \mathit R}

. 






H
n


.
.
.


H
3


H
2


H
1

A
=
R


{\displaystyle H_n \; ... \; H_3 H_2 H_1 A = R}


The product of all the Householder matrices 




H



{\displaystyle \mathit H}

, for every column, in reverse order, will then yield the orthogonal matrix 




Q



{\displaystyle \mathit Q}

.






H
1


H
2


H
3


.
.
.


H
n

=
Q


{\displaystyle H_1 H_2 H_3 \; ... \; H_n = Q}


The QR decomposition should then be used to solve linear least squares (Multiple regression) problems 




A

x
=
b


{\displaystyle \mathit A x = b}

 by solving





R

x
=

Q
T


b


{\displaystyle R \; x = Q^T \; b}


When 




R



{\displaystyle \mathit R}

 is not square, i.e. 



m
>
n


{\displaystyle m > n}

 we have to cut off the 




m

−
n


{\displaystyle \mathit m - n}

 zero padded bottom rows.





R
=

(




R
1





0



)



{\displaystyle R =
\begin{pmatrix}
R_1 \\
0 \end{pmatrix}}


and the same for the RHS:






Q
T


b
=

(




q
1






q
2




)



{\displaystyle Q^T \; b =
\begin{pmatrix}
q_1 \\
q_2 \end{pmatrix}}


Finally, solve the square upper triangular system by back substitution:






R
1


x
=

q
1



{\displaystyle R_1 \; x = q_1}


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,17.0
Sorting algorithms/Shell sort,https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort,Sorting,True,,"

Task

Sort an array of elements using the Shell sort algorithm, a diminishing increment sort. 
The Shell sort   (also known as Shellsort or Shell's method)   is named after its inventor, Donald Shell, who published the algorithm in 1959.
Shell sort is a sequence of interleaved insertion sorts based on an increment sequence. 
The increment size is reduced after each pass until the increment size is 1. 
With an increment size of 1, the sort is a basic insertion sort, but by this time the data is guaranteed to be almost sorted, which is insertion sort's ""best case"". 
Any sequence will sort the data as long as it ends in 1, but some work better than others. 
Empirical studies have shown a geometric increment sequence with a ratio of about 2.2 work well in practice.
[1]
Other good sequences are found at the On-Line Encyclopedia of Integer Sequences.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,27.0
Command-line arguments,https://rosettacode.org/wiki/Command-line_arguments,Initialization,True,,"Retrieve the list of command-line arguments given to the program. For programs that only print the arguments when run directly, see Scripted main.
See also Program name.
For parsing command line arguments intelligently, see Parsing command-line arguments.
Example command line:

myprogram -c ""alpha beta"" -h ""gamma""

",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,35.0
Environment variables,https://rosettacode.org/wiki/Environment_variables,Initialization,True,,"
Task

Show how to get one of your process's environment variables. 
The available variables vary by system;   some of the common ones available on Unix include:

  PATH
  HOME
  USER


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,29.0
GUI/Maximum window dimensions,https://rosettacode.org/wiki/GUI/Maximum_window_dimensions,Initialization,True,,"
The task is to determine the maximum height and width of a window that can fit within the physical display area of the screen without scrolling. 
This is effectively the screen size (not the total desktop area, which could be bigger than the screen display area) in pixels minus any adjustments for window decorations and menubars. 
The idea is to determine the physical display parameters for the maximum height and width of the usable display area in pixels (without scrolling). 
The values calculated should represent the usable desktop area of a window maximized to fit the the screen.


Considerations

--- Multiple Monitors

For multiple monitors, the values calculated should represent the size of the usable display area on the monitor which is related to the task (i.e.:   the monitor which would display a window if such instructions were given).

--- Tiling Window Managers
For a tiling window manager, the values calculated should represent the maximum height and width of the display area of the maximum size a window can be created (without scrolling). This would typically be a full screen window (minus any areas occupied by desktop bars), unless the window manager has restrictions that prevents the creation of a full screen window, in which case the values represent the usable area of the desktop that occupies the maximum permissible window size (without scrolling).


",1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,16.0
Read a configuration file,https://rosettacode.org/wiki/Read_a_configuration_file,Initialization,True,,"
The task is to read a configuration file in standard configuration file format, 
and set variables accordingly. 
For this task, we have a configuration file as follows:

# This is a configuration file in standard configuration file format
#
# Lines beginning with a hash or a semicolon are ignored by the application
# program. Blank lines are also ignored by the application program.

# This is the fullname parameter
FULLNAME Foo Barber

# This is a favourite fruit
FAVOURITEFRUIT banana

# This is a boolean that should be set
NEEDSPEELING

# This boolean is commented out
; SEEDSREMOVED

# Configuration option names are not case sensitive, but configuration parameter
# data is case sensitive and may be preserved by the application program.

# An optional equals sign can be used to separate configuration parameter data
# from the option name. This is dropped by the parser. 

# A configuration option may take multiple parameters separated by commas.
# Leading and trailing whitespace around parameter names and parameter data fields
# are ignored by the application program.

OTHERFAMILY Rhu Barber, Harry Barber


For the task we need to set four variables according to the configuration entries as follows:

fullname = Foo Barber
favouritefruit = banana
needspeeling = true
seedsremoved = false

We also have an option that contains multiple parameters. These may be stored in an array.

otherfamily(1) = Rhu Barber
otherfamily(2) = Harry Barber


",1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,25.0
User input/Graphical,https://rosettacode.org/wiki/User_input/Graphical,Text processing,True,,"

In this task, the goal is to input a string and the integer 75000, from graphical user interface.

See also: User input/Text


",1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,21.0
Find common directory path,https://rosettacode.org/wiki/Find_common_directory_path,String manipulation,True,,"
Create a routine that, given a set of strings representing directory paths and a single character directory separator, will return a string representing that part of the directory tree that is common to all the directories.
Test your routine using the forward slash '/' character as the directory separator and the following three strings as input paths:

     '/home/user1/tmp/coverage/test'
     '/home/user1/tmp/covert/operator'
     '/home/user1/tmp/coven/members'

Note: The resultant path should be the valid directory '/home/user1/tmp' and not the longest common string '/home/user1/tmp/cove'.
If your language has a routine that performs this function (even if it does not have a changeable separator character), then mention it as part of the task.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,27.0
String matching,https://rosettacode.org/wiki/String_matching,String manipulation,True,,"

Task

Given two strings, demonstrate the following three types of string matching:

  Determining if the first string starts with second string
  Determining if the first string contains the second string at any location
  Determining if the first string ends with the second string

Optional requirements:

  Print the location of the match for part 2
  Handle multiple occurrences of a string for part 2.



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Factors of a Mersenne number,https://rosettacode.org/wiki/Factors_of_a_Mersenne_number,Arithmetic,True,,"
A Mersenne number is a number in the form of 2P-1. 
If P is prime, the Mersenne number may be a Mersenne prime 
(if P is not prime, the Mersenne number is also not prime). 
In the search for Mersenne prime numbers it is advantageous to eliminate exponents by finding a small factor before starting a,  potentially lengthy, Lucas-Lehmer test. 
There are very efficient algorithms for determining if a number divides 2P-1 (or equivalently, if 2P mod (the number) = 1). 
Some languages already have built-in implementations of this exponent-and-mod operation (called modPow or similar). 
The following is how to implement this modPow yourself:
For example, let's compute 223 mod 47. 
Convert the exponent 23 to binary, you get 10111. Starting with square = 1, repeatedly square it. 
Remove the top bit of the exponent, and if it's 1 multiply square by the base of the exponentiation (2), then compute square modulo 47. 
Use the result of the modulo from the last step as the initial value of square in the next step:

                  remove       optional   
      square      top bit   multiply by 2   mod 47
   ────────────   ───────   ─────────────   ────── 
   1*1 = 1        1  0111   1*2 = 2            2
   2*2 = 4        0   111      no              4
   4*4 = 16       1    11   16*2 = 32         32
   32*32 = 1024   1     1   1024*2 = 2048     27
   27*27 = 729    1         729*2 = 1458       1

Since 223 mod 47 = 1, 47 is a factor of 2P-1. 
(To see this, subtract 1 from both sides: 223-1 = 0 mod 47.) 
Since we've shown that 47 is a factor, 223-1 is not prime. 
Further properties of Mersenne numbers allow us to refine the process even more. 
Any factor q of 2P-1 must be of the form 2kP+1, k being a positive integer or zero. Furthermore, q must be 1 or 7 mod 8. 
Finally any potential factor q must be prime. 
As in other trial division algorithms, the algorithm stops when 2kP+1 > sqrt(N).
These primality tests only work on Mersenne numbers where P is prime. For example, M4=15 yields no factors using these techniques, but factors into 3 and 5, neither of which fit 2kP+1.


Task

Using the above method find a factor of  2929-1 (aka M929)


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,24.0
Animation,https://rosettacode.org/wiki/Animation,Temporal media,True,,"

Animation is integral to many parts of GUIs, including both the fancy effects when things change used in window managers, and of course games.   The core of any animation system is a scheme for periodically changing the display while still remaining responsive to the user.   This task demonstrates this.


Task

Create a window containing the string ""Hello World! "" (the trailing space is significant). 
Make the text appear to be rotating right by periodically removing one letter from the end of the string and attaching it to the front. 
When the user clicks on the (windowed) text, it should reverse its direction.


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,25.0
Determine if only one instance is running,https://rosettacode.org/wiki/Determine_if_only_one_instance_is_running,Programming environment operations,True,,"
This task is to determine if there is only one instance of an application running. If the program discovers that an instance of it is already running, then it should display a message indicating that it is already running and exit.

",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,19.0
HTTPS,https://rosettacode.org/wiki/HTTPS,Programming environment operations,True,,"
Task

Send a GET request to obtain the resource located at the URL ""https://www.w3.org/"", then print it to the console.
Checking the host certificate for validity is recommended.
Do not authenticate. That is the subject of other tasks.
Readers may wish to contrast with the HTTP Request task, and also the task on HTTPS request with authentication.

",1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,26.0
Grayscale image,https://rosettacode.org/wiki/Grayscale_image,Image processing,True,,"
Many image processing algorithms are defined for grayscale (or else monochromatic) images. 


Task

Extend the data storage type defined on this page to support grayscale images. 
Define two operations, one to convert a color image to a grayscale image and one for the backward conversion. 
To get luminance of a color use the formula recommended by CIE:

 L  =  0.2126 × R   +   0.7152 × G   +   0.0722 × B 

When using floating-point arithmetic make sure that rounding errors would not cause run-time problems or else distorted results when calculated luminance is stored as an unsigned integer. 


",1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,22.0
Gamma function,https://rosettacode.org/wiki/Gamma_function,Mathematical operations,True,implement a function,"
Task

Implement one algorithm (or more) to compute the Gamma (



Γ


{\displaystyle \Gamma}

) function (in the real field only). 
If your language has the function as built-in or you know a library which has it, compare your implementation's results with the results of the built-in/library function.
The Gamma function can be defined as:

 



Γ
(
x
)
=


∫
0
∞


t

x
−
1



e

−
t


d
t



{\displaystyle \Gamma(x) = \displaystyle\int_0^\infty t^{x-1}e^{-t} dt}


This suggests a straightforward (but inefficient) way of computing the 



Γ


{\displaystyle \Gamma}

 through numerical integration.

Better suggested methods:

Lanczos approximation
Stirling's approximation


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,26.0
Last Friday of each month,https://rosettacode.org/wiki/Last_Friday_of_each_month,Date and time,True,,"
Task

Write a program or a script that returns the date of the last Fridays of each month of a given year. 
The year may be given through any simple input method in your language (command line, std in, etc).

Example of an expected output:

./last_fridays 2012
2012-01-27
2012-02-24
2012-03-30
2012-04-27
2012-05-25
2012-06-29
2012-07-27
2012-08-31
2012-09-28
2012-10-26
2012-11-30
2012-12-28



",1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,29.0
Short-circuit evaluation,https://rosettacode.org/wiki/Short-circuit_evaluation,Programming language concepts,True,,"


Assume functions   a   and   b   return boolean values,   and further, the execution of function   b   takes considerable resources without side effects,  and is to be minimized.
If we needed to compute the conjunction   (and):

 x = a() and b() 
Then it would be best to not compute the value of   b()   if the value of   a()    is computed as   false,   as the value of   x   can then only ever be    false.
Similarly, if we needed to compute the disjunction (or):

 y = a() or b() 
Then it would be best to not compute the value of   b()   if the value of   a()   is computed as   true,   as the value of   y   can then only ever be   true.
Some languages will stop further computation of boolean equations as soon as the result is known, so-called   short-circuit evaluation   of boolean expressions


Task

Create two functions named   a   and   b,   that take and return the same boolean value. 
The functions should also print their name whenever they are called.
Calculate and assign the values of the following equations to a variable in such a way that function   b   is only called when necessary:

 x = a(i) and b(j) 
 y = a(i) or  b(j) 
If the language does not have short-circuit evaluation, this might be achieved with nested     if     statements.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,30.0
Circles of given radius through two points,https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points,Geometry,True,,"
2 circles with a given radius through 2 points in 2D space.
Given two points on a plane and a radius, usually two circles of given radius can be drawn through the points. 

Exceptions

r==0.0 should be treated as never describing circles (except in the case where the points are coincident).
If the points are coincident then an infinite number of circles with the point on their circumference can be drawn, unless r==0.0 as well which then collapses the circles to a point.
If the points form a diameter then return two identical circles or return a single circle, according to which is the most natural mechanism for the implementation language.
If the points are too far apart then no circles can be drawn.


Task detail

Write a function/subroutine/method/... that takes two points and a radius and returns the two circles through those points, or some indication of special cases where two, possibly equal, circles cannot be returned.
Show here the output for the following inputs:
      p1                p2           r
0.1234, 0.9876    0.8765, 0.2345    2.0
0.0000, 2.0000    0.0000, 0.0000    1.0
0.1234, 0.9876    0.1234, 0.9876    2.0
0.1234, 0.9876    0.8765, 0.2345    0.5
0.1234, 0.9876    0.1234, 0.9876    0.0



Related task

  Total circles area.


See also

  Finding the Center of a Circle from 2 Points and Radius from Math forum @ Drexel


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,25.0
Binary digits,https://rosettacode.org/wiki/Binary_digits,Basic language learning,True,,"
Task

Create and display the sequence of binary digits for a given   non-negative integer.

   The decimal value      5   should produce an output of               101
   The decimal value     50   should produce an output of            110010
   The decimal value   9000   should produce an output of    10001100101000

The results can be achieved using built-in radix functions within the language   (if these are available),   or alternatively a user defined function can be used. 
The output produced should consist just of the binary digits of each number followed by a   newline. 
There should be no other whitespace, radix or sign markers in the produced output, and leading zeros should not appear in the results.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,36.0
Generic swap,https://rosettacode.org/wiki/Generic_swap,Basic language learning,True,simple,"
Task

Write a generic swap function or operator which exchanges the values of two variables (or, more generally, any two storage places that can be assigned), regardless of their types. 
If your solution language is statically typed please describe the way your language provides genericity.
If variables are typed in the given language, it is permissible that the two variables be constrained to having a mutually compatible type, such that each is permitted to hold the value previously stored in the other without a type violation. 
That is to say, solutions do not have to be capable of exchanging, say, a string and integer value, if the underlying storage locations are not attributed with types that permit such an exchange.
Generic swap is a task which brings together a few separate issues in programming language semantics.
Dynamically typed languages deal with values in a generic way quite readily, but do not necessarily make it easy to write a function to destructively swap two variables, because this requires indirection upon storage places or upon the syntax designating storage places.
Functional languages, whether static or dynamic, do not necessarily allow a destructive operation such as swapping two variables regardless of their generic capabilities.
Some static languages have difficulties with generic programming due to a lack of support for (Parametric Polymorphism). 
Do your best!


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Handle a signal,https://rosettacode.org/wiki/Handle_a_signal,Concurrency,True,,"
Most operating systems provide interrupt facilities, sometimes called signals either generated by the user or as a result of program failure or reaching a limit like file space. 
Unhandled signals generally terminate a program in a disorderly manner. 
Signal handlers are created so that the program behaves in a well-defined manner upon receipt of a signal.

Task

Provide a program that displays an integer on each line of output at the rate of about one per half second. 
Upon receipt of the SIGINT signal (often generated by the user typing ctrl-C ( or better yet, SIGQUIT ctrl-\ ))  the program will cease outputting integers, output the number of seconds the program has run, and then the program will quit. 


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,26.0
Topological sort,https://rosettacode.org/wiki/Topological_sort,Sorting,True,,"


Given a mapping between items, and items they depend on, a topological sort orders items so that no item precedes an item it depends upon. 
The compiling of a library in the VHDL language has the constraint that a library must be compiled after any library it depends on. 
A tool exists that extracts library dependencies. 


Task

Write a function that will return a valid compile order of VHDL libraries from their dependencies.

Assume library names are single words.
Items mentioned as only dependents, (sic), have no dependents of their own, but their order of compiling must be given.
Any self dependencies should be ignored.
Any un-orderable dependencies should be flagged.

Use the following data as an example:

LIBRARY          LIBRARY DEPENDENCIES
=======          ====================
des_system_lib   std synopsys std_cell_lib des_system_lib dw02 dw01 ramlib ieee
dw01             ieee dw01 dware gtech
dw02             ieee dw02 dware
dw03             std synopsys dware dw03 dw02 dw01 ieee gtech
dw04             dw04 ieee dw01 dware gtech
dw05             dw05 ieee dware
dw06             dw06 ieee dware
dw07             ieee dware
dware            ieee dware
gtech            ieee gtech
ramlib           std ieee
std_cell_lib     ieee std_cell_lib
synopsys


Note: the above data would be un-orderable if, for example, dw04 is added to the list of dependencies of dw01.


C.f.

  Topological sort/Extracted top item.

There are two popular algorithms for topological sorting:

  Kahn's 1962 topological sort [1]
  depth-first search [2] [3]


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,23.0
File input/output,https://rosettacode.org/wiki/File_input/output,File handling,True,," 
Task

Create a file called   ""output.txt"",   and place in it the contents of the file   ""input.txt"",   via an intermediate variable. 
In other words, your program will demonstrate: 

  how to read from a file into a variable
  how to write a variable's contents into a file

Oneliners that skip the intermediate variable are of secondary interest — operating systems have copy commands for that.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,33.0
Linear congruential generator,https://rosettacode.org/wiki/Linear_congruential_generator,Randomness,True,,"
The linear congruential generator is a very simple example of a random number generator. 
All linear congruential generators use this formula:






r

n
+
1


=
a
×

r
n

+
c

(
mod

m
)


{\displaystyle r_{n + 1} = a \times r_n + c \pmod m}



Where:






r
0



{\displaystyle r_0}

 is a seed.





r
1



{\displaystyle r_1}

, 




r
2



{\displaystyle r_2}

, 




r
3



{\displaystyle r_3}

, ..., are the random numbers.




a


{\displaystyle a}

, 



c


{\displaystyle c}

, 



m


{\displaystyle m}

 are constants.

If one chooses the values of 



a


{\displaystyle a}

, 



c


{\displaystyle c}

 and 



m


{\displaystyle m}

 with care, then the generator produces a uniform distribution of integers from 



0


{\displaystyle 0}

 to 



m
−
1


{\displaystyle m - 1}

.
LCG numbers have poor quality. 




r
n



{\displaystyle r_n}

 and 




r

n
+
1




{\displaystyle r_{n + 1}}

 are not independent, as true random numbers would be. Anyone who knows 




r
n



{\displaystyle r_n}

 can predict 




r

n
+
1




{\displaystyle r_{n + 1}}

, therefore LCG is not cryptographically secure. The LCG is still good enough for simple tasks like Miller-Rabin primality test, or FreeCell deals. Among the benefits of the LCG, one can easily reproduce a sequence of numbers, from the same 




r
0



{\displaystyle r_0}

. One can also reproduce such sequence with a different programming language, because the formula is so simple.
The task is to replicate two historic random number generators. One is the rand() function from BSD libc, and the other is the rand() function from the Microsoft C Runtime (MSCVRT.DLL). Each replica must yield the same sequence of integers as the original generator, when starting from the same seed.
In these formulas, the seed becomes 



s
t
a
t

e
0



{\displaystyle state_0}

. The random sequence is 



r
a
n

d
1



{\displaystyle rand_1}

, 



r
a
n

d
2



{\displaystyle rand_2}

 and so on.


BSD formula





s
t
a
t

e

n
+
1


=
1103515245
×
s
t
a
t

e
n

+
12345

(
mod


2

31


)


{\displaystyle state_{n + 1} = 1103515245 \times state_n + 12345 \pmod{2^{31}}}






r
a
n

d
n

=
s
t
a
t

e
n



{\displaystyle rand_n = state_n}






r
a
n

d
n



{\displaystyle rand_n}

 is in range 0 to 2147483647.


Microsoft formula





s
t
a
t

e

n
+
1


=
214013
×
s
t
a
t

e
n

+
2531011

(
mod


2

31


)


{\displaystyle state_{n + 1} = 214013 \times state_n + 2531011 \pmod{2^{31}}}






r
a
n

d
n

=
s
t
a
t

e
n

÷

2

16




{\displaystyle rand_n = state_n \div 2^{16}}






r
a
n

d
n



{\displaystyle rand_n}

 is in range 0 to 32767.

The BSD formula was so awful that FreeBSD switched to a different formula. 
More info is at Random number generator (included)#C.


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,26.0
Random number generator (device),https://rosettacode.org/wiki/Random_number_generator_(device),Randomness,True,,"
Task

If your system has a means to generate random numbers involving not only a software algorithm   (like the /dev/urandom devices in Unix),   then:
show how to obtain a random 32-bit number from that mechanism.

Related task
Random_number_generator_(included)


",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,21.0
Main step of GOST 28147-89,https://rosettacode.org/wiki/Main_step_of_GOST_28147-89,Encryption,True,,"
GOST 28147-89 is a standard symmetric encryption based on a Feistel network. 

The structure of the algorithm consists of three levels:

  encryption modes - simple replacement, application range, imposing a range of feedback and authentication code generation;
  cycles - 32-З, 32-Р and 16-З, is a repetition of the main step;
  main step, a function that takes a 64-bit block of text and one of the eight 32-bit encryption key elements, and uses the replacement table (8x16 matrix of 4-bit values), and returns encrypted block.


Task

Implement the main step of this encryption algorithm.


",1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,11.0
Factors of an integer,https://rosettacode.org/wiki/Factors_of_an_integer,Mathematical operations,True,,"

Task

Compute the   factors   of a positive integer. 
These factors are the positive integers by which the number being factored can be divided to yield a positive integer result. 
(Though the concepts function correctly for zero and negative integers, the set of factors of zero has countably infinite members, and the factors of negative integers can be obtained from the factors of related positive numbers without difficulty;   this task does not require handling of either of these cases). 
Note that every prime number has two factors:   1   and itself.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Dragon curve,https://rosettacode.org/wiki/Dragon_curve,Recursion,True,very long description,"


Create and display a dragon curve fractal. 
(You may either display the curve directly or write it to an image file.)


Algorithms
Here are some brief notes the algorithms used and how they might suit various languages.

Recursively a right curling dragon is a right dragon followed by a left dragon, at 90-degree angle.  And a left dragon is a left followed by a right.
*---R----*     expands to     *       *
                               \     /
                                R   L
                                 \ /
                                  *

                                  *
                                 / \
                                L   R
                               /     \
*---L---*      expands to     *       *
The co-routines dcl and dcr in various examples do this recursively to a desired expansion level.
The curl direction right or left can be a parameter instead of two separate routines.
Recursively, a curl direction can be eliminated by noting the dragon consists of two copies of itself drawn towards a central point at 45-degrees.
*------->*   becomes    *       *     Recursive copies drawn
                         \     /      from the ends towards
                          \   /       the centre.
                           v v
                            *
This can be seen in the SVG example.  This is best suited to off-line drawing since the reversal in the second half means the drawing jumps backward and forward (in binary reflected Gray code order) which is not very good for a plotter or for drawing progressively on screen.
Successive approximation repeatedly re-writes each straight line as two new segments at a right angle,
                       *       
*-----*   becomes     / \      bend to left
                     /   \     if N odd
                    *     *

                    *     *   
*-----*   becomes    \   /     bend to right  
                      \ /      if N even 
                       *
Numbering from the start of the curve built so far, if the segment is at an odd position then the bend introduced is on the right side.  If the segment is an even position then on the left.  The process is then repeated on the new doubled list of segments.  This constructs a full set of line segments before any drawing.
The effect of the splitting is a kind of bottom-up version of the recursions.  See the Asymptote example for code doing this.
Iteratively the curve always turns 90-degrees left or right at each point.  The direction of the turn is given by the bit above the lowest 1-bit of n.  Some bit-twiddling can extract that efficiently.
n = 1010110000
        ^
        bit above lowest 1-bit, turn left or right as 0 or 1

LowMask = n BITXOR (n-1)   # eg. giving 0000011111
AboveMask = LowMask + 1    # eg. giving 0000100000
BitAboveLowestOne = n BITAND AboveMask
The first turn is at n=1, so reckon the curve starting at the origin as n=0 then a straight line segment to position n=1 and turn there.
If you prefer to reckon the first turn as n=0 then take the bit above the lowest 0-bit instead.  This works because ""...10000"" minus 1 is ""...01111"" so the lowest 0 in n-1 is where the lowest 1 in n is.
Going by turns suits turtle graphics such as Logo or a plotter drawing with a pen and current direction.
If a language doesn't maintain a ""current direction"" for drawing then you can always keep that separately and apply turns by bit-above-lowest-1.
Absolute direction to move at point n can be calculated by the number of bit-transitions in n.
n = 11 00 1111 0 1
      ^  ^    ^ ^     4 places where change bit value
                      so direction=4*90degrees=East
This can be calculated by counting the number of 1 bits in ""n XOR (n RIGHTSHIFT 1)"" since such a shift and xor leaves a single 1 bit at each position where two adjacent bits differ.
Absolute X,Y coordinates of a point n can be calculated in complex numbers by some powers (i+1)^k and add/subtract/rotate.  This is done in the gnuplot code.  This might suit things similar to Gnuplot which want to calculate each point independently.
Predicate test for whether a given X,Y point or segment is on the curve can be done.  This might suit line-by-line output rather than building an entire image before printing.  See M4 for an example of this.
A predicate works by dividing out complex number i+1 until reaching the origin, so it takes roughly a bit at a time from X and Y is thus quite efficient.  Why it works is slightly subtle but the calculation is not difficult.  (Check segment by applying an offset to move X,Y to an ""even"" position before dividing i+1.  Check vertex by whether the segment either East or West is on the curve.)
The number of steps in the predicate corresponds to doublings of the curve, so stopping the check at say 8 steps can limit the curve drawn to 2^8=256 points.  The offsets arising in the predicate are bits of n the segment number, so can note those bits to calculate n and limit to an arbitrary desired length or sub-section.
As a Lindenmayer system of expansions.  The simplest is two symbols F and S both straight lines, as used by the PGF code.
Axiom F, angle 90 degrees
F -> F+S
S -> F-S
This always has F at even positions and S at odd.  Eg. after 3 levels F_S_F_S_F_S_F_S.  The +/- turns in between bend to the left or right the same as the ""successive approximation"" method above.  Read more at for instance Joel Castellanos' L-system page.
Variations are possible if you have only a single symbol for line draw, for example the Icon and Unicon and Xfractint code.  The angles can also be broken into 45-degree parts to keep the expansion in a single direction rather than the endpoint rotating around.
The string rewrites can be done recursively without building the whole string, just follow its instructions at the target level.  See for example C by IFS Drawing code.  The effect is the same as ""recursive with parameter"" above but can draw other curves defined by L-systems. 

",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,25.0
"Calendar - for ""REAL"" programmers",https://rosettacode.org/wiki/Calendar_-_for_%22REAL%22_programmers,Date and time,True,,"
Task

Provide an algorithm as per the Calendar task, except the entire code for the algorithm must be presented   entirely without lowercase. 
Also - as per many 1969 era line printers - format the calendar to nicely fill a page that is 132 characters wide.
(Hint: manually convert the code from the Calendar task to all UPPERCASE)
This task also is inspired by Real Programmers Don't Use PASCAL by Ed Post, Datamation, volume 29 number 7, July 1983.

THE REAL PROGRAMMER'S NATURAL HABITAT
""Taped to the wall is a line-printer Snoopy calender for the year 1969.""

Moreover this task is further inspired by the long lost corollary article titled:

""Real programmers think in UPPERCASE""!

Note: Whereas today we only need to worry about ASCII, UTF-8, UTF-16, UTF-32, UTF-7 and UTF-EBCDIC encodings, in the 1960s having code in UPPERCASE was often mandatory as characters were often stuffed into 36-bit words as 6 lots of 6-bit characters. More extreme words sizes include 60-bit words of the CDC 6000 series computers.   The Soviets even had a national character set that was inclusive of all
4-bit,
5-bit,
6-bit &
7-bit depending on how the file was opened... And one rogue Soviet university went further and built a 1.5-bit based computer.
Of course... as us Boomers have turned into Geezers we have become HARD OF HEARING, 
and suffer from chronic Presbyopia, hence programming in UPPERCASE 
is less to do with computer architecture and more to do with practically. :-)
For economy of size, do not actually include Snoopy generation 
in either the code or the output, instead just output a place-holder.  
FYI: a nice ASCII art file of Snoopy can be found at textfiles.com.  Save with a .txt extension.
Trivia: The terms uppercase and lowercase date back to the early days of the mechanical printing press.  Individual metal alloy casts of each needed letter, or punctuation symbol, were meticulously added to a press block, by hand, before rolling out copies of a page. These metal casts were stored and organized in wooden cases. The more often needed minuscule letters were placed closer to hand, in the lower cases of the work bench.  The less often needed, capitalized, majuscule letters, ended up in the harder to reach upper cases.


",0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,14.0
Echo server,https://rosettacode.org/wiki/Echo_server,Networking and Web Interaction,True,,"
Create a network service that sits on TCP port 12321, which accepts connections on that port, and which echoes complete lines (using a carriage-return/line-feed sequence as line separator) back to clients. No error handling is required. For the purposes of testing, it is only necessary to support connections from localhost (127.0.0.1 or perhaps ::1). Logging of connection information to standard output is recommended.
The implementation must be able to handle simultaneous connections from multiple clients. A multi-threaded or multi-process solution may be used. Each connection must be able to echo more than a single line.
The implementation must not stop responding to other clients if one client sends a partial line or stops reading responses.

",1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,21.0
Sockets,https://rosettacode.org/wiki/Sockets,Networking and Web Interaction,True,,"
For this exercise a program is open a socket to localhost on port 256 and send the message ""hello socket world"" before closing the socket. 
Catching any exceptions or errors is not required.


",1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,26.0
Draw a pixel,https://rosettacode.org/wiki/Draw_a_pixel,GUI,True,,"
Task

Create a window and draw a pixel in it, subject to the following:

 the window is 320 x 240
 the color of the pixel must be red (255,0,0)
 the position of the pixel is x = 100, y = 100
",1.0,1.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,16.0
Window creation,https://rosettacode.org/wiki/Window_creation,GUI,True,,"
Display a GUI window. The window need not have any contents, but should respond to requests to be closed.

",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,27.0
Dot product,https://rosettacode.org/wiki/Dot_product,Geometry,True,,"
Task

Create a function/use an in-built function, to compute the   dot product,   also known as the   scalar product   of two vectors. 
If possible, make the vectors of arbitrary length.

As an example, compute the dot product of the vectors:

    [1,  3, -5]       and
    [4,      -2, -1]  

If implementing the dot product of two vectors directly:

  each vector must be the same length
  multiply corresponding terms from each vector
  sum the products   (to produce the answer)


Related task

  Vector products


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,39.0
Sierpinski carpet,https://rosettacode.org/wiki/Sierpinski_carpet,Geometry,True,,"
Task
Produce a graphical or ASCII-art representation of a Sierpinski carpet of order   N. 

For example, the Sierpinski carpet of order   3   should look like this:

###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################
#########         #########
# ## ## #         # ## ## #
#########         #########
###   ###         ###   ###
# #   # #         # #   # #
###   ###         ###   ###
#########         #########
# ## ## #         # ## ## #
#########         #########
###########################
# ## ## ## ## ## ## ## ## #
###########################
###   ######   ######   ###
# #   # ## #   # ## #   # #
###   ######   ######   ###
###########################
# ## ## ## ## ## ## ## ## #
###########################

The use of the   #   character is not rigidly required for ASCII art. 
The important requirement is the placement of whitespace and non-whitespace characters.


Related task

  Sierpinski triangle


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,30.0
Singly-linked list/Element definition,https://rosettacode.org/wiki/Singly-linked_list/Element_definition,Data Structures,True,,"Define the data structure for a singly-linked list element. Said element should contain a data member capable of holding a numeric value, and the link to the next element should be mutable.
See also

Array
Associative array: Creation, Iteration
Collections
Compound data type
Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
Linked list
Queue: Definition, Usage
Set
Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
Stack
",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,27.0
Singly-linked list/Element insertion,https://rosettacode.org/wiki/Singly-linked_list/Element_insertion,Data Structures,True,,"Using the link element defined in Singly-Linked List (element), define a method to insert an element into a singly-linked list following a given element.
Using this method, insert an element C into a list comprised of elements A->B, following element A.

See also

Array
Associative array: Creation, Iteration
Collections
Compound data type
Doubly-linked list: Definition, Element definition, Element insertion, List Traversal, Element Removal
Linked list
Queue: Definition, Usage
Set
Singly-linked list: Element definition, Element insertion, List Traversal, Element Removal
Stack


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,0.0,24.0
Host introspection,https://rosettacode.org/wiki/Host_introspection,Programming environment operations,True,,"
Print the word size and endianness of the host machine.
See also: Variable size/Get

",1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,26.0
Bulls and cows,https://rosettacode.org/wiki/Bulls_and_cows,Puzzles,True,,"
Bulls and Cows   is an old game played with pencil and paper that was later implemented using computers.


Task

Create a four digit random number from the digits   1   to   9,   without duplication.
The program should: 

  ask for guesses to this number
  reject guesses that are malformed
  print the score for the guess

The score is computed as:

The player wins if the guess is the same as the randomly chosen number, and the program ends.
A score of one bull is accumulated for each digit in the guess that equals the corresponding digit in the randomly chosen initial number.
A score of one cow is accumulated for each digit in the guess that also appears in the randomly chosen number, but in the wrong position.


",1.0,1.0,1.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,33.0
Draw a clock,https://rosettacode.org/wiki/Draw_a_clock,Date and time,True,draw stuff,"
Task

Draw a clock.  

More specific:

Draw a time keeping device. It can be a stopwatch, hourglass, sundial, a mouth counting ""one thousand and one"", anything. Only showing the seconds is required, e.g.: a watch with just a second hand will suffice. However, it must clearly change every second, and the change must cycle every so often (one minute, 30 seconds, etc.) It must be drawn; printing a string of numbers to your terminal doesn't qualify. Both text-based and graphical drawing are OK.
The clock is unlikely to be used to control space flights, so it needs not be hyper-accurate, but it should be usable, meaning if one can read the seconds off the clock, it must agree with the system clock.
A clock is rarely (never?) a major application: don't be a CPU hog and poll the system timer every microsecond, use a proper timer/signal/event from your system or language instead. For a bad example, many OpenGL programs update the frame-buffer in a busy loop even if no redraw is needed, which is very undesirable for this task.
A clock is rarely (never?) a major application: try to keep your code simple and to the point. Don't write something too elaborate or convoluted, instead do whatever is natural, concise and clear in your language.


Key points
animate simple object
timed event
polling system resources
code clarity


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,23.0
Simple windowed application,https://rosettacode.org/wiki/Simple_windowed_application,GUI,True,,"
Task

Create a window that has:

  a label that says   ""There have been no clicks yet""
  a button that says   ""click me""

Upon clicking the button with the mouse, the label should change and show the number of times the button has been clicked.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,27.0
Count in octal,https://rosettacode.org/wiki/Count_in_octal,Iteration,True,,"
Task

Produce a sequential count in octal,   starting at zero,   and using an increment of a one for each consecutive number. 
Each number should appear on a single line,   and the program should count until terminated,   or until the maximum value of the numeric type in use is reached.


Related task

  Integer sequence   is a similar task without the use of octal numbers.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,32.0
Mandelbrot set,https://rosettacode.org/wiki/Mandelbrot_set,Geometry,True,"draw stuff, contains external algorithm information","

This page uses content from Wikipedia. The original article was at Mandelbrot_set. The list of authors can be seen in the page history. As with Rosetta Code, the text of Wikipedia is available under the GNU FDL. (See links for details on variance)




Task

Generate and draw the Mandelbrot set. 

Note that there are many algorithms to draw Mandelbrot set and there are many functions which generate it .


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,33.0
Pythagorean triples,https://rosettacode.org/wiki/Pythagorean_triples,Geometry,True,,"
A Pythagorean triple is defined as three positive integers 



(
a
,
b
,
c
)


{\displaystyle (a, b, c)}

 where 



a
<
b
<
c


{\displaystyle a < b < c}

, and 




a
2

+

b
2

=

c
2

.


{\displaystyle a^2+b^2=c^2.}


They are called primitive triples if 



a
,
b
,
c


{\displaystyle a, b, c}

 are co-prime, that is, if their pairwise greatest common divisors 




g
c
d

(
a
,
b
)
=

g
c
d

(
a
,
c
)
=

g
c
d

(
b
,
c
)
=
1


{\displaystyle {\rm gcd}(a, b) = {\rm gcd}(a, c) = {\rm gcd}(b, c) = 1}

. 
Because of their relationship through the Pythagorean theorem, a, b, and c are co-prime if a and b are co-prime (




g
c
d

(
a
,
b
)
=
1


{\displaystyle {\rm gcd}(a, b) = 1}

).   
Each triple forms the length of the sides of a right triangle, whose perimeter is 



P
=
a
+
b
+
c


{\displaystyle P=a+b+c}

.


Task

The task is to determine how many Pythagorean triples there are with a perimeter no larger than 100 and the number of these that are primitive.


Extra credit

Deal with large values.   Can your program handle a maximum perimeter of 1,000,000?   What about 10,000,000?   100,000,000?
Note: the extra credit is not for you to demonstrate how fast your language is compared to others;   you need a proper algorithm to solve them in a timely manner.


",1.0,1.0,1.0,1.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,1.0,0.0,0.0,0.0,1.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,1.0,0.0,0.0,1.0,1.0,0.0,1.0,1.0,0.0,0.0,1.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,1.0,29.0
Playfair cipher,https://rosettacode.org/wiki/Playfair_cipher,Encryption,True,,"


Task

Implement a  Playfair cipher for encryption and decryption.

The user must be able to choose   J  =  I      or   no   Q   in the alphabet.
The output of the encrypted and decrypted message must be in capitalized digraphs, separated by spaces.


Output example

                HI DE TH EG OL DI NT HE TR EX ES TU MP



",1.0,0.0,1.0,1.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,1.0,1.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,0.0,11.0
