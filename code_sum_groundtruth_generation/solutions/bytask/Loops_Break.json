[{"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Python", "code": "\nfrom random import randrange\n\nwhile True:\n    a = randrange(20)\n    print(a)\n    if a == 10:\n        break\n    b = randrange(20)\n    print(b)\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "C", "code": "\nint main(){\n\ttime_t t;\n\tint a, b;\n\tsrand((unsigned)time(&t));\n\tfor(;;){\n\t\ta = rand() % 20;\n\t\tprintf(\"%d\\n\", a);\n\t\tif(a == 10)\n\t\t\tbreak;\n\t\tb = rand() % 20;\n\t\tprintf(\"%d\\n\", b);\n\t}\n\treturn 0;\n}\n\n\n12\n18\n2\n8\n10\n18\n9\n9\n4\n10\n\n", "explain": "Output (example):\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "C++", "code": "\n#include <iostream>\n#include <ctime>\n#include <cstdlib>\n\nint main(){\n\tsrand(time(NULL)); // randomize seed\n\twhile(true){\n\t\tconst int a = rand() % 20; // biased towards lower numbers if RANDMAX\u00a0% 20 > 0\n\t\tstd::cout << a << std::endl;\n\t\tif(a == 10)\n\t\t\tbreak;\n\t\tconst int b = rand() % 20;\n\t\tstd::cout << b << std::endl;\n\t}\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Java", "code": "\nimport java.util.Random;\n\nRandom rand = new Random();\nwhile(true){\n    int a = rand.nextInt(20);\n    System.out.println(a);\n    if(a == 10) break;\n    int b = rand.nextInt(20);\n    System.out.println(b);\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "C#", "code": "\nclass Program\n{\n    static void Main(string[] args)\n    {\n        Random random = new Random();\n        while (true)\n        {\n            int a = random.Next(20);\n            Console.WriteLine(a);\n            if (a == 10)\n                break;\n            int b = random.Next(20)\n            Console.WriteLine(b);\n        }\n           \n        Console.ReadLine();\n    }       \n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "JavaScript", "code": "\nfor (;;) {\n  var a = Math.floor(Math.random() * 20);\n  print(a);\n  if (a == 10) \n    break;\n  a = Math.floor(Math.random() * 20);\n  print(a);\n}\n\n\n(function streamTillInitialTen() {\n    var nFirst = Math.floor(Math.random() * 20);\n        \n    console.log(nFirst);\n    \n    if (nFirst === 10) return true;\n    \n    console.log(\n        Math.floor(Math.random() * 20)\n    );\n    \n    return streamTillInitialTen();\n})();\n\n\n18\n10\n16\n10\n8\n0\n13\n3\n2\n14\n15\n17\n14\n7\n10\n8\n0\n2\n0\n2\n5\n16\n3\n16\n6\n7\n19\n0\n16\n9\n7\n11\n17\n10\n\nconsole.log(\n  (function streamTillInitialTen() {\n    var nFirst = Math.floor(Math.random() * 20);\n  \n    if (nFirst === 10) return [10];\n  \n    return [\n      nFirst,\n      Math.floor(Math.random() * 20)\n    ].concat(\n      streamTillInitialTen()\n    );\n  })().join('\\n')\n);\n\n\n17\n14\n3\n4\n13\n10\n15\n5\n10\n", "explain": "The print() function is available in the Rhino JavaScript shell.\n\nIf we step back for a moment from imperative assumptions about repetitive processes and their interruption, we may notice that there is actually no necessary connection between repetitive process and loops.\nIn a functional idiom of JavaScript, we might instead write something like:\nObtaining runs like:\nThough returning a value composes better, and costs less IO traffic, than firing off side-effects from a moving thread:\nSample result:\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Program\n    Sub Main()\n        ' Initialize with seed 0 to get deterministic output (may vary across .NET versions, though).\n        Dim rand As New Random(0)\n\n        Do\n            Dim first = rand.Next(20) ' Upper bound is exclusive.\n            Console.Write(first & \" \")\n\n            If first = 10 Then Exit Do\n\n            Dim second = rand.Next(20)\n            Console.Write(second & \" \")\n        Loop\n    End Sub\nEnd Module\n\nOutput:\n14 16 15 11 4 11 18 8 19 5 5 9 12 9 19 0 17 19 13 6 16 16 19 0 13 10 18 13 10 \n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "PHP", "code": "\nwhile (true) {\n    $a = rand(0,19);\n    echo \"$a\\n\";\n    if ($a == 10)\n        break;\n    $b = rand(0,19);\n    echo \"$b\\n\";\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram Example\n  implicit none\n\n  real :: r\n  integer :: a, b\n\n  do\n     call random_number(r)\n     a = int(r * 20)\n     write(*,*) a\n     if (a == 10) exit\n     call random_number(r)\n     b = int(r * 20)\n     write(*,*) b\n  end do\n\nend program Example\n\nWorks with: Fortran version 77 and later\n      PROGRAM LOOPBREAK\n        INTEGER I, RNDINT\n\nC       It doesn't matter what number you put here.\n        CALL SDRAND(123)\n\nC       Because FORTRAN 77 semantically lacks many loop structures, we\nC       have to use GOTO statements to do the same thing.\n   10   CONTINUE\nC         Print a random number.\n          I = RNDINT(0, 19)\n          WRITE (*,*) I\n\nC         If the random number is ten, break (i.e. skip to after the end\nC         of the \"loop\").\n          IF (I .EQ. 10) GOTO 20\n\nC         Otherwise, print a second random number.\n          I = RNDINT(0, 19)\n          WRITE (*,*) I\n\nC         This is the end of our \"loop,\" meaning we jump back to the\nC         beginning again.\n          GOTO 10\n\n   20   CONTINUE\n\n        STOP\n      END\n\nC FORTRAN 77 does not come with a random number generator, but it\nC is easy enough to type \"fortran 77 random number generator\" into your\nC preferred search engine and to copy and paste what you find. The\nC following code is a slightly-modified version of:\nC\nC     http://www.tat.physik.uni-tuebingen.de/\nC         ~kley/lehre/ftn77/tutorial/subprograms.html\n      SUBROUTINE SDRAND (IRSEED)\n        COMMON  /SEED/ UTSEED, IRFRST\n        UTSEED = IRSEED\n        IRFRST = 0\n        RETURN\n      END\n      INTEGER FUNCTION RNDINT (IFROM, ITO)\n        INTEGER IFROM, ITO\n        PARAMETER (MPLIER=16807, MODLUS=2147483647,                     &\n     &              MOBYMP=127773, MOMDMP=2836)\n        COMMON  /SEED/ UTSEED, IRFRST\n        INTEGER HVLUE, LVLUE, TESTV, NEXTN\n        SAVE    NEXTN\n        IF (IRFRST .EQ. 0) THEN\n          NEXTN = UTSEED\n          IRFRST = 1\n        ENDIF\n        HVLUE = NEXTN / MOBYMP\n        LVLUE = MOD(NEXTN, MOBYMP)\n        TESTV = MPLIER*LVLUE - MOMDMP*HVLUE\n        IF (TESTV .GT. 0) THEN\n          NEXTN = TESTV\n        ELSE\n          NEXTN = TESTV + MODLUS\n        ENDIF\n        IF (NEXTN .GE. 0) THEN\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + IFROM\n        ELSE\n          RNDINT = MOD(MOD(NEXTN, MODLUS), ITO - IFROM + 1) + ITO + 1\n        ENDIF\n        RETURN\n      END\n\nWorks with: Fortran version 66 and earlier\n\n      SUBROUTINE RANDU(IX,IY,YFL)\nCopied from the IBM1130 Scientific Subroutines Package (1130-CM-02X): Programmer's Manual, page 60.\nCAUTION! This routine's 32-bit variant is reviled by Prof. Knuth and many others for good reason!\n        IY = IX*899\n        IF (IY) 5,6,6\n    5   IY = IY + 32767 + 1\n    6   YFL = IY\n        YFL = YFL/32767.\n      END\n\n      FUNCTION IR19(IX)\n        CALL RANDU(IX,IY,YFL)\n        IX = IY\n        I = YFL*20\n        IF (I - 20) 12,11,11\n   11   I = 19\n   12   IR19 = I\n      END\n\n      IX = 1\nCommence the loop.\n   10 I = IR19(IX)\n      WRITE (6,11) I\n   11 FORMAT (I3)\n      IF (I - 10) 12,20,12\n   12 I = IR19(IX)\n      WRITE (6,11) I\n      GO TO 10\nCease.\n   20 CONTINUE\n      END\n\n\n 0 13  4 19  1  7  2 12  4  7 14 11  6  4  0  9  5 12 16 19 18  2  0 13  2  7 10\n\n\n", "explain": "Anyone who attempts to produce random numbers via a computation is already in a state of sin, so, one might as well be hung as a goat rather than as a lamb. Here is a version using the RANDU generator, in the style of Fortran 66 as offered by the IBM1130. No logical-if statements and reliance on implicit type declarations. Sixteen-bit integers result. The standard advice is to start IX off as an odd number. Note that RANDU does not update IX (the \"seed\"); the caller must do so. Since integer overflow producing negative numbers is undone by adding 32768 (trusting that the compiler will not attempt to combine constants, thus + 32767 + 1) in the absence of an AND operation, possible values for IY are presumably zero to 32767. Since IY is divided by 32767.0 (not 32768.0 for example), the range for YFL is zero to one inclusive, though further inspection shows that zero is not attained for proper starts - should IX be zero it will never change, thus the span is (0,1]; a more common arrangement is [0,1).\nBecause the upper bound is attainable, multiplying YFL by 19 and truncating the result will mean that 19 appears only as an edge event when IY = 32767. Multiplying by 20 will ensure that 19 gets its fair share along with each other integer, but, the edge event might now occasionally produce a 20. There is no MIN function available, so, explicit testing results. Rather than repeat this code with its consequent litter of labels, a helper function IR19 does the work once. These out-by-one opportunities are vexing.\nThe RANDU routine is so notorious that latter-day compilers can supply their own RANDU (using a better method), and further, disregard a user-supplied RANDU routine so it may have to be called RANDUU or some other name!\nOutput, converted to along the line:\nThis source will compile with later compilers (possibly after adding INTEGER*2 declarations to not use larger integers), as well as earlier compilers. But the IBM1620's Fortran II ran on a decimal computer (and the compiler allowed an option to specify how many digits in a number) so the assumption of sixteen-bit two's-complement arithmetic would fail. There was once much more variety in computer design, not just always a power of two in word sizes.\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\nimport \"math/rand\"\nimport \"time\"\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    for {\n        a := rand.Intn(20)\n        fmt.Println(a)\n        if a == 10 {\n            break\n        }\n        b := rand.Intn(20)\n        fmt.Println(b)\n    }\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program loopbreak.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessEndLoop: .asciz \"loop break with value\u00a0: \\n\"\nszMessResult:  .ascii \"Resultat = \"      @ message result\nsMessValeur:   .fill 12, 1, ' '\n                   .asciz \"\\n\"\n.align 4\niGraine:  .int 123456\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                @ entry of program \n    push {fp,lr}      @ saves 2 registers \n1:    @ begin loop \n    mov r4,#20\n2:\n    mov r0,#19\n    bl genereraleas               @ generate number\n    cmp r0,#10                       @ compar value\n    beq 3f                         @ break if equal\n    ldr r1,iAdrsMessValeur     @ display value\n    bl conversion10             @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    subs r4,#1                   @ decrement counter\n    bgt 2b                      @ loop if greather\n    b 1b                          @ begin loop one\n\t\n3:\n    mov r2,r0             @ save value\n    ldr r0,iAdrszMessEndLoop\n    bl affichageMess            @ display message\n    mov r0,r2\n    ldr r1,iAdrsMessValeur                \n    bl conversion10       @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n\n100:   @ standard end of the program \n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    svc #0                       @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszMessResult:         .int szMessResult\niAdrszMessEndLoop:        .int szMessEndLoop\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}      @ save  registres\n    mov r2,#0                  @ counter length \n1:      @ loop length calculation \n    ldrb r1,[r0,r2]           @ read octet start position + index \n    cmp r1,#0                  @ if 0 its over \n    addne r2,r2,#1            @ else add 1 in the length \n    bne 1b                    @ and loop \n                                @ so here r2 contains the length of the message \n    mov r1,r0        \t\t\t@ address message in r1 \n    mov r0,#STDOUT      \t\t@ code to write to the standard output Linux \n    mov r7, #WRITE             @ code call system \"write\" \n    svc #0                      @ call systeme \n    pop {r0,r1,r2,r7,lr}        @ restaur des  2 registres */ \n    bx lr                       @ return  \n/******************************************************************/\n/*     Converting a register to a decimal                                 */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\nconversion10:\n    push {r1-r4,lr}    @ save registers \n    mov r3,r1\n    mov r2,#10\n\n1:\t   @ start loop\n    bl divisionpar10 @ r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48        @ digit\t\n    strb r1,[r3,r2]  @ store digit on area\n    sub r2,#1         @ previous position\n    cmp r0,#0         @ stop if quotient = 0 */\n    bne 1b\t          @ else loop\n    @ and move spaces in first on area\n    mov r1,#' '   @ space\t\n2:\t\n    strb r1,[r3,r2]  @ store space in area\n    subs r2,#1       @ @ previous position\n    bge 2b           @ loop if r2 >= z\u00e9ro \n\n100:\t\n    pop {r1-r4,lr}    @ restaur registres \n    bx lr\t          @return\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}   /* save registers  */\n    mov r4,r0 \n    mov r3,#0x6667   @ r3 <- magic_number  lower\n    movt r3,#0x6666  @ r3 <- magic_number  upper\n    smull r1, r2, r3, r0   @ r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) \n    mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n    mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n    add r0, r2, r1         /* r0 <- r2 + r1 */\n    add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n    sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n    pop {r2-r4}\n    bx lr                  /* leave function */\n\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* r0 contains limit  */\ngenereraleas:\n    push {r1-r4,lr}    @ save registers \n    ldr r4,iAdriGraine\n    ldr r2,[r4]\n    ldr r3,iNbDep1\n    mul r2,r3,r2\n    ldr r3,iNbDep1\n    add r2,r2,r3\n    str r2,[r4]     @ maj de la graine pour l appel suivant \n\n    mov r1,r0        @ divisor\n    mov r0,r2        @ dividende\n    bl division\n    mov r0,r3       @  r\u00e9sult = remainder\n  \n100:                @ end function\n    pop {r1-r4,lr}   @ restaur registers\n    bx lr            @ return\n/********************************************************************/\niAdriGraine: .int iGraine\t\niNbDep1: .int 0x343FD\niNbDep2: .int 0x269EC3 \n/***************************************************/\n/* integer division unsigned                       */\n/***************************************************/\ndivision:\n    /* r0 contains dividend */\n    /* r1 contains divisor */\n    /* r2 returns quotient */\n    /* r3 returns remainder */\n    push {r4, lr}\n    mov r2, #0                @ init quotient\n    mov r3, #0                @ init remainder\n    mov r4, #32               @ init counter bits\n    b 2f\n1:          @ loop \n    movs r0, r0, LSL #1     @ r0 <- r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1)\n    adc r3, r3, r3           @ r3 <- r3 + r3 + C. This is equivalent to r3 <- (r3 << 1) + C \n    cmp r3, r1               @ compute r3 - r1 and update cpsr \n    subhs r3, r3, r1        @ if r3 >= r1 (C=1) then r3 <- r3 - r1 \n    adc r2, r2, r2           @ r2 <- r2 + r2 + C. This is equivalent to r2 <- (r2 << 1) + C \n2:\n    subs r4, r4, #1          @ r4 <- r4 - 1 \n    bpl 1b                  @ if r4 >= 0 (N=0) then loop\n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Delphi", "code": "\nprogram Project5;\n\n{$APPTYPE CONSOLE}\n\nvar\n  num:Integer;\nbegin\n  Randomize;\n  while true do\n  begin\n    num:=Random(20);\n    Writeln(num);\n    if num=10 then break;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Ruby", "code": "\nloop do\n  a = rand(20)\n  print a\n  if a == 10\n    puts\n    break\n  end\n  b = rand(20)\n  puts \"\\t#{b}\"\nend\n\n\nloop do\n  print a = rand(20)\n  puts or break if a == 10\n  puts \"\\t#{rand(20)}\"\nend\n\nOutput:\n0       4\n11      0\n8       2\n12      13\n3       0\n6       9\n2       8\n12      10\n8       17\n12      6\n10\n\n", "explain": "or\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Rust", "code": "\nLibrary: rand\n// cargo-deps: rand\n\nextern crate rand;\nuse rand::{thread_rng, Rng};\n \nfn main() {\n    let mut rng = thread_rng();\n    loop {\n        let num = rng.gen_range(0, 20);\n        if num == 10 {\n            println!(\"{}\", num);\n            break;\n        }\n        println!(\"{}\", rng.gen_range(0, 20));\n    }\n}\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Swift", "code": "\nwhile true\n{\n  let a = Int(arc4random())\u00a0% (20)\n  print(\"a: \\(a)\",terminator: \"   \")\n  if (a == 10)\n  {\n    break\n  }\n  let b = Int(arc4random())\u00a0% (20)\n  print(\"b: \\(b)\")\n}\nOutput:\na: 2   b: 7\na: 16   b: 13\na: 18   b: 16\na: 10   \n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "R", "code": "\nWorks with: R version 2.8.1\nsample0to19 <- function() sample(0L:19L, 1,replace=TRUE)\nrepeat\n{\n  result1 <- sample0to19()\n  if (result1 == 10L)\n  {\n    print(result1)\n    break\n  }\n  result2 <- sample0to19()\n  cat(result1, result2, \"\\n\")\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "COBOL", "code": "\nWorks with: OpenCOBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Random-Nums.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  Num  PIC Z9.\n\n       PROCEDURE DIVISION.\n       Main.\n           PERFORM FOREVER\n               PERFORM Generate-And-Display-Num\n\n               IF Num = 10\n                   EXIT PERFORM\n               ELSE\n                   PERFORM Generate-And-Display-Num\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n       Generate-And-Display-Num.\n           COMPUTE Num =  FUNCTION REM(FUNCTION RANDOM * 100, 20)\n           DISPLAY Num\n           .\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\n\nprocedure Test_Loop_Break is\n   type Value_Type is range 0..19;\n   package Random_Values is new Ada.Numerics.Discrete_Random (Value_Type);\n   use Random_Values;\n   Dice : Generator;\n   A, B : Value_Type;\nbegin\n   loop\n      A := Random (Dice);\n      Put_Line (Value_Type'Image (A));\n      exit when A = 10;\n      B := Random (Dice);\n      Put_Line (Value_Type'Image (B));\n   end loop;\nend Test_Loop_Break;\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Julia", "code": "\nwhile true\n    n = rand(0:19)\n    @printf \"%4d\" n\n    if n == 10\n        println()\n        break\n    end\n    n = rand(0:19)\n    @printf \"%4d\\n\" n\nend\n\n\nOutput:\n   0  11\n  11   7\n   4  19\n   7  19\n   5   2\n   5  17\n  12   5\n  14  18\n   1  10\n  18  14\n  16   0\n  17   1\n  10\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "SAS", "code": "\ndata _null_;\ndo while(1);\n   n=floor(uniform(0)*20);\n   put n;\n   if n=10 then leave;    /* 'leave' to break a loop */\nend;\nrun;\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Kotlin", "code": "\nimport kotlin.random.Random\n\nfun main() {\n    while (true) {\n        val a = Random.nextInt(20)\n        println(a)\n        if (a == 10) break\n        println(Random.nextInt(20))\n    }\n}\n\n\nimport kotlin.random.Random\n\nfun main() {\n    while (Random.nextInt(20).also { println(it) } != 10)\n        println(Random.nextInt(20))\n}\n\n", "explain": "A more compact version:\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Perl", "code": "\nwhile (1) {\n    my $a = int(rand(20));\n    print \"$a\\n\";\n    if ($a == 10) {\n        last;\n    }\n    my $b = int(rand(20));\n    print \"$b\\n\";\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Lua", "code": "\nrepeat\n  k = math.random(19)\n  print(k)\n  if k == 10 then break end\n  print(math.random(19)\nuntil false\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Scala", "code": "\nscala> import util.control.Breaks.{breakable, break}\nimport util.control.Breaks.{breakable, break}\n\nscala> import util.Random\nimport util.Random\n\nscala> breakable {\n     |   while(true) {\n     |     val a = Random.nextInt(20)\n     |     println(a)\n     |     if(a == 10)\n     |       break\n     |     val b = Random.nextInt(20)\n     |     println(b)\n     |   }\n     | }\n5\n4\n10\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Transact-SQL", "code": "\nDECLARE @i INT;\nWHILE 1=1\nBEGIN\n    SET @i = ABS(CHECKSUM(NewId()))\u00a0% 20;\n    PRINT @i;\n    IF @i=10 BREAK;\n    PRINT ABS(CHECKSUM(NewId()))\u00a0% 20;\nEND;\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "D", "code": "\nimport std.stdio, std.random;\n\nvoid main() {\n    while (true) {\n        int r = uniform(0, 20);\n        write(r, \" \");\n        if (r == 10)\n            break;\n        write(uniform(0, 20), \" \");\n    }\n}\n\n\nOutput:\n2 4 9 5 3 7 4 4 14 14 3 7 13 8 13 6 10 \n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Haskell", "code": "\nimport Control.Monad\nimport System.Random\n\nloopBreak n k = do \n  r <- randomRIO (0,n)\n  print r\n  unless (r==k) $ do\n    print =<< randomRIO (0,n)\n    loopBreak n k\n\n\nloopBreak 19 10\n\n", "explain": "Use:\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "VBScript", "code": "\n\nDim a, b, i\n\nDo\n    a = Int(Rnd * 20)\n    WScript.StdOut.Write a \n    If a = 10 Then Exit Do\n    b = Int(Rnd * 20)\n    WScript.Echo vbNullString, b\nLoop\n\nFor i = 1 To 100000\n    a = Int(Rnd * 20)\n    WScript.StdOut.Write a \n    If a = 10 Then Exit For\n    b = Int(Rnd * 20)\n    WScript.Echo vbNullString, b\nNext\n", "explain": "Based on BASIC version. Demonstrates breaking out of Do/Loop and For/Next (Exit is good for getting out of functions and subs as well).\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Scheme", "code": "\n(let loop ((first (random 20)))\n  (print first)\n  (if (not (= first 10))\n      (begin\n        (print (random 20))\n        (loop (random 20)))))\n\n(call/cc \n (lambda (break)\n   (let loop ((first (random 20)))\n     (print first)\n     (if (= first 10)\n         (break))\n     (print (random 20))\n     (loop (random 20)))))\n", "explain": "Or by using call/cc to break out:\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "PowerShell", "code": "\n$r = New-Object Random\nfor () {\n    $n = $r.Next(20)\n    Write-Host $n\n    if ($n -eq 10) {\n        break\n    }\n    Write-Host $r.Next(20)\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "ColdFusion", "code": "\n<Cfset randNum = 0>\n<cfloop condition=\"randNum neq 10\">\n  <Cfset randNum = RandRange(0, 19)>\n  <Cfoutput>#randNum#</Cfoutput>\n  <Cfif randNum eq 10><cfbreak></Cfif>\n  <Cfoutput>#RandRange(0, 19)#</Cfoutput>\n  <Br>\n</cfloop>\n\n\nOutput:\n\n6 0 \n9 6 \n12 3 \n6 0 \n14 10 \n19 12 \n18 14 \n19 8 \n3 2 \n19 1 \n11 12 \n16 9 \n11 15 \n3 19 \n13 8 \n6 4 \n4 4 \n13 17 \n16 9 \n5 12 \n12 6 \n4 14 \n1 10 \n3 7 \n11 15 \n11 8 \n0 16 \n16 14 \n8 14 \n11 10 \n8 8 \n16 11 \n4 7 \n19 10 \n8 2 \n15 11 \n18 10 \n1 2 \n18 9 \n4 9 \n6 6 \n11 8 \n14 6 \n17 15 \n13 2 \n2 0 \n2 17 \n8 17 \n18 13 \n11 5 \n15 18 \n17 8 \n15 3 \n7 17 \n7 13 \n15 14 \n11 9 \n10\n\n10\n\n", "explain": "My first two test outputs (I swear this is true)\n"}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "F#", "code": "\n// Loops/Break. Nigel Galloway: February 21st., 2022\nlet n=System.Random()\nlet rec fN g=printf \"%d \" g; if g <> 10 then fN(n.Next(20))\nfN(n.Next(20))\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Groovy", "code": "\nfinal random = new Random()\n\nwhile (true) {\n    def random1 = random.nextInt(20)\n    print random1\n    if (random1 == 10) break\n    print '     '\n    println random.nextInt(20)\n}\n\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const RndGen = std.rand.DefaultPrng;\n    var rnd = RndGen.init(42);\n    // possible improvement: make rng fair\n    var rand_num1: u5 = undefined;\n    var rand_num2: u5 = undefined;\n    while (true) {\n        rand_num1 = rnd.random().int(u5)\u00a0% 20;\n        try std.io.getStdOut().writer().print(\"{d}\\n\", .{rand_num1});\n        if (rand_num1 == 10)\n            break;\n        rand_num2 = rnd.random().int(u5)\u00a0% 20;\n        try std.io.getStdOut().writer().print(\"{d}\\n\", .{rand_num2});\n    }\n}\n", "explain": ""}, {"task_name": "Loops/Break", "task_url": "https://rosettacode.org/wiki/Loops/Break", "task_cat": "Iteration", "lang": "AWK", "code": "\nBEGIN {\n    srand()  # randomize the RNG\n\tfor (;;) {\n\t\tprint n = int(rand() * 20)\n\t\tif (n == 10)\n\t\t\tbreak\n\t\tprint int(rand() * 20)\n\t}\n}\n\n", "explain": ""}]