[{"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Python", "code": "\n\nclass LinkedList(object):\n     \"\"\"USELESS academic/classroom example of a linked list implemented in Python.\n        Don't ever consider using something this crude!  Use the built-in list() type!\n     \"\"\"\n\tclass Node(object):\n\t\tdef __init__(self, item):\n\t\t\tself.value  = item\n\t\t\tself.next = None\n\tdef __init__(self, item=None):\n\t\tif item is not None:\n\t\t\tself.head = Node(item); self.tail = self.head\n\t\telse:\n\t\t\tself.head = None; self.tail = None\n\tdef append(self, item):\n\t\tif not self.head:\n\t\t\tself.head = Node(item)\n\t\t\tself.tail = self.head\n\t\telif self.tail:\n\t\t\tself.tail.next = Node(item)\n\t\t\tself.tail = self.tail.next\n\t\telse:\n\t\t\tself.tail = Node(item)\n\tdef __iter__(self):\n\t\tcursor = self.head\n\t\twhile cursor:\n\t\t\tyield cursor.value\n\t\t\tcursor = cursor.next\n\n\n", "explain": "The Node class implements also iteration for more Pythonic iteration over linked lists.\nNote: As explained in this class' docstring implementing linked lists and nodes in Python is an utterly pointless academic exercise.  It may give on the flavor of the elements that would be necessary in some other programming languages (e.g. using Python as \"executable psuedo-code\").  Adding methods for finding, counting, removing and inserting elements is left as an academic exercise to the reader.  For any practical application use the built-in list() or dict() types as appropriate.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "C", "code": "\nstruct link {\n  struct link *next;\n  int data;\n};\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "C++", "code": "\n\nstruct link\n{\n  link* next;\n  int data;\n};\n\n\nstruct link\n{\n  link* next;\n  int data;\n  link(int a_data, link* a_next = 0): next(a_next), data(a_data) {}\n};\n\n\n link* small_primes = new link(2, new link(3, new link(5, new link(7))));\n\n\ntemplate<typename T> struct link\n{\n  link* next;\n  T data;\n  link(T a_data, link* a_next = 0): next(a_next), data(a_data) {}\n};\n\n\n", "explain": "The simplest C++ version looks basically like the C version:\nInitialization of links on the heap can be simplified by adding a constructor:\nWith this constructor, new nodes can be initialized directly at allocation; e.g. the following code creates a complete list with just one statement:\nHowever, C++ also allows to make it generic on the data type (e.g. if you need large numbers, you might want to use a larger type than int, e.g. long on 64-bit platforms, long long on compilers that support it, or even a bigint class).\nNote that the generic version works for any type, not only integral types.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Java", "code": "\n\nclass Link\n{\n    Link next;\n    int data;\n}\n\n\nclass Link\n{\n    Link next;\n    int data;\n    Link(int a_data, Link a_next) { next = a_next; data = a_data; }\n}\n\n\n Link small_primes = new Link(2, new Link(3, new Link(5, new Link(7, null))));\n\nWorks with: Java version 1.5+\n\nclass Link<T>\n{\n  Link<T> next;\n  T data;\n  Link(T a_data, Link<T> a_next) { next = a_next; data = a_data; }\n}\n\n", "explain": "The simplest Java version looks basically like the C++ version:\nInitialization of links on the heap can be simplified by adding a constructor:\nWith this constructor, new nodes can be initialized directly at allocation; e.g. the following code creates a complete list with just one statement:\nHowever, Java also allows to make it generic on the data type. This will only work on reference types, not primitive types like int or float (wrapper classes like Integer and Float are available).\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "C#", "code": "\nclass LinkedListNode\n{\n    public int Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    // A constructor is not necessary, but could be useful.\n    public Link(int value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n\n\nclass LinkedListNode<T>\n{\n    public T Value { get; set; }\n    public LinkedListNode Next { get; set; }\n\n    public Link(T value, LinkedListNode next = null)\n    {\n        Item = value;\n        Next = next;\n    }\n}\n\n\nunsafe struct link {\n    public link* next;\n    public int data;\n};\n\n", "explain": "A generic version:\nThe most C-like possible version is basically C.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\nfunction LinkedList(value, next) {\n    this._value = value;\n    this._next = next;\n}\nLinkedList.prototype.value = function() {\n    if (arguments.length == 1) \n        this._value = arguments[0];\n    else\n        return this._value;\n}\nLinkedList.prototype.next = function() {\n    if (arguments.length == 1) \n        this._next = arguments[0];\n    else\n        return this._next;\n}\n\n// convenience function to assist the creation of linked lists.\nfunction createLinkedListFromArray(ary) {\n    var head = new LinkedList(ary[0], null);\n    var prev = head;\n    for (var i = 1; i < ary.length; i++) {\n        var node = new LinkedList(ary[i], null);\n        prev.next(node);\n        prev = node;\n    }\n    return head;\n}\n\nvar head = createLinkedListFromArray([10,20,30,40]);\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Fortran", "code": "\n\ntype node\n   real :: data\n   type( node ), pointer :: next => null() \nend type node\n!\n!. . . .\n!\ntype( node ) :: head\n\n", "explain": "In ISO Fortran 95 or later:\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Go", "code": "\ntype Ele struct {\n    Data interface{}\n    Next *Ele\n}\n\nfunc (e *Ele) Append(data interface{}) *Ele {\n    if e.Next == nil {\n        e.Next = &Ele{data, nil}\n    } else {\n        tmp := &Ele{data, e.Next}\n        e.Next = tmp\n    }\n    return e.Next\n}\n\nfunc (e *Ele) String() string {\n    return fmt.Sprintf(\"Ele: %v\", e.Data)\n}\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program defList.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ READ,   3\n.equ WRITE,  4\n\n.equ NBELEMENTS,      100                @ list size\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure linkedlist*/\n    .struct  0\nllist_next:                             @ next element\n    .struct  llist_next + 4 \nllist_value:                            @ element value\n    .struct  llist_value + 4 \nllist_fin:\n/* Initialized data */\n.data\nszMessInitListe:         .asciz \"List initialized.\\n\"\nszCarriageReturn:        .asciz \"\\n\"\n/* datas error display */\nszMessErreur:            .asciz \"Error detected.\\n\"\n\n/* UnInitialized data */\n.bss \nlList1:                  .skip llist_fin * NBELEMENTS    @ list memory place \n\n/*  code section */\n.text\n.global main \nmain: \n    ldr r0,iAdrlList1\n    mov r1,#0\n    str r1,[r0,#llist_next]\n    ldr r0,iAdrszMessInitListe\n    bl affichageMess\n\n100:                                    @ standard end of the program\n    mov r7, #EXIT                       @ request to exit program\n    svc 0                               @ perform system call\niAdrszMessInitListe:       .int szMessInitListe\niAdrszMessErreur:          .int szMessErreur\niAdrszCarriageReturn:      .int szCarriageReturn\niAdrlList1:                .int lList1\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "X86_Assembly", "code": "\n\n\n; x86_64 Linux NASM\n; Linked_List_Definition.asm\n\n%ifndef LinkedListDefinition\n%define LinkedListDefinition\n\nstruc link\n  value: resd 1\n  next: resq 1\n  linkSize:\nendstruc\n\n%endif\n\nWorks with: NASM\nstruct link\n.next: resd 1\n.data: resd 1\nendstruc\n\n\nlink resb 16\n\n\nWorks with: MASM\nlink struct\nnext dd ?\ndata dd ?\nlink ends\n\nWorks with: FASM\nstruc link next,data\n{\n    .next dd next\n    .data dd data\n}\n\n", "explain": "This file will be included in the singly-linked list operation implementations\nOf course, ASM not natively having structures we can simply do..\nWhich would reserve 16 bytes(2 dwords). We could just simply think of it in the form of a structure.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Delphi", "code": "\n\nType\n  pOneWayList = ^OneWayList;\n  OneWayList = record\n                pData : pointer ;\n                Next  : pOneWayList ;\n               end;\n\n", "explain": "A simple one way list. I use a generic pointer for the data that way it can point to any structure, individual variable or whatever. Note that in Standard Pascal, there are no generic pointers, therefore one has to settle for a specific data type there.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Ruby", "code": "\nclass ListNode\n  attr_accessor :value, :succ\n\n  def initialize(value, succ=nil)\n    self.value = value\n    self.succ = succ\n  end\n\n  def each(&b)\n    yield self\n    succ.each(&b) if succ\n  end\n\n  include Enumerable\n\n  def self.from_array(ary)\n    head = self.new(ary[0], nil)\n    prev = head\n    ary[1..-1].each do |val|\n      node = self.new(val, nil)\n      prev.succ = node\n      prev = node\n    end\n    head\n  end\nend\n\nlist = ListNode.from_array([1,2,3,4])\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Rust", "code": "\n\n struct Node<T> {\n    elem: T,\n    next: Option<Box<Node<T>>>,\n}\n\n\ntype Link<T> = Option<Box<Node<T>>>; // Type alias\npub struct List<T> { // User-facing interface for list\n    head: Link<T>,\n}\n\nstruct Node<T> { // Private implementation of Node\n    elem: T,\n    next: Link<T>,\n}\n\nimpl<T> List<T> {\n    #[inline]\n    pub fn new() -> Self { // List constructor\n        List { head: None }\n    // Add other methods here\n}\n\n\nextern crate LinkedList; // Name is arbitrary here\n\nuse LinkedList::List;\n\nfn main() {\n    let list = List::new();\n    // Do stuff\n}\n\n", "explain": "Rust's Option<T> type make the definition of a singly-linked list trivial. The use of Box<T> (an owned pointer) is necessary because it has a known size, thus making sure the struct that contains it can have a finite size. \nHowever, the above example would not be suitable for a library because, first and foremost, it is private by default but simply making it public would not allow for any encapsulation. \nThen a separate program could utilize the basic implementation above like so:\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Swift", "code": "\nclass Node<T>{\n    var data: T = nil\n    var next: Node? = nil\n    init(input: T){\n        data = input\n        next = nil\n    }\n}\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Ada", "code": "\ntype Link;\ntype Link_Access is access Link;\ntype Link is record\n   Next : Link_Access := null;\n   Data : Integer;\nend record;\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nabstract type AbstractNode{T} end\n\nstruct EmptyNode{T} <: AbstractNode{T} end\nmutable struct Node{T} <: AbstractNode{T}\n    data::T\n    next::AbstractNode{T}\nend\nNode{T}(x) where T = Node{T}(x::T, EmptyNode{T}())\n\nmutable struct LinkedList{T}\n    head::AbstractNode{T}\nend\nLinkedList{T}() where T = LinkedList{T}(EmptyNode{T}())\nLinkedList() = LinkedList{Any}()\n\nBase.isempty(ll::LinkedList) = ll.head isa EmptyNode\nfunction lastnode(ll::LinkedList)\n    if isempty(ll) throw(BoundsError()) end\n    nd = ll.head\n    while !(nd.next isa EmptyNode)\n        nd = nd.next\n    end\n    return nd\nend\n\nfunction Base.push!(ll::LinkedList{T}, x::T) where T\n    nd = Node{T}(x)\n    if isempty(ll)\n        ll.head = nd\n    else\n        tail = lastnode(ll)\n        tail.next = nd\n    end\n    return ll\nend\nfunction Base.pop!(ll::LinkedList{T}) where T\n    if isempty(ll)\n        throw(ArgumentError(\"list must be non-empty\"))\n    elseif ll.head.next isa EmptyNode\n        nd = ll.head\n        ll.head = EmptyNode{T}()\n    else\n        nx = ll.head\n        while !isa(nx.next.next, EmptyNode)\n            nx = nx.next\n        end\n        nd = nx.next\n        nx.next = EmptyNode{T}()\n    end\n    return nd.data\nend\n\nlst = LinkedList{Int}()\npush!(lst, 1)\npush!(lst, 2)\npush!(lst, 3)\npop!(lst) # 3\npop!(lst) # 2\npop!(lst) # 1\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nclass Node<T: Number>(var data: T, var next: Node<T>? = null) {\n    override fun toString(): String {\n        val sb = StringBuilder(this.data.toString())\n        var node = this.next\n        while (node != null) {\n            sb.append(\" -> \", node.data.toString())\n            node = node.next\n        }\n        return sb.toString()\n    }\n}\n\nfun main(args: Array<String>) {\n    val n = Node(1, Node(2, Node(3)))\n    println(n)\n}\n\n\nOutput:\n1 -> 2 -> 3\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Perl", "code": "\n\nmy %node = (\n    data => 'say what',\n    next => \\%foo_node,\n);\n$node{next} = \\%bar_node;  # mutable\n\n", "explain": "Just use an array. You can traverse and splice it any way. Linked lists are way too low level.\nHowever, if all you got is an algorithm in a foreign language, you can use references to accomplish the translation.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\n@interface RCListElement<T> : NSObject\n{\n  RCListElement<T> *next;\n  T datum;\n}\n- (RCListElement<T> *)next;\n- (T)datum;\n- (RCListElement<T> *)setNext: (RCListElement<T> *)nx;\n- (void)setDatum: (T)d;\n@end\n\n@implementation RCListElement\n- (RCListElement *)next\n{\n  return next;\n}\n- (id)datum\n{\n  return datum;\n}\n- (RCListElement *)setNext: (RCListElement *)nx\n{\n  RCListElement *p = next;\n  next = nx;\n  return p;\n}\n- (void)setDatum: (id)d\n{\n  datum = d;\n}\n@end\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Scala", "code": "\n\nsealed trait List[+A]\ncase class Cons[+A](head: A, tail: List[A]) extends List[A]\ncase object Nil extends List[Nothing]\n\nobject List {\n  def apply[A](as: A*): List[A] =\n    if (as.isEmpty) Nil else Cons(as.head, apply(as.tail: _*))\n}\n\n\ndef main(args: Array[String]): Unit = {\n  val words = List(\"Rosetta\", \"Code\", \"Scala\", \"Example\")\n}\n\n", "explain": "Immutable lists that you can use with pattern matching.\nBasic usage\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "D", "code": "\n\nstruct SLinkedNode(T) {\n    T data;\n    typeof(this)* next;\n}\n\nvoid main() {\n    alias SLinkedNode!int N;\n    N* n = new N(10);\n}\n\n\n", "explain": "Generic template-based node element.\nAlso the Phobos library contains a singly-linked list, std.container.SList. Tango contains tango.util.collection.LinkSeq.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\n data List a = Nil | Cons a (List a)\n\n\n data IntList s = Nil | Cons Integer (STRef s (IntList s))\n\n\n", "explain": "This task is not idiomatic for Haskell. Usually, all data in pure functional programming is immutable, and deconstructed through Pattern Matching. The Prelude already contains a parametrically polymorphic list type that can take any data member type, including numeric values. These lists are then used very frequently. Because of this, lists have additional special syntactic sugar.\nAn equivalent declaration for such a list type without the special syntax would look like this:\nA declaration like the one required in the task, with an integer as element type and a mutable link, would be\nbut that would be really awkward to use.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Scheme", "code": "\n\n(cons value next)\n\n\n(car my-list) ; returns the first element of the list\n(cdr my-list) ; returns the remainder of the list\n\n\n(set-car! my-list new-elem)\n(set-cdr! my-list new-next)\n\n", "explain": "Scheme, like other Lisp dialects, has extensive support for singly-linked lists. The element of such a list is known as a cons-pair, because you use the cons function to construct it:\nThe value and next-link parts of the pair can be deconstructed using the car and cdr functions, respectively:\nEach of these parts are mutable and can be set using the set-car! and set-cdr! functions, respectively:\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Logo", "code": "\n\nfput item list\u00a0; add item to the head of a list\n\nfirst list \u00a0; get the data\nbutfirst list\u00a0; get the remainder\nbf list      \u00a0; contraction for \"butfirst\"\n\n.setfirst list value\n.setbf list remainder\n", "explain": "As with other list-based languages, simple lists are represented easily in Logo.\nThese return modified lists, but you can also destructively modify lists. These are normally not used because you might accidentally create cycles in the list.\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\nclass ListNode {\n    Object payload\n    ListNode next\n    String toString() { \"${payload} -> ${next}\" }\n}\n\n\ndef n1 = new ListNode(payload:25)\nn1.next = new ListNode(payload:88)\n\nprintln n1\n\n\n25 -> 88 -> null\n", "explain": "Solution:\nTest:\nOutput:\n"}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n \nvar arena = std.heap.ArenaAllocator.init(std.heap.page_allocator);\n \nconst allocator = arena.allocator();\n \npub fn LinkedList(comptime Value: type) type {\n    return struct {\n        const This = @This();\n \n        const Node = struct {\n            value: Value,\n            next: ?*Node,\n        };\n \n        head: ?*Node,\n        tail: ?*Node,\n \n        pub fn init() This {\n            return LinkedList(Value) {\n                .head = null,\n                .tail = null,\n            };\n        }\n \n        pub fn add(this: *This, value: Value) !void {\n            var newNode = try allocator.create(Node);\n \n            newNode.* = .{ .value = value, .next = null };\n \n            if (this.tail) |tail| {\n                tail.next = newNode;\n                this.tail = newNode;\n            } else if (this.head) |head| {\n                head.next = newNode;\n                this.tail = newNode;\n            } else {\n                this.head = newNode;\n            }\n        }\n    };\n}\n\n", "explain": ""}, {"task_name": "Singly-linked list/Element definition", "task_url": "https://rosettacode.org/wiki/Singly-linked_list/Element_definition", "task_cat": "Data Structures", "lang": "AWK", "code": "\n\nBEGIN {\n    NIL = 0\n    HEAD = 1\n    LINK = 1\n    VALUE = 2\n \n    delete list\n    initList()\n}\n\nfunction initList() {\n    delete list\n    list[HEAD] = makeNode(NIL, NIL)\n}\n\nfunction makeNode(link, value) {\n    return link SUBSEP value\n}\n\nfunction getNode(part, nodePtr,    linkAndValue) {\n    split(list[nodePtr], linkAndValue, SUBSEP)\n    return linkAndValue[part]\n}\n\n", "explain": "Awk only has global associative arrays, which will be used for the list. Numerical indexes into the array will serve as node pointers. A list element will have the next node pointer separated from the value by the pre-defined SUBSEP value. A function will be used to access a node's next node pointer or value given a node pointer (array index). The first array element will serve as the list head.\n"}]