[{"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Python", "code": "\n\na, b = b, a\n\ndef swap(a, b):\n    return b, a\n\n", "explain": "Python has support for swapping built in:\nBut the task calls for a \"generic swap method\" to be written, so here it is:\nNote that tuples are immutable in Python. This function doesn't mutate anything, but simply returns a new pair with the order of the elements switched.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "C", "code": "\n\nvoid swap(void *va, void *vb, size_t s)\n{\n  char t, *a = (char*)va, *b = (char*)vb;\n  while(s--)\n    t = a[s], a[s] = b[s], b[s] = t;\n}\n\nWorks with: gcc\n\nCaution: __typeof__ is a gcc extension, not part of standard C. __typeof__ does not conflict with C89 because the standard allows compilers to add keywords with underscores like __typeof__.\n#define Swap(X,Y)  do{ __typeof__ (X) _T = X; X = Y; Y = _T; }while(0)\n\n\n#include <stdio.h>\n\n#define Swap(X,Y)  do{ __typeof__ (X) _T = X; X = Y; Y = _T; }while(0)\n\nstruct test\n{\n  int a, b, c;\n};\n\n\nint main()\n{\n  struct test t = { 1, 2, 3 };\n  struct test h = { 4, 5, 6 };\n  double alfa = 0.45, omega = 9.98;\n  \n  struct test *pt = &t;\n  struct test *th = &h;\n  \n  printf(\"%d %d %d\\n\", t.a, t.b, t.c );\n  Swap(t, h);\n  printf(\"%d %d %d\\n\", t.a, t.b, t.c );\n  printf(\"%d %d %d\\n\", h.a, h.b, h.c );\n  \n  printf(\"%lf\\n\", alfa);\n  Swap(alfa, omega);\n  printf(\"%lf\\n\", alfa);\n  \n  printf(\"%d\\n\", pt->a);\n  Swap(pt, th);\n  printf(\"%d\\n\", pt->a);\n}\n\n\n", "explain": "This has a restriction that a and b must be the same size.\nIf you have gcc, you can write a preprocessor macro with __typeof__.\nUsage examples are:\nThis is tested with GCC with -std=c89 option.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "C++", "code": "\n\ntemplate<typename T> void swap(T& left, T& right)\n{\n  T tmp(left);\n  left = right;\n  right = tmp;\n}\n\n\nstd::swap(x,y);\n\n\nC++11[edit]\n\ntemplate<class T>\nvoid swap(T &lhs, T &rhs){\n  T tmp = std::move(lhs);\n  lhs = std::move(rhs);\n  rhs = std::move(tmp);\n}\n\n", "explain": "Generic programming in C++ is provided through templates. Templates in C++ are quite powerful: They form a Turing-complete compile-time sub-language. However, that power isn't needed for swap. Note that the C++ standard library already provides a swap function which contains optimized implementations for standard library types; thus it's advisable to use that instead of a self-written variant like the one below.\nWhile the standard allows to separate declaration and definition of templates into different files using the export keyword, most compilers (including the most used ones) don't implement that. Therefore in practice, templates declared in header files also have to be defined there.\nThe implementation of the swap function template is straightforward:\nNote that this function requires that the type T has an accessible copy constructor and assignment operator.\n\nThe standard utility 'swap' can be used to swap two values:\nIt will work with any types.\nC++11 adds move constructors which can be more efficient than copy constructors.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Java", "code": "\nWorks with: Java version 1.5+\n\nclass Pair<T> {\n    T first;\n    T second;\n}\npublic static <T> void swap(Pair<T> p) {\n   T temp = p.first;\n   p.first = p.second;\n   p.second = temp;\n}\n\n", "explain": "Java uses references, so it can't swap the values of two variables that don't belong to a class.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "C#", "code": "\nC#: Using a generic method[edit]\nWorks with: C# version 2.0+\n\nstatic void Swap<T>(ref T a, ref T b)\n{\n    T temp = a;\n    a = b;\n    b = temp;\n}\n\n\nint a = 1;\nint b = 2;\nSwap(ref a, ref b); // Type parameter is inferred.\n\nC#: Using tuple syntax[edit]\nWorks with: C# version 7.0+\n\nint a = 1;\nint b = 2;\n(a, b) = (b, a);\n\n", "explain": "C# 2.0 introduced the concept of generics to the language. Generics are outwardly \nsimilar to C++ templates, but are implemented quite differently: generics are\nmaintained generically at runtime rather than being substitued with definite types\nby the compiler. Generics are intended to promote reusable, efficient, type-safe\ncode, and are used widely throughout the .NET framework and 3rd party libraries,\nespecially in collections. C# generics are less flexible than C++ templates, but\nare more strongly typed and arguably easier to work with.\nUsage:\nC# 7.0 introduced language support for tuples, which are implemented using the ValueTuple family of structs. The example below creates a tuple with the values of b and a and uses deconstructing assignment to assign the members of the tuple back to the variables.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "JavaScript", "code": "\n\nfunction swap(arr) {\n  var tmp = arr[0];\n  arr[0] = arr[1];\n  arr[1] = tmp;\n}\n\n\nfunction swap(aName, bName) {\n  eval('(function(){ arguments[0] = aName; aName = bName; bName = arguments[0] })()'\n    .replace(/aName/g, aName)\n    .replace(/bName/g, bName)\n  )\n}\nvar x = 1\nvar y = 2\nswap('x', 'y')\n\n\nfunction swap(a, b) {\n  var tmp = window[a];\n  window[a] = window[b];\n  window[b] = tmp;\n}\nvar x = 1;\nvar y = 2;\nswap('x', 'y');\n\n\nconst arr = [1, 2, 3, 4, 5];\n[arr[0], arr[1]] = [arr[1], arr[0]]\n\n", "explain": "JavaScript uses references, but if a function reassigns a parametric reference, the new object only has a local reference. However, if we wrap the variables to be switched in some other structure, like an object or an array, we can easily swap the values.\nThere's no actual \"generics\", since all variables are just that, variables of some kind.\nThe below function expects an array of length 2 (or longer), and switches the first two values in place, in the same array. This is closely related to how the Java solution works.\nAlso there is metaprogramming solution. It uses code generation and eval. To avoid naming conflicts(user can pass 'tmp', which causes var tmp = tmp) it uses buildin, per activation context (thats why it is enclosed into self executing lambda), var arguments for temp storage.\nSolution without eval(), assuming that the code is running in the browser (window is the global object)\nAnother solution for swapping array items using destructing assignment:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "PHP", "code": "\nfunction swap(&$a, &$b) {\n    list($a, $b) = array($b, $a);\n}\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nMODULE Genericswap\n  IMPLICIT NONE\n\n  INTERFACE Swap\n    MODULE PROCEDURE Swapint, Swapreal, Swapstring\n  END INTERFACE\n\nCONTAINS\n\n  SUBROUTINE Swapint(a, b)\n    INTEGER, INTENT(IN OUT) :: a, b\n    INTEGER :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapint\n\n  SUBROUTINE Swapreal(a, b)\n    REAL, INTENT(IN OUT) :: a, b\n    REAL :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapreal\n\n  SUBROUTINE Swapstring(a, b)\n    CHARACTER(*), INTENT(IN OUT) :: a, b\n    CHARACTER(len(a)) :: temp\n    temp = a ; a = b ; b = temp\n  END SUBROUTINE Swapstring\nEND MODULE Genericswap\n\nPROGRAM EXAMPLE\n  USE Genericswap\n  IMPLICIT NONE\n  INTEGER :: i1 = 1, i2 = 2\n  REAL :: r1 = 1.0, r2 = 2.0\n  CHARACTER(3) :: s1=\"abc\", s2=\"xyz\"\n\n  CALL Swap(i1, i2)\n  CALL Swap(r1, r2)\n  CALL Swap(s1, s2)\n\n  WRITE(*,*) i1, i2   ! Prints 2 and 1\n  WRITE(*,*) r1, r2   ! Prints 2.0 and 1.0\n  WRITE(*,*) s1, s2   ! Prints xyz and abc\nEND PROGRAM EXAMPLE\n\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Go", "code": "\nBuilt in[edit]\n\na, b = b, a\n\nPass interfaces[edit]\n\npackage main\n\nimport \"fmt\"\n\nfunc swap(a, b *interface{}) {\n    *a, *b = *b, *a\n}\n\nfunc main() {\n    var a, b interface{} = 3, \"four\"\n    fmt.Println(a, b)\n    swap(&a, &b)\n    fmt.Println(a, b)\n}\n\n\nOutput:\n3 four\nfour 3\n\nPass pointers[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"reflect\"\n)\n\nfunc swap(a, b interface{}) error {\n    ta := reflect.TypeOf(a)\n    tb := reflect.TypeOf(b)\n    if ta != tb {\n        return fmt.Errorf(\"swap args are different types: %v and %v\", ta, tb)\n    }\n    if ta.Kind() != reflect.Ptr {\n        return fmt.Errorf(\"swap args must be pointers\")\n    }\n    ea := reflect.ValueOf(a).Elem()\n    eb := reflect.ValueOf(b).Elem()\n    temp := reflect.New(ea.Type()).Elem()\n    temp.Set(ea)\n    ea.Set(eb)\n    eb.Set(temp)\n    return nil\n}\n\nfunc main() {\n    a, b := 3, \"cats\"\n    fmt.Println(\"a b:\", a, b)\n    err := swap(a, b)\n    fmt.Println(err, \"\\n\")\n\n    c, d := 3, 4\n    fmt.Println(\"c d:\", c, d)\n    err = swap(c, d)\n    fmt.Println(err, \"\\n\")\n\n    e, f := 3, 4\n    fmt.Println(\"e f:\", e, f)\n    swap(&e, &f)\n    fmt.Println(\"e f:\", e, f, \"\\n\")\n\n    type mult struct {\n        int\n        string\n    }\n\n    g, h := mult{3, \"cats\"}, mult{4, \"dogs\"}\n    fmt.Println(\"g h:\", g, h)\n    swap(&g, &h)\n    fmt.Println(\"g h:\", g, h)\n}\n\n\nOutput:\na b: 3 cats\nswap args are different types: int and string \n\nc d: 3 4\nswap args must be pointers \n\ne f: 3 4\ne f: 4 3 \n\ng h: {3 cats} {4 dogs}\ng h: {4 dogs} {3 cats}\n\n", "explain": "Not a valid solution, since the task requires writing a function or operator, but it is worth mentioning that Go's built in assignment operator does generic swap.  The following swaps the values of a and b as long as they are of identical type.\nA generic swap function can easily be written however, if you require the caller to use variables of the empty interface type.  The empty interface can hold a value of any type.\nSomewhat less restrictive, this version allows pointers of any type to be passed, as long as they are the same type.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Delphi", "code": "\n\nprocedure Swap_T(var a, b: T);\nvar\n  temp: T;\nbegin\n  temp := a;\n  a := b;\n  b := temp;\nend;\n\n\nprogram GenericSwap;\n\ntype\n  TSwap = class\n    class procedure Swap<T>(var left, right: T);\n  end;\n\nclass procedure TSwap.Swap<T>(var left, right: T);\nvar\n  temp : T;\nbegin\n  temp := left;\n  left := right;\n  right := temp;\nend;\n\nvar\n  a, b : integer;\n  \nbegin\n  a := 5;\n  b := 3;\n  writeln('Before swap: a=', a, ' b=', b);\n  TSwap.Swap<integer>(a, b);\n  writeln('After swap: a=', a, ' b=', b);\nend.\n\n", "explain": "Delphi does not have generics as such. The following code must be copied for each type that a swap is required. T should be changed to the required type.\nGenerics were introduced with Delphi 2009\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Ruby", "code": "\n\na, b = b, a\n\ndef swap(a, b)\n    return b, a\nend\n\nx = 42\ny = \"string\"\nx, y = swap x, y\nputs x  # prints string\nputs y  # prints 42\n", "explain": "Ruby has support for swapping built in:\nBut the task calls for a \"generic swap method\", so here it is:\nThis method does not swap the original variables, because Ruby passes parameters by value. \nInstead, this method returns simply a new array with the order of the elements switched. The caller may assign the original variables with the return value:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Rust", "code": "\n\nfn generic_swap<'a, T>(var1: &'a mut T, var2: &'a mut T) {\n    std::mem::swap(var1, var2)\n}\n\nfn main() {\n    let mut a: String = \"Alice\".to_owned();\n    let mut b: String = \"Bob\".to_owned();\n    let mut c: i32 = 1;\n    let mut d: i32 = 2;\n\n    generic_swap(&mut a, &mut b);\n    generic_swap(&mut c, &mut d);\n\n    println!(\"a={}, b={}\", a, b);\n    println!(\"c={}, d={}\", c, d);\n}\n\nOutput:\na=Bob, b=Alice\nc=2, d=1\n\n", "explain": "Rust does not allow for swapping the value of two variables with different types, but if the types are the same it can be done using generic types and lifetimes.\nThis function can be used in e.g. the following ways:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Swift", "code": "\nfunc swap<T>(inout a: T, inout b: T) {\n  (a, b) = (b, a)\n}\n\n", "explain": "Note: The Swift standard library has already a swap function.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "R", "code": "\n\nswap <- function(name1, name2, envir = parent.env(environment()))\n{\n    temp <- get(name1, pos = envir)\n    assign(name1, get(name2, pos = envir), pos = envir)\n    assign(name2, temp, pos = envir)\n}\n\n> x <- 1\n> y <- 2\n> swap('x', 'y')\n> cat(x, y)\n2 1\n", "explain": "R function arguments are passed by value, not by reference.  You can work around this, however, by using their names and environment:\nUsage:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "COBOL", "code": "\n       PROGRAM-ID. SWAP-DEMO.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A simple program to demonstrate the SWAP subprogram.\n      **     \n      ************************************************************\n       \n       DATA DIVISION.\n       \n       WORKING-STORAGE SECTION.\n       \n       01  Val1                 PIC X(72).\n       01  Val2                 PIC X(72).\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n          DISPLAY 'Enter a Value: ' WITH NO ADVANCING.\n          ACCEPT Val1.\n          DISPLAY 'Enter another Value: ' WITH NO ADVANCING.\n          ACCEPT Val2.\n          DISPLAY ' ' .\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1) .\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2) .\n\n           CALL \"SWAP\" USING BY REFERENCE Val1,  BY REFERENCE Val2.\n\n          DISPLAY ' '.\n          DISPLAY 'After SWAP '.\n          DISPLAY ' '.\n          DISPLAY 'First value: ' FUNCTION TRIM(Val1).\n          DISPLAY 'Second value: ' FUNCTION TRIM(Val2).\n\n           STOP RUN.\n       \n       END PROGRAM SWAP-DEMO.\n       \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SWAP.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   SWAP any Alphanumeric value.  Only limit is 72\n      **     character size.  But that can be adjusted for\n      **     whatever use one needs.\n      ************************************************************\n\n       DATA DIVISION.\n\n       WORKING-STORAGE SECTION.\n\n       01  TEMP                  PIC X(72).\n\n       LINKAGE SECTION.\n\n       01  Field1                PIC X(72).\n       01  Field2                PIC X(72).\n\n       PROCEDURE DIVISION \n               USING BY REFERENCE Field1, BY REFERENCE Field2.\n\n       MOVE Field1 to TEMP.\n       MOVE Field2 to Field1.\n       MOVE TEMP to Field2.\n\n       GOBACK.\n\n       END PROGRAM SWAP.\n\n\nOutput:\nEnter a Value: 33\nEnter another Value: 77\n \nFirst value: 33\nSecond value: 77\n \nAfter SWAP \n \nFirst value: 77\nSecond value: 33\n\n--------------------------------\n\nEnter a Value: Hello World\nEnter another Value: Good Bye\n \nFirst value: Hello World\nSecond value: Good Bye\n \nAfter SWAP \n \nFirst value: Good Bye\nSecond value: Hello World\n\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Visual_FoxPro", "code": "\nSince Visual FoxPro is not strongly typed, this will work with any data types.\n\n *!* Swap two variables\n LOCAL a, b\n a = 1\n b = \"Hallo\"\n\u00a0? a, b\n *!* Pass a and b by reference\n Swap(@a, @b)\n\u00a0? a, b\n\nPROCEDURE Swap(v1, v2)\nLOCAL dum\ndum = v1\nv1 = v2\nv2 = dum\nENDPROC\n\nOutput:\n 1 Hallo\n Hallo 1\n \n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Ada", "code": "\n\ngeneric\n   type Swap_Type is private; -- Generic parameter\nprocedure Generic_Swap (Left, Right : in out Swap_Type);\n\nprocedure Generic_Swap (Left, Right : in out Swap_Type) is\n   Temp : constant Swap_Type := Left;\nbegin\n   Left := Right;\n   Right := Temp;\nend Generic_Swap;\n\nusage[edit]\n\nwith Generic_Swap;\n...\ntype T is ...\nprocedure T_Swap is new Generic_Swap (Swap_Type => T);\nA, B : T;\n...\nT_Swap (A, B);\n\n", "explain": "The generic parameters for an Ada generic procedure are defined in a procedure specification, while the algorithm is defined in a procedure body. The first code snippet is the procedure specification. The second code snippet is the procedure body.\nTo use the generic swap procedure, you need to instantiate the procedure for each type that you intend to use.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Julia", "code": "\n\na, b = b, a\n\n", "explain": "Similar to Python, Julia has built-in support for swapping:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Kotlin", "code": "\n\nfun <T> swap(t1: T, t2: T) = Pair(t2, t1)\n\nfun main() {\n    var a = 3\n    var b = 4\n    val c = swap(a, b) // infers that swap<Int> be used\n    a = c.first\n    b = c.second\n    println(\"a = $a\")\n    println(\"b = $b\")\n    var d = false\n    var e = true\n    val f = swap(d, e) // infers that swap<Boolean> be used\n    d = f.first\n    e = f.second\n    println(\"d = $d\")\n    println(\"e = $e\")\n}\n\n\nOutput:\na = 4\nb = 3\nd = true\ne = false\n\n\ndata class Ref<T>(var value: T) {\n    fun swap(other: Ref<T>) {\n        val tmp = this.value\n        this.value = other.value\n        other.value = tmp\n    }\n    override fun toString() = \"$value\"\n}\n\u200b\nfun main() {\n    val a = Ref(1)\n    val b = Ref(2)\n    a.swap(b)\n    println(a)\n    println(b)\n}\n\n", "explain": "As Kotlin does not support passing parameters by reference and tuples cannot be destructured automatically to pre-existing variables, it's just as easy to swap variable values 'inline' rather than using a function. However, here's one of way of doing it generically using the latter:\nYou can also explicitly create a container class and swap the value that it contains (but this is a bad idea in practice):\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Perl", "code": "\n\n($y, $x) = ($x, $y);\n\nsub swap {@_[0, 1] = @_[1, 0]}\n", "explain": "Perl has support for swapping built-in\nHere's a generic swap routine:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Prolog", "code": "\nswap(A,B,B,A).\n\n?- swap(1,2,X,Y).\nX = 2,\nY = 1.\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Lua", "code": "\n\nx, y = y, x                -- swap the values inside x and y\nt[1], t[2] = t[2], t[1]    -- swap the first and second values inside table t\n\nx, y = 3, 4\nprint(x, y)                --> 3 4\nx, y = y, x                -- swap\nprint(x, y)                --> 4 3\n", "explain": "Lua evaluates the values on the right-hand side before assigning them to the variables on the left-hand side. This behaviour allows the following notation to be used to swap two values:\nUsage example:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Scala", "code": "\n\ndef swap[A,B](a: A, b: B): (B, A) = (b, a)\n", "explain": "Scala has type parameters and abstract types (not to be confused with abstract data types).\nThe swap example is about as simple as such things can be, with no variance or high-order\ntype parameters.\nThe return type need not be declared in the example below, but it is shown for clarity. However,\nas Scala does not pass parameters by reference, it cannot swap values in-place. \nTo make up for that, it receives two values, and returns a tuple with the values inverted.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "D", "code": "\nimport std.algorithm: swap; // from Phobos standard library\n\n// The D solution uses templates and it's similar to the C++ one:\nvoid mySwap(T)(ref T left, ref T right) {\n    auto temp = left;\n    left = right;\n    right = temp;\n}\n\nvoid main() {\n    import std.stdio;\n\n    int[] a = [10, 20];\n    writeln(a);\n\n    // The std.algorithm standard library module\n    // contains a generic swap:\n    swap(a[0], a[1]);\n    writeln(a);\n\n    // Using mySwap:\n    mySwap(a[0], a[1]);\n    writeln(a);\n}\n\n\nOutput:\n[10, 20]\n[20, 10]\n[10, 20]\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Haskell", "code": "\nPure swap[edit]\n\nswap :: (a, b) -> (b, a)\nswap (x, y) = (y, x)\n\n\nSwap mutable variables[edit]\n\nimport Control.Monad.Ref\nswap :: MonadRef r m => r a -> r a -> m ()\nswap xRef yRef = do \n   x<-readRef xRef\n   y<-readRef yRef\n   writeRef xRef y\n   writeRef yRef x\n\n", "explain": "Usually Haskellers prefer to work with immutable data. The following function doesn't mutate anything, but simply returns a new pair with the order of the elements switched.\nThe type signature, the first line, is optional; it may be inferred.\nThis swap function is available in the Data.Tuple standard library module in GHC 7.0+\nThe following function swaps the contents of two mutable references. Again the type signature is optional.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Scheme", "code": "\n; swap elements of a vector\n; vector-swap! is not part of r5rs, so we define it\n(define (vector-swap! v i j)\n(let ((a (vector-ref v i)) (b (vector-ref v j)))\n(vector-set! v i b)\n(vector-set! v j a)))\n\n(let ((vec (vector 1 2 3 4 5)))\n  (vector-swap! vec 0 4)\n  vec)\n; #(5 2 3 4 1)\n\n\n; we can swap also in lists\n(define (list-swap! v i j)\n(let* ((x (list-tail v i))\n       (y (list-tail v j))\n       (a (car x))\n       (b (car y)))\n(set-car! x b)\n(set-car! y a)))\n\n(let ((lis (list 1 2 3 4 5)))\n   (list-swap! lis 0 4)\n   lis)\n; (5 2 3 4 1)\n\n\n; using macros (will work on variables, not on vectors or lists)\n(define-syntax swap!\n(syntax-rules ()\n((_ a b)\n   (let ((tmp a))\n   (set! a b)\n   (set! b tmp)))))\n\n; try it\n(let ((a 1) (b 2)) (swap! a b) (list a b))\n; (2 1)\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "PowerShell", "code": "\n\n$b, $a = $a, $b\n\nfunction swap ([ref] $a, [ref] $b) {\n    $a.Value, $b.Value = $b.Value, $a.Value\n}\n\nswap ([ref] $a) ([ref] $b)\n", "explain": "PowerShell allows swapping directly, through tuple assignment:\nBut one can also define a function which swaps the values of two references:\nWhen using this function the arguments have to be explicitly given as references:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Logo", "code": "\nto swap :s1 :s2\n  localmake \"t thing :s1\n  make :s1 thing :s2\n  make :s2 :t\nend\n\nmake \"a 4\nmake \"b \"dog\nswap \"a \"b       \u00a0; pass the names of the variables to swap\nshow list :a :b \u00a0; [dog 4]\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "ColdFusion", "code": "\n\n<cfset temp = a />\n<cfset a = b />\n<cfset b = temp />\n\n", "explain": "This is another standard swap.\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "F#", "code": "\nlet swap (a,b) = (b,a)\n\n", "explain": ""}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "Groovy", "code": "\n\n(a, b) = [b, a]\n\n\ndef swap(a, b) {\n    [b, a]\n}\n\n\ndef (x, y) = swap(1, 3)\nassert x == 3\nassert y == 1\n\n\ndef listSwap = { a, i, j ->\n    assert (0..<(a.size())).containsAll([i,j]);\n    a[[j,i]] = a[[i,j]]\n}\n\ndef list = [2,4,6,8]\nlistSwap(list, 1, 3)\nassert list == [2,8,6,4]\n\n", "explain": "Groovy has support for swapping built in:\nBut the task calls for a \"generic swap method\" to be written, so here it is:\nThis function doesn't mutate anything, but simply returns a new list with the order of the elements switched. It can be used like shown below:\nSome examples here show an in-place swap of indexed elements in an array or collection, so for completeness here is an in-place swap of arbitrary indexed elements in a list:\n"}, {"task_name": "Generic swap", "task_url": "https://rosettacode.org/wiki/Generic_swap", "task_cat": "Basic language learning", "lang": "AWK", "code": "\n# syntax: GAWK -f GENERIC_SWAP.AWK\nBEGIN {\n    printf(\"%s version %s\\n\",ARGV[0],PROCINFO[\"version\"])\n    foo = 1\n    bar = \"a\"\n    printf(\"\\n%s %s\\n\",foo,bar)\n    rc = swap(\"foo\",\"bar\") # ok\n    printf(\"%s %s %s\\n\",foo,bar,rc?\"ok\":\"ng\")\n    printf(\"\\n%s %s\\n\",foo,bar)\n    rc = swap(\"FOO\",\"BAR\") # ng\n    printf(\"%s %s %s\\n\",foo,bar,rc?\"ok\":\"ng\")\n    exit(0)\n}\nfunction swap(a1,a2,  tmp) { # strings or numbers only; no arrays\n    if (a1 in SYMTAB && a2 in SYMTAB) {\n      if (isarray(SYMTAB[a1]) || isarray(SYMTAB[a2])) {\n        return(0)\n      }\n      tmp = SYMTAB[a1]\n      SYMTAB[a1] = SYMTAB[a2]\n      SYMTAB[a2] = tmp\n      return(1)\n    }\n    return(0)\n}\n\n\nOutput:\ngawk version 4.1.0\n\n1 a\na 1 ok\n\na 1\na 1 ng\n\n", "explain": ""}]