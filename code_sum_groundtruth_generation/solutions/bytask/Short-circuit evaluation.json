[{"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Python", "code": "\n\n>>> def a(answer):\n\tprint(\"  # Called function a(%r) -> %r\" % (answer, answer))\n\treturn answer\n\n>>> def b(answer):\n\tprint(\"  # Called function b(%r) -> %r\" % (answer, answer))\n\treturn answer\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j)\")\n\t\tx = a(i) and b(j)\n\t\tprint (\"Calculating: y = a(i) or  b(j)\")\n\t\ty = a(i) or  b(j)\n\n\t\t\n\nCalculating: x = a(i) and b(j)\n  # Called function a(False) -> False\nCalculating: y = a(i) or  b(j)\n  # Called function a(False) -> False\n  # Called function b(False) -> False\n\nCalculating: x = a(i) and b(j)\n  # Called function a(False) -> False\nCalculating: y = a(i) or  b(j)\n  # Called function a(False) -> False\n  # Called function b(True) -> True\n\nCalculating: x = a(i) and b(j)\n  # Called function a(True) -> True\n  # Called function b(False) -> False\nCalculating: y = a(i) or  b(j)\n  # Called function a(True) -> True\n\nCalculating: x = a(i) and b(j)\n  # Called function a(True) -> True\n  # Called function b(True) -> True\nCalculating: y = a(i) or  b(j)\n  # Called function a(True) -> True\n\n\n>>> for i in (False, True):\n\tfor j in (False, True):\n\t\tprint (\"\\nCalculating: x = a(i) and b(j) using x = b(j) if a(i) else False\")\n\t\tx = b(j) if a(i) else False\n\t\tprint (\"Calculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True\")\n\t\ty = b(j) if not a(i) else True\n\n\t\t\n\nCalculating: x = a(i) and b(j) using x = b(j) if a(i) else False\n  # Called function a(False) -> False\nCalculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True\n  # Called function a(False) -> False\n  # Called function b(False) -> False\n\nCalculating: x = a(i) and b(j) using x = b(j) if a(i) else False\n  # Called function a(False) -> False\nCalculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True\n  # Called function a(False) -> False\n  # Called function b(True) -> True\n\nCalculating: x = a(i) and b(j) using x = b(j) if a(i) else False\n  # Called function a(True) -> True\n  # Called function b(False) -> False\nCalculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True\n  # Called function a(True) -> True\n\nCalculating: x = a(i) and b(j) using x = b(j) if a(i) else False\n  # Called function a(True) -> True\n  # Called function b(True) -> True\nCalculating: y = a(i) or  b(j) using y = b(j) if not a(i) else True\n  # Called function a(True) -> True\n\n", "explain": "Pythons and and or binary, infix, boolean operators will not evaluate their right-hand expression if the outcome can be determined from the value of the left-hand expression.\nPythons if expression can also be used to the same ends (but probably should not):\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdbool.h>\n\nbool a(bool in)\n{\n  printf(\"I am a\\n\");\n  return in;\n}\n\nbool b(bool in)\n{\n  printf(\"I am b\\n\");\n  return in;\n}\n\n#define TEST(X,Y,O)\t\t\t\t\t\t\\\n  do {\t\t\t\t\t\t\t\t\\\n    x = a(X) O b(Y);\t\t\t\t\t\t\\\n    printf(#X \" \" #O \" \" #Y \" = %s\\n\\n\", x\u00a0? \"true\"\u00a0: \"false\");\t\\\n  } while(false);\n\nint main()\n{\n  bool x;\n\n  TEST(false, true, &&); // b is not evaluated\n  TEST(true, false, ||); // b is not evaluated\n  TEST(true, false, &&); // b is evaluated\n  TEST(false, false, ||); // b is evaluated \n\n  return 0;\n}\n\n", "explain": "Boolean operators && and || are shortcircuit operators.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "C++", "code": "\n\n#include <iostream>\n\nbool a(bool in)\n{\n    std::cout << \"a\" << std::endl;\n    return in;\n}\n\nbool b(bool in)\n{\n    std::cout << \"b\" << std::endl;\n    return in;\n}\n\nvoid test(bool i, bool j) {\n    std::cout << std::boolalpha << i << \" and \" << j << \" = \" << (a(i) && b(j)) << std::endl;\n    std::cout << std::boolalpha << i << \" or \" << j << \" = \" << (a(i) || b(j)) << std::endl;\n}\n\nint main()\n{\n    test(false, false);\n    test(false, true);\n    test(true, false);\n    test(true, true);\n    return 0;\n}\n\n\nOutput:\na \nfalse and false = false\na \nb \nfalse or false = false\na \nfalse and true = false\na \nb \nfalse or true = true\na \nb \ntrue and false = false\na \ntrue or false = true\na \nb \ntrue and true = true\na \ntrue or true = true\n", "explain": "Just like C, boolean operators && and || are shortcircuit operators.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Java", "code": "\n\npublic class ShortCirc {\n    public static void main(String[] args){\n        System.out.println(\"F and F = \" + (a(false) && b(false)) + \"\\n\");\n        System.out.println(\"F or F = \" + (a(false) || b(false)) + \"\\n\");\n\n        System.out.println(\"F and T = \" + (a(false) && b(true)) + \"\\n\");\n        System.out.println(\"F or T = \" + (a(false) || b(true)) + \"\\n\");\n\n        System.out.println(\"T and F = \" + (a(true) && b(false)) + \"\\n\");\n        System.out.println(\"T or F = \" + (a(true) || b(false)) + \"\\n\");\n\n        System.out.println(\"T and T = \" + (a(true) && b(true)) + \"\\n\");\n        System.out.println(\"T or T = \" + (a(true) || b(true)) + \"\\n\");\n    }\n\n    public static boolean a(boolean a){\n        System.out.println(\"a\");\n        return a;\n    }\n\n    public static boolean b(boolean b){\n        System.out.println(\"b\");\n        return b;\n    }\n}\n\n\nOutput:\na\nF and F = false\n\na\nb\nF or F = false\n\na\nF and T = false\n\na\nb\nF or T = true\n\na\nb\nT and F = false\n\na\nT or F = true\n\na\nb\nT and T = true\n\na\nT or T = true\n", "explain": "In Java the boolean operators && and || are short circuit operators. The eager operator counterparts are & and |.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static bool a(bool value)\n    {\n        Console.WriteLine(\"a\");\n        return value;\n    }\n\n    static bool b(bool value)\n    {\n        Console.WriteLine(\"b\");\n        return value;\n    }\n\n    static void Main()\n    {\n        foreach (var i in new[] { false, true })\n        {\n            foreach (var j in new[] { false, true })\n            {\n                Console.WriteLine(\"{0} and {1} = {2}\", i, j, a(i) && b(j));\n                Console.WriteLine();\n                Console.WriteLine(\"{0} or {1} = {2}\", i, j, a(i) || b(j));\n                Console.WriteLine();\n            }\n        }\n    }\n}\n\n\nOutput:\na\nFalse and False = False\n\na\nb\nFalse or False = False\n\na\nFalse and True = False\n\na\nb\nFalse or True = True\n\na\nb\nTrue and False = False\n\na\nTrue or False = True\n\na\nb\nTrue and True = True\n\na\nTrue or True = True\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "JavaScript", "code": "\n\n(function () {\n    'use strict';\n\n    function a(bool) {\n        console.log('a -->', bool);\n\n        return bool;\n    }\n\n    function b(bool) {\n        console.log('b -->', bool);\n\n        return bool;\n    }\n  \n  \n    var x = a(false) && b(true),\n        y = a(true) || b(false),\n        z = true ? a(true) : b(false);\n    \n  return [x, y, z];\n})();\n\n\n\nOutput:\n\n/* a --> false */\n/* a --> true */\n/* a --> true */\n\n[false, true, true]\n", "explain": "Short-circuiting evaluation of boolean expressions has been the default since the first versions of JavaScript.\nThe console log shows that in each case (the binding of all three values), only the left-hand part of the expression (the application of a(expr)) was evaluated \u2013 b(expr) was skipped by logical short-circuiting.\nConsole:\nReturn value:\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: c++\nModule Module1\n\n    Function A(v As Boolean) As Boolean\n        Console.WriteLine(\"a\")\n        Return v\n    End Function\n\n    Function B(v As Boolean) As Boolean\n        Console.WriteLine(\"b\")\n        Return v\n    End Function\n\n    Sub Test(i As Boolean, j As Boolean)\n        Console.WriteLine(\"{0} and {1} = {2} (eager evaluation)\", i, j, A(i) And B(j))\n        Console.WriteLine(\"{0} or {1} = {2} (eager evaluation)\", i, j, A(i) Or B(j))\n        Console.WriteLine(\"{0} and {1} = {2} (lazy evaluation)\", i, j, A(i) AndAlso B(j))\n        Console.WriteLine(\"{0} or {1} = {2} (lazy evaluation)\", i, j, A(i) OrElse B(j))\n\n        Console.WriteLine()\n    End Sub\n\n    Sub Main()\n        Test(False, False)\n        Test(False, True)\n        Test(True, False)\n        Test(True, True)\n    End Sub\n\nEnd Module\n\n\nOutput:\na\nb\nFalse and False = False (eager evaluation)\na\nb\nFalse or False = False (eager evaluation)\na\nFalse and False = False (lazy evaluation)\na\nb\nFalse or False = False (lazy evaluation)\n\na\nb\nFalse and True = False (eager evaluation)\na\nb\nFalse or True = True (eager evaluation)\na\nFalse and True = False (lazy evaluation)\na\nb\nFalse or True = True (lazy evaluation)\n\na\nb\nTrue and False = False (eager evaluation)\na\nb\nTrue or False = True (eager evaluation)\na\nb\nTrue and False = False (lazy evaluation)\na\nTrue or False = True (lazy evaluation)\n\na\nb\nTrue and True = True (eager evaluation)\na\nb\nTrue or True = True (eager evaluation)\na\nb\nTrue and True = True (lazy evaluation)\na\nTrue or True = True (lazy evaluation)\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nprogram Short_Circuit_Eval\n  implicit none\n\n  logical :: x, y\n  logical, dimension(2) :: l = (/ .false., .true. /)\n  integer :: i, j\n\n  do i = 1, 2\n    do j = 1, 2\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating x = a(\", l(i), \") and b(\", l(j), \")\"   \n      ! a AND b\n      x = a(l(i))  \n      if(x) then\n        x = b(l(j))\n        write(*, \"(a,l1)\") \"x = \", x\n      else\n        write(*, \"(a,l1)\") \"x = \", x\n      end if\n  \n      write(*,*)\n      write(*, \"(a,l1,a,l1,a)\") \"Calculating y = a(\", l(i), \") or b(\", l(j), \")\"   \n      ! a OR b\n      y = a(l(i))\n      if(y) then\n        write(*, \"(a,l1)\") \"y = \", y\n      else\n        y = b(l(j))\n        write(*, \"(a,l1)\") \"y = \", y\n      end if\n      write(*,*)\n    end do\n  end do\n\ncontains\n\nfunction a(value)\n  logical :: a\n  logical, intent(in) :: value\n\n  a = value\n  write(*, \"(a,l1,a)\") \"Called function a(\", value, \")\"\nend function\n\nfunction b(value)\n  logical :: b\n  logical, intent(in) :: value\n  \n  b = value\n  write(*, \"(a,l1,a)\") \"Called function b(\", value, \")\"\nend function\nend program\n\n\nOutput:\nCalculating x = a(F) and b(F)\nCalled function a(F)\nx = F\n \nCalculating y = a(F) or b(F)\nCalled function a(F)\nCalled function b(F)\ny = F\n \nCalculating x = a(F) and b(T)\nCalled function a(F)\nx = F\n \nCalculating y = a(F) or b(T)\nCalled function a(F)\nCalled function b(T)\ny = T\n \nCalculating x = a(T) and b(F)\nCalled function a(T)\nCalled function b(F)\nx = F\n \nCalculating y = a(T) or b(F)\nCalled function a(T)\ny = T\n \nCalculating x = a(T) and b(T)\nCalled function a(T)\nCalled function b(T)\nx = T\n \nCalculating y = a(T) or b(T)\nCalled function a(T)\ny = T\n", "explain": "Using an IF .. THEN .. ELSE construct\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nfunc a(v bool) bool {\n    fmt.Print(\"a\")\n    return v\n}\n\nfunc b(v bool) bool {\n    fmt.Print(\"b\")\n    return v\n}\n\nfunc test(i, j bool) {\n    fmt.Printf(\"Testing a(%t) && b(%t)\\n\", i, j)\n    fmt.Print(\"Trace:  \")\n    fmt.Println(\"\\nResult:\", a(i) && b(j))\n\n    fmt.Printf(\"Testing a(%t) || b(%t)\\n\", i, j)\n    fmt.Print(\"Trace:  \")\n    fmt.Println(\"\\nResult:\", a(i) || b(j))\n\n    fmt.Println(\"\")\n}\n\nfunc main() {\n    test(false, false)\n    test(false, true)\n    test(true, false)\n    test(true, true)\n}\n\n\nOutput:\nTesting a(false) && b(false)\nTrace:  a\nResult: false\nTesting a(false) || b(false)\nTrace:  ab\nResult: false\n\nTesting a(false) && b(true)\nTrace:  a\nResult: false\nTesting a(false) || b(true)\nTrace:  ab\nResult: true\n\nTesting a(true) && b(false)\nTrace:  ab\nResult: false\nTesting a(true) || b(false)\nTrace:  a\nResult: true\n\nTesting a(true) && b(true)\nTrace:  ab\nResult: true\nTesting a(true) || b(true)\nTrace:  a\nResult: true\n", "explain": "Short circuit operators are && and ||.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Delphi", "code": "\n\nprogram ShortCircuitEvaluation;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nfunction A(aValue: Boolean): Boolean;\nbegin\n  Writeln('a');\n  Result := aValue;\nend;\n\nfunction B(aValue: Boolean): Boolean;\nbegin\n  Writeln('b');\n  Result := aValue;\nend;\n\nvar\n  i, j: Boolean;\nbegin\n  for i in [False, True] do\n  begin\n    for j in [False, True] do\n    begin\n      Writeln(Format('%s and %s = %s', [BoolToStr(i, True), BoolToStr(j, True), BoolToStr(A(i) and B(j), True)]));\n      Writeln;\n      Writeln(Format('%s or %s = %s', [BoolToStr(i, True), BoolToStr(j, True), BoolToStr(A(i) or B(j), True)]));\n      Writeln;\n    end;\n  end;\nend.\n\n", "explain": "Delphi supports short circuit evaluation by default.  It can be turned off using the {$BOOLEVAL OFF} compiler directive.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Ruby", "code": "\n\ndef a( bool )\n  puts \"a( #{bool} ) called\"\n  bool\nend\n\ndef b( bool )\n  puts \"b( #{bool} ) called\"\n  bool\nend\n\n [true, false].each do |a_val|\n   [true, false].each do |b_val|\n     puts \"a( #{a_val} ) and b( #{b_val} ) is #{a( a_val ) and b( b_val )}.\"\n     puts\n     puts \"a( #{a_val} ) or b( #{b_val} ) is #{a( a_val)  or b( b_val )}.\"\n     puts\n   end\n end\n\n\nOutput:\na( true ) called\nb( true ) called\na( true ) and b( true ) is true.\n\na( true ) called\na( true ) or b( true ) is true.\n\na( true ) called\nb( false ) called\na( true ) and b( false ) is false.\n\na( true ) called\na( true ) or b( false ) is true.\n\na( false ) called\na( false ) and b( true ) is false.\n\na( false ) called\nb( true ) called\na( false ) or b( true ) is true.\n\na( false ) called\na( false ) and b( false ) is false.\n\na( false ) called\nb( false ) called\na( false ) or b( false ) is false.\n\n", "explain": "Binary operators are short-circuiting. Demonstration code:\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Rust", "code": "\nfn a(foo: bool) -> bool {\n    println!(\"a\");\n    foo\n}\n\nfn b(foo: bool) -> bool {\n    println!(\"b\");\n    foo\n}\n\nfn main() {\n    for i in vec![true, false] {\n        for j in vec![true, false] {\n            println!(\"{} and {} == {}\", i, j, a(i) && b(j));\n            println!(\"{} or {} == {}\", i, j, a(i) || b(j));\n            println!();\n        }\n    }\n}\n\n\nOutput:\na\nb\ntrue and true == true\na\ntrue or true == true\n\na\nb\ntrue and false == false\na\ntrue or false == true\n\na\nfalse and true == false\na\nb\nfalse or true == true\n\na\nfalse and false == false\na\nb\nfalse or false == false\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Swift", "code": "\n\nfunc a(v: Bool) -> Bool {\n  print(\"a\")\n  return v\n}\n\nfunc b(v: Bool) -> Bool {\n  print(\"b\")\n  return v\n}\n\nfunc test(i: Bool, j: Bool) {\n  println(\"Testing a(\\(i)) && b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) && b(j))\")\n  \n  println(\"Testing a(\\(i)) || b(\\(j))\")\n  print(\"Trace:  \")\n  println(\"\\nResult: \\(a(i) || b(j))\")\n  \n  println()\n}\n\ntest(false, false)\ntest(false, true)\ntest(true, false)\ntest(true, true)\n\n\nOutput:\nTesting a(false) && b(false)\nTrace:  a\nResult: false\nTesting a(false) || b(false)\nTrace:  ab\nResult: false\n\nTesting a(false) && b(true)\nTrace:  a\nResult: false\nTesting a(false) || b(true)\nTrace:  ab\nResult: true\n\nTesting a(true) && b(false)\nTrace:  ab\nResult: false\nTesting a(true) || b(false)\nTrace:  a\nResult: true\n\nTesting a(true) && b(true)\nTrace:  ab\nResult: true\nTesting a(true) || b(true)\nTrace:  a\nResult: true\n\n", "explain": "Short circuit operators are && and ||.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "R", "code": "\n\nTranslation of: Perl\na <- function(x) {cat(\"a called\\n\"); x}\nb <- function(x) {cat(\"b called\\n\"); x}\n\ntests <- expand.grid(op=list(quote(`||`), quote(`&&`)), x=c(1,0), y=c(1,0))\n\ninvisible(apply(tests, 1, function(row) {\n  call <- substitute(op(a(x),b(y)), row)\n  cat(deparse(call), \"->\", eval(call), \"\\n\\n\")\n}))\n\n\nOutput:\na called\na(1) || b(1) -> TRUE \n\na called\nb called\na(1) && b(1) -> TRUE \n\na called\nb called\na(0) || b(1) -> TRUE \n\na called\na(0) && b(1) -> FALSE \n\na called\na(1) || b(0) -> TRUE \n\na called\nb called\na(1) && b(0) -> FALSE \n\na called\nb called\na(0) || b(0) -> FALSE \n\na called\na(0) && b(0) -> FALSE\n\n\nswitchop <- function(s, x, y) {\n  if(s < 0) x || y\n  else if (s > 0) x && y\n  else xor(x, y)\n}\n\n\nOutput:\n> switchop(-1, a(1), b(1))\na called\n[1] TRUE\n> switchop(1, a(1), b(1))\na called\nb called\n[1] TRUE\n> switchop(1, a(0), b(1))\na called\n[1] FALSE\n> switchop(0, a(0), b(1))\na called\nb called\n[1] TRUE\n\n", "explain": "The builtins && and || will short circuit:\nBecause R waits until function arguments are needed before evaluating them, user-defined functions can also short circuit.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Visual_FoxPro", "code": "\n*!* Visual FoxPro natively supports short circuit evaluation\nCLEAR\nCREATE CURSOR funceval(arg1 L, arg2 L, operation V(3), result L, calls V(10))\n*!* Conjunction\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.F., .F., \"AND\")\nREPLACE result WITH (a(arg1) AND b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.F., .T., \"AND\")\nREPLACE result WITH (a(arg1) AND b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.T., .F., \"AND\")\nREPLACE result WITH (a(arg1) AND b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.T., .T., \"AND\")\nREPLACE result WITH (a(arg1) AND b(arg2))\n*!* Disjunction\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.F., .F., \"OR\")\nREPLACE result WITH (a(arg1) OR b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.F., .T., \"OR\")\nREPLACE result WITH (a(arg1) OR b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.T., .F., \"OR\")\nREPLACE result WITH (a(arg1) OR b(arg2))\nINSERT INTO funceval (arg1, arg2, operation) VALUES (.T., .T., \"OR\")\nREPLACE result WITH (a(arg1) OR b(arg2))\nGO TOP\n\n_VFP.DataToClip(\"funceval\", 8, 3)\n\nFUNCTION a(v As Boolean) As Boolean\nREPLACE calls WITH \"a()\"\nRETURN v\nENDFUNC\n\nFUNCTION b(v As Boolean) As Boolean\nREPLACE calls WITH calls + \", b()\"\nRETURN v\nENDFUNC\n\n\nOutput:\nArg1\tArg2\tOperation\tResult\tCalls     \t\nF   \tF   \tAND      \tF     \ta()       \t\nF   \tT   \tAND      \tF     \ta()       \t\nT   \tF   \tAND      \tF     \ta(), b()  \t\nT   \tT   \tAND      \tT     \ta(), b()  \t\nF   \tF   \tOR       \tF     \ta(), b()  \t\nF   \tT   \tOR       \tT     \ta(), b()  \t\nT   \tF   \tOR       \tT     \ta()       \t\nT   \tT   \tOR       \tT     \ta()       \t\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Short_Circuit is\n   function A (Value : Boolean) return Boolean is\n   begin\n      Put (\" A=\" & Boolean'Image (Value));\n      return Value;\n   end A;\n   function B (Value : Boolean) return Boolean is\n   begin\n      Put (\" B=\" & Boolean'Image (Value));\n      return Value;\n   end B;\nbegin\n   for I in Boolean'Range loop\n      for J in Boolean'Range loop\n         Put (\" (A and then B)=\" & Boolean'Image (A (I) and then B (J)));\n         New_Line;\n      end loop;\n   end loop;\n   for I in Boolean'Range loop\n      for J in Boolean'Range loop\n         Put (\" (A or else B)=\" & Boolean'Image (A (I) or else B (J)));\n         New_Line;\n      end loop;\n   end loop;\nend Test_Short_Circuit;\n\n\nSample output:\n A=FALSE (A and then B)=FALSE\n A=FALSE (A and then B)=FALSE\n A=TRUE B=FALSE (A and then B)=FALSE\n A=TRUE B=TRUE (A and then B)=TRUE\n A=FALSE B=FALSE (A or else B)=FALSE\n A=FALSE B=TRUE (A or else B)=TRUE\n A=TRUE (A or else B)=TRUE\n A=TRUE (A or else B)=TRUE\n\n", "explain": "Ada has built-in short-circuit operations and then and or else:\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Julia", "code": "\n\na(x) = (println(\"\\t# Called a($x)\"); return x)\nb(x) = (println(\"\\t# Called b($x)\"); return x)\n\nfor i in [true,false], j in [true, false]\n    println(\"\\nCalculating: x = a($i) && b($j)\"); x = a(i) && b(j)\n    println(\"\\tResult: x = $x\")\n    println(\"\\nCalculating: y = a($i) || b($j)\"); y = a(i) || b(j)\n    println(\"\\tResult: y = $y\")\nend\n\n\nOutput:\nCalculating: x = a(true) && b(true)\n\t# Called a(true)\n\t# Called b(true)\n\tResult: x = true\n\nCalculating: y = a(true) || b(true)\n\t# Called a(true)\n\tResult: y = true\n\nCalculating: x = a(true) && b(false)\n\t# Called a(true)\n\t# Called b(false)\n\tResult: x = false\n\nCalculating: y = a(true) || b(false)\n\t# Called a(true)\n\tResult: y = true\n\nCalculating: x = a(false) && b(true)\n\t# Called a(false)\n\tResult: x = false\n\nCalculating: y = a(false) || b(true)\n\t# Called a(false)\n\t# Called b(true)\n\tResult: y = true\n\nCalculating: x = a(false) && b(false)\n\t# Called a(false)\n\tResult: x = false\n\nCalculating: y = a(false) || b(false)\n\t# Called a(false)\n\t# Called b(false)\n\tResult: y = false\n", "explain": "Julia does have short-circuit evaluation, which works just as you expect it to:\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nfun a(v: Boolean): Boolean {\n    println(\"'a' called\")\n    return v\n}\n\nfun b(v: Boolean): Boolean {\n    println(\"'b' called\")\n    return v\n}\n\nfun main(args: Array<String>){\n    val pairs = arrayOf(Pair(true, true), Pair(true, false), Pair(false, true), Pair(false, false))\n    for (pair in pairs) {\n        val x = a(pair.first) && b(pair.second)\n        println(\"${pair.first} && ${pair.second} = $x\")\n        val y = a(pair.first) || b(pair.second)\n        println(\"${pair.first} || ${pair.second} = $y\")\n        println()\n    }\n}\n\n\nOutput:\n'a' called\n'b' called\ntrue && true = true\n'a' called\ntrue || true = true\n\n'a' called\n'b' called\ntrue && false = false\n'a' called\ntrue || false = true\n\n'a' called\nfalse && true = false\n'a' called\n'b' called\nfalse || true = true\n\n'a' called\nfalse && false = false\n'a' called\n'b' called\nfalse || false = false\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Perl", "code": "\n\nsub a { print 'A'; return $_[0] }\nsub b { print 'B'; return $_[0] }\n\n# Test-driver\nsub test {\n    for my $op ('&&','||') {\n        for (qw(1,1 1,0 0,1 0,0)) {\n           my ($x,$y) = /(.),(.)/;\n           print my $str = \"a($x) $op b($y)\", ': ';\n           eval $str; print \"\\n\"; } }\n}    \n\n# Test and display\ntest();\n\n\nOutput:\na(1) && b(1): AB\na(1) && b(0): AB\na(0) && b(1): A\na(0) && b(0): A\na(1) || b(1): A\na(1) || b(0): A\na(0) || b(1): AB\na(0) || b(0): AB\n", "explain": "Perl uses short-circuit boolean evaluation.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Prolog", "code": "\n\nshort_circuit :-\n\t(   a_or_b(true, true) -> writeln('==> true'); writeln('==> false')) , nl,\n\t(   a_or_b(true, false)-> writeln('==>  true'); writeln('==> false')) , nl,\n\t(   a_or_b(false, true)-> writeln('==> true'); writeln('==> false')) , nl,\n\t(   a_or_b(false, false)-> writeln('==> true'); writeln('==> false')) , nl,\n\t(   a_and_b(true, true)-> writeln('==> true'); writeln('==> false')) , nl,\n\t(   a_and_b(true, false)-> writeln('==>  true'); writeln('==> false')) , nl,\n\t(   a_and_b(false, true)-> writeln('==>  true'); writeln('==> false')) , nl,\n\t(   a_and_b(false, false)-> writeln('==>  true'); writeln('==> false')) .\n\n\na_and_b(X, Y) :-\n\tformat('a(~w) and b(~w)~n', [X, Y]),\n\t(   a(X), b(Y)).\n\na_or_b(X, Y) :-\n\tformat('a(~w) or b(~w)~n', [X, Y]),\n\t(   a(X); b(Y)).\n\na(X) :-\n\tformat('a(~w)~n', [X]),\n\tX.\n\nb(X) :-\n\tformat('b(~w)~n', [X]),\n\tX.\n\n\nOutput:\n?- short_circuit.\na(true) or b(true)\na(true)\n==> true\n\na(true) or b(false)\na(true)\n==> true\n\na(false) or b(true)\na(false)\nb(true)\n==> true\n\na(false) or b(false)\na(false)\nb(false)\n==> false\n\na(true) and b(true)\na(true)\nb(true)\n==> true\n\na(true) and b(false)\na(true)\nb(false)\n==> false\n\na(false) and b(true)\na(false)\n==> false\n\na(false) and b(false)\na(false)\n==> false\n\ntrue.\n\n", "explain": "Prolog has not functions but predicats succeed of fail.\nTested with SWI-Prolog. Should work with other dialects.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Lua", "code": "\nfunction a(i)\n    print \"Function a(i) called.\"\n    return i\nend\n\nfunction b(i)\n    print \"Function b(i) called.\"\n    return i\nend\n\ni = true\nx = a(i) and b(i);  print \"\"\ny = a(i) or  b(i);  print \"\"\n\ni = false\nx = a(i) and b(i);  print \"\"\ny = a(i) or  b(i)\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Scala", "code": "\nobject ShortCircuit {\n   def a(b:Boolean)={print(\"Called A=%5b\".format(b));b}\n   def b(b:Boolean)={print(\" -> B=%5b\".format(b));b}\n\n   def main(args: Array[String]): Unit = {\n      val boolVals=List(false,true)\n      for(aa<-boolVals; bb<-boolVals){\n         print(\"\\nTesting A=%5b AND B=%5b   -> \".format(aa, bb))\n         a(aa) && b(bb)\n      }\n      for(aa<-boolVals; bb<-boolVals){\n         print(\"\\nTesting A=%5b  OR B=%5b   -> \".format(aa, bb))\n         a(aa) || b(bb)\n      }\n      println\n   }\n}\n\n\nOutput:\nTesting A=false AND B=false   -> Called A=false\nTesting A=false AND B= true   -> Called A=false\nTesting A= true AND B=false   -> Called A= true -> B=false\nTesting A= true AND B= true   -> Called A= true -> B= true\nTesting A=false  OR B=false   -> Called A=false -> B=false\nTesting A=false  OR B= true   -> Called A=false -> B= true\nTesting A= true  OR B=false   -> Called A= true\nTesting A= true  OR B= true   -> Called A= true\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "D", "code": "\nTranslation of: Python\nimport std.stdio, std.algorithm;\n\nT a(T)(T answer) {\n    writefln(\"  # Called function a(%s) -> %s\", answer, answer);\n    return answer;\n}\n\nT b(T)(T answer) {\n    writefln(\"  # Called function b(%s) -> %s\", answer, answer);\n    return answer;\n}\n\nvoid main() {\n    foreach (immutable x, immutable y;\n             [false, true].cartesianProduct([false, true])) {\n        writeln(\"\\nCalculating: r1 = a(x) && b(y)\");\n        immutable r1 = a(x) && b(y);\n        writeln(\"Calculating: r2 = a(x) || b(y)\");\n        immutable r2 = a(x) || b(y);\n    }\n}\n\n\nOutput:\nCalculating: r1 = a(x) && b(y)\n  # Called function a(false) -> false\nCalculating: r2 = a(x) || b(y)\n  # Called function a(false) -> false\n  # Called function b(false) -> false\n\nCalculating: r1 = a(x) && b(y)\n  # Called function a(true) -> true\n  # Called function b(false) -> false\nCalculating: r2 = a(x) || b(y)\n  # Called function a(true) -> true\n\nCalculating: r1 = a(x) && b(y)\n  # Called function a(false) -> false\nCalculating: r2 = a(x) || b(y)\n  # Called function a(false) -> false\n  # Called function b(true) -> true\n\nCalculating: r1 = a(x) && b(y)\n  # Called function a(true) -> true\n  # Called function b(true) -> true\nCalculating: r2 = a(x) || b(y)\n  # Called function a(true) -> true\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Haskell", "code": "\n\nmodule ShortCircuit where\n\nimport Prelude hiding ((&&), (||))\nimport Debug.Trace\n\nFalse && _     = False\nTrue  && False = False\n_     && _     = True\n\nTrue  || _     = True\nFalse || True  = True\n_     || _     = False\n\na p = trace (\"<a \" ++ show p ++ \">\") p\nb p = trace (\"<b \" ++ show p ++ \">\") p\n\nmain = mapM_ print (    [ a p || b q | p <- [False, True], q <- [False, True] ]\n                     ++ [ a p && b q | p <- [False, True], q <- [False, True] ])\n\n\nOutput:\n<a False>\n<b False>\nFalse\n<a False>\n<b True>\nTrue\n<a True>\nTrue\n<a True>\nTrue\n<a False>\nFalse\n<a False>\nFalse\n<a True>\n<b False>\nFalse\n<a True>\n<b True>\nTrue\n\n\n_     && False = False\nFalse && True  = False\n_     && _     = True\n\n_     || True  = True\nTrue  || False = True\n_     || _     = False\n\n\nOutput:\n<b False>\n<a False>\nFalse\n<b True>\nTrue\n<b False>\n<a True>\nTrue\n<b True>\nTrue\n<b False>\nFalse\n<b True>\n<a False>\nFalse\n<b False>\nFalse\n<b True>\n<a True>\nTrue\n\n\np && q = case p of\n           False -> False\n           _     -> case q of\n                      False -> False\n                      _     -> True\n                      \np || q = case p of\n           True -> True\n           _    -> case q of\n                      True -> True\n                      _    -> False\n\n", "explain": "Lazy evaluation makes it possible for user-defined functions to be short-circuited. An expression will not be evaluated as long as it is not pattern matched:\nOne can force the right-hand arguemnt to be evaluated first be using the alternate definitions:\nThe order of evaluation (in this case the original order again) can be seen in a more explicit form by desugaring the pattern matching:\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Scheme", "code": "\n>(define (a x)\n   (display \"a\\n\")\n   x)\n>(define (b x)\n   (display \"b\\n\")\n   x)\n>(for-each (lambda (i)\n   (for-each (lambda (j)\n     (display i) (display \" and \") (display j) (newline)\n     (and (a i) (b j))\n     (display i) (display \" or \") (display j) (newline)\n     (or (a i) (b j))\n    ) '(#t #f))\n  ) '(#t #f))\n#t and #t\na\nb\n#t or #t\na\n#t and #f\na\nb\n#t or #f\na\n#f and #t\na\n#f or #t\na\nb\n#f and #f\na\n#f or #f\na\nb\n\n", "explain": ""}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "PowerShell", "code": "\n\n#  Simulated fast function\nfunction a ( [boolean]$J ) { return $J }\n \n#  Simulated slow function\nfunction b ( [boolean]$J ) { Sleep -Seconds 2; return $J }\n \n#  These all short-circuit and do not evaluate the right hand function\n( a $True  ) -or  ( b $False )\n( a $True  ) -or  ( b $True  )\n( a $False ) -and ( b $False )\n( a $False ) -and ( b $True  )\n \n#  Measure of execution time\nMeasure-Command {\n( a $True  ) -or  ( b $False )\n( a $True  ) -or  ( b $True  )\n( a $False ) -and ( b $False )\n( a $False ) -and ( b $True  )\n} | Select TotalMilliseconds\n \n#  These all appropriately do evaluate the right hand function\n( a $False ) -or  ( b $False )\n( a $False ) -or  ( b $True  )\n( a $True  ) -and ( b $False )\n( a $True  ) -and ( b $True  )\n \n#  Measure of execution time\nMeasure-Command {\n( a $False ) -or  ( b $False )\n( a $False ) -or  ( b $True  )\n( a $True  ) -and ( b $False )\n( a $True  ) -and ( b $True  )\n} | Select TotalMilliseconds\n\n\nOutput:\nTrue\nTrue\nFalse\nFalse\n\nTotalMilliseconds\n-----------------\n           15.653\nFalse\nTrue\nFalse\nTrue\n        8012.9405\n", "explain": "PowerShell handles this natively.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Logo", "code": "\n\nand [notequal? :x 0] [1/:x > 3]\n(or [:x < 0] [:y < 0] [sqrt :x + sqrt :y <  3])\n", "explain": "The AND and OR predicates may take either expressions which are all evaluated beforehand, or lists which are short-circuit evaluated from left to right only until the overall value of the expression can be determined.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "F#", "code": "\nlet a (x : bool) = printf \"(a)\"; x\nlet b (x : bool) = printf \"(b)\"; x\n\n[for x in [true; false] do for y in [true; false] do yield (x, y)]\n|> List.iter (fun (x, y) ->\n    printfn \"%b AND %b = %b\" x y ((a x) && (b y))\n    printfn \"%b OR %b = %b\" x y ((a x) || (b y)))\n\n\n(a)(b)true AND true = true\n(a)true OR true = true\n(a)(b)true AND false = false\n(a)true OR false = true\n(a)false AND true = false\n(a)(b)false OR true = true\n(a)false AND false = false\n(a)(b)false OR false = false\n", "explain": "Output\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "Groovy", "code": "\n\ndef f = { println '  AHA!'; it instanceof String }\ndef g = { printf ('%5d ', it); it > 50 }\n\nprintln 'bitwise'\nassert g(100) & f('sss')\nassert g(2) | f('sss')\nassert ! (g(1) & f('sss'))\nassert g(200) | f('sss')\n\nprintln '''\nlogical'''\nassert g(100) && f('sss')\nassert g(2) || f('sss')\nassert ! (g(1) && f('sss'))\nassert g(200) || f('sss')\n\n\nOutput:\nbitwise\n  100   AHA!\n    2   AHA!\n    1   AHA!\n  200   AHA!\n\nlogical\n  100   AHA!\n    2   AHA!\n    1   200\n", "explain": "Like all C-based languages (of which I am aware), Groovy short-circuits the logical and (&&) and logical or (||) operations, but not the bitwise and (&) and bitwise or (|) operations.\n"}, {"task_name": "Short-circuit evaluation", "task_url": "https://rosettacode.org/wiki/Short-circuit_evaluation", "task_cat": "Programming language concepts", "lang": "AWK", "code": "\n\n#!/usr/bin/awk -f \nBEGIN {\n\tprint (a(1) && b(1))\n\tprint (a(1) || b(1))\n\tprint (a(0) && b(1))\n\tprint (a(0) || b(1))\n}\n\n\nfunction a(x) {\n\tprint \"  x:\"x\n\treturn x\n}\nfunction b(y) {\n\tprint \"  y:\"y\n\treturn y\n}\n\n\nOutput:\n  x:1\n  y:1\n1\n  x:1\n1\n  x:0\n0\n  x:0\n  y:1\n1\n\n", "explain": "Short-circuit evalation is done in logical AND (&&) and logical OR (||) operators: \n"}]