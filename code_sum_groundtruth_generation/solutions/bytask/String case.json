[{"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Python", "code": "\ns = \"alphaBETA\"\nprint s.upper() # => \"ALPHABETA\"\nprint s.lower() # => \"alphabeta\"\n\nprint s.swapcase() # => \"ALPHAbeta\"\n\nprint \"fOo bAR\".capitalize() # => \"Foo bar\"\nprint \"fOo bAR\".title() # => \"Foo Bar\"\n\nimport string\nprint string.capwords(\"fOo bAR\") # => \"Foo Bar\"\n\nprint \"foo's bar\".title()          # => \"Foo'S Bar\"\nprint string.capwords(\"foo's bar\") # => \"Foo's Bar\"\n", "explain": "string.capwords() allows the user to define word separators, and by default behaves slightly differently than title().\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "C", "code": "\n\n/* Demonstrate toupper and tolower for \n   standard C strings.\n   This does not work for multibyte character sets. */\n#include <ctype.h>\n#include <stdio.h>\n\n/* upper-cases s in place */\nvoid str_toupper(char *s)\n{\n    while(*s)\n    {\n        *s=toupper(*s);\n        s++;\n    }\n}\n\n\n/* lower-cases s in place */\nvoid str_tolower(char *s)\n{\n    while(*s)\n    {\n        *s=tolower(*s);\n        s++;\n    }\n}\n\nint main(int argc, char *argv[])\n{\n    char t[255]=\"alphaBETA\";\n    str_toupper(t);\n    printf(\"uppercase: %s\\n\", t);\n    str_tolower(t);\n    printf(\"lowercase: %s\\n\", t);\n    return 0;\n}\n\n", "explain": "The tolower and toupper functions are locale-aware.\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "C++", "code": "\nWorks with: g++ version  3.4.4 (cygming special)\nLibrary: STL\n\n#include <algorithm>\n#include <string>\n#include <cctype>\n\n/// \\brief in-place convert string to upper case\n/// \\return ref to transformed string\nvoid str_toupper(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::toupper);\n}\n\n/// \\brief in-place convert string to lower case\n/// \\return ref to transformed string\nvoid str_tolower(std::string &str) {\n  std::transform(str.begin(), \n                 str.end(), \n                 str.begin(),\n                 (int(*)(int)) std::tolower);\n}\n\n\n#include <iostream>\n#include <string>\n\nusing namespace std;\nint main() {\n  string foo(\"_upperCas3Me!!\");\n  str_toupper(foo);\n  cout << foo << endl;\n  str_tolower(foo);\n  cout << foo << endl;\n  return 0;\n}\n\n", "explain": "This method does the transform in-place. Alternate methods might return a new copy or use a stream manipulator.\nHere is sample usage code:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Java", "code": "\n\nString string = \"alphaBETA\".toUpperCase();\n\nString string = \"alphaBETA\".toLowerCase();\n\n\nString str = \"alphaBETA\";\nSystem.out.println(str.toUpperCase());\nSystem.out.println(str.toLowerCase());\n//Also works with non-English characters with no modification\nSystem.out.println(\"\u00e4\u00e0\u00e2\u00e1\u00e7\u00f1\u00df\u00e6\u03b5\u0431\u1ebf\".toUpperCase());\nSystem.out.println(\"\u00c4\u00c0\u00c2\u00c1\u00c7\u00d1SS\u00c6\u0395\u0411\u1ebe\".toLowerCase()); //does not transalate \"SS\" to \"\u00df\"\n\n\n", "explain": "The String class offers the toUpperCase and toLowerCase methods.\nThere is no title-case, alternate-case, or sentence-case methods.\n\nAlternately\nYou could also easily create a swapCase method using Character.isLowerCase(), Character.isUpperCase(), and Character.isLetter().\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "C#", "code": "\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string input;\n        Console.Write(\"Enter a series of letters: \");\n        input = Console.ReadLine();\n        stringCase(input);\n    }\n\n    private static void stringCase(string str)\n    {\n        char[] chars = str.ToCharArray();\n        string newStr = \"\";\n\n        foreach (char i in chars)\n            if (char.IsLower(i))\n                newStr += char.ToUpper(i);\n            else\n                newStr += char.ToLower(i);\n        Console.WriteLine(\"Converted: {0}\", newStr);\n    }\n}\n\n\nSystem.Console.WriteLine(System.Globalization.CultureInfo.CurrentCulture.TextInfo.ToTitleCase(\"exAmpLe sTrinG\"));\n\n", "explain": "Title case is a little different:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nalert( \"alphaBETA\".toUpperCase() );\nalert( \"alphaBETA\".toLowerCase() );\n\n\nALPHABETA\nalphabeta\n\nWorks with: NJS version  0.2.5\nvar string = \"alphaBETA\";\nvar uppercase = string.toUpperCase();\nvar lowercase = string.toLowerCase();\n\n", "explain": "Output:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "SQL", "code": "\nWorks with: MS SQL version  2005\ndeclare @s varchar(10)\nset @s = 'alphaBETA'\nprint upper(@s)\nprint lower(@s)\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "PHP", "code": "\n$str = \"alphaBETA\";\necho strtoupper($str), \"\\n\"; // ALPHABETA\necho strtolower($str), \"\\n\"; // alphabeta\n\necho ucfirst($str), \"\\n\"; // AlphaBETA\necho lcfirst(\"FOObar\"), \"\\n\"; // fOObar\necho ucwords(\"foO baR baZ\"), \"\\n\"; // FoO BaR BaZ\necho lcwords(\"FOo BAr BAz\"), \"\\n\"; // fOo bAr bAz\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n program example\n  \n   implicit none\n   \n   character(9) :: teststring = \"alphaBETA\"\n  \n   call To_upper(teststring)\n   write(*,*) teststring\n   call To_lower(teststring)\n   write(*,*) teststring\n  \n contains\n \n   subroutine To_upper(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"a\":\"z\")\n           str(i:i) = achar(iachar(str(i:i))-32)\n       end select\n     end do \n   end subroutine To_upper\n \n   subroutine To_lower(str)\n     character(*), intent(in out) :: str\n     integer :: i\n  \n     do i = 1, len(str)\n       select case(str(i:i))\n         case(\"A\":\"Z\")\n           str(i:i) = achar(iachar(str(i:i))+32)\n       end select\n     end do  \n   end subroutine To_Lower\n\n end program example\n\n\nFor converting lower-case text to upper, the following will work both on an ASCII system and an EBCDIC system (or any other encodement), once it is compiled for that system:       SUBROUTINE UPCASE(TEXT)\n       CHARACTER*(*) TEXT\n       INTEGER I,C\n        DO I = 1,LEN(TEXT)\n          C = INDEX(\"abcdefghijklmnopqrstuvwxyz\",TEXT(I:I))\n          IF (C.GT.0) TEXT(I:I) = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"(C:C)\n        END DO\n      END\n\nThe INDEX function of course returning zero if the character is not found. Converting from upper to lower case is the obvious inverse and it might be worthwhile defining a MODULE with suitable named character constants to avoid repetition - one might hope the compiler will share duplicated constants rather than producing a fresh version every time, but it might not too. The repeated text scanning done by the INDEX function for each character of TEXT will of course be a lot slower. A still-more advanced compiler might be able to take advantage of special translation op-codes, on systems that offer them. If storage space is not at a premium a swifter method would be to create something like CHARACTER*1 XLATUC(0:255) with most entries being equal to their index, except for those corresponding to the lower case letters for which the value is the corresponding upper case letter. Then       DO I = 1,LEN(TEXT)\n        TEXT(I:I) = XLATUC(ICHAR(TEXT(I:I)))\n      END DO\n\n\nmodule uplow\n   implicit none\n   character(len=26), parameter, private :: low  = \"abcdefghijklmnopqrstuvwxyz\"\n   character(len=26), parameter, private :: high = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\ncontains\n\n   function to_upper(s) result(t)\n      ! returns upper case of s\n      implicit none\n      character(len=*), intent(in) :: s\n      character(len=len(s))        :: t\n\n      character(len=1), save       :: convtable(0:255)\n      logical, save                :: first = .true.\n      integer                      :: i\n\n      if(first) then\n         do i=0,255\n            convtable(i) = char(i)\n         enddo\n         do i=1,len(low)\n            convtable(iachar(low(i:i))) = char(iachar(high(i:i)))\n         enddo\n         first = .false.\n      endif\n\n      t = s\n\n      do i=1,len_trim(s)\n         t(i:i) = convtable(iachar(s(i:i)))\n      enddo\n\n   end function to_upper\n\n   function to_lower(s) result(t)\n      ! returns lower case of s\n      implicit none\n      character(len=*), intent(in) :: s\n      character(len=len(s))        :: t\n\n      character(len=1), save :: convtable(0:255)\n      logical, save          :: first = .true.\n      integer                :: i\n\n      if(first) then\n         do i=0,255\n            convtable(i) = char(i)\n         enddo\n         do i = 1,len(low)\n            convtable(iachar(high(i:i))) = char(iachar(low(i:i)))\n         enddo\n         first = .false.\n      endif\n\n      t = s\n\n      do i=1,len_trim(s)\n         t(i:i) = convtable(iachar(s(i:i)))\n      enddo\n\n   end function to_lower\n\n\nend module uplow\n\n\nprogram doit\n   use uplow\n   character(len=40) :: s\n\n   s = \"abcdxyz ZXYDCBA _!@\"\n   print *,\"original: \",'[',s,']'\n   print *,\"to_upper: \",'[',to_upper(s),']'\n   print *,\"to_lower: \",'[',to_lower(s),']'\n\nend program doit\n\n", "explain": "Functions could be used instead, especially with later compilers that enable lengths not fixed at compile time, but this involves copying the text about. By contrast, the subroutines alter the text in-place, though if something like Utext = Uppercase(text) is desired so that both versions are available, a subroutine is less convenient.\nF90 introduced the intrinsic function  i = IACHAR(c), which returns the integer value of the position of character c in the ASCII character set, even if the processor's default character set is different, such as perhaps EBCDIC. Function ACHAR is the inverse. If the bit pattern of the character was not being interpreted as in the ASCII set, this will cause odd results, say on a system using EBCDIC or (on an ASCII-using cpu) for a file originating from an EBCDIC-using system. Some systems offer additional options to the file OPEN statement that enable character conversion between ASCII and EBCDIC, and there may also be options concerning big- and little-endian usage. But much will depend on the format of the data in the file. If the data are a mixture of text, integers, floating-point, etc. all in binary, there will be no hope for such simple translations.\nNote that in EBCDIC the offset is not 32 but 64. Rather than using an undocumented \"magic constant\" such as 32, one could define PARAMETER (HIC = ICHAR(\"A\") - ICHAR(\"a\")) instead or just place such code in-line and have hope for the compiler. This would also handle the small detail that \"A\" > \"a\" in EBCDIC rather than ASCII's \"A\" < \"a\". But alas, in EBCDIC the letter codes are not contiguous (there are many non-letter symbols between \"a\" and \"z\" as well as between \"A\" and \"Z\"), so the bounds of \"A\" to \"Z\" will not isolate only letters for attack. And it was not just IBM mainframes that used various versions of EBCDIC, so also did Burroughs, among others.\nHere a complete example, using functions, and as far as I can tell, will work also with EBCDIC:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"unicode\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    show(\"alphaBETA\")\n    show(\"alpha BETA\")\n    // Three digraphs that should render similar to DZ, Lj, and nj.\n    show(\"\u01c4\u01c8\u01cc\")\n    // Unicode apostrophe in third word.\n    show(\"o'hare O'HARE o\u2019hare don't\")\n}\n\nfunc show(s string) {\n    fmt.Println(\"\\nstring:         \",\n        s, \" len:\", utf8.RuneCountInString(s), \"runes\") // DZLjnj\n    fmt.Println(\"All upper case: \", strings.ToUpper(s)) // DZLJNJ\n    fmt.Println(\"All lower case: \", strings.ToLower(s)) // dzljnj\n    fmt.Println(\"All title case: \", strings.ToTitle(s)) // DzLjNj\n    fmt.Println(\"Title words:    \", strings.Title(s))   // Dzljnj\n    fmt.Println(\"Swapping case:  \",                     // DzLjNJ\n        strings.Map(unicode.SimpleFold, s))\n}\n\n\nOutput:\nstring:          alphaBETA  len: 9 runes\nAll upper case:  ALPHABETA\nAll lower case:  alphabeta\nAll title case:  ALPHABETA\nTitle words:     AlphaBETA\nSwapping case:   ALPHAbeta\n\nstring:          alpha BETA  len: 10 runes\nAll upper case:  ALPHA BETA\nAll lower case:  alpha beta\nAll title case:  ALPHA BETA\nTitle words:     Alpha BETA\nSwapping case:   ALPHA beta\n\nstring:          \u01c4\u01c8\u01cc  len: 3 runes\nAll upper case:  \u01c4\u01c7\u01ca\nAll lower case:  \u01c6\u01c9\u01cc\nAll title case:  \u01c5\u01c8\u01cb\nTitle words:     \u01c5\u01c8\u01cc\nSwapping case:   \u01c5\u01c9\u01ca\n\nstring:          o'hare O'HARE o\u2019hare don't  len: 26 runes\nAll upper case:  O'HARE O'HARE O\u2019HARE DON'T\nAll lower case:  o'hare o'hare o\u2019hare don't\nAll title case:  O'HARE O'HARE O\u2019HARE DON'T\nTitle words:     O'Hare O'HARE O\u2019hare Don'T\nSwapping case:   O'HARE o'hare O\u2019HARE DON'T\n\n\npackage main\n\nimport (\n  \"fmt\"\n  \"strings\"\n)\n\nfunc main() {\n  a := \"Stro\u00dfb\u00f9rri\"\n  b := \"\u0125\u00e5\u00e7\u00fd\u0434\u0436\u043a\"\n  fmt.Println(strings.ToUpper(a))\n  fmt.Println(strings.ToUpper(b))\n}\n}\n\n\nOutput:\nSTRO\u00dfB\u00d9RRI\n\u0124\u00c5\u00c7\u00dd\u0414\u0416\u041a\n\n", "explain": "\"Title case\" in Go's Unicode package does not mean capitalize the first letter of each word, but rather capitalize each letter as if it were the first letter of a word.  The distinction matters in languages such as Croatian with digraphs with a capitialized form that is different from the all-caps form.  ToTitle() converts a string to all title case.\nIt is Title() on the other hand, that capitalizes the first letter of each word.  It identifies word boundaries and capitalizes first letters, leaving other letters unmodified.  As of Go 1.2 though, the word breaking algorithm is not Unicode compliant.\nGo handles many Unicode characters upcasing well but fails for some like \u00df where it hasn't changed \u00df into SS (expected STROSSB\u00d9RRI).\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n\nToUpper:\n;input: $a0 = pointer to beginning of string\n;clobbers: $t0,$t1,$t2\n\n\tli $t1,'a'\n\tli $t2,'z'\nToUpper_again:\n\n\tlbu $t0,($a0)\n\tnop\n\n\tbeqz $t0,ToUpper_done     ;if char is null terminator, exit\n\tnop\n\n\tbltu $t0,$t1,ToUpper_overhead    ;if char stored in $t0 < 'a', skip\n\tnop\n\n\tbgtu $t0,$t2,ToUpper_overhead    ;if char stored in $t0 > 'z', skip\n\tnop\n\n\n\tandi $t0,$t0,0xDF        ;otherwise, do the work.\n\tsb $t0,($a0)\n\nToUpper_overhead:\n\taddiu $a0,1\n\tb ToUpper_again\n\tnop\n\nToUpper_done:\n\tjr ra\n\tnop\n\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nToLower:\n\t;input: $a0 = pointer to beginning of string\n\t;clobbers: $t0,$t1,$t2\n\n\tli $t1,'A'\n\tli $t2,'Z'\nToLower_again:\n\n\tlbu $t0,($a0)\n\tnop\n\n\tbeqz $t0,ToUpper_done     \t\t;not a typo, I did this to save space.\n\tnop\n\n\tbltu $t0,$t1,ToLower_overhead    ;if char stored in $t0 < 'a', skip\n\tnop\n\n\tbgtu $t0,$t2,ToLower_overhead    ;if char stored in $t0 > 'z', skip\n\tnop\n\n\n\tori $t0,$t0,0x20\n\tsb $t0,($a0)\n\nToLower_overhead:\n\taddiu $a0,1\n\tb ToLower_again\n\tnop\n;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;\nToggleCase:\n\tli $t1,'A'\n\tli $t2,'Z'\n\t\n\tlbu $t0,($a0)\n\tnop\n\t\n\tbeqz $t0,ToggleCase_done\n\tnop\n\t\n\tbltu $t0,$t1,ToggleCase_next\n\tnop\n\tbleu $t0,$t2,ToggleCase_Xor\n\tnop\nToggleCase_next:\n\taddiu $t1,0x20\t;li $t1,'a'\n\taddiu $t2,0x20\t;li $t2,'z'\n\t\n\tbltu $t0,$t1,ToggleCase_overhead\n\tnop\n\tbgtu $t0,$t2,ToggleCase_overhead\n\tnop\nToggleCase_Xor:\n\txori $t0,$t0,0x20\n\tsb $t0,($a0)\nToggleCase_overhead:\n\taddiu $a0,1\n\tb ToggleCase\n\tnop\nToggleCase_done:\n\tjr ra\n\tnop\n\nOutput:\nalphaBETA  ;original\nALPHABETA  ;uppercase\nalphabeta  ;lowercase\nALPHAbeta  ;toggled\n", "explain": "These examples modify a string in place. $a0 is assumed to contain a pointer to the string in RAM; writes to ROM will obviously not have the desired effect.\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nwriteln(uppercase('alphaBETA'));\nwriteln(lowercase('alphaBETA'));\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\"alphaBETA\".downcase # => \"alphabeta\"\n\"alphaBETA\".upcase # => \"ALPHABETA\"\n\n\"alphaBETA\".swapcase # => \"ALPHAbeta\"\n\"alphaBETA\".capitalize # => \"Alphabeta\"\n\nWorks with: Ruby version  2.4\n'\u0125\u00e5\u00e7\u00fd\u0434\u0436\u043a'.upcase  # => \"\u0124\u00c5\u00c7\u00dd\u0414\u0416\u041a\"\n", "explain": "These methods used to affect ASCII letters A-Z and a-z only. From Ruby 2.4 onward however, these methods support Full Unicode case mapping, suitable for most languages, by default. (Options can be specified for Turkic, Lithuanian and ascii)\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Rust", "code": "\nWorks with: Rust version  1.3\nfn main() {\n    println!(\"{}\", \"jalape\u00f1o\".to_uppercase()); // JALAPE\u00d1O\n    println!(\"{}\", \"JALAPE\u00d1O\".to_lowercase()); // jalape\u00f1o\n}\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Swift", "code": "\nimport Foundation\n\nprintln(\"alphaBETA\".uppercaseString)\nprintln(\"alphaBETA\".lowercaseString)\nprintln(\"foO BAr\".capitalizedString)\n\nOutput:\nALPHABETA\nalphabeta\nFoo Bar\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "R", "code": "\n str <- \"alphaBETA\"\n toupper(str)\n tolower(str)\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "COBOL", "code": "\nStandard-compliant Methods[edit]\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-85.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  example PIC X(9) VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           *> Using the intrinsic functions.\n           DISPLAY \"Lower-case: \" FUNCTION LOWER-CASE(example)\n\n           DISPLAY \"Upper-case: \" FUNCTION UPPER-CASE(example)\n\n           *> Using INSPECT\n           MOVE example TO result\n           INSPECT result CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"abcdefghijklmnopqrstuvwxyz\"\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           INSPECT result CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO  \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n\nCompiler Extensions[edit]\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. string-case-extensions.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  example VALUE \"alphaBETA\".\n\n       01  result  PIC X(9).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"Example: \" example\n\n           *> ACUCOBOL-GT\n           MOVE example TO result\n           CALL \"C$TOLOWER\" USING result, BY VALUE 9\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           CALL \"C$TOUPPER\" USING result, BY VALUE 9\n           DISPLAY \"Upper-case: \" result\n\n           *> Visual COBOL\n           MOVE example TO result\n           CALL \"CBL_TOLOWER\" USING result, BY VALUE 9\n           DISPLAY \"Lower-case: \" result\n\n           MOVE example TO result\n           CALL \"CBL_TOUPPER\" USING result BY VALUE 9\n           DISPLAY \"Upper-case: \" result\n\n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Characters.Handling, Ada.Text_IO;\nuse  Ada.Characters.Handling, Ada.Text_IO;\n\nprocedure Upper_Case_String is\n   S : constant String := \"alphaBETA\";\nbegin\n   Put_Line (To_Upper (S));\n   Put_Line (To_Lower (S));\nend Upper_Case_String;\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Julia", "code": "\njulia> uppercase(\"alphaBETA\")\n\"ALPHABETA\"\n\njulia> lowercase(\"alphaBETA\")\n\"alphabeta\"\n\n\njulia> a = '\u00df'\n'\u00df': Unicode U+00DF (category Ll: Letter, lowercase)\n\njulia> uppercase(a)\n'\u1e9e': Unicode U+1E9E (category Lu: Letter, uppercase)\n\n", "explain": "Some letters like \u00df (U+00DF) are transformed to \u1e9e (U+1E9E) in Julia, instead of SS (2 \ud835\uddd1 U+0053) as expected of the Unicode standard[1].\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    val s = \"alphaBETA\"\n    println(s.toUpperCase())\n    println(s.toLowerCase()) \n    println(s.capitalize())\n    println(s.decapitalize())    \n}\n\n\nOutput:\nALPHABETA\nalphabeta\nAlphaBETA\nalphaBETA\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Perl", "code": "\nWorks with: Perl version 5.x\nmy $string = \"alphaBETA\";\nprint uc($string), \"\\n\"; # => \"ALPHABETA\"\nprint lc($string), \"\\n\"; # => \"alphabeta\"\n$string =~ tr/[a-z][A-Z]/[A-Z][a-z]/; print \"$string\\n\"; # => ALPHAbeta \n\nprint ucfirst($string), \"\\n\"; # => \"AlphaBETA\"\nprint lcfirst(\"FOObar\"), \"\\n\"; # => \"fOObar\"\n\n\n", "explain": "Also works in Perl 4 if the my is removed.\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Objective-C", "code": "\nWorks with: GNUstep\nWorks with: Cocoa\nNSLog(@\"%@\", @\"alphaBETA\".uppercaseString);\nNSLog(@\"%@\", @\"alphaBETA\".lowercaseString);\n\nNSLog(@\"%@\", @\"foO BAr\".capitalizedString); // \"Foo Bar\"\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Lua", "code": "\nstr = \"alphaBETA\"\n\nprint( string.upper(str) ) -- ALPHABETA\nprint( string.lower(str) ) -- alphabeta\n\nprint ( str:upper() ) -- ALPHABETA\nprint ( str:lower() ) -- alphabeta\n\n\nprint ( string.upper(\"a\u00e7\u00e3o\") ) -- returns A\u00e7\u00e3O instead of A\u00c7\u00c3O\nprint ( string.upper(\"\u0125\u00e5\u00e7\u00fd\u0434\u0436\u043a\") ) -- returns \u0125\u00e5\u00e7\u00fd\u0434\u0436\u043a instead of \u0124\u00c5\u00c7\u00dd\u0414\u0416\u041a\n\n", "explain": "The string library properly works only for ASCII and extended ASCII (depending on the locals) ranges but not for Unicode.\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Scala", "code": "\nval s=\"alphaBETA\"\nprintln(s.toUpperCase)   //-> ALPHABETA\nprintln(s.toLowerCase)   //-> alphabeta\nprintln(s.capitalize)    //-> AlphaBETA\nprintln(s.reverse)       //-> ATEBahpla\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Dart", "code": "\nString capitalize(String string) {\n  if (string.isEmpty) {\n    return string;\n  }\n  return string[0].toUpperCase() + string.substring(1);\n}\n\nvoid main() {\n  var s = 'alphaBETA';\n  print('Original string: $s');\n  print('To Lower case:   ${s.toLowerCase()}');\n  print('To Upper case:   ${s.toUpperCase()}');\n  print('To Capitalize:   ${capitalize(s)}');\n}\n\n\nOutput:\nOriginal string: alphaBETA\nTo Lower case:   alphabeta\nTo Upper case:   ALPHABETA\nTo Capitalize:   AlphaBETA\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.string;\n\n    immutable s = \"alphaBETA\";\n    s.toUpper.writeln;\n    s.toLower.writeln;\n}\n\n\nOutput:\nALPHABETA\nalphabeta\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nimport Data.Char\n\ns = \"alphaBETA\"\n\nlower = map toLower s\nupper = map toUpper s\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "PL/SQL", "code": "\ndeclare\n    vc  VARCHAR2(40)\u00a0:= 'alphaBETA';\n    ivc VARCHAR2(40);\n    lvc VARCHAR2(40);\n    uvc VARCHAR2(40);\nbegin\n    ivc\u00a0:= INITCAP(vc); -- 'Alphabeta'\n    lvc\u00a0:= LOWER(vc);   -- 'alphabeta'\n    uvc\u00a0:= UPPER(vc);   -- 'ALPHABETA'\nend;\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nDim MyWord\nMyWord = UCase(\"alphaBETA\")   ' Returns \"ALPHABETA\"\nMyWord = LCase(\"alphaBETA\")   ' Returns \"alphabeta\"\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Scheme", "code": "\n(define s \"alphaBETA\")\n(list->string (map char-upcase (string->list s)))\n(list->string (map char-downcase (string->list s)))\n\n> (define s \"alphaBETA gammaDELTA\")\n> (string-upcase s)    \u00a0;; turn all into upper case\n\"ALPHABETA GAMMADELTA\"\n> (string-downcase s)  \u00a0;; turn all into lower case\n\"alphabeta gammadelta\"\n> (string-titlecase s) \u00a0;; capitalise start of each word\n\"Alphabeta Gammadelta\"\n", "explain": "Using SRFI-13:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n$string = 'alphaBETA'\n$lower  = $string.ToLower()\n$upper  = $string.ToUpper()\n$title  = (Get-Culture).TextInfo.ToTitleCase($string)\n\n$lower, $upper, $title\n\nOutput:\nalphabeta\nALPHABETA\nAlphabeta\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Logo", "code": "\nprint uppercase \"alphaBETA \u00a0; ALPHABETA\nprint lowercase \"alphaBETA \u00a0; alphabeta\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\n\n<cfset upper = UCase(\"alphaBETA\")>\n<cfset lower = LCase(\"alphaBETA\")>\n\n<cfset string = \"alphaBETA\">\n<cfset upper = UCase(string)>\n<cfset lower = LCase(string)>\n", "explain": "converting a string literal\nconverting the value of a variable\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "F#", "code": "\nlet s = \"alphaBETA\"\nlet upper = s.ToUpper()\nlet lower = s.ToLower()\n\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Groovy", "code": "\ndef str = 'alphaBETA'\n\nprintln str.toUpperCase()\nprintln str.toLowerCase()\n\n\nALPHABETA\nalphabeta\n", "explain": "Output:\n"}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\npub fn main() !void {\n    const stdout_wr = std.io.getStdOut().writer();\n    const string = \"alphaBETA\";\n    var lower: [string.len]u8 = undefined;\n    var upper: [string.len]u8 = undefined;\n    for (string) |char, i| {\n        lower[i] = std.ascii.toLower(char);\n        upper[i] = std.ascii.toUpper(char);\n    }\n    try stdout_wr.print(\"lower: {s}\\n\", .{lower});\n    try stdout_wr.print(\"upper: {s}\\n\", .{upper});\n\n    // TODO use https://github.com/jecolon/zigstr\n}\n", "explain": ""}, {"task_name": "String case", "task_url": "https://rosettacode.org/wiki/String_case", "task_cat": "String manipulation", "lang": "AWK", "code": "\nBEGIN {\n  a = \"alphaBETA\";\n  print toupper(a), tolower(a)\n}\n\n\nBEGIN {\n  a = \"alphaBETA\"; \n  print toupper(substr(a, 1, 1)) tolower(substr(a, 2))\n}\n\n", "explain": "Capitalize:\n"}]