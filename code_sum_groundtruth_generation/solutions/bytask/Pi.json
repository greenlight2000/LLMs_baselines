[{"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Python", "code": "\ndef calcPi():\n    q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n    while True:\n        if 4*q+r-t < n*t:\n            yield n\n            nr = 10*(r-n*t)\n            n  = ((10*(3*q+r))//t)-10*n\n            q  *= 10\n            r  = nr\n        else:\n            nr = (2*q+r)*l\n            nn = (q*(7*k)+2+(r*l))//(t*l)\n            q  *= k\n            t  *= l\n            l  += 2\n            k += 1\n            n  = nn\n            r  = nr\n\nimport sys\npi_digits = calcPi()\ni = 0\nfor d in pi_digits:\n    sys.stdout.write(str(d))\n    i += 1\n    if i == 40: print(\"\"); i = 0\noutput\n3141592653589793238462643383279502884197\n1693993751058209749445923078164062862089\n9862803482534211706798214808651328230664\n7093844609550582231725359408128481117450\n2841027019385211055596446229489549303819\n6442881097566593344612847564823378678316\n5271201909145648566923460348610454326648\n2133936072602491412737245870066063155881\n7488152092096282925409171536436789259036\n0011330530548820466521384146951941511609\n4330572703657595919530921861173819326117\n...\n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "C", "code": "\n\n\n\nDigits\n\nSpigot 1\n\nSpigot 2\n\nMachin 1\n\nMachin 2\n\nAGM\n\nChudnovsky\n\n\n1,000\n\n0.008\n\n0.009\n\n0.001\n\n0.001\n\n0.000\n\n0.000\n\n\n10,000\n\n0.402\n\n0.589\n\n0.020\n\n0.016\n\n0.003\n\n0.002\n\n\n100,000\n\n39.400\n\n85.600\n\n1.740\n\n1.480\n\n0.084\n\n0.002\n\n\n1,000,000\n\n\n\n\n\n177.900\n\n156.800\n\n1.474\n\n0.333\n\n\n10,000,000\n\n\n\n\n\n\n\n\n\n25.420\n\n5.715\n\nSpigot 1: plain C (no GMP), modified Winter/Flammenkamp, correct to 1+M digits\nSpigot 2: C+GMP, as used in Computer Language Benchmarks Game\nMachin 1: C+GMP, shown below\nMachin 2: C+GMP, as below but using Chien-Lih 1997 formula\nAGM: C+GMP, essentially from the Arithmetic-geometric mean/Calculate Pi task.  This has performance only slightly slower than MPFR.\nChudnovsky: Hanhong Xue's code from GMP web site.\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <gmp.h>\n\nmpz_t tmp1, tmp2, t5, t239, pows;\nvoid actan(mpz_t res, unsigned long base, mpz_t pows)\n{\n\tint i, neg = 1;\n\tmpz_tdiv_q_ui(res, pows, base);\n\tmpz_set(tmp1, res);\n\tfor (i = 3; ; i += 2) {\n\t\tmpz_tdiv_q_ui(tmp1, tmp1, base * base);\n\t\tmpz_tdiv_q_ui(tmp2, tmp1, i);\n\t\tif (mpz_cmp_ui(tmp2, 0) == 0) break;\n\t\tif (neg) mpz_sub(res, res, tmp2);\n\t\telse\t  mpz_add(res, res, tmp2);\n\t\tneg = !neg;\n\t}\n}\n\nchar * get_digits(int n, size_t* len)\n{\n\tmpz_ui_pow_ui(pows, 10, n + 20);\n\n\tactan(t5, 5, pows);\n\tmpz_mul_ui(t5, t5, 16);\n\n\tactan(t239, 239, pows);\n\tmpz_mul_ui(t239, t239, 4);\n\n\tmpz_sub(t5, t5, t239);\n\tmpz_ui_pow_ui(pows, 10, 20);\n\tmpz_tdiv_q(t5, t5, pows);\n\n\t*len = mpz_sizeinbase(t5, 10);\n\treturn mpz_get_str(0, 0, t5);\n}\n\nint main(int c, char **v)\n{\n\tunsigned long accu = 16384, done = 0;\n\tsize_t got;\n\tchar *s;\n\n\tmpz_init(tmp1);\n\tmpz_init(tmp2);\n\tmpz_init(t5);\n\tmpz_init(t239);\n\tmpz_init(pows);\n\n\twhile (1) {\n\t\ts = get_digits(accu, &got);\n\n\t\t/* write out digits up to the last one not preceding a 0 or 9*/\n\t\tgot -= 2; /* -2: length estimate may be longer than actual */\n\t\twhile (s[got] == '0' || s[got] == '9') got--;\n\n\t\tprintf(\"%.*s\", (int)(got - done), s + done);\n\t\tfree(s);\n\n\t\tdone = got;\n\n\t\t/* double the desired digits; slows down at least cubically */\n\t\taccu *= 2;\n\t}\n\n\treturn 0;\n}\n\n", "explain": "There are many ways to do this, with quite different performance profiles.  A simple measurement of 6 programs:\n\nUsing Machin's formula.  The \"continuous printing\" part is silly: the algorithm really calls for a preset number of digits, so the program repeatedly calculates Pi digits with increasing length and chop off leading digits already displayed.  But it's still faster than the unbounded Spigot method by an order of magnitude, at least for the first 100k digits.\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "C++", "code": "\n#include <iostream>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing namespace boost::multiprecision;\n\nclass Gospers\n{\n    cpp_int q, r, t, i, n;\n\npublic:    \n\n    // use Gibbons spigot algorith based on the Gospers series\n    Gospers() : q{1}, r{0}, t{1}, i{1}\n    {\n        ++*this; // move to the first digit\n    }\n\n    // the ++ prefix operator will move to the next digit\n    Gospers& operator++()\n    {\n        n = (q*(27*i-12)+5*r) / (5*t);\n\n        while(n != (q*(675*i-216)+125*r)/(125*t))\n        {\n            r = 3*(3*i+1)*(3*i+2)*((5*i-2)*q+r);\n            q = i*(2*i-1)*q;\n            t = 3*(3*i+1)*(3*i+2)*t;\n            i++;\n\n            n = (q*(27*i-12)+5*r) / (5*t);\n        }\n\n        q = 10*q;\n        r = 10*r-10*n*t;\n\n        return *this;\n    }\n\n    // the dereference operator will give the current digit\n    int operator*()\n    {\n        return (int)n;\n    }\n};\n\nint main()\n{\n    Gospers g;\n\n    std::cout << *g << \".\";  // print the first digit and the decimal point\n\n    for(;;) // run forever\n    {\n        std::cout << *++g;  // increment to the next digit and print\n    }\n}\n\n\nOutput:\n3.1415926535897932384626433832795028841971693993751058209749445923078164062862 . . . \n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Java", "code": "\nTranslation of: Icon\nimport java.math.BigInteger ;\n\npublic class Pi {\n  final BigInteger TWO = BigInteger.valueOf(2) ;\n  final BigInteger THREE = BigInteger.valueOf(3) ;\n  final BigInteger FOUR = BigInteger.valueOf(4) ;\n  final BigInteger SEVEN = BigInteger.valueOf(7) ;\n\n  BigInteger q = BigInteger.ONE ;\n  BigInteger r = BigInteger.ZERO ;\n  BigInteger t = BigInteger.ONE ;\n  BigInteger k = BigInteger.ONE ;\n  BigInteger n = BigInteger.valueOf(3) ;\n  BigInteger l = BigInteger.valueOf(3) ;\n\n  public void calcPiDigits(){\n    BigInteger nn, nr ;\n    boolean first = true ;\n    while(true){\n        if(FOUR.multiply(q).add(r).subtract(t).compareTo(n.multiply(t)) == -1){\n          System.out.print(n) ;\n          if(first){System.out.print(\".\") ; first = false ;}\n          nr = BigInteger.TEN.multiply(r.subtract(n.multiply(t))) ;\n          n = BigInteger.TEN.multiply(THREE.multiply(q).add(r)).divide(t).subtract(BigInteger.TEN.multiply(n)) ;\n          q = q.multiply(BigInteger.TEN) ;\n          r = nr ;\n          System.out.flush() ;\n        }else{\n          nr = TWO.multiply(q).add(r).multiply(l) ;\n          nn = q.multiply((SEVEN.multiply(k))).add(TWO).add(r.multiply(l)).divide(t.multiply(l)) ;\n          q = q.multiply(k) ;\n          t = t.multiply(l) ;\n          l = l.add(TWO) ;\n          k = k.add(BigInteger.ONE) ;\n          n = nn ;\n          r = nr ;\n        }\n    }\n  }\n\n  public static void main(String[] args) {\n    Pi p = new Pi() ;\n    p.calcPiDigits() ;\n  }\n}\n\n\n3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480 ...\n", "explain": "Output\u00a0:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "C#", "code": "\nLibrary: System.Numerics\nTranslation of: Java\nusing System;\nusing System.Numerics;\n\nnamespace PiCalc {\n    internal class Program {\n        private readonly BigInteger FOUR = new BigInteger(4);\n        private readonly BigInteger SEVEN = new BigInteger(7);\n        private readonly BigInteger TEN = new BigInteger(10);\n        private readonly BigInteger THREE = new BigInteger(3);\n        private readonly BigInteger TWO = new BigInteger(2);\n\n        private BigInteger k = BigInteger.One;\n        private BigInteger l = new BigInteger(3);\n        private BigInteger n = new BigInteger(3);\n        private BigInteger q = BigInteger.One;\n        private BigInteger r = BigInteger.Zero;\n        private BigInteger t = BigInteger.One;\n\n        public void CalcPiDigits() {\n            BigInteger nn, nr;\n            bool first = true;\n            while (true) {\n                if ((FOUR*q + r - t).CompareTo(n*t) == -1) {\n                    Console.Write(n);\n                    if (first) {\n                        Console.Write(\".\");\n                        first = false;\n                    }\n                    nr = TEN*(r - (n*t));\n                    n = TEN*(THREE*q + r)/t - (TEN*n);\n                    q *= TEN;\n                    r = nr;\n                } else {\n                    nr = (TWO*q + r)*l;\n                    nn = (q*(SEVEN*k) + TWO + r*l)/(t*l);\n                    q *= k;\n                    t *= l;\n                    l += TWO;\n                    k += BigInteger.One;\n                    n = nn;\n                    r = nr;\n                }\n            }\n        }\n\n        private static void Main(string[] args) {\n            new Program().CalcPiDigits();\n        }\n    }\n}\n\n\nLibrary: System.Numerics\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Numerics;\n\nnamespace EnumeratePi {\n  class Program {\n    private const int N = 60;\n    private const string ZS = \" +-\";\n    static void Main() {\n      Console.WriteLine(\"Digits of PI\");\n      Console.WriteLine(new string('=', N + 13));\n\n      Console.WriteLine(\"Decimal   \u00a0: {0}\", string.Concat(PiDigits(10).Take(N).Select(_ => _.ToString(\"d\"))));\n      Console.WriteLine(\"Binary    \u00a0: {0}\", string.Concat(PiDigits(2).Take(N).Select(_ => _.ToString(\"d\"))));\n      Console.WriteLine(\"Quaternary\u00a0: {0}\", string.Concat(PiDigits(4).Take(N).Select(_ => _.ToString(\"d\"))));\n      Console.WriteLine(\"Octal     \u00a0: {0}\", string.Concat(PiDigits(8).Take(N).Select(_ => _.ToString(\"d\"))));\n      Console.WriteLine(\"Hexadecimal: {0}\", string.Concat(PiDigits(16).Take(N).Select(_ => _.ToString(\"x\"))));\n      Console.WriteLine(\"Alphabetic\u00a0: {0}\", string.Concat(PiDigits(26).Take(N).Select(_ => (char) ('A' + _))));\n      Console.WriteLine(\"Fun       \u00a0: {0}\", string.Concat(PiDigits(ZS.Length).Take(N).Select(_ => ZS[(int)_])));\n\n      Console.WriteLine(\"Nibbles   \u00a0: {0}\", string.Concat(PiDigits(0x10).Take(N/2).Select(_ => string.Format(\"{0:x1} \", _))));\n      Console.WriteLine(\"Bytes     \u00a0: {0}\", string.Concat(PiDigits(0x100).Take(N/3).Select(_ => string.Format(\"{0:x2} \", _))));\n      Console.WriteLine(\"Words     \u00a0: {0}\", string.Concat(PiDigits(0x10000).Take(N/5).Select(_ => string.Format(\"{0:x4} \", _))));\n      Console.WriteLine(\"Dwords    \u00a0: {0}\", string.Concat(PiDigits(0x100000000).Take(N/9).Select(_ => string.Format(\"{0:x8} \", _))));\n\n      Console.WriteLine(new string('=', N + 13));\n      Console.WriteLine(\"* press any key to exit *\");\n      Console.ReadKey();\n    }\n\n    /// <summary>Enumerates the digits of PI.</summary>\n    /// <param name=\"b\">Base of the Numeral System to use for the resulting digits (default = Base.Decimal (10)).</param>\n    /// <returns>The digits of PI.</returns>\n    static IEnumerable<long> PiDigits(long b = 10) {\n      BigInteger\n        k = 1,\n        l = 3,\n        n = 3,\n        q = 1,\n        r = 0,\n        t = 1\n        ;\n\n      // skip integer part\n      var nr = b * (r - t * n);\n      n = b * (3 * q + r) / t - b * n;\n      q *= b;\n      r = nr;\n\n      for (; ; ) {\n        var tn = t * n;\n        if (4 * q + r - t < tn) {\n          yield return (long)n;\n          nr = b * (r - tn);\n          n = b * (3 * q + r) / t - b * n;\n          q *= b;\n        } else {\n          t *= l;\n          nr = (2 * q + r) * l;\n          var nn = (q * (7 * k) + 2 + r * l) / t;\n          q *= k;\n          l += 2;\n          ++k;\n          n = nn;\n        }\n        r = nr;\n      }\n    }\n  }\n}\n\n\nOutput:\nDigits of PI\n=========================================================================\nDecimal   \u00a0: 141592653589793238462643383279502884197169399375105820974944\nBinary    \u00a0: 001001000011111101101010100010001000010110100011000010001101\nQuaternary\u00a0: 021003331222202020112203002031030103012120220232000313001303\nOctal     \u00a0: 110375524210264302151423063050560067016321122011160210514763\nHexadecimal: 243f6a8885a308d313198a2e03707344a4093822299f31d0082efa98ec4e\nAlphabetic\u00a0: DRSQLOLYRTRODNLHNQTGKUDQGTUIRXNEQBCKBSZIVQQVGDMELMUEXROIQIYA\nFun       \u00a0:  + -++ +---- + -++  -+++++ --+----- +++- +-+-+-+-  +-++  +\nNibbles   \u00a0: 2 4 3 f 6 a 8 8 8 5 a 3 0 8 d 3 1 3 1 9 8 a 2 e 0 3 7 0 7 3\nBytes     \u00a0: 24 3f 6a 88 85 a3 08 d3 13 19 8a 2e 03 70 73 44 a4 09 38 22\nWords     \u00a0: 243f 6a88 85a3 08d3 1319 8a2e 0370 7344 a409 3822 299f 31d0\nDwords    \u00a0: 243f6a88 85a308d3 13198a2e 03707344 a4093822 299f31d0\n=========================================================================\n* press any key to exit *\n", "explain": "Adopted Version:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nSpigot Algorithm[edit]\n\nlet q = 1n, r = 180n, t = 60n, i = 2n;\nfor (;;) {\n  let y = (q*(27n*i-12n)+5n*r)/(5n*t);\n  let u = 3n*(3n*i+1n)*(3n*i+2n);\n  r = 10n*u*(q*(5n*i-2n)+r-y*t);\n  q = 10n*q*i*(2n*i-1n);\n  t = t*u;\n  i = i+1n;\n  process.stdout.write(y.toString());\n  if (i === 3n) { process.stdout.write('.'); }\n}\n\nWeb Page version[edit]\n\n<html><head><script src='https://rawgit.com/andyperlitch/jsbn/v1.1.0/index.js'></script></head>\n<body style=\"width: 100%\"><tt id=\"pi\"></tt><tt>...</tt>\n<script async defer>\nfunction bi(n, b) { return new jsbn.BigInteger(n.toString(), b ? b : 10); };\nvar one=bi(1), two=bi(2), three=bi(3), four=bi(4), seven=bi(7), ten=bi(10);\nfunction calcPi() {\n    var q=bi(1), r=bi(0), t=bi(1), k=bi(1), n=bi(3), l=bi(3);\n    var digit=0, firstrun=1;\n    var p=document.getElementById('pi');\n    function w(s) { p.appendChild(document.createTextNode(s));}\n    function continueCalcPi(q, r, t, k, n, l) {\n        while (true) {\n            if (q.multiply(four).add(r).subtract(t).compareTo(n.multiply(t)) < 0) {\n                w(n.toString());\n                if (digit==0 && firstrun==1) { w('.'); firstrun=0; };\n                digit = (digit+1) % 256;\n                var nr = (r.subtract(n.multiply(t))).multiply(ten);\n                n  = (q.multiply(three).add(r)).multiply(ten).divide(t).subtract(n.multiply(ten));\n                q  = q.multiply(ten);\n                r  = nr;\n                if (digit%8==0) {\n                    if (digit%64==0) {\n                     p.appendChild(document.createElement('br'));\n                    }\n                    w(' ');\n                    return setTimeout(function() { continueCalcPi(q, r, t, k, n, l); }, 50);\n                };\n            } else {\n                var nr = q.shiftLeft(1).add(r).multiply(l);\n                var nn = q.multiply(k).multiply(seven).add(two).add(r.multiply(l)).divide(t.multiply(l));\n                q = q.multiply(k);\n                t = t.multiply(l);\n                l = l.add(two);\n                k = k.add(one);\n                n  = nn;\n                r  = nr;\n            }\n        }\n    }\n    continueCalcPi(q, r, t, k, n, l);\n}\ncalcPi();\n</script>\n</body></html>\n\nWeb Page using BigInt[edit]\n\n<html>\n <head>\n </head>\n <body style=\"width: 100%\">\n  <tt id=\"pi\"></tt>\n  <tt>...</tt>\n  <script async defer>\nfunction calcPi() {\n    let q=1n, r=0n, t=1n, k=1n, n=3n, l=3n, nr, nn, digit=0, firstrun=1;\n    const p=document.getElementById('pi');\n    function w(s) { p.appendChild(document.createTextNode(s));}\n//  function continueCalcPi(q, r, t, k, n, l) {  // (see note)\n    function continueCalcPi() {\n        while (true) {\n            if (q*4n+r-t < n*t) {\n                w(n.toString());\n                if (digit==0 && firstrun==1) { w('.'); firstrun=0; };\n                digit = (digit+1) % 256;\n                nr = (r-n*t)*10n;\n                n  = (q*3n+r)*10n/t-n*10n;\n                q *= 10n;\n                r  = nr;\n                if (digit%8==0) {\n                    if (digit%64==0) {\n                     p.appendChild(document.createElement('br'));\n                    }\n                    w('\\xA0');\n//                  return setTimeout(function() { continueCalcPi(q, r, t, k, n, l); }, 50);\n                    return setTimeout(continueCalcPi, 50);\n                };\n            } else {\n                nr = (q*2n+r)*l;\n                nn = (q*k*7n+2n+r*l)/(t*l);\n                q *= k;\n                t *= l;\n                l += 2n;\n                k += 1n;\n                n  = nn;\n                r  = nr;\n            }\n        }\n    }\n    continueCalcPi(q, r, t, k, n, l);\n}\ncalcPi();\n  </script>\n </body>\n</html>\n\n\nSimple Approximation[edit]\n\nvar calcPi = function() {\n  var n = 20000;\n  var pi = 0;\n  for (var i = 0; i < n; i++) {\n    var temp = 4 / (i*2+1);\n    if (i\u00a0% 2 == 0) {\n      pi += temp;\n    }\n    else {\n      pi -= temp;\n    }\n  }\n  return pi;\n}\n\n", "explain": "Calculate one digit of \u03c0 at a time and write it out.\nprocess.stdout.write will work in Node.js; to make this work in a browser, change it to document.body.textContent += .\nThis shows how to load the previous code into a webpage that writes digits out without freezing the browser\nAbove converted to use BigInt\nNote: removing the parameters to continueCalcPi() as shown may eat (even) more memory, not entirely sure about that.\nReturns an approximation of Pi.\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\n\nImports System\nImports System.Numerics\n\t\t\t\t\nPublic Module Module1\n\tPublic Sub Main()\n        Dim two, three, four, seven, ten, k, q, t, l, n, r, nn, nr As BigInteger,\n            first As Boolean = True\n        two = New BigInteger(2) : three = New BigInteger(3) : four = two + two\n        seven = three + four : ten = three + seven : k = BigInteger.One\n        q = k : t = k : l = three : n = three : r = BigInteger.Zero\n        While True\n            If four * q + r - t < n * t Then\n                Console.Write(n) : If first Then Console.Write(\".\") : first = False\n                nr = ten * (r - n * t) : n = ten * (three * q + r) / t - ten * n\n                q *= ten\n            Else\n                nr = (two * q + r) * l : nn = (q * seven * k + two + r * l) / (t * l)\n                q *= k : t *= l : l += two : k += BigInteger.One : n = nn\n            End If\n            r = nr\n        End While\n    End Sub\n\nEnd Module\n\n\nOutput:\n3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337867831652712019091456485669234603486104543266482133936072602491412737245870066063155881748815209209628292540917153643678925903600113305305488204665213841469519415116094330572703657595919530921861173819326117931051185480744623799627495673518857527248912279381830119491298336733624406566430860213949463952247371907021798609437027705392171762931767523846748184676694051320005681271452635608277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201989380952572010654858632788659361533818279682303019520353018529689957736225994138912497217752834791315155748572424541506959508295331168617278558890750983817546374649393192550604009277016711390098488240128583616035637076601047101819429555961989467678374494482553797747268471040475346462080466842590694912933136770289891521047521620569660240580381501935112533824300355876402474964732639141992726042699227967823547816360093417216412199245863150302861829745557067498385054945885869269956909272107975093029553211653449872027559602364806654991198818347977535663698074265425278625518184175746728909777727938000816470600161452491921732172147723501414419735685481613611573525521334757418494684385233239073941433345477624168625189835694855620992192221842725502542568876717904946016534668049886272327917860857843838279679766814541009538837863609506800642251252051173929848960841284886269456042419652850222106611863067442786220391949450471237137869609563643719172874677646575739624138908658326459958133904780275900994657640789512694683983525957098258226205224894077267194782684826014769909026401363944374553050682034962524517493996514314298091906592509372216964615157098583874105978859597729754989301617539284681382686838689427741559918559252459539594310499725246808459872736446958486538367362226260991246080512438843904512441365497627807977156914359977001296160894416948685558484063534220722258284886481584560285060168427394522674676788952521385225499546667278239864565961163548862305774564980355936345681743241125150760694794510965960940252288797108931456691368672287489405601015033086179286809208747609178249385890097149096759852613655497818931297848216829989487226588048575640142704775551323796414515237462343645428584447952658678210511413547357395231134271661021359695362314429524849371871101457654035902799344037420073105785390621983874478084784896833214457138687519435064302184531910484810053706146806749192781911979399520614196634287544406437451237181921799983910159195618146751426912397489409071864942319615679452080951465502252316038819301420937621378559566389377870830390697920773467221825625996615014215030680384477345492026054146659252014974428507325186660021324340881907104863317346496514539057962685610055081066587969981635747363840525714591028970641401109712062804390397595156771577004203378699360072305587631763594218731251471205329281918261861258673215791984148488291644706095752706957220917567116722910981690915280173506712748583222871835209353965725121083579151369882091444210067510334671103141267111369908658516398315019701651511685171437657618351556508849099898599823873455283316355076479185358932261854896321329330898570642046752590709154814165498594616371802709819943099244889575712828905923233260972997120844335732654893823911932597463667305836041428138830320382490375898524374417029132765618093773444030707469211201913020330380197621101100449293215160842444859637669838952286847831235526582131449576857262433441893039686426243410773226978028073189154411010446823252716201052652272111660396665573092547110557853763466820653109896526918620564769312570586356620185581007293606598764861179104533488503461136576867532494416680396265797877185560845529654126654085306143444318586769751456614068007002378776591344017127494704205622305389945613140711270004078547332699390814546646458807972708266830634328587856983052358089330657574067954571637752542021149557615814002501262285941302164715509792592309907965473761255176567513575178296664547791745011299614890304639947132962107340437518957359614589019389713111790429782856475032031986915140287080859904801094121472213179476477726224142548545403321571853061422881375850430633217518297986622371721591607716692547487389866549494501146540628433663937900397692656721463853067360965712091807638327166416274888800786925602902284721040317211860820419000422966171196377921337575114959501566049631862947265473642523081770367515906735023507283540567040386743513622224771589150495309844489333096340878076932599397805419341447377441842631298608099888687413260472156951623965864573021631598193195167353812974167729478672422924654366800980676928238280689964004824354037014163149658979409243237896907069779422362508221688957383798623001593776471651228935786015881617557829735233446042815126272037343146531977774160319906655418763979293344195215413418994854447345673831624993419131814809277771038638773431772075456545322077709212019051660962804909263601975988281613323166636528619326686336062735676303544776280350450777235547105859548702790814356240145171806246436267945612753181340783303362542327839449753824372058353114771199260638133467768796959703098339130771098704085913374641442822772634659470474587847787201927715280731767907707157213444730605700733492436931138350493163128404251219256517980694113528013147013047816437885185290928545201165839341965621349143415956258658655705526904965209858033850722426482939728584783163057777560688876446248246857926039535277348030480290058760758251047470916439613626760449256274204208320856611906254543372131535958450687724602901618766795240616342522577195429162991930645537799140373404328752628889639958794757291746426357455254079091451357111369410911939325191076020825202618798531887705842972591677813149699009019211697173727847684726860849003377024242916513005005168323364350389517029893922334517220138128069650117844087451960121228599371623130171144484640903890644954440061986907548516026327505298349187407866808818338510228334508504860825039302133219715518430635455007668282949304137765527939751754613953984683393638304746119966538581538420568533862186725233402830871123282789212507712629463229563989898935821167456270102183564622013496715188190973038119800497340723961036854066431939509790190699639552453005450580685501956730229219139339185680344903982059551002263535361920419947455385938102343955449597783779023742161727111\n\nQuicker, unverified algo[edit]\n\nImports System, System.Numerics, System.Text\n \nModule Module1\n \n    Sub RunPiF(ByVal msg As String)\n        If msg.Length > 0 Then Console.WriteLine(msg)\n        Dim first As Boolean = True, stp As Integer = 360,\n            res As StringBuilder = New StringBuilder(),\n            rc As Integer = -1, y As Byte, et As TimeSpan,\n            st As DateTime = DateTime.Now,\n            q, r, t, g, j, h, k, a, b As BigInteger\n            q = 1 : r = 180 : t = 60 : g = 60 : j = 54\n            h = 10 : k = 10 : a = 15 : b = 3\n        While True ' use this to stop after a keypress\n        ' While rc < 20000 ' use this to stop after some fixed point\n            While res.Length < stp\n                a += 27 : y = CByte((q * a + 5 * r) / (5 * t))\n                res.Append(y) : b += 5 : j += 54 : g += j\n                r = 10 * g * (q * b + r - y * t)\n                k += 40 : h += k : q *= h : t *= g\n            End While\n            If first Then res.Insert(1, \".\"c) : first = False\n            Console.Write(res.ToString())\n            rc += res.Length : res.Clear()\n            If Console.KeyAvailable Then Exit While\n        End While\n        et = DateTime.Now - st : Console.ReadKey()\n        Console.Write(res.ToString()) : rc += res.Length\n        Console.WriteLine(vbLf & \"Produced {0} digits in {1:n4} seconds.\", rc, et.TotalSeconds)\n    End Sub\n \n    Sub Main(args As String())\n        RunPiF(\"Press a key to exit...\")\n        If Diagnostics.Debugger.IsAttached Then Console.ReadKey()\n    End Sub\nEnd Module\n\n\nOutput:The First several thousand digits verified the same as the conventional spigot algorithm, haven't detected any differences yet.\nPress a key to exit...\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198938095257201065485863278865936153381827968230301952035301852968995773622599413891249721775283479131515574857242454150695950829533116861727855889075098381754637464939319255060400927701671139009848824012858361603563707660104710181942955596198946767837449448255379774726847104047534646208046684259069491293313677028989152104752162056966024058038150193511253382430035587640247496473263914199272604269922796782354781636009341721641219924586315030286182974555706749838505494588586926995690927210797509302955321165344987202755960236480665499119881834797753566369807426542527862551818417574672890977772793800081647060016145249192173217214772350141441973568548161361157352552133475741849468438523323907394143334547762416862518983569485562099219222184272550254256887671790494601653466804988627232791786085784383827967976681454100953883786360950680064225125205117392984896084128488626945604241965285022210661186306744278622039194945047123713786960956364371917287467764657573962413890865832645995813390478027590099465764078951269468398352595709825822620522489407726719478268482601476990902640136394437455305068203496252451749399651431429809190659250937221696461515709858387410597885959772975498930161753928468138268683868942774155991855925245953959431049972524680845987273644695848653836736222626099124608051243884390451244136549762780797715691435997700129616089441694868555848406353422072225828488648158456028506016842739452267467678895252138522549954666727823986456596116354886230577456498035593634568174324112515076069479451096596094025228879710893145669136867228748940560101503308617928680920874760917824938589009714909675985261365549781893129784821682998948722658804857564014270477555132379641451523746234364542858444795265867821051141354735739523113427166102135969536231442952484937187110145765403590279934403742007310578539062198387447808478489683321445713868751943506430218453191048481005370614680674919278191197939952061419663428754440643745123718192179998391015919561814675142691239748940907186494231961567945208095146550225231603881930142093762137855956638937787083039069792077346722182562599661501421503068038447734549202605414665925201497442850732518666002132434088190710486331734649651453905796268561005508106658796998163574736384052571459102897064140110971206280439039759515677157700420337869936007230558763176359421873125147120532928191826186125867321579198414848829164470609575270695722091756711672291098169091528017350671274858322287183520935396572512108357915136988209144421006751033467110314126711136990865851639831501970165151168517143765761835155650884909989859982387345528331635507647918535893226185489632132933089857064204675259070915481416549859461637180270981994309924488957571282890592323326097299712084433573265489382391193259746366730583604142813883032038249037589852437441702913276561809377344403070746921120191302033038019762110110044929321516084244485963766983895228684783123552658213144957685726243344189303968642624341077322697802807318915441101044682325271620105265227211166039666557309254711055785376346682065310989652691862056476931257058635662018558100729360659876486117910453348850346113657686753249441668039626579787718556084552965412665408530614344431858676975145661406800700237877659134401712749470420562230538994561314071127000407854733269939081454664645880797270826683063432858785698305235808933065757406795457163775254202114955761581400250126228594130216471550979259230990796547376125517656751357517829666454779174501129961489030463994713296210734043751895735961458901938971311179042978285647503203198691514028708085990480109412147221317947647772622414254854540332157185306142288137585043063321751829798662237172159160771669254748738986654949450114654062843366393790039769265672146385306736096571209180763832716641627488880078692560290228472104031721186082041900042296617119637792133757511495950156604963186294726547364252308177036751590673502350728354056704038674351362222477158915049530984448933309634087807693259939780541934144737744184263129860809988868741326047215695162396586457302163159819319516735 \nProduced 5038 digits in 0.3391 seconds.\n", "explain": "Don't forget to use the \"Project\" tab, \"Add Reference...\" for System.Numerics (in case you get compiler errors in the Visual Studio IDE)\nThere seems to be another algorithm in the original reference article (see the Ada entry), which produces output a bit faster.  However, the math behind the algorithm has not been completely proven.  It's faster because it doesn't calculate whether each digit is accumulated properly before squirting it out.  When using (slow) arbitrary precision libraries, this avoids a lot of computation time.\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "MATLAB", "code": "\n\nfunction pi_str = piSpigot(N)\n% Return N digits of pi using Gibbons's first spigot algorithm.\n% If N is omitted, the digits are printed ad infinitum.\n% Uses the expansion\n%   pi = sum_{i=0} (i!)^2 2^{i+1} /(2i+1)!\n%      = 2 + 1/3 * ( 2 + 2/5 * (2 + 3/7 * ( 2 + 4/9 * ( ..... )))))\n%      = (2 + 1/3 *)(2 + 2/5 *)(2 + 3/7 *)...\n% where the terms in the last expression represent Linear Fractional \n% Transforms (LFTs).\n%\n% Requires the Variable Precision Integer (vpi) Toolbox\n%\n% Reference:\n% \"Unbounded Spigot Algorithms for the Digits of Pi\" by J. Gibbons, 2004\n% American Mathematical Monthly, vol. 113. \nif nargin < 1\n    N = Inf;\n    lineLength = 50;\nelse\n    pi_str = repmat(' ',1,N);\nend\n\nq = vpi(1);\nr = vpi(0);\nt = vpi(1);\nk = 1; % If printing more than 3E15 digits, use k = vpi(1);\n\ni = 1;\nfirst_digit = true;\nwhile i <= N\n    threeQplusR = 3*q + r;\n    n = double(threeQplusR / t);\n    if q+threeQplusR < (n+1)*t\n        d = num2str(n);\n        if isinf(N)\n            fprintf(1,'%s', d);\n            if first_digit\n                fprintf(1,'.');\n                first_digit = false;\n                i = i+1;\n            end\n            if i == lineLength \n                fprintf(1,'\\n');\n                i = 0;\n            end\n        else\n            pi_str(i) = d;\n        end\n        q = 10*q;\n        r = 10*(r-n*t);\n        i = i + 1;\n    else\n        t = (2*k+1)*t;\n        r = (4*k+2)*q + (2*k+1)*r;\n        q = k*q;\n        k = k + 1;\n    end\nend\nend\n\n>> piSpigot\n3.141592653589793238462643383279502884197169399375\n10582097494459230781640628620899862803482534211706\n79821480865132823066470938446095505822317253594081\n28481117450284102701938521105559644622948954930381\n96442881097566593344612847564823378678316527120190\n91456485669234603486104543266482133936072602491412\n\n", "explain": "Requires the Variable Precision Integer (vpi) Toolbox\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Fortran", "code": "\n\nprogram pi\n  implicit none\n  integer,dimension(3350) :: vect\n  integer,dimension(201) :: buffer\n  integer :: more,karray,num,k,l,n\n  more = 0\n  vect = 2\n  do n = 1,201\n    karray = 0\n    do l = 3350,1,-1\n      num = 100000*vect(l) + karray*l\n      karray = num/(2*l - 1)\n      vect(l) = num - karray*(2*l - 1)\n    end do\n    k = karray/100000\n    buffer(n) = more + k\n    more = karray - k*100000\n  end do\n  write (*,'(i2,\".\"/(1x,10i5.5))') buffer\nend program pi\n\n\n3.\n14159265358979323846264338327950288419716939937510\n58209749445923078164062862089986280348253421170679\n82148086513282306647093844609550582231725359408128\n48111745028410270193852110555964462294895493038196\n44288109756659334461284756482337867831652712019091\n45648566923460348610454326648213393607260249141273\n72458700660631558817488152092096282925409171536436\n78925903600113305305488204665213841469519415116094\n33057270365759591953092186117381932611793105118548\n07446237996274956735188575272489122793818301194912\n98336733624406566430860213949463952247371907021798\n60943702770539217176293176752384674818467669405132\n00056812714526356082778577134275778960917363717872\n14684409012249534301465495853710507922796892589235\n42019956112129021960864034418159813629774771309960\n51870721134999999837297804995105973173281609631859\n50244594553469083026425223082533446850352619311881\n71010003137838752886587533208381420617177669147303\n59825349042875546873115956286388235378759375195778\n18577805321712268066130019278766111959092164201989\n\n\n!================================================\n        program pi_spigot_unbounded\n!================================================\n          do \n            call print_next_pi_digit()\n          end do\n\n        contains\n\n!------------------------------------------------\n          subroutine print_next_pi_digit()\n!------------------------------------------------\n            use fmzm\n            type (im) :: q, r, t, k, n, l, nr\n            logical   :: dot=.false., init=.false.\n            save      :: q, r, t, k, n, l\n            if (.not.init) then\n              q=to_im(1)\n              r=to_im(0)\n              t=to_im(1)\n              k=to_im(1)\n              n=to_im(3)\n              l=to_im(3)\n              init=.true.\n            end if\n            if (4*q+r-t < n*t) then\n              write(6,fmt='(i1)',advance='no') to_int(n)\n              if (.not.dot) then\n                write(6,fmt='(a1)',advance='no') '.'\n                dot=.true.\n              end if\n              flush(6)\n              nr = 10 * (        r      - n*t )\n              n  = 10 * ( (3*q + r) / t - n   )\n              q  = 10 *      q\n              r  = nr\n            else\n              nr = (2*q + r) * l\n              n  = ( (q * (7*k + 2) + r*l) / (t*l) )\n              q  = q * k\n              t  = t * l\n              l  = l + 2\n              k  = k + 1\n              r  = nr\n            end if\n          end subroutine\n\n        end program\n\n", "explain": "This is a modernized version of the example Fortran programme written by S. Rabinowitz in 1991. It works in base 100000 and the key step is the initialisation of all elements of VECT to 2. The format code of I5.5 means I5 output but with all leading spaces made zero so that 66 comes out as \"00066\", not \"   66\". \nThe output is accumulated in BUFFER then written in one go at the end, but it could be written as successive values as each is calculated without much extra nitpickery: instead of BUFFER(N) = MORE + K for example just WRITE (*,\"(I5.5)\") MORE + K and no need for array BUFFER.\nThis is an alternate version using an unbounded spigot. Higher precision is accomplished by using the Fortran Multiple Precision\nLibrary, FMLIB (http://myweb.lmu.edu/dmsmith/fmlib.html), provided by Dr. David M. Smith (dsmith@lmu.edu), Mathematics Professor (Emeritus) at Loyola Marymount University. We use the default precision which is about 50 significant digits.\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\ntype lft struct {\n    q,r,s,t big.Int\n}\n\nfunc (t *lft) extr(x *big.Int) *big.Rat {\n    var n, d big.Int\n    var r big.Rat\n    return r.SetFrac(\n        n.Add(n.Mul(&t.q, x), &t.r),\n        d.Add(d.Mul(&t.s, x), &t.t))\n}\n\nvar three = big.NewInt(3)\nvar four = big.NewInt(4)\n\nfunc (t *lft) next() *big.Int {\n    r := t.extr(three)\n    var f big.Int\n    return f.Div(r.Num(), r.Denom())\n}\n\nfunc (t *lft) safe(n *big.Int) bool {\n    r := t.extr(four)\n    var f big.Int\n    if n.Cmp(f.Div(r.Num(), r.Denom())) == 0 {\n        return true\n    }\n    return false\n}\n\nfunc (t *lft) comp(u *lft) *lft {\n    var r lft\n    var a, b big.Int\n    r.q.Add(a.Mul(&t.q, &u.q), b.Mul(&t.r, &u.s))\n    r.r.Add(a.Mul(&t.q, &u.r), b.Mul(&t.r, &u.t))\n    r.s.Add(a.Mul(&t.s, &u.q), b.Mul(&t.t, &u.s))\n    r.t.Add(a.Mul(&t.s, &u.r), b.Mul(&t.t, &u.t))\n    return &r\n}\n\nfunc (t *lft) prod(n *big.Int) *lft {\n    var r lft\n    r.q.SetInt64(10)\n    r.r.Mul(r.r.SetInt64(-10), n)\n    r.t.SetInt64(1)\n    return r.comp(t)\n}\n\nfunc main() {\n    // init z to unit\n    z := new(lft)\n    z.q.SetInt64(1)\n    z.t.SetInt64(1)\n\n    // lfts generator\n    var k int64\n    lfts := func() *lft {\n        k++\n        r := new(lft)\n        r.q.SetInt64(k)\n        r.r.SetInt64(4*k+2)\n        r.t.SetInt64(2*k+1)\n        return r\n    }\n\n    // stream\n    for {\n        y := z.next()\n        if z.safe(y) {\n            fmt.Print(y)\n            z = z.prod(y)\n        } else {\n            z = z.comp(lfts())\n        }\n    }\n}\n\n", "explain": "Code below is a simplistic translation of Haskell code in Unbounded Spigot Algorithms for the Digits of Pi.  This is the algorithm specified for the pidigits benchmark of the Computer Language Benchmarks Game.\n(The standard Go distribution includes source submitted to the benchmark site, and that code runs stunning faster than the code below.)\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Delphi", "code": "\nTranslation of: BBC BASIC\n\nunit Pi_BBC_Main;\n\ninterface\n\nuses\n  Classes, Controls, Forms, Dialogs, StdCtrls;\n\ntype\n  TForm1 = class(TForm)\n    btnRunSpigotAlgo: TButton;\n    memScreen: TMemo;\n    procedure btnRunSpigotAlgoClick(Sender: TObject);\n    procedure FormCreate(Sender: TObject);\n  private\n    fScreenWidth : integer;\n    fLineBuffer : string;\n    procedure ClearText();\n    procedure AddText( const s : string);\n    procedure FlushText();\n  end;\n\nvar\n  Form1: TForm1;\n\nimplementation\n\n{$R *.dfm}\n\nuses SysUtils;\n\n// Button clicked to run algorithm\nprocedure TForm1.btnRunSpigotAlgoClick(Sender: TObject);\nvar\n  // BBC Basic variables. Delphi longint is 32 bits.\n  B : array of longint;\n  A, C, D, E, I, L, M, P : longint;\n  // Added for Delphi version\n  temp : string;\n  h, j, t : integer;\nbegin\n  fScreenWidth := 80;\n  ClearText();\n  M := 5368709; // floor( (2^31 - 1)/400 )\n\n  // DIM B%(M%) in BBC Basic declares an array [0..M%], i.e. M% + 1 elements\n  SetLength( B, M + 1);\n  for I := 0 to M do B[I] := 20;\n  E := 0;\n  L := 2;\n\n  // FOR C% = M% TO 14 STEP -7\n  // In Delphi (or at least Delphi 7) the step size in a for loop has to be 1.\n  // So the BBC Basic FOR loop has been replaced by a repeat loop.\n  C := M;\n  repeat\n    D := 0;\n    A := C*2 - 1;\n    for P := C downto 1 do begin\n      D := D*P + B[P]*$64; // hex notation copied from BBC version\n      B[P] := D mod A;\n      D := D div A;\n      dec( A, 2);\n    end;\n\n    // The BBC CASE statement here amounts to a series of if ... else\n    if (D = 99) then begin\n      E := E*100 + D;\n      inc( L, 2);\n    end\n    else if (C = M) then begin\n      AddText( SysUtils.Format( '%2.1f', [1.0*(D div 100) / 10.0] ));\n      E := D mod 100;\n    end\n    else begin\n      // PRINT RIGHT$(STRING$(L%,\"0\") + STR$(E% + D% DIV 100),L%);\n      // This can't be done so concisely in Delphi 7\n      SetLength( temp, L);\n      for j := 1 to L do temp[j] := '0';\n      temp := temp + SysUtils.IntToStr( E + D div 100);\n      t := Length( temp);\n      AddText( Copy( temp, t - L + 1, L));\n      E := D mod 100;\n      L := 2;\n    end;\n    dec( C, 7);\n  until (C < 14);\n  FlushText();\n\n  // Delphi addition: Write screen output to a file for checking\n  h := SysUtils.FileCreate( 'C:\\Delphi\\PiDigits.txt'); // h = file handle\n  for j := 0 to memScreen.Lines.Count - 1 do\n    SysUtils.FileWrite( h, memScreen.Lines[j][1], Length( memScreen.Lines[j]));\n  SysUtils.FileClose( h);\nend;\n\n{=========================== Auxiliary routines ===========================}\n\n// Form created\nprocedure TForm1.FormCreate(Sender: TObject);\nbegin\n  fScreenWidth := 80; // in case not set by the algotithm\n  ClearText();\nend;\n\n// This Delphi version builds each screen line in a buffer and puts\n//   the line into the TMemo when the buffer is full.\n// This is faster than writing to the TMemo a few characters at a time,\n//   but note that the buffer must be flushed at the end of the program.\nprocedure TForm1.ClearText();\nbegin\n  memScreen.Lines.Clear();\n  fLineBuffer := '';\nend;\n\nprocedure TForm1.AddText( const s : string);\nvar\n  nrChars, nrLeft : integer;\nbegin\n  nrChars := Length( s);\n  nrLeft := fScreenWidth - Length( fLineBuffer); // nr chars left in line\n  if (nrChars <= nrLeft) then fLineBuffer := fLineBuffer + s\n  else begin\n    fLineBuffer := fLineBuffer + Copy( s, 1, nrLeft);\n    memScreen.Lines.Add( fLineBuffer);\n    fLineBuffer := Copy( s, nrLeft + 1, nrChars - nrLeft);\n  end;\nend;\n\nprocedure TForm1.FlushText();\nbegin\n  if (Length(fLineBuffer) > 0) then begin\n    memScreen.Lines.Add( fLineBuffer);\n    fLineBuffer := '';\n  end;\nend;\n\nend.\n\n\nOutput:\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208\n99862803482534211706798214808651328230664709384460955058223172535940812848111745\n02841027019385211055596446229489549303819644288109756659334461284756482337867831\n...\n\n", "explain": "250,000 digits of pi on a BBC micro is pretty impressive, so a translation of the BBC code has been used for this Delphi 7 solution. A Delphi TMemo replaces the BBC screen, and the output is copied from the TMemo to a disk file at the end of the program. \nThe number of digits written depends on the variable M, and is found by experiment to be very close to 2*M/7. The value of M is limited by the danger of overflow in D, which can approach (but doesn't exceed) 400*M.\nWith M = floor( (2^31 - 1)/400 ), the Delphi version writes 1,533,913 decimal places, which have been verified against [sorry, defeated by the captcha as usual]\nintrocs dot cs dot princeton dot edu slash java slash data slash pi-10million.txt\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Ruby", "code": "\nTranslation of: Icon\npi_digits = Enumerator.new do |y|\n  q, r, t, k, n, l = 1, 0, 1, 1, 3, 3\n  loop do\n    if 4*q+r-t < n*t\n      y << n \n      nr = 10*(r-n*t)\n      n = ((10*(3*q+r)) / t) - 10*n\n      q *= 10\n      r = nr\n    else\n      nr = (2*q+r) * l\n      nn = (q*(7*k+2)+r*l) / (t*l)\n      q *= k\n      t *= l\n      l += 2\n      k += 1\n      n = nn\n      r = nr\n    end\n  end\nend\n\nprint pi_digits.next, \".\"\nloop { print pi_digits.next }\n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Rust", "code": "\nTranslation of: Kotlin\nuse num_bigint::BigInt;\n\nfn main() {\n    calc_pi();\n}\n\nfn calc_pi() {\n    let mut q = BigInt::from(1);\n    let mut r = BigInt::from(0);\n    let mut t = BigInt::from(1);\n    let mut k = BigInt::from(1);\n    let mut n = BigInt::from(3);\n    let mut l = BigInt::from(3);\n    let mut first = true;\n    loop {\n        if &q * 4 + &r - &t < &n * &t {\n            print!(\"{}\", n);\n            if first {\n                print!(\".\");\n                first = false;\n            }\n            let nr = (&r - &n * &t) * 10;\n            n = (&q * 3 + &r) * 10 / &t - &n * 10;\n            q *= 10;\n            r = nr;\n        } else {\n            let nr = (&q * 2 + &r) * &l;\n            let nn = (&q * &k * 7 + 2 + &r * &l) / (&t * &l);\n            q *= &k;\n            t *= &l;\n            l += 2;\n            k += 1;\n            n = nn;\n            r = nr;\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Swift", "code": "\nWorks with: Swift 4.2\n//\n//  main.swift\n//  pi digits\n//\n//  Created by max goren on 11/11/21.\n//  Copyright \u00a9 2021 maxcodes. All rights reserved.\n//\n\nimport Foundation\n\nvar r = [Int]()\nvar i = 0\nvar k = 2800\nvar b = 0\nvar c = 0\nvar d = 0\n\nfor _ in 0...2800 {\n    r.append(2000);\n}\nwhile k > 0 {\n    d = 0;\n    i = k;\n    while (true) {\n        d = d + r[i] * 10000\n        b = 2 * i - 1\n        r[i] = d % b\n        d = d / b\n        i = i - 1\n        if i == 0 {\n            break;\n        }\n        d = d * i;\n    }\n    print(c +  d / 10000, \"\")\n    c = d % 10000\n    k = k - 14\n}\n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "R", "code": "\nsuppressMessages(library(gmp))\nONE <- as.bigz(\"1\")\nTWO <- as.bigz(\"2\")\nTHREE <- as.bigz(\"3\")\nFOUR <- as.bigz(\"4\")\nSEVEN <- as.bigz(\"7\")\nTEN <- as.bigz(\"10\")\n\nq <- as.bigz(\"1\")\nr <- as.bigz(\"0\")\nt <- as.bigz(\"1\")\nk <- as.bigz(\"1\")\nn <- as.bigz(\"3\")\nl <- as.bigz(\"3\")\n\nchar_printed <- 0\n\nhow_many <- 1000\n\nfirst <- TRUE\nwhile (how_many > 0) {\n  if ((FOUR * q + r - t) < (n * t)) {\n    if (char_printed == 80) {\n      cat(\"\\n\")\n      char_printed <- 0\n    }\n    how_many <- how_many - 1\n    char_printed <- char_printed + 1\n    cat(as.integer(n))\n    if (first) {\n      cat(\".\")\n      first <- FALSE\n      char_printed <- char_printed + 1\n    }\n    nr <- as.bigz(TEN * (r - n * t))\n    n <- as.bigz(((TEN * (THREE * q + r)) %/% t) - (TEN * n))\n    q <- as.bigz(q * TEN)\n    r <- as.bigz(nr)\n  } else {\n    nr <- as.bigz((TWO * q + r) * l)\n    nn <- as.bigz((q * (SEVEN * k + TWO) + r * l) %/% (t * l))\n    q <- as.bigz(q * k)\n    t <- as.bigz(t * l)\n    l <- as.bigz(l + TWO)\n    k <- as.bigz(k + ONE)\n    n <- as.bigz(nn)\n    r <- as.bigz(nr)\n  }\n}\ncat(\"\\n\")\n\n\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208\n99862803482534211706798214808651328230664709384460955058223172535940812848111745\n02841027019385211055596446229489549303819644288109756659334461284756482337867831\n65271201909145648566923460348610454326648213393607260249141273724587006606315588\n17488152092096282925409171536436789259036001133053054882046652138414695194151160\n94330572703657595919530921861173819326117931051185480744623799627495673518857527\n24891227938183011949129833673362440656643086021394946395224737190702179860943702\n77053921717629317675238467481846766940513200056812714526356082778577134275778960\n91736371787214684409012249534301465495853710507922796892589235420199561121290219\n60864034418159813629774771309960518707211349999998372978049951059731732816096318\n59502445945534690830264252230825334468503526193118817101000313783875288658753320\n83814206171776691473035982534904287554687311595628638823537875937519577818577805\n32171226806613001927876611195909216420198\n\n", "explain": "Output:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\nWorks with: VBA version Access 97\nWorks with: VBA version 6.5\nWorks with: VBA version 7.1\nOption Explicit\n\nSub Main()\nConst VECSIZE As Long = 3350\nConst BUFSIZE As Long = 201\nDim buffer(1 To BUFSIZE) As Long\nDim vect(1 To VECSIZE) As Long\nDim more As Long, karray As Long, num As Long, k As Long, l As Long, n As Long\n\n  For n = 1 To VECSIZE\n    vect(n) = 2\n  Next n\n  For n = 1 To BUFSIZE\n    karray = 0\n    For l = VECSIZE To 1 Step -1\n      num = 100000 * vect(l) + karray * l\n      karray = num \\ (2 * l - 1)\n      vect(l) = num - karray * (2 * l - 1)\n    Next l\n    k = karray \\ 100000\n    buffer(n) = more + k\n    more = karray - k * 100000\n  Next n\n  Debug.Print CStr(buffer(1));\n  Debug.Print \".\"\n  l = 0\n  For n = 2 To BUFSIZE\n    Debug.Print Format$(buffer(n), \"00000\");\n    l = l + 1\n    If l = 10 Then\n      l = 0\n      Debug.Print 'line feed\n    End If\n  Next n\nEnd Sub\n\n\nOutput:\n3.\n14159265358979323846264338327950288419716939937510\n58209749445923078164062862089986280348253421170679\n82148086513282306647093844609550582231725359408128\n48111745028410270193852110555964462294895493038196\n44288109756659334461284756482337867831652712019091\n45648566923460348610454326648213393607260249141273\n72458700660631558817488152092096282925409171536436\n78925903600113305305488204665213841469519415116094\n33057270365759591953092186117381932611793105118548\n07446237996274956735188575272489122793818301194912\n98336733624406566430860213949463952247371907021798\n60943702770539217176293176752384674818467669405132\n00056812714526356082778577134275778960917363717872\n14684409012249534301465495853710507922796892589235\n42019956112129021960864034418159813629774771309960\n51870721134999999837297804995105973173281609631859\n50244594553469083026425223082533446850352619311881\n71010003137838752886587533208381420617177669147303\n59825349042875546873115956286388235378759375195778\n18577805321712268066130019278766111959092164201989\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Ada", "code": "\nWorks with: Ada 2005\nLibrary: GMP\n\npi_digits.adb\n\nwith Ada.Command_Line;\nwith Ada.Text_IO;\nwith GNU_Multiple_Precision.Big_Integers;\nwith GNU_Multiple_Precision.Big_Rationals;\nuse GNU_Multiple_Precision;\n\nprocedure Pi_Digits is\n   type Int is mod 2 ** 64;\n   package Int_To_Big is new Big_Integers.Modular_Conversions (Int);\n\n   -- constants\n   Zero : constant Big_Integer := Int_To_Big.To_Big_Integer (0);\n   One : constant Big_Integer := Int_To_Big.To_Big_Integer (1);\n   Two : constant Big_Integer := Int_To_Big.To_Big_Integer (2);\n   Three : constant Big_Integer := Int_To_Big.To_Big_Integer (3);\n   Four : constant Big_Integer := Int_To_Big.To_Big_Integer (4);\n   Ten : constant Big_Integer := Int_To_Big.To_Big_Integer (10);\n\n   -- type LFT = (Integer, Integer, Integer, Integer\n   type LFT is record\n      Q, R, S, T : Big_Integer;\n   end record;\n\n   -- extr\u00a0:: LFT -> Integer -> Rational\n   function Extr (T : LFT; X : Big_Integer) return Big_Rational is\n      use Big_Integers;\n      Result : Big_Rational;\n   begin\n      -- extr (q,r,s,t) x = ((fromInteger q) * x + (fromInteger r)) /\n      --                    ((fromInteger s) * x + (fromInteger t))\n      Big_Rationals.Set_Numerator (Item         => Result,\n                                   New_Value    => T.Q * X + T.R,\n                                   Canonicalize => False);\n      Big_Rationals.Set_Denominator (Item      => Result,\n                                     New_Value => T.S * X + T.T);\n      return Result;\n   end Extr;\n\n   -- unit\u00a0:: LFT\n   function Unit return LFT is\n   begin\n      -- unit = (1,0,0,1)\n      return LFT'(Q => One, R => Zero, S => Zero, T => One);\n   end Unit;\n\n   -- comp\u00a0:: LFT -> LFT -> LFT\n   function Comp (T1, T2 : LFT) return LFT is\n      use Big_Integers;\n   begin\n      -- comp (q,r,s,t) (u,v,w,x) = (q*u+r*w,q*v+r*x,s*u+t*w,s*v+t*x)\n      return LFT'(Q => T1.Q * T2.Q + T1.R * T2.S,\n                  R => T1.Q * T2.R + T1.R * T2.T,\n                  S => T1.S * T2.Q + T1.T * T2.S,\n                  T => T1.S * T2.R + T1.T * T2.T);\n   end Comp;\n\n   -- lfts = [(k, 4*k+2, 0, 2*k+1) | k<-[1..]\n   K : Big_Integer := Zero;\n   function LFTS return LFT is\n      use Big_Integers;\n   begin\n      K := K + One;\n      return LFT'(Q => K,\n                  R => Four * K + Two,\n                  S => Zero,\n                  T => Two * K + One);\n   end LFTS;\n\n   -- next z = floor (extr z 3)\n   function Next (T : LFT) return Big_Integer is\n   begin\n      return Big_Rationals.To_Big_Integer (Extr (T, Three));\n   end Next;\n\n   -- safe z n = (n == floor (extr z 4)\n   function Safe (T : LFT; N : Big_Integer) return Boolean is\n   begin\n      return N = Big_Rationals.To_Big_Integer (Extr (T, Four));\n   end Safe;\n\n   -- prod z n = comp (10, -10*n, 0, 1)\n   function Prod (T : LFT; N : Big_Integer) return LFT is\n      use Big_Integers;\n   begin\n      return Comp (LFT'(Q => Ten, R => -Ten * N, S => Zero, T => One), T);\n   end Prod;\n\n   procedure Print_Pi (Digit_Count : Positive) is\n      Z : LFT := Unit;\n      Y : Big_Integer;\n      Count : Natural := 0;\n   begin\n      loop\n         Y := Next (Z);\n         if Safe (Z, Y) then\n            Count := Count + 1;\n            Ada.Text_IO.Put (Big_Integers.Image (Y));\n            exit when Count >= Digit_Count;\n            Z := Prod (Z, Y);\n         else\n            Z := Comp (Z, LFTS);\n         end if;\n      end loop;\n   end Print_Pi;\n\n   N : Positive := 250;\nbegin\n   if Ada.Command_Line.Argument_Count = 1 then\n      N := Positive'Value (Ada.Command_Line.Argument (1));\n   end if;\n   Print_Pi (N);\nend Pi_Digits;\n\n\n 3 1 4 1 5 9 2 6 5 3 5 8 9 7 9 3 2 3 8 4 6 2 6 4 3 3 8 3 2 7 9 5 0 2 8 8 4 1 9 7 1 6 9 3 9 9 3 7 5 1 0 5 8 2 0 9 7 4 9 4 4 5 9 2 3 0 7 8 1 6 4 0 6 2 8 6 2 0 8 9 9 8 6 2 8 0 3 4 8 2 5 3 4 2 1 1 7 0 6 7\n", "explain": "uses same algorithm as Go solution, from http://web.comlab.ox.ac.uk/people/jeremy.gibbons/publications/spigot.pdf\noutput:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Julia", "code": "\n\nlet prec = precision(BigFloat), spi = \"\", digit = 1\n    while true\n      if digit > lastindex(spi)\n        prec *= 2\n        setprecision(prec)\n        spi = string(big(\u03c0))\n      end\n      print(spi[digit])\n      digit += 1\n    end\nend\n\n\n3.141592653589793238462643383279502884195e69399375105820974944592307816406286198e9862803482534211706798214808651328230664709384460955058223172535940812848115e450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724586997e0631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526357e8277857713427577896091736371787214684409012249534301465495853710507922796892589235420199561121290219608640344181598136297747713099605187072113499999983729780499510597317328160963185950244594553469083026425223082533446850352619311881710100031378387528865875332083814206171776691473035982534904287554687311595628638823537875937519577818577805321712268066130019278766111959092164201...\n", "explain": "Julia comes with built-in support for computing \u03c0 in arbitrary precision (using the GNU MPFR library).  This implementation computes \u03c0 at precisions that are repeatedly doubled as more digits are needed, printing one digit at a time and never terminating (until it runs out of memory) as specified:\nOutput:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.2\n\nimport java.math.BigInteger\n\nval ZERO  = BigInteger.ZERO\nval ONE   = BigInteger.ONE \nval TWO   = BigInteger.valueOf(2L)\nval THREE = BigInteger.valueOf(3L)\nval FOUR  = BigInteger.valueOf(4L)\nval SEVEN = BigInteger.valueOf(7L)\nval TEN   = BigInteger.TEN\n\nfun calcPi() {\n    var nn: BigInteger\n    var nr: BigInteger\n    var q = ONE\n    var r = ZERO\n    var t = ONE\n    var k = ONE\n    var n = THREE\n    var l = THREE     \n    var first = true\n    while (true) {\n        if (FOUR * q + r - t < n * t) {\n            print(n)\n            if (first) { print (\".\"); first = false }\n            nr = TEN * (r - n * t)\n            n = TEN * (THREE * q + r) / t - TEN * n\n            q *= TEN\n            r = nr\n        }\n        else {\n            nr = (TWO * q + r) * l\n            nn = (q * SEVEN * k + TWO + r * l) / (t * l)\n            q *= k\n            t *= l\n            l += TWO\n            k += ONE\n            n = nn\n            r = nr\n        }\n    }\n}\n\nfun main(args: Array<String>) = calcPi()\n\n\nOutput:\n3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745...\n\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Perl", "code": "\n\nSimple Spigot[edit]\n\nsub pistream {\n  my $digits = shift;\n  my(@out, @a);\n  my($b, $c, $d, $e, $f, $g, $i, $d4, $d3, $d2, $d1);\n  my $outi = 0;\n\n  $digits++;\n  $b = $d = $e = $g = $i = 0;\n  $f = 10000;\n  $c = 14 * (int($digits/4)+2);\n  @a = (20000000) x $c;\n  print \"3.\";\n  while (($b = $c -= 14) > 0 && $i < $digits) {\n    $d = $e = $d % $f;\n    while (--$b > 0) {\n      $d = $d * $b + $a[$b];\n      $g = ($b << 1) - 1;\n      $a[$b] = ($d % $g) * $f;\n      $d = int($d / $g);\n    }\n    $d4 = $e + int($d/$f);\n    if ($d4 > 9999) {\n      $d4 -= 10000;\n      $out[$i-1]++;\n      for ($b = $i-1; $out[$b] == 1; $b--) {\n        $out[$b] = 0;\n        $out[$b-1]++;\n      }\n    }\n    $d3 = int($d4/10);\n    $d2 = int($d3/10);\n    $d1 = int($d2/10);\n    $out[$i++] = $d1;\n    $out[$i++] = $d2-$d1*10;\n    $out[$i++] = $d3-$d2*10;\n    $out[$i++] = $d4-$d3*10;\n    print join \"\", @out[$i-15 .. $i-15+3]  if $i >= 16;\n  }\n  # We've closed the spigot.  Print the remainder without rounding.\n  print join \"\", @out[$i-15+4 .. $digits-2], \"\\n\";\n}\n\nRaku spigot[edit]\n\nTranslation of: Raku\nuse bigint try=>\"GMP\";\nsub stream { \n    my ($next, $safe, $prod, $cons, $z, $x) = @_;\n    $x = $x->();\n    sub {\n        while (1) {\n            my $y = $next->($z);\n            if ($safe->($z, $y)) {\n                $z = $prod->($z, $y);\n                return $y;\n            } else {\n                $z = $cons->($z, $x->());\n            }\n        }\n    }\n}\n \nsub extr {\n    use integer;\n    my ($q, $r, $s, $t) = @{shift()};\n    my $x = shift;\n    ($q * $x + $r) / ($s * $x + $t);\n}\n \nsub comp {\n    my ($q, $r, $s, $t) = @{shift()};\n    my ($u, $v, $w, $x) = @{shift()};\n    [$q * $u + $r * $w,\n     $q * $v + $r * $x,\n     $s * $u + $t * $w,\n     $s * $v + $t * $x];\n}\n \nmy $pi_stream = stream\n    sub { extr shift, 3 },\n    sub { my ($z, $n) = @_; $n == extr $z, 4 },\n    sub { my ($z, $n) = @_; comp([10, -10*$n, 0, 1], $z) },\n    \\&comp,\n    [1, 0, 0, 1],\n    sub { my $n = 0; sub { $n++; [$n, 4 * $n + 2, 0, 2 * $n + 1] } },\n;\n$|++;\nprint $pi_stream->(), '.';\nprint $pi_stream->() while 1;\n\nMachin's Formula[edit]\n\nuse bigint try=>\"GMP\";\n\n# Pi/4 = 4 arctan 1/5 - arctan 1/239\n# expanding it with Taylor series with what's probably the dumbest method\n\nmy ($ds, $ns) = (1, 0);\nmy ($n5, $d5) = (16 * (25 * 3 - 1), 3 * 5**3);\nmy ($n2, $d2) = (4 * (239 * 239 * 3 - 1), 3 * 239**3);\n\nsub next_term {\n\tmy ($coef, $p) = @_[1, 2];\n\t$_[0] /= ($p - 4) * ($p - 2);\n\t$_[0] *= $p * ($p + 2) * $coef**4;\n}\n\nmy $p2 = 5;\nmy $pow = 1;\n\n$| = 1;\nfor (my $x = 5; ; $x += 4) {\n\t($ns, $ds) = ($ns * $d5 + $n5 * $pow * $ds, $ds * $d5);\n\n\tnext_term($d5, 5, $x);\n\t$n5 = 16 * (5 * 5 * ($x + 2) - $x);\n\n\twhile ($d5 > $d2) {\n\t\t($ns, $ds) = ($ns * $d2 - $n2 * $pow * $ds, $ds * $d2);\n\t\t$n2 = 4 * (239 * 239 * ($p2 + 2) - $p2);\n\t\tnext_term($d2, 239, $p2);\n\t\t$p2 += 4;\n\t}\n\n\tmy $ppow = 1;\n\twhile ($pow * $n5 * 5**4 < $d5 && $pow * $n2 * $n2 * 239**4 < $d2) {\n\t\t$pow *= 10;\n\t\t$ppow *= 10;\n\t}\n\n\tif ($ppow > 1) {\n\t\t$ns *= $ppow;\n\t#FIX?\tmy $out = $ns->bdiv($ds);   # bugged?\n\t\tmy $out = $ns / $ds;\n\t\t$ns %= $ds;\n\n\t\t$out = (\"0\" x (length($ppow) - length($out) - 1)) . $out;\n\t\tprint $out;\n\t}\n\n\tif ( $p2 % 20 == 1) {\n\t\tmy $g = Math::BigInt::bgcd($ds, $ns);\n\t\t$ds /= $g;\n\t\t$ns /= $g;\n\t}\n}\n\nModules[edit]\n\nLibrary: ntheory\nuse ntheory qw/Pi/;\nsay Pi(10000);\n\nuse Math::Pari qw/setprecision Pi/;\nsetprecision(10000);\nsay Pi;\n\nuse Math::MPFR;\nmy $pi = Math::MPFR->new();\nMath::MPFR::Rmpfr_set_prec($pi, int(10000 * 3.322)+40);\nMath::MPFR::Rmpfr_const_pi($pi, 0);\nsay Math::MPFR::Rmpfr_get_str($pi, 10, 10000, 0);\n\nuse Math::BigFloat try=>\"GMP\";    # Slow without Math::BigInt::GMP installed\nsay Math::BigFloat::bpi(10000);   # For over ~2k digits, slower than AGM\n\nuse Math::Big qw/pi/;    # Very slow\nsay pi(10000);\n\n", "explain": "Perl being what it is, there are many ways to do this with many variations.  With a fixed number of digits and the Math::BigInt::GMP library installed, the [[Arithmetic-geometric mean/Calculate Pi code will be much faster than any of these methods other than some of the modules.  If Math::GMP is installed, then replacing \"use bigint\" with \"use Math::GMP qw/:constant/\" in either the Raku spigot or Machin methods below will be pretty fast.  They are not too bad if the Math::BigInt::GMP library is installed.  With the default Math::BigInt backend, the AGM code isn't very fast and the Raku spigot and Machin methods are very slow.\nThis takes a numer-of-digits argument, but we can make it large (albeit using memory and some startup time).  Unlike the other two, this uses no modules and does not require bigints so is worth showing.\nAs mentioned earlier, replacing \"use bigint\" with \"use Math::GMP qw/:constant/\" will result in many orders of magnitude faster performance.\nHere is an original Perl 5 code, using Machin's formula.  Not the fastest program in the world.  As with the previous code, using either Math::GMP or Math::BigInt::GMP instead of the default bigint Calc backend will make it run thousands of times faster.\nWhile no current CPAN module does continuous printing, there are (usually fast) ways to get digits of Pi.  Examples include:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Prolog", "code": "\n\npi_spigot :-\n    pi(X),\n    forall(member(Y, X), write(Y)).\n\npi(OUT) :-\n    pi(1, 180, 60, 2, OUT).\n\npi(Q, R, T, I, OUT) :-\n    freeze(OUT,\n           (   OUT = [Digit | OUT_]\n           ->  U is 3 * (3 * I + 1) * (3 * I + 2),\n               Y is (Q * (27 * I - 12) + 5 * R) // (5 * T),\n               Digit is Y,\n               Q2 is 10 * Q * I * (2 * I - 1),\n               R2 is 10 * U * (Q * (5 * I - 2) + R - Y * T),\n               T2 is T * U,\n               I2 is I + 1,\n               pi(Q2, R2, T2, I2, OUT_)\n           ;   true)).\n\n", "explain": "Using coroutine with freeze/2 predicate:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Lua", "code": "\nTranslation of: Pascal\na = {}\nn = 1000\nlen = math.modf( 10 * n / 3 )\n\nfor j = 1, len do\n    a[j] = 2\nend\nnines = 0\npredigit = 0\nfor j = 1, n do\n    q = 0\n    for i = len, 1, -1 do\n        x = 10 * a[i] + q * i\n        a[i] = math.fmod( x, 2 * i - 1 )\n        q = math.modf( x / ( 2 * i - 1 ) )\n    end\n    a[1] = math.fmod( q, 10 )\n    q = math.modf( q / 10 )\n    if q == 9 then\n        nines = nines + 1\n    else\n        if q == 10 then\n            io.write( predigit + 1 )\n            for k = 1, nines do\n                io.write(0)\n            end\n            predigit = 0\n            nines = 0\n        else\n            io.write( predigit )\n            predigit = q\n            if nines ~= 0 then\n                for k = 1, nines do\n                    io.write( 9 )\n                end\n                nines = 0\n            end\n        end\n    end\nend\nprint( predigit )\n\n03141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086 ...\n", "explain": ""}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Scala", "code": "\nobject Pi {\n  class PiIterator extends Iterable[BigInt] {\n    var r: BigInt = 0\n    var q, t, k: BigInt = 1\n    var n, l: BigInt = 3\n\n    def iterator: Iterator[BigInt] = new Iterator[BigInt] {\n      def hasNext = true\n\n      def next(): BigInt = {\n        while ((4 * q + r - t) >= (n * t)) {\n          val nr = (2 * q + r) * l\n          val nn = (q * (7 * k) + 2 + (r * l)) / (t * l)\n          q = q * k\n          t = t * l\n          l = l + 2\n          k = k + 1\n          n = nn\n          r = nr\n        }\n        val ret = n\n        val nr = 10 * (r - n * t)\n        n = ((10 * (3 * q + r)) / t) - (10 * n)\n        q = q * 10\n        r = nr\n        ret\n      }\n    }\n  }\n\n  def main(args: Array[String]): Unit = {\n    val it = new PiIterator\n    println(\"\" + (it.head) + \".\" + (it.take(300).mkString))\n  }\n\n}\n\n\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998\n62803482534211706798214808651328230664709384460955058223172535940812848111745028410\n27019385211055596446229489549303819644288109756659334461284756482337867831652712019\n09145648566923460348610454326648213393607260249141273\n", "explain": "Output:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "D", "code": "\n\nimport std.stdio, std.conv, std.string;\n\nstruct PiDigits {\n    immutable uint nDigits;\n\n    int opApply(int delegate(ref string /*chunk of pi digit*/) dg){\n        // Maximum width for correct output, for type ulong.\n        enum size_t width = 9;\n\n        enum ulong scale = 10UL ^^ width;\n        enum ulong initDigit = 2UL * 10UL ^^ (width - 1);\n        enum string formatString = \"%0\" ~ text(width) ~ \"d\";\n\n        immutable size_t len = 10 * nDigits / 3;\n        auto arr = new ulong[len];\n        arr[] = initDigit;\n        ulong carry;\n\n        foreach (i; 0 .. nDigits / width) {\n            ulong sum;\n            foreach_reverse (j; 0 .. len) {\n                auto quo = sum * (j + 1) + scale * arr[j];\n                arr[j] = quo % (j*2 + 1);\n                sum = quo / (j*2 + 1);\n            }\n            auto yield = format(formatString, carry + sum/scale);\n            if (dg(yield))\n                break;\n            carry = sum % scale;\n        }\n        return 0;\n    }\n}\n\nvoid main() {\n    foreach (d; PiDigits(100))\n        writeln(d);\n}\n\n\nOutput:\n314159265\n358979323\n846264338\n327950288\n419716939\n937510582\n097494459\n230781640\n628620899\n862803482\n534211706\nAlternative version[edit]\nimport std.stdio, std.bigint;\n\nvoid main() {\n    int ndigits = 0;\n    auto q = BigInt(1);\n    auto r = BigInt(0);\n    auto t = q;\n    auto k = q;\n    auto n = BigInt(3);\n    auto l = n;\n\n    bool first = true;\n    while (ndigits < 1_000) {\n        if (4 * q + r - t < n * t) {\n            write(n); ndigits++;\n            if (ndigits % 70 == 0) writeln();\n            if (first) { first = false; write('.'); }\n            auto nr = 10 * (r - n * t);\n            n = ((10 * (3 * q + r)) / t) - 10 * n;\n            q *= 10;\n            r = nr;\n        } else {\n            auto nr = (2    * q + r) * l;\n            auto nn = (q * (7 * k + 2) + r * l) / (t * l);\n            q *= k;\n            t *= l;\n            l += 2;\n            k++;\n            n = nn;\n            r = nr;\n        }\n    }\n}\n\n\nOutput:\n3.141592653589793238462643383279502884197169399375105820974944592307816\n4062862089986280348253421170679821480865132823066470938446095505822317\n2535940812848111745028410270193852110555964462294895493038196442881097\n5665933446128475648233786783165271201909145648566923460348610454326648\n2133936072602491412737245870066063155881748815209209628292540917153643\n6789259036001133053054882046652138414695194151160943305727036575959195\n3092186117381932611793105118548074462379962749567351885752724891227938\n1830119491298336733624406566430860213949463952247371907021798609437027\n7053921717629317675238467481846766940513200056812714526356082778577134\n2757789609173637178721468440901224953430146549585371050792279689258923\n5420199561121290219608640344181598136297747713099605187072113499999983\n7297804995105973173281609631859502445945534690830264252230825334468503\n5261931188171010003137838752886587533208381420617177669147303598253490\n4287554687311595628638823537875937519577818577805321712268066130019278\n76611195909216420198\n", "explain": "This modified Spigot algorithm does not continue infinitely, because its required memory grow as the number of digits need to print.    \n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Haskell", "code": "\n\npi_ = g (1, 0, 1, 1, 3, 3)\n  where\n    g (q, r, t, k, n, l) =\n      if 4 * q + r - t < n * t\n        then n :\n             g\n               ( 10 * q\n               , 10 * (r - n * t)\n               , t\n               , k\n               , div (10 * (3 * q + r)) t - 10 * n\n               , l)\n        else g\n               ( q * k\n               , (2 * q + r) * l\n               , t * l\n               , k + 1\n               , div (q * (7 * k + 2) + r * l) (t * l)\n               , l + 2)\n\nComplete command-line program[edit]\nWorks with: GHC version 7.4.1\n#!/usr/bin/runhaskell\n\nimport Control.Monad\nimport System.IO\n\npi_ = g(1,0,1,1,3,3) where\n  g (q,r,t,k,n,l) =\n   if 4*q+r-t < n*t\n    then n : g (10*q, 10*(r-n*t), t, k, div (10*(3*q+r)) t - 10*n, l)\n    else g (q*k, (2*q+r)*l, t*l, k+1, div (q*(7*k+2)+r*l) (t*l), l+2)\n\ndigs = insertPoint digs'\n  where insertPoint (x:xs) = x:'.':xs\n        digs' = map (head . show) pi_\n\nmain = do\n  hSetBuffering stdout $ BlockBuffering $ Just 80\n  forM_ digs putChar\n\n\nOutput:\n3.141592653589793238462643383279502884197169399375105820974944592307816406286208998628034825342117067982148086513282306647093844609550582231725359408128481117450284102701938521105559644622948954930381964428810975665933446128475648233786783165271201909145648566923460348610454326648213393607260249141273724587006606315588174881520920962829254091715364367892590360011330530548820466521384146951941511609433057270365759591953092186117381932611793105118548074462379962749567351885752724891227938183011949129833673362440656643086021394946395224737190702179860943702770539217176293176752384674818467669405132000568127145263560827785771342757789609173637178721468440901224953430146549585371050792279689258923542019956112129021960864034418159813629774771309960518707211349999998372978049951059731732816096318595024459455346908302642522308253344685035261931188171010003137838752886587533208381420617177669147303598253490428755468731159562863882353787593751957781857780532171226806613001927876611195909216420198\n\nQuicker, Unverified Algorithm[edit]\n\npiG3 = g(1,180,60,2) where\n  g(q,r,t,i) = let (u,y)=(3*(3*i+1)*(3*i+2),div(q*(27*i-12)+5*r)(5*t))\n    in y : g(10*q*i*(2*i-1),10*u*(q*(5*i-2)+r-y*t),t*u,i+1)\n\n\n", "explain": "The code from [3]:\nSnippet verbatim from source .pdf:\nThis is more efficient because each term converges in less than one step, so no checking needs to be done partway through the iteration. Only caveat is that the convergence is on average slightly over one digit, so there is a chance that, if one checked enough digits, one may find a gap where a digit would be incorrect. Though it seems to be OK for the first 100k digits, or so.\nOutput is the same. link to complete program at tio.run\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Scheme", "code": "\n(import (rnrs))\n\n(define (calc-pi yield)\n  (let loop ((q 1) (r 0) (t 1) (k 1) (n 3) (l 3))\n    (if (< (- (+ (* 4 q) r) t) (* n t))\n        (begin\n          (yield n)\n          (loop (* q  10)\n                (* 10 (- r (* n t)))\n                t\n                k\n                (- (div (* 10 (+ (* 3 q) r)) t) (* 10 n))\n                l))\n        (begin\n          (loop (* q k)\n                (* (+ (* 2 q) r) l)\n                (* t l)\n                (+ k 1)\n                (div (+ (* q (* 7 k)) 2 (* r l)) (* t l))\n                (+ l 2))))))\n\n(let ((i 0))\n  (calc-pi\n    (lambda (d)\n      (display d)\n      (set! i (+ i 1))\n      (if (= 40 i)\n          (begin\n            (newline)\n            (set! i 0))))))\n\n\n3141592653589793238462643383279502884197\n1693993751058209749445923078164062862089\n9862803482534211706798214808651328230664\n7093844609550582231725359408128481117450\n2841027019385211055596446229489549303819\n6442881097566593344612847564823378678316\n5271201909145648566923460348610454326648\n2133936072602491412737245870066063155881\n7488152092096282925409171536436789259036\n0011330530548820466521384146951941511609\n4330572703657595919530921861173819326117\n9310511854807446237996274956735188575272\n4891227938183011949129833673362440656643\n0860213949463952247371907021798609437027\n7053921717629317675238467481846766940513\n2000568127145263560827785771342757789609\n...\n", "explain": "Output:\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "TypeScript", "code": "\ntype AnyWriteableObject={write:((textToOutput:string)=>any)};\n\nfunction calcPi(pipe:AnyWriteableObject) {\n    let q = 1n, r=0n, t=1n, k=1n, n=3n, l=3n;\n    while (true) {\n        if (q * 4n + r - t < n* t) {\n            pipe.write(n.toString());\n            let nr = (r - n * t) * 10n;\n            n  = (q * 3n + r) * 10n / t - n * 10n ;\n            q  = q * 10n;\n            r  = nr;\n        } else {\n            let nr = (q * 2n + r) * l;\n            let nn = (q * k * 7n + 2n + r * l) / (t * l);\n            q = q * k;\n            t = t * l;\n            l = l + 2n;\n            k = k + 1n;\n            n  = nn;\n            r  = nr;\n        }\n    }\n}\n\ncalcPi(process.stdout);\n\n\nAsync version[edit]\ntype AnyWriteableObject = {write:((textToOutput:string)=>Promise<any>)};\n\nasync function calcPi<T extends AnyWriteableObject>(pipe:T) {\n    let q = 1n, r=0n, t=1n, k=1n, n=3n, l=3n;\n    while (true) {\n        if (q * 4n + r - t < n* t) {\n            await pipe.write(n.toString());\n            let nr = (r - n * t) * 10n;\n            n  = (q * 3n + r) * 10n / t - n * 10n ;\n            q  = q * 10n;\n            r  = nr;\n        } else {\n            let nr = (q * 2n + r) * l;\n            let nn = (q * k * 7n + 2n + r * l) / (t * l);\n            q = q * k;\n            t = t * l;\n            l = l + 2n;\n            k = k + 1n;\n            n  = nn;\n            r  = nr;\n        }\n    }\n}\n\nsetInterval(function(){\n    console.log(); // put a new line every second\n},1000);\n\nvar x = calcPi({\n    write: async function(phrase:string){\n        return new Promise(function(resolve){\n            setTimeout(function(){\n                process.stdout.write(phrase);\n                resolve();\n            },1);\n        });\n    }\n});\n\nconsole.log('.'); //start!\n\n\n", "explain": "Notes:\n1. Typescript has bigint support https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-2.html#bigint Literals are write with a n sufix: 10n\n2. Pi function receives any object that has a write function. Using node.js we can pass to it process.stdout\nHere the calculation does not continue if the consumer does not consume the character.\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "F#", "code": "\nTranslation of Haskell[edit]\nTranslation of: Haskell\nlet rec g q r t k n l = seq {\n    if 4I*q+r-t < n*t\n    then\n        yield n\n        yield! (g (10I*q) (10I*(r-n*t)) t k ((10I*(3I*q+r))/t - 10I*n) l)\n    else\n        yield! (g (q*k) ((2I*q+r)*l) (t*l) (k+1I) ((q*(7I*k+2I)+r*l)/(t*l)) (l+2I))\n}\n\nlet \u03c0 = (g 1I 0I 1I 1I 3I 3I)\n\nSeq.take 1 \u03c0 |> Seq.iter (printf \"%A.\")\n// 6 digits beginning at position 762 of \u03c0 are '9'\nSeq.take 767 (Seq.skip 1 \u03c0) |> Seq.iter (printf \"%A\")\n\n\nOutput:\n3.14159265358979323846264338327950288419716939937510582097494459230781640628620899862803482534211706798214808651328230664709384460955058223172535940812848111745028410270193852110555964462294895493038196442881097566593344612847564823378678316527120190914564856692346034861045432664821339360726024914127372458700660631558817488152092096282925409171536436789259036001133053054882046652138414695194151160943305727036575959195309218611738193261179310511854807446237996274956735188575272489122793818301194912983367336244065664308602139494639522473719070217986094370277053921717629317675238467481846766940513200056812714526356082778577134275778960917363717872146844090122495343014654958537105079227968925892354201995611212902196086403441815981362977477130996051870721134999999\nAs an Unfold[edit]\n\n// Generate Pi as above using unfold. Nigel Galloway: March 15th., 2022\nlet \u03c0()=Seq.unfold(fun(q,r,t,k,n,l)->Some(if 4I*q+r-t < n*t then(Some(int n),((10I*q),(10I*(r-n*t)),t,k,((10I*(3I*q+r))/t-10I*n),l)) else (None,((q*k),((2I*q+r)*l),(t*l),(k+1I),((q*(7I*k+2I)+r*l)/(t*l)),(l+2I)))))(1I,0I,1I,1I,3I,3I)|>Seq.choose id\n\u03c0()|>Seq.take 767|>Seq.iter(printf \"%d\")\n\n", "explain": "Haskell can probably do this as an unfold, it has not so I shall in F#\n"}, {"task_name": "Pi", "task_url": "https://rosettacode.org/wiki/Pi", "task_cat": "Geometry", "lang": "Groovy", "code": "\nTranslation of: Java\n\nBigInteger q = 1, r = 0, t = 1, k = 1, n = 3, l = 3\nString nn\nboolean first = true\n\nwhile (true) {\n    (nn, first, q, r, t, k, n, l) = (4*q + r - t < n*t) \\\n        ? [\"${n}${first?'.':''}\", false, 10*q, 10*(r - n*t), t  , k    , 10*(3*q + r)/t - 10*n    , l    ] \\\n       \u00a0: [''                   , first, q*k , (2*q + r)*l , t*l, k + 1, (q*(7*k + 2) + r*l)/(t*l), l + 2]\n    print nn\n}\n\n\n3.1415926535897932384626433832795028841971693993751058209749445923078164062862089986280348253421170679821480865132823066470938446095505822317253594081284811174502841027019385211055596446229489549303819644288109756659334461284756482337\n", "explain": "Solution:\nOutput (thru first 1000 iterations):\n"}]