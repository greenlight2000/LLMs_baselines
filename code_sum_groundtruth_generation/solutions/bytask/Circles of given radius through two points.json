[{"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Python", "code": "\n\nfrom collections import namedtuple\nfrom math import sqrt\n\nPt = namedtuple('Pt', 'x, y')\nCircle = Cir = namedtuple('Circle', 'x, y, r')\n\ndef circles_from_p1p2r(p1, p2, r):\n    'Following explanation at http://mathforum.org/library/drmath/view/53027.html'\n    if r == 0.0:\n        raise ValueError('radius of zero')\n    (x1, y1), (x2, y2) = p1, p2\n    if p1 == p2:\n        raise ValueError('coincident points gives infinite number of Circles')\n    # delta x, delta y between points\n    dx, dy = x2 - x1, y2 - y1\n    # dist between points\n    q = sqrt(dx**2 + dy**2)\n    if q > 2.0*r:\n        raise ValueError('separation of points > diameter')\n    # halfway point\n    x3, y3 = (x1+x2)/2, (y1+y2)/2\n    # distance along the mirror line\n    d = sqrt(r**2-(q/2)**2)\n    # One answer\n    c1 = Cir(x = x3 - d*dy/q,\n             y = y3 + d*dx/q,\n             r = abs(r))\n    # The other answer\n    c2 = Cir(x = x3 + d*dy/q,\n             y = y3 - d*dx/q,\n             r = abs(r))\n    return c1, c2\n\nif __name__ == '__main__':\n    for p1, p2, r in [(Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 2.0),\n                      (Pt(0.0000, 2.0000), Pt(0.0000, 0.0000), 1.0),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 2.0),\n                      (Pt(0.1234, 0.9876), Pt(0.8765, 0.2345), 0.5),\n                      (Pt(0.1234, 0.9876), Pt(0.1234, 0.9876), 0.0)]:\n        print('Through points:\\n  %r,\\n  %r\\n  and radius %f\\nYou can construct the following circles:'\n              % (p1, p2, r))\n        try:\n            print('  %r\\n  %r\\n' % circles_from_p1p2r(p1, p2, r))\n        except ValueError as v:\n            print('  ERROR: %s\\n' % (v.args[0],))\n\n\nOutput:\nThrough points:\n  Pt(x=0.1234, y=0.9876),\n  Pt(x=0.8765, y=0.2345)\n  and radius 2.000000\nYou can construct the following circles:\n  Circle(x=1.8631118016581893, y=1.974211801658189, r=2.0)\n  Circle(x=-0.8632118016581896, y=-0.7521118016581892, r=2.0)\n\nThrough points:\n  Pt(x=0.0, y=2.0),\n  Pt(x=0.0, y=0.0)\n  and radius 1.000000\nYou can construct the following circles:\n  Circle(x=0.0, y=1.0, r=1.0)\n  Circle(x=0.0, y=1.0, r=1.0)\n\nThrough points:\n  Pt(x=0.1234, y=0.9876),\n  Pt(x=0.1234, y=0.9876)\n  and radius 2.000000\nYou can construct the following circles:\n  ERROR: coincident points gives infinite number of Circles\n\nThrough points:\n  Pt(x=0.1234, y=0.9876),\n  Pt(x=0.8765, y=0.2345)\n  and radius 0.500000\nYou can construct the following circles:\n  ERROR: separation of points > diameter\n\nThrough points:\n  Pt(x=0.1234, y=0.9876),\n  Pt(x=0.1234, y=0.9876)\n  and radius 0.000000\nYou can construct the following circles:\n  ERROR: radius of zero\n", "explain": "The function raises the ValueError exception for the special cases \nand uses try - except to catch these and extract the exception detail.\n"}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "C", "code": "\n#include<stdio.h>\n#include<math.h>\n\ntypedef struct{\n\tdouble x,y;\n\t}point;\n\t\ndouble distance(point p1,point p2)\n{\n\treturn sqrt((p1.x-p2.x)*(p1.x-p2.x)+(p1.y-p2.y)*(p1.y-p2.y));\n}\n\t\nvoid findCircles(point p1,point p2,double radius)\n{\n\tdouble separation = distance(p1,p2),mirrorDistance;\n\t\n\tif(separation == 0.0)\n\t{\n\t\tradius == 0.0 ? printf(\"\\nNo circles can be drawn through (%.4f,%.4f)\",p1.x,p1.y):\n\t\t\t\t\t\t\t printf(\"\\nInfinitely many circles can be drawn through (%.4f,%.4f)\",p1.x,p1.y);\n\t}\n\t\n\telse if(separation == 2*radius)\n\t{\n\t\tprintf(\"\\nGiven points are opposite ends of a diameter of the circle with center (%.4f,%.4f) and radius\u00a0%.4f\",(p1.x+p2.x)/2,(p1.y+p2.y)/2,radius); \n\t}\n\t\n\telse if(separation > 2*radius)\n\t{\n\t\tprintf(\"\\nGiven points are farther away from each other than a diameter of a circle with radius\u00a0%.4f\",radius);\n\t}   \n\t\n\telse\n\t{\n\t\tmirrorDistance =sqrt(pow(radius,2) - pow(separation/2,2));\n\t\t\n\t\tprintf(\"\\nTwo circles are possible.\");\n\t\tprintf(\"\\nCircle C1 with center (%.4f,%.4f), radius\u00a0%.4f and Circle C2 with center (%.4f,%.4f), radius\u00a0%.4f\",(p1.x+p2.x)/2 + mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 + mirrorDistance*(p2.x-p1.x)/separation,radius,(p1.x+p2.x)/2 - mirrorDistance*(p1.y-p2.y)/separation,(p1.y+p2.y)/2 - mirrorDistance*(p2.x-p1.x)/separation,radius);\n\t}\n}\n\nint main()\n{\n    int i;\n\n    point cases[] = \t\n    {\t{0.1234, 0.9876},    {0.8765, 0.2345},  \n\t{0.0000, 2.0000},    {0.0000, 0.0000},   \n\t{0.1234, 0.9876},    {0.1234, 0.9876},   \n\t{0.1234, 0.9876},    {0.8765, 0.2345},    \n\t{0.1234, 0.9876},    {0.1234, 0.9876}\n    };\n\n    double radii[] = {2.0,1.0,2.0,0.5,0.0};\n\n    for(i=0;i<5;i++)\n    {\t\n\tprintf(\"\\nCase %d)\",i+1);\n\tfindCircles(cases[2*i],cases[2*i+1],radii[i]);\n    }\n\n    return 0;\n}\n\n\ntest run:\nCase 1)\nTwo circles are possible.\nCircle C1 with center (1.8631,1.9742), radius 2.0000 and Circle C2 with center (-0.8632,-0.7521), radius 2.0000\nCase 2)\nGiven points are opposite ends of a diameter of the circle with center (0.0000,1.0000) and radius 1.0000\nCase 3)\nInfinitely many circles can be drawn through (0.1234,0.9876)\nCase 4)\nGiven points are farther away from each other than a diameter of a circle with radius 0.5000\nCase 5)\nNo circles can be drawn through (0.1234,0.9876)\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "C++", "code": "\nWorks with: C++11\n#include <iostream>\n#include <cmath>\n#include <tuple>\n\nstruct point { double x, y; };\n\nbool operator==(const point& lhs, const point& rhs)\n{ return std::tie(lhs.x, lhs.y) == std::tie(rhs.x, rhs.y); }\n\nenum result_category { NONE, ONE_COINCEDENT, ONE_DIAMETER, TWO, INFINITE };\n\nusing result_t = std::tuple<result_category, point, point>;\n\ndouble distance(point l, point r)\n{ return std::hypot(l.x - r.x, l.y - r.y); }\n\nresult_t find_circles(point p1, point p2, double r)\n{\n    point ans1 { 1/0., 1/0.}, ans2 { 1/0., 1/0.};\n    if (p1 == p2) {\n        if(r == 0.) return std::make_tuple(ONE_COINCEDENT, p1,   p2  );\n        else        return std::make_tuple(INFINITE,       ans1, ans2);\n    }\n    point center { p1.x/2 + p2.x/2, p1.y/2 + p2.y/2};\n    double half_distance = distance(center, p1);\n    if(half_distance > r)      return std::make_tuple(NONE,         ans1,   ans2);\n    if(half_distance - r == 0) return std::make_tuple(ONE_DIAMETER, center, ans2);\n    double root = sqrt(pow(r, 2.l) - pow(half_distance, 2.l)) / distance(p1, p2);\n    ans1.x = center.x + root * (p1.y - p2.y);\n    ans1.y = center.y + root * (p2.x - p1.x);\n    ans2.x = center.x - root * (p1.y - p2.y);\n    ans2.y = center.y - root * (p2.x - p1.x);\n    return std::make_tuple(TWO, ans1, ans2);\n}\n\nvoid print(result_t result, std::ostream& out = std::cout)\n{\n    point r1, r2; result_category res;\n    std::tie(res, r1, r2) = result;\n    switch(res) {\n      case NONE:\n        out << \"There are no solutions, points are too far away\\n\"; break;\n      case ONE_COINCEDENT: case ONE_DIAMETER:\n        out << \"Only one solution: \" << r1.x << ' ' << r1.y << '\\n'; break;\n      case INFINITE:\n        out << \"Infinitely many circles can be drawn\\n\"; break;\n      case TWO:\n        out << \"Two solutions: \" << r1.x << ' ' << r1.y << \" and \" << r2.x << ' ' << r2.y << '\\n'; break;\n    }\n}\n\nint main()\n{\n    constexpr int size = 5;\n    const point points[size*2] = {\n        {0.1234, 0.9876}, {0.8765, 0.2345}, {0.0000, 2.0000}, {0.0000, 0.0000},\n        {0.1234, 0.9876}, {0.1234, 0.9876}, {0.1234, 0.9876}, {0.8765, 0.2345},\n        {0.1234, 0.9876}, {0.1234, 0.9876}\n    };\n    const double radius[size] = {2., 1., 2., .5, 0.};\n\n    for(int i = 0; i < size; ++i)\n        print(find_circles(points[i*2], points[i*2 + 1], radius[i]));\n}\n\n\nOutput:\nTwo solutions: 1.86311 1.97421 and -0.863212 -0.752112\nOnly one solution: 0 1\nInfinitely many circles can be drawn\nThere are no solutions, points are too far away\nOnly one solution: 0.1234 0.9876\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Java", "code": "\nTranslation of: Kotlin\nimport java.util.Objects;\n\npublic class Circles {\n    private static class Point {\n        private final double x, y;\n\n        public Point(Double x, Double y) {\n            this.x = x;\n            this.y = y;\n        }\n\n        public double distanceFrom(Point other) {\n            double dx = x - other.x;\n            double dy = y - other.y;\n            return Math.sqrt(dx * dx + dy * dy);\n        }\n\n        @Override\n        public boolean equals(Object other) {\n            if (this == other) return true;\n            if (other == null || getClass() != other.getClass()) return false;\n            Point point = (Point) other;\n            return x == point.x && y == point.y;\n        }\n\n        @Override\n        public String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y);\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\");\n        if (r == 0.0 && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\");\n        if (r == 0.0) return new Point[]{p1, p1};\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\");\n        double distance = p1.distanceFrom(p2);\n        double diameter = 2.0 * r;\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\");\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0);\n        if (distance == diameter) return new Point[]{center, center};\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0);\n        double dx = (p2.x - p1.x) * mirrorDistance / distance;\n        double dy = (p2.y - p1.y) * mirrorDistance / distance;\n        return new Point[]{\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        };\n    }\n\n    public static void main(String[] args) {\n        Point[] p = new Point[]{\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        };\n        Point[][] points = new Point[][]{\n            {p[0], p[1]},\n            {p[2], p[3]},\n            {p[0], p[0]},\n            {p[0], p[1]},\n            {p[0], p[0]},\n        };\n        double[] radii = new double[]{2.0, 1.0, 2.0, 0.5, 0.0};\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0];\n            Point p2 = points[i][1];\n            double r = radii[i];\n            System.out.printf(\"For points %s and %s with radius %f\\n\", p1, p2, r);\n            try {\n                Point[] circles = findCircles(p1, p2, r);\n                Point c1 = circles[0];\n                Point c2 = circles[1];\n                if (Objects.equals(c1, c2)) {\n                    System.out.printf(\"there is just one circle with center at %s\\n\", c1);\n                } else {\n                    System.out.printf(\"there are two circles with centers at %s and %s\\n\", c1, c2);\n                }\n            } catch (IllegalArgumentException ex) {\n                System.out.println(ex.getMessage());\n            }\n            System.out.println();\n        }\n    }\n}\n\n\nOutput:\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 2.000000\nthere are two circles with centers at (1.8631, 1.9742) and (-0.8632, -0.7521)\n\nFor points (0.0000, 2.0000) and (0.0000, 0.0000) with radius 1.000000\nthere is just one circle with center at (0.0000, 1.0000)\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 2.000000\nan infinite number of circles can be drawn\n\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.500000\nthe points are too far apart to draw a circle\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 0.000000\nthere is just one circle with center at (0.1234, 0.9876)\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "C#", "code": "\nWorks with: C sharp version 6\nusing System;\npublic class CirclesOfGivenRadiusThroughTwoPoints\n{\n    public static void Main()\n    {\n        double[][] values = new double[][] {\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345,   2 },\n            new [] { 0.0,       2.0,    0.0,    0.0,   1 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   2 },\n            new [] { 0.1234, 0.9876, 0.8765, 0.2345, 0.5 },\n            new [] { 0.1234, 0.9876, 0.1234, 0.9876,   0 }\n        };\n\t\t\n        foreach (var a in values) {\n            var p = new Point(a[0], a[1]);\n            var q = new Point(a[2], a[3]);\n            Console.WriteLine($\"Points {p} and {q} with radius {a[4]}:\");\n            try {\n                var centers = FindCircles(p, q, a[4]);\n                Console.WriteLine(\"\\t\" + string.Join(\" and \", centers));\n            } catch (Exception ex) {\n                Console.WriteLine(\"\\t\" + ex.Message);\n            }\n        }\n    }\n\t\n    static Point[] FindCircles(Point p, Point q, double radius) {\n        if(radius < 0) throw new ArgumentException(\"Negative radius.\");\n        if(radius == 0) {\n            if(p == q) return new [] { p };\n            else throw new InvalidOperationException(\"No circles.\");\n        }\n        if (p == q) throw new InvalidOperationException(\"Infinite number of circles.\");\n\t\t\n        double sqDistance = Point.SquaredDistance(p, q);\n        double sqDiameter = 4 * radius * radius;\n        if (sqDistance > sqDiameter) throw new InvalidOperationException(\"Points are too far apart.\");\n\t\t\n        Point midPoint = new Point((p.X + q.X) / 2, (p.Y + q.Y) / 2);\n        if (sqDistance == sqDiameter) return new [] { midPoint };\n\t\t\n        double d = Math.Sqrt(radius * radius - sqDistance / 4);\n        double distance = Math.Sqrt(sqDistance);\n        double ox = d * (q.X - p.X) / distance, oy = d * (q.Y - p.Y) / distance;\n        return new [] {\n            new Point(midPoint.X - oy, midPoint.Y + ox),\n            new Point(midPoint.X + oy, midPoint.Y - ox)\n        };\n    }\n\t\n    public struct Point\n    {\n        public Point(double x, double y) : this() {\n            X = x;\n            Y = y;\n        }\n\t\n        public double X { get; }\n        public double Y { get; }\n\t\n        public static bool operator ==(Point p, Point q) => p.X == q.X && p.Y == q.Y;\n        public static bool operator !=(Point p, Point q) => p.X != q.X || p.Y != q.Y;\n\t\n        public static double SquaredDistance(Point p, Point q) {\n            double dx = q.X - p.X, dy = q.Y - p.Y;\n            return dx * dx + dy * dy;\n        }\n\t\t\n        public override string ToString() => $\"({X}, {Y})\";\n\t\t\n    }\t\n}\n\n\nOutput:\nPoints (0.1234, 0.9876) and (0.8765, 0.2345) with radius 2:\n    (1.86311180165819, 1.97421180165819) and (-0.86321180165819, -0.752111801658189)\nPoints (0, 2) and (0, 0) with radius 1:\n    (0, 1)\nPoints (0.1234, 0.9876) and (0.1234, 0.9876) with radius 2:\n    Infinite number of circles.\nPoints (0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.5:\n    Points are too far apart.\nPoints (0.1234, 0.9876) and (0.1234, 0.9876) with radius 0:\n    (0.1234, 0.9876)\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nES6[edit]\nconst hDist = (p1, p2) => Math.hypot(...p1.map((e, i) => e - p2[i])) / 2;\nconst pAng = (p1, p2) => Math.atan(p1.map((e, i) => e - p2[i]).reduce((p, c) => c / p, 1));\nconst solveF = (p, r) => t => [r*Math.cos(t) + p[0], r*Math.sin(t) + p[1]];\nconst diamPoints = (p1, p2) => p1.map((e, i) => e + (p2[i] - e) / 2);\n\nconst findC = (...args) => {\n  const [p1, p2, s] = args;\n  const solve = solveF(p1, s);\n  const halfDist = hDist(p1, p2);\n\n  let msg = `p1: ${p1}, p2: ${p2}, r:${s} Result: `;\n  switch (Math.sign(s - halfDist)) {\n    case 0:\n      msg += s ? `Points on diameter. Circle at: ${diamPoints(p1, p2)}` :\n        'Radius Zero';\n      break;\n    case 1:\n      if (!halfDist) {\n        msg += 'Coincident point. Infinite solutions';\n      }\n      else {\n        let theta = pAng(p1, p2);\n        let theta2 = Math.acos(halfDist / s);\n        [1, -1].map(e => solve(theta + e * theta2)).forEach(\n          e => msg += `Circle at ${e} `);\n      }\n      break;\n    case -1:\n      msg += 'No intersection. Points further apart than circle diameter';\n      break;\n  }\n  return msg;\n};\n\n\n[\n  [[0.1234, 0.9876], [0.8765, 0.2345], 2.0],\n  [[0.0000, 2.0000], [0.0000, 0.0000], 1.0],\n  [[0.1234, 0.9876], [0.1234, 0.9876], 2.0],\n  [[0.1234, 0.9876], [0.8765, 0.2345], 0.5],\n  [[0.1234, 0.9876], [0.1234, 0.9876], 0.0]\n].forEach((t,i) => console.log(`Test: ${i}: ${findC(...t)}`));\n\n\nTest: 0: p1: 0.1234,0.9876, p2: 0.8765,0.2345, r:2 Result: Circle at 1.8631118016581891,1.974211801658189 Circle at -0.863211801658189,-0.7521118016581889 \nTest: 1: p1: 0,2, p2: 0,0, r:1 Result: Points on diameter. Circle at: 0,1\nTest: 2: p1: 0.1234,0.9876, p2: 0.1234,0.9876, r:2 Result: Coincident point. Infinite solutions\nTest: 3: p1: 0.1234,0.9876, p2: 0.8765,0.2345, r:0.5 Result: No intersection. Points further apart than circle diameter\nTest: 4: p1: 0.1234,0.9876, p2: 0.1234,0.9876, r:0 Result: Radius Zero\n\n", "explain": "Output:\n"}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nPublic Class CirclesOfGivenRadiusThroughTwoPoints\n    Public Shared Sub Main()\n        For Each valu In New Double()() {\n        New Double() {0.1234, 0.9876, 0.8765, 0.2345, 2},\n        New Double() {0.0, 2.0, 0.0, 0.0, 1},\n        New Double() {0.1234, 0.9876, 0.1234, 0.9876, 2},\n        New Double() {0.1234, 0.9876, 0.8765, 0.2345, 0.5},\n        New Double() {0.1234, 0.9876, 0.1234, 0.9876, 0},\n        New Double() {0.1234, 0.9876, 0.2345, 0.8765, 0}}\n            Dim p = New Point(valu(0), valu(1)), q = New Point(valu(2), valu(3))\n            Console.WriteLine($\"Points {p} and {q} with radius {valu(4)}:\")\n            Try\n                Console.WriteLine(vbTab & String.Join(\" and \", FindCircles(p, q, valu(4))))\n            Catch ex As Exception\n                Console.WriteLine(vbTab & ex.Message)\n            End Try\n        Next\n        If System.Diagnostics.Debugger.IsAttached Then Console.ReadKey()\n    End Sub\n\n    Private Shared Function FindCircles(ByVal p As Point, ByVal q As Point, ByVal rad As Double) As Point()\n        If rad < 0 Then Throw New ArgumentException(\"Negative radius.\")\n        If rad = 0 Then Throw New InvalidOperationException(If(p = q,\n            String.Format(\"{0} (degenerate circle)\", {p}), \"No circles.\"))\n        If p = q Then Throw New InvalidOperationException(\"Infinite number of circles.\")\n        Dim dist As Double = Point.Distance(p, q), sqDist As Double = dist * dist,\n            sqDiam As Double = 4 * rad * rad\n        If sqDist > sqDiam Then Throw New InvalidOperationException(\n            String.Format(\"Points are too far apart (by {0}).\", sqDist - sqDiam))\n        Dim midPoint As Point = New Point((p.X + q.X) / 2, (p.Y + q.Y) / 2)\n        If sqDist = sqDiam Then Return {midPoint}\n        Dim d As Double = Math.Sqrt(rad * rad - sqDist / 4),\n            a As Double = d * (q.X - p.X) / dist, b As Double = d * (q.Y - p.Y) / dist\n        Return {New Point(midPoint.X - b, midPoint.Y + a), New Point(midPoint.X + b, midPoint.Y - a)}\n    End Function\n\n    Public Structure Point\n        Public ReadOnly Property X As Double\n        Public ReadOnly Property Y As Double\n\n        Public Sub New(ByVal ix As Double, ByVal iy As Double)\n            Me.New() : X = ix : Y = iy\n        End Sub\n\n        Public Shared Operator =(ByVal p As Point, ByVal q As Point) As Boolean\n            Return p.X = q.X AndAlso p.Y = q.Y\n        End Operator\n\n        Public Shared Operator <>(ByVal p As Point, ByVal q As Point) As Boolean\n            Return p.X <> q.X OrElse p.Y <> q.Y\n        End Operator\n\n        Public Shared Function SquaredDistance(ByVal p As Point, ByVal q As Point) As Double\n            Dim dx As Double = q.X - p.X, dy As Double = q.Y - p.Y\n            Return dx * dx + dy * dy\n        End Function\n\n        Public Shared Function Distance(ByVal p As Point, ByVal q As Point) As Double\n            Return Math.Sqrt(SquaredDistance(p, q))\n        End Function\n\n        Public Overrides Function ToString() As String\n            Return $\"({X}, {Y})\"\n        End Function\n    End Structure\nEnd Class\n\n\nOutput:\nPoints (0.1234, 0.9876) and (0.8765, 0.2345) with radius 2:\n        (1.86311180165819, 1.97421180165819) and (-0.86321180165819, -0.752111801658189)\nPoints (0, 2) and (0, 0) with radius 1:\n        (0, 1)\nPoints (0.1234, 0.9876) and (0.1234, 0.9876) with radius 2:\n        Infinite number of circles.\nPoints (0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.5:\n        Points are too far apart (by 0.13431922).\nPoints (0.1234, 0.9876) and (0.1234, 0.9876) with radius 0:\n        (0.1234, 0.9876) (degenerate circle)\nPoints (0.1234, 0.9876) and (0.2345, 0.8765) with radius 0:\n        No circles.\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Fortran", "code": "\n! Implemented by Anant Dixit (Nov. 2014)\n! Transpose elements in find_center to obtain correct results. R.N. McLean (Dec 2017)\nprogram circles\nimplicit none\ndouble precision :: P1(2), P2(2), R\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0,0.2345d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.0d0, 2.0d0/)\nP2 = (/0.0d0,0.0d0/)\nR = 1.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 2.0d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.8765d0, 0.2345d0/)\nR = 0.5d0\ncall print_centers(P1,P2,R)\n\nP1 = (/0.1234d0, 0.9876d0/)\nP2 = (/0.1234d0, 0.9876d0/)\nR = 0.0d0\ncall print_centers(P1,P2,R)\nend program circles\n\nsubroutine print_centers(P1,P2,R)\nimplicit none\ndouble precision :: P1(2), P2(2), R, Center(2,2)\ninteger :: Res\ncall test_inputs(P1,P2,R,Res)\nwrite(*,*)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point1 \u00a0: ', P1(1), ' ', P1(2)\nwrite(*,'(A10,F7.4,A1,F7.4)') 'Point2 \u00a0: ', P2(1), ' ', P2(2)\nwrite(*,'(A10,F7.4)') 'Radius \u00a0: ', R\nif(Res.eq.1) then\n  write(*,*) 'Same point because P1=P2 and r=0.'\nelseif(Res.eq.2) then\n  write(*,*) 'No circles can be drawn because r=0.'\nelseif(Res.eq.3) then\n  write(*,*) 'Infinite circles because P1=P2 for non-zero radius.'\nelseif(Res.eq.4) then\n  write(*,*) 'No circles with given r can be drawn because points are far apart.'\nelseif(Res.eq.0) then\n  call find_center(P1,P2,R,Center)\n  if(Center(1,1).eq.Center(2,1) .and. Center(1,2).eq.Center(2,2)) then\n    write(*,*) 'Points lie on the diameter. A single circle can be drawn.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center \u00a0: ', Center(1,1), ' ', Center(1,2)\n  else\n    write(*,*) 'Two distinct circles found.'\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center1\u00a0: ', Center(1,1), ' ', Center(1,2)\n    write(*,'(A10,F7.4,A1,F7.4)') 'Center2\u00a0: ', Center(2,1), ' ', Center(2,2)\n  end if\nelseif(Res.lt.0) then\n  write(*,*) 'Incorrect value for r.'\nend if\nwrite(*,*)\nend subroutine print_centers\n\nsubroutine test_inputs(P1,P2,R,Res)\nimplicit none\ndouble precision :: P1(2), P2(2), R, dist\ninteger :: Res\nif(R.lt.0.0d0) then\n  Res = -1\n  return\nelseif(R.eq.0.0d0 .and. P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 1\n  return\nelseif(R.eq.0.0d0) then\n  Res = 2\n  return\nelseif(P1(1).eq.P2(1) .and. P1(2).eq.P2(2)) then\n  Res = 3\n  return\nelse\n  dist = sqrt( (P1(1)-P2(1))**2 + (P1(2)-P2(2))**2 )\n  if(dist.gt.2.0d0*R) then\n    Res = 4\n    return\n  else\n    Res = 0\n    return\n  end if\nend if\nend subroutine test_inputs\n\nsubroutine find_center(P1,P2,R,Center)\nimplicit none\ndouble precision :: P1(2), P2(2), MP(2), Center(2,2), R, dm, dd\nMP = (P1 + P2)/2.0d0\ndm = sqrt((P1(1) - P2(1))**2 + (P1(2) - P2(2))**2)\ndd = sqrt(R**2 - (dm/2.0d0)**2)\nCenter(1,1) = MP(1) - dd*(P2(2) - P1(2))/dm\nCenter(1,2) = MP(2) + dd*(P2(1) - P1(1))/dm\n\nCenter(2,1) = MP(1) + dd*(P2(2) - P1(2))/dm\nCenter(2,2) = MP(2) - dd*(P2(1) - P1(1))/dm\nend subroutine find_center\n\n\nOutput:\n\n\nPoint1 \u00a0:  0.1234  0.9876\nPoint2 \u00a0:  0.8765  0.2345\nRadius \u00a0:  2.0000\n Two distinct circles found.\nCenter1\u00a0:  1.8631  1.9742\nCenter2\u00a0: -0.8632 -0.7521\n\n\nPoint1 \u00a0:  0.0000  2.0000\nPoint2 \u00a0:  0.0000  0.0000\nRadius \u00a0:  1.0000\n Points lie on the diameter. A single circle can be drawn.\nCenter \u00a0:  0.0000  1.0000\n\n\nPoint1 \u00a0:  0.1234  0.9876\nPoint2 \u00a0:  0.1234  0.9876\nRadius \u00a0:  2.0000\n Infinite circles because P1=P2 for non-zero radius.\n\n\nPoint1 \u00a0:  0.1234  0.9876\nPoint2 \u00a0:  0.8765  0.2345\nRadius \u00a0:  0.5000\n No circles with given r can be drawn because points are far apart.\n\n\nPoint1 \u00a0:  0.1234  0.9876\nPoint2 \u00a0:  0.1234  0.9876\nRadius \u00a0:  0.0000\n Same point because P1=P2 and r=0.\n\nUsing complex numbers[edit]\n\n      MODULE GEOMETRY\t!Limited scope.\n       CHARACTER*(*) SQUAWK(-3:2)\t!Holds a schedule of complaints.\n       PARAMETER (SQUAWK = (/\t\t!According to what might go wrong.\n     3  \"No circles: points are more than 2R apart.\",\n     2  \"Innumerable circles: co-incident points, R > 0.\",\n     1  \"One 'circle', centred on the co-incident points. R is zero!\",\n     o  \"No circles! R is negative!\",\n     1  \"One circle: points are 2R apart.\",\n     2  \"Two circles.\"/))\t\t!This last is the hoped-for state.\n      CONTAINS\t!Now for the action.\n       SUBROUTINE BUBBLE(P,R,N)\t!Finds circles of radius R passing through two points.\n        COMPLEX P(2)\t!The two points. Results returned here.\n        REAL R\t\t!The specified radius.\n        INTEGER N\t!Indicates how many centres are valid.\n        COMPLEX MID,DP\t!Geometrical assistants.\n         DP = (P(2) - P(1))/2\t!Or, the other way around.\n         D = ABS(DP)\t\t!Half the separation is useful.\n         IF (R.LT.0) THEN\t!Is the specified radius silly?\n           N =  0\t\t\t!Yes. No circles, then.\n         ELSE IF (D.EQ.0) THEN\t!Any distance between the points?\n           IF (R.EQ.0) THEN\t\t!No. Zero radius?\n             N = -1\t\t\t\t!Yes. So a degenerate \"circle\" of zero radius.\n            ELSE\t\t\t!A negative radius being tested for above,\n             N = -2\t\t\t\t!A swirl of circles around the midpoint.\n           END IF\t\t!So much for co-incident points.\n         ELSE IF (D.GT.R) THEN\t!Points too far apart?\n           N = -3\t\t\t!A circle of radius R can't reach them.\n         ELSE IF (D.EQ.R) THEN\t!Maximum separation for R?\n           N = 1\t\t\t!Yes. The two circles lie atop each other.\n           P(1) = (P(1) + P(2))/2\t!Both centres are on the midpoint, but N = 1.\n         ELSE\t\t\t!Finally, the ordinary case.\n           N = 2\t\t\t!Two circles.\n           MID = (P(1) + P(2))/2\t!Midway between the two points.\n           D = SQRT((R/D)**2 - 1)\t!Rescale vector DP.\n           P = MID + DP*CMPLX(0,(/+D,-D/))\t!Array (0,+D), (0,-D)\n         END IF\t\t\t\t!P(1) = DP*CMPLX(0,+D) and P(2) = DP*CMPLX(0,-D)\n       END SUBROUTINE BUBBLE\t!Careful! P and N are modified.\n      END MODULE GEOMETRY\t!Not much.\n\n      PROGRAM POKE\t!A tester.\n      USE GEOMETRY\t!Useful to I. Newton.\n      COMPLEX P(2)\t\t!A pair of points.\n      REAL PP(4)\t\t!Also a pair.\n      EQUIVALENCE (P,PP)\t!Since free-format input likes (x,y), not x,y\n      REAL R\t\t\t!This is not complex.\n      INTEGER MSG,IN\t\t!I/O unit numbers.\n      MSG = 6\t\t\t!Standard output.\n      OPEN (MSG, RECL = 120)\t!For \"formatted\" files, this length is in characters.\n      IN = 10\t\t\t!For the disc file holding the test data.\n      WRITE (MSG,1)\t\t!Announce.\n    1 FORMAT (\"Given two points and a radius, find the centres \"\n     1 \"of circles of that radius passing through those points.\")\n\n      OPEN (IN,FILE=\"Circle.csv\", STATUS = \"OLD\", ACTION=\"READ\")\t!Have data, will compute.\n   10 READ (IN,*,END = 20) PP,R\t\t!Get two points and a radius.\n      WRITE (MSG,*)\t\t\t!Set off.\n      WRITE (MSG,*) P,R\t\t\t!Show the input.\n      CALL BUBBLE(P,R,N)\t\t!Calculate.\n      WRITE (MSG,*) P(1:N),SQUAWK(N)\t!Show results.\n      GO TO 10\t\t\t\t!Try it again.\n\n   20 CLOSE(IN)\t\t!Finihed with input.\n      END\t!Finished.\n\n\n(0.1234, 0.9876)    (0.8765, 0.2345)    2.0\n(0.0000, 2.0000)    (0.0000, 0.0000)    1.0\n(0.1234, 0.9876)    (0.1234, 0.9876)    2.0\n(0.1234, 0.9876)    (0.8765, 0.2345)    0.5\n(0.1234, 0.9876)    (0.1234, 0.9876)    0.0\n\n\nGiven two points and a radius, find the centres of circles of that radius passing through those points.\n\n (0.1234000,0.9876000) (0.8765000,0.2345000)   2.000000\n (1.863112,1.974212) (-0.8632119,-0.7521119) Two circles.\n\n (0.0000000E+00,2.000000) (0.0000000E+00,0.0000000E+00)   1.000000\n (0.0000000E+00,1.000000) One circle: points are 2R apart.\n\n (0.1234000,0.9876000) (0.1234000,0.9876000)   2.000000\n Innumerable circles: co-incident points, R > 0.\n\n (0.1234000,0.9876000) (0.8765000,0.2345000)  0.5000000\n No circles: points are more than 2R apart.\n\n (0.1234000,0.9876000) (0.1234000,0.9876000)  0.0000000E+00\n One 'circle', centred on the co-incident points. R is zero!\n\n", "explain": "Fortran 66 made standard the availability of complex number arithmetic. This version however takes advantage of facilities offered in F90 so as to perform some array-based arithmetic, though the opportunities in this small routine are thin: two statements become one (look for CMPLX). More seriously, the MODULE facility allows the definition of an array SQUAWK which contains an explanatory text associated with each return code. The routine has a troublesome variety of possible odd conditions to report. An older approach would be to have a return message CHARACTER variable to present the remark, at the cost of filling up that variable with text every time. By returning an integer code, less effort is required, but there is no explication of the return codes. One could still have an array of messages (and prior to F90, array index counting started at one only, so no starting with -3 for errorish  codes) but making that array available would require some sort of COMMON storage. The MODULE facility eases this problem.\nResults: little attempt has been made to present a fancy layout, \"free-format\" output does well enough. Notably, complex numbers are presented in brackets with a comma as (x,y); a FORMAT statement version would have to supply those decorations. Free-format input also expects such bracketing when reading complex numbers. The supplied data format however does not include the brackets and so is improper. Suitable data would be\nThe free-format input style allows spaces, a comma (with or without spaces), and even a tab as delimiters between data, but does not allow implicit delimiters so a sequence such as 2017-12-29 (a standard date format) would be rejected. Because the style of the supplied data does not include the brackets, when complex numbers are read from such an input stream, they are taken to be real numbers only so that each real number is deemed a complex number of the form (x,0); in this case the second number would be taken as being the real part of the second complex number. A mess results.\nBy using the EQUIVALENCE statement, array PP can be read via the free-format protocol, and so the first four numbers will be placed in array PP, which just happens to be the same storage area as the array P of complex numbers. This of course means that should proper bracketed complex numbers be presented as input, a different mess results.\nOutput:\n"}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nvar (\n    Two  = \"Two circles.\"\n    R0   = \"R==0.0 does not describe circles.\"\n    Co   = \"Coincident points describe an infinite number of circles.\"\n    CoR0 = \"Coincident points with r==0.0 describe a degenerate circle.\"\n    Diam = \"Points form a diameter and describe only a single circle.\"\n    Far  = \"Points too far apart to form circles.\"\n)\n\ntype point struct{ x, y float64 }\n\nfunc circles(p1, p2 point, r float64) (c1, c2 point, Case string) {\n    if p1 == p2 {\n        if r == 0 {\n            return p1, p1, CoR0\n        }\n        Case = Co\n        return\n    }\n    if r == 0 {\n        return p1, p2, R0\n    }\n    dx := p2.x - p1.x\n    dy := p2.y - p1.y\n    q := math.Hypot(dx, dy)\n    if q > 2*r {\n        Case = Far\n        return\n    }\n    m := point{(p1.x + p2.x) / 2, (p1.y + p2.y) / 2}\n    if q == 2*r {\n        return m, m, Diam\n    }\n    d := math.Sqrt(r*r - q*q/4)\n    ox := d * dx / q\n    oy := d * dy / q\n    return point{m.x - oy, m.y + ox}, point{m.x + oy, m.y - ox}, Two\n}\n\nvar td = []struct {\n    p1, p2 point\n    r      float64\n}{\n    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 2.0},\n    {point{0.0000, 2.0000}, point{0.0000, 0.0000}, 1.0},\n    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 2.0},\n    {point{0.1234, 0.9876}, point{0.8765, 0.2345}, 0.5},\n    {point{0.1234, 0.9876}, point{0.1234, 0.9876}, 0.0},\n}\n\nfunc main() {\n    for _, tc := range td {\n        fmt.Println(\"p1: \", tc.p1)\n        fmt.Println(\"p2: \", tc.p2)\n        fmt.Println(\"r: \", tc.r)\n        c1, c2, Case := circles(tc.p1, tc.p2, tc.r)\n        fmt.Println(\"  \", Case)\n        switch Case {\n        case CoR0, Diam:\n            fmt.Println(\"   Center: \", c1)\n        case Two:\n            fmt.Println(\"   Center 1: \", c1)\n            fmt.Println(\"   Center 2: \", c2)\n        }\n        fmt.Println()\n    }\n}\n\n\nOutput:\np1:  {0.1234 0.9876}\np2:  {0.8765 0.2345}\nr:  2\n   Two circles.\n   Center 1:  {1.8631118016581891 1.974211801658189}\n   Center 2:  {-0.8632118016581893 -0.752111801658189}\n\np1:  {0 2}\np2:  {0 0}\nr:  1\n   Points form a diameter and describe only a single circle.\n   Center:  {0 1}\n\np1:  {0.1234 0.9876}\np2:  {0.1234 0.9876}\nr:  2\n   Coincident points describe an infinite number of circles.\n\np1:  {0.1234 0.9876}\np2:  {0.8765 0.2345}\nr:  0.5\n   Points too far apart to form circles.\n\np1:  {0.1234 0.9876}\np2:  {0.1234 0.9876}\nr:  0\n   Coincident points with r==0.0 describe a degenerate circle.\n   Center:  {0.1234 0.9876}\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  System.Types\nLibrary:  System.Math\nTranslation of: C\nprogram Circles_of_given_radius_through_two_points;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  System.Types,\n  System.Math;\n\nconst\n  Cases: array[0..9] of TPointF = ((\n    x: 0.1234;\n    y: 0.9876\n  ), (\n    x: 0.8765;\n    y: 0.2345\n  ), (\n    x: 0.0000;\n    y: 2.0000\n  ), (\n    x: 0.0000;\n    y: 0.0000\n  ), (\n    x: 0.1234;\n    y: 0.9876\n  ), (\n    x: 0.1234;\n    y: 0.9876\n  ), (\n    x: 0.1234;\n    y: 0.9876\n  ), (\n    x: 0.8765;\n    y: 0.2345\n  ), (\n    x: 0.1234;\n    y: 0.9876\n  ), (\n    x: 0.1234;\n    y: 0.9876\n  ));\n  radii: array of double = [2.0, 1.0, 2.0, 0.5, 0.0];\n\nprocedure FindCircles(p1, p2: TPointF; radius: double);\nvar\n  separation, mirrorDistance: double;\nbegin\n  separation := p1.Distance(p2);\n  if separation = 0.0 then\n  begin\n    if radius = 0 then\n      write(format(#10'No circles can be drawn through (%.4f,%.4f)', [p1.x, p1.y]))\n    else\n      write(format(#10'Infinitely many circles can be drawn through (%.4f,%.4f)',\n        [p1.x, p1.y]));\n    exit;\n  end;\n\n  if separation = 2 * radius then\n  begin\n    write(format(#10'Given points are opposite ends of a diameter of the circle with center (%.4f,%.4f) and radius\u00a0%.4f',\n      [(p1.x + p2.x) / 2, (p1.y + p2.y) / 2, radius]));\n    exit;\n  end;\n\n  if separation > 2 * radius then\n  begin\n    write(format(#10'Given points are farther away from each other than a diameter of a circle with radius\u00a0%.4f',\n      [radius]));\n    exit;\n  end;\n\n  mirrorDistance := sqrt(Power(radius, 2) - Power(separation / 2, 2));\n  write(#10'Two circles are possible.');\n  write(format(#10'Circle C1 with center (%.4f,%.4f), radius\u00a0%.4f and Circle C2 with center (%.4f,%.4f), radius\u00a0%.4f',\n    [(p1.x + p2.x) / 2 + mirrorDistance * (p1.y - p2.y) / separation, (p1.y + p2.y)\n    / 2 + mirrorDistance * (p2.x - p1.x) / separation, radius, (p1.x + p2.x) / 2\n    - mirrorDistance * (p1.y - p2.y) / separation, (p1.y + p2.y) / 2 -\n    mirrorDistance * (p2.x - p1.x) / separation, radius]));\n\nend;\n\nbegin\n  for var i := 0 to 4 do\n  begin\n    write(#10'Case ', i + 1,')');\n    findCircles(cases[2 * i], cases[2 * i + 1], radii[i]);\n  end;\n  readln;\nend.\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Ruby", "code": "\nTranslation of: Python\nPt     = Struct.new(:x, :y)\nCircle = Struct.new(:x, :y, :r)\n\ndef circles_from(pt1, pt2, r)\n  raise ArgumentError, \"Infinite number of circles, points coincide.\" if pt1 == pt2 && r > 0\n  # handle single point and r == 0\n  return [Circle.new(pt1.x, pt1.y, r)] if pt1 == pt2 && r == 0\n  dx, dy = pt2.x - pt1.x, pt2.y - pt1.y\n  # distance between points\n  q = Math.hypot(dx, dy)\n  # Also catches pt1\u00a0!= pt2 && r == 0\n  raise ArgumentError, \"Distance of points > diameter.\" if q > 2.0*r\n  # halfway point\n  x3, y3 = (pt1.x + pt2.x)/2.0, (pt1.y + pt2.y)/2.0\n  d = (r**2 - (q/2)**2)**0.5\n  [Circle.new(x3 - d*dy/q, y3 + d*dx/q, r),\n   Circle.new(x3 + d*dy/q, y3 - d*dx/q, r)].uniq\nend\n\n# Demo:\nar = [[Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 2.0],\n      [Pt.new(0.0000, 2.0000), Pt.new(0.0000, 0.0000), 1.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 2.0],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.8765, 0.2345), 0.5],\n      [Pt.new(0.1234, 0.9876), Pt.new(0.1234, 0.9876), 0.0]]\n\nar.each do |p1, p2, r|\n  print \"Given points:\\n  #{p1.values},\\n  #{p2.values}\\n  and radius #{r}\\n\"\n  begin\n    circles = circles_from(p1, p2, r)\n    puts \"You can construct the following circles:\"\n    circles.each{|c| puts \"  #{c}\"}\n  rescue ArgumentError => e\n    puts e\n  end\n  puts\nend\n\n\nOutput:\nGiven points:\n  [0.1234, 0.9876],\n  [0.8765, 0.2345]\n  and radius 2.0\nYou can construct the following circles:\n  #<struct Circle x=1.8631118016581891, y=1.974211801658189, r=2.0>\n  #<struct Circle x=-0.8632118016581893, y=-0.752111801658189, r=2.0>\n\nGiven points:\n  [0.0, 2.0],\n  [0.0, 0.0]\n  and radius 1.0\nYou can construct the following circles:\n  #<struct Circle x=0.0, y=1.0, r=1.0>\n\nGiven points:\n  [0.1234, 0.9876],\n  [0.1234, 0.9876]\n  and radius 2.0\nInfinite number of circles, points coincide.\n\nGiven points:\n  [0.1234, 0.9876],\n  [0.8765, 0.2345]\n  and radius 0.5\nDistance of points > diameter.\n\nGiven points:\n  [0.1234, 0.9876],\n  [0.1234, 0.9876]\n  and radius 0.0\nYou can construct the following circles:\n  #<struct Circle x=0.1234, y=0.9876, r=0.0>\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Rust", "code": "\nTranslation of: C\nuse std::fmt;\n\n#[derive(Clone,Copy)]\nstruct Point {\n    x: f64,\n    y: f64\n}\n\nfn distance (p1: Point, p2: Point) -> f64 {\n    ((p1.x - p2.x).powi(2) + (p1.y - p2.y).powi(2)).sqrt()\n}\n\nimpl fmt::Display for Point {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        write!(f, \"({:.4}, {:.4})\", self.x, self.y)\n    }\n}\n\nfn describe_circle(p1: Point, p2: Point, r: f64) {\n    let sep = distance(p1, p2);\n\n    if sep == 0. {\n        if r == 0. {\n            println!(\"No circles can be drawn through {}\", p1);\n        } else {\n            println!(\"Infinitely many circles can be drawn through {}\", p1);\n        }\n    } else if sep == 2.0 * r {\n        println!(\"Given points are opposite ends of a diameter of the circle with center ({:.4},{:.4}) and r {:.4}\",\n                (p1.x+p2.x) / 2.0, (p1.y+p2.y) / 2.0, r);\n    } else if sep > 2.0 * r {\n        println!(\"Given points are farther away from each other than a diameter of a circle with r {:.4}\", r);\n    } else {\n        let mirror_dist = (r.powi(2) - (sep / 2.0).powi(2)).sqrt();\n\n        println!(\"Two circles are possible.\");\n        println!(\"Circle C1 with center ({:.4}, {:.4}), r {:.4} and Circle C2 with center ({:.4}, {:.4}), r {:.4}\",\n                ((p1.x + p2.x) / 2.0) + mirror_dist * (p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 + mirror_dist*(p2.x-p1.x)/sep,\n                r,\n                (p1.x+p2.x) / 2.0 - mirror_dist*(p1.y-p2.y)/sep, (p1.y+p2.y) / 2.0 - mirror_dist*(p2.x-p1.x)/sep, r);\n    }\n}\n\nfn main() {\n    let points: Vec<(Point, Point)> = vec![\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.0000, y: 2.0000 }, Point { x: 0.0000, y: 0.0000 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.8765, y: 0.2345 }),\n        (Point { x: 0.1234, y: 0.9876 }, Point { x: 0.1234, y: 0.9876 })\n    ];\n    let radii: Vec<f64> = vec![2.0, 1.0, 2.0, 0.5, 0.0];\n\n    for (p, r) in points.into_iter().zip(radii.into_iter()) {\n        println!(\"\\nPoints: ({}, {}), Radius: {:.4}\", p.0, p.1, r);\n        describe_circle(p.0, p.1, r);\n    }\n}\n\n\nOutput:\nPoints: ((0.1234, 0.9876), (0.8765, 0.2345)), Radius: 2.0000\nTwo circles are possible.\nCircle C1 with center (1.8631, 1.9742), r 2.0000 and Circle C2 with center (-0.8632, -0.7521), r 2.0000\n\nPoints: ((0.0000, 2.0000), (0.0000, 0.0000)), Radius: 1.0000\nGiven points are opposite ends of a diameter of the circle with center (0.0000,1.0000) and r 1.0000\n\nPoints: ((0.1234, 0.9876), (0.1234, 0.9876)), Radius: 2.0000\nInfinitely many circles can be drawn through (0.1234, 0.9876)\n\nPoints: ((0.1234, 0.9876), (0.8765, 0.2345)), Radius: 0.5000\nGiven points are farther away from each other than a diameter of a circle with r 0.5000\n\nPoints: ((0.1234, 0.9876), (0.1234, 0.9876)), Radius: 0.0000\nNo circles can be drawn through (0.1234, 0.9876)\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Swift", "code": "\nTranslation of: F#\nimport Foundation\n\nstruct Point: Equatable {\n    var x: Double\n    var y: Double\n}\n\nstruct Circle {\n  var center: Point\n  var radius: Double\n\n  static func circleBetween(\n    _ p1: Point,\n    _ p2: Point,\n    withRadius radius: Double\n  ) -> (Circle, Circle?)? {\n    func applyPoint(_ p1: Point, _ p2: Point, op: (Double, Double) -> Double) -> Point {\n      return Point(x: op(p1.x, p2.x), y: op(p1.y, p2.y))\n    }\n\n    func mul2(_ p: Point, mul: Double) -> Point {\n      return Point(x: p.x * mul, y: p.y * mul)\n    }\n\n    func div2(_ p: Point, div: Double) -> Point {\n      return Point(x: p.x / div, y: p.y / div)\n    }\n\n    func norm(_ p: Point) -> Point {\n      return div2(p, div: (p.x * p.x + p.y * p.y).squareRoot())\n    }\n\n    guard radius != 0, p1 != p2 else {\n      return nil\n    }\n\n    let diameter = 2 * radius\n    let pq = applyPoint(p1, p2, op: -)\n    let magPQ = (pq.x * pq.x + pq.y * pq.y).squareRoot()\n\n    guard diameter >= magPQ else {\n      return nil\n    }\n\n    let midpoint = div2(applyPoint(p1, p2, op: +), div: 2)\n    let halfPQ = magPQ / 2\n    let magMidC = abs(radius * radius - halfPQ * halfPQ).squareRoot()\n    let midC = mul2(norm(Point(x: -pq.y, y: pq.x)), mul: magMidC)\n    let center1 = applyPoint(midpoint, midC, op: +)\n    let center2 = applyPoint(midpoint, midC, op: -)\n\n    if center1 == center2 {\n      return (Circle(center: center1, radius: radius), nil)\n    } else {\n      return (Circle(center: center1, radius: radius), Circle(center: center2, radius: radius))\n    }\n  }\n}\n\nlet testCases = [\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 2.0),\n  (Point(x: 0.0000, y: 2.0000), Point(x: 0.0000, y: 0.0000), 1.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 2.0),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.8765, y: 0.2345), 0.5),\n  (Point(x: 0.1234, y: 0.9876), Point(x: 0.1234, y: 0.9876), 0.0)\n]\n\nfor testCase in testCases {\n  switch Circle.circleBetween(testCase.0, testCase.1, withRadius: testCase.2) {\n  case nil:\n    print(\"No ans\")\n  case (let circle1, nil)?:\n    print(\"One ans: \\(circle1)\")\n  case (let circle1, let circle2?)?:\n    print(\"Two ans: \\(circle1) \\(circle2)\")\n  }\n}\n\n\nOutput:\nTwo ans: Circle(center: Point(x: -0.8632118016581896, y: -0.7521118016581892), radius: 2.0) Circle(center: Point(x: 1.8631118016581893, y: 1.974211801658189), radius: 2.0)\nOne ans: Circle(center: Point(x: 0.0, y: 1.0), radius: 1.0)\nNo ans\nNo ans\nNo ans\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Visual_FoxPro", "code": "\n\nLOCAL p1 As point, p2 As point, rr As Double\nCLOSE DATABASES ALL\nSET FIXED ON\nSET DECIMALS TO 4\nCLEAR\nCREATE CURSOR circles (xc1 B(4), yc1 B(4), xc2 B(4), yc2 B(4), rad B(4))\nINSERT INTO circles VALUES (0.1234, 0.9876, 0.8765, 0.2345, 2.0)\nINSERT INTO circles VALUES (0.0000, 2.0000, 0.0000, 0.0000, 1.0)\nINSERT INTO circles VALUES (0.1234, 0.9876, 0.1234, 0.9876, 2.0)\nINSERT INTO circles VALUES (0.1234, 0.9876, 0.8765, 0.2345, 0.5)\nINSERT INTO circles VALUES (0.1234, 0.9876, 0.1234, 0.9876, 0.0)\nGO TOP\n\np1 = NEWOBJECT(\"point\")\np2 = NEWOBJECT(\"point\")\nSCAN\n    p1.SetPoints(xc1, yc1)\n    p2.SetPoints(xc2, yc2)\n    rr = rad\n    GetCircles(p1, p2, rr)\n   \u00a0?\nENDSCAN \t\n\nSET DECIMALS TO \nSET FIXED OFF\n\nPROCEDURE GetCircles(op1 As point, op2 As point, r As Double)\nLOCAL ctr As point, half As point, lenhalf As Double, dist As Double, rot As point, c As String\nctr = NEWOBJECT(\"point\")\nhalf = NEWOBJECT(\"point\")\nctr.SetPoints((op1.xc + op2.xc)/2, (op1.yc + op2.yc)/2)\nhalf.SetPoints(op1.xc - ctr.xc, op1.yc - ctr.yc)\nlenhalf = half.nLength\nPrintPoints(op1, op2, r)\nIF r < lenhalf\n   \u00a0? \"Cannot solve for these parameters.\"\n    RETURN\nENDIF\nIF lenhalf = 0\n   \u00a0? \"Points are coincident.\"\n    RETURN\nENDIF\ndist = SQRT(r^2 - lenhalf^2)/lenhalf\nrot = NEWOBJECT(\"point\")\nrot.SetPoints(-dist*(op1.yc - ctr.yc) + ctr.xc, dist*(op1.xc - ctr.xc) + ctr.yc)\nTEXT TO c TEXTMERGE NOSHOW PRETEXT 3\n    Circle 1 (<<rot.xc>>, <<rot.yc>>)\nENDTEXT\n? c\nrot.SetPoints(-(rot.xc - ctr.xc) + ctr.xc, -((rot.yc - ctr.yc)) + ctr.yc)\nTEXT TO c TEXTMERGE NOSHOW PRETEXT 3\n    Circle 2 (<<rot.xc>>, <<rot.yc>>)\nENDTEXT\n? c\nENDPROC\n\nPROCEDURE PrintPoints(op1 As point, op2 As point, r As Double)\nLOCAL lcTxt As String\nTEXT TO lcTxt TEXTMERGE NOSHOW PRETEXT 3\n    Points (<<op1.xc>>,<<op1.yc>>), (<<op2.xc>>,<<op2.yc>>) Radius <<r>>.\nENDTEXT\n? lcTxt\nENDPROC\t\n\nDEFINE CLASS point As Custom\nxc = 0\nyc = 0\nnLength = 0\n\nPROCEDURE Init\nDODEFAULT()\nENDPROC\n\nPROCEDURE SetPoints(tnx As Double, tny As Double)\nTHIS.xc = tnx\nTHIS.yc = tny\nTHIS.nLength = THIS.GetLength()\nENDPROC\n\nFUNCTION GetLength()\nRETURN SQRT(THIS.xc*THIS.xc + THIS.yc*THIS.yc)\nENDFUNC\n\nENDDEFINE\n\n\nOutput:\n\n\nPoints (0.1234,0.9876), (0.8765,0.2345) Radius 2.0000.\nPoints (0.1234,0.9876), (0.8765,0.2345) Radius 2.0000.         \nCircle 1 (-0.8632, -0.7521)\nCircle 1 (-0.8632, -0.7521)  \nCircle 2 (1.8631, 1.9742)\nCircle 2 (1.8631, 1.9742)   \n\nPoints (0.0000,2.0000), (0.0000,0.0000) Radius 1.0000.\nPoints (0.0000,2.0000), (0.0000,0.0000) Radius 1.0000.         \nCircle 1 (0.0000, 1.0000)\nCircle 1 (0.0000, 1.0000)   \nCircle 2 (0.0000, 1.0000)\nCircle 2 (0.0000, 1.0000)   \n\nPoints (0.1234,0.9876), (0.1234,0.9876) Radius 2.0000.\nPoints (0.1234,0.9876), (0.1234,0.9876) Radius 2.0000.         \nPoints are coincident.  \n\nPoints (0.1234,0.9876), (0.8765,0.2345) Radius 0.5000.\nPoints (0.1234,0.9876), (0.8765,0.2345) Radius 0.5000.         \nCannot solve for these parameters.     \n\nPoints (0.1234,0.9876), (0.1234,0.9876) Radius 0.0000.\nPoints (0.1234,0.9876), (0.1234,0.9876) Radius 0.0000.         \nPoints are coincident.  \n\n", "explain": "Translation of BASIC.\n"}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Julia", "code": "\n\nimmutable Point{T<:FloatingPoint}\n    x::T\n    y::T\nend\n\nimmutable Circle{T<:FloatingPoint}\n    c::Point{T}\n    r::T\nend\nCircle{T<:FloatingPoint}(a::Point{T}) = Circle(a, zero(T))\n\nusing AffineTransforms\n\nfunction circlepoints{T<:FloatingPoint}(a::Point{T}, b::Point{T}, r::T)\n    cp = Circle{T}[]\n    r >= 0 || return (cp, \"No Solution, Negative Radius\")\n    if a == b\n        if abs(r) < 2eps(zero(T))\n            return (push!(cp, Circle(a)), \"Point Solution, Zero Radius\")\n        else\n            return (cp, \"Infinite Solutions, Indefinite Center\")\n        end\n    end\n    ca = Complex(a.x, a.y)\n    cb = Complex(b.x, b.y)\n    d = (ca + cb)/2\n    tfd = tformtranslate([real(d), imag(d)])\n    tfr = tformrotate(angle(cb-ca))\n    tfm = tfd*tfr\n    u = abs(cb-ca)/2\n    r-u > -5eps(r) || return(cp, \"No Solution, Radius Too Small\")\n    if r-u < 5eps(r)\n        push!(cp, Circle(apply(Point, tfm*[0.0, 0.0]), r))\n        return return (cp, \"Single Solution, Degenerate Centers\")\n    end\n    v = sqrt(r^2 - u^2)\n    for w in [v, -v]\n        push!(cp, Circle(apply(Point, tfm*[0.0, w]), r))\n    end\n    return (cp, \"Two Solutions\")\nend\n\n\ntp = [Point(0.1234, 0.9876),\n      Point(0.0000, 2.0000),\n      Point(0.1234, 0.9876),\n      Point(0.1234, 0.9876),\n      Point(0.1234, 0.9876)]\n\ntq = [Point(0.8765, 0.2345),\n      Point(0.0000, 0.0000),\n      Point(0.1234, 0.9876),\n      Point(0.8765, 0.2345),\n      Point(0.1234, 0.9876)]\n\ntr = [2.0, 1.0, 2.0, 0.5, 0.0]\n\nprintln(\"Testing circlepoints:\")\nfor i in 1:length(tp)\n    p = tp[i]\n    q = tq[i]\n    r = tr[i]\n    (cp, rstatus) = circlepoints(p, q, r)\n    println(@sprintf(\"(%.4f, %.4f), (%.4f, %.4f), %.4f => %s\",\n                     p.x, p.y, q.x, q.y, r, rstatus))\n    for c in cp\n        println(@sprintf(\"    (%.4f, %.4f), %.4f\",\n                         c.c.x, c.c.y, c.r))\n    end\nend\n\n\nOutput:\nTesting circlepoints:\n(0.1234, 0.9876), (0.8765, 0.2345), 2.0000 => Two Solutions\n    (1.8631, 1.9742), 2.0000\n    (-0.8632, -0.7521), 2.0000\n(0.0000, 2.0000), (0.0000, 0.0000), 1.0000 => Single Solution, Degenerate Centers\n    (0.0000, 1.0000), 1.0000\n(0.1234, 0.9876), (0.1234, 0.9876), 2.0000 => Infinite Solutions, Indefinite Center\n(0.1234, 0.9876), (0.8765, 0.2345), 0.5000 => No Solution, Radius Too Small\n(0.1234, 0.9876), (0.1234, 0.9876), 0.0000 => Point Solution, Zero Radius\n    (0.1234, 0.9876), 0.0000\n\n", "explain": "This solution uses the package AffineTransforms.jl to introduce a coordinate system (u, v) centered on the midpoint between the two points and rotated so that these points are on the u-axis.  In this system, solving for the circles' centers is trivial.  The two points are cast as complex numbers to aid in determining the location of the midpoint and rotation angle.\nTypes and Functions\nMain\n"}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Kotlin", "code": "\n// version 1.1.51\n\ntypealias IAE = IllegalArgumentException\n\nclass Point(val x: Double, val y: Double) {\n    fun distanceFrom(other: Point): Double {\n        val dx = x - other.x\n        val dy = y - other.y\n        return Math.sqrt(dx * dx + dy * dy )\n    }\n\n    override fun equals(other: Any?): Boolean {\n        if (other == null || other !is Point) return false\n        return (x == other.x && y == other.y)\n    }\n\n    override fun toString() = \"(%.4f,\u00a0%.4f)\".format(x, y)\n}\n\nfun findCircles(p1: Point, p2: Point, r: Double): Pair<Point, Point> {\n    if (r < 0.0) throw IAE(\"the radius can't be negative\")\n    if (r == 0.0 && p1 != p2) throw IAE(\"no circles can ever be drawn\")\n    if (r == 0.0) return p1 to p1\n    if (p1 == p2) throw IAE(\"an infinite number of circles can be drawn\")\n    val distance = p1.distanceFrom(p2)\n    val diameter = 2.0 * r\n    if (distance > diameter) throw IAE(\"the points are too far apart to draw a circle\")\n    val center = Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0)\n    if (distance == diameter) return center to center\n    val mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0)\n    val dx =  (p2.x - p1.x) * mirrorDistance / distance\n    val dy =  (p2.y - p1.y) * mirrorDistance / distance\n    return Point(center.x - dy, center.y + dx) to\n           Point(center.x + dy, center.y - dx)\n}\n\nfun main(args: Array<String>) {\n    val p = arrayOf(\n        Point(0.1234, 0.9876),\n        Point(0.8765, 0.2345),\n        Point(0.0000, 2.0000),\n        Point(0.0000, 0.0000)\n    )\n    val points = arrayOf(\n        p[0] to p[1], p[2] to p[3], p[0] to p[0], p[0] to p[1], p[0] to p[0]\n    )\n    val radii = doubleArrayOf(2.0, 1.0, 2.0, 0.5, 0.0)\n    for (i in 0..4) {\n        try {\n            val (p1, p2) = points[i]            \n            val r  = radii[i]\n            println(\"For points $p1 and $p2 with radius $r\")\n            val (c1, c2) = findCircles(p1, p2, r)\n            if (c1 == c2)\n                println(\"there is just one circle with center at $c1\")\n            else\n                println(\"there are two circles with centers at $c1 and $c2\")\n        }\n        catch(ex: IllegalArgumentException) {\n            println(ex.message)\n        }\n        println()\n    }\n}\n\n\nOutput:\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 2.0\nthere are two circles with centers at (1.8631, 1.9742) and (-0.8632, -0.7521)\n\nFor points (0.0000, 2.0000) and (0.0000, 0.0000) with radius 1.0\nthere is just one circle with center at (0.0000, 1.0000)\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 2.0\nan infinite number of circles can be drawn\n\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.5\nthe points are too far apart to draw a circle\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 0.0\nthere is just one circle with center at (0.1234, 0.9876)\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Perl", "code": "\nTranslation of: Python\nuse strict;\n\nsub circles {\n    my ($x1, $y1, $x2, $y2, $r) = @_;\n\n    return \"Radius is zero\" if $r == 0;\n    return \"Coincident points gives infinite number of circles\" if $x1 == $x2 and $y1 == $y2;\n\n    # delta x, delta y between points\n    my ($dx, $dy) = ($x2 - $x1, $y2 - $y1);\n    my $q = sqrt($dx**2 + $dy**2);\n    return \"Separation of points greater than diameter\" if $q > 2*$r;\n\n    # halfway point\n    my ($x3, $y3) = (($x1 + $x2) / 2, ($y1 + $y2) / 2);\n    # distance along the mirror line\n    my $d = sqrt($r**2-($q/2)**2);\n\n    # pair of solutions\n    sprintf '(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f)',\n        $x3 - $d*$dy/$q, $y3 + $d*$dx/$q,\n        $x3 + $d*$dy/$q, $y3 - $d*$dx/$q;\n}\n\nmy @arr = (\n    [0.1234, 0.9876, 0.8765, 0.2345, 2.0],\n    [0.0000, 2.0000, 0.0000, 0.0000, 1.0],\n    [0.1234, 0.9876, 0.1234, 0.9876, 2.0],\n    [0.1234, 0.9876, 0.8765, 0.2345, 0.5],\n    [0.1234, 0.9876, 0.1234, 0.9876, 0.0]\n);\n\nprintf \"(%.4f,\u00a0%.4f) and (%.4f,\u00a0%.4f) with radius\u00a0%.1f: %s\\n\", @$_[0..4], circles @$_ for @arr;\n\n\nOutput:\n(0.1234, 0.9876) and (0.8765, 0.2345) with radius 2.0: (1.8631, 1.9742) and (-0.8632, -0.7521)\n(0.0000, 2.0000) and (0.0000, 0.0000) with radius 1.0: (0.0000, 1.0000) and (0.0000, 1.0000)\n(0.1234, 0.9876) and (0.1234, 0.9876) with radius 2.0: Coincident points gives infinite number of circles\n(0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.5: Separation of points greater than diameter\n(0.1234, 0.9876) and (0.1234, 0.9876) with radius 0.0: Radius is zero\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Lua", "code": "\nTranslation of: C\nfunction distance(p1, p2)\n    local dx = (p1.x-p2.x)\n    local dy = (p1.y-p2.y)\n    return math.sqrt(dx*dx + dy*dy)\nend\n\nfunction findCircles(p1, p2, radius)\n    local seperation = distance(p1, p2)\n    if seperation == 0.0 then\n        if radius == 0.0 then\n            print(\"No circles can be drawn through (\"..p1.x..\", \"..p1.y..\")\")\n        else\n            print(\"Infinitely many circles can be drawn through (\"..p1.x..\", \"..p1.y..\")\")\n        end\n    elseif seperation == 2*radius then\n        local cx = (p1.x+p2.x)/2\n        local cy = (p1.y+p2.y)/2\n        print(\"Given points are opposite ends of a diameter of the circle with center (\"..cx..\", \"..cy..\") and radius \"..radius)\n    elseif seperation > 2*radius then\n        print(\"Given points are further away from each other than a diameter of a circle with radius \"..radius)\n    else\n        local mirrorDistance = math.sqrt(math.pow(radius,2) - math.pow(seperation/2,2))\n        local dx = p2.x - p1.x\n        local dy = p1.y - p2.y\n        local ax = (p1.x + p2.x) / 2\n        local ay = (p1.y + p2.y) / 2\n        local mx = mirrorDistance * dx / seperation\n        local my = mirrorDistance * dy / seperation\n        c1 = {x=ax+my, y=ay+mx}\n        c2 = {x=ax-my, y=ay-mx}\n\n        print(\"Two circles are possible.\")\n        print(\"Circle C1 with center (\"..c1.x..\", \"..c1.y..\"), radius \"..radius)\n        print(\"Circle C2 with center (\"..c2.x..\", \"..c2.y..\"), radius \"..radius)\n    end\n    print()\nend\n\ncases = {\n    {x=0.1234, y=0.9876},   {x=0.8765, y=0.2345},\n    {x=0.0000, y=2.0000},   {x=0.0000, y=0.0000},\n    {x=0.1234, y=0.9876},   {x=0.1234, y=0.9876},\n    {x=0.1234, y=0.9876},   {x=0.8765, y=0.2345},\n    {x=0.1234, y=0.9876},   {x=0.1234, y=0.9876}\n}\nradii = { 2.0, 1.0, 2.0, 0.5, 0.0 }\nfor i=1, #radii do\n    print(\"Case \"..i)\n    findCircles(cases[i*2-1], cases[i*2], radii[i])\nend\n\n\nOutput:\nCase 1\nTwo circles are possible.\nCircle C1 with center (1.8631118016582, 1.9742118016582), radius 2\nCircle C2 with center (-0.86321180165819, -0.75211180165819), radius 2\n\nCase 2\nGiven points are opposite ends of a diameter of the circle with center (0, 1) and radius 1\n\nCase 3\nInfinitely many circles can be drawn through (0.1234, 0.9876)\n\nCase 4\nGiven points are further away from each other than a diameter of a circle with radius 0.5\n\nCase 5\nNo circles can be drawn through (0.1234, 0.9876)\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Scala", "code": "\nimport org.scalatest.FunSuite\nimport math._\n\ncase class V2(x: Double, y: Double) {\n  val distance = hypot(x, y)\n  def /(other: V2) = V2((x+other.x) / 2.0, (y+other.y) / 2.0)\n  def -(other: V2) = V2(x-other.x,y-other.y)\n  override def equals(other: Any) = other match {\n    case p: V2 => abs(x-p.x) <  0.0001 && abs(y-p.y) <  0.0001\n    case _ => false\n  }\n  override def toString = f\"($x%.4f, $y%.4f)\"\n}\n\ncase class Circle(center: V2, radius: Double)\n\nclass PointTest extends FunSuite {\n  println(\"       p1               p2         r    result\")\n  Seq(\n    (V2(0.1234, 0.9876), V2(0.8765, 0.2345), 2.0, Seq(Circle(V2(1.8631, 1.9742), 2.0), Circle(V2(-0.8632, -0.7521), 2.0))),\n    (V2(0.0000, 2.0000), V2(0.0000, 0.0000), 1.0, Seq(Circle(V2(0.0, 1.0), 1.0))),\n    (V2(0.1234, 0.9876), V2(0.1234, 0.9876), 2.0, \"coincident points yields infinite circles\"),\n    (V2(0.1234, 0.9876), V2(0.8765, 0.2345), 0.5, \"radius is less then the distance between points\"),\n    (V2(0.1234, 0.9876), V2(0.1234, 0.9876), 0.0, \"radius of zero yields no circles\")\n  ) foreach { v =>\n    print(s\"${v._1} ${v._2}  ${v._3}: \")\n    circles(v._1, v._2, v._3) match {\n      case Right(list) => println(list mkString \",\")\n        assert(list === v._4)\n      case Left(error) => println(error)\n        assert(error === v._4)\n    }\n  }\n\n  def circles(p1: V2, p2: V2, radius: Double) = if (radius == 0.0) {\n      Left(\"radius of zero yields no circles\")\n    } else if (p1 == p2) {\n      Left(\"coincident points yields infinite circles\")\n    } else if (radius * 2 < (p1-p2).distance) {\n      Left(\"radius is less then the distance between points\")\n    } else {\n      Right(circlesThruPoints(p1, p2, radius))\n    } ensuring { result =>\n      result.isLeft || result.right.get.nonEmpty\n    }\n\n  def circlesThruPoints(p1: V2, p2: V2, radius: Double): Seq[Circle] = {\n    val diff = p2 - p1\n    val d = pow(pow(radius, 2) - pow(diff.distance / 2, 2), 0.5)\n    val mid = p1 / p2\n    Seq(\n      Circle(V2(mid.x - d * diff.y / diff.distance, mid.y + d * diff.x / diff.distance), abs(radius)),\n      Circle(V2(mid.x + d * diff.y / diff.distance, mid.y - d * diff.x / diff.distance), abs(radius))).distinct\n  }\n}\n\n\nOutput:\n       p1               p2         r    result\n(0.1234, 0.9876) (0.8765, 0.2345)  2.0: Circle((1.8631, 1.9742),2.0),Circle((-0.8632, -0.7521),2.0)\n(0.0000, 2.0000) (0.0000, 0.0000)  1.0: Circle((0.0000, 1.0000),1.0)\n(0.1234, 0.9876) (0.1234, 0.9876)  2.0: coincident points yields infinite circles\n(0.1234, 0.9876) (0.8765, 0.2345)  0.5: radius is less then the distance between points\n(0.1234, 0.9876) (0.1234, 0.9876)  0.0: radius of zero yields no circlesEmpty test suite.\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "D", "code": "\nTranslation of: Python\nimport std.stdio, std.typecons, std.math;\n\nclass ValueException : Exception {\n    this(string msg_) pure { super(msg_); }\n}\n\nstruct V2 { double x, y; }\nstruct Circle { double x, y, r; }\n\n/**Following explanation at:\nhttp://mathforum.org/library/drmath/view/53027.html\n*/\nTuple!(Circle, Circle)\ncirclesFromTwoPointsAndRadius(in V2 p1, in V2 p2, in double r)\npure in {\n    assert(r >= 0, \"radius can't be negative\");\n} body {\n    enum nBits = 40;\n\n    if (r.abs < (1.0 / (2.0 ^^ nBits)))\n        throw new ValueException(\"radius of zero\");\n\n    if (feqrel(p1.x, p2.x) >= nBits &&\n        feqrel(p1.y, p2.y) >= nBits)\n        throw new ValueException(\"coincident points give\" ~\n                                 \" infinite number of Circles\");\n\n    // Delta between points.\n    immutable d = V2(p2.x - p1.x, p2.y - p1.y);\n\n    // Distance between points.\n    immutable q = sqrt(d.x ^^ 2 + d.y ^^ 2);\n    if (q > 2.0 * r)\n        throw new ValueException(\"separation of points > diameter\");\n\n    // Halfway point.\n    immutable h = V2((p1.x + p2.x) / 2, (p1.y + p2.y) / 2);\n\n    // Distance along the mirror line.\n    immutable dm = sqrt(r ^^ 2 - (q / 2) ^^ 2);\n\n    return typeof(return)(\n        Circle(h.x - dm * d.y / q, h.y + dm * d.x / q, r.abs),\n        Circle(h.x + dm * d.y / q, h.y - dm * d.x / q, r.abs));\n}\n\nvoid main() {\n    foreach (immutable t; [\n                 tuple(V2(0.1234, 0.9876), V2(0.8765, 0.2345), 2.0),\n                 tuple(V2(0.0000, 2.0000), V2(0.0000, 0.0000), 1.0),\n                 tuple(V2(0.1234, 0.9876), V2(0.1234, 0.9876), 2.0),\n                 tuple(V2(0.1234, 0.9876), V2(0.8765, 0.2345), 0.5),\n                 tuple(V2(0.1234, 0.9876), V2(0.1234, 0.9876), 0.0)]) {\n        writefln(\"Through points:\\n  %s   %s  and radius %f\\n\" ~\n                 \"You can construct the following circles:\", t[]);\n        try {\n            writefln(\"  %s\\n  %s\\n\",\n                     circlesFromTwoPointsAndRadius(t[])[]);\n        } catch (ValueException v)\n            writefln(\"  ERROR: %s\\n\", v.msg);\n    }\n}\n\n\nOutput:\nThrough points:\n  immutable(V2)(0.1234, 0.9876)   immutable(V2)(0.8765, 0.2345)  and radius 2.000000\nYou can construct the following circles:\n  Circle(1.86311, 1.97421, 2)\n  Circle(-0.863212, -0.752112, 2)\n\nThrough points:\n  immutable(V2)(0, 2)   immutable(V2)(0, 0)  and radius 1.000000\nYou can construct the following circles:\n  Circle(0, 1, 1)\n  Circle(0, 1, 1)\n\nThrough points:\n  immutable(V2)(0.1234, 0.9876)   immutable(V2)(0.1234, 0.9876)  and radius 2.000000\nYou can construct the following circles:\n  ERROR: coincident points give infinite number of Circles\n\nThrough points:\n  immutable(V2)(0.1234, 0.9876)   immutable(V2)(0.8765, 0.2345)  and radius 0.500000\nYou can construct the following circles:\n  ERROR: separation of points > diameter\n\nThrough points:\n  immutable(V2)(0.1234, 0.9876)   immutable(V2)(0.1234, 0.9876)  and radius 0.000000\nYou can construct the following circles:\n  ERROR: radius of zero\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Haskell", "code": "\nadd (a, b) (x, y) = (a + x, b + y)\nsub (a, b) (x, y) = (a - x, b - y)\nmagSqr (a, b)     = (a ^^ 2) + (b ^^ 2)\nmag a             = sqrt $ magSqr a\nmul (a, b) c      = (a * c, b * c)\ndiv2 (a, b) c     = (a / c, b / c)\nperp (a, b)       = (negate b, a)\nnorm a            = a `div2` mag a\n\ncirclePoints :: (Ord a, Floating a) =>\n                (a, a) -> (a, a) -> a -> Maybe ((a, a), (a, a))\ncirclePoints p q radius\n  | radius == 0      = Nothing\n  | p == q           = Nothing\n  | diameter < magPQ = Nothing\n  | otherwise        = Just (center1, center2)\n  where\n    diameter = radius * 2\n    pq       = p `sub` q\n    magPQ    = mag pq\n    midpoint = (p `add` q) `div2` 2\n    halfPQ   = magPQ / 2\n    magMidC  = sqrt . abs $ (radius ^^ 2) - (halfPQ ^^ 2)\n    midC     = (norm $ perp pq) `mul` magMidC\n    center1  = midpoint `add` midC\n    center2  = midpoint `sub` midC\n\nuncurry3 f (a, b, c) = f a b c\n\nmain :: IO ()\nmain = mapM_ (print . uncurry3 circlePoints)\n  [((0.1234, 0.9876), (0.8765, 0.2345), 2),\n   ((0     , 2     ), (0     , 0     ), 1),\n   ((0.1234, 0.9876), (0.1234, 0.9876), 2),\n   ((0.1234, 0.9876), (0.8765, 0.2345), 0.5),\n   ((0.1234, 0.9876), (0.1234, 0.1234), 0)]\n\n\nOutput:\nJust ((-0.8632118016581896,-0.7521118016581892),(1.8631118016581893,1.974211801658189))\nJust ((0.0,1.0),(0.0,1.0))\nNothing\nNothing\nNothing\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Scheme", "code": "\n(import (scheme base)\n        (scheme inexact)\n        (scheme write))\n\n;; c1 and c2 are pairs (x y), r a positive radius\n(define (find-circles c1 c2 r)\n  (define x-coord car) ; for easier to read coordinate extraction from list\n  (define y-coord cadr)\n  (define (approx= a b) (< (- a b) 0.000001)) ; equal within tolerance\n  (define (avg a b) (/ (+ a b) 2))\n  (define (distance pt1 pt2)\n    (sqrt (+ (square (- (x-coord pt1) (x-coord pt2)))\n             (square (- (y-coord pt1) (y-coord pt2))))))\n  (define (equal-points? pt1 pt2)\n    (and (approx= (x-coord pt1) (x-coord pt2))\n         (approx= (y-coord pt1) (y-coord pt2))))\n  (define (delete-duplicate pts) ; assume no more than two points in list\n    (if (and (= 2 (length pts))\n             (equal-points? (car pts) (cadr pts)))\n      (list (car pts)) ; keep the first only\n      pts))\n  ;\n  (let ((d (distance c1 c2)))\n    (cond ((equal-points? c1 c2) ; coincident points\n           (if (> r 0)\n             'infinite   ; r > 0\n             (list c1))) ; else r = 0\n          ((< (* 2 r) d) \n           '()) ; circle cannot reach both points, as too far apart\n          ((approx= r 0.0) ; r = 0, no circles, as points differ\n           '()) \n          (else ; find up to two circles meeting c1 and c2\n            (let* ((mid-pt (list (avg (x-coord c1) (x-coord c2))\n                                 (avg (y-coord c1) (y-coord c2))))\n                   (offset (sqrt (- (square r) \n                                    (square (* 0.5 d)))))\n                   (delta-cx (/ (- (x-coord c1) (x-coord c2)) d))\n                   (delta-cy (/ (- (y-coord c1) (y-coord c2)) d)))\n              (delete-duplicate\n                (list (list (- (x-coord mid-pt) (* offset delta-cx))\n                            (+ (y-coord mid-pt) (* offset delta-cy)))\n                      (list (+ (x-coord mid-pt) (* offset delta-cx))\n                            (- (y-coord mid-pt) (* offset delta-cy))))))))))\n\n;; work through the input examples, outputting results\n(for-each \n  (lambda (c1 c2 r)\n    (let ((result (find-circles c1 c2 r)))\n      (display \"p1: \") (display c1)\n      (display \" p2: \") (display c2)\n      (display \" r: \") (display (number->string r))\n      (display \" => \")\n      (cond ((eq? result 'infinite)\n             (display \"Infinite number of circles\"))\n            ((null? result)\n             (display \"No circles\"))\n            (else\n              (display result)))\n      (newline)))\n  '((0.1234 0.9876) (0.0000 2.0000) (0.1234 0.9876) (0.1234 0.9876) (0.1234 0.9876))\n  '((0.8765 0.2345) (0.0000 0.0000) (0.1234 0.9876) (0.8765 0.2345) (0.1234 0.9876))\n  '(2.0 1.0 2.0 0.5 0.0))\n\n\nOutput:\np1: (0.1234 0.9876) p2: (0.8765 0.2345) r: 2.0 => ((1.86311180165819 1.97421180165819) (-0.863211801658189 -0.752111801658189))\np1: (0.0 2.0) p2: (0.0 0.0) r: 1.0 => ((0.0 1.0))\np1: (0.1234 0.9876) p2: (0.1234 0.9876) r: 2.0 => Infinite number of circles\np1: (0.1234 0.9876) p2: (0.8765 0.2345) r: 0.5 => No circles\np1: (0.1234 0.9876) p2: (0.1234 0.9876) r: 0.0 => ((0.1234 0.9876))\n\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "F#", "code": "\nopen System\n\nlet add (a:double, b:double) (x:double, y:double) = (a + x, b + y)\nlet sub (a:double, b:double) (x:double, y:double) = (a - x, b - y)\nlet magSqr (a:double, b:double) = a * a + b * b\nlet mag a:double = Math.Sqrt(magSqr a)\nlet mul (a:double, b:double) c = (a * c, b * c)\nlet div2 (a:double, b:double) c = (a / c, b / c)\nlet perp (a:double, b:double) = (-b, a)\nlet norm a = div2 a (mag a)\n\nlet circlePoints p q (radius:double) =\n    let diameter = radius * 2.0\n    let pq = sub p q\n    let magPQ = mag pq\n    let midpoint = div2 (add p q) 2.0\n    let halfPQ = magPQ / 2.0\n    let magMidC = Math.Sqrt(Math.Abs(radius * radius - halfPQ * halfPQ))\n    let midC = mul (norm (perp pq)) magMidC\n    let center1 = add midpoint midC\n    let center2 = sub midpoint midC\n    if radius = 0.0 then None\n    else if p = q then None\n    else if diameter < magPQ then None\n    else Some (center1, center2)\n\n[<EntryPoint>]\nlet main _ = \n    printfn \"%A\" (circlePoints (0.1234, 0.9876) (0.8765, 0.2345) 2.0)\n    printfn \"%A\" (circlePoints (0.0, 2.0) (0.0, 0.0) 1.0)\n    printfn \"%A\" (circlePoints (0.1234, 0.9876) (0.1234, 0.9876) 2.0)\n    printfn \"%A\" (circlePoints (0.1234, 0.9876) (0.8765, 0.2345) 0.5)\n    printfn \"%A\" (circlePoints (0.1234, 0.9876) (0.1234, 0.1234) 0.0)\n\n    0 // return an integer exit code\n\n\nOutput:\nSome ((-0.8632118017, -0.7521118017), (1.863111802, 1.974211802))\nSome ((0.0, 1.0), (0.0, 1.0))\n<null>\n<null>\n<null>\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "Groovy", "code": "\nTranslation of: Java\nclass Circles {\n    private static class Point {\n        private final double x, y\n\n        Point(Double x, Double y) {\n            this.x = x\n            this.y = y\n        }\n\n        double distanceFrom(Point other) {\n            double dx = x - other.x\n            double dy = y - other.y\n            return Math.sqrt(dx * dx + dy * dy)\n        }\n\n        @Override\n        boolean equals(Object other) {\n            //if (this == other) return true\n            if (other == null || getClass() != other.getClass()) return false\n            Point point = (Point) other\n            return x == point.x && y == point.y\n        }\n\n        @Override\n        String toString() {\n            return String.format(\"(%.4f,\u00a0%.4f)\", x, y)\n        }\n    }\n\n    private static Point[] findCircles(Point p1, Point p2, double r) {\n        if (r < 0.0) throw new IllegalArgumentException(\"the radius can't be negative\")\n        if (r == 0.0.toDouble() && p1 != p2) throw new IllegalArgumentException(\"no circles can ever be drawn\")\n        if (r == 0.0.toDouble()) return [p1, p1]\n        if (Objects.equals(p1, p2)) throw new IllegalArgumentException(\"an infinite number of circles can be drawn\")\n        double distance = p1.distanceFrom(p2)\n        double diameter = 2.0 * r\n        if (distance > diameter) throw new IllegalArgumentException(\"the points are too far apart to draw a circle\")\n        Point center = new Point((p1.x + p2.x) / 2.0, (p1.y + p2.y) / 2.0)\n        if (distance == diameter) return [center, center]\n        double mirrorDistance = Math.sqrt(r * r - distance * distance / 4.0)\n        double dx = (p2.x - p1.x) * mirrorDistance / distance\n        double dy = (p2.y - p1.y) * mirrorDistance / distance\n        return [\n            new Point(center.x - dy, center.y + dx),\n            new Point(center.x + dy, center.y - dx)\n        ]\n    }\n\n    static void main(String[] args) {\n        Point[] p = [\n            new Point(0.1234, 0.9876),\n            new Point(0.8765, 0.2345),\n            new Point(0.0000, 2.0000),\n            new Point(0.0000, 0.0000)\n        ]\n        Point[][] points = [\n            [p[0], p[1]],\n            [p[2], p[3]],\n            [p[0], p[0]],\n            [p[0], p[1]],\n            [p[0], p[0]],\n        ]\n        double[] radii = [2.0, 1.0, 2.0, 0.5, 0.0]\n        for (int i = 0; i < radii.length; ++i) {\n            Point p1 = points[i][0]\n            Point p2 = points[i][1]\n            double r = radii[i]\n            printf(\"For points %s and %s with radius %f\\n\", p1, p2, r)\n            try {\n                Point[] circles = findCircles(p1, p2, r)\n                Point c1 = circles[0]\n                Point c2 = circles[1]\n                if (Objects.equals(c1, c2)) {\n                    printf(\"there is just one circle with center at %s\\n\", c1)\n                } else {\n                    printf(\"there are two circles with centers at %s and %s\\n\", c1, c2)\n                }\n            } catch (IllegalArgumentException ex) {\n                println(ex.getMessage())\n            }\n            println()\n        }\n    }\n}\n\n\nOutput:\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 2.000000\nthere are two circles with centers at (1.8631, 1.9742) and (-0.8632, -0.7521)\n\nFor points (0.0000, 2.0000) and (0.0000, 0.0000) with radius 1.000000\nthere is just one circle with center at (0.0000, 1.0000)\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 2.000000\nan infinite number of circles can be drawn\n\nFor points (0.1234, 0.9876) and (0.8765, 0.2345) with radius 0.500000\nthe points are too far apart to draw a circle\n\nFor points (0.1234, 0.9876) and (0.1234, 0.9876) with radius 0.000000\nthere is just one circle with center at (0.1234, 0.9876)\n", "explain": ""}, {"task_name": "Circles of given radius through two points", "task_url": "https://rosettacode.org/wiki/Circles_of_given_radius_through_two_points", "task_cat": "Geometry", "lang": "AWK", "code": "\n# syntax: GAWK -f CIRCLES_OF_GIVEN_RADIUS_THROUGH_TWO_POINTS.AWK\n# converted from PL/I\nBEGIN {\n    split(\"0.1234,0,0.1234,0.1234,0.1234\",m1x,\",\")\n    split(\"0.9876,2,0.9876,0.9876,0.9876\",m1y,\",\")\n    split(\"0.8765,0,0.1234,0.8765,0.1234\",m2x,\",\")\n    split(\"0.2345,0,0.9876,0.2345,0.9876\",m2y,\",\")\n    leng = split(\"2,1,2,0.5,0\",r,\",\")\n    print(\"     x1      y1      x2      y2    r   cir1x   cir1y   cir2x   cir2y\")\n    print(\"------- ------- ------- ------- ---- ------- ------- ------- -------\")\n    for (i=1; i<=leng; i++) {\n      printf(\"%7.4f %7.4f %7.4f %7.4f %4.2f %s\\n\",m1x[i],m1y[i],m2x[i],m2y[i],r[i],main(m1x[i],m1y[i],m2x[i],m2y[i],r[i]))\n    }\n    exit(0)\n}\nfunction main(m1x,m1y,m2x,m2y,r,  bx,by,pb,x,x1,y,y1) {\n    if (r == 0) { return(\"radius of zero gives no circles\") }\n    x = (m2x - m1x) / 2\n    y = (m2y - m1y) / 2\n    bx = m1x + x\n    by = m1y + y\n    pb = sqrt(x^2 + y^2)\n    if (pb == 0) { return(\"coincident points give infinite circles\") }\n    if (pb > r) { return(\"points are too far apart for the given radius\") }\n    cb = sqrt(r^2 - pb^2)\n    x1 = y * cb / pb\n    y1 = x * cb / pb\n    return(sprintf(\"%7.4f %7.4f %7.4f %7.4f\",bx-x1,by+y1,bx+x1,by-y1))\n}\n\n\nOutput:\n     x1      y1      x2      y2    r   cir1x   cir1y   cir2x   cir2y\n------- ------- ------- ------- ---- ------- ------- ------- -------\n 0.1234  0.9876  0.8765  0.2345 2.00  1.8631  1.9742 -0.8632 -0.7521\n 0.0000  2.0000  0.0000  0.0000 1.00  0.0000  1.0000  0.0000  1.0000\n 0.1234  0.9876  0.1234  0.9876 2.00 coincident points give infinite circles\n 0.1234  0.9876  0.8765  0.2345 0.50 points are too far apart for the given radius\n 0.1234  0.9876  0.1234  0.9876 0.00 radius of zero gives no circles\n\n", "explain": ""}]