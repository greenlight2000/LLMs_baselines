[{"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Python", "code": "\n\n\nan ordered_set class\nan unordered_set class\nan array class\na dictionary class\na bag class\na map class\n\n\n# Module: calculus.py\n\nimport enum\n\nclass entry_not_found(Exception):\n   \"\"\"Raised when an entry is not found in a collection\"\"\"\n   pass\n\nclass entry_already_exists(Exception):\n   \"\"\"Raised when an entry already exists in a collection\"\"\"\n   pass\n\nclass state(enum.Enum):\n   header = 0\n   left_high = 1\n   right_high = 2\n   balanced = 3\n\nclass direction(enum.Enum):\n   from_left = 0\n   from_right = 1\n\nfrom abc import ABC, abstractmethod\n\nclass comparer(ABC):\n\n    @abstractmethod\n    def compare(self,t):\n        pass\n\nclass node(comparer):\n \n    def __init__(self):\n        self.parent = None\n        self.left = self\n        self.right = self\n        self.balance = state.header\n\n    def compare(self,t):\n        if self.key < t:\n             return -1\n        elif t < self.key:\n             return 1\n        else:\n             return 0\n\n    def is_header(self):\n        return self.balance == state.header\n\n    def length(self):\n        if self != None:\n           if self.left != None:\n              left = self.left.length()\n           else:\n              left = 0\n           if self.right != None:   \n              right = self.right.length()\n           else:\n              right = 0\n              \n           return left + right + 1\n        else:\n           return 0\n    \n    def rotate_left(self):\n         _parent = self.parent\n         x = self.right\n         self.parent = x\n         x.parent = _parent\n         if x.left is not None:\n             x.left.parent = self\n         self.right = x.left\n         x.left = self\n         return x\n    \n \n    def rotate_right(self):\n        _parent = self.parent\n        x = self.left\n        self.parent = x\n        x.parent = _parent;\n        if x.right is not None:\n            x.right.parent = self\n        self.left = x.right\n        x.right = self\n        return x\n\n    def balance_left(self):\n       \n       _left = self.left\n\n       if _left is None:\n          return self;\n       \n       if _left.balance == state.left_high:\n                self.balance = state.balanced\n                _left.balance = state.balanced\n                self = self.rotate_right()\n       elif _left.balance == state.right_high: \n                subright = _left.right\n                if subright.balance == state.balanced:\n                        self.balance = state.balanced\n                        _left.balance = state.balanced\n                elif subright.balance == state.right_high:\n                        self.balance = state.balanced\n                        _left.balance = state.left_high\n                elif subright.balance == left_high:\n                        root.balance = state.right_high\n                        _left.balance = state.balanced\n                subright.balance = state.balanced\n                _left = _left.rotate_left()\n                self.left = _left\n                self = self.rotate_right()\n       elif _left.balance == state.balanced:\n               self.balance = state.left_high\n               _left.balance = state.right_high\n               self = self.rotate_right()\n       return self;\n   \n    def balance_right(self):\n\n       _right = self.right\n\n       if _right is None:\n          return self;\n       \n       if _right.balance == state.right_high:\n                self.balance = state.balanced\n                _right.balance = state.balanced\n                self = self.rotate_left()\n       elif _right.balance == state.left_high:\n                subleft = _right.left;\n                if subleft.balance == state.balanced:\n                        self.balance = state.balanced\n                        _right.balance = state.balanced\n                elif subleft.balance == state.left_high:\n                        self.balance = state.balanced\n                        _right.balance = state.right_high\n                elif subleft.balance == state.right_high:\n                        self.balance = state.left_high\n                        _right.balance = state.balanced\n                subleft.balance = state.balanced\n                _right = _right.rotate_right()\n                self.right = _right\n                self = self.rotate_left()\n       elif _right.balance == state.balanced:\n                self.balance = state.right_high\n                _right.balance = state.left_high\n                self = self.rotate_left()\n       return self\n\n\n    def balance_tree(self, direct):\n        taller = True\n        while taller:\n            _parent = self.parent;\n            if _parent.left == self:\n                next_from =  direction.from_left\n            else:\n                next_from = direction.from_right;\n\n            if direct == direction.from_left:\n                if self.balance == state.left_high:\n                        if _parent.is_header():\n                            _parent.parent = _parent.parent.balance_left()\n                        elif _parent.left == self:\n                            _parent.left = _parent.left.balance_left()\n                        else:\n                            _parent.right = _parent.right.balance_left()\n                        taller = False\n \n                elif self.balance == state.balanced:\n                        self.balance = state.left_high\n                        taller = True\n      \n                elif self.balance == state.right_high:\n                        self.balance = state.balanced\n                        taller = False\n            else:\n              if self.balance == state.left_high:\n                        self.balance = state.balanced\n                        taller = False\n  \n              elif self.balance ==  state.balanced:\n                        self.balance = state.right_high\n                        taller = True\n  \n              elif self.balance ==  state.right_high:\n                        if _parent.is_header():\n                            _parent.parent = _parent.parent.balance_right()\n                        elif _parent.left == self:\n                            _parent.left = _parent.left.balance_right()\n                        else:\n                            _parent.right = _parent.right.balance_right()\n                        taller = False\n  \n            if taller:\n                if _parent.is_header():\n                    taller = False\n                else:\n                    self = _parent\n                    direct = next_from\n\n    def balance_tree_remove(self, _from):\n      \n        if self.is_header():\n            return;\n\n        shorter = True;\n\n        while shorter:\n            _parent = self.parent;\n            if _parent.left == self:\n                next_from = direction.from_left\n            else:\n                next_from = direction.from_right\n\n            if _from == direction.from_left:\n                if self.balance == state.left_high:\n                        shorter = True\n \n                elif self.balance == state.balanced:\n                        self.balance = state.right_high;\n                        shorter = False\n  \n                elif self.balance == state.right_high:\n                        if self.right is not None:\n                            if self.right.balance == state.balanced:\n                                shorter = False\n                            else:\n                                shorter = True\n                        else:\n                            shorter = False;\n\n                        if _parent.is_header():\n                            _parent.parent = _parent.parent.balance_right()\n                        elif _parent.left == self:\n                            _parent.left = _parent.left.balance_right();\n                        else:\n                            _parent.right = _parent.right.balance_right()\n            \n            else:\n                if self.balance == state.right_high:\n                        self.balance = state.balanced\n                        shorter = True\n  \n                elif self.balance == state.balanced:\n                        self.balance = state.left_high\n                        shorter = False\n                 \n                elif self.balance == state.left_high:\n\n                        if self.left is not None:\n                            if self.left.balance == state.balanced:\n                                shorter = False\n                            else:\n                                shorter = True\n                        else:\n                           short = False;\n\n                        if _parent.is_header():\n                            _parent.parent = _parent.parent.balance_left();\n                        elif _parent.left == self:\n                            _parent.left = _parent.left.balance_left();\n                        else:\n                            _parent.right = _parent.right.balance_left();\n \n            if shorter:\n               if _parent.is_header():\n                    shorter = False\n               else: \n                    _from = next_from\n                    self = _parent\n\n    def previous(self):\n        if self.is_header():\n            return self.right\n\n        if self.left is not None:\n            y = self.left\n            while y.right is not None:\n                y = y.right\n            return y\n         \n        else: \n            y = self.parent;\n            if y.is_header():\n                return y\n\n            x = self\n            while x == y.left:\n                x = y\n                y = y.parent\n\n            return y\n        \n    def next(self):\n        if self.is_header():\n            return self.left\n\n        if self.right is not None:\n            y = self.right\n            while y.left is not None:\n                y = y.left\n            return y;\n         \n        else:\n            y = self.parent\n            if y.is_header():\n                return y\n\n            x = self;         \n            while x == y.right:\n                x = y\n                y = y.parent;\n                \n            return y\n\n    def swap_nodes(a, b):\n       \n        if b == a.left:\n            if b.left is not None:\n                b.left.parent = a\n\n            if b.right is not None:\n                b.right.parent = a\n\n            if a.right is not None:\n                a.right.parent = b\n\n            if not a.parent.is_header():\n                if a.parent.left == a:\n                    a.parent.left = b\n                else:\n                    a.parent.right = b;\n            else:\n                a.parent.parent = b\n\n            b.parent = a.parent\n            a.parent = b\n\n            a.left = b.left\n            b.left = a\n\n            temp = a.right\n            a.right = b.right\n            b.right = temp\n        elif b == a.right:\n            if b.right is not None:\n                b.right.parent = a\n                \n            if b.left is not None:\n               b.left.parent = a\n\n            if a.left is not None:\n               a.left.parent = b\n\n            if not a.parent.is_header(): \n                if a.parent.left == a:\n                    a.parent.left = b\n                else:\n                    a.parent.right = b\n            else:\n               a.parent.parent = b\n\n            b.parent = a.parent\n            a.parent = b\n\n            a.right = b.right\n            b.right = a\n\n            temp = a.left\n            a.left = b.left\n            b.left = temp\n        elif a == b.left:\n            if a.left is not None:\n                a.left.parent = b\n                \n            if a.right is not None:\n                a.right.parent = b\n\n            if b.right is not None:\n                b.right.parent = a\n\n            if not parent.is_header(): \n                if b.parent.left == b:\n                    b.parent.left = a\n                else:\n                    b.parent.right = a\n            else:\n                b.parent.parent = a\n\n            a.parent = b.parent\n            b.parent = a\n\n            b.left = a.left\n            a.left = b\n\n            temp = a.right\n            a.right = b.right\n            b.right = temp\n        elif a == b.right:\n            if a.right is not None:\n                a.right.parent = b\n            if a.left is not None:\n               a.left.parent = b\n\n            if b.left is not None:\n               b.left.parent = a\n\n            if not b.parent.is_header():\n                if b.parent.left == b:\n                    b.parent.left = a\n                else:\n                    b.parent.right = a\n            else:\n                b.parent.parent = a\n\n            a.parent = b.parent\n            b.parent = a\n\n            b.right = a.right\n            a.right = b\n\n            temp = a.left\n            a.left = b.left\n            b.left = temp\n        else:\n            if a.parent == b.parent:\n                temp = a.parent.left\n                a.parent.left = a.parent.right\n                a.parent.right = temp\n            else:\n                if not a.parent.is_header():\n                    if a.parent.left == a:\n                        a.parent.left = b\n                    else:\n                        a.parent.right = b\n                else:\n                    a.parent.parent = b\n\n                if not b.parent.is_header():\n                    if b.parent.left == b:\n                        b.parent.left = a\n                    else:\n                        b.parent.right = a\n                else:\n                    b.parent.parent = a\n            \n            if b.left is not None:\n                b.left.parent = a\n                \n            if b.right is not None:\n                b.right.parent = a\n\n            if a.left is not None:\n                a.left.parent = b\n                \n            if a.right is not None:\n                a.right.parent = b\n\n            temp1 = a.left\n            a.left = b.left\n            b.left = temp1\n\n            temp2 = a.right\n            a.right = b.right\n            b.right = temp2\n\n            temp3 = a.parent\n            a.parent = b.parent\n            b.parent = temp3\n        \n        balance = a.balance\n        a.balance = b.balance\n        b.balance = balance\n    \nclass parent_node(node):\n\n    def __init__(self, parent):\n        self.parent = parent\n        self.left = None\n        self.right = None\n        self.balance = state.balanced\n\nclass set_node(node):\n\n    def __init__(self, parent, key):\n        self.parent = parent\n        self.left = None\n        self.right = None\n        self.balance = state.balanced\n        self.key = key\n\nclass ordered_set:\n    \n    def __init__(self):\n        self.header = node()\n\n    def __iter__(self):\n        self.node = self.header\n        return self\n    \n    def __next__(self):\n        self.node = self.node.next()\n        if self.node.is_header():\n            raise StopIteration\n        return self.node.key\n\n    def __delitem__(self, key):\n          self.remove(key)\n\n    def __lt__(self, other):\n        first1 = self.header.left\n        last1 = self.header\n        first2 = other.header.left\n        last2 = other.header\n\n        while (first1 != last1) and (first2 != last2):\n           l =  first1.key < first2.key\n           if not l: \n              first1 = first1.next();\n              first2 = first2.next();\n           else:\n              return True;\n  \n        a = self.__len__()\n        b = other.__len__()\n        return a < b\n\n    def __hash__(self):\n        h = 0\n        for i in self:\n            h = h + i.__hash__()\n        return h    \n\n    def __eq__(self, other):\n       if self < other:\n          return False\n       if other < self:\n          return False\n       return True\n     \n    def __ne__(self, other):\n       if self < other:\n          return True\n       if other < self:\n          return True\n       return False\n\n    def __len__(self):\n        return self.header.parent.length()\n\n    def __getitem__(self, key):\n          return self.contains(key)\n\n    def __str__(self):\n       l = self.header.right\n       s = \"{\"\n       i = self.header.left\n       h = self.header\n       while i != h:\n           s = s + i.key.__str__()\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s\n\n    def __or__(self, other):\n       r = ordered_set()\n       \n       first1 = self.header.left\n       last1 = self.header\n       first2 = other.header.left\n       last2 = other.header\n       \n       while first1 != last1 and first2 != last2:\n          les = first1.key < first2.key\n          graater = first2.key < first1.key\n\n          if les:\n             r.add(first1.key)\n             first1 = first1.next()\n          elif graater:\n             r.add(first2.key)\n             first2 = first2.next()\n          else:\n             r.add(first1.key)\n             first1 = first1.next()\n             first2 = first2.next()\n             \n       while first1 != last1:\n          r.add(first1.key)\n          first1 = first1.next()\n                        \n       while first2 != last2:\n          r.add(first2.key)\n          first2 = first2.next()\n\n       return r\n\n    def __and__(self, other):\n       r = ordered_set()\n       \n       first1 = self.header.left\n       last1 = self.header\n       first2 = other.header.left\n       last2 = other.header\n       \n       while first1 != last1 and first2 != last2:\n          les = first1.key < first2.key\n          graater = first2.key < first1.key\n\n          if les:\n             first1 = first1.next()\n          elif graater:\n             first2 = first2.next()\n          else:\n             r.add(first1.key)\n             first1 = first1.next()\n             first2 = first2.next()\n  \n       return r\n\n    def __xor__(self, other):\n       r = ordered_set()\n       \n       first1 = self.header.left\n       last1 = self.header\n       first2 = other.header.left\n       last2 = other.header\n       \n       while first1 != last1 and first2 != last2:\n          les = first1.key < first2.key\n          graater = first2.key < first1.key\n\n          if les:\n             r.add(first1.key)\n             first1 = first1.next()\n          elif graater:\n             r.add(first2.key)\n             first2 = first2.next()\n          else:\n             first1 = first1.next()\n             first2 = first2.next()\n             \n       while first1 != last1:\n          r.add(first1.key)\n          first1 = first1.next()\n                        \n       while first2 != last2:\n          r.add(first2.key)\n          first2 = first2.next()\n\n       return r\n\n\n    def __sub__(self, other):\n       r = ordered_set()\n       \n       first1 = self.header.left\n       last1 = self.header\n       first2 = other.header.left\n       last2 = other.header\n       \n       while first1 != last1 and first2 != last2:\n          les = first1.key < first2.key\n          graater = first2.key < first1.key\n\n          if les:\n             r.add(first1.key)\n             first1 = first1.next()\n          elif graater:\n             r.add(first2.key)\n             first2 = first2.next()\n          else:\n             first1 = first1.next()\n             first2 = first2.next()\n             \n       while first1 != last1:\n          r.add(first1.key)\n          first1 = first1.next()\n\n       return r\n \n    def __lshift__(self, data):\n       self.add(data)\n       return self\n\n    def __rshift__(self, data):\n       self.remove(data)\n       return self\n\n    def is_subset(self, other):\n       first1 = self.header.left\n       last1 = self.header\n       first2 = other.header.left\n       last2 = other.header\n\n       is_subet = True\n\n       while first1 != last1 and first2 != last2:\n          if first1.key < first2.key:\n              is_subset = False\n              break\n          elif first2.key < first1.key:\n             first2 = first2.next()\n          else:\n             first1 = first1.next()\n             first2 = first2.next()\n \n          if is_subet:\n             if first1 != last1:\n                is_subet = False\n \n       return is_subet\n\n    def is_superset(self,other):\n       return other.is_subset(self)\n  \n    def add(self, data):\n            if self.header.parent is None:\n                self.header.parent = set_node(self.header,data)\n                self.header.left = self.header.parent\n                self.header.right = self.header.parent\n            else:\n                \n                root = self.header.parent\n\n                while True:\n                    c = root.compare(data)\n                    if c >= 0:\n                        if root.left is not None:\n                            root = root.left\n                        else:\n                            new_node = set_node(root,data)\n                            root.left = new_node\n                            \n                            if self.header.left == root:\n                                 self.header.left = new_node\n                            root.balance_tree(direction.from_left)\n                            return\n                        \n                    else:\n                        if root.right is not None:\n                            root = root.right\n                        else:\n                            new_node = set_node(root, data)\n                            root.right = new_node\n                            if self.header.right == root:\n                                  self.header.right = new_node\n                            root.balance_tree(direction.from_right)\n                            return\n                    \n    def remove(self,data):\n        root = self.header.parent;\n\n        while True:\n            if root is None:\n                raise entry_not_found(\"Entry not found in collection\")\n                \n            c  = root.compare(data)\n\n            if c < 0:\n               root = root.left;\n\n            elif c > 0:\n               root = root.right;\n\n            else:\n                 \n                 if root.left is not None:\n                     if root.right is not None: \n                         replace = root.left\n                         while replace.right is not None:\n                             replace = replace.right\n                         root.swap_nodes(replace)\n                         \n                 _parent = root.parent\n\n                 if _parent.left == root:\n                     _from = direction.from_left\n                 else:\n                     _from = direction.from_right\n\n                 if self.header.left == root:\n                                \n                     n = root.next();\n                 \n                     if n.is_header():\n                         self.header.left = self.header\n                         self.header.right = self.header\n                     else:\n                        self.header.left = n\n                 elif self.header.right == root: \n\n                     p = root.previous();\n\n                     if p.is_header():\n                          self.header.left = self.header\n                          self.header.right = self.header\n                     else:\n                          self.header.right = p\n\n                 if root.left is None:\n                     if _parent == self.header:\n                         self.header.parent = root.right\n                     elif _parent.left == root:\n                         _parent.left = root.right\n                     else:\n                         _parent.right = root.right\n\n                     if root.right is not None:\n                          root.right.parent = _parent\n                            \n                 else:\n                     if _parent == self.header:\n                          self.header.parent = root.left\n                     elif _parent.left == root:\n                         _parent.left = root.left\n                     else:\n                         _parent.right = root.left\n\n                     if root.left is not None:\n                         root.left.parent = _parent;\n\n\n                 _parent.balance_tree_remove(_from)\n                 return   \n\n    def contains(self,data):\n        root = self.header.parent;\n\n        while True:\n            if root == None:\n                return False\n\n            c  = root.compare(data);\n\n            if c > 0:\n               root = root.left;\n\n            elif c < 0:\n               root = root.right;\n\n            else:\n           \n                 return True  \n\n   \n    def find(self,data):\n        root = self.header.parent;\n\n        while True:\n            if root == None:\n                raise entry_not_found(\"An entry is not found in a collection\")\n\n            c  = root.compare(data);\n\n            if c > 0:\n               root = root.left;\n\n            elif c < 0:\n               root = root.right;\n\n            else:\n           \n                 return root.key;  \n            \nclass key_value(comparer):\n\n    def __init__(self, key, value):\n        self.key = key\n        self.value = value\n\n    def compare(self,kv):\n        if self.key < kv.key:\n             return -1\n        elif kv.key < self.key:\n             return 1\n        else:\n             return 0\n\n    def __lt__(self, other):\n        return self.key < other.key\n\n    def __str__(self):\n        return '(' + self.key.__str__() + ',' + self.value.__str__() + ')'\n\n    def __eq__(self, other):\n       return self.key == other.key\n\n    def __hash__(self):\n        return hash(self.key)\n \n\nclass dictionary:\n\n    def __init__(self):\n        self.set = ordered_set()\n        return None\n\n    def __lt__(self, other):\n       if self.keys() < other.keys():\n          return true\n\n       if other.keys() < self.keys():\n          return false\n         \n       first1 = self.set.header.left\n       last1 = self.set.header\n       first2 = other.set.header.left\n       last2 = other.set.header\n\n       while (first1 != last1) and (first2 != last2):\n          l =  first1.key.value < first2.key.value\n          if not l: \n             first1 = first1.next();\n             first2 = first2.next();\n          else:\n             return True;\n  \n       a = self.__len__()\n       b = other.__len__()\n       return a < b\n\n\n    def add(self, key, value):\n       try:\n           self.set.remove(key_value(key,None))\n       except entry_not_found:\n            pass  \n       self.set.add(key_value(key,value))\n       return\n\n    def remove(self, key):\n       self.set.remove(key_value(key,None))\n       return\n\n    def clear(self):\n       self.set.header = node()\n\n    def sort(self):\n    \n      sort_bag = bag()\n      for e in self:\n        sort_bag.add(e.value)\n      keys_set = self.keys()\n      self.clear()\n      i = sort_bag.__iter__()\n      i = sort_bag.__next__()\n      try:\n        for e in keys_set:\n          self.add(e,i)\n          i = sort_bag.__next__()\n      except:\n         return        \n\n    def keys(self):\n         keys_set = ordered_set()\n         for e in self:\n             keys_set.add(e.key)\n         return keys_set  \n   \n    def __len__(self):\n        return self.set.header.parent.length()\n\n    def __str__(self):\n       l = self.set.header.right;\n       s = \"{\"\n       i = self.set.header.left;\n       h = self.set.header;\n       while i != h:\n           s = s + \"(\"\n           s = s + i.key.key.__str__()\n           s = s + \",\"\n           s = s + i.key.value.__str__()\n           s = s + \")\"\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s;\n\n    def __iter__(self):\n       \n        self.set.node = self.set.header\n        return self\n    \n    def __next__(self):\n        self.set.node = self.set.node.next()\n        if self.set.node.is_header():\n            raise StopIteration\n        return key_value(self.set.node.key.key,self.set.node.key.value)\n\n    def __getitem__(self, key):\n          kv = self.set.find(key_value(key,None))\n          return kv.value\n\n    def __setitem__(self, key, value):\n          self.add(key,value)\n          return\n\n    def __delitem__(self, key):\n          self.set.remove(key_value(key,None))\n\n\nclass array:\n\n    def __init__(self):\n        self.dictionary = dictionary()\n        return None\n      \n    def __len__(self):\n        return self.dictionary.__len__()\n\n    def push(self, value):\n       k = self.dictionary.set.header.right\n       if k == self.dictionary.set.header:\n           self.dictionary.add(0,value)\n       else:\n           self.dictionary.add(k.key.key+1,value)\n       return\n\n    def pop(self):\n       if self.dictionary.set.header.parent != None:\n          data = self.dictionary.set.header.right.key.value\n          self.remove(self.dictionary.set.header.right.key.key)\n          return data\n\n    def add(self, key, value):\n       try:\n          self.dictionary.remove(key)\n       except entry_not_found:\n          pass\n       self.dictionary.add(key,value)          \n       return\n\n    def remove(self, key):\n       self.dictionary.remove(key)\n       return\n\n    def sort(self):\n       self.dictionary.sort()\n\n    def clear(self):\n      self.dictionary.header = node();\n      \n\n    def __iter__(self):\n        self.dictionary.node = self.dictionary.set.header\n        return self\n    \n    def __next__(self):\n        self.dictionary.node = self.dictionary.node.next()\n        if self.dictionary.node.is_header():\n            raise StopIteration\n        return self.dictionary.node.key.value\n\n    def __getitem__(self, key):\n          kv = self.dictionary.set.find(key_value(key,None))\n          return kv.value\n\n    def __setitem__(self, key, value):\n          self.add(key,value)\n          return\n\n    def __delitem__(self, key):\n          self.dictionary.remove(key)\n\n    def __lshift__(self, data):\n         self.push(data)\n         return self\n\n    def __lt__(self, other):\n       return self.dictionary < other.dictionary\n \n    def __str__(self):\n       l = self.dictionary.set.header.right;\n       s = \"{\"\n       i = self.dictionary.set.header.left;\n       h = self.dictionary.set.header;\n       while i != h:\n           s = s + i.key.value.__str__()\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s;\n          \n\nclass bag:\n    \n    def __init__(self):\n        self.header = node()\n      \n    def __iter__(self):\n        self.node = self.header\n        return self\n\n    def __delitem__(self, key):\n          self.remove(key)\n    \n    def __next__(self):\n        self.node = self.node.next()\n        if self.node.is_header():\n            raise StopIteration\n        return self.node.key\n\n    def __str__(self):\n       l = self.header.right;\n       s = \"(\"\n       i = self.header.left;\n       h = self.header;\n       while i != h:\n           s = s + i.key.__str__()\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \")\"\n       return s;\n\n    def __len__(self):\n        return self.header.parent.length()\n\n    def __lshift__(self, data):\n       self.add(data)\n       return self\n\n    def add(self, data):\n            if self.header.parent is None:\n                self.header.parent = set_node(self.header,data)\n                self.header.left = self.header.parent\n                self.header.right = self.header.parent\n            else:\n                \n                root = self.header.parent\n\n                while True:\n                    c = root.compare(data)\n                    if c >= 0:\n                        if root.left is not None:\n                            root = root.left\n                        else:\n                            new_node = set_node(root,data)\n                            root.left = new_node\n                            \n                            if self.header.left == root:\n                                 self.header.left = new_node\n\n                            root.balance_tree(direction.from_left)\n                            return\n                        \n                    else:\n                        if root.right is not None:\n                            root = root.right\n                        else:\n                            new_node = set_node(root, data)\n                            root.right = new_node\n\n                            if self.header.right == root:\n                                  self.header.right = new_node\n\n                            root.balance_tree(direction.from_right)\n                            return\n \n    def remove_first(self,data):\n       \n        root = self.header.parent;\n\n        while True:\n            if root is None:\n                return False;\n\n            c  = root.compare(data);\n\n            if c > 0:\n               root = root.left;\n\n            elif c < 0:\n               root = root.right;\n\n            else:\n                 \n                 if root.left is not None:\n                     if root.right is not None: \n                         replace = root.left;\n                         while replace.right is not None:\n                             replace = replace.right;\n                         root.swap_nodes(replace);\n                         \n                 _parent = root.parent\n\n                 if _parent.left == root:\n                     _from = direction.from_left\n                 else:\n                     _from = direction.from_right\n\n                 if self.header.left == root:\n                                \n                     n = root.next();\n                 \n                     if n.is_header():\n                         self.header.left = self.header\n                         self.header.right = self.header\n                     else:\n                        self.header.left = n;\n                 elif self.header.right == root: \n\n                     p = root.previous();\n\n                     if p.is_header():\n                          self.header.left = self.header\n                          self.header.right = self.header\n                     else:\n                          self.header.right = p\n\n                 if root.left is None:\n                     if _parent == self.header:\n                         self.header.parent = root.right\n                     elif _parent.left == root:\n                         _parent.left = root.right\n                     else:\n                         _parent.right = root.right\n\n                     if root.right is not None:\n                          root.right.parent = _parent\n                            \n                 else:\n                     if _parent == self.header:\n                          self.header.parent = root.left\n                     elif _parent.left == root:\n                         _parent.left = root.left\n                     else:\n                         _parent.right = root.left\n\n                     if root.left is not None:\n                         root.left.parent = _parent;\n\n\n                 _parent.balance_tree_remove(_from)\n                 return True;\n\n    def remove(self,data):\n       success = self.remove_first(data)\n       while success:\n          success = self.remove_first(data)\n\n    def remove_node(self, root):\n       \n        if root.left != None and root.right != None:\n            replace = root.left\n            while replace.right != None:\n               replace = replace.right\n            root.swap_nodes(replace)\n\n        parent = root.parent;\n\n        if parent.left == root:\n           next_from = direction.from_left\n        else:\n           next_from = direction.from_right\n\n        if self.header.left == root:\n            n = root.next()\n\n            if n.is_header():\n                self.header.left = self.header;\n                self.header.right = self.header\n            else:\n                self.header.left = n\n        elif self.header.right == root:\n             p = root.previous()\n\n             if p.is_header(): \n                root.header.left = root.header\n                root.header.right = header\n             else:\n                self.header.right = p\n\n        if root.left == None:\n            if parent == self.header:\n                self.header.parent = root.right\n            elif parent.left == root:\n                parent.left = root.right\n            else:\n                parent.right = root.right\n\n            if root.right != None:\n               root.right.parent = parent\n        else:\n            if parent == self.header:\n                self.header.parent = root.left\n            elif parent.left == root:\n                parent.left = root.left\n            else:\n                parent.right = root.left\n\n            if root.left != None:\n               root.left.parent = parent;\n\n        parent.balance_tree_remove(next_from)\n    \n    def remove_at(self, data, ophset):\n \n            p = self.search(data);\n\n            if p == None:\n                return\n            else:\n                lower = p\n                after = after(data)\n \n            s = 0\n            while True:\n                if ophset == s:\n                    remove_node(lower);\n                    return;\n                lower = lower.next_node()\n                if after == lower:\n                   break\n                s = s+1\n            \n            return\n\n    def search(self, key):\n        s = before(key)\n        s.next()\n        if s.is_header():\n           return None\n        c = s.compare(s.key)\n        if c != 0:\n           return None\n        return s\n    \n  \n    def before(self, data):\n        y = self.header;\n        x = self.header.parent;\n\n        while x != None:\n            if x.compare(data) >= 0:\n                x = x.left;\n            else:\n                y = x;\n                x = x.right;\n        return y\n    \n    def after(self, data):\n        y = self.header;\n        x = self.header.parent;\n\n        while x != None:\n            if x.compare(data) > 0:\n                y = x\n                x = x.left\n            else:\n                x = x.right\n\n        return y;\n    \n \n    def find(self,data):\n        root = self.header.parent;\n\n        results = array()\n        \n        while True:\n            if root is None:\n                break;\n\n            p = self.before(data)\n            p = p.next()\n            if not p.is_header():\n               i = p\n               l = self.after(data)\n               while i != l:\n                  results.push(i.key)\n                  i = i.next()\n         \n               return results\n            else:\n               break;\n            \n        return results\n    \nclass bag_dictionary:\n\n    def __init__(self):\n        self.bag = bag()\n        return None\n\n    def add(self, key, value):\n       self.bag.add(key_value(key,value))\n       return\n\n    def remove(self, key):\n       self.bag.remove(key_value(key,None))\n       return\n\n    def remove_at(self, key, index):\n       self.bag.remove_at(key_value(key,None), index)\n       return\n\n    def clear(self):\n       self.bag.header = node()\n\n    def __len__(self):\n        return self.bag.header.parent.length()\n\n    def __str__(self):\n       l = self.bag.header.right;\n       s = \"{\"\n       i = self.bag.header.left;\n       h = self.bag.header;\n       while i != h:\n           s = s + \"(\"\n           s = s + i.key.key.__str__()\n           s = s + \",\"\n           s = s + i.key.value.__str__()\n           s = s + \")\"\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s;\n\n    def __iter__(self):\n       \n        self.bag.node = self.bag.header\n        return self\n    \n    def __next__(self):\n        self.bag.node = self.bag.node.next()\n        if self.bag.node.is_header():\n            raise StopIteration\n        return key_value(self.bag.node.key.key,self.bag.node.key.value)\n\n    def __getitem__(self, key):\n          kv_array = self.bag.find(key_value(key,None))\n          return kv_array\n\n    def __setitem__(self, key, value):\n          self.add(key,value)\n          return\n\n    def __delitem__(self, key):\n          self.bag.remove(key_value(key,None))\n\nclass unordered_set:\n\n    def __init__(self):\n        self.bag_dictionary = bag_dictionary()\n\n    def __len__(self):\n        return self.bag_dictionary.__len__()\n\n    def __hash__(self):\n        h = 0\n        for i in self:\n            h = h + i.__hash__()\n        return h    \n\n    def __eq__(self, other):\n        for t in self:\n           if not other.contains(t):\n              return False\n        for u in other:\n           if self.contains(u):\n              return False\n        return true;\n\n    def __ne__(self, other):\n        return not self == other\n      \n    def __or__(self, other):\n       r = unordered_set()\n       \n       for t in self:\n          r.add(t);\n          \n       for u in other:\n          if not self.contains(u):\n             r.add(u);\n\n       return r\n\n    def __and__(self, other):\n       r = unordered_set()\n   \n       for t in self:\n          if other.contains(t):\n              r.add(t)\n              \n       for u in other:\n              if self.contains(u) and not r.contains(u):\n                  r.add(u);\n  \n       return r\n\n    def __xor__(self, other):\n       r = unordered_set()\n       \n       for t in self:\n          if not other.contains(t):\n             r.add(t)\n             \n       for u in other:\n          if not self.contains(u) and not r.contains(u):\n             r.add(u)\n             \n       return r\n\n\n    def __sub__(self, other):\n       r = ordered_set()\n       \n       for t in self:\n          if not other.contains(t):\n             r.add(t);\n             \n       return r\n \n    def __lshift__(self, data):\n       self.add(data)\n       return self\n\n    def __rshift__(self, data):\n       self.remove(data)\n       return self\n\n    def __getitem__(self, key):\n          return self.contains(key)\n\n    def is_subset(self, other):\n\n       is_subet = True\n\n       for t in self:\n          if not other.contains(t):\n             subset = False\n             break\n            \n       return is_subet\n\n    def is_superset(self,other):\n       return other.is_subset(self)\n\n\n    def add(self, value):\n       if not self.contains(value):\n           self.bag_dictionary.add(hash(value),value)\n       else:\n          raise entry_already_exists(\"Entry already exists in the unordered set\")\n\n    def contains(self, data):\n            if self.bag_dictionary.bag.header.parent == None:\n                return False;\n            else:\n                index = hash(data);\n\n                _search = self.bag_dictionary.bag.header.parent;\n\n                search_index =  _search.key.key;\n\n                if index < search_index:\n                   _search = _search.left\n\n                elif index > search_index:\n                   _search = _search.right\n\n                if _search == None:\n                    return False\n\n                while _search != None:\n                    search_index =  _search.key.key;\n\n                    if index < search_index:\n                       _search = _search.left\n\n                    elif index > search_index:\n                       _search = _search.right\n\n                    else:\n                       break\n\n                if _search == None:\n                   return False\n\n                return self.contains_node(data, _search)\n \n    def contains_node(self,data,_node):\n       \n        previous = _node.previous()\n        save = _node\n\n        while not previous.is_header() and previous.key.key == _node.key.key:\n            save = previous;\n            previous = previous.previous()\n      \n        c = _node.key.value\n        _node = save\n        if c == data:\n           return True\n\n        next = _node.next()\n        while not next.is_header() and next.key.key == _node.key.key:\n            _node = next\n            c = _node.key.value\n            if c == data:\n               return True;\n            next = _node.next()\n \n        return False;\n      \n    def find(self,data,_node):\n       \n        previous = _node.previous()\n        save = _node\n\n        while not previous.is_header() and previous.key.key == _node.key.key:\n            save = previous;\n            previous = previous.previous();\n \n        _node = save;\n        c = _node.key.value\n        if c == data:\n           return _node\n\n        next = _node.next()\n        while not next.is_header() and next.key.key == _node.key.key:\n            _node = next\n            c = _node.data.value\n            if c == data:\n               return _node\n            next = _node.next()\n \n        return None\n    \n    def search(self, data):\n        if self.bag_dictionary.bag.header.parent == None:\n            return None\n        else:\n            index = hash(data)\n\n            _search = self.bag_dictionary.bag.header.parent\n\n            c = _search.key.key\n\n            if index < c:\n               _search = _search.left;\n\n            elif index > c:\n               _search = _search.right;\n\n            while _search != None:\n\n                if index != c:\n                   break\n               \n                c = _search.key.key\n\n                if index < c:\n                   _search = _search.left;\n\n                elif index > c:\n                   _search = _search.right;\n\n                else:\n                   break\n\n            if _search == None:\n               return None\n\n            return self.find(data, _search)\n\n    def remove(self,data):\n       found = self.search(data);\n       if found != None:\n          self.bag_dictionary.bag.remove_node(found);\n       else:\n          raise entry_not_found(\"Entry not found in the unordered set\")\n \n    def clear(self):\n       self.bag_dictionary.bag.header = node()\n\n    def __str__(self):\n       l = self.bag_dictionary.bag.header.right;\n       s = \"{\"\n       i = self.bag_dictionary.bag.header.left;\n       h = self.bag_dictionary.bag.header;\n       while i != h:\n           s = s + i.key.value.__str__()\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s;\n\n    def __iter__(self):\n       \n        self.bag_dictionary.bag.node = self.bag_dictionary.bag.header\n        return self\n    \n    def __next__(self):\n        self.bag_dictionary.bag.node = self.bag_dictionary.bag.node.next()\n        if self.bag_dictionary.bag.node.is_header():\n            raise StopIteration\n        return self.bag_dictionary.bag.node.key.value\n\n\nclass map:\n\n    def __init__(self):\n        self.set = unordered_set()\n        return None\n\n    def __len__(self):\n        return self.set.__len__()\n\n    def add(self, key, value):\n       try:\n           self.set.remove(key_value(key,None))\n       except entry_not_found:\n            pass  \n       self.set.add(key_value(key,value))\n       return\n\n    def remove(self, key):\n       self.set.remove(key_value(key,None))\n       return\n\n    def clear(self):\n       self.set.clear()\n\n    def __str__(self):\n       l = self.set.bag_dictionary.bag.header.right;\n       s = \"{\"\n       i = self.set.bag_dictionary.bag.header.left;\n       h = self.set.bag_dictionary.bag.header;\n       while i != h:\n           s = s + \"(\"\n           s = s + i.key.value.key.__str__()\n           s = s + \",\"\n           s = s + i.key.value.value.__str__()\n           s = s + \")\"\n           if i != l:\n               s = s + \",\"\n           i = i.next()\n\n       s = s + \"}\"\n       return s;\n\n    def __iter__(self):\n       \n        self.set.node = self.set.bag_dictionary.bag.header\n        return self\n    \n    def __next__(self):\n        self.set.node = self.set.node.next()\n        if self.set.node.is_header():\n            raise StopIteration\n        return key_value(self.set.node.key.key,self.set.node.key.value)\n\n    def __getitem__(self, key):\n          kv = self.set.find(key_value(key,None))\n          return kv.value\n\n    def __setitem__(self, key, value):\n          self.add(key,value)\n          return\n\n    def __delitem__(self, key):\n          self.remove(key)\n\n", "explain": "This is the source code of Pure Calculus in Python. The code includes:\nThe dictionary and array classes includes an AVL bag sort method - which is novel."}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "C", "code": "\n\n", "explain": "See AVL tree/C\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "C++", "code": "\nTranslation of: D\n#include <algorithm>\n#include <iostream>\n\n/* AVL node */\ntemplate <class T>\nclass AVLnode {\npublic:\n    T key;\n    int balance;\n    AVLnode *left, *right, *parent;\n\n    AVLnode(T k, AVLnode *p) : key(k), balance(0), parent(p),\n                        left(NULL), right(NULL) {}\n\n    ~AVLnode() {\n        delete left;\n        delete right;\n    }\n};\n\n/* AVL tree */\ntemplate <class T>\nclass AVLtree {\npublic:\n    AVLtree(void);\n    ~AVLtree(void);\n    bool insert(T key);\n    void deleteKey(const T key);\n    void printBalance();\n\nprivate:\n    AVLnode<T> *root;\n\n    AVLnode<T>* rotateLeft          ( AVLnode<T> *a );\n    AVLnode<T>* rotateRight         ( AVLnode<T> *a );\n    AVLnode<T>* rotateLeftThenRight ( AVLnode<T> *n );\n    AVLnode<T>* rotateRightThenLeft ( AVLnode<T> *n );\n    void rebalance                  ( AVLnode<T> *n );\n    int height                      ( AVLnode<T> *n );\n    void setBalance                 ( AVLnode<T> *n );\n    void printBalance               ( AVLnode<T> *n );\n};\n\n/* AVL class definition */\ntemplate <class T>\nvoid AVLtree<T>::rebalance(AVLnode<T> *n) {\n    setBalance(n);\n\n    if (n->balance == -2) {\n        if (height(n->left->left) >= height(n->left->right))\n            n = rotateRight(n);\n        else\n            n = rotateLeftThenRight(n);\n    }\n    else if (n->balance == 2) {\n        if (height(n->right->right) >= height(n->right->left))\n            n = rotateLeft(n);\n        else\n            n = rotateRightThenLeft(n);\n    }\n\n    if (n->parent != NULL) {\n        rebalance(n->parent);\n    }\n    else {\n        root = n;\n    }\n}\n\ntemplate <class T>\nAVLnode<T>* AVLtree<T>::rotateLeft(AVLnode<T> *a) {\n    AVLnode<T> *b = a->right;\n    b->parent = a->parent;\n    a->right = b->left;\n\n    if (a->right != NULL)\n        a->right->parent = a;\n\n    b->left = a;\n    a->parent = b;\n\n    if (b->parent != NULL) {\n        if (b->parent->right == a) {\n            b->parent->right = b;\n        }\n        else {\n            b->parent->left = b;\n        }\n    }\n\n    setBalance(a);\n    setBalance(b);\n    return b;\n}\n\ntemplate <class T>\nAVLnode<T>* AVLtree<T>::rotateRight(AVLnode<T> *a) {\n    AVLnode<T> *b = a->left;\n    b->parent = a->parent;\n    a->left = b->right;\n\n    if (a->left != NULL)\n        a->left->parent = a;\n\n    b->right = a;\n    a->parent = b;\n\n    if (b->parent != NULL) {\n        if (b->parent->right == a) {\n            b->parent->right = b;\n        }\n        else {\n            b->parent->left = b;\n        }\n    }\n\n    setBalance(a);\n    setBalance(b);\n    return b;\n}\n\ntemplate <class T>\nAVLnode<T>* AVLtree<T>::rotateLeftThenRight(AVLnode<T> *n) {\n    n->left = rotateLeft(n->left);\n    return rotateRight(n);\n}\n\ntemplate <class T>\nAVLnode<T>* AVLtree<T>::rotateRightThenLeft(AVLnode<T> *n) {\n    n->right = rotateRight(n->right);\n    return rotateLeft(n);\n}\n\ntemplate <class T>\nint AVLtree<T>::height(AVLnode<T> *n) {\n    if (n == NULL)\n        return -1;\n    return 1 + std::max(height(n->left), height(n->right));\n}\n\ntemplate <class T>\nvoid AVLtree<T>::setBalance(AVLnode<T> *n) {\n    n->balance = height(n->right) - height(n->left);\n}\n\ntemplate <class T>\nvoid AVLtree<T>::printBalance(AVLnode<T> *n) {\n    if (n != NULL) {\n        printBalance(n->left);\n        std::cout << n->balance << \" \";\n        printBalance(n->right);\n    }\n}\n\ntemplate <class T>\nAVLtree<T>::AVLtree(void) : root(NULL) {}\n\ntemplate <class T>\nAVLtree<T>::~AVLtree(void) {\n    delete root;\n}\n\ntemplate <class T>\nbool AVLtree<T>::insert(T key) {\n    if (root == NULL) {\n        root = new AVLnode<T>(key, NULL);\n    }\n    else {\n        AVLnode<T>\n            *n = root,\n            *parent;\n\n        while (true) {\n            if (n->key == key)\n                return false;\n\n            parent = n;\n\n            bool goLeft = n->key > key;\n            n = goLeft ? n->left : n->right;\n\n            if (n == NULL) {\n                if (goLeft) {\n                    parent->left = new AVLnode<T>(key, parent);\n                }\n                else {\n                    parent->right = new AVLnode<T>(key, parent);\n                }\n\n                rebalance(parent);\n                break;\n            }\n        }\n    }\n\n    return true;\n}\n\ntemplate <class T>\nvoid AVLtree<T>::deleteKey(const T delKey) {\n    if (root == NULL)\n        return;\n\n    AVLnode<T>\n        *n       = root,\n        *parent  = root,\n        *delNode = NULL,\n        *child   = root;\n\n    while (child != NULL) {\n        parent = n;\n        n = child;\n        child = delKey >= n->key ? n->right : n->left;\n        if (delKey == n->key)\n            delNode = n;\n    }\n\n    if (delNode != NULL) {\n        delNode->key = n->key;\n\n        child = n->left != NULL ? n->left : n->right;\n\n        if (root->key == delKey) {\n            root = child;\n        }\n        else {\n            if (parent->left == n) {\n                parent->left = child;\n            }\n            else {\n                parent->right = child;\n            }\n\n            rebalance(parent);\n        }\n    }\n}\n\ntemplate <class T>\nvoid AVLtree<T>::printBalance() {\n    printBalance(root);\n    std::cout << std::endl;\n}\n\nint main(void)\n{\n    AVLtree<int> t;\n\n    std::cout << \"Inserting integer values 1 to 10\" << std::endl;\n    for (int i = 1; i <= 10; ++i)\n        t.insert(i);\n\n    std::cout << \"Printing balance: \";\n    t.printBalance();\n}\n\n\nOutput:\nInserting integer values 1 to 10\nPrinting balance: 0 0 0 1 0 0 0 0 1 0 \n\nMore elaborate version[edit]\n\n", "explain": "See AVL_tree/C++\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Java", "code": "\n\npublic class AVLtree {\n\n    private Node root;\n\n    private static class Node {\n        private int key;\n        private int balance;\n        private int height;\n        private Node left;\n        private Node right;\n        private Node parent;\n\n        Node(int key, Node parent) {\n            this.key = key;\n            this.parent = parent;\n        }\n    }\n\n    public boolean insert(int key) {\n        if (root == null) {\n            root = new Node(key, null);\n            return true;\n        }\n\n        Node n = root;\n        while (true) {\n            if (n.key == key)\n                return false;\n\n            Node parent = n;\n\n            boolean goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n\n            if (n == null) {\n                if (goLeft) {\n                    parent.left = new Node(key, parent);\n                } else {\n                    parent.right = new Node(key, parent);\n                }\n                rebalance(parent);\n                break;\n            }\n        }\n        return true;\n    }\n\n    private void delete(Node node) {\n        if (node.left == null && node.right == null) {\n            if (node.parent == null) {\n                root = null;\n            } else {\n                Node parent = node.parent;\n                if (parent.left == node) {\n                    parent.left = null;\n                } else {\n                    parent.right = null;\n                }\n                rebalance(parent);\n            }\n            return;\n        }\n\n        if (node.left != null) {\n            Node child = node.left;\n            while (child.right != null) child = child.right;\n            node.key = child.key;\n            delete(child);\n        } else {\n            Node child = node.right;\n            while (child.left != null) child = child.left;\n            node.key = child.key;\n            delete(child);\n        }\n    }\n\n    public void delete(int delKey) {\n        if (root == null)\n            return;\n\n        Node child = root;\n        while (child != null) {\n            Node node = child;\n            child = delKey >= node.key ? node.right : node.left;\n            if (delKey == node.key) {\n                delete(node);\n                return;\n            }\n        }\n    }\n\n    private void rebalance(Node n) {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent != null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node rotateLeft(Node a) {\n\n        Node b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right != null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateRight(Node a) {\n\n        Node b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left != null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent != null) {\n            if (b.parent.right == a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node rotateLeftThenRight(Node n) {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node rotateRightThenLeft(Node n) {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(Node n) {\n        if (n == null)\n            return -1;\n        return n.height;\n    }\n\n    private void setBalance(Node... nodes) {\n        for (Node n : nodes) {\n            reheight(n);\n            n.balance = height(n.right) - height(n.left);\n        }\n    }\n\n    public void printBalance() {\n        printBalance(root);\n    }\n\n    private void printBalance(Node n) {\n        if (n != null) {\n            printBalance(n.left);\n            System.out.printf(\"%s \", n.balance);\n            printBalance(n.right);\n        }\n    }\n\n    private void reheight(Node node) {\n        if (node != null) {\n            node.height = 1 + Math.max(height(node.left), height(node.right));\n        }\n    }\n\n    public static void main(String[] args) {\n        AVLtree tree = new AVLtree();\n\n        System.out.println(\"Inserting values 1 to 10\");\n        for (int i = 1; i < 10; i++)\n            tree.insert(i);\n\n        System.out.print(\"Printing balance: \");\n        tree.printBalance();\n    }\n}\n\nInserting values 1 to 10\nPrinting balance: 0 0 0 1 0 1 0 0 0\nMore elaborate version[edit]\n\n", "explain": "This code has been cobbled together from various online examples. It's not easy to find a clear and complete explanation of AVL trees. Textbooks tend to concentrate on red-black trees because of their better efficiency. (AVL trees need to make 2 passes through the tree when inserting and deleting: one down to find the node to operate upon and one up to rebalance the tree.)\nSee AVL_tree/Java\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "C#", "code": "\n\n", "explain": "See AVL_tree/C_sharp.\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\nfunction tree(less, val, more) {\n  return {\n    depth: 1+Math.max(less.depth, more.depth),\n    less: less,\n    val: val,\n    more: more,\n  };\n}\n\nfunction node(val) {\n  return tree({depth: 0}, val, {depth: 0});\n}\n\nfunction insert(x,y) {\n  if (0 == y.depth) return x;\n  if (0 == x.depth) return y;\n  if (1 == x.depth && 1 == y.depth) {\n    switch (Math.sign(y.val)-x.val) {\n      case -1: return tree(y, x.val, {depth: 0});\n      case 0: return y;\n      case 1: return tree(x, y.val, {depth: 0});\n    }\n  }\n  switch (Math.sign(y.val-x.val)) {\n    case -1: return balance(insert(x.less, y), x.val, x.more);\n    case 0: return balance(insert(x.less, y.less), x.val, insert(x.more, y.more));\n    case 1: return balance(x.less. x.val, insert(x.more, y));\n  }\n}\n\nfunction balance(less,val,more) {\n  if (2 > Math.abs(less.depth-more.depth))\n    return tree(less,val,more);\n  if (more.depth > less.depth) {\n    if (more.more.depth >= more.less.depth) {\n      // 'more' was heavy\n      return moreHeavy(less, val, more);\n    } else {\n      return moreHeavy(less,val,lessHeavy(more.less, more.val, more.more));\n    }\n  } else {\n    if(less.less.depth >= less.more.depth) {\n      return lessHeavy(less, val, more);\n    } else {\n      return lessHeavy(moreHeavy(less.less, less.val, less.more), val, more);\n    }\n  }\n}\n\nfunction moreHeavy(less,val,more) {\n  return tree(tree(less,val,more.less), more.val, more.more)\n}\n\nfunction lessHeavy(less,val,more) {\n  return tree(less.less, less.val, tree(less.more, val, more));\n}\n\nfunction remove(val, y) {\n  switch (y.depth) {\n    case 0: return y;\n    case 1:\n      if (val == y.val) {\n        return y.less;\n      } else {\n        return y;\n      }\n    default:\n      switch (Math.sign(y.val - val)) {\n        case -1: return balance(y.less, y.val, remove(val, y.more));\n        case  0: return insert(y.less, y.more);\n        case  1: return balance(remove(val, y.less), y.val, y.more)\n      }\n  }\n}\n\nfunction lookup(val, y) {\n  switch (y.depth) {\n    case 0: return y;\n    case 1: if (val == y.val) {\n      return y;\n    } else {\n      return {depth: 0};\n    }\n    default: \n      switch (Math.sign(y.val-val)) {\n        case -1: return lookup(val, y.more);\n        case  0: return y;\n        case  1: return lookup(val, y.less);\n      }\n  }\n}\n\n\nfunction dumptree(t) {\n  switch (t.depth) {\n    case 0: return '';\n    case 1: return t.val;\n    default: return '('+dumptree(t.less)+','+t.val+','+dumptree(t.more)+')';\n  }\n}\nfunction example() {\n  let t= node(0);\n  for (let j= 1; j<20; j++) {\n    t= insert(node(j), t);\n  }\n  console.log(dumptree(t));\n  t= remove(2, t);\n  console.log(dumptree(t));\n  console.log(dumptree(lookup(5, t)));\n  console.log(dumptree(remove(5, t)));\n}\n\nexample();\n\n\nOutput:\n(((((0,1,2),3,(4,5,)),6,((7,8,),9,)),10,(((11,12,),13,),14,)),15,(((16,17,),18,),19,))\n(((((0,1,),3,(4,5,)),6,((7,8,),9,)),10,(((11,12,),13,),14,)),15,(((16,17,),18,),19,))\n(4,5,)\n(((((0,1,),3,4),6,((7,8,),9,)),10,(((11,12,),13,),14,)),15,(((16,17,),18,),19,))\n", "explain": "Some examples:\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Fortran", "code": "\nWorks with: Fortran version 2008\nWorks with: Fortran version 2018\n\nmodule avl_trees\n  !\n  ! References:\n  !\n  !   * Niklaus Wirth, 1976. Algorithms + Data Structures =\n  !     Programs. Prentice-Hall, Englewood Cliffs, New Jersey.\n  !\n  !   * Niklaus Wirth, 2004. Algorithms and Data Structures. Updated\n  !     by Fyodor Tkachov, 2014.\n  !\n\n  implicit none\n  private\n\n  ! The type for an AVL tree.\n  public :: avl_tree_t\n\n  ! The type for a pair of pointers to key and data within the tree.\n  ! (Be careful with these!)\n  public :: avl_pointer_pair_t\n\n  ! Insertion, replacement, modification, etc.\n  public :: avl_insert_or_modify\n\n  ! Insert or replace.\n  public :: avl_insert\n\n  ! Is the key in the tree?\n  public :: avl_contains\n\n  ! Retrieve data from a tree.\n  public :: avl_retrieve\n\n  ! Delete data from a tree. This is a generic function.\n  public :: avl_delete\n\n  ! Implementations of avl_delete.\n  public :: avl_delete_with_found\n  public :: avl_delete_without_found\n\n  ! How many nodes are there in the tree?\n  public :: avl_size\n\n  ! Return a list of avl_pointer_pair_t for the elements in the\n  ! tree. The list will be in order.\n  public :: avl_pointer_pairs\n\n  ! Print a representation of the tree to an output unit.\n  public :: avl_write\n\n  ! Check the AVL condition (that the heights of the two branches from\n  ! a node should differ by zero or one). ERROR STOP if the condition\n  ! is not met.\n  public :: avl_check\n\n  ! Procedure types.\n  public :: avl_less_than_t\n  public :: avl_insertion_t\n  public :: avl_key_data_writer_t\n\n  type :: avl_node_t\n     class(*), allocatable :: key, data\n     type(avl_node_t), pointer :: left\n     type(avl_node_t), pointer :: right\n     integer :: bal             ! bal == -1, 0, 1\n  end type avl_node_t\n\n  type :: avl_tree_t\n     type(avl_node_t), pointer :: p => null ()\n   contains\n     final :: avl_tree_t_final\n  end type avl_tree_t\n\n  type :: avl_pointer_pair_t\n     class(*), pointer :: p_key, p_data\n     class(avl_pointer_pair_t), pointer :: next => null ()\n   contains\n     final :: avl_pointer_pair_t_final\n  end type avl_pointer_pair_t\n\n  interface avl_delete\n     module procedure avl_delete_with_found\n     module procedure avl_delete_without_found\n  end interface avl_delete\n\n  interface\n     function avl_less_than_t (key1, key2) result (key1_lt_key2)\n       !\n       ! The ordering predicate (\u2018<\u2019).\n       !\n       ! Two keys a,b are considered equivalent if neither a<b nor\n       ! b<a.\n       !\n       class(*), intent(in) :: key1, key2\n       logical key1_lt_key2\n     end function avl_less_than_t\n\n     subroutine avl_insertion_t (key, data, p_is_new, p)\n       !\n       ! Insertion or modification of a found node.\n       !\n       import avl_node_t\n       class(*), intent(in) :: key, data\n       logical, intent(in) :: p_is_new\n       type(avl_node_t), pointer, intent(inout) :: p\n     end subroutine avl_insertion_t\n\n     subroutine avl_key_data_writer_t (unit, key, data)\n       !\n       ! Printing the key and data of a node.\n       !\n       integer, intent(in) :: unit\n       class(*), intent(in) :: key, data\n     end subroutine avl_key_data_writer_t\n  end interface\n\ncontains\n\n  subroutine avl_tree_t_final (tree)\n    type(avl_tree_t), intent(inout) :: tree\n\n    type(avl_node_t), pointer :: p\n\n    p => tree%p\n    call free_the_nodes (p)\n\n  contains\n\n    recursive subroutine free_the_nodes (p)\n      type(avl_node_t), pointer, intent(inout) :: p\n\n      if (associated (p)) then\n         call free_the_nodes (p%left)\n         call free_the_nodes (p%right)\n         deallocate (p)\n      end if\n    end subroutine free_the_nodes\n\n  end subroutine avl_tree_t_final\n\n  recursive subroutine avl_pointer_pair_t_final (node)\n    type(avl_pointer_pair_t), intent(inout) :: node\n\n    if (associated (node%next)) deallocate (node%next)\n  end subroutine avl_pointer_pair_t_final\n\n  function avl_contains (less_than, key, tree) result (found)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    class(avl_tree_t), intent(in) :: tree\n    logical :: found\n\n    found = avl_contains_recursion (less_than, key, tree%p)\n  end function avl_contains\n\n  recursive function avl_contains_recursion (less_than, key, p) result (found)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    type(avl_node_t), pointer, intent(in) :: p\n    logical :: found\n\n    if (.not. associated (p)) then\n       found = .false.\n    else if (less_than (key, p%key)) then\n       found = avl_contains_recursion (less_than, key, p%left)\n    else if (less_than (p%key, key)) then\n       found = avl_contains_recursion (less_than, key, p%right)\n    else\n       found = .true.\n    end if\n  end function avl_contains_recursion\n\n  subroutine avl_retrieve (less_than, key, tree, found, data)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    class(avl_tree_t), intent(in) :: tree\n    logical, intent(out) :: found\n    class(*), allocatable, intent(inout) :: data\n\n    call avl_retrieve_recursion (less_than, key, tree%p, found, data)\n  end subroutine avl_retrieve\n\n  recursive subroutine avl_retrieve_recursion (less_than, key, p, found, data)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    type(avl_node_t), pointer, intent(in) :: p\n    logical, intent(out) :: found\n    class(*), allocatable, intent(inout) :: data\n\n    if (.not. associated (p)) then\n       found = .false.\n    else if (less_than (key, p%key)) then\n       call avl_retrieve_recursion (less_than, key, p%left, found, data)\n    else if (less_than (p%key, key)) then\n       call avl_retrieve_recursion (less_than, key, p%right, found, data)\n    else\n       found = .true.\n       data = p%data\n    end if\n  end subroutine avl_retrieve_recursion\n\n  subroutine avl_insert (less_than, key, data, tree)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key, data\n    class(avl_tree_t), intent(inout) :: tree\n\n    call avl_insert_or_modify (less_than, insert_or_replace, key, data, tree)\n  end subroutine avl_insert\n\n  subroutine insert_or_replace (key, data, p_is_new, p)\n    class(*), intent(in) :: key, data\n    logical, intent(in) :: p_is_new\n    type(avl_node_t), pointer, intent(inout) :: p\n\n    p%data = data\n  end subroutine insert_or_replace\n\n  subroutine avl_insert_or_modify (less_than, insertion, key, data, tree)\n    procedure(avl_less_than_t) :: less_than\n    procedure(avl_insertion_t) :: insertion ! Or modification in place.\n    class(*), intent(in) :: key, data\n    class(avl_tree_t), intent(inout) :: tree\n\n    logical :: fix_balance\n\n    fix_balance = .false.\n    call insertion_search (less_than, insertion, key, data, tree%p, fix_balance)\n  end subroutine avl_insert_or_modify\n\n  recursive subroutine insertion_search (less_than, insertion, key, data, p, fix_balance)\n    procedure(avl_less_than_t) :: less_than\n    procedure(avl_insertion_t) :: insertion\n    class(*), intent(in) :: key, data\n    type(avl_node_t), pointer, intent(inout) :: p\n    logical, intent(inout) :: fix_balance\n\n    type(avl_node_t), pointer :: p1, p2\n\n    if (.not. associated (p)) then\n       ! The key was not found. Make a new node.\n       allocate (p)\n       p%key = key\n       p%left => null ()\n       p%right => null ()\n       p%bal = 0\n       call insertion (key, data, .true., p)\n       fix_balance = .true.\n    else if (less_than (key, p%key)) then\n       ! Continue searching.\n       call insertion_search (less_than, insertion, key, data, p%left, fix_balance)\n       if (fix_balance) then\n          ! A new node has been inserted on the left side.\n          select case (p%bal)\n          case (1)\n             p%bal = 0\n             fix_balance = .false.\n          case (0)\n             p%bal = -1\n          case (-1)\n             ! Rebalance.\n             p1 => p%left\n             select case (p1%bal)\n             case (-1)\n                ! A single LL rotation.\n                p%left => p1%right\n                p1%right => p\n                p%bal = 0\n                p => p1\n                p%bal = 0\n                fix_balance = .false.\n             case (0, 1)\n                ! A double LR rotation.\n                p2 => p1%right\n                p1%right => p2%left\n                p2%left => p1\n                p%left => p2%right\n                p2%right => p\n                p%bal = -(min (p2%bal, 0))\n                p1%bal = -(max (p2%bal, 0))\n                p => p2\n                p%bal = 0\n                fix_balance = .false.\n             case default\n                error stop\n             end select\n          case default\n             error stop\n          end select\n       end if\n    else if (less_than (p%key, key)) then\n       call insertion_search (less_than, insertion, key, data, p%right, fix_balance)\n       if (fix_balance) then\n          ! A new node has been inserted on the right side.\n          select case (p%bal)\n          case (-1)\n             p%bal = 0\n             fix_balance = .false.\n          case (0)\n             p%bal = 1\n          case (1)\n             ! Rebalance.\n             p1 => p%right\n             select case (p1%bal)\n             case (1)\n                ! A single RR rotation.\n                p%right => p1%left\n                p1%left => p\n                p%bal = 0\n                p => p1\n                p%bal = 0\n                fix_balance = .false.\n             case (-1, 0)\n                ! A double RL rotation.\n                p2 => p1%left\n                p1%left => p2%right\n                p2%right => p1\n                p%right => p2%left\n                p2%left => p\n                p%bal = -(max (p2%bal, 0))\n                p1%bal = -(min (p2%bal, 0))\n                p => p2\n                p%bal = 0\n                fix_balance = .false.\n             case default\n                error stop\n             end select\n          case default\n             error stop\n          end select\n       end if\n    else\n       ! The key was found. The pointer p points to an existing node.\n       call insertion (key, data, .false., p)\n    end if\n  end subroutine insertion_search\n\n  subroutine avl_delete_with_found (less_than, key, tree, found)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    class(avl_tree_t), intent(inout) :: tree\n    logical, intent(out) :: found\n\n    logical :: fix_balance\n\n    fix_balance = .false.\n    call deletion_search (less_than, key, tree%p, fix_balance, found)\n  end subroutine avl_delete_with_found\n\n  subroutine avl_delete_without_found (less_than, key, tree)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    class(avl_tree_t), intent(inout) :: tree\n\n    logical :: found\n\n    call avl_delete_with_found (less_than, key, tree, found)\n  end subroutine avl_delete_without_found\n\n  recursive subroutine deletion_search (less_than, key, p, fix_balance, found)\n    procedure(avl_less_than_t) :: less_than\n    class(*), intent(in) :: key\n    type(avl_node_t), pointer, intent(inout) :: p\n    logical, intent(inout) :: fix_balance\n    logical, intent(out) :: found\n\n    type(avl_node_t), pointer :: q\n\n    if (.not. associated (p)) then\n       ! The key is not in the tree.\n       found = .false.\n    else if (less_than (key, p%key)) then\n       call deletion_search (less_than, key, p%left, fix_balance, found)\n       if (fix_balance) call balance_for_shrunken_left (p, fix_balance)\n    else if (less_than (p%key, key)) then\n       call deletion_search (less_than, key, p%right, fix_balance, found)\n       if (fix_balance) call balance_for_shrunken_right (p, fix_balance)\n    else\n       q => p\n       if (.not. associated (q%right)) then\n          p => q%left\n          fix_balance = .true.\n       else if (.not. associated (q%left)) then\n          p => q%right\n          fix_balance = .true.\n       else\n          call del (q%left, q, fix_balance)\n          if (fix_balance) call balance_for_shrunken_left (p, fix_balance)\n       end if\n       deallocate (q)\n       found = .true.\n    end if\n  end subroutine deletion_search\n\n  recursive subroutine del (r, q, fix_balance)\n    type(avl_node_t), pointer, intent(inout) :: r, q\n    logical, intent(inout) :: fix_balance\n\n    if (associated (r%right)) then\n       call del (r%right, q, fix_balance)\n       if (fix_balance) call balance_for_shrunken_right (r, fix_balance)\n    else\n       q%key = r%key\n       q%data = r%data\n       q => r\n       r => r%left\n       fix_balance = .true.\n    end if\n  end subroutine del\n\n  subroutine balance_for_shrunken_left (p, fix_balance)\n    type(avl_node_t), pointer, intent(inout) :: p\n    logical, intent(inout) :: fix_balance\n\n    ! The left side has lost a node.\n\n    type(avl_node_t), pointer :: p1, p2\n\n    if (.not. fix_balance) error stop\n\n    select case (p%bal)\n    case (-1)\n       p%bal = 0\n    case (0)\n       p%bal = 1\n       fix_balance = .false.\n    case (1)\n       ! Rebalance.\n       p1 => p%right\n       select case (p1%bal)\n       case (0)\n          ! A single RR rotation.\n          p%right => p1%left\n          p1%left => p\n          p%bal = 1\n          p1%bal = -1\n          p => p1\n          fix_balance = .false.\n       case (1)\n          ! A single RR rotation.\n          p%right => p1%left\n          p1%left => p\n          p%bal = 0\n          p1%bal = 0\n          p => p1\n          fix_balance = .true.\n       case (-1)\n          ! A double RL rotation.\n          p2 => p1%left\n          p1%left => p2%right\n          p2%right => p1\n          p%right => p2%left\n          p2%left => p\n          p%bal = -(max (p2%bal, 0))\n          p1%bal = -(min (p2%bal, 0))\n          p => p2\n          p2%bal = 0\n       case default\n          error stop\n       end select\n    case default\n       error stop\n    end select\n  end subroutine balance_for_shrunken_left\n\n  subroutine balance_for_shrunken_right (p, fix_balance)\n    type(avl_node_t), pointer, intent(inout) :: p\n    logical, intent(inout) :: fix_balance\n\n    ! The right side has lost a node.\n\n    type(avl_node_t), pointer :: p1, p2\n\n    if (.not. fix_balance) error stop\n\n    select case (p%bal)\n    case (1)\n       p%bal = 0\n    case (0)\n       p%bal = -1\n       fix_balance = .false.\n    case (-1)\n       ! Rebalance.\n       p1 => p%left\n       select case (p1%bal)\n       case (0)\n          ! A single LL rotation.\n          p%left => p1%right\n          p1%right => p\n          p1%bal = 1\n          p%bal = -1\n          p => p1\n          fix_balance = .false.\n       case (-1)\n          ! A single LL rotation.\n          p%left => p1%right\n          p1%right => p\n          p1%bal = 0\n          p%bal = 0\n          p => p1\n          fix_balance = .true.\n       case (1)\n          ! A double LR rotation.\n          p2 => p1%right\n          p1%right => p2%left\n          p2%left => p1\n          p%left => p2%right\n          p2%right => p\n          p%bal = -(min (p2%bal, 0))\n          p1%bal = -(max (p2%bal, 0))\n          p => p2\n          p2%bal = 0\n       case default\n          error stop\n       end select\n    case default\n       error stop\n    end select\n  end subroutine balance_for_shrunken_right\n\n  function avl_size (tree) result (size)\n    class(avl_tree_t), intent(in) :: tree\n    integer :: size\n\n    size = traverse (tree%p)\n\n  contains\n\n    recursive function traverse (p) result (size)\n      type(avl_node_t), pointer, intent(in) :: p\n      integer :: size\n\n      if (associated (p)) then\n         ! The order of traversal is arbitrary.\n         size = 1 + traverse (p%left) + traverse (p%right)\n      else\n         size = 0\n      end if\n    end function traverse\n\n  end function avl_size\n\n  function avl_pointer_pairs (tree) result (lst)\n    class(avl_tree_t), intent(in) :: tree\n    type(avl_pointer_pair_t), pointer :: lst\n\n    ! Reverse in-order traversal of the tree, to produce a CONS-list\n    ! of pointers to the contents.\n\n    lst => null ()\n    if (associated (tree%p)) lst => traverse (tree%p, lst)\n\n  contains\n\n    recursive function traverse (p, lst1) result (lst2)\n      type(avl_node_t), pointer, intent(in) :: p\n      type(avl_pointer_pair_t), pointer, intent(in) :: lst1\n      type(avl_pointer_pair_t), pointer :: lst2\n\n      type(avl_pointer_pair_t), pointer :: new_entry\n\n      lst2 => lst1\n      if (associated (p%right)) lst2 => traverse (p%right, lst2)\n      allocate (new_entry)\n      new_entry%p_key => p%key\n      new_entry%p_data => p%data\n      new_entry%next => lst2\n      lst2 => new_entry\n      if (associated (p%left)) lst2 => traverse (p%left, lst2)\n    end function traverse\n\n  end function avl_pointer_pairs\n\n  subroutine avl_write (write_key_data, unit, tree)\n    procedure(avl_key_data_writer_t) :: write_key_data\n    integer, intent(in) :: unit\n    class(avl_tree_t), intent(in) :: tree\n\n    character(len = *), parameter :: tab = achar (9)\n\n    type(avl_node_t), pointer :: p\n\n    p => tree%p\n    if (.not. associated (p)) then\n       continue\n    else\n       call traverse (p%left, 1, .true.)\n       call write_key_data (unit, p%key, p%data)\n       write (unit, '(2A, \"depth = \", I0, \"  bal = \", I0)') tab, tab, 0, p%bal\n       call traverse (p%right, 1, .false.)\n    end if\n\n  contains\n\n    recursive subroutine traverse (p, depth, left)\n      type(avl_node_t), pointer, intent(in) :: p\n      integer, value :: depth\n      logical, value :: left\n\n      if (.not. associated (p)) then\n         continue\n      else\n         call traverse (p%left, depth + 1, .true.)\n         call pad (depth, left)\n         call write_key_data (unit, p%key, p%data)\n         write (unit, '(2A, \"depth = \", I0, \"  bal = \", I0)') tab, tab, depth, p%bal\n         call traverse (p%right, depth + 1, .false.)\n      end if\n    end subroutine traverse\n\n    subroutine pad (depth, left)\n      integer, value :: depth\n      logical, value :: left\n\n      integer :: i\n\n      do i = 1, depth\n         write (unit, '(2X)', advance = 'no')\n      end do\n    end subroutine pad\n\n  end subroutine avl_write\n\n  subroutine avl_check (tree)\n    use, intrinsic :: iso_fortran_env, only: error_unit\n    class(avl_tree_t), intent(in) :: tree\n\n    type(avl_node_t), pointer :: p\n    integer :: height_L, height_R\n\n    p => tree%p\n    call get_heights (p, height_L, height_R)\n    call check_heights (height_L, height_R)\n\n  contains\n\n    recursive subroutine get_heights (p, height_L, height_R)\n      type(avl_node_t), pointer, intent(in) :: p\n      integer, intent(out) :: height_L, height_R\n\n      integer :: height_LL, height_LR\n      integer :: height_RL, height_RR\n\n      height_L = 0\n      height_R = 0\n      if (associated (p)) then\n         call get_heights (p%left, height_LL, height_LR)\n         call check_heights (height_LL, height_LR)\n         height_L = height_LL + height_LR\n         call get_heights (p%right, height_RL, height_RR)\n         call check_heights (height_RL, height_RR)\n         height_R = height_RL + height_RR\n      end if\n    end subroutine get_heights\n\n    subroutine check_heights (height_L, height_R)\n      integer, value :: height_L, height_R\n\n      if (2 <= abs (height_L - height_R)) then\n         write (error_unit, '(\"*** AVL condition violated ***\")')\n         error stop\n      end if\n    end subroutine check_heights\n\n  end subroutine avl_check\n\nend module avl_trees\n\nprogram avl_trees_demo\n  use, intrinsic :: iso_fortran_env, only: output_unit\n  use, non_intrinsic :: avl_trees\n\n  implicit none\n\n  integer, parameter :: keys_count = 20\n\n  type(avl_tree_t) :: tree\n  logical :: found\n  class(*), allocatable :: retval\n  integer :: the_keys(1:keys_count)\n  integer :: i, j\n\n  do i = 1, keys_count\n     the_keys(i) = i\n  end do\n  call fisher_yates_shuffle (the_keys, keys_count)\n\n  call avl_check (tree)\n  do i = 1, keys_count\n     call avl_insert (lt, the_keys(i), real (the_keys(i)), tree)\n     call avl_check (tree)\n     if (avl_size (tree) /= i) error stop\n     do j = 1, keys_count\n        if (avl_contains (lt, the_keys(j), tree) .neqv. (j <= i)) error stop\n     end do\n     do j = 1, keys_count\n        call avl_retrieve (lt, the_keys(j), tree, found, retval)\n        if (found .neqv. (j <= i)) error stop\n        if (found) then\n           ! This crazy way to write \u2018/=\u2019 is to quell those tiresome\n           ! warnings about using \u2018==\u2019 or \u2018/=\u2019 with floating point\n           ! numbers. Floating point numbers can represent integers\n           ! *exactly*.\n           if (0 < abs (real_cast (retval) - real (the_keys(j)))) error stop\n        end if\n        if (found) then\n           block\n             character(len = 1), parameter :: ch = '*'\n             !\n             ! Try replacing the data with a character and then\n             ! restoring the number.\n             !\n             call avl_insert (lt, the_keys(j), ch, tree)\n             call avl_retrieve (lt, the_keys(j), tree, found, retval)\n             if (.not. found) error stop\n             if (char_cast (retval) /= ch) error stop\n             call avl_insert (lt, the_keys(j), real (the_keys(j)), tree)\n             call avl_retrieve (lt, the_keys(j), tree, found, retval)\n             if (.not. found) error stop\n             if (0 < abs (real_cast (retval) - real (the_keys(j)))) error stop\n           end block\n        end if\n     end do\n  end do\n\n  write (output_unit, '(70(\"-\"))')\n  call avl_write (int_real_writer, output_unit, tree)\n  write (output_unit, '(70(\"-\"))')\n  call print_contents (output_unit, tree)\n  write (output_unit, '(70(\"-\"))')\n\n  call fisher_yates_shuffle (the_keys, keys_count)\n  do i = 1, keys_count\n     call avl_delete (lt, the_keys(i), tree)\n     call avl_check (tree)\n     if (avl_size (tree) /= keys_count - i) error stop\n     ! Try deleting a second time.\n     call avl_delete (lt, the_keys(i), tree)\n     call avl_check (tree)\n     if (avl_size (tree) /= keys_count - i) error stop\n     do j = 1, keys_count\n        if (avl_contains (lt, the_keys(j), tree) .neqv. (i < j)) error stop\n     end do\n     do j = 1, keys_count\n        call avl_retrieve (lt, the_keys(j), tree, found, retval)\n        if (found .neqv. (i < j)) error stop\n        if (found) then\n           if (0 < abs (real_cast (retval) - real (the_keys(j)))) error stop\n        end if\n     end do\n  end do\n\ncontains\n\n  subroutine fisher_yates_shuffle (keys, n)\n    integer, intent(inout) :: keys(*)\n    integer, intent(in) :: n\n\n    integer :: i, j\n    real :: randnum\n    integer :: tmp\n\n    do i = 1, n - 1\n       call random_number (randnum)\n       j = i + floor (randnum * (n - i + 1))\n       tmp = keys(i)\n       keys(i) = keys(j)\n       keys(j) = tmp\n    end do\n  end subroutine fisher_yates_shuffle\n\n  function int_cast (u) result (v)\n    class(*), intent(in) :: u\n    integer :: v\n\n    select type (u)\n    type is (integer)\n       v = u\n    class default\n       ! This case is not handled.\n       error stop\n    end select\n  end function int_cast\n\n  function real_cast (u) result (v)\n    class(*), intent(in) :: u\n    real :: v\n\n    select type (u)\n    type is (real)\n       v = u\n    class default\n       ! This case is not handled.\n       error stop\n    end select\n  end function real_cast\n\n  function char_cast (u) result (v)\n    class(*), intent(in) :: u\n    character(len = 1) :: v\n\n    select type (u)\n    type is (character(*))\n       v = u\n    class default\n       ! This case is not handled.\n       error stop\n    end select\n  end function char_cast\n\n  function lt (u, v) result (u_lt_v)\n    class(*), intent(in) :: u, v\n    logical :: u_lt_v\n\n    select type (u)\n    type is (integer)\n       select type (v)\n       type is (integer)\n          u_lt_v = (u < v)\n       class default\n          ! This case is not handled.\n          error stop\n       end select\n    class default\n       ! This case is not handled.\n       error stop\n    end select\n  end function lt\n\n  subroutine int_real_writer (unit, key, data)\n    integer, intent(in) :: unit\n    class(*), intent(in) :: key, data\n\n    write (unit, '(\"(\", I0, \", \", F0.1, \")\")', advance = 'no') &\n         & int_cast(key), real_cast(data)\n  end subroutine int_real_writer\n\n  subroutine print_contents (unit, tree)\n    integer, intent(in) :: unit\n    class(avl_tree_t), intent(in) :: tree\n\n    type(avl_pointer_pair_t), pointer :: ppairs, pp\n\n    write (unit, '(\"tree size = \", I0)') avl_size (tree)\n    ppairs => avl_pointer_pairs (tree)\n    pp => ppairs\n    do while (associated (pp))\n       write (unit, '(\"(\", I0, \", \", F0.1, \")\")') &\n            & int_cast (pp%p_key), real_cast (pp%p_data)\n       pp => pp%next\n    end do\n    if (associated (ppairs)) deallocate (ppairs)\n  end subroutine print_contents\n\nend program avl_trees_demo\n\n\nOutput:\n\n$ gfortran -std=f2018 -O2 -g -fcheck=all -Wall -Wextra -Wno-unused-dummy-argument avl_trees-fortran.f90 && ./a.out\n----------------------------------------------------------------------\n      (1, 1.0)          depth = 3  bal = 1\n        (2, 2.0)                depth = 4  bal = 0\n    (3, 3.0)            depth = 2  bal = -1\n      (4, 4.0)          depth = 3  bal = 0\n  (5, 5.0)              depth = 1  bal = 0\n      (6, 6.0)          depth = 3  bal = 1\n        (7, 7.0)                depth = 4  bal = 0\n    (8, 8.0)            depth = 2  bal = 0\n        (9, 9.0)                depth = 4  bal = 0\n      (10, 10.0)                depth = 3  bal = 0\n        (11, 11.0)              depth = 4  bal = 0\n(12, 12.0)              depth = 0  bal = 0\n      (13, 13.0)                depth = 3  bal = 1\n        (14, 14.0)              depth = 4  bal = 0\n    (15, 15.0)          depth = 2  bal = -1\n      (16, 16.0)                depth = 3  bal = 0\n  (17, 17.0)            depth = 1  bal = -1\n      (18, 18.0)                depth = 3  bal = 0\n    (19, 19.0)          depth = 2  bal = 0\n      (20, 20.0)                depth = 3  bal = 0\n----------------------------------------------------------------------\ntree size = 20\n(1, 1.0)\n(2, 2.0)\n(3, 3.0)\n(4, 4.0)\n(5, 5.0)\n(6, 6.0)\n(7, 7.0)\n(8, 8.0)\n(9, 9.0)\n(10, 10.0)\n(11, 11.0)\n(12, 12.0)\n(13, 13.0)\n(14, 14.0)\n(15, 15.0)\n(16, 16.0)\n(17, 17.0)\n(18, 18.0)\n(19, 19.0)\n(20, 20.0)\n----------------------------------------------------------------------\n", "explain": "See also ATS and Scheme, where persistent (\u2018immutable\u2019) versions of this algorithm are implemented.\nThe following AVL tree implementation is for keys and data of any type, mixed freely. This is made possible by Fortran 2008\u2019s unlimited polymorphism. The demonstration is for INTEGER keys and mixtures of REAL and CHARACTER data.\nSupported operations include insertion of a key-data pair, deletion, tree size computed by traversal, output of the full contents as an ordered linked list, printing a representation of the tree, checking that the AVL condition is satisfied. There are actually some slightly more general mechanisms available, in terms of which the foregoing operations are written.\nThe demonstration is randomized, so this is just one example of a run.\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Go", "code": "\n\npackage avl\n\n// AVL tree adapted from Julienne Walker's presentation at\n// http://eternallyconfuzzled.com/tuts/datastructures/jsw_tut_avl.aspx.\n// This port uses similar indentifier names.\n\n// The Key interface must be supported by data stored in the AVL tree.\ntype Key interface {\n    Less(Key) bool\n    Eq(Key) bool\n}\n\n// Node is a node in an AVL tree.\ntype Node struct {\n    Data    Key      // anything comparable with Less and Eq.\n    Balance int      // balance factor\n    Link    [2]*Node // children, indexed by \"direction\", 0 or 1.\n}\n\n// A little readability function for returning the opposite of a direction,\n// where a direction is 0 or 1.  Go inlines this.\n// Where JW writes !dir, this code has opp(dir).\nfunc opp(dir int) int {\n    return 1 - dir\n}\n\n// single rotation\nfunc single(root *Node, dir int) *Node {\n    save := root.Link[opp(dir)]\n    root.Link[opp(dir)] = save.Link[dir]\n    save.Link[dir] = root\n    return save\n}\n\n// double rotation\nfunc double(root *Node, dir int) *Node {\n    save := root.Link[opp(dir)].Link[dir]\n\n    root.Link[opp(dir)].Link[dir] = save.Link[opp(dir)]\n    save.Link[opp(dir)] = root.Link[opp(dir)]\n    root.Link[opp(dir)] = save\n\n    save = root.Link[opp(dir)]\n    root.Link[opp(dir)] = save.Link[dir]\n    save.Link[dir] = root\n    return save\n}\n\n// adjust valance factors after double rotation\nfunc adjustBalance(root *Node, dir, bal int) {\n    n := root.Link[dir]\n    nn := n.Link[opp(dir)]\n    switch nn.Balance {\n    case 0:\n        root.Balance = 0\n        n.Balance = 0\n    case bal:\n        root.Balance = -bal\n        n.Balance = 0\n    default:\n        root.Balance = 0\n        n.Balance = bal\n    }\n    nn.Balance = 0\n}\n\nfunc insertBalance(root *Node, dir int) *Node {\n    n := root.Link[dir]\n    bal := 2*dir - 1\n    if n.Balance == bal {\n        root.Balance = 0\n        n.Balance = 0\n        return single(root, opp(dir))\n    }\n    adjustBalance(root, dir, bal)\n    return double(root, opp(dir))\n}\n\nfunc insertR(root *Node, data Key) (*Node, bool) {\n    if root == nil {\n        return &Node{Data: data}, false\n    }\n    dir := 0\n    if root.Data.Less(data) {\n        dir = 1\n    }\n    var done bool\n    root.Link[dir], done = insertR(root.Link[dir], data)\n    if done {\n        return root, true\n    }\n    root.Balance += 2*dir - 1\n    switch root.Balance {\n    case 0:\n        return root, true\n    case 1, -1:\n        return root, false\n    }\n    return insertBalance(root, dir), true\n}\n\n// Insert a node into the AVL tree.\n// Data is inserted even if other data with the same key already exists.\nfunc Insert(tree **Node, data Key) {\n    *tree, _ = insertR(*tree, data)\n}\n\nfunc removeBalance(root *Node, dir int) (*Node, bool) {\n    n := root.Link[opp(dir)]\n    bal := 2*dir - 1\n    switch n.Balance {\n    case -bal:\n        root.Balance = 0\n        n.Balance = 0\n        return single(root, dir), false\n    case bal:\n        adjustBalance(root, opp(dir), -bal)\n        return double(root, dir), false\n    }\n    root.Balance = -bal\n    n.Balance = bal\n    return single(root, dir), true\n}\n\nfunc removeR(root *Node, data Key) (*Node, bool) {\n    if root == nil {\n        return nil, false\n    }\n    if root.Data.Eq(data) {\n        switch {\n        case root.Link[0] == nil:\n            return root.Link[1], false\n        case root.Link[1] == nil:\n            return root.Link[0], false\n        }\n        heir := root.Link[0]\n        for heir.Link[1] != nil {\n            heir = heir.Link[1]\n        }\n        root.Data = heir.Data\n        data = heir.Data\n    }\n    dir := 0\n    if root.Data.Less(data) {\n        dir = 1\n    }\n    var done bool\n    root.Link[dir], done = removeR(root.Link[dir], data)\n    if done {\n        return root, true\n    }\n    root.Balance += 1 - 2*dir\n    switch root.Balance {\n    case 1, -1:\n        return root, true\n    case 0:\n        return root, false\n    }\n    return removeBalance(root, dir)\n}\n\n// Remove a single item from an AVL tree.\n// If key does not exist, function has no effect.\nfunc Remove(tree **Node, data Key) {\n    *tree, _ = removeR(*tree, data)\n}\n\n\npackage main\n\nimport (\n    \"encoding/json\"\n    \"fmt\"\n    \"log\"\n\n    \"avl\"\n)\n\ntype intKey int\n\n// satisfy avl.Key\nfunc (k intKey) Less(k2 avl.Key) bool { return k < k2.(intKey) }\nfunc (k intKey) Eq(k2 avl.Key) bool   { return k == k2.(intKey) }\n\n// use json for cheap tree visualization\nfunc dump(tree *avl.Node) {\n    b, err := json.MarshalIndent(tree, \"\", \"   \")\n    if err != nil {\n        log.Fatal(err)\n    }\n    fmt.Println(string(b))\n}\n\nfunc main() {\n    var tree *avl.Node\n    fmt.Println(\"Empty tree:\")\n    dump(tree)\n\n    fmt.Println(\"\\nInsert test:\")\n    avl.Insert(&tree, intKey(3))\n    avl.Insert(&tree, intKey(1))\n    avl.Insert(&tree, intKey(4))\n    avl.Insert(&tree, intKey(1))\n    avl.Insert(&tree, intKey(5))\n    dump(tree)\n\n    fmt.Println(\"\\nRemove test:\")\n    avl.Remove(&tree, intKey(3))\n    avl.Remove(&tree, intKey(1))\n    dump(tree)\n}\n\n\nOutput:\nEmpty tree:\nnull\n\nInsert test:\n{\n   \"Data\": 3,\n   \"Balance\": 0,\n   \"Link\": [\n      {\n         \"Data\": 1,\n         \"Balance\": -1,\n         \"Link\": [\n            {\n               \"Data\": 1,\n               \"Balance\": 0,\n               \"Link\": [\n                  null,\n                  null\n               ]\n            },\n            null\n         ]\n      },\n      {\n         \"Data\": 4,\n         \"Balance\": 1,\n         \"Link\": [\n            null,\n            {\n               \"Data\": 5,\n               \"Balance\": 0,\n               \"Link\": [\n                  null,\n                  null\n               ]\n            }\n         ]\n      }\n   ]\n}\n\nRemove test:\n{\n   \"Data\": 4,\n   \"Balance\": 0,\n   \"Link\": [\n      {\n         \"Data\": 1,\n         \"Balance\": 0,\n         \"Link\": [\n            null,\n            null\n         ]\n      },\n      {\n         \"Data\": 5,\n         \"Balance\": 0,\n         \"Link\": [\n            null,\n            null\n         ]\n      }\n   ]\n}\n\n", "explain": "A package:\nA demonstration program:\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program avltree2.s   */\n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n\n/*******************************************/\n/* Constantes                              */\n/*******************************************/\n.equ STDOUT, 1           @ Linux output console\n.equ EXIT,   1           @ Linux syscall\n.equ WRITE,  4           @ Linux syscall\n.equ BRK,    0x2d        @ Linux syscall\n.equ CHARPOS,     '@'\n\n.equ NBVAL,    12\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure tree     */\n    .struct  0\ntree_root:                             @ root pointer (or node right)\n    .struct  tree_root + 4 \ntree_size:                             @ number of element of tree\n    .struct  tree_size + 4 \ntree_suite:\n    .struct  tree_suite + 12           @ for alignement to node\ntree_fin:\n/* structure node tree */\n    .struct  0\nnode_right:                            @ right pointer\n    .struct  node_right + 4 \nnode_left:                             @ left pointer\n    .struct  node_left + 4 \nnode_value:                            @ element value\n    .struct  node_value + 4 \nnode_height:                          @ element value\n    .struct  node_height + 4 \nnode_parent:                          @ element value\n    .struct  node_parent + 4 \nnode_fin:\n/* structure queue*/\n    .struct  0\nqueue_begin:                           @ next pointer\n    .struct  queue_begin + 4 \nqueue_end:                             @ element value\n    .struct  queue_end + 4 \nqueue_fin:\n/* structure node queue    */\n    .struct  0\nqueue_node_next:                       @ next pointer\n    .struct  queue_node_next + 4 \nqueue_node_value:                      @ element value\n    .struct  queue_node_value + 4 \nqueue_node_fin:\n/*******************************************/\n/* Initialized data                        */\n/*******************************************/\n.data\nszMessPreOrder:       .asciz \"PreOrder\u00a0:\\n\"\nszCarriageReturn:     .asciz \"\\n\"\n/* datas error display */\nszMessErreur:         .asciz \"Error detected.\\n\"\nszMessKeyDbl:         .asciz \"Key exists in tree.\\n\"\nszMessInsInv:         .asciz \"Insertion in inverse order.\\n\"\n/* datas message display */\nszMessResult:         .asciz \"Ele: @ G: @ D: @ val @ h @ pere @\\n\"\nsValue:               .space 12,' '\n                      .asciz \"\\n\"\n/*******************************************/\n/* UnInitialized data                      */\n/*******************************************/\n.bss \nsZoneConv:            .skip 24\nstTree:               .skip tree_fin    @ place to structure tree\nstTree1:              .skip tree_fin    @ place to structure tree\nstQueue:              .skip queue_fin   @ place to structure queue\n/*******************************************/\n/*  code section                           */\n/*******************************************/\n.text\n.global main \nmain: \n    mov r8,#1                           @ node tree value\n1:                                      @ loop insertion in order\n    ldr r0,iAdrstTree                   @ structure tree address\n    mov r1,r8\n    bl insertElement                    @ add element value r1\n    cmp r0,#-1\n    beq 99f\n    //ldr r3,iAdrstTree                 @ tree root address (begin structure)\n    //ldr r0,[r3,#tree_root]\n    //ldr r1,iAdrdisplayElement           @ function to execute\n    //bl preOrder\n    add r8,#1                           @ increment value\n    cmp r8,#NBVAL                       @ end\u00a0?\n    ble 1b                              @ no -> loop\n\n    ldr r0,iAdrstTree                   @ structure tree address\n    mov r1,#11                          @ verif key dobble\n    bl insertElement                    @ add element value r1\n    cmp r0,#-1\n    bne 2f\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n2:\n    ldr r0,iAdrszMessPreOrder           @ load verification\n    bl affichageMess\n    ldr r3,iAdrstTree                   @ tree root address (begin structure)\n    ldr r0,[r3,#tree_root]\n    ldr r1,iAdrdisplayElement           @ function to execute\n    bl preOrder\n    \n\n    ldr r0,iAdrszMessInsInv\n    bl affichageMess\n    mov r8,#NBVAL                       @ node tree value\n3:                                      @ loop insertion inverse order\n    ldr r0,iAdrstTree1                  @ structure tree address\n    mov r1,r8\n    bl insertElement                    @ add element value r1\n    cmp r0,#-1\n    beq 99f\n    sub r8,#1                           @ increment value\n    cmp r8,#0                           @ end\u00a0?\n    bgt 3b                              @ no -> loop\n\n    ldr r0,iAdrszMessPreOrder           @ load verification\n    bl affichageMess\n    ldr r3,iAdrstTree1                  @ tree root address (begin structure)\n    ldr r0,[r3,#tree_root]\n    ldr r1,iAdrdisplayElement           @ function to execute\n    bl preOrder\n\n                                        @ search value\n    ldr r0,iAdrstTree1                  @ tree root address (begin structure)\n    mov r1,#11                          @ value to search\n    bl searchTree\n    cmp r0,#-1\n    beq 100f\n    mov r2,r0\n    ldr r0,iAdrszMessKeyDbl             @ key exists\n    bl affichageMess\n                                        @ suppresssion previous value\n    mov r0,r2\n    ldr r1,iAdrstTree1\n    bl supprimer\n\n    ldr r0,iAdrszMessPreOrder           @ verification\n    bl affichageMess\n    ldr r3,iAdrstTree1                  @ tree root address (begin structure)\n    ldr r0,[r3,#tree_root]\n    ldr r1,iAdrdisplayElement           @ function to execute\n    bl preOrder\n\n    b 100f\n99:                                     @ display error\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n100:                                    @ standard end of the program\n    mov r7, #EXIT                       @ request to exit program\n    svc 0                               @ perform system call\niAdrszMessPreOrder:        .int szMessPreOrder\niAdrszMessErreur:          .int szMessErreur\niAdrszCarriageReturn:      .int szCarriageReturn\niAdrstTree:                .int stTree\niAdrstTree1:               .int stTree1\niAdrstQueue:               .int stQueue\niAdrdisplayElement:        .int displayElement\niAdrszMessInsInv:          .int szMessInsInv\n/******************************************************************/\n/*     insert element in the tree                                 */ \n/******************************************************************/\n/* r0 contains the address of the tree structure */\n/* r1 contains the value of element              */\n/* r0 returns address of element or - 1 if error */\ninsertElement:                        @ INFO: insertElement\n    push {r1-r8,lr}                   @ save  registers \n    mov r7,r0                         @ save head\n    mov r0,#node_fin                  @ reservation place one element\n    bl allocHeap\n    cmp r0,#-1                        @ allocation error\n    beq 100f\n    mov r5,r0\n    str r1,[r5,#node_value]           @ store value in address heap\n    mov r3,#0\n    str r3,[r5,#node_left]            @ init left pointer with zero\n    str r3,[r5,#node_right]           @ init right pointer with zero\n    str r3,[r5,#node_height]          @ init balance with zero\n    ldr r2,[r7,#tree_size]            @ load tree size\n    cmp r2,#0                         @ 0 element\u00a0?\n    bne 1f\n    str r5,[r7,#tree_root]            @ yes -> store in root\n    b 4f\n1:                                    @ else search free address in tree\n    ldr r3,[r7,#tree_root]            @ start with address root\n2:                                    @ begin loop to insertion\n    ldr r4,[r3,#node_value]           @ load key \n    cmp r1,r4\n    beq 6f                            @ key equal\n    blt 3f                            @ key <\n                                      @ key >  insertion right\n    ldr r8,[r3,#node_right]           @ node empty\u00a0?\n    cmp r8,#0\n    movne r3,r8                       @ no -> next node\n    bne 2b                            @ and loop\n    str r5,[r3,#node_right]           @ store node address in right pointer\n    b 4f\n3:                                    @ left\n    ldr r8,[r3,#node_left]            @ left pointer empty\u00a0?\n    cmp r8,#0\n    movne r3,r8                       @\n    bne 2b                            @ no -> loop\n    str r5,[r3,#node_left]            @ store node address in left pointer\n4:\n    str r3,[r5,#node_parent]          @ store parent\n    mov r4,#1\n    str r4,[r5,#node_height]          @ store height = 1\n    mov r0,r5                         @ begin node to requilbrate\n    mov r1,r7                         @ head address\n    bl equilibrer\n\n5:\n    add r2,#1                        @ increment tree size\n    str r2,[r7,#tree_size]\n    mov r0,#0\n    b 100f\n6:                                   @ key equal\u00a0?\n    ldr r0,iAdrszMessKeyDbl\n    bl affichageMess\n    mov r0,#-1\n    b 100f\n100:\n    pop {r1-r8,lr}                    @ restaur registers\n    bx lr                             @ return\niAdrszMessKeyDbl:           .int szMessKeyDbl\n/******************************************************************/\n/*     equilibrer after insertion                                    */ \n/******************************************************************/\n/* r0 contains the address of the node       */\n/* r1 contains the address of head */\nequilibrer:                       @ INFO: equilibrer\n    push {r1-r8,lr}               @ save  registers \n    mov r3,#0                     @ balance factor\n1:                                @ begin loop\n    ldr r5,[r0,#node_parent]      @ load father\n    cmp r5,#0                     @ end\u00a0?\n    beq 5f\n    cmp r3,#2                     @ right tree too long\n    beq 5f\n    cmp r3,#-2                    @ left tree too long\n    beq 5f\n    mov r6,r0                     @ s = current\n    ldr r0,[r6,#node_parent]      @ current = father\n    ldr r7,[r0,#node_left]\n    cmp r7,#0\n    ldrne r8,[r7,#node_height]     @ height left tree \n    moveq r8,#0\n    ldr r7,[r0,#node_right]\n    cmp r7,#0\n    ldrne r9,[r7,#node_height]     @ height right tree \n    moveq r9,#0\n    cmp r8,r9\n    addgt r8,#1\n    strgt r8,[r0,#node_height]\n    addle r9,#1\n    strle r9,[r0,#node_height]\n    //\n    ldr r7,[r0,#node_right]\n    cmp r7,#0\n    ldrne r8,[r7,#node_height]\n    moveq r8,#0\n    ldr r7,[r0,#node_left]\n    cmp r7,#0\n    ldrne r9,[r7,#node_height]\n    moveq r9,#0\n    sub r3,r8,r9                    @ compute balance factor\n    b 1b\n5:\n    cmp r3,#2\n    beq 6f\n    cmp r3,#-2\n    beq 6f\n    b 100f\n6:\n    mov r3,r1\n    mov r4,r0\n    mov r1,r6\n    bl equiUnSommet\n                                      @ change head address\u00a0?\n    ldr r2,[r3,#tree_root]\n    cmp r2,r4\n    streq r6,[r3,#tree_root]\n100:\n    pop {r1-r8,lr}                    @ restaur registers\n    bx lr                             @ return\n/******************************************************************/\n/*     equilibre 1 sommet                                     */ \n/******************************************************************/\n/* r0 contains the address of the node       */\n/* r1 contains the address of the node    */\nequiUnSommet:                             @ INFO: equiUnSommet\n    push {r1-r9,lr}                       @ save  registers \n    mov r5,r0                             @ save p\n    mov r6,r1    // s\n    ldr r2,[r5,#node_left]\n    cmp r2,r6\n    bne 5f\n    ldr r7,[r5,#node_right]\n    cmp r7,#0\n    moveq r8,#0\n    ldrne r8,[r7,#node_height]\n    ldr r7,[r5,#node_left]\n    cmp r7,#0\n    moveq r9,#0\n    ldrne r9,[r7,#node_height]\n    sub r3,r8,r9\n    cmp r3,#-2\n    bne 100f\n    ldr r7,[r6,#node_right]\n    cmp r7,#0\n    moveq r8,#0\n    ldrne r8,[r7,#node_height]\n    ldr r7,[r6,#node_left]\n    cmp r7,#0\n    moveq r9,#0\n    ldrne r9,[r7,#node_height]\n    sub r3,r8,r9\n    cmp r3,#1\n    bge 2f\n    mov r0,r5\n    bl rotRight\n    b 100f\n2:\n    mov r0,r6\n    bl rotLeft\n    mov r0,r5\n    bl rotRight\n    b 100f\n\n5:\n    ldr r7,[r5,#node_right]\n    cmp r7,#0\n    moveq r8,#0\n    ldrne r8,[r7,#node_height]\n    ldr r7,[r5,#node_left]\n    cmp r7,#0\n    moveq r9,#0\n    ldrne r9,[r7,#node_height]\n    sub r3,r8,r9\n    cmp r3,#2\n    bne 100f\n    ldr r7,[r6,#node_right]\n    cmp r7,#0\n    moveq r8,#0\n    ldrne r8,[r7,#node_height]\n    ldr r7,[r6,#node_left]\n    cmp r7,#0\n    moveq r9,#0\n    ldrne r9,[r7,#node_height]\n    sub r3,r8,r9\n    cmp r3,#-1\n    ble 2f\n    mov r0,r5\n    bl rotLeft\n    b 100f\n2:\n    mov r0,r6\n    bl rotRight\n    mov r0,r5\n    bl rotLeft\n    b 100f\n\n100:\n    pop {r1-r9,lr}                    @ restaur registers\n    bx lr                             @ return\n/******************************************************************/\n/*     right rotation                                     */ \n/******************************************************************/\n/* r0 contains the address of the node       */\nrotRight:                           @ INFO: rotRight \n    push {r1-r5,lr}                 @ save  registers \n    //   r2                  r2\n    //      r0                   r1\n    //   r1                         r0\n    //      r3                    r3\n    ldr r1,[r0,#node_left]          @ load left children\n    ldr r2,[r0,#node_parent]        @ load father\n    cmp r2,#0                       @ no father\u00a0???\n    beq 2f\n    ldr r3,[r2,#node_left]          @ load left node father\n    cmp r3,r0                       @ equal current node\u00a0?\n    streq r1,[r2,#node_left]        @ yes store left children\n    strne r1,[r2,#node_right]       @ no store right\n2:\n    str r2,[r1,#node_parent]        @ change parent\n    str r1,[r0,#node_parent]\n    ldr r3,[r1,#node_right]\n    str r3,[r0,#node_left]\n    cmp r3,#0\n    strne r0,[r3,#node_parent]      @ change parent node left\n    str r0,[r1,#node_right]\n\n    ldr r3,[r0,#node_left]          @ compute newbalance factor \n    cmp r3,#0\n    moveq r4,#0\n    ldrne r4,[r3,#node_height]\n    ldr r3,[r0,#node_right]\n    cmp r3,#0\n    moveq r5,#0\n    ldrne r5,[r3,#node_height]\n    cmp r4,r5\n    addgt r4,#1\n    strgt r4,[r0,#node_height]\n    addle r5,#1\n    strle r5,[r0,#node_height]\n//\n    ldr r3,[r1,#node_left]         @ compute new balance factor\n    cmp r3,#0\n    moveq r4,#0\n    ldrne r4,[r3,#node_height]\n    ldr r3,[r1,#node_right]\n    cmp r3,#0\n    moveq r5,#0\n    ldrne r5,[r3,#node_height]\n    cmp r4,r5\n    addgt r4,#1\n    strgt r4,[r1,#node_height]\n    addle r5,#1\n    strle r5,[r1,#node_height]\n100:\n    pop {r1-r5,lr}                   @ restaur registers\n    bx lr\n/******************************************************************/\n/*     left rotation                                     */ \n/******************************************************************/\n/* r0 contains the address of the node  sommet     */\nrotLeft:                             @ INFO: rotLeft \n    push {r1-r5,lr}                  @ save  registers \n    //   r2                  r2\n    //      r0                   r1\n    //          r1            r0\n    //        r3                 r3\n    ldr r1,[r0,#node_right]          @ load right children\n    ldr r2,[r0,#node_parent]         @ load father (racine)\n    cmp r2,#0                        @ no father\u00a0???\n    beq 2f\n    ldr r3,[r2,#node_left]           @ load left node father\n    cmp r3,r0                        @ equal current node\u00a0?\n    streq r1,[r2,#node_left]         @ yes store left children\n    strne r1,[r2,#node_right]        @ no store to right\n2:\n    str r2,[r1,#node_parent]         @ change parent of right children\n    str r1,[r0,#node_parent]         @ change parent of sommet\n    ldr r3,[r1,#node_left]           @ left children \n    str r3,[r0,#node_right]          @ left children pivot exists\u00a0? \n    cmp r3,#0\n    strne r0,[r3,#node_parent]       @ yes store in \n    str r0,[r1,#node_left]\n//\n    ldr r3,[r0,#node_left]           @ compute new height for old summit\n    cmp r3,#0\n    moveq r4,#0\n    ldrne r4,[r3,#node_height]       @ left height\n    ldr r3,[r0,#node_right]\n    cmp r3,#0\n    moveq r5,#0\n    ldrne r5,[r3,#node_height]       @ right height\n    cmp r4,r5\n    addgt r4,#1\n    strgt r4,[r0,#node_height]       @ if right > left\n    addle r5,#1\n    strle r5,[r0,#node_height]       @ if left > right\n//\n    ldr r3,[r1,#node_left]           @ compute new height for new\n    cmp r3,#0\n    moveq r4,#0\n    ldrne r4,[r3,#node_height]\n    ldr r3,[r1,#node_right]\n    cmp r3,#0\n    moveq r5,#0\n    ldrne r5,[r3,#node_height]\n    cmp r4,r5\n    addgt r4,#1\n    strgt r4,[r1,#node_height]\n    addle r5,#1\n    strle r5,[r1,#node_height]\n100:\n    pop {r1-r5,lr}                        @ restaur registers\n    bx lr\n/******************************************************************/\n/*     search value in tree                                       */ \n/******************************************************************/\n/* r0 contains the address of structure of tree */\n/* r1 contains the value to search  */\nsearchTree:                           @ INFO: searchTree\n    push {r1-r4,lr}                   @ save  registers \n    ldr r2,[r0,#tree_root]\n\n1:                                    @ begin loop\n    ldr r4,[r2,#node_value]           @ load key \n    cmp r1,r4\n    beq 3f                            @ key equal\n    blt 2f                            @ key <\n                                      @ key >  insertion right\n    ldr r3,[r2,#node_right]           @ node empty\u00a0?\n    cmp r3,#0\n    movne r2,r3                       @ no -> next node\n    bne 1b                            @ and loop\n    mov r0,#-1                        @ not find\n    b 100f\n2:                                    @ left\n    ldr r3,[r2,#node_left]            @ left pointer empty\u00a0?\n    cmp r3,#0\n    movne r2,r3                       @\n    bne 1b                            @ no -> loop\n    mov r0,#-1                        @ not find\n    b 100f\n3:\n    mov r0,r2                         @ return node address\n100:\n    pop {r1-r4,lr}                    @ restaur registers\n    bx lr\n/******************************************************************/\n/*     suppression node                                           */ \n/******************************************************************/\n/* r0 contains the address of the node */\n/* r1 contains structure tree address  */\nsupprimer:                       @ INFO: supprimer\n    push {r1-r8,lr}              @ save  registers \n    ldr r1,[r0,#node_left]\n    cmp r1,#0\n    bne 5f\n    ldr r1,[r0,#node_right]\n    cmp r1,#0\n    bne 5f\n                                 @ is a leaf\n    mov r4,#0\n    ldr r3,[r0,#node_parent]     @ father\n    cmp r3,#0\n    streq r4,[r1,#tree_root]\n    beq 100f\n    ldr r1,[r3,#node_left]\n    cmp r1,r0\n    bne 2f\n    str r4,[r3,#node_left]       @ suppression left children\n    ldr r5,[r3,#node_right]\n    cmp r5,#0\n    moveq r6,#0\n    ldrne r6,[r5,#node_height]\n    add r6,#1\n    str r6,[r3,#node_height]\n    b 3f\n2:                                @ suppression right children\n    str r4,[r3,#node_right]\n    ldr r5,[r3,#node_left]\n    cmp r5,#0\n    moveq r6,#0\n    ldrne r6,[r5,#node_height]\n    add r6,#1\n    str r6,[r3,#node_height]\n3:                                @ new balance\n    mov r0,r3\n    bl equilibrerSupp\n    b 100f\n5:                                @ is not \u00e0 leaf\n    ldr r7,[r0,#node_right]\n    cmp r7,#0\n    beq 7f\n    mov r8,r0\n    mov r0,r7\n6:\n    ldr r6,[r0,#node_left]\n    cmp r6,#0\n    movne r0,r6\n    bne 6b\n    b 9f\n7:\n    ldr r7,[r0,#node_left]         @ search the litle element\n    cmp r7,#0\n    beq 9f\n    mov r8,r0\n    mov r0,r7\n8:\n    ldr r6,[r0,#node_right]        @ search the great element\n    cmp r6,#0\n    movne r0,r6\n    bne 8b\n9:\n    ldr r5,[r0,#node_value]         @ copy value\n    str r5,[r8,#node_value]\n    bl supprimer                    @ suppression node r0\n100:\n    pop {r1-r8,lr}                  @ restaur registers\n    bx lr\n\n/******************************************************************/\n/*     equilibrer after suppression                                   */ \n/******************************************************************/\n/* r0 contains the address of the node       */\n/* r1 contains the address of head */\nequilibrerSupp:                   @ INFO: equilibrerSupp\n    push {r1-r8,lr}               @ save  registers \n    mov r3,#1                     @ balance factor\n    ldr r2,[r1,#tree_root]\n1:\n    ldr r5,[r0,#node_parent]      @ load father\n    cmp r5,#0                     @ no father \n    beq 100f\n    cmp r3,#0                     @ balance equilibred\n    beq 100f\n    mov r6,r0                     @ save entry node\n    ldr r0,[r6,#node_parent]      @ current = father\n    ldr r7,[r0,#node_left]\n    cmp r7,#0\n    ldrne r8,[r7,#node_height]    @ height left tree \n    moveq r8,#0\n    ldr r7,[r0,#node_right]\n    cmp r7,#0\n    ldrne r9,[r7,#node_height]    @ height right tree \n    moveq r9,#0\n    cmp r8,r9\n    addgt r8,#1\n    strgt r8,[r0,#node_height]\n    addle r9,#1\n    strle r9,[r0,#node_height]\n    //\n    ldr r7,[r0,#node_right]\n    cmp r7,#0\n    ldrne r8,[r7,#node_height]\n    moveq r8,#0\n    ldr r7,[r0,#node_left]\n    cmp r7,#0\n    ldrne r9,[r7,#node_height]\n    moveq r9,#0\n    sub r3,r8,r9                   @ compute balance factor\n    mov r2,r1\n    mov r4,r0                      @ save current\n    mov r1,r6\n    bl equiUnSommet\n                                   @ change head address\u00a0?\n    cmp r2,r4\n    streq r6,[r3,#tree_root]\n    mov r0,r4                      @ restaur current\n    b 1b\n\n100:\n    pop {r1-r8,lr}                  @ restaur registers\n    bx lr                           @ return\n/******************************************************************/\n/*     preOrder                                  */ \n/******************************************************************/\n/* r0 contains the address of the node */\n/* r1 function address                 */\npreOrder:                                 @ INFO: preOrder\n    push {r1-r2,lr}                       @ save  registers \n    cmp r0,#0\n    beq 100f\n    mov r2,r0\n    blx r1                                @ call function\n\n    ldr r0,[r2,#node_left]\n    bl preOrder\n    ldr r0,[r2,#node_right]\n    bl preOrder\n100:\n    pop {r1-r2,lr}                        @ restaur registers\n    bx lr       \n\n/******************************************************************/\n/*     display node                                               */ \n/******************************************************************/\n/* r0 contains node  address          */\ndisplayElement:                        @ INFO: displayElement\n    push {r1,r2,r3,lr}                 @ save  registers \n    mov r2,r0\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,r0]\n    ldr r0,iAdrszMessResult\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#node_left]\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,r0]\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#node_right]\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,r0]\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#node_value]\n    ldr r1,iAdrsZoneConv\n    bl conversion10\n    mov r4,#0\n    strb r4,[r1,r0]\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#node_height]\n    ldr r1,iAdrsZoneConv\n    bl conversion10\n    mov r4,#0\n    strb r4,[r1,r0]\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    mov r3,r0\n    ldr r0,[r2,#node_parent]\n    ldr r1,iAdrsZoneConv\n    bl conversion16\n    mov r4,#0\n    strb r4,[r1,r0]\n    mov r0,r3\n    ldr r1,iAdrsZoneConv\n    bl strInsertAtCharInc\n    bl affichageMess\n100:\n    pop {r1,r2,r3,lr}                        @ restaur registers\n    bx lr                              @ return\niAdrszMessResult:          .int szMessResult\niAdrsZoneConv:             .int sZoneConv\niAdrsValue:                .int sValue\n\n/******************************************************************/\n/*     memory allocation on the heap                                  */ \n/******************************************************************/\n/* r0 contains the size to allocate */\n/* r0 returns address of memory heap or - 1 if error */\n/* CAUTION\u00a0: The size of the allowance must be a multiple of 4  */\nallocHeap:\n    push {r5-r7,lr}                   @ save  registers \n    @ allocation\n    mov r6,r0                         @ save size\n    mov r0,#0                         @ read address start heap\n    mov r7,#0x2D                      @ call system 'brk'\n    svc #0\n    mov r5,r0                         @ save address heap for return\n    add r0,r6                         @ reservation place for size\n    mov r7,#0x2D                      @ call system 'brk'\n    svc #0\n    cmp r0,#-1                        @ allocation error\n    movne r0,r5                       @ return address memory heap\n    pop {r5-r7,lr}                    @ restaur registers\n    bx lr                             @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                 */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nKey exists in tree.\nError detected.\nPreOrder\u00a0:\nEle: 007EC08C G: 007EC03C D: 007EC0B4 val 8 h 4 pere 00000000\nEle: 007EC03C G: 007EC014 D: 007EC064 val 4 h 3 pere 007EC08C\nEle: 007EC014 G: 007EC000 D: 007EC028 val 2 h 2 pere 007EC03C\nEle: 007EC000 G: 00000000 D: 00000000 val 1 h 1 pere 007EC014\nEle: 007EC028 G: 00000000 D: 00000000 val 3 h 1 pere 007EC014\nEle: 007EC064 G: 007EC050 D: 007EC078 val 6 h 2 pere 007EC03C\nEle: 007EC050 G: 00000000 D: 00000000 val 5 h 1 pere 007EC064\nEle: 007EC078 G: 00000000 D: 00000000 val 7 h 1 pere 007EC064\nEle: 007EC0B4 G: 007EC0A0 D: 007EC0C8 val 10 h 3 pere 007EC08C\nEle: 007EC0A0 G: 00000000 D: 00000000 val 9 h 1 pere 007EC0B4\nEle: 007EC0C8 G: 00000000 D: 007EC0DC val 11 h 2 pere 007EC0B4\nEle: 007EC0DC G: 00000000 D: 00000000 val 12 h 1 pere 007EC0C8\nInsertion in inverse order.\nPreOrder\u00a0:\nEle: 007ED0F9 G: 007ED121 D: 007ED0A9 val 5 h 4 pere 00000000\nEle: 007ED121 G: 007ED135 D: 007ED10D val 3 h 3 pere 007ED0F9\nEle: 007ED135 G: 007ED149 D: 00000000 val 2 h 2 pere 007ED121\nEle: 007ED149 G: 00000000 D: 00000000 val 1 h 1 pere 007ED135\nEle: 007ED10D G: 00000000 D: 00000000 val 4 h 1 pere 007ED121\nEle: 007ED0A9 G: 007ED0D1 D: 007ED081 val 9 h 3 pere 007ED0F9\nEle: 007ED0D1 G: 007ED0E5 D: 007ED0BD val 7 h 2 pere 007ED0A9\nEle: 007ED0E5 G: 00000000 D: 00000000 val 6 h 1 pere 007ED0D1\nEle: 007ED0BD G: 00000000 D: 00000000 val 8 h 1 pere 007ED0D1\nEle: 007ED081 G: 007ED095 D: 007ED06D val 11 h 2 pere 007ED0A9\nEle: 007ED095 G: 00000000 D: 00000000 val 10 h 1 pere 007ED081\nEle: 007ED06D G: 00000000 D: 00000000 val 12 h 1 pere 007ED081\nKey exists in tree.\nPreOrder\u00a0:\nEle: 007ED0F9 G: 007ED121 D: 007ED0A9 val 5 h 4 pere 00000000\nEle: 007ED121 G: 007ED135 D: 007ED10D val 3 h 3 pere 007ED0F9\nEle: 007ED135 G: 007ED149 D: 00000000 val 2 h 2 pere 007ED121\nEle: 007ED149 G: 00000000 D: 00000000 val 1 h 1 pere 007ED135\nEle: 007ED10D G: 00000000 D: 00000000 val 4 h 1 pere 007ED121\nEle: 007ED0A9 G: 007ED0D1 D: 007ED081 val 9 h 3 pere 007ED0F9\nEle: 007ED0D1 G: 007ED0E5 D: 007ED0BD val 7 h 2 pere 007ED0A9\nEle: 007ED0E5 G: 00000000 D: 00000000 val 6 h 1 pere 007ED0D1\nEle: 007ED0BD G: 00000000 D: 00000000 val 8 h 1 pere 007ED0D1\nEle: 007ED081 G: 007ED095 D: 00000000 val 12 h 2 pere 007ED0A9\nEle: 007ED095 G: 00000000 D: 00000000 val 10 h 1 pere 007ED081\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Rust", "code": "\n\n", "explain": "See AVL tree/Rust.\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Ada", "code": "\nTranslation of: C++\nwith Ada.Text_IO, Ada.Finalization, Ada.Unchecked_Deallocation;\n\nprocedure Main is\n\n   generic\n      type Key_Type is private;\n      with function \"<\"(a, b : Key_Type) return Boolean is <>;\n      with function \"=\"(a, b : Key_Type) return Boolean is <>;\n      with function \"<=\"(a, b : Key_Type) return Boolean is <>;\n   package AVL_Tree is\n      type Tree is tagged limited private;\n      function insert(self : in out Tree; key : Key_Type) return Boolean;\n      procedure delete(self : in out Tree; key : Key_Type);\n      procedure print_balance(self : in out Tree);\n\n   private\n      type Height_Amt is range -1 .. Integer'Last;\n\n      -- Since only one key is inserted before each rebalance, the balance of\n      -- all trees/subtrees will stay in range -2 .. 2\n      type Balance_Amt is range -2 .. 2;\n\n      type Node;\n      type Node_Ptr is access Node;\n      type Node is new Ada.Finalization.Limited_Controlled with record\n         left, right, parent : Node_Ptr := null;\n         key : Key_Type;\n         balance : Balance_Amt := 0;\n      end record;\n      overriding procedure Finalize(self : in out Node);\n      subtype Node_Parent is Ada.Finalization.Limited_Controlled;\n\n      type Tree is new Ada.Finalization.Limited_Controlled with record\n         root : Node_Ptr := null;\n      end record;\n      overriding procedure Finalize(self : in out Tree);\n\n   end AVL_Tree;\n\n   package body AVL_Tree is\n\n      procedure Free_Node is new Ada.Unchecked_Deallocation(Node, Node_Ptr);\n\n      overriding procedure Finalize(self : in out Node) is\n      begin\n         Free_Node(self.left);\n         Free_Node(self.right);\n      end Finalize;\n\n      overriding procedure Finalize(self : in out Tree) is\n      begin\n         Free_Node(self.root);\n      end Finalize;\n\n\n      function height(n : Node_Ptr) return Height_Amt is\n      begin\n         if n = null then\n            return -1;\n         else\n            return 1 + Height_Amt'Max(height(n.left), height(n.right));\n         end if;\n      end height;\n\n      procedure set_balance(n : not null Node_Ptr) is\n      begin\n         n.balance := Balance_Amt(height(n.right) - height(n.left));\n      end set_balance;\n\n      procedure update_parent(parent : Node_Ptr; new_child : Node_Ptr; old_child : Node_Ptr) is\n      begin\n         if parent /= null then\n            if parent.right = old_child then\n               parent.right := new_child;\n            else\n               parent.left := new_child;\n            end if;\n         end if;\n      end update_parent;\n\n      function rotate_left(a : not null Node_Ptr) return Node_Ptr is\n         b : Node_Ptr := a.right;\n      begin\n         b.parent := a.parent;\n         a.right := b.left;\n         if a.right /= null then\n            a.right.parent := a;\n         end if;\n         b.left := a;\n         a.parent := b;\n         update_parent(parent => b.parent, new_child => b, old_child => a);\n\n         set_balance(a);\n         set_balance(b);\n         return b;\n      end rotate_left;\n\n      function rotate_right(a : not null Node_Ptr) return Node_Ptr is\n         b : Node_Ptr := a.left;\n      begin\n         b.parent := a.parent;\n         a.left := b.right;\n         if a.left /= null then\n            a.left.parent := a;\n         end if;\n         b.right := a;\n         a.parent := b;\n         update_parent(parent => b.parent, new_child => b, old_child => a);\n\n         set_balance(a);\n         set_balance(b);\n         return b;\n      end rotate_right;\n\n      function rotate_left_right(n : not null Node_Ptr) return Node_Ptr is\n      begin\n         n.left := rotate_left(n.left);\n         return rotate_right(n);\n      end rotate_left_right;\n\n      function rotate_right_left(n : not null Node_Ptr) return Node_Ptr is\n      begin\n         n.right := rotate_right(n.right);\n         return rotate_left(n);\n      end rotate_right_left;\n\n      procedure rebalance(self : in out Tree; n : not null Node_Ptr) is\n         new_n : Node_Ptr := n;\n      begin\n         set_balance(new_n);\n         if new_n.balance = -2 then\n            if height(new_n.left.left) >= height(new_n.left.right) then\n               new_n := rotate_right(new_n);\n            else\n               new_n := rotate_left_right(new_n);\n            end if;\n         elsif new_n.balance = 2 then\n            if height(new_n.right.right) >= height(new_n.right.left) then\n               new_n := rotate_left(new_n);\n            else\n               new_n := rotate_right_left(new_n);\n            end if;\n         end if;\n\n         if new_n.parent /= null then\n            rebalance(self, new_n.parent);\n         else\n            self.root := new_n;\n         end if;\n      end rebalance;\n\n      function new_node(key : Key_Type) return Node_Ptr is\n        (new Node'(Node_Parent with key => key, others => <>));\n\n      function insert(self : in out Tree; key : Key_Type) return Boolean is\n         curr, parent : Node_Ptr;\n         go_left : Boolean;\n      begin\n         if self.root = null then\n            self.root := new_node(key);\n            return True;\n         end if;\n\n         curr := self.root;\n         while curr.key /= key loop\n            parent := curr;\n            go_left := key < curr.key;\n            curr := (if go_left then curr.left else curr.right);\n            if curr = null then\n               if go_left then\n                  parent.left := new_node(key);\n                  parent.left.parent := parent;\n               else\n                  parent.right := new_node(key);\n                  parent.right.parent := parent;\n               end if;\n               rebalance(self, parent);\n               return True;\n            end if;\n         end loop;\n         return False;\n      end insert;\n\n      procedure delete(self : in out Tree; key : Key_Type) is\n         successor, parent, child : Node_Ptr := self.root;\n         to_delete : Node_Ptr := null;\n      begin\n         if self.root = null then\n            return;\n         end if;\n\n         while child /= null loop\n            parent := successor;\n            successor := child;\n            child := (if successor.key <= key then successor.right else successor.left);\n            if successor.key = key then\n               to_delete := successor;\n            end if;\n         end loop;\n\n         if to_delete = null then\n            return;\n         end if;\n         to_delete.key := successor.key;\n         child := (if successor.left = null then successor.right else successor.left);\n         if self.root.key = key then\n            self.root := child;\n         else\n            update_parent(parent => parent, new_child => child, old_child => successor);\n            rebalance(self, parent);\n         end if;\n         Free_Node(successor);\n      end delete;\n\n      procedure print_balance(n : Node_Ptr) is\n      begin\n         if n /= null then\n            print_balance(n.left);\n            Ada.Text_IO.Put(n.balance'Image);\n            print_balance(n.right);\n         end if;\n      end print_balance;\n\n      procedure print_balance(self : in out Tree) is\n      begin\n         print_balance(self.root);\n      end print_balance;\n   end AVL_Tree;\n\n   package Int_AVL_Tree is new AVL_Tree(Integer);\n\n   tree : Int_AVL_Tree.Tree;\n   success : Boolean;\nbegin\n   for i in 1 .. 10 loop\n      success := tree.insert(i);\n   end loop;\n   Ada.Text_IO.Put(\"Printing balance: \");\n   tree.print_balance;\n   Ada.Text_IO.New_Line;\nend Main;\n\n\nOutput:\nPrinting balance:  0 0 0 1 0 0 0 0 1 0\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Julia", "code": "\nTranslation of: Sidef\nmodule AVLTrees\n\nimport Base.print\nexport AVLNode, AVLTree, insert, deletekey, deletevalue, findnodebykey, findnodebyvalue, allnodes\n\n@enum Direction LEFT RIGHT\navlhash(x) = Int32(hash(x) & 0xfffffff)\nconst MIDHASH = Int32(div(0xfffffff, 2))\n\nmutable struct AVLNode{T}\n    value::T\n    key::Int32\n    balance::Int32\n    left::Union{AVLNode, Nothing}\n    right::Union{AVLNode, Nothing}\n    parent::Union{AVLNode, Nothing}\nend\nAVLNode(v::T, b, l, r, p) where T <: Real = AVLNode(v, avlhash(v), Int32(b), l, r, p)\nAVLNode(v::T, h, b::Int64, l, r, p) where T <: Real = AVLNode(v, h, Int32(b), l, r, p)\nAVLNode(v::T) where T <: Real = AVLNode(v, avlhash(v), Int32(0), nothing, nothing, nothing)\n\nAVLTree(typ::Type) = AVLNode(typ(0), MIDHASH, Int32(0), nothing, nothing, nothing)\nconst MaybeAVL = Union{AVLNode, Nothing}\n\nheight(node::MaybeAVL) = (node == nothing) ? 0 : 1 + max(height(node.right), height(node.left))\n\nfunction insert(node, value)\n    if node == nothing\n        node = AVLNode(value)\n        return true\n    end\n    key, n, parent::MaybeAVL = avlhash(value), node, nothing\n    while true\n        if n.key == key\n            return false\n        end\n        parent = n\n        ngreater = n.key > key\n        n = ngreater ? n.left : n.right\n        if n == nothing\n            if ngreater\n                parent.left = AVLNode(value, key, 0, nothing, nothing, parent)\n            else\n                parent.right = AVLNode(value, key, 0, nothing, nothing, parent)\n            end\n            rebalance(parent)\n            break\n        end\n    end\n    return true\nend\n\nfunction deletekey(node, delkey)\n    node == nothing && return nothing\n    n, parent = MaybeAVL(node), MaybeAVL(node)\n    delnode, child = MaybeAVL(nothing), MaybeAVL(node)\n    while child != nothing\n        parent, n = n, child\n        child = delkey >= n.key ? n.right : n.left\n        if delkey == n.key\n            delnode = n\n        end\n    end\n    if delnode != nothing\n        delnode.key = n.key\n        delnode.value = n.value\n        child = (n.left != nothing) ? n.left : n.right\n        if node.key == delkey\n            root = child\n        else\n            if parent.left == n\n                parent.left = child\n            else\n                parent.right = child\n            end\n            rebalance(parent)\n        end\n    end\nend\n\ndeletevalue(node, val) = deletekey(node, avlhash(val))\n\nfunction rebalance(node::MaybeAVL)\n    node == nothing && return nothing\n    setbalance(node)\n    if node.balance < -1\n        if height(node.left.left) >= height(node.left.right)\n            node = rotate(node, RIGHT)\n        else\n            node = rotatetwice(node, LEFT, RIGHT)\n        end\n    elseif node.balance > 1\n        if node.right != nothing && height(node.right.right) >= height(node.right.left)\n            node = rotate(node, LEFT)\n        else\n            node = rotatetwice(node, RIGHT, LEFT)\n        end\n    end\n    if node != nothing && node.parent != nothing\n        rebalance(node.parent)\n    end\nend\n\nfunction rotate(a, direction)\n    (a == nothing || a.parent == nothing) && return nothing\n    b = direction == LEFT ? a.right : a.left\n    b == nothing && return\n    b.parent = a.parent\n    if direction == LEFT\n        a.right = b.left\n    else\n        a.left  = b.right\n    end\n    if a.right != nothing\n        a.right.parent = a\n    end\n    if direction == LEFT\n        b.left = a\n    else\n        b.right = a\n    end\n    a.parent = b\n    if b.parent != nothing\n        if b.parent.right == a\n            b.parent.right = b\n        else\n            b.parent.left = b\n        end\n    end\n    setbalance([a, b])\n    return b\nend\n\nfunction rotatetwice(n, dir1, dir2)\n    n.left = rotate(n.left, dir1)\n    rotate(n, dir2)\nend\n\nsetbalance(n::AVLNode) = begin n.balance = height(n.right) - height(n.left) end\nsetbalance(n::Nothing) = 0\nsetbalance(nodes::Vector) = for n in nodes setbalance(n) end\n\nfunction findnodebykey(node, key)\n    result::MaybeAVL = node == nothing ? nothing : node.key == key ? node : \n        node.left != nothing && (n = findbykey(n, key) != nothing) ? n :\n        node.right != nothing ? findbykey(node.right, key) : nothing\n    return result\nend\nfindnodebyvalue(node, val) = findnodebykey(node, avlhash(v))\n\nfunction allnodes(node)\n    result = AVLNode[]\n    if node != nothing\n        append!(result, allnodes(node.left))\n        if node.key != MIDHASH\n            push!(result, node)\n        end\n        append!(result, node.right)\n    end\n    return result\nend\n\nfunction Base.print(io::IO, n::MaybeAVL)\n    if n != nothing\n        n.left != nothing && print(io, n.left)\n        print(io, n.key == MIDHASH ? \"<ROOT> \" : \"<$(n.key):$(n.value):$(n.balance)> \")\n        n.right != nothing && print(io, n.right)\n    end\nend\n\nend # module\n\nusing .AVLTrees\n\nconst tree = AVLTree(Int)\n\nprintln(\"Inserting 10 values.\")\nforeach(x -> insert(tree, x), rand(collect(1:80), 10))\nprintln(\"Printing tree after insertion: \")\nprintln(tree)\n\nOutput:\nInserting 10 values.\nPrinting tree after insertion:\n<35627180:79:1> <51983710:44:0> <55727576:19:0> <95692146:13:0> <119148308:42:0> <131027959:27:0> <ROOT> <144455609:36:0> <172953853:41:1> <203559702:58:1> <217724037:80:0>\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\nTranslation of: Java\nclass AvlTree {\n    private var root: Node? = null\n\n    private class Node(var key: Int, var parent: Node?) {\n        var balance: Int = 0\n        var left : Node? = null\n        var right: Node? = null\n    }\n\n    fun insert(key: Int): Boolean {\n        if (root == null)\n            root = Node(key, null)\n        else {\n            var n: Node? = root\n            var parent: Node\n            while (true) {\n                if (n!!.key == key) return false\n                parent = n\n                val goLeft = n.key > key\n                n = if (goLeft) n.left else n.right\n                if (n == null) {\n                    if (goLeft)\n                        parent.left  = Node(key, parent)\n                    else\n                        parent.right = Node(key, parent)\n                    rebalance(parent)\n                    break\n                }\n            }\n        }\n        return true\n    }\n\n    fun delete(delKey: Int) {\n        if (root == null) return\n        var n:       Node? = root\n        var parent:  Node? = root\n        var delNode: Node? = null\n        var child:   Node? = root\n        while (child != null) {\n            parent = n\n            n = child\n            child = if (delKey >= n.key) n.right else n.left\n            if (delKey == n.key) delNode = n\n        }\n        if (delNode != null) {\n            delNode.key = n!!.key\n            child = if (n.left != null) n.left else n.right\n            if (0 == root!!.key.compareTo(delKey)) {\n                root = child\n\n                if (null != root) {\n                    root!!.parent = null\n                }\n\n            } else {\n                if (parent!!.left == n)\n                    parent.left = child\n                else\n                    parent.right = child\n\n                if (null != child) {\n                    child.parent = parent\n                }\n\n                rebalance(parent)\n            }\n    }\n\n    private fun rebalance(n: Node) {\n        setBalance(n)\n        var nn = n\n        if (nn.balance == -2)\n            if (height(nn.left!!.left) >= height(nn.left!!.right))\n                nn = rotateRight(nn)\n            else\n                nn = rotateLeftThenRight(nn)\n        else if (nn.balance == 2)\n            if (height(nn.right!!.right) >= height(nn.right!!.left))\n                nn = rotateLeft(nn)\n            else\n                nn = rotateRightThenLeft(nn)\n        if (nn.parent != null) rebalance(nn.parent!!)\n        else root = nn\n    }\n\n    private fun rotateLeft(a: Node): Node {\n        val b: Node? = a.right\n        b!!.parent = a.parent\n        a.right = b.left\n        if (a.right != null) a.right!!.parent = a\n        b.left = a\n        a.parent = b\n        if (b.parent != null) {\n            if (b.parent!!.right == a)\n                b.parent!!.right = b\n            else\n                b.parent!!.left = b\n        }\n        setBalance(a, b)\n        return b\n    }\n\n    private fun rotateRight(a: Node): Node {\n        val b: Node? = a.left\n        b!!.parent = a.parent\n        a.left = b.right\n        if (a.left != null) a.left!!.parent = a\n        b.right = a\n        a.parent = b\n        if (b.parent != null) {\n            if (b.parent!!.right == a)\n                b.parent!!.right = b\n            else\n                b.parent!!.left = b\n        }\n        setBalance(a, b)\n        return b\n    }\n\n    private fun rotateLeftThenRight(n: Node): Node {\n        n.left = rotateLeft(n.left!!)\n        return rotateRight(n)\n    }\n\n    private fun rotateRightThenLeft(n: Node): Node {\n        n.right = rotateRight(n.right!!)\n        return rotateLeft(n)\n    }\n\n    private fun height(n: Node?): Int {\n        if (n == null) return -1\n        return 1 + Math.max(height(n.left), height(n.right))\n    }\n\n    private fun setBalance(vararg nodes: Node) {\n        for (n in nodes) n.balance = height(n.right) - height(n.left)\n    }\n\n    fun printKey() {\n        printKey(root)\n        println()\n    }\n\n    private fun printKey(n: Node?) {\n        if (n != null) {\n            printKey(n.left)\n            print(\"${n.key} \")\n            printKey(n.right)\n        }\n    }\n\n    fun printBalance() {\n        printBalance(root)\n        println()\n    }\n\n    private fun printBalance(n: Node?) {\n        if (n != null) {\n            printBalance(n.left)\n            print(\"${n.balance} \")\n            printBalance(n.right)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val tree = AvlTree()\n    println(\"Inserting values 1 to 10\")\n    for (i in 1..10) tree.insert(i)\n    print(\"Printing key    \u00a0: \")\n    tree.printKey()\n    print(\"Printing balance\u00a0: \")\n    tree.printBalance()\n}\n\n\nOutput:\nInserting values 1 to 10\nPrinting key    \u00a0: 1 2 3 4 5 6 7 8 9 10\nPrinting balance\u00a0: 0 0 0 1 0 0 0 0 1 0\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\nTranslation of: Java\n\n\nThis example is incomplete. It is missing an @interface for AVLTree and also missing any @interface or @implementation for AVLTreeNode. Please ensure that it meets all task requirements and remove this message.\n\n@implementation AVLTree\n\n-(BOOL)insertWithKey:(NSInteger)key {\n    \n    if (self.root == nil) {\n        self.root = [[AVLTreeNode alloc]initWithKey:key andParent:nil];\n    } else {\n        \n        AVLTreeNode *n = self.root;\n        AVLTreeNode *parent;\n        \n        while (true) {\n            \n            if (n.key == key) {\n                return false;\n            }\n            \n            parent = n;\n            \n            BOOL goLeft = n.key > key;\n            n = goLeft ? n.left : n.right;\n            \n            if (n == nil) {\n                \n                if (goLeft) {\n                    parent.left = [[AVLTreeNode alloc]initWithKey:key andParent:parent];\n                } else {\n                    parent.right = [[AVLTreeNode alloc]initWithKey:key andParent:parent];\n                }\n                [self rebalanceStartingAtNode:parent];\n                break;\n            }\n        }\n    }\n    \n    return true;\n}\n\n-(void)rebalanceStartingAtNode:(AVLTreeNode*)n {\n    \n    [self setBalance:@[n]];\n    \n    if (n.balance == -2) {\n        if ([self height:(n.left.left)] >= [self height:n.left.right]) {\n            n = [self rotateRight:n];\n        } else {\n            n = [self rotateLeftThenRight:n];\n        }\n    } else if (n.balance == 2) {\n        if ([self height:n.right.right] >= [self height:n.right.left]) {\n            n = [self rotateLeft:n];\n        } else {\n            n = [self rotateRightThenLeft:n];\n        }\n    }\n    \n    if (n.parent != nil) {\n        [self rebalanceStartingAtNode:n.parent];\n    } else {\n        self.root = n;\n    }\n}\n\n\n-(AVLTreeNode*)rotateRight:(AVLTreeNode*)a {\n    \n    AVLTreeNode *b = a.left;\n    b.parent = a.parent;\n    \n    a.left = b.right;\n    \n    if (a.left != nil) {\n        a.left.parent = a;\n    }\n    \n    b.right = a;\n    a.parent = b;\n    \n    if (b.parent != nil) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.left = b;\n        }\n    }\n    \n    [self setBalance:@[a,b]];\n    return b;\n    \n}\n\n-(AVLTreeNode*)rotateLeftThenRight:(AVLTreeNode*)n {\n    \n    n.left = [self rotateLeft:n.left];\n    return [self rotateRight:n];\n    \n}\n\n-(AVLTreeNode*)rotateRightThenLeft:(AVLTreeNode*)n {\n    \n    n.right = [self rotateRight:n.right];\n    return [self rotateLeft:n];\n}\n\n-(AVLTreeNode*)rotateLeft:(AVLTreeNode*)a {\n    \n    //set a's right node as b\n    AVLTreeNode* b = a.right;\n    //set b's parent as a's parent (which could be nil)\n    b.parent = a.parent;\n    //in case b had a left child transfer it to a\n    a.right = b.left;\n    \n    // after changing a's reference to the right child, make sure the parent is set too\n    if (a.right != nil) {\n        a.right.parent = a;\n    }\n    \n    // switch a over to the left to be b's left child\n    b.left = a;\n    a.parent = b;\n    \n    if (b.parent != nil) {\n        if (b.parent.right == a) {\n            b.parent.right = b;\n        } else {\n            b.parent.right = b;\n        }\n    }\n    \n    [self setBalance:@[a,b]];\n    \n    return b;\n    \n}\n\n\n\n-(void) setBalance:(NSArray*)nodesArray {\n    \n    for (AVLTreeNode* n in nodesArray) {\n        \n        n.balance = [self height:n.right] - [self height:n.left];\n    }\n    \n}\n\n-(int)height:(AVLTreeNode*)n {\n    \n    if (n == nil) {\n        return -1;\n    }\n    \n    return 1 + MAX([self height:n.left], [self height:n.right]);\n}\n\n-(void)printKey:(AVLTreeNode*)n {\n    if (n != nil) {\n        [self printKey:n.left];\n        NSLog(@\"%ld\", n.key);\n        [self printKey:n.right];\n    }\n}\n\n-(void)printBalance:(AVLTreeNode*)n {\n    if (n != nil) {\n        [self printBalance:n.left];\n        NSLog(@\"%ld\", n.balance);\n        [self printBalance:n.right];\n    }\n}\n@end\n-- test \n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n        AVLTree *tree = [AVLTree new];\n        NSLog(@\"inserting values 1 to 6\");\n        [tree insertWithKey:1];\n        [tree insertWithKey:2];\n        [tree insertWithKey:3];\n        [tree insertWithKey:4];\n        [tree insertWithKey:5];\n        [tree insertWithKey:6];\n        \n        NSLog(@\"printing balance: \");\n        [tree printBalance:tree.root];\n        \n        NSLog(@\"printing key: \");\n        [tree printKey:tree.root];\n    }\n    return 0;\n}\n\n\nOutput:\ninserting values 1 to 6\nprinting balance:\n0\n0\n0\n0\n1\n0\n\nprinting key:\n1\n2\n3\n4\n5\n6\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Lua", "code": "\nAVL={balance=0}\nAVL.__mt={__index = AVL}\n\n\nfunction AVL:new(list)\n  local o={}  \n  setmetatable(o, AVL.__mt)\n  for _,v in ipairs(list or {}) do\n    o=o:insert(v)\n  end\n  return o\nend\n  \nfunction AVL:rebalance()\n  local rotated=false\n  if self.balance>1 then\n    if self.right.balance<0 then\n      self.right, self.right.left.right, self.right.left = self.right.left, self.right, self.right.left.right\n      self.right.right.balance=self.right.balance>-1 and 0 or 1\n      self.right.balance=self.right.balance>0 and 2 or 1\n    end\n    self, self.right.left, self.right = self.right, self, self.right.left\n    self.left.balance=1-self.balance\n    self.balance=self.balance==0 and -1 or 0\n    rotated=true\n  elseif self.balance<-1 then\n    if self.left.balance>0 then\n      self.left, self.left.right.left, self.left.right = self.left.right, self.left, self.left.right.left\n      self.left.left.balance=self.left.balance<1 and 0 or -1\n      self.left.balance=self.left.balance<0 and -2 or -1\n    end\n    self, self.left.right, self.left = self.left, self, self.left.right\n    self.right.balance=-1-self.balance\n    self.balance=self.balance==0 and 1 or 0\n    rotated=true\n  end\n  return self,rotated\nend\n\nfunction AVL:insert(v)\n  if not self.value then \n    self.value=v\n    self.balance=0\n    return self,1\n  end\n  local grow\n  if v==self.value then\n    return self,0\n  elseif v<self.value then\n    if not self.left then self.left=self:new() end\n    self.left,grow=self.left:insert(v)\n    self.balance=self.balance-grow\n  else\n    if not self.right then self.right=self:new() end\n    self.right,grow=self.right:insert(v)\n    self.balance=self.balance+grow\n  end\n  self,rotated=self:rebalance()\n  return self, (rotated or self.balance==0) and 0 or grow \nend\n\nfunction AVL:delete_move(dir,other,mul)\n  if self[dir] then\n    local sb2,v\n    self[dir], sb2, v=self[dir]:delete_move(dir,other,mul)\n    self.balance=self.balance+sb2*mul\n    self,sb2=self:rebalance()\n    return self,(sb2 or self.balance==0) and -1 or 0,v\n  else\n    return self[other],-1,self.value\n  end\nend\n\nfunction AVL:delete(v,isSubtree)\n  local grow=0\n  if v==self.value then\n    local v\n    if self.balance>0 then\n      self.right,grow,v=self.right:delete_move(\"left\",\"right\",-1)\n    elseif self.left then\n      self.left,grow,v=self.left:delete_move(\"right\",\"left\",1)\n      grow=-grow\n    else\n      return not isSubtree and AVL:new(),-1\n    end\n    self.value=v\n    self.balance=self.balance+grow\n  elseif v<self.value and self.left then\n    self.left,grow=self.left:delete(v,true)\n    self.balance=self.balance-grow\n  elseif v>self.value and self.right then\n    self.right,grow=self.right:delete(v,true)\n    self.balance=self.balance+grow\n  else\n    return self,0\n  end\n  self,rotated=self:rebalance()\n  return self, grow~=0 and (rotated or self.balance==0) and -1 or 0\nend\n\n-- output functions\n\nfunction AVL:toList(list)\n  if not self.value then return {} end\n  list=list or {}\n  if self.left then self.left:toList(list) end\n  list[#list+1]=self.value\n  if self.right then self.right:toList(list) end\n  return list\nend\n\nfunction AVL:dump(depth)\n  if not self.value then return end\n  depth=depth or 0\n  if self.right then self.right:dump(depth+1) end\n  print(string.rep(\"    \",depth)..self.value..\" (\"..self.balance..\")\")\n  if self.left then self.left:dump(depth+1) end\nend\n\n-- test\n\nlocal test=AVL:new{1,10,5,15,20,3,5,14,7,13,2,8,3,4,5,10,9,8,7}\n\ntest:dump()\nprint(\"\\ninsert 17:\")\ntest=test:insert(17)\ntest:dump()\nprint(\"\\ndelete 10:\")\ntest=test:delete(10)\ntest:dump()\nprint(\"\\nlist:\")\nprint(unpack(test:toList()))\n\n\nOutput:\n            20 (0)\n        15 (1)\n    14 (1)\n        13 (0)\n10 (-1)\n            9 (0)\n        8 (0)\n            7 (0)\n    5 (-1)\n                4 (0)\n            3 (1)\n        2 (1)\n            1 (0)\n\ninsert 17:\n            20 (0)\n        17 (0)\n            15 (0)\n    14 (1)\n        13 (0)\n10 (-1)\n            9 (0)\n        8 (0)\n            7 (0)\n    5 (-1)\n                4 (0)\n            3 (1)\n        2 (1)\n            1 (0)\n\ndelete 10:\n            20 (0)\n        17 (0)\n            15 (0)\n    14 (1)\n        13 (0)\n9 (-1)\n        8 (-1)\n            7 (0)\n    5 (-1)\n                4 (0)\n            3 (1)\n        2 (1)\n            1 (0)\n\nlist:\n1       2       3       4       5       7       8       9       13      14      15      17      20\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Scala", "code": "\nimport scala.collection.mutable\n\nclass AVLTree[A](implicit val ordering: Ordering[A]) extends mutable.SortedSet[A] {\n\n  if (ordering eq null) throw new NullPointerException(\"ordering must not be null\")\n\n  private var _root: AVLNode = _\n  private var _size = 0\n\n  override def size: Int = _size\n\n  override def foreach[U](f: A => U): Unit = {\n    val stack = mutable.Stack[AVLNode]()\n    var current = root\n    var done = false\n\n    while (!done) {\n      if (current != null) {\n        stack.push(current)\n        current = current.left\n      } else if (stack.nonEmpty) {\n        current = stack.pop()\n        f.apply(current.key)\n\n        current = current.right\n      } else {\n        done = true\n      }\n    }\n  }\n\n  def root: AVLNode = _root\n\n  override def isEmpty: Boolean = root == null\n\n  override def min[B >: A](implicit cmp: Ordering[B]): A = minNode().key\n\n  def minNode(): AVLNode = {\n    if (root == null) throw new UnsupportedOperationException(\"empty tree\")\n    var node = root\n    while (node.left != null) node = node.left\n    node\n  }\n\n  override def max[B >: A](implicit cmp: Ordering[B]): A = maxNode().key\n\n  def maxNode(): AVLNode = {\n    if (root == null) throw new UnsupportedOperationException(\"empty tree\")\n    var node = root\n    while (node.right != null) node = node.right\n    node\n  }\n\n  def next(node: AVLNode): Option[AVLNode] = {\n    var successor = node\n    if (successor != null) {\n      if (successor.right != null) {\n        successor = successor.right\n        while (successor != null && successor.left != null) {\n          successor = successor.left\n        }\n      } else {\n        successor = node.parent\n        var n = node\n        while (successor != null && successor.right == n) {\n          n = successor\n          successor = successor.parent\n        }\n      }\n    }\n    Option(successor)\n  }\n\n  def prev(node: AVLNode): Option[AVLNode] = {\n    var predecessor = node\n    if (predecessor != null) {\n      if (predecessor.left != null) {\n        predecessor = predecessor.left\n        while (predecessor != null && predecessor.right != null) {\n          predecessor = predecessor.right\n        }\n      } else {\n        predecessor = node.parent\n        var n = node\n        while (predecessor != null && predecessor.left == n) {\n          n = predecessor\n          predecessor = predecessor.parent\n        }\n      }\n    }\n    Option(predecessor)\n  }\n\n  override def rangeImpl(from: Option[A], until: Option[A]): mutable.SortedSet[A] = ???\n\n  override def +=(key: A): AVLTree.this.type = {\n    insert(key)\n    this\n  }\n\n  def insert(key: A): AVLNode = {\n    if (root == null) {\n      _root = new AVLNode(key)\n      _size += 1\n      return root\n    }\n\n    var node = root\n    var parent: AVLNode = null\n    var cmp = 0\n\n    while (node != null) {\n      parent = node\n      cmp = ordering.compare(key, node.key)\n      if (cmp == 0) return node // duplicate\n      node = node.matchNextChild(cmp)\n    }\n\n    val newNode = new AVLNode(key, parent)\n    if (cmp <= 0) parent._left = newNode\n    else parent._right = newNode\n\n    while (parent != null) {\n      cmp = ordering.compare(parent.key, key)\n      if (cmp < 0) parent.balanceFactor -= 1\n      else parent.balanceFactor += 1\n\n      parent = parent.balanceFactor match {\n        case -1 | 1 => parent.parent\n        case x if x < -1 =>\n          if (parent.right.balanceFactor == 1) rotateRight(parent.right)\n          val newRoot = rotateLeft(parent)\n          if (parent == root) _root = newRoot\n          null\n        case x if x > 1 =>\n          if (parent.left.balanceFactor == -1) rotateLeft(parent.left)\n          val newRoot = rotateRight(parent)\n          if (parent == root) _root = newRoot\n          null\n        case _ => null\n      }\n    }\n\n    _size += 1\n    newNode\n  }\n\n  override def -=(key: A): AVLTree.this.type = {\n    remove(key)\n    this\n  }\n\n  override def remove(key: A): Boolean = {\n    var node = findNode(key).orNull\n    if (node == null) return false\n\n    if (node.left != null) {\n      var max = node.left\n\n      while (max.left != null || max.right != null) {\n        while (max.right != null) max = max.right\n\n        node._key = max.key\n        if (max.left != null) {\n          node = max\n          max = max.left\n        }\n      }\n      node._key = max.key\n      node = max\n    }\n\n    if (node.right != null) {\n      var min = node.right\n\n      while (min.left != null || min.right != null) {\n        while (min.left != null) min = min.left\n\n        node._key = min.key\n        if (min.right != null) {\n          node = min\n          min = min.right\n        }\n      }\n      node._key = min.key\n      node = min\n    }\n\n    var current = node\n    var parent = node.parent\n    while (parent != null) {\n      parent.balanceFactor += (if (parent.left == current) -1 else 1)\n\n      current = parent.balanceFactor match {\n        case x if x < -1 =>\n          if (parent.right.balanceFactor == 1) rotateRight(parent.right)\n          val newRoot = rotateLeft(parent)\n          if (parent == root) _root = newRoot\n          newRoot\n        case x if x > 1 =>\n          if (parent.left.balanceFactor == -1) rotateLeft(parent.left)\n          val newRoot = rotateRight(parent)\n          if (parent == root) _root = newRoot\n          newRoot\n        case _ => parent\n      }\n\n      parent = current.balanceFactor match {\n        case -1 | 1 => null\n        case _ => current.parent\n      }\n    }\n\n    if (node.parent != null) {\n      if (node.parent.left == node) {\n        node.parent._left = null\n      } else {\n        node.parent._right = null\n      }\n    }\n\n    if (node == root) _root = null\n\n    _size -= 1\n    true\n  }\n\n  def findNode(key: A): Option[AVLNode] = {\n    var node = root\n    while (node != null) {\n      val cmp = ordering.compare(key, node.key)\n      if (cmp == 0) return Some(node)\n      node = node.matchNextChild(cmp)\n    }\n    None\n  }\n\n  private def rotateLeft(node: AVLNode): AVLNode = {\n    val rightNode = node.right\n    node._right = rightNode.left\n    if (node.right != null) node.right._parent = node\n\n    rightNode._parent = node.parent\n    if (rightNode.parent != null) {\n      if (rightNode.parent.left == node) {\n        rightNode.parent._left = rightNode\n      } else {\n        rightNode.parent._right = rightNode\n      }\n    }\n\n    node._parent = rightNode\n    rightNode._left = node\n\n    node.balanceFactor += 1\n    if (rightNode.balanceFactor < 0) {\n      node.balanceFactor -= rightNode.balanceFactor\n    }\n\n    rightNode.balanceFactor += 1\n    if (node.balanceFactor > 0) {\n      rightNode.balanceFactor += node.balanceFactor\n    }\n    rightNode\n  }\n\n  private def rotateRight(node: AVLNode): AVLNode = {\n    val leftNode = node.left\n    node._left = leftNode.right\n    if (node.left != null) node.left._parent = node\n\n    leftNode._parent = node.parent\n    if (leftNode.parent != null) {\n      if (leftNode.parent.left == node) {\n        leftNode.parent._left = leftNode\n      } else {\n        leftNode.parent._right = leftNode\n      }\n    }\n\n    node._parent = leftNode\n    leftNode._right = node\n\n    node.balanceFactor -= 1\n    if (leftNode.balanceFactor > 0) {\n      node.balanceFactor -= leftNode.balanceFactor\n    }\n\n    leftNode.balanceFactor -= 1\n    if (node.balanceFactor < 0) {\n      leftNode.balanceFactor += node.balanceFactor\n    }\n    leftNode\n  }\n\n  override def contains(elem: A): Boolean = findNode(elem).isDefined\n\n  override def iterator: Iterator[A] = ???\n\n  override def keysIteratorFrom(start: A): Iterator[A] = ???\n\n  class AVLNode private[AVLTree](k: A, p: AVLNode = null) {\n\n    private[AVLTree] var _key: A = k\n    private[AVLTree] var _parent: AVLNode = p\n    private[AVLTree] var _left: AVLNode = _\n    private[AVLTree] var _right: AVLNode = _\n    private[AVLTree] var balanceFactor: Int = 0\n\n    def parent: AVLNode = _parent\n\n    private[AVLTree] def selectNextChild(key: A): AVLNode = matchNextChild(ordering.compare(key, this.key))\n\n    def key: A = _key\n\n    private[AVLTree] def matchNextChild(cmp: Int): AVLNode = cmp match {\n      case x if x < 0 => left\n      case x if x > 0 => right\n      case _ => null\n    }\n\n    def left: AVLNode = _left\n\n    def right: AVLNode = _right\n  }\n\n}\n\n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "D", "code": "\nTranslation of: Java\nimport std.stdio, std.algorithm;\n\nclass AVLtree {\n    private Node* root;\n\n    private static struct Node {\n        private int key, balance;\n        private Node* left, right, parent;\n\n        this(in int k, Node* p) pure nothrow @safe @nogc {\n            key = k;\n            parent = p;\n        }\n    }\n\n    public bool insert(in int key) pure nothrow @safe {\n        if (root is null)\n            root = new Node(key, null);\n        else {\n            Node* n = root;\n            Node* parent;\n            while (true) {\n                if (n.key == key)\n                    return false;\n\n                parent = n;\n\n                bool goLeft = n.key > key;\n                n = goLeft ? n.left : n.right;\n\n                if (n is null) {\n                    if (goLeft) {\n                        parent.left = new Node(key, parent);\n                    } else {\n                        parent.right = new Node(key, parent);\n                    }\n                    rebalance(parent);\n                    break;\n                }\n            }\n        }\n        return true;\n    }\n\n    public void deleteKey(in int delKey) pure nothrow @safe @nogc {\n        if (root is null)\n            return;\n        Node* n = root;\n        Node* parent = root;\n        Node* delNode = null;\n        Node* child = root;\n\n        while (child !is null) {\n            parent = n;\n            n = child;\n            child = delKey >= n.key ? n.right : n.left;\n            if (delKey == n.key)\n                delNode = n;\n        }\n\n        if (delNode !is null) {\n            delNode.key = n.key;\n\n            child = n.left !is null ? n.left : n.right;\n\n            if (root.key == delKey) {\n                root = child;\n            } else {\n                if (parent.left is n) {\n                    parent.left = child;\n                } else {\n                    parent.right = child;\n                }\n                rebalance(parent);\n            }\n        }\n    }\n\n    private void rebalance(Node* n) pure nothrow @safe @nogc {\n        setBalance(n);\n\n        if (n.balance == -2) {\n            if (height(n.left.left) >= height(n.left.right))\n                n = rotateRight(n);\n            else\n                n = rotateLeftThenRight(n);\n\n        } else if (n.balance == 2) {\n            if (height(n.right.right) >= height(n.right.left))\n                n = rotateLeft(n);\n            else\n                n = rotateRightThenLeft(n);\n        }\n\n        if (n.parent !is null) {\n            rebalance(n.parent);\n        } else {\n            root = n;\n        }\n    }\n\n    private Node* rotateLeft(Node* a) pure nothrow @safe @nogc {\n        Node* b = a.right;\n        b.parent = a.parent;\n\n        a.right = b.left;\n\n        if (a.right !is null)\n            a.right.parent = a;\n\n        b.left = a;\n        a.parent = b;\n\n        if (b.parent !is null) {\n            if (b.parent.right is a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node* rotateRight(Node* a) pure nothrow @safe @nogc {\n        Node* b = a.left;\n        b.parent = a.parent;\n\n        a.left = b.right;\n\n        if (a.left !is null)\n            a.left.parent = a;\n\n        b.right = a;\n        a.parent = b;\n\n        if (b.parent !is null) {\n            if (b.parent.right is a) {\n                b.parent.right = b;\n            } else {\n                b.parent.left = b;\n            }\n        }\n\n        setBalance(a, b);\n\n        return b;\n    }\n\n    private Node* rotateLeftThenRight(Node* n) pure nothrow @safe @nogc {\n        n.left = rotateLeft(n.left);\n        return rotateRight(n);\n    }\n\n    private Node* rotateRightThenLeft(Node* n) pure nothrow @safe @nogc {\n        n.right = rotateRight(n.right);\n        return rotateLeft(n);\n    }\n\n    private int height(in Node* n) const pure nothrow @safe @nogc {\n        if (n is null)\n            return -1;\n        return 1 + max(height(n.left), height(n.right));\n    }\n\n    private void setBalance(Node*[] nodes...) pure nothrow @safe @nogc {\n        foreach (n; nodes)\n            n.balance = height(n.right) - height(n.left);\n    }\n\n    public void printBalance() const @safe {\n        printBalance(root);\n    }\n\n    private void printBalance(in Node* n) const @safe {\n        if (n !is null) {\n            printBalance(n.left);\n            write(n.balance, ' ');\n            printBalance(n.right);\n        }\n    }\n}\n\nvoid main() @safe {\n    auto tree = new AVLtree();\n\n    writeln(\"Inserting values 1 to 10\");\n    foreach (immutable i; 1 .. 11)\n        tree.insert(i);\n\n    write(\"Printing balance: \");\n    tree.printBalance;\n}\n\n\nOutput:\nInserting values 1 to 10\nPrinting balance: 0 0 0 1 0 0 0 0 1 0 \n", "explain": ""}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\ndata Tree a\n  = Leaf\n  | Node\n      Int\n      (Tree a)\n      a\n      (Tree a)\n  deriving (Show, Eq)\n \nfoldTree :: Ord a => [a] -> Tree a\nfoldTree = foldr insert Leaf\n \nheight :: Tree a -> Int\nheight Leaf = -1\nheight (Node h _ _ _) = h\n \ndepth :: Tree a -> Tree a -> Int\ndepth a b = succ (max (height a) (height b))\n \ninsert :: Ord a => a -> Tree a -> Tree a\ninsert v Leaf = Node 1 Leaf v Leaf\ninsert v t@(Node n left v_ right)\n  | v_ < v = rotate $ Node n left v_ (insert v right)\n  | v_ > v = rotate $ Node n (insert v left) v_ right\n  | otherwise = t\n \nmax_ :: Ord a => Tree a -> Maybe a\nmax_ Leaf = Nothing\nmax_ (Node _ _ v right) =\n  case right of\n    Leaf -> Just v\n    _ -> max_ right\n \ndelete :: Ord a => a -> Tree a -> Tree a\ndelete _ Leaf = Leaf\ndelete x (Node h left v right)\n  | x == v =\n    maybe left (rotate . (Node h left <*> (`delete` right))) (max_ right)\n  | x > v = rotate $ Node h left v (delete x right)\n  | x < v = rotate $ Node h (delete x left) v right\n \nrotate :: Tree a -> Tree a\nrotate Leaf = Leaf\nrotate (Node h (Node lh ll lv lr) v r)\n  -- Left Left.\n  | lh - height r > 1 && height ll - height lr > 0 =\n    Node lh ll lv (Node (depth r lr) lr v r)\nrotate (Node h l v (Node rh rl rv rr))\n  -- Right Right.\n  | rh - height l > 1 && height rr - height rl > 0 =\n    Node rh (Node (depth l rl) l v rl) rv rr\nrotate (Node h (Node lh ll lv (Node rh rl rv rr)) v r)\n  -- Left Right.\n  | lh - height r > 1 =\n    Node h (Node (rh + 1) (Node (lh - 1) ll lv rl) rv rr) v r\nrotate (Node h l v (Node rh (Node lh ll lv lr) rv rr))\n  -- Right Left.\n  | rh - height l > 1 =\n    Node h l v (Node (lh + 1) ll lv (Node (rh - 1) lr rv rr))\nrotate (Node h l v r) =\n  -- Re-weighting.\n  let (l_, r_) = (rotate l, rotate r)\n   in Node (depth l_ r_) l_ v r_\n \ndraw :: Show a => Tree a -> String\ndraw t = '\\n' : draw_ t 0 <> \"\\n\"\n  where\n    draw_ Leaf _ = []\n    draw_ (Node h l v r) d = draw_ r (d + 1) <> node <> draw_ l (d + 1)\n      where\n        node = padding d <> show (v, h) <> \"\\n\"\n        padding n = replicate (n * 4) ' '\n \nmain :: IO ()\nmain = putStr $ draw $ foldTree [1 .. 31]\n\n\nOutput:\n                (31,0)\n            (30,1)\n                (29,0)\n        (28,2)\n                (27,0)\n            (26,1)\n                (25,0)\n    (24,3)\n                (23,0)\n            (22,1)\n                (21,0)\n        (20,2)\n                (19,0)\n            (18,1)\n                (17,0)\n(16,4)\n                (15,0)\n            (14,1)\n                (13,0)\n        (12,2)\n                (11,0)\n            (10,1)\n                (9,0)\n    (8,3)\n                (7,0)\n            (6,1)\n                (5,0)\n        (4,2)\n                (3,0)\n            (2,1)\n                (1,0)\n", "explain": "Based on solution of homework #4 from course http://www.seas.upenn.edu/~cis194/spring13/lectures.html.\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "Scheme", "code": "\nTranslation of: Fortran\n\nWorks with: CHICKEN version 5.3.0\nLibrary: r7rs\n\n(cond-expand\n  (r7rs)\n  (chicken (import r7rs)))\n\n(define-library (avl-trees)\n\n  ;;\n  ;; This library implements \u2018persistent\u2019 (that is, \u2018immutable\u2019) AVL\n  ;; trees for R7RS Scheme.\n  ;;\n  ;; Included are generators of the key-data pairs in a tree. Because\n  ;; the trees are persistent (\u2018immutable\u2019), these generators are safe\n  ;; from alterations of the tree.\n  ;;\n  ;; References:\n  ;;\n  ;;   * Niklaus Wirth, 1976. Algorithms + Data Structures =\n  ;;     Programs. Prentice-Hall, Englewood Cliffs, New Jersey.\n  ;;\n  ;;   * Niklaus Wirth, 2004. Algorithms and Data Structures. Updated\n  ;;     by Fyodor Tkachov, 2014.\n  ;;\n  ;; Note that the references do not discuss persistent\n  ;; implementations. It seems worthwhile to compare the methods of\n  ;; implementation.\n  ;;\n\n  (export avl)\n  (export alist->avl)\n  (export avl->alist)\n  (export avl?)\n  (export avl-empty?)\n  (export avl-size)\n  (export avl-insert)\n  (export avl-delete)\n  (export avl-delete-values)\n  (export avl-has-key?)\n  (export avl-search)\n  (export avl-search-values)\n  (export avl-make-generator)\n  (export avl-pretty-print)\n  (export avl-check-avl-condition)\n  (export avl-check-usage)\n\n  (import (scheme base))\n  (import (scheme case-lambda))\n  (import (scheme process-context))\n  (import (scheme write))\n\n  (cond-expand\n    (chicken\n     (import (only (chicken base) define-record-printer))\n     (import (only (chicken format) format))) ; For debugging.\n    (else))\n\n  (begin\n\n    ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n    ;;\n    ;; Tools for making generators. These use call/cc and so might be\n    ;; inefficient in your Scheme. I am using CHICKEN, in which\n    ;; call/cc is not so inefficient.\n    ;;\n    ;; Often I have made &fail a unique object rather than #f, but in\n    ;; this case #f will suffice.\n    ;;\n\n    (define &fail #f)\n\n    (define *suspend*\n      (make-parameter (lambda (x) x)))\n\n    (define (suspend v)\n      ((*suspend*) v))\n\n    (define (fail-forever)\n      (let loop ()\n        (suspend &fail)\n        (loop)))\n\n    (define (make-generator-procedure thunk)\n      ;; Make a suspendable procedure that takes no arguments. The\n      ;; result is a simple generator of values. (This can be\n      ;; elaborated upon for generators to take values on resumption,\n      ;; in the manner of Icon co-expressions.)\n      (define (next-run return)\n        (define (my-suspend v)\n          (set! return (call/cc (lambda (resumption-point)\n                                  (set! next-run resumption-point)\n                                  (return v)))))\n        (parameterize ((*suspend* my-suspend))\n          (suspend (thunk))\n          (fail-forever)))\n      (lambda () (call/cc next-run)))\n\n    ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    (define-syntax avl-check-usage\n      (syntax-rules ()\n        ((_ pred msg)\n         (or pred (usage-error msg)))))\n\n    ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    (define-record-type <avl>\n      (%avl key data bal left right)\n      avl?\n      (key %key)\n      (data %data)\n      (bal %bal)\n      (left %left)\n      (right %right))\n\n    (cond-expand\n      (chicken (define-record-printer (<avl> rt out)\n                 (display \"#<avl \" out)\n                 (display (%key rt) out)\n                 (display \" \" out)\n                 (display (%data rt) out)\n                 (display \" \" out)\n                 (display (%bal rt) out)\n                 (display \" \" out)\n                 (display (%left rt) out)\n                 (display \" \" out)\n                 (display (%right rt) out)\n                 (display \">\" out)))\n      (else))\n\n    ;; - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -\n\n    (define avl\n      (case-lambda\n        (() (%avl #f #f #f #f #f))\n        ((pred<? . args) (alist->avl pred<? args))))\n\n    (define (avl-empty? tree)\n      (avl-check-usage\n       (avl? tree)\n       \"avl-empty? expects an AVL tree as argument\")\n      (not (%bal tree)))\n\n    (define (avl-size tree)\n      (define (traverse p sz)\n        (if (not p)\n            sz\n            (traverse (%left p) (traverse (%right p) (+ sz 1)))))\n      (if (avl-empty? tree)\n          0\n          (traverse tree 0)))\n\n    (define (avl-has-key? pred<? tree key)\n      (define (search p)\n        (and p\n             (let ((k (%key p)))\n               (cond ((pred<? key k) (search (%left p)))\n                     ((pred<? k key) (search (%right p)))\n                     (else #t)))))\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-has-key? expects a procedure as first argument\")\n      (and (not (avl-empty? tree))\n           (search tree)))\n\n    (define (avl-search pred<? tree key)\n      ;; Return the data matching a key, or #f if the key is not\n      ;; found. (Note that the data matching the key might be #f.)\n      (define (search p)\n        (and p\n             (let ((k (%key p)))\n               (cond ((pred<? key k) (search (%left p)))\n                     ((pred<? k key) (search (%right p)))\n                     (else (%data p))))))\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-search expects a procedure as first argument\")\n      (and (not (avl-empty? tree))\n           (search tree)))\n\n    (define (avl-search-values pred<? tree key)\n      ;; Return two values: the data matching the key, or #f is the\n      ;; key is not found; and a second value that is either #f or #t,\n      ;; depending on whether the key is found.\n      (define (search p)\n        (if (not p)\n            (values #f #f)\n            (let ((k (%key p)))\n              (cond ((pred<? key k) (search (%left p)))\n                    ((pred<? k key) (search (%right p)))\n                    (else (values (%data p) #t))))))\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-search-values expects a procedure as first argument\")\n      (if (avl-empty? tree)\n          (values #f #f)\n          (search tree)))\n\n    (define (alist->avl pred<? alst)\n      ;; Go from association list to AVL tree.\n      (avl-check-usage\n       (procedure? pred<?)\n       \"alist->avl expects a procedure as first argument\")\n      (let loop ((tree (avl))\n                 (lst alst))\n        (if (null? lst)\n            tree\n            (let ((head (car lst)))\n              (loop (avl-insert pred<? tree (car head) (cdr head))\n                    (cdr lst))))))\n\n    (define (avl->alist tree)\n      ;; Go from AVL tree to association list. The output will be in\n      ;; order.\n      (define (traverse p lst)\n        ;; Reverse in-order traversal of the tree, to produce an\n        ;; in-order cons-list.\n        (if (not p)\n            lst\n            (traverse (%left p) (cons (cons (%key p) (%data p))\n                                      (traverse (%right p) lst)))))\n      (if (avl-empty? tree)\n          '()\n          (traverse tree '())))\n\n    (define (avl-insert pred<? tree key data)\n\n      (define (search p fix-balance?)\n        (cond\n         ((not p)\n          ;; The key was not found. Make a new node and set\n          ;; fix-balance?\n          (values (%avl key data 0 #f #f) #t))\n\n         ((pred<? key (%key p))\n          ;; Continue searching.\n          (let-values (((p1 fix-balance?)\n                        (search (%left p) fix-balance?)))\n            (cond\n             ((not fix-balance?)\n              (let ((p^ (%avl (%key p) (%data p) (%bal p)\n                              p1 (%right p))))\n                (values p^ #f)))\n             (else\n              ;; A new node has been inserted on the left side.\n              (case (%bal p)\n                ((1)\n                 (let ((p^ (%avl (%key p) (%data p) 0\n                                 p1 (%right p))))\n                   (values p^ #f)))\n                ((0)\n                 (let ((p^ (%avl (%key p) (%data p) -1\n                                 p1 (%right p))))\n                   (values p^ fix-balance?)))\n                ((-1)\n                 ;; Rebalance.\n                 (case (%bal p1)\n                   ((-1)\n                    ;; A single LL rotation.\n                    (let* ((p^ (%avl (%key p) (%data p) 0\n                                     (%right p1) (%right p)))\n                           (p1^ (%avl (%key p1) (%data p1) 0\n                                      (%left p1) p^)))\n                      (values p1^ #f)))\n                   ((0 1)\n                    ;; A double LR rotation.\n                    (let* ((p2 (%right p1))\n                           (bal2 (%bal p2))\n                           (p^ (%avl (%key p) (%data p)\n                                     (- (min bal2 0))\n                                     (%right p2) (%right p)))\n                           (p1^ (%avl (%key p1) (%data p1)\n                                      (- (max bal2 0))\n                                      (%left p1) (%left p2)))\n                           (p2^ (%avl (%key p2) (%data p2) 0\n                                      p1^ p^)))\n                      (values p2^ #f)))\n                   (else (internal-error))))\n                (else (internal-error)))))))\n\n         ((pred<? (%key p) key)\n          ;; Continue searching.\n          (let-values (((p1 fix-balance?)\n                        (search (%right p) fix-balance?)))\n            (cond\n             ((not fix-balance?)\n              (let ((p^ (%avl (%key p) (%data p) (%bal p)\n                              (%left p) p1)))\n                (values p^ #f)))\n             (else\n              ;; A new node has been inserted on the right side.\n              (case (%bal p)\n                ((-1)\n                 (let ((p^ (%avl (%key p) (%data p) 0\n                                 (%left p) p1)))\n                   (values p^ #f)))\n                ((0)\n                 (let ((p^ (%avl (%key p) (%data p) 1\n                                 (%left p) p1)))\n                   (values p^ fix-balance?)))\n                ((1)\n                 ;; Rebalance.\n                 (case (%bal p1)\n                   ((1)\n                    ;; A single RR rotation.\n                    (let* ((p^ (%avl (%key p) (%data p) 0\n                                     (%left p) (%left p1)))\n                           (p1^ (%avl (%key p1) (%data p1) 0\n                                      p^ (%right p1))))\n                      (values p1^ #f)))\n                   ((-1 0)\n                    ;; A double RL rotation.\n                    (let* ((p2 (%left p1))\n                           (bal2 (%bal p2))\n                           (p^ (%avl (%key p) (%data p)\n                                     (- (max bal2 0))\n                                     (%left p) (%left p2)))\n                           (p1^ (%avl (%key p1) (%data p1)\n                                      (- (min bal2 0))\n                                      (%right p2) (%right p1)))\n                           (p2^ (%avl (%key p2) (%data p2) 0\n                                      p^ p1^)))\n                      (values p2^ #f)))\n                   (else (internal-error))))\n                (else (internal-error)))))))\n\n         (else\n          ;; The key was found; p is an existing node.\n          (values (%avl key data (%bal p) (%left p) (%right p))\n                  #f))))\n\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-insert expects a procedure as first argument\")\n      (if (avl-empty? tree)\n          (%avl key data 0 #f #f)\n          (let-values (((p fix-balance?) (search tree #f)))\n            p)))\n\n    (define (avl-delete pred<? tree key)\n      ;; If one is not interested in whether the key was in the tree,\n      ;; then throw away that information.\n      (let-values (((tree had-key?)\n                    (avl-delete-values pred<? tree key)))\n        tree))\n\n    (define (balance-for-shrunken-left p)\n      ;; Returns two values: a new p and a new fix-balance?\n      (case (%bal p)\n        ((-1) (values (%avl (%key p) (%data p) 0\n                            (%left p) (%right p))\n                      #t))\n        ((0) (values (%avl (%key p) (%data p) 1\n                           (%left p) (%right p))\n                     #f))\n        ((1)\n         ;; Rebalance.\n         (let* ((p1 (%right p))\n                (bal1 (%bal p1)))\n           (case bal1\n             ((0)\n              ;; A single RR rotation.\n              (let* ((p^ (%avl (%key p) (%data p) 1\n                               (%left p) (%left p1)))\n                     (p1^ (%avl (%key p1) (%data p1) -1\n                                p^ (%right p1))))\n                (values p1^ #f)))\n             ((1)\n              ;; A single RR rotation.\n              (let* ((p^ (%avl (%key p) (%data p) 0\n                               (%left p) (%left p1)))\n                     (p1^ (%avl (%key p1) (%data p1) 0\n                                p^ (%right p1))))\n                (values p1^ #t)))\n             ((-1)\n              ;; A double RL rotation.\n              (let* ((p2 (%left p1))\n                     (bal2 (%bal p2))\n                     (p^ (%avl (%key p) (%data p) (- (max bal2 0))\n                               (%left p) (%left p2)))\n                     (p1^ (%avl (%key p1) (%data p1) (- (min bal2 0))\n                                (%right p2) (%right p1)))\n                     (p2^ (%avl (%key p2) (%data p2) 0 p^ p1^)))\n                (values p2^ #t)))\n             (else (internal-error)))))\n        (else (internal-error))))\n\n    (define (balance-for-shrunken-right p)\n      ;; Returns two values: a new p and a new fix-balance?\n      (case (%bal p)\n        ((1) (values (%avl (%key p) (%data p) 0\n                           (%left p) (%right p))\n                     #t))\n        ((0) (values (%avl (%key p) (%data p) -1\n                           (%left p) (%right p))\n                     #f))\n        ((-1)\n         ;; Rebalance.\n         (let* ((p1 (%left p))\n                (bal1 (%bal p1)))\n           (case bal1\n             ((0)\n              ;; A single LL rotation.\n              (let* ((p^ (%avl (%key p) (%data p) -1\n                               (%right p1) (%right p)))\n                     (p1^ (%avl (%key p1) (%data p1) 1\n                                (%left p1) p^)))\n                (values p1^ #f)))\n             ((-1)\n              ;; A single LL rotation.\n              (let* ((p^ (%avl (%key p) (%data p) 0\n                               (%right p1) (%right p)))\n                     (p1^ (%avl (%key p1) (%data p1) 0\n                                (%left p1) p^)))\n                (values p1^ #t)))\n             ((1)\n              ;; A double LR rotation.\n              (let* ((p2 (%right p1))\n                     (bal2 (%bal p2))\n                     (p^ (%avl (%key p) (%data p) (- (min bal2 0))\n                               (%right p2) (%right p)))\n                     (p1^ (%avl (%key p1) (%data p1) (- (max bal2 0))\n                                (%left p1) (%left p2)))\n                     (p2^ (%avl (%key p2) (%data p2) 0 p1^ p^)))\n                (values p2^ #t)))\n             (else (internal-error)))))\n        (else (internal-error))))\n\n    (define (avl-delete-values pred<? tree key)\n\n      (define-syntax balance-L\n        (syntax-rules ()\n          ((_ p fix-balance?)\n           (if fix-balance?\n               (balance-for-shrunken-left p)\n               (values p #f)))))\n\n      (define-syntax balance-R\n        (syntax-rules ()\n          ((_ p fix-balance?)\n           (if fix-balance?\n               (balance-for-shrunken-right p)\n               (values p #f)))))\n\n      (define (del r fix-balance?)\n        ;; Returns a new r, a new fix-balance?, and key and data to be\n        ;; \u2018moved up the tree\u2019.\n        (if (%right r)\n            (let*-values\n                (((q fix-balance? key^ data^)\n                  (del (%right r) fix-balance?))\n                 ((r fix-balance?)\n                  (balance-R (%avl (%key r) (%data r) (%bal r)\n                                   (%left r) q)\n                             fix-balance?)))\n              (values r fix-balance? key^ data^))\n            (values (%left r) #t (%key r) (%data r))))\n\n      (define (search p fix-balance?)\n        ;; Return three values: a new p, a new fix-balance, and\n        ;; whether the key was found.\n        (cond\n         ((not p) (values #f #f #f))\n         ((pred<? key (%key p))\n          ;; Recursive search down the left branch.\n          (let*-values\n              (((q fix-balance? found?)\n                (search (%left p) fix-balance?))\n               ((p fix-balance?)\n                (balance-L (%avl (%key p) (%data p) (%bal p)\n                                 q (%right p))\n                           fix-balance?)))\n            (values p fix-balance? found?)))\n         ((pred<? (%key p) key)\n          ;; Recursive search down the right branch.\n          (let*-values\n              (((q fix-balance? found?)\n                (search (%right p) fix-balance?))\n               ((p fix-balance?)\n                (balance-R (%avl (%key p) (%data p) (%bal p)\n                                 (%left p) q)\n                           fix-balance?)))\n            (values p fix-balance? found?)))\n         ((not (%right p))\n          ;; Delete p, replace it with its left branch, then\n          ;; rebalance.\n          (values (%left p) #t #t))\n         ((not (%left p))\n          ;; Delete p, replace it with its right branch, then\n          ;; rebalance.\n          (values (%right p) #t #t))\n         (else\n          ;; Delete p, but it has both left and right branches,\n          ;; and therefore may have complicated branch structure.\n          (let*-values\n              (((q fix-balance? key^ data^)\n                (del (%left p) fix-balance?))\n               ((p fix-balance?)\n                (balance-L (%avl key^ data^ (%bal p) q (%right p))\n                           fix-balance?)))\n            (values p fix-balance? #t)))))\n\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-delete-values expects a procedure as first argument\")\n      (if (avl-empty? tree)\n          (values tree #f)\n          (let-values (((tree fix-balance? found?)\n                        (search tree #f)))\n            (if found?\n                (values (or tree (avl)) #t)\n                (values tree #f)))))\n\n    (define avl-make-generator\n      (case-lambda\n        ((tree) (avl-make-generator tree 1))\n        ((tree direction)\n         (if (negative? direction)\n             (make-generator-procedure\n              (lambda ()\n                (define (traverse p)\n                  (unless (or (not p) (avl-empty? p))\n                    (traverse (%right p))\n                    (suspend (cons (%key p) (%data p)))\n                    (traverse (%left p)))\n                  &fail)\n                (traverse tree)))\n             (make-generator-procedure\n              (lambda ()\n                (define (traverse p)\n                  (unless (or (not p) (avl-empty? p))\n                    (traverse (%left p))\n                    (suspend (cons (%key p) (%data p)))\n                    (traverse (%right p)))\n                  &fail)\n                (traverse tree)))))))\n\n    (define avl-pretty-print\n      (case-lambda\n        ((tree)\n         (avl-pretty-print tree (current-output-port)))\n        ((tree port)\n         (avl-pretty-print tree port\n                           (lambda (port key data)\n                             (display \"(\" port)\n                             (write key port)\n                             (display \", \" port)\n                             (write data port)\n                             (display \")\" port))))\n        ((tree port key-data-printer)\n         ;; In-order traversal, so the printing is done in\n         ;; order. Reflect the display diagonally to get the more\n         ;; usual orientation of left-to-right, top-to-bottom.\n         (define (pad depth)\n           (unless (zero? depth)\n             (display \"  \" port)\n             (pad (- depth 1))))\n         (define (traverse p depth)\n           (when p\n             (traverse (%left p) (+ depth 1))\n             (pad depth)\n             (key-data-printer port (%key p) (%data p))\n             (display \"\\t\\tdepth = \" port)\n             (display depth port)\n             (display \" bal = \" port)\n             (display (%bal p) port)\n             (display \"\\n\" port)\n             (traverse (%right p) (+ depth 1))))\n         (unless (avl-empty? tree)\n           (traverse (%left tree) 1)\n           (key-data-printer port (%key tree) (%data tree))\n           (display \"\\t\\tdepth = 0  bal = \" port)\n           (display (%bal tree) port)\n           (display \"\\n\" port)\n           (traverse (%right tree) 1)))))\n\n    (define (avl-check-avl-condition tree)\n      ;; Check that the AVL condition is satisfied.\n      (define (check-heights height-L height-R)\n        (when (<= 2 (abs (- height-L height-R)))\n          (display \"*** AVL condition violated ***\"\n                   (current-error-port))\n          (internal-error)))\n      (define (get-heights p)\n        (if (not p)\n            (values 0 0)\n            (let-values (((height-LL height-LR)\n                          (get-heights (%left p)))\n                         ((height-RL height-RR)\n                          (get-heights (%right p))))\n              (check-heights height-LL height-LR)\n              (check-heights height-RL height-RR)\n              (values (+ height-LL height-LR)\n                      (+ height-RL height-RR)))))\n      (unless (avl-empty? tree)\n        (let-values (((height-L height-R) (get-heights tree)))\n          (check-heights height-L height-R))))\n\n    (define (internal-error)\n      (display \"internal error\\n\" (current-error-port))\n      (emergency-exit 123))\n\n    (define (usage-error msg)\n      (display \"Procedure usage error:\\n\" (current-error-port))\n      (display \"  \" (current-error-port))\n      (display msg (current-error-port))\n      (newline (current-error-port))\n      (exit 1))\n\n    )) ;; end library (avl-trees)\n\n\n(cond-expand\n  (DEMONSTRATION\n   (begin\n     (import (avl-trees))\n     (import (scheme base))\n     (import (scheme time))\n     (import (scheme process-context))\n     (import (scheme write))\n\n     (cond-expand\n       (chicken\n        (import (only (chicken format) format))) ; For debugging.\n       (else))\n\n     (define 2**64 (expt 2 64))\n\n     (define seed (truncate-remainder (exact (current-second)) 2**64))\n     (define random\n       ;; A really slow (but presumably highly portable)\n       ;; implementation of Donald Knuth\u2019s linear congruential random\n       ;; number generator, returning a rational number in [0,1). See\n       ;; https://en.wikipedia.org/w/index.php?title=Linear_congruential_generator&oldid=1076681286\n       (let ((a 6364136223846793005)\n             (c 1442695040888963407))\n         (lambda ()\n           (let ((result (/ seed 2**64)))\n             (set! seed (truncate-remainder (+ (* a seed) c) 2**64))\n             result))))\n     (do ((i 0 (+ i 1)))\n         ((= i 10))\n       (random))\n\n     (define (fisher-yates-shuffle keys)\n       (let ((n (vector-length keys)))\n         (do ((i 1 (+ i 1)))\n             ((= i n))\n           (let* ((randnum (random))\n                  (j (+ i (floor (* randnum (- n i)))))\n                  (xi (vector-ref keys i))\n                  (xj (vector-ref keys j)))\n             (vector-set! keys i xj)\n             (vector-set! keys j xi)))))\n\n     (define (display-key-data key data)\n       (display \"(\")\n       (write key)\n       (display \", \")\n       (write data)\n       (display \")\"))\n\n     (define (display-tree-contents tree)\n       (do ((p (avl->alist tree) (cdr p)))\n           ((null? p))\n         (display-key-data (caar p) (cdar p))\n         (newline)))\n\n     (define (error-stop)\n       (display \"*** ERROR STOP ***\\n\" (current-error-port))\n       (emergency-exit 1))\n\n     (define n 20)\n     (define keys (make-vector (+ n 1)))\n     (do ((i 0 (+ i 1)))\n         ((= i n))\n       ;; To keep things more like Fortran, do not use index zero.\n       (vector-set! keys (+ i 1) (+ i 1)))\n\n     (fisher-yates-shuffle keys)\n\n     ;; Insert key-data pairs in the shuffled order.\n     (define tree (avl))\n     (avl-check-avl-condition tree)\n     (do ((i 1 (+ i 1)))\n         ((= i (+ n 1)))\n       (let ((ix (vector-ref keys i)))\n         (set! tree (avl-insert < tree ix (inexact ix)))\n         (avl-check-avl-condition tree)\n         (do ((j 1 (+ j 1)))\n             ((= j (+ n 1)))\n           (let*-values (((k) (vector-ref keys j))\n                         ((has-key?) (avl-has-key? < tree k))\n                         ((data) (avl-search < tree k))\n                         ((data^ has-key?^)\n                          (avl-search-values < tree k)))\n             (unless (exact? k) (error-stop))\n             (if (<= j i)\n                 (unless (and has-key? data data^ has-key?^\n                              (inexact? data) (= data k)\n                              (inexact? data^) (= data^ k))\n                   (error-stop))\n                 (when (or has-key? data data^ has-key?^)\n                   (error-stop)))))))\n\n     (display \"----------------------------------------------------------------------\\n\")     \n     (display \"keys = \")\n     (write (cdr (vector->list keys)))\n     (newline)\n     (display \"----------------------------------------------------------------------\\n\")\n     (avl-pretty-print tree)\n     (display \"----------------------------------------------------------------------\\n\")\n     (display \"tree size = \")\n     (display (avl-size tree))\n     (newline)\n     (display-tree-contents tree)\n     (display \"----------------------------------------------------------------------\\n\")\n\n     ;;\n     ;; Reshuffle the keys, and change the data from inexact numbers\n     ;; to strings.\n     ;;\n\n     (fisher-yates-shuffle keys)\n\n     (do ((i 1 (+ i 1)))\n         ((= i (+ n 1)))\n       (let ((ix (vector-ref keys i)))\n         (set! tree (avl-insert < tree ix (number->string ix)))\n         (avl-check-avl-condition tree)))\n\n     (avl-pretty-print tree)\n     (display \"----------------------------------------------------------------------\\n\")\n     (display \"tree size = \")\n     (display (avl-size tree))\n     (newline)\n     (display-tree-contents tree)\n     (display \"----------------------------------------------------------------------\\n\")\n\n     ;;\n     ;; Reshuffle the keys, and delete the contents of the tree, but\n     ;; also keep the original tree by saving it in a variable. Check\n     ;; persistence of the tree.\n     ;;\n\n     (fisher-yates-shuffle keys)\n\n     (define saved-tree tree)\n\n     (do ((i 1 (+ i 1)))\n         ((= i (+ n 1)))\n       (let ((ix (vector-ref keys i)))\n         (set! tree (avl-delete < tree ix))\n         (avl-check-avl-condition tree)\n         (unless (= (avl-size tree) (- n i)) (error-stop))\n         ;; Try deleting a second time.\n         (set! tree (avl-delete < tree ix))\n         (avl-check-avl-condition tree)\n         (unless (= (avl-size tree) (- n i)) (error-stop))\n         (do ((j 1 (+ j 1)))\n             ((= j (+ n 1)))\n           (let ((jx (vector-ref keys j)))\n             (unless (eq? (avl-has-key? < tree jx) (< i j))\n               (error-stop))\n             (let ((data (avl-search < tree jx)))\n               (unless (eq? (not (not data)) (< i j))\n                 (error-stop))\n               (unless (or (not data)\n                           (= (string->number data) jx))\n                 (error-stop)))\n             (let-values (((data found?)\n                           (avl-search-values < tree jx)))\n               (unless (eq? found? (< i j)) (error-stop))\n               (unless (or (and (not data) (<= j i))\n                           (and data (= (string->number data) jx)))\n                 (error-stop)))))))\n     (do ((i 1 (+ i 1)))\n         ((= i (+ n 1)))\n       ;; Is save-tree the persistent value of the tree we just\n       ;; deleted?\n       (let ((ix (vector-ref keys i)))\n         (unless (equal? (avl-search < saved-tree ix)\n                         (number->string ix))\n           (error-stop))))\n\n     (display \"forwards generator:\\n\")\n     (let ((gen (avl-make-generator saved-tree)))\n       (do ((pair (gen) (gen)))\n           ((not pair))\n         (display-key-data (car pair) (cdr pair))\n         (newline)))\n\n     (display \"----------------------------------------------------------------------\\n\")\n\n     (display \"backwards generator:\\n\")\n     (let ((gen (avl-make-generator saved-tree -1)))\n       (do ((pair (gen) (gen)))\n           ((not pair))\n         (display-key-data (car pair) (cdr pair))\n         (newline)))\n\n     (display \"----------------------------------------------------------------------\\n\")\n\n     ))\n  (else))\n\n\nOutput:\n\n$ csc -DDEMONSTRATION -R r7rs -X r7rs avl_trees-scheme.scm && ./avl_trees-scheme\n----------------------------------------------------------------------\nkeys = (12 16 20 6 9 18 15 10 13 4 2 7 11 5 8 3 19 14 17 1)\n----------------------------------------------------------------------\n        (1, 1.0)\t\tdepth = 4 bal = 0\n      (2, 2.0)\t\tdepth = 3 bal = 0\n        (3, 3.0)\t\tdepth = 4 bal = 0\n    (4, 4.0)\t\tdepth = 2 bal = -1\n      (5, 5.0)\t\tdepth = 3 bal = 0\n  (6, 6.0)\t\tdepth = 1 bal = 0\n      (7, 7.0)\t\tdepth = 3 bal = 1\n        (8, 8.0)\t\tdepth = 4 bal = 0\n    (9, 9.0)\t\tdepth = 2 bal = 0\n      (10, 10.0)\t\tdepth = 3 bal = 1\n        (11, 11.0)\t\tdepth = 4 bal = 0\n(12, 12.0)\t\tdepth = 0  bal = 0\n      (13, 13.0)\t\tdepth = 3 bal = 0\n    (14, 14.0)\t\tdepth = 2 bal = 0\n      (15, 15.0)\t\tdepth = 3 bal = 0\n  (16, 16.0)\t\tdepth = 1 bal = 1\n        (17, 17.0)\t\tdepth = 4 bal = 0\n      (18, 18.0)\t\tdepth = 3 bal = -1\n    (19, 19.0)\t\tdepth = 2 bal = -1\n      (20, 20.0)\t\tdepth = 3 bal = 0\n----------------------------------------------------------------------\ntree size = 20\n(1, 1.0)\n(2, 2.0)\n(3, 3.0)\n(4, 4.0)\n(5, 5.0)\n(6, 6.0)\n(7, 7.0)\n(8, 8.0)\n(9, 9.0)\n(10, 10.0)\n(11, 11.0)\n(12, 12.0)\n(13, 13.0)\n(14, 14.0)\n(15, 15.0)\n(16, 16.0)\n(17, 17.0)\n(18, 18.0)\n(19, 19.0)\n(20, 20.0)\n----------------------------------------------------------------------\n        (1, \"1\")\t\tdepth = 4 bal = 0\n      (2, \"2\")\t\tdepth = 3 bal = 0\n        (3, \"3\")\t\tdepth = 4 bal = 0\n    (4, \"4\")\t\tdepth = 2 bal = -1\n      (5, \"5\")\t\tdepth = 3 bal = 0\n  (6, \"6\")\t\tdepth = 1 bal = 0\n      (7, \"7\")\t\tdepth = 3 bal = 1\n        (8, \"8\")\t\tdepth = 4 bal = 0\n    (9, \"9\")\t\tdepth = 2 bal = 0\n      (10, \"10\")\t\tdepth = 3 bal = 1\n        (11, \"11\")\t\tdepth = 4 bal = 0\n(12, \"12\")\t\tdepth = 0  bal = 0\n      (13, \"13\")\t\tdepth = 3 bal = 0\n    (14, \"14\")\t\tdepth = 2 bal = 0\n      (15, \"15\")\t\tdepth = 3 bal = 0\n  (16, \"16\")\t\tdepth = 1 bal = 1\n        (17, \"17\")\t\tdepth = 4 bal = 0\n      (18, \"18\")\t\tdepth = 3 bal = -1\n    (19, \"19\")\t\tdepth = 2 bal = -1\n      (20, \"20\")\t\tdepth = 3 bal = 0\n----------------------------------------------------------------------\ntree size = 20\n(1, \"1\")\n(2, \"2\")\n(3, \"3\")\n(4, \"4\")\n(5, \"5\")\n(6, \"6\")\n(7, \"7\")\n(8, \"8\")\n(9, \"9\")\n(10, \"10\")\n(11, \"11\")\n(12, \"12\")\n(13, \"13\")\n(14, \"14\")\n(15, \"15\")\n(16, \"16\")\n(17, \"17\")\n(18, \"18\")\n(19, \"19\")\n(20, \"20\")\n----------------------------------------------------------------------\nforwards generator:\n(1, \"1\")\n(2, \"2\")\n(3, \"3\")\n(4, \"4\")\n(5, \"5\")\n(6, \"6\")\n(7, \"7\")\n(8, \"8\")\n(9, \"9\")\n(10, \"10\")\n(11, \"11\")\n(12, \"12\")\n(13, \"13\")\n(14, \"14\")\n(15, \"15\")\n(16, \"16\")\n(17, \"17\")\n(18, \"18\")\n(19, \"19\")\n(20, \"20\")\n----------------------------------------------------------------------\nbackwards generator:\n(20, \"20\")\n(19, \"19\")\n(18, \"18\")\n(17, \"17\")\n(16, \"16\")\n(15, \"15\")\n(14, \"14\")\n(13, \"13\")\n(12, \"12\")\n(11, \"11\")\n(10, \"10\")\n(9, \"9\")\n(8, \"8\")\n(7, \"7\")\n(6, \"6\")\n(5, \"5\")\n(4, \"4\")\n(3, \"3\")\n(2, \"2\")\n(1, \"1\")\n----------------------------------------------------------------------\n", "explain": "See also ATS.\nIn the following, an argument key a is consider to match a stored key b if neither (pred<? a b) nor (pred<? b a). So pred<? should be analogous to <. No equality predicate is needed.\nThe demonstration is randomized. The following is an example of one run.\nThe \u2018pretty printed\u2019 tree is a diagonal reflection of the usual from-the-root-downwards, left-to-right representation. It goes from-the-root-rightwards, top-to-bottom.\n"}, {"task_name": "AVL tree", "task_url": "https://rosettacode.org/wiki/AVL_tree", "task_cat": "Data Structures", "lang": "TypeScript", "code": "\nTranslation of: Java\n\n/** A single node in an AVL tree */\nclass AVLnode <T> {\n    balance: number\n    left: AVLnode<T>\n    right: AVLnode<T>\n\n    constructor(public key: T, public parent: AVLnode<T> = null) {\n        this.balance = 0\n        this.left = null\n        this.right = null\n    }\n}\n\n/** The balanced AVL tree */\nclass AVLtree <T> {\n    // public members organized here\n    constructor() {\n        this.root = null\n    }\n\n    insert(key: T): boolean {\n        if (this.root === null) {\n            this.root = new AVLnode<T>(key)\n        } else {\n            let n: AVLnode<T> = this.root,\n                parent: AVLnode<T> = null\n\n            while (true) {\n                if(n.key === key) {\n                    return false\n                }\n\n                parent = n\n\n                let goLeft: boolean = n.key > key\n                n = goLeft ? n.left : n.right\n\n                if (n === null) {\n                    if (goLeft) {\n                        parent.left = new AVLnode<T>(key, parent)\n                    } else {\n                        parent.right = new AVLnode<T>(key, parent)\n                    }\n\n                    this.rebalance(parent)\n                    break\n                }\n            }\n        }\n\n        return true\n    }\n\n    deleteKey(delKey: T): void {\n        if (this.root === null) {\n            return\n        }\n\n        let n: AVLnode<T> = this.root,\n            parent: AVLnode<T> = this.root,\n            delNode: AVLnode<T> = null,\n            child: AVLnode<T> = this.root\n        \n        while (child !== null) {\n            parent = n\n            n = child\n            child = delKey >= n.key ? n.right : n.left\n            if (delKey === n.key) {\n                delNode = n\n            }\n        }\n\n        if (delNode !== null) {\n            delNode.key = n.key\n\n            child = n.left !== null ? n.left : n.right\n\n            if (this.root.key === delKey) {\n                this.root = child\n            } else {\n                if (parent.left === n) {\n                    parent.left = child\n                } else {\n                    parent.right = child\n                }\n\n                this.rebalance(parent)\n            }\n        }\n    }\n\n    treeBalanceString(n: AVLnode<T> = this.root): string {\n        if (n !== null) {\n            return `${this.treeBalanceString(n.left)} ${n.balance} ${this.treeBalanceString(n.right)}`\n        }\n        return \"\"\n    }\n\n    toString(n: AVLnode<T> = this.root): string {\n        if (n !== null) {\n            return `${this.toString(n.left)} ${n.key} ${this.toString(n.right)}`\n        }\n        return \"\"\n    }\n\n\n    // private members organized here\n    private root: AVLnode<T>\n\n    private rotateLeft(a: AVLnode<T>): AVLnode<T> {\n        let b: AVLnode<T> = a.right\n        b.parent = a.parent\n        a.right = b.left\n\n        if (a.right !== null) {\n            a.right.parent = a\n        }\n\n        b.left = a\n        a.parent = b\n\n        if (b.parent !== null) {\n            if (b.parent.right === a) {\n                b.parent.right = b\n            } else {\n                b.parent.left = b\n            }\n        }\n\n        this.setBalance(a)\n        this.setBalance(b)\n\n        return b\n    }\n\n    private rotateRight(a: AVLnode<T>): AVLnode<T> {\n        let b: AVLnode<T> = a.left\n        b.parent = a.parent\n        a.left = b.right\n\n        if (a.left !== null) {\n            a.left.parent = a\n        }\n\n        b.right = a\n        a.parent = b\n\n        if (b.parent !== null) {\n            if (b.parent.right === a) {\n                b.parent.right = b\n            } else {\n                b.parent.left = b\n            }\n        }\n\n        this.setBalance(a)\n        this.setBalance(b)\n\n        return b\n    }\n\n    private rotateLeftThenRight(n: AVLnode<T>): AVLnode<T> {\n        n.left = this.rotateLeft(n.left)\n        return this.rotateRight(n)\n    }\n\n    private rotateRightThenLeft(n: AVLnode<T>): AVLnode<T> {\n        n.right = this.rotateRight(n.right)\n        return this.rotateLeft(n)\n    }\n\n    private rebalance(n: AVLnode<T>): void {\n        this.setBalance(n)\n\n        if (n.balance === -2) {\n            if(this.height(n.left.left) >= this.height(n.left.right)) {\n                n = this.rotateRight(n)\n            } else {\n                n = this.rotateLeftThenRight(n)\n            }\n        } else if (n.balance === 2) {\n            if(this.height(n.right.right) >= this.height(n.right.left)) {\n                n = this.rotateLeft(n)\n            } else {\n                n = this.rotateRightThenLeft(n)\n            }\n        }\n\n        if (n.parent !== null) {\n            this.rebalance(n.parent)\n        } else {\n            this.root = n\n        }\n    }\n\n    private height(n: AVLnode<T>): number {\n        if (n === null) {\n            return -1\n        }\n        return 1 + Math.max(this.height(n.left), this.height(n.right))\n    }\n\n    private setBalance(n: AVLnode<T>): void {\n        n.balance = this.height(n.right) - this.height(n.left)\n    }\n    \n    public showNodeBalance(n: AVLnode<T>): string {\n        if (n !== null) {\n            return `${this.showNodeBalance(n.left)} ${n.balance} ${this.showNodeBalance(n.right)}`\n        }\n        return \"\"\n    }\n}\n\n", "explain": "For use within a project, consider adding \"export default\" to AVLtree class declaration.\n"}]