[{"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Python", "code": "\nfrom random import shuffle, randrange\n\ndef make_maze(w = 16, h = 8):\n    vis = [[0] * w + [1] for _ in range(h)] + [[1] * (w + 1)]\n    ver = [[\"|  \"] * w + ['|'] for _ in range(h)] + [[]]\n    hor = [[\"+--\"] * w + ['+'] for _ in range(h + 1)]\n\n    def walk(x, y):\n        vis[y][x] = 1\n\n        d = [(x - 1, y), (x, y + 1), (x + 1, y), (x, y - 1)]\n        shuffle(d)\n        for (xx, yy) in d:\n            if vis[yy][xx]: continue\n            if xx == x: hor[max(y, yy)][x] = \"+  \"\n            if yy == y: ver[y][max(x, xx)] = \"   \"\n            walk(xx, yy)\n\n    walk(randrange(w), randrange(h))\n\n    s = \"\"\n    for (a, b) in zip(hor, ver):\n        s += ''.join(a + ['\\n'] + b + ['\\n'])\n    return s\n\nif __name__ == '__main__':\n    print(make_maze())\n\n\nOutput:\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n|        |     |     |                    |     |\n+  +  +  +  +  +  +  +  +--+--+--+--+--+  +--+  +\n|  |  |     |  |  |     |     |        |        |\n+--+  +--+--+  +  +--+--+--+  +  +--+  +--+--+  +\n|     |     |  |  |  |        |     |  |        |\n+  +--+  +--+  +  +  +  +  +  +--+  +  +  +--+--+\n|  |           |  |     |  |     |  |     |     |\n+  +--+  +--+--+  +  +--+  +--+--+  +--+--+  +  +\n|     |  |        |     |           |        |  |\n+--+  +  +  +--+--+--+  +--+--+--+--+--+--+--+  +\n|     |  |  |        |        |           |     |\n+  +--+--+  +--+--+  +--+--+  +--+  +--+  +  +  +\n|        |        |        |        |     |  |  |\n+  +--+  +--+--+--+  +  +--+--+--+--+  +--+  +  +\n|     |              |                       |  |\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <locale.h>\n\n#define DOUBLE_SPACE 1\n\n#if DOUBLE_SPACE\n#\tdefine SPC \"\u3000\"\n#else\n#\tdefine SPC \" \"\n#endif\n\nwchar_t glyph[] = L\"\"SPC\"\u2502\u2502\u2502\u2500\u2518\u2510\u2524\u2500\u2514\u250c\u251c\u2500\u2534\u252c\u253c\"SPC\"\u2506\u2506\u2506\u2504\u256f\u256e \u2504\u2570\u256d \u2504\";\n\ntypedef unsigned char byte;\nenum { N = 1, S = 2, W = 4, E = 8, V = 16 };\n\nbyte **cell;\nint w, h, avail;\n#define each(i, x, y) for (i = x; i <= y; i++)\n\nint irand(int n)\n{\n\tint r, rmax = n * (RAND_MAX / n);\n\twhile ((r = rand()) >= rmax);\n\treturn r / (RAND_MAX/n);\n}\n\nvoid show()\n{\n\tint i, j, c;\n\teach(i, 0, 2 * h) {\n\t\teach(j, 0, 2 * w) {\n\t\t\tc = cell[i][j];\n\t\t\tif (c > V) printf(\"\\033[31m\");\n\t\t\tprintf(\"%lc\", glyph[c]);\n\t\t\tif (c > V) printf(\"\\033[m\");\n\t\t}\n\t\tputchar('\\n');\n\t}\n}\n\ninline int max(int a, int b) { return a >= b ? a : b; }\ninline int min(int a, int b) { return b >= a ? a : b; }\n\nstatic int dirs[4][2] = {{-2, 0}, {0, 2}, {2, 0}, {0, -2}};\nvoid walk(int x, int y)\n{\n\tint i, t, x1, y1, d[4] = { 0, 1, 2, 3 };\n\n\tcell[y][x] |= V;\n\tavail--;\n\n\tfor (x1 = 3; x1; x1--)\n\t\tif (x1 != (y1 = irand(x1 + 1)))\n\t\t\ti = d[x1], d[x1] = d[y1], d[y1] = i;\n\n\tfor (i = 0; avail && i < 4; i++) {\n\t\tx1 = x + dirs[ d[i] ][0], y1 = y + dirs[ d[i] ][1];\n\n\t\tif (cell[y1][x1] & V) continue;\n\n\t\t/* break walls */\n\t\tif (x1 == x) {\n\t\t\tt = (y + y1) / 2;\n\t\t\tcell[t][x+1] &= ~W, cell[t][x] &= ~(E|W), cell[t][x-1] &= ~E;\n\t\t} else if (y1 == y) {\n\t\t\tt = (x + x1)/2;\n\t\t\tcell[y-1][t] &= ~S, cell[y][t] &= ~(N|S), cell[y+1][t] &= ~N;\n\t\t}\n\t\twalk(x1, y1);\n\t}\n}\n\nint solve(int x, int y, int tox, int toy)\n{\n\tint i, t, x1, y1;\n\n\tcell[y][x] |= V;\n\tif (x == tox && y == toy) return 1;\n\n\teach(i, 0, 3) {\n\t\tx1 = x + dirs[i][0], y1 = y + dirs[i][1];\n\t\tif (cell[y1][x1]) continue;\n\n\t\t/* mark path */\n\t\tif (x1 == x) {\n\t\t\tt = (y + y1)/2;\n\t\t\tif (cell[t][x] || !solve(x1, y1, tox, toy)) continue;\n\n\t\t\tcell[t-1][x] |= S, cell[t][x] |= V|N|S, cell[t+1][x] |= N;\n\t\t} else if (y1 == y) {\n\t\t\tt = (x + x1)/2;\n\t\t\tif (cell[y][t] || !solve(x1, y1, tox, toy)) continue;\n\n\t\t\tcell[y][t-1] |= E, cell[y][t] |= V|E|W, cell[y][t+1] |= W;\n\t\t}\n\t\treturn 1;\n\t}\n\n\t/* backtrack */\n\tcell[y][x] &= ~V;\n\treturn 0;\n}\n\nvoid make_maze()\n{\n\tint i, j;\n\tint h2 = 2 * h + 2, w2 = 2 * w + 2;\n\tbyte **p;\n\n\tp = calloc(sizeof(byte*) * (h2 + 2) + w2 * h2 + 1, 1);\n\n\tp[1] = (byte*)(p + h2 + 2) + 1;\n\teach(i, 2, h2) p[i] = p[i-1] + w2;\n\tp[0] = p[h2];\n\tcell = &p[1];\n\n\teach(i, -1, 2 * h + 1) cell[i][-1] = cell[i][w2 - 1] = V;\n\teach(j, 0, 2 * w) cell[-1][j] = cell[h2 - 1][j] = V;\n\teach(i, 0, h) each(j, 0, 2 * w) cell[2*i][j] |= E|W;\n\teach(i, 0, 2 * h) each(j, 0, w) cell[i][2*j] |= N|S;\n\teach(j, 0, 2 * w) cell[0][j] &= ~N, cell[2*h][j] &= ~S;\n\teach(i, 0, 2 * h) cell[i][0] &= ~W, cell[i][2*w] &= ~E;\n\n\tavail = w * h;\n\twalk(irand(2) * 2 + 1, irand(h) * 2 + 1);\n\n\t/* reset visited marker (it's also used by path finder) */\n\teach(i, 0, 2 * h) each(j, 0, 2 * w) cell[i][j] &= ~V;\n\tsolve(1, 1, 2 * w - 1, 2 * h - 1);\n\n\tshow();\n}\n\nint main(int c, char **v)\n{\n\tsetlocale(LC_ALL, \"\");\n\tif (c < 2 || (w = atoi(v[1])) <= 0) w = 16;\n\tif (c < 3 || (h = atoi(v[2])) <= 0) h = 8;\n\n\tmake_maze();\n\n\treturn 0;\n}\n\n\nSample output:\n\u250c\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u252c\u2500\u2500\u2500\u2510\n\u2502\u2504\u2504\u256e\u2502\u256d\u2504\u2504\u2504\u256e\u2502\u3000\u3000\u256d\u2504\u2504\u2504\u2504\u2504\u256e\u2502\u3000\u3000\u256d\u2504\u2504\u2504\u256e\u2502\u256d\u2504\u256e\u2502\n\u2502\u3000\u2502\u2506\u2502\u2506\u2500\u2500\u2510\u2506\u2502\u3000\u2502\u2506\u2500\u2500\u252c\u2500\u2510\u2506\u2514\u2500\u2500\u2506\u250c\u2500\u2510\u2506\u2502\u2506\u2502\u2506\u2502\n\u2502\u3000\u2502\u2506\u2502\u2570\u2504\u256e\u2502\u2506\u2502\u3000\u2502\u2570\u2504\u256e\u2502\u3000\u2502\u2570\u2504\u2504\u2504\u256f\u2502\u3000\u2502\u2570\u2504\u256f\u2502\u2506\u2502\n\u2502\u3000\u2502\u2506\u2514\u2500\u2500\u2506\u2502\u2506\u2514\u2500\u253c\u2500\u2500\u2506\u2502\u3000\u2514\u2500\u2500\u2500\u2500\u2500\u2524\u3000\u2514\u2500\u252c\u2500\u2518\u2506\u2502\n\u2502\u3000\u2502\u2570\u2504\u2504\u2504\u256f\u2502\u2570\u2504\u256e\u2502\u256d\u2504\u256f\u2502\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2502\u3000\u3000\u3000\u2502\u256d\u2504\u256f\u2502\n\u2502\u3000\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2510\u2506\u2502\u2506\u250c\u2500\u2534\u2500\u2500\u2500\u2510\u3000\u2502\u3000\u2502\u3000\u2502\u3000\u2502\u2506\u2500\u2500\u2524\n\u2502\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2502\u2506\u2502\u2506\u2502\u256d\u2504\u2504\u2504\u256e\u2502\u3000\u2502\u3000\u3000\u3000\u2502\u3000\u2502\u2570\u2504\u256e\u2502\n\u2502\u3000\u2500\u2500\u2500\u2500\u2500\u2500\u2510\u3000\u2502\u2506\u2502\u2506\u2502\u2506\u2500\u2500\u2510\u2506\u2514\u2500\u2524\u3000\u250c\u2500\u2518\u3000\u2514\u2500\u2510\u2506\u2502\n\u2502\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2502\u3000\u2502\u2506\u2502\u2570\u2504\u256f\u3000\u3000\u2502\u2570\u2504\u256e\u2502\u3000\u2502\u3000\u3000\u3000\u3000\u3000\u2502\u2506\u2502\n\u2502\u3000\u250c\u2500\u2500\u2500\u2500\u2500\u2518\u3000\u2502\u2506\u251c\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2510\u2506\u2502\u3000\u2502\u3000\u2500\u2500\u252c\u2500\u2518\u2506\u2502\n\u2502\u3000\u2502\u3000\u3000\u3000\u3000\u3000\u3000\u3000\u2502\u2506\u2502\u256d\u2504\u2504\u2504\u2504\u2504\u256e\u2502\u2506\u2502\u3000\u2502\u3000\u3000\u3000\u2502\u256d\u2504\u256f\u2502\n\u251c\u2500\u2524\u3000\u2500\u2500\u252c\u2500\u252c\u2500\u2518\u2506\u2502\u2506\u250c\u2500\u252c\u2500\u2500\u2506\u2502\u2506\u2514\u2500\u2534\u2500\u2510\u3000\u2502\u2506\u250c\u2500\u2524\n\u2502\u3000\u2502\u3000\u3000\u3000\u2502\u3000\u2502\u256d\u2504\u256f\u2502\u2506\u2502\u3000\u2502\u256d\u2504\u256f\u2502\u2570\u2504\u2504\u2504\u256e\u2502\u3000\u2502\u2506\u2502\u3000\u2502\n\u2502\u3000\u2514\u2500\u2500\u3000\u2502\u3000\u2502\u2506\u2500\u2500\u2518\u2506\u2502\u3000\u2502\u2506\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2506\u2502\u3000\u2502\u2506\u2502\u3000\u2502\n\u2502\u3000\u3000\u3000\u3000\u3000\u2502\u3000\u3000\u2570\u2504\u2504\u2504\u256f\u2502\u3000\u3000\u2570\u2504\u2504\u2504\u2504\u2504\u2504\u2504\u256f\u2502\u3000\u3000\u2570\u2504\u2504\u2502\n\u2514\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2500\u2534\u2500\u2500\u2500\u2500\u2500\u2518\n", "explain": "Generation/solver in one. Requires UTF8 locale and unicode capable console.  If your console font line-drawing chars are single width, define DOUBLE_SPACE to 0.\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "C++", "code": "\n\n#include <windows.h>\n#include <iostream>\n#include <string>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nconst int BMP_SIZE = 512, CELL_SIZE = 8;\n\n//--------------------------------------------------------------------------------------------------\nenum directions { NONE, NOR = 1, EAS = 2, SOU = 4, WES = 8 };\n\n//--------------------------------------------------------------------------------------------------\nclass myBitmap\n{\npublic:\n    myBitmap() : pen( NULL ) {}\n    ~myBitmap()\n    {\n\tDeleteObject( pen );\n\tDeleteDC( hdc );\n\tDeleteObject( bmp );\n    }\n\n    bool create( int w, int h )\n    {\n\tBITMAPINFO\tbi;\n\tZeroMemory( &bi, sizeof( bi ) );\n\tbi.bmiHeader.biSize\t   = sizeof( bi.bmiHeader );\n\tbi.bmiHeader.biBitCount\t   = sizeof( DWORD ) * 8;\n\tbi.bmiHeader.biCompression = BI_RGB;\n\tbi.bmiHeader.biPlanes\t   = 1;\n\tbi.bmiHeader.biWidth\t   =  w;\n\tbi.bmiHeader.biHeight\t   = -h;\n\n\tHDC dc = GetDC( GetConsoleWindow() );\n\tbmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n\tif( !bmp ) return false;\n\n\thdc = CreateCompatibleDC( dc );\n\tSelectObject( hdc, bmp );\n\tReleaseDC( GetConsoleWindow(), dc ); \n\twidth = w; height = h;\n\n\treturn true;\n    }\n\n    void clear()\n    {\n\tZeroMemory( pBits, width * height * sizeof( DWORD ) );\n    }\n\n    void setPenColor( DWORD clr )\n    {\n\tif( pen ) DeleteObject( pen );\n\tpen = CreatePen( PS_SOLID, 1, clr );\n\tSelectObject( hdc, pen );\n    }\n\n    void saveBitmap( string path )\n    {\n\tBITMAPFILEHEADER fileheader;\n\tBITMAPINFO\t infoheader;\n\tBITMAP\t\t bitmap;\n\tDWORD\t\t wb;\n\n\tGetObject( bmp, sizeof( bitmap ), &bitmap );\n\n\tDWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n\tZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n\tZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n\tZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n\n\tinfoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n\tinfoheader.bmiHeader.biCompression = BI_RGB;\n\tinfoheader.bmiHeader.biPlanes = 1;\n\tinfoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n\tinfoheader.bmiHeader.biHeight = bitmap.bmHeight;\n\tinfoheader.bmiHeader.biWidth = bitmap.bmWidth;\n\tinfoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n\n\tfileheader.bfType    = 0x4D42;\n\tfileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n\tfileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n\n\tGetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n\n\tHANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\tWriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n\tWriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n\tWriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n\tCloseHandle( file );\n\n\tdelete [] dwpBits;\n    }\n\n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\n\nprivate:\n    HBITMAP bmp;\n    HDC\t    hdc;\n    HPEN    pen;\n    void    *pBits;\n    int\t    width, height;\n};\n//--------------------------------------------------------------------------------------------------\nclass mazeGenerator\n{\npublic:\n    mazeGenerator()\n    {\n\t_world = 0; \n\t_bmp.create( BMP_SIZE, BMP_SIZE ); \n\t_bmp.setPenColor( RGB( 0, 255, 0 ) ); \n    }\n\n    ~mazeGenerator() { killArray(); }\n\n    void create( int side )\n    {\n\t_s = side;\n\tgenerate();\n\tdisplay();\n    }\n\nprivate:\n    void generate()\n    {\n\tkillArray();\n\t_world = new BYTE[_s * _s];\n\tZeroMemory( _world, _s * _s );\n\t_ptX = rand() % _s; _ptY = rand() % _s;\n\tcarve();\n    }\n\n    void carve()\n    {\n\twhile( true )\n\t{\n\t    int d = getDirection();\n\t    if( d < NOR ) return;\n\n\t    switch( d )\n\t    {\n\t        case NOR:\n\t            _world[_ptX + _s * _ptY] |= NOR; _ptY--;\n\t\t    _world[_ptX + _s * _ptY] = SOU | SOU << 4;\n\t\tbreak;\n\t        case EAS:\n\t\t    _world[_ptX + _s * _ptY] |= EAS; _ptX++;\n\t\t    _world[_ptX + _s * _ptY] = WES | WES << 4;\n\t\tbreak;\n\t\tcase SOU:\n\t\t    _world[_ptX + _s * _ptY] |= SOU; _ptY++;\n\t\t    _world[_ptX + _s * _ptY] = NOR | NOR << 4;\n\t\tbreak;\n\t\tcase WES:\n\t\t    _world[_ptX + _s * _ptY] |= WES; _ptX--;\n\t\t    _world[_ptX + _s * _ptY] = EAS | EAS << 4;\n\t    }\n\t}\n    }\n\n    void display()\n    {\n\t_bmp.clear();\n\tHDC dc = _bmp.getDC();\n\tfor( int y = 0; y < _s; y++ )\n\t{\n\t    int yy = y * _s;\n\t    for( int x = 0; x < _s; x++ )\n\t    {\n\t\tBYTE b = _world[x + yy];\n\t\tint nx = x * CELL_SIZE, \n\t\t    ny = y * CELL_SIZE;\n\t\t\t\t\n\t\tif( !( b & NOR ) )\n\t\t{\n\t\t    MoveToEx( dc, nx, ny, NULL );\n\t\t    LineTo( dc, nx + CELL_SIZE + 1, ny );\n\t\t}\n\t\tif( !( b & EAS ) )\n\t\t{\n\t\t    MoveToEx( dc, nx + CELL_SIZE, ny, NULL );\n\t\t    LineTo( dc, nx + CELL_SIZE, ny + CELL_SIZE + 1 );\n\t\t}\n\t\tif( !( b & SOU ) )\n\t\t{\n\t\t    MoveToEx( dc, nx, ny + CELL_SIZE, NULL );\n\t\t    LineTo( dc, nx + CELL_SIZE + 1, ny + CELL_SIZE );\n\t\t}\n\t\tif( !( b & WES ) )\n\t\t{\n\t\t    MoveToEx( dc, nx, ny, NULL );\n\t\t    LineTo( dc, nx, ny + CELL_SIZE + 1 );\n\t\t}\n\t    }\n\t}\n\n\t//_bmp.saveBitmap( \"f:\\\\rc\\\\maze.bmp\" );\n\tBitBlt( GetDC( GetConsoleWindow() ), 10, 60, BMP_SIZE, BMP_SIZE, _bmp.getDC(), 0, 0, SRCCOPY );\n    }\n\n    int getDirection()\n    {\n\tint d = 1 << rand() % 4;\n\twhile( true )\n\t{\n\t    for( int x = 0; x < 4; x++ )\n\t    {\n\t\tif( testDir( d ) ) return d;\n\t\td <<= 1;\n\t\tif( d > 8 ) d = 1;\n\t    }\n\t    d = ( _world[_ptX + _s * _ptY] & 0xf0 ) >> 4;\n\t    if( !d ) return -1;\n\t    switch( d )\n\t    {\n\t\tcase NOR: _ptY--; break;\n\t\tcase EAS: _ptX++; break;\n\t\tcase SOU: _ptY++; break;\n\t\tcase WES: _ptX--; break;\n\t    }\n            d = 1 << rand() % 4;\n\t}\n    }\n\n    bool testDir( int d )\n    {\n\tswitch( d )\n\t{\n\t    case NOR: return ( _ptY - 1 > -1 && !_world[_ptX + _s * ( _ptY - 1 )] );\n\t    case EAS: return ( _ptX + 1 < _s && !_world[_ptX + 1 + _s * _ptY] );\n\t    case SOU: return ( _ptY + 1 < _s && !_world[_ptX + _s * ( _ptY + 1 )] );\n\t    case WES: return ( _ptX - 1 > -1 && !_world[_ptX - 1 + _s * _ptY] );\n\t}\n\treturn false;\n    }\n\n    void killArray() { if( _world ) delete [] _world; }\n\n    BYTE*    _world;\n    int      _s, _ptX, _ptY;\n    myBitmap _bmp;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );\n    srand( GetTickCount() );\n\n    mazeGenerator mg;\n    int s;\n    while( true )\n    {\n\tcout << \"Enter the maze size, an odd number bigger than 2 ( 0 to QUIT ): \"; cin >> s;\n\tif( !s ) return 0;\n\tif( !( s & 1 ) ) s++;\n\tif( s >= 3 ) mg.create( s );\n\tcout << endl;\n\tsystem( \"pause\" );\n\tsystem( \"cls\" );\n    }\n    return 0;\n}\n//--------------------------------------------------------------------------------------------------\n\n", "explain": "\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Java", "code": "\nWorks with: Java version 1.5+\npackage org.rosettacode;\n\nimport java.util.Collections;\nimport java.util.Arrays;\n\n/*\n * recursive backtracking algorithm\n * shamelessly borrowed from the ruby at\n * http://weblog.jamisbuck.org/2010/12/27/maze-generation-recursive-backtracking\n */\npublic class MazeGenerator {\n\tprivate final int x;\n\tprivate final int y;\n\tprivate final int[][] maze;\n\n\tpublic MazeGenerator(int x, int y) {\n\t\tthis.x = x;\n\t\tthis.y = y;\n\t\tmaze = new int[this.x][this.y];\n\t\tgenerateMaze(0, 0);\n\t}\n\n\tpublic void display() {\n\t\tfor (int i = 0; i < y; i++) {\n\t\t\t// draw the north edge\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 1) == 0 ? \"+---\" : \"+   \");\n\t\t\t}\n\t\t\tSystem.out.println(\"+\");\n\t\t\t// draw the west edge\n\t\t\tfor (int j = 0; j < x; j++) {\n\t\t\t\tSystem.out.print((maze[j][i] & 8) == 0 ? \"|   \" : \"    \");\n\t\t\t}\n\t\t\tSystem.out.println(\"|\");\n\t\t}\n\t\t// draw the bottom line\n\t\tfor (int j = 0; j < x; j++) {\n\t\t\tSystem.out.print(\"+---\");\n\t\t}\n\t\tSystem.out.println(\"+\");\n\t}\n\n\tprivate void generateMaze(int cx, int cy) {\n\t\tDIR[] dirs = DIR.values();\n\t\tCollections.shuffle(Arrays.asList(dirs));\n\t\tfor (DIR dir : dirs) {\n\t\t\tint nx = cx + dir.dx;\n\t\t\tint ny = cy + dir.dy;\n\t\t\tif (between(nx, x) && between(ny, y)\n\t\t\t\t\t&& (maze[nx][ny] == 0)) {\n\t\t\t\tmaze[cx][cy] |= dir.bit;\n\t\t\t\tmaze[nx][ny] |= dir.opposite.bit;\n\t\t\t\tgenerateMaze(nx, ny);\n\t\t\t}\n\t\t}\n\t}\n\n\tprivate static boolean between(int v, int upper) {\n\t\treturn (v >= 0) && (v < upper);\n\t}\n\n\tprivate enum DIR {\n\t\tN(1, 0, -1), S(2, 0, 1), E(4, 1, 0), W(8, -1, 0);\n\t\tprivate final int bit;\n\t\tprivate final int dx;\n\t\tprivate final int dy;\n\t\tprivate DIR opposite;\n\n\t\t// use the static initializer to resolve forward references\n\t\tstatic {\n\t\t\tN.opposite = S;\n\t\t\tS.opposite = N;\n\t\t\tE.opposite = W;\n\t\t\tW.opposite = E;\n\t\t}\n\n\t\tprivate DIR(int bit, int dx, int dy) {\n\t\t\tthis.bit = bit;\n\t\t\tthis.dx = dx;\n\t\t\tthis.dy = dy;\n\t\t}\n\t};\n\n\tpublic static void main(String[] args) {\n\t\tint x = args.length >= 1 ? (Integer.parseInt(args[0])) : 8;\n\t\tint y = args.length == 2 ? (Integer.parseInt(args[1])) : 8;\n\t\tMazeGenerator maze = new MazeGenerator(x, y);\n\t\tmaze.display();\n\t}\n\n}\n\n\nOutput:\n+---+---+---+---+---+---+---+---+---+---+\n|   |                           |       |\n+   +---+---+   +---+---+   +   +   +---+\n|           |   |   |       |   |       |\n+---+---+   +   +   +   +---+   +---+   +\n|           |       |   |   |       |   |\n+   +---+---+   +---+   +   +---+   +   +\n|   |       |   |       |           |   |\n+   +   +   +---+   +---+---+---+   +   +\n|   |   |       |               |       |\n+   +   +---+   +   +---+---+   +---+---+\n|   |       |   |   |           |       |\n+   +---+   +   +---+   +---+---+   +   +\n|       |   |       |               |   |\n+---+   +   +---+   +   +---+---+---+   +\n|   |   |       |   |       |           |\n+   +   +---+   +   +---+---+   +---+   +\n|   |       |   |           |   |   |   |\n+   +---+   +   +---+---+   +   +   +   +\n|               |               |       |\n+---+---+---+---+---+---+---+---+---+---+\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "C#", "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Diagnostics;\nusing System.Linq;\nusing System.Text;\nusing System.Drawing;\n\nnamespace MazeGeneration\n{\n    public static class Extensions\n    {\n        public static IEnumerable<T> Shuffle<T>(this IEnumerable<T> source, Random rng)\n        {\n            var e = source.ToArray();\n            for (var i = e.Length - 1; i >= 0; i--)\n            {\n                var swapIndex = rng.Next(i + 1);\n                yield return e[swapIndex];\n                e[swapIndex] = e[i];\n            }\n        }\n\n        public static CellState OppositeWall(this CellState orig)\n        {\n            return (CellState)(((int) orig >> 2) | ((int) orig << 2)) & CellState.Initial;\n        }\n\n        public static bool HasFlag(this CellState cs,CellState flag)\n        {\n            return ((int)cs & (int)flag) != 0;\n        }\n    }\n\n    [Flags]\n    public enum CellState\n    {\n        Top = 1,\n        Right = 2,\n        Bottom = 4,\n        Left = 8,\n        Visited = 128,\n        Initial = Top | Right | Bottom | Left,\n    }\n\n    public struct RemoveWallAction\n    {\n        public Point Neighbour;\n        public CellState Wall;\n    }\n\n    public class Maze\n    {\n        private readonly CellState[,] _cells;\n        private readonly int _width;\n        private readonly int _height;\n        private readonly Random _rng;\n\n        public Maze(int width, int height)\n        {\n            _width = width;\n            _height = height;\n            _cells = new CellState[width, height];\n            for(var x=0; x<width; x++)\n                for(var y=0; y<height; y++)\n                    _cells[x, y] = CellState.Initial;\n            _rng = new Random();\n            VisitCell(_rng.Next(width), _rng.Next(height));\n        }\n\n        public CellState this[int x, int y]\n        {\n            get { return _cells[x,y]; }\n            set { _cells[x,y] = value; }\n        }\n\n        public IEnumerable<RemoveWallAction> GetNeighbours(Point p)\n        {\n            if (p.X > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X - 1, p.Y), Wall = CellState.Left};\n            if (p.Y > 0) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y - 1), Wall = CellState.Top};\n            if (p.X < _width-1) yield return new RemoveWallAction {Neighbour = new Point(p.X + 1, p.Y), Wall = CellState.Right};\n            if (p.Y < _height-1) yield return new RemoveWallAction {Neighbour = new Point(p.X, p.Y + 1), Wall = CellState.Bottom};\n        }\n\n        public void VisitCell(int x, int y)\n        {\n            this[x,y] |= CellState.Visited;\n            foreach (var p in GetNeighbours(new Point(x, y)).Shuffle(_rng).Where(z => !(this[z.Neighbour.X, z.Neighbour.Y].HasFlag(CellState.Visited))))\n            {\n                this[x, y] -= p.Wall;\n                this[p.Neighbour.X, p.Neighbour.Y] -= p.Wall.OppositeWall();\n                VisitCell(p.Neighbour.X, p.Neighbour.Y);\n            }\n        }\n\n        public void Display()\n        {\n            var firstLine = string.Empty;\n            for (var y = 0; y < _height; y++)\n            {\n                var sbTop = new StringBuilder();\n                var sbMid = new StringBuilder();\n                for (var x = 0; x < _width; x++)\n                {\n                    sbTop.Append(this[x, y].HasFlag(CellState.Top) ? \"+---\" : \"+   \");\n                    sbMid.Append(this[x, y].HasFlag(CellState.Left) ? \"|   \" : \"    \");\n                }\n                if (firstLine == string.Empty)\n                    firstLine = \"   \" + sbTop.ToString();\n                Debug.WriteLine(\"   \" + sbTop + \"+\");\n                Debug.WriteLine(\"   \" + sbMid + \"|\");\n            }\n            Debug.WriteLine(firstLine);\n        }\n    }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            var maze = new Maze(20, 20);\n            maze.Display();\n        }\n    }\n}\n\n\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n   |           |                   |                       |                       |\n   +   +---+   +---+---+   +---+   +   +---+---+   +---+   +---+---+   +---+---+   +\n   |   |       |           |   |   |       |       |       |           |       |   |\n   +   +   +---+   +---+---+   +   +---+---+   +---+---+   +   +---+---+   +   +   +\n   |   |           |   |       |   |           |       |       |           |   |   |\n   +   +   +---+---+   +   +   +   +   +---+---+   +   +---+---+   +---+---+   +   +\n   |   |   |       |   |   |       |               |           |   |           |   |\n   +   +---+   +   +   +   +---+---+   +---+---+---+---+---+   +   +   +---+---+   +\n   |           |   |   |           |                   |   |       |   |   |       |\n   +---+---+---+   +   +---+---+   +---+---+---+---+   +   +---+---+   +   +   +---+\n   |           |   |           |               |           |           |       |   |\n   +   +---+---+---+   +   +---+---+---+---+   +   +---+---+   +---+---+   +---+   +\n   |       |           |           |       |   |   |           |       |   |       |\n   +   +   +   +---+---+---+---+   +   +   +   +   +   +---+---+   +   +   +---+   +\n   |   |       |                   |   |       |   |       |       |               |\n   +   +---+---+   +---+   +---+---+   +---+---+   +---+   +---+---+   +---+---+---+\n   |       |       |   |   |           |       |   |   |   |       |       |       |\n   +---+---+   +---+   +   +   +---+---+   +---+   +   +   +   +   +---+---+   +   +\n   |           |           |       |   |           |   |       |               |   |\n   +   +---+---+   +---+---+---+   +   +   +---+---+   +---+---+---+---+---+---+   +\n   |       |       |           |   |   |       |                               |   |\n   +   +   +   +---+   +---+   +   +   +---+   +---+---+   +---+---+---+---+---+   +\n   |   |   |   |       |   |       |       |   |           |                       |\n   +   +   +---+   +---+   +---+---+   +   +   +   +---+---+   +---+---+---+---+   +\n   |   |           |                   |   |       |       |   |               |   |\n   +   +---+---+---+---+---+   +---+---+   +   +---+   +   +   +   +   +---+---+   +\n   |   |       |           |   |       |   |   |       |       |   |   |       |   |\n   +   +   +   +---+   +   +   +   +---+   +   +   +---+---+---+   +---+   +   +   +\n   |       |       |   |       |   |       |   |           |   |           |       |\n   +---+---+---+   +   +---+---+   +   +---+   +---+---+   +   +   +---+---+---+---+\n   |           |   |       |           |       |   |       |       |       |       |\n   +   +---+   +   +   +   +   +---+---+   +---+   +   +---+   +---+   +---+   +   +\n   |   |   |       |   |   |           |   |       |   |   |   |       |       |   |\n   +   +   +---+---+---+   +---+---+---+   +   +---+   +   +   +   +   +   +---+   +\n   |       |           |               |       |       |   |   |   |           |   |\n   +---+   +---+   +   +---+---+---+   +---+   +   +---+   +   +---+---+---+---+   +\n   |   |           |   |           |           |   |   |       |                   |\n   +   +---+---+---+   +   +---+   +---+---+---+   +   +   +---+   +---+---+---+   +\n   |                       |                       |               |               |\n   +---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---\n\n", "explain": "Sample output:\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "JavaScript", "code": "\nTranslation of: J\nfunction maze(x,y) {\n\tvar n=x*y-1;\n\tif (n<0) {alert(\"illegal maze dimensions\");return;}\n\tvar horiz =[]; for (var j= 0; j<x+1; j++) horiz[j]= [],\n\t    verti =[]; for (var j= 0; j<x+1; j++) verti[j]= [],\n\t    here = [Math.floor(Math.random()*x), Math.floor(Math.random()*y)],\n\t    path = [here],\n\t    unvisited = [];\n\tfor (var j = 0; j<x+2; j++) {\n\t\tunvisited[j] = [];\n\t\tfor (var k= 0; k<y+1; k++)\n\t\t\tunvisited[j].push(j>0 && j<x+1 && k>0 && (j != here[0]+1 || k != here[1]+1));\n\t}\n\twhile (0<n) {\n\t\tvar potential = [[here[0]+1, here[1]], [here[0],here[1]+1],\n\t\t    [here[0]-1, here[1]], [here[0],here[1]-1]];\n\t\tvar neighbors = [];\n\t\tfor (var j = 0; j < 4; j++)\n\t\t\tif (unvisited[potential[j][0]+1][potential[j][1]+1])\n\t\t\t\tneighbors.push(potential[j]);\n\t\tif (neighbors.length) {\n\t\t\tn = n-1;\n\t\t\tnext= neighbors[Math.floor(Math.random()*neighbors.length)];\n\t\t\tunvisited[next[0]+1][next[1]+1]= false;\n\t\t\tif (next[0] == here[0])\n\t\t\t\thoriz[next[0]][(next[1]+here[1]-1)/2]= true;\n\t\t\telse \n\t\t\t\tverti[(next[0]+here[0]-1)/2][next[1]]= true;\n\t\t\tpath.push(here = next);\n\t\t} else \n\t\t\there = path.pop();\n\t}\n\treturn {x: x, y: y, horiz: horiz, verti: verti};\n}\n\nfunction display(m) {\n\tvar text= [];\n\tfor (var j= 0; j<m.x*2+1; j++) {\n\t\tvar line= [];\n\t\tif (0 == j%2)\n\t\t\tfor (var k=0; k<m.y*4+1; k++)\n\t\t\t\tif (0 == k%4) \n\t\t\t\t\tline[k]= '+';\n\t\t\t\telse\n\t\t\t\t\tif (j>0 && m.verti[j/2-1][Math.floor(k/4)])\n\t\t\t\t\t\tline[k]= ' ';\n\t\t\t\t\telse\n\t\t\t\t\t\tline[k]= '-';\n\t\telse\n\t\t\tfor (var k=0; k<m.y*4+1; k++)\n\t\t\t\tif (0 == k%4)\n\t\t\t\t\tif (k>0 && m.horiz[(j-1)/2][k/4-1])\n\t\t\t\t\t\tline[k]= ' ';\n\t\t\t\t\telse\n\t\t\t\t\t\tline[k]= '|';\n\t\t\t\telse\n\t\t\t\t\tline[k]= ' ';\n\t\tif (0 == j) line[1]= line[2]= line[3]= ' ';\n\t\tif (m.x*2-1 == j) line[4*m.y]= ' ';\n\t\ttext.push(line.join('')+'\\r\\n');\n\t}\n\treturn text.join('');\n}\n\n\nx,y \u2014 dimensions of maze\nn \u2014 number of openings to be generated\nhoriz \u2014 two dimensional array of locations of horizontal openings (true means wall is open)\nverti \u2014 two dimensional array of locations of vertical openings (true means wall is open)\nhere \u2014 current location under consideration\npath \u2014 history (stack) of locations that might need to be revisited\nunvisited \u2014 two dimensional array of locations that have not been visited, padded to avoid need for boundary tests (true means location needs to be visited)\npotential \u2014 locations adjacent to here\nneighbors \u2014 unvisited locations adjacent to here\n\nm \u2014 maze to be drawn\ntext \u2014 lines of text representing maze\nline \u2014 characters of current line\n\n\nExample use:\n<html><head><title></title></head><body><pre id=\"out\"></pre></body></html>\n<script type=\"text/javascript\">\n/* ABOVE CODE GOES HERE */\ndocument.getElementById('out').innerHTML= display(maze(8,11)); \n</script>\n\n\n+   +---+---+---+---+---+---+---+---+---+---+\n|                   |                   |   |\n+---+---+   +   +---+   +   +---+---+   +   +\n|       |   |   |       |   |           |   |\n+   +   +   +---+   +---+   +---+---+   +   +\n|   |   |               |           |   |   |\n+   +---+   +---+---+---+---+---+   +   +   +\n|       |   |               |       |       |\n+---+   +---+   +---+---+   +   +---+---+   +\n|   |   |       |               |       |   |\n+   +   +   +---+---+---+---+---+   +   +   +\n|       |                   |       |   |   |\n+   +---+---+   +---+---+   +   +---+---+   +\n|   |       |   |           |       |       |\n+   +   +   +---+   +---+---+   +   +   +---+\n|       |           |           |            \n+---+---+---+---+---+---+---+---+---+---+---+\n\n\tfunction step() {\n\t\tif (0<n) {\n\n\n\t\t\tdocument.getElementById('out').innerHTML= display({x: x, y: y, horiz: horiz, verti: verti, here: here});\n\t\t\tsetTimeout(step, 100);\n\t\t}\n\t}\n\tstep();\n\n\n\t\t\t\tif (m.here && m.here[0]*2+1 == j && m.here[1]*4+2 == k) \n\t\t\t\t\tline[k]= '#'\n\t\t\t\telse if (0 == k%4) {\n\n\n\t\t\there= next;\n\t\t\tif (1 < neighbors.length) \n\t\t\t\tpath.push(here);\n\n\nHTML Table[edit]\n\n<html><head><title>Maze maker</title>\n<style type=\"text/css\">\ntable { border-collapse: collapse }\ntd { width: 1em; height: 1em; border: 1px solid }\ntd.s { border-bottom: none }\ntd.n { border-top: none }\ntd.w { border-left: none }\ntd.e { border-right: none }\ntd.v { background: skyblue}\n</style>\n<script type=\"application/javascript\">\nNode.prototype.add = function(tag, cnt, txt) {\n\tfor (var i = 0; i < cnt; i++)\n\t\tthis.appendChild(ce(tag, txt));\n}\nNode.prototype.ins = function(tag) {\n\tthis.insertBefore(ce(tag), this.firstChild)\n}\nNode.prototype.kid = function(i) { return this.childNodes[i] }\nNode.prototype.cls = function(t) { this.className += ' ' + t }\n\nNodeList.prototype.map = function(g) {\n\tfor (var i = 0; i < this.length; i++) g(this[i]);\n}\n\nfunction ce(tag, txt) {\n\tvar x = document.createElement(tag);\n\tif (txt !== undefined) x.innerHTML = txt;\n\treturn x\n}\n\nfunction gid(e) { return document.getElementById(e) }\nfunction irand(x) { return Math.floor(Math.random() * x) }\n\nfunction make_maze() {\n\tvar w = parseInt(gid('rows').value || 8, 10);\n\tvar h = parseInt(gid('cols').value || 8, 10);\n\tvar tbl = gid('maze');\n\ttbl.innerHTML = '';\n\ttbl.add('tr', h);\n\ttbl.childNodes.map(function(x) {\n\t\t\tx.add('th', 1);\n\t\t\tx.add('td', w, '*');\n\t\t\tx.add('th', 1)});\n\ttbl.ins('tr');\n\ttbl.add('tr', 1);\n\ttbl.firstChild.add('th', w + 2);\n\ttbl.lastChild.add('th', w + 2);\n\tfor (var i = 1; i <= h; i++) {\n\t\tfor (var j = 1; j <= w; j++) {\n\t\t\ttbl.kid(i).kid(j).neighbors = [\n\t\t\t\ttbl.kid(i + 1).kid(j),\n\t\t\t\ttbl.kid(i).kid(j + 1),\n\t\t\t\ttbl.kid(i).kid(j - 1),\n\t\t\t\ttbl.kid(i - 1).kid(j)\n\t\t\t];\n\t\t}\n\t}\n\twalk(tbl.kid(irand(h) + 1).kid(irand(w) + 1));\n\tgid('solve').style.display='inline';\n}\n\nfunction shuffle(x) {\n\tfor (var i = 3; i > 0; i--) {\n\t\tj = irand(i + 1);\n\t\tif (j == i) continue;\n\t\tvar t = x[j]; x[j] = x[i]; x[i] = t;\n\t}\n\treturn x;\n}\n\nvar dirs = ['s', 'e', 'w', 'n'];\nfunction walk(c) {\n\tc.innerHTML = '&nbsp;';\n\tvar idx = shuffle([0, 1, 2, 3]);\n\tfor (var j = 0; j < 4; j++) {\n\t\tvar i = idx[j];\n\t\tvar x = c.neighbors[i];\n\t\tif (x.textContent != '*') continue;\n\t\tc.cls(dirs[i]), x.cls(dirs[3 - i]);\n\t\twalk(x);\n\t}\n}\n\nfunction solve(c, t) {\n\tif (c === undefined) {\n\t\tc = gid('maze').kid(1).kid(1);\n\t\tc.cls('v');\n\t}\n\tif (t === undefined)\n\t\tt = gid('maze')\t.lastChild.previousSibling\n\t\t\t\t.lastChild.previousSibling;\n\n\tif (c === t) return 1;\n\tc.vis = 1;\n\tfor (var i = 0; i < 4; i++) {\n\t\tvar x = c.neighbors[i];\n\t\tif (x.tagName.toLowerCase() == 'th') continue;\n\t\tif (x.vis || !c.className.match(dirs[i]) || !solve(x, t))\n\t\t\tcontinue;\n\n\t\tx.cls('v');\n\t\treturn 1;\n\t}\n\tc.vis = null;\n\treturn 0;\n}\n\n</script></head>\n<body><form><fieldset>\n<label>rows </label><input id='rows' size=\"3\"/>\n<label>colums </label><input id='cols' size=\"3\"/>\n<a href=\"javascript:make_maze()\">Generate</a>\n<a id='solve' style='display:none' href='javascript:solve(); void(0)'>Solve</a>\n</fieldset></form><table id='maze'/></body></html>\n\n", "explain": "Variable meanings in function maze:\nVariable meanings in function display:\nNote that this implementation relies on javascript arrays being treatable as infinite in size with false (null) values springing into existence as needed, to support referenced array locations.  (This significantly reduces the bulk of the necessary initialization code.)\nproduced output:\nFor an animated presentation of the progress of this maze creation process, you can use display in each iteration of the main loop.  You would also need to take steps to make sure you could see each intermediate result.\nFor example, change replace the line while (0<n) { with:\nAnd replace the closing brace for this while loop with:\nTo better see the progress, you might want a marker in place, showing the position being considered.  To do that, replace the line which reads if (0 == k%4) { with\nNote however that this leaves the final '#' in place on maze completion, and that the function maze no longer returns a result which represents a generated maze.\nNote also that this display suggests an optimization.  You can replace the line reading path.push(here= next); with:\nAnd this does indeed save a negligible bit of processing, but the maze algorithm will still be forced to backtrack through a number of locations which have no unvisited neighbors.\nUsing HTML, CSS and table cells for maze.\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "PHP", "code": "\n\n<?php\nclass Maze \n{\n    protected $width;\n    protected $height;\n    protected $grid;\n    protected $path;\n    protected $horWalls;\n    protected $vertWalls;\n    protected $dirs;\n    protected $isDebug;\n\n    public function __construct($x, $y, $debug = false)\n    {\n        $this->width = $x;\n        $this->height = $y;\n        $this->path = [];        \n        $this->dirs = [ [0, -1], [0, 1], [-1, 0], [1, 0]]; // array of coordinates of N,S,W,E\n        $this->horWalls = []; // list of removed horizontal walls (---+)        \n        $this->vertWalls = [];// list of removed vertical walls (|)        \n        $this->isDebug = $debug; // debug flag\n\n        // generate the maze:\n        $this->generate();\n    }\n\n    protected function generate()\n    {        \n        $this->initMaze(); // init the stack and an unvisited grid\n        // start from a random cell and then proceed recursively\n        $this->walk(mt_rand(0, $this->width-1), mt_rand(0, $this->height-1));\n    }\n\n    /**\n    * Actually prints the Maze, on stdOut. Put in a separate method to allow extensibility\n    * For simplicity sake doors are positioned on the north wall and east wall\n    */\n    public function printOut()\n    {\n        $this->log(\"Horizontal walls: %s\", json_encode($this->horWalls));\n        $this->log(\"Vertical walls: %s\", json_encode($this->vertWalls));        \n        \n        $northDoor = mt_rand(0,$this->width-1);\n        $eastDoor = mt_rand(0, $this->height-1);\n\n        $str = '+';\n        for ($i=0;$i<$this->width;$i++) {\n            $str .= ($northDoor == $i) ? '   +' : '---+';\n        }\n        $str .= PHP_EOL;\n        for ($i=0; $i<$this->height; $i++) {\n            \n            for ($j=0; $j<$this->width; $j++) {\n                $str .= (!empty($this->vertWalls[$j][$i]) ? $this->vertWalls[$j][$i] : '|   ');\n            }\n            $str .= ($i == $eastDoor ? '  ' : '|').PHP_EOL.'+';\n            for ($j=0; $j<$this->width; $j++) {\n                $str .= (!empty($this->horWalls[$j][$i]) ? $this->horWalls[$j][$i] : '---+');\n            }\n            $str .= PHP_EOL;\n        }\n        echo $str;\n    }\n\n    /**\n    * Logs to stdOut if debug flag is enabled\n    */\n    protected function log(...$params)\n    {\n        if ($this->isDebug) {\n            echo vsprintf(array_shift($params), $params).PHP_EOL;\n        }\n    }\n\n    private function walk($x, $y)\n    {\n        $this->log('Entering cell %d,%d', $x, $y);\n        // mark current cell as visited     \n        $this->grid[$x][$y] = true; \n        // add cell to path\n        $this->path[] = [$x, $y];\n        // get list of all neighbors\n        $neighbors = $this->getNeighbors($x, $y);       \n        $this->log(\"Valid neighbors: %s\", json_encode($neighbors));\n\n        if(empty($neighbors)) {\n            // Dead end, we need now to backtrack, if there's still any cell left to be visited\n            $this->log(\"Start backtracking along path: %s\", json_encode($this->path));\n            array_pop($this->path);\n            if (!empty($this->path)) {\n                $next = array_pop($this->path);\n                return $this->walk($next[0], $next[1]);\n            }\n        } else {            \n            // randomize neighbors, as per request\n            shuffle($neighbors);\n\n            foreach ($neighbors as $n) {\n                $nextX = $n[0];\n                $nextY = $n[1];\n                if ($nextX == $x) {\n                    $wallY = max($nextY, $y);\n                    $this->log(\"New cell is on the same column (%d,%d), removing %d, (%d-1) horizontal wall\", $nextX, $nextY, $x, $wallY);\n                    $this->horWalls[$x][min($nextY, $y)] = \"   +\";\n                }\n                if ($nextY == $y) {\n                    $wallX = max($nextX, $x);\n                    $this->log(\"New cell is on the same row (%d,%d), removing %d,%d vertical wall\", $nextX, $nextY, $wallX, $y);\n                    $this->vertWalls[$wallX][$y] = \"    \";              \n                }\n                return $this->walk($nextX, $nextY);\n            }\n        }\n    }\n    \n    /**\n    * Initialize an empty grid of $width * $height dimensions\n    */\n    private function initMaze()\n    {\n        for ($i=0;$i<$this->width;$i++) {\n            for ($j = 0;$j<$this->height;$j++) {\n                $this->grid[$i][$j] = false;\n            }\n        }\n    }\n\n    /**\n    * @param int $x\n    * @param int $y\n    * @return array\n    */\n    private function getNeighbors($x, $y) \n    {       \n        $neighbors = [];\n        foreach ($this->dirs as $dir) {\n            $nextX = $dir[0] + $x;\n            $nextY = $dir[1] + $y;\n            if (($nextX >= 0 && $nextX < $this->width && $nextY >= 0 && $nextY < $this->height) && !$this->grid[$nextX][$nextY]) {\n                $neighbors[] = [$nextX, $nextY];\n            }\n        }\n        return $neighbors;\n    }\n}\n\n$maze = new Maze(10,10);\n$maze->printOut();\n\n\nOutput:\n+---+   +---+---+---+---+---+---+---+---+\n|                                       |\n+---+---+---+---+---+---+---+   +---+   +\n|               |   |           |       |\n+   +---+---+   +   +   +---+---+   +---+\n|   |       |       |   |       |   |   |\n+   +   +   +---+---+   +---+   +   +   +\n|   |   |       |       |       |       |\n+   +---+   +   +---+   +   +---+---+   +\n|           |   |       |   |       |   |\n+---+---+---+   +   +---+   +   +   +   +\n|           |       |           |       |\n+   +---+---+---+---+   +---+---+---+---+\n|       |               |                 \n+---+   +   +---+---+---+---+---+   +   +\n|       |   |           |           |   |\n+   +---+   +   +   +   +   +---+---+   +\n|   |       |   |   |   |   |   |       |\n+   +   +---+---+   +   +   +   +   +---+\n|                   |       |           |\n+---+---+---+---+---+---+---+---+---+---+\n\n", "explain": "Code inspired by the D and Python solutions (with the implementation of backtracking, or sometimes it wouldn't work). Could have been done procedurally or fully OO (with cells as class too). A debug flag has been provided to allow following the inner workings. Works on PHP > 5.6.\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)   \n    \ntype maze struct { \n    c  []byte   // cell contents\n    h  []byte   // horizontal walls above cells\n    v  []byte   // vertical walls to the left of cells\n    c2 [][]byte // cells by row\n    h2 [][]byte // horizontal walls by row (ignore first row)\n    v2 [][]byte // vertical walls by row (ignore first of each column)\n}\n\nfunc newMaze(rows, cols int) *maze {\n    c := make([]byte, rows*cols)              // all cells\n    h := bytes.Repeat([]byte{'-'}, rows*cols) // all horizontal walls\n    v := bytes.Repeat([]byte{'|'}, rows*cols) // all vertical walls\n    c2 := make([][]byte, rows)                // cells by row\n    h2 := make([][]byte, rows)                // horizontal walls by row\n    v2 := make([][]byte, rows)                // vertical walls by row\n    for i := range h2 {\n        c2[i] = c[i*cols : (i+1)*cols]\n        h2[i] = h[i*cols : (i+1)*cols]\n        v2[i] = v[i*cols : (i+1)*cols]\n    }\n    return &maze{c, h, v, c2, h2, v2}\n}\n\nfunc (m *maze) String() string {\n    hWall := []byte(\"+---\")\n    hOpen := []byte(\"+   \")\n    vWall := []byte(\"|   \")\n    vOpen := []byte(\"    \")\n    rightCorner := []byte(\"+\\n\") \n    rightWall := []byte(\"|\\n\")\n    var b []byte\n    // for all rows \n    for r, hw := range m.h2 {\n        // draw h walls\n        for _, h := range hw { \n            if h == '-' || r == 0 {\n                b = append(b, hWall...)\n            } else {\n                b = append(b, hOpen...)\n            }\n        }\n        b = append(b, rightCorner...)\n        // draw v walls\n        for c, vw := range m.v2[r] {\n            if vw == '|' || c == 0 {\n                b = append(b, vWall...)\n            } else {\n                b = append(b, vOpen...)\n            }\n            // draw cell contents\n            if m.c2[r][c] != 0 {\n                b[len(b)-2] = m.c2[r][c]\n            }\n        }\n        b = append(b, rightWall...)\n    }\n    // draw bottom edge of maze\n    for _ = range m.h2[0] {\n        b = append(b, hWall...)\n    }\n    b = append(b, rightCorner...)\n    return string(b)\n}\n\nfunc (m *maze) gen() {\n    m.g2(rand.Intn(len(m.c2)), rand.Intn(len(m.c2[0])))\n}\n\nconst (\n    up = iota\n    dn\n    rt\n    lf\n)\n\nfunc (m *maze) g2(r, c int) {\n    m.c2[r][c] = ' '\n    for _, dir := range rand.Perm(4) {\n        switch dir {\n        case up:\n            if r > 0 && m.c2[r-1][c] == 0 {\n                m.h2[r][c] = 0\n                m.g2(r-1, c)\n            }\n        case lf:\n            if c > 0 && m.c2[r][c-1] == 0 {\n                m.v2[r][c] = 0\n                m.g2(r, c-1)\n            }\n        case dn:\n            if r < len(m.c2)-1 && m.c2[r+1][c] == 0 {\n                m.h2[r+1][c] = 0\n                m.g2(r+1, c)\n            }\n        case rt:\n            if c < len(m.c2[0])-1 && m.c2[r][c+1] == 0 {\n                m.v2[r][c+1] = 0\n                m.g2(r, c+1)\n            }\n        }\n    }\n}\n\nfunc main() {\n    rand.Seed(time.Now().UnixNano())\n    m := newMaze(4, 6)\n    m.gen()\n    fmt.Print(m)\n}\n\n\nOutput:\n+---+---+---+---+---+---+\n|   |           |       |\n+   +   +   +---+   +---+\n|   |   |           |   |\n+   +   +---+---+---+   +\n|   |   |               |\n+   +   +   +---+---+   +\n|           |           |\n+---+---+---+---+---+---+\n\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Delphi", "code": "\nprogram MazeGen_Rosetta;\n\n{$APPTYPE CONSOLE}\n\nuses System.SysUtils, System.Types, System.Generics.Collections, System.IOUtils;\n\ntype\n  TMCell = record\n    Visited  : Boolean;\n    PassTop  : Boolean;\n    PassLeft : Boolean;\n  end;\n  TMaze  = array of array of TMCell;\n  TRoute = TStack<TPoint>;\n\nconst\n  mwidth  = 24;\n  mheight = 14;\n\nprocedure ClearVisited(var AMaze: TMaze);\nvar\n  x, y: Integer;\nbegin\n  for y := 0 to mheight - 1 do\n    for x := 0 to mwidth - 1 do\n      AMaze[x, y].Visited := False;\nend;\n\nprocedure PrepareMaze(var AMaze: TMaze);\nvar\n  Route    : TRoute;\n  Position : TPoint;\n  d        : Integer;\n  Pool     : array of TPoint; // Pool of directions to pick randomly from\nbegin\n  SetLength(AMaze, mwidth, mheight);\n  ClearVisited(AMaze);\n  Position := Point(Random(mwidth), Random(mheight));\n  Route := TStack<TPoint>.Create;\n  try\n    with Position do\n    while True do\n    begin\n      repeat\n        SetLength(Pool, 0);\n        if (y > 0)         and not AMaze[x, y-1].Visited then Pool := Pool + [Point(0, -1)];\n        if (x < mwidth-1)  and not AMaze[x+1, y].Visited then Pool := Pool + [Point(1,  0)];\n        if (y < mheight-1) and not AMaze[x, y+1].Visited then Pool := Pool + [Point(0,  1)];\n        if (x > 0)         and not AMaze[x-1, y].Visited then Pool := Pool + [Point(-1, 0)];\n\n        if Length(Pool) = 0 then // no direction to draw from\n        begin\n          if Route.Count = 0 then Exit; // and we are back at start so this is the end\n          Position := Route.Pop;\n        end;\n      until Length(Pool) > 0;\n\n      d := Random(Length(Pool));\n      Offset(Pool[d]);\n\n      AMaze[x, y].Visited := True;\n      if Pool[d].y = -1 then AMaze[x, y+1].PassTop  := True; // comes from down to up ( ^ )\n      if Pool[d].x =  1 then AMaze[x, y].PassLeft   := True; // comes from left to right ( --> )\n      if Pool[d].y =  1 then AMaze[x, y].PassTop    := True; // comes from left to right ( v )\n      if Pool[d].x = -1 then AMaze[x+1, y].PassLeft := True; // comes from right to left ( <-- )\n      Route.Push(Position);\n    end;\n  finally\n    Route.Free;\n  end;\nend;\n\nfunction MazeToString(const AMaze: TMaze; const S, E: TPoint): String; overload;\nvar\n  x, y: Integer;\n  v   : Char;\nbegin\n  Result := '';\n  for y := 0 to mheight - 1 do\n  begin\n    for x := 0 to mwidth - 1 do\n      if AMaze[x, y].PassTop then Result := Result + '+'#32#32#32 else Result := Result + '+---';\n    Result := Result + '+' + sLineBreak;\n    for x := 0 to mwidth - 1 do\n    begin\n      if S = Point(x, y) then v := 'S' else\n        if E = Point(x, y) then v := 'E' else\n          v := #32'*'[Ord(AMaze[x, y].Visited) + 1];\n\n      Result := Result + '|'#32[Ord(AMaze[x, y].PassLeft) + 1] + #32 + v + #32;\n    end;\n    Result := Result + '|' + sLineBreak;\n  end;\n  for x := 0 to mwidth - 1 do Result := Result + '+---';\n  Result := Result + '+' + sLineBreak;\nend;\n\nprocedure Main;\nvar\n  Maze: TMaze;\nbegin\n  Randomize;\n  PrepareMaze(Maze);\n  ClearVisited(Maze);     // show no route\n  Write(MazeToString(Maze, Point(-1, -1), Point(-1, -1)));\n  ReadLn;\nend;\n\nbegin\n  Main;\n\nend.\n\n\nOutput:\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |               |                           |       |                           |               |                   |       |\n+   +   +---+---+   +   +   +---+---+---+---+---+   +   +   +---+---+---+   +---+   +   +---+---+   +   +   +---+   +---+---+   +\n|       |       |       |                           |       |               |       |   |           |   |   |       |           |\n+   +---+   +---+---+---+---+---+---+---+---+---+---+---+   +   +---+---+---+   +---+---+   +---+---+   +   +---+---+   +---+---+\n|   |               |               |           |       |   |       |           |       |               |           |   |       |\n+   +---+---+   +   +   +   +---+   +---+   +   +   +   +---+---+   +---+---+   +   +   +   +---+---+---+   +---+   +   +   +   +\n|       |       |   |   |   |               |   |   |           |           |       |   |   |           |       |   |   |   |   |\n+---+   +---+   +   +---+   +---+---+---+---+---+   +---+---+   +---+---+   +---+---+   +---+   +---+   +---+---+   +   +   +   +\n|       |       |       |           |           |   |   |       |           |       |   |       |       |       |   |       |   |\n+   +---+   +---+---+   +---+---+   +   +---+   +   +   +   +---+   +---+---+   +   +   +   +---+   +---+   +   +   +---+---+   +\n|           |   |                   |       |       |   |       |   |           |   |       |   |           |   |   |       |   |\n+---+---+---+   +   +---+---+---+---+---+   +---+---+   +---+   +   +---+   +---+   +---+---+   +---+---+---+   +   +   +   +   +\n|               |       |               |   |           |       |       |       |   |               |               |   |       |\n+   +---+   +---+---+   +   +---+---+   +   +   +   +---+   +---+   +   +---+   +---+   +---+---+   +   +---+---+---+   +---+---+\n|   |   |           |   |   |               |   |           |       |       |           |       |       |               |       |\n+   +   +---+---+   +   +   +   +---+---+---+   +---+---+---+   +---+---+   +   +---+---+---+   +---+---+   +---+---+---+   +---+\n|       |   |       |   |   |   |           |           |       |       |   |                       |       |           |       |\n+---+   +   +   +---+   +   +---+   +---+   +---+---+   +---+---+   +   +   +---+---+---+---+---+   +   +---+---+   +   +---+   +\n|   |       |   |       |       |   |   |       |                   |       |                   |   |               |           |\n+   +---+   +   +   +---+---+   +   +   +---+   +---+---+---+---+---+---+---+   +---+---+---+   +---+---+---+---+---+---+---+   +\n|       |   |   |   |       |   |   |       |           |           |       |   |           |                       |           |\n+   +   +   +   +   +   +   +   +   +---+   +---+---+   +   +---+   +   +   +   +---+   +   +---+---+---+   +---+---+   +---+---+\n|   |       |           |   |                       |           |       |               |               |                       |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Ruby", "code": "\nclass Maze\n  DIRECTIONS = [ [1, 0], [-1, 0], [0, 1], [0, -1] ]\n  \n  def initialize(width, height)\n    @width   = width\n    @height  = height\n    @start_x = rand(width)\n    @start_y = 0\n    @end_x   = rand(width)\n    @end_y   = height - 1\n    \n    # Which walls do exist? Default to \"true\". Both arrays are\n    # one element bigger than they need to be. For example, the\n    # @vertical_walls[x][y] is true if there is a wall between\n    # (x,y) and (x+1,y). The additional entry makes printing easier.\n    @vertical_walls   = Array.new(width) { Array.new(height, true) }\n    @horizontal_walls = Array.new(width) { Array.new(height, true) }\n    # Path for the solved maze.\n    @path             = Array.new(width) { Array.new(height) }\n    \n    # \"Hack\" to print the exit.\n    @horizontal_walls[@end_x][@end_y] = false\n    \n    # Generate the maze.\n    generate\n  end\n  \n  # Print a nice ASCII maze.\n  def print\n    # Special handling: print the top line.\n    puts @width.times.inject(\"+\") {|str, x| str << (x == @start_x ? \"   +\" : \"---+\")}\n    \n    # For each cell, print the right and bottom wall, if it exists.\n    @height.times do |y|\n      line = @width.times.inject(\"|\") do |str, x|\n        str << (@path[x][y] ? \" * \" : \"   \") << (@vertical_walls[x][y] ? \"|\" : \" \")\n      end\n      puts line\n      \n      puts @width.times.inject(\"+\") {|str, x| str << (@horizontal_walls[x][y] ? \"---+\" : \"   +\")}\n    end\n  end\n  \n  private\n  \n  # Reset the VISITED state of all cells.\n  def reset_visiting_state\n    @visited = Array.new(@width) { Array.new(@height) }\n  end\n  \n  # Is the given coordinate valid and the cell not yet visited?\n  def move_valid?(x, y)\n    (0...@width).cover?(x) && (0...@height).cover?(y) && !@visited[x][y]\n  end\n  \n  # Generate the maze.\n  def generate\n    reset_visiting_state\n    generate_visit_cell(@start_x, @start_y)\n  end\n  \n  # Depth-first maze generation.\n  def generate_visit_cell(x, y)\n    # Mark cell as visited.\n    @visited[x][y] = true\n    \n    # Randomly get coordinates of surrounding cells (may be outside\n    # of the maze range, will be sorted out later).\n    coordinates = DIRECTIONS.shuffle.map { |dx, dy| [x + dx, y + dy] }\n    \n    for new_x, new_y in coordinates\n      next unless move_valid?(new_x, new_y)\n      \n      # Recurse if it was possible to connect the current and\n      # the cell (this recursion is the \"depth-first\" part).\n      connect_cells(x, y, new_x, new_y)\n      generate_visit_cell(new_x, new_y)\n    end\n  end\n  \n  # Try to connect two cells. Returns whether it was valid to do so.\n  def connect_cells(x1, y1, x2, y2)\n    if x1 == x2\n      # Cells must be above each other, remove a horizontal wall.\n      @horizontal_walls[x1][ [y1, y2].min ] = false\n    else\n      # Cells must be next to each other, remove a vertical wall.\n      @vertical_walls[ [x1, x2].min ][y1] = false\n    end\n  end\nend\n\n# Demonstration:\nmaze = Maze.new 20, 10\nmaze.print\n\n\nOutput:\n+---+---+---+---+---+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+\n|                   |   |                       |   |       |           |       |\n+   +---+   +---+   +   +   +---+---+---+   +   +   +---+   +   +---+   +---+   +\n|   |   |   |           |   |       |       |   |       |       |   |   |       |\n+   +   +   +---+---+   +   +   +---+   +---+   +---+   +---+---+   +   +   +---+\n|   |   |           |   |       |       |       |           |   |       |       |\n+   +   +---+---+   +---+---+   +   +---+---+   +   +---+   +   +   +---+---+   +\n|   |           |           |   |           |       |       |   |               |\n+   +---+---+   +---+---+   +   +---+---+   +---+---+   +---+   +---+---+---+   +\n|               |       |   |       |   |   |                       |       |   |\n+---+---+   +---+   +   +   +---+   +   +   +---+---+---+---+   +---+   +   +   +\n|   |       |       |           |       |           |           |       |       |\n+   +   +---+   +---+---+---+---+---+   +---+---+   +   +---+---+   +---+---+---+\n|   |       |                       |   |       |   |       |   |   |           |\n+   +---+   +---+---+---+---+---+   +   +---+   +   +---+   +   +   +---+---+   +\n|       |           |   |           |           |       |       |   |           |\n+   +   +---+---+   +   +   +---+---+---+---+   +---+   +---+---+   +   +---+---+\n|   |       |       |   |       |               |       |           |           |\n+   +   +---+   +---+   +---+   +   +---+---+---+   +---+   +---+---+---+---+   +\n|   |                       |                   |                               |\n+---+---+---+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+---+\n\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Rust", "code": "\n\nuse rand::{thread_rng, Rng, rngs::ThreadRng};\n\nconst WIDTH: usize = 16;\nconst HEIGHT: usize = 16;\n\n#[derive(Clone, Copy)]\nstruct Cell {\n    col: usize,\n    row: usize,\n}\n\nimpl Cell {\n    fn from(col: usize, row: usize) -> Cell {\n        Cell {col, row}\n    }\n}\n\nstruct Maze {\n    cells: [[bool; HEIGHT]; WIDTH],         //cell visited/non visited\n    walls_h: [[bool; WIDTH]; HEIGHT + 1],   //horizontal walls existing/removed\n    walls_v: [[bool; WIDTH + 1]; HEIGHT],   //vertical walls existing/removed\n    thread_rng: ThreadRng,                  //Random numbers generator\n}\n\nimpl Maze {\n\n    ///Inits the maze, with all the cells unvisited and all the walls active\n    fn new() -> Maze {\n        Maze { \n            cells: [[true; HEIGHT]; WIDTH], \n            walls_h: [[true; WIDTH]; HEIGHT + 1],\n            walls_v: [[true; WIDTH + 1]; HEIGHT],\n            thread_rng: thread_rng(),\n        }\n    }\n\n    ///Randomly chooses the starting cell\n    fn first(&mut self) -> Cell {\n        Cell::from(self.thread_rng.gen_range(0, WIDTH), self.thread_rng.gen_range(0, HEIGHT))\n    }\n\n    ///Opens the enter and exit doors\n    fn open_doors(&mut self) {\n        let from_top: bool = self.thread_rng.gen();\n        let limit = if from_top { WIDTH } else { HEIGHT };\n        let door = self.thread_rng.gen_range(0, limit);\n        let exit = self.thread_rng.gen_range(0, limit);\n        if from_top { \n            self.walls_h[0][door] = false;\n            self.walls_h[HEIGHT][exit] = false;\n        } else {\n            self.walls_v[door][0] = false;\n            self.walls_v[exit][WIDTH] = false;\n        }\n    }\n\n    ///Removes a wall between the two Cell arguments\n    fn remove_wall(&mut self, cell1: &Cell, cell2: &Cell) {\n        if cell1.row == cell2.row {\n            self.walls_v[cell1.row][if cell1.col > cell2.col { cell1.col } else { cell2.col }] = false;\n        } else { \n            self.walls_h[if cell1.row > cell2.row { cell1.row } else { cell2.row }][cell1.col] = false;\n        };\n    }\n\n    ///Returns a random non-visited neighbor of the Cell passed as argument\n    fn neighbor(&mut self, cell: &Cell) -> Option<Cell> {\n        self.cells[cell.col][cell.row] = false;\n        let mut neighbors = Vec::new();\n        if cell.col > 0 && self.cells[cell.col - 1][cell.row] { neighbors.push(Cell::from(cell.col - 1, cell.row)); }\n        if cell.row > 0 && self.cells[cell.col][cell.row - 1] { neighbors.push(Cell::from(cell.col, cell.row - 1)); }\n        if cell.col < WIDTH - 1 && self.cells[cell.col + 1][cell.row] { neighbors.push(Cell::from(cell.col + 1, cell.row)); }\n        if cell.row < HEIGHT - 1 && self.cells[cell.col][cell.row + 1] { neighbors.push(Cell::from(cell.col, cell.row + 1)); }\n        if neighbors.is_empty() {\n            None\n        } else {\n            let next = neighbors.get(self.thread_rng.gen_range(0, neighbors.len())).unwrap();\n            self.remove_wall(cell, next);\n            Some(*next)\n        }\n    }\n\n    ///Builds the maze (runs the Depth-first search algorithm)\n    fn build(&mut self) {\n        let mut cell_stack: Vec<Cell> = Vec::new();\n        let mut next = self.first();\n        loop {\n            while let Some(cell) = self.neighbor(&next) {\n                cell_stack.push(cell);\n                next = cell;\n            }\n            match cell_stack.pop() {\n                Some(cell) => next = cell,\n                None => break,\n            }\n        }\n    }\n\n    ///Displays a wall\n    fn paint_wall(h_wall: bool, active: bool) {\n        if h_wall {\n            print!(\"{}\", if active { \"+---\" } else { \"+   \" });\n        } else {\n            print!(\"{}\", if active { \"|   \" } else { \"    \" });\n        }\n    }\n\n    ///Displays a final wall for a row\n    fn paint_close_wall(h_wall: bool) {\n        if h_wall { println!(\"+\") } else { println!() }\n    }\n\n    ///Displays a whole row of walls\n    fn paint_row(&self, h_walls: bool, index: usize) {\n        let iter = if h_walls { self.walls_h[index].iter() } else { self.walls_v[index].iter() };\n        for &wall in iter {\n            Maze::paint_wall(h_walls, wall);\n        }\n        Maze::paint_close_wall(h_walls);\n    } \n\n    ///Paints the maze\n    fn paint(&self) {\n        for i in 0 .. HEIGHT {\n            self.paint_row(true, i);\n            self.paint_row(false, i);\n        }\n        self.paint_row(true, HEIGHT);\n    }\n}\n\nfn main() {\n    let mut maze = Maze::new();\n    maze.build();\n    maze.open_doors();\n    maze.paint();\n}\n\n\nOutput:\n+---+---+---+---+---+---+---+   +---+---+---+---+---+---+---+---+\n|           |           |                       |               |   \n+   +---+---+   +   +   +---+   +---+---+---+   +---+---+---+   +\n|           |   |   |   |       |       |   |           |       |   \n+   +---+   +   +   +   +   +---+   +   +   +---+---+   +   +   +\n|       |   |   |   |       |       |               |       |   |   \n+---+   +   +   +   +---+---+   +   +---+---+   +---+---+---+   +\n|       |       |   |   |       |   |   |       |               |   \n+   +---+---+---+   +   +   +---+   +   +   +---+   +---+---+---+\n|               |   |       |   |   |           |   |           |   \n+---+---+   +---+   +   +---+   +   +---+---+   +   +   +   +   +\n|           |       |   |       |           |   |   |   |   |   |   \n+   +---+---+   +---+   +   +---+---+---+   +---+   +   +   +---+\n|   |       |   |       |               |       |   |   |       |   \n+   +   +   +   +   +---+   +---+   +   +---+   +   +---+---+   +\n|   |   |   |   |       |       |   |       |   |   |       |   |   \n+   +   +---+   +---+   +---+---+   +---+   +   +   +   +   +   +\n|   |   |       |   |   |           |       |   |   |   |   |   |   \n+   +   +   +---+   +   +   +   +---+---+---+   +   +   +   +   +\n|   |   |   |       |   |   |   |           |   |       |       |   \n+   +   +   +   +   +   +   +---+   +---+   +   +---+---+---+   +\n|       |   |   |       |   |       |           |   |           |   \n+---+   +   +   +---+---+   +   +---+---+---+   +   +   +---+---+\n|       |   |           |   |               |   |   |   |       |   \n+   +---+   +---+---+   +   +---+---+---+   +   +   +   +   +   +\n|       |       |   |           |   |       |   |   |   |   |   |   \n+---+---+   +   +   +---+---+   +   +   +---+   +   +   +---+   +\n|       |   |   |           |   |   |   |           |       |   |   \n+---+   +---+   +---+   +   +   +   +   +---+---+---+---+   +   +\n|   |       |       |   |   |       |                   |       |   \n+   +---+   +---+   +   +---+---+   +---+---+---+---+   +---+   +\n|                   |                               |           |   \n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+   +\n", "explain": "Uses the rand library\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Swift", "code": "\nWorks with: Swift version 3\nimport Foundation\n\nextension Array {\n    mutating func shuffle() {\n        guard count > 1 else { return }\n\n        for i in 0..<self.count - 1 {\n            let j = Int(arc4random_uniform(UInt32(count - i))) + i\n            guard i != j else { continue }\n            swap(&self[i], &self[j])\n        }\n    }\n}\n\nenum Direction:Int {\n    case north = 1\n    case south = 2\n    case east = 4\n    case west = 8\n\n    static var allDirections:[Direction] {\n        return [Direction.north, Direction.south, Direction.east, Direction.west]\n    }\n\n    var opposite:Direction {\n        switch self {\n        case .north:\n            return .south\n        case .south:\n            return .north\n        case .east:\n            return .west\n        case .west:\n            return .east\n        }\n    }\n\n    var diff:(Int, Int) {\n        switch self {\n        case .north:\n            return (0, -1)\n        case .south:\n            return (0, 1)\n        case .east:\n            return (1, 0)\n        case .west:\n            return (-1, 0)\n        }\n    }\n\n    var char:String {\n        switch self {\n        case .north:\n            return \"N\"\n        case .south:\n            return \"S\"\n        case .east:\n            return \"E\"\n        case .west:\n            return \"W\"\n        }\n    }\n\n}\n\nclass MazeGenerator {\n    let x:Int\n    let y:Int\n    var maze:[[Int]]\n\n    init(_ x:Int, _ y:Int) {\n        self.x  = x\n        self.y = y\n        let column = [Int](repeating: 0, count: y)\n        self.maze = [[Int]](repeating: column, count: x)\n        generateMaze(0, 0)\n    }\n\n    private func generateMaze(_ cx:Int, _ cy:Int) {\n        var directions = Direction.allDirections\n        directions.shuffle()\n        for direction in directions {\n            let (dx, dy) = direction.diff\n            let nx = cx + dx\n            let ny = cy + dy\n            if inBounds(nx, ny) && maze[nx][ny] == 0 {\n                maze[cx][cy] |= direction.rawValue\n                maze[nx][ny] |= direction.opposite.rawValue\n                generateMaze(nx, ny)\n            }\n        }\n    }\n\n    private func inBounds(_ testX:Int, _ testY:Int) -> Bool {\n        return inBounds(value:testX, upper:self.x) && inBounds(value:testY, upper:self.y)\n    }\n\n    private func inBounds(value:Int, upper:Int) -> Bool {\n        return (value >= 0) && (value < upper)\n    }\n\n    func display() {\n        let cellWidth = 3\n        for j in 0..<y {\n            // Draw top edge\n            var topEdge = \"\"\n            for i in 0..<x {\n                topEdge += \"+\"\n                topEdge += String(repeating: (maze[i][j] & Direction.north.rawValue) == 0 ? \"-\" : \" \", count: cellWidth)\n            }\n            topEdge += \"+\"\n            print(topEdge)\n\n            // Draw left edge\n            var leftEdge = \"\"\n            for i in 0..<x {\n                leftEdge += (maze[i][j] & Direction.west.rawValue) == 0 ? \"|\" : \" \"\n                leftEdge += String(repeating: \" \", count: cellWidth)\n            }\n            leftEdge += \"|\"\n            print(leftEdge)\n        }\n\n        // Draw bottom edge\n        var bottomEdge = \"\"\n        for _ in 0..<x {\n            bottomEdge += \"+\"\n            bottomEdge += String(repeating: \"-\", count: cellWidth)\n        }\n        bottomEdge += \"+\"\n        print(bottomEdge)\n    }\n    \n    func displayInts() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += String(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    func displayDirections() {\n        for j in 0..<y {\n            var line = \"\"\n            for i in 0..<x {\n                line += getDirectionsAsString(maze[i][j]) + \"\\t\"\n            }\n            print(line)\n        }\n    }\n\n    private func getDirectionsAsString(_ value:Int) -> String {\n        var line = \"\"\n        for direction in Direction.allDirections {\n            if (value & direction.rawValue) != 0 {\n                line += direction.char\n            }\n        }\n        return line\n    }\n}\n\n\nlet x = 20\nlet y = 10\nlet maze = MazeGenerator(x, y)\nmaze.display()\n\n\nOutput:\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|           |                                   |           |               |   |\n+---+---+   +---+   +   +---+---+---+---+---+   +---+   +   +---+---+   +   +   +\n|       |       |   |   |                   |           |               |       |\n+   +---+---+   +   +   +   +---+   +---+   +---+---+---+---+---+---+---+---+   +\n|       |       |   |   |   |   |       |               |                   |   |\n+---+   +   +---+   +   +   +   +---+   +---+---+---+   +   +---+---+   +   +   +\n|       |   |       |   |       |   |   |       |       |           |   |   |   |\n+   +---+   +   +---+   +---+   +   +   +   +   +---+---+---+   +---+   +---+   +\n|   |       |       |   |           |       |       |           |       |       |\n+   +   +---+---+   +   +---+---+   +---+---+---+   +   +---+---+   +   +   +---+\n|       |   |       |       |               |       |   |   |       |   |       |\n+   +---+   +   +---+---+   +---+---+---+   +   +   +   +   +   +---+   +---+   +\n|   |   |               |           |       |   |   |   |   |   |           |   |\n+   +   +   +---+---+---+   +---+   +   +---+   +   +   +   +   +---+---+---+   +\n|   |       |           |   |       |       |   |   |   |   |   |               |\n+   +---+---+   +---+   +   +   +---+---+   +   +---+   +   +   +   +---+---+---+\n|           |   |       |   |   |           |       |   |   |   |           |   |\n+---+---+   +   +   +---+---+   +   +---+---+---+   +   +   +   +---+---+   +   +\n|               |               |               |           |                   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Ada", "code": "\nWorks with: Ada 2005\nWorks with: GNAT\n\ngeneric\n   Height : Positive;\n   Width : Positive;\npackage Mazes is\n\n   type Maze_Grid is private;\n\n   procedure Initialize (Maze : in out Maze_Grid);\n\n   procedure Put (Item : Maze_Grid);\n\nprivate\n\n   type Directions is (North, South, West, East);\n\n   type Cell_Walls is array (Directions) of Boolean;\n   type Cells is record\n      Walls   : Cell_Walls := (others => True);\n      Visited : Boolean    := False;\n   end record;\n\n   subtype Height_Type is Positive range 1 .. Height;\n   subtype Width_Type is Positive range 1 .. Width;\n\n   type Maze_Grid is array (Height_Type, Width_Type) of Cells;\n\nend Mazes;\n\n\nwith Ada.Numerics.Discrete_Random;\nwith Ada.Text_IO;\n \npackage body Mazes is\n   package RNG is new Ada.Numerics.Discrete_Random (Positive);\n   package Random_Direction is new Ada.Numerics.Discrete_Random (Directions);\n \n   Generator     : RNG.Generator;\n   Dir_Generator : Random_Direction.Generator;\n \n   function \"-\" (Dir : Directions) return Directions is\n   begin\n      case Dir is\n         when North =>\n            return South;\n         when South =>\n            return North;\n         when East =>\n            return West;\n         when West =>\n            return East;\n      end case;\n   end \"-\";\n \n   procedure Move\n     (Row        : in out Height_Type;\n      Column     : in out Width_Type;\n      Direction  : Directions;\n      Valid_Move : out Boolean)\n   is\n   begin\n      Valid_Move := False;\n      case Direction is\n         when North =>\n            if Row > Height_Type'First then\n               Valid_Move := True;\n               Row        := Row - 1;\n            end if;\n         when East =>\n            if Column < Width_Type'Last then\n               Valid_Move := True;\n               Column     := Column + 1;\n            end if;\n         when West =>\n            if Column > Width_Type'First then\n               Valid_Move := True;\n               Column     := Column - 1;\n            end if;\n         when South =>\n            if Row < Height_Type'Last then\n               Valid_Move := True;\n               Row        := Row + 1;\n            end if;\n      end case;\n   end Move;\n \n   procedure Depth_First_Algorithm\n     (Maze   : in out Maze_Grid;\n      Row    : Height_Type;\n      Column : Width_Type)\n   is\n      Next_Row        : Height_Type;\n      Next_Column     : Width_Type;\n      Next_Direction  : Directions;\n      Valid_Direction : Boolean;\n      Tested_Wall     : array (Directions) of Boolean := (others => False);\n      All_Tested      : Boolean;\n   begin\n      -- mark as visited\n      Maze (Row, Column).Visited := True;\n      loop\n         -- use random direction\n         loop\n            Next_Direction := Random_Direction.Random (Dir_Generator);\n            exit when not Tested_Wall (Next_Direction);\n         end loop;\n         Next_Row       := Row;\n         Next_Column    := Column;\n         Move (Next_Row, Next_Column, Next_Direction, Valid_Direction);\n         if Valid_Direction then\n            if not Maze (Next_Row, Next_Column).Visited then\n               -- connect the two cells\n               Maze (Row, Column).Walls (Next_Direction)              :=\n                 False;\n               Maze (Next_Row, Next_Column).Walls (-Next_Direction)   :=\n                 False;\n               Depth_First_Algorithm (Maze, Next_Row, Next_Column);\n            end if;\n         end if;\n         Tested_Wall (Next_Direction) := True;\n         -- continue as long as there are unvisited neighbours left\n         All_Tested := True;\n         for D in Directions loop\n            All_Tested := All_Tested and Tested_Wall (D);\n         end loop;\n         -- all directions are either visited (from here,\n         -- or previously visited), or invalid.\n         exit when All_Tested;\n      end loop;\n   end Depth_First_Algorithm;\n \n   procedure Initialize (Maze : in out Maze_Grid) is\n      Row, Column : Positive;\n   begin\n      -- initialize random generators\n      RNG.Reset (Generator);\n      Random_Direction.Reset (Dir_Generator);\n      -- choose starting cell\n      Row    := RNG.Random (Generator) mod Height + 1;\n      Column := RNG.Random (Generator) mod Width + 1;\n      Ada.Text_IO.Put_Line\n        (\"Starting generation at \" &\n         Positive'Image (Row) &\n         \" x\" &\n         Positive'Image (Column));\n      Depth_First_Algorithm (Maze, Row, Column);\n   end Initialize;\n \n   procedure Put (Item : Maze_Grid) is\n   begin\n      for Row in Item'Range (1) loop\n         if Row = Item'First (1) then\n            Ada.Text_IO.Put ('+');\n            for Col in Item'Range (2) loop\n               if Item (Row, Col).Walls (North) then\n                  Ada.Text_IO.Put (\"---+\");\n               else\n                  Ada.Text_IO.Put (\"   +\");\n               end if;\n            end loop;\n            Ada.Text_IO.New_Line;\n         end if;\n         for Col in Item'Range (2) loop\n            if Col = Item'First (2) then\n               if Item (Row, Col).Walls (West) then\n                  Ada.Text_IO.Put ('|');\n               else\n                  Ada.Text_IO.Put (' ');\n               end if;\n            elsif Item (Row, Col).Walls (West)\n              and then Item (Row, Col - 1).Walls (East)\n            then\n               Ada.Text_IO.Put ('|');\n            elsif Item (Row, Col).Walls (West)\n              or else Item (Row, Col - 1).Walls (East)\n            then\n               Ada.Text_IO.Put ('>');\n            else\n               Ada.Text_IO.Put (' ');\n            end if;\n            if Item (Row, Col).Visited then\n               Ada.Text_IO.Put (\"   \");\n            else\n               Ada.Text_IO.Put (\"???\");\n            end if;\n         end loop;\n         if Item (Row, Item'Last (2)).Walls (East) then\n            Ada.Text_IO.Put_Line (\"|\");\n         else\n            Ada.Text_IO.Put_Line (\" \");\n         end if;\n         Ada.Text_IO.Put ('+');\n         for Col in Item'Range (2) loop\n            if Item (Row, Col).Walls (South) then\n               Ada.Text_IO.Put (\"---+\");\n            else\n               Ada.Text_IO.Put (\"   +\");\n            end if;\n         end loop;\n         Ada.Text_IO.New_Line;\n      end loop;\n   end Put;\nend Mazes;\n\n\nwith Mazes;\nprocedure Main is\n   package Small_Mazes is new Mazes (Height => 8, Width => 11);\n   My_Maze : Small_Mazes.Maze_Grid;\nbegin\n   Small_Mazes.Initialize (My_Maze);\n   Small_Mazes.Put (My_Maze);\nend Main;\n\n\nOutput:\nStarting generation at  3 x 7\n+---+---+---+---+---+---+---+---+---+---+---+\n|   |               |   |                   |\n+   +   +   +---+   +   +   +---+---+---+   +\n|       |       |       |   |       |       |\n+   +---+---+   +---+---+   +   +   +   +---+\n|           |           |   |   |   |   |   |\n+   +---+---+---+---+   +---+   +   +   +   +\n|   |           |       |       |       |   |\n+   +   +---+   +   +   +   +---+---+---+   +\n|   |   |           |   |       |           |\n+   +   +---+---+---+---+---+   +---+   +   +\n|   |   |                   |           |   |\n+---+   +   +---+---+---+   +---+---+---+   +\n|       |   |           |                   |\n+   +---+   +---+---+   +---+---+---+---+---+\n|                                           |\n+---+---+---+---+---+---+---+---+---+---+---+\n", "explain": "mazes.ads:\nmazes.adb:\nExample main.adb:\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Julia", "code": "\nWorks with: Julia version >0.6\n\nusing Random\ncheck(bound::Vector) = cell -> all([1, 1] .\u2264 cell .\u2264 bound)\nneighbors(cell::Vector, bound::Vector, step::Int=2) =\n    filter(check(bound), map(dir -> cell + step * dir, [[0, 1], [-1, 0], [0, -1], [1, 0]]))\n\nfunction walk(maze::Matrix, nxtcell::Vector, visited::Vector=[])\n    push!(visited, nxtcell)\n    for neigh in shuffle(neighbors(nxtcell, collect(size(maze))))\n        if neigh \u2209 visited\n            maze[round.(Int, (nxtcell + neigh) / 2)...] = 0\n            walk(maze, neigh, visited)\n        end\n    end\n    maze\nend\nfunction maze(w::Int, h::Int)\n    maze = collect(i % 2 | j % 2 for i in 1:2w+1, j in 1:2h+1)\n    firstcell = 2 * [rand(1:w), rand(1:h)]\n    return walk(maze, firstcell)\nend\n\n\npprint(matrix) = for i = 1:size(matrix, 1) println(join(matrix[i, :])) end\nfunction printmaze(maze)\n    walls = split(\"\u2579 \u2578 \u251b \u257a \u2517 \u2501 \u253b \u257b \u2503 \u2513 \u252b \u250f \u2523 \u2533 \u254b\")\n    h, w = size(maze)\n    f = cell -> 2 ^ ((3cell[1] + cell[2] + 3) / 2)\n    wall(i, j) = if maze[i,j] == 0 \" \" else\n        walls[Int(sum(f, filter(x -> maze[x...] != 0, neighbors([i, j], [h, w], 1)) .- [[i, j]]))]\n    end\n    mazewalls = collect(wall(i, j) for i in 1:2:h, j in 1:w)\n    pprint(mazewalls)\nend\n\nprintmaze(maze(10, 10))\n\n\nOutput:\n\u250f\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2513\n\u2503 \u257b \u257b \u2503 \u257a\u2501\u2513 \u2579 \u250f\u2501\u2501\u2501\u2513 \u2503\n\u2523\u2501\u251b \u2503 \u2517\u2501\u2513 \u2517\u2501\u2501\u2501\u251b \u257b \u2503 \u2503\n\u2503 \u257a\u2501\u253b\u2501\u2513 \u2503 \u257a\u2501\u2533\u2501\u2501\u2501\u251b \u2503 \u2503\n\u2503 \u257a\u2501\u2513 \u2503 \u2517\u2501\u2501\u2501\u251b \u250f\u2501\u2501\u2501\u251b \u2503\n\u2523\u2501\u2501\u2501\u251b \u2523\u2501\u2501\u2501\u2501\u2501\u2533\u2501\u251b \u250f\u2501\u2501\u2501\u252b\n\u2503 \u250f\u2501\u2501\u2501\u251b \u250f\u2501\u2578 \u2503 \u257a\u2501\u251b \u257b \u2503\n\u2523\u2501\u251b \u250f\u2501\u2501\u2501\u251b \u257b \u2523\u2501\u2501\u2501\u2501\u2501\u251b \u2503\n\u2503 \u250f\u2501\u251b \u250f\u2501\u2501\u2501\u253b\u2501\u251b \u250f\u2501\u2501\u2501\u2533\u2501\u252b\n\u2503 \u2503 \u257a\u2501\u251b \u257a\u2501\u2501\u2501\u2501\u2501\u251b \u257b \u2579 \u2503\n\u2517\u2501\u253b\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u2501\u253b\u2501\u2501\u2501\u251b\n", "explain": "Generating functions\nPrinting functions\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Kotlin", "code": "\nTranslation of: Java\nimport java.util.*\n\nclass MazeGenerator(val x: Int, val y: Int) {\n    private val maze = Array(x) { IntArray(y) }\n\n    fun generate(cx: Int, cy: Int) {\n        Direction.values().shuffle().forEach {\n            val nx = cx + it.dx\n            val ny = cy + it.dy\n            if (between(nx, x) && between(ny, y) && maze[nx][ny] == 0) {\n                maze[cx][cy] = maze[cx][cy] or it.bit\n                maze[nx][ny] = maze[nx][ny] or it.opposite!!.bit\n                generate(nx, ny)\n            }\n        }\n    }\n\n    fun display() {\n        for (i in 0..y - 1) {\n            // draw the north edge\n            for (j in 0..x - 1)\n                print(if (maze[j][i] and 1 == 0) \"+---\" else \"+   \")\n            println('+')\n\n            // draw the west edge\n            for (j in 0..x - 1)\n                print(if (maze[j][i] and 8 == 0) \"|   \" else \"    \")\n            println('|')\n        }\n\n        // draw the bottom line\n        for (j in 0..x - 1) print(\"+---\")\n        println('+')\n    }\n\n    inline private fun <reified T> Array<T>.shuffle(): Array<T> {\n        val list = toMutableList()\n        Collections.shuffle(list)\n        return list.toTypedArray()\n    }\n\n    private enum class Direction(val bit: Int, val dx: Int, val dy: Int) {\n        N(1, 0, -1), S(2, 0, 1), E(4, 1, 0),W(8, -1, 0);\n\n        var opposite: Direction? = null\n\n        companion object {\n            init {\n                N.opposite = S\n                S.opposite = N\n                E.opposite = W\n                W.opposite = E\n            }\n        }\n    }\n\n    private fun between(v: Int, upper: Int) = v >= 0 && v < upper\n}\n\nfun main(args: Array<String>) {\n    val x = if (args.size >= 1) args[0].toInt() else 8\n    val y = if (args.size == 2) args[1].toInt() else 8\n    with(MazeGenerator(x, y)) {\n        generate(0, 0)\n        display()\n    }\n}\n\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Perl", "code": "\nuse List::Util 'max';\n\nmy ($w, $h) = @ARGV;\n$w ||= 26;\n$h ||= 127;\nmy $avail = $w * $h;\n\n# cell is padded by sentinel col and row, so I don't check array bounds\nmy @cell = (map([(('1') x $w), 0], 1 .. $h), [('') x ($w + 1)]);\nmy @ver = map([(\"|  \") x $w], 1 .. $h);\nmy @hor = map([(\"+--\") x $w], 0 .. $h);\n\nsub walk {\n\tmy ($x, $y) = @_;\n\t$cell[$y][$x] = '';\n\t$avail-- or return;\t# no more bottles, er, cells\n\n\tmy @d = ([-1, 0], [0, 1], [1, 0], [0, -1]);\n\twhile (@d) {\n\t\tmy $i = splice @d, int(rand @d), 1;\n\t\tmy ($x1, $y1) = ($x + $i->[0], $y + $i->[1]);\n\n\t\t$cell[$y1][$x1] or next;\n\n\t\tif ($x == $x1) { $hor[ max($y1, $y) ][$x] = '+  ' }\n\t\tif ($y == $y1) { $ver[$y][ max($x1, $x) ] = '   ' }\n\t\twalk($x1, $y1);\n\t}\n}\n\nwalk(int rand $w, int rand $h);\t# generate\n\nfor (0 .. $h) {\t\t\t# display\n\tprint @{$hor[$_]}, \"+\\n\";\n\tprint @{$ver[$_]}, \"|\\n\" if $_ < $h;\n}\n\n\n\nSample 4 x 1 output:\n+--+--+--+--+\n|           |\n+--+--+--+--+\n", "explain": "Run as maze.pl [width] [height] or use default dimensions.\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Prolog", "code": "\n\n:- dynamic cell/2.\n\nmaze(Lig,Col) :-\n\tretractall(cell(_,_)),\n\n\tnew(D, window('Maze')),\n\n\t% creation of the grid\n\tforall(between(0,Lig, I),\n\t       (XL is  50, YL is I * 30 + 50,\n\t\tXR is Col * 30 + 50,\n\t\tnew(L, line(XL, YL, XR, YL)),\n\t\tsend(D, display, L))),\n\n\tforall(between(0,Col, I),\n\t       (XT is  50 + I * 30, YT is 50,\n\t\tYB is Lig * 30 + 50,\n\t\tnew(L, line(XT, YT, XT, YB)),\n\t\tsend(D, display, L))),\n\n\tSX is Col * 30 + 100,\n\tSY is Lig * 30 + 100,\n\tsend(D, size, new(_, size(SX, SY))),\n\n\t% choosing a first cell\n\tL0 is random(Lig),\n\tC0 is random(Col),\n\tassert(cell(L0, C0)),\n\t\\+search(D, Lig, Col, L0, C0),\n\tsend(D, open).\n\nsearch(D, Lig, Col, L, C) :-\n\tDir is random(4),\n\tnextcell(Dir, Lig, Col, L, C, L1, C1),\n\tassert(cell(L1,C1)),\n\tassert(cur(L1,C1)),\n\terase_line(D, L, C, L1, C1),\n\tsearch(D, Lig, Col, L1, C1).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nerase_line(D, L, C, L, C1) :-\n\t(   C < C1 -> C2 = C1; C2 = C),\n\tXT is C2  * 30 + 50,\n\tYT is L * 30 + 51, YR is (L+1) * 30 + 50,\n\tnew(Line, line(XT, YT, XT, YR)),\n\tsend(Line, colour, white),\n\tsend(D, display, Line).\n\nerase_line(D, L, C, L1, C) :-\n\tXT is  51 + C * 30, XR is 50 + (C + 1) * 30,\n\t(   L < L1 -> L2 is L1; L2 is L),\n\tYT is L2 * 30 + 50,\n\tnew(Line, line(XT, YT, XR, YT)),\n\tsend(Line, colour, white),\n\tsend(D, display, Line).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nnextcell(Dir, Lig, Col, L, C, L1, C1) :-\n\tnext(Dir, Lig, Col, L, C, L1, C1);\n\t(   Dir1 is (Dir+3) mod 4,\n\t    next(Dir1, Lig, Col, L, C, L1, C1));\n\t(   Dir2 is (Dir+1) mod 4,\n\t    next(Dir2, Lig, Col, L, C, L1, C1));\n\t(   Dir3 is (Dir+2) mod 4,\n\t    next(Dir3, Lig, Col, L, C, L1, C1)).\n\n% 0 => northward\nnext(0, _Lig, _Col, L, C, L1, C) :-\n\tL > 0,\n\tL1 is L - 1,\n\t\\+cell(L1, C).\n\n% 1 => rightward\nnext(1, _Lig, Col, L, C, L, C1) :-\n\tC < Col - 1,\n\tC1 is C + 1,\n\t\\+cell(L, C1).\n\n% 2 => southward\nnext(2, Lig, _Col, L, C, L1, C) :-\n\tL < Lig - 1,\n\tL1 is L + 1,\n\t\\+cell(L1, C).\n\n% 3 => leftward\nnext(2, _Lig, _Col, L, C, L, C1) :-\n\tC > 0,\n\tC1 is C - 1,\n\t\\+cell(L, C1).\n\n\nOutput:\n\n", "explain": "Works with SWI-Prolog and XPCE.\n\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Lua", "code": "\nWorks with: Lua version 5.1\nmath.randomseed( os.time() )\n\n-- Fisher-Yates shuffle from http://santos.nfshost.com/shuffling.html\nfunction shuffle(t)\n  for i = 1, #t - 1 do\n    local r = math.random(i, #t)\n    t[i], t[r] = t[r], t[i]\n  end\nend\n\n-- builds a width-by-height grid of trues\nfunction initialize_grid(w, h)\n  local a = {}\n  for i = 1, h do\n    table.insert(a, {})\n    for j = 1, w do\n      table.insert(a[i], true)\n    end\n  end\n  return a\nend\n\n-- average of a and b\nfunction avg(a, b)\n  return (a + b) / 2\nend\n\n\ndirs = {\n  {x = 0, y = -2}, -- north\n  {x = 2, y = 0}, -- east\n  {x = -2, y = 0}, -- west\n  {x = 0, y = 2}, -- south\n}\n\nfunction make_maze(w, h)\n  w = w or 16\n  h = h or 8\n\n  local map = initialize_grid(w*2+1, h*2+1)\n\n  function walk(x, y)\n    map[y][x] = false\n\n    local d = { 1, 2, 3, 4 }\n    shuffle(d)\n    for i, dirnum in ipairs(d) do\n      local xx = x + dirs[dirnum].x\n      local yy = y + dirs[dirnum].y\n      if map[yy] and map[yy][xx] then\n        map[avg(y, yy)][avg(x, xx)] = false\n        walk(xx, yy)\n      end\n    end\n  end\n\n  walk(math.random(1, w)*2, math.random(1, h)*2)\n\n  local s = {}\n  for i = 1, h*2+1 do\n    for j = 1, w*2+1 do\n      if map[i][j] then\n        table.insert(s, '#')\n      else\n        table.insert(s, ' ')\n      end\n    end\n    table.insert(s, '\\n')\n  end\n  return table.concat(s)\nend\n\nprint(make_maze())\n\n\nOutput:\n#################################\n# #     # #         #         # #\n# # ### # # ### ##### # ##### # #\n# # # # #     #       # #   #   #\n# # # # ########### ### # # #####\n#   # #     #     # # #   #     #\n# ### ##### # ### # # ####### # #\n# #     # # # # # #       # # # #\n# # ### # # # # # ######### ### #\n# #   #   # #   #   #       #   #\n# ### ### # ### ### # ####### # #\n# #   # # #     # #   #   #   # #\n# # ### # ####### ##### # # ### #\n# #   # #       #   #   # # # # #\n# ### # ####### # # # ### # # # #\n#     #           #   #     #   #\n#################################\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Scala", "code": "\nimport scala.util.Random\n\nobject MazeTypes {\n  case class Direction(val dx: Int, val dy: Int)\n\n  case class Loc(val x: Int, val y: Int) {\n    def +(that: Direction): Loc = Loc(x + that.dx, y + that.dy)\n  }\n  \n  case class Door(val from: Loc, to: Loc)\n\n  val North = Direction(0,-1)\n  val South = Direction(0,1)\n  val West = Direction(-1,0)\n  val East = Direction(1,0)\n  val directions = Set(North, South, West, East)\n}\n\nobject MazeBuilder {\n  import MazeTypes._\n\n  def shuffle[T](set: Set[T]): List[T] = Random.shuffle(set.toList)\n  \n  def buildImpl(current: Loc, grid: Grid): Grid = {\n    var newgrid = grid.markVisited(current)\n    val nbors = shuffle(grid.neighbors(current))\n    nbors.foreach { n =>\n      if (!newgrid.isVisited(n)) {\n        newgrid = buildImpl(n, newgrid.markVisited(current).addDoor(Door(current, n)))\n      }\n    }\n    newgrid\n  }\n    \n  def build(width: Int, height: Int): Grid = {\n    val exit = Loc(width-1, height-1)\n    buildImpl(exit, new Grid(width, height, Set(), Set()))\n  }  \n}\n\nclass Grid(val width: Int, val height: Int, val doors: Set[Door], val visited: Set[Loc]) {\n\n  def addDoor(door: Door): Grid = \n    new Grid(width, height, doors + door, visited)\n  \n  def markVisited(loc: Loc): Grid = \n    new Grid(width, height, doors, visited + loc)\n  \n  def isVisited(loc: Loc): Boolean = \n    visited.contains(loc)\n    \n  def neighbors(current: Loc): Set[Loc] = \n    directions.map(current + _).filter(inBounds(_)) -- visited\n    \n  def printGrid(): List[String] = {\n    (0 to height).toList.flatMap(y => printRow(y))\n  }\n  \n  private def inBounds(loc: Loc): Boolean = \n    loc.x >= 0 && loc.x < width && loc.y >= 0 && loc.y < height\n\n  private def printRow(y: Int): List[String] = {\n    val row = (0 until width).toList.map(x => printCell(Loc(x, y)))\n    val rightSide = if (y == height-1) \" \" else \"|\"\n    val newRow = row :+ List(\"+\", rightSide)\n    List.transpose(newRow).map(_.mkString)\n  }\n  \n  private val entrance = Loc(0,0)\n\n  private def printCell(loc: Loc): List[String] = {\n    if (loc.y == height) \n      List(\"+--\")\n    else List(\n      if (openNorth(loc)) \"+  \" else \"+--\", \n      if (openWest(loc) || loc == entrance) \"   \" else \"|  \"\n    )\n  }\n  \n  def openNorth(loc: Loc): Boolean = openInDirection(loc, North)\n  \n  def openWest(loc: Loc): Boolean = openInDirection(loc, West)\n    \n  private def openInDirection(loc: Loc, dir: Direction): Boolean = \n    doors.contains(Door(loc, loc + dir)) || doors.contains(Door(loc + dir, loc))\n}\n\n\nOutput:\n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n                     |     |                 |\n+--+--+  +  +--+--+  +  +  +--+--+--+  +--+  +\n|     |  |     |  |  |  |           |  |     |\n+  +  +--+--+  +  +  +  +--+--+--+  +--+  +  +\n|  |           |        |        |     |  |  |\n+  +--+--+--+--+  +--+--+--+  +  +--+  +  +  +\n|  |     |        |        |  |     |  |  |  |\n+  +  +  +--+--+--+  +--+  +  +--+  +  +  +  +\n|     |  |           |  |  |  |  |  |     |  |\n+  +--+  +  +--+--+--+  +  +  +  +  +--+--+  +\n|  |  |  |     |        |  |     |        |  |\n+  +  +  +--+  +--+--+  +  +--+--+--+  +--+  +\n|  |  |     |           |           |        |\n+  +  +  +--+--+--+--+  +--+--+--+  +--+--+  +\n|     |              |  |     |  |        |  |\n+--+  +--+--+  +--+--+  +  +  +  +--+--+  +--+\n|  |        |        |  |  |     |     |     |\n+  +--+--+  +--+--+  +  +  +--+  +  +  +--+  +\n|        |        |  |     |     |  |     |  |\n+  +--+  +--+--+  +  +--+--+  +--+  +--+  +  +\n|     |     |     |        |        |  |  |  |\n+--+  +--+  +  +--+  +--+  +--+--+--+  +  +  +\n|  |     |     |     |  |  |           |  |  |\n+  +--+  +--+--+  +--+  +  +  +--+  +--+  +  +\n|  |        |     |           |     |     |  |\n+  +  +--+--+  +  +--+--+--+--+--+--+  +--+  +\n|  |  |        |  |                    |  |  |\n+  +  +  +--+--+--+  +--+--+--+--+--+--+  +  +\n|     |                                   |   \n+--+--+--+--+--+--+--+--+--+--+--+--+--+--+--+\n\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "D", "code": "\nvoid main() @safe {\n    import std.stdio, std.algorithm, std.range, std.random;\n\n    enum uint w = 14, h = 10;\n    auto vis = new bool[][](h, w),\n         hor = iota(h + 1).map!(_ => [\"+---\"].replicate(w)).array,\n         ver = h.iota.map!(_ => [\"|   \"].replicate(w) ~ \"|\").array;\n\n    void walk(in uint x, in uint y) /*nothrow*/ @safe /*@nogc*/ {\n        vis[y][x] = true;\n        //foreach (immutable p; [[x-1,y], [x,y+1], [x+1,y], [x,y-1]].randomCover) {\n        foreach (const p; [[x-1, y], [x, y+1], [x+1, y], [x, y-1]].randomCover) {\n            if (p[0] >= w || p[1] >= h || vis[p[1]][p[0]]) continue;\n            if (p[0] == x) hor[max(y, p[1])][x] = \"+   \";\n            if (p[1] == y) ver[y][max(x, p[0])] = \"    \";\n            walk(p[0], p[1]);\n        }\n    }\n    walk(uniform(0, w), uniform(0, h));\n    foreach (const a, const b; hor.zip(ver ~ []))\n        join(a ~ \"+\\n\" ~ b).writeln;\n}\n\n\nOutput:\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|   |               |           |                       |\n+   +   +---+---+   +   +---+   +   +---+---+---+   +   +\n|               |           |   |       |       |   |   |\n+---+---+---+---+---+---+---+   +---+   +---+   +   +---+\n|                   |       |       |           |       |\n+   +---+---+---+   +   +   +---+   +---+---+   +---+---+\n|       |       |   |   |               |   |       |   |\n+---+   +   +   +   +   +---+---+---+   +   +---+   +   +\n|       |   |   |       |       |           |       |   |\n+   +---+   +   +---+---+   +   +---+---+---+   +---+   +\n|           |   |           |               |           |\n+   +---+---+   +   +---+---+---+---+---+   +---+---+   +\n|       |   |       |   |               |           |   |\n+---+   +   +---+---+   +   +---+   +   +   +---+---+   +\n|   |               |       |       |   |   |           |\n+   +---+---+---+   +   +---+   +---+   +   +   +---+---+\n|   |               |   |       |   |   |       |       |\n+   +   +---+---+---+---+   +---+   +   +---+---+   +   +\n|                           |                       |   |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "Haskell", "code": "\n{-# LANGUAGE FlexibleContexts #-}\n{-# LANGUAGE TypeFamilies #-}\n\nimport Data.Array.ST\n       (STArray, freeze, newArray, readArray, writeArray)\nimport Data.STRef (STRef, newSTRef, readSTRef, writeSTRef)\nimport System.Random (Random(..), getStdGen, StdGen)\nimport Control.Monad (forM_, unless)\nimport Control.Monad.ST (ST, stToIO)\nimport Data.Array (Array, (!), bounds)\nimport Data.Bool (bool)\n\nrand\n  :: Random a\n  => (a, a) -> STRef s StdGen -> ST s a\nrand range gen = do\n  (a, g) <- randomR range <$> readSTRef gen\n  gen `writeSTRef` g\n  return a\n\ndata Maze = Maze\n  { rightWalls, belowWalls :: Array (Int, Int) Bool\n  }\n\nmaze :: Int -> Int -> StdGen -> ST s Maze\nmaze width height gen = do\n  visited <- mazeArray False\n  rWalls <- mazeArray True\n  bWalls <- mazeArray True\n  gen <- newSTRef gen\n  (,) <$> rand (0, maxX) gen <*> rand (0, maxY) gen >>=\n    visit gen visited rWalls bWalls\n  Maze <$> freeze rWalls <*> freeze bWalls\n  where\n    visit gen visited rWalls bWalls here = do\n      writeArray visited here True\n      let ns = neighbors here\n      i <- rand (0, length ns - 1) gen\n      forM_ (ns !! i : take i ns ++ drop (i + 1) ns) $\n        \\there -> do\n          seen <- readArray visited there\n          unless seen $\n            do removeWall here there\n               visit gen visited rWalls bWalls there\n      where\n        removeWall (x1, y1) (x2, y2) =\n          writeArray (bool rWalls bWalls (x1 == x2)) (min x1 x2, min y1 y2) False\n    neighbors (x, y) =\n      bool [(x - 1, y)] [] (0 == x) ++\n      bool [(x + 1, y)] [] (maxX == x) ++\n      bool [(x, y - 1)] [] (0 == y) ++ bool [(x, y + 1)] [] (maxY == y)\n    maxX = width - 1\n    maxY = height - 1\n    mazeArray =\n      newArray ((0, 0), (maxX, maxY)) :: Bool -> ST s (STArray s (Int, Int) Bool)\n\nprintMaze :: Maze -> IO ()\nprintMaze (Maze rWalls bWalls) = do\n  putStrLn $ '+' : concat (replicate (maxX + 1) \"---+\")\n  forM_ [0 .. maxY] $\n    \\y -> do\n      putStr \"|\"\n      forM_ [0 .. maxX] $\n        \\x -> do\n          putStr \"   \"\n          putStr $ bool \" \" \"|\" (rWalls ! (x, y))\n      putStrLn \"\"\n      forM_ [0 .. maxX] $\n        \\x -> do\n          putStr \"+\"\n          putStr $ bool \"   \" \"---\" (bWalls ! (x, y))\n      putStrLn \"+\"\n  where\n    maxX = fst (snd $ bounds rWalls)\n    maxY = snd (snd $ bounds rWalls)\n\nmain :: IO ()\nmain = getStdGen >>= stToIO . maze 11 8 >>= printMaze\n\n\nSample output:\n +---+---+---+---+---+---+---+---+---+---+---+\n |               |                           |\n +   +---+---+---+   +---+---+---+---+---+   +\n |               |           |   |       |   |\n +   +---+---+   +---+---+   +   +   +   +   +\n |   |   |       |           |       |   |   |\n +   +   +   +---+---+---+---+   +---+   +   +\n |       |   |                   |   |       |\n +---+---+   +   +---+---+---+---+   +---+---+\n |       |   |   |                       |   |\n +   +   +   +   +---+---+---+   +---+   +   +\n |   |       |   |               |       |   |\n +   +---+---+   +   +---+---+---+   +---+   +\n |               |       |           |       |\n +   +---+---+---+---+   +   +---+---+   +   +\n |                       |               |   |\n +---+---+---+---+---+---+---+---+---+---+---+\n\n", "explain": ""}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "TypeScript", "code": "\nrandomized depth first search function to create maze[edit]\ninterface mazeData{\n\tnodes:Node[]\n\tx:number\n\ty:number\n\tblockSize:number\n}\n\nclass Node{\n\tx:number\n\ty:number\n\twallsTo:Node[]\n\tvisited = false\n\tconstructor(x:number,y:number){\n\t\tthis.x = x\n\t\tthis.y = y\n\t}\n\tgetTouchingNodes(nodes:Node[],blockSize:number){\n    return nodes.filter(n=>\n      (this != n) && \n      (Math.hypot(this.x-n.x,this.y-n.y) == blockSize )\n    )\n  }\n\tdraw(ctx:CanvasRenderingContext2D,blockSize:number){\n    ctx.fillStyle ='black'\n    this.wallsTo.forEach(el=>{\n      ctx.save()\n      ctx.translate(this.x,this.y)\n      ctx.rotate(Math.atan2(this.y-el.y,this.x-el.x)+ Math.PI)\n      ctx.beginPath()\n      ctx.moveTo(blockSize/2,blockSize/2)\n      ctx.lineTo(blockSize/2,-blockSize/2)\n      ctx.stroke()\n      ctx.restore()\n    })\n  }\n}\n\nexport function maze(x:number,y:number):mazeData {\n\tlet blockSize = 20\n\tx *= blockSize\n\ty *= blockSize\n\tlet nodes = Array((x/blockSize)*(y/blockSize)).fill(0).map((_el,i)=>\n\t\tnew Node(\n\t\t\t(i%(x/blockSize)*(blockSize))+(blockSize/2),\n\t\t\t(Math.floor(i/(x/blockSize))*(blockSize))+(blockSize/2)\n\t\t)\n\t)  \n\tnodes.forEach(n=>n.wallsTo = n.getTouchingNodes(nodes,blockSize))\n\tlet que = [nodes[0]]\n\twhile(que.length > 0){\n\t\tlet current = que.shift()\n\t\tlet unvisited = current\n\t\t.getTouchingNodes(nodes,blockSize)\n\t\t.filter(el=>!el.visited)\n\t\tif(unvisited.length >0){\n\t\t\tque.push(current)\n\t\t\tlet chosen = unvisited[Math.floor(Math.random()*unvisited.length)];\n\t\t\tcurrent.wallsTo = current.wallsTo.filter((el)=>el != chosen)\n\t\t\tchosen.wallsTo = chosen.wallsTo.filter((el)=>el != current)\n\t\t\tchosen.visited = true\n\t\t\tque.unshift(chosen)\n\t\t} \n\t}\n\treturn {x:x,y:y,nodes:nodes,blockSize:blockSize}\n}\n\nexport function display(c:HTMLCanvasElement,mazeData:mazeData){\n\tlet ctx = c.getContext('2d')\n\tc.width = mazeData.x\n\tc.height = mazeData.y\n\tctx.fillStyle = 'white'\n\tctx.strokeStyle = 'black'\n\tctx.fillRect(0,0,mazeData.x,mazeData.y)\n\tctx.strokeRect(0,0,mazeData.x,mazeData.y)\n\tmazeData.nodes.forEach(el=>el.draw(ctx,mazeData.blockSize))\n}\n\nmaze creation using html canvas[edit]\nimport { maze,display } from \"./maze\"\nconst X = 10\nconst Y = 10\n\nlet canvas = document.createElement('canvas')\ndocument.body.appendChild(canvas)\nlet m = maze(X,Y)\ndisplay(canvas,m)\n\n\nOutput:\nrendered 10x20 maze[edit]\n\n", "explain": "\n\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "F#", "code": "\n\nlet rnd : int -> int =\n  let gen = new System.Random()\n  fun max -> gen.Next(max)\n\n// randomly choose an element of a list\nlet choose (xs:_ list) = xs.[rnd xs.Length]\n\ntype Maze(width, height) =\n  // (x,y) -> have we been here before?\n  let visited = Array2D.create width height false\n  // (x,y) -> is there a wall between (x,y) and (x+1,y)?\n  let horizWalls = Array2D.create width height true\n  // (x,y) -> is there a wall between (x,y) and (x,y+1)?\n  let vertWalls = Array2D.create width height  true\n  \n  let isLegalPoint (x,y) =\n    x >= 0 && x < width && y >= 0 && y < height\n  \n  let neighbours (x,y) = \n    [(x-1,y);(x+1,y);(x,y-1);(x,y+1)] |> List.filter isLegalPoint\n    \n  let removeWallBetween (x1,y1) (x2,y2) =\n    if x1 <> x2 then\n      horizWalls.[min x1 x2, y1] <- false\n    else\n      vertWalls.[x1, min y1 y2] <- false\n \n  let rec visit (x,y as p) = \n    let rec loop ns =\n      let (nx,ny) as n = choose ns\n      if not visited.[nx,ny] then\n        removeWallBetween p n\n        visit n\n      match List.filter ((<>) n) ns with\n      | [] -> ()\n      | others -> loop others\n\n    visited.[x,y] <- true\n    loop (neighbours p)\n\n  do visit (rnd width, rnd height)\n\n  member x.Print() =\n    (\"+\" + (String.replicate width \"-+\")) ::\n    [for y in 0..(height-1) do\n       yield \"\\n|\"\n       for x in 0..(width-1) do \n         yield if horizWalls.[x,y] then \" |\" else \"  \"\n       yield \"\\n+\"\n       for x in 0..(width-1) do \n         yield if vertWalls.[x,y] then \"-+\" else \" +\"\n    ]\n    |> String.concat \"\"\n    |> printfn \"%s\"\n\nlet m = new Maze(10,10)\nm.Print()\n\n\nOutput example:\n+-+-+-+-+-+-+-+-+-+-+\n|         |     |   |\n+ +-+-+-+-+ +-+ + + +\n|       |   |   | | |\n+ +-+-+ + +-+-+ +-+ +\n|     | |     |     |\n+-+ +-+ +-+-+ +-+-+ +\n|   |   |     |     |\n+ +-+ +-+ +-+-+-+ +-+\n| | |   |       |   |\n+ + +-+ +-+ +-+ +-+ +\n| |   | | |   |   | |\n+ + +-+ + +-+-+-+ + +\n|   |   |         | |\n+-+ + +-+-+-+-+-+-+ +\n|   |     |       | |\n+ +-+-+ +-+ +-+-+ + +\n| |   |   |     |   |\n+ +-+ +-+ +-+-+ +-+-+\n|       |           |\n+-+-+-+-+-+-+-+-+-+-+\n", "explain": "Using mutable state in the form of 2D arrays:\n"}, {"task_name": "Maze generation", "task_url": "https://rosettacode.org/wiki/Maze_generation", "task_cat": "Games", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\n\n# Remember: AWK is 1-based, for better or worse.\n\nBEGIN {\n    # The maze dimensions.\n    width = 20;  # Global\n    height = 20; # Global\n    resetMaze();\n\n    # Some constants.\n    top = 1;\n    bottom = 2;\n    left = 3;\n    right = 4;\n\n    # Randomize the PRNG.\n    randomize();\n\n    # Visit all the cells starting at a random point.\n    visitCell(getRandX(), getRandY());\n    \n    # Show the result.\n    printMaze();\n}\n\n# Wander through the maze removing walls as we go.\nfunction visitCell(x, y,    dirList, dir, nx, ny, ndir, pi) {\n    setVisited(x, y);   # This cell has been visited.\n\n    # Visit neighbors in a random order.\n    dirList = getRandDirList();\n    for (dir = 1; dir <= 4; dir++) {\n        # Get coordinates of a random neighbor (next in random direction list).\n        ndir = substr(dirList, dir, 1);\n        nx = getNextX(x, ndir);\n        ny = getNextY(y, ndir);\n        \n        # Visit an unvisited neighbor, removing the separating walls.\n        if (wasVisited(nx, ny) == 0) {\n            rmWall(x, y, ndir);\n            rmWall(nx, ny, getOppositeDir(ndir));\n            visitCell(nx, ny)\n        } \n    }\n}\n\n# Display the text-mode maze.\nfunction printMaze(    x, y, r, w) {\n    for (y = 1; y <= height; y++) {\n        for (pass = 1; pass <= 2; pass++) { # Go over each row twice: top, middle\n            for (x = 1; x <= width; x++) {\n                if (pass == 1) { # top\n                    printf(\"+\");\n                    printf(hasWall(x, y, top) == 1 ? \"---\" : \"   \");\n                    if (x == width) printf(\"+\");\n                }\n                else if (pass == 2) { # left, right\n                    printf(hasWall(x, y, left) == 1 ? \"|\" : \" \");\n                    printf(\"   \");\n                    if (x == width) printf(hasWall(x, y, right) == 1 ? \"|\" : \" \");\n                }\n            }\n            print;\n        }\n    }\n    for (x = 1; x <= width; x++) printf(\"+---\"); # bottom row\n    print(\"+\"); # bottom right corner\n}\n\n# Given a direction, get its opposite.\nfunction getOppositeDir(d) {\n    if (d == top) return bottom;\n    if (d == bottom) return top;\n    if (d == left) return right;\n    if (d == right) return left;\n}\n\n# Build a list (string) of the four directions in random order.\nfunction getRandDirList(    dirList, randDir, nx, ny, idx) {\n    dirList = \"\";\n    while (length(dirList) < 4) {\n        randDir = getRandDir();\n        if (!index(dirList, randDir)) {\n            dirList = dirList randDir;\n        }\n    }\n    return dirList;\n}\n\n# Get x coordinate of the neighbor in a given a direction.\nfunction getNextX(x, dir) {\n    if (dir == left) x = x - 1;\n    if (dir == right) x = x + 1;\n    if (!isGoodXY(x, 1)) return -1; # Off the edge.\n    return x;\n}\n\n# Get y coordinate of the neighbor in a given a direction.\nfunction getNextY(y, dir) {\n    if (dir == top) y = y - 1;\n    if (dir == bottom) y = y + 1;\n    if (!isGoodXY(1, y)) return -1; # Off the edge.\n    return y;\n}\n\n# Mark a cell as visited.\nfunction setVisited(x, y,    cell) {\n    cell = getCell(x, y);\n    if (cell == -1) return;\n    cell = substr(cell, 1, 4) \"1\"; # walls plus visited\n    setCell(x, y, cell);\n}\n\n# Get the visited state of a cell.\nfunction wasVisited(x, y,    cell) {\n    cell = getCell(x, y);\n    if (cell == -1) return 1; # Off edges already visited.\n    return substr(getCell(x,y), 5, 1);\n}\n\n# Remove a cell's wall in a given direction.\nfunction rmWall(x, y, d,    i, oldCell, newCell) {\n    oldCell = getCell(x, y);\n    if (oldCell == -1) return;\n    newCell = \"\";\n    for (i = 1; i <= 4; i++) { # Ugly as concat of two substrings and a constant?.\n        newCell = newCell (i == d ? \"0\" : substr(oldCell, i, 1));\n    }\n    newCell = newCell wasVisited(x, y);\n    setCell(x, y, newCell);\n}\n\n# Determine if a cell has a wall in a given direction.\nfunction hasWall(x, y, d,    cell) {\n    cell = getCell(x, y);\n    if (cell == -1) return 1; # Cells off edge always have all walls.\n    return substr(getCell(x, y), d, 1);\n}\n\n# Plunk a cell into the maze.\nfunction setCell(x, y, cell,    idx) {\n    if (!isGoodXY(x, y)) return;\n    maze[x, y] = cell\n}\n\n# Get a cell from the maze.\nfunction getCell(x, y,    idx) {\n    if (!isGoodXY(x, y)) return -1; # Bad cell marker.\n    return maze[x, y];\n}\n\n# Are the given coordinates in the maze?\nfunction isGoodXY(x, y) {\n    if (x < 1 || x > width) return 0;\n    if (y < 1 || y > height) return 0;\n    return 1;\n}\n\n# Build the empty maze.\nfunction resetMaze(    x, y) {\n    delete maze;\n    for (y = 1; y <= height; y++) {\n        for (x = 1; x <= width; x++) {\n            maze[x, y] = \"11110\"; # walls (up, down, left, right) and visited state.\n        }\n    }\n}\n\n# Random things properly scaled.\n\nfunction getRandX() {\n    return 1 + int(rand() * width);\n}\n\nfunction getRandY() {\n    return 1 +int(rand() * height);\n}\n\nfunction getRandDir() {\n    return 1 + int(rand() * 4);\n}\n\nfunction randomize() {\n    \"echo $RANDOM\" | getline t;\n    srand(t);\n}\n\n\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n|                       |                   |                       |           |\n+---+   +---+   +---+---+   +---+   +---+---+   +---+   +---+---+   +   +---+   +\n|       |   |   |           |   |           |       |   |   |       |       |   |\n+   +---+   +   +   +---+---+   +---+---+   +   +---+   +   +   +---+---+---+   +\n|       |       |   |                   |       |       |       |               |\n+   +   +   +---+   +---+   +   +---+   +---+---+   +---+---+   +---+   +---+   +\n|   |   |   |   |       |   |   |       |       |   |       |           |       |\n+---+   +   +   +---+   +---+   +   +---+---+   +   +   +   +---+---+---+   +---+\n|       |       |       |       |               |       |   |       |       |   |\n+   +   +---+---+   +---+   +---+---+---+---+   +---+---+   +---+   +   +---+   +\n|   |   |       |   |           |           |   |       |       |   |   |       |\n+   +---+   +   +   +---+---+   +---+   +   +   +   +   +---+   +   +   +   +   +\n|   |       |       |       |       |   |   |   |   |       |   |   |       |   |\n+   +   +---+---+---+   +   +---+   +   +   +   +---+---+   +   +   +---+---+   +\n|   |   |               |           |   |   |               |   |               |\n+   +   +---+---+---+   +---+---+---+   +   +---+---+---+   +   +---+---+   +---+\n|       |               |   |           |           |       |   |       |       |\n+   +---+   +---+---+---+   +   +---+---+---+---+   +   +---+   +   +   +---+   +\n|   |       |           |   |   |       |       |   |   |   |       |   |       |\n+   +   +   +   +---+   +   +   +   +   +   +   +   +   +   +---+---+   +   +---+\n|       |   |       |   |           |   |   |   |   |   |           |   |       |\n+   +---+---+---+   +   +---+---+---+   +   +   +   +   +   +---+   +   +---+   +\n|   |               |           |   |       |   |           |   |   |       |   |\n+---+   +---+---+---+---+---+   +   +---+   +---+---+---+---+   +   +---+   +   +\n|   |   |       |           |   |       |   |           |       |       |   |   |\n+   +   +   +---+   +---+   +   +---+   +   +   +---+   +---+   +---+   +   +   +\n|   |   |           |       |       |       |   |           |           |   |   |\n+   +   +   +---+---+   +---+---+   +   +---+   +---+---+   +---+---+   +   +---+\n|   |   |   |   |       |           |       |       |   |           |   |       |\n+   +   +   +   +   +---+   +---+---+---+---+---+   +   +---+---+   +   +---+   +\n|       |   |   |           |                       |               |       |   |\n+---+---+   +   +---+---+---+---+   +   +---+---+---+   +---+---+---+---+   +   +\n|       |       |               |   |       |       |           |           |   |\n+   +   +---+   +---+---+   +   +   +---+   +   +   +---+---+   +---+---+---+   +\n|   |       |       |       |   |       |   |   |   |       |           |       |\n+   +   +---+---+   +   +---+   +   +---+   +---+   +   +   +---+---+   +   +---+\n|   |           |   |   |       |   |       |       |   |           |   |       |\n+   +---+   +---+   +   +   +---+---+   +---+   +---+   +---+---+   +   +---+   +\n|       |               |               |                       |               |\n+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+---+\n\n", "explain": "Example output:\n"}]