[{"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nclass Ref(object):\n    def __init__(self, value=None):\n        self.value = value\n\ndef harmonic_sum(i, lo, hi, term):\n    # term is passed by-name, and so is i\n    temp = 0\n    i.value = lo\n    while i.value <= hi:  # Python \"for\" loop creates a distinct which\n        temp += term() # would not be shared with the passed \"i\"\n        i.value += 1   # Here the actual passed \"i\" is incremented.\n    return temp\n\ni = Ref()\n\n# note the correspondence between the mathematical notation and the\n# call to sum it's almost as good as sum(1/i for i in range(1,101))\nprint harmonic_sum(i, 1, 100, lambda: 1.0/i.value)\n\n\ndef harmonic_sum(i, lo, hi, term):\n    return sum(term() for i[0] in range(lo, hi + 1))\n \ni = [0]\nprint(harmonic_sum(i, 1, 100, lambda: 1.0 / i[0]))\n\n\ndef harmonic_sum(i, lo, hi, term):\n    return sum(eval(term) for i[0] in range(lo, hi + 1))\n \ni = [0]\nprint(harmonic_sum(i, 1, 100, \"1.0 / i[0]\"))\n\n\n", "explain": "or\nor\nOutput: 5.18737751764\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n\nint i;\ndouble sum(int *i, int lo, int hi, double (*term)()) {\n    double temp = 0;\n    for (*i = lo; *i <= hi; (*i)++)\n        temp += term();\n    return temp;\n}\n\ndouble term_func() { return 1.0 / i; }\n\nint main () {\n    printf(\"%f\\n\", sum(&i, 1, 100, term_func));\n    return 0;\n}\n\n\nWorks with: gcc\n\n#include <stdio.h>\n \nint i;\n\n#define sum(i, lo_byname, hi_byname, term)      \\\n  ({                                            \\\n  int lo = lo_byname;                           \\\n  int hi = hi_byname;                           \\\n                                                \\\n  double temp = 0;                              \\\n  for (i = lo; i <= hi; ++i)                    \\\n    temp += term;                               \\\n  temp;                                         \\\n  })\n\nint main () {\n    printf(\"%f\\n\", sum(i, 1, 100, 1.0 / i));\n    return 0;\n}\n\n\n", "explain": "Output: 5.18738\nAlternatively, C's macros provide a closer imitation of ALGOL's call-by-name semantics:\nOutput: 5.187378\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include <iostream>\n\n#define SUM(i,lo,hi,term)\\\n[&](const int _lo,const int _hi){\\\n  decltype(+(term)) sum{};\\\n  for (i = _lo; i <= _hi; ++i) sum += (term);\\\n  return sum;\\\n}((lo),(hi))\n\nint i;\ndouble sum(int &i, int lo, int hi, double (*term)()) {\n    double temp = 0;\n    for (i = lo; i <= hi; i++)\n        temp += term();\n    return temp;\n}\ndouble term_func() { return 1.0 / i; }\n\nint main () {\n    std::cout << sum(i, 1, 100, term_func) << std::endl;\n    std::cout << SUM(i,1,100,1.0/i) << \"\\n\";\n    return 0;\n}\n\n\n", "explain": "Output: 5.18738\n5.18738\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\nimport java.util.function.*;\nimport java.util.stream.*;\n\npublic class Jensen {\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        return IntStream.rangeClosed(lo, hi).mapToDouble(f).sum();\n    }\n        \n    public static void main(String args[]) {\n        System.out.println(sum(1, 100, (i -> 1.0/i)));\n    }\n}\n\n\npublic class Jensen2 {\n\n    interface IntToDoubleFunction {\n        double apply(int n);\n    }\n\n    static double sum(int lo, int hi, IntToDoubleFunction f) {\n        double res = 0;\n        for (int i = lo; i <= hi; i++)\n            res += f.apply(i);\n        return res;\n\n    }\n    public static void main(String args[]) {\n        System.out.println(\n            sum(1, 100,\n                new IntToDoubleFunction() {\n                    public double apply(int i) { return 1.0/i;}\n                }));\n    }\n}\n\n", "explain": "This is Java 8.\nThe program prints '5.187377517639621'.\nJava 7 is more verbose, but under the hood does essentially the same thing:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nusing System;\n\nclass JensensDevice\n{    \n    public static double Sum(ref int i, int lo, int hi, Func<double> term)\n    {\n        double temp = 0.0;\n        for (i = lo; i <= hi; i++)\n        {\n            temp += term();\n        }\n        return temp;\n    }\n\n    static void Main()\n    {\n        int i = 0;\n        Console.WriteLine(Sum(ref i, 1, 100, () => 1.0 / i));\n    }\n}\n\n", "explain": "Can be simulated via lambda expressions:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nTranslation of: C\n\nvar obj;\n\nfunction sum(o, lo, hi, term) {\n  var tmp = 0;\n  for (o.val = lo; o.val <= hi; o.val++)\n    tmp += term();\n  return tmp;\n}\n\nobj = {val: 0};\nalert(sum(obj, 1, 100, function() {return 1 / obj.val}));\n\n\n", "explain": "Uses an object o instead of integer pointer i, as the C example does.\nThe alert shows us '5.187377517639621'.\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n$i;\nfunction sum (&$i, $lo, $hi, $term) {\n    $temp = 0;\n    for ($i = $lo; $i <= $hi; $i++) {\n        $temp += $term();\n    }\n    return $temp;\n}\n\necho sum($i, 1, 100, create_function('', 'global $i; return 1 / $i;')), \"\\n\";\n//Output: 5.18737751764 (5.1873775176396)\n\nfunction sum ($lo,$hi)\n{\n $temp = 0;\n for ($i = $lo; $i <= $hi; $i++)\n {\n  $temp += (1 / $i);\n }\n return $temp;\n}\necho sum(1,100);\n\n//Output: 5.1873775176396\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nFortran does not offer call-by-name in the manner of the Algol language. It passes parameters by reference (i.e. by passing the storage address) and alternatively uses copy-in, copy-out to give the same effect, approximately, as by reference. If a parameter is an arithmetic expression, it will be evaluated and its value stored in a temporary storage area, whose address will be passed to the routine. This evaluation is done once only for each call, thus vitiating the repeated re-evaluation required by Jensen's device every time within the routine that the parameter is accessed. So, this will not work      FUNCTION SUM(I,LO,HI,TERM)\n        SUM = 0\n        DO I = LO,HI\n          SUM = SUM + TERM\n        END DO\n      END FUNCTION SUM\n      WRITE (6,*) SUM(I,1,100,1.0/I)\n      END\n\n\nFortran does offer a facility to pass a function as a parameter using the EXTERNAL declaration, as follows - SUM is a F90 library function, so a name change to SUMJ:       FUNCTION SUMJ(I,LO,HI,TERM)\t!Attempt to follow Jensen's Device...\n       INTEGER I\t!Being by reference is workable.\n       INTEGER LO,HI\t!Just as any other parameters.\n       EXTERNAL TERM\t!Thus, not a variable, but a function.\n        SUMJ = 0\n        DO I = LO,HI\t!The specified span.\n          SUMJ = SUMJ + TERM(I)\t!Number and type of parameters now apparent.\n        END DO\t\t!TERM will be evaluated afresh, each time.\n      END FUNCTION SUMJ\t!So, almost there.\n\n      FUNCTION THIS(I)\t!A function of an integer.\n       INTEGER I\n        THIS = 1.0/I\t!Convert to floating-point.\n      END\t\t!Since 1/i will mostly give zero.\n\n      PROGRAM JENSEN\t!Aspiration.\n      EXTERNAL THIS\t!Thus, not a variable, but a function.\n      INTEGER I\t\t!But this is a variable, not a function.\n\n      WRITE (6,*) SUMJ(I,1,100,THIS)\t!No statement as to the parameters of THIS.\n      END\n\n\n", "explain": "Here, type declarations have been omitted to save space because they won't help - until there appears a \"BY NAME\" or some such phrasing. Although variable I in the calling routine will have its value adjusted as the DO-loop in SUM proceeds (the parameter being passed by reference), this won't affect the evaluation of 1.0/I, which will be performed once using whatever value is in the caller's variable (it is uninitialised, indeed, undeclared also and so by default an integer) then the function is invoked with the address of the location containing that result. The function will make many references to that result, obtaining the same value each time. The fact that the caller's I will be changed each time doesn't matter.\nThe result of this is 5.187378, however it does not follow the formalism of Jensen's Device. The invocation statement SUMJ(I,1,100,THIS) does not contain the form of the function but only its name, and the function itself is defined separately. This means that the convenience of different functions via the likes of SUM(I,1,100,1.0/I**2) is unavailable, a separately-defined function with its own name must be defined for each such function. Further, the SUM routine must invoke TERM(I) itself, explicitly supplying the appropriate parameter. And the fact that variable I is a parameter to SUM is an irrelevance, and might as well be omitted from SUMJ.\nIncidentally, a subroutine such as TEST(A,B) invoked as TEST(X,X) enables the discovery of copy-in, copy-out parameter passing. Within the routine, modify the value of A and look to see if B suddenly has a new value also.\n\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nvar i int\n\nfunc sum(i *int, lo, hi int, term func() float64) float64 {\n    temp := 0.0\n    for *i = lo; *i <= hi; (*i)++ {\n        temp += term()\n    }\n    return temp\n}\n\nfunc main() {\n    fmt.Printf(\"%f\\n\", sum(&i, 1, 100, func() float64 { return 1.0 / float64(i) }))\n}\n\n\nOutput:\n5.187378\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program jensen.s   */\n/* compil as with option  -mcpu=<processor> -mfpu=vfpv4 -mfloat-abi=hard  */\n/* link with gcc          */\n\n/* Constantes    */\n.equ EXIT,   1                           @ Linux syscall\n/* Initialized data */\n.data\n\nszFormat: .asciz \"Result =\u00a0%.8f \\n\" \n.align 4\n\n/* UnInitialized data */\n.bss \n\n/*  code section */\n.text\n.global main \nmain: \n    mov r0,#1                                   @ first indice\n    mov r1,#100                                 @ last indice\n    adr r2,funcdiv                              @ address function\n    bl funcSum\n    vcvt.f64.f32  d1, s0                        @ conversion double float for print by C\n    ldr r0,iAdrszFormat                         @ display format\n    vmov r2,r3,d1                               @ parameter function printf for float double\n    bl printf                                   @ display float double\n\n100:                                            @ standard end of the program\n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc 0                                       @ perform system call\n\niAdrszFormat:             .int szFormat\n/******************************************************************/\n/*     function sum                                               */ \n/******************************************************************/\n/* r0 contains begin  */\n/* r1 contains end */\n/* r2 contains address function */\n\n/* r0 return result                      */\nfuncSum:\n    push {r0,r3,lr}                       @ save  registers \n    mov r3,r0\n    mov r0,#0                             @ init r0\n    vmov s3,r0                            @ and s3\n    vcvt.f32.s32 s3, s3                   @ convert in float single pr\u00e9cision (32bits)\n1:                                        @ begin loop\n    mov r0,r3                             @ loop indice -> parameter function\n    blx r2                                @ call function address in r2\n    vadd.f32 s3,s0                        @ addition float\n    add r3,#1                             @ increment indice\n    cmp r3,r1                             @ end\u00a0?\n    ble 1b                                @ no loop\n    vmov s0,s3                            @ return float result in s0\n\n100:\n    pop {r0,r3,lr}                        @ restaur registers\n    bx lr                                 @ return\n/******************************************************************/\n/*     compute 1/r0                                               */ \n/******************************************************************/\n/* r0 contains the value                 */\n/* r0 return result                      */\nfuncdiv:\n    push {r1,lr}                       @ save  registers \n    vpush {s1}                         @ save float registers\n    cmp r0,#0                          @ division by zero -> end\n    beq 100f\n    ldr r1,fUn                         @ load float constant 1.0\n    vmov s0,r1                         @ in float register s3\n    vmov s1,r0                         @ \n    vcvt.f32.s32 s1, s1                @conversion in float single pr\u00e9cision (32 bits)\n    vdiv.f32 s0,s0,s1                  @ division 1/r0\n                                       @ and return result in s0\n100:\n    vpop {s1}                          @ restaur float registers\n    pop {r1,lr}                        @ restaur registers\n    bx lr                              @ return\nfUn:                .float 1\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\ntype TTerm = function(i: integer): real;\n\nfunction Term(I: integer): double;\nbegin\nTerm := 1 / I;\nend;\n\n\nfunction Sum(var I: integer; Lo, Hi: integer; Term: TTerm): double;\nbegin\nResult := 0;\nI := Lo;\nwhile I <= Hi do\n\tbegin\n\tResult := Result + Term(I);\n\tInc(I);\n\tend;\nend;\n\n\nprocedure ShowJensenDevice(Memo: TMemo);\nvar I: LongInt;\nbegin\nMemo.Lines.Add(FloatToStrF(Sum(I, 1, 100, @Term), ffFixed,18,15));\nend;\n\n\nOutput:\n5.187377517639621\n\nElapsed Time: 1.037 ms.\n\n\n\n", "explain": "\n\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\ndef sum(var, lo, hi, term, context)\n  sum = 0.0\n  lo.upto(hi) do |n|\n    sum += eval \"#{var} = #{n}; #{term}\", context\n  end\n  sum\nend\np sum \"i\", 1, 100, \"1.0 / i\", binding   # => 5.18737751763962\n\n\ndef sum2(lo, hi)\n  lo.upto(hi).inject(0.0) {|sum, n| sum += yield n}\nend\np sum2(1, 100) {|i| 1.0/i}  # => 5.18737751763962\n\n\ndef sum lo, hi, &term\n  (lo..hi).sum(&term)\nend\np sum(1,100){|i| 1.0/i}   # => 5.187377517639621\n# or using Rational:\np sum(1,100){|i| Rational(1,i)}  # => 14466636279520351160221518043104131447711 / 2788815009188499086581352357412492142272\n\n", "explain": "Here, setting the variable and evaluating the term are truly executed in the \"outer\" context:\nBut here is the Ruby way to do it:\nEven more concise: (requires ruby >= 2.4)\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nuse std::f32;\n\nfn harmonic_sum<F>(lo: usize, hi: usize, term: F) -> f32\nwhere\n    F: Fn(f32) -> f32,\n{\n    (lo..hi + 1).fold(0.0, |acc, item| acc + term(item as f32))\n}\n\nfn main() {\n    println!(\"{}\", harmonic_sum(1, 100, |i| 1.0 / i));\n}\n\n\nOutput:\n5.187378\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nvar i = 42 // initial value doesn't matter\n\nfunc sum(inout i: Int, lo: Int, hi: Int, @autoclosure term: () -> Double) -> Double {\n  var result = 0.0\n  for i = lo; i <= hi; i++ {\n    result += term()\n  }\n  return result\n}\n\nprintln(sum(&i, 1, 100, 1 / Double(i)))\n\n\n\nOutput:\n5.187378\n", "explain": "(Prior to Swift 1.2, replace @autoclosure term: () -> Double with term: @autoclosure () -> Double.)\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nsum <- function(var, lo, hi, term)\n  eval(substitute({\n    .temp <- 0;\n    for (var in lo:hi) {\n      .temp <- .temp + term\n    }\n    .temp\n  }, as.list(match.call()[-1])),\n  enclos=parent.frame())\n\nsum(i, 1, 100, 1/i) #prints 5.187378\n\n##and because of enclos=parent.frame(), the term can involve variables in the caller's scope:\nx <- -1\nsum(i, 1, 100, i^x) #5.187378\n\n", "explain": "R uses a call by need evaluation strategy where function inputs\nare evaluated on demand and then cached; functions can bypass the normal argument evaluation by using functions substitute and match.call to access the parse tree of the as-yet-unevaluated arguments, and using parent.frame to access the scope of the caller. There are some proposed\nconventions to do this in a way that is less confusing to the user\nof a function; however, ignoring conventions we can come disturbingly close to the ALGOL call-by-name semantics.\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Jensen_Device is\n   function Sum\n            (  I : not null access Float;\n               Lo, Hi : Float;\n               F : access function return Float\n            )  return Float is\n      Temp : Float := 0.0;\n   begin\n      I.all := Lo;\n      while I.all <= Hi loop\n         Temp := Temp + F.all;\n         I.all := I.all + 1.0;\n      end loop;\n      return Temp;\n   end Sum;\n\n   I : aliased Float;\n   function Inv_I return Float is\n   begin\n      return 1.0 / I;\n   end Inv_I;\nbegin\n   Put_Line (Float'Image (Sum (I'Access, 1.0, 100.0, Inv_I'Access)));\nend Jensen_Device;\n\n 5.18738E+00\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nTranslation of: C\nmacro sum(i, loname, hiname, term)\n    return quote\n        lo = $loname\n        hi = $hiname\n        tmp = 0.0\n        for i in lo:hi\n            tmp += $term\n        end\n        return tmp\n    end\nend\n\ni = 0\n@sum(i, 1, 100, 1.0 / i)\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nfun sum(lo: Int, hi: Int, f: (Int) -> Double) = (lo..hi).sumByDouble(f)\n\nfun main(args: Array<String>) = println(sum(1, 100, { 1.0 / it }))\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nmy $i;\nsub sum {\n    my ($i, $lo, $hi, $term) = @_; \n    my $temp = 0;\n    for ($$i = $lo; $$i <= $hi; $$i++) {\n        $temp += $term->();\n    }\n    return $temp;\n}\n\nprint sum(\\$i, 1, 100, sub { 1 / $i }), \"\\n\";\n\n\nmy $i;\nsub sum {\n    my (undef, $lo, $hi, $term) = @_; \n    my $temp = 0;\n    for ($_[0] = $lo; $_[0] <= $hi; $_[0]++) {\n        $temp += $term->();\n    }\n    return $temp;\n}\n\nprint sum($i, 1, 100, sub { 1 / $i }), \"\\n\";\n\n\n", "explain": "Output: 5.18737751763962\nOr you can take advantage of the fact that elements of the @_ are aliases of the original:\nOutput: 5.18737751763962\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction sum(var, a, b, str)\n  local ret = 0\n  for i = a, b do\n    ret = ret + setfenv(loadstring(\"return \"..str), {[var] = i})()\n  end\n  return ret\nend\nprint(sum(\"i\", 1, 100, \"1/i\"))\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\n\nclass MyInt { var i: Int = _ }\nval i = new MyInt\ndef sum(i: MyInt, lo: Int, hi: Int, term: => Double) = {\n  var temp = 0.0\n  i.i = lo\n  while(i.i <= hi) {\n    temp = temp + term\n    i.i += 1\n  }\n  temp\n}\nsum(i, 1, 100, 1.0 / i.i)\n\n\nres2: Double = 5.187377517639621\n\n", "explain": "Actually, the i parameter needs to be passed by reference, as done in so many\nexamples here, so that changes made to it reflect on the parameter that was passed. Scala\nsupports passing parameters by name, but not by reference, which means it can't change the\nvalue of any parameter passed. The code below gets around that by creating a mutable integer\nclass, which is effectively the same as passing by reference.\nResult:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\n\ndouble sum(ref int i, in int lo, in int hi, lazy double term)\npure @safe /*nothrow @nogc*/ {\n    double result = 0.0;\n    for (i = lo; i <= hi; i++)\n        result += term();\n    return result;\n}\n\nvoid main() {\n    import std.stdio;\n\n    int i;\n    sum(i, 1, 100, 1.0/i).writeln;\n}\n\n\nOutput:\n5.18738\n", "explain": "There are better ways to do this in D, but this is closer to the original Algol version:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nimport Control.Monad.ST\nimport Data.STRef\n\nsum_ :: STRef s Double -> Double -> Double \n     -> ST s Double -> ST s Double\nsum_ ref lo hi term = \n   do\n     vs <- forM [lo .. hi] \n            (\\k -> do { writeSTRef ref k\n                      ; term } )\n     return $ sum vs\n\nfoo :: Double\nfoo =\n  runST $\n  do ref <- newSTRef undefined\n          -- initial value doesn't matter\n     sum_ ref 1 100 $\n       do\n         k <- readSTRef ref\n         return $ recip k\n\nmain :: IO ()\nmain = print foo\n\n\nOutput:\n5.187377517639621\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n(define-syntax sum\n  (syntax-rules ()\n    ((sum var low high . body)\n     (let loop ((var low)\n                (result 0))\n       (if (> var high)\n           result\n           (loop (+ var 1)\n                 (+ result . body)))))))\n\n(exact->inexact (sum i 1 100 (/ 1 i)))\n5.18737751763962\n\n", "explain": "Scheme procedures do not support call-by-name. Scheme macros, however, do:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nprintfn \"%.14f\" (List.fold(fun n g->n+1.0/g) 0.0 [1.0..100.0]);;\n\n\nOutput:\n5.18737751763962\n\n", "explain": ""}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\nTranslation of: JavaScript\n\ndef sum = { i, lo, hi, term ->\n    (lo..hi).sum { i.value = it; term() }\n}\ndef obj = [:]\nprintln (sum(obj, 1, 100, { 1 / obj.value }))\n\n\n5.1873775176\n", "explain": "Solution:\nOutput:\n"}, {"task_name": "Jensen's Device", "task_url": "https://rosettacode.org/wiki/Jensen%27s_Device", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f JENSENS_DEVICE.AWK\n# converted from FreeBASIC\nBEGIN {\n    evaluation()\n    exit(0)\n}\nfunction evaluation(  hi,i,lo,tmp) {\n    lo = 1\n    hi = 100\n    for (i=lo; i<=hi; i++) {\n      tmp += (1/i)\n    }\n    printf(\"%.15f\\n\",tmp)\n}\n\n\nOutput:\n5.187377517639621\n\n", "explain": ""}]