[{"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\n>>> [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n\n", "explain": "The built-in comparison operators already do this:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\nint list_cmp(int *a, int la, int *b, int lb)\n{\n\tint i, l = la;\n\tif (l > lb) l = lb;\n\tfor (i = 0; i < l; i++) {\n\t\tif (a[i] == b[i]) continue;\n\t\treturn (a[i] > b[i]) ? 1 : -1;\n\t}\n\tif (la == lb) return 0;\n\treturn la > lb ? 1 : -1;\n}\n\nThis funciton returns one of three states, not a boolean.  One can define boolean comparisons, such as list_less_or_eq, based on it:#define list_less_or_eq(a,b,c,d) (list_cmp(a,b,c,d)\u00a0!= 1)\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> a;\n  a.push_back(1);\n  a.push_back(2);\n  a.push_back(1);\n  a.push_back(3);\n  a.push_back(2);\n  std::vector<int> b;\n  b.push_back(1);\n  b.push_back(2);\n  b.push_back(0);\n  b.push_back(4);\n  b.push_back(4);\n  b.push_back(0);\n  b.push_back(0);\n  b.push_back(0);\n\n  std::cout << std::boolalpha << (a < b) << std::endl; // prints \"false\"\n  return 0;\n}\n\n", "explain": "The built-in comparison operators already do this:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nWorks with: Java version 1.5+\nTranslation of: Common Lisp\n\nimport java.util.Arrays;\nimport java.util.List;\n\npublic class ListOrder{\n\tpublic static boolean ordered(double[] first, double[] second){\n\t\tif(first.length == 0) return true;\n\t\tif(second.length == 0) return false;\n\t\tif(first[0] == second[0])\n\t\t\treturn ordered(Arrays.copyOfRange(first, 1, first.length),\n\t\t\t\t\tArrays.copyOfRange(second, 1, second.length));\n\t\treturn first[0] < second[0];\n\t}\n\t\n\tpublic static <T extends Comparable<? super T>> boolean ordered(List<T> first, List<T> second){\n\t\tint i = 0;\n\t\tfor(; i < first.size() && i < second.size();i++){\n\t\t\tint cmp = first.get(i).compareTo(second.get(i));\n\t\t\tif(cmp == 0) continue;\n\t\t\tif(cmp < 0) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.size();\n\t}\n\t\n\tpublic static boolean ordered2(double[] first, double[] second){\n\t\tint i = 0;\n\t\tfor(; i < first.length && i < second.length;i++){\n\t\t\tif(first[i] == second[i]) continue;\n\t\t\tif(first[i] < second[i]) return true;\n\t\t\treturn false;\n\t\t}\n\t\treturn i == first.length;\n\t}\n}\n\n", "explain": "There are a few methods here. The method named \"ordered\" which works on arrays is a translation of Common Lisp. The other two are loose translations of Tcl (some tweaks were needed to get the length checks to work out) and are probably better options.\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nnamespace RosettaCode.OrderTwoNumericalLists\n{\n    using System;\n    using System.Collections.Generic;\n\n    internal static class Program\n    {\n        private static bool IsLessThan(this IEnumerable<int> enumerable,\n            IEnumerable<int> otherEnumerable)\n        {\n            using (\n                IEnumerator<int> enumerator = enumerable.GetEnumerator(),\n                    otherEnumerator = otherEnumerable.GetEnumerator())\n            {\n                while (true)\n                {\n                    if (!otherEnumerator.MoveNext())\n                    {\n                        return false;\n                    }\n\n                    if (!enumerator.MoveNext())\n                    {\n                        return true;\n                    }\n\n                    if (enumerator.Current == otherEnumerator.Current)\n                    {\n                        continue;\n                    }\n\n                    return enumerator.Current < otherEnumerator.Current;\n                }\n            }\n        }\n\n        private static void Main()\n        {\n            Console.WriteLine(\n                new[] {1, 2, 1, 3, 2}.IsLessThan(new[] {1, 2, 0, 4, 4, 0, 0, 0}));\n        }\n    }\n}\n\n\nOutput:\nFalse\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES6[edit]\n\n(() => {\n    'use strict';\n\n    // <= is already defined for lists in JS\n\n    // compare\u00a0:: [a] -> [a] -> Bool\n    const compare = (xs, ys) => xs <= ys;\n\n\n    // TEST\n    return [\n        compare([1, 2, 1, 3, 2], [1, 2, 0, 4, 4, 0, 0, 0]),\n        compare([1, 2, 0, 4, 4, 0, 0, 0], [1, 2, 1, 3, 2])\n    ];\n\n    // --> [false, true]\n})()\n\n\nOutput:\n[false, true]\n\n", "explain": "<= is already defined for numeric lists in JavaScript\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\n// If your numbers happen to be in the range of Unicode code points (0 to 0x10ffff), this function\n// satisfies the task:\nfunc lessRune(a, b []rune) bool {\n    return string(a) < string(b) // see also bytes.Compare\n}\n\n// Otherwise, the following function satisfies the task for all integer\n// and floating point types, by changing the type definition appropriately.\ntype numericType int\n\nfunc lessNT(a, b []numericType) bool {\n    l := len(a)\n    if len(b) < l {\n        l = len(b)\n    }\n    for i := 0; i < l; i++ {\n        if a[i] != b[i] {\n            return a[i] < b[i]\n        }\n    }\n    return l < len(b)\n}\n\nvar testCases = [][][]numericType{\n    {{0}, {}},\n    {{}, {}},\n    {{}, {0}},\n\n    {{-1}, {0}},\n    {{0}, {0}},\n    {{0}, {-1}},\n\n    {{0}, {0, -1}},\n    {{0}, {0, 0}},\n    {{0}, {0, 1}},\n    {{0, -1}, {0}},\n    {{0, 0}, {0}},\n    {{0, 0}, {1}},\n}\n\nfunc main() {\n    // demonstrate the general function\n    for _, tc := range testCases {\n        fmt.Printf(\"order %6s before %6s\u00a0: %t\\n\",\n            fmt.Sprintf(\"%v\", tc[0]),\n            fmt.Sprintf(\"%v\", tc[1]),\n            lessNT(tc[0], tc[1]))\n    }\n    fmt.Println()\n\n    // demonstrate that the byte specific function gives identical results\n    // by offsetting test data to a printable range of characters.\n    for _, tc := range testCases {\n        a := toByte(tc[0])\n        b := toByte(tc[1])\n        fmt.Printf(\"order %6q before %6q\u00a0: %t\\n\",\n            string(a),\n            string(b),\n            lessByte(a, b))\n    }\n}\n\nfunc toByte(a []numericType) []byte {\n    b := make([]byte, len(a))\n    for i, n := range a {\n        b[i] = 'b' + byte(n)\n    }\n    return b\n}\n\n\nOutput:\norder    [0] before     []\u00a0: false\norder     [] before     []\u00a0: false\norder     [] before    [0]\u00a0: true\norder   [-1] before    [0]\u00a0: true\norder    [0] before    [0]\u00a0: false\norder    [0] before   [-1]\u00a0: false\norder    [0] before [0 -1]\u00a0: true\norder    [0] before  [0 0]\u00a0: true\norder    [0] before  [0 1]\u00a0: true\norder [0 -1] before    [0]\u00a0: false\norder  [0 0] before    [0]\u00a0: false\norder  [0 0] before    [1]\u00a0: true\n\norder    \"b\" before     \"\"\u00a0: false\norder     \"\" before     \"\"\u00a0: false\norder     \"\" before    \"b\"\u00a0: true\norder    \"a\" before    \"b\"\u00a0: true\norder    \"b\" before    \"b\"\u00a0: false\norder    \"b\" before    \"a\"\u00a0: false\norder    \"b\" before   \"ba\"\u00a0: true\norder    \"b\" before   \"bb\"\u00a0: true\norder    \"b\" before   \"bc\"\u00a0: true\norder   \"ba\" before    \"b\"\u00a0: false\norder   \"bb\" before    \"b\"\u00a0: false\norder   \"bb\" before    \"c\"\u00a0: true\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program orderlist.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult1:      .asciz \"List1 < List2 \\n\"           @ message result\nszMessResult2:      .asciz \"List1 => List2 \\n\"           @ message result\nszCarriageReturn:  .asciz \"\\n\"\n\niTabList1:         .int  1,2,3,4,5\n.equ NBELEMENTS1,   (. - iTabList1) /4\niTabList2:         .int  1,2,1,5,2,2\n.equ NBELEMENTS2,   (. - iTabList2) /4\niTabList3:         .int  1,2,3,4,5\n.equ NBELEMENTS3,   (. - iTabList3) /4\niTabList4:         .int  1,2,3,4,5,6\n.equ NBELEMENTS4,   (. - iTabList4) /4\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                       @ entry of program \n    ldr r0,iAdriTabList1\n    mov r1,#NBELEMENTS1\n    ldr r2,iAdriTabList2\n    mov r3,#NBELEMENTS2\n    bl listeOrder\n    cmp r0,#0                               @ false\u00a0?\n    beq 1f                                  @ yes\n    ldr r0,iAdrszMessResult1                @ list 1 < list 2\n    bl affichageMess                        @ display message\n    b 2f\n1:\n    ldr r0,iAdrszMessResult2\n    bl affichageMess                        @ display message\n\n2:\n    ldr r0,iAdriTabList1\n    mov r1,#NBELEMENTS1\n    ldr r2,iAdriTabList3\n    mov r3,#NBELEMENTS3\n    bl listeOrder\n    cmp r0,#0                               @ false\u00a0?\n    beq 3f                                  @ yes\n    ldr r0,iAdrszMessResult1                @ list 1 < list 2\n    bl affichageMess                        @ display message\n    b 4f\n3:\n    ldr r0,iAdrszMessResult2\n    bl affichageMess                        @ display message\n4:\n    ldr r0,iAdriTabList1\n    mov r1,#NBELEMENTS1\n    ldr r2,iAdriTabList4\n    mov r3,#NBELEMENTS4\n    bl listeOrder\n    cmp r0,#0                               @ false\u00a0?\n    beq 5f                                  @ yes\n    ldr r0,iAdrszMessResult1                @ list 1 < list 2\n    bl affichageMess                        @ display message\n    b 6f\n5:\n    ldr r0,iAdrszMessResult2\n    bl affichageMess                        @ display message\n6:\n100:                                        @ standard end of the program \n    mov r0, #0                              @ return code\n    mov r7, #EXIT                           @ request to exit program\n    svc #0                                  @ perform the system call\niAdriTabList1:             .int iTabList1\niAdriTabList2:             .int iTabList2\niAdriTabList3:             .int iTabList3\niAdriTabList4:             .int iTabList4\niAdrszMessResult1:        .int szMessResult1\niAdrszMessResult2:        .int szMessResult2\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of list 1 */\n/* r1 contains list 1 size           */\n/* r2 contains the address of list 2 */\n/* r3 contains list 2 size           */\n/* r0 returns 1 if list1 < list2     */\n/* r0 returns 0 else                 */\nlisteOrder:\n    push {r1-r7,lr}                   @ save  registres\n    cmp r1,#0                         @ list 1 size = zero\u00a0?\n    moveq r0,#-1                      @ yes -> error\n    beq 100f\n    cmp r3,#0                         @ list 2 size = zero\u00a0?\n    moveq r0,#-2                      @ yes -> error\n    beq 100f\n    mov r4,#0                         @ index list 1\n    mov r5,#0                         @ index list 2\n1:\n    ldr r6,[r0,r4,lsl #2]             @ load list 1 element\n    ldr r7,[r2,r5,lsl #2]             @ load list 2 element\n    cmp r6,r7                         @ compar\n    movgt r0,#0                       @ list 1 > list 2\u00a0?\n    bgt 100f\n    beq 2f                            @ list 1 = list 2\n    add r4,#1                         @ increment index 1\n    cmp r4,r1                         @ end list\u00a0?\n    movge r0,#1                       @ yes -> ok list 1 < list 2\n    bge 100f\n    b 1b                              @ else loop\n2:\n    add r4,#1                         @ increment index 1\n    cmp r4,r1                         @ end list\u00a0?\n    bge 3f                            @ yes -> verif size\n    add r5,#1                         @ else increment index 2\n    cmp r5,r3                         @ end list 2\u00a0?\n    movge r0,#0                       @ yes -> list 2 < list 1\n    bge 100f\n    b 1b                              @ else loop\n3:\n   cmp r1,r3                          @ compar size\n   movge r0,#0                        @ list 2 < list 1\n   movlt r0,#1                        @ list 1 < list 2\n100:\n    pop {r1-r7,lr}                    @ restaur registers\n    bx lr                             @ return  \n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                   @ save  registres\n    mov r2,#0                               @ counter length \n1:                                          @ loop length calculation \n    ldrb r1,[r0,r2]                         @ read octet start position + index \n    cmp r1,#0                               @ if 0 its over \n    addne r2,r2,#1                          @ else add 1 in the length \n    bne 1b                                  @ and loop \n                                            @ so here r2 contains the length of the message \n    mov r1,r0                               @ address message in r1 \n    mov r0,#STDOUT                          @ code to write to the standard output Linux \n    mov r7, #WRITE                          @ code call system \"write\" \n    svc #0                                  @ call systeme \n    pop {r0,r1,r2,r7,lr}                    @ restaur registers */ \n    bx lr                                   @ return\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  System.Generics.Defaults\nTranslation of: Java\n\nprogram Order_two_numerical_lists;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  System.Generics.Defaults;\n\ntype\n  TArray = record\n    class function LessOrEqual<T>(first, second: TArray<T>): Boolean; static;\n  end;\n\nclass function TArray.LessOrEqual<T>(first, second: TArray<T>): Boolean;\nbegin\n  if Length(first) = 0 then\n    exit(true);\n  if Length(second) = 0 then\n    exit(false);\n  var comp := TComparer<T>.Default.Compare(first[0], second[0]);\n  if comp = 0 then\n    exit(LessOrEqual(copy(first, 1, length(first)), copy(second, 1, length(second))));\n  Result := comp < 0;\nend;\n\nbegin\n  writeln(TArray.LessOrEqual<Integer>([1, 2, 3], [2, 3, 4]));\n  writeln(TArray.LessOrEqual<Integer>([2, 3, 4], [1, 2, 3]));\n  writeln(TArray.LessOrEqual<Integer>([1, 2], [1, 2, 3]));\n  writeln(TArray.LessOrEqual<Integer>([1, 2, 3], [1, 2]));\n  writeln(TArray.LessOrEqual<Char>(['a', 'c', 'b'], ['a', 'b', 'b']));\n  writeln(TArray.LessOrEqual<string>(['this', 'is', 'a', 'test'], ['this', 'is',\n    'not', 'a', 'test']));\n  readln;\nend.\n\n\nOutput:\nTRUE\nFALSE\nTRUE\nFALSE\nFALSE\nTRUE\n", "explain": "This is not a full translate of Java, just adaptation and aplication of method previus introduced.\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\n>> ([1,2,1,3,2] <=> [1,2,0,4,4,0,0,0]) < 0\n=> false\n\n", "explain": "The built-in <=> operator already does this:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\n\nvec![1, 2, 1, 3, 2] < vec![1, 2, 0, 4, 4, 0, 0, 0]\n\n", "explain": "Vec<T> implements Ord when T does, so we can just compare them with <. (Same with arrays and slices).\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nlet a = [1,2,1,3,2]\nlet b = [1,2,0,4,4,0,0,0]\nprintln(lexicographicalCompare(a, b)) // this is \"less than\"\n\n\nOutput:\nfalse\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;  use Ada.Text_IO;\nprocedure Order is\n\n   type IntArray is array (Positive range <>) of Integer;\n   List1 : IntArray := (1, 2, 3, 4, 5);\n   List2 : IntArray := (1, 2, 1, 5, 2, 2);\n   List3 : IntArray := (1, 2, 1, 5, 2);\n   List4 : IntArray := (1, 2, 1, 5, 2);\n\n   type Animal is (Rat, Cat, Elephant);\n   type AnimalArray is array (Positive range <>) of Animal;\n   List5 : AnimalArray := (Cat, Elephant, Rat, Cat);\n   List6 : AnimalArray := (Cat, Elephant, Rat);\n   List7 : AnimalArray := (Cat, Cat, Elephant);\n\nbegin\n   Put_Line (Boolean'Image (List1 > List2)); --  True\n   Put_Line (Boolean'Image (List2 > List3)); --  True\n   Put_Line (Boolean'Image (List3 > List4)); --  False, equal\n   Put_Line (Boolean'Image (List5 > List6)); --  True\n   Put_Line (Boolean'Image (List6 > List7)); --  True\nend Order;\n\n\nOutput:\nTRUE\nTRUE\nFALSE\nTRUE\nTRUE\n\n", "explain": "This is already implemented in the built-in comparison operators for arrays of types that have a direct ordering.\nThis also includes arrays of user defined types, using the type definition order from smallest to largest. \nDemonstrated in the program below:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction islexless(a::AbstractArray{<:Real}, b::AbstractArray{<:Real})\n    for (x, y) in zip(a, b)\n        if x == y continue end\n        return x < y\n    end\n    return length(a) < length(b)\nend\n\nusing Primes, Combinatorics\ntests = [[1, 2, 3], primes(10), 0:2:6, [-Inf, 0.0, Inf], [\u03c0, e, \u03c6, catalan], [2015, 5], [-sqrt(50.0), 50.0 ^ 2]]\nprintln(\"List not sorted:\\n - \", join(tests, \"\\n - \"))\nsort!(tests; lt=islexless)\nprintln(\"List sorted:\\n - \", join(tests, \"\\n - \"))\n\n\nOutput:\nList not sorted:\n - [1, 2, 3]\n - [2, 3, 5, 7]\n - 0:2:6\n - [-Inf, 0.0, Inf]\n - [3.14159, 2.71828, 1.61803, 0.915966]\n - [2015, 5]\n - [-7.07107, 2500.0]\nList sorted:\n - [-Inf, 0.0, Inf]\n - [-7.07107, 2500.0]\n - 0:2:6\n - [1, 2, 3]\n - [2, 3, 5, 7]\n - [3.14159, 2.71828, 1.61803, 0.915966]\n - [2015, 5]\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.0.6\n\noperator fun <T> List<T>.compareTo(other: List<T>): Int\n    where T: Comparable<T>, T: Number {\n    for (i in 0 until this.size) {\n        if (other.size == i) return 1\n        when {\n            this[i] < other[i] -> return -1\n            this[i] > other[i] -> return 1\n        }\n    }\n    return if (this.size == other.size) 0 else -1\n} \n\nfun main(args: Array<String>) {\n    val lists = listOf(\n        listOf(1, 2, 3, 4, 5),\n        listOf(1, 2, 1, 5, 2, 2),\n        listOf(1, 2, 1, 5, 2),\n        listOf(1, 2, 1, 5, 2),\n        listOf(1, 2, 1, 3, 2),\n        listOf(1, 2, 0, 4, 4, 0, 0, 0),\n        listOf(1, 2, 0, 4, 4, 1, 0, 0)\n    )\n    for (i in 0 until lists.size) println(\"list${i + 1}\u00a0: ${lists[i]}\")\n    println()  \n    for (i in 0 until lists.size - 1) println(\"list${i + 1} > list${i + 2} = ${lists[i] > lists[i + 1]}\")    \n}\n\n\nOutput:\nlist1\u00a0: [1, 2, 3, 4, 5]\nlist2\u00a0: [1, 2, 1, 5, 2, 2]\nlist3\u00a0: [1, 2, 1, 5, 2]\nlist4\u00a0: [1, 2, 1, 5, 2]\nlist5\u00a0: [1, 2, 1, 3, 2]\nlist6\u00a0: [1, 2, 0, 4, 4, 0, 0, 0]\nlist7\u00a0: [1, 2, 0, 4, 4, 1, 0, 0]\n\nlist1 > list2 = true\nlist2 > list3 = true\nlist3 > list4 = false\nlist4 > list5 = true\nlist5 > list6 = true\nlist6 > list7 = false\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nuse strict;\nuse warnings;\n\nsub orderlists {\n    my ($firstlist, $secondlist) = @_;\n\n    my ($first, $second);\n    while (@{$firstlist}) {\n        $first = shift @{$firstlist};\n        if (@{$secondlist}) {\n            $second = shift @{$secondlist};\n            if ($first < $second) {\n                return 1;\n            }\n            if ($first > $second) {\n                return 0;\n            }\n        }\n        else {\n            return 0;\n        }\n    }\n\n    @{$secondlist} ? 1 : 0;\n}\n\nforeach my $pair (\n    [[1, 2, 4], [1, 2, 4]],\n    [[1, 2, 4], [1, 2,  ]],\n    [[1, 2,  ], [1, 2, 4]],\n    [[55,53,1], [55,62,83]],\n    [[20,40,51],[20,17,78,34]],\n) {\n    my $first  = $pair->[0];\n    my $second = $pair->[1];\n    my $before = orderlists([@$first], [@$second]) ? 'true' : 'false';\n    print \"(@$first) comes before (@$second)\u00a0: $before\\n\";\n}\n\n\nOutput:\n(1 2 4) comes before (1 2 4)\u00a0: false\n(1 2 4) comes before (1 2)\u00a0: false\n(1 2) comes before (1 2 4)\u00a0: true\n(55 53 1) comes before (55 62 83)\u00a0: true\n(20 40 51) comes before (20 17 78 34)\u00a0: false\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\n\nfunction arraycompare(a, b)\n    for i = 1, #a do\n        if b[i] == nil then\n            return true\n        end\n        if a[i] ~= b[i] then\n            return a[i] < b[1]\n        end\n    end\n    return true\nend\n\n\nfunction randomarray()\n    local t = {}\n    for i = 1, math.random(1, 10) do\n        t[i] = math.random(1, 10)\n    end\n    return t\nend\n\nmath.randomseed(os.time())\n\nfor i = 1, 10 do\n    local a = randomarray()\n    local b = randomarray()\n\n    print(\n        string.format(\"{%s} %s {%s}\",\n        table.concat(a, ', '),\n        arraycompare(a, b) and \"<=\" or \">\",\n        table.concat(b, ', ')))\nend\n\n\nOutput: (time used as random seed\n1413127434):\n    {10, 7, 4, 9, 10, 3, 5, 5, 5, 5} > {7, 4, 6, 4, 3, 5, 10}\n    {5, 7} <= {6, 3, 7, 7, 7, 1}\n    {4} <= {10, 10, 3, 8, 10, 5, 2, 5, 10, 6}\n    {6} <= {6, 10, 2, 1, 9, 4, 5, 6, 9}\n    {9, 5, 7, 5, 5, 7, 9, 5, 6, 8} > {4, 7, 3, 5, 1, 2, 1, 2}\n    {10, 8, 6, 1, 8, 5, 4} > {1, 2}\n    {9, 7} > {4, 1, 5, 2, 6, 1, 9, 3, 5}\n    {5, 9, 7, 6, 10, 8} <= {9, 6, 9}\n    {4, 3, 4, 6, 3, 6, 7, 2, 2, 5} > {3, 10, 6, 8, 1}\n    {1, 5, 1, 5, 4} > {1, 3, 5, 3, 2, 10, 1}\n\n", "explain": "In Lua tables with numerical indices are used as lists or arrays and they do not support comparison out-of-the-box, so a function is needed to implement the comparison:\nHere is some demonstration code:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef lessThan1(a: List[Int], b: List[Int]): Boolean =\n  if (b.isEmpty) false\n  else if (a.isEmpty) true\n  else if (a.head != b.head) a.head < b.head\n  else lessThan1(a.tail, b.tail)\ndef lessThan2(a: List[Int], b: List[Int]): Boolean = (a, b) match {\n  case (_, Nil) => false\n  case (Nil, _) => true\n  case (a :: _, b :: _) if a != b => a < b\n  case _ => lessThan2(a.tail, b.tail)\n}\ndef lessThan3(a: List[Int], b: List[Int]): Boolean =\n  a.zipAll(b, Integer.MIN_VALUE, Integer.MIN_VALUE)\n   .find{case (a, b) => a != b}\n   .map{case (a, b) => a < b}\n   .getOrElse(false)\nval tests = List(\n  (List(1, 2, 3), List(1, 2, 3)) -> false,\n  (List(3, 2, 1), List(3, 2, 1)) -> false,\n  (List(1, 2, 3), List(3, 2, 1)) -> true,\n  (List(3, 2, 1), List(1, 2, 3)) -> false,\n  (List(1, 2), List(1, 2, 3)) -> true,\n  (List(1, 2, 3), List(1, 2)) -> false\n)\n\ntests.foreach{case test @ ((a, b), c) =>\n  assert(lessThan1(a, b) == c, test)\n  assert(lessThan2(a, b) == c, test)\n  assert(lessThan3(a, b) == c, test)\n}\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\n\nvoid main() {\n    assert([1,2,1,3,2] >= [1,2,0,4,4,0,0,0]);\n}\n\n", "explain": "The built-in comparison operators already do this:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nPrelude>  [1,2,1,3,2] < [1,2,0,4,4,0,0,0]\nFalse\n\n", "explain": "The built-in comparison operators already do this:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\nFunction order_list(arr1,arr2)\n\torder_list = \"FAIL\"\n\tn1 = UBound(arr1): n2 = UBound(arr2)\n\tn = 0 : p = 0\n\tIf n1 > n2 Then\n\t\tmax = n2\n\tElse\n\t\tmax = n1\n\tEnd If\n\tFor i = 0 To max\n\t\tIf arr1(i) > arr2(i) Then\n\t\t\tn = n + 1\n\t\tElseIf arr1(i) = arr2(i) Then\n\t\t\tp = p + 1\n\t\tEnd If\t\n\tNext\n\tIf (n1 < n2 And n = 0) Or _\n\t\t (n1 = n2 And n = 0 And p - 1 <> n1) Or _\n\t\t (n1 > n2 And n = 0 And p = n2) Then\n\t\t\torder_list = \"PASS\"\n\tEnd If\nEnd Function\n\nWScript.StdOut.WriteLine order_list(Array(-1),Array(0))\nWScript.StdOut.WriteLine order_list(Array(0),Array(0))\nWScript.StdOut.WriteLine order_list(Array(0),Array(-1))\nWScript.StdOut.WriteLine order_list(Array(0),Array(0,-1))\nWScript.StdOut.WriteLine order_list(Array(0),Array(0,0))\nWScript.StdOut.WriteLine order_list(Array(0),Array(0,1))\nWScript.StdOut.WriteLine order_list(Array(0,-1),Array(0))\nWScript.StdOut.WriteLine order_list(Array(0,0),Array(0))\nWScript.StdOut.WriteLine order_list(Array(0,0),Array(1))\nWScript.StdOut.WriteLine order_list(Array(1,2,1,3,2),Array(1,2,0,4,4,0,0,0))\n\n\nOutput:\nPASS\nFAIL\nFAIL\nPASS\nPASS\nPASS\nFAIL\nFAIL\nPASS\nFAIL\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n(define (lex<? a b)\n        (cond ((null? b) #f)\n              ((null? a) #t)\n              ((= (car a) (car b)) (lex<? (cdr a) (cdr b)))\n              (else (< (car a) (car b)))))\n\n", "explain": ""}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nfunction  order($as,$bs) {\n    if($as -and $bs) {\n        $a, $as = $as\n        $b, $bs = $bs\n        if($a -eq $b) {order $as $bs}\n        else{$a -lt $b}\n    } elseif ($bs) {$true} else {$false}\n}\n\"$(order @(1,2,1,3,2) @(1,2,0,4,4,0,0,0))\"\n\n\nFalse\n\nNon-Recursive Version[edit]\nfunction Test-Order ([int[]]$ReferenceArray, [int[]]$DifferenceArray)\n{\n    for ($i = 0; $i -lt $ReferenceArray.Count; $i++)\n    { \n        if ($ReferenceArray[$i] -lt $DifferenceArray[$i])\n        {\n            return $true\n        }\n        elseif ($ReferenceArray[$i] -gt $DifferenceArray[$i])\n        {\n            return $false\n        }\n    }\n\n    return ($ReferenceArray.Count -lt $DifferenceArray.Count) -or (Compare-Object $ReferenceArray $DifferenceArray) -eq $null\n}\n\nTest-Order -ReferenceArray 1, 2, 1, 3, 2 -DifferenceArray 1, 2, 0, 4, 4, 0, 0, 0\nTest-Order -ReferenceArray 1, 2, 1, 3, 2 -DifferenceArray 1, 2, 2, 4, 4, 0, 0, 0\nTest-Order -ReferenceArray 1, 2, 3       -DifferenceArray 1, 2\nTest-Order -ReferenceArray 1, 2          -DifferenceArray 1, 2, 3\nTest-Order -ReferenceArray 1, 2          -DifferenceArray 1, 2\n\n\nOutput:\nFalse\nTrue\nFalse\nTrue\nTrue\n\n", "explain": "Output:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nlet inline cmp x y = if x < y then -1 else if x = y then 0 else 1\nlet before (s1 : seq<'a>) (s2 : seq<'a>) = (Seq.compareWith cmp s1 s2) < 0\n\n[\n    ([0], []);\n    ([], []);\n    ([], [0]);\n    ([-1], [0]);\n    ([0], [0]);\n    ([0], [-1]);\n    ([0], [0; -1]);\n    ([0], [0; 0]);\n    ([0], [0; 1]);\n    ([0; -1], [0]);\n    ([0; 0], [0]);\n    ([0; 0], [1]);\n]\n|> List.iter (fun (x, y) -> printf \"%A %s %A\\n\" x (if before x y then \"< \" else \">=\") y)\n\n\nOutput:\n[0] >= []\n[] >= []\n[] <  [0]\n[-1] <  [0]\n[0] >= [0]\n[0] >= [-1]\n[0] <  [0; -1]\n[0] <  [0; 0]\n[0] <  [0; 1]\n[0; -1] >= [0]\n[0; 0] >= [0]\n[0; 0] <  [1]\n", "explain": "By using the Collection.Seq Module the static method Seq.compareWith fits our needs.\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nclass CList extends ArrayList implements Comparable {\n    CList() { }\n    CList(Collection c) { super(c) }\n    int compareTo(Object that) {\n        assert that instanceof List\n        def n = [this.size(), that.size()].min()\n        def comp = [this[0..<n], that[0..<n]].transpose().find { it[0] != it[1] }\n        comp ? comp[0] <=> comp[1] : this.size() <=> that.size()\n    }\n}\n\n\nCList a, b; (a, b) = [[], []]; assert ! (a < b)\nb = [1] as CList;              assert   (a < b)\na = [1] as CList;              assert ! (a < b)\nb = [2] as CList;              assert   (a < b)\na = [2, -1, 0] as CList;       assert ! (a < b)\nb = [2, -1] as CList;          assert ! (a < b)\nb = [2, -1, 0] as CList;       assert ! (a < b)\nb = [2, -1, 0, -17] as CList;  assert   (a < b)\na = [2,  8, 0] as CList;       assert ! (a < b)\n\n", "explain": "Solution:\nTest:\n"}, {"task_name": "Order two numerical lists", "task_url": "https://rosettacode.org/wiki/Order_two_numerical_lists", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f ORDER_TWO_NUMERICAL_LISTS.AWK\nBEGIN {\n    split(\"1,2,1,5,2\",list1,\",\")\n    split(\"1,2,1,5,2,2\",list2,\",\")\n    split(\"1,2,3,4,5\",list3,\",\")\n    split(\"1,2,3,4,5\",list4,\",\")\n    x = compare_array(list1,list2) ? \"<\" : \">=\" ; printf(\"list1%slist2\\n\",x)\n    x = compare_array(list2,list3) ? \"<\" : \">=\" ; printf(\"list2%slist3\\n\",x)\n    x = compare_array(list3,list4) ? \"<\" : \">=\" ; printf(\"list3%slist4\\n\",x)\n    exit(0)\n}\nfunction compare_array(arr1,arr2,  ans,i) {\n    ans = 0\n    for (i=1; i<=length(arr1); i++) {\n      if (arr1[i] != arr2[i]) {\n        ans = 1\n        break\n      }\n    }\n    if (length(arr1) != length(arr2)) {\n      ans = 1\n    }\n    return(ans)\n}\n\n\nOutput:\nlist1<list2\nlist2<list3\nlist3>=list4\n\n\n", "explain": "\n"}]