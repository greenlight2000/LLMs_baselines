[{"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Python", "code": "\n\n>>> s = 'abcdefgh'\n>>> n, m, char, chars = 2, 3, 'd', 'cd'\n>>> # starting from n=2 characters in and m=3 in length;\n>>> s[n-1:n+m-1]\n'bcd'\n>>> # starting from n characters in, up to the end of the string;\n>>> s[n-1:]\n'bcdefgh'\n>>> # whole string minus last character;\n>>> s[:-1]\n'abcdefg'\n>>> # starting from a known character char=\"d\" within the string and of m length;\n>>> indx = s.index(char)\n>>> s[indx:indx+m]\n'def'\n>>> # starting from a known substring chars=\"cd\" within the string and of m length. \n>>> indx = s.index(chars)\n>>> s[indx:indx+m]\n'cde'\n>>>\n\n", "explain": "Python uses zero-based indexing, so the n'th character is at index n-1.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "C", "code": "\nC: ASCII version[edit]\n/*\n * RosettaCode: Substring, C89\n *\n * In this task display a substring: starting from n characters in and of m\n * length; starting from n characters in, up to the end of the string; whole\n * string minus last character; starting from a known character within the\n * string and of m length; starting from a known substring within the string\n * and of m length.\n *\n * This example program DOES NOT make substrings. The program simply displays\n * certain parts of the input string.\n * \n */\n#define _CRT_SECURE_NO_WARNINGS /* MSVS compilers need this */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Put no more than m characters from string to standard output.\n *\n * It is worth noting that printf(\"%*s\",width,string) does not limit the number\n * of characters to be printed.\n *\n * @param string null terminated string\n * @param m      number of characters to display\n */\nvoid putm(char* string, size_t m)\n{\n    while(*string && m--)\n        putchar(*string++);\n}\n\nint main(void)\n{\n\n    char string[] = \n        \"Programs for other encodings (such as 8-bit ASCII, or EUC-JP).\"\n\n    int n = 3;\n    int m = 4;\n    char knownCharacter = '(';\n    char knownSubstring[] = \"encodings\";\n\n    putm(string+n-1, m );                       putchar('\\n');\n    puts(string+n+1);                           putchar('\\n');\n    putm(string, strlen(string)-1);             putchar('\\n');\n    putm(strchr(string, knownCharacter), m );   putchar('\\n');\n    putm(strstr(string, knownSubstring), m );   putchar('\\n');\n\n    return EXIT_SUCCESS;\n}\n\nC: Unicode version[edit]\n/*\n * RosettaCode: Substring, C89, Unicode\n *\n * In this task display a substring: starting from n characters in and of m\n * length; starting from n characters in, up to the end of the string; whole\n * string minus last character; starting from a known character within the\n * string and of m length; starting from a known substring within the string\n * and of m length.\n *\n * This example program DOES NOT make substrings. The program simply displays\n * certain parts of the input string.\n * \n */\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/*\n * Put all characters from string to standard output AND write newline.\n * BTW, _putws may not be avaliable.\n */\nvoid put(wchar_t* string)\n{\n    while(*string)\n        putwchar(*string++);\n    putwchar(L'\\n');\n}\n\n/*\n * Put no more than m characters from string to standard output AND newline.\n */\nvoid putm(wchar_t* string, size_t m)\n{\n    while(*string && m--)\n        putwchar(*string++);\n    putwchar(L'\\n');\n}\n\nint main(void)\n{\n    wchar_t string[] = \n        L\"Programs for other encodings (such as 8-bit ASCII).\";\n\n    int n = 3;\n    int m = 4;\n    wchar_t knownCharacter = L'(';\n    wchar_t knownSubstring[] = L\"encodings\";\n\n    putm(string+n-1,m);                        \n    put (string+n+1);                         \n    putm(string, wcslen(string)-1);           \n    putm(wcschr(string, knownCharacter), m ); \n    putm(wcsstr(string, knownSubstring), m ); \n\n    return EXIT_SUCCESS;\n}\n\nC: another version[edit]\n#include <stddef.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nchar *substring(const char *s, size_t n, ptrdiff_t m)\n{\n  char *result;\n  /* check for null s */\n  if (NULL == s)\n    return NULL;\n  /* negative m to mean 'up to the mth char from right' */\n  if (m < 0) \n    m = strlen(s) + m - n + 1;\n\n  /* n < 0 or m < 0 is invalid */\n  if (n < 0 || m < 0)\n    return NULL;\n\n  /* make sure string does not end before n \n   * and advance the \"s\" pointer to beginning of substring */\n  for ( ; n > 0; s++, n--)\n    if (*s == '\\0')\n      /* string ends before n: invalid */\n      return NULL;\n\n  result = malloc(m+1);\n  if (NULL == result)\n    /* memory allocation failed */\n    return NULL;\n  result[0]=0;\n  strncat(result, s, m); /* strncat() will automatically add null terminator\n                          * if string ends early or after reading m characters */\n  return result;\n}\n\nchar *str_wholeless1(const char *s)\n{\n  return substring(s, 0, strlen(s) - 1);\n}\n\nchar *str_fromch(const char *s, int ch, ptrdiff_t m)\n{\n  return substring(s, strchr(s, ch) - s, m);\n}\n\nchar *str_fromstr(const char *s, char *in, ptrdiff_t m)\n{\n  return substring(s, strstr(s, in) - s , m);\n}\n\n\n#define TEST(A) do {\t\t\\\n    char *r = (A);\t\t\\\n    if (NULL == r)\t\t\\\n      puts(\"--error--\");\t\\\n    else {\t\t\t\\\n      puts(r);\t\t\t\\\n      free(r);\t\t\t\\\n    }\t\t\t\t\\\n  } while(0)\n\nint main()\n{\n  const char *s = \"hello world shortest program\";\n\n  TEST( substring(s, 12, 5) );\t\t// get \"short\"\n  TEST( substring(s, 6, -1) );\t\t// get \"world shortest program\"\n  TEST( str_wholeless1(s) );\t\t// \"... progra\"\n  TEST( str_fromch(s, 'w', 5) );\t// \"world\"\n  TEST( str_fromstr(s, \"ro\", 3) );\t// \"rog\"\n\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <iostream>\n#include <string>\n\nint main()\n{\n  std::string s = \"0123456789\";\n\n  int const n = 3;\n  int const m = 4;\n  char const c = '2';\n  std::string const sub = \"456\";\n\n  std::cout << s.substr(n, m)<< \"\\n\";\n  std::cout << s.substr(n) << \"\\n\";\n  std::cout << s.substr(0, s.size()-1) << \"\\n\";\n  std::cout << s.substr(s.find(c), m) << \"\\n\";\n  std::cout << s.substr(s.find(sub), m) << \"\\n\";\n}\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Java", "code": "\npublic static String Substring(String str, int n, int m){\n    return str.substring(n, n+m);\n}\npublic static String Substring(String str, int n){\n    return str.substring(n);\n}\npublic static String Substring(String str){\n    return str.substring(0, str.length()-1);\n}\npublic static String Substring(String str, char c, int m){\n    return str.substring(str.indexOf(c), str.indexOf(c)+m+1);\n}\npublic static String Substring(String str, String sub, int m){\n    return str.substring(str.indexOf(sub), str.indexOf(sub)+m+1);\n}\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "C#", "code": "\nusing System;\nnamespace SubString\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            string s = \"0123456789\";\n            const int n = 3;\n            const int m = 2;\n            const char c = '3';\n            const string z = \"345\";\n\n            // A: starting from n characters in and of m length;\n            Console.WriteLine(s.Substring(n, m));\n            // B: starting from n characters in, up to the end of the string;\n            Console.WriteLine(s.Substring(n, s.Length - n));\n            // C: whole string minus the last character;\n            Console.WriteLine(s.Substring(0, s.Length - 1));\n            // D: starting from a known character within the string and of m length;\n            Console.WriteLine(s.Substring(s.IndexOf(c), m));\n            // E: starting from a known substring within the string and of m length.\n            Console.WriteLine(s.Substring(s.IndexOf(z), m));\n        }\n    }\n}\n\n\n// B: starting from n characters in, up to the end of the string;\nConsole.WriteLine(s[n..]);\n// C: whole string minus the last character;\nConsole.WriteLine(s[..^1]);\n\n", "explain": "As of C# 8, we can use the Range syntax. Cases B and C can be written more succinctly.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\n\nsubstr(start, [len]) returns a substring beginning at a specified location and having a specified length.\nsubstring(start, [end]) returns a string containing the substring from start up to, but not including, end.\nvar str = \"abcdefgh\";\n\nvar n = 2;\nvar m = 3;\n\n//  *  starting from n characters in and of m length;\nstr.substr(n, m);  // => \"cde\"\n\n//  * starting from n characters in, up to the end of the string;\nstr.substr(n);  // => \"cdefgh\"\nstr.substring(n);  // => \"cdefgh\"\n\n//  * whole string minus last character;\nstr.substring(0, str.length - 1);  // => \"abcdefg\"\n\n//  * starting from a known character within the string and of m length;\nstr.substr(str.indexOf('b'), m);  // => \"bcd\"\n\n//  * starting from a known substring within the string and of m length. \nstr.substr(str.indexOf('bc'), m);  // => \"bcd\"\n\n\n(function () {\n    'use strict';\n\n    //  take :: Int -> Text -> Text\n    function take(n, s) {\n        return s.substr(0, n);\n    }\n\n    //  drop :: Int -> Text -> Text\n    function drop(n, s) {\n        return s.substr(n);\n    }\n\n\n    // init :: Text -> Text\n    function init(s) {\n        var n = s.length;\n        return (n > 0 ? s.substr(0, n - 1) : undefined);\n    }\n    \n    // breakOn :: Text -> Text -> (Text, Text)\n    function breakOn(strPattern, s) {\n        var i = s.indexOf(strPattern);\n        return i === -1 ? [strPattern, ''] : [s.substr(0, i), s.substr(i)];\n    }\n    \n\n    var str = '\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341';\n\n\n    return JSON.stringify({\n    \n        'from n in, of m length': (function (n, m) {\n            return take(m, drop(n, str));\n        })(4, 3),\n        \n        \n        'from n in, up to end' :(function (n) {\n            return drop(n, str);\n        })(3),\n        \n        \n        'all but last' : init(str),\n        \n        \n        'from matching char, of m length' : (function (pattern, s, n) {\n            return take(n, breakOn(pattern, s)[1]);\n        })('\u4e94', str, 3),\n        \n        \n        'from matching string, of m length':(function (pattern, s, n) {\n            return take(n, breakOn(pattern, s)[1]);\n        })('\u516d\u4e03', str, 4)\n        \n    }, null, 2);\n\n})();\n\n\nOutput:\n{\n  \"from n in, of m length\": \"\u4e94\u516d\u4e03\",\n  \"from n in, up to end\": \"\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\",\n  \"all but last\": \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\",\n  \"from matching char, of m length\": \"\u4e94\u516d\u4e03\",\n  \"from matching string, of m length\": \"\u516d\u4e03\u516b\u4e5d\"\n}\n\n", "explain": "The String object has two similar methods: substr and substring.\n\nOr, in terms of some familiar functional primitives, translating broadly from Haskell:\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "PHP", "code": "\n<?php\n$str = 'abcdefgh';\n$n = 2;\n$m = 3;\necho substr($str, $n, $m), \"\\n\"; //cde\necho substr($str, $n), \"\\n\"; //cdefgh\necho substr($str, 0, -1), \"\\n\"; //abcdefg\necho substr($str, strpos($str, 'd'), $m), \"\\n\"; //def\necho substr($str, strpos($str, 'de'), $m), \"\\n\"; //def\n?>\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram test_substring\n\n  character (*), parameter :: string = 'The quick brown fox jumps over the lazy dog.'\n  character (*), parameter :: substring = 'brown'\n  character    , parameter :: c = 'q'\n  integer      , parameter :: n = 5\n  integer      , parameter :: m = 15\n  integer                  :: i\n\n! Display the substring starting from n characters in and of length m.\n  write (*, '(a)') string (n : n + m - 1)\n! Display the substring starting from n characters in, up to the end of the string.\n  write (*, '(a)') string (n :)\n! Display the whole string minus the last character.\n  i = len (string) - 1\n  write (*, '(a)') string (: i)\n! Display the substring starting from a known character and of length m.\n  i = index (string, c)\n  write (*, '(a)') string (i : i + m - 1)\n! Display the substring starting from a known substring and of length m.\n  i = index (string, substring)\n  write (*, '(a)') string (i : i + m - 1)\n\nend program test_substring\n\n\nOutput:\nquick brown fox\nquick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog\nquick brown fox\nbrown fox jumps\n\n\n", "explain": "Note that in Fortran positions inside character strings are one-based, i. e. the first character is in position one.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Go", "code": "\nASCII[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s := \"ABCDEFGH\"\n    n, m := 2, 3\n    // for reference\n    fmt.Println(\"Index: \", \"01234567\")\n    fmt.Println(\"String:\", s)\n    // starting from n characters in and of m length\n    fmt.Printf(\"Start %d, length %d:    %s\\n\", n, m, s[n : n+m])\n    // starting from n characters in, up to the end of the string\n    fmt.Printf(\"Start %d, to end:      %s\\n\", n, s[n:])\n    // whole string minus last character\n    fmt.Printf(\"All but last:         %s\\n\", s[:len(s)-1])\n    // starting from a known character within the string and of m length\n    dx := strings.IndexByte(s, 'D')\n    fmt.Printf(\"Start 'D', length %d:  %s\\n\", m, s[dx : dx+m])\n    // starting from a known substring within the string and of m length\n    sx := strings.Index(s, \"DE\")\n    fmt.Printf(`Start \"DE\", length %d: %s`+\"\\n\", m, s[sx : sx+m])\n}\n\n\nOutput:\nIndex:  01234567\nString: ABCDEFGH\nStart 2, length 3:    CDE\nStart 2, to end:      CDEFGH\nAll but last:         ABCDEFG\nStart 'D', length 3:  DEF\nStart \"DE\", length 3: DEF\n\nUTF-8[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc main() {\n    s := \"\u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\"\n    r := []rune(s)\n    n, m := 2, 3\n    kc := '\u03b4'  // known character\n    ks := \"\u03b4\u03b5\" // known string\n    // for reference\n    fmt.Println(\"Index: \", \"01234567\")\n    fmt.Println(\"String:\", s)\n    // starting from n characters in and of m length\n    fmt.Printf(\"Start %d, length %d:    %s\\n\", n, m, string(r[n:n+m]))\n    // starting from n characters in, up to the end of the string\n    fmt.Printf(\"Start %d, to end:      %s\\n\", n, string(r[n:]))\n    // whole string minus last character\n    fmt.Printf(\"All but last:         %s\\n\", string(r[:len(r)-1]))\n    // starting from a known character within the string and of m length\n    dx := strings.IndexRune(s, kc)\n    fmt.Printf(\"Start %q, length %d:  %s\\n\", kc, m, string([]rune(s[dx:])[:m]))\n    // starting from a known substring within the string and of m length\n    sx := strings.Index(s, ks)\n    fmt.Printf(\"Start %q, length %d: %s\\n\", ks, m, string([]rune(s[sx:])[:m]))\n}\n\n\nOutput:\nIndex:  01234567\nString: \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\nStart 2, length 3:    \u03b3\u03b4\u03b5\nStart 2, to end:      \u03b3\u03b4\u03b5\u03b6\u03b7\u03b8\nAll but last:         \u03b1\u03b2\u03b3\u03b4\u03b5\u03b6\u03b7\nStart '\u03b4', length 3:  \u03b4\u03b5\u03b6\nStart \"\u03b4\u03b5\", length 3: \u03b4\u03b5\u03b6\n\n", "explain": "The task originally had no mention of unicode.  This solution works with ASCII data.\nStrings are generally handled as UTF-8 in Go.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program substring.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ WRITE,  4                           @ Linux syscall\n\n.equ BUFFERSIZE,          100\n\n/* Initialized data */\n.data\nszMessString:            .asciz \"Result\u00a0: \" \nszString1:               .asciz \"abcdefghijklmnopqrstuvwxyz\"\nszStringStart:           .asciz \"abcdefg\"\nszCarriageReturn:        .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \nszSubString:             .skip 500             @ buffer result\n\n\n/*  code section */\n.text\n.global main \nmain: \n\n    ldr r0,iAdrszString1                        @ address input string\n    ldr r1,iAdrszSubString                      @ address output string\n    mov r2,#22                                  @ location\n    mov r3,#4                                   @ length\n    bl subStringNbChar                          @ starting from n characters in and of m length\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszSubString                      @ display substring result\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn                 @ display line return\n    bl affichageMess\n    @\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszSubString\n    mov r2,#15                                  @ location\n    bl subStringEnd                             @starting from n characters in, up to the end of the string\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszSubString\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn                 @ display line return\n    bl affichageMess\n    @\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszSubString\n    bl subStringMinus                           @ whole string minus last character\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszSubString\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn                 @ display line return\n    bl affichageMess\n    @\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszSubString\n    mov r2,#'c'                                 @ start character\n    mov r3,#5                                   @ length\n    bl subStringStChar                          @starting from a known character within the string and of m length\n    cmp r0,#-1                                  @ error\u00a0?\n    beq 2f\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszSubString\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn                 @ display line return\n    bl affichageMess\n    @\n2:\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszSubString\n    ldr r2,iAdrszStringStart                    @ sub string to start\n    mov r3,#10                                  @ length\n    bl subStringStString                        @ starting from a known substring within the string and of m length\n    cmp r0,#-1                                  @ error\u00a0?\n    beq 3f\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszSubString\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn                 @ display line return\n    bl affichageMess\n3:\n100:                                            @ standard end of the program\n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc 0                                       @ perform system call\niAdrszMessString:         .int szMessString\niAdrszString1:            .int szString1\niAdrszSubString:            .int szSubString\niAdrszStringStart:            .int szStringStart\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     sub strings  index start  number of characters             */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of the output string */\n/* r2 contains the start index                  */\n/* r3 contains numbers of characters to extract */\n/* r0 returns number of characters or -1 if error */\nsubStringNbChar:\n    push {r1-r5,lr}                             @ save  registers \n    mov r4,#0                                   @ counter byte output string \n1:\n    ldrb r5,[r0,r2]                             @ load byte string input\n    cmp r5,#0                                   @ zero final\u00a0?\n    beq 2f\n    strb r5,[r1,r4]                             @ store byte output string\n    add r2,#1                                   @ increment counter\n    add r4,#1\n    cmp r4,r3                                   @ end\u00a0?\n    blt 1b                                      @ no -> loop\n2:\n    mov r5,#0\n    strb r5,[r1,r4]                             @ load byte string 2\n    mov r0,r4\n100:\n    pop {r1-r5,lr}                              @ restaur registers\n    bx lr                                       @ return\n/******************************************************************/\n/*     sub strings  index start at end of string             */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of the output string */\n/* r2 contains the start index                  */\n/* r0 returns number of characters or -1 if error */\nsubStringEnd:\n    push {r1-r5,lr}                             @ save registers \n    mov r4,#0                                   @ counter byte output string \n1:\n    ldrb r5,[r0,r2]                             @ load byte string 1\n    cmp r5,#0                                   @ zero final\u00a0?\n    beq 2f\n    strb r5,[r1,r4]\n    add r2,#1\n    add r4,#1\n    b 1b                                        @ loop\n2:\n    mov r5,#0\n    strb r5,[r1,r4]                             @ load byte string 2\n    mov r0,r4\n100:\n    pop {r1-r5,lr}                              @ restaur registers\n    bx lr   \n/******************************************************************/\n/*      whole string minus last character                        */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of the output string */\n/* r0 returns number of characters or -1 if error */\nsubStringMinus:\n    push {r1-r5,lr}                             @ save  registers \n    mov r2,#0                                   @ counter byte input string\n    mov r4,#0                                   @ counter byte output string \n1:\n    ldrb r5,[r0,r2]                             @ load byte string \n    cmp r5,#0                                   @ zero final\u00a0?\n    beq 2f\n    strb r5,[r1,r4]\n    add r2,#1\n    add r4,#1\n    b 1b                                        @  loop\n2:\n    sub r4,#1\n    mov r5,#0\n    strb r5,[r1,r4]                             @ load byte string 2\n    mov r0,r4\n100:\n    pop {r1-r5,lr}                              @ restaur registers\n    bx lr   \n/******************************************************************/\n/*   starting from a known character within the string and of m length  */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of the output string */\n/* r2 contains the character    */\n/* r3 contains the length\n/* r0 returns number of characters or -1 if error */\nsubStringStChar:\n    push {r1-r5,lr}                             @ save  registers \n    mov r6,#0                                   @ counter byte input string\n    mov r4,#0                                   @ counter byte output string \n\n1:\n    ldrb r5,[r0,r6]                             @ load byte string \n    cmp r5,#0                                   @ zero final\u00a0?\n    streqb r5,[r1,r4]\n    moveq r0,#-1\n    beq 100f\n    cmp r5,r2\n    beq 2f\n    add r6,#1\n    b 1b                                        @  loop\n2:\n    strb r5,[r1,r4]\n    add r6,#1\n    add r4,#1\n    cmp r4,r3\n    bge 3f\n    ldrb r5,[r0,r6]                             @ load byte string \n    cmp r5,#0\n    bne 2b\n3:\n    mov r5,#0\n    strb r5,[r1,r4]                             @ load byte string 2\n    mov r0,r4\n100:\n    pop {r1-r5,lr}                              @ restaur registers\n    bx lr   \n\n/******************************************************************/\n/*   starting from a known substring within the string and of m length  */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of the output string */\n/* r2 contains the address of string to start    */\n/* r3 contains the length\n/* r0 returns number of characters or -1 if error */\nsubStringStString:\n    push {r1-r8,lr}                             @ save  registers \n    mov r7,r0                                   @ save address\n    mov r8,r1                                   @ counter byte string \n    mov r1,r2\n    bl searchSubString\n    cmp r0,#-1\n    beq 100f\n    mov r6,r0                                   @ counter byte input string\n    mov r4,#0\n1:\n    ldrb r5,[r7,r6]                             @ load byte string \n    strb r5,[r8,r4]\n    cmp r5,#0                                   @ zero final\u00a0?\n    moveq r0,r4\n    beq 100f\n    add r4,#1\n    cmp r4,r3\n    addlt r6,#1\n    blt 1b                                      @  loop\n    mov r5,#0\n    strb r5,[r8,r4]\n    mov r0,r4\n100:\n    pop {r1-r8,lr}                              @ restaur registers\n    bx lr   \n\n/******************************************************************/\n/*   search a substring in the string                            */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of substring */\n/* r0 returns index of substring in string or -1 if not found */\nsearchSubString:\n    push {r1-r6,lr}                       @ save registers \n    mov r2,#0                             @ counter byte input string\n    mov r3,#0                             @ counter byte string \n    mov r6,#-1                            @ index found\n    ldrb r4,[r1,r3]\n1:\n    ldrb r5,[r0,r2]                       @ load byte string \n    cmp r5,#0                             @ zero final\u00a0?\n    moveq r0,#-1                          @ yes returns error\n    beq 100f\n    cmp r5,r4                             @ compare character \n    beq 2f\n    mov r6,#-1                            @ no equals - > raz index \n    mov r3,#0                             @ and raz counter byte\n    add r2,#1                             @ and increment counter byte\n    b 1b                                  @ and loop\n2:                                        @ characters equals\n    cmp r6,#-1                            @ first characters equals\u00a0?\n    moveq r6,r2                           @ yes -> index begin in r6\n    add r3,#1                             @ increment counter substring\n    ldrb r4,[r1,r3]                       @ and load next byte\n    cmp r4,#0                             @ zero final\u00a0?\n    beq 3f                                @ yes -> end search\n    add r2,#1                             @ else increment counter string\n    b 1b                                  @ and loop\n3:\n    mov r0,r6\n100:\n    pop {r1-r6,lr}                        @ restaur registers\n    bx lr   \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nprogram ShowSubstring;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nconst\n  s = '0123456789';\n  n = 3;\n  m = 4;\n  c = '2';\n  sub = '456';\nbegin\n  Writeln(Copy(s, n, m));             // starting from n characters in and of m length;\n  Writeln(Copy(s, n, Length(s)));     // starting from n characters in, up to the end of the string;\n  Writeln(Copy(s, 1, Length(s) - 1)); // whole string minus last character;\n  Writeln(Copy(s, Pos(c, s), m));     // starting from a known character within the string and of m length;\n  Writeln(Copy(s, Pos(sub, s), m));   // starting from a known substring within the string and of m length.\nend.\n\n\nOutput:\n2345\n23456789\n012345678\n2345\n4567\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Ruby", "code": "\nstr = 'abcdefgh'\nn = 2\nm = 3\nputs str[n, m]                  #=> cde\nputs str[n..m]                  #=> cd\nputs str[n..-1]                 #=> cdefgh\nputs str[0..-2]                 #=> abcdefg\nputs str[str.index('d'), m]     #=> def\nputs str[str.index('de'), m]    #=> def\nputs str[/a.*d/]                #=> abcd\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Rust", "code": "\nlet s = \"abc\u6587\u5b57\u5316\u3051def\";\nlet n = 2;\nlet m = 3;\n\n    // Print 3 characters starting at index 2 (c\u6587\u5b57)\nprintln!(\"{}\", s.chars().skip(n).take(m).collect::<String>());\n\n    // Print all characters starting at index 2 (c\u6587\u5b57\u5316\u3051def)\nprintln!(\"{}\", s.chars().skip(n).collect::<String>());\n\n    // Print all characters except the last (abc\u6587\u5b57\u5316\u3051de)\nprintln!(\"{}\", s.chars().rev().skip(1).collect::<String>());\n\n    // Print 3 characters starting with 'b' (bc\u6587)\nlet cpos = s.find('b').unwrap();\nprintln!(\"{}\", s[cpos..].chars().take(m).collect::<String>());\n\n    // Print 3 characters starting with \"\u3051d\" (\u3051de)\nlet spos = s.find(\"\u3051d\").unwrap();\nprintln!(\"{}\", s[spos..].chars().take(m).collect::<String>());\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Swift", "code": "\nlet string = \"Hello, Swift language\"\nlet (n, m) = (5, 4)\n\n// Starting from `n` characters in and of `m` length.\ndo {\n  let start = string.startIndex.advancedBy(n)\n  let end = start.advancedBy(m)\n  // Pure-Swift (standard library only):\n  _ = string[start..<end]\n  // With Apple's Foundation framework extensions:\n  string.substringWithRange(start..<end)\n}\n\n// Starting from `n` characters in, up to the end of the string.\ndo {\n  // Pure-Swift (standard library only):\n  _ = String(\n    string.characters.suffix(string.characters.count - n)\n  )\n  // With Apple's Foundation framework extensions:\n  _ = string.substringFromIndex(string.startIndex.advancedBy(n))\n}\n\n// Whole string minus last character.\ndo {\n  // Pure-Swift (standard library only):\n  _ = String(\n    string.characters.prefix(\n      string.characters.count.predecessor()\n    )\n  )\n  // With Apple's Foundation framework extensions:\n  _ = string.substringToIndex(string.endIndex.predecessor())\n}\n\n// Starting from a known character within the string and of `m` length.\ndo {\n  // Pure-Swift (standard library only):\n  let character = Character(\"l\")\n  guard let characterIndex = string.characters.indexOf(character) else {\n    fatalError(\"Index of '\\(character)' character not found.\")\n  }\n  let endIndex = characterIndex.advancedBy(m)\n  _ = string[characterIndex..<endIndex]\n}\n\n// Starting from a known substring within the string and of `m` length.\ndo {\n  // With Apple's Foundation framework extensions:\n  let substring = \"Swift\"\n  guard let range = string.rangeOfString(substring) else {\n    fatalError(\"Range of substring \\(substring) not found\")\n  }\n  let start = range.startIndex\n  let end = start.advancedBy(m)\n  string[start..<end]\n}\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "R", "code": "\ns <- \"abcdefgh\"\nn <- 2; m <- 2; char <- 'd'; chars <- 'cd'\nsubstring(s, n, n + m)\nsubstring(s, n)\nsubstring(s, 1, nchar(s)-1)\nindx <- which(strsplit(s, '')[[1]] %in% strsplit(char, '')[[1]])\nsubstring(s, indx, indx + m)\nindx <- which(strsplit(s, '')[[1]] %in% strsplit(chars, '')[[1]])[1]\nsubstring(s, indx, indx + m)\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "COBOL", "code": "\n       identification division.\n       program-id. substring.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       data division.\n       working-storage section.\n       01 original.\n          05 value \"this is a string\".\n       01 starting  pic 99 value 3.\n       01 width     pic 99 value 8.\n       01 pos       pic 99.\n       01 ender     pic 99.\n       01 looking   pic 99.\n       01 indicator pic x.\n          88 found  value high-value when set to false is low-value.\n       01 look-for  pic x(8).\n\n       procedure division.\n       substring-main.\n\n       display \"Original |\" original \"|, n = \" starting \" m = \" width\n       display original(starting : width)\n       display original(starting :)\n       display original(1 : length(original) - 1)\n\n       move \"a\" to look-for\n       move 1 to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n\n       move \"is a st\" to look-for\n       move length(trim(look-for)) to looking\n       perform find-position\n       if found\n           display original(pos : width)\n       end-if\n       goback.\n\n       find-position.\n       set found to false\n       compute ender = length(original) - looking\n       perform varying pos from 1 by 1 until pos > ender\n           if original(pos : looking) equal look-for then\n               set found to true\n               exit perform\n           end-if\n       end-perform\n       .\n\n       end program substring.\n\n\nOutput:\nprompt$ cobc -xj substring.cob\nOriginal |this is a string|, n = 03 m = 08\nis is a\nis is a string\nthis is a strin\na string\nis a str\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Ada", "code": "\n\ntype String is array (Positive range <>) of Character;\n\n\nA (<first-index>..<last-index>)\n\n\nwith Ada.Text_IO;        use Ada.Text_IO;\nwith Ada.Strings.Fixed;  use Ada.Strings.Fixed;\n\nprocedure Test_Slices is\n   Str : constant String := \"abcdefgh\";\n   N : constant := 2;\n   M : constant := 3;\nbegin\n   Put_Line (Str (Str'First + N - 1..Str'First + N + M - 2));\n   Put_Line (Str (Str'First + N - 1..Str'Last));\n   Put_Line (Str (Str'First..Str'Last - 1));\n   Put_Line (Head (Tail (Str, Str'Last - Index (Str, \"d\", 1)), M));\n   Put_Line (Head (Tail (Str, Str'Last - Index (Str, \"de\", 1) - 1), M));\nend Test_Slices;\n\n\nOutput:\nbcd\nbcdefgh\nabcdefg\nefg\nfgh\n\n", "explain": "String in Ada is an array of Character elements indexed by Positive:\nSubstring is a first-class object in Ada, an anonymous subtype of String. The language uses the term slice for it. Slices can be retrieved, assigned and passed as a parameter to subprograms in mutable or immutable mode. A slice is specified as:\nA string array in Ada can start with any positive index. This is why the implementation below uses Str'First in all slices, which in this concrete case is 1, but intentionally left in the code because the task refers to N as an offset to the string beginning rather than an index in the string. In Ada it is unusual to deal with slices in such way. One uses plain string index instead.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Julia", "code": "\n\njulia> s = \"abcdefg\"\n\"abcdefg\"\n\njulia> n = 3\n3\n\njulia> s[n:end]\n\"cdefg\"\n\njulia> m=2\n2\n\njulia> s[n:n+m]\n\"cde\"\n\njulia> s[1:end-1]\n\"abcdef\"\n\njulia> s[search(s,'c')]\n'c'\n\njulia> s[search(s,'c'):search(s,'c')+m]\n\"cde\"\n\n", "explain": "By default, the type of the string is infered from its elements. In the example below, the string s is an ASCII string. In order to interpret the string as an UTF8 string with logical access to its argument, one should use\nCharString(\"/\\\u0295\u2022\u1d25\u2022\u0294/\\\"...). Without the CharString declaration, the string is interpreted as an UTF8 string with access through its byte representation.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "SAS", "code": "\ndata _null_;\n   a=\"abracadabra\";\n   b=substr(a,2,3); /* first number is position, starting at 1,\n                       second number is length */\n   put _all_;\nrun;\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    val s = \"0123456789\"\n    val n = 3\n    val m = 4\n    val c = '5'\n    val z = \"12\"\n    var i: Int\n    println(s.substring(n, n + m))\n    println(s.substring(n))\n    println(s.dropLast(1))\n    i = s.indexOf(c)\n    println(s.substring(i, i + m))\n    i = s.indexOf(z)\n    println(s.substring(i, i + m))\n}\n\n\nOutput:\n3456\n3456789\n012345678\n5678\n1234\n\n", "explain": "Strings in Kotlin are 0-indexed:\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Perl", "code": "\nmy $str = 'abcdefgh';\nprint substr($str, 2, 3), \"\\n\"; # Returns 'cde'\nprint substr($str, 2), \"\\n\"; # Returns 'cdefgh'\nprint substr($str, 0, -1), \"\\n\"; #Returns 'abcdefg'\nprint substr($str, index($str, 'd'), 3), \"\\n\"; # Returns 'def'\nprint substr($str, index($str, 'de'), 3), \"\\n\"; # Returns 'def'\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Prolog", "code": "\nWorks with: SWI Prolog version 7\nsubstring_task(Str, N, M, Char, SubStr) :-\n    sub_string(Str, N, M, _, Span),\n    sub_string(Str, N, _, 0, ToEnd),\n    sub_string(Str, 0, _, 1, MinusLast),\n    string_from_substring_to_m(Str, Char, M, FromCharToMth),\n    string_from_substring_to_m(Str, SubStr, M, FromSubToM),\n    maplist( writeln,\n            [ 'from n to m ':Span,\n              'from n to end ': ToEnd,\n              'string minus last char ': MinusLast,\n              'form known char to m ': FromCharToMth,\n              'from known substring to m ': FromSubToM ]).\n\n\nstring_from_substring_to_m(String, Sub, M, FromSubToM) :-\n    sub_string(String, Before, _, _, Sub),\n    sub_string(String, Before, M, _, FromSubToM).\n\n\n?- substring_task(\"abcdefghijk\", 2, 4, \"d\", \"ef\").\nfrom n to m :cdef\nfrom n to end :cdefghijk\nstring minus last char :abcdefghij\nform known char to m :defg\nfrom known substring to m :efgh\ntrue\n\n", "explain": "Running it:\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Lua", "code": "\nstr = \"abcdefghijklmnopqrstuvwxyz\"\nn, m = 5, 15\n\nprint( string.sub( str, n, m ) )    -- efghijklmno\nprint( string.sub( str, n, -1 ) )   -- efghijklmnopqrstuvwxyz\nprint( string.sub( str, 1, -2 ) )   -- abcdefghijklmnopqrstuvwxy\n\npos = string.find( str, \"i\" )\nif pos ~= nil then print( string.sub( str, pos, pos+m ) ) end -- ijklmnopqrstuvwx\n\npos = string.find( str, \"ijk\" )\nif pos ~= nil then print( string.sub( str, pos, pos+m ) ) end-- ijklmnopqrstuvwx \n\n-- Alternative (more modern) notation\n\nprint ( str:sub(n,m) )         -- efghijklmno\nprint ( str:sub(n) )           -- efghijklmnopqrstuvwxyz\nprint ( str:sub(1,-2) )        -- abcdefghijklmnopqrstuvwxy\n\npos = str:find \"i\"\nif pos then print (str:sub(pos,pos+m)) end -- ijklmnopqrstuvwx \n\npos = str:find \"ijk\"\nif pos then print (str:sub(pos,pos+m)) end d-- ijklmnopqrstuvwx\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Scala", "code": "\nLibrary: Scala\nobject Substring {\n  // Ruler             1         2         3         4         5         6\n  //         012345678901234567890123456789012345678901234567890123456789012\n  val str = \"The good life is one inspired by love and guided by knowledge.\"\n  val (n, m) = (21, 16) // An one-liner to set n = 21, m = 16\n\n  // Starting from n characters in and of m length\n  assert(\"inspired by love\" == str.slice(n, n + m))\n  \n  // Starting from n characters in, up to the end of the string\n  assert(\"inspired by love and guided by knowledge.\" == str.drop(n))\n  \n  // Whole string minus last character\n  assert(\"The good life is one inspired by love and guided by knowledge\" == str.init)\n  \n  // Starting from a known character within the string and of m length\n  assert(\"life is one insp\" == str.dropWhile(_\u00a0!= 'l').take(m) )\n  \n  // Starting from a known substring within the string and of m length\n  assert(\"good life is one\" == { val i = str.indexOf(\"good\"); str.slice(i, i + m) })\n  // Alternatively\n  assert(\"good life is one\" == str.drop(str.indexOf(\"good\")).take(m))\n}\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "D", "code": "\nWorks with: D version 2\nimport std.stdio, std.string;\n\nvoid main() {\n    const s = \"the quick brown fox jumps over the lazy dog\";\n    enum n = 5, m = 3;\n\n    writeln(s[n .. n + m]);\n\n    writeln(s[n .. $]);\n\n    writeln(s[0 .. $ - 1]);\n\n    const i = s.indexOf(\"q\");\n    writeln(s[i .. i + m]);\n\n    const j = s.indexOf(\"qu\");\n    writeln(s[j .. j + m]);\n}\n\n\nOutput:\nuic\nuick brown fox jumps over the lazy dog.\nThe quick brown fox jumps over the lazy dog\nqui\nqui\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nStrings[edit]\nWorks with: Haskell version 6.10.4\n\nThe first three tasks are simply:\n*Main> take 3 $ drop 2 \"1234567890\"\n\"345\"\n\n*Main> drop 2 \"1234567890\"\n\"34567890\"\n\n*Main> init \"1234567890\"\n\"123456789\"\n\nThe last two can be formulated with the following function:\nt45 n c s | null sub = []\n          | otherwise = take n. head $ sub\n  where sub = filter(isPrefixOf c) $ tails s\n\n*Main> t45 3 \"4\" \"1234567890\"\n\"456\"\n\n*Main> t45 3 \"45\" \"1234567890\"\n\"456\"\n\n*Main> t45 3 \"31\" \"1234567890\"\n\"\"\nData.Text[edit]\n\nWorks with: Haskell version 8.0.2\n{-# LANGUAGE OverloadedStrings #-}\n\nimport qualified Data.Text as T (Text, take, drop, init, breakOn)\nimport qualified Data.Text.IO as O (putStrLn)\n\nfromMforN :: Int -> Int -> T.Text -> T.Text\nfromMforN n m s = T.take m (T.drop n s)\n\nfromNtoEnd :: Int -> T.Text -> T.Text\nfromNtoEnd = T.drop\n\nallButLast :: T.Text -> T.Text\nallButLast = T.init\n\nfromCharForN, fromStringForN :: Int -> T.Text -> T.Text -> T.Text\nfromCharForN m needle haystack = T.take m $ snd $ T.breakOn needle haystack\n\nfromStringForN = fromCharForN\n\n-- TEST ---------------------------------------------------\nmain :: IO ()\nmain =\n  mapM_\n    O.putStrLn\n    ([ fromMforN 9 10\n     , fromNtoEnd 20\n     , allButLast\n     , fromCharForN 6 \"\u8bdd\"\n     , fromStringForN 6 \"\u5927\u52bf\"\n     ] <*>\n     [\"\u5929\u5730\u4e0d\u4ec1\u4ec1\u8005\u4eba\u4e5f\ud83d\udc12\u8bdd\u8bf4\u5929\u4e0b\u5927\u52bf\u5206\u4e45\u5fc5\u5408\ud83c\udf51\u5408\u4e45\u5fc5\u5206\ud83d\udd25\"])\n\n\nOutput:\n\u8bdd\u8bf4\u5929\u4e0b\u5927\u52bf\u5206\u4e45\u5fc5\u5408\n\u5408\u4e45\u5fc5\u5206\ud83d\udd25\n\u5929\u5730\u4e0d\u4ec1\u4ec1\u8005\u4eba\u4e5f\ud83d\udc12\u8bdd\u8bf4\u5929\u4e0b\u5927\u52bf\u5206\u4e45\u5fc5\u5408\ud83c\udf51\u5408\u4e45\u5fc5\u5206\n\u8bdd\u8bf4\u5929\u4e0b\u5927\u52bf\n\u5927\u52bf\u5206\u4e45\u5fc5\u5408\n", "explain": "A string in Haskell is a list of chars: [Char]\nTesting with an extended set of characters, and using Data.Text functions, including breakOn:\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Scheme", "code": "\nWorks with: Guile\n(define s \"Hello, world!\")\n(define n 5)\n(define m (+ n 6))\n\n(display (substring s n m))\n(newline)\n\n(display (substring s n))\n(newline)\n\n(display (substring s 0 (- (string-length s) 1)))\n(newline)\n\n(display (substring s (string-index s #\\o) m))\n(newline)\n\n(display (substring s (string-contains s \"lo\") m))\n(newline)\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Apex", "code": "\n\nString x = 'testing123';\n//Test1: testing123\nSystem.debug('Test1: ' + x.substring(0,x.length()));\n//Test2: esting123\nSystem.debug('Test2: ' + x.substring(1,x.length()));\n//Test3: testing123\nSystem.debug('Test3: ' + x.substring(0));\n//Test4: 3\nSystem.debug('Test4: ' + x.substring(x.length()-1));\n//Test5: \nSystem.debug('Test5: ' + x.substring(1,1));\n//Test 6: testing123\nSystem.debug('Test6: ' + x.substring(x.indexOf('testing')));\n//Test7: e\nSystem.debug('Test7: ' + x.substring(1,2));\n", "explain": "In Apex, the substring method returns a new String that begins with the character at the specified zero-based startIndex and extends to the end of the String.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n\n# test string\n$s = \"abcdefgh\"\n# test parameters\n$n, $m, $c, $s2 = 2, 3, [char]'d', $s2 = 'cd'\n\n# starting from n characters in and of m length\n# n = 2, m = 3\n$s.Substring($n-1, $m)              # returns 'bcd'\n\n# starting from n characters in, up to the end of the string\n# n = 2\n$s.Substring($n-1)                  # returns 'bcdefgh'\n\n# whole string minus last character\n$s.Substring(0, $s.Length - 1)      # returns 'abcdefg'\n\n# starting from a known character within the string and of m length\n# c = 'd', m =3\n$s.Substring($s.IndexOf($c), $m)    # returns 'def'\n\n# starting from a known substring within the string and of m length\n# s2 = 'cd', m = 3\n$s.Substring($s.IndexOf($s2), $m)   # returns 'cde'\n\n", "explain": "Since .NET and PowerShell use zero-based indexing, all character indexes have to be reduced by one.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Logo", "code": "\nWorks with: UCB Logo\n\nto items :n :thing\n  if :n >= count :thing [output :thing]\n  output items :n butlast :thing\nend\n\nto butitems :n :thing \n  if or :n <= 0 empty? :thing [output :thing]\n  output butitems :n-1 butfirst :thing\nend\n\nto middle :n :m :thing\n  output items :m-(:n-1) butitems :n-1 :thing\nend\n\nto lastitems :n :thing\n  if :n >= count :thing [output :thing]\n output lastitems :n butfirst :thing\nend\n\nto starts.with :sub :thing\n  if empty? :sub [output \"true]\n  if empty? :thing [output \"false]\n  if not equal? first :sub first :thing [output \"false]\n  output starts.with butfirst :sub butfirst :thing\nend\n\nto members :sub :thing\n  output cascade [starts.with :sub\u00a0?] [bf\u00a0?] :thing\nend\n\n; note: Logo indices start at one\nmake \"s \"abcdefgh\nprint items 3 butitems 2 :s\u00a0; cde\nprint middle 3 5  :s  \u00a0; cde\nprint butitems 2  :s  \u00a0; cdefgh\nprint butlast     :s  \u00a0; abcdefg\nprint items 3 member  \"d  :s\u00a0; def\nprint items 3 members \"de :s\u00a0; def\n", "explain": "The following are defined to behave similarly to the built-in index operator ITEM. As with most Logo list operators, these are designed to work for both words (strings) and lists.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\nClassic tag based CFML[edit]\n<cfoutput>\n\t<cfset str = \"abcdefg\">\n\t<cfset n = 2>\n\t<cfset m = 3>\n\n\t<!--- Note: In CF index starts at 1 rather than 0\n\tstarting from n characters in and of m length --->\n\t#mid( str, n, m )#\n\t<!--- starting from n characters in, up to the end of the string --->\n\t<cfset countFromRight = Len( str ) - n + 1>\n\t#right( str, countFromRight )#\n\t<!--- whole string minus last character --->\n\t<cfset allButLast = Len( str ) - 1>\n\t#left( str, allButLast )#\n\t<!--- starting from a known character within the string and of m length --->\n\t<cfset startingIndex = find( \"b\", str )>\n\t#mid( str, startingIndex, m )#\n\t<!--- starting from a known substring within the string and of m length --->\n\t<cfset startingIndexSubString = find( \"bc\", str )>\n\t#mid( str, startingIndexSubString, m )#\n\n</cfoutput>\n\n\nOutput:\nbcd\nbcdefg\nabcdef\nbcd\nbcd\n\nScript Based CFML[edit]\n<cfscript>\n\tstr=\"abcdefg\";\n\tn = 2;\n\tm = 3;\n\n\t// Note: In CF index starts at 1 rather than 0\n\t// starting from n characters in and of m length\n\twriteOutput( mid( str, n, m ) );\n\t// starting from n characters in, up to the end of the string\n\tcountFromRight = Len( str ) - n + 1;\n\twriteOutput( right( str, countFromRight ) );\n\t// whole string minus last character\n\tallButLast = Len( str ) - 1;\n\twriteOutput( left( str, allButLast ) );\n\t// starting from a known character within the string and of m length\n\tstartingIndex = find( \"b\", str );\n\twriteOutput( mid( str, startingIndex, m ) );\n\t// starting from a known substring within the string and of m length\n\tstartingIndexSubString = find( \"bc\", str );\n\twriteOutput( mid( str, startingIndexSubString, m ) );\n</cfscript>\n\n\nOutput:\nbcd\nbcdefg\nabcdef\nbcd\nbcd\n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "F#", "code": "\n[<EntryPoint>]\nlet main args =\n    let s = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\n    let n, m  = 3, 2\n    let c = '\u516d'\n    let z = \"\u516d\u4e03\u516b\"\n\n    printfn \"%s\" (s.Substring(n, m))\n    printfn \"%s\" (s.Substring(n))\n    printfn \"%s\" (s.Substring(0, s.Length - 1))\n    printfn \"%s\" (s.Substring(s.IndexOf(c), m))\n    printfn \"%s\" (s.Substring(s.IndexOf(z), m))\n    0\n\n\nOutput:\n\u56db\u4e94\n\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\n\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\n\u516d\u4e03\n\u516d\u4e03\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\ndef str = 'abcdefgh'\ndef n = 2\ndef m = 3\n// #1\nprintln str[n..n+m-1]\n/* or */\nprintln str[n..<(n+m)]\n// #2\nprintln str[n..-1]\n// #3\nprintln str[0..-2]\n// #4\ndef index1 = str.indexOf('d')\nprintln str[index1..index1+m-1]\n/* or */\nprintln str[index1..<(index1+m)]\n// #5\ndef index2 = str.indexOf('de')\nprintln str[index2..index2+m-1]\n/* or */\nprintln str[index2..<(index2+m)]\n\n", "explain": "Strings in Groovy are 0-indexed.\n"}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "RPG", "code": "\n      *                                         1...5....1....5....2....5..    \n     D myString        S             30    inz('Liebe bewegt das Universum!')  \n     D output          S             30    inz('')                             \n     D n               S              2  0 inz(1)                              \n     D m               S              2  0 inz(5)                              \n     D length          S              2  0 inz(0)                              \n     D find            S              2  0 inz(0)                              \n                                                                               \n      /free                                                                    \n       *inlr = *on;                                                           \n        dsply    %subst(myString:n:m);                   \n        dsply    %subst(myString:7:20);                  \n                                                         \n        length = %len(%trim(myString));                  \n        dsply    %subst(myString:1:length-1);            \n                                                         \n        find   = %scan('U':myString);                    \n        dsply    %subst(myString:find:9);                \n                                                         \n        find   = %scan('bewegt':myString);               \n        dsply    %subst(myString:find:%len('bewegt'));   \n                                                         \n        output = ' *** end *** ';                        \n        dsply ' ' ' ' output;                            \n      /end-free\n\nOutput:\nDSPLY  Liebe                     \nDSPLY  bewegt das Universum      \nDSPLY  Liebe bewegt das Universum\nDSPLY  Universum                 \nDSPLY  bewegt                                   \n\n", "explain": ""}, {"task_name": "Substring", "task_url": "https://rosettacode.org/wiki/Substring", "task_cat": "String manipulation", "lang": "AWK", "code": "\nTranslation of: AutoHotKey\nBEGIN {\n\tstr = \"abcdefghijklmnopqrstuvwxyz\"\n\tn = 12\n\tm = 5\n\n\tprint substr(str, n, m)\n\tprint substr(str, n)\n\tprint substr(str, 1, length(str) - 1)\n\tprint substr(str, index(str, \"q\"), m)\n\tprint substr(str, index(str, \"pq\"), m)\n}\n\n\nOutput:\n$ awk -f substring.awk  \nlmnop\nlmnopqrstuvwxyz\nabcdefghijklmnopqrstuvwxy\nqrstu\npqrst\n", "explain": ""}]