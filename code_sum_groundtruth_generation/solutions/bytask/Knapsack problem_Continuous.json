[{"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\n#        NAME, WEIGHT, VALUE (for this weight)\nitems = [(\"beef\",    3.8, 36.0),\n         (\"pork\",    5.4, 43.0),\n         (\"ham\",     3.6, 90.0),\n         (\"greaves\", 2.4, 45.0),\n         (\"flitch\",  4.0, 30.0),\n         (\"brawn\",   2.5, 56.0),\n         (\"welt\",    3.7, 67.0),\n         (\"salami\",  3.0, 95.0),\n         (\"sausage\", 5.9, 98.0)]\n\nMAXWT = 15.0\n\nsorted_items = sorted(((value/amount, amount, name)\n                       for name, amount, value in items),\n                      reverse = True)\nwt = val = 0\nbagged = []\nfor unit_value, amount, name in sorted_items:\n    portion = min(MAXWT - wt, amount)\n    wt     += portion\n    addval  = portion * unit_value\n    val    += addval\n    bagged += [(name, portion, addval)]\n    if wt >= MAXWT:\n        break\n\nprint(\"    ITEM   PORTION VALUE\")\nprint(\"\\n\".join(\"%10s %6.2f %6.2f\" % item for item in bagged))\nprint(\"\\nTOTAL WEIGHT: %5.2f\\nTOTAL VALUE: %5.2f\" % (wt, val))\n\n\n    ITEM   PORTION VALUE\n    salami   3.00  95.00\n       ham   3.60  90.00\n     brawn   2.50  56.00\n   greaves   2.40  45.00\n      welt   3.50  63.38\n\nTOTAL WEIGHT: 15.00\nTOTAL VALUE: 349.38\n", "explain": "I think this greedy algorithm of taking the largest amounts of items ordered by their value per unit weight is maximal:\nSample Output\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct item { double w, v; const char *name; } items[] = {\n\t{ 3.8, 36, \"beef\" },\n\t{ 5.4, 43, \"pork\" },\n\t{ 3.6, 90, \"ham\" },\n\t{ 2.4, 45, \"greaves\" },\n\t{ 4.0, 30, \"flitch\" },\n\t{ 2.5, 56, \"brawn\" },\n\t{ 3.7, 67, \"welt\" },\n\t{ 3.0, 95, \"salami\" },\n\t{ 5.9, 98, \"sausage\" },\n};\n\nint item_cmp(const void *aa, const void *bb)\n{\n\tconst struct item *a = aa, *b = bb;\n\tdouble ua = a->v / a->w, ub = b->v / b->w;\n\treturn ua < ub ? -1 : ua > ub;\n}\n\nint main()\n{\n\tstruct item *it;\n\tdouble space = 15;\n\n\tqsort(items, 9, sizeof(struct item), item_cmp);\n\tfor (it = items + 9; it---items && space > 0; space -= it->w)\n\t\tif (space >= it->w)\n\t\t\tprintf(\"take all %s\\n\", it->name);\n\t\telse\n\t\t\tprintf(\"take %gkg of %g kg of %s\\n\",\n\t\t\t\tspace, it->w, it->name);\n\n\treturn 0;\n}\noutputtake all salami\ntake all ham\ntake all brawn\ntake all greaves\ntake 3.5kg of 3.7 kg of welt\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include<iostream>\n#include<algorithm>\n#include<string.h>\n\nusing namespace std;\ndouble result;\ndouble capacity = 15;\nint NumberOfItems;\nint number;\n\nstruct items\n{\n    char name[32];\n    double weight;\n    double price;\n    double m;\n} item[256];\n\nbool cmp(items a,items b)\n{\n    return a.price/a.weight > b.price/b.weight; // the compare function for the sorting algorithm\n}\n\nint main()\n{\nNumberOfItems=9;\nstrcpy(item[1].name,\"beef\");\nitem[1].weight=3.8;\nitem[1].price=36;\n\nstrcpy(item[2].name,\"pork\");\nitem[2].weight=5.4;\nitem[2].price=43;\n\nstrcpy(item[3].name,\"ham\");\nitem[3].weight=3.6;\nitem[3].price=90;\n\nstrcpy(item[4].name,\"greaves\");\nitem[4].weight=2.4;\nitem[4].price=45;\n\nstrcpy(item[5].name,\"flitch\");\nitem[5].weight=4.0;\nitem[5].price=30;\n\nstrcpy(item[6].name,\"brawn\");\nitem[6].weight=2.5;\nitem[6].price=56;\n\nstrcpy(item[7].name,\"welt\");\nitem[7].weight=3.7;\nitem[7].price=67;\n\nstrcpy(item[8].name,\"salami\");\nitem[8].weight=3.0;\nitem[8].price=95;\n\nstrcpy(item[9].name,\"sausage\");\nitem[9].weight=5.9;\nitem[9].price=98;\n\n\nsort(item+1,item+NumberOfItems+1,cmp); // We'll sort using Introsort from STL\n\n number = 1;\n while(capacity>0&&number<=NumberOfItems)\n {\n  if(item[number].weight<=capacity)\n    {\n        result+=item[number].price;\n        capacity-=item[number].weight;\n        item[number].m=1;\n    }\n  else\n  {\n      result+=(item[number].price)*(capacity/item[number].weight);\n      item[number].m=(capacity/item[number].weight);\n      capacity=0;\n\n  }\n  ++number;\n }\n\ncout<<\"Total Value = \"<<result<<'\\n';\ncout<<\"Total Weight = \"<<(double)15-capacity<<'\\n';\ncout<<\"Items Used:\\n\";\nfor(int i=1;i<=NumberOfItems;++i)\n    if(item[i].m)\n    {\n       cout<<\"We took \"<<item[i].m*item[i].weight<<\"kg of \\\"\"<<item[i].name<<\"\\\" and the value it brought is \"<<item[i].price*item[i].m<<\"\\n\";\n    }\n\nreturn 0;\n}\n\n\nOutput:\nTotal Value = 349.378\nTotal Weight = 15\nItems Used:\nWe took 3kg of \"salami\" and the value it brought is 95\nWe took 3.6kg of \"ham\" and the value it brought is 90\nWe took 2.5kg of \"brawn\" and the value it brought is 56\nWe took 2.4kg of \"greaves\" and the value it brought is 45\nWe took 3.5kg of \"welt\" and the value it brought is 63.3784\n\nAlternate Version[edit]\n// C++11 version\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <string>\n\nusing namespace std;\n\nstruct item_type\n{\n    double  weight, value;\n    string  name;\n};\n\nvector< item_type > items =\n{\n    { 3.8, 36, \"beef\"    },\n    { 5.4, 43, \"pork\"    },\n    { 3.6, 90, \"ham\"     },\n    { 2.4, 45, \"greaves\" },\n    { 4.0, 30, \"flitch\"  },\n    { 2.5, 56, \"brawn\"   },\n    { 3.7, 67, \"welt\"    },\n    { 3.0, 95, \"salami\"  },\n    { 5.9, 98, \"sausage\" }\n};\n \nint main()\n{\n    sort\n    ( \n        begin( items ), end( items ),\n        [] (const item_type& a, const item_type& b)\n        {\n            return a.value / a.weight > b.value / b.weight;\n        }\n    );\n\n    double space = 15;\n\n    for ( const auto& item : items )\n    {\n        if ( space >= item.weight )\n            cout << \"Take all \" << item.name << endl;\n        else \n        {\n            cout << \"Take \" << space << \"kg of \" << item.name << endl;\n            break;\n        }\n            \n        space -= item.weight;\n    }\n}\n\n\nOutput:\nTake all salami\nTake all ham\nTake all brawn\nTake all greaves\nTake 3.5kg of welt\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npackage hu.pj.alg.test;\n\nimport hu.pj.alg.ContinuousKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class ContinousKnapsackForRobber {\n    final private double tolerance = 0.0005;\n\n    public ContinousKnapsackForRobber() {\n        ContinuousKnapsack cok = new ContinuousKnapsack(15); // 15 kg\n\n        // making the list of items that you want to bring\n        cok.add(\"beef\",     3.8, 36); // marhah\u00fas\n        cok.add(\"pork\",     5.4, 43); // diszn\u00f3h\u00fas\n        cok.add(\"ham\",      3.6, 90); // sonka\n        cok.add(\"greaves\",  2.4, 45); // tepert\u0151\n        cok.add(\"flitch\",   4.0, 30); // oldalas\n        cok.add(\"brawn\",    2.5, 56); // diszn\u00f3sajt\n        cok.add(\"welt\",     3.7, 67); // hurka\n        cok.add(\"salami\",   3.0, 95); // szal\u00e1mi\n        cok.add(\"sausage\",  5.9, 98); // kolb\u00e1sz\n\n        // calculate the solution:\n        List<Item> itemList = cok.calcSolution();\n\n        // write out the solution in the standard output\n        if (cok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(cok.getMaxWeight()) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(cok.getSolutionWeight()) + \" kg\"\n            );\n            System.out.println(\n                \"Total value (profit)     = \" +\n                nf.format(cok.getProfit())\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry the following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > tolerance) {\n                    System.out.format(\n                        \"%1$-10s %2$-15s %3$-15s \\n\",\n                        nf.format(item.getInKnapsack()) + \" kg \",\n                        item.getName(),\n                        \"(value = \" + nf.format(item.getInKnapsack() *\n                                                (item.getValue() / item.getWeight())) + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ContinousKnapsackForRobber();\n    }\n\n} // class\n\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.util.*;\n\npublic class ContinuousKnapsack {\n\n    protected List<Item> itemList   = new ArrayList<Item>();\n    protected double maxWeight      = 0;\n    protected double solutionWeight = 0;\n    protected double profit         = 0;\n    protected boolean calculated    = false;\n\n    public ContinuousKnapsack() {}\n\n    public ContinuousKnapsack(double _maxWeight) {\n        setMaxWeight(_maxWeight);\n    }\n\n    public List<Item> calcSolution() {\n        int n = itemList.size();\n\n        setInitialStateForCalculation();\n        if (n > 0  &&  maxWeight > 0) {\n            Collections.sort(itemList);\n            for (int i = 0; (maxWeight - solutionWeight) > 0.0  &&  i < n; i++) {\n                Item item = itemList.get(i);\n                if (item.getWeight() >= (maxWeight - solutionWeight)) {\n                    item.setInKnapsack(maxWeight - solutionWeight);\n                    solutionWeight = maxWeight;\n                    profit += item.getInKnapsack() / item.getWeight() * item.getValue();\n                    break;\n                } else {\n                    item.setInKnapsack(item.getWeight());\n                    solutionWeight += item.getInKnapsack();\n                    profit += item.getValue();\n                }\n            }\n            calculated = true;\n        }\n        \n        return itemList;\n    }\n\n    // add an item to the item list\n    public void add(String name, double weight, double value) {\n        if (name.equals(\"\"))\n            name = \"\" + (itemList.size() + 1);\n        itemList.add(new Item(name, weight, value));\n        setInitialStateForCalculation();\n    }\n\n    public double getMaxWeight() {return maxWeight;}\n    public double getProfit() {return profit;}\n    public double getSolutionWeight() {return solutionWeight;}\n    public boolean isCalculated() {return calculated;}\n\n    public void setMaxWeight(double _maxWeight) {\n        maxWeight = Math.max(_maxWeight, 0);\n    }\n\n    // set the member with name \"inKnapsack\" by all items:\n    private void setInKnapsackByAll(double inKnapsack) {\n        for (Item item : itemList)\n            item.setInKnapsack(inKnapsack);\n    }\n\n    // set the data members of class in the state of starting the calculation:\n    protected void setInitialStateForCalculation() {\n        setInKnapsackByAll(-0.0001);\n        calculated     = false;\n        profit         = 0.0;\n        solutionWeight = 0.0;\n    }\n\n} // class\n\npackage hu.pj.obj;\n\npublic class Item implements Comparable {\n\n    protected String name       = \"\";\n    protected double weight     = 0;\n    protected double value      = 0;\n    protected double inKnapsack = 0; // the weight of item in solution\n\n    public Item() {}\n\n    public Item(Item item) {\n        setName(item.name);\n        setWeight(item.weight);\n        setValue(item.value);\n    }\n\n    public Item(double _weight, double _value) {\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(String _name, double _weight, double _value) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public void setName(String _name) {name = _name;}\n    public void setWeight(double _weight) {weight = Math.max(_weight, 0);}\n    public void setValue(double _value) {value = Math.max(_value, 0);}\n\n    public void setInKnapsack(double _inKnapsack) {\n        inKnapsack = Math.max(_inKnapsack, 0);\n    }\n\n    public void checkMembers() {\n        setWeight(weight);\n        setValue(value);\n        setInKnapsack(inKnapsack);\n    }\n\n    public String getName() {return name;}\n    public double getWeight() {return weight;}\n    public double getValue() {return value;}\n    public double getInKnapsack() {return inKnapsack;}\n\n    // implementing of Comparable interface:\n    public int compareTo(Object item) {\n        int result = 0;\n        Item i2 = (Item)item;\n        double rate1 = value / weight;\n        double rate2 = i2.value / i2.weight;\n        if (rate1 > rate2) result = -1;  // if greater, put it previously\n        else if (rate1 < rate2) result = 1;\n        return result;\n    }\n\n} // class\n\n\nMaximal weight           = 15 kg\nTotal weight of solution = 15 kg\nTotal value (profit)     = 349,378\n\nYou can carry the following materials in the knapsack:\n3 kg       salami          (value = 95)    \n3,6 kg     ham             (value = 90)    \n2,5 kg     brawn           (value = 56)    \n2,4 kg     greaves         (value = 45)    \n3,5 kg     welt            (value = 63,378)\n", "explain": "Greedy solution.\noutput:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nusing System;  //4790@3.6\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(knapSack(15) + \"\\n\");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) knapSack(15);\n        Console.Write(sw.Elapsed); Console.Read();    // 0.60 \u00b5s\n    }\n\n    static string knapSack(double w1)\n    {\n        int k = w.Length; var q = new double[k];\n        for (int i = 0; i < k; ) q[i] = v[i] / w[i++];\n        var c = new double[k];\n        Array.Copy(q, c, k); Array.Sort(c, w);\n        Array.Copy(q, c, k); Array.Sort(c, v);\n        Array.Sort(q, items);\n        string str = \"\";\n        for (k--; k >= 0; k--)\n            if (w1 - w[k] > 0) { w1 -= w[k]; str += items[k] + \"\\n\"; }\n            else break;\n        return w1 > 0 && k >= 0 ? str + items[k] : str;\n    }\n\n    static double[] w = { 3.8, 5.4, 3.6, 2.4, 4.0, 2.5, 3.7, 3.0, 5.9 },\n\n                    v = { 36, 43, 90, 45, 30, 56, 67, 95, 98 };\n\n    static string[] items = {\"beef\",\"pork\",\"ham\",\"greaves\",\"flitch\",\n                             \"brawn\",\"welt\",\"salami\",\"sausage\"};\n}\n\n\nusing System;\nclass Program\n{\n    static void Main()\n    {\n        Console.WriteLine(knapSack(15) + \"\\n\");\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) knapSack(15);\n        Console.Write(sw.Elapsed); Console.Read();    // 0.37 \u00b5s\n    }\n\n    static string knapSack(double w1)\n    {\n        int i = 0, k = w.Length; var idx = new int[k];\n        {\n            var q = new double[k];\n            while (i < k) q[i] = v[i] / w[idx[i] = i++];\n            Array.Sort(q, idx);\n        }\n        string str = \"\";\n        for (k--; k >= 0; k--)\n            if (w1 > w[i = idx[k]]) { w1 -= w[i]; str += items[i] + \"\\n\"; }\n            else break;\n        return w1 > 0 && k >= 0 ? str + items[idx[k]] : str;\n    }\n\n    static double[] w = { 3.8, 5.4, 3.6, 2.4, 4.0, 2.5, 3.7, 3.0, 5.9 },\n\n                    v = { 36, 43, 90, 45, 30, 56, 67, 95, 98 };\n\n    static string[] items = {\"beef\",\"pork\",\"ham\",\"greaves\",\"flitch\",\n                             \"brawn\",\"welt\",\"salami\",\"sausage\"};\n}\n\n", "explain": "Sorting three times is expensive,\nan alternative is sorting once, with an indices array.\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n/* Added by @1x24. Translated from C++. Uses the PHP 7.x spaceship operator */\n$data = [\n\t\t\t[\n\t\t\t\t'name'=>'beef',\n\t\t\t\t'weight'=>3.8,\n\t\t\t\t'cost'=>36,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'pork',\n\t\t\t\t'weight'=>5.4,\n\t\t\t\t'cost'=>43,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'ham',\n\t\t\t\t'weight'=>3.6,\n\t\t\t\t'cost'=>90,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'greaves',\n\t\t\t\t'weight'=>2.4,\n\t\t\t\t'cost'=>45,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'flitch',\n\t\t\t\t'weight'=>4.0,\n\t\t\t\t'cost'=>30,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'brawn',\n\t\t\t\t'weight'=>2.5,\n\t\t\t\t'cost'=>56,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'welt',\n\t\t\t\t'weight'=>3.7,\n\t\t\t\t'cost'=>67,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'salami',\n\t\t\t\t'weight'=>3.0,\n\t\t\t\t'cost'=>95,\n\t\t\t],\n\t\t\t[\n\t\t\t\t'name'=>'sausage',\n\t\t\t\t'weight'=>5.9,\n\t\t\t\t'cost'=>98,\n\t\t\t],\n\t\t];\n\nuasort($data, function($a, $b) {\n    return ($b['cost']/$b['weight']) <=> ($a['cost']/$a['weight']);\n});\n\n$limit = 15;\n\nforeach ($data as $item):\n\tif ($limit >= $item['weight']):\n\t\techo \"Take all the {$item['name']}<br/>\";\n\telse:\n\t\techo \"Take $limit kg of {$item['name']}<br/>\";\n\t\tbreak;\n\tendif;\n\t$limit -= $item['weight'];\nendforeach;\n\n\nTake all the salami\nTake all the ham\nTake all the brawn\nTake all the greaves\nTake 3.5 kg of welt\n", "explain": "Output:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram KNAPSACK_CONTINUOUS\n  implicit none\n \n  real, parameter :: maxweight = 15.0\n  real :: total_weight = 0, total_value = 0, frac\n  integer :: i, j\n  \n  type Item\n    character(7) :: name\n    real :: weight\n    real :: value\n  end type Item\n\n  type(Item) :: items(9), temp\n  \n  items(1) = Item(\"beef\",    3.8, 36.0)\n  items(2) = Item(\"pork\",    5.4, 43.0)\n  items(3) = Item(\"ham\",     3.6, 90.0)\n  items(4) = Item(\"greaves\", 2.4, 45.0)\n  items(5) = Item(\"flitch\",  4.0, 30.0)\n  items(6) = Item(\"brawn\",   2.5, 56.0)\n  items(7) = Item(\"welt\",    3.7, 67.0)\n  items(8) = Item(\"salami\",  3.0, 95.0)\n  items(9) = Item(\"sausage\", 5.9, 98.0)\n\n  ! sort items in descending order of their value per unit weight\n  do i = 2, size(items)\n     j = i - 1\n     temp = items(i)\n     do while (j>=1 .and. items(j)%value / items(j)%weight < temp%value / temp%weight)\n       items(j+1) = items(j)\n       j = j - 1\n     end do\n    items(j+1) = temp\n  end do\n \n  i = 0\n  write(*, \"(a4, a13, a6)\") \"Item\", \"Weight\", \"Value\"\n  do while(i < size(items) .and. total_weight < maxweight)\n    i = i + 1\n    if(total_weight+items(i)%weight < maxweight) then\n      total_weight = total_weight + items(i)%weight\n      total_value = total_value + items(i)%value\n      write(*, \"(a7, 2f8.2)\") items(i)\n    else\n      frac = (maxweight-total_weight) / items(i)%weight\n      total_weight = total_weight + items(i)%weight * frac\n      total_value = total_value + items(i)%value * frac\n      write(*, \"(a7, 2f8.2)\") items(i)%name, items(i)%weight * frac, items(i)%value * frac\n    end if \n  end do\n\n  write(*, \"(f15.2, f8.2)\") total_weight, total_value\n \nend program KNAPSACK_CONTINUOUS\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype item struct {\n    item   string\n    weight float64\n    price  float64\n}\n\ntype items []item\n\nvar all = items{\n    {\"beef\", 3.8, 36},\n    {\"pork\", 5.4, 43},\n    {\"ham\", 3.6, 90},\n    {\"greaves\", 2.4, 45},\n    {\"flitch\", 4.0, 30},\n    {\"brawn\", 2.5, 56},\n    {\"welt\", 3.7, 67},\n    {\"salami\", 3.0, 95},\n    {\"sausage\", 5.9, 98},\n}\n\n// satisfy sort interface\nfunc (z items) Len() int      { return len(z) }\nfunc (z items) Swap(i, j int) { z[i], z[j] = z[j], z[i] }\nfunc (z items) Less(i, j int) bool {\n    return z[i].price/z[i].weight > z[j].price/z[j].weight\n}\n\nfunc main() {\n    left := 15.\n    sort.Sort(all)\n    for _, i := range all {\n        if i.weight <= left {\n            fmt.Println(\"take all the\", i.item)\n            if i.weight == left {\n                return\n            }\n            left -= i.weight\n        } else {\n            fmt.Printf(\"take\u00a0%.1fkg %s\\n\", left, i.item)\n            return\n        }\n    }\n}\n\n\ntake all the salami\ntake all the ham\ntake all the brawn\ntake all the greaves\ntake 3.5kg welt\n\n", "explain": "Output:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\n{Structure to hold the data}\n\ntype TButcherInfo = record\n Name: string;\n Weight,Cost,PerKG: double;\n end;\ntype PButcherInfo = ^TButcherInfo;\n\n{Array of actual data}\n\nvar Items: array [0..8] of TButcherInfo =(\n\t(Name: 'beef';    Weight: 3.8; Cost: 36.0),\n\t(Name: 'pork';    Weight: 5.4; Cost: 43.0),\n\t(Name: 'ham';     Weight: 3.6; Cost: 90.0),\n\t(Name: 'greaves'; Weight: 2.4; Cost: 45.0),\n\t(Name: 'flitch';  Weight: 4.0; Cost: 30.0),\n\t(Name: 'brawn';   Weight: 2.5; Cost: 56.0),\n\t(Name: 'welt';    Weight: 3.7; Cost: 67.0),\n\t(Name: 'salami';  Weight: 3.0; Cost: 95.0),\n\t(Name: 'sausage'; Weight: 5.9; Cost: 98.0)\n\t);\n\n\nfunction CompareButcher(List: TStringList; Index1, Index2: Integer): Integer;\n{Compare routine to sort by Per Kilograph cost}\nvar Info1,Info2: TButcherInfo;\nbegin\nInfo1:=PButcherInfo(List.Objects[Index1])^;\nInfo2:=PButcherInfo(List.Objects[Index2])^;\nResult:=Trunc(Info2.PerKG * 100 - Info1.PerKG * 100);\nend;\n\n\nprocedure KnapsackProblem(Memo: TMemo);\n{Solve the knapsack problem}\nvar SL: TStringList;\nvar I,Inx: integer;\nvar Info: TButcherInfo;\nvar Weight,Cost,Diff: double;\nconst Limit = 15;\nbegin\nSL:=TStringList.Create;\ntry\n{Calculate the per Kilogram cost for each item}\nfor I:=0 to High(Items) do\n\tbegin\n\tItems[I].PerKG:=Items[I].Cost/Items[I].Weight;\n\tSL.AddObject(Items[I].Name,@Items[I]);\n\tend;\n{Sort most expensive items to top of list}\nSL.CustomSort(CompareButcher);\n\n{Take the most expensive items }\nWeight:=0; Cost:=0;\nfor I:=0 to SL.Count-1 do\n\tbegin\n\tInfo:=PButcherInfo(SL.Objects[I])^;\n\t{Item exceeds the weight limit? }\n\tif (Weight+Info.Weight)>=Limit then\n\t\tbegin\n\t\t{Calculate percent to fill gap}\n\t\tDiff:=(Limit-Weight)/Info.Weight;\n\t\t{Save index}\n\t\tInx:=I;\n\t\tbreak;\n\t\tend\n\telse\n\t\tbegin\n\t\t{Add up totals}\n\t\tWeight:=Weight+Info.Weight;\n\t\tCost:=Cost+Info.Cost;\n\t\tend;\n\tend;\n\n{Display all items}\nMemo.Lines.Add('Item      Portion    Value');\nMemo.Lines.Add('--------------------------');\nfor I:=0 to Inx-1 do\n\tbegin\n\tInfo:=PButcherInfo(SL.Objects[I])^;\n\tMemo.Lines.Add(Format('%-8s %8.2f %8.2f',[Info.Name,Info.Weight,Info.Cost]));\n\tend;\nInfo:=PButcherInfo(SL.Objects[Inx])^;\n{Calculate cost and weight to fill gap}\nweight:=Weight+Info.Weight*Diff;\nCost:=Cost+Info.Cost*Diff;\n{Display gap filling item}\nMemo.Lines.Add(Format('%-8s %8.2f %8.2f',[Info.Name,Info.Weight*Diff,Info.Cost*Diff]));\nMemo.Lines.Add('--------------------------');\nMemo.Lines.Add(Format('Totals   %8.2f %8.2f',[Weight,Cost]));\nfinally SL.Free; end;\nend;\n\n\nOutput:\nItem      Portion    Value\n--------------------------\nsalami       3.00    95.00\nham          3.60    90.00\nbrawn        2.50    56.00\ngreaves      2.40    45.00\nwelt         3.50    63.38\n--------------------------\nTotals      15.00   349.38\n\nElapsed Time: 10.998 ms.\n\n\n\n", "explain": "\n\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nitems = [ [:beef   , 3.8, 36],\n          [:pork   , 5.4, 43],\n          [:ham    , 3.6, 90],\n          [:greaves, 2.4, 45],\n          [:flitch , 4.0, 30],\n          [:brawn  , 2.5, 56],\n          [:welt   , 3.7, 67],\n          [:salami , 3.0, 95],\n          [:sausage, 5.9, 98] ].sort_by{|item, weight, price| -price / weight}\nmaxW, value = 15.0, 0\nitems.each do |item, weight, price|\n  if (maxW -= weight) > 0\n    puts \"Take all #{item}\"\n    value += price\n  else\n    puts \"Take %gkg of %s\" % [t=weight+maxW, item], \"\",\n         \"Total value of swag is %g\" % (value+(price/weight)*t)\n    break\n  end\nend\n\n\nOutput:\nTake all salami\nTake all ham\nTake all brawn\nTake all greaves\nTake 3.5kg of welt\n\nTotal value of swag is 349.378\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nfn main() {\n    let items: [(&str, f32, u8); 9] = [\n        (\"beef\", 3.8, 36),\n        (\"pork\", 5.4, 43),\n        (\"ham\", 3.6, 90),\n        (\"greaves\", 2.4, 45),\n        (\"flitch\", 4.0, 30),\n        (\"brawn\", 2.5, 56),\n        (\"welt\", 3.7, 67),\n        (\"salami\", 3.0, 95),\n        (\"sausage\", 5.9, 98),\n    ];\n    let mut weight: f32 = 15.0;\n    let mut values: Vec<(&str, f32, f32)> = Vec::new();\n    for item in &items {\n        values.push((item.0, f32::from(item.2) / item.1, item.1));\n    }\n\n    values.sort_by(|a, b| (a.1).partial_cmp(&b.1).unwrap());\n    values.reverse();\n\n    for choice in values {\n        if choice.2 <= weight {\n            println!(\"Grab {:.1} kgs of {}\", choice.2, choice.0);\n            weight -= choice.2;\n            if (choice.2 - weight).abs() < std::f32::EPSILON {\n                return;\n            }\n        } else {\n            println!(\"Grab {:.1} kgs of {}\", weight, choice.0);\n            return;\n        }\n    }\n}\n Output:Grab 3.0 kgs of salami\nGrab 3.6 kgs of ham\nGrab 2.5 kgs of brawn\nGrab 2.4 kgs of greaves\nGrab 3.5 kgs of welt\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nknapsack<- function(Value, Weight, Objects, Capacity){\n  Fraction = rep(0, length(Value))\n  Cost = Value/Weight\n  #print(Cost)\n  W = Weight[order(Cost, decreasing = TRUE)]\n  Obs = Objects[order(Cost, decreasing = TRUE)]\n  Val = Value[order(Cost, decreasing = TRUE)]\n  #print(W)\n  RemainCap = Capacity\n  i = 1\n  n = length(Cost)\n  if (W[1] <= Capacity){\n    Fits <- TRUE\n  }\n  else{\n    Fits <- FALSE \n  }\n  while (Fits && i <= n ){\n    Fraction[i] <- 1\n    RemainCap <- RemainCap - W[i]\n    i <- i+1\n    #print(RemainCap)\n    if (W[i] <= RemainCap){\n      Fits <- TRUE\n    }\n    else{\n      Fits <- FALSE\n    }\n  }\n  #print(RemainCap)\n  if (i <= n){\n    Fraction[i] <- RemainCap/W[i]\n  }\n  names(Fraction) = Obs\n  Quantity_to_take = W*Fraction\n  Total_Value = sum(Val*Fraction)\n  print(\"Fraction of available quantity to take:\")\n  print(round(Fraction, 3))\n  print(\"KG of each to take:\")\n  print(Quantity_to_take)\n  print(\"Total value of tasty meats:\")\n  print(Total_Value)\n}\n\n\no = c(\"beef\", \"pork\", \"ham\", \"greaves\", \"flitch\", \"brawn\", \"welt\", \"salami\", \"sausage\")\nw = c(3.8,5.4,3.6,2.4,4.0,2.5,3.7,3.0,5.9)\nv = c(36,43,90,45,30,56,67,95,98)\nknapsack(v, w, o, 15)\n\n[1] \"Fraction of available quantity to take:\"\n salami     ham   brawn greaves    welt sausage    beef    pork  flitch \n  1.000   1.000   1.000   1.000   0.946   0.000   0.000   0.000   0.000 \n[1] \"KG of each to take:\"\n salami     ham   brawn greaves    welt sausage    beef    pork  flitch \n    3.0     3.6     2.5     2.4     3.5     0.0     0.0     0.0     0.0 \n[1] \"Total value of tasty meats:\"\n[1] 349.3784\n", "explain": "Translated into r-script by Shana White (vandersm@mail.uc.edu) from pseudocode found in 'Algorithms: Sequential Parallel and Distributed', by Kenneth A. Berman and Jerome L. Paul\nSample Input\nSample Output\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO;\nwith Ada.Float_Text_IO;\nwith Ada.Strings.Unbounded;\n \nprocedure Knapsack_Continuous is\n   package US renames Ada.Strings.Unbounded;\n \n   type Item is record\n      Name   : US.Unbounded_String;\n      Weight : Float;\n      Value  : Positive;\n      Taken  : Float;\n   end record;\n \n   function \"<\" (Left, Right : Item) return Boolean is\n   begin\n      return Float (Left.Value) / Left.Weight <\n             Float (Right.Value) / Right.Weight;\n   end \"<\";\n \n   type Item_Array is array (Positive range <>) of Item;\n \n   function Total_Weight (Items : Item_Array) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Items'Range loop\n         Sum := Sum + Items (I).Taken;\n      end loop;\n      return Sum;\n   end Total_Weight;\n \n   function Total_Value (Items : Item_Array) return Float is\n      Sum : Float := 0.0;\n   begin\n      for I in Items'Range loop\n         Sum := Sum + Float (Items (I).Value) / Items(I).Weight * Items (I).Taken;\n      end loop;\n      return Sum;\n   end Total_Value;\n \n   procedure Solve_Knapsack_Continuous\n     (Items        : in out Item_Array;\n      Weight_Limit : Float)\n   is\n   begin\n      -- order items by value per weight unit\n      Sorting : declare\n         An_Item : Item;\n         J       : Natural;\n      begin\n         for I in Items'First + 1 .. Items'Last loop\n            An_Item := Items (I);\n            J       := I - 1;\n            while J in Items'Range and then Items (J) < An_Item loop\n               Items (J + 1) := Items (J);\n               J             := J - 1;\n            end loop;\n            Items (J + 1) := An_Item;\n         end loop;\n      end Sorting;\n      declare\n         Rest : Float := Weight_Limit;\n      begin\n         for I in Items'Range loop\n            if Items (I).Weight <= Rest then\n               Items (I).Taken := Items (I).Weight;\n            else\n               Items (I).Taken := Rest;\n            end if;\n            Rest := Rest - Items (I).Taken;\n            exit when Rest <= 0.0;\n         end loop;\n      end;\n   end Solve_Knapsack_Continuous;\n    All_Items : Item_Array :=\n     ((US.To_Unbounded_String (\"beef\"), 3.8, 36, 0.0),\n      (US.To_Unbounded_String (\"pork\"), 5.4, 43, 0.0),\n      (US.To_Unbounded_String (\"ham\"), 3.6, 90, 0.0),\n      (US.To_Unbounded_String (\"greaves\"), 2.4, 45, 0.0),\n      (US.To_Unbounded_String (\"flitch\"), 4.0, 30, 0.0),\n      (US.To_Unbounded_String (\"brawn\"), 2.5, 56, 0.0),\n      (US.To_Unbounded_String (\"welt\"), 3.7, 67, 0.0),\n      (US.To_Unbounded_String (\"salami\"), 3.0, 95, 0.0),\n      (US.To_Unbounded_String (\"sausage\"), 5.9, 98, 0.0));\n \nbegin\n   Solve_Knapsack_Continuous (All_Items, 15.0);\n   Ada.Text_IO.Put (\"Total Weight: \");\n   Ada.Float_Text_IO.Put (Total_Weight (All_Items), 0, 2, 0);\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Total Value:  \");\n   Ada.Float_Text_IO.Put (Total_Value (All_Items), 0, 2, 0);\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put_Line (\"Items:\");\n   for I in All_Items'Range loop\n      if All_Items (I).Taken > 0.0 then\n         Ada.Text_IO.Put (\"   \");\n         Ada.Float_Text_IO.Put (All_Items (I).Taken, 0, 2, 0);\n         Ada.Text_IO.Put_Line (\" of \" & US.To_String (All_Items (I).Name));\n      end if;\n   end loop;\nend Knapsack_Continuous;\n\n\nOutput:\nTotal Weight: 15.00\nTotal Value:  349.38\nItems:\n   3.00 of salami\n   3.60 of ham\n   2.50 of brawn\n   2.40 of greaves\n   3.50 of welt\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\n\nusing Printf\n\nstruct KPCSupply{T<:Real}\n    item::String\n    weight::T\n    value::T\n    uvalue::T\nend\nfunction KPCSupply(item::AbstractString, weight::Real, value::Real)\n    w, v = promote(weight, value)\n    KPCSupply(item, w, v, v / w)\nend\n\nBase.show(io::IO, s::KPCSupply) = print(io, s.item, @sprintf \" (%.2f kg, %.2f \u20ac, %.2f \u20ac/kg)\" s.weight s.value s.uvalue)\nBase.isless(a::KPCSupply, b::KPCSupply) = a.uvalue < b.uvalue\n\nfunction solve(store::Vector{KPCSupply{T}}, capacity::Real) where T<:Real\n    sack = similar(store, 0) # vector like store, but of length 0\n    kweight = zero(T)\n    for s in sort(store, rev = true)\n        if kweight + s.weight \u2264 capacity\n            kweight += s.weight\n            push!(sack, s)\n        else\n            w = capacity - kweight\n            v = w * s.uvalue\n            push!(sack, KPCSupply(s.item, w, v, s.value))\n            break\n        end\n    end\n    return sack\nend\n\n\nstore = [KPCSupply(\"beef\", 38//10, 36),\n         KPCSupply(\"pork\", 54//10, 43),\n         KPCSupply(\"ham\", 36//10, 90),\n         KPCSupply(\"greaves\", 24//10, 45),\n         KPCSupply(\"flitch\", 4//1, 30),\n         KPCSupply(\"brawn\", 25//10, 56),\n         KPCSupply(\"welt\", 37//10, 67),\n         KPCSupply(\"salami\", 3//1, 95),\n         KPCSupply(\"sausage\", 59//10, 98)]\n\nsack = solve(store, 15)\nprintln(\"The store contains:\\n - \", join(store, \"\\n - \"))\nprintln(\"\\nThe thief should take::\\n - \", join(sack, \"\\n - \"))\n@printf(\"\\nTotal value in the sack: %.2f \u20ac\\n\", sum(getfield.(sack, :value)))\n\n\nOutput:\nThe store contains:\n - beef (3.80 kg, 36.00 \u20ac, 9.47 \u20ac/kg)\n - pork (5.40 kg, 43.00 \u20ac, 7.96 \u20ac/kg)\n - ham (3.60 kg, 90.00 \u20ac, 25.00 \u20ac/kg)\n - greaves (2.40 kg, 45.00 \u20ac, 18.75 \u20ac/kg)\n - flitch (4.00 kg, 30.00 \u20ac, 7.50 \u20ac/kg)\n - brawn (2.50 kg, 56.00 \u20ac, 22.40 \u20ac/kg)\n - welt (3.70 kg, 67.00 \u20ac, 18.11 \u20ac/kg)\n - salami (3.00 kg, 95.00 \u20ac, 31.67 \u20ac/kg)\n - sausage (5.90 kg, 98.00 \u20ac, 16.61 \u20ac/kg)\n\nThe thief should take::\n - salami (3.00 kg, 95.00 \u20ac, 31.67 \u20ac/kg)\n - ham (3.60 kg, 90.00 \u20ac, 25.00 \u20ac/kg)\n - brawn (2.50 kg, 56.00 \u20ac, 22.40 \u20ac/kg)\n - greaves (2.40 kg, 45.00 \u20ac, 18.75 \u20ac/kg)\n - welt (3.50 kg, 63.38 \u20ac, 67.00 \u20ac/kg)\n\nTotal value in the sack: 349.38 \u20ac\n", "explain": "This solution is built around the immutable type KPCSupply, which holds an item's data including its unit value (uvalue).  When the store's inventory is kept in this way, the solution to the continuous knapsack problem (provided by solve), is straightforward.  The thief should pack as much of the highest value items as are available until full capacity is reached, topping off with as much of the last item as the knapsack will hold.  (If the store contains less than the thief's knapsack will hold, he'll take the store's entire inventory.)\nAn outer constructor method is used to create instances of KPCSupply when only the item, weight and value are supplied.  The isless method is provided for KPCSupply objects so that items are transparently sorted by their unit value.  KPCSupply supports any real type for weight, value and uvalue (though this simple implementation does not support mixed types or promotion).  This solution uses Rational numbers to avoid rounding errors until the results are printed.\nType and Functions:\nMain:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\n\n/* create SAS data set */\ndata mydata;\n   input item $ weight value;\n   datalines;\nbeef    3.8  36  \npork    5.4  43  \nham     3.6  90  \ngreaves 2.4  45  \nflitch  4.0  30  \nbrawn   2.5  56  \nwelt    3.7  67  \nsalami  3.0  95  \nsausage 5.9  98  \n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare sets and parameters, and read input data */\n   set <str> ITEMS;\n   num weight {ITEMS};\n   num value {ITEMS};\n   read data mydata into ITEMS=[item] weight value;\n\n   /* declare variables, objective, and constraints */\n   var WeightSelected {i in ITEMS} >= 0 <= weight[i];\n   max TotalValue = sum {i in ITEMS} (value[i]/weight[i]) * WeightSelected[i];\n   con WeightCon:\n      sum {i in ITEMS} WeightSelected[i] <= 15;\n\n   /* call linear programming (LP) solver */\n   solve;\n\n   /* print optimal solution */\n   print TotalValue;\n   print {i in ITEMS: WeightSelected[i].sol > 1e-3} WeightSelected;\nquit;\n\n\nTotalValue \n349.38 \n\n[1] WeightSelected \nbrawn 2.5 \ngreaves 2.4 \nham 3.6 \nsalami 3.0 \nwelt 3.5 \n", "explain": "Use LP solver in SAS/OR:\nOutput:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.1.2\n\ndata class Item(val name: String, val weight: Double, val value: Double)\n\nval items = mutableListOf(\n    Item(\"beef\", 3.8, 36.0),\n    Item(\"pork\", 5.4, 43.0),\n    Item(\"ham\", 3.6, 90.0),\n    Item(\"greaves\", 2.4, 45.0),\n    Item(\"flitch\", 4.0, 30.0),\n    Item(\"brawn\", 2.5, 56.0),\n    Item(\"welt\", 3.7, 67.0),\n    Item(\"salami\", 3.0, 95.0),\n    Item(\"sausage\", 5.9, 98.0)\n)\n\nconst val MAX_WEIGHT = 15.0\n\nfun main(args: Array<String>) {\n    // sort items by value per unit weight in descending order\n    items.sortByDescending { it.value / it.weight }\n    println(\"Item Chosen   Weight  Value  Percentage\")\n    println(\"-----------   ------ ------  ----------\")\n    var w = MAX_WEIGHT\n    var itemCount = 0\n    var sumValue = 0.0\n    for (item in items) {\n        itemCount++\n        if (item.weight <= w) {\n           sumValue += item.value\n           print(\"${item.name.padEnd(11)}     ${\"%3.1f\".format(item.weight)}   ${\"%5.2f\".format(item.value)}\")\n           println(\"    100.00\")\n        }\n        else {\n           val value  = Math.round((w / item.weight * item.value * 100.0)) / 100.0\n           val percentage = Math.round((w / item.weight * 10000.0)) / 100.0\n           sumValue += value\n           print(\"${item.name.padEnd(11)}     ${\"%3.1f\".format(w)}   ${\"%5.2f\".format(value)}\")\n           println(\"     $percentage\")\n           break\n        }\n        w -= item.weight\n        if (w == 0.0) break\n    }\n    println(\"-----------   ------ ------\")\n    println(\"${itemCount} items        15.0  ${\"%6.2f\".format(sumValue)}\")\n}\n\n\nOutput:\nItem Chosen   Weight  Value  Percentage\n-----------   ------ ------  ----------\nsalami          3.0   95.00    100.00\nham             3.6   90.00    100.00\nbrawn           2.5   56.00    100.00\ngreaves         2.4   45.00    100.00\nwelt            3.5   63.38     94.59\n-----------   ------ ------\n5 items        15.0  349.38\n\nTranslation of: Fortran\n\n", "explain": "Using QuickSort (a generic form, non recursive)\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nmy @items = sort { $b->[2]/$b->[1] <=> $a->[2]/$a->[1] }\n(\n        [qw'beef    3.8 36'],\n        [qw'pork    5.4 43'],\n        [qw'ham     3.6 90'],\n        [qw'greaves 2.4 45'],\n        [qw'flitch  4.0 30'],\n        [qw'brawn   2.5 56'],\n        [qw'welt    3.7 67'],\n        [qw'salami  3.0 95'],\n        [qw'sausage 5.9 98'],\n);\n\nmy ($limit, $value) = (15, 0);\n\nprint \"item   fraction weight value\\n\";\nfor (@items) {\n        my $ratio = $_->[1] > $limit ? $limit/$_->[1] : 1;\n        print \"$_->[0]\\t\";\n        $value += $_->[2] * $ratio;\n        $limit -= $_->[1];\n        if ($ratio == 1) {\n                print \"  all\\t$_->[1]\\t$_->[2]\\n\";\n        } else {\n                printf \"%5.3f   %s   %8.3f\\n\", $ratio, $_->[1] * $ratio, $_->[2] * $ratio;\n                last;\n        }\n}\n\nprint \"-\" x 40, \"\\ntotal value: $value\\n\";\n\nOutput:item   fraction weight value\nsalami    all   3.0     95\nham       all   3.6     90\nbrawn     all   2.5     56\ngreaves   all   2.4     45\nwelt    0.946   3.5     63.378\n----------------------------------------\ntotal value: 349.378378378378\n\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\n:- use_module(library(simplex)).\n% tuples (name, weights, value).\nknapsack :-\n\tL = [(   beef, \t  3.8, \t36),\n\t     (   pork, \t  5.4, \t43),\n\t     (   ham, \t  3.6, \t90),\n\t     (   greaves, 2.4, \t45),\n\t     (   flitch,  4.0, \t30),\n\t     (   brawn,   2.5, \t56),\n\t     (   welt, \t  3.7, \t67),\n\t     (   salami,  3.0, \t95),\n\t     (   sausage, 5.9, \t98)],\n\n\t gen_state(S0),\n\t length(L, N),\n\t numlist(1, N, LN),\n\t (   (  create_constraint_N(LN, L, S0, S1, [], LW, [], LV),\n\t\tconstraint(LW =< 15.0, S1, S2),\n\t\tmaximize(LV, S2, S3)\n\t      )),\n\tcompute_lenword(L, 0, Len),\n\tsformat(A1, '~~w~~t~~~w|', [Len]),\n\tsformat(A2, '~~t~~2f~~~w|', [10]),\n\tsformat(A3, '~~t~~2f~~~w|', [10]),\n\tprint_results(S3, A1,A2,A3, L, LN, 0, 0).\n\n\ncreate_constraint_N([], [], S, S, LW, LW, LV, LV).\n\ncreate_constraint_N([HN|TN], [(_, W, V) | TL], S1, SF, LW, LWF, LV, LVF) :-\n\tconstraint([x(HN)] >= 0, S1, S2),\n\tconstraint([x(HN)] =< W, S2, S3),\n\tX is V/W,\n\tcreate_constraint_N(TN, TL, S3, SF, [x(HN) | LW], LWF, [X * x(HN) | LV], LVF).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([(Name, _, _)|T], N, NF):-\n\tatom_length(Name, L),\n\t(   L > N -> N1 = L; N1 = N),\n\tcompute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(_S, A1, A2, A3, [], [], WM, VM) :-\n\tsformat(W1, A1, [' ']),\n\tsformat(W2, A2, [WM]),\n\tsformat(W3, A3, [VM]),\n\tformat('~w~w~w~n', [W1,W2,W3]).\n\n\nprint_results(S, A1, A2, A3, [(Name, W, V)|T], [N|TN], W1, V1) :-\n\tvariable_value(S, x(N), X),\n\t(   X = 0 -> W1 = W2, V1 = V2\n\t;\n\t    sformat(S1, A1, [Name]),\n\t    sformat(S2, A2, [X]),\n\t    Vtemp is X * V/W,\n\t    sformat(S3, A3, [Vtemp]),\n\t    format('~w~w~w~n', [S1,S2,S3]),\n\t    W2 is W1 + X,\n\t    V2 is V1 + Vtemp ),\n\tprint_results(S, A1, A2, A3, T, TN, W2, V2).\n\n\n\u00a0?- knapsack.\nham          3.60     90.00\ngreaves      2.40     45.00\nbrawn        2.50     56.00\nwelt         3.50     63.38\nsalami       3.00     95.00\n            15.00    349.38\ntrue .\n", "explain": "Works with SWI-Prolog and library(simplex) written by Markus Triska\nOutput\u00a0:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nFunctional approach (Tail recursive)[edit]\nimport scala.annotation.tailrec\n\nobject ContinousKnapsackForRobber extends App {\n  val MaxWeight = 15.0\n  val items = Seq(\n    Item(\"Beef\",    3.8, 3600),\n    Item(\"Pork\",    5.4, 4300),\n    Item(\"Ham\",     3.6, 9000),\n    Item(\"Greaves\", 2.4, 4500),\n    Item(\"Flitch\",  4.0, 3000),\n    Item(\"Brawn\",   2.5, 5600),\n    Item(\"Welt\",    3.7, 6700),\n    Item(\"Salami\",  3.0, 9500),\n    Item(\"Sausage\", 5.9, 9800))\n\n  // sort items by value per unit weight in descending order\n  def sortedItems = items.sortBy(it => -it.value / it.weight)\n\n  @tailrec\n  def packer(notPacked: Seq[Item], packed: Lootsack): Lootsack = {\n\n    if (!packed.isNotFull || notPacked.isEmpty) packed\n    else {\n      val try2fit = packed.copy(bagged = notPacked.head +: packed.bagged)\n      if (try2fit.isNotFull) packer(notPacked.tail, try2fit)\n      else {\n        try2fit.copy(lastPiece = packed.weightLeft / notPacked.head.weight)\n      }\n    }\n  }\n\n  case class Item(name: String, weight: Double, value: Int)\n\n  case class Lootsack(bagged: Seq[Item], lastPiece: Double = 1.0) {\n    private val totWeight = if (bagged.isEmpty) 0.0\n    else bagged.tail.map(_.weight).sum + bagged.head.weight * lastPiece\n\n    def isNotFull: Boolean = weightLeft > 0\n\n    def weightLeft: Double = MaxWeight - totWeight\n\n    override def toString = f\"${show(bagged, lastPiece)}Totals: weight: $totWeight%4.1f, value: $totValue%6.2f\"\n\n    private def totValue: BigDecimal = if (bagged.isEmpty) 0.0\n    else (bagged.tail.map(_.value).sum + bagged.head.value * lastPiece) / 100\n\n    private def show(is: Seq[Item], percentage: Double) = {\n      def toStr(is: Seq[Item], percentage: Double = 1): String =\n        is.map(it => f\"${percentage * 100}%6.2f%% ${it.name}%-7s ${\n          it.weight * percentage}%4.1f ${it.value * percentage / 100}%6.2f\\n\").mkString\n\n      toStr(is.tail.reverse) + toStr(Seq(is.head), percentage)\n    }\n  }\n\n  println(packer(sortedItems, Lootsack(Nil)))\n}\n\n\nOutput:\n100.00% Salami   3.0  95.00\n100.00% Ham      3.6  90.00\n100.00% Brawn    2.5  56.00\n100.00% Greaves  2.4  45.00\n 94.59% Welt     3.5  63.38\nTotals: weight: 15.0, value: 349.38\n\nOutput:See it in running in your browser by ScalaFiddle (JavaScript) .\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport std.stdio, std.algorithm, std.string;\n\nstruct Item {\n    string name;\n    real amount, value;\n\n    @property real valuePerKG() @safe const pure nothrow @nogc {\n        return value / amount;\n    }\n\n    string toString() const pure /*nothrow*/ @safe {\n        return format(\"%10s %7.2f %7.2f %7.2f\",\n                      name, amount, value, valuePerKG);\n    }\n}\n\nreal sumBy(string field)(in Item[] items) @safe pure nothrow @nogc {\n    return reduce!(\"a + b.\" ~ field)(0.0L, items);\n}\n\nvoid main() /*@safe*/ {\n    const items = [Item(\"beef\",    3.8, 36.0),\n                   Item(\"pork\",    5.4, 43.0),\n                   Item(\"ham\",     3.6, 90.0),\n                   Item(\"greaves\", 2.4, 45.0),\n                   Item(\"flitch\",  4.0, 30.0),\n                   Item(\"brawn\",   2.5, 56.0),\n                   Item(\"welt\",    3.7, 67.0),\n                   Item(\"salami\",  3.0, 95.0),\n                   Item(\"sausage\", 5.9, 98.0)]\n                  .schwartzSort!(it => -it.valuePerKG)\n                  .release;\n\n    immutable(Item)[] chosen;\n    real space = 15.0;\n    foreach (const item; items)\n        if (item.amount < space) {\n            chosen ~= item;\n            space -= item.amount;\n        } else {\n            chosen ~= Item(item.name, space, item.valuePerKG * space);\n            break;\n        }\n\n    writefln(\"%10s %7s %7s %7s\", \"ITEM\", \"AMOUNT\", \"VALUE\", \"$/unit\");\n    writefln(\"%(%s\\n%)\", chosen);\n    Item(\"TOTAL\", chosen.sumBy!\"amount\", chosen.sumBy!\"value\").writeln;\n}\n\n\nOutput:\n      ITEM  AMOUNT   VALUE  $/unit\n    salami    3.00   95.00   31.67\n       ham    3.60   90.00   25.00\n     brawn    2.50   56.00   22.40\n   greaves    2.40   45.00   18.75\n      welt    3.50   63.38   18.11\n     TOTAL   15.00  349.38   23.29\nAlternative Version[edit]\nvoid main() {\n    import std.stdio, std.algorithm;\n\n    static struct T { string item; double weight, price; }\n\n    auto items = [T(\"beef\",    3.8, 36.0),\n                  T(\"pork\",    5.4, 43.0),\n                  T(\"ham\",     3.6, 90.0),\n                  T(\"greaves\", 2.4, 45.0),\n                  T(\"flitch\",  4.0, 30.0),\n                  T(\"brawn\",   2.5, 56.0),\n                  T(\"welt\",    3.7, 67.0),\n                  T(\"salami\",  3.0, 95.0),\n                  T(\"sausage\", 5.9, 98.0)]\n                 .schwartzSort!q{ -a.price / a.weight };\n\n    auto left = 15.0;\n    foreach (it; items)\n        if (it.weight <= left) {\n            writeln(\"Take all the \", it.item);\n            if (it.weight == left)\n                return;\n            left -= it.weight;\n        } else\n            return writefln(\"Take\u00a0%.1fkg %s\", left, it.item);\n}\n\n\nOutput:\nTake all the salami\nTake all the ham\nTake all the brawn\nTake all the greaves\nTake 3.5kg welt\n", "explain": ""}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nimport Data.List (sortBy)\nimport Data.Ord (comparing)\nimport Text.Printf (printf)\nimport Control.Monad (forM_)\nimport Data.Ratio (numerator, denominator)\n\nmaxWgt :: Rational\nmaxWgt = 15\n\ndata Bounty = Bounty\n  { itemName :: String\n  , itemVal, itemWgt :: Rational\n  }\n\nitems :: [Bounty]\nitems =\n  [ Bounty \"beef\" 36 3.8\n  , Bounty \"pork\" 43 5.4\n  , Bounty \"ham\" 90 3.6\n  , Bounty \"greaves\" 45 2.4\n  , Bounty \"flitch\" 30 4.0\n  , Bounty \"brawn\" 56 2.5\n  , Bounty \"welt\" 67 3.7\n  , Bounty \"salami\" 95 3.0\n  , Bounty \"sausage\" 98 5.9\n  ]\n\nsolution :: [(Rational, Bounty)]\nsolution = g maxWgt $ sortBy (flip $ comparing f) items\n  where\n    g room (b@(Bounty _ _ w):bs) =\n      if w < room\n        then (w, b) : g (room - w) bs\n        else [(room, b)]\n    f (Bounty _ v w) = v / w\n\nmain :: IO ()\nmain = do\n  forM_ solution $ \\(w, b) -> printf \"%s kg of %s\\n\" (mixedNum w) (itemName b)\n  (printf \"Total value: %s\\n\" . mixedNum . sum) $ f <$> solution\n  where\n    f (w, Bounty _ v wtot) = v * (w / wtot)\n    mixedNum q =\n      if b == 0\n        then show a\n        else printf \"%d %d/%d\" a (numerator b) (denominator b)\n      where\n        a = floor q\n        b = q - toEnum a\n\n\nOutput:\n3 kg of salami\n3 3/5 kg of ham\n2 1/2 kg of brawn\n2 2/5 kg of greaves\n3 1/2 kg of welt\nTotal value: 349 14/37\n\nimport Data.List (sortBy)\nimport Data.Ord (comparing)\nimport Text.Printf (printf)\n\n-- (name, (value, weight))\nitems =\n  [ (\"beef\", (36, 3.8))\n  , (\"pork\", (43, 5.4))\n  , (\"ham\", (90, 3.6))\n  , (\"greaves\", (45, 2.4))\n  , (\"flitch\", (30, 4.0))\n  , (\"brawn\", (56, 2.5))\n  , (\"welt\", (67, 3.7))\n  , (\"salami\", (95, 3.0))\n  , (\"sausage\", (98, 5.9))\n  ]\n\nunitWeight (_, (val, weight)) = fromIntegral val / weight\n\nsolution k = loop k . sortBy (flip $ comparing unitWeight)\n  where\n    loop k ((name, (_, weight)):xs)\n      | weight < k = putStrLn (\"Take all the \" ++ name) >> loop (k - weight) xs\n      | otherwise = printf \"Take\u00a0%.2f kg of the %s\\n\" (k :: Float) name\n\nmain = solution 15 items\n\n\nOutput:\nTake all the salami\nTake all the ham\nTake all the brawn\nTake all the greaves\nTake 3.50 kg of the welt\n", "explain": "We use a greedy algorithm.\nOr similar to above (but more succinct):\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n//Fill a knapsack optimally - Nigel Galloway: February 1st., 2015\nlet items = [(\"beef\", 3.8, 36);(\"pork\", 5.4, 43);(\"ham\", 3.6, 90);(\"greaves\", 2.4, 45);(\"flitch\" , 4.0, 30);(\"brawn\", 2.5, 56);(\"welt\", 3.7, 67);(\"salami\" , 3.0, 95);(\"sausage\", 5.9, 98)]\n            |> List.sortBy(fun(_,weight,value) -> float(-value)/weight) \n\n\nlet knap items maxW=\n  let rec take(n,g,a) = \n    match g with\n      | i::e -> let name, weight, value = i\n                let total = n + weight\n                if total <= maxW then \n                  printfn \"Take all %s\" name\n                  take(total, e, a+float(value))\n                else\n                  printfn \"Take %0.2f kg of %s\\nTotal value of swag is %0.2f\" (maxW - n) name (a + (float(value)/weight)*(maxW - n))\n      | []   -> printfn \"Everything taken! Total value of swag is \u00a3%0.2f; Total weight of bag is %0.2fkg\" a n\n  take(0.0, items, 0.0)\n\n\nOutput:\n> knap items 15.0;;\nTake all salami\nTake all ham\nTake all brawn\nTake all greaves\nTake 3.50kg of welt\nTotal value of swag is \u00a3349.38\n\n\n> knap items 100.0;;\nTake all salami\nTake all ham\nTake all brawn\nTake all greaves\nTake all welt\nTake all sausage\nTake all beef\nTake all pork\nTake all flitch\nEverything taken! Total value of swag is \u00a3560.00; Total weight of bag is 34.30kg\n\n", "explain": "Should your burglar be greedy, he may bring a bigger bag.\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nimport static java.math.RoundingMode.*\n\ndef knapsackCont = { list, maxWeight = 15.0 ->\n    list.sort{ it.weight / it.value }\n    def remainder = maxWeight\n    List sack = []\n    for (item in list) {\n        if (item.weight < remainder) {\n            sack << [name: item.name, weight: item.weight,\n                        value: (item.value as BigDecimal).setScale(2, HALF_UP)]\n        } else {\n            sack << [name: item.name, weight: remainder,\n                        value: (item.value * remainder / item.weight).setScale(2, HALF_UP)]\n            break\n        }\n        remainder -= item.weight\n    }\n    sack\n}\n\n\ndef possibleItems = [\n    [name:'beef',    weight:3.8, value:36],\n    [name:'pork',    weight:5.4, value:43],\n    [name:'ham',     weight:3.6, value:90],\n    [name:'greaves', weight:2.4, value:45],\n    [name:'flitch',  weight:4.0, value:30],\n    [name:'brawn',   weight:2.5, value:56],\n    [name:'welt',    weight:3.7, value:67],\n    [name:'salami',  weight:3.0, value:95],\n    [name:'sausage', weight:5.9, value:98],\n]\n\ndef contents = knapsackCont(possibleItems)\nprintln \"Total Value: ${contents*.value.sum()}\"\ncontents.each {\n    printf(\"    name:\u00a0%-7s  weight: ${it.weight}  value: ${it.value}\\n\", it.name)\n}\n\n\nTotal Value: 349.38\n    name: salami   weight: 3.0  value: 95.00\n    name: ham      weight: 3.6  value: 90.00\n    name: brawn    weight: 2.5  value: 56.00\n    name: greaves  weight: 2.4  value: 45.00\n    name: welt     weight: 3.5  value: 63.38\n", "explain": "Solution: obvious greedy algorithm\nTest:\nOutput:\n"}, {"task_name": "Knapsack problem/Continuous", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Continuous", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f KNAPSACK_PROBLEM_CONTINUOUS.AWK\nBEGIN {\n#   arr[\"item,weight,price\"]\n    arr[\"beef,3.8,36\"]\n    arr[\"pork,5.4,43\"]\n    arr[\"ham,3.6,90\"]\n    arr[\"greaves,2.4,45\"]\n    arr[\"flitch,4.0,30\"]\n    arr[\"brawn,2.5,56\"]\n    arr[\"welt,3.7,67\"]\n    arr[\"salami,3.0,95\"]\n    arr[\"sausage,5.9,98\"]\n    for (i in arr) {\n      split(i,tmp,\",\")\n      arr[i] = tmp[3] / tmp[2] # $/unit\n    }\n    sack_size = 15 # kg\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"\n    print(\"item    weight  price $/unit\")\n    for (i in arr) {\n      if (total_weight >= sack_size) {\n        break\n      }\n      split(i,tmp,\",\")\n      weight = tmp[2]\n      if (total_weight + weight <= sack_size) {\n        price = tmp[3]\n        msg = \"all\"\n      }\n      else {\n        weight = sack_size - total_weight\n        price = weight * arr[i]\n        msg = weight \" of \" tmp[2]\n      }\n      printf(\"%-7s %6.2f %6.2f %6.2f take %s\\n\",tmp[1],weight,tmp[3],arr[i],msg)\n      total_items++\n      total_price += price\n      total_weight += weight\n    }\n    printf(\"%7d %6.2f %6.2f total\\n\",total_items,total_weight,total_price)\n    exit(0)\n}\n\n\nOutput:\nitem    weight  price $/unit\nsalami    3.00  95.00  31.67 take all\nham       3.60  90.00  25.00 take all\nbrawn     2.50  56.00  22.40 take all\ngreaves   2.40  45.00  18.75 take all\nwelt      3.50  67.00  18.11 take 3.5 of 3.7\n      5  15.00 349.38 total\n\n", "explain": ""}]