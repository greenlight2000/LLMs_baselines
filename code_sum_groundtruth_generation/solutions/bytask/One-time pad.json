[{"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Python", "code": "\n\"\"\"One-time pad using an XOR cipher. Requires Python >=3.6.\"\"\"\n\nimport argparse\nimport itertools\nimport pathlib\nimport re\nimport secrets\nimport sys\n\n\n# One-time pad file signature.\nMAGIC = \"#one-time pad\"\n\n\ndef make_keys(n, size):\n    \"\"\"Generate ``n`` secure, random keys of ``size`` bytes.\"\"\"\n    # We're generating and storing keys in their hexadecimal form to make\n    # one-time pad files a little more human readable and to ensure a key\n    # can not start with a hyphen.\n    return (secrets.token_hex(size) for _ in range(n))\n\n\ndef make_pad(name, pad_size, key_size):\n    \"\"\"Create a new one-time pad identified by the given name.\n\n    Args:\n        name (str): Unique one-time pad identifier.\n        pad_size (int): The number of keys (or pages) in the pad.\n        key_size (int): The number of bytes per key.\n    Returns:\n        The new one-time pad as a string.\n    \"\"\"\n    pad = [\n        MAGIC,\n        f\"#name={name}\",\n        f\"#size={pad_size}\",\n        *make_keys(pad_size, key_size),\n    ]\n\n    return \"\\n\".join(pad)\n\n\ndef xor(message, key):\n    \"\"\"Return ``message`` XOR-ed with ``key``.\n\n    Args:\n        message (bytes): Plaintext or cyphertext to be encrypted or decrypted.\n        key (bytes): Encryption and decryption key.\n    Returns:\n        Plaintext or cyphertext as a byte string.\n    \"\"\"\n    return bytes(mc ^ kc for mc, kc in zip(message, itertools.cycle(key)))\n\n\ndef use_key(pad):\n    \"\"\"Use the next available key from the given one-time pad.\n\n    Args:\n        pad (str): A one-time pad.\n    Returns:\n        (str, str) A two-tuple of updated pad and key.\n    \"\"\"\n    match = re.search(r\"^[a-f0-9]+$\", pad, re.MULTILINE)\n    if not match:\n        error(\"pad is all used up\")\n\n    key = match.group()\n    pos = match.start()\n\n    return (f\"{pad[:pos]}-{pad[pos:]}\", key)\n\n\ndef log(msg):\n    \"\"\"Log a message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n\n\ndef error(msg):\n    \"\"\"Exit with an error message.\"\"\"\n    sys.stderr.write(msg)\n    sys.stderr.write(\"\\n\")\n    sys.exit(1)\n\n\ndef write_pad(path, pad_size, key_size):\n    \"\"\"Write a new one-time pad to the given path.\n\n    Args:\n        path (pathlib.Path): Path to write one-time pad to.\n        length (int): Number of keys in the pad.\n    \"\"\"\n    if path.exists():\n        error(f\"pad '{path}' already exists\")\n\n    with path.open(\"w\") as fd:\n        fd.write(make_pad(path.name, pad_size, key_size))\n\n    log(f\"New one-time pad written to {path}\")\n\n\ndef main(pad, message, outfile):\n    \"\"\"Encrypt or decrypt ``message`` using the given pad.\n\n    Args:\n        pad (pathlib.Path): Path to one-time pad.\n        message (bytes): Plaintext or ciphertext message to encrypt or decrypt.\n        outfile: File-like object to write to.\n    \"\"\"\n    if not pad.exists():\n        error(f\"no such pad '{pad}'\")\n\n    with pad.open(\"r\") as fd:\n        if fd.readline().strip() != MAGIC:\n            error(f\"file '{pad}' does not look like a one-time pad\")\n\n    # Rewrites the entire one-time pad every time\n    with pad.open(\"r+\") as fd:\n        updated, key = use_key(fd.read())\n\n        fd.seek(0)\n        fd.write(updated)\n\n    outfile.write(xor(message, bytes.fromhex(key)))\n\n\nif __name__ == \"__main__\":\n    # Command line interface\n    parser = argparse.ArgumentParser(description=\"One-time pad.\")\n\n    parser.add_argument(\n        \"pad\",\n        help=(\n            \"Path to one-time pad. If neither --encrypt or --decrypt \"\n            \"are given, will create a new pad.\"\n        ),\n    )\n\n    parser.add_argument(\n        \"--length\",\n        type=int,\n        default=10,\n        help=\"Pad size. Ignored if --encrypt or --decrypt are given. Defaults to 10.\",\n    )\n\n    parser.add_argument(\n        \"--key-size\",\n        type=int,\n        default=64,\n        help=\"Key size in bytes. Ignored if --encrypt or --decrypt are given. Defaults to 64.\",\n    )\n\n    parser.add_argument(\n        \"-o\",\n        \"--outfile\",\n        type=argparse.FileType(\"wb\"),\n        default=sys.stdout.buffer,\n        help=(\n            \"Write encoded/decoded message to a file. Ignored if --encrypt or \"\n            \"--decrypt is not given. Defaults to stdout.\"\n        ),\n    )\n\n    group = parser.add_mutually_exclusive_group()\n\n    group.add_argument(\n        \"--encrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Encrypt FILE using the next available key from pad.\",\n    )\n    group.add_argument(\n        \"--decrypt\",\n        metavar=\"FILE\",\n        type=argparse.FileType(\"rb\"),\n        help=\"Decrypt FILE using the next available key from pad.\",\n    )\n\n    args = parser.parse_args()\n\n    if args.encrypt:\n        message = args.encrypt.read()\n    elif args.decrypt:\n        message = args.decrypt.read()\n    else:\n        message = None\n\n    # Sometimes necessary if message came from stdin\n    if isinstance(message, str):\n        message = message.encode()\n\n    pad = pathlib.Path(args.pad).with_suffix(\".1tp\")\n\n    if message:\n        main(pad, message, args.outfile)\n    else:\n        write_pad(pad, args.length, args.key_size)\n\n\nOutput:\n\n$ python otp.py --help\nusage: otp.py [-h] [--length LENGTH] [--key-size KEY_SIZE] [-o OUTFILE]\n              [--encrypt FILE | --decrypt FILE]\n              pad\n\nOne-time pad.\n\npositional arguments:\n  pad                   Path to one-time pad. If neither --encrypt or --decrypt\n                        are given, will create a new pad.\n\noptional arguments:\n  -h, --help            show this help message and exit\n  --length LENGTH       Pad size. Ignored if --encrypt or --decrypt are given.\n                        Defaults to 10.\n  --key-size KEY_SIZE   Key size in bytes. Ignored if --encrypt or --decrypt\n                        are given. Defaults to 64.\n  -o OUTFILE, --outfile OUTFILE\n                        Write encoded/decoded message to a file. Ignored if\n                        --encrypt or --decrypt is not given. Defaults to\n                        stdout.\n  --encrypt FILE        Encrypt FILE using the next available key from pad.\n  --decrypt FILE        Decrypt FILE using the next available key from pad.\n\n\n$ python otp.py mypad --length 5 --key-size 128\n$\n$ head mypad.1tp\n#one-time pad\n#name=mypad.1tp\n#size=5\n8522ecc603a492693c04a19e55a3340601e3 ...\n\n\n$ cp mypad.1tp shared.1tp\n$\n$ echo \"like all shared secrets, the pad has to be at least as long as the message\" > message.txt\n$ python otp.py mypad.1tp --encrypt message.txt -o secret.dat\n\n\n$ python otp.py shared.1tp --decrypt secret.dat -o plaintext.txt\n\n", "explain": "Command line interface. Show the help message and exit\n\nCreate a new one-time pad in the current working directory.\n\nDistribute our new one-time pad and use it to encrypt a message.\n\nAnd decrypt the message using the shared copy of the one-time pad.\n"}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Java", "code": "\n\nimport java.io.BufferedReader;\nimport java.io.BufferedWriter;\nimport java.io.FileReader;\nimport java.io.FileWriter;\nimport java.io.IOException;\nimport java.util.Random;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class OneTimePad {\n\n    public static void main(String[] args) {\n        String controlName = \"AtomicBlonde\";\n        generatePad(controlName, 5, 60, 65, 90);\n        String text = \"IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\";\n        String encrypted = parse(true, controlName, text.replaceAll(\" \", \"\"));\n        String decrypted = parse(false, controlName, encrypted);\n        System.out.println(\"Input  text    = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n\n        controlName = \"AtomicBlondeCaseSensitive\";\n        generatePad(controlName, 5, 60, 32, 126);\n        text = \"It was the best of times, it was the worst of times.\";\n        encrypted = parse(true, controlName, text);\n        decrypted = parse(false, controlName, encrypted);\n        System.out.println();\n        System.out.println(\"Input text     = \" + text);\n        System.out.println(\"Encrypted text = \" + encrypted);\n        System.out.println(\"Decrypted text = \" + decrypted);\n    }\n    \n    private static String parse(boolean encryptText, String controlName, String text) {\n        StringBuilder sb = new StringBuilder();\n        int minCh = 0;\n        int maxCh = 0;\n        Pattern minChPattern = Pattern.compile(\"^#  MIN_CH = ([\\\\d]+)$\");\n        Pattern maxChPattern = Pattern.compile(\"^#  MAX_CH = ([\\\\d]+)$\");\n        boolean validated = false;\n        try (BufferedReader in = new BufferedReader(new FileReader(getFileName(controlName))); ) {\n            String inLine = null;\n            while ( (inLine = in.readLine()) != null ) {\n                Matcher minMatcher = minChPattern.matcher(inLine);\n                if ( minMatcher.matches() ) {\n                    minCh = Integer.parseInt(minMatcher.group(1));\n                    continue;\n                }\n                Matcher maxMatcher = maxChPattern.matcher(inLine);\n                if ( maxMatcher.matches() ) {\n                    maxCh = Integer.parseInt(maxMatcher.group(1));\n                    continue;\n                }\n                if ( ! validated && minCh > 0 && maxCh > 0 ) {\n                    validateText(text, minCh, maxCh);\n                    validated = true;\n                }\n                //  # is comment.  - is used key. \n                if ( inLine.startsWith(\"#\") || inLine.startsWith(\"-\") ) {\n                    continue;\n                }\n                //  Have encryption key.\n                String key = inLine;\n                if ( encryptText ) {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        sb.append((char) (((text.charAt(i) - minCh + key.charAt(i) - minCh) % (maxCh - minCh + 1)) + minCh));\n                    }\n                }\n                else {\n                    for ( int i = 0 ; i < text.length(); i++) {\n                        int decrypt = text.charAt(i) - key.charAt(i);\n                        if ( decrypt < 0 ) {\n                            decrypt += maxCh - minCh + 1;\n                        }\n                        decrypt += minCh;\n                        sb.append((char) decrypt);\n                    }\n                }\n                break;\n            }\n        } catch (IOException e) {\n            throw new RuntimeException(e);\n        }\n        return sb.toString();\n    }\n\n    private static void validateText(String text, int minCh, int maxCh) {\n        //  Validate text is in range\n        for ( char ch : text.toCharArray() ) {\n            if ( ch != ' ' && (ch < minCh || ch > maxCh) ) {\n                throw new IllegalArgumentException(\"ERROR 103:  Invalid text.\");\n            }\n        }\n        \n    }\n    \n    private static String getFileName(String controlName) {\n        return controlName + \".1tp\";\n    }\n    \n    private static void generatePad(String controlName, int keys, int keyLength, int minCh, int maxCh) {\n        Random random = new Random();\n        try ( BufferedWriter writer = new BufferedWriter(new FileWriter(getFileName(controlName), false)); ) {\n            writer.write(\"#  Lines starting with '#' are ignored.\");\n            writer.newLine();\n            writer.write(\"#  Lines starting with '-' are previously used.\");\n            writer.newLine();\n            writer.write(\"#  MIN_CH = \" + minCh);\n            writer.newLine();\n            writer.write(\"#  MAX_CH = \" + maxCh);\n            writer.newLine();\n            for ( int line = 0 ; line < keys ; line++ ) {\n                StringBuilder sb = new StringBuilder();\n                for ( int ch = 0 ; ch < keyLength ; ch++ ) {\n                    sb.append((char) (random.nextInt(maxCh - minCh + 1) + minCh));\n                }\n                writer.write(sb.toString());\n                writer.newLine();\n            }\n            writer.write(\"#  EOF\");\n            writer.newLine();\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n}\n\n\nOutput:\n\nInput  text    = IT WAS THE BEST OF TIMES IT WAS THE WORST OF TIMES\nEncrypted text = ANFNPULTOZRSUNBACQXBMUVIGNWSRJFFNCBVCNF\nDecrypted text = ITWASTHEBESTOFTIMESITWASTHEWORSTOFTIMES\n\nInput text     = It was the best of times, it was the worst of times.\nEncrypted text = jF,2abB`:3f9}@85\"Y.k[JyWRNO\\(q~0Z-5_P:E_H3Q0U(2>'eWy\nDecrypted text = It was the best of times, it was the worst of times.\n\n\n#  Lines starting with '#' are ignored.\n#  Lines starting with '-' are previously used.\n#  MIN_CH = 65\n#  MAX_CH = 90\nSUJNXBEPNVZZGIISQMFTTYVQNGSWDSNMZXINQJNEQHFBLCSZFCHJGKDLPQPN\nRQMZKUCZQZXQDTKXKSVRCFNZYTGZWCDPPMCHDHORVFWBLXJLWTJRBRGUOYWM\nPKEVUUBDOMBSFXVJFWGORCZPBSQOWZEOFFHZARVJWTEUQUAKGTMHFAVZSVOO\nDKNEKKCTQITFVSOWKMXAOQKWTUYOUXICSEWYCPGOPWFKHYZXQXOIVQUZWWZB\nNQUICNAJLTKDFSPXVBIVUUYUTZNNRNBQQXAGPERXZQNQLHEUXSRNIADKXZCL\n#  EOF\n\n\n#  Lines starting with '#' are ignored.\n#  Lines starting with '-' are previously used.\n#  MIN_CH = 32\n#  MAX_CH = 126\nAQ,: nBkQMfV8LC52r.vq\\4cFNeg(y=<Z8LyPBUlT>Q@n(=T9 ckJJt6c59[\nA{qjk{}x?vlu5(/I4IrkC0NJS2}?_a xF__;5V& -Nz7qh@7OD}l<u9~xGMZ\n6JOW|8cZ<,O:vp*LMwU~5u@AJ5nVG7 x?_zfyY(>QMA|U37Z39B}M-lnI-GB\n|Qe1*V^PHo\"\\M:YQo1Z$}2XUk[,L(<P+RDso>'LE.>#K)I6IvrJ&l}O<~=C^\nrx0ubl%t(-tOnCQz_y5k%xlHHi$cvaRCIYD<5nUFWD5Hmd@K2.{/N^>PP.<I\n#  EOF\n\n", "explain": "Implementation supports multiple pads using the control name.  \nImplementation also includes the start and end ASCII characters.  One usage shows support for uppercase only, a second usage shows allowing spaces, upper case, and lower case in the input text.\nDemonstration of job:\nGenerated one time pad supporting uppercase only.\nGenerated one time pad supporting lowercase, uppercase, symbols, and spaces.\n"}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Go", "code": "\nTranslation of: Kotlin\npackage main\n\nimport (\n    \"bufio\"\n    \"crypto/rand\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"log\"\n    \"math/big\"\n    \"os\"\n    \"strconv\"\n    \"strings\"\n    \"unicode\"\n)\n\nconst (\n    charsPerLine = 48\n    chunkSize    = 6\n    cols         = 8\n    demo         = true // would normally be set to false\n)\n\ntype fileType int\n\nconst (\n    otp fileType = iota\n    enc\n    dec\n)\n\nvar scnr = bufio.NewScanner(os.Stdin)\n\nfunc check(err error) {\n    if err != nil {\n        log.Fatal(err)\n    }\n}\n\nfunc toAlpha(s string) string {\n    var filtered []rune\n    for _, r := range s {\n        if unicode.IsUpper(r) {\n            filtered = append(filtered, r)\n        }\n    }\n    return string(filtered)\n}\n\nfunc isOtpRelated(s string) bool {\n    return strings.HasSuffix(s, \".1tp\") || strings.HasSuffix(s, \"1tp_cpy\") ||\n        strings.HasSuffix(s, \".1tp_enc\") || strings.HasSuffix(s, \"1tp_dec\")\n}\n\nfunc makePad(nLines int) string {\n    nChars := nLines * charsPerLine\n    bytes := make([]byte, nChars)\n    /* generate random upper case letters */\n    max := big.NewInt(26)\n    for i := 0; i < nChars; i++ {\n        n, err := rand.Int(rand.Reader, max)\n        check(err)\n        bytes[i] = byte(65 + n.Uint64())\n    }\n    return inChunks(string(bytes), nLines, otp)\n}\n\nfunc vigenere(text, key string, encrypt bool) string {\n    bytes := make([]byte, len(text))\n    var ci byte\n    for i, c := range text {\n        if encrypt {\n            ci = (byte(c) + key[i] - 130) % 26\n        } else {\n            ci = (byte(c) + 26 - key[i]) % 26\n        }\n        bytes[i] = ci + 65\n    }\n    temp := len(bytes) % charsPerLine\n    if temp > 0 { // pad with random characters so each line is a full one\n        max := big.NewInt(26)\n        for i := temp; i < charsPerLine; i++ {\n            n, err := rand.Int(rand.Reader, max)\n            check(err)\n            bytes = append(bytes, byte(65+n.Uint64()))\n        }\n    }\n    ft := enc\n    if !encrypt {\n        ft = dec\n    }\n    return inChunks(string(bytes), len(bytes)/charsPerLine, ft)\n}\n\nfunc inChunks(s string, nLines int, ft fileType) string {\n    nChunks := len(s) / chunkSize\n    remainder := len(s) % chunkSize\n    chunks := make([]string, nChunks)\n    for i := 0; i < nChunks; i++ {\n        chunks[i] = s[i*chunkSize : (i+1)*chunkSize]\n    }\n    if remainder > 0 {\n        chunks = append(chunks, s[nChunks*chunkSize:])\n    }\n    var sb strings.Builder\n    for i := 0; i < nLines; i++ {\n        j := i * cols\n        sb.WriteString(\" \" + strings.Join(chunks[j:j+cols], \" \") + \"\\n\")\n    }\n    ss := \" file\\n\" + sb.String()\n    switch ft {\n    case otp:\n        return \"# OTP\" + ss\n    case enc:\n        return \"# Encrypted\" + ss\n    default: // case dec:\n        return \"# Decrypted\" + ss\n    }\n}\n\nfunc menu() int {\n    fmt.Println(`\n1. Create one time pad file.\n\n2. Delete one time pad file.\n\n3. List one time pad files.\n\n4. Encrypt plain text.\n\n5. Decrypt cipher text.\n\n6. Quit program.\n`)\n    choice := 0\n    for choice < 1 || choice > 6 {\n        fmt.Print(\"Your choice (1 to 6)\u00a0: \")\n        scnr.Scan()\n        choice, _ = strconv.Atoi(scnr.Text())\n        check(scnr.Err())\n    }\n    return choice\n}\n\nfunc main() {\n    for {\n        choice := menu()\n        fmt.Println()\n        switch choice {\n        case 1: // Create OTP\n            fmt.Println(\"Note that encrypted lines always contain 48 characters.\\n\")\n            fmt.Print(\"OTP file name to create (without extension)\u00a0: \")\n            scnr.Scan()\n            fileName := scnr.Text() + \".1tp\"\n            nLines := 0\n            for nLines < 1 || nLines > 1000 {\n                fmt.Print(\"Number of lines in OTP (max 1000)\u00a0: \")\n                scnr.Scan()\n                nLines, _ = strconv.Atoi(scnr.Text())\n            }\n            check(scnr.Err())\n            key := makePad(nLines)\n            file, err := os.Create(fileName)\n            check(err)\n            _, err = file.WriteString(key)\n            check(err)\n            file.Close()\n            fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", fileName)\n            if demo {\n                // a copy of the OTP file would normally be on a different machine\n                fileName2 := fileName + \"_cpy\" // copy for decryption\n                file, err := os.Create(fileName2)\n                check(err)\n                _, err = file.WriteString(key)\n                check(err)\n                file.Close()\n                fmt.Printf(\"'%s' has been created in the current directory.\\n\", fileName2)\n                fmt.Println(\"\\nThe contents of these files are\u00a0:\\n\")\n                fmt.Println(key)\n            }\n        case 2: // Delete OTP\n            fmt.Println(\"Note that this will also delete ALL associated files.\\n\")\n            fmt.Print(\"OTP file name to delete (without extension)\u00a0: \")\n            scnr.Scan()\n            toDelete1 := scnr.Text() + \".1tp\"\n            check(scnr.Err())\n            toDelete2 := toDelete1 + \"_cpy\"\n            toDelete3 := toDelete1 + \"_enc\"\n            toDelete4 := toDelete1 + \"_dec\"\n            allToDelete := []string{toDelete1, toDelete2, toDelete3, toDelete4}\n            deleted := 0\n            fmt.Println()\n            for _, name := range allToDelete {\n                if _, err := os.Stat(name); !os.IsNotExist(err) {\n                    err = os.Remove(name)\n                    check(err)\n                    deleted++\n                    fmt.Printf(\"'%s' has been deleted from the current directory.\\n\", name)\n                }\n            }\n            if deleted == 0 {\n                fmt.Println(\"There are no files to delete.\")\n            }\n        case 3: // List OTPs\n            fmt.Println(\"The OTP (and related) files in the current directory are:\\n\")\n            files, err := ioutil.ReadDir(\".\") // already sorted by file name\n            check(err)\n            for _, fi := range files {\n                name := fi.Name()\n                if !fi.IsDir() && isOtpRelated(name) {\n                    fmt.Println(name)\n                }\n            }\n        case 4: // Encrypt\n            fmt.Print(\"OTP file name to use (without extension)\u00a0: \")\n            scnr.Scan()\n            keyFile := scnr.Text() + \".1tp\"\n            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {\n                file, err := os.Open(keyFile)\n                check(err)\n                bytes, err := ioutil.ReadAll(file)\n                check(err)\n                file.Close()\n                lines := strings.Split(string(bytes), \"\\n\")\n                le := len(lines)\n                first := le\n                for i := 0; i < le; i++ {\n                    if strings.HasPrefix(lines[i], \" \") {\n                        first = i\n                        break\n                    }\n                }\n                if first == le {\n                    fmt.Println(\"\\nThat file has no unused lines.\")\n                    continue\n                }\n                lines2 := lines[first:] // get rid of comments and used lines\n\n                fmt.Println(\"Text to encrypt\u00a0:-\\n\")\n                scnr.Scan()\n                text := toAlpha(strings.ToUpper(scnr.Text()))\n                check(scnr.Err())\n                tl := len(text)\n                nLines := tl / charsPerLine\n                if tl%charsPerLine > 0 {\n                    nLines++\n                }\n                if len(lines2) >= nLines {\n                    key := toAlpha(strings.Join(lines2[0:nLines], \"\"))\n                    encrypted := vigenere(text, key, true)\n                    encFile := keyFile + \"_enc\"\n                    file2, err := os.Create(encFile)\n                    check(err)\n                    _, err = file2.WriteString(encrypted)\n                    check(err)\n                    file2.Close()\n                    fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", encFile)\n                    for i := first; i < first+nLines; i++ {\n                        lines[i] = \"-\" + lines[i][1:]\n                    }\n                    file3, err := os.Create(keyFile)\n                    check(err)\n                    _, err = file3.WriteString(strings.Join(lines, \"\\n\"))\n                    check(err)\n                    file3.Close()\n                    if demo {\n                        fmt.Println(\"\\nThe contents of the encrypted file are\u00a0:\\n\")\n                        fmt.Println(encrypted)\n                    }\n                } else {\n                    fmt.Println(\"Not enough lines left in that file to do encryption.\")\n                }\n            } else {\n                fmt.Println(\"\\nThat file does not exist.\")\n            }\n        case 5: // Decrypt\n            fmt.Print(\"OTP file name to use (without extension)\u00a0: \")\n            scnr.Scan()\n            keyFile := scnr.Text() + \".1tp_cpy\"\n            check(scnr.Err())\n            if _, err := os.Stat(keyFile); !os.IsNotExist(err) {\n                file, err := os.Open(keyFile)\n                check(err)\n                bytes, err := ioutil.ReadAll(file)\n                check(err)\n                file.Close()\n                keyLines := strings.Split(string(bytes), \"\\n\")\n                le := len(keyLines)\n                first := le\n                for i := 0; i < le; i++ {\n                    if strings.HasPrefix(keyLines[i], \" \") {\n                        first = i\n                        break\n                    }\n                }\n                if first == le {\n                    fmt.Println(\"\\nThat file has no unused lines.\")\n                    continue\n                }\n                keyLines2 := keyLines[first:] // get rid of comments and used lines\n\n                encFile := keyFile[0:len(keyFile)-3] + \"enc\"\n                if _, err := os.Stat(encFile); !os.IsNotExist(err) {\n                    file2, err := os.Open(encFile)\n                    check(err)\n                    bytes, err := ioutil.ReadAll(file2)\n                    check(err)\n                    file2.Close()\n                    encLines := strings.Split(string(bytes), \"\\n\")[1:] // exclude comment line\n                    nLines := len(encLines)\n                    if len(keyLines2) >= nLines {\n                        encrypted := toAlpha(strings.Join(encLines, \"\"))\n                        key := toAlpha(strings.Join(keyLines2[0:nLines], \"\"))\n                        decrypted := vigenere(encrypted, key, false)\n                        decFile := keyFile[0:len(keyFile)-3] + \"dec\"\n                        file3, err := os.Create(decFile)\n                        check(err)\n                        _, err = file3.WriteString(decrypted)\n                        check(err)\n                        file3.Close()\n                        fmt.Printf(\"\\n'%s' has been created in the current directory.\\n\", decFile)\n                        for i := first; i < first+nLines; i++ {\n                            keyLines[i] = \"-\" + keyLines[i][1:]\n                        }\n                        file4, err := os.Create(keyFile)\n                        check(err)\n                        _, err = file4.WriteString(strings.Join(keyLines, \"\\n\"))\n                        check(err)\n                        file4.Close()\n                        if demo {\n                            fmt.Println(\"\\nThe contents of the decrypted file are\u00a0:\\n\")\n                            fmt.Println(decrypted)\n                        }\n                    }\n                } else {\n                    fmt.Println(\"Not enough lines left in that file to do decryption.\")\n                }\n            } else {\n                fmt.Println(\"\\nThat file does not exist.\")\n            }\n        case 6: // Quit program\n            return\n        }\n    }\n}\n\n\nOutput:\nSimilar (not exactly the same, of course) as the Kotlin sample session.\n\n", "explain": ""}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Julia", "code": "\n\n", "explain": "See One-time pad/Julia\n"}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Kotlin", "code": "\n\n// version 1.2.31\n\nimport java.io.File\nimport java.security.SecureRandom\n\nconst val CHARS_PER_LINE = 48\nconst val CHUNK_SIZE = 6\nconst val COLS = 8\nconst val DEMO = true  // would normally be set to false\n\nenum class FileType { OTP, ENC, DEC }\n\nfun Char.isAlpha() = this in 'A'..'Z'\n\nfun String.toAlpha() = this.filter { it.isAlpha() }\n\nfun String.isOtpRelated() = endsWith(\".1tp\") || endsWith(\".1tp_cpy\") ||\n                            endsWith(\".1tp_enc\") || endsWith(\".1tp_dec\")\n\nfun makePad(nLines: Int): String {\n    val nChars = nLines * CHARS_PER_LINE\n    val sr = SecureRandom()\n    val sb = StringBuilder(nChars)\n    /* generate random upper case letters */\n    for (i in 0 until nChars) sb.append((sr.nextInt(26) + 65).toChar())\n    return sb.toString().inChunks(nLines, FileType.OTP)\n}\n\nfun vigenere(text: String, key: String, encrypt: Boolean = true): String {\n    val sb = StringBuilder(text.length)\n    for ((i, c) in text.withIndex()) {\n        val ci = if (encrypt)\n            (c.toInt() + key[i].toInt() - 130) % 26\n        else\n            (c.toInt() - key[i].toInt() +  26) % 26\n        sb.append((ci + 65).toChar())\n    }\n    val temp = sb.length % CHARS_PER_LINE\n    if (temp > 0) {  // pad with random characters so each line is a full one\n        val sr = SecureRandom()\n        for (i in temp until CHARS_PER_LINE) sb.append((sr.nextInt(26) + 65).toChar())\n    }\n    val ft = if (encrypt) FileType.ENC else FileType.DEC\n    return sb.toString().inChunks(sb.length / CHARS_PER_LINE, ft)\n}\n\nfun String.inChunks(nLines: Int, ft: FileType): String {\n    val chunks = this.chunked(CHUNK_SIZE)\n    val sb = StringBuilder(this.length + nLines * (COLS + 1))\n    for (i in 0 until nLines) {\n        val j = i * COLS\n        sb.append(\" ${chunks.subList(j, j + COLS).joinToString(\" \")}\\n\")\n    }\n    val s = \" file\\n\" + sb.toString()\n    return when (ft) {\n        FileType.OTP -> \"# OTP\" + s\n        FileType.ENC -> \"# Encrypted\" + s\n        FileType.DEC -> \"# Decrypted\" + s\n    }\n}\n\nfun menu(): Int {\n    println(\"\"\"\n        |\n        |1. Create one time pad file.\n        |\n        |2. Delete one time pad file.\n        |\n        |3. List one time pad files.\n        |\n        |4. Encrypt plain text.\n        |\n        |5. Decrypt cipher text.\n        |\n        |6. Quit program.\n        |\n        \"\"\".trimMargin())\n    var choice: Int?\n    do {\n        print(\"Your choice (1 to 6)\u00a0: \")\n        choice = readLine()!!.toIntOrNull()\n    }\n    while (choice == null || choice !in 1..6)\n    return choice\n}\n\nfun main(args: Array<String>) {\n    mainLoop@ while (true) {\n        val choice = menu()\n        println()\n        when (choice) {\n            1 -> {  // Create OTP\n                println(\"Note that encrypted lines always contain 48 characters.\\n\")\n                print(\"OTP file name to create (without extension)\u00a0: \")\n                val fileName = readLine()!! + \".1tp\"  \n                var nLines: Int?\n\n                do {\n                    print(\"Number of lines in OTP (max 1000)\u00a0: \")\n                    nLines = readLine()!!.toIntOrNull()\n                }\n                while (nLines == null || nLines !in 1..1000)\n\n                val key = makePad(nLines)\n                File(fileName).writeText(key)\n                println(\"\\n'$fileName' has been created in the current directory.\")\n                if (DEMO) {\n                    // a copy of the OTP file would normally be on a different machine\n                    val fileName2 = fileName + \"_cpy\"  // copy for decryption\n                    File(fileName2).writeText(key)\n                    println(\"'$fileName2' has been created in the current directory.\")\n                    println(\"\\nThe contents of these files are\u00a0:\\n\")\n                    println(key)\n                }\n            }\n\n            2 -> {  // Delete OTP\n                println(\"Note that this will also delete ALL associated files.\\n\")\n                print(\"OTP file name to delete (without extension)\u00a0: \")\n                val toDelete1 = readLine()!! + \".1tp\"\n                val toDelete2 = toDelete1 + \"_cpy\"\n                val toDelete3 = toDelete1 + \"_enc\"\n                val toDelete4 = toDelete1 + \"_dec\"\n                val allToDelete = listOf(toDelete1, toDelete2, toDelete3, toDelete4)\n                var deleted = 0\n                println()\n                for (name in allToDelete) {\n                    val f = File(name)\n                    if (f.exists()) {\n                        f.delete()\n                        deleted++\n                        println(\"'$name' has been deleted from the current directory.\")\n                    }\n                }\n                if (deleted == 0) println(\"There are no files to delete.\")\n            }\n\n            3 -> {  // List OTPs\n                println(\"The OTP (and related) files in the current directory are:\\n\")\n                val otpFiles = File(\".\").listFiles().filter {\n                    it.isFile() && it.name.isOtpRelated()\n                }.map { it.name }.toMutableList()\n                otpFiles.sort()\n                println(otpFiles.joinToString(\"\\n\"))\n            }\n\n            4 -> {  // Encrypt\n                print(\"OTP file name to use (without extension)\u00a0: \")\n                val keyFile = readLine()!! + \".1tp\"\n                val kf = File(keyFile)\n                if (kf.exists()) {\n                    val lines = File(keyFile).readLines().toMutableList()\n                    var first = lines.size\n                    for (i in 0 until lines.size) {\n                        if (lines[i].startsWith(\" \")) {\n                            first = i\n                            break\n                        }\n                    }\n                    if (first == lines.size) {\n                        println(\"\\nThat file has no unused lines.\")\n                        continue@mainLoop\n                    }\n                    val lines2 = lines.drop(first)  // get rid of comments and used lines\n\n                    println(\"Text to encrypt\u00a0:-\\n\")\n                    val text = readLine()!!.toUpperCase().toAlpha()\n                    val len = text.length\n                    var nLines = len / CHARS_PER_LINE\n                    if (len % CHARS_PER_LINE > 0) nLines++\n\n                    if (lines2.size >= nLines) {\n                        val key = lines2.take(nLines).joinToString(\"\").toAlpha()\n                        val encrypted = vigenere(text, key)\n                        val encFile = keyFile + \"_enc\"\n                        File(encFile).writeText(encrypted)\n                        println(\"\\n'$encFile' has been created in the current directory.\")\n                        for (i in first until first + nLines) {\n                            lines[i] = \"-\" + lines[i].drop(1)\n                        }\n                        File(keyFile).writeText(lines.joinToString(\"\\n\"))\n                        if (DEMO) {\n                            println(\"\\nThe contents of the encrypted file are\u00a0:\\n\")\n                            println(encrypted)\n                        }\n                    }\n                    else println(\"Not enough lines left in that file to do encryption\")\n                }\n                else println(\"\\nThat file does not exist.\")\n            }\n\n            5 -> {  // Decrypt\n                print(\"OTP file name to use (without extension)\u00a0: \")\n                val keyFile = readLine()!! + \".1tp_cpy\"\n                val kf = File(keyFile)\n                if (kf.exists()) {\n                    val keyLines = File(keyFile).readLines().toMutableList()\n                    var first = keyLines.size\n                    for (i in 0 until keyLines.size) {\n                        if (keyLines[i].startsWith(\" \")) {\n                            first = i\n                            break\n                        }\n                    }\n                    if (first == keyLines.size) {\n                        println(\"\\nThat file has no unused lines.\")\n                        continue@mainLoop\n                    }\n                    val keyLines2 = keyLines.drop(first)  // get rid of comments and used lines\n\n                    val encFile = keyFile.dropLast(3) + \"enc\"\n                    val ef = File(encFile)\n                    if (ef.exists()) {\n                        val encLines = File(encFile).readLines().drop(1)  // exclude comment line\n                        val nLines = encLines.size\n                        if (keyLines2.size >= nLines) {\n                            val encrypted = encLines.joinToString(\"\").toAlpha()\n                            val key = keyLines2.take(nLines).joinToString(\"\").toAlpha()\n                            val decrypted = vigenere(encrypted, key, false)\n                            val decFile = keyFile.dropLast(3) + \"dec\"\n                            File(decFile).writeText(decrypted)\n                            println(\"\\n'$decFile' has been created in the current directory.\")\n                            for (i in first until first + nLines) {\n                                keyLines[i] = \"-\" + keyLines[i].drop(1)\n                            }\n                            File(keyFile).writeText(keyLines.joinToString(\"\\n\"))\n                            if (DEMO) {\n                                println(\"\\nThe contents of the decrypted file are\u00a0:\\n\")\n                                println(decrypted)\n                            }\n                        }\n                        else println(\"Not enough lines left in that file to do decryption\")\n                    }\n                    else println(\"\\n'$encFile' is missing.\")\n                }\n                else println(\"\\nThat file does not exist.\")\n            }\n\n            else -> return  // Quit\n        }\n    }\n}\n\n\nOutput:\n\n1. Create one time pad file.\n\n2. Delete one time pad file.\n\n3. List one time pad files.\n\n4. Encrypt plain text.\n\n5. Decrypt cipher text.\n\n6. Quit program.\n\nYour choice (1 to 6)\u00a0: 1\n\nNote that encrypted lines always contain 48 characters.\n\nOTP file name to create (without extension)\u00a0: user1\nNumber of lines in OTP (max 1000)\u00a0: 4\n\n'user1.1tp' has been created in the current directory.\n'user1.1tp_cpy' has been created in the current directory.\n\nThe contents of these files are\u00a0:\n\n# OTP file\n MZSAVH VHJLRS YLFXZB JWAHSN AHPCSE RUJMFX ZZPMFB QTTNLM\n LDANXY LGJEBV IRKDTR NHKOPG ZDUBDC KOOWZC HEBKWC YAHOFY\n DYPCXG TGCBXC VFETFM VOTHNI ZCGKNL QONXYE IDCROZ LHLWMN\n YWSGDO YYSNNV QMOJFM AHVOGP CDFAKM HZCWEX CEAXXV INKAEO\n\n\n--<menu>--\n\nYour choice (1 to 6)\u00a0: 3\n\nThe OTP (and related) files in the current directory are:\n\nuser1.1tp\nuser1.1tp_cpy\n\n--<menu>--\n\nYour choice (1 to 6)\u00a0: 4\n\nOTP file name to use (without extension)\u00a0: user1\nText to encrypt\u00a0:-\n\nBeware the Jabberwock, my son! The jaws that bite, the claws that catch!\n\n'user1.1tp_enc' has been created in the current directory.\n\nThe contents of the encrypted file are\u00a0:\n\n# Encrypted file\n NDOAML OONURT ZPWTND TIYZGA TOTLSA JNQMYY HSTFMF SETJDF\n SDTPXR NNHVAO YSCVZU UTLAFM PEWGRH OJRCTF IOVEHK ZKETBQ\n\n\n--<menu>--\n\nYour choice (1 to 6)\u00a0: 5\n\nOTP file name to use (without extension)\u00a0: user1\n\n'user1.1tp_dec' has been created in the current directory.\n\nThe contents of the decrypted file are\u00a0:\n\n# Decrypted file\n BEWARE THEJAB BERWOC KMYSON THEJAW STHATB ITETHE CLAWST\n HATCAT CHYRZT QBSSGD HMBMQG QBCFOF EVDGUD BKUULI BKXFWS\n\n\n--<menu>-\n\nYour choice (1 to 6)\u00a0: 2\n\nNote that this will also delete ALL associated files.\n\nOTP file name to delete (without extension)\u00a0: user1\n\n'user1.1tp' has been deleted from the current directory.\n'user1.1tp_cpy' has been deleted from the current directory.\n'user1.1tp_enc' has been deleted from the current directory.\n'user1.1tp_dec' has been deleted from the current directory.\n\n--<menu>--\n\nYour choice (1 to 6)\u00a0: 6\n\n", "explain": "This uses the JDK's SecureRandom class for generating cryptographically strong random numbers. For convenience all three sub-tasks are catered for by a single, menu-based, program.\nInput/output for a sample session. In the interests of brevity, --<menu>-- indicates the re-display of the menu after the previous choice has been processed:  \n"}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Perl", "code": "\n# 20200814 added Perl programming solution\n\nuse strict;\nuse warnings;\n\nuse Crypt::OTP;\nuse Bytes::Random::Secure qw( random_bytes );\n\nprint \"Message    \u00a0: \", my $message = \"show me the monKey\", \"\\n\";\n\nmy $otp = random_bytes(length $message);\nprint \"Ord(OTP)   \u00a0: \", ( map { ord($_).' ' } (split //, $otp)   ) , \"\\n\";\n\nmy $cipher = OTP( $otp, $message, 1 );\nprint \"Ord(Cipher)\u00a0: \", ( map { ord($_).' ' } (split //, $cipher) ) , \"\\n\";\n\nprint \"Decoded    \u00a0: \",  OTP( $otp, $cipher, 1 ), \"\\n\";\n\n\nOutput:\nMessage    \u00a0: show me the monKey\nOrd(OTP)   \u00a0: 133 61 239 52 182 60 169 161 33 153 142 106 128 43 55 44 224 7\nOrd(Cipher)\u00a0: 246 85 128 67 150 81 204 129 85 241 235 74 237 68 89 103 133 126\nDecoded    \u00a0: show me the monKey\n\n", "explain": ""}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "Haskell", "code": "\n-- To compile into an executable:\n-- ghc -main-is OneTimePad OneTimePad.hs\n-- To run:\n-- ./OneTimePad --help\n\nmodule OneTimePad (main) where\n\nimport           Control.Monad\nimport           Data.Char\nimport           Data.Function         (on)\nimport qualified Data.Text             as T\nimport qualified Data.Text.IO          as TI\nimport           Data.Time\nimport           System.Console.GetOpt\nimport           System.Environment\nimport           System.Exit\nimport           System.IO\n\n-- Command-line options parsing\ndata Options = Options  { optCommand :: String\n                        , optInput   :: IO T.Text\n                        , optOutput  :: T.Text -> IO ()\n                        , optPad     :: (IO T.Text, T.Text -> IO ())\n                        , optLines   :: Int\n                        }\n\nstartOptions :: Options\nstartOptions = Options  { optCommand    = \"decrypt\"\n                        , optInput      = TI.getContents\n                        , optOutput     = TI.putStr\n                        , optPad        = (TI.getContents, TI.putStr)\n                        , optLines      = 0\n                        }\n\noptions :: [ OptDescr (Options -> IO Options) ]\noptions =\n    [ Option \"e\" [\"encrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"encrypt\" }))\n        \"Encrypt file\"\n    , Option \"d\" [\"decrypt\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"decrypt\" }))\n        \"Decrypt file (default)\"\n    , Option \"g\" [\"generate\"]\n        (NoArg\n            (\\opt -> return opt { optCommand = \"generate\" }))\n        \"Generate a one-time pad\"\n    , Option \"i\" [\"input\"]\n        (ReqArg\n            (\\arg opt -> return opt { optInput = TI.readFile arg })\n            \"FILE\")\n        \"Input file (for decryption and encryption)\"\n    , Option \"o\" [\"output\"]\n        (ReqArg\n            (\\arg opt -> return opt { optOutput = TI.writeFile arg })\n            \"FILE\")\n        \"Output file (for generation, decryption, and encryption)\"\n    , Option \"p\" [\"pad\"]\n        (ReqArg\n            (\\arg opt -> return opt { optPad = (TI.readFile arg,\n                                                TI.writeFile arg) })\n            \"FILE\")\n        \"One-time pad to use (for decryption and encryption)\"\n    , Option \"l\" [\"lines\"]\n        (ReqArg\n            (\\arg opt -> return opt { optLines = read arg :: Int })\n            \"LINES\")\n        \"New one-time pad's length (in lines of 48 characters) (for generation)\"\n    , Option \"V\" [\"version\"]\n        (NoArg\n            (\\_ -> do\n                hPutStrLn stderr \"Version 0.01\"\n                exitWith ExitSuccess))\n        \"Print version\"\n    , Option \"h\" [\"help\"]\n        (NoArg\n            (\\_ -> do\n                prg <- getProgName\n                putStrLn \"usage: OneTimePad [-h] [-V] [--lines LINES] [-i FILE] [-o FILE] [-p FILE] [--encrypt | --decrypt | --generate]\"\n                hPutStrLn stderr (usageInfo prg options)\n                exitWith ExitSuccess))\n        \"Show this help message and exit\"\n    ]\n\nmain :: IO ()\nmain = do\n  args <- getArgs\n  let (actions, nonOptions, errors) = getOpt RequireOrder options args\n  opts <- Prelude.foldl (>>=) (return startOptions) actions\n  let Options { optCommand = command\n              , optInput   = input\n              , optOutput  = output\n              , optPad     = (inPad, outPad)\n              , optLines   = linecnt } = opts\n\n  case command of\n    \"generate\" -> generate linecnt output\n    \"encrypt\"  -> do\n      inputContents <- clean <$> input\n      padContents <- inPad\n      output $ format $ encrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n    \"decrypt\"  -> do\n      inputContents <- unformat <$> input\n      padContents <- inPad\n      output $ decrypt inputContents $ unformat $ T.concat\n        $ dropWhile (\\t -> T.head t == '-' || T.head t == '#')\n        $ T.lines padContents\n      let discardLines = ceiling\n            $ ((/) `on` fromIntegral) (T.length inputContents) 48\n      outPad $ discard discardLines $ T.lines padContents\n\n{- | Discard used pad lines. Is only called at decryption to enable using the\nsame pad file for both encryption and decryption.\n-}\ndiscard :: Int -> [T.Text] -> T.Text\ndiscard 0 ts = T.unlines ts\ndiscard x (t:ts) = if (T.head t == '-' || T.head t == '#')\n  then T.unlines [t, (discard x ts)]\n  else T.unlines [(T.append (T.pack \"- \") t), (discard (x-1) ts)]\n\n{- | Clean the text from symbols that cannot be encrypted.\n-}\nclean :: T.Text -> T.Text\nclean = T.map toUpper . T.filter (\\c -> let oc = ord c\n                                   in oc >= 65 && oc <= 122\n                                   && (not $ oc >=91 && oc <= 96))\n\n{- | Format text (usually encrypted text) for pretty-printing it in a similar\nway to the example from Wikipedia (see Rosetta Code page for this task)\n-}\nformat :: T.Text -> T.Text\nformat = T.unlines . map (T.intercalate (T.pack \" \") . T.chunksOf 6)\n  . T.chunksOf 48\n\n{- | Unformat encrypted text, getting rid of characters that are irrelevant for\ndecryption.\n-}\nunformat :: T.Text -> T.Text\nunformat = T.filter (\\c -> c/='\\n' && c/=' ')\n\n{- | Generate a one-time pad and write it to file (specified as second\nparameter). Note: this only works on operating systems that have the\n\"/dev/random\" file.\n-}\ngenerate :: Int -> (T.Text -> IO ()) -> IO ()\ngenerate lines output = do\n  withBinaryFile \"/dev/random\" ReadMode\n    (\\handle -> do\n        contents <- replicateM (48 * lines) $ hGetChar handle\n        time <- getCurrentTime\n        output\n          $ T.unlines [ T.pack\n                        $ \"# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on \"\n                        ++ show time\n                      , format $ T.pack\n                        $ map (chr . (65 +) . flip mod 26 . ord) contents\n                      ])\n\n-- Helper function for encryption/decryption.\ncrypt :: (Int -> Int -> Int) -> T.Text -> T.Text -> T.Text\ncrypt f = T.zipWith ((chr .) . f `on` ord)\n\n-- Encrypt first parameter's contents, using the second parameter as a key.\nencrypt :: T.Text -> T.Text -> T.Text\nencrypt = crypt ((((+65) . flip mod 26 . subtract 130) .) . (+))\n\n-- Decrypt first parameter's contents, using the second parameter as a key.\ndecrypt :: T.Text -> T.Text -> T.Text\ndecrypt = crypt ((((+65) . flip mod 26) .) . (-))\n\n\nOutput:\n\n$ ./OneTimePad --help\nusage: OneTimePad [-h] [-V] [--lines LINES] [-i FILE] [-o FILE] [-p FILE] [--encrypt | --decrypt | --generate]\nOneTimePad\n  -e        --encrypt      Encrypt file\n  -d        --decrypt      Decrypt file (default)\n  -g        --generate     Generate a one-time pad\n  -i FILE   --input=FILE   Input file (for decryption and encryption)\n  -o FILE   --output=FILE  Output file (for generation, decryption, and encryption)\n  -p FILE   --pad=FILE     One-time pad to use (for decryption and encryption)\n  -l LINES  --lines=LINES  New one-time pad's length (in lines of 48 characters) (for generation)\n  -V        --version      Print version\n  -h        --help         Show this help message and exit\n\n\n$ ./OneTimePad -g -o test-pad.1tp -l 2\n\n\n$ ./OneTimePad -e -i jabberwock.txt -o encrypted.txt -p test-pad.1tp \n\n\n$ ./OneTimePad -d -i encrypted.txt -o decrypted.txt -p test-pad.1tp \n\n\n# OTP pad, generated by https://github.com/kssytsrk/one-time-pad on 2021-08-08 06:53:52.91928977 UTC\n- XAKUVI GLSWZB TEQCIR GNPHNR FBAPXQ IKXBCX BAAQIK OTTCQR\n- YCLYOE YTPFWC SBVHSL MTEKHN QYOVMN GXWTUV VHQWUE DSWVJJ\n\n\nYEGUMM ZSWFZC UIHYWT QZNZBE YIEYXM ADEBVY JTEJPO QETYIK\nFCEAOX AA\n\n\nBEWARETHEJABBERWOCKMYSONTHEJAWSTHATBITETHECLAWSTHATCATCH\n\n", "explain": "Help message:\nGenerate a pad, outputting into test-pad.1tp file:\nEncrypt a message using test-pad.1tp and jabberwock.txt (contents of jabberwock.txt: \"Beware the Jabberwock, my son! The jaws that bite, the claws that catch!\"), outputting the result into encrypted.txt:\nDecrypt the message, outputting the result into decrypted.txt:\nContents of test-pad.1tp:\nContents of encrypted.txt:\nContents of decrypted.txt:\n"}, {"task_name": "One-time pad", "task_url": "https://rosettacode.org/wiki/One-time_pad", "task_cat": "Encryption", "lang": "TypeScript", "code": "\n#!/usr/bin/env node\nimport { writeFileSync, existsSync, readFileSync, unlinkSync } from 'node:fs';\n//https://www.elitizon.com/2021/01-09-how-to-create-a-cli-command-with-typescript/#:~:text=%20Boost%20your%20productivity%20by%20creating%20your%20own,information.%20Required%3A%20string.%20%20...%20%20More%20\n\nconst a:string[] = process.argv;\nconst argv:string[] = a.splice(2)\n/**\n *  Extension of the pad files\n */\nconst padExtension:string = \".1tp\";\n/**\n * Extension of the key generated\n */\nconst keyExtension:string = \".key\";\n/**\n * Array of commands usable\n */\nconst commands:string[] = [\"--generate\", \"--encrypt\",\"--decrypt\"];\n/**\n * The alphabet\n */\nconst stringLetter = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n\n\n/**\n * Main function\n */\nconst main = ():void => {\n    // if no args have been give display help\n    if(argv.length == 0){\n        help();\n        return;\n    }\n\n    // Check if there is a command in the file\n    if(commands.includes(argv[0])){\n        let choise = argv[0].trim().toLowerCase();\n        if(choise === \"--generate\"){\n                console.log(\"Generating action chosen\");\n\n                // Check if the arguments have been given to generate a new key\n                if(!argv[1]){\n                    (\"Pad name not specified\")\n                    help();\n                    return;\n                }\n\n                // Check if the length of the filename is at least 4 characters\n                if(argv[1].length <= 3){\n                    console.log(\"The name of the pad should be at least 4 letters long\");\n                    help();\n                    return;\n                }\n\n                // Check if the filesize is a number(should be the second argv)\n                let fileSize = +argv[2];\n                if(isNaN(fileSize)){\n                    console.log(\"File size should be a number\");\n                    help();\n                    return\n                }\n\n                createFile(argv[1], fileSize)\n        }\n\n        // If the selected action is to encrypt\n        if( choise === \"--encrypt\"){\n                console.log(\"Encrypting action chosen\");\n                let padDataName = argv[2] ? `${argv[2].trim()}${padExtension}` : `${argv[1].trim()}${padExtension}`\n\n                // Check if the files exist\n                if(!argv[1] && !argv[2]){\n                    console.log(\"Parameters not given\");\n                    help();\n                    return;\n                }\n\n                // Check if the text file exists and the pad file\n                if(!existsSync(`${argv[1].trim().toLowerCase()}.txt`)){\n                    console.log(\"Text file doesn't exit\");\n                    help();\n                    return;\n                }\n\n                console.log(\"Reading file\")\n                // Get the data from the file as well as the data from the padfile\n                let fileDataEnc = readFileSync(`${argv[1].trim().toLowerCase()}.txt`, 'utf-8'); \n                \n                if(!existsSync(`${argv[2]}${padExtension}`)){\n                    console.log(\"1tp file doesn't exist, generating new 1pt file\");\n                    createFile(argv[1], fileDataEnc.length);\n                }\n\n                console.log(\"Reading 1pt file\");\n                // Get the pad data\n                let padDataEnc = RetrievePadData(padDataName);\n                \n                // if the file 1pt file has been specified but it's not big enough\n                if(fileDataEnc.length > padDataEnc.length){\n                    console.log(\"The file is bigger than the 1tp file. Generating a new padfile\");\n                    createFile(argv[1], fileDataEnc.length);\n                    padDataEnc = RetrievePadData(`${argv[1]}${padExtension}`)\n                }\n\n                console.log(\"Converting the file\");\n                let keyEnc = padFunction(fileDataEnc,padDataEnc);\n                createFile(`${argv[1]}.key`, keyEnc.length, false, keyEnc);\n\n        }\n\n\n        if(choise === \"--decrypt\"){\n                console.log(\"Decrypting action chosen\");\n\n                // Check if the necessary args were given\n                if(!argv[1]){\n                    console.log(\"No file specified For decryption specified\")\n                    return;\n                }\n                if(!argv[2]){\n                    console.log(\"No 1pt file was given, Please specify the file to use\");\n                    return;\n                }\n                if(!argv[3] || argv[3].trim() != '-o') {\n                   console.log(\"No file for output specified\");\n                }\n\n\n                let fileNameDec = `${argv[1].trim()}${keyExtension}`; \n                let padNameDec = `${argv[2].trim()}${padExtension}`;\n\n                // Check if the files exists or not\n                if(!existsSync(fileNameDec)){\n                    console.log(\"File specified does not exist\");\n                    return;\n                }\n                if(!existsSync(padNameDec)){\n                    console.log(\"1pt file specified doesn't exist\");\n                    return;\n                }\n\n                console.log(\"Read the encrypted file\");\n                let fileDataDec = readFileSync(fileNameDec, 'utf-8');\n                console.log(\"Reading the 1pt file\");\n                let padDataDec = RetrievePadData(padNameDec);\n\n                // decrypt the file\n                console.log(\"Generating the file\");\n                let keyDec = padFunction(fileDataDec, padDataDec)\n                \n\n                if(argv[3] && argv[3].trim()==='-o'){\n                    let textFileDec = `${argv[1].trim()}.txt`; \n                    if(!argv[4]){\n                        console.log(\"No output file specified, creating a new file\")\n                    }\n                    if(argv[4] && argv[4].trim().length < 3){\n                        console.log(\"The name of the output file should be greater than 4 characters\");\n                        console.log(`Creating new file`)\n                    }else {\n                        argv[4] ? textFileDec = `${argv[4].trim()}.txt` : textFileDec = `${argv[1].trim()}.txt`\n                    }\n\n                    console.log(\"Generating text file\");\n                    createFile(textFileDec, 0, false, keyDec );\n                    // https://sebhastian.com/javascript-delete-file/\n                    console.log(\"Deleting encrypted file\");\n                    unlinkSync(fileNameDec);\n                    console.log(\"Deleting 1pt file\");\n                    unlinkSync(padNameDec);\n                }else {\n                    console.log(\"The decrypted file is: \\n\\n\")\n                    console.log(keyDec);\n                }\n        }\n\n    }else {\n        console.log(\"Invalid action\");\n        help();\n        return;\n    }\n\n}\n\n/**\n * Display help messages\n */\nconst help = ():void => {\n    console.log(\"\\n\\n\\n1tp is a tool used to encrypt and decrypt text files\");\n    console.log(\"Look at the commands below to learn the use of it\");\n    console.log(\"The input file for encryption should be a txt file\");\n    console.log(\"The output will be a .kye file and a .1pt file\");\n    console.log(\"\\n\\n**Note: Don't add file extensios while running the command**\");\n    console.log(\"**Note: if during creation, the application encouters a file already existing, it will overwrite the file**\");\n    console.log(\"Options: \");\n    console.log(\"\\t -h | --help \\t\\t\\t\\t\\t\\t\\t View help\");\n    console.log(\"\\t --generate <pad name> <size of file> \\t\\t\\t\\t Create a pad file given a size\");\n    console.log(\"\\t --encrypt <txt file> <pad name> \\t\\t\\t\\t Encrypt a file give a pad file\");\n    console.log(\"\\t\\t\\t\\t All parameters for encryption are required\");\n    console.log(\"\\t --decrypt <key file> <pad name> -o <txt file>  \\t Decrypt a file give a key and 1tp files\");\n    console.log(\"\\t\\t\\t\\t If output file is not specified it will display the text inside the console\");\n    console.log(\"\\t\\t\\t\\t If only the `-o` option is defined without a txt file, it will create a new file\");\n    console.log(\"\\n** Note: Decrypting a file will delete the key and the 1pt files**\");\n}\n\n/**\n * Create a file with a random key\n * @param file Name of the file being created\n * @param fileSize Size of the file being created\n */\nconst createFile = (file:string, fileSize:number = 1024, key:boolean = true, data:string = \"\"):void => {\n    let fileName:string;\n    if(key){\n        fileName = `${file.trim().toLowerCase()}${padExtension}`;\n    \n        // https://flaviocopes.com/how-to-check-if-file-exists-node/#:~:text=The%20way%20to%20check%20if%20a%20file%20exists,the%20existence%20of%20a%20file%20without%20opening%20it%3A\n        \n        console.log(\"Generating the One time pad\");\n        const pad = generateOneTimePad(fileSize);\n        //https://code-boxx.com/create-save-files-javascript/#:~:text=%20The%20possible%20ways%20to%20create%20and%20save,the%20server.%0Avar%20data%20%3D%20new%20FormData...%20More%20\n        console.log(\"Writing to file\");\n        writeFileSync(fileName, pad);\n        return; \n        \n    }\n\n    console.log(\"Writing to file\");\n    writeFileSync(file, data);\n};\n\n/**\n * Generate a pad\n * @param fileSize Size of the new pad being created\n * @returns the new pad\n */\nconst generateOneTimePad = (fileSize:number):string => {\n    /**\n     * String in which we will put the one time pad\n     */\n    let otp:string = \"\";\n    /**\n     * used to organize the key\n     */\n    let splitCounter = 0;\n    let columnCounter = 0;\n\n    for (let i = 0; i <= fileSize;) {\n        if(splitCounter < 6){\n            // Generate a random letter from the alphabet given\n            otp += (stringLetter.charAt(Math.random()*1000%stringLetter.length))\n            splitCounter++;\n            i++;\n            continue;\n        }\n        // Used to organize the key so it looks estetic\n        if(columnCounter < 7){\n            splitCounter = 0;\n            columnCounter++;\n            otp += (\"\\t\");\n            continue;\n        }else{\n            splitCounter = 0;\n            columnCounter = 0;\n            otp += (\"\\n\");\n            continue;\n        }\n        \n    }\n    return otp\n}\n\n/**\n * Get the pad data from the file\n * @returns Text pad data\n */\nconst RetrievePadData = (padFile:string):string => {\n    // Retrieve the pad data\n    let padData = \"\" \n    // read the file\n    const data = readFileSync(`${padFile}`, 'utf-8') \n\n    // Take out all the tabs and new lines we added while generating the key\n    const stringArray = data.toString().split(\"\\n\");\n    for (let index = 0; index < stringArray.length; index++) {\n        const element = stringArray[index].split(\"\\t\");\n        for (let i = 0; i < element.length; i++) {\n            padData += element[i];\n        }\n    }\n\n    return padData;\n}\n\n/**\n * One time pad function\n * @param fileData Data of the file to encrypt or decrypt\n * @param padData Data of the pad file\n * @returns The generated encryption or decryption\n */\nconst padFunction = (fileData:string, padData:string ):string => {\n    let key = \"\";\n    for (let i = 0; i < fileData.length; i++) {\n        key += String.fromCharCode(-fileData[i].charCodeAt(0)+padData[i].toLowerCase().charCodeAt(0)+97);\n        // console.log(`File char: ${fileData[i]} ${fileData[i].charCodeAt(0)}   Pad Data: ${padData[i]} ${padData[i].toLocaleLowerCase().charCodeAt(0)}   Key: ${key[i]} ${key[i].charCodeAt(0)}`)\n    }\n    return key;\n}\n\nmain();\n\n\nOutput:\n\n $ node .\\bin\\\n1tp is a tool used to encrypt and decrypt text files\nLook at the commands below to learn the use of it\nThe input file for encryption should be a txt file\nThe output will be a .kye file and a .1pt file\n\n**Note: Don't add file extensios while running the command**\n**Note: if during creation, the application encouters a file already existing, it will overwrite the file**\nOptions: \n\t -h | --help \t\t\t\t\t\t\t View help\n\t --generate <pad name> <size of file> \t\t\t\t Create a pad file given a size\n\t --encrypt <txt file> <pad name> \t\t\t\t Encrypt a file give a pad file\n\t\t\t\t All parameters for encryption are required\n\t --decrypt <key file> <pad name> -o <txt file>  \t Decrypt a file give a key and 1tp files\n\t\t\t\t If output file is not specified it will display the text inside the console\n\t\t\t\t If only the `-o` option is defined without a txt file, it will create a new file\n\n** Note: Decrypting a file will delete the key and the 1pt files**\n\n\n $ node .\\bin\\ --encrypt fileName\nEncrypting action chosen\nReading file\n1tp file doesn't exist, generating new 1pt file\nGenerating the One time pad\nWriting to file\nReading 1pt file\nConverting the file\nWriting to file\n_________________________________________________\nfileName.1tp\n_________________________________________________\nSKGLQD\tOJANNV\tWTRAUE\tHOTWJK\tOCUEK\n\n_________________________________________________\nfileName.key\n_________________________________________________\n\ufffdd_Z\u00b2\\]\u00abUV\u00afrjraIfRdl\u00b5kfY]coa\n_________________________________________________\n\n\n $ node .\\bin\\ --decrypt fileName fileName\nDecrypting action chosen\nNo file for output specified\nRead the encrypted file\nReading the 1pt file\nGenerating the file\nThe decrypted file is: \n\nThis is my encrypted message\n\n\n\n\n", "explain": "Help Message\nEncrypting a file\nDecrypting a file\n"}]