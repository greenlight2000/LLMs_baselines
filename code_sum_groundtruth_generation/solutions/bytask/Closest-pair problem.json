[{"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\"\"\"\n  Compute nearest pair of points using two algorithms\n  \n  First algorithm is 'brute force' comparison of every possible pair.\n  Second, 'divide and conquer', is based on:\n    www.cs.iupui.edu/~xkzou/teaching/CS580/Divide-and-conquer-closestPair.ppt \n\"\"\"\n\nfrom random import randint, randrange\nfrom operator import itemgetter, attrgetter\n\ninfinity = float('inf')\n\n# Note the use of complex numbers to represent 2D points making distance == abs(P1-P2)\n\ndef bruteForceClosestPair(point):\n    numPoints = len(point)\n    if numPoints < 2:\n        return infinity, (None, None)\n    return min( ((abs(point[i] - point[j]), (point[i], point[j]))\n                 for i in range(numPoints-1)\n                 for j in range(i+1,numPoints)),\n                key=itemgetter(0))\n\ndef closestPair(point):\n    xP = sorted(point, key= attrgetter('real'))\n    yP = sorted(point, key= attrgetter('imag'))\n    return _closestPair(xP, yP)\n\ndef _closestPair(xP, yP):\n    numPoints = len(xP)\n    if numPoints <= 3:\n        return bruteForceClosestPair(xP)\n    Pl = xP[:numPoints/2]\n    Pr = xP[numPoints/2:]\n    Yl, Yr = [], []\n    xDivider = Pl[-1].real\n    for p in yP:\n        if p.real <= xDivider:\n            Yl.append(p)\n        else:\n            Yr.append(p)\n    dl, pairl = _closestPair(Pl, Yl)\n    dr, pairr = _closestPair(Pr, Yr)\n    dm, pairm = (dl, pairl) if dl < dr else (dr, pairr)\n    # Points within dm of xDivider sorted by Y coord\n    closeY = [p for p in yP  if abs(p.real - xDivider) < dm]\n    numCloseY = len(closeY)\n    if numCloseY > 1:\n        # There is a proof that you only need compare a max of 7 next points\n        closestY = min( ((abs(closeY[i] - closeY[j]), (closeY[i], closeY[j]))\n                         for i in range(numCloseY-1)\n                         for j in range(i+1,min(i+8, numCloseY))),\n                        key=itemgetter(0))\n        return (dm, pairm) if dm <= closestY[0] else closestY\n    else:\n        return dm, pairm\n    \ndef times():\n    ''' Time the different functions\n    '''\n    import timeit\n\n    functions = [bruteForceClosestPair, closestPair]\n    for f in functions:\n        print 'Time for', f.__name__, timeit.Timer(\n            '%s(pointList)' % f.__name__,\n            'from closestpair import %s, pointList' % f.__name__).timeit(number=1)\n    \n\n\npointList = [randint(0,1000)+1j*randint(0,1000) for i in range(2000)]\n\nif __name__ == '__main__':\n    pointList = [(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]\n    print pointList\n    print '  bruteForceClosestPair:', bruteForceClosestPair(pointList)\n    print '            closestPair:', closestPair(pointList)\n    for i in range(10):\n        pointList = [randrange(11)+1j*randrange(11) for i in range(10)]\n        print '\\n', pointList\n        print ' bruteForceClosestPair:', bruteForceClosestPair(pointList)\n        print '           closestPair:', closestPair(pointList)\n    print '\\n'\n    times()\n    times()\n    times()\n\n\nOutput: followed by timing comparisons\n\n[(5+9j), (9+3j), (2+0j), (8+4j), (7+4j), (9+10j), (1+9j), (8+2j), 10j, (9+6j)]\n  bruteForceClosestPair: (1.0, ((8+4j), (7+4j)))\n            closestPair: (1.0, ((8+4j), (7+4j)))\n\n[(10+6j), (7+0j), (9+4j), (4+8j), (7+5j), (6+4j), (1+9j), (6+4j), (1+3j), (5+0j)]\n bruteForceClosestPair: (0.0, ((6+4j), (6+4j)))\n           closestPair: (0.0, ((6+4j), (6+4j)))\n\n[(4+10j), (8+5j), (10+3j), (9+7j), (2+5j), (6+7j), (6+2j), (9+6j), (3+8j), (5+1j)]\n bruteForceClosestPair: (1.0, ((9+7j), (9+6j)))\n           closestPair: (1.0, ((9+7j), (9+6j)))\n\n[(10+0j), (3+10j), (10+7j), (1+8j), (5+10j), (8+8j), (4+7j), (6+2j), (6+10j), (9+3j)]\n bruteForceClosestPair: (1.0, ((5+10j), (6+10j)))\n           closestPair: (1.0, ((5+10j), (6+10j)))\n\n[(3+7j), (5+3j), 0j, (2+9j), (2+5j), (9+6j), (5+9j), (4+3j), (3+8j), (8+7j)]\n bruteForceClosestPair: (1.0, ((3+7j), (3+8j)))\n           closestPair: (1.0, ((4+3j), (5+3j)))\n\n[(4+3j), (10+9j), (2+7j), (7+8j), 0j, (3+10j), (10+2j), (7+10j), (7+3j), (1+4j)]\n bruteForceClosestPair: (2.0, ((7+8j), (7+10j)))\n           closestPair: (2.0, ((7+8j), (7+10j)))\n\n[(9+2j), (9+8j), (6+4j), (7+0j), (10+2j), (10+0j), (2+7j), (10+7j), (9+2j), (1+5j)]\n bruteForceClosestPair: (0.0, ((9+2j), (9+2j)))\n           closestPair: (0.0, ((9+2j), (9+2j)))\n\n[(3+3j), (8+2j), (4+0j), (1+1j), (9+10j), (5+0j), (2+3j), 5j, (5+0j), (7+0j)]\n bruteForceClosestPair: (0.0, ((5+0j), (5+0j)))\n           closestPair: (0.0, ((5+0j), (5+0j)))\n\n[(1+5j), (8+3j), (8+10j), (6+8j), (10+9j), (2+0j), (2+7j), (8+7j), (8+4j), (1+2j)]\n bruteForceClosestPair: (1.0, ((8+3j), (8+4j)))\n           closestPair: (1.0, ((8+3j), (8+4j)))\n\n[(8+4j), (8+6j), (8+0j), 0j, (10+7j), (10+6j), 6j, (1+3j), (1+8j), (6+9j)]\n bruteForceClosestPair: (1.0, ((10+7j), (10+6j)))\n           closestPair: (1.0, ((10+7j), (10+6j)))\n\n[(6+8j), (10+1j), 3j, (7+9j), (4+10j), (4+7j), (5+7j), (6+10j), (4+7j), (2+4j)]\n bruteForceClosestPair: (0.0, ((4+7j), (4+7j)))\n           closestPair: (0.0, ((4+7j), (4+7j)))\n\n\nTime for bruteForceClosestPair 4.57953371169\nTime for closestPair 0.122539596513\nTime for bruteForceClosestPair 5.13221177552\nTime for closestPair 0.124602707886\nTime for bruteForceClosestPair 4.83609397284\nTime for closestPair 0.119326618327\n>>> \n", "explain": "(Note how the two algorithms agree on the minimum distance, but may return a different pair of points if more than one pair of points share that minimum separation):\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n", "explain": "See Closest-pair problem/C\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n/*\n\tAuthor: Kevin Bacon\n\tDate: 04/03/2014\n\tTask: Closest-pair problem\n*/\n\n#include <iostream>\n#include <vector>\n#include <utility>\n#include <cmath>\n#include <random>\n#include <chrono>\n#include <algorithm>\n#include <iterator>\n\ntypedef std::pair<double, double> point_t;\ntypedef std::pair<point_t, point_t> points_t;\n\ndouble distance_between(const point_t& a, const point_t& b) {\n\treturn std::sqrt(std::pow(b.first - a.first, 2)\n\t\t+ std::pow(b.second - a.second, 2));\n}\n\nstd::pair<double, points_t> find_closest_brute(const std::vector<point_t>& points) {\n\tif (points.size() < 2) {\n\t\treturn { -1, { { 0, 0 }, { 0, 0 } } };\n\t}\n\tauto minDistance = std::abs(distance_between(points.at(0), points.at(1)));\n\tpoints_t minPoints = { points.at(0), points.at(1) };\n\tfor (auto i = std::begin(points); i != (std::end(points) - 1); ++i) {\n\t\tfor (auto j = i + 1; j < std::end(points); ++j) {\n\t\t\tauto newDistance = std::abs(distance_between(*i, *j));\n\t\t\tif (newDistance < minDistance) {\n\t\t\t\tminDistance = newDistance;\n\t\t\t\tminPoints.first = *i;\n\t\t\t\tminPoints.second = *j;\n\t\t\t}\n\t\t}\n\t}\n\treturn { minDistance, minPoints };\n}\n\nstd::pair<double, points_t> find_closest_optimized(const std::vector<point_t>& xP,\n\tconst std::vector<point_t>& yP) {\n\tif (xP.size() <= 3) {\n\t\treturn find_closest_brute(xP);\n\t}\n\tauto N = xP.size();\n\tauto xL = std::vector<point_t>();\n\tauto xR = std::vector<point_t>();\n\tstd::copy(std::begin(xP), std::begin(xP) + (N / 2), std::back_inserter(xL));\n\tstd::copy(std::begin(xP) + (N / 2), std::end(xP), std::back_inserter(xR));\n\tauto xM = xP.at((N-1) / 2).first;\n\tauto yL = std::vector<point_t>();\n\tauto yR = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yL), [&xM](const point_t& p) {\n\t\treturn p.first <= xM;\n\t});\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yR), [&xM](const point_t& p) {\n\t\treturn p.first > xM;\n\t});\n\tauto p1 = find_closest_optimized(xL, yL);\n\tauto p2 = find_closest_optimized(xR, yR);\n\tauto minPair = (p1.first <= p2.first) ? p1 : p2;\n\tauto yS = std::vector<point_t>();\n\tstd::copy_if(std::begin(yP), std::end(yP), std::back_inserter(yS), [&minPair, &xM](const point_t& p) {\n\t\treturn std::abs(xM - p.first) < minPair.first;\n\t});\n\tauto result = minPair;\n\tfor (auto i = std::begin(yS); i != (std::end(yS) - 1); ++i) {\n\t\tfor (auto k = i + 1; k != std::end(yS) &&\n\t\t ((k->second - i->second) < minPair.first); ++k) {\n\t\t\tauto newDistance = std::abs(distance_between(*k, *i));\n\t\t\tif (newDistance < result.first) {\n\t\t\t\tresult = { newDistance, { *k, *i } };\n\t\t\t}\n\t\t}\n\t}\n\treturn result;\n}\n\nvoid print_point(const point_t& point) {\n\tstd::cout << \"(\" << point.first\n\t\t<< \", \" << point.second\n\t\t<< \")\";\n}\n\nint main(int argc, char * argv[]) {\n\tstd::default_random_engine re(std::chrono::system_clock::to_time_t(\n\t\tstd::chrono::system_clock::now()));\n\tstd::uniform_real_distribution<double> urd(-500.0, 500.0);\n\tstd::vector<point_t> points(100);\n\tstd::generate(std::begin(points), std::end(points), [&urd, &re]() {\n                return point_t { 1000 + urd(re), 1000 + urd(re) };\n        });\n\tauto answer = find_closest_brute(points);\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.first < b.first;\n\t});\n\tauto xP = points;\n\tstd::sort(std::begin(points), std::end(points), [](const point_t& a, const point_t& b) {\n\t\treturn a.second < b.second;\n\t});\n\tauto yP = points;\n\tstd::cout << \"Min distance (brute): \" << answer.first << \" \";\n\tprint_point(answer.second.first);\n\tstd::cout << \", \";\n\tprint_point(answer.second.second);\n\tanswer = find_closest_optimized(xP, yP);\n\tstd::cout << \"\\nMin distance (optimized): \" << answer.first << \" \";\n\tprint_point(answer.second.first);\n\tstd::cout << \", \";\n\tprint_point(answer.second.second);\n\treturn 0;\n}\n\n\nOutput:\nMin distance (brute): 6.95886 (932.735, 1002.7), (939.216, 1000.17)\nMin distance (optimized): 6.95886 (932.735, 1002.7), (939.216, 1000.17)\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\nimport java.util.*;\n\npublic class ClosestPair\n{\n  public static class Point\n  {\n    public final double x;\n    public final double y;\n    \n    public Point(double x, double y)\n    {\n      this.x = x;\n      this.y = y;\n    }\n    \n    public String toString()\n    {  return \"(\" + x + \", \" + y + \")\";  }\n  }\n  \n  public static class Pair\n  {\n    public Point point1 = null;\n    public Point point2 = null;\n    public double distance = 0.0;\n    \n    public Pair()\n    {  }\n    \n    public Pair(Point point1, Point point2)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      calcDistance();\n    }\n    \n    public void update(Point point1, Point point2, double distance)\n    {\n      this.point1 = point1;\n      this.point2 = point2;\n      this.distance = distance;\n    }\n    \n    public void calcDistance()\n    {  this.distance = distance(point1, point2);  }\n    \n    public String toString()\n    {  return point1 + \"-\" + point2 + \"\u00a0: \" + distance;  }\n  }\n  \n  public static double distance(Point p1, Point p2)\n  {\n    double xdist = p2.x - p1.x;\n    double ydist = p2.y - p1.y;\n    return Math.hypot(xdist, ydist);\n  }\n  \n  public static Pair bruteForce(List<? extends Point> points)\n  {\n    int numPoints = points.size();\n    if (numPoints < 2)\n      return null;\n    Pair pair = new Pair(points.get(0), points.get(1));\n    if (numPoints > 2)\n    {\n      for (int i = 0; i < numPoints - 1; i++)\n      {\n        Point point1 = points.get(i);\n        for (int j = i + 1; j < numPoints; j++)\n        {\n          Point point2 = points.get(j);\n          double distance = distance(point1, point2);\n          if (distance < pair.distance)\n            pair.update(point1, point2, distance);\n        }\n      }\n    }\n    return pair;\n  }\n  \n  public static void sortByX(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.x < point2.x)\n            return -1;\n          if (point1.x > point2.x)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static void sortByY(List<? extends Point> points)\n  {\n    Collections.sort(points, new Comparator<Point>() {\n        public int compare(Point point1, Point point2)\n        {\n          if (point1.y < point2.y)\n            return -1;\n          if (point1.y > point2.y)\n            return 1;\n          return 0;\n        }\n      }\n    );\n  }\n  \n  public static Pair divideAndConquer(List<? extends Point> points)\n  {\n    List<Point> pointsSortedByX = new ArrayList<Point>(points);\n    sortByX(pointsSortedByX);\n    List<Point> pointsSortedByY = new ArrayList<Point>(points);\n    sortByY(pointsSortedByY);\n    return divideAndConquer(pointsSortedByX, pointsSortedByY);\n  }\n  \n  private static Pair divideAndConquer(List<? extends Point> pointsSortedByX, List<? extends Point> pointsSortedByY)\n  {\n    int numPoints = pointsSortedByX.size();\n    if (numPoints <= 3)\n      return bruteForce(pointsSortedByX);\n    \n    int dividingIndex = numPoints >>> 1;\n    List<? extends Point> leftOfCenter = pointsSortedByX.subList(0, dividingIndex);\n    List<? extends Point> rightOfCenter = pointsSortedByX.subList(dividingIndex, numPoints);\n    \n    List<Point> tempList = new ArrayList<Point>(leftOfCenter);\n    sortByY(tempList);\n    Pair closestPair = divideAndConquer(leftOfCenter, tempList);\n    \n    tempList.clear();\n    tempList.addAll(rightOfCenter);\n    sortByY(tempList);\n    Pair closestPairRight = divideAndConquer(rightOfCenter, tempList);\n    \n    if (closestPairRight.distance < closestPair.distance)\n      closestPair = closestPairRight;\n    \n    tempList.clear();\n    double shortestDistance =closestPair.distance;\n    double centerX = rightOfCenter.get(0).x;\n    for (Point point : pointsSortedByY)\n      if (Math.abs(centerX - point.x) < shortestDistance)\n        tempList.add(point);\n    \n    for (int i = 0; i < tempList.size() - 1; i++)\n    {\n      Point point1 = tempList.get(i);\n      for (int j = i + 1; j < tempList.size(); j++)\n      {\n        Point point2 = tempList.get(j);\n        if ((point2.y - point1.y) >= shortestDistance)\n          break;\n        double distance = distance(point1, point2);\n        if (distance < closestPair.distance)\n        {\n          closestPair.update(point1, point2, distance);\n          shortestDistance = distance;\n        }\n      }\n    }\n    return closestPair;\n  }\n  \n  public static void main(String[] args)\n  {\n    int numPoints = (args.length == 0) ? 1000 : Integer.parseInt(args[0]);\n    List<Point> points = new ArrayList<Point>();\n    Random r = new Random();\n    for (int i = 0; i < numPoints; i++)\n      points.add(new Point(r.nextDouble(), r.nextDouble()));\n    System.out.println(\"Generated \" + numPoints + \" random points\");\n    long startTime = System.currentTimeMillis();\n    Pair bruteForceClosestPair = bruteForce(points);\n    long elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Brute force (\" + elapsedTime + \" ms): \" + bruteForceClosestPair);\n    startTime = System.currentTimeMillis();\n    Pair dqClosestPair = divideAndConquer(points);\n    elapsedTime = System.currentTimeMillis() - startTime;\n    System.out.println(\"Divide and conquer (\" + elapsedTime + \" ms): \" + dqClosestPair);\n    if (bruteForceClosestPair.distance != dqClosestPair.distance)\n      System.out.println(\"MISMATCH\");\n  }\n}\n\n\nOutput:\njava ClosestPair 10000\nGenerated 10000 random points\nBrute force (1594 ms): (0.9246533850872104, 0.098709007587097)-(0.924591196030625, 0.09862206991823985)\u00a0: 1.0689077146927108E-4\nDivide and conquer (250 ms): (0.924591196030625, 0.09862206991823985)-(0.9246533850872104, 0.098709007587097)\u00a0: 1.0689077146927108E-4\n", "explain": "Both the brute-force and the divide-and-conquer methods are implemented.\nCode:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nclass Segment\n{\n    public Segment(PointF p1, PointF p2)\n    {\n        P1 = p1;\n        P2 = p2;\n    }\n\n    public readonly PointF P1;\n    public readonly PointF P2;\n\n    public float Length()\n    {\n        return (float)Math.Sqrt(LengthSquared());\n    }\n\n    public float LengthSquared()\n    {\n        return (P1.X - P2.X) * (P1.X - P2.X)\n            + (P1.Y - P2.Y) * (P1.Y - P2.Y);\n    }\n}\n\n\nSegment Closest_BruteForce(List<PointF> points)\n{\n    int n = points.Count;\n    var result = Enumerable.Range( 0, n-1)\n        .SelectMany( i => Enumerable.Range( i+1, n-(i+1) )\n            .Select( j => new Segment( points[i], points[j] )))\n            .OrderBy( seg => seg.LengthSquared())\n            .First();\n\n    return result;\n}\n\n\npublic static Segment MyClosestDivide(List<PointF> points)\n{\n   return MyClosestRec(points.OrderBy(p => p.X).ToList());\n}\n\nprivate static Segment MyClosestRec(List<PointF> pointsByX)\n{\n   int count = pointsByX.Count;\n   if (count <= 4)\n      return Closest_BruteForce(pointsByX);\n\n   // left and right lists sorted by X, as order retained from full list\n   var leftByX = pointsByX.Take(count/2).ToList();\n   var leftResult = MyClosestRec(leftByX);\n\n   var rightByX = pointsByX.Skip(count/2).ToList();\n   var rightResult = MyClosestRec(rightByX);\n\n   var result = rightResult.Length() < leftResult.Length() ? rightResult : leftResult;\n\n   // There may be a shorter distance that crosses the divider\n   // Thus, extract all the points within result.Length either side\n   var midX = leftByX.Last().X;\n   var bandWidth = result.Length();\n   var inBandByX = pointsByX.Where(p => Math.Abs(midX - p.X) <= bandWidth);\n\n   // Sort by Y, so we can efficiently check for closer pairs\n   var inBandByY = inBandByX.OrderBy(p => p.Y).ToArray();\n\n   int iLast = inBandByY.Length - 1;\n   for (int i = 0; i < iLast; i++ )\n   {\n      var pLower = inBandByY[i];\n\n      for (int j = i + 1; j <= iLast; j++)\n      {\n         var pUpper = inBandByY[j];\n\n         // Comparing each point to successivly increasing Y values\n         // Thus, can terminate as soon as deltaY is greater than best result\n         if ((pUpper.Y - pLower.Y) >= result.Length())\n            break;\n\n         if (Segment.Length(pLower, pUpper) < result.Length())\n            result = new Segment(pLower, pUpper);\n      }\n   }\n\n   return result;\n}\n\n\nvar randomizer = new Random(10);\nvar points = Enumerable.Range( 0, 10000).Select( i => new PointF( (float)randomizer.NextDouble(), (float)randomizer.NextDouble())).ToList();\nStopwatch sw = Stopwatch.StartNew();\nvar r1 = Closest_BruteForce(points);\nsw.Stop();\nDebugger.Log(1, \"\", string.Format(\"Time used (Brute force) (float): {0} ms\", sw.Elapsed.TotalMilliseconds));\nStopwatch sw2 = Stopwatch.StartNew();\nvar result2 = Closest_Recursive(points);\nsw2.Stop();\nDebugger.Log(1, \"\", string.Format(\"Time used (Divide & Conquer): {0} ms\",sw2.Elapsed.TotalMilliseconds));\nAssert.Equal(r1.Length(), result2.Length());\n\n\nOutput:\nTime used (Brute force) (float): 145731.8935 ms\nTime used (Divide & Conquer): 1139.2111 ms\n\n        Segment Closest_BruteForce(List<PointF> points)\n        {\n            Trace.Assert(points.Count >= 2);\n\n            int count = points.Count;\n            \n            // Seed the result - doesn't matter what points are used\n            // This just avoids having to do null checks in the main loop below\n            var result = new Segment(points[0], points[1]);\n            var bestLength = result.Length();\n\n            for (int i = 0; i < count; i++)\n                for (int j = i + 1; j < count; j++)\n                    if (Segment.Length(points[i], points[j]) < bestLength)\n                    {\n                        result = new Segment(points[i], points[j]);\n                        bestLength = result.Length();\n                    }\n\n            return result;\n        }\n\n\n        Segment Closest(List<PointF> points)\n        {\n            Trace.Assert(points.Count >= 2);\n\n            int count = points.Count;\n            points.Sort((lhs, rhs) => lhs.X.CompareTo(rhs.X));\n\n            var result = new Segment(points[0], points[1]);\n            var bestLength = result.Length();\n\n            for (int i = 0; i < count; i++)\n            {\n                var from = points[i];\n\n                for (int j = i + 1; j < count; j++)\n                {\n                    var to = points[j];\n\n                    var dx = to.X - from.X;\n                    if (dx >= bestLength)\n                    {\n                        break;\n                    }\n\n                    if (Segment.Length(from, to) < bestLength)\n                    {\n                        result = new Segment(from, to);\n                        bestLength = result.Length();\n                    }\n                }\n            }\n\n            return result;\n        }\n\n", "explain": "We provide a small helper class for distance comparisons:\nBrute force:\n\nAnd divide-and-conquer.  \nHowever, the difference in speed is still remarkable.\nNon Linq Brute Force:\nTargeted Search: Much simpler than divide and conquer, and actually runs faster for the random points.  Key optimization is that if the distance along the X axis is greater than the best total length you already have, you can terminate the inner loop early.  However, as only sorts in the X direction, it degenerates into an N^2 algorithm if all the points have the same X.  \n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\nfunction distance(p1, p2) {\n  var dx = Math.abs(p1.x - p2.x);\n  var dy = Math.abs(p1.y - p2.y);\n  return Math.sqrt(dx*dx + dy*dy);\n}\n\nfunction bruteforceClosestPair(arr) {\n  if (arr.length < 2) {\n    return Infinity;\n  } else {\n    var minDist = distance(arr[0], arr[1]);\n    var minPoints = arr.slice(0, 2);\n    \n    for (var i=0; i<arr.length-1; i++) {\n      for (var j=i+1; j<arr.length; j++) {\n        if (distance(arr[i], arr[j]) < minDist) {\n          minDist = distance(arr[i], arr[j]);\n          minPoints = [ arr[i], arr[j] ];\n        }\n      }\n    }\n    return {\n      distance: minDist,\n      points: minPoints\n    };\n  }\n}\n\n\nvar Point = function(x, y) {\n\tthis.x = x;\n\tthis.y = y;\n};\nPoint.prototype.getX = function() {\n\treturn this.x;\n};\nPoint.prototype.getY = function() {\n\treturn this.y;\n};\n\nvar mergeSort = function mergeSort(points, comp) {\n\tif(points.length < 2) return points;\n\n\n\tvar n = points.length,\n\t\ti = 0,\n\t\tj = 0,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\n\tvar leftPart = mergeSort( points.slice(0, leftN), comp),\n\t\trightPart = mergeSort( points.slice(rightN), comp );\n\n\tvar sortedPart = [];\n\n\twhile((i < leftPart.length) && (j < rightPart.length)) {\n\t\tif(comp(leftPart[i], rightPart[j]) < 0) {\n\t\t\tsortedPart.push(leftPart[i]);\n\t\t\ti += 1;\n\t\t}\n\t\telse {\n\t\t\tsortedPart.push(rightPart[j]);\n\t\t\tj += 1;\n\t\t}\n\t}\n\twhile(i < leftPart.length) {\n\t\tsortedPart.push(leftPart[i]);\n\t\ti += 1;\n\t}\n\twhile(j < rightPart.length) {\n\t\tsortedPart.push(rightPart[j]);\n\t\tj += 1;\n\t}\n\treturn sortedPart;\n};\n\nvar closestPair = function _closestPair(Px, Py) {\n\tif(Px.length < 2) return { distance: Infinity, pair: [ new Point(0, 0), new Point(0, 0) ] };\n\tif(Px.length < 3) {\n\t\t//find euclid distance\n\t\tvar d = Math.sqrt( Math.pow(Math.abs(Px[1].x - Px[0].x), 2) + Math.pow(Math.abs(Px[1].y - Px[0].y), 2) );\n\t\treturn {\n\t\t\tdistance: d,\n\t\t\tpair: [ Px[0], Px[1] ]\n\t\t};\n\t}\n\n\tvar\tn = Px.length,\n\t\tleftN = Math.floor(n / 2),\n\t\trightN = leftN;\n\n\tvar Xl = Px.slice(0, leftN),\n\t\tXr = Px.slice(rightN),\n\t\tXm = Xl[leftN - 1],\n\t\tYl = [],\n\t\tYr = [];\n\t//separate Py\n\tfor(var i = 0; i < Py.length; i += 1) {\n\t\tif(Py[i].x <= Xm.x)\n\t\t\tYl.push(Py[i]);\n\t\telse\n\t\t\tYr.push(Py[i]);\n\t}\n\n\tvar dLeft = _closestPair(Xl, Yl),\n\t\tdRight = _closestPair(Xr, Yr);\n\n\tvar minDelta = dLeft.distance,\n\t\tclosestPair = dLeft.pair;\n\tif(dLeft.distance > dRight.distance) {\n\t\tminDelta = dRight.distance;\n\t\tclosestPair = dRight.pair;\n\t}\n\n\n\t//filter points around Xm within delta (minDelta)\n\tvar closeY = [];\n\tfor(i = 0; i < Py.length; i += 1) {\n\t\tif(Math.abs(Py[i].x - Xm.x) < minDelta) closeY.push(Py[i]);\n\t}\n\t//find min within delta. 8 steps max\n\tfor(i = 0; i < closeY.length; i += 1) {\n\t\tfor(var j = i + 1; j < Math.min( (i + 8), closeY.length ); j += 1) {\n\t\t\tvar d = Math.sqrt( Math.pow(Math.abs(closeY[j].x - closeY[i].x), 2) + Math.pow(Math.abs(closeY[j].y - closeY[i].y), 2) );\n\t\t\tif(d < minDelta) {\n\t\t\t\tminDelta = d;\n\t\t\t\tclosestPair = [ closeY[i], closeY[j] ]\n\t\t\t}\n\t\t}\n\t}\n\n\treturn {\n\t\tdistance: minDelta,\n\t\tpair: closestPair\n\t};\n};\n\n\nvar points = [\n\tnew Point(0.748501, 4.09624),\n\tnew Point(3.00302, 5.26164),\n\tnew Point(3.61878,  9.52232),\n\tnew Point(7.46911,  4.71611),\n\tnew Point(5.7819,   2.69367),\n\tnew Point(2.34709,  8.74782),\n\tnew Point(2.87169,  5.97774),\n\tnew Point(6.33101,  0.463131),\n\tnew Point(7.46489,  4.6268),\n\tnew Point(1.45428,  0.087596)\n];\n\nvar sortX = function (a, b) { return (a.x < b.x) ? -1 : ((a.x > b.x) ? 1 : 0); }\nvar sortY = function (a, b) { return (a.y < b.y) ? -1 : ((a.y > b.y) ? 1 : 0); }\n\nvar Px = mergeSort(points, sortX);\nvar Py = mergeSort(points, sortY);\n\nconsole.log(JSON.stringify(closestPair(Px, Py))) // {\"distance\":0.0894096443343775,\"pair\":[{\"x\":7.46489,\"y\":4.6268},{\"x\":7.46911,\"y\":4.71611}]}\n\nvar points2 = [new Point(37100, 13118), new Point(37134, 1963), new Point(37181, 2008), new Point(37276, 21611), new Point(37307, 9320)];\n\nPx = mergeSort(points2, sortX);\nPy = mergeSort(points2, sortY);\n\nconsole.log(JSON.stringify(closestPair(Px, Py))); // {\"distance\":65.06919393998976,\"pair\":[{\"x\":37134,\"y\":1963},{\"x\":37181,\"y\":2008}]}\n\n", "explain": "Using bruteforce algorithm, the bruteforceClosestPair method below expects an array of objects with x- and y-members set to numbers, and returns an object containing the members distance and points.\ndivide-and-conquer method:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\n\nfunction [closest,closestpair] = closestPair(xP,yP)\n\n    N = numel(xP);\n\n    if(N <= 3)\n        \n        %Brute force closestpair\n        if(N < 2)\n            closest = +Inf;\n            closestpair = {};\n        else        \n            closest = norm(xP{1}-xP{2});\n            closestpair = {xP{1},xP{2}};\n\n            for i = ( 1:N-1 )\n                for j = ( (i+1):N )\n                    if ( norm(xP{i} - xP{j}) < closest )\n                        closest = norm(xP{i}-xP{j});\n                        closestpair = {xP{i},xP{j}};\n                    end %if\n                end %for\n            end %for\n        end %if (N < 2)\n    else\n        \n        halfN = ceil(N/2);\n        \n        xL = { xP{1:halfN} };\n        xR = { xP{halfN+1:N} };\n        xm = xP{halfN}(1);\n        \n        %cellfun( @(p)le(p(1),xm),yP ) is the same as { p \u2208 yP\u00a0: px \u2264 xm }\n        yLIndicies = cellfun( @(p)le(p(1),xm),yP );\n        \n        yL = { yP{yLIndicies} };\n        yR = { yP{~yLIndicies} };\n\n        [dL,pairL] = closestPair(xL,yL);\n        [dR,pairR] = closestPair(xR,yR);\n        \n        if dL < dR\n            dmin = dL;\n            pairMin = pairL;\n        else\n            dmin = dR;\n            pairMin = pairR;\n        end\n\n        %cellfun( @(p)lt(norm(xm-p(1)),dmin),yP ) is the same as\n        %{ p \u2208 yP\u00a0: |xm - px| < dmin }\n        yS = {yP{ cellfun( @(p)lt(norm(xm-p(1)),dmin),yP ) }};\n        nS = numel(yS);\n\n        closest = dmin;\n        closestpair = pairMin;\n\n        for i = (1:nS-1)\n            k = i+1;\n\n            while( (k<=nS) && (yS{k}(2)-yS{i}(2) < dmin) )\n\n                if norm(yS{k}-yS{i}) < closest\n                    closest = norm(yS{k}-yS{i});\n                    closestpair = {yS{k},yS{i}};\n                end\n\n                k = k+1;\n            end %while\n        end %for\n    end %if (N <= 3)\nend %closestPair\n\n\nOutput:\n[distance,pair]=closestPair({[0 -.3],[1 1],[1.5 2],[2 2],[3 3]},{[0 -.3],[1 1],[1.5 2],[2 2],[3 3]})\n\ndistance =\n\n   0.500000000000000\n\n\npair = \n\n    [1x2 double]    [1x2 double] %The pair is [1.5 2] and [2 2] which is correct\n\n", "explain": "This solution is an almost direct translation of the above pseudo-code into MATLAB.\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\n\n", "explain": "See Closest pair problem/Fortran\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\ntype xy struct {\n    x, y float64\n}\n\nconst n = 1000\nconst scale = 100.\n\nfunc d(p1, p2 xy) float64 {\n    return math.Hypot(p2.x-p1.x, p2.y-p1.y)\n}\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    points := make([]xy, n)\n    for i := range points {\n        points[i] = xy{rand.Float64() * scale, rand.Float64() * scale}\n    }\n    p1, p2 := closestPair(points)\n    fmt.Println(p1, p2)\n    fmt.Println(\"distance:\", d(p1, p2))\n}\n\nfunc closestPair(points []xy) (p1, p2 xy) {\n    if len(points) < 2 {\n        panic(\"at least two points expected\")\n    }\n    min := 2 * scale\n    for i, q1 := range points[:len(points)-1] {\n        for _, q2 := range points[i+1:] {\n            if dq := d(q1, q2); dq < min {\n                p1, p2 = q1, q2\n                min = dq\n            }\n        }\n    }\n    return\n}\n\n\n// implementation following algorithm described in\n// http://www.cs.umd.edu/~samir/grant/cp.pdf\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\n// number of points to search for closest pair\nconst n = 1e6\n\n// size of bounding box for points.\n// x and y will be random with uniform distribution in the range [0,scale).\nconst scale = 100.\n\n// point struct\ntype xy struct {\n    x, y float64 // coordinates\n    key  int64   // an annotation used in the algorithm\n}\n\nfunc d(p1, p2 xy) float64 {\n    return math.Hypot(p2.x-p1.x, p2.y-p1.y)\n}\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    points := make([]xy, n)\n    for i := range points {\n        points[i] = xy{rand.Float64() * scale, rand.Float64() * scale, 0}\n    }\n    p1, p2 := closestPair(points)\n    fmt.Println(p1, p2)\n    fmt.Println(\"distance:\", d(p1, p2))\n}\n\nfunc closestPair(s []xy) (p1, p2 xy) {\n    if len(s) < 2 {\n        panic(\"2 points required\")\n    }\n    var dxi float64\n    // step 0\n    for s1, i := s, 1; ; i++ {\n        // step 1: compute min distance to a random point\n        // (for the case of random data, it's enough to just try\n        // to pick a different point)\n        rp := i % len(s1)\n        xi := s1[rp]\n        dxi = 2 * scale\n        for p, xn := range s1 {\n            if p != rp {\n                if dq := d(xi, xn); dq < dxi {\n                    dxi = dq\n                }\n            }\n        }\n\n        // step 2: filter\n        invB := 3 / dxi             // b is size of a mesh cell\n        mx := int64(scale*invB) + 1 // mx is number of cells along a side\n        // construct map as a histogram:\n        // key is index into mesh.  value is count of points in cell\n        hm := map[int64]int{}\n        for ip, p := range s1 {\n            key := int64(p.x*invB)*mx + int64(p.y*invB)\n            s1[ip].key = key\n            hm[key]++\n        }\n        // construct s2 = s1 less the points without neighbors\n        s2 := make([]xy, 0, len(s1))\n        nx := []int64{-mx - 1, -mx, -mx + 1, -1, 0, 1, mx - 1, mx, mx + 1}\n        for i, p := range s1 {\n            nn := 0\n            for _, ofs := range nx {\n                nn += hm[p.key+ofs]\n                if nn > 1 {\n                    s2 = append(s2, s1[i])\n                    break\n                }\n            }\n        }\n\n        // step 3: done?\n        if len(s2) == 0 {\n            break\n        }\n        s1 = s2\n    }\n    // step 4: compute answer from approximation\n    invB := 1 / dxi\n    mx := int64(scale*invB) + 1\n    hm := map[int64][]int{}\n    for i, p := range s {\n        key := int64(p.x*invB)*mx + int64(p.y*invB)\n        s[i].key = key\n        hm[key] = append(hm[key], i)\n    }\n    nx := []int64{-mx - 1, -mx, -mx + 1, -1, 0, 1, mx - 1, mx, mx + 1}\n    var min = scale * 2\n    for ip, p := range s {\n        for _, ofs := range nx {\n            for _, iq := range hm[p.key+ofs] {\n                if ip != iq {\n                    if d1 := d(p, s[iq]); d1 < min {\n                        min = d1\n                        p1, p2 = p, s[iq]\n                    }\n                }\n            }\n        }\n    }\n    return p1, p2\n}\n\n", "explain": "Brute force\nO(n)\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nPoint = Struct.new(:x, :y)\n\ndef distance(p1, p2)\n  Math.hypot(p1.x - p2.x, p1.y - p2.y)\nend\n\ndef closest_bruteforce(points)\n  mindist, minpts = Float::MAX, []\n  points.combination(2) do |pi,pj|\n    dist = distance(pi, pj)\n    if dist < mindist\n      mindist = dist\n      minpts = [pi, pj]\n    end\n  end\n  [mindist, minpts]\nend\n\ndef closest_recursive(points)\n  return closest_bruteforce(points) if points.length <= 3\n  xP = points.sort_by(&:x)\n  mid = points.length / 2\n  xm = xP[mid].x\n  dL, pairL = closest_recursive(xP[0,mid])\n  dR, pairR = closest_recursive(xP[mid..-1])\n  dmin, dpair = dL<dR ? [dL, pairL] : [dR, pairR]\n  yP = xP.find_all {|p| (xm - p.x).abs < dmin}.sort_by(&:y)\n  closest, closestPair = dmin, dpair\n  0.upto(yP.length - 2) do |i|\n    (i+1).upto(yP.length - 1) do |k|\n      break if (yP[k].y - yP[i].y) >= dmin\n      dist = distance(yP[i], yP[k])\n      if dist < closest\n        closest = dist\n        closestPair = [yP[i], yP[k]]\n      end\n    end\n  end\n  [closest, closestPair]\nend\n\npoints = Array.new(100) {Point.new(rand, rand)}\np ans1 = closest_bruteforce(points)\np ans2 = closest_recursive(points)\nfail \"bogus!\" if ans1[0] != ans2[0]\n\nrequire 'benchmark'\n\npoints = Array.new(10000) {Point.new(rand, rand)}\nBenchmark.bm(12) do |x|\n  x.report(\"bruteforce\") {ans1 = closest_bruteforce(points)}\n  x.report(\"recursive\")  {ans2 = closest_recursive(points)}\nend\n\n\n[0.005299616045889868, [#<struct Point x=0.24805908871087445, y=0.8413503128160198>, #<struct Point x=0.24355227214243136, y=0.8385620275629906>]]\n[0.005299616045889868, [#<struct Point x=0.24355227214243136, y=0.8385620275629906>, #<struct Point x=0.24805908871087445, y=0.8413503128160198>]]\n                   user     system      total        real\nbruteforce    43.446000   0.000000  43.446000 ( 43.530062)\nrecursive      0.187000   0.000000   0.187000 (  0.190000)\n\n", "explain": "Sample output\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\n//! We interpret complex numbers as points in the Cartesian plane, here. We also use the\n//! [sweepline/plane sweep closest pairs algorithm][algorithm] instead of the divide-and-conquer\n//! algorithm, since it's (arguably) easier to implement, and an efficient implementation does not\n//! require use of unsafe.\n//!\n//! [algorithm]: http://www.cs.mcgill.ca/~cs251/ClosestPair/ClosestPairPS.html\nextern crate num;\n\nuse num::complex::Complex;\nuse std::cmp::{Ordering, PartialOrd};\nuse std::collections::BTreeSet;\ntype Point = Complex<f32>;\n\n/// Wrapper around `Point` (i.e. `Complex<f32>`) so that we can use a `TreeSet`\n#[derive(PartialEq)]\nstruct YSortedPoint {\n    point: Point,\n}\n\nimpl PartialOrd for YSortedPoint {\n    fn partial_cmp(&self, other: &YSortedPoint) -> Option<Ordering> {\n        (self.point.im, self.point.re).partial_cmp(&(other.point.im, other.point.re))\n    }\n}\n\nimpl Ord for YSortedPoint {\n    fn cmp(&self, other: &YSortedPoint) -> Ordering {\n        self.partial_cmp(other).unwrap()\n    }\n}\n\nimpl Eq for YSortedPoint {}\n\nfn closest_pair(points: &mut [Point]) -> Option<(Point, Point)> {\n    if points.len() < 2 {\n        return None;\n    }\n\n    points.sort_by(|a, b| (a.re, a.im).partial_cmp(&(b.re, b.im)).unwrap());\n\n    let mut closest_pair = (points[0], points[1]);\n    let mut closest_distance_sqr = (points[0] - points[1]).norm_sqr();\n    let mut closest_distance = closest_distance_sqr.sqrt();\n\n    // the strip that we inspect for closest pairs as we sweep right\n    let mut strip: BTreeSet<YSortedPoint> = BTreeSet::new();\n    strip.insert(YSortedPoint { point: points[0] });\n    strip.insert(YSortedPoint { point: points[1] });\n\n    // index of the leftmost point on the strip (on points)\n    let mut leftmost_idx = 0;\n\n    // Start the sweep!\n    for (idx, point) in points.iter().enumerate().skip(2) {\n        // Remove all points farther than `closest_distance` away from `point`\n        // along the x-axis\n        while leftmost_idx < idx {\n            let leftmost_point = &points[leftmost_idx];\n            if (leftmost_point.re - point.re).powi(2) < closest_distance_sqr {\n                break;\n            }\n            strip.remove(&YSortedPoint {\n                point: *leftmost_point,\n            });\n            leftmost_idx += 1;\n        }\n\n        // Compare to points in bounding box\n        {\n            let low_bound = YSortedPoint {\n                point: Point {\n                    re:\u00a0::std::f32::INFINITY,\n                    im: point.im - closest_distance,\n                },\n            };\n            let mut strip_iter = strip.iter().skip_while(|&p| p < &low_bound);\n            loop {\n                let point2 = match strip_iter.next() {\n                    None => break,\n                    Some(p) => p.point,\n                };\n                if point2.im - point.im >= closest_distance {\n                    // we've reached the end of the box\n                    break;\n                }\n                let dist_sqr = (*point - point2).norm_sqr();\n                if dist_sqr < closest_distance_sqr {\n                    closest_pair = (point2, *point);\n                    closest_distance_sqr = dist_sqr;\n                    closest_distance = dist_sqr.sqrt();\n                }\n            }\n        }\n\n        // Insert point into strip\n        strip.insert(YSortedPoint { point: *point });\n    }\n\n    Some(closest_pair)\n}\n\npub fn main() {\n    let mut test_data = [\n        Complex::new(0.654682, 0.925557),\n        Complex::new(0.409382, 0.619391),\n        Complex::new(0.891663, 0.888594),\n        Complex::new(0.716629, 0.996200),\n        Complex::new(0.477721, 0.946355),\n        Complex::new(0.925092, 0.818220),\n        Complex::new(0.624291, 0.142924),\n        Complex::new(0.211332, 0.221507),\n        Complex::new(0.293786, 0.691701),\n        Complex::new(0.839186, 0.728260),\n    ];\n    let (p1, p2) = closest_pair(&mut test_data[..]).unwrap();\n    println!(\"Closest pair: {} and {}\", p1, p2);\n    println!(\"Distance: {}\", (p1 - p2).norm_sqr().sqrt());\n}\n\n\nOutput:\nClosest pair: 0.891663+0.888594i and 0.925092+0.81822i\nDistance: 0.07791013\n\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nimport Foundation\n\nstruct Point {\n  var x: Double\n  var y: Double\n\n  func distance(to p: Point) -> Double {\n    let x = pow(p.x - self.x, 2)\n    let y = pow(p.y - self.y, 2)\n    \n    return (x + y).squareRoot()\n  }\n}\n\nextension Collection where Element == Point {\n  func closestPair() -> (Point, Point)? {\n    let (xP, xY) = (sorted(by: { $0.x < $1.x }), sorted(by: { $0.y < $1.y }))\n    \n    return Self.closestPair(xP, xY)?.1\n  }\n  \n  static func closestPair(_ xP: [Element], _ yP: [Element]) -> (Double, (Point, Point))? {\n    guard xP.count > 3 else { return xP.closestPairBruteForce() }\n    \n    let half = xP.count / 2\n    let xl = Array(xP[..<half])\n    let xr = Array(xP[half...])\n    let xm = xl.last!.x\n    let (yl, yr) = yP.reduce(into: ([Element](), [Element]()), {cur, el in\n      if el.x > xm {\n        cur.1.append(el)\n      } else {\n        cur.0.append(el)\n      }\n    })\n    \n    guard let (distanceL, pairL) = closestPair(xl, yl) else { return nil }\n    guard let (distanceR, pairR) = closestPair(xr, yr) else { return nil }\n    \n    let (dMin, pairMin) = distanceL > distanceR ? (distanceR, pairR) : (distanceL, pairL)\n    \n    let ys = yP.filter({ abs(xm - $0.x) < dMin })\n    \n    var (closest, pairClosest) = (dMin, pairMin)\n    \n    for i in 0..<ys.count {\n      let p1 = ys[i]\n      \n      for k in i+1..<ys.count {\n        let p2 = ys[k]\n        \n        guard abs(p2.y - p1.y) < dMin else { break }\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < closest {\n          (closest, pairClosest) = (distance, (p1, p2))\n        }\n      }\n    }\n    \n    return (closest, pairClosest)\n  }\n  \n  func closestPairBruteForce() -> (Double, (Point, Point))? {\n    guard count >= 2 else { return nil }\n    \n    var closestPoints = (self.first!, self[index(after: startIndex)])\n    var minDistance = abs(closestPoints.0.distance(to: closestPoints.1))\n    \n    guard count != 2 else { return (minDistance, closestPoints) }\n    \n    for i in 0..<count {\n      for j in i+1..<count {\n        let (iIndex, jIndex) = (index(startIndex, offsetBy: i), index(startIndex, offsetBy: j))\n        let (p1, p2) = (self[iIndex], self[jIndex])\n        \n        let distance = abs(p1.distance(to: p2))\n        \n        if distance < minDistance {\n          minDistance = distance\n          closestPoints = (p1, p2)\n        }\n      }\n    }\n    \n    return (minDistance, closestPoints)\n  }\n}\n\nvar points = [Point]()\n\nfor _ in 0..<10_000 {\n  points.append(Point(\n    x: .random(in: -10.0...10.0),\n    y: .random(in: -10.0...10.0)\n  ))\n}\n\nprint(points.closestPair()!)\n\n\nOutput:\n(Point(x: 5.279430517795172, y: 8.85108182685002), Point(x: 5.278427575530877, y: 8.851990433099456))\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nWorks with: R version 2.8.1+\n\nclosest_pair_brute <-function(x,y,plotxy=F) { \n    xy = cbind(x,y)\n    cp = bruteforce(xy)\n    cat(\"\\n\\nShortest path found = \\n From:\\t\\t(\",cp[1],',',cp[2],\")\\n To:\\t\\t(\",cp[3],',',cp[4],\")\\n Distance:\\t\",cp[5],\"\\n\\n\",sep=\"\")\n    if(plotxy) {\n        plot(x,y,pch=19,col='black',main=\"Closest Pair\", asp=1)\n        points(cp[1],cp[2],pch=19,col='red')\n        points(cp[3],cp[4],pch=19,col='red')\n    }\n    distance <- function(p1,p2) {\n        x1 = (p1[1])\n        y1 = (p1[2]) \n        x2 = (p2[1])\n        y2 = (p2[2]) \n        sqrt((x2-x1)^2 + (y2-y1)^2)\n    }\n    bf_iter <- function(m,p,idx=NA,d=NA,n=1) {\n        dd = distance(p,m[n,])\n        if((is.na(d) || dd<=d) && p!=m[n,]){d = dd; idx=n;}\n        if(n == length(m[,1])) { c(m[idx,],d) }\n        else bf_iter(m,p,idx,d,n+1)\n    }\n    bruteforce <- function(pmatrix,n=1,pd=c(NA,NA,NA,NA,NA)) {\n        p = pmatrix[n,]\n        ppd = c(p,bf_iter(pmatrix,p))\n        if(ppd[5]<pd[5] || is.na(pd[5])) pd = ppd\n        if(n==length(pmatrix[,1]))  pd \n        else bruteforce(pmatrix,n+1,pd)\n    }\n}\n\n\nclosestPair<-function(x,y)\n  {\n  distancev <- function(pointsv)\n    {\n    x1 <- pointsv[1]\n    y1 <- pointsv[2]\n    x2 <- pointsv[3]\n    y2 <- pointsv[4]\n    sqrt((x1 - x2)^2 + (y1 - y2)^2)\n    }\n  pairstocompare <- t(combn(length(x),2))\n  pointsv <- cbind(x[pairstocompare[,1]],y[pairstocompare[,1]],x[pairstocompare[,2]],y[pairstocompare[,2]])\n  pairstocompare <- cbind(pairstocompare,apply(pointsv,1,distancev))\n  minrow <- pairstocompare[pairstocompare[,3] == min(pairstocompare[,3])]\n  if (!is.null(nrow(minrow))) {print(\"More than one point at this distance!\"); minrow <- minrow[1,]}\n  cat(\"The closest pair is:\\n\\tPoint 1: \",x[minrow[1]],\", \",y[minrow[1]],\n                          \"\\n\\tPoint 2: \",x[minrow[2]],\", \",y[minrow[2]],\n                          \"\\n\\tDistance: \",minrow[3],\"\\n\",sep=\"\")\n  c(distance=minrow[3],x1.x=x[minrow[1]],y1.y=y[minrow[1]],x2.x=x[minrow[2]],y2.y=y[minrow[2]])\n  }\n\n\nclosest.pairs <- function(x, y=NULL, ...){\n      # takes two-column object(x,y-values), or creates such an object from x and y values\n       if(!is.null(y))  x <- cbind(x, y)\n       \n       distances <- dist(x)\n        min.dist <- min(distances)\n          point.pair <- combn(1:nrow(x), 2)[, which.min(distances)]\n       \n     cat(\"The closest pair is:\\n\\t\", \n      sprintf(\"Point 1:\u00a0%.3f,\u00a0%.3f \\n\\tPoint 2:\u00a0%.3f,\u00a0%.3f \\n\\tDistance:\u00a0%.3f.\\n\", \n        x[point.pair[1],1], x[point.pair[1],2], \n          x[point.pair[2],1], x[point.pair[2],2],  \n            min.dist), \n            sep=\"\"   )\n     c( x1=x[point.pair[1],1],y1=x[point.pair[1],2],\n        x2=x[point.pair[2],1],y2=x[point.pair[2],2],\n        distance=min.dist)\n     }\n\nExamplex = (sample(-1000.00:1000.00,100))\ny = (sample(-1000.00:1000.00,length(x)))\ncp = closest.pairs(x,y)\n#cp = closestPair(x,y)\nplot(x,y,pch=19,col='black',main=\"Closest Pair\", asp=1)\npoints(cp[\"x1.x\"],cp[\"y1.y\"],pch=19,col='red')\npoints(cp[\"x2.x\"],cp[\"y2.y\"],pch=19,col='red')\n#closest_pair_brute(x,y,T)\n\nPerformance\nsystem.time(closest_pair_brute(x,y), gcFirst = TRUE)\nShortest path found =\n From:          (32,-987)\n To:            (25,-993)\n Distance:      9.219544\n\n   user  system elapsed\n   0.35    0.02    0.37\n\nsystem.time(closest.pairs(x,y), gcFirst = TRUE)\nThe closest pair is:\n        Point 1: 32.000, -987.000\n        Point 2: 25.000, -993.000\n        Distance: 9.220.\n\n   user  system elapsed\n   0.08    0.00    0.10\n\nsystem.time(closestPair(x,y), gcFirst = TRUE)\nThe closest pair is:\n        Point 1: 32, -987\n        Point 2: 25, -993\n        Distance: 9.219544\n\n   user  system elapsed\n   0.17    0.00    0.19\n\n\nclosest.pairs.bruteforce <- function(x, y=NULL)\n{\n\tif (!is.null(y))\n\t{\n\t\tx <- cbind(x,y)\n\t}\n\td <- dist(x)\n\tcp <- x[combn(1:nrow(x), 2)[, which.min(d)],]\n\tlist(p1=cp[1,], p2=cp[2,], d=min(d))\n}\n\nclosest.pairs.dandc <- function(x, y=NULL)\n{\n\tif (!is.null(y))\n\t{\n\t\tx <- cbind(x,y)\n\t}\n\tif (sd(x[,\"x\"]) < sd(x[,\"y\"]))\n\t{\n\t\tx <- cbind(x=x[,\"y\"],y=x[,\"x\"])\n\t\tswap <- TRUE\n\t}\n\telse\n\t{\n\t\tswap <- FALSE\n\t}\n\txp <- x[order(x[,\"x\"]),]\n\t.cpdandc.rec <- function(xp,yp)\n\t{\n\t\tn <- dim(xp)[1]\n\t\tif (n <= 4)\n\t\t{\n\t\t\tclosest.pairs.bruteforce(xp)\n\t\t}\n\t\telse\n\t\t{\n\t\t\txl <- xp[1:floor(n/2),]\n\t\t\txr <- xp[(floor(n/2)+1):n,]\n\t\t\tcpl <- .cpdandc.rec(xl)\n\t\t\tcpr <- .cpdandc.rec(xr)\n\t\t\tif (cpl$d<cpr$d) cp <- cpl else cp <- cpr\n\t\t\tcp\n\t\t}\n\t}\n\tcp <- .cpdandc.rec(xp)\n\t\n\typ <- x[order(x[,\"y\"]),]\n\txm <- xp[floor(dim(xp)[1]/2),\"x\"]\n\tys <- yp[which(abs(xm - yp[,\"x\"]) <= cp$d),]\n\tnys <- dim(ys)[1]\n\tif (!is.null(nys) && nys > 1)\n\t{\n\t\tfor (i in 1:(nys-1))\n\t\t{\n\t\t\tk <- i + 1\n\t\t\twhile (k <= nys && ys[i,\"y\"] - ys[k,\"y\"] < cp$d)\n\t\t\t{\n\t\t\t\td <- sqrt((ys[k,\"x\"]-ys[i,\"x\"])^2 + (ys[k,\"y\"]-ys[i,\"y\"])^2)\n\t\t\t\tif (d < cp$d) cp <- list(p1=ys[i,],p2=ys[k,],d=d)\n\t\t\t\tk <- k + 1\n\t\t\t}\n\t\t}\n\t}\n\tif (swap)\n\t{\n\t\tlist(p1=cbind(x=cp$p1[\"y\"],y=cp$p1[\"x\"]),p2=cbind(x=cp$p2[\"y\"],y=cp$p2[\"x\"]),d=cp$d)\n\t}\n\telse\n\t{\n\t\tcp\n\t}\n}\n\n# Test functions\ncat(\"How many points?\\n\")\nn <- scan(what=integer(),n=1)\nx <- rnorm(n)\ny <- rnorm(n)\ntstart <- proc.time()[3]\ncat(\"Closest pairs divide and conquer:\\n\")\nprint(cp <- closest.pairs.dandc(x,y))\ncat(sprintf(\"That took\u00a0%.2f seconds.\\n\",proc.time()[3] - tstart))\nplot(x,y)\npoints(c(cp$p1[\"x\"],cp$p2[\"x\"]),c(cp$p1[\"y\"],cp$p2[\"y\"]),col=\"red\")\ntstart <- proc.time()[3]\ncat(\"\\nClosest pairs brute force:\\n\")\nprint(closest.pairs.bruteforce(x,y))\ncat(sprintf(\"That took\u00a0%.2f seconds.\\n\",proc.time()[3] - tstart))\n\n\nOutput:\nHow many points?\n1: 500\nRead 1 item\nClosest pairs divide and conquer:\n$p1\n         x          y \n1.68807938 0.05876328 \n\n$p2\n         x          y \n1.68904694 0.05878173 \n\n$d\n[1] 0.0009677302\n\nThat took 0.43 seconds.\n\nClosest pairs brute force:\n$p1\n         x          y \n1.68807938 0.05876328 \n\n$p2\n         x          y \n1.68904694 0.05878173 \n\n$d\n[1] 0.0009677302\n\nThat took 6.38 seconds.\n\n", "explain": "Brute force solution as per wikipedia pseudo-code\nQuicker brute force solution for R that makes use of the apply function native to R for dealing with matrices.  It expects x and y to take the form of separate vectors.\n\nThis is the quickest version, that makes use of the 'dist' function of R. It takes a two-column object of x,y-values as input, or creates such an object from seperate x and y-vectors.\nUsing dist function for brute force, but divide and conquer (as per pseudocode) for speed:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Visual_FoxPro", "code": "\nCLOSE DATABASES ALL\nCREATE CURSOR pairs(id I, xcoord B(6), ycoord B(6))\nINSERT INTO pairs VALUES (1, 0.654682, 0.925557)\nINSERT INTO pairs VALUES (2, 0.409382, 0.619391)\nINSERT INTO pairs VALUES (3, 0.891663, 0.888594)\nINSERT INTO pairs VALUES (4, 0.716629, 0.996200)\nINSERT INTO pairs VALUES (5, 0.477721, 0.946355)\nINSERT INTO pairs VALUES (6, 0.925092, 0.818220)\nINSERT INTO pairs VALUES (7, 0.624291, 0.142924)\nINSERT INTO pairs VALUES (8, 0.211332, 0.221507)\nINSERT INTO pairs VALUES (9, 0.293786, 0.691701)\nINSERT INTO pairs VALUES (10, 0.839186, 0.728260)\n\nSELECT p1.id As id1, p2.id As id2, ;\n(p1.xcoord-p2.xcoord)^2 + (p1.ycoord-p2.ycoord)^2 As dist2 ;\nFROM pairs p1 JOIN pairs p2 ON p1.id < p2.id ORDER BY 3 INTO CURSOR tmp\n\nGO TOP\n? \"Closest pair is \" + TRANSFORM(id1) + \" and \" + TRANSFORM(id2) + \".\"\n? \"Distance is \" + TRANSFORM(SQRT(dist2))\n\n\nOutput:\nVisual FoxPro uses 1 based indexing,\n\nClosest pair is 3 and 6.\nDistance is 0.077910.\n\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Ada.Text_IO;\n\nprocedure Closest is\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Float);\n\n   Dimension : constant := 2;\n   type Vector is array (1 .. Dimension) of Float;\n   type Matrix is array (Positive range <>) of Vector;\n\n   -- calculate the distance of two points\n   function Distance (Left, Right : Vector) return Float is\n      Result : Float := 0.0;\n      Offset : Natural := 0;\n   begin\n      loop\n         Result := Result + (Left(Left'First + Offset) - Right(Right'First + Offset))**2;\n         Offset := Offset + 1;\n         exit when Offset >= Left'Length;\n      end loop;\n      return Math.Sqrt (Result);\n   end Distance;\n\n   -- determine the two closest points inside a cloud of vectors\n   function Get_Closest_Points (Cloud : Matrix) return Matrix is\n      Result : Matrix (1..2);\n      Min_Distance : Float;\n   begin\n      if Cloud'Length(1) < 2 then\n         raise Constraint_Error;\n      end if;\n      Result := (Cloud (Cloud'First), Cloud (Cloud'First + 1));\n      Min_Distance := Distance (Cloud (Cloud'First), Cloud (Cloud'First + 1));\n      for I in Cloud'First (1) .. Cloud'Last(1) - 1 loop\n         for J in I + 1 .. Cloud'Last(1) loop\n            if Distance (Cloud (I), Cloud (J)) < Min_Distance then\n               Min_Distance := Distance (Cloud (I), Cloud (J));\n               Result := (Cloud (I), Cloud (J));\n            end if;\n         end loop;\n      end loop;\n      return Result;\n   end Get_Closest_Points;\n\n   Test_Cloud : constant Matrix (1 .. 10) := ( (5.0, 9.0),  (9.0, 3.0),\n                                               (2.0, 0.0),  (8.0, 4.0),\n                                               (7.0, 4.0),  (9.0, 10.0),\n                                               (1.0, 9.0),  (8.0, 2.0),\n                                               (0.0, 10.0), (9.0, 6.0));\n   Closest_Points : Matrix := Get_Closest_Points (Test_Cloud);\n\n   Second_Test : constant Matrix (1 .. 10) := ( (0.654682, 0.925557), (0.409382, 0.619391),\n                                                (0.891663, 0.888594), (0.716629,   0.9962),\n                                                (0.477721, 0.946355), (0.925092,  0.81822),\n                                                (0.624291, 0.142924), (0.211332, 0.221507),\n                                                (0.293786, 0.691701), (0.839186,  0.72826));\n   Second_Points : Matrix := Get_Closest_Points (Second_Test);\nbegin\n   Ada.Text_IO.Put_Line (\"Closest Points:\");\n   Ada.Text_IO.Put_Line (\"P1: \" & Float'Image (Closest_Points (1) (1)) & \" \" & Float'Image (Closest_Points (1) (2)));\n   Ada.Text_IO.Put_Line (\"P2: \" & Float'Image (Closest_Points (2) (1)) & \" \" & Float'Image (Closest_Points (2) (2)));\n   Ada.Text_IO.Put_Line (\"Distance: \" & Float'Image (Distance (Closest_Points (1), Closest_Points (2))));\n   Ada.Text_IO.Put_Line (\"Closest Points 2:\");\n   Ada.Text_IO.Put_Line (\"P1: \" & Float'Image (Second_Points (1) (1)) & \" \" & Float'Image (Second_Points (1) (2)));\n   Ada.Text_IO.Put_Line (\"P2: \" & Float'Image (Second_Points (2) (1)) & \" \" & Float'Image (Second_Points (2) (2)));\n   Ada.Text_IO.Put_Line (\"Distance: \" & Float'Image (Distance (Second_Points (1), Second_Points (2))));\nend Closest;\n\n\nOutput:\nClosest Points:\nP1:  8.00000E+00  4.00000E+00\nP2:  7.00000E+00  4.00000E+00\nDistance:  1.00000E+00\nClosest Points 2:\nP1:  8.91663E-01  8.88594E-01\nP2:  9.25092E-01  8.18220E-01\nDistance:  7.79101E-02\n", "explain": "Dimension independent, but has to be defined at procedure call time \n(could be a parameter). \nOutput is simple, can be formatted using Float_IO.\nclosest.adb: (uses brute force algorithm)\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nfunction closestpair(P::Vector{Vector{T}}) where T <: Number\n    N = length(P)\n    if N < 2 return (Inf, ()) end\n    mindst = norm(P[1] - P[2])\n    minpts = (P[1], P[2])\n    for i in 1:N-1, j in i+1:N\n        tmpdst = norm(P[i] - P[j])\n        if tmpdst < mindst\n            mindst = tmpdst\n            minpts = (P[i], P[j])\n        end\n    end\n    return mindst, minpts\nend\n\nclosestpair([[0, -0.3], [1., 1.], [1.5, 2], [2, 2], [3, 3]])\n\n", "explain": "Brute-force algorithm:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n// version 1.1.2\n\ntypealias Point = Pair<Double, Double>\n\nfun distance(p1: Point, p2: Point) = Math.hypot(p1.first- p2.first, p1.second - p2.second)\n\nfun bruteForceClosestPair(p: List<Point>): Pair<Double, Pair<Point, Point>> {\n    val n = p.size\n    if (n < 2) throw IllegalArgumentException(\"Must be at least two points\")\n    var minPoints = p[0] to p[1]\n    var minDistance = distance(p[0], p[1])\n    for (i in 0 until n - 1)\n        for (j in i + 1 until n) {\n            val dist = distance(p[i], p[j])\n            if (dist < minDistance) {\n                minDistance = dist\n                minPoints = p[i] to p[j]\n            }\n        }\n    return minDistance to Pair(minPoints.first, minPoints.second)\n}\n\nfun optimizedClosestPair(xP: List<Point>, yP: List<Point>): Pair<Double, Pair<Point, Point>> {\n    val n = xP.size\n    if (n <= 3) return bruteForceClosestPair(xP)\n    val xL = xP.take(n / 2)\n    val xR = xP.drop(n / 2)\n    val xm = xP[n / 2 - 1].first\n    val yL = yP.filter { it.first <= xm }\n    val yR = yP.filter { it.first >  xm }\n    val (dL, pairL) = optimizedClosestPair(xL, yL)\n    val (dR, pairR) = optimizedClosestPair(xR, yR)\n    var dmin = dR\n    var pairMin = pairR\n    if (dL < dR) {\n        dmin = dL\n        pairMin = pairL\n    }\n    val yS = yP.filter { Math.abs(xm - it.first) < dmin }\n    val nS = yS.size\n    var closest = dmin\n    var closestPair = pairMin\n    for (i in 0 until nS - 1) {\n        var k = i + 1\n        while (k < nS && (yS[k].second - yS[i].second < dmin)) {\n            val dist = distance(yS[k], yS[i])\n            if (dist < closest) {\n                closest = dist\n                closestPair = Pair(yS[k], yS[i])\n            }\n            k++\n        }\n    }\n    return closest to closestPair\n}\n\n\nfun main(args: Array<String>) {\n    val points = listOf(\n        listOf(\n            5.0 to  9.0, 9.0 to 3.0,  2.0 to 0.0, 8.0 to  4.0, 7.0 to 4.0,\n            9.0 to 10.0, 1.0 to 9.0,  8.0 to 2.0, 0.0 to 10.0, 9.0 to 6.0\n        ),\n        listOf(\n            0.654682 to 0.925557, 0.409382 to 0.619391, 0.891663 to 0.888594,\n            0.716629 to 0.996200, 0.477721 to 0.946355, 0.925092 to 0.818220,\n            0.624291 to 0.142924, 0.211332 to 0.221507, 0.293786 to 0.691701,\n            0.839186 to 0.728260\n        )\n    )\n    for (p in points) {\n        val (dist, pair) = bruteForceClosestPair(p)\n        println(\"Closest pair (brute force) is ${pair.first} and ${pair.second}, distance $dist\")\n        val xP = p.sortedBy { it.first }\n        val yP = p.sortedBy { it.second }\n        val (dist2, pair2) = optimizedClosestPair(xP, yP)\n        println(\"Closest pair (optimized)   is ${pair2.first} and ${pair2.second}, distance $dist2\\n\")\n    }\n}\n\n\nOutput:\nClosest pair (brute force) is (8.0, 4.0) and (7.0, 4.0), distance 1.0\nClosest pair (optimized)   is (7.0, 4.0) and (8.0, 4.0), distance 1.0\n\nClosest pair (brute force) is (0.891663, 0.888594) and (0.925092, 0.81822), distance 0.07791019135517516\nClosest pair (optimized)   is (0.891663, 0.888594) and (0.925092, 0.81822), distance 0.07791019135517516\n\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\nuse strict;\nuse warnings;\nuse POSIX qw(ceil);\n\nsub dist {\n   my ($a, $b) = @_;\n   return sqrt(($a->[0] - $b->[0])**2 +\n               ($a->[1] - $b->[1])**2)\n}\n\nsub closest_pair_simple {\n    my @points = @{ shift @_ };\n    my ($a, $b, $d) = ( $points[0], $points[1], dist($points[0], $points[1]) );\n    while( @points ) {\n        my $p = pop @points;\n        for my $l (@points) {\n            my $t = dist($p, $l);\n            ($a, $b, $d) = ($p, $l, $t) if $t < $d;\n        }\n    }\n    $a, $b, $d\n}\n\nsub closest_pair {\n   my @r = @{ shift @_ };\n   closest_pair_real( [sort { $a->[0] <=> $b->[0] } @r], [sort { $a->[1] <=> $b->[1] } @r] )\n}\n\nsub closest_pair_real {\n    my ($rx, $ry) = @_;\n    return closest_pair_simple($rx) if scalar(@$rx) <= 3;\n\n    my(@yR, @yL, @yS);\n    my $N = @$rx;\n    my $midx = ceil($N/2)-1;\n    my @PL = @$rx[      0 .. $midx];\n    my @PR = @$rx[$midx+1 .. $N-1];\n    my $xm = $$rx[$midx]->[0];\n    $_->[0] <= $xm ? push @yR, $_ : push @yL, $_ for @$ry;\n    my ($al, $bl, $dL) = closest_pair_real(\\@PL, \\@yR);\n    my ($ar, $br, $dR) = closest_pair_real(\\@PR, \\@yL);\n    my ($w1, $w2, $closest) = $dR > $dL ? ($al, $bl, $dL) : ($ar, $br, $dR);\n    abs($xm - $_->[0]) < $closest and push @yS, $_ for @$ry;\n\n    for my $i (0 .. @yS-1) {\n        my $k = $i + 1;\n        while ( $k <= $#yS and ($yS[$k]->[1] - $yS[$i]->[1]) < $closest ) {\n            my $d = dist($yS[$k], $yS[$i]);\n            ($w1, $w2, $closest) = ($yS[$k], $yS[$i], $d) if $d < $closest;\n            $k++;\n        }\n    }\n    $w1, $w2, $closest\n}\n\nmy @points;\npush @points, [rand(20)-10, rand(20)-10] for 1..5000;\nprintf \"%.8f between (%.5f,\u00a0%.5f), (%.5f,\u00a0%.5f)\\n\", $_->[2], @{$$_[0]}, @{$$_[1]}\n    for [closest_pair_simple(\\@points)], [closest_pair(\\@points)];\n\n\nOutput:\n0.00259322 between (-1.95541, -4.29695), (-1.95351, -4.29871)\n0.00259322 between (-1.95541, -4.29695), (-1.95351, -4.29871)\n", "explain": "The divide & conquer technique is about 100x faster than the brute-force algorithm.\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n\n", "explain": "See Closest-pair problem/Objective-C\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\n% main predicate, find and print closest point\ndo_find_closest_points(Points) :-\n\tpoints_closest(Points, points(point(X1,Y1),point(X2,Y2),Dist)),\n\tformat('Point 1\u00a0: (~p, ~p)~n', [X1,Y1]),\n\tformat('Point 1\u00a0: (~p, ~p)~n', [X2,Y2]),\n\tformat('Distance: ~p~n', [Dist]).\n\n% Find the distance between two points\ndistance(point(X1,Y1), point(X2,Y2), points(point(X1,Y1),point(X2,Y2),Dist)) :-\n\tDx is X2 - X1,\n\tDy is Y2 - Y1,\n\tDist is sqrt(Dx * Dx + Dy * Dy).\n\n% find the closest point that relatest to another point\npoint_closest(Points, Point, Closest) :-\n\tselect(Point, Points, Remaining),\n\tmaplist(distance(Point), Remaining, PointList),\n\tfoldl(closest, PointList, 0, Closest).\n\n% find the closest point/dist pair for all points\npoints_closest(Points, Closest) :-\n\tmaplist(point_closest(Points), Points, ClosestPerPoint),\n\tfoldl(closest, ClosestPerPoint, 0, Closest).\n\n% used by foldl to get the lowest point/distance combination\nclosest(points(P1,P2,Dist), 0, points(P1,P2,Dist)).\nclosest(points(_,_,Dist), points(P1,P2,Dist2), points(P1,P2,Dist2)) :-\n\tDist2 < Dist.\nclosest(points(P1,P2,Dist), points(_,_,Dist2), points(P1,P2,Dist)) :-\n\tDist =< Dist2.\n\n\ndo_find_closest_points([\n    point(0.654682, 0.925557),\n    point(0.409382, 0.619391),\n    point(0.891663, 0.888594),\n    point(0.716629, 0.996200),\n    point(0.477721, 0.946355),\n    point(0.925092, 0.818220),\n    point(0.624291, 0.142924),\n    point(0.211332, 0.221507),\n    point(0.293786, 0.691701),\n    point(0.839186, 0.728260)\n]).\n\n\nOutput:\nPoint 1\u00a0: (0.925092, 0.81822)\nPoint 1\u00a0: (0.891663, 0.888594)\nDistance: 0.07791019135517516\ntrue\u00a0;\nfalse.\n\n", "explain": "Brute force version, works with SWI-Prolog, tested on version 7.2.3.\nTo test, pass in a list of points.\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nimport scala.collection.mutable.ListBuffer\nimport scala.util.Random\n\nobject ClosestPair {\n  case class Point(x: Double, y: Double){\n    def distance(p: Point) = math.hypot(x-p.x, y-p.y)\n\n    override def toString = \"(\" + x + \", \" + y + \")\"\n  }\n\n  case class Pair(point1: Point, point2: Point) {\n    val distance: Double = point1 distance point2\n\n    override def toString = {\n      point1 + \"-\" + point2 + \"\u00a0: \" + distance\n    }\n  }\n\n  def sortByX(points: List[Point]) = {\n    points.sortBy(point => point.x)\n  }\n\n  def sortByY(points: List[Point]) = {\n    points.sortBy(point => point.y)\n  }\n\n  def divideAndConquer(points: List[Point]): Pair = {\n    val pointsSortedByX = sortByX(points)\n    val pointsSortedByY = sortByY(points)\n\n    divideAndConquer(pointsSortedByX, pointsSortedByY)\n  }\n\n  def bruteForce(points: List[Point]): Pair = {\n    val numPoints = points.size\n    if (numPoints < 2)\n      return null\n    var pair = Pair(points(0), points(1))\n    if (numPoints > 2) {\n      for (i <- 0 until numPoints - 1) {\n        val point1 = points(i)\n        for (j <- i + 1 until numPoints) {\n          val point2 = points(j)\n          val distance = point1 distance point2\n          if (distance < pair.distance)\n            pair = Pair(point1, point2)\n        }\n      }\n    }\n    return pair\n  }\n\n\n  private def divideAndConquer(pointsSortedByX: List[Point], pointsSortedByY: List[Point]): Pair = {\n    val numPoints = pointsSortedByX.size\n    if(numPoints <= 3) {\n      return bruteForce(pointsSortedByX)\n    }\n\n    val dividingIndex = numPoints >>> 1\n    val leftOfCenter = pointsSortedByX.slice(0, dividingIndex)\n    val rightOfCenter = pointsSortedByX.slice(dividingIndex, numPoints)\n\n    var tempList = leftOfCenter.map(x => x)\n    //println(tempList)\n    tempList = sortByY(tempList)\n    var closestPair = divideAndConquer(leftOfCenter, tempList)\n\n    tempList = rightOfCenter.map(x => x)\n    tempList = sortByY(tempList)\n\n    val closestPairRight = divideAndConquer(rightOfCenter, tempList)\n\n    if (closestPairRight.distance < closestPair.distance)\n      closestPair = closestPairRight\n\n    tempList = List[Point]()\n    val shortestDistance = closestPair.distance\n    val centerX = rightOfCenter(0).x\n\n    for (point <- pointsSortedByY) {\n      if (Math.abs(centerX - point.x) < shortestDistance)\n        tempList = tempList :+ point\n    }\n\n    closestPair = shortestDistanceF(tempList, shortestDistance, closestPair)\n    closestPair\n  }\n\n  private def shortestDistanceF(tempList: List[Point], shortestDistance: Double, closestPair: Pair ): Pair = {\n    var shortest = shortestDistance\n    var bestResult = closestPair\n    for (i <- 0 until tempList.size) {\n      val point1 = tempList(i)\n      for (j <- i + 1 until tempList.size) {\n        val point2 = tempList(j)\n        if ((point2.y - point1.y) >= shortestDistance)\n          return closestPair\n        val distance = point1 distance point2\n        if (distance < closestPair.distance)\n        {\n          bestResult = Pair(point1, point2)\n          shortest = distance\n        }\n      }\n    }\n\n    closestPair\n  }\n\n  def main(args: Array[String]) {\n    val numPoints = if(args.length == 0) 1000 else args(0).toInt\n\n    val points = ListBuffer[Point]()\n    val r = new Random()\n    for (i <- 0 until numPoints) {\n      points.+=:(new Point(r.nextDouble(), r.nextDouble()))\n    }\n    println(\"Generated \" + numPoints + \" random points\")\n\n    var startTime = System.currentTimeMillis()\n    val bruteForceClosestPair = bruteForce(points.toList)\n    var elapsedTime = System.currentTimeMillis() - startTime\n    println(\"Brute force (\" + elapsedTime + \" ms): \" + bruteForceClosestPair)\n\n    startTime = System.currentTimeMillis()\n    val dqClosestPair = divideAndConquer(points.toList)\n    elapsedTime = System.currentTimeMillis() - startTime\n    println(\"Divide and conquer (\" + elapsedTime + \" ms): \" + dqClosestPair)\n    if (bruteForceClosestPair.distance != dqClosestPair.distance)\n      println(\"MISMATCH\")\n  }\n}\n\n\nOutput:\nscala ClosestPair 1000\nGenerated 1000 random points\nBrute force (981 ms): (0.41984960343173994, 0.4499078600557793)-(0.4198255166110827, 0.45044969701435)\u00a0: 5.423720721077961E-4\nDivide and conquer (52 ms): (0.4198255166110827, 0.45044969701435)-(0.41984960343173994, 0.4499078600557793)\u00a0: 5.423720721077961E-4\n\n", "explain": ""}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nCompact Versions[edit]\nimport std.stdio, std.typecons, std.math, std.algorithm,\n       std.random, std.traits, std.range, std.complex;\n\nauto bruteForceClosestPair(T)(in T[] points) pure nothrow @nogc {\n//  return pairwise(points.length.iota, points.length.iota)\n//         .reduce!(min!((i, j) => abs(points[i] - points[j])));\n  auto minD = Unqual!(typeof(T.re)).infinity;\n  T minI, minJ;\n  foreach (immutable i, const p1; points.dropBackOne)\n    foreach (const p2; points[i + 1 .. $]) {\n      immutable dist = abs(p1 - p2);\n      if (dist < minD) {\n        minD = dist;\n        minI = p1;\n        minJ = p2;\n      }\n    }\n  return tuple(minD, minI, minJ);\n}\n\nauto closestPair(T)(T[] points) pure nothrow {\n  static Tuple!(typeof(T.re), T, T) inner(in T[] xP, /*in*/ T[] yP)\n  pure nothrow {\n    if (xP.length <= 3)\n      return xP.bruteForceClosestPair;\n    const Pl = xP[0 .. $ / 2];\n    const Pr = xP[$ / 2 .. $];\n    immutable xDiv = Pl.back.re;\n    auto Yr = yP.partition!(p => p.re <= xDiv);\n    immutable dl_pairl = inner(Pl, yP[0 .. yP.length - Yr.length]);\n    immutable dr_pairr = inner(Pr, Yr);\n    immutable dm_pairm = dl_pairl[0]<dr_pairr[0] ? dl_pairl : dr_pairr;\n    immutable dm = dm_pairm[0];\n    const nextY = yP.filter!(p => abs(p.re - xDiv) < dm).array;\n\n    if (nextY.length > 1) {\n      auto minD = typeof(T.re).infinity;\n      size_t minI, minJ;\n      foreach (immutable i; 0 .. nextY.length - 1)\n        foreach (immutable j; i + 1 .. min(i + 8, nextY.length)) {\n          immutable double dist = abs(nextY[i] - nextY[j]);\n          if (dist < minD) {\n            minD = dist;\n            minI = i;\n            minJ = j;\n          }\n        }\n      return dm <= minD ? dm_pairm :\n                        typeof(return)(minD, nextY[minI], nextY[minJ]);\n    } else\n      return dm_pairm;\n  }\n\n  points.sort!q{ a.re < b.re };\n  const xP = points.dup;\n  points.sort!q{ a.im < b.im };\n  return inner(xP, points);\n}\n\nvoid main() {\n  alias C = complex;\n  auto pts = [C(5,9), C(9,3), C(2), C(8,4), C(7,4), C(9,10), C(1,9),\n              C(8,2), C(0,10), C(9,6)];\n  pts.writeln;\n  writeln(\"bruteForceClosestPair: \", pts.bruteForceClosestPair);\n  writeln(\"          closestPair: \", pts.closestPair);\n\n  rndGen.seed = 1;\n  Complex!double[10_000] points;\n  foreach (ref p; points)\n    p = C(uniform(0.0, 1000.0) + uniform(0.0, 1000.0));\n  writeln(\"bruteForceClosestPair: \", points.bruteForceClosestPair);\n  writeln(\"          closestPair: \", points.closestPair);\n}\n\n\nOutput:\n[5+9i, 9+3i, 2+0i, 8+4i, 7+4i, 9+10i, 1+9i, 8+2i, 0+10i, 9+6i]\nbruteForceClosestPair: Tuple!(double, Complex!double, Complex!double)(1, 8+4i, 7+4i)\n          closestPair: Tuple!(double, Complex!double, Complex!double)(1, 7+4i, 8+4i)\nbruteForceClosestPair: Tuple!(double, Complex!double, Complex!double)(1.76951e-05, 1040.2+0i, 1040.2+0i)\n          closestPair: Tuple!(double, Complex!double, Complex!double)(1.76951e-05, 1040.2+0i, 1040.2+0i)\n\nFaster Brute-force Version[edit]\nimport std.stdio, std.random, std.math, std.typecons, std.complex,\n       std.traits;\n\nNullable!(Tuple!(size_t, size_t))\nbfClosestPair2(T)(in Complex!T[] points) pure nothrow @nogc {\n    auto minD = Unqual!(typeof(points[0].re)).infinity;\n    if (points.length < 2)\n        return typeof(return)();\n\n    size_t minI, minJ;\n    foreach (immutable i; 0 .. points.length - 1)\n        foreach (immutable j; i + 1 .. points.length) {\n            auto dist = (points[i].re - points[j].re) ^^ 2;\n            if (dist < minD) {\n                dist += (points[i].im - points[j].im) ^^ 2;\n                if (dist < minD) {\n                    minD = dist;\n                    minI = i;\n                    minJ = j;\n                }\n            }\n        }\n\n    return typeof(return)(tuple(minI, minJ));\n}\n\nvoid main() {\n    alias C = Complex!double;\n    auto rng = 31415.Xorshift;\n    C[10_000] pts;\n    foreach (ref p; pts)\n        p = C(uniform(0.0, 1000.0, rng), uniform(0.0, 1000.0, rng));\n\n    immutable ij = pts.bfClosestPair2;\n    if (ij.isNull)\n        return;\n    writefln(\"Closest pair: Distance: %f  p1, p2: %f, %f\",\n             abs(pts[ij[0]] - pts[ij[1]]), pts[ij[0]], pts[ij[1]]);\n}\n\n\nOutput:\nClosest pair: Distance: 0.019212  p1, p2: 9.74223+119.419i, 9.72306+119.418i\n\n", "explain": "About 1.87 seconds run-time for data generation and brute force version, and about 0.03 seconds for data generation and divide & conquer (10_000 points in both cases) with ldc2 compiler.\nAbout 0.12 seconds run-time for brute-force version 2 (10_000 points) with with LDC2 compiler.\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nimport Data.List (minimumBy, tails, unfoldr, foldl1') --'\n\nimport System.Random (newStdGen, randomRs)\n\nimport Control.Arrow ((&&&))\n\nimport Data.Ord (comparing)\n\nvecLeng [[a, b], [p, q]] = sqrt $ (a - p) ^ 2 + (b - q) ^ 2\n\nfindClosestPair =\n  foldl1'' ((minimumBy (comparing vecLeng) .) . (. return) . (:)) .\n  concatMap (\\(x:xs) -> map ((x :) . return) xs) . init . tails\n\ntestCP = do\n  g <- newStdGen\n  let pts :: [[Double]]\n      pts = take 1000 . unfoldr (Just . splitAt 2) $ randomRs (-1, 1) g\n  print . (id &&& vecLeng) . findClosestPair $ pts\n\nmain = testCP\n\nfoldl1'' = foldl1'\n\n\nOutput:\n*Main> testCP\n([[0.8347201880148426,0.40774840545089647],[0.8348731214261784,0.4087113189531284]],9.749825850154334e-4)\n(4.02 secs, 488869056 bytes)\n\n", "explain": "BF solution:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nlet closest_pairs (xys: Point []) =\n  let n = xys.Length\n  seq { for i in 0..n-2 do\n          for j in i+1..n-1 do\n            yield xys.[i], xys.[j] }\n  |> Seq.minBy (fun (p0, p1) -> (p1 - p0).LengthSquared)\n\n\nclosest_pairs\n  [|Point(0.0, 0.0); Point(1.0, 0.0); Point (2.0, 2.0)|]\n\n\n(0,0, 1,0)\n\n\nopen System;\nopen System.Drawing;\nopen System.Diagnostics;\n \nlet Length (seg : (PointF * PointF) option) =\n    match seg with\n    | None -> System.Single.MaxValue\n    | Some(line) ->\n        let f = fst line\n        let t = snd line\n \n        let dx = f.X - t.X\n        let dy = f.Y - t.Y\n        sqrt (dx*dx + dy*dy)\n \n \nlet Shortest a b =\n    if Length(a) < Length(b) then\n        a\n    else\n        b\n \n \nlet rec ClosestBoundY from maxY (ptsByY : PointF list) =\n    match ptsByY with\n    | [] -> None\n    | hd :: tl ->\n        if hd.Y > maxY then\n            None\n        else\n            let toHd = Some(from, hd)\n            let bestToRest = ClosestBoundY from maxY tl\n            Shortest toHd bestToRest\n\n \nlet rec ClosestWithinRange ptsByY maxDy =\n    match ptsByY with\n    | [] -> None\n    | hd :: tl ->\n        let fromHd = ClosestBoundY hd (hd.Y + maxDy) tl\n        let fromRest = ClosestWithinRange tl  maxDy\n        Shortest fromHd fromRest\n\n\n// Cuts pts half way through it's length\n// Order is not maintained in result lists however\nlet Halve pts =\n    let rec ShiftToFirst first second n =\n        match (n, second) with\n        | 0, _ -> (first, second)   // finished the split, so return current state\n        | _, [] -> (first, [])      // not enough items, so first takes the whole original list\n        | n, hd::tl -> ShiftToFirst (hd :: first) tl (n-1)  // shift 1st item from second to first, then recurse with n-1\n\n    let n = (List.length pts) / 2\n    ShiftToFirst [] pts n\n    \n\nlet rec ClosestPair (pts : PointF list) =\n    if List.length pts < 2 then\n        None\n    else\n        let ptsByX = pts |> List.sortBy(fun(p) -> p.X)\n \n        let (left, right) = Halve ptsByX\n        let leftResult = ClosestPair left\n        let rightResult = ClosestPair right\n \n        let bestInHalf = Shortest  leftResult rightResult\n        let bestLength = Length bestInHalf\n \n        let divideX = List.head(right).X\n        let inBand = pts |> List.filter(fun(p) -> Math.Abs(p.X - divideX) < bestLength)\n \n        let byY = inBand |> List.sortBy(fun(p) -> p.Y)\n        let bestCross = ClosestWithinRange byY bestLength\n        Shortest bestInHalf bestCross\n\n\nlet GeneratePoints n =\n    let rand = new Random()\n    [1..n] |> List.map(fun(i) -> new PointF(float32(rand.NextDouble()), float32(rand.NextDouble())))\n\nlet timer = Stopwatch.StartNew()\nlet pts = GeneratePoints (50 * 1000)\nlet closest = ClosestPair pts\nlet takenMs = timer.ElapsedMilliseconds\n\nprintfn \"Closest Pair '%A'.  Distance %f\" closest (Length closest)\nprintfn \"Took %d [ms]\" takenMs\n\n", "explain": "Brute force:\nFor example:\ngives:\nDivide And Conquer:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nclass Point {\n    final Number x, y\n    Point(Number x = 0, Number y = 0) { this.x = x; this.y = y }\n    Number distance(Point that) { ((this.x - that.x)**2 + (this.y - that.y)**2)**0.5 }\n    String toString() { \"{x:${x}, y:${y}}\" } \n}\n\n\ndef bruteClosest(Collection pointCol) {\n    assert pointCol\n    List l = pointCol\n    int n = l.size()\n    assert n > 1\n    if (n == 2) return [distance:l[0].distance(l[1]), points:[l[0],l[1]]]\n    def answer = [distance: Double.POSITIVE_INFINITY]\n    (0..<(n-1)).each { i ->\n        ((i+1)..<n).findAll { j ->\n            (l[i].x - l[j].x).abs() < answer.distance &&\n            (l[i].y - l[j].y).abs() < answer.distance \n        }.each { j ->\n            if ((l[i].x - l[j].x).abs() < answer.distance &&\n                (l[i].y - l[j].y).abs() < answer.distance) {\n                def dist = l[i].distance(l[j])\n                if (dist < answer.distance) {\n                    answer = [distance:dist, points:[l[i],l[j]]]\n                }\n            }\n        }\n    }\n    answer\n}\n\n\ndef elegantClosest(Collection pointCol) {\n    assert pointCol\n    List xList = (pointCol as List).sort { it.x }\n    List yList = xList.clone().sort { it.y }\n    reductionClosest(xList, xList)\n}\n\ndef reductionClosest(List xPoints, List yPoints) {\n//    assert xPoints && yPoints\n//    assert (xPoints as Set) == (yPoints as Set)\n    int n = xPoints.size()\n    if (n < 10) return bruteClosest(xPoints)\n    \n    int nMid = Math.ceil(n/2)\n    List xLeft = xPoints[0..<nMid]\n    List xRight = xPoints[nMid..<n]\n    Number xMid = xLeft[-1].x\n    List yLeft = yPoints.findAll { it.x <= xMid }\n    List yRight = yPoints.findAll { it.x > xMid }\n    if (xRight[0].x == xMid) {\n        yLeft = xLeft.collect{ it }.sort { it.y }\n        yRight = xRight.collect{ it }.sort { it.y }\n    }\n    \n    Map aLeft = reductionClosest(xLeft, yLeft)\n    Map aRight = reductionClosest(xRight, yRight)\n    Map aMin = aRight.distance < aLeft.distance ? aRight : aLeft\n    List yMid = yPoints.findAll { (xMid - it.x).abs() < aMin.distance }\n    int nyMid = yMid.size()\n    if (nyMid < 2) return aMin\n    \n    Map answer = aMin\n    (0..<(nyMid-1)).each { i ->\n        ((i+1)..<nyMid).findAll { j ->\n            (yMid[j].x - yMid[i].x).abs() < aMin.distance &&\n            (yMid[j].y - yMid[i].y).abs() < aMin.distance &&\n            yMid[j].distance(yMid[i]) < aMin.distance\n        }.each { k ->\n            if ((yMid[k].x - yMid[i].x).abs() < answer.distance && (yMid[k].y - yMid[i].y).abs() < answer.distance) {\n                def ikDist = yMid[i].distance(yMid[k])\n                if ( ikDist < answer.distance) {\n                    answer = [distance:ikDist, points:[yMid[i],yMid[k]]]\n                }\n            }\n        }\n    }\n    answer\n}\n\n\ndef random = new Random()\n\n(1..4).each {\ndef point10 = (0..<(10**it)).collect { new Point(random.nextInt(1000001) - 500000,random.nextInt(1000001) - 500000) }\n\ndef startE = System.currentTimeMillis()\ndef closestE = elegantClosest(point10)\ndef elapsedE = System.currentTimeMillis() - startE\nprintln \"\"\"\n${10**it} POINTS\n-----------------------------------------\nElegant reduction:\nelapsed: ${elapsedE/1000} s\nclosest: ${closestE}\n\"\"\"\n\n\ndef startB = System.currentTimeMillis()\ndef closestB = bruteClosest(point10)\ndef elapsedB = System.currentTimeMillis() - startB\nprintln \"\"\"Brute force:\nelapsed: ${elapsedB/1000} s\nclosest: ${closestB}\n\nSpeedup ratio (B/E): ${elapsedB/elapsedE}\n=========================================\n\"\"\"\n}\n\n\n10 POINTS\n-----------------------------------------\nElegant reduction:\nelapsed: 0.019 s\nclosest: [distance:85758.5249173515, points:[{x:310073, y:-27339}, {x:382387, y:18761}]]\n\nBrute force:\nelapsed: 0.001 s\nclosest: [distance:85758.5249173515, points:[{x:310073, y:-27339}, {x:382387, y:18761}]]\n\nSpeedup ratio (B/E): 0.0526315789\n=========================================\n\n\n100 POINTS\n-----------------------------------------\nElegant reduction:\nelapsed: 0.019 s\nclosest: [distance:3166.229934796271, points:[{x:-343735, y:-244394}, {x:-341099, y:-246148}]]\n\nBrute force:\nelapsed: 0.027 s\nclosest: [distance:3166.229934796271, points:[{x:-343735, y:-244394}, {x:-341099, y:-246148}]]\n\nSpeedup ratio (B/E): 1.4210526316\n=========================================\n\n\n1000 POINTS\n-----------------------------------------\nElegant reduction:\nelapsed: 0.241 s\nclosest: [distance:374.22586762542215, points:[{x:411817, y:-83016}, {x:412038, y:-82714}]]\n\nBrute force:\nelapsed: 0.618 s\nclosest: [distance:374.22586762542215, points:[{x:411817, y:-83016}, {x:412038, y:-82714}]]\n\nSpeedup ratio (B/E): 2.5643153527\n=========================================\n\n\n10000 POINTS\n-----------------------------------------\nElegant reduction:\nelapsed: 1.957 s\nclosest: [distance:79.00632886041473, points:[{x:187928, y:-452338}, {x:187929, y:-452259}]]\n\nBrute force:\nelapsed: 51.567 s\nclosest: [distance:79.00632886041473, points:[{x:187928, y:-452338}, {x:187929, y:-452259}]]\n\nSpeedup ratio (B/E): 26.3500255493\n=========================================\n", "explain": "Point class:\nBrute force solution. Incorporates X-only and Y-only pre-checks in two places to cut down on the square root calculations: \nElegant (divide-and-conquer reduction) solution. Incorporates X-only and Y-only pre-checks in two places (four if you count the inclusion of the brute force solution) to cut down on the square root calculations: \nBenchmark/Test:\nResults:\n"}, {"task_name": "Closest-pair problem", "task_url": "https://rosettacode.org/wiki/Closest-pair_problem", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f CLOSEST-PAIR_PROBLEM.AWK\nBEGIN {\n    x[++n] = 0.654682 ; y[n] = 0.925557\n    x[++n] = 0.409382 ; y[n] = 0.619391\n    x[++n] = 0.891663 ; y[n] = 0.888594\n    x[++n] = 0.716629 ; y[n] = 0.996200\n    x[++n] = 0.477721 ; y[n] = 0.946355\n    x[++n] = 0.925092 ; y[n] = 0.818220\n    x[++n] = 0.624291 ; y[n] = 0.142924\n    x[++n] = 0.211332 ; y[n] = 0.221507\n    x[++n] = 0.293786 ; y[n] = 0.691701\n    x[++n] = 0.839186 ; y[n] = 0.728260\n    min = 1E20\n    for (i=1; i<=n-1; i++) {\n      for (j=i+1; j<=n; j++) {\n        dsq = (x[i]-x[j])^2 + (y[i]-y[j])^2\n        if (dsq < min) {\n          min = dsq\n          mini = i\n          minj = j\n        }\n      }\n    }\n    printf(\"distance between (%.6f,%.6f) and (%.6f,%.6f) is %g\\n\",x[mini],y[mini],x[minj],y[minj],sqrt(min))\n    exit(0)\n}\n\n\nOutput:\ndistance between (0.891663,0.888594) and (0.925092,0.818220) is 0.0779102\n\n", "explain": ""}]