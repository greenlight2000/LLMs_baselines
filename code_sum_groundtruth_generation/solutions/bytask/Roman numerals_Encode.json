[{"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Python", "code": "\nPythonic[edit]\nimport roman\nprint(roman.toRoman(2022))\nMinimalistic structuralism[edit]\ndef toRoman(n):\n    res=''\t\t#converts int to str(Roman numeral)\n    reg=n\t\t#using the numerals (M,D,C,L,X,V,I)\n    if reg<4000:#no more than three repetitions\n        while reg>=1000:\t#thousands up to MMM\n            res+='M'\t\t#MAX is MMMCMXCIX\n            reg-=1000\t\t\n        if reg>=900:\t\t#nine hundreds in 900-999\n            res+='CM'\n            reg-=900\n        if reg>=500:\t\t#five hudreds in 500-899\n            res+='D'\n            reg-=500\n        if reg>=400:\t\t#four hundreds in 400-499\n            res+='CD'\n            reg-=400\n        while reg>=100:\t\t#hundreds in 100-399\n            res+='C'\n            reg-=100\n        if reg>=90:\t\t\t#nine tens in 90-99\n            res+='XC'\n            reg-=90\n        if reg>=50:\t\t\t#five Tens in 50-89\n            res+='L'\n            reg-=50\n        if reg>=40:\n            res+='XL'\t\t#four Tens\n            reg-=40\n        while reg>=10:\n            res+=\"X\"\t\t#tens\n            reg-=10\n        if reg>=9:\n            res+='IX'\t\t#nine Units\n            reg-=9\n        if reg>=5:\n            res+='V'\t\t#five Units\n            reg-=5\n        if reg>=4:\n            res+='IV'\t\t#four Units\n            reg-=4\n        while reg>0:\t\t#three or less Units\n            res+='I'\n            reg-=1\n    return res\nImperative[edit]\nVersion for Python 2\nroman =        \"MDCLXVmdclxvi\"; # UPPERCASE for thousands #\nadjust_roman = \"CCXXmmccxxii\";\narabic =       (1000000, 500000, 100000, 50000, 10000, 5000, 1000, 500, 100, 50, 10, 5, 1);\nadjust_arabic = (100000, 100000,  10000, 10000,  1000, 1000,  100, 100,  10, 10,  1, 1, 0);\n\ndef arabic_to_roman(dclxvi):\n  org = dclxvi; # 666 #\n  out = \"\";\n  for scale,arabic_scale  in enumerate(arabic): \n    if org == 0: break\n    multiples = org / arabic_scale;\n    org -= arabic_scale * multiples;\n    out += roman[scale] * multiples;\n    if org >= -adjust_arabic[scale] + arabic_scale: \n      org -= -adjust_arabic[scale] + arabic_scale;\n      out +=  adjust_roman[scale] +  roman[scale]\n  return out\n \nif __name__ == \"__main__\": \n  test = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,40,50,60,69,70,\n     80,90,99,100,200,300,400,500,600,666,700,800,900,1000,1009,1444,1666,1945,1997,1999,\n     2000,2008,2500,3000,4000,4999,5000,6666,10000,50000,100000,500000,1000000);\n  for val in test: \n    print '%d - %s'%(val, arabic_to_roman(val))\nAn alternative which uses the divmod() functionromanDgts= 'ivxlcdmVXLCDM_'\n\ndef ToRoman(num):\n   namoR = ''\n   if num >=4000000:\n      print 'Too Big -'\n      return '-----'\n   for rdix in range(0, len(romanDgts), 2):\n      if num==0: break\n      num,r = divmod(num,10)\n      v,r = divmod(r, 5)\n      if r==4:\n         namoR += romanDgts[rdix+1+v] + romanDgts[rdix]\n      else:\n         namoR += r*romanDgts[rdix] + (romanDgts[rdix+1] if(v==1) else '')\n   return namoR[-1::-1]\n\nanums = [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\nrnums = \"M CM D CD C XC L XL X IX V IV I\".split()\n\ndef to_roman(x):\n    ret = []\n    for a,r in zip(anums, rnums):\n        n,x = divmod(x,a)\n        ret.append(r*n)\n    return ''.join(ret)\n        \nif __name__ == \"__main__\":\n    test = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,40,\n            50,60,69,70,80,90,99,100,200,300,400,500,600,666,700,800,900,\n            1000,1009,1444,1666,1945,1997,1999,2000,2008,2010,2011,2500,\n            3000,3999)\n    \n    for val in test:\n        print '%d - %s'%(val, to_roman(val))\nVersion for Python 3\ndef arabic_to_roman(dclxvi):\n#===========================\n  '''Convert an integer from the decimal notation to the Roman notation'''\n  org = dclxvi; # 666 #\n  out = \"\";\n  for scale, arabic_scale  in enumerate(arabic):\n    if org == 0: break\n    multiples = org // arabic_scale;\n    org -= arabic_scale * multiples;\n    out += roman[scale] * multiples;\n    if (org >= -adjust_arabic[scale] + arabic_scale):\n      org -= -adjust_arabic[scale] + arabic_scale;\n      out +=  adjust_roman[scale] +  roman[scale]\n  return out\n\nif __name__ == \"__main__\": \n  test = (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,25,30,40,50,60,69,70,\n     80,90,99,100,200,300,400,500,600,666,700,800,900,1000,1009,1444,1666,1945,1997,1999,\n     2000,2008,2500,3000,4000,4999,5000,6666,10000,50000,100000,500000,1000000);\n  \n  for val in test: \n    print(\"%8d %s\"\u00a0%(val, arabic_to_roman(val)))\nDeclarative[edit]\n\nrnl = [ { '4'\u00a0: 'MMMM', '3'\u00a0: 'MMM', '2'\u00a0: 'MM', '1'\u00a0: 'M', '0'\u00a0: '' }, { '9'\u00a0: 'CM', '8'\u00a0: 'DCCC', '7'\u00a0: 'DCC',\n          '6'\u00a0: 'DC', '5'\u00a0: 'D', '4'\u00a0: 'CD', '3'\u00a0: 'CCC', '2'\u00a0: 'CC', '1'\u00a0: 'C', '0'\u00a0: '' }, { '9'\u00a0: 'XC',\n          '8'\u00a0: 'LXXX', '7'\u00a0: 'LXX', '6'\u00a0: 'LX', '5'\u00a0: 'L', '4'\u00a0: 'XL', '3'\u00a0: 'XXX', '2'\u00a0: 'XX', '1'\u00a0: 'X',\n          '0'\u00a0: '' }, { '9'\u00a0: 'IX', '8'\u00a0: 'VIII', '7'\u00a0: 'VII', '6'\u00a0: 'VI', '5'\u00a0: 'V', '4'\u00a0: 'IV', '3'\u00a0: 'III',\n          '2'\u00a0: 'II', '1'\u00a0: 'I', '0'\u00a0: '' }]\n# Option 1\ndef number2romannumeral(n):\n    return ''.join([rnl[x][y] for x, y in zip(range(4), str(n).zfill(4)) if n < 5000 and n > -1])\n# Option 2\ndef number2romannumeral(n):\n    return reduce(lambda x, y: x + y, map(lambda x, y: rnl[x][y], range(4), str(n).zfill(4))) if -1 < n < 5000 else None\n\nWorks with: Python version 3\nTranslation of: Haskell\n'''Encoding Roman Numerals'''\n\nfrom functools import reduce\nfrom itertools import chain\n\n\n# romanFromInt\u00a0::  Int -> String\ndef romanFromInt(n):\n    '''A string of Roman numerals encoding an integer.'''\n    def go(a, ms):\n        m, s = ms\n        q, r = divmod(a, m)\n        return (r, s * q)\n\n    return concat(snd(mapAccumL(go)(n)(\n        zip([\n            1000, 900, 500, 400, 100, 90, 50,\n            40, 10, 9, 5, 4, 1\n        ], [\n            'M', 'CM', 'D', 'CD', 'C', 'XC', 'L',\n            'XL', 'X', 'IX', 'V', 'IV', 'I'\n        ])\n    )))\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Sample of years'''\n    for s in [\n            romanFromInt(x) for x in [\n                1666, 1990, 2008, 2016, 2018, 2020\n            ]\n    ]:\n        print(s)\n\n\n# ------------------ GENERIC FUNCTIONS -------------------\n\n# concat\u00a0:: [[a]] -> [a]\n# concat\u00a0:: [String] -> String\ndef concat(xxs):\n    '''The concatenation of all the elements in a list.'''\n    xs = list(chain.from_iterable(xxs))\n    unit = '' if isinstance(xs, str) else []\n    return unit if not xs else (\n        ''.join(xs) if isinstance(xs[0], str) else xs\n    )\n\n\n# mapAccumL\u00a0:: (acc -> x -> (acc, y)) -> acc -> [x] -> (acc, [y])\ndef mapAccumL(f):\n    '''A tuple of an accumulation and a list derived by a\n       combined map and fold,\n       with accumulation from left to right.'''\n    def go(a, x):\n        tpl = f(a[0], x)\n        return (tpl[0], a[1] + [tpl[1]])\n    return lambda acc: lambda xs: (\n        reduce(go, xs, (acc, []))\n    )\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second component of a tuple.'''\n    return tpl[1]\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\nMDCLXVI\nMCMXC\nMMVIII\nMMXVI\nMMXVIII\nMMXX\n", "explain": "It is more Pythonic to use zip to iterate over two lists together:\nLess readable, but a 'one liner':\n\nOr, defining roman in terms of mapAccumL:\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "C", "code": "\nNaive solution[edit]\n\n#include <stdio.h>\n\n\nint main() {\n    int arabic[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};\n\n    // There is a bug: \"XL\\0\" is translated into sequence 58 4C 00 00, i.e. it is 4-bytes long...\n    // Should be \"XL\" without \\0 etc.\n    //\n    char roman[13][3] = {\"M\\0\", \"CM\\0\", \"D\\0\", \"CD\\0\", \"C\\0\", \"XC\\0\", \"L\\0\", \"XL\\0\", \"X\\0\", \"IX\\0\", \"V\\0\", \"IV\\0\", \"I\\0\"};\n    int N;\n\n    printf(\"Enter arabic number:\\n\");\n    scanf(\"%d\", &N);\n    printf(\"\\nRoman number:\\n\");\n\n    for (int i = 0; i < 13; i++) {\n        while (N >= arabic[i]) {\n            printf(\"%s\", roman[i]);\n            N -= arabic[i];\n        }\n    }\n    return 0;\n}\n\n\nOutput:\nEnter arabic number:\n215\n\nRoman number:\nCCXV\n\nNot thread-safe[edit]\n#define _CRT_SECURE_NO_WARNINGS\n\n#include <stdio.h>\n#include <string.h>\n\nint RomanNumerals_parseInt(const char* string)\n{\n    int value;\n    return scanf(\"%u\", &value) == 1 && value > 0 ? value : 0;\n}\n\nconst char* RomanNumerals_toString(int value)\n{\n#define ROMAN_NUMERALS_MAX_OUTPUT_STRING_SIZE 64\n    static buffer[ROMAN_NUMERALS_MAX_OUTPUT_STRING_SIZE];\n\n    const static int maxValue = 5000;\n    const static int minValue = 1;\n\n    const static struct Digit {\n        char string[4]; // It's better to use 4 than 3 (aligment).\n        int  value;\n    } digits[] = {\n        {\"M\", 1000}, {\"CM\", 900}, {\"D\", 500 }, {\"CD\", 400 },\n        {\"C\", 100 }, {\"XC\", 90 }, {\"L\",  50 }, {\"XL\", 40}, \n        {\"X\", 10}, {\"IX\", 9}, {\"V\", 5}, {\"IV\", 4}, {\"I\", 1 }, \n        {\"?\", 0}\n    };\n\n    *buffer = '\\0'; // faster than memset(buffer, 0, sizeof(buffer));\n    if (minValue <= value && value <= maxValue)\n    {\n        struct Digit* digit = &digits[0];\n\n        while (digit->value)\n        {\n            while (value >= digit->value)\n            {\n                value -= digit->value;\n                // It is not necessary - total length would not be exceeded...\n                // if (strlen(buffer) + strlen(digit->string) < sizeof(buffer))\n                strcat(buffer, digit->string);\n            }\n            digit++;\n        }\n    }\n    return buffer;\n}\n\n\nint main(int argc, char* argv[])\n{\n    if (argc < 2)\n    {\n        // Blanks are needed for a consistient blackground on some systems.\n        // BTW, puts append an extra newline at the end.\n        //\n        puts(\"Write given numbers as Roman numerals. \\n\"\n             \"                                       \\n\"\n             \"Usage:                                 \\n\"\n             \"    roman n1 n2 n3 ...                 \\n\"\n             \"                                       \\n\"\n             \"where n1 n2 n3 etc. are Arabic numerals\\n\");\n\n        int numbers[] = { 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 1498, 2022 };\n        for (int i = 0; i < sizeof(numbers) / sizeof(int); i++)\n        {\n            printf(\"%4d = %s\\n\", \n                numbers[i], RomanNumerals_toString(numbers[i]));\n        }\n    }\n    else\n    {\n        for (int i = 1; i < argc; i++)\n        {\n            int number = RomanNumerals_parseInt(argv[i]);\n            if (number)\n            {\n                puts(RomanNumerals_toString(number));\n            }\n            else\n            {\n                puts(\"???\");\n            }\n        }\n    }\n\n    return 0;\n}\n\n\nOutput:\nWrite given numbers as Roman numerals.\n\nUsage:\n    roman n1 n2 n3 ...\n\nwhere n1 n2 n3 etc. are Arabic numerals\n\n   1 = I\n   2 = II\n   3 = III\n   4 = IV\n   5 = V\n   6 = VI\n   7 = VII\n   8 = VIII\n   9 = IX\n  10 = X\n1498 = MCDXCVIII\n2022 = MMXXII\n", "explain": "This solution is a smart but does not return the number written as a string.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "C++", "code": "\nC++ 98[edit]\n#include <iostream>\n#include <string>\n\nstd::string to_roman(int value)\n{\n  struct romandata_t { int value; char const* numeral; };\n  static romandata_t const romandata[] =\n     { 1000, \"M\",\n        900, \"CM\",\n        500, \"D\",\n        400, \"CD\",\n        100, \"C\",\n         90, \"XC\",\n         50, \"L\",\n         40, \"XL\",\n         10, \"X\",\n          9, \"IX\",\n          5, \"V\",\n          4, \"IV\",\n          1, \"I\",\n          0, NULL }; // end marker\n\n  std::string result;\n  for (romandata_t const* current = romandata; current->value > 0; ++current)\n  {\n    while (value >= current->value)\n    {\n      result += current->numeral;\n      value  -= current->value;\n    }\n  }\n  return result;\n}\n\nint main()\n{\n  for (int i = 1; i <= 4000; ++i)\n  {\n    std::cout << to_roman(i) << std::endl;\n  }\n}\n\nC++ 11[edit]\n#include <iostream>\n#include <string>\n\nstd::string to_roman(int x) {\n     if (x <= 0)\n         return \"Negative or zero!\";\n     auto roman_digit = [](char one, char five, char ten, int x) {\n        if (x <= 3)\n            return std::string().assign(x, one);\n        if (x <= 5)\n            return std::string().assign(5 - x, one) + five;\n        if (x <= 8)\n            return five + std::string().assign(x - 5, one);\n        return std::string().assign(10 - x, one) + ten;\n    };\n    if (x >= 1000)\n        return x - 1000 > 0 ? \"M\" + to_roman(x - 1000) : \"M\";\n    if (x >= 100) {\n        auto s = roman_digit('C', 'D', 'M', x / 100);\n        return x % 100 > 0 ? s + to_roman(x % 100) : s;\n    }\n    if (x >= 10) {\n        auto s = roman_digit('X', 'L', 'C', x / 10);\n        return x % 10 > 0 ? s + to_roman(x % 10) : s;\n    }\n    return roman_digit('I', 'V', 'X', x);\n}\n\nint main() {\n    for (int i = 0; i < 2018; i++)\n        std::cout << i << \" --> \" << to_roman(i) << std::endl;\n}\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Java", "code": "\nTranslation of: Ada\n\nWorks with: Java version 1.5+\npublic class RN {\n\n    enum Numeral {\n        I(1), IV(4), V(5), IX(9), X(10), XL(40), L(50), XC(90), C(100), CD(400), D(500), CM(900), M(1000);\n        int weight;\n\n        Numeral(int weight) {\n            this.weight = weight;\n        }\n    };\n\n    public static String roman(long n) {\n        \n        if( n <= 0) {\n            throw new IllegalArgumentException();\n        }\n        \n        StringBuilder buf = new StringBuilder();\n\n        final Numeral[] values = Numeral.values();\n        for (int i = values.length - 1; i >= 0; i--) {\n            while (n >= values[i].weight) {\n                buf.append(values[i]);\n                n -= values[i].weight;\n            }\n        }\n        return buf.toString();\n    }\n\n    public static void test(long n) {\n        System.out.println(n + \" = \" + roman(n));\n    }\n\n    public static void main(String[] args) {\n        test(1999);\n        test(25);\n        test(944);\n        test(0);\n    }\n\n}\n\n\nOutput:\n1999 = MCMXCIX\n25 = XXV\n944 = CMXLIV\nException in thread \"main\" java.lang.IllegalArgumentException\n\tat RN.roman(RN.java:15)\n\tat RN.test(RN.java:31)\n\tat RN.main(RN.java:38)\nWorks with: Java version 1.8+\nimport java.util.Set;\nimport java.util.EnumSet;\nimport java.util.Collections;\nimport java.util.stream.Collectors;\nimport java.util.stream.LongStream;\n\npublic interface RomanNumerals {\n  public enum Numeral {\n    M(1000), CM(900), D(500), CD(400), C(100), XC(90), L(50), XL(40), X(10), IX(9), V(5), IV(4), I(1);\n\n    public final long weight;\n\n    private static final Set<Numeral> SET = Collections.unmodifiableSet(EnumSet.allOf(Numeral.class));\n\n    private Numeral(long weight) {\n      this.weight = weight;\n    }\n\n    public static Numeral getLargest(long weight) {\n      return SET.stream()\n        .filter(numeral -> weight >= numeral.weight)\n        .findFirst()\n        .orElse(I)\n      ;\n    }\n  };\n\n  public static String encode(long n) {\n    return LongStream.iterate(n, l -> l - Numeral.getLargest(l).weight)\n      .limit(Numeral.values().length)\n      .filter(l -> l > 0)\n      .mapToObj(Numeral::getLargest)\n      .map(String::valueOf)\n      .collect(Collectors.joining())\n    ;\n  }\n\n  public static long decode(String roman) {\n    long result =  new StringBuilder(roman.toUpperCase()).reverse().chars()\n      .mapToObj(c -> Character.toString((char) c))\n      .map(numeral -> Enum.valueOf(Numeral.class, numeral))\n      .mapToLong(numeral -> numeral.weight)\n      .reduce(0, (a, b) -> a + (a <= b ? b : -b))\n    ;\n    if (roman.charAt(0) == roman.charAt(1)) {\n      result += 2 * Enum.valueOf(Numeral.class, roman.substring(0, 1)).weight;\n    }\n    return result;\n  }\n\n  public static void test(long n) {\n    System.out.println(n + \" = \" + encode(n));\n    System.out.println(encode(n) + \" = \" + decode(encode(n)));\n  }\n\n  public static void main(String[] args) {\n    LongStream.of(1999, 25, 944).forEach(RomanNumerals::test);\n  }\n}\n\n\nOutput:\n1999 = MCMXCIX\nMCMXCIX = 1999\n25 = XXV\nXXV = 25\n944 = CMXLIV\nCMXLIV = 944\n", "explain": "The conversion function throws an IllegalArgumentException for non-positive numbers, since Java does not have unsigned primitives.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "C#", "code": "\nusing System;\nclass Program\n{\n    static uint[] nums = { 1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1 };\n    static string[] rum = { \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\", \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\" };\n\n    static string ToRoman(uint number)\n    {\n        string value = \"\";\n        for (int i = 0; i < nums.Length && number != 0; i++)\n        {\n            while (number >= nums[i])\n            {\n                number -= nums[i];\n                value += rum[i];\n            }\n        }\n        return value;\n    }\n\n    static void Main()\n    {\n        for (uint number = 1; number <= 1 << 10; number *= 2)\n        {\n            Console.WriteLine(\"{0} = {1}\", number, ToRoman(number));\n        }\n    }\n}\n\n\nFunc<int, string> toRoman = (number) =>\n  new Dictionary<int, string>\n  {\n    {1000, \"M\"},\n    {900, \"CM\"},\n    {500, \"D\"},\n    {400, \"CD\"},\n    {100, \"C\"},\n    {90, \"XC\"},\n    {50, \"L\"},\n    {40, \"XL\"},\n    {10, \"X\"},\n    {9, \"IX\"},\n    {5, \"V\"},\n    {4, \"IV\"},\n    {1, \"I\"}\n  }.Aggregate(new string('I', number), (m, _) => m.Replace(new string('I', _.Key), _.Value));\n\n\nOutput:\n1 = I\n2 = II\n4 = IV\n8 = VIII\n16 = XVI\n32 = XXXII\n64 = LXIV\n128 = CXXVIII\n256 = CCLVI\n512 = DXII\n1024 = MXXIV\n\n", "explain": "One-liner Mono REPL\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nES5[edit]\nIteration[edit]\nTranslation of: Tcl\nvar roman = {\n    map: [\n        1000, 'M', 900, 'CM', 500, 'D', 400, 'CD', 100, 'C', 90, 'XC',\n        50, 'L', 40, 'XL', 10, 'X', 9, 'IX', 5, 'V', 4, 'IV', 1, 'I',\n    ],\n    int_to_roman: function(n) {\n        var value = '';\n        for (var idx = 0; n > 0 && idx < this.map.length; idx += 2) {\n            while (n >= this.map[idx]) {\n                value += this.map[idx + 1];\n                n -= this.map[idx];\n            }\n        }\n        return value;\n    }\n}\n\nroman.int_to_roman(1999); // \"MCMXCIX\"\n\nFunctional composition[edit]\n(function () {\n    'use strict';\n\n\n    // If the Roman is a string, pass any delimiters through\n\n    // (Int | String) -> String\n    function romanTranscription(a) {\n        if (typeof a === 'string') {\n            var ps = a.split(/\\d+/),\n                dlm = ps.length > 1 ? ps[1] : undefined;\n\n            return (dlm ? a.split(dlm)\n                    .map(function (x) {\n                        return Number(x);\n                    }) : [a])\n                .map(roman)\n                .join(dlm);\n        } else return roman(a);\n    }\n\n    // roman\u00a0:: Int -> String\n    function roman(n) {\n        return [[1000, \"M\"], [900, \"CM\"], [500, \"D\"], [400, \"CD\"], [100,\n        \"C\"], [90, \"XC\"], [50, \"L\"], [40, \"XL\"], [10, \"X\"], [9,\n        \"IX\"], [5, \"V\"], [4, \"IV\"], [1, \"I\"]]\n            .reduce(function (a, lstPair) {\n                var m = a.remainder,\n                    v = lstPair[0];\n\n                return (v > m ? a : {\n                    remainder: m % v,\n                    roman: a.roman + Array(\n                            Math.floor(m / v) + 1\n                        )\n                        .join(lstPair[1])\n                });\n            }, {\n                remainder: n,\n                roman: ''\n            }).roman;   \n    }\n\n    // TEST\n\n    return [2016, 1990, 2008, \"14.09.2015\", 2000, 1666].map(\n        romanTranscription);\n\n})();\n\n\nOutput:\n[\"MMXVI\", \"MCMXC\", \"MMVIII\", \"XIV.IX.MMXV\", \"MM\", \"MDCLXVI\"]\n\nES6[edit]\nFunctional[edit]\nTranslation of: Haskell\n\n(() => {\n    \"use strict\";\n\n    // -------------- ROMAN INTEGER STRINGS --------------\n\n    // roman\u00a0:: Int -> String\n    const roman = n =>\n        mapAccumL(residue =>\n            ([k, v]) => second(\n                q => 0 < q ? (\n                    k.repeat(q)\n                ) : \"\"\n            )(remQuot(residue)(v))\n        )(n)(\n            zip([\n                \"M\", \"CM\", \"D\", \"CD\", \"C\", \"XC\",\n                \"L\", \"XL\", \"X\", \"IX\", \"V\", \"IV\", \"I\"\n            ])([\n                1000, 900, 500, 400, 100, 90,\n                50, 40, 10, 9, 5, 4, 1\n            ])\n        )[1]\n        .join(\"\");\n\n\n    // ---------------------- TEST -----------------------\n    // main\u00a0:: IO ()\n    const main = () => (\n        [2016, 1990, 2008, 2000, 2020, 1666].map(roman)\n    ).join(\"\\n\");\n\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // mapAccumL\u00a0:: (acc -> x -> (acc, y)) -> acc ->\n    // [x] -> (acc, [y])\n    const mapAccumL = f =>\n        // A tuple of an accumulation and a list\n        // obtained by a combined map and fold,\n        // with accumulation from left to right.\n        acc => xs => [...xs].reduce(\n            (a, x) => {\n                const tpl = f(a[0])(x);\n\n                return [\n                    tpl[0],\n                    a[1].concat(tpl[1])\n                ];\n            },\n            [acc, []]\n        );\n\n\n    // remQuot\u00a0:: Int -> Int -> (Int, Int)\n    const remQuot = m =>\n        n => [m % n, Math.trunc(m / n)];\n\n\n    // second\u00a0:: (a -> b) -> ((c, a) -> (c, b))\n    const second = f =>\n        // A function over a simple value lifted\n        // to a function over a tuple.\n        // f (a, b) -> (a, f(b))\n        xy => [xy[0], f(xy[1])];\n\n\n    // zip\u00a0:: [a] -> [b] -> [(a, b)]\n    const zip = xs =>\n        // The paired members of xs and ys, up to\n        // the length of the shorter of the two lists.\n        ys => Array.from({\n            length: Math.min(xs.length, ys.length)\n        }, (_, i) => [xs[i], ys[i]]);\n\n\n    // MAIN --\n    return main();\n})();\n\n\nOutput:\nMDCLXVI\nMCMXC\nMMVIII\nMMXVI\nMMXVIII\nMMXX\nDeclarative[edit]\nfunction toRoman(num) {\n  return 'I'\n    .repeat(num)\n    .replace(/IIIII/g, 'V')\n    .replace(/VV/g, 'X')\n    .replace(/XXXXX/g, 'L')\n    .replace(/LL/g, 'C')\n    .replace(/CCCCC/g, 'D')\n    .replace(/DD/g, 'M')\n    .replace(/VIIII/g, 'IX')\n    .replace(/LXXXX/g, 'XC')\n    .replace(/XXXX/g, 'XL')\n    .replace(/DCCCC/g, 'CM')\n    .replace(/CCCC/g, 'CD')\n    .replace(/IIII/g, 'IV');\n}\n\nconsole.log(toRoman(1666));\n\n\nOutput:\nMDCLXVI\n\n", "explain": "(mapAccumL version)\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "SQL", "code": "\n-- \n-- This only works under Oracle and has the limitation of 1 to 3999\n\n\nSQL> select to_char(1666, 'RN') urcoman, to_char(1666, 'rn') lcroman from dual;\n\nURCOMAN         LCROMAN\n--------------- ---------------\n        MDCLXVI         mdclxvi\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "PHP", "code": "\nWorks with: PHP version 4+ tested in 5.2.12\n/**\n * int2roman\n * Convert any positive value of a 32-bit signed integer to its modern roman \n * numeral representation. Numerals within parentheses are multiplied by \n * 1000. ie. M == 1 000, (M) == 1 000 000, ((M)) == 1 000 000 000\n * \n * @param number - an integer between 1 and 2147483647\n * @return roman numeral representation of number\n */\nfunction int2roman($number)\n{\n\tif (!is_int($number) || $number < 1) return false; // ignore negative numbers and zero\n\t\n\t$integers = array(900, 500,  400, 100,   90,  50,   40,  10,    9,   5,    4,   1);\n\t$numerals = array('CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I');\n\t$major = intval($number / 1000) * 1000;\n\t$minor = $number - $major;\n\t$numeral = $leastSig = '';\n\t\n\tfor ($i = 0; $i < sizeof($integers); $i++) {\n\t\twhile ($minor >= $integers[$i]) {\n\t\t\t$leastSig .= $numerals[$i];\n\t\t\t$minor  -= $integers[$i];\n\t\t}\n\t}\n\t\n\tif ($number >= 1000 && $number < 40000) {\n\t\tif ($major >= 10000) {\n\t\t\t$numeral .= '(';\n\t\t\twhile ($major >= 10000) {\n\t\t\t\t$numeral .= 'X';\n\t\t\t\t$major -= 10000;\n\t\t\t}\n\t\t\t$numeral .= ')';\n\t\t}\n\t\tif ($major == 9000) {\n\t\t\t$numeral .= 'M(X)';\n\t\t\treturn $numeral . $leastSig;\n\t\t}\n\t\tif ($major == 4000) {\n\t\t\t$numeral .= 'M(V)';\n\t\t\treturn $numeral . $leastSig;\n\t\t}\n\t\tif ($major >= 5000) {\n\t\t\t$numeral .= '(V)';\n\t\t\t$major -= 5000;\n\t\t}\n\t\twhile ($major >= 1000) {\n\t\t\t$numeral .= 'M';\n\t\t\t$major -= 1000;\n\t\t}\n\t}\n\t\n\tif ($number >= 40000) {\n\t\t$major = $major/1000;\n\t\t$numeral .= '(' . int2roman($major) . ')';\n\t}\n\t\n\treturn $numeral . $leastSig;\n}\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram roman_numerals\n\n  implicit none\n\n  write (*, '(a)') roman (2009)\n  write (*, '(a)') roman (1666)\n  write (*, '(a)') roman (3888)\n\ncontains\n\nfunction roman (n) result (r)\n\n  implicit none\n  integer, intent (in) :: n\n  integer, parameter   :: d_max = 13\n  integer              :: d\n  integer              :: m\n  integer              :: m_div\n  character (32)       :: r\n  integer,        dimension (d_max), parameter :: d_dec = &\n    & (/1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1/)\n  character (32), dimension (d_max), parameter :: d_rom = &\n    & (/'M ', 'CM', 'D ', 'CD', 'C ', 'XC', 'L ', 'XL', 'X ', 'IX', 'V ', 'IV', 'I '/)\n\n  r = ''\n  m = n\n  do d = 1, d_max\n    m_div = m / d_dec (d)\n    r = trim (r) // repeat (trim (d_rom (d)), m_div)\n    m = m - d_dec (d) * m_div\n  end do\n\nend function roman\n\nend program roman_numerals\n\n\nOutput:\n  MMIX\n  MDCLXVI\n  MMMDCCCLXXXVIII\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nvar (\n    m0 = []string{\"\", \"I\", \"II\", \"III\", \"IV\", \"V\", \"VI\", \"VII\", \"VIII\", \"IX\"}\n    m1 = []string{\"\", \"X\", \"XX\", \"XXX\", \"XL\", \"L\", \"LX\", \"LXX\", \"LXXX\", \"XC\"}\n    m2 = []string{\"\", \"C\", \"CC\", \"CCC\", \"CD\", \"D\", \"DC\", \"DCC\", \"DCCC\", \"CM\"}\n    m3 = []string{\"\", \"M\", \"MM\", \"MMM\", \"I\u0305V\u0305\",\n        \"V\u0305\", \"V\u0305I\u0305\", \"V\u0305I\u0305I\u0305\", \"V\u0305I\u0305I\u0305I\u0305\", \"I\u0305X\u0305\"}\n    m4 = []string{\"\", \"X\u0305\", \"X\u0305X\u0305\", \"X\u0305X\u0305X\u0305\", \"X\u0305L\u0305\",\n        \"L\u0305\", \"L\u0305X\u0305\", \"L\u0305X\u0305X\u0305\", \"L\u0305X\u0305X\u0305X\u0305\", \"X\u0305C\u0305\"}\n    m5 = []string{\"\", \"C\u0305\", \"C\u0305C\u0305\", \"C\u0305C\u0305C\u0305\", \"C\u0305D\u0305\",\n        \"D\u0305\", \"D\u0305C\u0305\", \"D\u0305C\u0305C\u0305\", \"D\u0305C\u0305C\u0305C\u0305\", \"C\u0305M\u0305\"}\n    m6 = []string{\"\", \"M\u0305\", \"M\u0305M\u0305\", \"M\u0305M\u0305M\u0305\"}\n)\n\nfunc formatRoman(n int) (string, bool) {\n    if n < 1 || n >= 4e6 {\n        return \"\", false\n    }\n    // this is efficient in Go.  the seven operands are evaluated,\n    // then a single allocation is made of the exact size needed for the result.\n    return m6[n/1e6] + m5[n%1e6/1e5] + m4[n%1e5/1e4] + m3[n%1e4/1e3] +\n        m2[n%1e3/1e2] + m1[n%100/10] + m0[n%10],\n        true\n}\n\nfunc main() {\n    // show three numbers mentioned in task descriptions\n    for _, n := range []int{1990, 2008, 1666} {\n        r, ok := formatRoman(n)\n        if ok {\n            fmt.Println(n, \"==\", r)\n        } else {\n            fmt.Println(n, \"not representable\")\n        }\n    }\n}\n\n\nOutput:\n1990 == MCMXC\n2008 == MMVIII\n1666 == MDCLXVI\n\n", "explain": "For fluff, the unicode overbar is recognized as a factor of 1000, as described in WP.\nIf you see boxes in the code below, those are supposed to be the Unicode combining overline (U+0305) and look like IVXLCDM.  Or, if you see overstruck combinations of letters, that's a different font rendering problem.  (If you need roman numerals > 3999 reliably, it might best to stick to chiseling them in stone...)\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nTranslation of: DWScript\nprogram RomanNumeralsEncode;\n\n{$APPTYPE CONSOLE}\n\nfunction IntegerToRoman(aValue: Integer): string;\nvar\n  i: Integer;\nconst\n  WEIGHTS: array[0..12] of Integer = (1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1);\n  SYMBOLS: array[0..12] of string = ('M', 'CM', 'D', 'CD', 'C', 'XC', 'L', 'XL', 'X', 'IX', 'V', 'IV', 'I');\nbegin\n  for i := Low(WEIGHTS) to High(WEIGHTS) do\n  begin\n    while aValue >= WEIGHTS[i] do\n    begin\n      Result := Result + SYMBOLS[i];\n      aValue := aValue - WEIGHTS[i];\n    end;\n    if aValue = 0 then\n      Break;\n  end;\nend;\n\nbegin\n  Writeln(IntegerToRoman(1990)); // MCMXC\n  Writeln(IntegerToRoman(2008)); // MMVIII\n  Writeln(IntegerToRoman(1666)); // MDCLXVI\nend.\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\nSymbols = { 1=>'I', 5=>'V', 10=>'X', 50=>'L', 100=>'C', 500=>'D', 1000=>'M' }\nSubtractors = [ [1000, 100], [500, 100], [100, 10], [50, 10], [10, 1], [5, 1], [1, 0] ]\n\ndef roman(num)\n  return Symbols[num]  if Symbols.has_key?(num)\n  Subtractors.each do |cutPoint, subtractor| \n    return roman(cutPoint) + roman(num - cutPoint)      if num >  cutPoint\n    return roman(subtractor) + roman(num + subtractor)  if num >= cutPoint - subtractor and num < cutPoint\n  end\nend\n\n[1990, 2008, 1666].each do |i|\n  puts \"%4d => %s\"\u00a0% [i, roman(i)]\nend\n\nOutput:\n1990 => MCMXC\n2008 => MMVIII\n1666 => MDCLXVI\n\n\nSymbols = [ [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I'] ]\n\ndef arabic_to_roman(arabic)\n  return '' if arabic.zero?\n  Symbols.each { |arabic_rep, roman_rep| return roman_rep + arabic_to_roman(arabic - arabic_rep) if arabic >= arabic_rep }\nend\n\nSymbols = [ [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I'] ]\n\ndef to_roman(num)\n    Symbols.reduce \"\" do |memo, (divisor, letter)|\n        div, num = num.divmod(divisor)\n        memo + letter * div\n    end\nend\n", "explain": "Roman numeral generation was used as an example for demonstrating Test Driven Development in Ruby. The solution came to be:\nAnother shorter version if we don't consider calculating the substractors:\nYet another way to solve it in terms of reduce\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Rust", "code": "\nstruct RomanNumeral {\n    symbol: &'static str,\n    value: u32\n}\n\nconst NUMERALS: [RomanNumeral; 13] = [\n    RomanNumeral {symbol: \"M\",  value: 1000},\n    RomanNumeral {symbol: \"CM\", value: 900},\n    RomanNumeral {symbol: \"D\",  value: 500},\n    RomanNumeral {symbol: \"CD\", value: 400},\n    RomanNumeral {symbol: \"C\",  value: 100},\n    RomanNumeral {symbol: \"XC\", value: 90},\n    RomanNumeral {symbol: \"L\",  value: 50},\n    RomanNumeral {symbol: \"XL\", value: 40},\n    RomanNumeral {symbol: \"X\",  value: 10},\n    RomanNumeral {symbol: \"IX\", value: 9},\n    RomanNumeral {symbol: \"V\",  value: 5},\n    RomanNumeral {symbol: \"IV\", value: 4},\n    RomanNumeral {symbol: \"I\",  value: 1}\n];\n\nfn to_roman(mut number: u32) -> String {\n    let mut min_numeral = String::new();\n    for numeral in NUMERALS.iter() {\n        while numeral.value <= number {\n            min_numeral = min_numeral + numeral.symbol;\n            number -= numeral.value;\n        }\n    }\n    min_numeral\n}\n\nfn main() {\n    let nums = [2014, 1999, 25, 1666, 3888];\n    for &n in nums.iter() {\n        // 4 is minimum printing width, for alignment\n        println!(\"{:2$} = {}\", n, to_roman(n), 4);\n    }\n}\nOutput:\n2014 = MMXIV\n1999 = MCMXCIX\n  25 = XXV\n1666 = MDCLXVI\n3888 = MMMDCCCLXXXVIII\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Swift", "code": "\nfunc ator(var n: Int) -> String {\n\n    var result = \"\"\n    \n    for (value, letter) in\n       [( 1000,    \"M\"),\n        (  900,   \"CM\"),\n        (  500,    \"D\"),\n        (  400,   \"CD\"),\n        (  100,    \"C\"),\n        (   90,   \"XC\"),\n        (   50,    \"L\"),\n        (   40,   \"XL\"),\n        (   10,    \"X\"),\n        (    9,   \"IX\"),\n        (    5,    \"V\"),\n        (    4,   \"IV\"),\n        (    1,    \"I\")]\n    {\n        while n >= value {\n            result += letter\n            n   -= value\n        }\n    }\n    return result\n}\n\nWorks with: Swift version 1.x\nprintln(ator(1666)) // MDCLXVI\nWorks with: Swift version 2.0\nprint(ator(1666)) // MDCLXVI\n\nOutput:\nMDCLXVI \n", "explain": "Sample call:\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "R", "code": "\n\nas.roman(1666)   # MDCLXVI\n\nas.roman(1666) + 334   # MM\n", "explain": "R has a built-in function, as.roman, for conversion to Roman numerals.  The implementation details are found in utils:::.numeric2roman (see previous link), and utils:::.roman2numeric, for conversion back to Arabic decimals.\nSince the object as.roman creates is just an integer vector with a class, you can do arithmetic with Roman numerals:\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "COBOL", "code": "\nIDENTIFICATION DIVISION.\nPROGRAM-ID. TOROMAN.\nDATA DIVISION.\nworking-storage section.\n  01 ws-number pic 9(4) value 0.\n  01 ws-save-number pic 9(4).\n  01 ws-tbl-def.\n    03 filler pic x(7) value '1000M  '.\n    03 filler pic x(7) value '0900CM '.\n    03 filler pic x(7) value '0500D  '.\n    03 filler pic x(7) value '0400CD '.\n    03 filler pic x(7) value '0100C  '.\n    03 filler pic x(7) value '0090XC '.\n    03 filler pic x(7) value '0050L  '.\n    03 filler pic x(7) value '0040XL '.\n    03 filler pic x(7) value '0010X  '.\n    03 filler pic x(7) value '0009IX '.\n    03 filler pic x(7) value '0005V  '.\n    03 filler pic x(7) value '0004IV '.\n    03 filler pic x(7) value '0001I  '.\n  01  filler redefines ws-tbl-def.\n    03 filler occurs 13 times indexed by rx.\n      05 ws-tbl-divisor    pic 9(4).\n      05 ws-tbl-roman-ch   pic x(1) occurs 3 times indexed by cx.\n  01 ocx pic 99.\n  01 ws-roman.\n    03 ws-roman-ch         pic x(1) occurs 16 times.\nPROCEDURE DIVISION.\n  accept ws-number\n  perform\n  until ws-number = 0\n    move ws-number to ws-save-number\n    if ws-number > 0 and ws-number < 4000\n      initialize ws-roman\n      move 0 to ocx\n      perform varying rx from 1 by +1\n      until ws-number = 0\n        perform until ws-number < ws-tbl-divisor (rx)\n          perform varying cx from 1 by +1 \n  \t\t  until ws-tbl-roman-ch (rx, cx) = spaces\n            compute ocx = ocx + 1\n            move ws-tbl-roman-ch (rx, cx) to ws-roman-ch (ocx)\n          end-perform\n          compute ws-number = ws-number - ws-tbl-divisor (rx)\n        end-perform\n      end-perform\n      display 'inp=' ws-save-number ' roman=' ws-roman\n    else\n      display 'inp=' ws-save-number ' invalid'\n    end-if\n    accept ws-number\n  end-perform\n  .\n\n\nOutput: (input was supplied via STDIN)\ninp=0111 roman=CXI             \ninp=2234 roman=MMCCXXXIV       \ninp=0501 roman=DI              \ninp=0010 roman=X               \ninp=0040 roman=XL              \ninp=0050 roman=L               \ninp=0066 roman=LXVI            \ninp=0666 roman=DCLXVI          \ninp=5666 invalid\ninp=3333 roman=MMMCCCXXXIII    \ninp=3888 roman=MMMDCCCLXXXVIII \ninp=3999 roman=MMMCMXCIX       \ninp=3345 roman=MMMCCCXLV      \n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Roman_Numeral_Test is\n   function To_Roman (Number : Positive) return String is\n      subtype Digit is Integer range 0..9;\n      function Roman (Figure : Digit; I, V, X : Character) return String is\n      begin\n         case Figure is\n            when 0 => return \"\";\n            when 1 => return \"\" & I;\n            when 2 => return I & I;\n            when 3 => return I & I & I;\n            when 4 => return I & V;\n            when 5 => return \"\" & V;\n            when 6 => return V & I;\n            when 7 => return V & I & I;\n            when 8 => return V & I & I & I;\n            when 9 => return I & X;\n         end case;\n      end Roman;\n   begin\n      pragma Assert (Number >= 1 and Number < 4000);\n      return\n         Roman (Number / 1000,       'M', ' ', ' ') &\n         Roman (Number / 100 mod 10, 'C', 'D', 'M') &\n         Roman (Number / 10 mod 10,  'X', 'L', 'C') &\n         Roman (Number mod 10,       'I', 'V', 'X');\n   end To_Roman;\nbegin\n   Put_Line (To_Roman (1999));\n   Put_Line (To_Roman (25));\n   Put_Line (To_Roman (944));\nend Roman_Numeral_Test;\n\n\nOutput:\n MCMXCIX\n XXV\n CMXLIV\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Julia", "code": "\nusing Printf\n\nfunction romanencode(n::Integer)\n    if n < 1 || n > 4999 throw(DomainError()) end\n\n    DR = [[\"I\", \"X\", \"C\", \"M\"] [\"V\", \"L\", \"D\", \"MMM\"]]\n    rnum = \"\"\n    for (omag, d) in enumerate(digits(n))\n        if d == 0\n            omr = \"\"\n        elseif d <  4\n            omr = DR[omag, 1] ^ d\n        elseif d == 4\n            omr = DR[omag, 1] * DR[omag, 2]\n        elseif d == 5\n            omr = DR[omag, 2]\n        elseif d <  9\n            omr = DR[omag, 2] * DR[omag, 1] ^ (d - 5)\n        else\n            omr = DR[omag, 1] * DR[omag + 1, 1]\n        end\n        rnum = omr * rnum\n    end\n    return rnum\nend\n\ntestcases = [1990, 2008, 1668]\nappend!(testcases, rand(1:4999, 12))\ntestcases = unique(testcases)\n\nprintln(\"Test romanencode, arabic => roman:\")\nfor n in testcases\n    @printf(\"%-4i => %s\\n\", n, romanencode(n))\nend\n\n\nOutput:\nTest romanencode, arabic => roman:\n1990 => MCMXC\n2008 => MMVIII\n1668 => MDCLXVIII\n2928 => MMCMXXVIII\n129  => CXXIX\n4217 => MMMMCCXVII\n1503 => MDIII\n2125 => MMCXXV\n1489 => MCDLXXXIX\n3677 => MMMDCLXXVII\n1465 => MCDLXV\n1421 => MCDXXI\n1642 => MDCXLII\n572  => DLXXII\n3714 => MMMDCCXIV\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\nval romanNumerals = mapOf(\n    1000 to \"M\",\n    900 to \"CM\",\n    500 to \"D\",\n    400 to \"CD\",\n    100 to \"C\",\n    90 to \"XC\",\n    50 to \"L\",\n    40 to \"XL\",\n    10 to \"X\",\n    9 to \"IX\",\n    5 to \"V\",\n    4 to \"IV\",\n    1 to \"I\"\n)\n\nfun encode(number: Int): String? {\n    if (number > 5000 || number < 1) {\n        return null\n    }\n    var num = number\n    var result = \"\"\n    for ((multiple, numeral) in romanNumerals.entries) {\n        while (num >= multiple) {\n            num -= multiple\n            result += numeral\n        }\n    }\n    return result\n}\n\nfun main(args: Array<String>) {\n    println(encode(1990))\n    println(encode(1666))\n    println(encode(2008))\n}\n\n\nOutput:\nMCMXC\nMDCLXVI\nMMVIII\n\n\nfun Int.toRomanNumeral(): String {\n    fun digit(k: Int, unit: String, five: String, ten: String): String {\n        return when (k) {\n            in 1..3 -> unit.repeat(k)\n            4 -> unit + five\n            in 5..8 -> five + unit.repeat(k - 5)\n            9 -> unit + ten\n            else -> throw IllegalArgumentException(\"$k not in range 1..9\")\n        }\n    }\n    return when (this) {\n        0 -> \"\"\n        in 1..9 -> digit(this, \"I\", \"V\", \"X\")\n        in 10..99 -> digit(this / 10, \"X\", \"L\", \"C\") + (this % 10).toRomanNumeral()\n        in 100..999 -> digit(this / 100, \"C\", \"D\", \"M\") + (this % 100).toRomanNumeral()\n        in 1000..3999 -> \"M\" + (this - 1000).toRomanNumeral()\n        else -> throw IllegalArgumentException(\"${this} not in range 0..3999\")\n    }\n}\n\n", "explain": "Alternatively:\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Perl", "code": "\nSimple program[edit]\n\nmy @symbols = ( [1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I']  );\n\nsub roman {\n  my($n, $r) = (shift, '');\n  ($r, $n) = ('-', -$n) if $n < 0;  # Optional handling of negative input\n  foreach my $s (@symbols) {\n    my($arabic, $roman) = @$s;\n    ($r, $n) = ($r .= $roman x int($n/$arabic),  $n\u00a0% $arabic)\n       if $n >= $arabic;\n  }\n  $r;\n}\n\nsay roman($_) for 1..2012;\nUsing a module[edit]\nuse Math::Roman qw/roman/;\nsay roman($_) for 1..2012'\nPorted version of Raku[edit]\nuse List::MoreUtils qw( natatime );\n\nmy %symbols = (\n    1 => \"I\", 5 => \"V\", 10 => \"X\", 50 => \"L\", 100 => \"C\",\n    500 => \"D\", 1_000 => \"M\"\n);\n\nmy @subtractors = (\n        1_000, 100,  500, 100,  100, 10,  50, 10,  10, 1,  5, 1,  1, 0\n);\n\nsub roman {\n    return '' if 0 == (my $n = shift);\n    my $iter = natatime 2, @subtractors;\n    while( my ($cut, $minus) = $iter->() ) {\n        $n >= $cut\n            and return $symbols{$cut} . roman($n - $cut);\n        $n >= $cut - $minus\n            and return $symbols{$minus} . roman($n + $minus);\n    }\n};\n\nprint roman($_) . \"\\n\" for 1..2012;\n", "explain": "Simple, fast, produces same output as the Math::Roman module and the Raku example, less crazy than writing a Latin program, and doesn't require experimental modules like the Raku translation.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog\nLibrary: clpfd\n\n:- use_module(library(clpfd)).\n\nroman\u00a0:-\n\tLA =  [    _       , 2010,    _, 1449,         _],\n\tLR =  ['MDCCLXXXIX',  _  , 'CX',    _, 'MDCLXVI'],\n\tmaplist(roman,   LA, LR),\n\tmaplist(my_print,LA, LR).\n\n\nroman(A, R)\u00a0:-\n\tA #> 0,\n\troman(A, [u, t, h, th], LR, []),\n\tlabel([A]),\n\tparse_Roman(CR, LR, []),\n\tatom_chars(R, CR).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% using DCG\n \nroman(0, []) --> [].\n\nroman(N, [H | T]) -->\n\t{N1 #= N / 10,\n\t N2 #= N mod 10},\n\troman(N1, T),\n\tunity(N2, H).\n\nunity(1, u) --> ['I'].\nunity(1, t) --> ['X'].\nunity(1, h) --> ['C'].\nunity(1, th)--> ['M'].\n\nunity(4, u) --> ['IV'].\nunity(4, t) --> ['XL'].\nunity(4, h) --> ['CD'].\nunity(4, th)--> ['MMMM'].\n\nunity(5, u) --> ['V'].\nunity(5, t) --> ['L'].\nunity(5, h) --> ['D'].\nunity(5, th)--> ['MMMMM'].\n\nunity(9, u) --> ['IX'].\nunity(9, t) --> ['XC'].\nunity(9, h) --> ['CM'].\nunity(9, th)--> ['MMMMMMMMM'].\n\nunity(0, _) --> [].\n\n\nunity(V, U)-->\n\t{V #> 5,\n\tV1 #= V - 5},\n\tunity(5, U),\n\tunity(V1, U).\n\nunity(V, U) -->\n\t{V #> 1, V #< 4,\n\tV1 #= V-1},\n\tunity(1, U),\n\tunity(V1, U).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% Extraction of roman \"lexeme\"\nparse_Roman(['C','M'|T]) -->\n\t['CM'],\n\tparse_Roman(T).\n\nparse_Roman(['C','D'|T]) -->\n\t['CD'],\n\tparse_Roman(T).\n\nparse_Roman(['X','C'| T]) -->\n\t['XC'],\n\tparse_Roman(T).\n\n\nparse_Roman(['X','L'| T]) -->\n\t['XL'],\n\tparse_Roman(T).\n\n\nparse_Roman(['I','X'| T]) -->\n\t['IX'],\n\tparse_Roman(T).\n\n\nparse_Roman(['I','V'| T]) -->\n\t['IV'],\n\tparse_Roman(T).\n\nparse_Roman([H | T]) -->\n\t[H],\n\tparse_Roman(T).\n\n\nparse_Roman([]) -->\n\t[].\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nmy_print(A, R)\u00a0:-\n\tformat('~w in roman is ~w~n', [A, R]).\n\nOutput:\n\u00a0?- roman.\n1789 in roman is MDCCLXXXIX\n2010 in roman is MMX\n110 in roman is CX\n1449 in roman is MCDXLIX\n1666 in roman is MDCLXVI\ntrue .\n\n", "explain": "Library clpfd assures that the program works in both managements\u00a0: Roman towards Arabic and Arabic towards Roman.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Lua", "code": "\nromans = {\n{1000, \"M\"},\n{900, \"CM\"}, {500, \"D\"}, {400, \"CD\"}, {100, \"C\"},\n{90, \"XC\"}, {50, \"L\"}, {40, \"XL\"}, {10, \"X\"},\n{9, \"IX\"}, {5, \"V\"}, {4, \"IV\"}, {1, \"I\"} }\n\nk = io.read() + 0\nfor _, v in ipairs(romans) do --note that this is -not- ipairs.\n  val, let = unpack(v)\n  while k >= val do\n    k = k - val\n\tio.write(let)\n  end\nend\nprint()\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Scala", "code": "\nWorks with: Scala version 2.8\nval romanDigits = Map(\n  1 -> \"I\", 5 -> \"V\", \n  10 -> \"X\", 50 -> \"L\", \n  100 -> \"C\", 500 -> \"D\", \n  1000 -> \"M\", \n  4 -> \"IV\", 9 -> \"IX\", \n  40 -> \"XL\", 90 -> \"XC\", \n  400 -> \"CD\", 900 -> \"CM\")\nval romanDigitsKeys = romanDigits.keysIterator.toList sortBy (x => -x)\ndef toRoman(n: Int): String = romanDigitsKeys find (_ >= n) match {\n  case Some(key) => romanDigits(key) + toRoman(n - key)\n  case None => \"\"\n}\n\nOutput:\nscala> List(1990, 2008, 1666) map toRoman\nres55: List[String] = List(MCMXC, MMVIII, MDCLXVI)\nUsing foldLeft[edit]\ndef toRoman( v:Int )\u00a0: String = {\n  val romanNumerals = List(1000->\"M\",900->\"CM\",500->\"D\",400->\"CD\",100->\"C\",90->\"XC\",\n                           50->\"L\",40->\"XL\",10->\"X\",9->\"IX\",5->\"V\",4->\"IV\",1->\"I\")\t\n                            \n  var n = v                          \n  romanNumerals.foldLeft(\"\"){(s,t) => {val c = n/t._1; n = n-t._1*c;  s + (t._2 * c) } }\n}\n  \n// A small test\ndef test( arabic:Int ) = println( arabic + \" => \" + toRoman( arabic ) )\n  \ntest(1990)\ntest(2008)\ntest(1666)\nDifferent code-style[edit]\ndef toRoman(num: Int): String = {\n  case class RomanUnit(value: Int, token: String)\n  val romanNumerals = List(\n    RomanUnit(1000, \"M\"),\n    RomanUnit(900, \"CM\"),\n    RomanUnit(500, \"D\"),\n    RomanUnit(400, \"CD\"),\n    RomanUnit(100, \"C\"),\n    RomanUnit(90, \"XC\"),\n    RomanUnit(50, \"L\"),\n    RomanUnit(40, \"XL\"),\n    RomanUnit(10, \"X\"),\n    RomanUnit(9, \"IX\"),\n    RomanUnit(5, \"V\"),\n    RomanUnit(4, \"IV\"),\n    RomanUnit(1, \"I\"))\n\n  var remainingNumber = num\n  romanNumerals.foldLeft(\"\") { (outputStr, romanUnit) =>\n    {\n      val times = remainingNumber / romanUnit.value\n      remainingNumber -= romanUnit.value * times\n      outputStr + (romanUnit.token * times)\n    }\n  }\n}\n\nOutput:\n1990 => MCMXC\n2008 => MMVIII\n1666 => MDCLXVI\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "D", "code": "\nstring toRoman(int n) pure nothrow\nin {\n    assert(n < 5000);\n} body {\n    static immutable weights = [1000, 900, 500, 400, 100, 90,\n                                50, 40, 10, 9, 5, 4, 1];\n    static immutable symbols = [\"M\",\"CM\",\"D\",\"CD\",\"C\",\"XC\",\"L\",\n                                \"XL\",\"X\",\"IX\",\"V\",\"IV\",\"I\"];\n\n    string roman;\n    foreach (i, w; weights) {\n        while (n >= w) {\n            roman ~= symbols[i];\n            n -= w;\n        }\n        if (n == 0)\n            break;\n    }\n    return roman;\n} unittest {\n    assert(toRoman(455)  == \"CDLV\");\n    assert(toRoman(3456) == \"MMMCDLVI\");\n    assert(toRoman(2488) == \"MMCDLXXXVIII\");\n}\n\nvoid main() {}\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Haskell", "code": "\n\ndigit :: Char -> Char -> Char -> Integer -> String\ndigit x y z k =\n  [[x], [x, x], [x, x, x], [x, y], [y], [y, x], [y, x, x], [y, x, x, x], [x, z]] !!\n  (fromInteger k - 1)\n\ntoRoman :: Integer -> String\ntoRoman 0 = \"\"\ntoRoman x\n  | x < 0 = error \"Negative roman numeral\"\ntoRoman x\n  | x >= 1000 = 'M' : toRoman (x - 1000)\ntoRoman x\n  | x >= 100 = digit 'C' 'D' 'M' q ++ toRoman r\n  where\n    (q, r) = x `divMod` 100\ntoRoman x\n  | x >= 10 = digit 'X' 'L' 'C' q ++ toRoman r\n  where\n    (q, r) = x `divMod` 10\ntoRoman x = digit 'I' 'V' 'X' x\n\nmain :: IO ()\nmain = print $ toRoman <$> [1999, 25, 944]\n\n\nOutput:\n[\"MCMXCIX\",\"XXV\",\"CMXLIV\"]\n\nimport Data.Bifunctor (first)\nimport Data.List (mapAccumL)\nimport Data.Tuple (swap)\n\nroman :: Int -> String\nroman =\n  romanFromInt $\n  zip\n    [1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1]\n    (words \"M CM D CD C XC L XL X IX V IV I\")\n\nromanFromInt :: [(Int, String)] -> Int -> String\nromanFromInt nks n = concat . snd $ mapAccumL go n nks\n  where\n    go a (v, s) = swap $ first ((>> s) . enumFromTo 1) $ quotRem a v\n\nmain :: IO ()\nmain = (putStrLn . unlines) (roman <$> [1666, 1990, 2008, 2016, 2018])\n\n\nOutput:\nMDCLXVI\nMCMXC\nMMVIII\nMMXVI\nMMXVIII\n\nmodule Main where\n\n------------------------\n--  ENCODER FUNCTION  --\n------------------------\n\nromanDigits = \"IVXLCDM\"\n\n--  Meaning and indices of the romanDigits sequence:\n--\n--    magnitude |  1 5  | index\n--   -----------|-------|-------\n--        0     |  I V  |  0 1   \n--        1     |  X L  |  2 3   \n--        2     |  C D  |  4 5   \n--        3     |  M    |  6     \n--\n--  romanPatterns are index offsets into romanDigits,\n--  from an index base of 2 * magnitude.\n\nromanPattern 0 = []      -- empty string\nromanPattern 1 = [0]     -- I or X or C or M\nromanPattern 2 = [0,0]   -- II or XX...\nromanPattern 3 = [0,0,0] -- III...\nromanPattern 4 = [0,1]   -- IV...\nromanPattern 5 = [1]     -- ...\nromanPattern 6 = [1,0]\nromanPattern 7 = [1,0,0]\nromanPattern 8 = [1,0,0,0]\nromanPattern 9 = [0,2]\n\nencodeValue 0 _ = \"\"\nencodeValue value magnitude = encodeValue rest (magnitude + 1) ++ digits\n  where\n    low = rem value 10 -- least significant digit (encoded now)\n    rest = div value 10 -- the other digits (to be encoded next)\n    indices = map addBase (romanPattern low)\n    addBase i = i + (2 * magnitude)\n    digits = map pickDigit indices\n    pickDigit i = romanDigits!!i\n\nencode value = encodeValue value 0\n\n------------------\n--  TEST SUITE  --\n------------------\n\nmain = do\n  test \"MCMXC\" 1990\n  test \"MMVIII\" 2008\n  test \"MDCLXVI\" 1666\n\ntest expected value = putStrLn ((show value) ++ \" = \" ++ roman ++ remark)\n  where\n    roman = encode value\n    remark =\n      \" (\" ++\n      (if roman == expected then \"PASS\"\n       else (\"FAIL, expected \" ++ (show expected))) ++ \")\"\n\n\nOutput:\n1990 = MCMXC (PASS)\n2008 = MMVIII (PASS)\n1666 = MDCLXVI (PASS)\n\n", "explain": "With an explicit decimal digit representation list:\nor, defining romanFromInt in terms of mapAccumL\nWith the Roman patterns abstracted, and in a simple logic programming idiom:\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "PL/SQL", "code": "\n/*****************************************************************\n * $Author: Atanas Kebedjiev $\n *****************************************************************\n * Encoding an Arabic numeral to a Roman in the range 1..3999 is much simpler as Oracle provides the conversion formats.\n * Please see also the SQL solution for the same task.\n */\n\nCREATE OR REPLACE\nFUNCTION rencode(an IN NUMBER) \n  RETURN VARCHAR2 \nIS\nBEGIN\n  RETURN to_char(an, 'RN');\nEND rencode;\n\nBEGIN\n\n    DBMS_OUTPUT.PUT_LINE ('2012 = ' || rencode('2012'));     -- MMXII\n    DBMS_OUTPUT.PUT_LINE ('1951 = ' || rencode('1951'));     -- MCMLI\n    DBMS_OUTPUT.PUT_LINE ('1987 = ' || rencode('1987'));     -- MCMLXXXVII\n    DBMS_OUTPUT.PUT_LINE ('1666 = ' || rencode('1666'));     -- MDCLXVI\n    DBMS_OUTPUT.PUT_LINE ('1999 = ' || rencode('1999'));     -- MCMXCIX\n\nEND;\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Scheme", "code": "\n\n(define (to-roman n)\n  (format \"~@r\" n))\n\n(define roman-decimal\n  '((\"M\"  . 1000)\n    (\"CM\" . 900)\n    (\"D\"  . 500)\n    (\"CD\" . 400)\n    (\"C\"  . 100)\n    (\"XC\" .  90)\n    (\"L\"  .  50)\n    (\"XL\" .  40)\n    (\"X\"  .  10)\n    (\"IX\" .   9)\n    (\"V\"  .   5)\n    (\"IV\" .   4)\n    (\"I\"  .   1)))\n\n(define (to-roman value)\n  (apply string-append\n         (let loop ((v value)\n                    (decode roman-decimal))\n           (let ((r (caar decode))\n                 (d (cdar decode)))\n             (cond\n              ((= v 0) '())\n              ((>= v d) (cons r (loop (- v d) decode)))\n              (else (loop v (cdr decode))))))))\n\n\n(let loop ((n '(1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19 20 25 30 40 \n                  50 60 69 70 80 90 99 100 200 300 400 500 600 666 700 800 900 \n                  1000 1009 1444 1666 1945 1997 1999 2000 2008 2010 2011 2500 \n                  3000 3999)))\n  (unless (null? n)\n    (printf \"~a ~a\\n\" (car n) (to-roman (car n)))\n    (loop (cdr n))))\n", "explain": "This uses format directives supported in Chez Scheme since v6.9b; YMMV.\nThis is a general example using Chicken Scheme.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "TypeScript", "code": "\nTranslation of: DWScript\n\n// Roman numerals/Encode\n\nconst weightsSymbols: [number, string][] = \n  [[1000, 'M'], [900, 'CM'], [500, 'D'], [400, 'CD'], [100, 'C'], [90, 'XC'], \n  [50, 'L'], [40, 'XL'], [10, 'X'], [9, 'IX'], [5, 'V'], [4, 'IV'], [1, 'I']];\n// 3888 or MMMDCCCLXXXVIII (15 chars) is the longest string properly encoded\n// with these symbols.\n\nfunction toRoman(n: number): string {\n  var roman = \"\"; // Result\n  for (i = 0; i <= 12 && n > 0; i++) {\n    var w = weightsSymbols[i][0];\n    while (n >= w) {\n      roman += weightsSymbols[i][1];\n      n -= w;\n    }\n  }\n  return roman;\n}\n\nconsole.log(toRoman(1990)); // MCMXC\nconsole.log(toRoman(2022)); // MMXXII\nconsole.log(toRoman(3888)); // MMMDCCCLXXXVIII\n\nOutput:\nMCMXC\nMMXXII\nMMMDCCCLXXXVIII\n\n", "explain": "Weights and symbols in tuples.\n"}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\nFilter ToRoman {\n\t$output = ''\n\t\n\tif ($_ -ge 4000) {\n\t\tthrow 'Number too high'\n\t}\n\t\n\t$current = 1000\n\t$subtractor = 'M'\n\t$whole = $False\n\t$decimal = $_\n\t'C','D','X','L','I','V',' ' `\n\t|\u00a0%{\n\t\t$divisor = $current\n\t\tif ($whole =\u00a0!$whole) {\n\t\t\t$current /= 10\n\t\t\t$subtractor = $_ + $subtractor[0]\n\t\t\t$_ = $subtractor[1]\n\t\t}\n\t\telse {\n\t\t\t$divisor *= 5 \n\t\t\t$subtractor = $subtractor[0] + $_\n\t\t}\n\t\t\n\t\t$multiple = [Math]::floor($decimal / $divisor)\n\t\tif ($multiple) {\n\t\t\t$output += [string]$_ * $multiple\n\t\t\t$decimal\u00a0%= $divisor\n\t\t}\n\t\tif ($decimal -ge ($divisor -= $current)) {\n\t\t\t$output += $subtractor\n\t\t\t$decimal -= $divisor\n\t\t}\n\t}\n\t\n\t$output\n}\n19,4,0,2479,3001 | ToRoman\n\nOutput:\nXIX\nIV\n\nMMCDLXXIX\nMMMI             \n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Logo", "code": "\nmake \"roman.rules [\n  [1000 M] [900 CM] [500 D] [400 CD]\n  [ 100 C] [ 90 XC] [ 50 L] [ 40 XL]\n  [  10 X] [  9 IX] [  5 V] [  4 IV]\n  [   1 I]\n]\n\nto roman :n [:rules :roman.rules] [:acc \"||]\n  if empty? :rules [output :acc]\n  if :n < first first :rules [output (roman :n bf :rules :acc)]\n  output (roman :n - first first :rules  :rules  word :acc last first :rules)\nend\nWorks with: UCB Logo\nmake \"patterns [[?] [?\u00a0?] [?\u00a0?\u00a0?] [? ?2] [?2] [?2\u00a0?] [?2\u00a0?\u00a0?] [?2\u00a0?\u00a0?\u00a0?] [? ?3]]\n\nto digit :d :numerals\n  if :d = 0 [output \"||]\n  output apply (sentence \"\\( \"word (item :d :patterns) \"\\)) :numerals\nend\nto digits :n :numerals\n  output word ifelse :n < 10 [\"||] [digits int :n/10 bf bf :numerals] ~\n              digit modulo :n 10 :numerals\nend\nto roman :n\n  if or :n < 0 :n >= 4000 [output [EX MODVS!]]\n  output digits :n [I V X L C D M]\nend\n\nprint roman 1999 \u00a0; MCMXCIX \nprint roman 25   \u00a0; XXV\nprint roman 944  \u00a0; CMXLIV\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "F#", "code": "\nlet digit x y z = function\n    1 -> x\n  | 2 -> x + x\n  | 3 -> x + x + x\n  | 4 -> x + y\n  | 5 -> y\n  | 6 -> y + x\n  | 7 -> y + x + x\n  | 8 -> y + x + x + x\n  | 9 -> x + z\n  | _ -> failwith \"invalid call to digit\"\n \nlet rec to_roman acc = function\n    | x when x >= 1000 -> to_roman (acc + \"M\") (x - 1000)\n    | x when x >= 100 -> to_roman (acc + digit \"C\" \"D\" \"M\" (x / 100)) (x % 100)\n    | x when x >= 10 -> to_roman (acc + digit \"X\" \"L\" \"C\" (x / 10)) (x % 10)\n    | x when x > 0 -> acc + digit \"I\" \"V\" \"X\" x\n    | 0 -> acc\n    | _ -> failwith \"invalid call to_roman (negative input)\"\n\nlet roman n = to_roman \"\" n\n\n[<EntryPoint>]\nlet main args =\n    [1990; 2008; 1666]\n    |> List.map (fun n -> roman n)\n    |> List.iter (printfn \"%s\")\n    0\n\n\nOutput:\nMCMXC\nMMVIII\nMDCLXVI\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "Groovy", "code": "\nsymbols = [ 1:'I', 4:'IV', 5:'V', 9:'IX', 10:'X', 40:'XL', 50:'L', 90:'XC', 100:'C', 400:'CD', 500:'D', 900:'CM', 1000:'M' ]\n\ndef roman(arabic) {\n    def result = \"\"\n    symbols.keySet().sort().reverse().each { \n        while (arabic >= it) {\n            arabic-=it\n            result+=symbols[it]\n        }\n    }\n    return result\n}\nassert roman(1) == 'I'\nassert roman(2) == 'II'\nassert roman(4) == 'IV'\nassert roman(8) == 'VIII'\nassert roman(16) == 'XVI'\nassert roman(32) == 'XXXII'\nassert roman(25) == 'XXV'\nassert roman(64) == 'LXIV'\nassert roman(128) == 'CXXVIII'\nassert roman(256) == 'CCLVI'\nassert roman(512) == 'DXII'\nassert roman(954) == 'CMLIV'\nassert roman(1024) == 'MXXIV'\nassert roman(1666) == 'MDCLXVI'\nassert roman(1990) == 'MCMXC'\nassert roman(2008) == 'MMVIII'\n\n", "explain": ""}, {"task_name": "Roman numerals/Encode", "task_url": "https://rosettacode.org/wiki/Roman_numerals/Encode", "task_cat": "String manipulation", "lang": "AWK", "code": "\n# syntax: GAWK -f ROMAN_NUMERALS_ENCODE.AWK\nBEGIN {\n    leng = split(\"1990 2008 1666\",arr,\" \")\n    for (i=1; i<=leng; i++) {\n      n = arr[i]\n      printf(\"%s = %s\\n\",n,dec2roman(n))\n    }\n    exit(0)\n}\nfunction dec2roman(number,  v,w,x,y,roman1,roman10,roman100,roman1000) {\n    number = int(number) # force to integer\n    if (number < 1 || number > 3999) { # number is too small | big\n      return\n    }\n    split(\"I II III IV V VI VII VIII IX\",roman1,\" \")   # 1 2 ... 9\n    split(\"X XX XXX XL L LX LXX LXXX XC\",roman10,\" \")  # 10 20 ... 90\n    split(\"C CC CCC CD D DC DCC DCCC CM\",roman100,\" \") # 100 200 ... 900\n    split(\"M MM MMM\",roman1000,\" \")                    # 1000 2000 3000\n    v = (number - (number % 1000)) / 1000\n    number = number % 1000\n    w = (number - (number % 100)) / 100\n    number = number % 100\n    x = (number - (number % 10)) / 10\n    y = number % 10\n    return(roman1000[v] roman100[w] roman10[x] roman1[y])\n}\n\n\nOutput:\n1990 = MCMXC\n2008 = MMVIII\n1666 = MDCLXVI\n\n", "explain": ""}]