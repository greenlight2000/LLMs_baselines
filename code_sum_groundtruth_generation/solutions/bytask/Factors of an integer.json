[{"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Python", "code": "\n\n>>> def factors(n):\n      return [i for i in range(1, n + 1) if not n%i]\n\n>>> def factors(n):\n      return [i for i in range(1, n//2 + 1) if not n%i] + [n]\n\n>>> factors(45)\n[1, 3, 5, 9, 15, 45]\n\nfrom math import isqrt\ndef factor(n):\n    factors1, factors2 = [], []\n    for x in range(1, isqrt(n)):\n        if n\u00a0% x == 0:\n            factors1.append(x)\n            factors2.append(n // x)\n    x += 1\n    if x * x == n:\n        factors1.append(x)\n    factors1.extend(reversed(factors2))\n    return factors1\n\nfor i in 45, 53, 64:\n    print(\"%i: factors: %s\"\u00a0% (i, factor(i)))45: factors: [1, 3, 5, 9, 15, 45]\n53: factors: [1, 53]\n64: factors: [1, 2, 4, 8, 16, 32, 64]\n\nfrom itertools import chain, cycle, accumulate # last of which is Python 3 only\n\ndef factors(n):\n    def prime_powers(n):\n        # c goes through 2, 3, 5, then the infinite (6n+1, 6n+5) series\n        for c in accumulate(chain([2, 1, 2], cycle([2,4]))):\n            if c*c > n: break\n            if n%c: continue\n            d,p = (), c\n            while not n%c:\n                n,p,d = n//c, p*c, d + (p,)\n            yield(d)\n        if n > 1: yield((n,))\n\n    r = [1]\n    for e in prime_powers(n):\n        r += [a*b for a in r for b in e]\n    return r\n", "explain": "Naive and slow but simplest (check all numbers from 1 to n):\nSlightly better (realize that there are no factors between n/2 and n):\nMuch better (realize that factors come in pairs, the smaller of which is no bigger than sqrt(n)):\nMore efficient when factoring many numbers:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    int *list;\n    short count; \n} Factors;\n\nvoid xferFactors( Factors *fctrs, int *flist, int flix ) \n{\n    int ix, ij;\n    int newSize = fctrs->count + flix;\n    if (newSize > flix)  {\n        fctrs->list = realloc( fctrs->list, newSize * sizeof(int));\n    }\n    else {\n        fctrs->list = malloc(  newSize * sizeof(int));\n    }\n    for (ij=0,ix=fctrs->count; ix<newSize; ij++,ix++) {\n        fctrs->list[ix] = flist[ij];\n    }\n    fctrs->count = newSize;\n}\n\nFactors *factor( int num, Factors *fctrs)\n{\n    int flist[301], flix;\n    int dvsr;\n    flix = 0;\n    fctrs->count = 0;\n    free(fctrs->list);\n    fctrs->list = NULL;\n    for (dvsr=1; dvsr*dvsr < num; dvsr++) {\n        if (num % dvsr != 0) continue;\n        if ( flix == 300) {\n            xferFactors( fctrs, flist, flix );\n            flix = 0;\n        }\n        flist[flix++] = dvsr;\n        flist[flix++] = num/dvsr;\n    }\n    if (dvsr*dvsr == num) \n        flist[flix++] = dvsr;\n    if (flix > 0)\n        xferFactors( fctrs, flist, flix );\n\n    return fctrs;\n}\n        \nint main(int argc, char*argv[])\n{\n    int nums2factor[] = { 2059, 223092870, 3135, 45 };\n    Factors ftors = { NULL, 0};\n    char sep;\n    int i,j;\n\n    for (i=0; i<4; i++) {\n        factor( nums2factor[i], &ftors );\n        printf(\"\\nfactors of %d are:\\n  \", nums2factor[i]);\n        sep = ' ';\n        for (j=0; j<ftors.count; j++) {\n            printf(\"%c %d\", sep, ftors.list[j]);\n            sep = ',';\n        }\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\nPrime factoring[edit]\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n/* 65536 = 2^16, so we can factor all 32 bit ints */\nchar bits[65536];\n\ntypedef unsigned long ulong;\nulong primes[7000], n_primes;\n\ntypedef struct { ulong p, e; } prime_factor; /* prime, exponent */\n\nvoid sieve()\n{\n\tint i, j;\n\tmemset(bits, 1, 65536);\n\tbits[0] = bits[1] = 0;\n\tfor (i = 0; i < 256; i++)\n\t\tif (bits[i])\n\t\t\tfor (j = i * i; j < 65536; j += i)\n\t\t\t\tbits[j] = 0;\n\n\t/* collect primes into a list. slightly faster this way if dealing with large numbers */\n\tfor (i = j = 0; i < 65536; i++)\n\t\tif (bits[i]) primes[j++] = i;\n\n\tn_primes = j;\n}\n\nint get_prime_factors(ulong n, prime_factor *lst)\n{\n\tulong i, e, p;\n\tint len = 0;\n\n\tfor (i = 0; i < n_primes; i++) {\n\t\tp = primes[i];\n\t\tif (p * p > n) break;\n\t\tfor (e = 0; !(n % p); n /= p, e++);\n\t\tif (e) {\n\t\t\tlst[len].p = p;\n\t\t\tlst[len++].e = e;\n\t\t}\n\t}\n\n\treturn n == 1 ? len : (lst[len].p = n, lst[len].e = 1, ++len);\n}\n\nint ulong_cmp(const void *a, const void *b)\n{\n\treturn *(const ulong*)a < *(const ulong*)b ? -1 : *(const ulong*)a > *(const ulong*)b;\n}\n\nint get_factors(ulong n, ulong *lst)\n{\n\tint n_f, len, len2, i, j, k, p;\n\tprime_factor f[100];\n\n\tn_f = get_prime_factors(n, f);\n\n\tlen2 = len = lst[0] = 1;\n\t/* L = (1); L = (L, L * p**(1 .. e)) forall((p, e)) */\n\tfor (i = 0; i < n_f; i++, len2 = len)\n\t\tfor (j = 0, p = f[i].p; j < f[i].e; j++, p *= f[i].p)\n\t\t\tfor (k = 0; k < len2; k++)\n\t\t\t\tlst[len++] = lst[k] * p;\n\n\tqsort(lst, len, sizeof(ulong), ulong_cmp);\n\treturn len;\n}\n\nint main()\n{\n\tulong fac[10000];\n\tint len, i, j;\n\tulong nums[] = {3, 120, 1024, 2UL*2*2*2*3*3*3*5*5*7*11*13*17*19 };\n\n\tsieve();\n\n\tfor (i = 0; i < 4; i++) {\n\t\tlen = get_factors(nums[i], fac);\n\t\tprintf(\"%lu:\", nums[i]);\n\t\tfor (j = 0; j < len; j++)\n\t\t\tprintf(\" %lu\", fac[j]);\n\t\tprintf(\"\\n\");\n\t}\n\n\treturn 0;\n}\n\n\nOutput:\n3: 1 3\n120: 1 2 3 4 5 6 8 10 12 15 20 24 30 40 60 120\n1024: 1 2 4 8 16 32 64 128 256 512 1024\n3491888400: 1 2 3 4 5 6 7 8 9 10 11 ...(>1900 numbers)... 1163962800 1745944200 3491888400\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "C++", "code": "\n#include <iostream>\n#include <iomanip>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n\nstd::vector<int> GenerateFactors(int n) {\n    std::vector<int> factors = { 1, n };\n    for (int i = 2; i * i <= n; ++i) {\n        if (n % i == 0) {\n            factors.push_back(i);\n            if (i * i != n)\n                factors.push_back(n / i);\n        }\n    }\n\n    std::sort(factors.begin(), factors.end());\n    return factors;\n}\n\nint main() {\n    const int SampleNumbers[] = { 3135, 45, 60, 81 };\n\n    for (size_t i = 0; i < sizeof(SampleNumbers) / sizeof(int); ++i) {\n        std::vector<int> factors = GenerateFactors(SampleNumbers[i]);\n        std::cout << \"Factors of \";\n        std::cout.width(4);\n        std::cout << SampleNumbers[i] << \" are: \";\n        std::copy(factors.begin(), factors.end(), std::ostream_iterator<int>(std::cout, \" \"));\n        std::cout << std::endl;\n    }\n\n    return EXIT_SUCCESS;\n}\n\n\nOutput:\nFactors of 3135 are: 1 3 5 11 15 19 33 55 57 95 165 209 285 627 1045 3135 \nFactors of   45 are: 1 3 5 9 15 45 \nFactors of   60 are: 1 2 3 4 5 6 10 12 15 20 30 60 \nFactors of   81 are: 1 3 9 27 81 \n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Java", "code": "\nWorks with: Java version 5+\npublic static TreeSet<Long> factors(long n)\n{\n TreeSet<Long> factors = new TreeSet<Long>();\n factors.add(n);\n factors.add(1L);\n for(long test = n - 1; test >= Math.sqrt(n); test--)\n  if(n % test == 0)\n  {\n   factors.add(test);\n   factors.add(n / test);\n  }\n return factors;\n}\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "C#", "code": "\nC# 1.0[edit]\nstatic void Main (string[] args) {\n    do {\n        Console.WriteLine (\"Number:\");\n        Int64 p = 0;\n        do {\n            try {\n                p = Convert.ToInt64 (Console.ReadLine ());\n                break;\n            } catch (Exception) { }\n\n        } while (true);\n\n        Console.WriteLine (\"For 1 through \" + ((int) Math.Sqrt (p)).ToString () + \"\");\n        for (int x = 1; x <= (int) Math.Sqrt (p); x++) {\n            if (p % x == 0)\n                Console.WriteLine (\"Found: \" + x.ToString () + \". \" + p.ToString () + \" / \" + x.ToString () + \" = \" + (p / x).ToString ());\n        }\n\n        Console.WriteLine (\"Done.\");\n    } while (true);\n}\n\n\nOutput:\nNumber:\n32434243\nFor 1 through 5695\nFound: 1. 32434243 / 1 = 32434243\nFound: 307. 32434243 / 307 = 105649\nDone.\nC# 3.0[edit]\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\npublic static class Extension {\n    public static List<int> Factors (this int me) {\n        return Enumerable.Range (1, me).Where (x => me % x == 0).ToList ();\n    }\n}\n\nclass Program {\n    static void Main (string[] args) {\n        Console.WriteLine (String.Join (\", \", 45. Factors ()));\n    }\n}\n\n\nOutput:\n1, 3, 5, 9, 15, 45\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "JavaScript", "code": "\nImperative[edit]\nfunction factors(num)\n{\n var\n  n_factors = [],\n  i;\n\n for (i = 1; i <= Math.floor(Math.sqrt(num)); i += 1)\n  if (num % i === 0)\n  {\n   n_factors.push(i);\n   if (num / i !== i)\n    n_factors.push(num / i);\n  }\n n_factors.sort(function(a, b){return a - b;});  // numeric sort\n return n_factors;\n}\n\nfactors(45);  // [1,3,5,9,15,45] \nfactors(53);  // [1,53] \nfactors(64);  // [1,2,4,8,16,32,64]\n\nFunctional[edit]\nES5[edit]\n\n// Monadic bind (chain) for lists\nfunction chain(xs, f) {\n  return [].concat.apply([], xs.map(f));\n}\n\n// [m..n]\nfunction range(m, n) {\n  return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n    return m + i;\n  });\n}\n\nfunction factors_naive(n) {\n  return chain( range(1, n), function (x) {       // monadic chain/bind\n    return n\u00a0% x\u00a0? []\u00a0: [x];                      // monadic fail or inject/return\n  });\n}\n\nfactors_naive(6)\n\n[1, 2, 3, 6]\n\nconsole.log(\n  (function (lstTest) {\n\n    // INTEGER FACTORS\n    function integerFactors(n) {\n      var rRoot = Math.sqrt(n),\n        intRoot = Math.floor(rRoot),\n\n        lows = range(1, intRoot).filter(function (x) {\n          return (n\u00a0% x) === 0;\n        });\n\n      // for perfect squares, we can drop the head of the 'highs' list\n      return lows.concat(lows.map(function (x) {\n        return n / x;\n      }).reverse().slice((rRoot === intRoot) | 0));\n    }\n\n    // [m .. n]\n    function range(m, n) {\n      return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n        return m + i;\n      });\n    }\n\n    /*************************** TESTING *****************************/\n\n    // TABULATION OF RESULTS IN SPACED AND ALIGNED COLUMNS\n    function alignedTable(lstRows, lngPad, fnAligned) {\n      var lstColWidths = range(0, lstRows.reduce(function (a, x) {\n        return x.length > a\u00a0? x.length\u00a0: a;\n      }, 0) - 1).map(function (iCol) {\n        return lstRows.reduce(function (a, lst) {\n          var w = lst[iCol]\u00a0? lst[iCol].toString().length\u00a0: 0;\n          return (w > a)\u00a0? w\u00a0: a;\n        }, 0);\n      });\n\n      return lstRows.map(function (lstRow) {\n        return lstRow.map(function (v, i) {\n          return fnAligned(v, lstColWidths[i] + lngPad);\n        }).join('')\n      }).join('\\n');\n    }\n\n    function alignRight(n, lngWidth) {\n      var s = n.toString();\n      return Array(lngWidth - s.length + 1).join(' ') + s;\n    }\n\n    // TEST\n    return '\\nintegerFactors(n)\\n\\n' + alignedTable(\n      lstTest.map(integerFactors).map(function (x, i) {\n        return [lstTest[i], '-->'].concat(x);\n      }), 2, alignRight\n    ) + '\\n';\n\n  })([25, 45, 53, 64, 100, 102, 120, 12345, 32766, 32767])\n);\n\nintegerFactors(n)\n\n     25  -->  1   5  25\n     45  -->  1   3   5    9   15    45\n     53  -->  1  53\n     64  -->  1   2   4    8   16    32    64\n    100  -->  1   2   4    5   10    20    25     50  100\n    102  -->  1   2   3    6   17    34    51    102\n    120  -->  1   2   3    4    5     6     8     10   12   15   20   24    30     40     60    120\n  12345  -->  1   3   5   15  823  2469  4115  12345\n  32766  -->  1   2   3    6   43    86   127    129  254  258  381  762  5461  10922  16383  32766\n  32767  -->  1   7  31  151  217  1057  4681  32767\n\nES6[edit]\n(function (lstTest) {\n    'use strict';\n\n    // INTEGER FACTORS\n\n    // integerFactors\u00a0:: Int -> [Int]\n    let integerFactors = (n) => {\n            let rRoot = Math.sqrt(n),\n                intRoot = Math.floor(rRoot),\n\n                lows = range(1, intRoot)\n                .filter(x => (n\u00a0% x) === 0);\n\n            // for perfect squares, we can drop \n            // the head of the 'highs' list\n            return lows.concat(lows\n                .map(x => n / x)\n                .reverse()\n                .slice((rRoot === intRoot) | 0)\n            );\n        },\n\n        // range\u00a0:: Int -> Int -> [Int]\n        range = (m, n) => Array.from({\n            length: (n - m) + 1\n        }, (_, i) => m + i);\n\n\n\n\n\n    /*************************** TESTING *****************************/\n\n    // TABULATION OF RESULTS IN SPACED AND ALIGNED COLUMNS\n    let alignedTable = (lstRows, lngPad, fnAligned) => {\n            var lstColWidths = range(\n                    0, lstRows\n                    .reduce(\n                        (a, x) => (x.length > a\u00a0? x.length\u00a0: a),\n                        0\n                    ) - 1\n                )\n                .map((iCol) => lstRows\n                    .reduce((a, lst) => {\n                        let w = lst[iCol]\u00a0? lst[iCol].toString()\n                            .length\u00a0: 0;\n                        return (w > a)\u00a0? w\u00a0: a;\n                    }, 0));\n\n            return lstRows.map((lstRow) =>\n                    lstRow.map((v, i) => fnAligned(\n                        v, lstColWidths[i] + lngPad\n                    ))\n                    .join('')\n                )\n                .join('\\n');\n        },\n\n        alignRight = (n, lngWidth) => {\n            let s = n.toString();\n            return Array(lngWidth - s.length + 1)\n                .join(' ') + s;\n        };\n\n    // TEST\n    return '\\nintegerFactors(n)\\n\\n' + alignedTable(lstTest\n        .map(integerFactors)\n        .map(\n            (x, i) => [lstTest[i], '-->'].concat(x)\n        ), 2, alignRight\n    ) + '\\n';\n\n})([25, 45, 53, 64, 100, 102, 120, 12345, 32766, 32767]);\n\nOutput:\nintegerFactors(n)\n\n     25  -->  1   5  25\n     45  -->  1   3   5    9   15    45\n     53  -->  1  53\n     64  -->  1   2   4    8   16    32    64\n    100  -->  1   2   4    5   10    20    25     50  100\n    102  -->  1   2   3    6   17    34    51    102\n    120  -->  1   2   3    4    5     6     8     10   12   15   20   24    30     40     60    120\n  12345  -->  1   3   5   15  823  2469  4115  12345\n  32766  -->  1   2   3    6   43    86   127    129  254  258  381  762  5461  10922  16383  32766\n  32767  -->  1   7  31  151  217  1057  4681  32767\n\n", "explain": "Translating the naive list comprehension  example from Haskell, using a list monad for the comprehension\nOutput:\nTranslating the Haskell (lows and highs) example\nOutput:\n\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "PHP", "code": "\nfunction GetFactors($n){\n   $factors = array(1, $n);\n   for($i = 2; $i * $i <= $n; $i++){\n      if($n\u00a0% $i == 0){\n         $factors[] = $i;\n         if($i * $i\u00a0!= $n)\n            $factors[] = $n/$i;\n      }\n   }\n   sort($factors);\n   return $factors;\n}\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram Factors\n  implicit none\n  integer :: i, number\n  \n  write(*,*) \"Enter a number between 1 and 2147483647\"\n  read*, number\n\n  do i = 1, int(sqrt(real(number))) - 1\n    if (mod(number, i) == 0) write (*,*) i, number/i\n  end do\n  \n  ! Check to see if number is a square\n  i = int(sqrt(real(number))) \n  if (i*i == number) then\n     write (*,*) i\n  else if (mod(number, i) == 0) then\n     write (*,*) i, number/i\n  end if\n    \nend program\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    printFactors(-1)\n    printFactors(0)\n    printFactors(1)\n    printFactors(2)\n    printFactors(3)\n    printFactors(53)\n    printFactors(45)\n    printFactors(64)\n    printFactors(600851475143)\n    printFactors(999999999999999989)\n}\n\nfunc printFactors(nr int64) {\n    if nr < 1 {\n        fmt.Println(\"\\nFactors of\", nr, \"not computed\")\n        return\n    }\n    fmt.Printf(\"\\nFactors of %d: \", nr)\n    fs := make([]int64, 1)\n    fs[0] = 1\n    apf := func(p int64, e int) {\n        n := len(fs)\n        for i, pp := 0, p; i < e; i, pp = i+1, pp*p {\n            for j := 0; j < n; j++ {\n                fs = append(fs, fs[j]*pp)\n            }\n        }\n    }\n    e := 0\n    for ; nr & 1 == 0; e++ {\n        nr >>= 1\n    }\n    apf(2, e)\n    for d := int64(3); nr > 1; d += 2 {\n        if d*d > nr {\n            d = nr\n        }\n        for e = 0; nr%d == 0; e++ {\n            nr /= d\n        }\n        if e > 0 {\n            apf(d, e)\n        }\n    }\n    fmt.Println(fs)\n    fmt.Println(\"Number of factors =\", len(fs))\n}\n\n\nOutput:\nFactors of -1 not computed\n\nFactors of 0 not computed\n\nFactors of 1: [1]\nNumber of factors = 1\n\nFactors of 2: [1 2]\nNumber of factors = 2\n\nFactors of 3: [1 3]\nNumber of factors = 2\n\nFactors of 53: [1 53]\nNumber of factors = 2\n\nFactors of 45: [1 3 9 5 15 45]\nNumber of factors = 6\n\nFactors of 64: [1 2 4 8 16 32 64]\nNumber of factors = 7\n\nFactors of 600851475143: [1 71 839 59569 1471 104441 1234169 87625999 6857 486847 5753023 408464633 10086647 716151937 8462696833 600851475143]\nNumber of factors = 16\n\nFactors of 999999999999999989: [1 999999999999999989]\nNumber of factors = 2\n", "explain": "Trial division, no prime number generator, but with some optimizations.  It's good enough to factor any 64 bit integer, with large primes taking several seconds.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program factorst.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/* Initialized data */\n.data\nszMessDeb: .ascii \"Factors of\u00a0:\"\nsMessValeur:   .fill 12, 1, ' '\n                   .asciz \"are\u00a0: \\n\"\nsMessFactor:   .fill 12, 1, ' '\n                   .asciz \"\\n\"\nszCarriageReturn:  .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* saves 2 registers */\n \n    mov r0,#100\n    bl factors\n    mov r0,#97\n    bl factors\n    ldr r0,iNumber\n    bl factors\n\n    \n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\n\niNumber: .int 32767\niAdrszCarriageReturn:  .int  szCarriageReturn\n/******************************************************************/\n/*     calcul factors of number                                  */ \n/******************************************************************/\n/* r0 contains the number */\nfactors:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r1-r6}    \t\t/* save others registers */\n    mov r5,r0    @ limit calcul\n    ldr r1,iAdrsMessValeur   @ conversion register in decimal string\n    bl conversion10S\n    ldr r0,iAdrszMessDeb     @ display message\n    bl affichageMess\n    mov r6,#1    @ counter loop\n1:   @ loop \n    mov r0,r5    @ dividende\n    mov r1,r6    @ divisor\n    bl division\n    cmp r3,#0    @ remainder = zero\u00a0?\n    bne 2f\n    @ display result if yes\n    mov r0,r6\n    ldr r1,iAdrsMessFactor\n    bl conversion10S\n    ldr r0,iAdrsMessFactor\n    bl affichageMess\n2:\n    add r6,#1      @ add 1 to loop counter\n    cmp r6,r5      @ <=  number\u00a0?\n    ble 1b        @ yes loop\n100:\n    pop {r1-r6}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\niAdrsMessValeur: .int sMessValeur\niAdrszMessDeb: .int szMessDeb\niAdrsMessFactor: .int sMessFactor\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n/*=============================================*/\n/* division integer unsigned                */\n/*============================================*/\ndivision:\n    /* r0 contains N */\n    /* r1 contains D */\n    /* r2 contains Q */\n    /* r3 contains R */\n    push {r4, lr}\n    mov r2, #0                 /* r2\u00a0? 0 */\n    mov r3, #0                 /* r3\u00a0? 0 */\n    mov r4, #32                /* r4\u00a0? 32 */\n    b 2f\n1:\n    movs r0, r0, LSL #1    /* r0\u00a0? r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1) */\n    adc r3, r3, r3         /* r3\u00a0? r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C */\n \n    cmp r3, r1             /* compute r3 - r1 and update cpsr */\n    subhs r3, r3, r1       /* if r3 >= r1 (C=1) then r3\u00a0? r3 - r1 */\n    adc r2, r2, r2         /* r2\u00a0? r2 + r2 + C. This is equivalent to r2\u00a0? (r2 << 1) + C */\n2:\n    subs r4, r4, #1        /* r4\u00a0? r4 - 1 */\n    bpl 1b            /* if r4 >= 0 (N=0) then branch to .Lloop1 */\n \n    pop {r4, lr}\n    bx lr\t\n\n/***************************************************/\n/*   conversion register in string d\u00e9cimal signed  */\n/***************************************************/\n/* r0 contains the register   */\n/* r1 contains address of conversion area */\nconversion10S:\n    push {fp,lr}    /* save registers frame and return */\n    push {r0-r5}   /* save other registers  */\n    mov r2,r1       /* early storage area */\n    mov r5,#'+'     /* default sign is + */\n    cmp r0,#0       /* n\u00e9gatif number\u00a0? */\n    movlt r5,#'-'     /* yes sign is - */\n    mvnlt r0,r0       /* and inverse in positive value */\n    addlt r0,#1\n    mov r4,#10   /* area length */\n1: /* conversion loop */\n    bl divisionpar10 /* division  */\n    add r1,#48        /* add 48 at remainder for conversion ascii */\t\n    strb r1,[r2,r4]  /* store byte area r5 + position r4 */\n    sub r4,r4,#1      /* previous position */\n    cmp r0,#0     \n    bne 1b\t       /* loop if quotient not equal z\u00e9ro */\n    strb r5,[r2,r4]  /* store sign at current position  */\n    subs r4,r4,#1   /* previous position */\n    blt  100f         /* if r4 < 0  end  */\n    /* else complete area with space */\n    mov r3,#' '   /* character space */\t\n2:\n    strb r3,[r2,r4]  /* store  byte  */\n    subs r4,r4,#1   /* previous position */\n    bge 2b        /* loop if r4 greather or equal zero */\n100:  /*  standard end of function  */\n    pop {r0-r5}   /*restaur others registers */\n    pop {fp,lr}   /* restaur des  2 registers frame et return  */\n    bx lr   \n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 contient le dividende   */\n/* r0 retourne le quotient */\t\n/* r1 retourne le reste  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n   push {r2-r4}   /* save autres registres  */\n   mov r4,r0 \n   ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n   smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n   mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n   mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n   add r0, r2, r1         /* r0 <- r2 + r1 */\n   add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n   sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n   pop {r2-r4}\n   bx lr                  /* leave function */\n   .align 4\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "X86_Assembly", "code": "\nWorks with: nasm\nsection .bss \n    factorArr resd 250 ;big buffer against seg fault\n    \nsection .text\nglobal _main\n_main:\n    mov ebp, esp; for correct debugging\n    mov eax, 0x7ffffffe ;number of which we want to know the factors, max num this program works with\n    mov ebx, eax ;save eax\n    mov ecx, 1 ;n, factor we test for\n    mov [factorArr], dword 0\n    looping:\n        mov eax, ebx ;restore eax\n        xor edx, edx ;clear edx\n        div ecx\n        cmp edx, 0 ;test if our number\u00a0% n == 0\n        jne next\n        mov edx, [factorArr] ;if yes, we increment the size of the array and append n\n        inc edx\n        mov [factorArr+edx*4], ecx ;appending n\n        mov [factorArr], edx ;storing the new size\n    next:\n        mov eax, ecx\n        cmp eax, ebx ;is n bigger then our number\u00a0?\n        jg end ;if yes we end\n        inc ecx\n        jmp looping\n    end:\n        mov ecx, factorArr ;pass arr address by ecx  \n        xor eax, eax ;clear eax\n        mov esp, ebp ;garbage collecting\n        ret\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Delphi", "code": "\n\n", "explain": "See #Pascal.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Ruby", "code": "\nclass Integer\n  def factors() (1..self).select { |n| (self\u00a0% n).zero? } end\nend\np 45.factors\n[1, 3, 5, 9, 15, 45]\n\n\nclass Integer\n  def factors\n    1.upto(Integer.sqrt(self)).select {|i| (self\u00a0% i).zero?}.inject([]) do |f, i| \n      f << self/i unless i == self/i\n      f << i\n    end.sort\n  end\nend\n[45, 53, 64].each {|n| puts \"#{n}\u00a0: #{n.factors}\"}\n\nOutput:\n45\u00a0: [1, 3, 5, 9, 15, 45]\n53\u00a0: [1, 53]\n64\u00a0: [1, 2, 4, 8, 16, 32, 64]\nUsing the prime library[edit]\nrequire 'prime'\n\ndef factors m\n  return [1] if 1==m\n  primes, powers = Prime.prime_division(m).transpose\n  ranges = powers.map{|n| (0..n).to_a}\n  ranges[0].product( *ranges[1..-1] ).\n  map{|es| primes.zip(es).map{|p,e| p**e}.reduce\u00a0:*}.\n  sort\nend\n\n[1, 7, 45, 100].each{|n| p factors n}\n\n[1]\n[1, 7]\n[1, 3, 5, 9, 15, 45]\n[1, 2, 4, 5, 10, 20, 25, 50, 100]\n\n", "explain": "As we only have to loop up to \n\n\n\n\nn\n\n\n\n{\\displaystyle \\sqrt{n}}\n\n, we can write\nOutput:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Rust", "code": "\nfn main() {\n    assert_eq!(vec![1, 2, 4, 5, 10, 10, 20, 25, 50, 100], factor(100)); // asserts that two expressions are equal to each other\n    assert_eq!(vec![1, 101], factor(101));\n\n}\n\nfn factor(num: i32) -> Vec<i32> {\n    let mut factors: Vec<i32> = Vec::new(); // creates a new vector for the factors of the number\n\n    for i in 1..((num as f32).sqrt() as i32 + 1) { \n        if num\u00a0% i == 0 {\n            factors.push(i); // pushes smallest factor to factors\n            factors.push(num/i); // pushes largest factor to factors\n        }\n    }\n    factors.sort(); // sorts the factors into numerical order for viewing purposes\n    factors // returns the factors\n}\n\nfn factor(n: i32) -> Vec<i32> {\n    (1..=n).filter(|i| n\u00a0% i == 0).collect()\n}\n", "explain": "Alternative functional version:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Swift", "code": "\n\nfunc factors(n: Int) -> [Int] {\n    \n    return filter(1...n) { n\u00a0% $0 == 0 }\n}\n\nimport func Darwin.sqrt\n\nfunc sqrt(x:Int) -> Int { return Int(sqrt(Double(x))) }\n\nfunc factors(n: Int) -> [Int] {\n    \n    var result = [Int]()\n    \n    for factor in filter (1...sqrt(n), { n\u00a0% $0 == 0 }) {\n        \n        result.append(factor)\n\n        if n/factor\u00a0!= factor { result.append(n/factor) }\n    }\n    \n    return sorted(result)\n    \n}\n\nprintln(factors(4))\nprintln(factors(1))\nprintln(factors(25))\nprintln(factors(63))\nprintln(factors(19))\nprintln(factors(768))\n\nOutput:\n[1, 2, 4]\n[1]\n[1, 5, 25]\n[1, 3, 7, 9, 21, 63]\n[1, 19]\n[1, 2, 3, 4, 6, 8, 12, 16, 24, 32, 48, 64, 96, 128, 192, 256, 384, 768]\n\n", "explain": "Simple implementation:\nMore efficient implementation:\nCall:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "R", "code": "\nArray solution[edit]\nfactors <- function(n)\n{\n   if(length(n) > 1) \n   {\n      lapply(as.list(n), factors)\n   } else\n   {\n      one.to.n <- seq_len(n)\n      one.to.n[(n\u00a0%% one.to.n) == 0]\n   }\n}\n\nOutput:\n>factors(60)\n[1]  1  2  3  4  5  6 10 12 15 20 30 60\n>factors(c(45, 53, 64))\n[[1]]\n[1]  1  3  5  9 15 45\n[[2]]\n[1]  1 53\n[[3]]\n[1]  1  2  4  8 16 32 64\n\nFilter solution[edit]\n\nfactors <- function(n) c(Filter(function(x) n\u00a0%% x == 0, seq_len(n\u00a0%/% 2)), n)\n#Vectorize is an interesting alternative to the previous solution's lapply.\nmanyFactors <- function(vec) Vectorize(factors)(vec)\n", "explain": "With identical output, a more idiomatic way is to use R's Filter.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. FACTORS.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  CALCULATING.\n           03  NUM  USAGE BINARY-LONG VALUE ZERO.\n           03  LIM  USAGE BINARY-LONG VALUE ZERO.\n           03  CNT  USAGE BINARY-LONG VALUE ZERO.\n           03  DIV  USAGE BINARY-LONG VALUE ZERO.\n           03  REM  USAGE BINARY-LONG VALUE ZERO.\n           03  ZRS  USAGE BINARY-SHORT VALUE ZERO.\n\n       01  DISPLAYING.\n           03  DIS  PIC 9(10) USAGE DISPLAY.\n\n       PROCEDURE DIVISION.\n       MAIN-PROCEDURE.\n           DISPLAY \"Factors of? \" WITH NO ADVANCING\n           ACCEPT NUM\n           DIVIDE NUM BY 2 GIVING LIM.\n\n           PERFORM VARYING CNT FROM 1 BY 1 UNTIL CNT > LIM\n               DIVIDE NUM BY CNT GIVING DIV REMAINDER REM\n               IF REM = 0\n                   MOVE CNT TO DIS\n                   PERFORM SHODIS\n               END-IF\n           END-PERFORM.\n\n           MOVE NUM TO DIS.\n           PERFORM SHODIS.\n           STOP RUN.\n\n       SHODIS.\n           MOVE ZERO TO ZRS.\n           INSPECT DIS TALLYING ZRS FOR LEADING ZERO.\n           DISPLAY DIS(ZRS + 1:)\n           EXIT PARAGRAPH.\n\n       END PROGRAM FACTORS.\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Ada", "code": "\nwith Ada.Text_IO;\nwith Ada.Command_Line;\nprocedure Factors is\n   Number  : Positive;\n   Test_Nr : Positive := 1;\nbegin\n   if Ada.Command_Line.Argument_Count /= 1 then\n      Ada.Text_IO.Put (Ada.Text_IO.Standard_Error, \"Missing argument!\");\n      Ada.Command_Line.Set_Exit_Status (Ada.Command_Line.Failure);\n      return;\n   end if;\n   Number := Positive'Value (Ada.Command_Line.Argument (1));\n   Ada.Text_IO.Put (\"Factors of\" & Positive'Image (Number) & \": \");\n   loop\n      if Number mod Test_Nr = 0 then\n         Ada.Text_IO.Put (Positive'Image (Test_Nr) & \",\");\n      end if;\n      exit when Test_Nr ** 2 >= Number;\n      Test_Nr := Test_Nr + 1;\n   end loop;\n   Ada.Text_IO.Put_Line (Positive'Image (Number) & \".\");\nend Factors;\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Julia", "code": "\nusing Primes\n\n\"\"\" Return the factors of n, including 1, n \"\"\"\nfunction factors(n::T)::Vector{T} where T <: Integer\n  sort(vec(map(prod, Iterators.product((p.^(0:m) for (p, m) in eachfactor(n))...))))\nend\n\nconst examples = [28, 45, 53, 64, 6435789435768]\n\nfor n in examples\n    @time println(\"The factors of $n are: $(factors(n))\")\nend\n\nOutput:\nThe factors of 28 are: [1, 2, 4, 7, 14, 28]\n  0.330684 seconds (784.75 k allocations: 39.104 MiB, 3.17% gc time)\nThe factors of 45 are: [1, 3, 5, 9, 15, 45]\n  0.000117 seconds (56 allocations: 2.672 KiB)\nThe factors of 53 are: [1, 53]\n  0.000102 seconds (35 allocations: 1.516 KiB)\n\n\nThe factors of 64 are: [1, 2, 4, 8, 16, 32, 64]\n  0.000093 seconds (56 allocations: 3.172 KiB)\nThe factors of 6435789435768 are: [1, 2, 3, 4, 6, 7, 8, 11, 12, 14, 21, 22, 24, 28, \n33, 42, 44, 56, 66, 77, 84, 88, 132, 154, 168, 191, 231, 264, 308, 382, 462, 573, \n616, 764, 924, 1146, 1337, 1528, 1848, 2101, 2292, 2674, 4011, 4202, 4584, 5348, \n6303, 8022, 8404, 10696, 12606, 14707, 16044, 16808, 25212, 29414, 32088, 44121, \n50424, 58828, 88242, 117656, 176484, 352968, 18233351, 36466702, 54700053, 72933404, \n109400106, 127633457, 145866808, 200566861, 218800212, 255266914, 382900371, \n401133722, 437600424, 510533828, 601700583, 765800742, 802267444, 1021067656, \n1203401166, 1403968027, 1531601484, 1604534888, 2406802332, 2807936054, 3063202968, \n3482570041, 4211904081, 4813604664, 5615872108, 6965140082, 8423808162, 10447710123, \n11231744216, 13930280164, 16847616324, 20895420246, 24377990287, 27860560328, \n33695232648, 38308270451, 41790840492, 48755980574, 73133970861, 76616540902, \n83581680984, 97511961148, 114924811353, 146267941722, 153233081804, 195023922296, \n229849622706, 268157893157, 292535883444, 306466163608, 459699245412, 536315786314, \n585071766888, 804473679471, 919398490824, 1072631572628, 1608947358942, 2145263145256, \n3217894717884, 6435789435768]\n  0.000249 seconds (451 allocations: 24.813 KiB)\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Kotlin", "code": "\nfun printFactors(n: Int) {\n    if (n < 1) return\n    print(\"$n => \")\n    (1..n / 2)\n        .filter { n\u00a0% it == 0 }\n        .forEach { print(\"$it \") }\n    println(n)\n}\n\nfun main(args: Array<String>) {\n    val numbers = intArrayOf(11, 21, 32, 45, 67, 96)\n    for (number in numbers) printFactors(number)\n}\n\nOutput:\n11 => 1 11\n21 => 1 3 7 21\n32 => 1 2 4 8 16 32\n45 => 1 3 5 9 15 45\n67 => 1 67\n96 => 1 2 3 4 6 8 12 16 24 32 48 96\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Perl", "code": "\nsub factors\n{\n        my($n) = @_;\n        return grep { $n\u00a0% $_ == 0 }(1 .. $n);\n}\nprint join ' ',factors(64), \"\\n\";\n\nsub factors {\n  my $n = shift;\n  $n = -$n if $n < 0;\n  my @divisors;\n  for (1 .. int(sqrt($n))) {  # faster and less memory than map/grep\n    push @divisors, $_ unless $n\u00a0% $_;\n  }\n  # Return divisors including top half, without duplicating a square\n  @divisors, map { $_*$_ == $n\u00a0? ()\u00a0: int($n/$_) } reverse @divisors;\n}\nprint join \" \", factors(64), \"\\n\";\n\nLibrary: ntheory\nuse ntheory qw/divisors/;\nprint join \" \", divisors(12345678), \"\\n\";\n# Alternately something like:  fordivisors { say } 12345678;\n", "explain": "Or more intelligently:\nOne could also use a module, e.g.:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Prolog", "code": "\n\nbrute_force_factors( N , Fs )\u00a0:-\n  integer(N) ,\n  N > 0 ,  \n  setof( F , ( between(1,N,F) , N mod F =:= 0 ) , Fs )\n  .\n\nsmart_factors(N,Fs)\u00a0:-\n  integer(N) ,\n  N > 0 ,\n  setof( F , factor(N,F) , Fs )\n  .\n\nfactor(N,F)\u00a0:-\n  L is floor(sqrt(N)) ,\n  between(1,L,X) ,\n  0 =:= N mod X ,\n  ( F = X\u00a0; F is N // X )\n  .\n\nbetween(X,Y,Z)\u00a0:-\n  integer(X) ,\n  integer(Y) ,\n  X =< Z ,\n  between1(X,Y,Z)\n  .\n\nbetween1(X,Y,X)\u00a0:-\n  X =< Y\n  .\nbetween1(X,Y,Z)\u00a0:-\n  X < Y ,\n  X1 is X+1 ,\n  between1(X1,Y,Z)\n  .\n\nOutput:\n?- N=36 ,( brute_force_factors(N,Factors)\u00a0; smart_factors(N,Factors) ).\nN = 36, Factors = [1, 2, 3, 4, 6, 9, 12, 18, 36]\u00a0;\nN = 36, Factors = [1, 2, 3, 4, 6, 9, 12, 18, 36] .\n\n?- N=53,( brute_force_factors(N,Factors)\u00a0; smart_factors(N,Factors) ).\nN = 53, Factors = [1, 53]\u00a0;\nN = 53, Factors = [1, 53] .\n\n?- N=100,( brute_force_factors(N,Factors);smart_factors(N,Factors) ).\nN = 100, Factors = [1, 2, 4, 5, 10, 20, 25, 50, 100]\u00a0;\nN = 100, Factors = [1, 2, 4, 5, 10, 20, 25, 50, 100] .\n\n?- N=144,( brute_force_factors(N,Factors);smart_factors(N,Factors) ).\nN = 144, Factors = [1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 36, 48, 72, 144]\u00a0;\nN = 144, Factors = [1, 2, 3, 4, 6, 8, 9, 12, 16, 18, 24, 36, 48, 72, 144] .\n\n?- N=32765,( brute_force_factors(N,Factors);smart_factors(N,Factors) ).\nN = 32765, Factors = [1, 5, 6553, 32765]\u00a0;\nN = 32765, Factors = [1, 5, 6553, 32765] .\n\n?- N=32766,( brute_force_factors(N,Factors);smart_factors(N,Factors) ).\nN = 32766, Factors = [1, 2, 3, 6, 43, 86, 127, 129, 254, 258, 381, 762, 5461, 10922, 16383, 32766]\u00a0;\nN = 32766, Factors = [1, 2, 3, 6, 43, 86, 127, 129, 254, 258, 381, 762, 5461, 10922, 16383, 32766] .\n\n38\u00a0?- N=32767,( brute_force_factors(N,Factors);smart_factors(N,Factors) ).\nN = 32767, Factors = [1, 7, 31, 151, 217, 1057, 4681, 32767]\u00a0;\nN = 32767, Factors = [1, 7, 31, 151, 217, 1057, 4681, 32767] .\n\n", "explain": "Simple Brute Force Implementation\nA Slightly Smarter Implementation\nNot every Prolog has between/3: you might need this:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Lua", "code": "\nfunction Factors( n ) \n    local f = {}\n    \n    for i = 1, n/2 do\n        if n\u00a0% i == 0 then \n            f[#f+1] = i\n        end\n    end\n    f[#f+1] = n\n    \n    return f\nend\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Scala", "code": "\n\ndef factors(num: Int) = {\n    (1 to num).filter { divisor =>\n      num\u00a0% divisor == 0\n    }\n}\n\ndef factors(num: Int) = {\n    val list = (1 to math.sqrt(num).floor.toInt).filter(num\u00a0% _ == 0)\n    list ++ list.reverse.dropWhile(d => d*d == num).map(num / _)\n}\n", "explain": "Brute force approach:\nBrute force until sqrt(num) is enough, the code above can be edited as follows (Scala 3 enabled)\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Dart", "code": "\nimport 'dart:math';\n\nfactors(n)\n{\n var factorsArr = [];\n factorsArr.add(n);\n factorsArr.add(1);\n for(var test = n - 1; test >= sqrt(n).toInt(); test--)\n  if(n\u00a0% test == 0)\n  {\n   factorsArr.add(test);\n   factorsArr.add(n / test);\n  }\n return factorsArr;\n}\n\nvoid main() {\n  print(factors(5688));\n}\n\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "D", "code": "\nProcedural Style[edit]\nimport std.stdio, std.math, std.algorithm;\n\nT[] factors(T)(in T n) pure nothrow {\n    if (n == 1)\n        return [n];\n\n    T[] res = [1, n];\n    T limit = cast(T)real(n).sqrt + 1;\n    for (T i = 2; i < limit; i++) {\n        if (n % i == 0) {\n            res ~= i;\n            immutable q = n / i;\n            if (q > i)\n                res ~= q;\n        }\n    }\n\n    return res.sort().release;\n}\n\nvoid main() {\n    writefln(\"%(%s\\n%)\", [45, 53, 64, 1111111].map!factors);\n}\n\n\nOutput:\n[1, 3, 5, 9, 15, 45]\n[1, 53]\n[1, 2, 4, 8, 16, 32, 64]\n[1, 239, 4649, 1111111]\nFunctional Style[edit]\nimport std.stdio, std.algorithm, std.range;\n\nauto factors(I)(I n) {\n    return iota(1, n + 1).filter!(i => n % i == 0);\n}\n\nvoid main() {\n    36.factors.writeln;\n}\n\n\nOutput:\n[1, 2, 3, 4, 6, 9, 12, 18, 36]\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Haskell", "code": "\n\nimport HFM.Primes (primePowerFactors)\nimport Control.Monad (mapM)\nimport Data.List (product)\n\n-- primePowerFactors\u00a0:: Integer -> [(Integer,Int)]\n\nfactors = map product .\n          mapM (\\(p,m)-> [p^i | i<-[0..m]]) . primePowerFactors\n\n\n~> factors 42\n[1,7,3,21,2,14,6,42]\n\n\nimport Data.List (group)\nprimePowerFactors = map (\\x-> (head x, length x)) . group . factorize\n\n\nintegerFactors :: Int -> [Int]\nintegerFactors n\n  | 1 > n = []\n  | otherwise = lows <> (quot n <$> part n (reverse lows))\n  where\n    part n\n      | n == square = tail\n      | otherwise = id\n    (square, lows) =\n      (,) . (^ 2)\n        <*> (filter ((0 ==) . rem n) . enumFromTo 1)\n        $ floor (sqrt $ fromIntegral n)\n\nmain :: IO ()\nmain = print $ integerFactors 600\n\n\nOutput:\n[1,2,3,4,5,6,8,10,12,15,20,24,25,30,40,50,60,75,100,120,150,200,300,600]\nList comprehension[edit]\n\nfactorsNaive n =\n  [ i\n  | i <- [1 .. n] \n  , mod n i == 0 ]\n\n~> factorsNaive 25\n[1,5,25]\n\n\nimport Data.List (sort)\n\nfactorsCo n =\n  sort\n    [ i\n    | i <- [1 .. floor (sqrt (fromIntegral n))] \n    , (d, 0) <- [divMod n i] \n    , i <-\n       i :\n       [ d\n       | d > i ] ]\n\n\nfactorsO n =\n  ds ++\n  [ r\n  | (d, 0) <- [divMod n r] \n  , r <-\n     r :\n     [ d\n     | d > r ] ] ++\n  reverse (map (n `div`) ds)\n  where\n    r = floor (sqrt (fromIntegral n))\n    ds =\n      [ i\n      | i <- [1 .. r - 1] \n      , mod n i == 0 ]\n\n\n*Main> :set +s\n~> factorsO 120\n[1,2,3,4,5,6,8,10,12,15,20,24,30,40,60,120]\n(0.00 secs, 0 bytes)\n\n~> factorsO 12041111117\n[1,7,41,287,541,3787,22181,77551,155267,542857,3179591,22257137,41955091,2936856\n37,1720158731,12041111117]\n(0.09 secs, 50758224 bytes)\n\n", "explain": "Using D. Amos'es Primes module for finding prime factors\nReturns list of factors out of order, e.g.:\nOr, prime decomposition task can be used (although, a trial division-only version will become very slow for large primes),\nThe above function can also be found in the package arithmoi, as Math.NumberTheory.Primes.factorise\u00a0:: Integer -> [(Integer, Int)], which performs \"factorisation of Integers by the elliptic curve algorithm after Montgomery\" and \"is best suited for numbers of up to 50-60 digits\".\nOr, deriving cofactors from factors up to the square root:\nNaive, functional, no import, in increasing order:\nFactor, cofactor. Get the list of factor\u2013cofactor pairs sorted, for a quadratic speedup:\nA version of the above without the need for sorting, making it to be online (i.e. productive immediately, which can be seen in GHCi); factors in increasing order:\nTesting:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Scheme", "code": "\n\n(define (factors n)\n  (define (*factors d)\n    (cond ((> d n) (list))\n          ((= (modulo n d) 0) (cons d (*factors (+ d 1))))\n          (else (*factors (+ d 1)))))\n  (*factors 1))\n\n(display (factors 1111111))\n(newline)\n\nOutput:\n (1 239 4649 1111111)\n\n", "explain": "This implementation uses a naive trial division algorithm.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "PowerShell", "code": "\nStraightforward but slow[edit]\nfunction Get-Factor ($a) {\n    1..$a | Where-Object { $a\u00a0% $_ -eq 0 }\n}\n\nA little more clever[edit]\nfunction Get-Factor ($a) {\n    1..[Math]::Sqrt($a) `\n        | Where-Object { $a\u00a0% $_ -eq 0 } `\n        | ForEach-Object { $_; $a / $_ } `\n        | Sort-Object -Unique\n}\n\n", "explain": "This one uses a range of integers up to the target number and just filters it using the Where-Object cmdlet. It's very slow though, so it is not very usable for larger numbers.\nHere the range of integers is only taken up to the square root of the number, the same filtering applies. Afterwards the corresponding larger factors are calculated and sent down the pipeline along with the small ones found earlier.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Logo", "code": "\nto factors :n\n  output filter [equal? 0 modulo :n\u00a0?] iseq 1 :n\nend\n\nshow factors 28      \u00a0; [1 2 4 7 14 28]\n", "explain": ""}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "F#", "code": "\n\nlet factors number = seq {\n    for divisor in 1 .. (float >> sqrt >> int) number do\n    if number % divisor = 0 then\n        yield divisor\n        if number <> 1 then yield number / divisor //special case condition: when number=1 then divisor=(number/divisor), so don't repeat it\n}\n\nPrime factoring[edit]\n[6;120;2048;402642;1206432] |> Seq.iter(fun n->printf \"%d\u00a0:\" n; [1..n]|>Seq.filter(fun g->n%g=0)|>Seq.iter(fun n->printf \" %d\" n); printfn \"\");;\n\n\nOutput:\nOUTPUT\u00a0:\n6\u00a0: 1  2  3  6                                                                                                                                                                  \n120\u00a0: 1  2  3  4  5  6  8  10  12  15  20  24  30  40  60  120                                                                                                                  \n2048\u00a0: 1  2  4  8  16  32  64  128  256  512  1024  2048                                                                                                                        \n402642\u00a0: 1  2  3  6  9  18  22369  44738  67107  134214  201321  402642                                                                                                         \n120643200\u00a0: 1  2  3  4  6  8  9  12  16  18  24  32  36  48  59  71  72  96  118  142  144  177  213  236  284  288  354  426  472  531  568  639  708  852  944  1062  1136  12\n78  1416  1704  1888  2124  2272  2556  2832  3408  4189  4248  5112  5664  6816  8378  8496  10224  12567  16756  16992  20448  25134  33512  37701  50268  67024  75402  10053\n6  134048  150804  201072  301608  402144  603216  1206432\n\n", "explain": "If number\u00a0% divisor = 0 then both divisor AND number / divisor are factors.\nSo, we only have to search till sqrt(number).\nAlso, this is lazily evaluated.\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "Groovy", "code": "\n\ndef factorize = { long target -> \n\n    if (target == 1) return [1L]\n\n    if (target < 4) return [1L, target]\n\n    def targetSqrt = Math.sqrt(target)\n    def lowfactors = (2L..targetSqrt).grep { (target % it) == 0 }\n    if (lowfactors == []) return [1L, target]\n    def nhalf = lowfactors.size() - ((lowfactors[-1] == targetSqrt) ? 1 : 0)\n    \n    [1] + lowfactors + (0..<nhalf).collect { target.intdiv(lowfactors[it]) }.reverse() + [target]\n}\n\n\n((1..30) + [333333]).each { println ([number:it, factors:factorize(it)]) }\n\n\nOutput:\n[number:1, factors:[1]]\n[number:2, factors:[1, 2]]\n[number:3, factors:[1, 3]]\n[number:4, factors:[1, 2, 4]]\n[number:5, factors:[1, 5]]\n[number:6, factors:[1, 2, 3, 6]]\n[number:7, factors:[1, 7]]\n[number:8, factors:[1, 2, 4, 8]]\n[number:9, factors:[1, 3, 9]]\n[number:10, factors:[1, 2, 5, 10]]\n[number:11, factors:[1, 11]]\n[number:12, factors:[1, 2, 3, 4, 6, 12]]\n[number:13, factors:[1, 13]]\n[number:14, factors:[1, 2, 7, 14]]\n[number:15, factors:[1, 3, 5, 15]]\n[number:16, factors:[1, 2, 4, 8, 16]]\n[number:17, factors:[1, 17]]\n[number:18, factors:[1, 2, 3, 6, 9, 18]]\n[number:19, factors:[1, 19]]\n[number:20, factors:[1, 2, 4, 5, 10, 20]]\n[number:21, factors:[1, 3, 7, 21]]\n[number:22, factors:[1, 2, 11, 22]]\n[number:23, factors:[1, 23]]\n[number:24, factors:[1, 2, 3, 4, 6, 8, 12, 24]]\n[number:25, factors:[1, 5, 25]]\n[number:26, factors:[1, 2, 13, 26]]\n[number:27, factors:[1, 3, 9, 27]]\n[number:28, factors:[1, 2, 4, 7, 14, 28]]\n[number:29, factors:[1, 29]]\n[number:30, factors:[1, 2, 3, 5, 6, 10, 15, 30]]\n[number:333333, factors:[1, 3, 7, 9, 11, 13, 21, 33, 37, 39, 63, 77, 91, 99, 111, 117, 143, 231, 259, 273, 333, 407, 429, 481, 693, 777, 819, 1001, 1221, 1287, 1443, 2331, 2849, 3003, 3367, 3663, 4329, 5291, 8547, 9009, 10101, 15873, 25641, 30303, 37037, 47619, 111111, 333333]]\n", "explain": "A straight brute force approach up to the square root of N:\nTest:\n"}, {"task_name": "Factors of an integer", "task_url": "https://rosettacode.org/wiki/Factors_of_an_integer", "task_cat": "Mathematical operations", "lang": "AWK", "code": "\n# syntax: GAWK -f FACTORS_OF_AN_INTEGER.AWK\nBEGIN {\n    print(\"enter a number or C/R to exit\")\n}\n{   if ($0 == \"\") { exit(0) }\n    if ($0 !~ /^[0-9]+$/) {\n      printf(\"invalid: %s\\n\",$0)\n      next\n    }\n    n = $0\n    printf(\"factors of %s:\",n)\n    for (i=1; i<=n; i++) {\n      if (n % i == 0) {\n        printf(\" %d\",i)\n      }\n    }\n    printf(\"\\n\")\n}\n\n\nOutput:\nenter a number or C/R to exit\ninvalid: -1\nfactors of 0:\nfactors of 1: 1\nfactors of 2: 1 2\nfactors of 11: 1 11\nfactors of 64: 1 2 4 8 16 32 64\nfactors of 100: 1 2 4 5 10 20 25 50 100\nfactors of 32766: 1 2 3 6 43 86 127 129 254 258 381 762 5461 10922 16383 32766\nfactors of 32767: 1 7 31 151 217 1057 4681 32767\n\n", "explain": ""}]