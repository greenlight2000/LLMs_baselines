[{"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Python", "code": "\nimport re\n\nstring = \"This is a string\"\n\nif re.search('string$', string):\n    print(\"Ends with string.\")\n\nstring = re.sub(\" a \", \" another \", string)\nprint(string)\n\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "C", "code": "\nWorks with: POSIX\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <sys/types.h>\n#include <regex.h>\n#include <string.h>\n\nint main()\n{\n   regex_t preg;\n   regmatch_t substmatch[1];\n   const char *tp = \"string$\";\n   const char *t1 = \"this is a matching string\";\n   const char *t2 = \"this is not a matching string!\";\n   const char *ss = \"istyfied\";\n   \n   regcomp(&preg, \"string$\", REG_EXTENDED);\n   printf(\"'%s' %smatched with '%s'\\n\", t1,\n                                        (regexec(&preg, t1, 0, NULL, 0)==0) ? \"\" : \"did not \", tp);\n   printf(\"'%s' %smatched with '%s'\\n\", t2,\n                                        (regexec(&preg, t2, 0, NULL, 0)==0) ? \"\" : \"did not \", tp);\n   regfree(&preg);\n   /* change \"a[a-z]+\" into \"istifyed\"?*/\n   regcomp(&preg, \"a[a-z]+\", REG_EXTENDED);\n   if ( regexec(&preg, t1, 1, substmatch, 0) == 0 )\n   {\n      //fprintf(stderr, \"%d, %d\\n\", substmatch[0].rm_so, substmatch[0].rm_eo);\n      char *ns = malloc(substmatch[0].rm_so + 1 + strlen(ss) +\n                        (strlen(t1) - substmatch[0].rm_eo) + 2);\n      memcpy(ns, t1, substmatch[0].rm_so+1);\n      memcpy(&ns[substmatch[0].rm_so], ss, strlen(ss));\n      memcpy(&ns[substmatch[0].rm_so+strlen(ss)], &t1[substmatch[0].rm_eo],\n                strlen(&t1[substmatch[0].rm_eo]));\n      ns[ substmatch[0].rm_so + strlen(ss) +\n          strlen(&t1[substmatch[0].rm_eo]) ] = 0;\n      printf(\"mod string: '%s'\\n\", ns);\n      free(ns); \n   } else {\n      printf(\"the string '%s' is the same: no matching!\\n\", t1);\n   }\n   regfree(&preg);\n   \n   return 0;\n}\n\nAlternative using GLib[edit]\n\nLibrary: GLib\n#include <stdio.h>\n#include <glib.h>\n\nvoid print_regex_match(const GRegex* regex, const char* string) {\n    GMatchInfo* match_info;\n    gboolean match = g_regex_match(regex, string, 0, &match_info);\n    printf(\"  string = '%s': %s\\n\", string, match ? \"yes\" : \"no\");\n    g_match_info_free(match_info);\n}\n\nvoid regex_match_demo() {\n    const char* pattern = \"^[a-z]+$\";\n    GError* error = NULL;\n    GRegex* regex = g_regex_new(pattern, 0, 0, &error);\n    if (regex == NULL) {\n        fprintf(stderr, \"%s\\n\", error->message);\n        g_error_free(error);\n        return;\n    }\n    printf(\"Does the string match the pattern '%s'?\\n\", pattern);\n    print_regex_match(regex, \"test\");\n    print_regex_match(regex, \"Test\");\n    g_regex_unref(regex);\n}\n\nvoid regex_replace_demo() {\n    const char* pattern = \"[0-9]\";\n    const char* input = \"Test2\";\n    const char* replace = \"X\";\n    GError* error = NULL;\n    GRegex* regex = g_regex_new(pattern, 0, 0, &error);\n    if (regex == NULL) {\n        fprintf(stderr, \"%s\\n\", error->message);\n        g_error_free(error);\n        return;\n    }\n    char* result = g_regex_replace_literal(regex, input, -1,\n                                           0, replace, 0, &error);\n    if (result == NULL) {\n        fprintf(stderr, \"%s\\n\", error->message);\n        g_error_free(error);\n    } else {\n        printf(\"Replace pattern '%s' in string '%s' by '%s': '%s'\\n\",\n               pattern, input, replace, result);\n        g_free(result);\n    }\n    g_regex_unref(regex);\n}\n\nint main() {\n    regex_match_demo();\n    regex_replace_demo();\n    return 0;\n}\n\n\nOutput:\nDoes the string match the pattern '^[a-z]+$'?\n  string = 'test': yes\n  string = 'Test': no\nReplace pattern '[0-9]' in string 'Test2' by 'X': 'TestX'\n\n", "explain": "As far as I can see, POSIX defined function for regex matching, but nothing for substitution. So we must do all the hard work by hand. The complex-appearing code could be turned into a function.\nThe task is a bit easier with GLib's Perl-compatible regular expression functionality.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "C++", "code": "\nWorks with: g++ version 4.0.2 (may need to be retested?)\n\n#include <iostream>\n#include <string>\n#include <iterator>\n#include <regex>\n\nint main()\n{\n  std::regex re(\".* string$\");\n  std::string s = \"Hi, I am a string\";\n\n  // match the complete string\n  if (std::regex_match(s, re))\n    std::cout << \"The string matches.\\n\";\n  else\n    std::cout << \"Oops - not found?\\n\";\n\n  // match a substring\n  std::regex re2(\" a.*a\");\n  std::smatch match;\n  if (std::regex_search(s, match, re2))\n  {\n    std::cout << \"Matched \" << match.length()\n              << \" characters starting at \" << match.position() << \".\\n\";\n    std::cout << \"Matched character sequence: \\\"\"\n              << match.str() << \"\\\"\\n\";\n  }\n  else\n  {\n    std::cout << \"Oops - not found?\\n\";\n  }\n\n  // replace a substring\n  std::string dest_string;\n  std::regex_replace(std::back_inserter(dest_string),\n                       s.begin(), s.end(),\n                       re2,\n                       \"'m now a changed\");\n  std::cout << dest_string << std::endl;\n}\n\n", "explain": "Standards earlier than C++11 can make use of Boost's Regex library via boost/regex.hpp\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Java", "code": "\n/* match entire string against a pattern */\nboolean isNumber = \"-1234.567\".matches(\"-?\\\\d+(?:\\\\.\\\\d+)?\");\n\n/* substitute part of string using a pattern */\nString reduceSpaces = \"a  b c   d e  f\".replaceAll(\" +\", \" \");\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n...\n/* group capturing example */\nPattern pattern = Pattern.compile(\"(?:(https?)://)?([^/]+)/(?:([^#]+)(?:#(.+))?)?\");\nMatcher matcher = pattern.matcher(\"https://rosettacode.org/wiki/Regular_expressions#Java\");\nif (matcher.find()) {\n    String protocol = matcher.group(1);\n    String authority = matcher.group(2);\n    String path = matcher.group(3);\n    String fragment = matcher.group(4);\n}\n\n/* split a string using a pattern */\nString[] strings = \"abc\\r\\ndef\\r\\nghi\".split(\"\\r\\n?\");\n\n\nWorks with: Java version 1.4+\n\nString str = \"I am a string\";\nif (str.matches(\".*string\")) { // note: matches() tests if the entire string is a match\n  System.out.println(\"ends with 'string'\");\n}\n\n\nimport java.util.regex.*;\nPattern p = Pattern.compile(\"a*b\");\nMatcher m = p.matcher(str);\nwhile (m.find()) {\n  // use m.group() to extract matches\n}\n\n\nString orig = \"I am the original string\";\nString result = orig.replaceAll(\"original\", \"modified\");\n// result is now \"I am the modified string\"\n\n", "explain": "\nAn alternate demonstration\nTest\nTo match part of a string, or to process matches:\nSubstitute\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "C#", "code": "\nusing System;\nusing System.Text.RegularExpressions;\n\nclass Program {\n    static void Main(string[] args) {\n        string str = \"I am a string\";\n\n        if (new Regex(\"string$\").IsMatch(str)) {\n            Console.WriteLine(\"Ends with string.\");\n        }\n\n        str = new Regex(\" a \").Replace(str, \" another \");\n        Console.WriteLine(str);\n    }\n}\n\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "JavaScript", "code": "\n\nvar subject = \"Hello world!\";\n\n// Two different ways to create the RegExp object\n// Both examples use the exact same pattern... matching \"hello \"\nvar re_PatternToMatch = /Hello (World)/i; // creates a RegExp literal with case-insensitivity\nvar re_PatternToMatch2 = new RegExp(\"Hello (World)\", \"i\");\n\n// Test for a match - return a bool\nvar isMatch = re_PatternToMatch.test(subject);\n\n// Get the match details\n//    Returns an array with the match's details\n//    matches[0] == \"Hello world\"\n//    matches[1] == \"world\"\nvar matches = re_PatternToMatch2.exec(subject);\n\n\nvar subject = \"Hello world!\";\n\n// Perform a string replacement\n//    newSubject == \"Replaced!\"\nvar newSubject = subject.replace(re_PatternToMatch, \"Replaced\");\n\n", "explain": "Test/Match\nSubstitute\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "PHP", "code": "\nWorks with: PHP version 5.2.0\n$string = 'I am a string';\n# Test\nif (preg_match('/string$/', $string))\n{\n    echo \"Ends with 'string'\\n\";\n}\n# Replace\n$string = preg_replace('/\\ba\\b/', 'another', $string);\necho \"Found 'a' and replace it with 'another', resulting in this string: $string\\n\";\n\n\nOutput:\nEnds with 'string'\nFoud 'a' and replaced it with 'another', resulting in this string: I am another string\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Go", "code": "\npackage main\nimport \"fmt\"\nimport \"regexp\"\n\nfunc main() {\n  str := \"I am the original string\"\n\n  // Test\n  matched, _ := regexp.MatchString(\".*string$\", str)\n  if matched { fmt.Println(\"ends with 'string'\") }\n\n  // Substitute\n  pattern := regexp.MustCompile(\"original\")\n  result := pattern.ReplaceAllString(str, \"modified\")\n  fmt.Println(result)\n}\n\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  System.RegularExpressions\n\nprogram Regular_expressions;\n\n{$APPTYPE CONSOLE}\n{$R *.res}\n\nuses\n  System.SysUtils,\n  System.RegularExpressions;\n\nconst\n  CPP_IF = '\\s*if\\s*\\(\\s*(?<COND>.*)\\s*\\)\\s*\\{\\s*return\\s+(?<RETURN>.+);\\s*\\}';\n  PASCAL_IF = 'If ${COND} then result:= ${RETURN};';\n\nvar\n  RegularExpression: TRegEx;\n  str: string;\n\nbegin\n  str := ' if ( a < 0 ) { return -a; }';\n\n  Writeln('Expression: '#10#10, str);\n\n  if RegularExpression.Create(CPP_IF).IsMatch(str) then\n  begin\n    Writeln(#10'   Is a single If in Cpp:'#10);\n\n    Writeln('Translate to Pascal:'#10);\n    str := RegularExpression.Create(CPP_IF).Replace(str, PASCAL_IF);\n    Writeln(str);\n  end;\n  readln;\nend.\n\n\nOutput:\nExpression:\n\n if ( a < 0 ) { return -a; }\n\n   Is a single If in Cpp:\n\nTranslate to Pascal:\n\nIf a < 0  then result:= -a;\n\n", "explain": "Sample program that uses a regex, for translate a line of code in cpp to pascal.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Ruby", "code": "\n\nstr = \"I am a string\"\np \"Ends with 'string'\" if str =~ /string$/\np \"Does not start with 'You'\" unless str =~ /^You/\n\nstr.sub(/ a /, ' another ') #=> \"I am another string\"\n# Or:\nstr[/ a /] = ' another '    #=> \"another\"\nstr                         #=> \"I am another string\"\n\nstr.gsub(/\\bam\\b/) { |match| match.upcase } #=> \"I AM a string\"\n", "explain": "Test\nSubstitute\nSubstitute using block\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Rust", "code": "\n\nuse regex::Regex;\n\nfn main() {\n    let s = \"I am a string\";\n\n    if Regex::new(\"string$\").unwrap().is_match(s) {\n        println!(\"Ends with string.\");\n    }\n\n    println!(\"{}\", Regex::new(\" a \").unwrap().replace(s, \" another \"));\n}\n", "explain": "Note that Regex::new checks for a valid regex and thus returns a Result<Regex, Error>. \n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Swift", "code": "\nRegularExpressionSearch[edit]\n\nimport Foundation\n\nlet str = \"I am a string\"\nif let range = str.rangeOfString(\"string$\", options: .RegularExpressionSearch) {\n  println(\"Ends with 'string'\")\n}\n\nimport Foundation\n\nlet orig = \"I am the original string\"\nlet result = orig.stringByReplacingOccurrencesOfString(\"original\", withString: \"modified\", options: .RegularExpressionSearch)\nprintln(result)\nNSRegularExpression[edit]\n\nimport Foundation\n\nif let regex = NSRegularExpression(pattern: \"string$\", options: nil, error: nil) {\n  let str = \"I am a string\"\n  if let result = regex.firstMatchInString(str, options: nil, range: NSRange(location: 0, length: count(str.utf16))) {\n    println(\"Ends with 'string'\")\n  }\n}\n\n  for x in regex.matchesInString(str, options: nil, range: NSRange(location: 0, length: count(str.utf16))) {\n    let match = x as! NSTextCheckingResult\n    // match.range gives the range of the whole match\n    // match.rangeAtIndex(i) gives the range of the i'th capture group (starting from 1)\n  }\n\nimport Foundation\n\nlet orig = \"I am the original string\"\nif let regex = NSRegularExpression(pattern: \"original\", options: nil, error: nil) {\nlet result = regex.stringByReplacingMatchesInString(orig, options: nil, range: NSRange(location: 0, length: count(orig.utf16)), withTemplate: \"modified\")\n  println(result)\n}\n", "explain": "Test\nSubstitute (undocumented)\nTest\nLoop through matches\nSubstitute\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "R", "code": "\n\npattern <- \"string\"\ntext1 <- \"this is a matching string\"\ntext2 <- \"this does not match\"\n\n\ngrep(pattern, c(text1, text2))  # 1\n\n\nregexpr(pattern, c(text1, text2))\n\n[1] 20 -1\nattr(,\"match.length\")\n[1]  6 -1\n\n\ngsub(pattern, \"pair of socks\", c(text1, text2))\n\n[1] \"this is a matching pair of socks\" \"this does not match\"\n\n", "explain": "First, define some strings.\nMatching with grep.  The indices of the texts containing matches are returned.\nMatching with regexpr.  The positions of the starts of the matches are returned, along with the lengths of the matches.\nReplacement\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Ada", "code": "\n\nwith Ada.Text_IO; with Gnat.Regpat; use Ada.Text_IO;\n\nprocedure Regex is\n\n   package Pat renames Gnat.Regpat;\n\n   procedure Search_For_Pattern(Compiled_Expression: Pat.Pattern_Matcher;\n                                Search_In: String;\n                                First, Last: out Positive;\n                                Found: out Boolean) is\n      Result: Pat.Match_Array (0 .. 1);\n   begin\n      Pat.Match(Compiled_Expression, Search_In, Result);\n      Found := not Pat.\"=\"(Result(1), Pat.No_Match);\n      if Found then\n         First := Result(1).First;\n         Last := Result(1).Last;\n      end if;\n   end Search_For_Pattern;\n\n   Word_Pattern: constant String := \"([a-zA-Z]+)\";\n\n   Str:           String:= \"I love PATTERN matching!\";\n   Current_First: Positive := Str'First;\n   First, Last:   Positive;\n   Found:         Boolean;\n\nbegin\n   -- first, find all the words in Str\n   loop\n      Search_For_Pattern(Pat.Compile(Word_Pattern),\n                         Str(Current_First .. Str'Last),\n                         First, Last, Found);\n   exit when not Found;\n      Put_Line(\"<\" & Str(First .. Last) & \">\");\n      Current_First := Last+1;\n   end loop;\n\n   -- second, replace \"PATTERN\" in Str by \"pattern\"\n   Search_For_Pattern(Pat.Compile(\"(PATTERN)\"), Str, First, Last, Found);\n   Str := Str(Str'First .. First-1) & \"pattern\" & Str(Last+1 .. Str'Last);\n   Put_Line(Str);\nend Regex;\n\n\nOutput:\n<I>\n<love>\n<PATTERN>\n<matching>\nI love pattern matching!\n", "explain": "There is no Regular Expression library in the Ada Standard, \nso I am using one of the libraries provided by gnat/gcc. \n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Julia", "code": "\nTranslation of: Perl\n\ns = \"I am a string\"\nif ismatch(r\"string$\", s)\n    println(\"'$s' ends with 'string'\")\nend\n\n\ns = \"I am a string\"\ns = replace(s, r\" (a|an) \", \" another \")\n\n\n", "explain": "Julia implements Perl-compatible regular expressions (via the built-in PCRE library).  To test for a match:\nTo perform replacements:\nThere are many other features of Julia's regular-expression support, too numerous to list here.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    val s1 = \"I am the original string\"\n    val r1 = Regex(\"^.*string$\")\n    if (s1.matches(r1)) println(\"`$s1` matches `$r1`\")\n    val r2 = Regex(\"original\")\n    val s3 = \"replacement\"\n    val s2 = s1.replace(r2, s3)\n    if (s2 != s1) println(\"`$s2` replaces `$r2` with `$s3`\")\n}\n\n\nOutput:\n`I am the original string` matches `^.*string$`\n`I am the replacement string` replaces `original` with `replacement`\n\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Perl", "code": "\nWorks with: Perl version 5.8.8\n\n$string = \"I am a string\";\nif ($string =~ /string$/) {\n   print \"Ends with 'string'\\n\";\n}\n\nif ($string !~ /^You/) {\n   print \"Does not start with 'You'\\n\";\n}\n\n\n$string = \"I am a string\";\n$string =~ s/ a / another /; # makes \"I am a string\" into \"I am another string\"\nprint $string;\n\n\n$string = \"I am a string\";\n$string2 = $string =~ s/ a / another /r; # $string2 == \"I am another string\", $string is unaltered\nprint $string2;\n\n\n$string = \"I am a string\";\nif ($string =~ s/\\bam\\b/was/) { # \\b is a word border\n   print \"I was able to find and replace 'am' with 'was'\\n\";\n}\n\n\n# add the following just after the last / for additional control\n# g = globally (match as many as possible)\n# i = case-insensitive\n# s = treat all of $string as a single line (in case you have line breaks in the content)\n# m = multi-line (the expression is run on each line individually)\n\n$string =~ s/i/u/ig; # would change \"I am a string\" into \"u am a strung\"\n\n\n$_ = \"I like banana milkshake.\";\nif (/banana/) {          # The regular expression binding operator is omitted\n  print \"Match found\\n\";\n}\n\n", "explain": "Test\n\nSubstitute\nIn Perl 5.14+, you can return a new substituted string without altering the original string:\n\nTest and Substitute\n\nOptions\nOmission of the regular expression binding operators\nIf regular expression matches are being made against the topic variable, it is possible to omit the regular expression binding operators:\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Objective-C", "code": "\n\nWorks with: Mac OS X version 10.4+\nWorks with: iOS version 3.0+\nNSString *str = @\"I am a string\";\nNSString *regex = @\".*string$\";\n\n// Note: the MATCHES operator matches the entire string, necessitating the \".*\"\nNSPredicate *pred = [NSPredicate predicateWithFormat:@\"SELF MATCHES\u00a0%@\", regex];\n\nif ([pred evaluateWithObject:str]) {\n    NSLog(@\"ends with 'string'\");\n}\n\n\nNSRegularExpressionSearch[edit]\n\nWorks with: Mac OS X version 10.7+\nWorks with: iOS version 3.2+\nNSString *str = @\"I am a string\";\nif ([str rangeOfString:@\"string$\" options:NSRegularExpressionSearch].location != NSNotFound) {\n    NSLog(@\"Ends with 'string'\");\n}\n\n\nWorks with: Mac OS X version 10.7+\nWorks with: iOS version 4.0+ undocumented\nNSString *orig = @\"I am the original string\";\nNSString *result = [orig stringByReplacingOccurrencesOfString:@\"original\"\n                                                   withString:@\"modified\"\n                                                      options:NSRegularExpressionSearch\n                                                        range:NSMakeRange(0, [orig length])];\nNSLog(@\"%@\", result);\n\nNSRegularExpression[edit]\nWorks with: Mac OS X version 10.7+\nWorks with: iOS version 4.0+\n\nNSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@\"string$\"\n                                                                       options:0\n                                                                         error:NULL];\nNSString *str = @\"I am a string\";\nif ([regex rangeOfFirstMatchInString:str\n                             options:0\n                               range:NSMakeRange(0, [str length])\n     ].location != NSNotFound) {\n    NSLog(@\"Ends with 'string'\");\n}\n\n\nfor (NSTextCheckingResult *match in [regex matchesInString:str\n                                                   options:0\n                                                     range:NSMakeRange(0, [str length])\n                                     ]) {\n    // match.range gives the range of the whole match\n    // [match rangeAtIndex:i] gives the range of the i'th capture group (starting from 1)\n}\n\n\nNSString *orig = @\"I am the original string\";\nNSRegularExpression *regex = [NSRegularExpression regularExpressionWithPattern:@\"original\"\n                                                                       options:0\n                                                                         error:NULL];\nNSString *result = [regex stringByReplacingMatchesInString:orig\n                                                   options:0\n                                                     range:NSMakeRange(0, [orig length])\n                                              withTemplate:@\"modified\"];\nNSLog(@\"%@\", result);\n\n", "explain": "Test\nUnfortunately this method cannot find the location of the match or do substitution.\nTest\nSubstitute\nTest\nLoop through matches\nSubstitute\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Lua", "code": "\n\ntest = \"My name is Lua.\"\npattern = \".*name is (%a*).*\"\n\nif test:match(pattern) then\n    print(\"Name found.\")\nend\n\nsub, num_matches = test:gsub(pattern, \"Hello, %1!\")\nprint(sub)\n\n", "explain": "In Lua many string manipulation methods use patterns, which offer almost the same fucntionality as regular expressions, but whose syntax differs slightly. The percent sign (%) is generally used instead of a backslash to start a character class or a reference for a match in a substitution.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Scala", "code": "\nLibrary: Scala\n\nval Bottles1 = \"(\\\\d+) bottles of beer\".r                                            // syntactic sugar\nval Bottles2 = \"\"\"(\\d+) bottles of beer\"\"\".r                                         // using triple-quotes to preserve backslashes\nval Bottles3 = new scala.util.matching.Regex(\"(\\\\d+) bottles of beer\")               // standard\nval Bottles4 = new scala.util.matching.Regex(\"\"\"(\\d+) bottles of beer\"\"\", \"bottles\") // with named groups\n\n\"99 bottles of beer\" matches \"(\\\\d+) bottles of beer\" // the full string must match\n\"99 bottles of beer\" replace (\"99\", \"98\") // Single replacement\n\"99 bottles of beer\" replaceAll (\"b\", \"B\") // Multiple replacement\n\n\"\\\\d+\".r findFirstIn \"99 bottles of beer\" // returns first partial match, or None\n\"\\\\w+\".r findAllIn \"99 bottles of beer\" // returns all partial matches as an iterator\n\"\\\\s+\".r findPrefixOf \"99 bottles of beer\" // returns a matching prefix, or None\nBottles4 findFirstMatchIn \"99 bottles of beer\" // returns a \"Match\" object, or None\nBottles4 findPrefixMatchOf \"99 bottles of beer\" // same thing, for prefixes\nval bottles = (Bottles4 findFirstMatchIn \"99 bottles of beer\").get.group(\"bottles\") // Getting a group by name\n\nval Some(bottles) = Bottles4 findPrefixOf \"99 bottles of beer\" // throws an exception if the matching fails; full string must match\nfor {\n  line <- \"\"\"|99 bottles of beer on the wall\n             |99 bottles of beer\n             |Take one down, pass it around\n             |98 bottles of beer on the wall\"\"\".stripMargin.lines\n} line match {\n  case Bottles1(bottles) => println(\"There are still \"+bottles+\" bottles.\") // full string must match, so this will match only once\n  case _ =>\n}\nfor {\n  matched <- \"(\\\\w+)\".r findAllIn \"99 bottles of beer\" matchData // matchData converts to an Iterator of Match\n} println(\"Matched from \"+matched.start+\" to \"+matched.end)\n\nBottles2 replaceFirstIn (\"99 bottles of beer\", \"98 bottles of beer\")\nBottles3 replaceAllIn (\"99 bottles of beer\", \"98 bottles of beer\")\n", "explain": "Define\nSearch and replace with string methods:\nSearch with regex methods:\nUsing pattern matching with regex:\nReplacing with regex:\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Dart", "code": "\nRegExp regexp = new RegExp(r'\\w+\\!');\n\nString capitalize(Match m) => '${m[0].substring(0, m[0].length-1).toUpperCase()}';\n\nvoid main(){\n  String hello = 'hello hello! world world!';\n  String hellomodified = hello.replaceAllMapped(regexp, capitalize);\n  print(hello);\n  print(hellomodified);\n}\n\n\nOutput:\nhello hello! world world!\nhello HELLO world WORLD\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.regex;\n\n    immutable s = \"I am a string\";\n\n    // Test.\n    if (s.match(\"string$\"))\n        \"Ends with 'string'.\".writeln;\n\n    // Substitute.\n    s.replace(\" a \".regex, \" another \").writeln;\n}\n\n\nOutput:\nEnds with 'string'.\nI am another string\n\n", "explain": "In std.string there are string functions to perform the same operations more efficiently.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Haskell", "code": "\n\nimport Text.Regex\n\nstr = \"I am a string\"\n\ncase matchRegex (mkRegex \".*string$\") str of\n  Just _  -> putStrLn $ \"ends with 'string'\"\n  Nothing -> return ()\n\n\nimport Text.Regex\n\norig = \"I am the original string\"\nresult = subRegex (mkRegex \"original\") orig \"modified\"\nputStrLn $ result\n\n", "explain": "Test\nSubstitute\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "VBScript", "code": "\n\ntext = \"I need more coffee!!!\"\nSet regex = New RegExp\nregex.Global = True\nregex.Pattern = \"\\s\"\nIf regex.Test(text) Then\n\tWScript.StdOut.Write regex.Replace(text,vbCrLf)\nElse\n\tWScript.StdOut.Write \"No matching pattern\"\nEnd If\n\nInput:\nI need more coffee!!!\n\nOutput:\nI\nneed\nmore\ncoffee!!!\n\n", "explain": "Replace white spaces with line breaks.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "PowerShell", "code": "\n\"I am a string\" -match '\\bstr'       # true\n\"I am a string\" -replace 'a\\b','no'  # I am no string\n\n\n", "explain": "By default both the -match and -replace operators are case-insensitive. They can be made case-sensitive by using the -cmatch and -creplace operators.\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "ABAP", "code": "\nDATA: text TYPE string VALUE 'This is a Test'.\n\nFIND FIRST OCCURRENCE OF REGEX 'is' IN text.\nIF sy-subrc = 0.\n  cl_demo_output=>write( 'Regex matched' ).\nENDIF.\n\nREPLACE ALL OCCURRENCES OF REGEX '[t|T]est' IN text WITH 'Regex'.\n\ncl_demo_output=>write( text ).\ncl_demo_output=>display( ).\n\n\nRegex matched\n\nThis is a Regex\n\n", "explain": "Output:\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "F#", "code": "\nTranslation of: C#\nopen System\nopen System.Text.RegularExpressions\n\n[<EntryPoint>]\nlet main argv =\n    let str = \"I am a string\"\n    if Regex(\"string$\").IsMatch(str) then Console.WriteLine(\"Ends with string.\")\n \n    let rstr = Regex(\" a \").Replace(str, \" another \")\n    Console.WriteLine(rstr)\n    0\n\n", "explain": ""}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "Groovy", "code": "\n\nimport java.util.regex.*;\n\ndef woodchuck = \"How much wood would a woodchuck chuck if a woodchuck could chuck wood?\"\ndef pepper = \"Peter Piper picked a peck of pickled peppers\"\n\n\nprintln \"=== Regular-expression String syntax (/string/) ===\"\ndef woodRE = /[Ww]o\\w+d/\ndef piperRE = /[Pp]\\w+r/\nassert woodRE instanceof String && piperRE instanceof String\nassert (/[Ww]o\\w+d/ == \"[Ww]o\\\\w+d\") && (/[Pp]\\w+r/ == \"[Pp]\\\\w+r\")\nprintln ([woodRE: woodRE, piperRE: piperRE])\nprintln ()\n\n\nprintln \"=== Pattern (~) operator ===\"\ndef woodPat = ~/[Ww]o\\w+d/\ndef piperPat = ~piperRE\nassert woodPat instanceof Pattern && piperPat instanceof Pattern\n\ndef woodList = woodchuck.split().grep(woodPat)\nprintln ([exactTokenMatches: woodList])\nprintln ([exactTokenMatches: pepper.split().grep(piperPat)])\nprintln ()\n\n\nprintln \"=== Matcher (=~) operator ===\"\ndef wwMatcher = (woodchuck =~ woodRE)\ndef ppMatcher = (pepper =~ /[Pp]\\w+r/)\ndef wpMatcher = (woodchuck =~ /[Pp]\\w+r/)\nassert wwMatcher instanceof Matcher && ppMatcher instanceof Matcher\nassert wwMatcher.toString() == woodPat.matcher(woodchuck).toString()\nassert ppMatcher.toString() == piperPat.matcher(pepper).toString()\nassert wpMatcher.toString() == piperPat.matcher(woodchuck).toString()\n\nprintln ([ substringMatches: wwMatcher.collect { it }])\nprintln ([ substringMatches: ppMatcher.collect { it }])\nprintln ([ substringMatches: wpMatcher.collect { it }])\nprintln ()\n\n\nprintln \"=== Exact Match (==~) operator ===\"\ndef containsWoodRE = /.*/ + woodRE + /.*/\ndef containsPiperRE = /.*/ + piperRE + /.*/\ndef wwMatches = (woodchuck ==~ containsWoodRE)\nassert wwMatches instanceof Boolean\ndef wwNotMatches = ! (woodchuck ==~ woodRE)\ndef ppMatches = (pepper ==~ containsPiperRE)\ndef pwNotMatches = ! (pepper ==~ containsWoodRE)\ndef wpNotMatches = ! (woodchuck ==~ containsPiperRE)\nassert wwMatches && wwNotMatches && ppMatches && pwNotMatches && pwNotMatches\n\nprintln (\"'${woodchuck}' ${wwNotMatches\u00a0? 'does not'\u00a0: 'does'} match '${woodRE}' exactly\")\nprintln (\"'${woodchuck}' ${wwMatches\u00a0? 'does'\u00a0: 'does not'} match '${containsWoodRE}' exactly\")\n\n\nOutput:\n=== Regular-expression String syntax (/string/)=== \n[woodRE:[Ww]o\\w+d, piperRE:[Pp]\\w+r]\n\n=== Pattern (~) operator ===\n[exactTokenMatches:[wood, would]]\n[exactTokenMatches:[Peter, Piper]]\n\n=== Matcher (=~) operator ===\n[substringMatches:[wood, would, wood, wood, wood]]\n[substringMatches:[Peter, Piper, pepper]]\n[substringMatches:[]]\n\n=== Exact Match (==~) operator ===\n'How much wood would a woodchuck chuck if a woodchuck could chuck wood?' does not match '[Ww]o\\w+d' exactly\n'How much wood would a woodchuck chuck if a woodchuck could chuck wood?' does match '.*[Ww]o\\w+d.*' exactly\n\nprintln woodchuck.replaceAll(/c\\w+k/, \"CHUCK\")\n\n\nOutput:\nHow much wood would a woodCHUCK CHUCK if a woodCHUCK could CHUCK wood?\n\ndef ck = (woodchuck =~ /c\\w+k/)\nprintln (ck.replaceAll(\"CHUCK\"))\nprintln (ck.replaceAll(\"wind\"))\nprintln (ck.replaceAll(\"pile\"))\nprintln (ck.replaceAll(\"craft\"))\nprintln (ck.replaceAll(\"block\"))\nprintln (ck.replaceAll(\"row\"))\nprintln (ck.replaceAll(\"shed\"))\nprintln (ck.replaceAll(\"man\"))\nprintln (ck.replaceAll(\"work\"))\nprintln (ck.replaceAll(\"pickle\"))\n\n\nOutput:\nHow much wood would a woodCHUCK CHUCK if a woodCHUCK could CHUCK wood?\nHow much wood would a woodwind wind if a woodwind could wind wood?\nHow much wood would a woodpile pile if a woodpile could pile wood?\nHow much wood would a woodcraft craft if a woodcraft could craft wood?\nHow much wood would a woodblock block if a woodblock could block wood?\nHow much wood would a woodrow row if a woodrow could row wood?\nHow much wood would a woodshed shed if a woodshed could shed wood?\nHow much wood would a woodman man if a woodman could man wood?\nHow much wood would a woodwork work if a woodwork could work wood?\nHow much wood would a woodpickle pickle if a woodpickle could pickle wood?\n", "explain": "\"Matching\" Solution (it's complicated):\nReplacement Solution (String.replaceAll()):\nReusable Replacement Solution (Matcher.replaceAll()):\n"}, {"task_name": "Regular expressions", "task_url": "https://rosettacode.org/wiki/Regular_expressions", "task_cat": "Text processing", "lang": "AWK", "code": "\n\n$ awk '{if($0~/[A-Z]/)print \"uppercase detected\"}'\nabc\nABC\nuppercase detected\n\n\nawk '/[A-Z]/{print \"uppercase detected\"}'\ndef\nDeF\nuppercase detected\n\n\n$ awk '{gsub(/[A-Z]/,\"*\");print}'\nabCDefG\nab**ef*\n$ awk '{gsub(/[A-Z]/,\"(&)\");print}'\nabCDefGH\nab(C)(D)ef(G)(H)\n\n\n$ awk '{gsub(/[A-Z]+/,\"(&)\");print}'\nabCDefGH\nab(CD)ef(GH)\n\n\n print \"Match not found\"\n\n\n", "explain": "AWK supports regular expressions, which are typically enclosed using slash symbols at the front and back, and the tilde regular expression binding operator: \nAs shorthand, a regular expression in the condition part fires if it matches an input line:\nFor substitution, the first argument can be a regular expression, while the replacement string is constant (only that '&' in it receives the value of the match):\nThis variant matches one or more uppercase letters in one round:\nRegular expression negation can be achieved by combining the regular expression binding operator with a logical not operator, as follows:\nif (text\u00a0!~ /strawberry/) {\n}\n"}]