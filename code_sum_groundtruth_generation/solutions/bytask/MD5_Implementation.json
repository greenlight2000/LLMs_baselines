[{"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Python", "code": "\nWorks with: Python version 3.2\n\nimport math\n\nrotate_amounts = [7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n                  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n                  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconstants = [int(abs(math.sin(i+1)) * 2**32) & 0xFFFFFFFF for i in range(64)]\n\ninit_values = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476]\n\nfunctions = 16*[lambda b, c, d: (b & c) | (~b & d)] + \\\n            16*[lambda b, c, d: (d & b) | (~d & c)] + \\\n            16*[lambda b, c, d: b ^ c ^ d] + \\\n            16*[lambda b, c, d: c ^ (b | ~d)]\n\nindex_functions = 16*[lambda i: i] + \\\n                  16*[lambda i: (5*i + 1)%16] + \\\n                  16*[lambda i: (3*i + 5)%16] + \\\n                  16*[lambda i: (7*i)%16]\n\ndef left_rotate(x, amount):\n    x &= 0xFFFFFFFF\n    return ((x<<amount) | (x>>(32-amount))) & 0xFFFFFFFF\n\ndef md5(message):\n\n    message = bytearray(message) #copy our input into a mutable buffer\n    orig_len_in_bits = (8 * len(message)) & 0xffffffffffffffff\n    message.append(0x80)\n    while len(message)%64 != 56:\n        message.append(0)\n    message += orig_len_in_bits.to_bytes(8, byteorder='little')\n\n    hash_pieces = init_values[:]\n\n    for chunk_ofst in range(0, len(message), 64):\n        a, b, c, d = hash_pieces\n        chunk = message[chunk_ofst:chunk_ofst+64]\n        for i in range(64):\n            f = functions[i](b, c, d)\n            g = index_functions[i](i)\n            to_rotate = a + f + constants[i] + int.from_bytes(chunk[4*g:4*g+4], byteorder='little')\n            new_b = (b + left_rotate(to_rotate, rotate_amounts[i])) & 0xFFFFFFFF\n            a, b, c, d = d, new_b, b, c\n        for i, val in enumerate([a, b, c, d]):\n            hash_pieces[i] += val\n            hash_pieces[i] &= 0xFFFFFFFF\n    \n    return sum(x<<(32*i) for i, x in enumerate(hash_pieces))\n        \ndef md5_to_hex(digest):\n    raw = digest.to_bytes(16, byteorder='little')\n    return '{:032x}'.format(int.from_bytes(raw, byteorder='big'))\n\nif __name__=='__main__':\n    demo = [b\"\", b\"a\", b\"abc\", b\"message digest\", b\"abcdefghijklmnopqrstuvwxyz\",\n            b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n            b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n    for message in demo:\n        print(md5_to_hex(md5(message)),' <= \"',message.decode('ascii'),'\"', sep='')\n\n\nThe code works with whole bytes, arbitrary message length is not supported.\nInstead of doing an if-else chain in the inner loop, we build a list of functions to use for each iteration. An if-else chain would probably be faster, but this shows off the language features better.\nPython integers don't ever overflow (they are implemented internally as bignums), so the code actually has to emulate 32-bit overflow by masking manually where it matters. On the other hand, this allows us to return the digest as a regular 128-bit number instead of a bytes object.\nThe code makes heavy use of int.from_bytes() and int.to_bytes() to convert between bytes and integers. These methods were introduced in Python 3.2. In earlier versions, you needed to use more cumbersome ways to convert between the two types.\nThe multiple assignment feature allows us to easily decompose the four items in hash_pieces into individual variables, and to shuffle around the four helper variables at the end of every iteration without introducing a temporary variable.\n", "explain": "Note that the following code focuses on brevity and elegance instead of performance, since Python isn't very good at number crunching anyway. If performance is important, the best solution is to use the built-in md5 module, written in C.\nImplementation notes:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "C", "code": "\n\n", "explain": "See the implementation at MD5#C. Also, RFC 1321 already provides C code.\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Java", "code": "\nWorks with: Java version 1.5+\n\nclass MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    int messageLenBytes = message.length;\n    int numBlocks = ((messageLenBytes + 8) >>> 6) + 1;\n    int totalLen = numBlocks << 6;\n    byte[] paddingBytes = new byte[totalLen - messageLenBytes];\n    paddingBytes[0] = (byte)0x80;\n    \n    long messageLenBits = (long)messageLenBytes << 3;\n    for (int i = 0; i < 8; i++)\n    {\n      paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits;\n      messageLenBits >>>= 8;\n    }\n    \n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    int[] buffer = new int[16];\n    for (int i = 0; i < numBlocks; i ++)\n    {\n      int index = i << 6;\n      for (int j = 0; j < 64; j++, index++)\n        buffer[j >>> 2] = ((int)((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8);\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n    }\n    \n    byte[] md5 = new byte[16];\n    int count = 0;\n    for (int i = 0; i < 4; i++)\n    {\n      int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d));\n      for (int j = 0; j < 4; j++)\n      {\n        md5[count++] = (byte)n;\n        n >>>= 8;\n      }\n    }\n    return md5;\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n\n\n0xD41D8CD98F00B204E9800998ECF8427E <== \"\"\n0x0CC175B9C0F1B6A831C399E269772661 <== \"a\"\n0x900150983CD24FB0D6963F7D28E17F72 <== \"abc\"\n0xF96B697D7CB7938D525A2F31AAF161D0 <== \"message digest\"\n0xC3FCD3D76192E4007DFB496CCA67E13B <== \"abcdefghijklmnopqrstuvwxyz\"\n0xD174AB98D277D9F5A5611C2C9F419D9F <== \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n0x57EDF4A22BE3C955AC49DA2E2107B67A <== \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n\nWorks with: Java version 1.5+\n\nimport java.nio.ByteBuffer;\nimport java.nio.ByteOrder;\n\nclass MD5\n{\n\n  private static final int INIT_A = 0x67452301;\n  private static final int INIT_B = (int)0xEFCDAB89L;\n  private static final int INIT_C = (int)0x98BADCFEL;\n  private static final int INIT_D = 0x10325476;\n  \n  private static final int[] SHIFT_AMTS = {\n    7, 12, 17, 22,\n    5,  9, 14, 20,\n    4, 11, 16, 23,\n    6, 10, 15, 21\n  };\n  \n  private static final int[] TABLE_T = new int[64];\n  static\n  {\n    for (int i = 0; i < 64; i++)\n      TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)));\n  }\n  \n  public static byte[] computeMD5(byte[] message)\n  {\n    ByteBuffer padded = ByteBuffer.allocate((((message.length + 8) / 64) + 1) * 64).order(ByteOrder.LITTLE_ENDIAN);\n    padded.put(message);\n    padded.put((byte)0x80);\n    long messageLenBits = (long)message.length * 8;\n    padded.putLong(padded.capacity() - 8, messageLenBits);\n\n    padded.rewind();\n\n    int a = INIT_A;\n    int b = INIT_B;\n    int c = INIT_C;\n    int d = INIT_D;\n    while (padded.hasRemaining()) {\n      // obtain a slice of the buffer from the current position,\n      // and view it as an array of 32-bit ints\n      IntBuffer chunk = padded.slice().order(ByteOrder.LITTLE_ENDIAN).asIntBuffer();\n      int originalA = a;\n      int originalB = b;\n      int originalC = c;\n      int originalD = d;\n      for (int j = 0; j < 64; j++)\n      {\n        int div16 = j >>> 4;\n        int f = 0;\n        int bufferIndex = j;\n        switch (div16)\n        {\n          case 0:\n            f = (b & c) | (~b & d);\n            break;\n            \n          case 1:\n            f = (b & d) | (c & ~d);\n            bufferIndex = (bufferIndex * 5 + 1) & 0x0F;\n            break;\n            \n          case 2:\n            f = b ^ c ^ d;\n            bufferIndex = (bufferIndex * 3 + 5) & 0x0F;\n            break;\n            \n          case 3:\n            f = c ^ (b | ~d);\n            bufferIndex = (bufferIndex * 7) & 0x0F;\n            break;\n        }\n        int temp = b + Integer.rotateLeft(a + f + chunk.get(bufferIndex) + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)]);\n        a = d;\n        d = c;\n        c = b;\n        b = temp;\n      }\n      \n      a += originalA;\n      b += originalB;\n      c += originalC;\n      d += originalD;\n      padded.position(padded.position() + 64);\n    }\n    \n    ByteBuffer md5 = ByteBuffer.allocate(16).order(ByteOrder.LITTLE_ENDIAN);\n    for (int n : new int[]{a, b, c, d})\n    {\n      md5.putInt(n);\n    }\n    return md5.array();\n  }\n  \n  public static String toHexString(byte[] b)\n  {\n    StringBuilder sb = new StringBuilder();\n    for (int i = 0; i < b.length; i++)\n    {\n      sb.append(String.format(\"%02X\", b[i] & 0xFF));\n    }\n    return sb.toString();\n  }\n\n  public static void main(String[] args)\n  {\n    String[] testStrings = { \"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\", \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" };\n    for (String s : testStrings)\n      System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\");\n    return;\n  }\n  \n}\n\n\n0xD41D8CD98F00B204E9800998ECF8427E <== \"\"\n0x0CC175B9C0F1B6A831C399E269772661 <== \"a\"\n0x900150983CD24FB0D6963F7D28E17F72 <== \"abc\"\n0xF96B697D7CB7938D525A2F31AAF161D0 <== \"message digest\"\n0xC3FCD3D76192E4007DFB496CCA67E13B <== \"abcdefghijklmnopqrstuvwxyz\"\n0xD174AB98D277D9F5A5611C2C9F419D9F <== \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n0x57EDF4A22BE3C955AC49DA2E2107B67A <== \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n\n", "explain": "Based on RFC-1321.\nOutput:\nUsing ByteBuffers\nOutput:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "C#", "code": "\n\n\t/// Represent digest with ABCD\n\tsealed public class Digest\n\t{\n\t\tpublic uint A;\n\t\tpublic uint B;\n\t\tpublic uint C;\n\t\tpublic uint D;\n\n\t\tpublic Digest()\n\t\t{\n\t\t\tA=(uint)MD5InitializerConstant.A;\n\t\t\tB=(uint)MD5InitializerConstant.B;\n\t\t\tC=(uint)MD5InitializerConstant.C;\n\t\t\tD=(uint)MD5InitializerConstant.D;\n       \t        }\n\n\t\tpublic override string ToString()\n\t\t{\n\t\t\tstring st ;\n\t\t\tst= MD5Helper.ReverseByte(A).ToString(\"X8\")+\n\t\t\t    MD5Helper.ReverseByte(B).ToString(\"X8\")+\n                            MD5Helper.ReverseByte(C).ToString(\"X8\")+\n\t\t\t    MD5Helper.ReverseByte(D).ToString(\"X8\");\n\t\t\treturn st;\n\t\t\t\n\t\t}\n\t}\n\n\tpublic class MD5\n\t{\n\t\t/***********************VARIABLES************************************/\n\n\n\t\t/***********************Statics**************************************/\n\t\t/// <summary>\n\t\t/// lookup table 4294967296*sin(i)\n\t\t/// </summary>\n\t\tprotected readonly static uint []  T =new uint[64] \n\t\t\t{\t0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee,\n\t\t\t\t0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501,\n                0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be,\n                0x6b901122,0xfd987193,0xa679438e,0x49b40821,\n\t\t\t\t0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa,\n                0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8,\n                0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed,\n\t\t\t\t0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a,\n                0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c,\n                0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70,\n                0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05,\n\t\t\t\t0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665,\n                0xf4292244,0x432aff97,0xab9423a7,0xfc93a039,\n                0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1,\n                0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1,\n\t\t\t\t0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391};\n\t\t\n\t\t/*****instance variables**************/\n\t\t/// <summary>\n\t\t/// X used to proces data in \n\t\t///\t512 bits chunks as 16 32 bit word\n\t\t/// </summary>\n\t\tprotected  uint [] X = new uint [16];\t\n\t\t\n\t\t/// <summary>\n\t\t/// the finger print obtained. \n\t\t/// </summary>\n\t\tprotected Digest dgFingerPrint;\t\t\t\n\n\t\t/// <summary>\n\t\t/// the input bytes\n\t\t/// </summary>\n\t\tprotected\tbyte [] m_byteInput;\t\t\n\t\t\n\t\n\t\t\n\t\t/**********************EVENTS AND DELEGATES*******************************************/\n\n\t\tpublic delegate void ValueChanging (object sender,MD5ChangingEventArgs Changing);\n\t\tpublic delegate void ValueChanged (object sender,MD5ChangedEventArgs Changed);\n\n\n\t\tpublic event ValueChanging OnValueChanging;\n\t\tpublic event ValueChanged  OnValueChanged;\n\n\n\t\t\n\t\t/********************************************************************/\n\t\t/***********************PROPERTIES ***********************/\n\t\t/// <summary>\n\t\t///gets or sets as string\n\t\t/// </summary>\n\t\tpublic string Value\n\t\t{\n\t\t\tget\n\t\t\t{ \n\t\t\t\tstring st ;\n\t\t\t\tchar [] tempCharArray= new Char[m_byteInput.Length];\n\t\t\t\t\n\t\t\t\tfor(int i =0; i<m_byteInput.Length;i++)\n\t\t\t\t\ttempCharArray[i]=(char)m_byteInput[i];\n\n\t\t\t\tst= new String(tempCharArray);\n\t\t\t\treturn st;\n\t\t\t}\n\t\t\tset\n\t\t\t{\n\t\t\t\t/// raise the event to notify the changing \n\t\t\t\tif (this.OnValueChanging !=null)\n\t\t\t\t\tthis.OnValueChanging(this,new MD5ChangingEventArgs(value));\n\n\n\t\t\t\tm_byteInput=new byte[value.Length];\n\t\t\t\tfor (int i =0; i<value.Length;i++)\n\t\t\t\t\tm_byteInput[i]=(byte)value[i];\n\t\t\t\tdgFingerPrint=CalculateMD5Value();\t\t\t\t\n\n\t\t\t\t/// raise the event to notify the change\n\t\t\t\tif (this.OnValueChanged !=null)\n\t\t\t\t\tthis.OnValueChanged(this,new MD5ChangedEventArgs(value,dgFingerPrint.ToString()));\n\t\t\t\t \n\t\t\t}\n\t\t}\t\t\n\t\t\n\t\t/// <summary>\n\t\t/// get/sets as  byte array \n\t\t/// </summary>\n\t\tpublic byte [] ValueAsByte\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\tbyte [] bt = new byte[m_byteInput.Length];\n\t\t\t\tfor (int i =0; i<m_byteInput.Length;i++)\n\t\t\t\t\tbt[i]=m_byteInput[i];\n\t\t\t\treturn bt;\n          }\n\t\t\tset\n\t\t\t{\n\t\t\t\t/// raise the event to notify the changing\n\t\t\t\tif (this.OnValueChanging !=null)\n\t\t\t\t\tthis.OnValueChanging(this,new MD5ChangingEventArgs(value));\n\n\t\t\t\tm_byteInput=new byte[value.Length];\n\t\t\t\tfor (int i =0; i<value.Length;i++)\n\t\t\t\t\tm_byteInput[i]=value[i];\n\t\t\t\tdgFingerPrint=CalculateMD5Value();\n\n\t\n\t\t\t\t/// notify the changed  value\n\t\t\t\tif (this.OnValueChanged !=null)\n\t\t\t\t\tthis.OnValueChanged(this,new MD5ChangedEventArgs(value,dgFingerPrint.ToString()));\n\t\t\t}\n\t\t}\n\n\t\t//gets the signature/figner print as string\n\t\tpublic  string FingerPrint\n\t\t{\n\t\t\tget\n\t\t\t{\n\t\t\t\treturn dgFingerPrint.ToString();\n\t\t\t}\n\t\t}\n\n\n\t\t/*************************************************************************/\n\t\t/// <summary>\n\t\t/// Constructor\n\t\t/// </summary>\n\t\tpublic MD5()\n\t\t{\t\t\t\n\t\t\tValue=\"\";\n\t\t}\n\t\t\n\t\t\n\t\t/******************************************************************************/\n\t\t/*********************METHODS**************************/\n\n\t\t/// <summary>\n\t\t/// calculat md5 signature of the string in Input\n\t\t/// </summary>\n\t\t/// <returns> Digest: the finger print of msg</returns>\n\t\tprotected Digest CalculateMD5Value()\n\t\t{\n\t\t\t/***********vairable declaration**************/\n\t\t\tbyte [] bMsg;\t//buffer to hold bits\n\t\t\tuint N;\t\t\t//N is the size of msg as  word (32 bit) \n\t\t\tDigest dg =new Digest();\t\t\t//  the value to be returned\n\n\t\t\t// create a buffer with bits padded and length is alos padded\n\t\t\tbMsg=CreatePaddedBuffer();\n\n\t\t\tN=(uint)(bMsg.Length*8)/32;\t\t//no of 32 bit blocks\n\t\t\t\n\t\t\tfor (uint  i=0; i<N/16;i++)\n\t\t\t{\n\t\t\t\tCopyBlock(bMsg,i);\n\t\t\t\tPerformTransformation(ref dg.A,ref dg.B,ref dg.C,ref dg.D);\n\t\t\t}\n\t\t\treturn dg;\n\t\t}\n\t\n\t\t/********************************************************\n\t\t * TRANSFORMATIONS\u00a0:  FF , GG , HH , II  acc to RFC 1321\n\t\t * where each Each letter represnets the aux function used\n\t\t *********************************************************/\n\n\n\n\t\t/// <summary>\n\t\t/// perform transformatio using f(((b&c) | (~(b)&d))\n\t\t/// </summary>\n\t\tprotected void TransF(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )\n\t\t{\n\t\t\ta = b + MD5Helper.RotateLeft((a + ((b&c) | (~(b)&d)) + X[k] + T[i-1]), s);\n\t\t}\n\n\t\t/// <summary>\n\t\t/// perform transformatio using g((b&d) | (c & ~d) )\n\t\t/// </summary>\n\t\tprotected void TransG(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )\n\t\t{\n\t\t\ta = b + MD5Helper.RotateLeft((a + ((b&d) | (c & ~d) ) + X[k] + T[i-1]), s);\n\t\t}\n\t\t\n\t\t/// <summary>\n\t\t/// perform transformatio using h(b^c^d)\n\t\t/// </summary>\n\t\tprotected void TransH(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )\n\t\t{\n\t\t\ta = b + MD5Helper.RotateLeft((a + (b^c^d) + X[k] + T[i-1]), s);\n\t\t}\n\t\t\n\t\t/// <summary>\n\t\t/// perform transformatio using i (c^(b|~d))\n\t\t/// </summary>\n\t\tprotected void TransI(ref uint a, uint b, uint c, uint d,uint k,ushort s, uint i )\n\t\t{\n\t\t\ta = b + MD5Helper.RotateLeft((a + (c^(b|~d))+ X[k] + T[i-1]), s);\n\t\t}\n\t\t\n\t\t\n\t\t\n\t\t/// <summary>\n\t\t/// Perform All the transformation on the data\n\t\t/// </summary>\n\t\t/// <param name=\"A\">A</param>\n\t\t/// <param name=\"B\">B </param>\n\t\t/// <param name=\"C\">C</param>\n\t\t/// <param name=\"D\">D</param>\n\t\tprotected void PerformTransformation(ref uint A,ref uint B,ref uint C, ref uint D)\n\t\t{\n\t\t\t//// saving  ABCD  to be used in end of loop\n\t\t\t\n\t\t\tuint AA,BB,CC,DD;\n\n\t\t\tAA=A;\t\n\t\t\tBB=B;\n\t\t\tCC=C;\n\t\t\tDD=D;\n\n\t\t\t/* Round 1 \n\t\t\t\t* [ABCD  0  7  1]  [DABC  1 12  2]  [CDAB  2 17  3]  [BCDA  3 22  4]\n\t\t\t\t* [ABCD  4  7  5]  [DABC  5 12  6]  [CDAB  6 17  7]  [BCDA  7 22  8]\n\t\t\t\t* [ABCD  8  7  9]  [DABC  9 12 10]  [CDAB 10 17 11]  [BCDA 11 22 12]\n\t\t\t\t* [ABCD 12  7 13]  [DABC 13 12 14]  [CDAB 14 17 15]  [BCDA 15 22 16]\n\t\t\t\t*  * */\n\t\t\tTransF(ref A,B,C,D,0,7,1);TransF(ref D,A,B,C,1,12,2);TransF(ref C,D,A,B,2,17,3);TransF(ref B,C,D,A,3,22,4);\n\t\t\tTransF(ref A,B,C,D,4,7,5);TransF(ref D,A,B,C,5,12,6);TransF(ref C,D,A,B,6,17,7);TransF(ref B,C,D,A,7,22,8);\n\t\t\tTransF(ref A,B,C,D,8,7,9);TransF(ref D,A,B,C,9,12,10);TransF(ref C,D,A,B,10,17,11);TransF(ref B,C,D,A,11,22,12);\n\t\t\tTransF(ref A,B,C,D,12,7,13);TransF(ref D,A,B,C,13,12,14);TransF(ref C,D,A,B,14,17,15);TransF(ref B,C,D,A,15,22,16);\n\t\t\t/** rOUND 2\n\t\t\t\t**[ABCD  1  5 17]  [DABC  6  9 18]  [CDAB 11 14 19]  [BCDA  0 20 20]\n\t\t\t\t*[ABCD  5  5 21]  [DABC 10  9 22]  [CDAB 15 14 23]  [BCDA  4 20 24]\n\t\t\t\t*[ABCD  9  5 25]  [DABC 14  9 26]  [CDAB  3 14 27]  [BCDA  8 20 28]\n\t\t\t\t*[ABCD 13  5 29]  [DABC  2  9 30]  [CDAB  7 14 31]  [BCDA 12 20 32]\n\t\t\t*/\n\t\t\tTransG(ref A,B,C,D,1,5,17);TransG(ref D,A,B,C,6,9,18);TransG(ref C,D,A,B,11,14,19);TransG(ref B,C,D,A,0,20,20);\n\t\t\tTransG(ref A,B,C,D,5,5,21);TransG(ref D,A,B,C,10,9,22);TransG(ref C,D,A,B,15,14,23);TransG(ref B,C,D,A,4,20,24);\n\t\t\tTransG(ref A,B,C,D,9,5,25);TransG(ref D,A,B,C,14,9,26);TransG(ref C,D,A,B,3,14,27);TransG(ref B,C,D,A,8,20,28);\n\t\t\tTransG(ref A,B,C,D,13,5,29);TransG(ref D,A,B,C,2,9,30);TransG(ref C,D,A,B,7,14,31);TransG(ref B,C,D,A,12,20,32);\n\t\t\t/*  rOUND 3\n\t\t\t\t* [ABCD  5  4 33]  [DABC  8 11 34]  [CDAB 11 16 35]  [BCDA 14 23 36]\n\t\t\t\t* [ABCD  1  4 37]  [DABC  4 11 38]  [CDAB  7 16 39]  [BCDA 10 23 40]\n\t\t\t\t* [ABCD 13  4 41]  [DABC  0 11 42]  [CDAB  3 16 43]  [BCDA  6 23 44]\n\t\t\t\t* [ABCD  9  4 45]  [DABC 12 11 46]  [CDAB 15 16 47]  [BCDA  2 23 48]\n\t\t\t * */\n\t\t\tTransH(ref A,B,C,D,5,4,33);TransH(ref D,A,B,C,8,11,34);TransH(ref C,D,A,B,11,16,35);TransH(ref B,C,D,A,14,23,36);\n\t\t\tTransH(ref A,B,C,D,1,4,37);TransH(ref D,A,B,C,4,11,38);TransH(ref C,D,A,B,7,16,39);TransH(ref B,C,D,A,10,23,40);\n\t\t\tTransH(ref A,B,C,D,13,4,41);TransH(ref D,A,B,C,0,11,42);TransH(ref C,D,A,B,3,16,43);TransH(ref B,C,D,A,6,23,44);\n\t\t\tTransH(ref A,B,C,D,9,4,45);TransH(ref D,A,B,C,12,11,46);TransH(ref C,D,A,B,15,16,47);TransH(ref B,C,D,A,2,23,48);\n\t\t\t/*ORUNF  4\n\t\t\t\t*[ABCD  0  6 49]  [DABC  7 10 50]  [CDAB 14 15 51]  [BCDA  5 21 52]\n\t\t\t\t*[ABCD 12  6 53]  [DABC  3 10 54]  [CDAB 10 15 55]  [BCDA  1 21 56]\n\t\t\t\t*[ABCD  8  6 57]  [DABC 15 10 58]  [CDAB  6 15 59]  [BCDA 13 21 60]\n\t\t\t\t*[ABCD  4  6 61]  [DABC 11 10 62]  [CDAB  2 15 63]  [BCDA  9 21 64]\n\t\t\t\t\t\t * */\n\t\t\tTransI(ref A,B,C,D,0,6,49);TransI(ref D,A,B,C,7,10,50);TransI(ref C,D,A,B,14,15,51);TransI(ref B,C,D,A,5,21,52);\n\t\t\tTransI(ref A,B,C,D,12,6,53);TransI(ref D,A,B,C,3,10,54);TransI(ref C,D,A,B,10,15,55);TransI(ref B,C,D,A,1,21,56);\n\t\t\tTransI(ref A,B,C,D,8,6,57);TransI(ref D,A,B,C,15,10,58);TransI(ref C,D,A,B,6,15,59);TransI(ref B,C,D,A,13,21,60);\n\t\t\tTransI(ref A,B,C,D,4,6,61);TransI(ref D,A,B,C,11,10,62);TransI(ref C,D,A,B,2,15,63);TransI(ref B,C,D,A,9,21,64);\n\n\n\t\t\tA=A+AA;\n\t\t\tB=B+BB;\n\t\t\tC=C+CC;\n\t\t\tD=D+DD;\n\n\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Create Padded buffer for processing , buffer is padded with 0 along \n\t\t/// with the size in the end\n\t\t/// </summary>\n\t\t/// <returns>the padded buffer as byte array</returns>\n\t\tprotected byte[] CreatePaddedBuffer()\n\t\t{\n\t\t\tuint pad;\t\t//no of padding bits for 448 mod 512 \n\t\t\tbyte [] bMsg;\t//buffer to hold bits\n\t\t\tulong sizeMsg;\t\t//64 bit size pad\n\t\t\tuint sizeMsgBuff;\t//buffer size in multiple of bytes\n\t\t\tint temp=(448-((m_byteInput.Length*8)%512)); //temporary \n\n\n\t\t\tpad = (uint )((temp+512)%512);\t\t//getting no of bits to  be pad\n\t\t\tif (pad==0)\t\t\t\t///pad is in bits\n\t\t\t\tpad=512;\t\t\t//at least 1 or max 512 can be added\n\n\t\t\tsizeMsgBuff= (uint) ((m_byteInput.Length)+ (pad/8)+8);\n\t\t\tsizeMsg=(ulong)m_byteInput.Length*8;\n\t\t\tbMsg=new byte[sizeMsgBuff];\t///no need to pad with 0 coz new bytes \n\t\t\t// are already initialize to 0\u00a0:)\n\n\n\n\n\t\t\t////copying string to buffer \n\t\t\tfor (int i =0; i<m_byteInput.Length;i++)\n\t\t\t\tbMsg[i]=m_byteInput[i];\n\n\t\t\tbMsg[m_byteInput.Length]|=0x80;\t\t///making first bit of padding 1,\n\t\t\t\n\t\t\t//wrting the size value\n\t\t\tfor (int i =8; i >0;i--)\n\t\t\t\tbMsg[sizeMsgBuff-i]=(byte) (sizeMsg>>((8-i)*8) & 0x00000000000000ff);\n\n\t\t\treturn bMsg;\n\t\t}\n\n\n\t\t/// <summary>\n\t\t/// Copies a 512 bit block into X as 16 32 bit words\n\t\t/// </summary>\n\t\t/// <param name=\"bMsg\"> source buffer</param>\n\t\t/// <param name=\"block\">no of block to copy starting from 0</param>\n\t\tprotected void CopyBlock(byte[] bMsg,uint block)\n\t\t{\n\n\t\t\tblock=block<<6;\n\t\t\tfor (uint j=0; j<61;j+=4)\n\t\t\t{\n\t\t\t\tX[j>>2]=(((uint) bMsg[block+(j+3)]) <<24 ) |\n\t\t\t\t\t\t(((uint) bMsg[block+(j+2)]) <<16 ) |\n\t\t\t\t\t\t(((uint) bMsg[block+(j+1)]) <<8 ) |\n\t\t\t\t\t\t(((uint) bMsg[block+(j)]) ) ;\n\t\t\t\n\t\t\t}\n\t\t}\n\t}\n\n\nSystem.Security.Cryptography.MD5CryptoServiceProvider x = new System.Security.Cryptography.MD5CryptoServiceProvider();\nbyte[] bs = System.Text.Encoding.UTF8.GetBytes(password);\nbs = x.ComputeHash(bs); //this function is not in the above classdefinition\nSystem.Text.StringBuilder s = new System.Text.StringBuilder();\nforeach (byte b in bs)\n{\n   s.Append(b.ToString(\"x2\").ToLower());\n} \npassword = s.ToString();\n\n", "explain": "Handwritten implementation ([1]):\nStandard library-based implementation:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"bytes\"\n    \"encoding/binary\"\n)\n\ntype testCase struct {\n    hashCode string\n    string\n}\n\nvar testCases = []testCase{\n    {\"d41d8cd98f00b204e9800998ecf8427e\", \"\"},\n    {\"0cc175b9c0f1b6a831c399e269772661\", \"a\"},\n    {\"900150983cd24fb0d6963f7d28e17f72\", \"abc\"},\n    {\"f96b697d7cb7938d525a2f31aaf161d0\", \"message digest\"},\n    {\"c3fcd3d76192e4007dfb496cca67e13b\", \"abcdefghijklmnopqrstuvwxyz\"},\n    {\"d174ab98d277d9f5a5611c2c9f419d9f\",\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"},\n    {\"57edf4a22be3c955ac49da2e2107b67a\", \"12345678901234567890\" +\n        \"123456789012345678901234567890123456789012345678901234567890\"},\n}\n\nfunc main() {\n    for _, tc := range testCases {\n        fmt.Printf(\"%s\\n%x\\n\\n\", tc.hashCode, md5(tc.string))\n    }\n}\n\nvar shift = [...]uint{7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21}\nvar table [64]uint32\n\nfunc init() {\n    for i := range table {\n        table[i] = uint32((1 << 32) * math.Abs(math.Sin(float64(i + 1))))\n    }\n}\n\nfunc md5(s string) (r [16]byte) {\n    padded := bytes.NewBuffer([]byte(s))\n    padded.WriteByte(0x80)\n    for padded.Len() % 64 != 56 {\n        padded.WriteByte(0)\n    }\n    messageLenBits := uint64(len(s)) * 8\n    binary.Write(padded, binary.LittleEndian, messageLenBits)\n\n    var a, b, c, d uint32 = 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476\n    var buffer [16]uint32\n    for binary.Read(padded, binary.LittleEndian, buffer[:]) == nil { // read every 64 bytes\n        a1, b1, c1, d1 := a, b, c, d\n        for j := 0; j < 64; j++ {\n            var f uint32\n            bufferIndex := j\n            round := j >> 4\n            switch round {\n            case 0:\n                f = (b1 & c1) | (^b1 & d1)\n            case 1:\n                f = (b1 & d1) | (c1 & ^d1)\n                bufferIndex = (bufferIndex*5 + 1) & 0x0F\n            case 2:\n                f = b1 ^ c1 ^ d1\n                bufferIndex = (bufferIndex*3 + 5) & 0x0F\n            case 3:\n                f = c1 ^ (b1 | ^d1)\n                bufferIndex = (bufferIndex * 7) & 0x0F\n            }\n            sa := shift[(round<<2)|(j&3)]\n            a1 += f + buffer[bufferIndex] + table[j]\n            a1, d1, c1, b1 = d1, c1, b1, a1<<sa|a1>>(32-sa)+b1\n        }\n        a, b, c, d = a+a1, b+b1, c+c1, d+d1\n    }\n\n    binary.Write(bytes.NewBuffer(r[:0]), binary.LittleEndian, []uint32{a, b, c, d})\n    return\n}\n\n\nd41d8cd98f00b204e9800998ecf8427e\nd41d8cd98f00b204e9800998ecf8427e\n\n0cc175b9c0f1b6a831c399e269772661\n0cc175b9c0f1b6a831c399e269772661\n\n900150983cd24fb0d6963f7d28e17f72\n900150983cd24fb0d6963f7d28e17f72\n\nf96b697d7cb7938d525a2f31aaf161d0\nf96b697d7cb7938d525a2f31aaf161d0\n\nc3fcd3d76192e4007dfb496cca67e13b\nc3fcd3d76192e4007dfb496cca67e13b\n\nd174ab98d277d9f5a5611c2c9f419d9f\nd174ab98d277d9f5a5611c2c9f419d9f\n\n57edf4a22be3c955ac49da2e2107b67a\n57edf4a22be3c955ac49da2e2107b67a\n\n", "explain": "A limitation from RFC 1321 is that the function md5 takes a string which is a number of whole bytes.  Messages of arbitrary bit length are not supported.\nOutput:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  System.Classes\nTranslation of: Go\nprogram MD5Implementation;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  System.Classes;\n\ntype\n  TTestCase = record\n    hashCode: string;\n    _: string;\n  end;\n\nvar\n  testCases: array[0..6] of TTestCase = ((\n    hashCode: 'D41D8CD98F00B204E9800998ECF8427E';\n    _: ''\n  ), (\n    hashCode: '0CC175B9C0F1B6A831C399E269772661';\n    _: 'a'\n  ), (\n    hashCode: '900150983CD24FB0D6963F7D28E17F72';\n    _: 'abc'\n  ), (\n    hashCode: 'F96B697D7CB7938D525A2F31AAF161D0';\n    _: 'message digest'\n  ), (\n    hashCode: 'C3FCD3D76192E4007DFB496CCA67E13B';\n    _: 'abcdefghijklmnopqrstuvwxyz'\n  ), (\n    hashCode: 'D174AB98D277D9F5A5611C2C9F419D9F';\n    _: 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'\n  ), (\n    hashCode: '57EDF4A22BE3C955AC49DA2E2107B67A';\n    _: '12345678901234567890123456789' + '012345678901234567890123456789012345678901234567890'\n  ));\n  shift: array of UInt32 = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21];\n  table: array[0..63] of UInt32;\n\nprocedure Init();\nvar\n  i: integer;\n\n  function fAbs(x: Extended): Extended;\n  begin\n    if x < 0 then\n      exit(-x);\n    exit(x);\n  end;\n\nbegin\n  for i := 0 to High(table) do\n    table[i] := Trunc((UInt64(1) shl 32) * fAbs(Sin(i + 1.0)));\nend;\n\nfunction Md5(s: string): TBytes;\nconst\n  BUFFER_SIZE = 16;\nvar\n  binary: TBytesStream;\n  buffer: Tarray<UInt32>;\n  messageLenBits: UInt64;\n  i, j, bufferIndex, count: integer;\n  byte_data: byte;\n  string_data: ansistring;\n  k, k1: Tarray<UInt32>;\n  f, rnd, sa: UInt32;\n  tmp: UInt64;\nbegin\n  k := [$67452301, $EFCDAB89, $98BADCFE, $10325476];\n\n  binary := TBytesStream.Create();\n\n  if not s.IsEmpty then\n  begin\n    string_data := Utf8ToAnsi(s);\n    binary.Write(Tbytes(string_data), length(string_data));\n  end;\n\n  byte_data := $80;\n  binary.Write(byte_data, 1);\n\n  messageLenBits := UInt64(s.Length * 8);\n  count := s.Length + 1;\n\n  while (count mod 64) <> 56 do\n  begin\n    byte_data := $00;\n    binary.Write(byte_data, 1);\n    inc(count);\n  end;\n\n  binary.Write(messageLenBits, sizeof(messageLenBits));\n\n  SetLength(buffer, BUFFER_SIZE);\n  SetLength(k1, length(k));\n\n  binary.Seek(0, soFromBeginning);\n\n  while binary.Read(buffer[0], BUFFER_SIZE * 4) > 0 do\n  begin\n    for i := 0 to 3 do\n      k1[i] := k[i];\n\n    for i := 0 to 63 do\n    begin\n      f := 0;\n      bufferIndex := i;\n      rnd := i shr 4;\n      case rnd of\n        0:\n          f := (k1[1] and k1[2]) or (not k1[1] and k1[3]);\n        1:\n          begin\n            f := (k1[1] and k1[3]) or (k1[2] and not k1[3]);\n            bufferIndex := (bufferIndex * 5 + 1) and $0F\n          end;\n        2:\n          begin\n            f := k1[1] xor k1[2] xor k1[3];\n            bufferIndex := (bufferIndex * 3 + 5) and $0F;\n          end;\n        3:\n          begin\n            f := k1[2] xor (k1[1] or not k1[3]);\n            bufferIndex := (bufferIndex * 7) and $0F;\n          end;\n      end;\n\n      sa := shift[(rnd shl 2) or (i and 3)];\n\n      k1[0] := k1[0] + f + buffer[bufferIndex] + table[i];\n\n      tmp := k1[0];\n\n      k1[0] := k1[3];\n      k1[3] := k1[2];\n      k1[2] := k1[1];\n\n      k1[1] := ((tmp shl sa) or (tmp shr (32 - sa))) + k1[1];\n    end;\n\n    for i := 0 to 3 do\n      k[i] := k[i] + k1[i];\n  end;\n\n  SetLength(result, BUFFER_SIZE);\n\n  binary.Clear;\n  for i := 0 to 3 do\n    binary.Write(k[i], 4);\n\n  binary.Seek(0, soBeginning);\n\n  binary.Read(Result, BUFFER_SIZE);\n\n  binary.Free;\nend;\n\nfunction BytesToString(b: TBytes): string;\nvar\n  v: byte;\nbegin\n  Result := '';\n  for v in b do\n    Result := Result + v.ToHexString(2);\nend;\n\nvar\n  tc: TTestCase;\n\nbegin\n  Init;\n\n  for tc in testCases do\n    Writeln(Format('%s'#10'%s'#10, [tc.hashCode, BytesToString(md5(tc._))]));\n  Readln;\nend.\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Rust", "code": "\n\n#![allow(non_snake_case)] // RFC 1321 uses many capitalized variables\nuse std::mem;\n\nfn md5(mut msg: Vec<u8>) -> (u32, u32, u32, u32) {\n    let bitcount = msg.len().saturating_mul(8) as u64;\n\n    // Step 1: Append Padding Bits\n    msg.push(0b10000000);\n    while (msg.len() * 8) % 512 != 448 {\n        msg.push(0u8);\n    }\n\n    // Step 2. Append Length  (64 bit integer)\n    msg.extend(&[\n        bitcount as u8,\n        (bitcount >> 8) as u8,\n        (bitcount >> 16) as u8,\n        (bitcount >> 24) as u8,\n        (bitcount >> 32) as u8,\n        (bitcount >> 40) as u8,\n        (bitcount >> 48) as u8,\n        (bitcount >> 56) as u8,\n    ]);\n\n    // Step 3. Initialize MD Buffer\n    /*A four-word buffer (A,B,C,D) is used to compute the message digest.\n    Here each of A, B, C, D is a 32-bit register.*/\n    let mut A = 0x67452301u32;\n    let mut B = 0xefcdab89u32;\n    let mut C = 0x98badcfeu32;\n    let mut D = 0x10325476u32;\n\n    // Step 4. Process Message in 16-Word Blocks\n    /* We first define four auxiliary functions */\n    let F = |X: u32, Y: u32, Z: u32| -> u32 { X & Y | !X & Z };\n    let G = |X: u32, Y: u32, Z: u32| -> u32 { X & Z | Y & !Z };\n    let H = |X: u32, Y: u32, Z: u32| -> u32 { X ^ Y ^ Z };\n    let I = |X: u32, Y: u32, Z: u32| -> u32 { Y ^ (X | !Z) };\n\n    /* This step uses a 64-element table T[1 ... 64] constructed from the sine function.  */\n    let T = [\n        0x00000000, // enable use as a 1-indexed table\n        0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf, 0x4787c62a, 0xa8304613,\n        0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be, 0x6b901122, 0xfd987193,\n        0xa679438e, 0x49b40821, 0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d,\n        0x02441453, 0xd8a1e681, 0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n        0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,\n        0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6, 0xeaa127fa,\n        0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665, 0xf4292244,\n        0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n        0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb,\n        0xeb86d391,\n    ];\n\n    /* Process each 16-word block. (since 1 word is 4 bytes, then 16 words is 64 bytes) */\n    for mut block in msg.chunks_exact_mut(64) {\n        /* Copy block into X. */\n        #![allow(unused_mut)]\n        let mut X = unsafe { mem::transmute::<&mut [u8], &mut [u32]>(&mut block) };\n        #[cfg(target_endian = \"big\")]\n        for j in 0..16 {\n            X[j] = X[j].swap_bytes();\n        }\n\n        /* Save Registers A,B,C,D */\n        let AA = A;\n        let BB = B;\n        let CC = C;\n        let DD = D;\n\n        /* Round 1.  Let [abcd k s i] denote the operation\n        a = b + ((a + F(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op1 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(F($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op1!(A, B, C, D, 0, 7, 1);\n        op1!(D, A, B, C, 1, 12, 2);\n        op1!(C, D, A, B, 2, 17, 3);\n        op1!(B, C, D, A, 3, 22, 4);\n\n        op1!(A, B, C, D, 4, 7, 5);\n        op1!(D, A, B, C, 5, 12, 6);\n        op1!(C, D, A, B, 6, 17, 7);\n        op1!(B, C, D, A, 7, 22, 8);\n\n        op1!(A, B, C, D, 8, 7, 9);\n        op1!(D, A, B, C, 9, 12, 10);\n        op1!(C, D, A, B, 10, 17, 11);\n        op1!(B, C, D, A, 11, 22, 12);\n\n        op1!(A, B, C, D, 12, 7, 13);\n        op1!(D, A, B, C, 13, 12, 14);\n        op1!(C, D, A, B, 14, 17, 15);\n        op1!(B, C, D, A, 15, 22, 16);\n\n        /* Round 2. Let [abcd k s i] denote the operation\n        a = b + ((a + G(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op2 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(G($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op2!(A, B, C, D, 1, 5, 17);\n        op2!(D, A, B, C, 6, 9, 18);\n        op2!(C, D, A, B, 11, 14, 19);\n        op2!(B, C, D, A, 0, 20, 20);\n\n        op2!(A, B, C, D, 5, 5, 21);\n        op2!(D, A, B, C, 10, 9, 22);\n        op2!(C, D, A, B, 15, 14, 23);\n        op2!(B, C, D, A, 4, 20, 24);\n\n        op2!(A, B, C, D, 9, 5, 25);\n        op2!(D, A, B, C, 14, 9, 26);\n        op2!(C, D, A, B, 3, 14, 27);\n        op2!(B, C, D, A, 8, 20, 28);\n\n        op2!(A, B, C, D, 13, 5, 29);\n        op2!(D, A, B, C, 2, 9, 30);\n        op2!(C, D, A, B, 7, 14, 31);\n        op2!(B, C, D, A, 12, 20, 32);\n\n        /* Round 3. Let [abcd k s t] denote the operation\n        a = b + ((a + H(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op3 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(H($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op3!(A, B, C, D, 5, 4, 33);\n        op3!(D, A, B, C, 8, 11, 34);\n        op3!(C, D, A, B, 11, 16, 35);\n        op3!(B, C, D, A, 14, 23, 36);\n\n        op3!(A, B, C, D, 1, 4, 37);\n        op3!(D, A, B, C, 4, 11, 38);\n        op3!(C, D, A, B, 7, 16, 39);\n        op3!(B, C, D, A, 10, 23, 40);\n\n        op3!(A, B, C, D, 13, 4, 41);\n        op3!(D, A, B, C, 0, 11, 42);\n        op3!(C, D, A, B, 3, 16, 43);\n        op3!(B, C, D, A, 6, 23, 44);\n\n        op3!(A, B, C, D, 9, 4, 45);\n        op3!(D, A, B, C, 12, 11, 46);\n        op3!(C, D, A, B, 15, 16, 47);\n        op3!(B, C, D, A, 2, 23, 48);\n\n        /* Round 4. Let [abcd k s t] denote the operation\n        a = b + ((a + I(b,c,d) + X[k] + T[i]) <<< s). */\n        macro_rules! op4 {\n            ($a:ident,$b:ident,$c:ident,$d:ident,$k:expr,$s:expr,$i:expr) => {\n                $a = $b.wrapping_add(\n                    ($a.wrapping_add(I($b, $c, $d))\n                        .wrapping_add(X[$k])\n                        .wrapping_add(T[$i]))\n                    .rotate_left($s),\n                )\n            };\n        }\n\n        /* Do the following 16 operations. */\n        op4!(A, B, C, D, 0, 6, 49);\n        op4!(D, A, B, C, 7, 10, 50);\n        op4!(C, D, A, B, 14, 15, 51);\n        op4!(B, C, D, A, 5, 21, 52);\n\n        op4!(A, B, C, D, 12, 6, 53);\n        op4!(D, A, B, C, 3, 10, 54);\n        op4!(C, D, A, B, 10, 15, 55);\n        op4!(B, C, D, A, 1, 21, 56);\n\n        op4!(A, B, C, D, 8, 6, 57);\n        op4!(D, A, B, C, 15, 10, 58);\n        op4!(C, D, A, B, 6, 15, 59);\n        op4!(B, C, D, A, 13, 21, 60);\n\n        op4!(A, B, C, D, 4, 6, 61);\n        op4!(D, A, B, C, 11, 10, 62);\n        op4!(C, D, A, B, 2, 15, 63);\n        op4!(B, C, D, A, 9, 21, 64);\n\n        /* . . . increment each of the four registers by the value \n        it had before this block was started.) */\n\n        A = A.wrapping_add(AA);\n        B = B.wrapping_add(BB);\n        C = C.wrapping_add(CC);\n        D = D.wrapping_add(DD);\n    }\n    (\n        A.swap_bytes(),\n        B.swap_bytes(),\n        C.swap_bytes(),\n        D.swap_bytes(),\n    )\n}\n\nfn md5_utf8(smsg: &str) -> String {\n    let mut msg = vec![0u8; 0];\n    msg.extend(smsg.as_bytes());\n    let (A, B, C, D) = md5(msg);\n    format!(\"{:08x}{:08x}{:08x}{:08x}\", A, B, C, D)\n}\n\nfn main() {\n    assert!(md5_utf8(\"\") == \"d41d8cd98f00b204e9800998ecf8427e\");\n    assert!(md5_utf8(\"a\") == \"0cc175b9c0f1b6a831c399e269772661\");\n    assert!(md5_utf8(\"abc\") == \"900150983cd24fb0d6963f7d28e17f72\");\n    assert!(md5_utf8(\"message digest\") == \"f96b697d7cb7938d525a2f31aaf161d0\");\n    assert!(md5_utf8(\"abcdefghijklmnopqrstuvwxyz\") == \"c3fcd3d76192e4007dfb496cca67e13b\");\n    assert!(md5_utf8(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\") == \"d174ab98d277d9f5a5611c2c9f419d9f\");\n    assert!(md5_utf8(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\") == \"57edf4a22be3c955ac49da2e2107b67a\");\n}\n\n", "explain": "A translation of RFC (1321), to highlight the algorithm itself in bare form. Notable Rust features are the strict limits on casting,  explicit description of bit-widths and wrap-around operations, and macros for the Rounds. This made it easy to translate and debug, although a bit 'wordy' in sections, and requiring special code to transliterate between strings and integers.\nReasonable speed was desired; Profiling revealed the \"copy block to X\" loop as hot. This loops casts arrays of 8 bit integers into 32 bit integers, which Rust does very slowly in 'safe' code, so an unsafe transmute, and, on big-endian machines a byteswap, was used. Runtime is 120-150% slower than standard linux /usr/bin/md5sum.\nAs with others implementations, this will not allow bit-lengths non-divisible by 8; this ability can be added in about 8 lines of code but no examples appear to be available for verification of correctness, and so it was elided.\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Swift", "code": "\n\n    import Foundation\n    public class MD5 {\n        /** specifies the per-round shift amounts */\n        private let s: [UInt32] = [7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,\n                           5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,\n                           4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,\n                           6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21]\n        \n        /** binary integer part of the sines of integers (Radians) */\n        private let K: [UInt32] = (0 ..< 64).map { UInt32(0x100000000 * abs(sin(Double($0 + 1)))) }\n        \n        let a0: UInt32 = 0x67452301\n        let b0: UInt32 = 0xefcdab89\n        let c0: UInt32 = 0x98badcfe\n        let d0: UInt32 = 0x10325476\n        \n        private var message: NSData\n        \n        //MARK: Public\n        \n        public init(_ message: NSData) {\n            self.message = message\n        }\n        \n        public func calculate() -> NSData? {\n            var tmpMessage: NSMutableData = NSMutableData(data: message)\n            let wordSize = sizeof(UInt32)\n            \n            var aa = a0\n            var bb = b0\n            var cc = c0\n            var dd = d0\n            \n            // Step 1. Append Padding Bits\n            tmpMessage.appendBytes([0x80]) // append one bit (Byte with one bit) to message\n            \n            // append \"0\" bit until message length in bits \u2261 448 (mod 512)\n            while tmpMessage.length % 64 != 56 {\n                tmpMessage.appendBytes([0x00])\n            }\n            \n            // Step 2. Append Length a 64-bit representation of lengthInBits\n            var lengthInBits = (message.length * 8)\n            var lengthBytes = lengthInBits.bytes(64 / 8)\n            tmpMessage.appendBytes(reverse(lengthBytes));\n            \n            // Process the message in successive 512-bit chunks:\n            let chunkSizeBytes = 512 / 8\n            var leftMessageBytes = tmpMessage.length\n            for var i = 0; i < tmpMessage.length; i = i + chunkSizeBytes, leftMessageBytes -= chunkSizeBytes {\n                let chunk = tmpMessage.subdataWithRange(NSRange(location: i, length: min(chunkSizeBytes,leftMessageBytes)))\n                \n                // break chunk into sixteen 32-bit words M[j], 0 \u2264 j \u2264 15\n                // println(\"wordSize \\(wordSize)\");\n                var M:[UInt32] = [UInt32](count: 16, repeatedValue: 0)\n                for x in 0..<M.count {\n                    var range = NSRange(location:x * wordSize, length: wordSize)\n                    chunk.getBytes(&M[x], range:range);\n                }\n                \n                // Initialize hash value for this chunk:\n                var A:UInt32 = a0\n                var B:UInt32 = b0\n                var C:UInt32 = c0\n                var D:UInt32 = d0\n                \n                var dTemp:UInt32 = 0\n                \n                // Main loop\n                for j in 0...63 {\n                    var g = 0\n                    var F:UInt32 = 0\n                    \n                    switch (j) {\n                    case 0...15:\n                        F = (B & C) | ((~B) & D)\n                        g = j\n                        break\n                    case 16...31:\n                        F = (D & B) | (~D & C)\n                        g = (5 * j + 1) % 16\n                        break\n                    case 32...47:\n                        F = B ^ C ^ D\n                        g = (3 * j + 5) % 16\n                        break\n                    case 48...63:\n                        F = C ^ (B | (~D))\n                        g = (7 * j) % 16\n                        break\n                    default:\n                        break\n                    }\n                    dTemp = D\n                    D = C\n                    C = B\n                    B = B &+ rotateLeft((A &+ F &+ K[j] &+ M[g]), s[j])\n                    A = dTemp    \n                }\n                \n                aa = aa &+ A\n                bb = bb &+ B\n                cc = cc &+ C\n                dd = dd &+ D\n            }\n\n            var buf: NSMutableData = NSMutableData();\n            buf.appendBytes(&aa, length: wordSize)\n            buf.appendBytes(&bb, length: wordSize)\n            buf.appendBytes(&cc, length: wordSize)\n            buf.appendBytes(&dd, length: wordSize)\n            \n            return buf.copy() as? NSData;\n        }\n\n        //MARK: Class\n        class func calculate(message: NSData) -> NSData?\n        {\n            return MD5(message).calculate();\n        }\n        \n        //MARK: Private\n        private func rotateLeft(x:UInt32, _ n:UInt32) -> UInt32 {\n            return (x &<< n) | (x &>> (32 - n))\n        }\n    }\n\n\nimport Foundation\n\nlet shift : [UInt32] = [7, 12, 17, 22, 5, 9, 14, 20, 4, 11, 16, 23, 6, 10, 15, 21]\nlet table: [UInt32] = (0 ..< 64).map { UInt32(0x100000000 * abs(sin(Double($0 + 1)))) }\n\nfunc md5(var message: [UInt8]) -> [UInt8] {\n  var messageLenBits = UInt64(message.count) * 8\n  message.append(0x80)\n  while message.count % 64 != 56 {\n    message.append(0)\n  }\n  \n  var lengthBytes = [UInt8](count: 8, repeatedValue: 0)\n  UnsafeMutablePointer<UInt64>(lengthBytes).memory = messageLenBits.littleEndian\n  message += lengthBytes\n  \n  var a : UInt32 = 0x67452301\n  var b : UInt32 = 0xEFCDAB89\n  var c : UInt32 = 0x98BADCFE\n  var d : UInt32 = 0x10325476\n  for chunkOffset in stride(from: 0, to: message.count, by: 64) {\n    let chunk = UnsafePointer<UInt32>(UnsafePointer<UInt8>(message) + chunkOffset)\n    let originalA = a\n    let originalB = b\n    let originalC = c\n    let originalD = d\n    for j in 0 ..< 64 {\n      var f : UInt32 = 0\n      var bufferIndex = j\n      let round = j >> 4\n      switch round {\n      case 0:\n        f = (b & c) | (~b & d)\n      case 1:\n        f = (b & d) | (c & ~d)\n        bufferIndex = (bufferIndex*5 + 1) & 0x0F\n      case 2:\n        f = b ^ c ^ d\n        bufferIndex = (bufferIndex*3 + 5) & 0x0F\n      case 3:\n        f = c ^ (b | ~d)\n        bufferIndex = (bufferIndex * 7) & 0x0F\n      default:\n        assert(false)\n      }\n      let sa = shift[(round<<2)|(j&3)]\n      let tmp = a &+ f &+ UInt32(littleEndian: chunk[bufferIndex]) &+ table[j]\n      a = d\n      d = c\n      c = b\n      b = b &+ (tmp << sa | tmp >> (32-sa))\n    }\n    a = a &+ originalA\n    b = b &+ originalB\n    c = c &+ originalC\n    d = d &+ originalD\n  }\n  \n  var result = [UInt8](count: 16, repeatedValue: 0)\n  for (i, n) in enumerate([a, b, c, d]) {\n    UnsafeMutablePointer<UInt32>(result)[i] = n.littleEndian\n  }\n  return result\n}\n\nfunc toHexString(bytes: [UInt8]) -> String {\n  return \"\".join(bytes.map { String(format:\"%02x\", $0) })\n}\n\nfor (hashCode, string) in [\n  (\"d41d8cd98f00b204e9800998ecf8427e\", \"\"),\n  (\"0cc175b9c0f1b6a831c399e269772661\", \"a\"),\n  (\"900150983cd24fb0d6963f7d28e17f72\", \"abc\"),\n  (\"f96b697d7cb7938d525a2f31aaf161d0\", \"message digest\"),\n  (\"c3fcd3d76192e4007dfb496cca67e13b\", \"abcdefghijklmnopqrstuvwxyz\"),\n  (\"d174ab98d277d9f5a5611c2c9f419d9f\",\n    \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n  (\"57edf4a22be3c955ac49da2e2107b67a\", \"12345678901234567890\" +\n    \"123456789012345678901234567890123456789012345678901234567890\")] {\n      println(hashCode)\n      println(toHexString(md5(Array(string.utf8))))\n      println()\n}\n\n\nOutput:\nd41d8cd98f00b204e9800998ecf8427e\nd41d8cd98f00b204e9800998ecf8427e\n\n0cc175b9c0f1b6a831c399e269772661\n0cc175b9c0f1b6a831c399e269772661\n\n900150983cd24fb0d6963f7d28e17f72\n900150983cd24fb0d6963f7d28e17f72\n\nf96b697d7cb7938d525a2f31aaf161d0\nf96b697d7cb7938d525a2f31aaf161d0\n\nc3fcd3d76192e4007dfb496cca67e13b\nc3fcd3d76192e4007dfb496cca67e13b\n\nd174ab98d277d9f5a5611c2c9f419d9f\nd174ab98d277d9f5a5611c2c9f419d9f\n\n57edf4a22be3c955ac49da2e2107b67a\n57edf4a22be3c955ac49da2e2107b67a\n\n", "explain": "Swift implementation of the pseudo-code found in the Wikipedia article.\nOriginal source: CryptoSwift\nFrom-scratch implementation based on the solutions on this page without needing any external libraries:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Ada", "code": "\n\npackage MD5 is\n\n   type Int32 is mod 2 ** 32;\n   type MD5_Hash is array (1 .. 4) of Int32;\n   function MD5 (Input : String) return MD5_Hash;\n\n   -- 32 hexadecimal characters + '0x' prefix\n   subtype MD5_String is String (1 .. 34);\n   function To_String (Item : MD5_Hash) return MD5_String;\n\nend MD5;\n\n\nwith Ada.Unchecked_Conversion;\n\npackage body MD5 is\n   type Int32_Array is array (Positive range <>) of Int32;\n\n   function Rotate_Left (Value : Int32; Count : Int32) return Int32 is\n      Bit    : Boolean;\n      Result : Int32 := Value;\n   begin\n      for I in 1 .. Count loop\n         Bit    := (2 ** 31 and Result) = 2 ** 31;\n         Result := Result * 2;\n         if Bit then\n            Result := Result + 1;\n         end if;\n      end loop;\n      return Result;\n   end Rotate_Left;\n\n   function Pad_String (Item : String) return Int32_Array is\n      -- always pad positive amount of Bytes\n      Padding_Bytes : Positive := 64 - Item'Length mod 64;\n      subtype String4 is String (1 .. 4);\n      function String4_To_Int32 is new Ada.Unchecked_Conversion\n        (Source => String4,\n         Target => Int32);\n   begin\n      if Padding_Bytes <= 2 then\n         Padding_Bytes := Padding_Bytes + 64;\n      end if;\n      declare\n         Result        : Int32_Array (1 .. (Item'Length + Padding_Bytes) / 4);\n         Current_Index : Positive := 1;\n      begin\n         for I in 1 .. Item'Length / 4 loop\n            Result (I)    :=\n              String4_To_Int32 (Item (4 * (I - 1) + 1 .. 4 * I));\n            Current_Index := Current_Index + 1;\n         end loop;\n\n         declare\n            Last_String : String4          := (others => Character'Val (0));\n            Chars_Left  : constant Natural := Item'Length mod 4;\n         begin\n            Last_String (1 .. Chars_Left) :=\n              Item (Item'Last - Chars_Left + 1 .. Item'Last);\n            Last_String (Chars_Left + 1)  := Character'Val (2#1000_0000#);\n            Result (Current_Index)        := String4_To_Int32 (Last_String);\n            Current_Index                 := Current_Index + 1;\n         end;\n\n         Result (Current_Index .. Result'Last) := (others => 0);\n         -- append length as bit count\n         Result (Result'Last - 1) := Item'Length * 2 ** 3; -- mod 2 ** 32;\n         Result (Result'Last)     := Item'Length / 2 ** (32 - 3);\n         return Result;\n      end;\n   end Pad_String;\n\n   function Turn_Around (X : Int32) return Int32 is\n      Result : Int32 := 0;\n   begin\n      for Byte in 1 .. 4 loop\n         Result := Result * 16#100#;\n         Result := Result + (X / (2 ** (8 * (Byte - 1)))) mod 16#100#;\n      end loop;\n      return Result;\n   end Turn_Around;\n\n   function MD5 (Input : String) return MD5_Hash is\n      function F (X, Y, Z : Int32) return Int32 is\n      begin\n         return Z xor (X and (Y xor Z));\n      end F;\n      function G (X, Y, Z : Int32) return Int32 is\n      begin\n         return (X and Z) or (Y and (not Z));\n      end G;\n      function H (X, Y, Z : Int32) return Int32 is\n      begin\n         return X xor Y xor Z;\n      end H;\n      function I (X, Y, Z : Int32) return Int32 is\n      begin\n         return Y xor (X or (not Z));\n      end I;\n      T  : constant Int32_Array :=\n        (16#d76aa478#, 16#e8c7b756#, 16#242070db#, 16#c1bdceee#,\n         16#f57c0faf#, 16#4787c62a#, 16#a8304613#, 16#fd469501#,\n         16#698098d8#, 16#8b44f7af#, 16#ffff5bb1#, 16#895cd7be#,\n         16#6b901122#, 16#fd987193#, 16#a679438e#, 16#49b40821#,\n         16#f61e2562#, 16#c040b340#, 16#265e5a51#, 16#e9b6c7aa#,\n         16#d62f105d#, 16#02441453#, 16#d8a1e681#, 16#e7d3fbc8#,\n         16#21e1cde6#, 16#c33707d6#, 16#f4d50d87#, 16#455a14ed#,\n         16#a9e3e905#, 16#fcefa3f8#, 16#676f02d9#, 16#8d2a4c8a#,\n         16#fffa3942#, 16#8771f681#, 16#6d9d6122#, 16#fde5380c#,\n         16#a4beea44#, 16#4bdecfa9#, 16#f6bb4b60#, 16#bebfbc70#,\n         16#289b7ec6#, 16#eaa127fa#, 16#d4ef3085#, 16#04881d05#,\n         16#d9d4d039#, 16#e6db99e5#, 16#1fa27cf8#, 16#c4ac5665#,\n         16#f4292244#, 16#432aff97#, 16#ab9423a7#, 16#fc93a039#,\n         16#655b59c3#, 16#8f0ccc92#, 16#ffeff47d#, 16#85845dd1#,\n         16#6fa87e4f#, 16#fe2ce6e0#, 16#a3014314#, 16#4e0811a1#,\n         16#f7537e82#, 16#bd3af235#, 16#2ad7d2bb#, 16#eb86d391#);\n      A : Int32 := 16#67452301#;\n      B : Int32 := 16#EFCDAB89#;\n      C : Int32 := 16#98BADCFE#;\n      D : Int32 := 16#10325476#;\n      Padded_String : constant Int32_Array := Pad_String (Input);\n   begin\n      for Block512 in 1 .. Padded_String'Length / 16 loop\n         declare\n            Words    : constant Int32_Array (1 .. 16) :=\n              Padded_String (16 * (Block512 - 1) + 1 .. 16 * Block512);\n            AA       : constant Int32                 := A;\n            BB       : constant Int32                 := B;\n            CC       : constant Int32                 := C;\n            DD       : constant Int32                 := D;\n         begin\n            -- round 1\n            A := B + Rotate_Left ((A + F (B, C, D) + Words (1) + T (1)),  7);\n            D := A + Rotate_Left ((D + F (A, B, C) + Words (2) + T (2)), 12);\n            C := D + Rotate_Left ((C + F (D, A, B) + Words (3) + T (3)), 17);\n            B := C + Rotate_Left ((B + F (C, D, A) + Words (4) + T (4)), 22);\n            A := B + Rotate_Left ((A + F (B, C, D) + Words (5) + T (5)),  7);\n            D := A + Rotate_Left ((D + F (A, B, C) + Words (6) + T (6)), 12);\n            C := D + Rotate_Left ((C + F (D, A, B) + Words (7) + T (7)), 17);\n            B := C + Rotate_Left ((B + F (C, D, A) + Words (8) + T (8)), 22);\n            A := B + Rotate_Left ((A + F (B, C, D) + Words (9) + T (9)),  7);\n            D := A + Rotate_Left ((D + F (A, B, C) + Words (10) + T (10)), 12);\n            C := D + Rotate_Left ((C + F (D, A, B) + Words (11) + T (11)), 17);\n            B := C + Rotate_Left ((B + F (C, D, A) + Words (12) + T (12)), 22);\n            A := B + Rotate_Left ((A + F (B, C, D) + Words (13) + T (13)),  7);\n            D := A + Rotate_Left ((D + F (A, B, C) + Words (14) + T (14)), 12);\n            C := D + Rotate_Left ((C + F (D, A, B) + Words (15) + T (15)), 17);\n            B := C + Rotate_Left ((B + F (C, D, A) + Words (16) + T (16)), 22);\n            -- round 2\n            A := B + Rotate_Left ((A + G (B, C, D) + Words (2) + T (17)),  5);\n            D := A + Rotate_Left ((D + G (A, B, C) + Words (7) + T (18)),  9);\n            C := D + Rotate_Left ((C + G (D, A, B) + Words (12) + T (19)), 14);\n            B := C + Rotate_Left ((B + G (C, D, A) + Words (1) + T (20)), 20);\n            A := B + Rotate_Left ((A + G (B, C, D) + Words (6) + T (21)),  5);\n            D := A + Rotate_Left ((D + G (A, B, C) + Words (11) + T (22)),  9);\n            C := D + Rotate_Left ((C + G (D, A, B) + Words (16) + T (23)), 14);\n            B := C + Rotate_Left ((B + G (C, D, A) + Words (5) + T (24)), 20);\n            A := B + Rotate_Left ((A + G (B, C, D) + Words (10) + T (25)),  5);\n            D := A + Rotate_Left ((D + G (A, B, C) + Words (15) + T (26)),  9);\n            C := D + Rotate_Left ((C + G (D, A, B) + Words (4) + T (27)), 14);\n            B := C + Rotate_Left ((B + G (C, D, A) + Words (9) + T (28)), 20);\n            A := B + Rotate_Left ((A + G (B, C, D) + Words (14) + T (29)),  5);\n            D := A + Rotate_Left ((D + G (A, B, C) + Words (3) + T (30)),  9);\n            C := D + Rotate_Left ((C + G (D, A, B) + Words (8) + T (31)), 14);\n            B := C + Rotate_Left ((B + G (C, D, A) + Words (13) + T (32)), 20);\n            -- round 3\n            A := B + Rotate_Left ((A + H (B, C, D) + Words (6) + T (33)),  4);\n            D := A + Rotate_Left ((D + H (A, B, C) + Words (9) + T (34)), 11);\n            C := D + Rotate_Left ((C + H (D, A, B) + Words (12) + T (35)), 16);\n            B := C + Rotate_Left ((B + H (C, D, A) + Words (15) + T (36)), 23);\n            A := B + Rotate_Left ((A + H (B, C, D) + Words (2) + T (37)),  4);\n            D := A + Rotate_Left ((D + H (A, B, C) + Words (5) + T (38)), 11);\n            C := D + Rotate_Left ((C + H (D, A, B) + Words (8) + T (39)), 16);\n            B := C + Rotate_Left ((B + H (C, D, A) + Words (11) + T (40)), 23);\n            A := B + Rotate_Left ((A + H (B, C, D) + Words (14) + T (41)),  4);\n            D := A + Rotate_Left ((D + H (A, B, C) + Words (1) + T (42)), 11);\n            C := D + Rotate_Left ((C + H (D, A, B) + Words (4) + T (43)), 16);\n            B := C + Rotate_Left ((B + H (C, D, A) + Words (7) + T (44)), 23);\n            A := B + Rotate_Left ((A + H (B, C, D) + Words (10) + T (45)),  4);\n            D := A + Rotate_Left ((D + H (A, B, C) + Words (13) + T (46)), 11);\n            C := D + Rotate_Left ((C + H (D, A, B) + Words (16) + T (47)), 16);\n            B := C + Rotate_Left ((B + H (C, D, A) + Words (3) + T (48)), 23);\n            -- round 4\n            A := B + Rotate_Left ((A + I (B, C, D) + Words (1) + T (49)),  6);\n            D := A + Rotate_Left ((D + I (A, B, C) + Words (8) + T (50)), 10);\n            C := D + Rotate_Left ((C + I (D, A, B) + Words (15) + T (51)), 15);\n            B := C + Rotate_Left ((B + I (C, D, A) + Words (6) + T (52)), 21);\n            A := B + Rotate_Left ((A + I (B, C, D) + Words (13) + T (53)),  6);\n            D := A + Rotate_Left ((D + I (A, B, C) + Words (4) + T (54)), 10);\n            C := D + Rotate_Left ((C + I (D, A, B) + Words (11) + T (55)), 15);\n            B := C + Rotate_Left ((B + I (C, D, A) + Words (2) + T (56)), 21);\n            A := B + Rotate_Left ((A + I (B, C, D) + Words (9) + T (57)),  6);\n            D := A + Rotate_Left ((D + I (A, B, C) + Words (16) + T (58)), 10);\n            C := D + Rotate_Left ((C + I (D, A, B) + Words (7) + T (59)), 15);\n            B := C + Rotate_Left ((B + I (C, D, A) + Words (14) + T (60)), 21);\n            A := B + Rotate_Left ((A + I (B, C, D) + Words (5) + T (61)),  6);\n            D := A + Rotate_Left ((D + I (A, B, C) + Words (12) + T (62)), 10);\n            C := D + Rotate_Left ((C + I (D, A, B) + Words (3) + T (63)), 15);\n            B := C + Rotate_Left ((B + I (C, D, A) + Words (10) + T (64)), 21);\n            -- increment\n            A := A + AA;\n            B := B + BB;\n            C := C + CC;\n            D := D + DD;\n         end;\n      end loop;\n      return\n        (Turn_Around (A),\n         Turn_Around (B),\n         Turn_Around (C),\n         Turn_Around (D));\n   end MD5;\n\n   function To_String (Item : MD5_Hash) return MD5_String is\n      Hex_Chars : constant array (0 .. 15) of Character :=\n        ('0', '1', '2', '3', '4', '5', '6', '7',\n        '8', '9', 'a', 'b', 'c', 'd', 'e', 'f');\n      Result    : MD5_String := (1      => '0',\n                                 2      => 'x',\n                                 others => '0');\n      Temp      : Int32;\n      Position  : Natural := Result'Last;\n   begin\n      for Part in reverse Item'Range loop\n         Temp := Item (Part);\n         while Position > Result'Last - (5 - Part) * 8 loop\n            Result (Position) := Hex_Chars (Natural (Temp mod 16));\n            Position          := Position - 1;\n            Temp              := Temp / 16;\n         end loop;\n      end loop;\n      return Result;\n   end To_String;\n\nend MD5;\n\n\nwith Ada.Strings.Unbounded;\nwith Ada.Text_IO;\nwith MD5;\n\nprocedure Tester is\n   use Ada.Strings.Unbounded;\n   type String_Array is array (Positive range <>) of Unbounded_String;\n   Sources : constant String_Array :=\n     (To_Unbounded_String (\"\"),\n      To_Unbounded_String (\"a\"),\n      To_Unbounded_String (\"abc\"),\n      To_Unbounded_String (\"message digest\"),\n      To_Unbounded_String (\"abcdefghijklmnopqrstuvwxyz\"),\n      To_Unbounded_String\n         (\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"),\n      To_Unbounded_String\n         (\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\")\n     );\n   Digests : constant String_Array :=\n     (To_Unbounded_String (\"0xd41d8cd98f00b204e9800998ecf8427e\"),\n      To_Unbounded_String (\"0x0cc175b9c0f1b6a831c399e269772661\"),\n      To_Unbounded_String (\"0x900150983cd24fb0d6963f7d28e17f72\"),\n      To_Unbounded_String (\"0xf96b697d7cb7938d525a2f31aaf161d0\"),\n      To_Unbounded_String (\"0xc3fcd3d76192e4007dfb496cca67e13b\"),\n      To_Unbounded_String (\"0xd174ab98d277d9f5a5611c2c9f419d9f\"),\n      To_Unbounded_String (\"0x57edf4a22be3c955ac49da2e2107b67a\"));\nbegin\n   for I in Sources'Range loop\n      Ada.Text_IO.Put_Line (\"MD5 (\"\"\" & To_String (Sources (I)) & \"\"\"):\");\n      Ada.Text_IO.Put_Line\n        (MD5.To_String (MD5.MD5 (To_String (Sources (I)))));\n      Ada.Text_IO.Put_Line (To_String (Digests (I)) & \" (correct value)\");\n   end loop;\nend Tester;\n\n\nMD5 (\"\"):\n0xd41d8cd98f00b204e9800998ecf8427e\n0xd41d8cd98f00b204e9800998ecf8427e (correct value)\nMD5 (\"a\"):\n0x0cc175b9c0f1b6a831c399e269772661\n0x0cc175b9c0f1b6a831c399e269772661 (correct value)\nMD5 (\"abc\"):\n0x900150983cd24fb0d6963f7d28e17f72\n0x900150983cd24fb0d6963f7d28e17f72 (correct value)\nMD5 (\"message digest\"):\n0xf96b697d7cb7938d525a2f31aaf161d0\n0xf96b697d7cb7938d525a2f31aaf161d0 (correct value)\nMD5 (\"abcdefghijklmnopqrstuvwxyz\"):\n0xc3fcd3d76192e4007dfb496cca67e13b\n0xc3fcd3d76192e4007dfb496cca67e13b (correct value)\nMD5 (\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"):\n0xd174ab98d277d9f5a5611c2c9f419d9f\n0xd174ab98d277d9f5a5611c2c9f419d9f (correct value)\nMD5 (\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"):\n0x57edf4a22be3c955ac49da2e2107b67a\n0x57edf4a22be3c955ac49da2e2107b67a (correct value)\n", "explain": "note: this could be dependent on the endianness of the machine it runs on - not tested on big endian.\nmd5.ads:\nmd5.adb:\ntester.adb:\noutput:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Julia", "code": "\n# a rather literal translation of the pseudocode at https://en.wikipedia.org/wiki/MD5\n\nconst s = UInt32[7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n                 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, 5, 9, 14, 20, \n                 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,  4, 11, 16, 23, \n                 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21]\n\nconst K = UInt32[0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee, 0xf57c0faf,\n    0x4787c62a, 0xa8304613, 0xfd469501, 0x698098d8, 0x8b44f7af, 0xffff5bb1,\n    0x895cd7be, 0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821, 0xf61e2562,\n    0xc040b340, 0x265e5a51, 0xe9b6c7aa, 0xd62f105d, 0x02441453, 0xd8a1e681,\n    0xe7d3fbc8, 0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed, 0xa9e3e905,\n    0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a, 0xfffa3942, 0x8771f681, 0x6d9d6122,\n    0xfde5380c, 0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70, 0x289b7ec6,\n    0xeaa127fa, 0xd4ef3085, 0x04881d05, 0xd9d4d039, 0xe6db99e5, 0x1fa27cf8,\n    0xc4ac5665, 0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039, 0x655b59c3,\n    0x8f0ccc92, 0xffeff47d, 0x85845dd1, 0x6fa87e4f, 0xfe2ce6e0, 0xa3014314,\n    0x4e0811a1, 0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391]\n\nfunction md5(msgbytes)\n    a0::UInt32 = 0x67452301  # A\n    b0::UInt32 = 0xefcdab89  # B\n    c0::UInt32 = 0x98badcfe  # C\n    d0::UInt32 = 0x10325476  # D\n\n    oldlen = length(msgbytes)\n    umsg = push!([UInt8(b) for b in msgbytes], UInt8(0x80))\n    while length(umsg) % 64 != 56\n        push!(umsg, UInt8(0))\n    end\n    append!(umsg, reinterpret(UInt8, [htol(UInt64(oldlen) * 8)]))\n\n    for j in 1:64:length(umsg)-1\n        arr = view(umsg, j:j+63)\n        M = [reinterpret(UInt32, arr[k:k+3])[1] for k in 1:4:62]\n        A = a0\n        B = b0\n        C = c0\n        D = d0\n\n        for i in 0:63\n            if 0 \u2264 i \u2264 15\n                F = D \u22bb (B & (C \u22bb D))\n                g = i\n            elseif 16 \u2264 i \u2264 31\n                F = C \u22bb (D & (B \u22bb C))\n                g = (5 * i + 1) % 16\n            elseif 32 \u2264 i \u2264 47\n                F = B \u22bb C \u22bb D\n                g = (3 * i + 5) % 16\n            elseif 48 \u2264 i \u2264 63\n                F = C \u22bb (B | (~D))\n                g = (7 * i) % 16\n            end\n            F += A + K[i+1] + M[g+1]\n            A = D\n            D = C\n            C = B\n            B += ((F) << s[i+1]) | (F >> (32 - s[i+1]))\n        end\n\n        a0 += A\n        b0 += B\n        c0 += C\n        d0 += D\n    end\n    digest = join(map(x -> lpad(string(x, base=16), 2, '0'), reinterpret(UInt8, [a0, b0, c0, d0])), \"\") # Output is in little-endian\nend\n\nfor pair in [0xd41d8cd98f00b204e9800998ecf8427e => \"\", 0x0cc175b9c0f1b6a831c399e269772661 => \"a\",\n   0x900150983cd24fb0d6963f7d28e17f72 => \"abc\", 0xf96b697d7cb7938d525a2f31aaf161d0 => \"message digest\",\n   0xc3fcd3d76192e4007dfb496cca67e13b => \"abcdefghijklmnopqrstuvwxyz\",\n   0xd174ab98d277d9f5a5611c2c9f419d9f => \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n   0x57edf4a22be3c955ac49da2e2107b67a => \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"]\n   println(\"MD5 of $(pair[2]) is $(md5(pair[2])), which checks with $(string(pair[1], base=16)).\")\nend\n\nOutput:\nMD5 of  is d41d8cd98f00b204e9800998ecf8427e, which checks with d41d8cd98f00b204e9800998ecf8427e.\nMD5 of a is 0cc175b9c0f1b6a831c399e269772661, which checks with cc175b9c0f1b6a831c399e269772661.\nMD5 of abc is 900150983cd24fb0d6963f7d28e17f72, which checks with 900150983cd24fb0d6963f7d28e17f72.\nMD5 of message digest is f96b697d7cb7938d525a2f31aaf161d0, which checks with f96b697d7cb7938d525a2f31aaf161d0.\nMD5 of abcdefghijklmnopqrstuvwxyz is c3fcd3d76192e4007dfb496cca67e13b, which checks with c3fcd3d76192e4007dfb496cca67e13b.\nMD5 of ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 is d174ab98d277d9f5a5611c2c9f419d9f, which checks with d174ab98d277d9f5a5611c2c9f419d9f.\nMD5 of 12345678901234567890123456789012345678901234567890123456789012345678901234567890 is 57edf4a22be3c955ac49da2e2107b67a, which checks with 57edf4a22be3c955ac49da2e2107b67a.\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.3\n\nobject MD5 {\n\n    private val INIT_A = 0x67452301\n    private val INIT_B = 0xEFCDAB89L.toInt()\n    private val INIT_C = 0x98BADCFEL.toInt()\n    private val INIT_D = 0x10325476\n \n    private val SHIFT_AMTS = intArrayOf(\n        7, 12, 17, 22,\n        5,  9, 14, 20,\n        4, 11, 16, 23,\n        6, 10, 15, 21\n    )\n\n    private val TABLE_T = IntArray(64) {\n        ((1L shl 32) * Math.abs(Math.sin(it + 1.0))).toLong().toInt()\n    }\n\n    fun compute(message: ByteArray): ByteArray {\n        val messageLenBytes = message.size\n        val numBlocks = ((messageLenBytes + 8) ushr 6) + 1\n        val totalLen = numBlocks shl 6\n        val paddingBytes = ByteArray(totalLen - messageLenBytes)\n        paddingBytes[0] = 0x80.toByte()\n        var messageLenBits = (messageLenBytes shl 3).toLong()\n\n        for (i in 0..7) {\n            paddingBytes[paddingBytes.size - 8 + i] = messageLenBits.toByte()\n            messageLenBits = messageLenBits ushr 8\n        }\n\n        var a = INIT_A\n        var b = INIT_B\n        var c = INIT_C\n        var d = INIT_D\n        val buffer = IntArray(16)\n\n        for (i in 0 until numBlocks) {\n            var index = i shl 6\n\n            for (j in 0..63) {\n                val temp = if (index < messageLenBytes) message[index] else \n                               paddingBytes[index - messageLenBytes]\n                buffer[j ushr 2] = (temp.toInt() shl 24) or (buffer[j ushr 2] ushr 8) \n                index++\n            }\n\n            val originalA = a\n            val originalB = b\n            val originalC = c\n            val originalD = d\n\n            for (j in 0..63) {\n                val div16 = j ushr 4\n                var f = 0\n                var bufferIndex = j\n                when (div16) {\n                    0 -> {\n                        f = (b and c) or (b.inv() and d)\n                    }\n\n                    1 -> {\n                        f = (b and d) or (c and d.inv()) \n                        bufferIndex = (bufferIndex * 5 + 1) and 0x0F\n                    }\n \n                    2 -> {\n                        f = b xor c xor d;\n                        bufferIndex = (bufferIndex * 3 + 5) and 0x0F\n                    }\n\n                    3 -> {\n                        f = c xor (b or d.inv());\n                        bufferIndex = (bufferIndex * 7) and 0x0F\n                    }\n                } \n\n                val temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + \n                           TABLE_T[j], SHIFT_AMTS[(div16 shl 2) or (j and 3)])\n                a = d\n                d = c\n                c = b\n                b = temp\n            }\n\n            a += originalA\n            b += originalB\n            c += originalC\n            d += originalD\n        }   \n\n        val md5 = ByteArray(16)\n        var count = 0\n\n        for (i in 0..3) {\n            var n = if (i == 0) a else (if (i == 1) b else (if (i == 2) c else d))\n\n            for (j in 0..3) {      \n                md5[count++] = n.toByte()\n                n = n ushr 8\n            }\n        }\n        return md5\n    }\n}\n\nfun ByteArray.toHexString(): String {\n    val sb = StringBuilder()\n    for (b in this) sb.append(String.format(\"%02x\", b.toInt() and 0xFF))\n    return sb.toString()\n}\n\nfun main(args: Array<String>) {\n    val testStrings = arrayOf(\n        \"\",\n        \"a\",\n        \"abc\",\n        \"message digest\",\n        \"abcdefghijklmnopqrstuvwxyz\",\n        \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n        \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n    )\n\n    println(\"${\"hash code\".padStart(34)} <== string\") \n    for (s in testStrings) {\n        println(\"0x${MD5.compute(s.toByteArray()).toHexString()} <== \\\"$s\\\"\")\n    }\n}\n\n\nOutput:\n                         hash code <== string\n0xd41d8cd98f00b204e9800998ecf8427e <== \"\"\n0x0cc175b9c0f1b6a831c399e269772661 <== \"a\"\n0x900150983cd24fb0d6963f7d28e17f72 <== \"abc\"\n0xf96b697d7cb7938d525a2f31aaf161d0 <== \"message digest\"\n0xc3fcd3d76192e4007dfb496cca67e13b <== \"abcdefghijklmnopqrstuvwxyz\"\n0xd174ab98d277d9f5a5611c2c9f419d9f <== \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n0x57edf4a22be3c955ac49da2e2107b67a <== \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Perl", "code": "\nWorks with: Perl version 5.10.1 (and later)\nuse strict;\nuse warnings;\nuse integer;\nuse Test::More;\n\nBEGIN { plan tests => 7 }\n\nsub A()   { 0x67_45_23_01 }\nsub B()   { 0xef_cd_ab_89 }\nsub C()   { 0x98_ba_dc_fe }\nsub D()   { 0x10_32_54_76 }\nsub MAX() { 0xFFFFFFFF }\n\nsub padding {\n    my $l = length (my $msg = shift() . chr(128));\n    $msg .= \"\\0\" x (($l%64<=56?56:120)-$l%64);\n    $l = ($l-1)*8;\n    $msg .= pack 'VV', $l & MAX , ($l >> 16 >> 16);\n}\n\nsub rotate_left {\n    ($_[0] << $_[1]) | (( $_[0] >> (32 - $_[1])  )  & ((1 << $_[1]) - 1));\n}\n\nsub gen_code {\n  # Discard upper 32 bits on 64 bit archs.\n  my $MSK = ((1 << 16) << 16) ? ' & ' . MAX : '';\n  my %f = (\n    FF => \"X0=rotate_left((X3^(X1&(X2^X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    GG => \"X0=rotate_left((X2^(X3&(X1^X2)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    HH => \"X0=rotate_left((X1^X2^X3)+X0+X4+X6$MSK,X5)+X1$MSK;\",\n    II => \"X0=rotate_left((X2^(X1|(~X3)))+X0+X4+X6$MSK,X5)+X1$MSK;\",\n  );\n\n  my %s = (  # shift lengths\n    S11 => 7, S12 => 12, S13 => 17, S14 => 22, S21 => 5, S22 => 9, S23 => 14,\n    S24 => 20, S31 => 4, S32 => 11, S33 => 16, S34 => 23, S41 => 6, S42 => 10,\n    S43 => 15, S44 => 21\n  );\n\n  my $insert = \"\\n\";\n  while(defined( my $data = <DATA> )) {\n    chomp $data;\n    next unless $data =~ /^[FGHI]/;\n    my ($func,@x) = split /,/, $data;\n    my $c = $f{$func};\n    $c =~ s/X(\\d)/$x[$1]/g;\n    $c =~ s/(S\\d{2})/$s{$1}/;\n    $c =~ s/^(.*)=rotate_left\\((.*),(.*)\\)\\+(.*)$//;\n\n    my $su = 32 - $3;\n    my $sh = (1 << $3) - 1;\n\n    $c = \"$1=(((\\$r=$2)<<$3)|((\\$r>>$su)&$sh))+$4\";\n\n    $insert .= \"\\t$c\\n\";\n  }\n  close DATA;\n\n  my $dump = '\n  sub round {\n    my ($a,$b,$c,$d) = @_[0 .. 3];\n    my $r;' . $insert . '\n    $_[0]+$a' . $MSK . ', $_[1]+$b ' . $MSK .\n    ', $_[2]+$c' . $MSK . ', $_[3]+$d' . $MSK . ';\n  }';\n  eval $dump;\n}\n\ngen_code();\n\nsub _encode_hex { unpack 'H*', $_[0] }\n\nsub md5 {\n    my $message = padding(join'',@_);\n    my ($a,$b,$c,$d) = (A,B,C,D);\n    my $i;\n    for $i (0 .. (length $message)/64-1) {\n        my @X = unpack 'V16', substr $message,$i*64,64;\n        ($a,$b,$c,$d) = round($a,$b,$c,$d,@X);\n    }\n    pack 'V4',$a,$b,$c,$d;\n}\n\nmy $strings = {\n    'd41d8cd98f00b204e9800998ecf8427e' => '',\n    '0cc175b9c0f1b6a831c399e269772661' => 'a',\n    '900150983cd24fb0d6963f7d28e17f72' => 'abc',\n    'f96b697d7cb7938d525a2f31aaf161d0' => 'message digest',\n    'c3fcd3d76192e4007dfb496cca67e13b' => 'abcdefghijklmnopqrstuvwxyz',\n    'd174ab98d277d9f5a5611c2c9f419d9f' => 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789',\n    '57edf4a22be3c955ac49da2e2107b67a' => '12345678901234567890123456789012345678901234567890123456789012345678901234567890',\n};\n\nfor my $k (keys %$strings) {\n    my $digest = _encode_hex md5($strings->{$k});\n    is($digest, $k, \"$digest is MD5 digest $strings->{$k}\");\n}\n\n__DATA__\nFF,$a,$b,$c,$d,$_[4],7,0xd76aa478,/* 1 */\nFF,$d,$a,$b,$c,$_[5],12,0xe8c7b756,/* 2 */\nFF,$c,$d,$a,$b,$_[6],17,0x242070db,/* 3 */\nFF,$b,$c,$d,$a,$_[7],22,0xc1bdceee,/* 4 */\nFF,$a,$b,$c,$d,$_[8],7,0xf57c0faf,/* 5 */\nFF,$d,$a,$b,$c,$_[9],12,0x4787c62a,/* 6 */\nFF,$c,$d,$a,$b,$_[10],17,0xa8304613,/* 7 */\nFF,$b,$c,$d,$a,$_[11],22,0xfd469501,/* 8 */\nFF,$a,$b,$c,$d,$_[12],7,0x698098d8,/* 9 */\nFF,$d,$a,$b,$c,$_[13],12,0x8b44f7af,/* 10 */\nFF,$c,$d,$a,$b,$_[14],17,0xffff5bb1,/* 11 */\nFF,$b,$c,$d,$a,$_[15],22,0x895cd7be,/* 12 */\nFF,$a,$b,$c,$d,$_[16],7,0x6b901122,/* 13 */\nFF,$d,$a,$b,$c,$_[17],12,0xfd987193,/* 14 */\nFF,$c,$d,$a,$b,$_[18],17,0xa679438e,/* 15 */\nFF,$b,$c,$d,$a,$_[19],22,0x49b40821,/* 16 */\nGG,$a,$b,$c,$d,$_[5],5,0xf61e2562,/* 17 */\nGG,$d,$a,$b,$c,$_[10],9,0xc040b340,/* 18 */\nGG,$c,$d,$a,$b,$_[15],14,0x265e5a51,/* 19 */\nGG,$b,$c,$d,$a,$_[4],20,0xe9b6c7aa,/* 20 */\nGG,$a,$b,$c,$d,$_[9],5,0xd62f105d,/* 21 */\nGG,$d,$a,$b,$c,$_[14],9,0x2441453,/* 22 */\nGG,$c,$d,$a,$b,$_[19],14,0xd8a1e681,/* 23 */\nGG,$b,$c,$d,$a,$_[8],20,0xe7d3fbc8,/* 24 */\nGG,$a,$b,$c,$d,$_[13],5,0x21e1cde6,/* 25 */\nGG,$d,$a,$b,$c,$_[18],9,0xc33707d6,/* 26 */\nGG,$c,$d,$a,$b,$_[7],14,0xf4d50d87,/* 27 */\nGG,$b,$c,$d,$a,$_[12],20,0x455a14ed,/* 28 */\nGG,$a,$b,$c,$d,$_[17],5,0xa9e3e905,/* 29 */\nGG,$d,$a,$b,$c,$_[6],9,0xfcefa3f8,/* 30 */\nGG,$c,$d,$a,$b,$_[11],14,0x676f02d9,/* 31 */\nGG,$b,$c,$d,$a,$_[16],20,0x8d2a4c8a,/* 32 */\nHH,$a,$b,$c,$d,$_[9],4,0xfffa3942,/* 33 */\nHH,$d,$a,$b,$c,$_[12],11,0x8771f681,/* 34 */\nHH,$c,$d,$a,$b,$_[15],16,0x6d9d6122,/* 35 */\nHH,$b,$c,$d,$a,$_[18],23,0xfde5380c,/* 36 */\nHH,$a,$b,$c,$d,$_[5],4,0xa4beea44,/* 37 */\nHH,$d,$a,$b,$c,$_[8],11,0x4bdecfa9,/* 38 */\nHH,$c,$d,$a,$b,$_[11],16,0xf6bb4b60,/* 39 */\nHH,$b,$c,$d,$a,$_[14],23,0xbebfbc70,/* 40 */\nHH,$a,$b,$c,$d,$_[17],4,0x289b7ec6,/* 41 */\nHH,$d,$a,$b,$c,$_[4],11,0xeaa127fa,/* 42 */\nHH,$c,$d,$a,$b,$_[7],16,0xd4ef3085,/* 43 */\nHH,$b,$c,$d,$a,$_[10],23,0x4881d05,/* 44 */\nHH,$a,$b,$c,$d,$_[13],4,0xd9d4d039,/* 45 */\nHH,$d,$a,$b,$c,$_[16],11,0xe6db99e5,/* 46 */\nHH,$c,$d,$a,$b,$_[19],16,0x1fa27cf8,/* 47 */\nHH,$b,$c,$d,$a,$_[6],23,0xc4ac5665,/* 48 */\nII,$a,$b,$c,$d,$_[4],6,0xf4292244,/* 49 */\nII,$d,$a,$b,$c,$_[11],10,0x432aff97,/* 50 */\nII,$c,$d,$a,$b,$_[18],15,0xab9423a7,/* 51 */\nII,$b,$c,$d,$a,$_[9],21,0xfc93a039,/* 52 */\nII,$a,$b,$c,$d,$_[16],6,0x655b59c3,/* 53 */\nII,$d,$a,$b,$c,$_[7],10,0x8f0ccc92,/* 54 */\nII,$c,$d,$a,$b,$_[14],15,0xffeff47d,/* 55 */\nII,$b,$c,$d,$a,$_[5],21,0x85845dd1,/* 56 */\nII,$a,$b,$c,$d,$_[12],6,0x6fa87e4f,/* 57 */\nII,$d,$a,$b,$c,$_[19],10,0xfe2ce6e0,/* 58 */\nII,$c,$d,$a,$b,$_[10],15,0xa3014314,/* 59 */\nII,$b,$c,$d,$a,$_[17],21,0x4e0811a1,/* 60 */\nII,$a,$b,$c,$d,$_[8],6,0xf7537e82,/* 61 */\nII,$d,$a,$b,$c,$_[15],10,0xbd3af235,/* 62 */\nII,$c,$d,$a,$b,$_[6],15,0x2ad7d2bb,/* 63 */\nII,$b,$c,$d,$a,$_[13],21,0xeb86d391,/* 64 */\n\n\nOutput:\n1..7\nok 1 - c3fcd3d76192e4007dfb496cca67e13b is MD5 digest abcdefghijklmnopqrstuvwxyz\nok 2 - f96b697d7cb7938d525a2f31aaf161d0 is MD5 digest message digest\nok 3 - 900150983cd24fb0d6963f7d28e17f72 is MD5 digest abc\nok 4 - d41d8cd98f00b204e9800998ecf8427e is MD5 digest\nok 5 - 57edf4a22be3c955ac49da2e2107b67a is MD5 digest 12345678901234567890123456789012345678901234567890123456789012345678901234567890\nok 6 - 0cc175b9c0f1b6a831c399e269772661 is MD5 digest a\nok 7 - d174ab98d277d9f5a5611c2c9f419d9f is MD5 digest ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Lua", "code": "\n\n-- shift amounts\nlocal s = {\n  7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22, 7, 12, 17, 22,\n  5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20, 5,  9, 14, 20,\n  4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23, 4, 11, 16, 23,\n  6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21, 6, 10, 15, 21\n}\n\n-- constants\nlocal K = {\n  0xd76aa478, 0xe8c7b756, 0x242070db, 0xc1bdceee,\n  0xf57c0faf, 0x4787c62a, 0xa8304613, 0xfd469501,\n  0x698098d8, 0x8b44f7af, 0xffff5bb1, 0x895cd7be,\n  0x6b901122, 0xfd987193, 0xa679438e, 0x49b40821,\n  0xf61e2562, 0xc040b340, 0x265e5a51, 0xe9b6c7aa,\n  0xd62f105d, 0x02441453, 0xd8a1e681, 0xe7d3fbc8,\n  0x21e1cde6, 0xc33707d6, 0xf4d50d87, 0x455a14ed,\n  0xa9e3e905, 0xfcefa3f8, 0x676f02d9, 0x8d2a4c8a,\n  0xfffa3942, 0x8771f681, 0x6d9d6122, 0xfde5380c,\n  0xa4beea44, 0x4bdecfa9, 0xf6bb4b60, 0xbebfbc70,\n  0x289b7ec6, 0xeaa127fa, 0xd4ef3085, 0x04881d05,\n  0xd9d4d039, 0xe6db99e5, 0x1fa27cf8, 0xc4ac5665,\n  0xf4292244, 0x432aff97, 0xab9423a7, 0xfc93a039,\n  0x655b59c3, 0x8f0ccc92, 0xffeff47d, 0x85845dd1,\n  0x6fa87e4f, 0xfe2ce6e0, 0xa3014314, 0x4e0811a1,\n  0xf7537e82, 0xbd3af235, 0x2ad7d2bb, 0xeb86d391,\n}\n\nlocal function leftRotate(x, c)\n  return (x << c) | (x >> (32-c))\nend\n\nlocal function getInt(byteArray, n)\n  return (byteArray[n+3]<<24) + (byteArray[n+2]<<16) + (byteArray[n+1]<<8) + byteArray[n]\nend\n\n--- converts 32bit integer n to a little endian hex representation\n-- @tparam integer n\nlocal function lE(n)\n  local s = ''\n  for i = 0, 3 do\n    s = ('%s%02x'):format(s, (n>>(i*8))&0xff)\n  end\n  return s\nend\n\n--- md5\n-- @tparam string message\nlocal function md5(message)\n  local a0, b0, c0, d0 = 0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476\n  local bytes = {message:byte(1, -1)}\n  \n  -- insert 1 bit (and the rest of the byte)\n  table.insert(bytes, 0x80)\n\n  -- pad with zeros until we have *just enough*\n  local p = #bytes%64\n  if p > 56 then\n    p = p - 64\n  end\n  for _ = p+1, 56 do\n    table.insert(bytes, 0)\n  end\n\n  -- insert the initial message length, in little-endian\n  local len = ((#message)<<3)&0xffffffffffffffff -- length in bits\n  for i = 0, 7 do\n    table.insert(bytes, (len>>(i*8))&0xff)\n  end\n\n  \n  for i = 0, #bytes//64-1 do\n    local a, b, c, d = a0, b0, c0, d0\n    for j = 0, 63 do\n      local F, g\n      -- permutate\n      if j <= 15 then\n        F = (b & c) | (~b & d)\n        g = j\n      elseif j <= 31 then\n        F = (d & b) | (~d & c)\n        g = (5*j + 1) & 15\n      elseif j <= 47 then\n        F = b ~ c ~ d\n        g = (3*j + 5) & 15\n      else\n        F = c ~ (b | ~d)\n        g = (7*j) & 15\n      end\n\n      F = (F + a + K[j+1] + getInt(bytes, i*64+g*4+1))&0xffffffff\n      -- shuffle\n      a = d\n      d = c\n      c = b\n      b = (b + leftRotate(F, s[j+1]))&0xffffffff\n    end\n    -- update internal state\n    a0 = (a0 + a)&0xffffffff\n    b0 = (b0 + b)&0xffffffff\n    c0 = (c0 + c)&0xffffffff\n    d0 = (d0 + d)&0xffffffff\n  end\n\n  -- lua doesn't support any other byte strings. Could convert to a wacky string but this is more printable.\n  return lE(a0)..lE(b0)..lE(c0)..lE(d0)\nend\n\nlocal demo = {\n  [\"\"] = \"d41d8cd98f00b204e9800998ecf8427e\",  \n  [\"a\"] = \"0cc175b9c0f1b6a831c399e269772661\",\n  [\"abc\"] = \"900150983cd24fb0d6963f7d28e17f72\",\n  [\"message digest\"] = \"f96b697d7cb7938d525a2f31aaf161d0\",\n  [\"abcdefghijklmnopqrstuvwxyz\"] = \"c3fcd3d76192e4007dfb496cca67e13b\",\n  [\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"] = \"d174ab98d277d9f5a5611c2c9f419d9f\",\n  [\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"] = \"57edf4a22be3c955ac49da2e2107b67a\",\n}\n\nfor k, v in pairs(demo) do\n  local m = md5(k)\n  print((\"%s [%2s] <== \\\"%s\\\"\"):format(m, m==v and 'OK' or '', k))\nend\n\n\nf96b697d7cb7938d525a2f31aaf161d0 [OK] <== \"message digest\"\nd174ab98d277d9f5a5611c2c9f419d9f [OK] <== \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\nc3fcd3d76192e4007dfb496cca67e13b [OK] <== \"abcdefghijklmnopqrstuvwxyz\"\nd41d8cd98f00b204e9800998ecf8427e [OK] <== \"\"\n900150983cd24fb0d6963f7d28e17f72 [OK] <== \"abc\"\n57edf4a22be3c955ac49da2e2107b67a [OK] <== \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n0cc175b9c0f1b6a831c399e269772661 [OK] <== \"a\"\n\n", "explain": "With advent of 5.3, Lua can now calculate a string representation of an md5 hash.\nOutput:\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Scala", "code": "\n\n\nThis example is incorrect. It does not accomplish the given task. Please fix the code and remove this message.\n\nobject MD5 extends App {\n\n  def hash(s: String) = {\n    def b = s.getBytes(\"UTF-8\")\n\n    def m = java.security.MessageDigest.getInstance(\"MD5\").digest(b)\n\n    BigInt(1, m).toString(16).reverse.padTo(32, \"0\").reverse.mkString\n  }\n\n  assert(\"d41d8cd98f00b204e9800998ecf8427e\" == hash(\"\"))\n  assert(\"0000045c5e2b3911eb937d9d8c574f09\" == hash(\"iwrupvqb346386\"))\n  assert(\"0cc175b9c0f1b6a831c399e269772661\" == hash(\"a\"))\n  assert(\"900150983cd24fb0d6963f7d28e17f72\" == hash(\"abc\"))\n  assert(\"f96b697d7cb7938d525a2f31aaf161d0\" == hash(\"message digest\"))\n  assert(\"c3fcd3d76192e4007dfb496cca67e13b\" == hash(\"abcdefghijklmnopqrstuvwxyz\"))\n  assert(\"d174ab98d277d9f5a5611c2c9f419d9f\" == hash(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"))\n  assert(\"57edf4a22be3c955ac49da2e2107b67a\" == hash(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"))\n\n}\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "D", "code": "\n\nimport std.bitmanip, core.stdc.string, std.conv, std.math, std.array,\n       std.string;\n\nversion (D_InlineAsm_X86) {} else {\n    static assert(false, \"For X86 machine only.\");\n}\n\n// CTFE construction of transform expressions.\nuint S(in uint n) pure nothrow @safe @nogc {\n    static immutable aux = [7u, 12, 17, 22, 5, 9, 14, 20, 4, 11,\n                            16, 23, 6, 10, 15, 21];\n    return aux[(n / 16) * 4 + (n % 4)];\n}\n\nuint K(in uint n) pure nothrow @safe @nogc {\n    uint r = 0;\n    if (n <= 15)\n        r = n;\n    else if (n <= 31)\n        r = 5 * n + 1;\n    else if (n <= 47)\n        r = 3 * n + 5;\n    else\n        r = 7 * n;\n    return r % 16;\n}\n\nuint T(in uint n) pure nothrow @nogc {\n    return cast(uint)(abs(sin(n + 1.0L)) * (2UL ^^ 32));\n}\n\nstring[] ABCD(in int n) pure nothrow {\n    enum abcd = [\"EAX\", \"EBX\", \"ECX\", \"EDX\"];\n    return abcd[(64 - n) % 4 .. 4] ~ abcd[0 .. (64 - n) % 4];\n}\n\nstring SUB(in int n, in string s) pure nothrow {\n    return s\n           .replace(\"ax\", n.ABCD[0])\n           .replace(\"bx\", n.ABCD[1])\n           .replace(\"cx\", n.ABCD[2])\n           .replace(\"dx\", n.ABCD[3]);\n}\n\n// FF, GG, HH & II expressions part 1 (F, G, H, I).\nstring fghi1(in int n) pure nothrow @nogc {\n    switch (n / 16) {\n        case 0:\n            // (bb & cc) | (~bb & dd)\n            return q{\n                        mov ESI, bx;\n                        mov EDI, bx;\n                        not ESI;\n                        and EDI, cx;\n                        and ESI, dx;\n                        or EDI, ESI;\n                        add ax, EDI;\n                    };\n        case 1:\n            // (dd & bb) | (~dd & cc)\n            return q{\n                        mov ESI, dx;\n                        mov EDI, dx;\n                        not ESI;\n                        and EDI, bx;\n                        and ESI, cx;\n                        or EDI, ESI;\n                        add ax, EDI;\n                    };\n        case 2: // (bb ^ cc ^ dd)\n            return q{\n                        mov EDI, bx;\n                        xor EDI, cx;\n                        xor EDI, dx;\n                        add ax, EDI;\n                    };\n        case 3: // (cc ^ (bb | ~dd))\n            return q{\n                       mov EDI, dx;\n                       not EDI;\n                       or EDI, bx;\n                       xor EDI, cx;\n                       add ax, EDI;\n                    };\n        default:\n            assert(false);\n    }\n}\n\n// FF, GG, HH & II expressions part 2.\nstring fghi2(in int n) pure nothrow {\n    return q{\n                add ax, [EBP + 4 * KK];\n                add ax, TT;\n            } ~ n.fghi1;\n}\n\n// FF, GG, HH & II expressions prepended with previous parts\n// & subsitute ABCD.\nstring FGHI(in int n) pure nothrow {\n    // aa = ((aa << SS)|( aa >>> (32 - SS))) + bb = ROL(aa, SS) + bb\n    return SUB(n, n.fghi2 ~ q{\n                                rol ax, SS;\n                                add ax, bx;\n                             });\n}\n\nstring genExpr(uint n) pure nothrow {\n    return FGHI(n)\n           .replace(\"SS\", n.S.text)\n           .replace(\"KK\", n.K.text)\n           .replace(\"TT\", \"0x\" ~ to!string(n.T, 16));\n}\n\nstring genTransformCode(int n) pure nothrow {\n    return (n < 63) ? n.genExpr ~ genTransformCode(n + 1) : n.genExpr;\n}\n\nenum string coreZMD5 = 0.genTransformCode;\n\nstruct ZMD5 {\n    uint[4] state = [0x67452301, 0xefcdab89, 0x98badcfe, 0x10325476];\n    ulong count;\n    ubyte[64] buffer;\n\n    ubyte[64] padding = [\n      0x80, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,\n      0, 0];\n\n    private void transform(ubyte* block) pure nothrow @nogc {\n        uint[16] x = void;\n\n        version (BigEndian) {\n            foreach (immutable i; 0 .. 16)\n                x[i] = littleEndianToNative!uint(*cast(ubyte[4]*)&block[i * 4]);\n        } else {\n            (cast(ubyte*)x.ptr)[0 .. 64] = block[0 .. 64];\n        }\n\n        auto pState = state.ptr;\n        auto pBuffer = x.ptr;\n\n        asm pure nothrow @nogc {\n            mov  ESI, pState[EBP];\n            mov  EDX, [ESI + 3 * 4];\n            mov  ECX, [ESI + 2 * 4];\n            mov  EBX, [ESI + 1 * 4];\n            mov  EAX, [ESI + 0 * 4];\n            push EBP;\n            push ESI;\n\n            mov  EBP, pBuffer[EBP];\n        }\n\n        mixin(\"asm pure nothrow @nogc { \" ~ coreZMD5 ~ \"}\");\n\n        asm pure nothrow @nogc {\n            pop ESI;\n            pop EBP;\n            add [ESI + 0 * 4], EAX;\n            add [ESI + 1 * 4], EBX;\n            add [ESI + 2 * 4], ECX;\n            add [ESI + 3 * 4], EDX;\n        }\n        x[] = 0;\n    }\n\n    void update(in void[] input) pure nothrow @nogc {\n        auto inputLen = input.length;\n        uint index = (count >> 3) & 0b11_1111U;\n        count += inputLen * 8;\n        immutable uint partLen = 64 - index;\n\n        uint i;\n        if (inputLen >= partLen) {\n            memcpy(&buffer[index], input.ptr, partLen);\n            transform(buffer.ptr);\n            for (i = partLen; i + 63 < inputLen; i += 64)\n                transform((cast(ubyte[])input)[i .. i + 64].ptr);\n            index = 0;\n        } else\n            i = 0;\n\n        if (inputLen - i)\n            memcpy(&buffer[index], &input[i], inputLen - i);\n    }\n\n    void finish(ref ubyte[16] digest) pure nothrow @nogc {\n        ubyte[8] bits = void;\n        bits[0 .. 8] = nativeToLittleEndian(count)[];\n\n        immutable uint index = (count >> 3) & 0b11_1111U;\n        immutable uint padLen = (index < 56) ?\n                                (56 - index) : (120 - index);\n        update(padding[0 .. padLen]);\n        update(bits);\n\n        digest[0 .. 4]   = nativeToLittleEndian(state[0])[];\n        digest[4 .. 8]   = nativeToLittleEndian(state[1])[];\n        digest[8 .. 12]  = nativeToLittleEndian(state[2])[];\n        digest[12 .. 16] = nativeToLittleEndian(state[3])[];\n\n        // Zeroize sensitive information.\n        memset(&this, 0, ZMD5.sizeof);\n    }\n}\n\nstring getDigestString(in void[][] data...) pure {\n    ZMD5 ctx;\n    foreach (datum; data)\n        ctx.update(datum);\n    ubyte[16] digest;\n    ctx.finish(digest);\n    return format(\"%-(%02X%)\", digest);\n}\n\n\nvoid main() { // Benchmark code --------------\n    import std.stdio, std.datetime, std.digest.md;\n\n    writefln(`md5  digest(\"\")  =\u00a0%-(%02X%)`, \"\".md5Of);\n    writefln(`zmd5 digest(\"\")  = %s`, \"\".getDigestString);\n\n    enum megaBytes = 512;\n    writefln(\"\\nTest performance / message size %dMBytes:\", megaBytes);\n    auto data = new float[megaBytes * 0x40000 + 13];\n\n    StopWatch sw;\n    sw.start;\n    immutable d1 = data.md5Of;\n    sw.stop;\n    immutable time1 = sw.peek.msecs / 1000.0;\n    writefln(\"digest(data) =\u00a0%-(%02X%)\", d1);\n    writefln(\"std.md5: %8.2f M/sec  ( %8.2f secs)\",\n             megaBytes / time1, time1);\n\n    sw.reset;\n    sw.start;\n    immutable d2 = data.getDigestString;\n    sw.stop;\n    immutable time2 = sw.peek.msecs / 1000.0;\n    writefln(\"digest(data) = %s\", d2);\n    writefln(\"zmd5  \u00a0: %8.2f M/sec  ( %8.2f secs)\",\n             megaBytes / time2, time2);\n}\n\n\nOutput (dmd compiler):\nmd5  digest(\"\")  = D41D8CD98F00B204E9800998ECF8427E\nzmd5 digest(\"\")  = D41D8CD98F00B204E9800998ECF8427E\n\nTest performance / message size 512MBytes:\ndigest(data) = A36190ECA92203A477EFC4DAB966CE6F\nstd.md5:    45.85 M/sec  (    11.17 secs)\ndigest(data) = A36190ECA92203A477EFC4DAB966CE6F\nzmd5  \u00a0:   244.86 M/sec  (     2.09 secs)\n\nOutput (ldc2 compiler):\nmd5  digest(\"\")  = D41D8CD98F00B204E9800998ECF8427E\nzmd5 digest(\"\")  = D41D8CD98F00B204E9800998ECF8427E\n\nTest performance / message size 512MBytes:\ndigest(data) = A36190ECA92203A477EFC4DAB966CE6F\nstd.md5:   310.12 M/sec  (     1.65 secs)\ndigest(data) = A36190ECA92203A477EFC4DAB966CE6F\nzmd5  \u00a0:   277.06 M/sec  (     1.85 secs)\n\n", "explain": "The standard library Phobos included an MD5 module.\nThis code generates x86 assembly code by compile time functions, then mix-in the assembly code. It only works on x86 machine.\nAs you see this asm is much faster than the D code compiled by dmd, but the D code compiled by ldc2 is a little faster still.\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Haskell", "code": "\nimport Control.Monad (replicateM)\n\nimport qualified Data.ByteString.Lazy as BL\nimport qualified Data.ByteString.Lazy.Char8 as BLC\nimport Data.Binary.Get\nimport Data.Binary.Put\nimport Data.Bits\n\nimport Data.Array (Array, listArray, (!))\nimport Data.List (foldl)\nimport Data.Word (Word32)\n\nimport Numeric (showHex)\n\n\n-- functions\ntype Fun = Word32 -> Word32 -> Word32 -> Word32\n\nfunF, funG, funH, funI :: Fun\nfunF x y z = (x .&. y) .|. (complement x .&. z)\nfunG x y z = (x .&. z) .|. (complement z .&. y)\nfunH x y z = x `xor` y `xor` z\nfunI x y z = y `xor` (complement z .|. x)\n\nidxF, idxG, idxH, idxI :: Int -> Int\nidxF i = i\nidxG i = (5 * i + 1) `mod` 16\nidxH i = (3 * i + 5) `mod` 16\nidxI i = 7 * i `mod` 16\n\n\n-- arrays\nfunA :: Array Int Fun\nfunA = listArray (1,64) $ replicate 16 =<< [funF, funG, funH, funI]\n\nidxA :: Array Int Int\nidxA = listArray (1,64) $ zipWith ($) (replicate 16 =<< [idxF, idxG, idxH, idxI]) [0..63]\n\nrotA :: Array Int Int\nrotA = listArray (1,64) $ concat . replicate 4 =<<\n       [[7, 12, 17, 22], [5, 9, 14, 20], [4, 11, 16, 23], [6, 10, 15, 21]]\n\nsinA :: Array Int Word32\nsinA = listArray (1,64) $ map (floor . (*mult) . abs . sin) [1..64]\n    where mult = 2 ** 32 :: Double\n\n\n-- to lazily calculate MD5 sum for standart input:\n-- main = putStrLn . md5sum =<< BL.getContents\n\nmain :: IO ()\nmain = mapM_ (putStrLn . md5sum . BLC.pack)\n        [ \"\" \n        , \"a\"\n        , \"abc\"\n        , \"message digest\"\n        , \"abcdefghijklmnopqrstuvwxyz\"\n        , \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\n        , \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\n        ]\n\n\nmd5sum :: BL.ByteString -> String\nmd5sum input =\n    let MD5 a b c d = getMD5 initial `runGet` input\n    in  foldr hex [] . BL.unpack . runPut $ mapM_ putWord32le [a,b,c,d]\n    where\n      initial = MD5 0x67452301 0xEFCDAB89 0x98BADCFE 0x10325476\n\n      hex x s | x < 16    = '0' : showHex x s -- quick hack: like \"%02x\"\n              | otherwise =       showHex x s\n\n\ndata MD5 = MD5\n    { a :: {-# UNPACK #-} !Word32\n    , b :: {-# UNPACK #-} !Word32\n    , c :: {-# UNPACK #-} !Word32\n    , d :: {-# UNPACK #-} !Word32\n    }\n\n\ngetMD5 :: MD5 -> Get MD5\ngetMD5 md5 = do\n  chunk <- getLazyByteString 64\n  let len = BL.length chunk\n\n  if len == 64\n  then getMD5 $! md5 <+> chunk  -- apply and process next chunk\n\n  else do                       -- input is totally eaten, finalize\n    bytes <- bytesRead\n    let fin   = runPut . putWord64le $ fromIntegral (bytes - 64 + len) * 8\n        pad n = chunk `BL.append` (0x80 `BL.cons` BL.replicate (n - 1) 0x00)\n\n    return $ if len >= 56\n        then md5 <+> pad (64 - len) <+> BL.replicate 56 0x00 `BL.append` fin\n        else md5 <+> pad (56 - len) `BL.append` fin\n\n\n(<+>) :: MD5 -> BL.ByteString -> MD5\ninfixl 5  <+>\nmd5@(MD5 a b c d) <+> bs =\n    let datA = listArray (0,15) $ replicateM 16 getWord32le `runGet` bs\n        MD5 a' b' c' d' = foldl' (md5round datA) md5 [1..64]\n    in MD5 (a + a') (b + b') (c + c') (d + d')\n\n\nmd5round :: Array Int Word32 -> MD5 -> Int -> MD5\nmd5round datA (MD5 a b c d) i =\n    let f  =  funA ! i\n        w  =  datA ! (idxA ! i)\n        a' =  b + (a + f b c d + w + sinA ! i) `rotateL` rotA ! i\n    in MD5 d a' b c\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "F#", "code": "\n\nlet fxyz x y z : uint32 = (x &&& y) ||| (~~~x &&& z)\nlet gxyz x y z : uint32 = (z &&& x) ||| (~~~z &&& y)\nlet hxyz x y z : uint32 = x ^^^ y ^^^ z\nlet ixyz x y z : uint32 = y ^^^ (x ||| ~~~z)\nlet fghi = [ fxyz; gxyz; hxyz; ixyz ] |> List.collect (List.replicate 16)\nlet g1Idx = id\nlet g2Idx i = (5 * i + 1) % 16\nlet g3Idx i = (3 * i + 5) % 16\nlet g4Idx i = (7 * i) % 16\n\nlet gIdxs = \n  [ g1Idx; g2Idx; g3Idx; g4Idx ]\n  |> List.collect (List.replicate 16)\n  |> List.map2 (fun idx func -> func idx) [ 0..63 ]\n\nlet s = \n  [ [ 7; 12; 17; 22 ]\n    [ 5; 9; 14; 20 ]\n    [ 4; 11; 16; 23 ]\n    [ 6; 10; 15; 21 ] ]\n  |> List.collect (List.replicate 4)\n  |> List.concat\n\nlet k = \n  [ 1...64. ] |> List.map (sin\n                           >> abs\n                           >> ((*) (2. ** 32.))\n                           >> floor\n                           >> uint32)\n\ntype MD5 = \n  { a : uint32\n    b : uint32\n    c : uint32\n    d : uint32 }\n\nlet initialMD5 = \n  { a = 0x67452301u\n    b = 0xefcdab89u\n    c = 0x98badcfeu\n    d = 0x10325476u }\n\nlet md5round (msg : uint32 []) { MD5.a = a; MD5.b = b; MD5.c = c; MD5.d = d } i = \n  let rotateL32 r x = (x <<< r) ||| (x >>> (32 - r))\n  let f = fghi.[i] b c d\n  let a' = b + (a + f + k.[i] + msg.[gIdxs.[i]]\n                |> rotateL32 s.[i])\n  { a = d\n    b = a'\n    c = b\n    d = c }\n\nlet md5plus m (bs : byte []) = \n  let msg = \n    bs\n    |> Array.chunkBySize 4\n    |> Array.take 16\n    |> Array.map (fun elt -> System.BitConverter.ToUInt32(elt, 0))\n  \n  let m' = List.fold (md5round msg) m [ 0..63 ]\n  { a = m.a + m'.a\n    b = m.b + m'.b\n    c = m.c + m'.c\n    d = m.d + m'.d }\n\nlet padMessage (msg : byte []) = \n  let msgLen = Array.length msg\n  let msgLenInBits = (uint64 msgLen) * 8UL\n  \n  let lastSegmentSize = \n    let m = msgLen % 64\n    if m = 0 then 64\n    else m\n  \n  let padLen = \n    64 - lastSegmentSize + (if lastSegmentSize >= 56 then 64\n                            else 0)\n  \n  [| yield 128uy\n     for i in 2..padLen - 8 do\n       yield 0uy\n     for i in 0..7 do\n       yield ((msgLenInBits >>> (8 * i)) |> byte) |]\n  |> Array.append msg\n\nlet md5sum (msg : string) = \n  System.Text.Encoding.ASCII.GetBytes msg\n  |> padMessage\n  |> Array.chunkBySize 64\n  |> Array.fold md5plus initialMD5\n  |> (fun { MD5.a = a; MD5.b = b; MD5.c = c; MD5.d = d } -> \n    System.BitConverter.GetBytes a\n    |> (fun x -> System.BitConverter.GetBytes b |> Array.append x)\n    |> (fun x -> System.BitConverter.GetBytes c |> Array.append x)\n    |> (fun x -> System.BitConverter.GetBytes d |> Array.append x))\n  |> Array.map (sprintf \"%02X\")\n  |> Array.reduce (+)\n\n", "explain": "Pure functional implementation (slower than library function) (Link to original blog [2]):\n"}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "Groovy", "code": "\nclass MD5 {\n\n    private static final int INIT_A = 0x67452301\n    private static final int INIT_B = (int)0xEFCDAB89L\n    private static final int INIT_C = (int)0x98BADCFEL\n    private static final int INIT_D = 0x10325476\n\n    private static final int[] SHIFT_AMTS = [\n            7, 12, 17, 22,\n            5,  9, 14, 20,\n            4, 11, 16, 23,\n            6, 10, 15, 21\n    ]\n\n    private static final int[] TABLE_T = new int[64]\n    static\n    {\n        for (int i in 0..63)\n            TABLE_T[i] = (int)(long)((1L << 32) * Math.abs(Math.sin(i + 1)))\n    }\n\n    static byte[] computeMD5(byte[] message)\n    {\n        int messageLenBytes = message.length\n        int numBlocks = ((messageLenBytes + 8) >>> 6) + 1\n        int totalLen = numBlocks << 6\n        byte[] paddingBytes = new byte[totalLen - messageLenBytes]\n        paddingBytes[0] = (byte)0x80\n\n        long messageLenBits = (long)messageLenBytes << 3\n        for (int i in 0..7)\n        {\n            paddingBytes[paddingBytes.length - 8 + i] = (byte)messageLenBits\n            messageLenBits >>>= 8\n        }\n\n        int a = INIT_A\n        int b = INIT_B\n        int c = INIT_C\n        int d = INIT_D\n        int[] buffer = new int[16]\n        for (int i in 0..(numBlocks - 1))\n        {\n            int index = i << 6\n            for (int j in 0..63) {\n                buffer[j >>> 2] = ((int) ((index < messageLenBytes) ? message[index] : paddingBytes[index - messageLenBytes]) << 24) | (buffer[j >>> 2] >>> 8)\n                index++\n            }\n            int originalA = a\n            int originalB = b\n            int originalC = c\n            int originalD = d\n            for (int j in 0..63)\n            {\n                int div16 = j >>> 4\n                int f = 0\n                int bufferIndex = j\n                switch (div16)\n                {\n                    case 0:\n                        f = (b & c) | (~b & d)\n                        break\n\n                    case 1:\n                        f = (b & d) | (c & ~d)\n                        bufferIndex = (bufferIndex * 5 + 1) & 0x0F\n                        break\n\n                    case 2:\n                        f = b ^ c ^ d\n                        bufferIndex = (bufferIndex * 3 + 5) & 0x0F\n                        break\n\n                    case 3:\n                        f = c ^ (b | ~d)\n                        bufferIndex = (bufferIndex * 7) & 0x0F\n                        break\n                }\n                int temp = b + Integer.rotateLeft(a + f + buffer[bufferIndex] + TABLE_T[j], SHIFT_AMTS[(div16 << 2) | (j & 3)])\n                a = d\n                d = c\n                c = b\n                b = temp\n            }\n\n            a += originalA\n            b += originalB\n            c += originalC\n            d += originalD\n        }\n\n        byte[] md5 = new byte[16]\n        int count = 0\n        for (int i in 0..3)\n        {\n            int n = (i == 0) ? a : ((i == 1) ? b : ((i == 2) ? c : d))\n            for (int j in 0..3)\n            {\n                md5[count++] = (byte)n\n                n >>>= 8\n            }\n        }\n        return md5\n    }\n\n    static String toHexString(byte[] b)\n    {\n        StringBuilder sb = new StringBuilder()\n        for (int i in 0..(b.length - 1))\n        {\n            sb.append(String.format(\"%02X\", b[i] & 0xFF))\n        }\n        return sb.toString()\n    }\n\n    static void main(String[] args)\n    {\n        String[] testStrings = [\"\", \"a\", \"abc\", \"message digest\", \"abcdefghijklmnopqrstuvwxyz\",\n                                \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\n                                \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" ]\n        for (String s : testStrings)\n            System.out.println(\"0x\" + toHexString(computeMD5(s.getBytes())) + \" <== \\\"\" + s + \"\\\"\")\n    }\n\n}\n\n", "explain": ""}, {"task_name": "MD5/Implementation", "task_url": "https://rosettacode.org/wiki/MD5/Implementation", "task_cat": "Checksums", "lang": "RPG", "code": "\n\n**FREE\nCtl-opt MAIN(Main);\nCtl-opt DFTACTGRP(*NO) ACTGRP(*NEW);\n\ndcl-pr QDCXLATE EXTPGM('QDCXLATE');\n  dataLen         packed(5\u00a0: 0) CONST;\n  data            char(32767) options(*VARSIZE);\n  conversionTable char(10) CONST;\nend-pr;\n\ndcl-c MASK32 CONST(4294967295);\ndcl-s SHIFT_AMTS int(3) dim(16) CTDATA PERRCD(16);\ndcl-s MD5_TABLE_T int(20) dim(64) CTDATA PERRCD(4);\n\ndcl-proc Main;\n  dcl-s inputData char(45);\n  dcl-s inputDataLen int(10) INZ(0);\n  dcl-s outputHash char(16);\n  dcl-s outputHashHex char(32);\n  \n  DSPLY 'Input: ' '' inputData;\n  inputData = %trim(inputData);\n  inputDataLen = %len(%trim(inputData));\n  DSPLY ('Input=' + inputData);\n  DSPLY ('InputLen=' + %char(inputDataLen));\n  \n  // Convert from EBCDIC to ASCII\n  if inputDataLen > 0;\n    QDCXLATE(inputDataLen\u00a0: inputData\u00a0: 'QTCPASC');\n  endif;\n  CalculateMD5(inputData\u00a0: inputDataLen\u00a0: outputHash);\n  // Convert to hex\n  ConvertToHex(outputHash\u00a0: 16\u00a0: outputHashHex);\n  DSPLY ('MD5: ' + outputHashHex);\n  return;\nend-proc;\n\ndcl-proc CalculateMD5;\n  dcl-pi *N;\n    message    char(65535) options(*VARSIZE) CONST;\n    messageLen int(10) value;\n    outputHash char(16);\n  end-pi;\n  dcl-s numBlocks int(10);\n  dcl-s padding char(72);\n  dcl-s a int(20) INZ(1732584193);\n  dcl-s b int(20) INZ(4023233417);\n  dcl-s c int(20) INZ(2562383102);\n  dcl-s d int(20) INZ(271733878);\n  dcl-s buffer int(20) dim(16) INZ(0);\n  dcl-s i int(10);\n  dcl-s j int(10);\n  dcl-s k int(10);\n  dcl-s multiplier int(20);\n  dcl-s index int(10);\n  dcl-s originalA int(20);\n  dcl-s originalB int(20);\n  dcl-s originalC int(20);\n  dcl-s originalD int(20);\n  dcl-s div16 int(10);\n  dcl-s f int(20);\n  dcl-s tempInt int(20);\n  dcl-s bufferIndex int(10);\n  dcl-ds byteToInt QUALIFIED;\n    n int(5) INZ(0);\n    c char(1) OVERLAY(n\u00a0: 2);\n  end-ds;\n  \n  numBlocks = (messageLen + 8) / 64 + 1;\n  MD5_FillPadding(messageLen\u00a0: numBlocks\u00a0: padding);\n  for i = 0 to numBlocks - 1;\n    index = i * 64;\n    \n    // Read message as little-endian 32-bit words\n    for j = 1 to 16;\n      multiplier = 1;\n      for k = 1 to 4;\n        index += 1;\n        if index <= messageLen;\n          byteToInt.c = %subst(message\u00a0: index\u00a0: 1);\n        else;\n          byteToInt.c = %subst(padding\u00a0: index - messageLen\u00a0: 1);\n        endif;\n        buffer(j) += multiplier * byteToInt.n;\n        multiplier *= 256;\n      endfor;\n    endfor;\n    \n    originalA = a;\n    originalB = b;\n    originalC = c;\n    originalD = d;\n    \n    for j = 0 to 63;\n      div16 = j / 16;\n      select;\n        when div16 = 0;\n          f = %bitor(%bitand(b\u00a0: c)\u00a0: %bitand(%bitnot(b)\u00a0: d));\n          bufferIndex = j;\n        \n        when div16 = 1;\n          f = %bitor(%bitand(b\u00a0: d)\u00a0: %bitand(c\u00a0: %bitnot(d)));\n          bufferIndex = %bitand(j * 5 + 1\u00a0: 15);\n        \n        when div16 = 2;\n          f = %bitxor(b\u00a0: %bitxor(c\u00a0: d));\n          bufferIndex = %bitand(j * 3 + 5\u00a0: 15);\n        \n        when div16 = 3;\n          f = %bitxor(c\u00a0: %bitor(b\u00a0: Mask32Bit(%bitnot(d))));\n          bufferIndex = %bitand(j * 7\u00a0: 15);\n      endsl;\n      tempInt = Mask32Bit(b + RotateLeft32Bit(a + f + buffer(bufferIndex + 1) + MD5_TABLE_T(j + 1)\u00a0:\n                                              SHIFT_AMTS(div16 * 4 + %bitand(j\u00a0: 3) + 1)));\n      a = d;\n      d = c;\n      c = b;\n      b = tempInt;\n    endfor;\n    a = Mask32Bit(a + originalA);\n    b = Mask32Bit(b + originalB);\n    c = Mask32Bit(c + originalC);\n    d = Mask32Bit(d + originalD);\n  endfor;\n  \n  for i = 0 to 3;\n    if i = 0;\n      tempInt = a;\n    elseif i = 1;\n      tempInt = b;\n    elseif i = 2;\n      tempInt = c;\n    else;\n      tempInt = d;\n    endif;\n    \n    for j = 0 to 3;\n      byteToInt.n = %bitand(tempInt\u00a0: 255);\n      %subst(outputHash\u00a0: i * 4 + j + 1\u00a0: 1) = byteToInt.c;\n      tempInt /= 256;\n    endfor;\n  endfor;\n  return;\nend-proc;\n\ndcl-proc MD5_FillPadding;\n  dcl-pi *N;\n    messageLen int(10);\n    numBlocks int(10);\n    padding char(72);\n  end-pi;\n  dcl-s totalLen int(10);\n  dcl-s paddingSize int(10);\n  dcl-ds *N;\n    messageLenBits int(20);\n    mlb_bytes char(8) OVERLAY(messageLenBits);\n  end-ds;\n  dcl-s i int(10);\n  \n  %subst(padding\u00a0: 1\u00a0: 1) = X'80';\n  totalLen = numBlocks * 64;\n  paddingSize = totalLen - messageLen; // 9 to 72\n  messageLenBits = messageLen;\n  messageLenBits *= 8;\n  for i = 1 to 8;\n    %subst(padding\u00a0: paddingSize - i + 1\u00a0: 1) = %subst(mlb_bytes\u00a0: i\u00a0: 1);\n  endfor;\n  for i = 2 to paddingSize - 8;\n    %subst(padding\u00a0: i\u00a0: 1) = X'00';\n  endfor;\n  return;\nend-proc;\n\ndcl-proc RotateLeft32Bit;\n  dcl-pi *N int(20);\n    n int(20) value;\n    amount int(3) value;\n  end-pi;\n  dcl-s i int(3);\n  \n  n = Mask32Bit(n);\n  for i = 1 to amount;\n    n *= 2;\n    if n >= 4294967296;\n      n -= MASK32;\n    endif;\n  endfor;\n  return n;\nend-proc;\n\ndcl-proc Mask32Bit;\n  dcl-pi *N int(20);\n    n int(20) value;\n  end-pi;\n  return %bitand(n\u00a0: MASK32);\nend-proc;\n\ndcl-proc ConvertToHex;\n  dcl-pi *N;\n    inputData    char(32767) options(*VARSIZE) CONST;\n    inputDataLen int(10) value;\n    outputData   char(65534) options(*VARSIZE);\n  end-pi;\n  dcl-c HEX_CHARS CONST('0123456789ABCDEF');\n  dcl-s i int(10);\n  dcl-s outputOffset int(10) INZ(1);\n  dcl-ds dataStruct QUALIFIED;\n    numField int(5) INZ(0);\n    // IBM i is big-endian\n    charField char(1) OVERLAY(numField\u00a0: 2);\n  end-ds;\n  \n  for i = 1 to inputDataLen;\n    dataStruct.charField = %BitAnd(%subst(inputData\u00a0: i\u00a0: 1)\u00a0: X'F0');\n    dataStruct.numField /= 16;\n    %subst(outputData\u00a0: outputOffset\u00a0: 1) = %subst(HEX_CHARS\u00a0: dataStruct.numField + 1\u00a0: 1);\n    outputOffset += 1;\n    dataStruct.charField = %BitAnd(%subst(inputData\u00a0: i\u00a0: 1)\u00a0: X'0F');\n    %subst(outputData\u00a0: outputOffset\u00a0: 1) = %subst(HEX_CHARS\u00a0: dataStruct.numField + 1\u00a0: 1);\n    outputOffset += 1;\n  endfor;\n  return;\nend-proc;\n\n**CTDATA SHIFT_AMTS\n  7 12 17 22  5  9 14 20  4 11 16 23  6 10 15 21\n**CTDATA MD5_TABLE_T\n          3614090360          3905402710           606105819          3250441966\n          4118548399          1200080426          2821735955          4249261313\n          1770035416          2336552879          4294925233          2304563134\n          1804603682          4254626195          2792965006          1236535329\n          4129170786          3225465664           643717713          3921069994\n          3593408605            38016083          3634488961          3889429448\n           568446438          3275163606          4107603335          1163531501\n          2850285829          4243563512          1735328473          2368359562\n          4294588738          2272392833          1839030562          4259657740\n          2763975236          1272893353          4139469664          3200236656\n           681279174          3936430074          3572445317            76029189\n          3654602809          3873151461           530742520          3299628645\n          4096336452          1126891415          2878612391          4237533241\n          1700485571          2399980690          4293915773          2240044497\n          1873313359          4264355552          2734768916          1309151649\n          4149444226          3174756917           718787259          3951481745\n\n DSPLY  Input:\n abcdefghijklmnopqrstuvwxyz\n DSPLY  Input=abcdefghijklmnopqrstuvwxyz\n DSPLY  InputLen=26\n DSPLY  MD5: C3FCD3D76192E4007DFB496CCA67E13B\n", "explain": "Based on my Java implementation. Uses free-form RPG and a CTDATA section to hold lookup tables. Converts input from EBCDIC to ASCII before hashing.\nSample output:\n"}]