[{"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Python", "code": "\nPython: With tutor[edit]\ntutor = True\n\ndef halve(x):\n    return x // 2\n\ndef double(x):\n    return x * 2\n\ndef even(x):\n    return not x % 2\n\ndef ethiopian(multiplier, multiplicand):\n    if tutor:\n        print(\"Ethiopian multiplication of %i and %i\" %\n              (multiplier, multiplicand))\n    result = 0\n    while multiplier >= 1:\n        if even(multiplier):\n            if tutor:\n                print(\"%4i %6i STRUCK\" %\n                      (multiplier, multiplicand))\n        else:\n            if tutor:\n                print(\"%4i %6i KEPT\" %\n                      (multiplier, multiplicand))\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n    if tutor:\n        print()\n    return result\n\n\nPython 3.1 (r31:73574, Jun 26 2009, 20:21:35) [MSC v.1500 32 bit (Intel)] on win32\nType \"copyright\", \"credits\" or \"license()\" for more information.\n>>> ethiopian(17, 34)\nEthiopian multiplication of 17 and 34\n  17     34 KEPT\n   8     68 STRUCK\n   4    136 STRUCK\n   2    272 STRUCK\n   1    544 KEPT\n\n578\n>>>\nPython: Without tutor[edit]\n\nhalve  = lambda x: x // 2\ndouble = lambda x: x*2\neven   = lambda x: not x\u00a0% 2\n \ndef ethiopian(multiplier, multiplicand):\n    result = 0\n\n    while multiplier >= 1:\n        if not even(multiplier):\n            result += multiplicand\n        multiplier   = halve(multiplier)\n        multiplicand = double(multiplicand)\n\n    return result\nPython: With tutor. More Functional[edit]\nUsing some features which Python has for use in functional programming. The example also tries to show how to mix different programming styles while keeping close to the task specification, a kind of \"executable pseudocode\". Note: While column2 could theoretically generate a sequence of infinite length, izip will stop requesting values from it (and so provide the necessary stop condition) when column1 has no more values. When not using the tutor, table will generate the table on the fly in an efficient way, not keeping any intermediate values.tutor = True\n\nfrom itertools import izip, takewhile\n\ndef iterate(function, arg):\n    while 1:\n        yield arg\n        arg = function(arg)\n\ndef halve(x): return x // 2\ndef double(x): return x * 2\ndef even(x): return x\u00a0% 2 == 0\n\ndef show_heading(multiplier, multiplicand):\n    print \"Multiplying %d by %d\"\u00a0% (multiplier, multiplicand),\n    print \"using Ethiopian multiplication:\"\n    print\n\nTABLE_FORMAT = \"%8s %8s %8s %8s %8s\"\n\ndef show_table(table):\n    for p, q in table:\n        print TABLE_FORMAT\u00a0% (p, q, \"->\",\n                              p, q if not even(p) else \"-\" * len(str(q)))\n\ndef show_result(result):\n    print TABLE_FORMAT\u00a0% ('', '', '', '', \"=\" * (len(str(result)) + 1))\n    print TABLE_FORMAT\u00a0% ('', '', '', '', result)\n\ndef ethiopian(multiplier, multiplicand):\n    def column1(x): return takewhile(lambda v: v >= 1, iterate(halve, x))\n    def column2(x): return iterate(double, x)\n    def rows(x, y): return izip(column1(x), column2(y))\n    table = rows(multiplier, multiplicand)\n    if tutor: \n        table = list(table)\n        show_heading(multiplier, multiplicand)\n        show_table(table)\n    result = sum(q for p, q in table if not even(p))\n    if tutor: \n        show_result(result)\n    return result\nExample output:\n>>> ethiopian(17, 34)\nMultiplying 17 by 34 using Ethiopian multiplication:\n\n     17       34       ->       17       34\n      8       68       ->        8       --\n      4      136       ->        4      ---\n      2      272       ->        2      ---\n      1      544       ->        1      544\n                                       ====\n                                        578\n578\n\nPython: as an unfold followed by a fold[edit]\nTranslation of: Haskell\nWorks with: Python version 3.7\n\n'''Ethiopian multiplication'''\n\nfrom functools import reduce\n\n\n# ethMult\u00a0:: Int -> Int -> Int\ndef ethMult(n):\n    '''Ethiopian multiplication of n by m.'''\n\n    def doubled(x):\n        return x + x\n\n    def halved(h):\n        qr = divmod(h, 2)\n        if 0 < h:\n            print('halve:', str(qr).rjust(8, ' '))\n        return qr if 0 < h else None\n\n    def addedWhereOdd(a, remx):\n        odd, x = remx\n        if odd:\n            print(\n                str(a).rjust(2, ' '), '+',\n                str(x).rjust(3, ' '), '->',\n                str(a + x).rjust(3, ' ')\n            )\n            return a + x\n        else:\n            print(str(x).rjust(8, ' '))\n            return a\n\n    return lambda m: reduce(\n        addedWhereOdd,\n        zip(\n            unfoldr(halved)(n),\n            iterate(doubled)(m)\n        ),\n        0\n    )\n\n\n# ------------------------- TEST -------------------------\ndef main():\n    '''Tests of multiplication.'''\n\n    print(\n        '\\nProduct:    ' + str(\n            ethMult(17)(34)\n        ),\n        '\\n_______________\\n'\n    )\n    print(\n        '\\nProduct:    ' + str(\n            ethMult(34)(17)\n        )\n    )\n\n\n# ----------------------- GENERIC ------------------------\n\n# iterate\u00a0:: (a -> a) -> a -> Gen [a]\ndef iterate(f):\n    '''An infinite list of repeated\n       applications of f to x.\n    '''\n    def go(x):\n        v = x\n        while True:\n            yield v\n            v = f(v)\n    return go\n\n\n# showLog\u00a0:: a -> IO String\ndef showLog(*s):\n    '''Arguments printed with\n       intercalated arrows.'''\n    print(\n        ' -> '.join(map(str, s))\n    )\n\n\n# unfoldr\u00a0:: (b -> Maybe (a, b)) -> b -> [a]\ndef unfoldr(f):\n    '''Dual to reduce or foldr.\n       Where catamorphism reduces a list to a summary value,\n       the anamorphic unfoldr builds a list from a seed value.\n       As long as f returns Just(a, b), a is prepended to the list,\n       and the residual b is used as the argument for the next\n       application of f.\n       When f returns Nothing, the completed list is returned.'''\n    def go(v):\n        xr = v, v\n        xs = []\n        while True:\n            xr = f(xr[0])\n            if xr:\n                xs.append(xr[1])\n            else:\n                return xs\n        return xs\n    return go\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\nhalve:   (8, 1)\nhalve:   (4, 0)\nhalve:   (2, 0)\nhalve:   (1, 0)\nhalve:   (0, 1)\n 0 +  34 ->  34\n      68\n     136\n     272\n34 + 544 -> 578\n\nProduct:    578 \n_______________\n\nhalve:  (17, 0)\nhalve:   (8, 1)\nhalve:   (4, 0)\nhalve:   (2, 0)\nhalve:   (1, 0)\nhalve:   (0, 1)\n      17\n 0 +  34 ->  34\n      68\n     136\n     272\n34 + 544 -> 578\n\nProduct:    578\n", "explain": "Sample output\nWithout the tutorial code, and taking advantage of Python's lambda:\n\nAvoiding the use of the multiplication operator, and defining a catamorphism applied over an anamorphism.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdbool.h>\n\nvoid halve(int *x) { *x >>= 1; }\nvoid doublit(int *x)  { *x <<= 1; }\nbool iseven(const int x) { return (x & 1) ==  0; }\n\nint ethiopian(int plier,\n\t      int plicand, const bool tutor)\n{\n  int result=0;\n\n  if (tutor)\n    printf(\"ethiopian multiplication of %d by %d\\n\", plier, plicand);\n  \n  while(plier >= 1) {\n    if ( iseven(plier) ) {\n      if (tutor) printf(\"%4d %6d struck\\n\", plier, plicand);\n    } else {\n      if (tutor) printf(\"%4d %6d kept\\n\", plier, plicand);\n      result += plicand;\n    }\n    halve(&plier); doublit(&plicand);\n  }\n  return result;\n}\n\nint main()\n{\n  printf(\"%d\\n\", ethiopian(17, 34, true));\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "C++", "code": "\n\ntemplate<int N>\nstruct Half    \n{              \n        enum { Result = N >> 1 };\n};                               \n\ntemplate<int N>\nstruct Double  \n{              \n        enum { Result = N << 1 };\n};                               \n\ntemplate<int N>\nstruct IsEven  \n{              \n        static const bool Result = (N & 1) == 0;\n};\n\ntemplate<int Multiplier, int Multiplicand>\nstruct EthiopianMultiplication\n{\n        template<bool Cond, int Plier, int RunningTotal>\n        struct AddIfNot\n        {\n                enum { Result = Plier + RunningTotal };\n        };\n        template<int Plier, int RunningTotal>\n        struct AddIfNot <true, Plier, RunningTotal>\n        {\n                enum { Result = RunningTotal };\n        };\n\n        template<int Plier, int Plicand, int RunningTotal>\n        struct Loop\n        {\n                enum { Result = Loop<Half<Plier>::Result, Double<Plicand>::Result,\n                       AddIfNot<IsEven<Plier>::Result, Plicand, RunningTotal >::Result >::Result };\n        };\n        template<int Plicand, int RunningTotal>\n        struct Loop <0, Plicand, RunningTotal>\n        {\n                enum { Result = RunningTotal };\n        };\n\n        enum { Result = Loop<Multiplier, Multiplicand, 0>::Result };\n};\n\n#include <iostream>\n\nint main(int, char **)\n{\n        std::cout << EthiopianMultiplication<17, 54>::Result << std::endl;\n        return 0;\n}\n\n", "explain": "Using C++ templates, these kind of tasks can be implemented as meta-programs.\nThe program runs at compile time, and the result is statically\nsaved into regularly compiled code.\nHere is such an implementation without tutor, since there is no mechanism in C++ to output\nmessages during program compilation.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Java", "code": "\nWorks with: Java version 1.5+\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.Scanner;\npublic class Mult{\n  public static void main(String[] args){\n    Scanner sc = new Scanner(System.in);\n    int first = sc.nextInt();\n    int second = sc.nextInt();\n\n    if(first < 0){\n        first = -first;\n        second = -second;\n    }\n\n    Map<Integer, Integer> columns = new HashMap<Integer, Integer>();\n        columns.put(first, second);\n    int sum = isEven(first)? 0 : second;\n    do{\n      first = halveInt(first);\n      second = doubleInt(second);\n      columns.put(first, second);\n      if(!isEven(first)){\n          sum += second;\n      }\n    }while(first > 1);\n \n    System.out.println(sum);\n  }\n\n  public static int doubleInt(int doubleMe){\n    return doubleMe << 1; //shift left\n  }\n\n  public static int halveInt(int halveMe){\n    return halveMe >>> 1; //shift right\n  }\n\n  public static boolean isEven(int num){\n    return (num & 1) == 0;\n  }\n}\nAn optimised variant using the three helper functions from the other example./**\n * This method will use ethiopian styled multiplication.\n * @param a Any non-negative integer.\n * @param b Any integer.\n * @result a multiplied by b\n */\npublic static int ethiopianMultiply(int a, int b) {\n  if(a==0 || b==0) {\n    return 0;\n  }\n  int result = 0;\n  while(a>=1) {\n    if(!isEven(a)) {\n      result+=b;\n    }\n    b = doubleInt(b);\n    a = halveInt(a);\n  }\n  return result;\n}\n\n/**\n * This method is an improved version that will use\n * ethiopian styled multiplication, and also\n * supports negative parameters.\n * @param a Any integer.\n * @param b Any integer.\n * @result a multiplied by b\n */\npublic static int ethiopianMultiplyWithImprovement(int a, int b) {\n  if(a==0 || b==0) {\n    return 0;\n  }\n  if(a<0) {\n    a=-a;\n    b=-b;\n  } else if(b>0 && a>b) {\n    int tmp = a;\n    a = b;\n    b = tmp;\n  }\n  int result = 0;\n  while(a>=1) {\n    if(!isEven(a)) {\n      result+=b;\n    }\n    b = doubleInt(b);\n    a = halveInt(a);\n  }\n  return result;\n}\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "C#", "code": "\nWorks with: C# version 3+\nLibrary: System.Linq\nusing System;\nusing System.Linq;\n\nnamespace RosettaCode.Tasks\n{\n\tpublic static class EthiopianMultiplication_Task\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Ethiopian Multiplication\" );\n\t\t\tint A = 17, B = 34;\n\t\t\tConsole.WriteLine ( \"Recursion: {0}*{1}={2}\", A, B, EM_Recursion ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Linq: {0}*{1}={2}\", A, B, EM_Linq ( A, B ) );\n\t\t\tConsole.WriteLine ( \"Loop: {0}*{1}={2}\", A, B, EM_Loop ( A, B ) );\n\t\t\tConsole.WriteLine ( );\n\t\t}\n\n\t\tpublic static int Halve ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number >> 1;\n\t\t}\n\t\tpublic static int Double ( this int p_Number )\n\t\t{\n\t\t\treturn p_Number << 1;\n\t\t}\n\t\tpublic static bool IsEven ( this int p_Number )\n\t\t{\n\t\t\treturn ( p_Number % 2 ) == 0;\n\t\t}\n\n\t\tpublic static int EM_Recursion ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t//     Anchor Point,                Recurse to find the next row                                 Sum it with the second number according to the rules\n\t\t\treturn p_NumberA == 1 ? p_NumberB : EM_Recursion ( p_NumberA.Halve ( ), p_NumberB.Double ( ) ) + ( p_NumberA.IsEven ( ) ? 0 : p_NumberB );\n\t\t}\n\t\tpublic static int EM_Linq ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\t// Creating a range from 1 to x where x the number of times p_NumberA can be halved.\n\t\t\t// This will be 2^x where 2^x <= p_NumberA. Basically, ln(p_NumberA)/ln(2).\n\t\t\treturn Enumerable.Range ( 1, Convert.ToInt32 ( Math.Log ( p_NumberA, Math.E ) / Math.Log ( 2, Math.E ) ) + 1 )\n\t\t\t\t// For every item (Y) in that range, create a new list, comprising the pair (p_NumberA,p_NumberB) Y times.\n\t\t\t\t.Select ( ( item ) => Enumerable.Repeat ( new { Col1 = p_NumberA, Col2 = p_NumberB }, item )\n\t\t\t\t\t// The aggregate method iterates over every value in the target list, passing the accumulated value and the current item's value.\n\t\t\t\t\t.Aggregate ( ( agg_pair, orig_pair ) => new { Col1 = agg_pair.Col1.Halve ( ), Col2 = agg_pair.Col2.Double ( ) } ) )\n\t\t\t\t// Remove all even items\n\t\t\t\t.Where ( pair => !pair.Col1.IsEven ( ) )\n\t\t\t\t// And sum!\n\t\t\t\t.Sum ( pair => pair.Col2 );\n\t\t}\n\t\tpublic static int EM_Loop ( int p_NumberA, int p_NumberB )\n\t\t{\n\t\t\tint RetVal = 0;\n\t\t\twhile ( p_NumberA >= 1 )\n\t\t\t{\n\t\t\t\tRetVal += p_NumberA.IsEven ( ) ? 0 : p_NumberB;\n\t\t\t\tp_NumberA = p_NumberA.Halve ( );\n\t\t\t\tp_NumberB = p_NumberB.Double ( );\n\t\t\t}\n\t\t\treturn RetVal;\n\t\t}\n\t}\n}\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "JavaScript", "code": "\nvar eth = {\n\t\n\thalve : function ( n ){  return Math.floor(n/2);  },\n\tdouble: function ( n ){  return 2*n;              },\n\tisEven: function ( n ){  return n%2 === 0);       },\n\t\n\tmult: function ( a , b ){\n\t\tvar sum = 0, a = [a], b = [b];\n\t\t\n\t\twhile ( a[0] !== 1 ){\n\t\t\ta.unshift( eth.halve( a[0] ) );\n\t\t\tb.unshift( eth.double( b[0] ) );\n\t\t}\n\t\t\n\t\tfor( var i = a.length - 1; i > 0 ; i -= 1 ){\n\t\t\t\n\t\t\tif( !eth.isEven( a[i] ) ){\n\t\t\t\tsum += b[i];\n\t\t\t}\n\t\t}\t\t\n\t\treturn sum + b[0];\n\t}\n}\n// eth.mult(17,34) returns 578\n\n\nHalve an integer, in this sense, with a right-shift (n >>= 1)\nDouble an integer by addition to self (m += m)\nTest if an integer is odd by bitwise and (n & 1)\n\nfunction ethMult(m, n) {\n  var o = !isNaN(m) ? 0 : ''; // same technique works with strings\n  if (n < 1) return o;\n  while (n > 1) {\n    if (n & 1) o += m;  // 3. integer odd/even? (bit-wise and 1)\n    n >>= 1;            // 1. integer halved (by right-shift)\n    m += m;             // 2. integer doubled (addition to self)\n  }\n  return o + m;\n}\n\nethMult(17, 34)\n\n\nOutput:\n578\n\nethMult('Ethiopian', 34)\n\n\nOutput:\n\"EthiopianEthiopianEthiopianEthiopianEthiopianEthiopian\nEthiopianEthiopianEthiopianEthiopianEthiopianEthiopianEthiopian\nEthiopianEthiopianEthiopianEthiopianEthiopianEthiopianEthiopian\nEthiopianEthiopianEthiopianEthiopianEthiopianEthiopianEthiopian\nEthiopianEthiopianEthiopianEthiopianEthiopianEthiopianEthiopian\"\n", "explain": "\nOr, avoiding the use of a multiplication operator in the version above, we can alternatively:\n\n\nNote that the same function will also multiply strings with some efficiency, particularly where n is larger. See Repeat_a_string\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "PHP", "code": "\nNot object oriented version:<?php\nfunction halve($x)\n{\n  return floor($x/2);\n}\n\nfunction double($x)\n{\n  return $x*2;\n}\n\nfunction iseven($x)\n{\n  return !($x & 0x1);\n}\n\nfunction ethiopicmult($plier, $plicand, $tutor)\n{\n  if ($tutor) echo \"ethiopic multiplication of $plier and $plicand\\n\";\n  $r = 0;\n  while($plier >= 1) {\n    if ( !iseven($plier) ) $r += $plicand;\n    if ($tutor)\n      echo \"$plier, $plicand \", (iseven($plier) ? \"struck\" : \"kept\"), \"\\n\";\n    $plier = halve($plier);\n    $plicand = double($plicand);\n  }\n  return $r;\n}\n\necho ethiopicmult(17, 34, true), \"\\n\";\n\n?>\n\nOutput:\nethiopic multiplication of 17 and 34\n17, 34 kept\n8, 68 struck\n4, 136 struck\n2, 272 struck\n1, 544 kept\n578 \n\n\nWorks with: PHP5<?php\n\nclass ethiopian_multiply {\n\n   protected $result = 0;\n\n   protected function __construct($x, $y){\n      while($x >= 1){\n         $this->sum_result($x, $y);\n         $x = $this->half_num($x);\n         $y = $this->double_num($y);\n      }\n   }\n   \n   protected function half_num($x){\n      return floor($x/2);\n   }\n\n   protected function double_num($y){\n      return $y*2;\n   }\n   \n   protected function not_even($n){\n      return $n%2 != 0 ? true : false;\n   }\n   \n   protected function sum_result($x, $y){\n      if($this->not_even($x)){\n         $this->result += $y;\n      }\n   }\n   \n   protected function get_result(){\n      return $this->result;\n   }\n   \n   static public function init($x, $y){\n      $init = new ethiopian_multiply($x, $y);\n      return $init->get_result();\n   }\n   \n}\n\necho ethiopian_multiply::init(17, 34);\n?>\n\n", "explain": "Object Oriented version:\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "MATLAB", "code": "\n\nfunction result = halveInt(number)\n    \n    result = idivide(number,2,'floor');\n\nend\n\n\nfunction result = doubleInt(number)\n\n    result = times(2,number);\n\nend\n\n\n%Returns a logical 1 if the number is even, 0 otherwise.\nfunction trueFalse = isEven(number)\n\n    trueFalse = logical( mod(number,2)==0 );\n    \nend\n\n\nfunction answer = ethiopianMultiplication(multiplicand,multiplier)\n \n    %Generate columns\n    while multiplicand(end)>1\n        multiplicand(end+1,1) = halveInt( multiplicand(end) );\n        multiplier(end+1,1) = doubleInt( multiplier(end) );\n    end\n \n    %Strike out appropriate rows\n    multiplier( isEven(multiplicand) ) = [];\n \n    %Generate answer\n    answer = sum(multiplier);\n \nend\n\n\nethiopianMultiplication( int32(17),int32(34) )\n\nans =\n\n   578\n\n", "explain": "First we define the three subroutines needed for this task. These must be saved in their own individual \".m\" files. The file names must be the same as the function name stored in that file. Also, they must be saved in the same directory as the script that performs the Ethiopian Multiplication. \nIn addition, with the exception of the \"isEven\" and \"doubleInt\" functions, the inputs of the functions have to be an integer data type. This means that the input to these functions must be coerced from the default IEEE754 double precision floating point data type that all numbers and variables are represented as, to integer data types. As of MATLAB 2007a, 64-bit integer arithmetic is not supported. So, at best, these will work for 32-bit integer data types.  \nhalveInt.m:\ndoubleInt.m:\nisEven.m:\nethiopianMultiplication.m:\nSample input: (with data type coercion)\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and laterprogram EthiopicMult\n  implicit none\n\n  print *, ethiopic(17, 34, .true.)\n\ncontains\n\n  subroutine halve(v)\n    integer, intent(inout) :: v\n    v = int(v / 2)\n  end subroutine halve\n\n  subroutine doublit(v)\n    integer, intent(inout) :: v\n    v = v * 2\n  end subroutine doublit\n\n  function iseven(x)\n    logical :: iseven\n    integer, intent(in) :: x\n    iseven = mod(x, 2) == 0\n  end function iseven\n\n  function ethiopic(multiplier, multiplicand, tutorialized) result(r)\n    integer :: r\n    integer, intent(in) :: multiplier, multiplicand\n    logical, intent(in), optional :: tutorialized\n\n    integer :: plier, plicand\n    logical :: tutor\n\n    plier = multiplier\n    plicand = multiplicand\n\n    if ( .not. present(tutorialized) ) then\n       tutor = .false.\n    else\n       tutor = tutorialized\n    endif\n\n    r = 0\n\n    if ( tutor ) write(*, '(A, I0, A, I0)') \"ethiopian multiplication of \", plier, \" by \", plicand\n\n    do while(plier >= 1)\n       if ( iseven(plier) ) then\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" struck\"\n       else\n          if (tutor) write(*, '(I4, \" \", I6, A)') plier, plicand, \" kept\"\n          r = r + plicand\n       endif\n       call halve(plier)\n       call doublit(plicand)\n    end do\n\n  end function ethiopic\n\nend program EthiopicMult\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc halve(i int) int { return i/2 }\n\nfunc double(i int) int { return i*2 }\n\nfunc isEven(i int) bool { return i%2 == 0 }\n\nfunc ethMulti(i, j int) (r int) {\n    for ; i > 0; i, j = halve(i), double(j) {\n        if !isEven(i) {\n            r += j\n        }\n    }\n    return\n}\n\nfunc main() {\n    fmt.Printf(\"17 ethiopian 34 = %d\\n\", ethMulti(17, 34))\n}\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program multieth.s   */\n\n /* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult:         .asciz \"Result\u00a0: \"\nszMessStart:          .asciz \"Program 32 bits start.\\n\"\nszCarriageReturn:     .asciz \"\\n\"\nszMessErreur:         .asciz \"Error overflow. \\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:             .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                            @ entry of program \n    ldr r0,iAdrszMessStart\n    bl affichageMess\n    mov r0,#17\n    mov r1,#34\n    bl multEthiop\n    ldr r1,iAdrsZoneConv\n    bl conversion10              @ decimal conversion\n    mov r0,#3                    @ number string to display\n    ldr r1,iAdrszMessResult\n    ldr r2,iAdrsZoneConv         @ insert conversion in message\n    ldr r3,iAdrszCarriageReturn\n    bl displayStrings            @ display message\n\n100:                              @ standard end of the program \n    mov r0, #0                    @ return code\n    mov r7, #EXIT                 @ request to exit program\n    svc #0                        @ perform the system call\niAdrszCarriageReturn:        .int szCarriageReturn\niAdrsZoneConv:               .int sZoneConv\niAdrszMessResult:            .int szMessResult\niAdrszMessErreur:            .int szMessErreur\niAdrszMessStart:             .int szMessStart\n/******************************************************************/\n/*     Ethiopian multiplication                                  */ \n/******************************************************************/\n/*  r0  first factor */\n/*  r1   2th  factor  */\n/*  r0 return r\u00e9sult  */\nmultEthiop:\n    push {r1-r3,lr}            @ save registers\n    mov r2,#0                  @ init result\n 1:                            @ loop\n    cmp r0,#1                  @ end\u00a0?\n    blt 3f\n    ands r3,r0,#1              @ \n    addne r2,r1                @ add factor2 to result\n    lsr r0,#1                  @ divide factor1 by 2\n    lsls r1,#1                 @ multiply factor2 by 2\n    bcs 2f                     @ overflow\u00a0?\n    b 1b                       @ or loop\n 2:                            @ error display \n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n    mov r2,#0\n 3:\n    mov r0,r2                  @ return result\n    pop {r1-r3,pc}\n/***************************************************/\n/*   display multi strings                    */\n/***************************************************/\n/* r0  contains number strings address */\n/* r1 address string1 */\n/* r2 address string2 */\n/* r3 address string3 */\n/* other address on the stack */\n/* thinck to add  number other address * 4 to add to the stack */\ndisplayStrings:            @ INFO:  displayStrings\n    push {r1-r4,fp,lr}     @ save des registres\n    add fp,sp,#24          @ save param\u00e9ters address (6 registers saved * 4 bytes)\n    mov r4,r0              @ save strings number\n    cmp r4,#0              @ 0 string -> end\n    ble 100f\n    mov r0,r1              @ string 1\n    bl affichageMess\n    cmp r4,#1              @ number > 1\n    ble 100f\n    mov r0,r2\n    bl affichageMess\n    cmp r4,#2\n    ble 100f\n    mov r0,r3\n    bl affichageMess\n    cmp r4,#3\n    ble 100f\n    mov r3,#3\n    sub r2,r4,#4\n1:                         @ loop extract address string on stack\n    ldr r0,[fp,r2,lsl #2]\n    bl affichageMess\n    subs r2,#1\n    bge 1b\n100:\n    pop {r1-r4,fp,pc}\n\n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nProgram 32 bits start.\nResult\u00a0: 578\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Object_Pascal", "code": "\nmultiplication.pas:unit Multiplication;\ninterface\n\nfunction Double(Number: Integer): Integer;\nfunction Halve(Number: Integer): Integer;\nfunction Even(Number: Integer): Boolean;\nfunction Ethiopian(NumberA, NumberB: Integer): Integer;\n\nimplementation\n  function Double(Number: Integer): Integer;\n  begin\n    result := Number * 2\n  end;\n\n  function Halve(Number: Integer): Integer;\n  begin\n    result := Number div 2\n  end;\n\n  function Even(Number: Integer): Boolean;\n  begin\n    result := Number mod 2 = 0\n  end;\n\n  function Ethiopian(NumberA, NumberB: Integer): Integer;\n  begin\n    result := 0;\n    while NumberA >= 1 do\n    begin\n      if not Even(NumberA) then\n        result := result + NumberB;\n      NumberA := Halve(NumberA);\n      NumberB := Double(NumberB)\n    end\n  end;\nbegin\nend.\nethiopianmultiplication.pas:program EthiopianMultiplication;\n\nuses\n  Multiplication;\n\nbegin\n  WriteLn('17 * 34 = ', Ethiopian(17, 34))\nend.\n\nOutput:\n17 * 34 = 578\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Ruby", "code": "\n\ndef halve(x) = x/2\ndef double(x) = x*2\n\n# iterative\ndef ethiopian_multiply(a, b)\n  product = 0\n  while a >= 1 \n    p [a, b, a.even?\u00a0? \"STRIKE\"\u00a0: \"KEEP\"] if $DEBUG\n    product += b unless a.even?\n    a = halve(a)\n    b = double(b)\n  end\n  product\nend\n\n# recursive\ndef rec_ethiopian_multiply(a, b)\n  return 0 if a < 1\n  p [a, b, a.even?\u00a0? \"STRIKE\"\u00a0: \"KEEP\"] if $DEBUG\n  (a.even?\u00a0? 0\u00a0: b) + rec_ethiopian_multiply(halve(a), double(b))\nend\n\n$DEBUG = true   # $DEBUG also set to true if \"-d\" option given\na, b = 20, 5\nputs \"#{a} * #{b} = #{ethiopian_multiply(a,b)}\"; puts\n\nOutput:\n[20, 5, \"STRIKE\"]\n[10, 10, \"STRIKE\"]\n[5, 20, \"KEEP\"]\n[2, 40, \"STRIKE\"]\n[1, 80, \"KEEP\"]\n20 * 5 = 100\n\nrequire 'test/unit'\nclass EthiopianTests < Test::Unit::TestCase\n  def test_iter1; assert_equal(578, ethopian_multiply(17,34)); end\n  def test_iter2; assert_equal(100, ethopian_multiply(20,5));  end\n  def test_iter3; assert_equal(5,   ethopian_multiply(5,1));   end\n  def test_iter4; assert_equal(5,   ethopian_multiply(1,5));   end\n  def test_iter5; assert_equal(0,   ethopian_multiply(5,0));   end\n  def test_iter6; assert_equal(0,   ethopian_multiply(0,5));   end\n  def test_rec1;  assert_equal(578, rec_ethopian_multiply(17,34)); end\n  def test_rec2;  assert_equal(100, rec_ethopian_multiply(20,5));  end\n  def test_rec3;  assert_equal(5,   rec_ethopian_multiply(5,1));   end\n  def test_rec4;  assert_equal(5,   rec_ethopian_multiply(1,5));   end\n  def test_rec5;  assert_equal(0,   rec_ethopian_multiply(5,0));   end\n  def test_rec6;  assert_equal(0,   rec_ethopian_multiply(0,5));   end\nend\nRun options: \n\n# Running tests:\n\n............\nFinished tests in 0.014001s, 857.0816 tests/s, 857.0816 assertions/s.\n\n12 tests, 12 assertions, 0 failures, 0 errors, 0 skips\n\nruby -v: ruby 2.0.0p247 (2013-06-27) [i386-mingw32]\n\n", "explain": "Iterative and recursive implementations here.\nI've chosen to highlight the example 20*5 which I think is more illustrative.\nA test suite:\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Rust", "code": "\nfn double(a: i32) -> i32 {\n    2*a\n}\n\nfn halve(a: i32) -> i32 {\n    a/2\n}\n\nfn is_even(a: i32) -> bool {\n    a\u00a0% 2 == 0\n}\n\nfn ethiopian_multiplication(mut x: i32, mut y: i32) -> i32 {\n    let mut sum = 0;\n\n    while x >= 1 {\n        print!(\"{} \\t {}\", x, y);\n        match is_even(x) {\n            true  => println!(\"\\t Not Kept\"),\n            false => {\n                println!(\"\\t Kept\");\n                sum += y;\n            }\n        }\n        x = halve(x);\n        y = double(y);\n    }\n    sum\n}\n\nfn main() {\n    let output = ethiopian_multiplication(17, 34);\n    println!(\"---------------------------------\");\n    println!(\"\\t {}\", output);\n}\n\nOutput:\n17       34      Kept\n8        68      Not Kept\n4        136     Not Kept\n2        272     Not Kept\n1        544     Kept\n---------------------------------\n         578\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Swift", "code": "\nimport Darwin\n\nfunc ethiopian(var #int1:Int, var #int2:Int) -> Int {\n  var lhs = [int1], rhs = [int2]\n  \n  func isEven(#n:Int) -> Bool {return n\u00a0% 2 == 0}\n  func double(#n:Int) -> Int {return n * 2}\n  func halve(#n:Int) -> Int {return n / 2}\n  \n  while int1\u00a0!= 1 {\n    lhs.append(halve(n: int1))\n    rhs.append(double(n: int2))\n    int1 = halve(n: int1)\n    int2 = double(n: int2)\n  }\n  \n  var returnInt = 0\n  for (a,b) in zip(lhs, rhs) {\n    if (!isEven(n: a)) {\n      returnInt += b\n    }\n  }\n  return returnInt\n}\n\nprintln(ethiopian(int1: 17, int2: 34))\n\nOutput:\n578\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "R", "code": "\nR: With tutor[edit]\nhalve <- function(a) floor(a/2)\ndouble <- function(a) a*2\niseven <- function(a) (a%%2)==0\n\nethiopicmult <- function(plier, plicand, tutor=FALSE) {\n  if (tutor) { cat(\"ethiopic multiplication of\", plier, \"and\", plicand, \"\\n\") }\n  result <- 0\n  while(plier >= 1) {\n    if (!iseven(plier)) { result <- result + plicand }\n    if (tutor) {\n      cat(plier, \", \", plicand, \" \", ifelse(iseven(plier), \"struck\", \"kept\"), \"\\n\", sep=\"\")\n    }\n    plier <- halve(plier)\n    plicand <- double(plicand)\n  }\n  result\n}\n\nprint(ethiopicmult(17, 34, TRUE))\nR: Without tutor[edit]\n\nhalve <- function(a) floor(a/2)\ndouble <- function(a) a*2\niseven <- function(a) (a%%2)==0\n\nethiopicmult<-function(x,y){\n\tres<-ifelse(iseven(y),0,x)\n\twhile(!y==1){\n\t\tx<-double(x)\n\t\ty<-halve(y)\n\t\tif(!iseven(y)) res<-res+x\n\t}\n\treturn(res)\n}\n\nprint(ethiopicmult(17,34))\n", "explain": "Simplified version.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "COBOL", "code": "\nTranslation of: Common Lisp\nWorks with: COBOL version 2002\nWorks with: OpenCOBOL version 1.1\n\n       *>* Ethiopian multiplication\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiplication.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  l                  PICTURE 9(10) VALUE 17.\n       01  r                  PICTURE 9(10) VALUE 34.\n       01  ethiopian-multiply PICTURE 9(20).\n       01  product            PICTURE 9(20).\n       PROCEDURE DIVISION.\n         CALL \"ethiopian-multiply\" USING\n           BY CONTENT l, BY CONTENT r,\n           BY REFERENCE ethiopian-multiply\n         END-CALL\n         DISPLAY ethiopian-multiply END-DISPLAY\n         MULTIPLY l BY r GIVING product END-MULTIPLY\n         DISPLAY product END-DISPLAY\n         STOP RUN.\n       END PROGRAM ethiopian-multiplication.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. ethiopian-multiply.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  evenp   PICTURE 9.\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       LINKAGE SECTION.\n       01  l       PICTURE 9(10).\n       01  r       PICTURE 9(10).\n       01  product PICTURE 9(20) VALUE ZERO.\n       PROCEDURE DIVISION using l, r, product.\n         MOVE ZEROES TO product\n         PERFORM UNTIL l EQUAL ZERO\n           CALL \"evenp\" USING\n             BY CONTENT l,\n             BY REFERENCE evenp\n           END-CALL\n           IF odd\n             ADD r TO product GIVING product END-ADD\n           END-IF\n           CALL \"halve\" USING\n             BY CONTENT l,\n             BY REFERENCE l\n           END-CALL\n           CALL \"twice\" USING\n             BY CONTENT r,\n             BY REFERENCE r\n           END-CALL\n         END-PERFORM\n         GOBACK.\n       END PROGRAM ethiopian-multiply.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. halve.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING m END-DIVIDE\n         GOBACK.\n       END PROGRAM halve.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. twice.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(10).\n       PROCEDURE DIVISION USING n, m.\n         MULTIPLY n by 2 GIVING m END-MULTIPLY\n         GOBACK.\n       END PROGRAM twice.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. evenp.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  q   PICTURE 9(10).\n       LINKAGE SECTION.\n       01  n   PICTURE 9(10).\n       01  m   PICTURE 9(1).\n         88 even   VALUE 1.\n         88 odd    VALUE 0.\n       PROCEDURE DIVISION USING n, m.\n         DIVIDE n BY 2 GIVING q REMAINDER m END-DIVIDE\n         SUBTRACT m FROM 1 GIVING m END-SUBTRACT\n         GOBACK.\n       END PROGRAM evenp.\n\n", "explain": "In COBOL, double is a reserved word, so the doubling functions is named twice, instead. \n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Ada", "code": "\nwith ada.text_io;use ada.text_io;\n\nprocedure ethiopian is\n  function double  (n : Natural) return Natural is (2*n);\n  function halve   (n : Natural) return Natural is (n/2);\n  function is_even (n : Natural) return Boolean is (n mod 2 = 0);\n  \n  function mul (l, r : Natural) return Natural is \n  (if l = 0 then 0 elsif l = 1 then r elsif is_even (l) then mul (halve (l),double (r)) \n   else r + double (mul (halve (l), r)));\n   \nbegin\n  put_line (mul (17,34)'img);\nend ethiopian;\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nhalve(x::Integer) = x >> one(x)\ndouble(x::Integer) = Int8(2) * x\neven(x::Integer) = x & 1 != 1\n\n\nfunction ethmult(a::Integer, b::Integer)\n    r = 0\n    while a > 0\n        r += b * !even(a)\n        a = halve(a)\n        b = double(b)\n    end\n    return r\nend\n\n@show ethmult(17, 34)\n\n\nfunction ethmult2(a::Integer, b::Integer)\n    A = [a]\n    B = [b]\n    while A[end] > 1\n        push!(A, halve(A[end]))\n        push!(B, double(B[end]))\n    end\n    return sum(B[map(!even, A)])\nend\n\n@show ethmult2(17, 34)\n\n\nOutput:\nethmult(17, 34) = 578\nethmult2(17, 34) = 578\n\njulia> @time ethmult(17, 34)\n  0.000003 seconds (5 allocations: 176 bytes)\n578\n\njulia> @time ethmult2(17, 34)\n  0.000007 seconds (18 allocations: 944 bytes)\n578\n\n", "explain": "Helper functions (type stable):\nMain function:\nArray version (more similar algorithm to the one from the task description):\nBenchmark test:\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nfun halve(n: Int) = n / 2\n\nfun double(n: Int) = n * 2\n\nfun isEven(n: Int) = n % 2 == 0\n\nfun ethiopianMultiply(x: Int, y: Int): Int {\n    var xx = x\n    var yy = y\n    var sum = 0\n    while (xx >= 1) {\n       if (!isEven(xx)) sum += yy\n       xx = halve(xx)\n       yy = double(yy)\n    }\n    return sum\n}\n\nfun main(args: Array<String>) {\n    println(\"17 x 34 = ${ethiopianMultiply(17, 34)}\")\n    println(\"99 x 99 = ${ethiopianMultiply(99, 99)}\")\n}\n\n\nOutput:\n17 x 34 = 578\n99 x 99 = 9801\n\nLiterally follow the algorithm using generateSequence()[edit]\nfun Int.halve()  = this shr 1\nfun Int.double() = this shl 1\nfun Int.isOdd()  = this and 1 == 1\n\n\nfun ethiopianMultiply(n: Int, m: Int): Int =\n    generateSequence(Pair(n, m)) { p -> Pair(p.first.halve(), p.second.double()) }\n        .takeWhile { it.first >= 1 }.filter { it.first.isOdd() }.sumOf { it.second }\n\nfun main() {\n    ethiopianMultiply(17, 34).also { println(it) } // 578\n    ethiopianMultiply(99, 99).also { println(it) } // 9801 \n    ethiopianMultiply(4, 8).also { println(it) }   // 32\n}\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Perl", "code": "\nuse strict;\n\nsub halve { int((shift) / 2); }\nsub double { (shift) * 2; }\nsub iseven { ((shift) & 1) == 0; }\n\nsub ethiopicmult\n{\n    my ($plier, $plicand, $tutor) = @_;\n    print \"ethiopic multiplication of $plier and $plicand\\n\" if $tutor;\n    my $r = 0;\n    while ($plier >= 1)\n    {\n\t$r += $plicand unless iseven($plier);\n\tif ($tutor) {\n\t    print \"$plier, $plicand \", (iseven($plier) ? \" struck\" : \" kept\"), \"\\n\";\n\t}\n\t$plier = halve($plier);\n\t$plicand = double($plicand);\n    }\n    return $r;\n}\n\nprint ethiopicmult(17,34, 1), \"\\n\";\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Objective-C", "code": "\n\n#import <stdio.h>\n\nBOOL iseven(int x)\n{\n  return (x&1) == 0;\n}\n\n@interface EthiopicMult\u00a0: NSObject\n+ (int)mult: (int)plier by: (int)plicand;\n+ (int)halve: (int)a;\n+ (int)double: (int)a;\n@end\n\n@implementation EthiopicMult\n+ (int)mult: (int)plier by: (int)plicand\n{\n  int r = 0;\n  while(plier >= 1) {\n    if ( !iseven(plier) ) r += plicand;\n    plier = [EthiopicMult halve: plier];\n    plicand = [EthiopicMult double: plicand];\n  }\n  return r;\n}\n\n+ (int)halve: (int)a\n{\n  return (a>>1);\n}\n\n+ (int)double: (int)a\n{\n  return (a<<1);\n}\n@end\n\nint main()\n{\n  @autoreleasepool {\n    printf(\"%d\\n\", [EthiopicMult mult: 17 by: 34]);\n  }\n  return 0;\n}\n\n", "explain": "Using class methods except for the generic useful function iseven.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Prolog", "code": "\nTraditional[edit]\nhalve(X,Y) :- Y is X // 2.\ndouble(X,Y) :- Y is 2*X.\nis_even(X) :- 0 is X mod 2.\n\n% columns(First,Second,Left,Right) is true if integers First and Second\n% expand into the columns Left and Right, respectively\ncolumns(1,Second,[1],[Second]).\ncolumns(First,Second,[First|Left],[Second|Right]) :-\n    halve(First,Halved),\n    double(Second,Doubled),\n    columns(Halved,Doubled,Left,Right).\n\n% contribution(Left,Right,Amount) is true if integers Left and Right,\n% from their respective columns contribute Amount to the final sum.\ncontribution(Left,_Right,0) :-\n    is_even(Left).\ncontribution(Left,Right,Right) :-\n    \\+ is_even(Left).\n\nethiopian(First,Second,Product) :-\n    columns(First,Second,Left,Right),\n    maplist(contribution,Left,Right,Contributions),\n    sumlist(Contributions,Product).\n\n\nFunctional Style[edit]\n\n:- use_module(library(func)).\n\n% halve/2, double/2, is_even/2 definitions go here\n\nethiopian(First,Second,Product) :-\n    ethiopian(First,Second,0,Product).\n\nethiopian(1,Second,Sum0,Sum) :-\n    Sum is Sum0 + Second.\nethiopian(First,Second,Sum0,Sum) :-\n    Sum1 is Sum0 + Second*(First mod 2),\n    ethiopian(halve $ First, double $ Second, Sum1, Sum).\n\n\nConstraint Handling Rules[edit]\n\n:- module(ethiopia, [test/0, mul/3]).\n\n:- use_module(library(chr)).\n\n:- chr_constraint mul/3, halve/2, double/2, even/1, add_odd/4.\n\nmul(1, Y, S) <=>          S = Y.\nmul(X, Y, S) <=> X \\= 1 | halve(X, X1),\n                          double(Y, Y1),\n                          mul(X1, Y1, S1),\n                          add_odd(X, Y, S1, S).\n\nhalve(X, Y) <=> Y is X // 2.\n\ndouble(X, Y) <=> Y is X * 2.\n\neven(X) <=> 0 is X mod 2 | true.\neven(X) <=> 1 is X mod 2 | false.\n\nadd_odd(X, _, A, S) <=> even(X)    | S is A.\nadd_odd(X, Y, A, S) <=> \\+ even(X) | S is A + Y.\n\ntest :-\n    mul(17, 34, Z), !,\n    writeln(Z).\nNote that the task statement is what makes the halve and double constraints required.  Their use is highly artificial and a more realistic implementation would look like this:\n:- module(ethiopia, [test/0, mul/3]).\n\n:- use_module(library(chr)).\n\n:- chr_constraint mul/3, even/1, add_if_odd/4.\n\nmul(1, Y, S) <=>          S = Y.\nmul(X, Y, S) <=> X \\= 1 | X1 is X // 2,\n                          Y1 is Y * 2,\n                          mul(X1, Y1, S1),\n                          add_if_odd(X, Y, S1, S).\n\neven(X) <=> 0 is X mod 2 | true.\neven(X) <=> 1 is X mod 2 | false.\n\nadd_if_odd(X, _, A, S) <=> even(X)    | S is A.\nadd_if_odd(X, Y, A, S) <=> \\+ even(X) | S is A + Y.\n\ntest :-\n    mul(17, 34, Z),\n    writeln(Z).\nEven this is more verbose than what a more native solution would look like.\n", "explain": "\nUsing the same definitions as above for \"halve/2\", \"double/2\" and \"is_even/2\" along with an SWI-Prolog pack for function notation, one might write the following solution\n\nThis is a CHR solution for this problem using Prolog as the host language.  Code will work in SWI-Prolog and YAP (and possibly in others with or without some minor tweaking).\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Lua", "code": "\nfunction halve(a)\n    return a/2\nend\n\nfunction double(a)\n    return a*2\nend\n\nfunction isEven(a)\n    return a%2 == 0\nend\n\nfunction ethiopian(x, y)\n    local result = 0\n\n    while (x >= 1) do\n        if not isEven(x) then\n            result = result + y\n        end\n\n        x = math.floor(halve(x))\n        y = double(y)\n    end\n\n    return result;\nend\n\nprint(ethiopian(17, 34))\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Scala", "code": "\n\ndef ethiopian(i:Int, j:Int):Int=\n   pairIterator(i,j).filter(x=> !isEven(x._1)).map(x=>x._2).foldLeft(0){(x,y)=>x+y}\n\ndef ethiopian2(i:Int, j:Int):Int=\n   pairIterator(i,j).map(x=>if(isEven(x._1)) 0 else x._2).foldLeft(0){(x,y)=>x+y}\n\ndef ethiopian3(i:Int, j:Int):Int=\n{\n   var res=0;\n   for((h,d) <- pairIterator(i,j) if !isEven(h)) res+=d;\n   res\n}\n\ndef ethiopian4(i: Int, j: Int): Int = if (i == 1) j else ethiopian(halve(i), double(j)) + (if (isEven(i)) 0 else j)\n\ndef isEven(x:Int)=(x&1)==0\ndef halve(x:Int)=x>>>1\ndef double(x:Int)=x<<1\n\n// generates pairs of values (halve,double)\ndef pairIterator(x:Int, y:Int)=new Iterator[(Int, Int)]\n{\n   var i=(x, y)\n   def hasNext=i._1>0\n   def next={val r=i; i=(halve(i._1), double(i._2)); r}\n}\n", "explain": "The first and second are only slightly different and use functional style.\nThe third uses a for loop to yield the result.\nThe fourth uses recursion.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "D", "code": "\nint ethiopian(int n1, int n2) pure nothrow @nogc\nin {\n    assert(n1 >= 0, \"Multiplier can't be negative\");\n} body {\n    static enum doubleNum = (in int n) pure nothrow @nogc => n * 2;\n    static enum halveNum = (in int n) pure nothrow @nogc => n / 2;\n    static enum isEven = (in int n) pure nothrow @nogc => !(n & 1);\n\n    int result;\n    while (n1 >= 1) {\n        if (!isEven(n1))\n            result += n2;\n        n1 = halveNum(n1);\n        n2 = doubleNum(n2);\n    }\n\n    return result;\n} unittest {\n    assert(ethiopian(77, 54) == 77 * 54);\n    assert(ethiopian(8, 923) == 8 * 923);\n    assert(ethiopian(64, -4) == 64 * -4);\n}\n\nvoid main() {\n    import std.stdio;\n\n    writeln(\"17 ethiopian 34 is \", ethiopian(17, 34));\n}\n\nOutput:\n17 ethiopian 34 is 578\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Haskell", "code": "\nUsing integer (+)[edit]\nimport Prelude hiding (odd)\nimport Control.Monad (join)\n\nhalve :: Int -> Int\nhalve = (`div` 2)\n\ndouble :: Int -> Int\ndouble = join (+)\n\nodd :: Int -> Bool\nodd = (== 1) . (`mod` 2)\n\nethiopicmult :: Int -> Int -> Int\nethiopicmult a b =\n  sum $\n  map snd $\n  filter (odd . fst) $\n  zip (takeWhile (>= 1) $ iterate halve a) (iterate double b)\n\nmain :: IO ()\nmain = print $ ethiopicmult 17 34 == 17 * 34\n\n\nOutput:\n*Main> ethiopicmult 17 34\n 578\n\nFold after unfold[edit]\n\nimport Data.List (inits, intercalate, unfoldr)\nimport Data.Tuple (swap)\nimport Debug.Trace (trace)\n\n----------------- ETHIOPIAN MULTIPLICATION ---------------\n\nethMult :: Int -> Int -> Int\nethMult n m =\n  ( trace\n      =<< (<> \"\\n\")\n        . ((showDoubles pairs <> \" = \") <>)\n        . show\n  )\n    (foldr addedWhereOdd 0 pairs)\n  where\n    pairs = zip (unfoldr halved n) (iterate doubled m)\n    doubled x = x + x\n    halved h\n      | 0 < h =\n        Just $\n          trace\n            (showHalf h)\n            (swap $ quotRem h 2)\n      | otherwise = Nothing\n\n    addedWhereOdd (d, x) a\n      | 0 < d = (+) a x\n      | otherwise = a\n\n---------------------- TRACE DISPLAY ---------------------\n\nshowHalf :: Int -> String\nshowHalf x = \"halve: \" <> rjust 6 ' ' (show (quotRem x 2))\n\nshowDoubles :: [(Int, Int)] -> String\nshowDoubles xs =\n  \"double:\\n\"\n    <> unlines (go <$> xs)\n    <> intercalate \" + \" (xs >>= f)\n  where\n    go x\n      | 0 < fst x = \"-> \" <> rjust 3 ' ' (show $ snd x)\n      | otherwise = rjust 6 ' ' $ show $ snd x\n    f (r, q)\n      | 0 < r = [show q]\n      | otherwise = []\n\nrjust :: Int -> Char -> String -> String\nrjust n c s = drop (length s) (replicate n c <> s)\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = do\n  print $ ethMult 17 34\n  print $ ethMult 34 17\n\n\nOutput:\nhalve:  (8,1)\nhalve:  (4,0)\nhalve:  (2,0)\nhalve:  (1,0)\nhalve:  (0,1)\ndouble:\n->  34\n    68\n   136\n   272\n-> 544\n34 + 544 = 578\n\nhalve: (17,0)\nhalve:  (8,1)\nhalve:  (4,0)\nhalve:  (2,0)\nhalve:  (1,0)\nhalve:  (0,1)\ndouble:\n    17\n->  34\n    68\n   136\n   272\n-> 544\n34 + 544 = 578\n\n578\n578\nUsing monoid mappend[edit]\n\nimport Control.Monad (join)\nimport Data.List (unfoldr)\nimport Data.Monoid (getProduct, getSum)\nimport Data.Tuple (swap)\n\n----------------- ETHIOPIAN MULTIPLICATION ---------------\n\nethMult :: (Monoid m) => Int -> m -> m\nethMult n m =\n  foldr addedWhereOdd mempty $\n    zip (unfoldr half n) $ iterate (join (<>)) m\n\nhalf :: Integral b => b -> Maybe (b, b)\nhalf n\n  | 0 /= n = Just . swap $ quotRem n 2\n  | otherwise = Nothing\n\naddedWhereOdd :: (Eq a, Num a, Semigroup p) => (a, p) -> p -> p\naddedWhereOdd (d, x) a\n  | 0 /= d = a <> x\n  | otherwise = a\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = do\n  mapM_ print $\n    [ getSum $ ethMult 17 34, -- 34 * 17\n      getProduct $ ethMult 3 34 -- 34 ^ 3\n    ]\n      -- [3 ^ 17, 4 ^ 17]\n      <> (getProduct <$> ([ethMult 17] <*> [3, 4]))\n  print $ ethMult 17 \"34\"\n  print $ ethMult 17 [3, 4]\n\n\nOutput:\n578\n39304\n129140163\n17179869184\n\"3434343434343434343434343434343434\"\n[3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4,3,4]\n", "explain": "\nLogging the stages of the unfoldr and foldr applications:\nAlternatively, we can express Ethiopian multiplication in terms of mappend and mempty, in place of (+) and 0. \nThis additional generality means that our ethMult function can now replicate a string n times as readily as it multiplies an integer n times, or raises an integer to the nth power.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "PL/SQL", "code": "\n\ncreate or replace package ethiopian is\n\n  function multiply\n    ( left    in  integer,\n      right   in  integer)\n  return integer;\n\nend ethiopian;\n/\n\ncreate or replace package body ethiopian is\n\n  function is_even(item  in integer) return boolean is\n  begin\n    return item mod 2 = 0;\n  end is_even;\n\n  function double(item  in integer) return integer is\n  begin\n    return item * 2;\n  end double;\n\n  function half(item  in integer) return integer is\n  begin\n    return trunc(item / 2);\n  end half;\n\n  function multiply\n    ( left   in integer,\n      right  in integer)\n    return Integer\n  is\n    temp     integer := 0;\n    plier    integer := left;\n    plicand  integer := right;\n  begin\n\n    loop\n      if not is_even(plier) then\n        temp := temp + plicand;\n      end if;\n      exit when plier <= 1;\n      plier := half(plier);\n      plicand := double(plicand);\n    end loop;\n\n    return temp;\n\n  end multiply;\n\nend ethiopian;\n/\n\n/* example call */\nbegin\n  dbms_output.put_line(ethiopian.multiply(17, 34));\nend;\n/\n\n", "explain": "This code was taken from the ADA example above - very minor differences.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "VBScript", "code": "\n\nImplementationoption explicit\n\nclass List\n\tprivate theList\n\tprivate nOccupiable\n\tprivate nTop\n\t\n\tsub class_initialize\n\t\tnTop = 0\n\t\tnOccupiable = 100\n\t\tredim theList( nOccupiable )\n\tend sub\n\t\n\tpublic sub store( x )\n\t\tif nTop >= nOccupiable then\n\t\t\tnOccupiable = nOccupiable + 100\n\t\t\tredim preserve theList( nOccupiable )\n\t\tend if\n\t\ttheList( nTop ) = x\n\t\tnTop = nTop + 1\n\tend sub\n\t\n\tpublic function recall( n )\n\t\tif n >= 0 and n <= nOccupiable then\n\t\t\trecall = theList( n )\n\t\telse\n\t\t\terr.raise vbObjectError + 1000,,\"Recall bounds error\"\n\t\tend if\n\tend function\n\t\n\tpublic sub replace( n, x )\n\t\tif n >= 0 and n <= nOccupiable then\n\t\t\ttheList( n )  = x\n\t\telse\n\t\t\terr.raise vbObjectError + 1001,,\"Replace bounds error\"\n\t\tend if\n\tend sub\n\t\n\tpublic property get listCount\n\t\tlistCount = nTop\n\tend property\n\t\t\nend class\n\nfunction halve( n )\n\thalve = int( n / 2 )\nend function\n\nfunction twice( n )\n\ttwice = int( n * 2 )\nend function\n\nfunction iseven( n )\n\tiseven = ( ( n mod 2 ) = 0 )\nend function\n\n\nfunction multiply( n1, n2 )\n\tdim LL\n\tset LL = new List\n\n\tdim RR\n\tset RR = new List\n\n\tLL.store n1\n\tRR.store n2\n\t\n\tdo while n1 <> 1\n\t\tn1 = halve( n1 )\n\t\tLL.store n1\n\t\tn2 = twice( n2 )\n\t\tRR.store n2\n\tloop\n\t\n\tdim i\n\tfor i = 0 to LL.listCount\n\t\tif iseven( LL.recall( i ) ) then\n\t\t\tRR.replace i, 0\n\t\tend if\n\tnext\n\n\tdim total\n\ttotal = 0\n\tfor i = 0 to RR.listCount\n\t\ttotal = total + RR.recall( i )\n\tnext\n\t\n\tmultiply = total\nend functionInvocationwscript.echo multiply(17,34)\nOutput:\n578\n\n", "explain": "Nowhere near as optimal a solution as the Ada. Yes, it could have made as optimal, but the long way seemed more interesting.\nDemonstrates a List class. The .recall and .replace methods have bounds checking but the code does not test for the exception that would be raised. List class extends the storage allocated for the list when the occupation of the list goes beyond the original allocation.\noption explicit makes sure that all variables are declared.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Scheme", "code": "\n\n(define (halve num)\n  (quotient num 2))\n\n(define (double num)\n  (* num 2))\n\n(define (*mul-eth plier plicand acc)\n  (cond ((zero? plier) acc)\n        ((even? plier) (*mul-eth (halve plier) (double plicand) acc))\n        (else (*mul-eth (halve plier) (double plicand) (+ acc plicand)))))\n\n(define (mul-eth plier plicand)\n  (*mul-eth plier plicand 0))\n\n(display (mul-eth 17 34))\n(newline)\n\n578\n\n", "explain": "In Scheme, even? is a standard procedure.\nOutput:\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "TypeScript", "code": "\nTranslation of: Modula-2\n// Ethiopian multiplication\n \nfunction double(a: number): number {\n  return 2 * a;\n}\n \nfunction halve(a: number): number {\n  return Math.floor(a / 2);\n}\n \nfunction isEven(a: number): bool { \n  return a\u00a0% 2 == 0;\n}\n \nfunction showEthiopianMultiplication(x: number, y: number): void {\n  var tot = 0;\n  while (x >= 1) {\n    process.stdout.write(x.toString().padStart(9, ' ') + \" \");\n    if (!isEven(x)) {\n      tot += y;\n      process.stdout.write(y.toString().padStart(9, ' '));\n    }\n    console.log();\n    x = halve(x);\n    y = double(y);\n  }  \n  console.log(\"=\" + \" \".repeat(9) + tot.toString().padStart(9, ' '));\n}\n \nshowEthiopianMultiplication(17, 34);\n\nOutput:\n       17        34\n        8 \n        4 \n        2 \n        1       544\n=               578\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "PowerShell", "code": "\nTraditional[edit]\nfunction isEven {\n\tparam ([int]$value)\n\treturn [bool]($value % 2 -eq 0)\n}\n\nfunction doubleValue {\n\tparam ([int]$value)\n\treturn [int]($value * 2)\n}\n\nfunction halveValue {\n\tparam ([int]$value)\n\treturn [int]($value / 2)\n}\n\nfunction multiplyValues {\n\tparam (\n\t\t[int]$plier,\n\t\t[int]$plicand,\n\t\t[int]$temp = 0\n\t)\n\t\n\twhile ($plier -ge 1)\n\t{\n\t\tif (!(isEven $plier)) {\n\t\t\t$temp += $plicand\n\t\t}\n\t\t$plier = halveValue $plier\n\t\t$plicand = doubleValue $plicand\n\t}\n\t\nreturn $temp\n}\n\nmultiplyValues 17 34\n\nPipes with Busywork[edit]\n\nfunction halveInt( [int] $rhs )\n{\n\t[math]::floor( $rhs / 2 )\n}\n\nfunction doubleInt( [int] $rhs )\n{\n\t$rhs*2\n}\n\nfunction isEven( [int] $rhs )\n{\n\t-not ( $_ % 2 )\n}\n\nfunction Ethiopian( [int] $lhs , [int] $rhs )\n{\n\t$scratch = @{}\n\t1..[math]::floor( [math]::log( $lhs , 2 ) + 1 ) | \n\tForEach-Object { \n\t\t$scratch[$lhs] = $rhs\n\t\t$lhs\n\t\t$lhs = halveInt( $lhs )\n\t\t$rhs = doubleInt( $rhs ) } | \n\tWhere-Object { -not ( isEven $_ ) } | \n\tForEach-Object { $sum = 0 } { $sum += $scratch[$_] } { $sum }\n}\n\nEthiopian 17 34\n\n", "explain": "This uses several PowerShell specific features, in functions everything is returned automatically, so explicitly stating return is unnecessary.  type conversion happens automatically for certain types, [int] into [boolean] maps 0 to false and everything else to true.  A hash is used to store the values as they are being written, then a pipeline is used to iterate over the keys of the hash, determine which are odd, and only sum those.  The three-valued ForEach-Object is used to set a start expression, an iterative expression, and a return expression.\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "Logo", "code": "\nto double :x\n  output ashift :x  1\nend\nto halve :x\n  output ashift :x -1\nend\nto even? :x\n  output equal? 0 bitand 1 :x\nend\nto eproduct :x :y\n  if :x = 0 [output 0]\n  ifelse even? :x ~\n    [output      eproduct halve :x double :y] ~\n    [output :y + eproduct halve :x double :y]\nend\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "ColdFusion", "code": "\n\n<cffunction name=\"double\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = number * 2>\n    <cfreturn answer>\n</cffunction>\n\n<cffunction name=\"halve\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = int(number / 2)>\n    <cfreturn answer>\n</cffunction>\n\n<cffunction name=\"even\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = number mod 2>\n    <cfreturn answer>\n</cffunction>\n\n<cffunction name=\"ethiopian\">\n    <cfargument name=\"Number_A\" type=\"numeric\" required=\"true\">\n    <cfargument name=\"Number_B\" type=\"numeric\" required=\"true\">\n    <cfset Result = 0>\n    \n    <cfloop condition = \"Number_A GTE 1\">\n        <cfif even(Number_A) EQ 1>\n            <cfset Result = Result + Number_B>\n        </cfif>\n        <cfset Number_A = halve(Number_A)>\n        <cfset Number_B = double(Number_B)>\n    </cfloop>\n    <cfreturn Result>  \n</cffunction>\n\n\n<cfoutput>#ethiopian(17,34)#</cfoutput>\nVersion with display pizza:<cfset Number_A = 17>\n<cfset Number_B = 34>\n<cfset Result = 0>\n\n<cffunction name=\"double\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = number * 2>\n    <cfreturn answer>\n</cffunction>\n\n<cffunction name=\"halve\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = int(number / 2)>\n    <cfreturn answer>\n</cffunction>\n\n<cffunction name=\"even\">\n    <cfargument name=\"number\" type=\"numeric\" required=\"true\">\n\t<cfset answer = number mod 2>\n    <cfreturn answer>\n</cffunction>\n\n\n<cfoutput>\n\nEthiopian multiplication of #Number_A# and #Number_B#...\n<br>\n\n\n<table width=\"512\" border=\"0\" cellspacing=\"20\" cellpadding=\"0\">\n\n<cfloop condition = \"Number_A GTE 1\">\n\n\n   <cfif even(Number_A) EQ 1>\n   \t<cfset Result = Result + Number_B>\n        <cfset Action = \"Keep\">\n   <cfelse>\n\t<cfset Action = \"Strike\">\n   </cfif>\n\n  <tr>\n    <td align=\"right\">#Number_A#</td>\n    <td align=\"right\">#Number_B#</td>\n    <td align=\"center\">#Action#</td>\n  </tr>\n  \n  <cfset Number_A = halve(Number_A)>\n  <cfset Number_B = double(Number_B)>\n  \n</cfloop>  \n  \n</table>\n\n...equals #Result#\n\n</cfoutput>\n\nSample output:Ethiopian multiplication of 17 and 34...\n17 \t34 \tKeep\n8 \t68 \tStrike\n4 \t136 \tStrike\n2 \t272 \tStrike\n1 \t544 \tKeep\n...equals 578 \n\n", "explain": "Version with as a function of functions:\n"}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "F#", "code": "\nlet ethopian n m =\n    let halve n = n / 2\n    let double n = n * 2\n    let even n = n % 2 = 0\n    let rec loop n m result =\n        if n <= 1 then result + m\n        else if even n then loop (halve n) (double m) result\n        else loop (halve n) (double m) (result + m)\n    loop n m 0\n\n", "explain": ""}, {"task_name": "Ethiopian multiplication", "task_url": "https://rosettacode.org/wiki/Ethiopian_multiplication", "task_cat": "Arithmetic", "lang": "AWK", "code": "\n\nfunction halve(x)\n{\n  return int(x/2)\n}\n\nfunction double(x)\n{\n  return x*2\n}\n\nfunction iseven(x)\n{\n  return x%2 == 0\n}\n\nfunction ethiopian(plier, plicand)\n{\n  r = 0\n  while(plier >= 1) {\n    if ( !iseven(plier) ) {\n      r += plicand\n    }\n    plier = halve(plier)\n    plicand = double(plicand)\n  }\n  return r\n}\n\nBEGIN {\n  print ethiopian(17, 34)\n}\n\n", "explain": "Implemented without the tutor.\n"}]