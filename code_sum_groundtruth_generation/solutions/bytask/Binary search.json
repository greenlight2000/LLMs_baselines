[{"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nPython: Iterative[edit]\ndef binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low <= high: \n        mid = (low+high)//2\n        if l[mid] > value: high = mid-1\n        elif l[mid] < value: low = mid+1\n        else: return mid\n    return -1\n\n# findIndexBinary\u00a0:: (a -> Ordering) -> [a] -> Maybe Int\ndef findIndexBinary(p):\n    def isFound(bounds):\n        (lo, hi) = bounds\n        return lo > hi or 0 == hi\n\n    def half(xs):\n        def choice(lh):\n            (lo, hi) = lh\n            mid = (lo + hi) // 2\n            cmpr = p(xs[mid])\n            return (lo, mid - 1) if cmpr < 0 else (\n                (1 + mid, hi) if cmpr > 0 else (\n                    mid, 0\n                )\n            )\n        return lambda bounds: choice(bounds)\n\n    def go(xs):\n        (lo, hi) = until(isFound)(\n            half(xs)\n        )((0, len(xs) - 1)) if xs else None\n        return None if 0\u00a0!= hi else lo\n\n    return lambda xs: go(xs)\n\n\n# COMPARISON CONSTRUCTORS ---------------------------------\n\n# compare\u00a0:: a -> a -> Ordering\ndef compare(a):\n    '''Simple comparison of x and y -> LT|EQ|GT'''\n    return lambda b: -1 if a < b else (1 if a > b else 0)\n\n\n# byKV\u00a0:: (a -> b) -> a -> a -> Ordering\ndef byKV(f):\n    '''Property accessor function -> target value -> x -> LT|EQ|GT'''\n    def go(v, x):\n        fx = f(x)\n        return -1 if v < fx else 1 if v > fx else 0\n    return lambda v: lambda x: go(v, x)\n\n\n# TESTS ---------------------------------------------------\ndef main():\n\n    # BINARY SEARCH FOR WORD IN AZ-SORTED LIST\n\n    mb1 = findIndexBinary(compare('iota'))(\n        # Sorted AZ\n        ['alpha', 'beta', 'delta', 'epsilon', 'eta', 'gamma', 'iota',\n         'kappa', 'lambda', 'mu', 'theta', 'zeta']\n    )\n\n    print (\n        'Not found' if None is mb1 else (\n            'Word found at index ' + str(mb1)\n        )\n    )\n\n    # BINARY SEARCH FOR WORD OF GIVEN LENGTH (IN WORD-LENGTH SORTED LIST)\n\n    mb2 = findIndexBinary(byKV(len)(7))(\n        # Sorted by rising length\n        ['mu', 'eta', 'beta', 'iota', 'zeta', 'alpha', 'delta', 'gamma',\n         'kappa', 'theta', 'lambda', 'epsilon']\n    )\n\n    print (\n        'Not found' if None is mb2 else (\n            'Word of given length found at index ' + str(mb2)\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\ndef until(p):\n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\nif __name__ == '__main__':\n    main()\n\nOutput:\nWord found at index 6\nWord of given length found at index 11\nPython: Recursive[edit]\ndef binary_search(l, value, low = 0, high = -1):\n    if not l: return -1\n    if(high == -1): high = len(l)-1\n    if low >= high:\n        if l[low] == value: return low\n        else: return -1\n    mid = (low+high)//2\n    if l[mid] > value: return binary_search(l, value, low, mid-1)\n    elif l[mid] < value: return binary_search(l, value, mid+1, high)\n    else: return mid\n\n# findIndexBinary_\u00a0:: (a -> Ordering) -> [a] -> Maybe Int\ndef findIndexBinary_(p):\n    def go(xs):\n        def bin(lo, hi):\n            if hi < lo:\n                return None\n            else:\n                mid = (lo + hi) // 2\n                cmpr = p(xs[mid])\n                return bin(lo, mid - 1) if -1 == cmpr else (\n                    bin(mid + 1, hi) if 1 == cmpr else (\n                        mid\n                    )\n                )\n        n = len(xs)\n        return bin(0, n - 1) if 0 < n else None\n    return lambda xs: go(xs)\n\n\n# COMPARISON CONSTRUCTORS ---------------------------------\n\n# compare\u00a0:: a -> a -> Ordering\ndef compare(a):\n    '''Simple comparison of x and y -> LT|EQ|GT'''\n    return lambda b: -1 if a < b else (1 if a > b else 0)\n\n\n# byKV\u00a0:: (a -> b) -> a -> a -> Ordering\ndef byKV(f):\n    '''Property accessor function -> target value -> x -> LT|EQ|GT'''\n    def go(v, x):\n        fx = f(x)\n        return -1 if v < fx else 1 if v > fx else 0\n    return lambda v: lambda x: go(v, x)\n\n\n# TESTS ---------------------------------------------------\n\n\nif __name__ == '__main__':\n\n    # BINARY SEARCH FOR WORD IN AZ-SORTED LIST\n\n    mb1 = findIndexBinary_(compare('mu'))(\n        # Sorted AZ\n        ['alpha', 'beta', 'delta', 'epsilon', 'eta', 'gamma', 'iota',\n         'kappa', 'lambda', 'mu', 'theta', 'zeta']\n    )\n\n    print (\n        'Not found' if None is mb1 else (\n            'Word found at index ' + str(mb1)\n        )\n    )\n\n    # BINARY SEARCH FOR WORD OF GIVEN LENGTH (IN WORD-LENGTH SORTED LIST)\n\n    mb2 = findIndexBinary_(byKV(len)(6))(\n        # Sorted by rising length\n        ['mu', 'eta', 'beta', 'iota', 'zeta', 'alpha', 'delta', 'gamma',\n         'kappa', 'theta', 'lambda', 'epsilon']\n    )\n\n    print (\n        'Not found' if None is mb2 else (\n            'Word of given length found at index ' + str(mb2)\n        )\n    )\n\nOutput:\nWord found at index 9\nWord of given length found at index 10\nPython: Library[edit]\n\nindex = bisect.bisect_left(list, item) # leftmost insertion point\nindex = bisect.bisect_right(list, item) # rightmost insertion point\nindex = bisect.bisect(list, item) # same as bisect_right\n\n# same as above but actually insert the item into the list at the given place:\nbisect.insort_left(list, item)\nbisect.insort_right(list, item)\nbisect.insort(list, item)\nPython: Alternate[edit]\n\nfrom bisect import bisect_left\n\ndef binary_search(a, x, lo=0, hi=None):   # can't use a to specify default for hi\n    hi = hi if hi is not None else len(a) # hi defaults to len(a)   \n    pos = bisect_left(a,x,lo,hi)          # find insertion position\n    return (pos if pos\u00a0!= hi and a[pos] == x else -1) # don't walk off the end\nPython: Approximate binary search[edit]\n\ndef binary_search(l, value):\n    low = 0\n    high = len(l)-1\n    while low + 1 < high:\n        mid = (low+high)//2\n        if l[mid] > value:\n            high = mid\n        elif l[mid] < value:\n            low = mid\n        else:\n            return mid\n    return high if abs(l[high] - value) < abs(l[low] - value) else low\n", "explain": "We can also generalize this kind of binary search from direct matches to searches using a custom comparator function.\nIn addition to a search for a particular word in an AZ-sorted list, for example, we could also perform a binary search for a word of a given length (in a word-list sorted by rising length), or for a particular value of any other comparable property of items in a suitably sorted list:\nGeneralizing again with a custom comparator function (see preamble to second iterative version above).\nThis time using the recursive definition:\nPython's bisect module provides binary search functions\nComplete binary search function with python's bisect module:\nReturns the nearest item of list l to value.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n\nint bsearch (int *a, int n, int x) {\n    int i = 0, j = n - 1;\n    while (i <= j) {\n        int k = i + ((j - i) / 2);\n        if (a[k] == x) {\n            return k;\n        }\n        else if (a[k] < x) {\n            i = k + 1;\n        }\n        else {\n            j = k - 1;\n        }\n    }\n    return -1;\n}\n\nint bsearch_r (int *a, int x, int i, int j) {\n    if (j < i) {\n        return -1;\n    }\n    int k = i + ((j - i) / 2);\n    if (a[k] == x) {\n        return k;\n    }\n    else if (a[k] < x) {\n        return bsearch_r(a, x, k + 1, j);\n    }\n    else {\n        return bsearch_r(a, x, i, k - 1);\n    }\n}\n\nint main () {\n    int a[] = {-31, 0, 1, 2, 2, 4, 65, 83, 99, 782};\n    int n = sizeof a / sizeof a[0];\n    int x = 2;\n    int i = bsearch(a, n, x);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    x = 5;\n    i = bsearch_r(a, x, 0, n - 1);\n    if (i >= 0)  \n      printf(\"%d is at index %d.\\n\", x, i);\n    else\n      printf(\"%d is not found.\\n\", x);\n    return 0;\n}\n\n\nOutput:\n2 is at index 4.\n5 is not found.\n\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\ntemplate <class T> int binsearch(const T array[], int low, int high, T value) {\n    if (high < low) {\n        return -1;\n    }\n    auto mid = (low + high) / 2;\n    if (value < array[mid]) {\n        return binsearch(array, low, mid - 1, value);\n    } else if (value > array[mid]) {\n        return binsearch(array, mid + 1, high, value);\n    }\n    return mid;\n}\n\n#include <iostream>\nint main()\n{\n  int array[] = {2, 3, 5, 6, 8};\n  int result1 = binsearch(array, 0, sizeof(array)/sizeof(int), 4),\n      result2 = binsearch(array, 0, sizeof(array)/sizeof(int), 8);\n  if (result1 == -1) std::cout << \"4 not found!\" << std::endl;\n  else std::cout << \"4 found at \" << result1 << std::endl;\n  if (result2 == -1) std::cout << \"8 not found!\" << std::endl;\n  else std::cout << \"8 found at \" << result2 << std::endl;\n\n  return 0;\n}\n\n\ntemplate <class T>\nint binSearch(const T arr[], int len, T what) {\n  int low = 0;\n  int high = len - 1;\n  while (low <= high) {\n    int mid = (low + high) / 2;\n    if (arr[mid] > what)\n      high = mid - 1;\n    else if (arr[mid] < what)\n      low = mid + 1;\n    else\n      return mid;\n  }\n  return -1; // indicate not found \n}\n\n\nC++'s Standard Template Library has four functions for binary search, depending on what information you want to get. They all need#include <algorithm>\n\n\nint *ptr = std::lower_bound(array, array+len, what); // a custom comparator can be given as fourth arg\n\n\nint *ptr = std::upper_bound(array, array+len, what); // a custom comparator can be given as fourth arg\n\n\nstd::pair<int *, int *> bounds = std::equal_range(array, array+len, what); // a custom comparator can be given as fourth arg\n\n\nbool found = std::binary_search(array, array+len, what); // a custom comparator can be given as fourth arg\n\n", "explain": "Recursive\nIterative\nLibrary\nThe lower_bound() function returns an iterator to the first position where a value could be inserted without violating the order; i.e. the first element equal to the element you want, or the place where it would be inserted.\nThe upper_bound() function returns an iterator to the last position where a value could be inserted without violating the order; i.e. one past the last element equal to the element you want, or the place where it would be inserted.\nThe equal_range() function returns a pair of the results of lower_bound() and upper_bound().\nNote that the difference between the bounds is the number of elements equal to the element you want.\nThe binary_search() function returns true or false for whether an element equal to the one you want exists in the array. It does not give you any information as to where it is.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npublic class BinarySearchIterative {\n\n    public static int binarySearch(int[] nums, int check) {\n        int hi = nums.length - 1;\n        int lo = 0;\n        while (hi >= lo) {\n            int guess = (lo + hi) >>> 1;  // from OpenJDK\n            if (nums[guess] > check) {\n                hi = guess - 1;\n            } else if (nums[guess] < check) {\n                lo = guess + 1;\n            } else {\n                return guess;\n            }\n        }\n        return -1;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n        int index = binarySearch(haystack, needle);\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n\n\npublic class BinarySearchRecursive {\n\n    public static int binarySearch(int[] haystack, int needle, int lo, int hi) {\n        if (hi < lo) {\n            return -1;\n        }\n        int guess = (hi + lo) / 2;\n        if (haystack[guess] > needle) {\n            return binarySearch(haystack, needle, lo, guess - 1);\n        } else if (haystack[guess] < needle) {\n            return binarySearch(haystack, needle, guess + 1, hi);\n        }\n        return guess;\n    }\n\n    public static void main(String[] args) {\n        int[] haystack = {1, 5, 6, 7, 8, 11};\n        int needle = 5;\n\n        int index = binarySearch(haystack, needle, 0, haystack.length);\n\n        if (index == -1) {\n            System.out.println(needle + \" is not in the array\");\n        } else {\n            System.out.println(needle + \" is at index \" + index);\n        }\n    }\n}\n\n\nimport java.util.Arrays;\n\nint index = Arrays.binarySearch(array, thing);\nint index = Arrays.binarySearch(array, startIndex, endIndex, thing);\n\n// for objects, also optionally accepts an additional comparator argument:\nint index = Arrays.binarySearch(array, thing, comparator);\nint index = Arrays.binarySearch(array, startIndex, endIndex, thing, comparator);\n\n\nimport java.util.Collections;\n\nint index = Collections.binarySearch(list, thing);\nint index = Collections.binarySearch(list, thing, comparator);\n\n", "explain": "Iterative\nRecursive\nLibrary\nWhen the key is not found, the following functions return ~insertionPoint (the bitwise complement of the index where the key would be inserted, which is guaranteed to be a negative number).\nFor arrays:\nFor Lists:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nnamespace Search {\n  using System;\n\n  public static partial class Extensions {\n    /// <summary>Use Binary Search to find index of GLB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of GLB for value</returns>\n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    /// <summary>Use Binary Search to find index of GLB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <param name=\"left\">leftmost index to search</param>\n    /// <param name=\"right\">rightmost index to search</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of GLB for value</returns>\n    public static int RecursiveBinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) < 0 ?\n          entries.RecursiveBinarySearchForGLB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForGLB(value, left, middle - 1);\n      }\n\n      //[Assert]left == right + 1\n      // GLB: entries[right] < value && value <= entries[right + 1]\n      return right;\n    }\n\n    /// <summary>Use Binary Search to find index of LUB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of LUB for value</returns>\n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.RecursiveBinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    /// <summary>Use Binary Search to find index of LUB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <param name=\"left\">leftmost index to search</param>\n    /// <param name=\"right\">rightmost index to search</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of LUB for value</returns>\n    public static int RecursiveBinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      if (left <= right) {\n        var middle = left + (right - left) / 2;\n        return entries[middle].CompareTo(value) <= 0 ?\n          entries.RecursiveBinarySearchForLUB(value, middle + 1, right) :\n          entries.RecursiveBinarySearchForLUB(value, left, middle - 1);\n      }\n\n      //[Assert]left == right + 1\n      // LUB: entries[left] > value && value >= entries[left - 1]\n      return left;\n    }\n  }\n}\n\n\nnamespace Search {\n  using System;\n\n  public static partial class Extensions {\n    /// <summary>Use Binary Search to find index of GLB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of GLB for value</returns>\n    public static int BinarySearchForGLB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.BinarySearchForGLB(value, 0, entries.Length - 1);\n    }\n\n    /// <summary>Use Binary Search to find index of GLB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <param name=\"left\">leftmost index to search</param>\n    /// <param name=\"right\">rightmost index to search</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of GLB for value</returns>\n    public static int BinarySearchForGLB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      while (left <= right) {\n        var middle = left + (right - left) / 2;\n        if (entries[middle].CompareTo(value) < 0)\n          left = middle + 1;\n        else\n          right = middle - 1;\n      }\n\n      //[Assert]left == right + 1\n      // GLB: entries[right] < value && value <= entries[right + 1]\n      return right;\n    }\n\n    /// <summary>Use Binary Search to find index of LUB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of LUB for value</returns>\n    public static int BinarySearchForLUB<T>(this T[] entries, T value)\n      where T : IComparable {\n      return entries.BinarySearchForLUB(value, 0, entries.Length - 1);\n    }\n\n    /// <summary>Use Binary Search to find index of LUB for value</summary>\n    /// <typeparam name=\"T\">type of entries and value</typeparam>\n    /// <param name=\"entries\">array of entries</param>\n    /// <param name=\"value\">search value</param>\n    /// <param name=\"left\">leftmost index to search</param>\n    /// <param name=\"right\">rightmost index to search</param>\n    /// <remarks>entries must be in ascending order</remarks>\n    /// <returns>index into entries of LUB for value</returns>\n    public static int BinarySearchForLUB<T>(this T[] entries, T value, int left, int right)\n      where T : IComparable {\n      while (left <= right) {\n        var middle = left + (right - left) / 2;\n        if (entries[middle].CompareTo(value) <= 0)\n          left = middle + 1;\n        else\n          right = middle - 1;\n      }\n\n      //[Assert]left == right + 1\n      // LUB: entries[left] > value && value >= entries[left - 1]\n      return left;\n    }\n  }\n}\n\n\n//#define UseRecursiveSearch\n\nusing System;\nusing Search;\n\nclass Program {\n  static readonly int[][] tests = {\n    new int[] { },\n    new int[] { 2 },\n    new int[] { 2, 2 },\n    new int[] { 2, 2, 2, 2 },\n    new int[] { 3, 3, 4, 4 },\n    new int[] { 0, 1, 3, 3, 4, 4 },\n    new int[] { 0, 1, 2, 2, 2, 3, 3, 4, 4},\n    new int[] { 0, 1, 1, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n    new int[] { 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 2, 2, 2, 2, 2, 2, 2, 3, 3, 4, 4 },\n  };\n\n  static void Main(string[] args) {\n    var index = 0;\n    foreach (var test in tests) {\n      var join = String.Join(\" \", test);\n      Console.WriteLine($\"test[{index}]: {join}\");\n#if UseRecursiveSearch\n      var glb = test.RecursiveBinarySearchForGLB(2);\n      var lub = test.RecursiveBinarySearchForLUB(2);\n#else\n      var glb = test.BinarySearchForGLB(2);\n      var lub = test.BinarySearchForLUB(2);\n#endif\n      Console.WriteLine($\"glb = {glb}\");\n      Console.WriteLine($\"lub = {lub}\");\n\n      index++;\n    }\n#if DEBUG\n    Console.Write(\"Press Enter\");\n    Console.ReadLine();\n#endif\n  }\n}\n\n\ntest[0]:\nglb = -1\nlub = 0\ntest[1]: 2\nglb = -1\nlub = 1\ntest[2]: 2 2\nglb = -1\nlub = 2\ntest[3]: 2 2 2 2\nglb = -1\nlub = 4\ntest[4]: 3 3 4 4\nglb = -1\nlub = 0\ntest[5]: 0 1 3 3 4 4\nglb = 1\nlub = 2\ntest[6]: 0 1 2 2 2 3 3 4 4\nglb = 1\nlub = 5\ntest[7]: 0 1 1 2 2 2 3 3 4 4\nglb = 2\nlub = 6\ntest[8]: 0 1 1 1 1 2 2 3 3 4 4\nglb = 4\nlub = 7\ntest[9]: 0 1 1 1 1 2 2 2 2 2 2 2 3 3 4 4\nglb = 4\nlub = 12\ntest[10]: 0 1 1 1 1 1 1 1 1 1 1 1 1 1 2 2 2 2 2 2 2 3 3 4 4\nglb = 13\nlub = 21\n", "explain": "Recursive\nIterative\nExample\nOutput\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\n\nfunction binary_search_recursive(a, value, lo, hi) {\n  if (hi < lo) { return null; }\n\n  var mid = Math.floor((lo + hi) / 2);\n\n  if (a[mid] > value) {\n    return binary_search_recursive(a, value, lo, mid - 1);\n  }\n  if (a[mid] < value) {\n    return binary_search_recursive(a, value, mid + 1, hi);\n  }\n  return mid;\n}\n\n\nfunction binary_search_iterative(a, value) {\n  var mid, lo = 0,\n      hi = a.length - 1;\n\n  while (lo <= hi) {\n    mid = Math.floor((lo + hi) / 2);\n\n    if (a[mid] > value) {\n      hi = mid - 1;\n    } else if (a[mid] < value) {\n      lo = mid + 1;\n    } else {\n      return mid;\n    }\n  }\n  return null;\n}\n\nES6[edit]\n\n(() => {\n    'use strict';\n\n    const main = () => {\n\n        // findRecursive\u00a0:: a -> [a] -> Either String Int\n        const findRecursive = (x, xs) => {\n            const go = (lo, hi) => {\n                if (hi < lo) {\n                    return Left('not found');\n                } else {\n                    const\n                        mid = div(lo + hi, 2),\n                        v = xs[mid];\n                    return v > x ? (\n                        go(lo, mid - 1)\n                    ) : v < x ? (\n                        go(mid + 1, hi)\n                    ) : Right(mid);\n                }\n            };\n            return go(0, xs.length);\n        };\n\n\n        // findRecursive\u00a0:: a -> [a] -> Either String Int\n        const findIter = (x, xs) => {\n            const [m, l, h] = until(\n                ([mid, lo, hi]) => lo > hi || lo === mid,\n                ([mid, lo, hi]) => {\n                    const\n                        m = div(lo + hi, 2),\n                        v = xs[m];\n                    return v > x ? [\n                        m, lo, m - 1\n                    ] : v < x ? [\n                        m, m + 1, hi\n                    ] : [m, m, hi];\n                },\n                [div(xs.length / 2), 0, xs.length - 1]\n            );\n            return l > h ? (\n                Left('not found')\n            ) : Right(m);\n        };\n\n        // TESTS ------------------------------------------\n\n        const\n            // (pre-sorted AZ)\n            xs = [\"alpha\", \"beta\", \"delta\", \"epsilon\", \"eta\", \"gamma\",\n                \"iota\", \"kappa\", \"lambda\", \"mu\", \"nu\", \"theta\", \"zeta\"\n            ];\n        return JSON.stringify([\n            'Recursive',\n            map(x => either(\n                    l => \"'\" + x + \"' \" + l,\n                    r => \"'\" + x + \"' found at index \" + r,\n                    findRecursive(x, xs)\n                ),\n                knuthShuffle(['cape'].concat(xs).concat('cairo'))\n            ),\n            '',\n            'Iterative:',\n            map(x => either(\n                    l => \"'\" + x + \"' \" + l,\n                    r => \"'\" + x + \"' found at index \" + r,\n                    findIter(x, xs)\n                ),\n                knuthShuffle(['cape'].concat(xs).concat('cairo'))\n            )\n        ], null, 2);\n    };\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // Left\u00a0:: a -> Either a b\n    const Left = x => ({\n        type: 'Either',\n        Left: x\n    });\n\n    // Right\u00a0:: b -> Either a b\n    const Right = x => ({\n        type: 'Either',\n        Right: x\n    });\n\n    // div\u00a0:: Int -> Int -> Int\n    const div = (x, y) => Math.floor(x / y);\n\n    // either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\n    const either = (fl, fr, e) =>\n        'Either' === e.type ? (\n            undefined !== e.Left ? (\n                fl(e.Left)\n            ) : fr(e.Right)\n        ) : undefined;\n\n    // Abbreviation for quick testing\n\n    // enumFromTo\u00a0:: (Int, Int) -> [Int]\n    const enumFromTo = (m, n) =>\n        Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n    // FOR TESTS\n\n    // knuthShuffle\u00a0:: [a] -> [a]\n    const knuthShuffle = xs => {\n        const swapped = (iFrom, iTo, xs) =>\n            xs.map(\n                (x, i) => iFrom !== i ? (\n                    iTo !== i ? x : xs[iFrom]\n                ) : xs[iTo]\n            );\n        return enumFromTo(0, xs.length - 1)\n            .reduceRight((a, i) => {\n                const iRand = randomRInt(0, i)();\n                return i !== iRand ? (\n                    swapped(i, iRand, a)\n                ) : a;\n            }, xs);\n    };\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = (f, xs) =>\n        (Array.isArray(xs) ? (\n            xs\n        ) : xs.split('')).map(f);\n\n\n    // FOR TESTS\n\n    // randomRInt\u00a0:: Int -> Int -> IO () -> Int\n    const randomRInt = (low, high) => () =>\n        low + Math.floor(\n            (Math.random() * ((high - low) + 1))\n        );\n\n    // reverse\u00a0:: [a] -> [a]\n    const reverse = xs =>\n        'string' !== typeof xs ? (\n            xs.slice(0).reverse()\n        ) : xs.split('').reverse().join('');\n\n    // until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\n    const until = (p, f, x) => {\n        let v = x;\n        while (!p(v)) v = f(v);\n        return v;\n    };\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[\n  \"Recursive\",\n  [\n    \"'delta' found at index 2\",\n    \"'cairo' not found\",\n    \"'cape' not found\",\n    \"'gamma' found at index 5\",\n    \"'eta' found at index 4\",\n    \"'kappa' found at index 7\",\n    \"'alpha' found at index 0\",\n    \"'mu' found at index 9\",\n    \"'beta' found at index 1\",\n    \"'epsilon' found at index 3\",\n    \"'nu' found at index 10\",\n    \"'iota' found at index 6\",\n    \"'theta' found at index 11\",\n    \"'lambda' found at index 8\",\n    \"'zeta' found at index 12\"\n  ],\n  \"\",\n  \"Iterative:\",\n  [\n    \"'theta' found at index 11\",\n    \"'kappa' found at index 7\",\n    \"'zeta' found at index 12\",\n    \"'cairo' not found\",\n    \"'epsilon' found at index 3\",\n    \"'beta' found at index 1\",\n    \"'nu' found at index 10\",\n    \"'eta' found at index 4\",\n    \"'alpha' found at index 0\",\n    \"'lambda' found at index 8\",\n    \"'iota' found at index 6\",\n    \"'mu' found at index 9\",\n    \"'gamma' found at index 5\",\n    \"'delta' found at index 2\",\n    \"'cape' not found\"\n  ]\n]\n", "explain": "Recursive binary search implementation\nIterative binary search implementation\nRecursive and iterative, by composition of pure functions, with tests and output:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n\nfunction binary_search( $array, $secret, $start, $end )\n{\n        do\n        {\n                $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n                if ( $array[$guess] > $secret )\n                        $end = $guess;\n\n                if ( $array[$guess] < $secret )\n                        $start = $guess;\n\n                if ( $end < $start)\n                        return -1;\n\n        } while ( $array[$guess]\u00a0!= $secret );\n\n        return $guess;\n}\n\nfunction binary_search( $array, $secret, $start, $end )\n{\n        $guess = (int)($start + ( ( $end - $start ) / 2 ));\n\n        if ( $end < $start)\n                return -1;\n\n        if ( $array[$guess] > $secret )\n                return (binary_search( $array, $secret, $start, $guess ));\n\n        if ( $array[$guess] < $secret )\n                return (binary_search( $array, $secret, $guess, $end ) );\n\n        return $guess;\n}\n", "explain": "Iterative\nRecursive\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\n\nfunction mid = binarySearchRec(list,value,low,high)\n\n    if( high < low )\n        mid = [];\n        return\n    end\n    \n    mid = floor((low + high)/2);\n    \n    if( list(mid) > value )\n        mid = binarySearchRec(list,value,low,mid-1);\n        return\n    elseif( list(mid) < value )\n        mid = binarySearchRec(list,value,mid+1,high);\n        return\n    else\n        return\n    end\n        \nend\n\n>> binarySearchRec([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5,1,numel([1 2 3 4 5 6 6.5 7 8 9 11 18]))\n\nans =\n\n     7\n\nfunction mid = binarySearchIter(list,value)\n\n    low = 1;\n    high = numel(list) - 1;\n    \n    while( low <= high )\n        mid = floor((low + high)/2);\n    \n        if( list(mid) > value )\n            high = mid - 1;\n        elseif( list(mid) < value )\n        \tlow = mid + 1;\n        else\n            return\n        end\n    end\n    \n    mid = [];\n            \nend\n\n>> binarySearchIter([1 2 3 4 5 6 6.5 7 8 9 11 18],6.5)\n\nans =\n\n     7\n", "explain": "Recursive\nSample Usage:\nIterative\nSample Usage:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\n\nrecursive function binarySearch_R (a, value) result (bsresult)\n    real, intent(in) :: a(:), value\n    integer          :: bsresult, mid\n    \n    mid = size(a)/2 + 1\n    if (size(a) == 0) then\n        bsresult = 0        ! not found\n    else if (a(mid) > value) then\n        bsresult= binarySearch_R(a(:mid-1), value)\n    else if (a(mid) < value) then\n        bsresult = binarySearch_R(a(mid+1:), value)\n        if (bsresult /= 0) then\n            bsresult = mid + bsresult\n        end if\n    else\n        bsresult = mid      ! SUCCESS!!\n    end if\nend function binarySearch_R\n\n\nfunction binarySearch_I (a, value)\n    integer                  :: binarySearch_I\n    real, intent(in), target :: a(:)\n    real, intent(in)         :: value\n    real, pointer            :: p(:)\n    integer                  :: mid, offset\n    \n    p => a\n    binarySearch_I = 0\n    offset = 0\n    do while (size(p) > 0)\n        mid = size(p)/2 + 1\n        if (p(mid) > value) then\n            p => p(:mid-1)\n        else if (p(mid) < value) then\n            offset = offset + mid\n            p => p(mid+1:)\n        else\n            binarySearch_I = offset + mid    ! SUCCESS!!\n            return\n        end if\n    end do\nend function binarySearch_I\n\nIterative, exclusive bounds, three-way test.[edit]\n\n      INTEGER FUNCTION FINDI(X,A,N)\t!Binary chopper. Find i such that X = A(i)\nCareful: it is surprisingly difficult to make this neat, due to vexations when N = 0 or 1.\n       REAL X,A(*)\t\t!Where is X in array A(1:N)?\n       INTEGER N\t\t!The count.\n       INTEGER L,R,P\t\t!Fingers.\n        L = 0\t\t\t!Establish outer bounds, to search A(L+1:R-1).\n        R = N + 1\t\t!L = first - 1; R = last + 1.\n    1   P = (R - L)/2\t\t!Probe point. Beware INTEGER overflow with (L + R)/2.\n        IF (P.LE.0) GO TO 5\t!Aha! Nowhere!! The span is empty.\n        P = P + L\t\t!Convert an offset from L to an array index.\n        IF (X - A(P)) 3,4,2\t!Compare to the probe point.\n    2   L = P\t\t\t!A(P) < X. Shift the left bound up: X follows A(P).\n        GO TO 1\t\t\t!Another chop.\n    3   R = P\t\t\t!X < A(P). Shift the right bound down: X precedes A(P).\n        GO TO 1\t\t\t!Try again.\n    4   FINDI = P\t\t!A(P) = X. So, X is found, here!\n       RETURN\t\t\t!Done.\nCurse it!\n    5   FINDI = -L\t\t!X is not found. Insert it at L + 1, i.e. at A(1 - FINDI).\n      END FUNCTION FINDI\t!A's values need not be all different, merely in order.\n\n\nStatistics[edit]\n\nAn alternative version[edit]\n      INTEGER FUNCTION FINDI(X,A,N)\t!Binary chopper. Find i such that X = A(i)\nCareful: it is surprisingly difficult to make this neat, due to vexations when N = 0 or 1.\n       REAL X,A(*)\t\t!Where is X in array A(1:N)?\n       INTEGER N\t\t!The count.\n       INTEGER L,R,P\t\t!Fingers.\n        L = 0\t\t\t!Establish outer bounds, to search A(L+1:R-1).\n        R = N + 1\t\t!L = first - 1; R = last + 1.\n        GO TO 1\t\t\t!Hop to it.\n    2   L = P\t\t\t!A(P) < X. Shift the left bound up: X follows A(P).\n    1   P = (R - L)/2\t\t!Probe point. Beware INTEGER overflow with (L + R)/2.\n        IF (P.LE.0) GO TO 5\t!Aha! Nowhere!! The span is empty.\n        P = P + L\t\t!Convert an offset from L to an array index.\n        IF (X - A(P)) 3,4,2\t!Compare to the probe point.\n    3   R = P\t\t\t!X < A(P). Shift the right bound down: X precedes A(P).\n        GO TO 1\t\t\t!Try again.\n    4   FINDI = P\t\t!A(P) = X. So, X is found, here!\n       RETURN\t\t\t!Done.\nCurse it!\n    5   FINDI = -L\t\t!X is not found. Insert it at L + 1, i.e. at A(1 - FINDI).\n      END FUNCTION FINDI\t!A's values need not be all different, merely in order.\n\n\n if expression > 0 then optionP\n  else if expression < 0 then optionN\n   else optionZ;\n\n\n if X > 0 then print \"Positive\"\n  else if X > 0 then print \"Still positive\";\n\n\n", "explain": "Recursive\nIn ISO Fortran 90 or later use a RECURSIVE function and ARRAY SECTION argument:\nIterative\n\nIn ISO Fortran 90 or later use an ARRAY SECTION POINTER:\nThis has the array indexed from 1 to N, and the \"not found\" return code is zero or negative. Changing the search to be for A(first:last) is trivial, but the \"not-found\" return protocol would require adjustment, as when starting the array indexing at zero. Aside from the \"not found\" report, The variables used in the search must be able to hold the values first - 1 and last + 1 so for example with sixteen-bit two's complement integers the maximum value for last is 32766, not 32767.\nDepending on the version of Fortran the compiler supports, the specification of the array parameter may vary, as A(1) or A(*) or A(:), and in the latter case, parameter N could be omitted because the size of an array parameter may be ascertained via the SIZE function. For the more advanced fortrans, declaring the parameters to be INTENT(IN) may help, as despite passing arrays \"by reference\" being the norm, the newer compilers may generate copy-in, copy-out code, vitiating the whole point of using a fast binary search instead of a slow linear search. In this case, INTENT(IN) will at least prevent the copy-back. In such a situation however, preparing in-line code may be the better move: fortunately, there is not a lot of code involved. There is no point in using an explicitly recursive version (even though the same actions may result during execution) because of the overhead of parameter passing and procedure entry/exit.\nLater compilers offer features allowing the development of \"generic\" functions so that the same function name may be used yet the actual routine invoked will be selected according to how the parameters are integers or floating-point, and of different precisions. There would still need to be a version of the function for each type combination, each with its own name. Unfortunately, there is no three-way comparison test for character data.\nThe use of \"exclusive\" bounds simplifies the adjustment of the bounds: the appropriate bound simply receives the value of P, there is no + 1 or - 1 adjustment at every step; similarly, the determination of an empty span is easy, and avoiding the risk of integer overflow via (L + R)/2 is achieved at the same time. The \"inclusive\" bounds version by contrast requires two manipulations of L and R at every step - once to see if the span is empty, and a second time to locate the index to test.\n\nImagine a test array containing the even numbers: 2,4,6,8. A count could be kept of the number of probes required to find each of those four values, and likewise with a search for the odd numbers 1,3,5,7,9 that would probe all the places where a value might be not found. Plot the average number of probes for the two cases, plus the maximum number of probes for any case, and then repeat for another number of elements to search. With only one element in the array to be searched, all values are the same: one probe.\n\n\n\nThe point of this is that the IF-test is going to initiate some jumps, so why not arrange that one of the bound adjustments needs no subsequent jump to the start of the next iteration - in the first version, both bound adjustments needed such a jump, the GO TO 1 statements. This was done by shifting the code for label 2 up to precede the code for label 1 - and removing its now pointless GO TO 1 (executed each time), but adding an initial GO TO 1, executed once only. This sort of change is routine when manipulating spaghetti code... \nIt is because the method involves such a small amount of effort per iteration that minor changes offer a significant benefit. A lot depends on the implementation of the three-way test: the hope is that after the comparison, the computer hardware has indicators set for various outcomes, so that the necessary conditional branches can be made through successive inspection of those indicators, rather than repeating the comparison. These branch tests may in turn be made in an order that notes which option (if any) involves \"falling through\" to the next statement, thus it may be better to swap the order of labels 3 and 4. Further, the compiler may itself choose to re-order the various code pieces. First Fortran (in 1958) had a FREQUENCY statement whereby the programmer could indicate which paths were the more likely - for the binary search, equality is the less likely discovery. An assembler version of this routine attended to all these details.\nSome compilers do not produce machine code directly, but instead translate the source code into another language which is then compiled, and a common choice for that is C. This is all very well, but C is one of the many languages that do not have a three-way test option and so cannot represent Fortran's three-way IF statement directly. Before emitting asservations of faith that pseudocode such as\nwill be recognised by the most excellent compiler producing only one comparison, note that the two expressions are not the same (one has <, the other >), and test what happens with pseudocode such as\nThat is, does the compiler make any remark, and does the resulting machine code contain a redundant test? However, despite all the above, the three-way IF statement has been declared deprecated in later versions of Fortran, with no alternative to repeated testing offered.\nIncidentally, the exclusive-bounds version leads to a good version of the interpolation search (whereby the probe position is interpolated, not just in the middle of the span), unlike the version based on inclusive-bounds. Further, the unsourced offering in Wikipedia contains a bug - try searching an array of two equal elements for that value.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\nfunc binarySearch(a []float64, value float64, low int, high int) int {\n    if high < low {\n        return -1\n    }\n    mid := (low + high) / 2\n    if a[mid] > value {\n        return binarySearch(a, value, low, mid-1)\n    } else if a[mid] < value {\n        return binarySearch(a, value, mid+1, high)\n    }\n    return mid\n}\n\n\nfunc binarySearch(a []float64, value float64) int {\n    low := 0\n    high := len(a) - 1\n    for low <= high {\n        mid := (low + high) / 2\n        if a[mid] > value {\n            high = mid - 1\n        } else if a[mid] < value {\n            low = mid + 1\n        } else {\n            return mid\n        }\n    }\n    return -1\n}\n\n\nimport \"sort\"\n\n//...\n\nsort.SearchInts([]int{0,1,4,5,6,7,8,9}, 6) // evaluates to 4\n\n\n", "explain": "Recursive:\nIterative:\nLibrary:\nExploration of library source code shows that it uses the mid = low + (high - low) / 2 technique to avoid overflow.\nThere are also functions sort.SearchFloat64s(), sort.SearchStrings(), and a very general sort.Search() function that allows you to binary search a range of numbers based on any condition (not necessarily just search for an index of an element in an array).\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program binsearch.s   */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:        .ascii \"Value find at index\u00a0: \"\nsMessValeur:        .fill 11, 1, ' '            @ size => 11\nszCarriageReturn:   .asciz \"\\n\"\nsMessRecursif:      .asciz \"Recursive search\u00a0: \\n\"\nsMessNotFound:      .asciz \"Value not found. \\n\"\n\n.equ NBELEMENTS,      9\nTableNumber:\t     .int   4,6,7,10,11,15,22,30,35\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                           @ entry of program \n    mov r0,#4                                   @ search first value\n    ldr r1,iAdrTableNumber                      @ address number table\n    mov r2,#NBELEMENTS                          @ number of \u00e9lements \n    bl bSearch\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n\n    mov r0,#11                                  @ search median value\n    ldr r1,iAdrTableNumber\n    mov r2,#NBELEMENTS\n    bl bSearch\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n\n    mov r0,#12                                  @value not found\n    ldr r1,iAdrTableNumber\n    mov r2,#NBELEMENTS\n    bl bSearch\n    cmp r0,#-1\n    bne 2f\n    ldr r0,iAdrsMessNotFound\n    bl affichageMess \n    b 3f\n2:\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n3:\n    mov r0,#35                                  @ search last value\n    ldr r1,iAdrTableNumber\n    mov r2,#NBELEMENTS\n    bl bSearch\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n/****************************************/\n/*       recursive                      */\n/****************************************/\n    ldr r0,iAdrsMessRecursif\n    bl affichageMess                            @ display message\n\n    mov r0,#4                                   @ search first value\n    ldr r1,iAdrTableNumber\n    mov r2,#0                                   @ low index of elements\n    mov r3,#NBELEMENTS - 1                      @ high index of elements\n    bl bSearchR\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n   \n    mov r0,#11\n    ldr r1,iAdrTableNumber\n    mov r2,#0\n    mov r3,#NBELEMENTS - 1\n    bl bSearchR\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n    \n    mov r0,#12\n    ldr r1,iAdrTableNumber\n    mov r2,#0\n    mov r3,#NBELEMENTS - 1\n    bl bSearchR\n    cmp r0,#-1\n    bne 2f\n    ldr r0,iAdrsMessNotFound\n    bl affichageMess \n    b 3f\n2:\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n3:\n    mov r0,#35\n    ldr r1,iAdrTableNumber\n    mov r2,#0\n    mov r3,#NBELEMENTS - 1\n    bl bSearchR\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n\n100:                                            @ standard end of the program \n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc #0                                      @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrsMessRecursif:        .int sMessRecursif\niAdrsMessNotFound:        .int sMessNotFound\niAdrTableNumber:          .int TableNumber\n\n/******************************************************************/\n/*     binary search   iterative                                  */ \n/******************************************************************/\n/* r0 contains the value to search */\n/* r1 contains the adress of table */\n/* r2 contains the number of elements */\n/* r0 return index or -1 if not find */\nbSearch:\n    push {r2-r5,lr}                                 @ save registers\n    mov r3,#0                                       @ low index\n    sub r4,r2,#1                                    @ high index = number of elements - 1\n1:\n    cmp r3,r4\n    movgt r0,#-1                                    @not found\n    bgt 100f\n    add r2,r3,r4                                    @ compute (low + high) /2\n    lsr r2,#1\n    ldr r5,[r1,r2,lsl #2]                           @ load value of table at index r2\n    cmp r5,r0\n    moveq r0,r2                                     @ find\u00a0!!!\n    beq 100f\n    addlt r3,r2,#1                                  @ lower -> index low = index + 1\n    subgt r4,r2,#1                                  @ bigger -> index high = index - 1\n    b 1b                                            @ and loop\n100:\n    pop {r2-r5,lr}\n    bx lr                       @ return \n/******************************************************************/\n/*     binary search   recursif                                  */ \n/******************************************************************/\n/* r0 contains the value to search */\n/* r1 contains the adress of table */\n/* r2 contains the low index of elements */\n/* r3 contains the high index of elements */\n/* r0 return index or -1 if not find */\nbSearchR:\n    push {r2-r5,lr}                                  @ save registers\n    cmp r3,r2                                        @ index high < low\u00a0?\n    movlt r0,#-1                                     @ yes -> not found\n    blt 100f\n\n    add r4,r2,r3                                     @ compute (low + high) /2\n    lsr r4,#1\n    ldr r5,[r1,r4,lsl #2]                            @ load value of table at index r4\n    cmp r5,r0\n    moveq r0,r4                                      @ find\u00a0!!!\n    beq 100f \n\n    bgt 1f                                           @ bigger\u00a0?\n    add r2,r4,#1                                     @ no new search with low = index + 1\n    bl bSearchR\n    b 100f\n1:                                                   @ bigger\n    sub r3,r4,#1                                     @ new search with high = index - 1\n    bl bSearchR\n100:\n    pop {r2-r5,lr}\n    bx lr                                            @ return \n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres\n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n\n1:\t                                            @ start loop\n    bl divisionpar10U                               @unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b\t                                    @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                     @ and move spaces in end on area\n    mov r0,r4                                        @ result length \n    mov r1,#' '                                      @ space\n3:\n    strb r1,[r3,r4]                                  @ store space in area\n    add r4,#1                                        @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                           @ loop if r4 <= area size\n\n100:\n    pop {r1-r4,lr}                                   @ restaur registres \n    bx lr                                            @return\n\n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                        @ save value\n    //mov r3,#0xCCCD                                 @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                              @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                             @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                               @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                             @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                             @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                            @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\n\n", "explain": "See #Pascal.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\nclass Array\n  def binary_search(val, low=0, high=(length - 1))\n    return nil if high < low\n    mid = (low + high) >> 1\n    case val <=> self[mid]\n      when -1\n        binary_search(val, low, mid - 1)\n      when 1\n        binary_search(val, mid + 1, high)\n      else mid\n    end\n  end\nend\n\nary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\n\n[0,42,45,24324,99999].each do |val|\n  i = ary.binary_search(val)\n  if i\n    puts \"found #{val} at index #{i}: #{ary[i]}\"\n  else\n    puts \"#{val} not found in array\"\n  end\nend\n\nclass Array\n  def binary_search_iterative(val)\n    low, high = 0, length - 1\n    while low <= high\n      mid = (low + high) >> 1\n      case val <=> self[mid]\n        when 1\n          low = mid + 1\n        when -1\n          high = mid - 1\n        else\n          return mid\n      end\n    end\n    nil\n  end\nend\n\nary = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\n\n[0,42,45,24324,99999].each do |val|\n  i = ary.binary_search_iterative(val)\n  if i\n    puts \"found #{val} at index #{i}: #{ary[i]}\"\n  else\n    puts \"#{val} not found in array\"\n  end\nend\n\nOutput:\nfound 0 at index 0: 0\n42 not found in array\nfound 45 at index 10: 45\nfound 24324 at index 24: 24324\n99999 not found in array\n\n\nhaystack = [0,1,4,5,6,7,8,9,12,26,45,67,78,90,98,123,211,234,456,769,865,2345,3215,14345,24324]\nneedles = [0,42,45,24324,99999]\n\nneedles.select{|needle| haystack.bsearch{|hay| needle <=> hay} } # => [0, 45, 24324]Which is 60% faster than \"needles & haystack\".\n", "explain": "Recursive\nIterative\nBuilt in\nSince Ruby 2.0, arrays ship with a binary search method \"bsearch\": \n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\n\nfn binary_search<T:PartialOrd>(v: &[T], searchvalue: T) -> Option<T> {\n    let mut lower = 0 as usize;\n    let mut upper = v.len() - 1;\n\n    while upper >= lower {\n        let mid = (upper + lower) / 2;\n        if v[mid] == searchvalue {\n            return Some(searchvalue);\n        } else if searchvalue < v[mid] {\n            upper = mid - 1;\n        } else {\n            lower = mid + 1;\n        }\n    }\n\n    None\n}\n", "explain": "Iterative\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\n\nfunc binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var recurse: ((Int, Int) -> Int?)!\n  recurse = {(low, high) in switch (low + high) / 2 {\n    case _ where high < low: return nil\n    case let mid where xs[mid] > x: return recurse(low, mid - 1)\n    case let mid where xs[mid] < x: return recurse(mid + 1, high)\n    case let mid: return mid\n  }}\n  return recurse(0, xs.count - 1)\n}\n\nfunc binarySearch<T: Comparable>(xs: [T], x: T) -> Int? {\n  var (low, high) = (0, xs.count - 1)\n  while low <= high {\n    switch (low + high) / 2 {\n      case let mid where xs[mid] > x: high = mid - 1\n      case let mid where xs[mid] < x: low = mid + 1\n      case let mid: return mid\n    }\n  }\n  return nil\n}\n\nfunc testBinarySearch(n: Int) {\n  let odds = Array(stride(from: 1, through: n, by: 2))\n  let result = flatMap(0...n) {binarySearch(odds, $0)}\n  assert(result == Array(0..<odds.count))\n  println(\"\\(odds) are odd natural numbers\")\n  for it in result {\n    println(\"\\(it) is ordinal of \\(odds[it])\")\n  }\n}\n\ntestBinarySearch(12)\n\nfunc flatMap<T, U>(source: [T], transform: (T) -> U?) -> [U] {\n  return source.reduce([]) {(var xs, x) in if let x = transform(x) {xs.append(x)}; return xs}\n}\n\n[1, 3, 5, 7, 9, 11] are odd natural numbers\n0 is ordinal of 1\n1 is ordinal of 3\n2 is ordinal of 5\n3 is ordinal of 7\n4 is ordinal of 9\n5 is ordinal of 11\n", "explain": "Recursive\nIterative\nTest\nOutput:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nBinSearch <- function(A, value, low, high) {\n  if ( high < low ) {\n    return(NULL)\n  } else {\n    mid <- floor((low + high) / 2)\n    if ( A[mid] > value )\n      BinSearch(A, value, low, mid-1)\n    else if ( A[mid] < value )\n      BinSearch(A, value, mid+1, high)\n    else\n      mid\n  }\n}\n\nIterBinSearch <- function(A, value) {\n  low = 1\n  high = length(A)\n  i = 0\n  while ( low <= high ) {\n    mid <- floor((low + high)/2)\n    if ( A[mid] > value )\n      high <- mid - 1\n    else if ( A[mid] < value )\n      low <- mid + 1\n    else\n      return(mid)\n  }\n  NULL\n}\n\na <- 1:100\nIterBinSearch(a, 50)\nBinSearch(a, 50, 1, length(a)) # output 50\nIterBinSearch(a, 101) # outputs NULL\n", "explain": "Recursive\nIterative\nExample\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\n\n        >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. binary-search.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  nums-area                           VALUE \"01040612184356\".\n    03  nums                            PIC 9(2)\n                                        OCCURS 7 TIMES\n                                        ASCENDING KEY nums\n                                        INDEXED BY nums-idx.\nPROCEDURE DIVISION.\n    SEARCH ALL nums\n        WHEN nums (nums-idx) = 4\n            DISPLAY \"Found 4 at index \" nums-idx\n    END-SEARCH\n    .\nEND PROGRAM binary-search.\n\n", "explain": "COBOL's SEARCH ALL statement is implemented as a binary search on most implementations.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\nRecursive\n\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Recursive_Binary_Search is\n   Not_Found : exception;\n   \n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Mid : Index;\n   begin\n      if Container'Length > 0 then\n         Mid := (Container'First + Container'Last) / 2;\n         if Value < Container (Mid) then\n            if Container'First /= Mid then\n               return Search (Container (Container'First..Mid - 1), Value);\n            end if;\n         elsif Container (Mid) < Value then\n            if Container'Last /= Mid then\n               return Search (Container (Mid + 1..Container'Last), Value);\n            end if;\n         else\n            return Mid;\n         end if;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n   \n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Recursive_Binary_Search;\n\nIterative\n\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Binary_Search is\n   Not_Found : exception;\n   \n   generic\n      type Index is range <>;\n      type Element is private;\n      type Array_Of_Elements is array (Index range <>) of Element;\n      with function \"<\" (L, R : Element) return Boolean is <>;\n   function Search (Container : Array_Of_Elements; Value : Element) return Index;\n\n   function Search (Container : Array_Of_Elements; Value : Element) return Index is\n      Low  : Index := Container'First;\n      High : Index := Container'Last;\n      Mid  : Index;\n   begin\n      if Container'Length > 0 then\n         loop\n            Mid := (Low + High) / 2;\n            if Value < Container (Mid) then\n               exit when Low = Mid;\n               High := Mid - 1;\n            elsif Container (Mid) < Value then\n               exit when High = Mid;\n               Low := Mid + 1;\n            else\n               return Mid;\n            end if;\n         end loop;\n      end if;\n      raise Not_Found;\n   end Search;\n\n   type Integer_Array is array (Positive range <>) of Integer;\n   function Find is new Search (Positive, Integer, Integer_Array);\n   \n   procedure Test (X : Integer_Array; E : Integer) is\n   begin\n      New_Line;\n      for I in X'Range loop\n         Put (Integer'Image (X (I)));\n      end loop;\n      Put (\" contains\" & Integer'Image (E) & \" at\" & Integer'Image (Find (X, E)));\n   exception\n      when Not_Found =>\n         Put (\" does not contain\" & Integer'Image (E));\n   end Test;\nbegin\n   Test ((2, 4, 6, 8, 9), 2);\n   Test ((2, 4, 6, 8, 9), 1);\n   Test ((2, 4, 6, 8, 9), 8);\n   Test ((2, 4, 6, 8, 9), 10);\n   Test ((2, 4, 6, 8, 9), 9);\n   Test ((2, 4, 6, 8, 9), 5);\nend Test_Binary_Search;\n\n\n 2 4 6 8 9 contains 2 at 1\n 2 4 6 8 9 does not contain 1\n 2 4 6 8 9 contains 8 at 4\n 2 4 6 8 9 does not contain 10\n 2 4 6 8 9 contains 9 at 5\n 2 4 6 8 9 does not contain 5\n\n", "explain": "Both solutions are generic. The element can be of any comparable type (such that the operation < is visible in the instantiation scope of the function Search). Note that the completion condition is different from one given in the pseudocode example above. The example assumes that the array index type does not overflow when mid is incremented or decremented beyond the corresponding array bound. This is a wrong assumption for Ada, where array bounds can start or end at the very first or last value of the index type. To deal with this, the exit condition is rather directly expressed as crossing the corresponding array bound by the coming interval middle.\nSample output:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nfunction binarysearch(lst::Vector{T}, val::T) where T\n    low = 1\n    high = length(lst)\n    while low \u2264 high\n        mid = (low + high) \u00f7 2\n        if lst[mid] > val\n            high = mid - 1\n        elseif lst[mid] < val\n            low = mid + 1\n        else\n            return mid\n        end\n    end\n    return 0\nend\n\n\nfunction binarysearch(lst::Vector{T}, value::T, low=1, high=length(lst)) where T\n    if isempty(lst) return 0 end\n    if low \u2265 high\n        if low > high || lst[low] != value\n            return 0\n        else\n            return low\n        end\n    end\n    mid = (low + high) \u00f7 2\n    if lst[mid] > value\n        return binarysearch(lst, value, low, mid-1)\n    elseif lst[mid] < value\n        return binarysearch(lst, value, mid+1, high)\n    else\n        return mid\n    end\nend\n\n", "explain": "Iterative:\nRecursive:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nfun <T : Comparable<T>> Array<T>.iterativeBinarySearch(target: T): Int {\n    var hi = size - 1\n    var lo = 0\n    while (hi >= lo) {\n        val guess = lo + (hi - lo) / 2\n        if (this[guess] > target) hi = guess - 1\n        else if (this[guess] < target) lo = guess + 1\n        else return guess\n    }\n    return -1\n}\n\nfun <T : Comparable<T>> Array<T>.recursiveBinarySearch(target: T, lo: Int, hi: Int): Int {\n    if (hi < lo) return -1\n\n    val guess = (hi + lo) / 2\n\n    return if (this[guess] > target) recursiveBinarySearch(target, lo, guess - 1)\n    else if (this[guess] < target) recursiveBinarySearch(target, guess + 1, hi)\n    else guess\n}\n\nfun main(args: Array<String>) {\n    val a = arrayOf(1, 3, 4, 5, 6, 7, 8, 9, 10)\n    var target = 6\n    var r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.iterativeBinarySearch(target)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n\n    target = 6\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n    target = 250\n    r = a.recursiveBinarySearch(target, 0, a.size)\n    println(if (r < 0) \"$target not found\" else \"$target found at index $r\")\n}\n\n\nOutput:\n6 found at index 4\n250 not found\n6 found at index 4\n250 not found\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\nsub binary_search {\n    my ($array_ref, $value, $left, $right) = @_;\n    while ($left <= $right) {\n        my $middle = int(($right + $left) >> 1);\n        if ($value == $array_ref->[$middle]) {\n            return $middle;\n        }\n        elsif ($value < $array_ref->[$middle]) {\n            $right = $middle - 1;\n        }\n        else {\n            $left = $middle + 1;\n        }\n    }\n    return -1;\n}\n\nsub binary_search {\n    my ($array_ref, $value, $left, $right) = @_;\n    return -1 if ($right < $left);\n    my $middle = int(($right + $left) >> 1);\n    if ($value == $array_ref->[$middle]) {\n        return $middle;\n    }\n    elsif ($value < $array_ref->[$middle]) {\n        binary_search($array_ref, $value, $left, $middle - 1);\n    }\n    else {\n        binary_search($array_ref, $value, $middle + 1, $right);\n    }\n}\n", "explain": "Iterative\nRecursive\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n\n#import <Foundation/Foundation.h>\n\n@interface NSArray (BinarySearch)\n// Requires all elements of this array to implement a -compare: method which\n// returns a NSComparisonResult for comparison.\n// Returns NSNotFound when not found\n- (NSInteger) binarySearch:(id)key;\n@end\n\n@implementation NSArray (BinarySearch)\n- (NSInteger) binarySearch:(id)key {\n  NSInteger lo = 0;\n  NSInteger hi = [self count] - 1;\n  while (lo <= hi) {\n    NSInteger mid = lo + (hi - lo) / 2;\n    id midVal = self[mid];\n    switch ([midVal compare:key]) {\n    case NSOrderedAscending:\n      lo = mid + 1;\n      break;\n    case NSOrderedDescending:\n      hi = mid - 1;\n      break;\n    case NSOrderedSame:\n      return mid;\n    }\n  }\n  return NSNotFound;\n}\n@end\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %d\", [a binarySearch:@6]); // prints 4\n\n  }\n  return 0;\n}\n\n#import <Foundation/Foundation.h>\n\n@interface NSArray (BinarySearchRecursive)\n// Requires all elements of this array to implement a -compare: method which\n// returns a NSComparisonResult for comparison.\n// Returns NSNotFound when not found\n- (NSInteger) binarySearch:(id)key inRange:(NSRange)range;\n@end\n\n@implementation NSArray (BinarySearchRecursive)\n- (NSInteger) binarySearch:(id)key inRange:(NSRange)range {\n  if (range.length == 0)\n    return NSNotFound;\n  NSInteger mid = range.location + range.length / 2;\n  id midVal = self[mid];\n  switch ([midVal compare:key]) {\n  case NSOrderedAscending:\n    return [self binarySearch:key\n                      inRange:NSMakeRange(mid + 1, NSMaxRange(range) - (mid + 1))];\n  case NSOrderedDescending:\n    return [self binarySearch:key\n                      inRange:NSMakeRange(range.location, mid - range.location)];\n  default:\n    return mid;\n  }\n}\n@end\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %d\", [a binarySearch:@6]); // prints 4\n\n  }\n  return 0;\n}\n\nWorks with: Mac OS X version 10.6+\n#import <Foundation/Foundation.h>\n\nint main()\n{\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %lu\", [a indexOfObject:@6\n                                      inSortedRange:NSMakeRange(0, [a count])\n                                            options:0\n                                    usingComparator:^(id x, id y){ return [x compare: y]; }]); // prints 4\n\n  }\n  return 0;\n}\n\n#import <Foundation/Foundation.h>\n\nCFComparisonResult myComparator(const void *x, const void *y, void *context) {\n  return [(__bridge id)x compare:(__bridge id)y];\n}\n\nint main(int argc, const char *argv[]) {\n  @autoreleasepool {\n\n    NSArray *a = @[@1, @3, @4, @5, @6, @7, @8, @9, @10];\n    NSLog(@\"6 is at position %ld\", CFArrayBSearchValues((__bridge CFArrayRef)a,\n                                                        CFRangeMake(0, [a count]),\n                                                        (__bridge const void *)@6,\n                                                        myComparator,\n                                                        NULL)); // prints 4\n\n  }\n  return 0;\n}\n", "explain": "Iterative\nRecursive\nLibrary\nUsing Core Foundation (part of Cocoa, all versions):\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\nbin_search(Elt,List,Result):-\n  length(List,N), bin_search_inner(Elt,List,1,N,Result).\n  \nbin_search_inner(Elt,List,J,J,J):-\n  nth(J,List,Elt).\nbin_search_inner(Elt,List,Begin,End,Mid):-\n  Begin < End,\n  Mid is (Begin+End) div 2,\n  nth(Mid,List,Elt).\nbin_search_inner(Elt,List,Begin,End,Result):-\n  Begin < End,\n  Mid is (Begin+End) div 2,\n  nth(Mid,List,MidElt),\n  MidElt < Elt,\n  NewBegin is Mid+1,\n  bin_search_inner(Elt,List,NewBegin,End,Result).\nbin_search_inner(Elt,List,Begin,End,Result):-\n  Begin < End,\n  Mid is (Begin+End) div 2,\n  nth(Mid,List,MidElt),\n  MidElt > Elt,\n  NewEnd is Mid-1,\n  bin_search_inner(Elt,List,Begin,NewEnd,Result).\n\nOutput examples:\n\u00a0?- bin_search(4,[1,2,4,8,16,32,64,128],Result).\nResult = 3.\n\n?- bin_search(5,[1,2,4,8],Result).\nResult = -1.\n", "explain": "Tested with Gnu-Prolog.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\n\nfunction binarySearch (list,value)\n    local low = 1\n    local high = #list\n    while low <= high do\n        local mid = math.floor((low+high)/2)\n        if list[mid] > value then high = mid - 1\n        elseif list[mid] < value then low = mid + 1\n        else return mid\n        end\n    end\n    return false\nend\n\n\nfunction binarySearch (list, value)\n    local function search(low, high)\n        if low > high then return false end\n        local mid = math.floor((low+high)/2)\n        if list[mid] > value then return search(low,mid-1) end\n        if list[mid] < value then return search(mid+1,high) end\n        return mid\n    end\n    return search(1,#list)\nend\n", "explain": "Iterative\nRecursive\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\n\ndef binarySearch[A <% Ordered[A]](a: IndexedSeq[A], v: A) = {\n  def recurse(low: Int, high: Int): Option[Int] = (low + high) / 2 match {\n    case _ if high < low => None\n    case mid if a(mid) > v => recurse(low, mid - 1)\n    case mid if a(mid) < v => recurse(mid + 1, high)\n    case mid => Some(mid)\n  }\n  recurse(0, a.size - 1)\n}\n\ndef binarySearch[T](xs: Seq[T], x: T)(implicit ordering: Ordering[T]): Option[Int] = {\n    var low: Int = 0\n    var high: Int = xs.size - 1\n\n    while (low <= high)\n      low + high >>> 1 match {\n        case guess if ordering.gt(xs(guess), x) => high = guess - 1 //too high\n        case guess if ordering.lt(xs(guess), x) => low = guess + 1 // too low\n        case guess => return Some(guess) //found it\n      }\n    None //not found\n  }\n\ndef testBinarySearch(n: Int) = {\n  val odds = 1 to n by 2\n  val result = (0 to n).flatMap(binarySearch(odds, _))\n  assert(result == (0 until odds.size))\n  println(s\"$odds are odd natural numbers\")\n  for (it <- result)\n    println(s\"$it is ordinal of ${odds(it)}\")\n}\n\ndef main() = testBinarySearch(12)\n\nRange(1, 3, 5, 7, 9, 11) are odd natural numbers\n0 is ordinal of 1\n1 is ordinal of 3\n2 is ordinal of 5\n3 is ordinal of 7\n4 is ordinal of 9\n5 is ordinal of 11\n", "explain": "Recursive\nIterative\nTest\nOutput:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport std.stdio, std.array, std.range, std.traits;\n\n/// Recursive.\nbool binarySearch(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    if (data.empty)\n        return false;\n    immutable i = data.length / 2;\n    immutable mid = data[i];\n    if (mid > x)\n        return data[0 .. i].binarySearch(x);\n    if (mid < x)\n        return data[i + 1 .. $].binarySearch(x);\n    return true;\n}\n\n/// Iterative.\nbool binarySearchIt(R, T)(/*in*/ R data, in T x) pure nothrow @nogc\nif (isRandomAccessRange!R && is(Unqual!T == Unqual!(ElementType!R))) {\n    while (!data.empty) {\n        immutable i = data.length / 2;\n        immutable mid = data[i];\n        if (mid > x)\n            data = data[0 .. i];\n        else if (mid < x)\n            data = data[i + 1 .. $];\n        else\n            return true;\n    }\n    return false;\n}\n\nvoid main() {\n    /*const*/ auto items = [2, 4, 6, 8, 9].assumeSorted;\n    foreach (const x; [1, 8, 10, 9, 5, 2])\n        writefln(\"%2d %5s %5s %5s\", x,\n                 items.binarySearch(x),\n                 items.binarySearchIt(x),\n                 // Standard Binary Search:\n                 !items.equalRange(x).empty);\n}\n\n\nOutput:\n 1 false false false\n 8  true  true  true\n10 false false false\n 9  true  true  true\n 5 false false false\n 2  true  true  true\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nRecursive algorithm[edit]\n\nimport Data.Array (Array, Ix, (!), listArray, bounds)\n\n-- BINARY SEARCH --------------------------------------------------------------\nbSearch\n  :: Integral a\n  => (a -> Ordering) -> (a, a) -> Maybe a\nbSearch p (low, high)\n  | high < low = Nothing\n  | otherwise =\n    let mid = (low + high) `div` 2\n    in case p mid of\n         LT -> bSearch p (low, mid - 1)\n         GT -> bSearch p (mid + 1, high)\n         EQ -> Just mid\n\n-- Application to an array:\nbSearchArray\n  :: (Ix i, Integral i, Ord e)\n  => Array i e -> e -> Maybe i\nbSearchArray a x = bSearch (compare x . (a !)) (bounds a)\n\n-- TEST -----------------------------------------------------------------------\naxs\n  :: (Num i, Ix i)\n  => Array i String\naxs =\n  listArray\n    (0, 11)\n    [ \"alpha\"\n    , \"beta\"\n    , \"delta\"\n    , \"epsilon\"\n    , \"eta\"\n    , \"gamma\"\n    , \"iota\"\n    , \"kappa\"\n    , \"lambda\"\n    , \"mu\"\n    , \"theta\"\n    , \"zeta\"\n    ]\n\nmain :: IO ()\nmain =\n  let e = \"mu\"\n      found = bSearchArray axs e\n  in putStrLn $\n     '\\'' :\n     e ++\n     case found of\n       Nothing -> \"' Not found\"\n       Just x -> \"' found at index \" ++ show x\n\n\nOutput:\n'mu' found at index 9\n\nimport Data.Array (Array, Ix, (!), listArray, bounds)\n\n-- BINARY SEARCH USING A HELPER FUNCTION WITH A SIMPLER TYPE SIGNATURE\nfindIndexBinary\n  :: Ord a\n  => (a -> Ordering) -> Array Int a -> Either String Int\nfindIndexBinary p axs =\n  let go (lo, hi)\n        | hi < lo = Left \"not found\"\n        | otherwise =\n          let mid = (lo + hi) `div` 2\n          in case p (axs ! mid) of\n               LT -> go (lo, pred mid)\n               GT -> go (succ mid, hi)\n               EQ -> Right mid\n  in go (bounds axs)\n\n-- TEST ---------------------------------------------------\nhaystack :: Array Int String\nhaystack =\n  listArray\n    (0, 11)\n    [ \"alpha\"\n    , \"beta\"\n    , \"delta\"\n    , \"epsilon\"\n    , \"eta\"\n    , \"gamma\"\n    , \"iota\"\n    , \"kappa\"\n    , \"lambda\"\n    , \"mu\"\n    , \"theta\"\n    , \"zeta\"\n    ]\n\nmain :: IO ()\nmain =\n  let needle = \"lambda\"\n  in putStrLn $\n     '\\'' :\n     needle ++\n     either\n       (\"' \" ++)\n       ((\"' found at index \" ++) . show)\n       (findIndexBinary (compare needle) haystack)\n\n\nOutput:\n'lambda' found at index 8\nIterative algorithm[edit]\n\nimport Data.Array (Array, Ix, (!), listArray, bounds)\n\n-- BINARY SEARCH USING THE ITERATIVE ALGORITHM\nfindIndexBinary_\n  :: Ord a\n  => (a -> Ordering) -> Array Int a -> Either String Int\nfindIndexBinary_ p axs =\n  let (lo, hi) =\n        until\n          (\\(lo, hi) -> lo > hi || 0 == hi)\n          (\\(lo, hi) ->\n              let m = quot (lo + hi) 2\n              in case p (axs ! m) of\n                   LT -> (lo, pred m)\n                   GT -> (succ m, hi)\n                   EQ -> (m, 0))\n          (bounds axs) :: (Int, Int)\n  in if 0 /= hi\n       then Left \"not found\"\n       else Right lo\n\n-- TEST ---------------------------------------------------\nhaystack :: Array Int String\nhaystack =\n  listArray\n    (0, 11)\n    [ \"alpha\"\n    , \"beta\"\n    , \"delta\"\n    , \"epsilon\"\n    , \"eta\"\n    , \"gamma\"\n    , \"iota\"\n    , \"kappa\"\n    , \"lambda\"\n    , \"mu\"\n    , \"theta\"\n    , \"zeta\"\n    ]\n\nmain :: IO ()\nmain =\n  let needle = \"kappa\"\n  in putStrLn $\n     '\\'' :\n     needle ++\n     either\n       (\"' \" ++)\n       ((\"' found at index \" ++) . show)\n       (findIndexBinary_ (compare needle) haystack)\n\n\nOutput:\n'kappa' found at index 7\n", "explain": "The algorithm itself, parametrized by an \"interrogation\" predicate p in the spirit of the explanation above:\nThe algorithm uses tail recursion, so the iterative and the recursive approach are identical in Haskell (the compiler will convert recursive calls into jumps).\nA common optimisation of recursion is to delegate the main computation to a helper function with simpler type signature. For the option type of the return value, we could also use an Either as an alternative to a Maybe.\nThe iterative algorithm could be written in terms of the until function, which takes a predicate p, a function f, and a seed value x. \nIt returns the result of applying f until p holds.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n(define (binary-search value vector)\n  (let helper ((low 0)\n               (high (- (vector-length vector) 1)))\n    (if (< high low)\n        #f\n        (let ((middle (quotient (+ low high) 2)))\n          (cond ((> (vector-ref vector middle) value)\n                 (helper low (- middle 1)))\n                ((< (vector-ref vector middle) value)\n                 (helper (+ middle 1) high))\n                (else middle))))))\n\n> (binary-search 6 '#(1 3 4 5 6 7 8 9 10))\n4\n> (binary-search 2 '#(1 3 4 5 6 7 8 9 10))\n#f\n\n\n", "explain": "Recursive\nExample:\nThe calls to helper are in tail position, so since Scheme implementations \nsupport proper tail-recursion the computation proces is iterative.\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nfunction BinarySearch-Iterative ([int[]]$Array, [int]$Value)\n{\n    [int]$low = 0\n    [int]$high = $Array.Count - 1\n\n    while ($low -le $high)\n    {\n        [int]$mid = ($low + $high) / 2\n\n        if ($Array[$mid] -gt $Value)\n        {\n            $high = $mid - 1\n        }\n        elseif ($Array[$mid] -lt $Value)\n        {\n            $low = $mid + 1\n        }\n        else\n        {\n            return $mid\n        }\n    }\n\n    return -1\n}\n\nfunction BinarySearch-Recursive ([int[]]$Array, [int]$Value, [int]$Low = 0, [int]$High = $Array.Count)\n{\n    if ($High -lt $Low)\n    {\n        return -1\n    }\n\n    [int]$mid = ($Low + $High) / 2\n\n    if ($Array[$mid] -gt $Value)\n    {\n        return BinarySearch $Array $Value $Low ($mid - 1)\n    }\n    elseif ($Array[$mid] -lt $Value)\n    {\n        return BinarySearch $Array $Value ($mid + 1) $High\n    }\n    else\n    {\n        return $mid\n    }\n}\n\nfunction Show-SearchResult ([int[]]$Array, [int]$Search, [ValidateSet(\"Iterative\", \"Recursive\")][string]$Function)\n{\n    switch ($Function)\n    {\n        \"Iterative\" {$index = BinarySearch-Iterative -Array $Array -Value $Search}\n        \"Recursive\" {$index = BinarySearch-Recursive -Array $Array -Value $Search}\n    }\n\n    if ($index -ge 0)\n    {\n        Write-Host (\"Using BinarySearch-{0}: {1} is at index {2}\" -f $Function, $numbers[$index], $index)\n    }\n    else\n    {\n        Write-Host (\"Using BinarySearch-{0}: {1} not found\" -f $Function, $Search) -ForegroundColor Red\n    }\n}\nShow-SearchResult -Array 10, 28, 41, 46, 58, 74, 76, 86, 89, 98 -Search 41 -Function Iterative\nShow-SearchResult -Array 10, 28, 41, 46, 58, 74, 76, 86, 89, 98 -Search 99 -Function Iterative\nShow-SearchResult -Array 10, 28, 41, 46, 58, 74, 76, 86, 89, 98 -Search 86 -Function Recursive\nShow-SearchResult -Array 10, 28, 41, 46, 58, 74, 76, 86, 89, 98 -Search 11 -Function Recursive\n\nOutput:\nUsing BinarySearch-Iterative: 41 is at index 2\nUsing BinarySearch-Iterative: 99 not found\nUsing BinarySearch-Recursive: 86 is at index 7\nUsing BinarySearch-Recursive: 11 not found\n\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto bsearch :value :a :lower :upper\n  if :upper < :lower [output []]\n  localmake \"mid int (:lower + :upper) / 2\n  if item :mid :a > :value [output bsearch :value :a :lower :mid-1]\n  if item :mid :a < :value [output bsearch :value :a :mid+1 :upper]\n  output :mid\nend\n", "explain": ""}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nlet rec binarySearch (myArray:array<IComparable>, low:int, high:int, value:IComparable) =\n    if (high < low) then\n        null\n    else\n        let mid = (low + high) / 2\n\n        if (myArray.[mid] > value) then\n            binarySearch (myArray, low, mid-1, value)\n        else if (myArray.[mid] < value) then\n            binarySearch (myArray, mid+1, high, value)\n        else\n            myArray.[mid]\n\n", "explain": "Generic recursive version, using #light syntax:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nRecursive Solution[edit]\ndef binSearchR\n//define binSearchR closure.\nbinSearchR = { a, key, offset=0 ->\n    def m = n.intdiv(2)\n    def n = a.size()\n    a.empty \\\n        ? [\"The insertion point is\": offset] \\\n        : a[m] > key \\\n            ? binSearchR(a[0..<m],key, offset) \\\n            : a[m] < target \\\n                ? binSearchR(a[(m + 1)..<n],key, offset + m + 1) \\\n                : [index: offset + m]\n}\n\nIterative Solution[edit]\ndef binSearchI = { aList, target ->\n    def a = aList\n    def offset = 0\n    while (!a.empty) {\n        def n = a.size()\n        def m = n.intdiv(2)\n        if(a[m] > target) {\n            a = a[0..<m]\n        } else if (a[m] < target) {\n            a = a[(m + 1)..<n]\n            offset += m + 1\n        } else {\n            return [index: offset + m]\n        }\n    }\n    return [\"insertion point\": offset]\n}\n\n\ndef a = [] as Set\ndef random = new Random()\nwhile (a.size() < 20) { a << random.nextInt(30) }\ndef source = a.sort()\nsource[0..-2].eachWithIndex { si, i -> assert si < source[i+1] }\n\nprintln \"${source}\"\n1.upto(5) {\n    target = random.nextInt(10) + (it - 2) * 10\n    print \"Trial #${it}. Looking for: ${target}\"\n    def answers = [binSearchR, binSearchI].collect { search ->\n        search(source, target)\n    }\n    assert answers[0] == answers[1]\n    println \"\"\"\n    Answer: ${answers[0]},\u00a0: ${source[answers[0].values().iterator().next()]}\"\"\"\n}\n\n\n[1, 2, 5, 8, 9, 10, 11, 14, 15, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 29]\nTrial #1. Looking for: -9\n    Answer: [insertion point:0],\u00a0: 1\nTrial #2. Looking for: 7\n    Answer: [insertion point:3],\u00a0: 8\nTrial #3. Looking for: 18\n    Answer: [index:9],\u00a0: 18\nTrial #4. Looking for: 29\n    Answer: [index:19],\u00a0: 29\nTrial #5. Looking for: 32\n    Answer: [insertion point:20],\u00a0: null\n", "explain": "Both solutions use sublists and a tracking offset in preference to \"high\" and \"low\".\nTest:\nOutput:\n"}, {"task_name": "Binary search", "task_url": "https://rosettacode.org/wiki/Binary_search", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\nWorks with: Gawk\nWorks with: Mawk\nWorks with: Nawk\n\nfunction binary_search(array, value, left, right,       middle) {\n    if (right < left) return 0\n    middle = int((right + left) / 2)\n    if (value == array[middle]) return 1\n    if (value <  array[middle])\n        return binary_search(array, value, left, middle - 1)\n    return binary_search(array, value, middle + 1, right)\n}\n\n\nfunction binary_search(array, value, left, right,       middle) {\n    while (left <= right) {\n        middle = int((right + left) / 2)\n        if (value == array[middle]) return 1\n        if (value <  array[middle]) right = middle - 1\n        else                        left  = middle + 1\n    }\n    return 0\n}\n\n", "explain": "Recursive\nIterative\n"}]