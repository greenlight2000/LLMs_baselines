[{"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Python", "code": "\n\ndef initiate():\n    box.append([0, 1, 2, 9, 10, 11, 18, 19, 20])\n    box.append([3, 4, 5, 12, 13, 14, 21, 22, 23])\n    box.append([6, 7, 8, 15, 16, 17, 24, 25, 26])\n    box.append([27, 28, 29, 36, 37, 38, 45, 46, 47])\n    box.append([30, 31, 32, 39, 40, 41, 48, 49, 50])\n    box.append([33, 34, 35, 42, 43, 44, 51, 52, 53])\n    box.append([54, 55, 56, 63, 64, 65, 72, 73, 74])\n    box.append([57, 58, 59, 66, 67, 68, 75, 76, 77])\n    box.append([60, 61, 62, 69, 70, 71, 78, 79, 80])\n    for i in range(0, 81, 9):\n        row.append(range(i, i+9))\n    for i in range(9):\n        column.append(range(i, 80+i, 9))\n\ndef valid(n, pos):\n    current_row = pos/9\n    current_col = pos%9\n    current_box = (current_row/3)*3 + (current_col/3)\n    for i in row[current_row]:\n        if (grid[i] == n):\n            return False\n    for i in column[current_col]:\n        if (grid[i] == n):\n            return False\n    for i in box[current_box]:\n        if (grid[i] == n):\n            return False\n    return True\n\ndef solve():\n    i = 0\n    proceed = 1\n    while(i < 81):\n        if given[i]:\n            if proceed:\n                    i += 1\n            else:\n                i -= 1\n        else:\n            n = grid[i]\n            prev = grid[i]\n            while(n < 9):\n              if (n < 9):\n                  n += 1\n              if valid(n, i):\n                  grid[i] = n\n                  proceed = 1\n                  break\n            if (grid[i] == prev):\n               grid[i] = 0\n               proceed = 0\n            if proceed:\n               i += 1\n            else:\n               i -=1\n\ndef inputs():\n    nextt = 'T'\n    number = 0\n    pos = 0\n    while(not(nextt == 'N' or nextt == 'n')):\n        print \"Enter the position:\",\n        pos = int(raw_input())\n        given[pos - 1] = True\n        print \"Enter the numerical:\",\n        number = int(raw_input())\n        grid[pos - 1] = number\n        print \"Do you want to enter another given?(Y, for yes: N, for no)\"\n        nextt = raw_input()\n\n\ngrid = [0]*81\ngiven = [False]*81\nbox = []\nrow = []\ncolumn = []\ninitiate()\ninputs()\nsolve()\nfor i in range(9):\n    print grid[i*9:i*9+9]\nraw_input()\n\n", "explain": "See Solving Sudoku puzzles with Python for GPL'd solvers of increasing complexity of algorithm.\nA simple backtrack algorithm -- Quick but may take longer if the grid had been more than 9 x 9\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "C", "code": "\n\n#include <stdio.h>\n\nvoid show(int *x)\n{\n\tint i, j;\n\tfor (i = 0; i < 9; i++) {\n\t\tif (!(i % 3)) putchar('\\n');\n\t\tfor (j = 0; j < 9; j++)\n\t\t\tprintf(j % 3 ? \"%2d\" : \"%3d\", *x++);\n\t\tputchar('\\n');\n\t}\n}\n\nint trycell(int *x, int pos)\n{\n\tint row = pos / 9;\n\tint col = pos % 9;\n\tint i, j, used = 0;\n\n\tif (pos == 81) return 1;\n\tif (x[pos]) return trycell(x, pos + 1);\n\n\tfor (i = 0; i < 9; i++)\n\t\tused |= 1 << (x[i * 9 + col] - 1);\n\n\tfor (j = 0; j < 9; j++)\n\t\tused |= 1 << (x[row * 9 + j] - 1);\n\n\trow = row / 3 * 3;\n\tcol = col / 3 * 3;\n\tfor (i = row; i < row + 3; i++)\n\t\tfor (j = col; j < col + 3; j++)\n\t\t\tused |= 1 << (x[i * 9 + j] - 1);\n\n\tfor (x[pos] = 1; x[pos] <= 9; x[pos]++, used >>= 1)\n\t\tif (!(used & 1) && trycell(x, pos + 1)) return 1;\n\n\tx[pos] = 0;\n\treturn 0;\n}\n\nvoid solve(const char *s)\n{\n\tint i, x[81];\n\tfor (i = 0; i < 81; i++)\n\t\tx[i] = s[i] >= '1' && s[i] <= '9' ? s[i] - '0' : 0;\n\n\tif (trycell(x, 0))\n\t\tshow(x);\n\telse\n\t\tputs(\"no solution\");\n}\n\nint main(void)\n{\n\tsolve(\t\"5x..7....\"\n\t\t\"6..195...\"\n\t\t\".98....6.\"\n\t\t\"8...6...3\"\n\t\t\"4..8.3..1\"\n\t\t\"7...2...6\"\n\t\t\".6....28.\"\n\t\t\"...419..5\"\n\t\t\"....8..79\"\t);\n\n\treturn 0;\n}\n\n", "explain": "See e.g. this GPLed solver written in C.\nThe following code is really only good for size 3 puzzles. A longer, even less readable version here could handle size 4s.\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "C++", "code": "\nTranslation of: Java\n#include <iostream>\nusing namespace std;\n\nclass SudokuSolver {\nprivate:\n    int grid[81];\n\npublic:\n\n    SudokuSolver(string s) {\n        for (unsigned int i = 0; i < s.length(); i++) {\n            grid[i] = (int) (s[i] - '0');\n        }\n    }\n\n    void solve() {\n        try {\n            placeNumber(0);\n            cout << \"Unsolvable!\" << endl;\n        } catch (char* ex) {\n            cout << ex << endl;\n            cout << this->toString() << endl;\n        }\n    }\n\n    void placeNumber(int pos) {\n        if (pos == 81) {\n            throw (char*) \"Finished!\";\n        }\n        if (grid[pos] > 0) {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++) {\n            if (checkValidity(n, pos % 9, pos / 9)) {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    bool checkValidity(int val, int x, int y) {\n        for (int i = 0; i < 9; i++) {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++) {\n            for (int j = startX; j < startX + 3; j++) {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    string toString() {\n        string sb;\n        for (int i = 0; i < 9; i++) {\n            for (int j = 0; j < 9; j++) {\n                char c[2];\n                c[0] = grid[i * 9 + j] + '0';\n                c[1] = '\\0';\n                sb.append(c);\n                sb.append(\" \");\n                if (j == 2 || j == 5)\n                    sb.append(\"| \");\n            }\n            sb.append(\"\\n\");\n            if (i == 2 || i == 5)\n                sb.append(\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n};\n\nint main() {\n    SudokuSolver ss(\"850002400\"\n                    \"720000009\"\n                    \"004000000\"\n                    \"000107002\"\n                    \"305000900\"\n                    \"040000000\"\n                    \"000080070\"\n                    \"017000000\"\n                    \"000036040\");\n    ss.solve();\n    return EXIT_SUCCESS;\n}\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Java", "code": "\npublic class Sudoku\n{\n    private int mBoard[][];\n    private int mBoardSize;\n    private int mBoxSize;\n    private boolean mRowSubset[][];\n    private boolean mColSubset[][];\n    private boolean mBoxSubset[][];\n \n    public Sudoku(int board[][]) {\n        mBoard = board;\n        mBoardSize = mBoard.length;\n        mBoxSize = (int)Math.sqrt(mBoardSize);\n        initSubsets();\n    }\n \n    public void initSubsets() {\n        mRowSubset = new boolean[mBoardSize][mBoardSize];\n        mColSubset = new boolean[mBoardSize][mBoardSize];\n        mBoxSubset = new boolean[mBoardSize][mBoardSize];\n        for(int i = 0; i < mBoard.length; i++) {\n            for(int j = 0; j < mBoard.length; j++) {\n                int value = mBoard[i][j];\n                if(value != 0) {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n \n    private void setSubsetValue(int i, int j, int value, boolean present) {\n        mRowSubset[i][value - 1] = present;\n        mColSubset[j][value - 1] = present;\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present;\n    }\n \n    public boolean solve() {\n        return solve(0, 0);\n    }\n \n    public boolean solve(int i, int j) {\n        if(i == mBoardSize) {\n            i = 0;\n            if(++j == mBoardSize) {\n                return true;\n            }\n        }\n        if(mBoard[i][j] != 0) {\n            return solve(i + 1, j);\n        }\n        for(int value = 1; value <= mBoardSize; value++) {\n            if(isValid(i, j, value)) {\n                mBoard[i][j] = value;\n                setSubsetValue(i, j, value, true);\n                if(solve(i + 1, j)) {\n                    return true;\n                }\n                setSubsetValue(i, j, value, false);\n            }\n        }\n \n        mBoard[i][j] = 0;\n        return false;\n    }\n \n    private boolean isValid(int i, int j, int val) {\n        val--;\n        boolean isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val];\n        return !isPresent;\n    }\n \n    private int computeBoxNo(int i, int j) {\n        int boxRow = i / mBoxSize;\n        int boxCol = j / mBoxSize;\n        return boxRow * mBoxSize + boxCol;\n    }\n \n    public void print() {\n        for(int i = 0; i < mBoardSize; i++) {\n            if(i % mBoxSize == 0) {\n                System.out.println(\" -----------------------\");\n            }\n            for(int j = 0; j < mBoardSize; j++) {\n                if(j % mBoxSize == 0) {\n                    System.out.print(\"| \");\n                }\n                System.out.print(mBoard[i][j] != 0 ? ((Object) (Integer.valueOf(mBoard[i][j]))) : \"-\");\n                System.out.print(' ');\n            }\n \n            System.out.println(\"|\");\n        }\n \n        System.out.println(\" -----------------------\");\n    }\n\n    public static void main(String[] args) {\n        int[][] board = { \n            {8, 5, 0, 0, 0, 2, 4, 0, 0},\n            {7, 2, 0, 0, 0, 0, 0, 0, 9},\n            {0, 0, 4, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 1, 0, 7, 0, 0, 2},\n            {3, 0, 5, 0, 0, 0, 9, 0, 0},\n            {0, 4, 0, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 8, 0, 0, 7, 0},\n            {0, 1, 7, 0, 0, 0, 0, 0, 0},\n            {0, 0, 0, 0, 3, 6, 0, 4, 0}\n        };\n        Sudoku s = new Sudoku(board);\n        System.out.print(\"Starting grid:\\n\");\n        s.print();        \n        if (s.solve()) {\n            System.out.print(\"\\nSolution:\\n\");\n            s.print();\n        } else {\n            System.out.println(\"\\nUnsolvable!\");\n        }\n    }\n}\n\n\nOutput:\nStarting grid:\n -----------------------\n| 8 5 - | - - 2 | 4 - - |\n| 7 2 - | - - - | - - 9 |\n| - - 4 | - - - | - - - |\n -----------------------\n| - - - | 1 - 7 | - - 2 |\n| 3 - 5 | - - - | 9 - - |\n| - 4 - | - - - | - - - |\n -----------------------\n| - - - | - 8 - | - 7 - |\n| - 1 7 | - - - | - - - |\n| - - - | - 3 6 | - 4 - |\n -----------------------\n\nSolution:\n -----------------------\n| 8 5 9 | 6 1 2 | 4 3 7 |\n| 7 2 3 | 8 5 4 | 1 6 9 |\n| 1 6 4 | 3 7 9 | 5 2 8 |\n -----------------------\n| 9 8 6 | 1 4 7 | 3 5 2 |\n| 3 7 5 | 2 6 8 | 9 1 4 |\n| 2 4 1 | 5 9 3 | 7 8 6 |\n -----------------------\n| 4 3 2 | 9 8 1 | 6 7 5 |\n| 6 1 7 | 4 2 5 | 8 9 3 |\n| 5 9 8 | 7 3 6 | 2 4 1 |\n -----------------------\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "C#", "code": "\nBacktracking[edit]\nTranslation of: Java\nusing System;\n\nclass SudokuSolver\n{\n    private int[] grid;\n\n    public SudokuSolver(String s)\n    {\n        grid = new int[81];\n        for (int i = 0; i < s.Length; i++)\n        {\n            grid[i] = int.Parse(s[i].ToString());\n        }\n    }\n\n    public void solve()\n    {\n        try\n        {\n            placeNumber(0);\n            Console.WriteLine(\"Unsolvable!\");\n        }\n        catch (Exception ex)\n        {\n            Console.WriteLine(ex.Message);\n            Console.WriteLine(this);\n        }\n    }\n\n    public void placeNumber(int pos)\n    {\n        if (pos == 81)\n        {\n            throw new Exception(\"Finished!\");\n        }\n        if (grid[pos] > 0)\n        {\n            placeNumber(pos + 1);\n            return;\n        }\n        for (int n = 1; n <= 9; n++)\n        {\n            if (checkValidity(n, pos % 9, pos / 9))\n            {\n                grid[pos] = n;\n                placeNumber(pos + 1);\n                grid[pos] = 0;\n            }\n        }\n    }\n\n    public bool checkValidity(int val, int x, int y)\n    {\n        for (int i = 0; i < 9; i++)\n        {\n            if (grid[y * 9 + i] == val || grid[i * 9 + x] == val)\n                return false;\n        }\n        int startX = (x / 3) * 3;\n        int startY = (y / 3) * 3;\n        for (int i = startY; i < startY + 3; i++)\n        {\n            for (int j = startX; j < startX + 3; j++)\n            {\n                if (grid[i * 9 + j] == val)\n                    return false;\n            }\n        }\n        return true;\n    }\n\n    public override string ToString()\n    {\n        string sb = \"\";\n        for (int i = 0; i < 9; i++)\n        {\n            for (int j = 0; j < 9; j++)\n            {\n                sb += (grid[i * 9 + j] + \" \");\n                if (j == 2 || j == 5)\n                    sb += (\"| \");\n            }\n            sb += ('\\n');\n            if (i == 2 || i == 5)\n                sb += (\"------+-------+------\\n\");\n        }\n        return sb;\n    }\n\n    public static void Main(String[] args)\n    {\n        new SudokuSolver(\"850002400\" +\n                         \"720000009\" +\n                         \"004000000\" +\n                         \"000107002\" +\n                         \"305000900\" +\n                         \"040000000\" +\n                         \"000080070\" +\n                         \"017000000\" +\n                         \"000036040\").solve();\n        Console.Read();\n    }\n}\n\nBest First Search[edit]\nusing System.Linq;\nusing static System.Linq.Enumerable;\nusing System.Collections.Generic;\nusing System;\nusing System.Runtime.CompilerServices;\n\nnamespace SodukoFastMemoBFS {\n    internal readonly record struct Square (int Row, int Col);\n    internal record Constraints (IEnumerable<int> ConstrainedRange, Square Square);\n    internal class Cache : Dictionary<Square, Constraints> { };\n    internal record CacheGrid (int[][] Grid, Cache Cache);\n\n    internal static class SudokuFastMemoBFS {\n        internal static U Fwd<T, U>(this T data, Func<T, U> f) => f(data);\n\n        [MethodImpl(MethodImplOptions.AggressiveInlining)]\n        private static int RowCol(int rc) => rc <= 2 ? 0 : rc <= 5 ? 3 : 6;\n\n        private static bool Solve(this CacheGrid cg, Constraints constraints, int finished) {            \n            var (row, col) = constraints.Square;\n            foreach (var i in constraints.ConstrainedRange) {\n                cg.Grid[row][col] = i;\n                if (cg.Cache.Count == finished || cg.Solve(cg.Next(constraints.Square), finished))\n                    return true;                    \n            }\n            cg.Grid[row][col] = 0;\n            return false;\n        }\n\n        private static readonly int[] domain = Range(0, 9).ToArray();\n        private static readonly int[] range = Range(1, 9).ToArray();\n\n        private static bool Valid(this int[][] grid, int row, int col, int val) {\n            for (var i = 0; i < 9; i++)\n                if (grid[row][i] == val || grid[i][col] == val)\n                    return false;\n            for (var r = RowCol(row); r < RowCol(row) + 3; r++)\n                for (var c = RowCol(col); c < RowCol(col) + 3; c++)\n                    if (grid[r][c] == val)\n                        return false;\n            return true;\n        }\n\n        private static IEnumerable<int> Constraints(this int[][] grid, int row, int col) =>\n            range.Where(val => grid.Valid(row, col, val));\n\n        private static Constraints Next(this CacheGrid cg, Square square) => \n            cg.Cache.ContainsKey(square)\n            ? cg.Cache[square]\n            : cg.Cache[square]=cg.Grid.SortedCells();\n\n        private static Constraints SortedCells(this int[][] grid) =>\n            (from row in domain\n            from col in domain\n            where grid[row][col] == 0\n            let cell = new Constraints(grid.Constraints(row, col), new Square(row, col))\n            orderby cell.ConstrainedRange.Count() ascending\n            select cell).First();\n\n        private static CacheGrid Parse(string input) =>\n            input\n            .Select((c, i) => (index: i, val: int.Parse(c.ToString())))\n            .GroupBy(id => id.index / 9)\n            .Select(grp => grp.Select(id => id.val).ToArray())\n            .ToArray()\n            .Fwd(grid => new CacheGrid(grid, new Cache()));\n            \n        public static string AsString(this int[][] grid) =>\n            string.Join('\\n', grid.Select(row => string.Concat(row)));\n\n        public static int[][] Run(string input) {\n            var cg = Parse(input);\n            var marked = cg.Grid.SelectMany(row => row.Where(c => c > 0)).Count();\n            return cg.Solve(cg.Grid.SortedCells(), 80 - marked) ? cg.Grid : new int[][] { Array.Empty<int>() };\n        }\n    }\n}\n\n\nusing System.Linq;\nusing static System.Linq.Enumerable;\nusing static System.Console;\nusing System.IO;\n\nnamespace SodukoFastMemoBFS {\n    static class Program {\n\n        static void Main(string[] args) {            \n            var num = int.Parse(args[0]);\n            var puzzles = File.ReadLines(@\"sudoku17.txt\").Take(num);\n            var single = puzzles.First();\n\n            var watch = new System.Diagnostics.Stopwatch();\n            watch.Start();\n            WriteLine(SudokuFastMemoBFS.Run(single).AsString());\n            watch.Stop();\n            WriteLine($\"{single}: {watch.ElapsedMilliseconds} ms\");\n\n            WriteLine($\"Doing {num} puzzles\");\n            var total = 0.0;\n            watch.Start();\n            foreach (var puzzle in puzzles) {\n                watch.Reset();\n                watch.Start();\n                SudokuFastMemoBFS.Run(puzzle);\n                watch.Stop();\n                total += watch.ElapsedMilliseconds;\n                Write(\".\");\n            }\n            watch.Stop();\n            WriteLine($\"\\nPuzzles:{num}, Total:{total} ms, Average:{total / num:0.00} ms\");\n            ReadKey();\n        }\n    }\n}\n\n\n693784512\n487512936\n125963874\n932651487\n568247391\n741398625\n319475268\n856129743\n274836159\n000000010400000000020000000000050407008000300001090000300400200050100000000806000: 336 ms\nDoing 100 puzzles\n....................................................................................................\nPuzzles:100, Total:5316 ms, Average:53.16 ms\nSolver[edit]\nLibrary: Microsoft Solver Foundation\nusing Microsoft.SolverFoundation.Solvers;\n\nnamespace Sudoku\n{\n    class Program\n    {\n        private static int[,] B = new int[,] {{9,7,0, 3,0,0, 0,6,0},\n                                              {0,6,0, 7,5,0, 0,0,0},\n                                              {0,0,0, 0,0,8, 0,5,0},\n\n                                              {0,0,0, 0,0,0, 6,7,0},\n                                              {0,0,0, 0,3,0, 0,0,0},\n                                              {0,5,3, 9,0,0, 2,0,0},\n\n                                              {7,0,0, 0,2,5, 0,0,0},\n                                              {0,0,2, 0,1,0, 0,0,8},\n                                              {0,4,0, 0,0,7, 3,0,0}};\n\n        private static CspTerm[] GetSlice(CspTerm[][] sudoku, int Ra, int Rb, int Ca, int Cb)\n        {\n            CspTerm[] slice = new CspTerm[9];\n            int i = 0;\n            for (int row = Ra; row < Rb + 1; row++)\n                for (int col = Ca; col < Cb + 1; col++)\n                {\n                    {\n                        slice[i++] = sudoku[row][col];\n                    }\n                }\n            return slice;\n        }\n\n        static void Main(string[] args)\n        {\n            ConstraintSystem S = ConstraintSystem.CreateSolver();\n            CspDomain Z = S.CreateIntegerInterval(1, 9);\n            CspTerm[][] sudoku = S.CreateVariableArray(Z, \"cell\", 9, 9);\n            for (int row = 0; row < 9; row++)\n            {\n                for (int col = 0; col < 9; col++)\n                {\n                    if (B[row, col] > 0)\n                    {\n                        S.AddConstraints(S.Equal(B[row, col], sudoku[row][col]));\n                    }\n                }\n                S.AddConstraints(S.Unequal(GetSlice(sudoku, row, row, 0, 8)));\n            }\n            for (int col = 0; col < 9; col++)\n            {\n                S.AddConstraints(S.Unequal(GetSlice(sudoku, 0, 8, col, col)));\n            }\n            for (int a = 0; a < 3; a++)\n            {\n                for (int b = 0; b < 3; b++)\n                {\n                    S.AddConstraints(S.Unequal(GetSlice(sudoku, a * 3, a * 3 + 2, b * 3, b * 3 + 2)));\n                }\n            }\n            ConstraintSolverSolution soln = S.Solve();\n            object[] h = new object[9];\n            for (int row = 0; row < 9; row++)\n            {\n                if ((row % 3) == 0) System.Console.WriteLine();\n                for (int col = 0; col < 9; col++)\n                {\n                    soln.TryGetValue(sudoku[row][col], out h [col]);\n                }\n                System.Console.WriteLine(\"{0}{1}{2} {3}{4}{5} {6}{7}{8}\", h[0],h[1],h[2],h[3],h[4],h[5],h[6],h[7],h[8]);\n            }\n        }\n    }\n}\n\n\n975 342 861\n861 759 432\n324 168 957\n\n219 584 673\n487 236 519\n653 971 284\n\n738 425 196\n592 613 748\n146 897 325\n\n\"Dancing Links\"/Algorithm X[edit]\nusing System;\nusing System.Collections.Generic;\nusing System.Text;\nusing static System.Linq.Enumerable;\n\npublic class Sudoku\n{\n    public static void Main2() {\n        string puzzle = \"....7.94.....9...53....5.7...74..1..463...........7.8.8........7......28.5.26....\";\n        string solution = new Sudoku().Solutions(puzzle).FirstOrDefault() ?? puzzle;\n        Print(puzzle, solution);\n    }\n\n    private DLX dlx;\n\n    public void Build() {\n        const int rows = 9 * 9 * 9, columns = 4 * 9 * 9;\n        dlx = new DLX(rows, columns);\n        for (int i = 0; i < columns; i++) dlx.AddHeader();\n\n        for (int cell = 0, row = 0; row < 9; row++) {\n            for (int column = 0; column < 9; column++) {\n                int box = row / 3 * 3 + column / 3;\n                for (int digit = 0; digit < 9; digit++) {\n                    dlx.AddRow(cell, 81 + row * 9 + digit, 2 * 81 + column * 9 + digit, 3 * 81 + box * 9 + digit);\n                }\n                cell++;\n            }\n        }\n    }\n\n    public IEnumerable<string> Solutions(string puzzle) {\n        if (puzzle == null) throw new ArgumentNullException(nameof(puzzle));\n        if (puzzle.Length != 81) throw new ArgumentException(\"The input is not of the correct length.\");\n        if (dlx == null) Build();\n\n        for (int i = 0; i < puzzle.Length; i++) {\n            if (puzzle[i] == '0' || puzzle[i] == '.') continue;\n            if (puzzle[i] < '1' && puzzle[i] > '9') throw new ArgumentException($\"Input contains an invalid character: ({puzzle[i]})\");\n            int digit = puzzle[i] - '0' - 1;\n            dlx.Give(i * 9 + digit);\n        }\n        return Iterator();\n\n        IEnumerable<string> Iterator() {\n            var sb = new StringBuilder(new string('.', 81));\n            foreach (int[] rows in dlx.Solutions()) {\n                foreach (int r in rows) {\n                    sb[r / 81 * 9 + r / 9 % 9] = (char)(r % 9 + '1');\n                }\n                yield return sb.ToString();\n            }\n        }\n    }\n\n    static void Print(string left, string right) {\n        foreach (string line in GetPrintLines(left).Zip(GetPrintLines(right), (l, r) => l + \"\\t\" + r)) {\n            Console.WriteLine(line);\n        }\n\n        IEnumerable<string> GetPrintLines(string s) {\n            int r = 0;\n            foreach (string row in s.Cut(9)) {\n                yield return r == 0\n                    ? \"\u2554\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2557\"\n                    : r % 3 == 0\n                    ? \"\u2560\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2563\"\n                    : \"\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\";\n                yield return \"\u2551 \" + row.Cut(3).Select(segment => segment.DelimitWith(\" \u2502 \")).DelimitWith(\" \u2551 \") + \" \u2551\";\n                r++;\n            }\n            yield return \"\u255a\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u255d\";\n        }\n    }\n\n}\n\npublic class DLX //Some functionality elided\n{\n    private readonly Header root = new Header(null, null) { Size = int.MaxValue };\n    private readonly List<Header> columns;\n    private readonly List<Node> rows;\n    private readonly Stack<Node> solutionNodes = new Stack<Node>();\n    private int initial = 0;\n\n    public DLX(int rowCapacity, int columnCapacity) {\n        columns = new List<Header>(columnCapacity);\n        rows = new List<Node>(rowCapacity);\n    }\n\n    public void AddHeader() {\n        Header h = new Header(root.Left, root);\n        h.AttachLeftRight();\n        columns.Add(h);\n    }\n\n    public void AddRow(params int[] newRow) {\n        Node first = null;\n        if (newRow != null) {\n            for (int i = 0; i < newRow.Length; i++) {\n                if (newRow[i] < 0) continue;\n                if (first == null) first = AddNode(rows.Count, newRow[i]);\n                else AddNode(first, newRow[i]);\n            }\n        }\n        rows.Add(first);\n    }\n\n    private Node AddNode(int row, int column) {\n        Node n = new Node(null, null, columns[column].Up, columns[column], columns[column], row);\n        n.AttachUpDown();\n        n.Head.Size++;\n        return n;\n    }\n\n    private void AddNode(Node firstNode, int column) {\n        Node n = new Node(firstNode.Left, firstNode, columns[column].Up, columns[column], columns[column], firstNode.Row);\n        n.AttachLeftRight();\n        n.AttachUpDown();\n        n.Head.Size++;\n    }\n\n    public void Give(int row) {\n        solutionNodes.Push(rows[row]);\n        CoverMatrix(rows[row]);\n        initial++;\n    }\n\n    public IEnumerable<int[]> Solutions() {\n        try {\n            Node node = ChooseSmallestColumn().Down;\n            do {\n                if (node == node.Head) {\n                    if (node == root) {\n                        yield return solutionNodes.Select(n => n.Row).ToArray();\n                    }\n                    if (solutionNodes.Count > initial) {\n                        node = solutionNodes.Pop();\n                        UncoverMatrix(node);\n                        node = node.Down;\n                    }\n                } else {\n                    solutionNodes.Push(node);\n                    CoverMatrix(node);\n                    node = ChooseSmallestColumn().Down;\n                }\n            } while(solutionNodes.Count > initial || node != node.Head);\n        } finally {\n            Restore();\n        }\n    }\n\n    private void Restore() {\n        while (solutionNodes.Count > 0) UncoverMatrix(solutionNodes.Pop());\n        initial = 0;\n    }\n\n    private Header ChooseSmallestColumn() {\n        Header traveller = root, choice = root;\n        do {\n            traveller = (Header)traveller.Right;\n            if (traveller.Size < choice.Size) choice = traveller;\n        } while (traveller != root && choice.Size > 0);\n        return choice;\n    }\n\n    private void CoverRow(Node row) {\n        Node traveller = row.Right;\n        while (traveller != row) {\n            traveller.DetachUpDown();\n            traveller.Head.Size--;\n            traveller = traveller.Right;\n        }\n    }\n\n    private void UncoverRow(Node row) {\n        Node traveller = row.Left;\n        while (traveller != row) {\n            traveller.AttachUpDown();\n            traveller.Head.Size++;\n            traveller = traveller.Left;\n        }\n    }\n\n    private void CoverColumn(Header column) {\n        column.DetachLeftRight();\n        Node traveller = column.Down;\n        while (traveller != column) {\n            CoverRow(traveller);\n            traveller = traveller.Down;\n        }\n    }\n\n    private void UncoverColumn(Header column) {\n        Node traveller = column.Up;\n        while (traveller != column) {\n            UncoverRow(traveller);\n            traveller = traveller.Up;\n        }\n        column.AttachLeftRight();\n    }\n\n    private void CoverMatrix(Node node) {\n        Node traveller = node;\n        do {\n            CoverColumn(traveller.Head);\n            traveller = traveller.Right;\n        } while (traveller != node);\n    }\n\n    private void UncoverMatrix(Node node) {\n        Node traveller = node;\n        do {\n            traveller = traveller.Left;\n            UncoverColumn(traveller.Head);\n        } while (traveller != node);\n    }\n\n    private class Node\n    {\n        public Node(Node left, Node right, Node up, Node down, Header head, int row) {\n            Left = left ?? this;\n            Right = right ?? this;\n            Up = up ?? this;\n            Down = down ?? this;\n            Head = head ?? this as Header;\n            Row = row;\n        }\n\n        public Node Left   { get; set; }\n        public Node Right  { get; set; }\n        public Node Up     { get; set; }\n        public Node Down   { get; set; }\n        public Header Head { get; }\n        public int Row     { get; }\n\n        public void AttachLeftRight() {\n            this.Left.Right = this;\n            this.Right.Left = this;\n        }\n\n        public void AttachUpDown() {\n            this.Up.Down = this;\n            this.Down.Up = this;\n        }\n\n        public void DetachLeftRight() {\n            this.Left.Right = this.Right;\n            this.Right.Left = this.Left;\n        }\n\n        public void DetachUpDown() {\n            this.Up.Down = this.Down;\n            this.Down.Up = this.Up;\n        }\n\n    }\n\n    private class Header : Node\n    {\n        public Header(Node left, Node right) : base(left, right, null, null, null, -1) { }\n        \n        public int Size { get; set; }\n    }\n\n}\n\nstatic class Extensions\n{\n    public static IEnumerable<string> Cut(this string input, int length)\n    {\n        for (int cursor = 0; cursor < input.Length; cursor += length) {\n            if (cursor + length > input.Length) yield return input.Substring(cursor);\n            else yield return input.Substring(cursor, length);\n        }\n    }\n\n    public static string DelimitWith<T>(this IEnumerable<T> source, string separator) => string.Join(separator, source);\n}\n\n\nOutput:\n\u2554\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2557\t\u2554\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2566\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2564\u2550\u2550\u2550\u2557\n\u2551 . \u2502 . \u2502 . \u2551 . \u2502 7 \u2502 . \u2551 9 \u2502 4 \u2502 . \u2551\t\u2551 2 \u2502 1 \u2502 5 \u2551 8 \u2502 7 \u2502 6 \u2551 9 \u2502 4 \u2502 3 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 . \u2502 . \u2502 . \u2551 . \u2502 9 \u2502 . \u2551 . \u2502 . \u2502 5 \u2551\t\u2551 6 \u2502 7 \u2502 8 \u2551 3 \u2502 9 \u2502 4 \u2551 2 \u2502 1 \u2502 5 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 3 \u2502 . \u2502 . \u2551 . \u2502 . \u2502 5 \u2551 . \u2502 7 \u2502 . \u2551\t\u2551 3 \u2502 4 \u2502 9 \u2551 1 \u2502 2 \u2502 5 \u2551 8 \u2502 7 \u2502 6 \u2551\n\u2560\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2563\t\u2560\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2563\n\u2551 . \u2502 . \u2502 7 \u2551 4 \u2502 . \u2502 . \u2551 1 \u2502 . \u2502 . \u2551\t\u2551 5 \u2502 8 \u2502 7 \u2551 4 \u2502 3 \u2502 2 \u2551 1 \u2502 6 \u2502 9 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 4 \u2502 6 \u2502 3 \u2551 . \u2502 . \u2502 . \u2551 . \u2502 . \u2502 . \u2551\t\u2551 4 \u2502 6 \u2502 3 \u2551 9 \u2502 8 \u2502 1 \u2551 7 \u2502 5 \u2502 2 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 . \u2502 . \u2502 . \u2551 . \u2502 . \u2502 7 \u2551 . \u2502 8 \u2502 . \u2551\t\u2551 1 \u2502 9 \u2502 2 \u2551 6 \u2502 5 \u2502 7 \u2551 3 \u2502 8 \u2502 4 \u2551\n\u2560\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2563\t\u2560\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256c\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u256a\u2550\u2550\u2550\u2563\n\u2551 8 \u2502 . \u2502 . \u2551 . \u2502 . \u2502 . \u2551 . \u2502 . \u2502 . \u2551\t\u2551 8 \u2502 2 \u2502 6 \u2551 7 \u2502 4 \u2502 3 \u2551 5 \u2502 9 \u2502 1 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 7 \u2502 . \u2502 . \u2551 . \u2502 . \u2502 . \u2551 . \u2502 2 \u2502 8 \u2551\t\u2551 7 \u2502 3 \u2502 4 \u2551 5 \u2502 1 \u2502 9 \u2551 6 \u2502 2 \u2502 8 \u2551\n\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\t\u255f\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u256b\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u253c\u2500\u2500\u2500\u2562\n\u2551 . \u2502 5 \u2502 . \u2551 2 \u2502 6 \u2502 . \u2551 . \u2502 . \u2502 . \u2551\t\u2551 9 \u2502 5 \u2502 1 \u2551 2 \u2502 6 \u2502 8 \u2551 4 \u2502 3 \u2502 7 \u2551\n\u255a\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u255d\t\u255a\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2569\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u2567\u2550\u2550\u2550\u255d\n", "explain": "Usage\nOutput \nProduces:\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "JavaScript", "code": "\nES6[edit]\n//-------------------------------------------[ Dancing Links and Algorithm X ]--\n/**\n * The doubly-doubly circularly linked data object.\n * Data object X\n */\nclass DoX {\n  /**\n   * @param {string} V\n   * @param {!DoX=} H\n   */\n  constructor(V, H) {\n    this.V = V;\n    this.L = this;\n    this.R = this;\n    this.U = this;\n    this.D = this;\n    this.S = 1;\n    this.H = H || this;\n    H && (H.S += 1);\n  }\n}\n\n/**\n * Helper function to help build a horizontal doubly linked list.\n * @param {!DoX} e An existing node in the list.\n * @param {!DoX} n A new node to add to the right of the existing node.\n * @return {!DoX}\n */\nconst addRight = (e, n) => {\n  n.R = e.R;\n  n.L = e;\n  e.R.L = n;\n  return e.R = n;\n};\n\n/**\n * Helper function to help build a vertical doubly linked list.\n * @param {!DoX} e An existing node in the list.\n * @param {!DoX} n A new node to add below the existing node.\n */\nconst addBelow = (e, n) => {\n  n.D = e.D;\n  n.U = e;\n  e.D.U = n;\n  return e.D = n;\n};\n\n/**\n * Verbatim copy of DK's search algorithm. The meat of the DLX algorithm.\n * @param {!DoX} h The root node.\n * @param {!Array<!DoX>} s The solution array.\n */\nconst search = function(h, s) {\n  if (h.R == h) {\n    printSol(s);\n  } else {\n    let c = chooseColumn(h);\n    cover(c);\n    for (let r = c.D; r != c; r = r.D) {\n      s.push(r);\n      for (let j = r.R; r !=j; j = j.R) {\n        cover(j.H);\n      }\n      search(h, s);\n      r = s.pop();\n      for (let j = r.R; j != r; j = j.R) {\n        uncover(j.H);\n      }\n    }\n    uncover(c);\n  }\n};\n\n/**\n * Verbatim copy of DK's algorithm for choosing the next column object.\n * @param {!DoX} h\n * @return {!DoX}\n */\nconst chooseColumn = h => {\n  let s = Number.POSITIVE_INFINITY;\n  let c = h;\n  for(let j = h.R; j != h; j = j.R) {\n    if (j.S < s) {\n      c = j;\n      s = j.S;\n    }\n  }\n  return c;\n};\n\n\n/**\n * Verbatim copy of DK's cover algorithm\n * @param {!DoX} c\n */\nconst cover = c => {\n  c.L.R = c.R;\n  c.R.L = c.L;\n  for (let i = c.D; i != c; i = i.D) {\n    for (let j = i.R; j != i; j = j.R) {\n      j.U.D = j.D;\n      j.D.U = j.U;\n      j.H.S = j.H.S - 1;\n    }\n  }\n};\n\n/**\n * Verbatim copy of DK's cover algorithm\n * @param {!DoX} c\n */\nconst uncover = c => {\n  for (let i = c.U; i != c; i = i.U) {\n    for (let j = i.L; i != j; j = j.L) {\n      j.H.S = j.H.S + 1;\n      j.U.D = j;\n      j.D.U = j;\n    }\n  }\n  c.L.R = c;\n  c.R.L = c;\n};\n\n//-----------------------------------------------------------[ Print Helpers ]--\n/**\n * Given the standard string format of a grid, print a formatted view of it.\n * @param {!string|!Array} a\n */\nconst printGrid = function(a) {\n\n  const getChar = c => {\n    let r = Number(c);\n    if (isNaN(r)) { return c }\n\n    let o = 48;\n    if (r > 9 && r < 36) { o = 55 }\n    if (r >= 36) { o = 61 }\n    return String.fromCharCode(r + o)\n  };\n\n  a = 'string' == typeof a ? a.split('') : a;\n\n  let U = Math.sqrt(a.length);\n  let N = Math.sqrt(U);\n  let line = new Array(N).fill('+').reduce((p, c) => {\n    p.push(... Array.from(new Array(1 + N*2).fill('-')));\n    p.push(c);\n    return p;\n  }, ['\\n+']).join('') + '\\n';\n\n  a = a.reduce(function(p, c, i) {\n      let d = i && !(i % U), G = i && !(i % N);\n      i = !(i % (U * N));\n      d && !i && (p += '|\\n| ');\n      d && i && (p += '|');\n      i && (p = '' + p + line + '| ');\n      return '' + p + (G && !d ? '| ' : '') + getChar(c) + ' ';\n    }, '') + '|' + line;\n  console.log(a);\n\n};\n\n/**\n * Given a search solution, print the resultant grid.\n * @param {!Array<!DoX>} a An array of data objects\n */\nconst printSol = a => {\n  printGrid(a.reduce((p, c) => {\n    let [i, v] = c.V.split(':');\n    p[i * 1] = v;\n    return p;\n  }, new Array(a.length).fill('.')));\n};\n\n//----------------------------------------------[ Grid to Exact cover Matrix ]--\n/**\n * Helper to get some meta about the grid.\n * @param {!string} s The standard string representation of a grid.\n * @return {!Array}\n */\nconst gridMeta = s => {\n  const g = s.split('');\n  const cellCount = g.length;\n  const tokenCount = Math.sqrt(cellCount);\n  const N = Math.sqrt(tokenCount);\n  const g2D = g.map(e => isNaN(e * 1) ?\n    new Array(tokenCount).fill(1).map((_, i) => i + 1) :\n    [e * 1]);\n  return [cellCount, N, tokenCount, g2D];\n};\n\n/**\n * Given a cell grid index, return the row, column and box indexes.\n * @param {!number} n The n-value of the grid. 3 for a 9x9 sudoku.\n * @return {!function(!number): !Array<!number>}\n */\nconst indexesN = n => i => {\n    let c = Math.floor(i / (n * n));\n    i %= n * n;\n    return [c, i, Math.floor(c / n) * n + Math.floor(i / n)];\n};\n\n/**\n * Given a puzzle string, reduce it to an exact-cover matrix and use\n * Donald Knuth's DLX algorithm to solve it.\n * @param puzString\n */\nconst reduceGrid = puzString => {\n\n  printGrid(puzString);\n  const [\n    numCells,   // The total number of cells in a grid (81 for a 9x9 grid)\n    N,          // the 'n' value of the grid. (3 for a 9x9 grid)\n    U,          // The total number of unique tokens to be placed.\n    g2D         // A 2D array representation of the grid, with each element\n                // being an array of candidates for a cell. Known cells are\n                // single element arrays.\n  ] = gridMeta(puzString);\n\n  const getIndex = indexesN(N);\n\n  /**\n   * The DLX Header row.\n   * Its length is 4 times the grid's size. This is to be able to encode\n   * each of the 4 Sudoku constrains, onto each of the cells of the grid.\n   * The array is initialised with unlinked DoX nodes, but in the next step\n   * those nodes are all linked.\n   * @type {!Array.<!DoX>}\n   */\n  const headRow = new Array(4 * numCells)\n    .fill('')\n    .map((_, i) => new DoX(`H${i}`));\n\n  /**\n   * The header row root object. This is circularly linked to be to the left\n   * of the first header object in the header row array.\n   * It is used as the entry point into the DLX algorithm.\n   * @type {!DoX}\n   */\n  let H = new DoX('ROOT');\n  headRow.reduce((p, c) => addRight(p, c), H);\n\n  /**\n   * Transposed the sudoku puzzle into a exact cover matrix, so it can be passed\n   * to the DLX algorithm to solve.\n   */\n  for (let i = 0; i < numCells; i++) {\n    const [ri, ci, bi] = getIndex(i);\n    g2D[i].forEach(num => {\n      let id = `${i}:${num}`;\n      let candIdx = num - 1;\n\n      // The 4 columns that we will populate.\n      const A = headRow[i];\n      const B = headRow[numCells + candIdx + (ri * U)];\n      const C = headRow[(numCells * 2) + candIdx + (ci * U)];\n      const D = headRow[(numCells * 3) + candIdx + (bi * U)];\n\n      // The Row-Column Constraint\n      let rcc = addBelow(A.U, new DoX(id, A));\n\n      // The Row-Number Constraint\n      let rnc = addBelow(B.U, addRight(rcc, new DoX(id, B)));\n\n      // The Column-Number Constraint\n      let cnc = addBelow(C.U, addRight(rnc, new DoX(id, C)));\n\n      // The Block-Number Constraint\n      addBelow(D.U, addRight(cnc, new DoX(id, D)));\n    });\n  }\n  search(H, []);\n};\n\n[\n  '819..5.....2...75..371.4.6.4..59.1..7..3.8..2..3.62..7.5.7.921..64...9.....2..438',\n  '53..247....2...8..1..7.39.2..8.72.49.2.98..7.79.....8.....3.5.696..1.3...5.69..1.',\n  '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..',\n  '394..267....3..4..5..69..2..45...9..6.......7..7...58..1..67..8..9..8....264..735',\n  '97.3...6..6.75.........8.5.......67.....3.....539..2..7...25.....2.1...8.4...73..',\n  '4......6.5...8.9..3....1....2.7....1.9.....4.8....3.5....2....7..6.5...8.1......6',\n  '85...24..72......9..4.........1.7..23.5...9...4...........8..7..17..........36.4.',\n  '..1..5.7.92.6.......8...6...9..2.4.1.........3.4.8..9...7...3.......7.69.1.8..7..',\n  '.9...4..7.....79..8........4.58.....3.......2.....97.6........4..35.....2..6...8.',\n  '12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8',\n  '9..2..5...4..6..3...3.....6...9..2......5..8...7..4..37.....1...5..2..4...1..6..9',\n  '1....7.9..3..2...8..96..5....53..9...1..8...26....4...3......1..4......7..7...3..',\n  '12.4..3..3...1..5...6...1..7...9.....4.6.3.....3..2...5...8.7....7.....5.......98',\n  '..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9',\n  '.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....',\n  '....839..1......3...4....7..42.3....6.......4....7..1..2........8...92.....25...6',\n  '..3......4...8..36..8...1...4..6..73...9..........2..5..4.7..686........7..6..5..'\n].forEach(reduceGrid);\n\n// Or of you want to create all the grids of a particular n-size.\n// I run out of stack space at n = 9\nlet n = 2;\nlet s = new Array(Math.pow(n, 4)).fill('.').join('');\nreduceGrid(s);\n\n+-------+-------+-------+\n| . . 3 | . . . | . . . |\n| 4 . . | . 8 . | . 3 6 |\n| . . 8 | . . . | 1 . . |\n+-------+-------+-------+\n| . 4 . | . 6 . | . 7 3 |\n| . . . | 9 . . | . . . |\n| . . . | . . 2 | . . 5 |\n+-------+-------+-------+\n| . . 4 | . 7 . | . 6 8 |\n| 6 . . | . . . | . . . |\n| 7 . . | 6 . . | 5 . . |\n+-------+-------+-------+\n\n+-------+-------+-------+\n| 1 2 3 | 4 5 6 | 7 8 9 |\n| 4 5 7 | 1 8 9 | 2 3 6 |\n| 9 6 8 | 3 2 7 | 1 5 4 |\n+-------+-------+-------+\n| 2 4 9 | 5 6 1 | 8 7 3 |\n| 5 7 6 | 9 3 8 | 4 1 2 |\n| 8 3 1 | 7 4 2 | 6 9 5 |\n+-------+-------+-------+\n| 3 1 4 | 2 7 5 | 9 6 8 |\n| 6 9 5 | 8 1 4 | 3 2 7 |\n| 7 8 2 | 6 9 3 | 5 4 1 |\n+-------+-------+-------+\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "SQL", "code": "\nWorks with: oracle version 11.2 and higher\n\nwith\n  symbols (d) as (select to_char(level) from dual connect by level <=  9)\n, board   (i) as (select level          from dual connect by level <= 81)\n, neighbors (i, j) as (\n    select b1.i, b2.i\n    from   board b1 inner join board b2\n      on   b1.i != b2.i\n           and (\n                    mod(b1.i - b2.i, 9) = 0\n                 or ceil(b1.i /  9) = ceil(b2.i /  9)\n                 or ceil(b1.i / 27) = ceil(b2.i / 27) and trunc(mod(b1.i - 1, 9) / 3) = trunc(mod(b2.i - 1, 9) / 3)\n               )\n  )\n, r (str, pos) as (\n    select  :game, instr(:game, ' ')\n      from  dual\n    union all\n    select  substr(r.str, 1, r.pos - 1) || s.d || substr(r.str, r.pos + 1), instr(r.str, ' ', r.pos + 1)\n      from  r inner join symbols s\n        on  r.pos > 0 and not exists (\n                                       select *\n                                       from   neighbors n\n                                       where  r.pos = n.i and s.d = substr(r.str, n.j, 1)\n                                     )\n  )\nselect str\nfrom   r\nwhere  pos = 0\n;\n\n\n", "explain": "The implementation below uses a recursive WITH clause (aka recursive CTE, recursive query, recursive factored subquery). This is supported - with minimal syntactical differences - by some (perhaps many) but not all SQL dialects. The code was written and tested in Oracle SQL; Oracle has supported recursive subqueries since version 11.2.\nThe code implements a brute force algorithm. It can solve most problems in less than half a second (depending on hardware too), although I found a few that take 2-3 and up to 6 seconds. The output may either be empty (when the problem is impossible), a single completed grid (for a \"correct\" problem), or all the correct solutions to problems that admit more than one solution.\nThe input and output are presented as strings of 81 characters, where each character is either a digit or a space (indicating an empty cell in the grid). The translation between grids and such strings is trivial (convert grid to string by concatenating rows, reading left to right and then top to bottom), and not covered in the solution. The input is given as a bind variable, :game.\nA better (faster) approach - taking advantage of database-specific features - is to create a table NEIGHBORS (similar to the inline view in the WITH clause) and an index on column I of that table; then the query execution time drops by more than half in most cases.\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "PHP", "code": "\nTranslation of: C++\n\tclass SudokuSolver {\n\t\tprotected $grid = [];\n\t\tprotected $emptySymbol;\n\t\tpublic static function parseString($str, $emptySymbol = '0')\n\t\t{\n\t\t\t$grid = str_split($str);\n\t\t\tforeach($grid as &$v)\n\t\t\t{\n\t\t\t\tif($v == $emptySymbol)\n\t\t\t\t{\n\t\t\t\t\t$v = 0;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\t$v = (int)$v;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn $grid;\n\t\t}\n\t\t\n\t\tpublic function __construct($str, $emptySymbol = '0') {\n\t\t\tif(strlen($str) !== 81)\n\t\t\t{\n\t\t\t\tthrow new \\Exception('Error sudoku');\n\t\t\t}\n\t\t\t$this->grid = static::parseString($str, $emptySymbol);\n\t\t\t$this->emptySymbol = $emptySymbol;\n\t\t}\n\t\t\n\t\tpublic function solve()\n\t\t{\n\t\t\ttry\n\t\t\t{\n\t\t\t\t$this->placeNumber(0);\n\t\t\t\treturn false;\n\t\t\t}\n\t\t\tcatch(\\Exception $e)\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t}\n\t\t\n\t\tprotected function placeNumber($pos)\n\t\t{\n\t\t\tif($pos == 81)\n\t\t\t{\n\t\t\t\tthrow new \\Exception('Finish');\n\t\t\t}\n\t\t\tif($this->grid[$pos] > 0)\n\t\t\t{\n\t\t\t\t$this->placeNumber($pos+1);\n\t\t\t\treturn;\n\t\t\t}\n\t\t\tfor($n = 1; $n <= 9; $n++)\n\t\t\t{\n\t\t\t\tif($this->checkValidity($n, $pos%9, floor($pos/9)))\n\t\t\t\t{\n\t\t\t\t\t$this->grid[$pos] = $n;\n\t\t\t\t\t$this->placeNumber($pos+1);\n\t\t\t\t\t$this->grid[$pos] = 0;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\t\n\t\tprotected function checkValidity($val, $x, $y)\n\t\t{\n\t\t\tfor($i = 0; $i < 9; $i++)\n\t\t\t{\n\t\t\t\tif(($this->grid[$y*9+$i] == $val) || ($this->grid[$i*9+$x] == $val))\n\t\t\t\t{\n\t\t\t\t\treturn false;\n\t\t\t\t}\n\t\t\t}\n\t\t\t$startX = (int) ((int)($x/3)*3);\n\t\t\t$startY = (int) ((int)($y/3)*3);\n\n\t\t\tfor($i = $startY; $i<$startY+3;$i++)\n\t\t\t{\n\t\t\t\tfor($j = $startX; $j<$startX+3;$j++)\n\t\t\t\t{\n\t\t\t\t\tif($this->grid[$i*9+$j] == $val)\n\t\t\t\t\t{\n\t\t\t\t\t\treturn false;\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn true;\n\t\t}\n\n\t\tpublic function display() {\n\t\t\t$str = '';\n\t\t\tfor($i = 0; $i<9; $i++)\n\t\t\t{\n\t\t\t\tfor($j = 0; $j<9;$j++)\n\t\t\t\t{\n\t\t\t\t\t$str .= $this->grid[$i*9+$j];\n\t\t\t\t\t$str .= \" \";\n\t\t\t\t\tif($j == 2 || $j == 5)\n\t\t\t\t\t{\n\t\t\t\t\t\t$str .= \"| \";\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t\t$str .= PHP_EOL;\n\t\t\t\tif($i == 2 || $i == 5)\n\t\t\t\t{\n\t\t\t\t\t$str .=  \"------+-------+------\".PHP_EOL;\n\t\t\t\t}\n\t\t\t}\n\t\t\techo $str;\n\t\t}\n\t\t\n\t\tpublic function __toString() {\n\t\t\tforeach ($this->grid as &$item)\n\t\t\t{\n\t\t\t\tif($item == 0)\n\t\t\t\t{\n\t\t\t\t\t$item = $this->emptySymbol;\n\t\t\t\t}\n\t\t\t}\n\t\t\treturn implode('', $this->grid);\n\t\t}\n\t}\n\t$solver = new SudokuSolver('009170000020600001800200000200006053000051009005040080040000700006000320700003900');\n\t$solver->solve();\n\t$solver->display();\n\n\nOutput:\n3 6 9 | 1 7 5 | 8 4 2 \n4 2 7 | 6 8 9 | 5 3 1 \n8 5 1 | 2 3 4 | 6 9 7 \n------+-------+------\n2 1 8 | 7 9 6 | 4 5 3 \n6 3 4 | 8 5 1 | 2 7 9 \n9 7 5 | 3 4 2 | 1 8 6 \n------+-------+------\n1 4 3 | 9 2 8 | 7 6 5 \n5 9 6 | 4 1 7 | 3 2 8 \n7 8 2 | 5 6 3 | 9 1 4\n(solved in 0.027s)\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "MATLAB", "code": "\n\nfunction solution = sudokuSolver(sudokuGrid)\n\n    %Define what each of the sub-boxes of the sudoku grid are by defining\n    %the start and end coordinates of each sub-box. The indecies represent\n    %the column and row of a grid coordinate on the actual sudoku grid.\n    %The contents of each cell with the same grid coordinates contain the\n    %information to determine which sub-box that grid coordinate is\n    %contained in on the sudoku grid. The array in position 1, i.e.\n    %subBoxes{row,column}(1), represents the row indecies of the subbox.\n    %The array in position 2, i.e. subBoxes{row,column}(2),represents the\n    %column indecies of the subbox.\n    \n    subBoxes(1:9,1:9) = {{(1:3),(1:3)}};\n    subBoxes(4:6,:)= {{(4:6),(1:3)}};\n    subBoxes(7:9,:)= {{(7:9),(1:3)}};\n    \n    for column = (4:6)\n        for row = (1:9) \n            subBoxes{row,column}(2)= {4:6};\n        end\n    end\n    for column = (7:9)\n        for row = (1:9) \n            subBoxes{row,column}(2)= {7:9};\n        end\n    end\n\n    %Generate a cell of arrays which contain the possible values of the\n    %sudoku grid for each cell in the grid. The possible values a specific\n    %grid coordinate can take share the same indices as the sudoku grid\n    %coordinate they represent.\n    %For example sudokuGrid(m,n) can be possibly filled in by the\n    %values stored in the array at possibleValues(m,n).\n    possibleValues(1:9,1:9) = { (1:9) };\n    \n    %Filter the possibleValues so that no entry exists for coordinates that\n    %have already been filled in. This will replace any array with an empty\n    %array in the possibleValues cell matrix at the coordinates of a grid\n    %already filled in the sudoku grid.\n    possibleValues( ~isnan(sudokuGrid) )={[]};\n    \n    %Iterate through each grid coordinate and filter out the possible\n    %values for that grid point that aren't alowed by the rules given the\n    %current values that are filled in. Or, if there is only one possible\n    %value for the current coordinate, fill it in.\n    \n    solution = sudokuGrid; %so the original sudoku input isn't modified\n    memory = 0; %contains the previous iterations possibleValues\n    dontStop = true; %stops the while loop when nothing else can be reasoned about the sudoku\n    \n    while( dontStop )\n \n%% Process of elimination deduction method\n\n        while( ~isequal(possibleValues,memory) ) %Stops using the process of elimination deduction method when this deduction rule stops working\n\n            memory = possibleValues; %Copies the current possibleValues into memory, for the above conditional on the next iteration.\n\n            %Iterate through everything\n            for row = (1:9) \n                for column = (1:9)\n\n                    if isnan( solution(row,column) ) %If grid coordinate hasn't been filled in, try to determine it's value.\n\n                        %Look at column to see what values have already\n                        %been filled in and thus the current grid\n                        %coordinate can't be\n                        removableValues = solution( ~isnan(solution(:,column)),column );\n\n                        %If there are any values that have been assigned to\n                        %other cells in the same column, filter those out\n                        %of the current cell's possiblValues\n                        if ~isempty(removableValues)\n                            for m = ( 1:numel(removableValues) )\n                                possibleValues{row,column}( possibleValues{row,column}==removableValues(m) )=[];\n                            end\n                        end\n\n                        %If the current grid coordinate can only atain one\n                        %possible value, assign it that value\n                        if numel( possibleValues{row,column} ) == 1\n                            solution(row,column) = possibleValues{row,column};\n                            possibleValues(row,column)={[]};\n                        end\n                    end  %end if\n\n                    if isnan( solution(row,column) ) %If grid coordinate hasn't been filled in, try to determine it's value. \n\n                        %Look at row to see what values have already\n                        %been filled in and thus the current grid\n                        %coordinate can't be\n                        removableValues = solution( row,~isnan(solution(row,:)) );\n\n                        %If there are any values that have been assigned to\n                        %other cells in the same row, filter those out\n                        %of the current cell's possiblValues\n                        if ~isempty(removableValues)\n                            for m = ( 1:numel(removableValues) )\n                                possibleValues{row,column}( possibleValues{row,column}==removableValues(m) )=[];\n                            end\n                        end\n                        \n                        %If the current grid coordinate can only atain one\n                        %possible value, assign it that value\n                        if numel( possibleValues{row,column} ) == 1\n                            solution(row,column) = possibleValues{row,column};\n                            possibleValues(row,column)={[]};\n                        end\n                    end %end if\n\n                    if isnan( solution(row,column) ) %If grid coordinate hasn't been filled in, try to determine it's value. \n                        \n                        %Look at sub-box to see if any possible values can be\n                        %filtered out. First pull the boundaries of the sub-box\n                        %containing the current array coordinate           \n                        currentBoxBoundaries=subBoxes{row,column};\n\n                        %Then pull the sub-boxes values out of the solution\n                        box = solution(currentBoxBoundaries{:});\n\n                        %Look at sub-box to see what values have already\n                        %been filled in and thus the current grid\n                        %coordinate can't be\n                        removableValues = box( ~isnan(box) );\n\n                        %If there are any values that have been assigned to\n                        %other cells in the same sub-box, filter those out\n                        %of the current cell's possiblValues\n                        if ~isempty(removableValues)\n                            for m = ( 1:numel(removableValues) )\n                                possibleValues{row,column}( possibleValues{row,column}==removableValues(m) )=[];\n                            end\n                        end\n                        \n                        %If the current grid coordinate can only atain one\n                        %possible value, assign it that value\n                        if numel( possibleValues{row,column} ) == 1\n                            solution(row,column) = possibleValues{row,column};\n                            possibleValues(row,column)={[]};\n                        end\n                    end %end if\n                    \n                end %end for column\n            end %end for row\n        end %stop process of elimination\n        \n%% Check that there are no contradictions in the solved grid coordinates.\n        \n        %Check that each row at most contains one of each of the integers\n        %from 1 to 9\n        if ~isempty( find( histc( solution,(1:9),1 )>1 ) )\n            solution = false;\n            return\n        end\n        \n        %Check that each column at most contains one of each of the integers\n        %from 1 to 9\n        if ~isempty( find( histc( solution,(1:9),2 )>1 ) )\n            solution = false;\n            return\n        end\n        \n        %Check that each sub-box at most contains one of each of the integers\n        %from 1 to 9\n        subBoxBins = zeros(9,9);\n        counter = 0;\n        for row = [2 5 8]\n            for column = [2 5 8]\n                counter = counter +1;\n                \n                %because the sub-boxes are extracted as square matricies,\n                %we need to reshape them into row vectors so all of the \n                %boxes can be input into histc simultaneously\n                subBoxBins(counter,:) = reshape( solution(subBoxes{row,column}{:}),1,9 ); \n            end\n        end\n        if ~isempty( find( histc( subBoxBins,(1:9),2 )>1 ) )\n            solution = false;\n            return\n        end\n                \n        %Check to make sure there are no grid coordinates that are not\n        %filled in and have no possible values.\n        \n        [rowStack,columnStack] = find(isnan(solution)); %extracts the indicies of the unsolved grid coordinates\n        if (numel(rowStack) > 0)\n            \n            for counter = (1:numel(rowStack))\n                if isempty(possibleValues{rowStack(counter),columnStack(counter)})\n                    solution = false;\n                    return\n                end  \n            end\n        \n        %if there are no more grid coordinates to be filed in then the\n        %sudoku is solved and we can return the solution without further \n        %computation\n        elseif (numel(rowStack) == 0)\n            return\n        end   \n        \n%% Use the unique relative compliment of sets deduction method\n\n        %Because no more information can be determined by the process of\n        %ellimination we have to try a new method of reasoning. Now we will\n        %look at the possible values a cell can take. If there is a value that\n        %that grid coordinate can take but no other coordinates in the same row,\n        %column or sub-box can take that value then we assign that coordinate\n        %that value.\n\n        keepGoing = true; %signals to keep applying rules to the current grid-coordinate because it hasn't been solved using previous rules\n        dontStop = false; %if this method doesn't figure anything out, this will terminate the top level while loop\n        \n        [rowStack,columnStack] = find(isnan(solution)); %This will also take care of the case where the sudoku is solved\n        counter = 0; %makes sure the loop terminates when there are no more cells to consider\n        \n        while( keepGoing && (counter < numel(rowStack)) ) %stop this method of reasoning when the value of one of the cells has been determined and return to the process of elimination method\n        \n            counter = counter + 1;\n            \n            row = rowStack(counter);\n            column = columnStack(counter);\n            \n            gridPossibles = [possibleValues{row,column}];\n            \n            coords = (1:9);\n            coords(column) = [];\n            rowPossibles = [possibleValues{row,coords}]; %extract possible values for everything in the same row except the current grid coordinate\n            \n            totalMatches = zeros( numel(gridPossibles),1 ); %preallocate for speed\n            \n            %count how many times a possible value for the current cell\n            %appears as a possible value for the cells in the same row\n            for n = ( 1:numel(gridPossibles) )\n                totalMatches(n) = sum( (rowPossibles == gridPossibles(n)) ); \n            end\n            \n            %remove any possible values for the current cell that have\n            %matches in other cells\n            gridPossibles = gridPossibles(totalMatches==0);\n            \n            %if there is only one possible value that the current cell can\n            %take that aren't shared by other cells, assign that value to\n            %the current cell.\n            if numel(gridPossibles) == 1\n                \n                solution(row,column) = gridPossibles;\n                possibleValues(row,column)={[]};\n                keepGoing = false; %stop this method of deduction and return to the process of elimination\n                dontStop = true; %keep the top level loop going\n                \n            end\n            \n            if(keepGoing) %do the same as above but for the current cell's column\n\n                gridPossibles = [possibleValues{row,column}];\n                \n                coords = (1:9);\n                coords(row) = [];\n                columnPossibles = [possibleValues{coords,column}];\n\n                totalMatches = zeros( numel(gridPossibles),1 );\n                for n = ( 1:numel(gridPossibles) )\n                    totalMatches(n) = sum( (columnPossibles == gridPossibles(n)) );\n                end\n\n                gridPossibles = gridPossibles(totalMatches==0);\n\n                if numel(gridPossibles) == 1\n\n                    solution(row,column) = gridPossibles;\n                    possibleValues(row,column)={[]};\n                    keepGoing = false;\n                    dontStop = true;\n\n                end\n            end\n            \n            if(keepGoing) %do the same as above but for the current cell's sub-box\n\n                gridPossibles = [possibleValues{row,column}];\n                \n                currentBoxBoundaries = subBoxes{row,column};\n                subBoxPossibles = [];\n                for m = currentBoxBoundaries{1}\n                    for n = currentBoxBoundaries{2}\n                        if ~((m == row) && (n == column))\n                            subBoxPossibles = [subBoxPossibles possibleValues{m,n}];\n                        end\n                    end\n                end\n\n                totalMatches = zeros( numel(gridPossibles),1 );\n                for n = ( 1:numel(gridPossibles) )\n                    totalMatches(n) = sum( (subBoxPossibles == gridPossibles(n)) );\n                end\n\n                gridPossibles = gridPossibles(totalMatches==0);\n\n                if numel(gridPossibles) == 1\n\n                    solution(row,column) = gridPossibles;\n                    possibleValues(row,column)={[]};\n                    keepGoing = false;\n                    dontStop = true;\n\n                end\n            end %end \n            \n        end %end  set comliment rule while loop \n    end %end top-level while loop\n\n%% Depth-first search of the solution tree\n\n    %There is no more reasoning that can solve the puzzle so now it is time\n    %for a depth-first search of the possible answers, basically\n    %guess-and-check. This is implimented recursively.\n    \n    [rowStack,columnStack] = find(isnan(solution)); %Get all of the unsolved cells\n    \n    if (numel(rowStack) > 0) %If all of the above stuff terminates then there will be at least one grid coordinate not filled in\n                \n        %Treat the rowStack and columnStack like stacks, and pop the top\n        %value off the stack to act as the current node whose\n        %possibleValues to search through, then assign the possible values\n        %of that grid coordinate to a variable that holds that values to\n        %search through\n        searchTreeNodes = possibleValues{rowStack(1),columnStack(1)}; \n        \n        keepSearching = true; %used to continue the search\n        counter = 0; %counts the amount of possible values searched for the current node\n        tempSolution = solution; %used so that the solution is not overriden until a solution hase been found\n        \n        while( keepSearching && (counter < numel(searchTreeNodes)) ) %stop recursing if we run out of possible values for the current node\n        \n            counter = counter + 1;\n            tempSolution(rowStack(1),columnStack(1)) = searchTreeNodes(counter); %assign a possible value to the current node in the tree\n            tempSolution = sudokuSolver(tempSolution); %recursively call the solver with the current guess value for the current grid coordinate           \n            \n            if ~islogical(tempSolution) %if tempSolution is not a boolean but a valid sudoku stop recursing and set solution to tempSolution\n               keepSearching = false;\n               solution = tempSolution;\n            elseif counter == numel(searchTreeNodes) %if we have run out of guesses for the current node, stop recursing and return a value of \"false\" for the solution\n               solution = false;\n            else %reset tempSolution to the current state of the board and try the next guess for the possible value of the current cell\n               tempSolution = solution;\n            end\n            \n        end %end recursion\n    end  %end if \n    \n%% End of program\nend %end sudokuSolver\n\n\nsudoku = [NaN   NaN   NaN   NaN     8     3     9   NaN   NaN\n     1   NaN   NaN   NaN   NaN   NaN   NaN     3   NaN\n   NaN   NaN     4   NaN   NaN   NaN   NaN     7   NaN\n   NaN     4     2   NaN     3   NaN   NaN   NaN   NaN\n     6   NaN   NaN   NaN   NaN   NaN   NaN   NaN     4\n   NaN   NaN   NaN   NaN     7   NaN   NaN     1   NaN\n   NaN     2   NaN   NaN   NaN   NaN   NaN   NaN   NaN\n   NaN     8   NaN   NaN   NaN     9     2   NaN   NaN\n   NaN   NaN   NaN     2     5   NaN   NaN   NaN     6]\n\n\nsolution =\n\n     7     6     5     4     8     3     9     2     1\n     1     9     8     7     2     6     4     3     5\n     2     3     4     9     1     5     6     7     8\n     8     4     2     5     3     1     7     6     9\n     6     1     7     8     9     2     3     5     4\n     3     5     9     6     7     4     8     1     2\n     9     2     6     1     4     7     5     8     3\n     5     8     1     3     6     9     2     4     7\n     4     7     3     2     5     8     1     9     6\n\n", "explain": "This solution impliments a recursive, depth-first search of the possible values unfilled sudoku cells can take. The search tree is pruned using logical deduction rules and takes about a minute to solve some of the more difficult puzzles. This code can be cleaned by making the main code blocks, denoted by \"%% [Block Title],\" into their own separate functions. This can also be further improved by implementing a Sudoku class and making this solver a member function. There are also several lines of code that can be vectorized to improve efficiency, but at the expense of readability.\nFor this to work, this code must be placed in a file named \"sudokuSolver.m\"\nTest Input:\nAll empty cells must have a value of NaN.\nOutput:\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nprogram sudoku\n\n  implicit none\n  integer, dimension (9, 9) :: grid\n  integer, dimension (9, 9) :: grid_solved\n  grid = reshape ((/               &\n    & 0, 0, 3, 0, 2, 0, 6, 0, 0,   &\n    & 9, 0, 0, 3, 0, 5, 0, 0, 1,   &\n    & 0, 0, 1, 8, 0, 6, 4, 0, 0,   &\n    & 0, 0, 8, 1, 0, 2, 9, 0, 0,   &\n    & 7, 0, 0, 0, 0, 0, 0, 0, 8,   &\n    & 0, 0, 6, 7, 0, 8, 2, 0, 0,   &\n    & 0, 0, 2, 6, 0, 9, 5, 0, 0,   &\n    & 8, 0, 0, 2, 0, 3, 0, 0, 9,   &\n    & 0, 0, 5, 0, 1, 0, 3, 0, 0/), &\n    & shape = (/9, 9/),            &\n    & order = (/2, 1/))\n  call pretty_print (grid)\n  call solve (1, 1)\n  write (*, *)\n  call pretty_print (grid_solved)\n\ncontains\n\n  recursive subroutine solve (i, j)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer :: n\n    integer :: n_tmp\n    if (i > 9) then\n      grid_solved = grid\n    else\n      do n = 1, 9\n        if (is_safe (i, j, n)) then\n          n_tmp = grid (i, j)\n          grid (i, j) = n\n          if (j == 9) then\n            call solve (i + 1, 1)\n          else\n            call solve (i, j + 1)\n          end if\n          grid (i, j) = n_tmp\n        end if\n      end do\n    end if\n  end subroutine solve\n\n  function is_safe (i, j, n) result (res)\n    implicit none\n    integer, intent (in) :: i\n    integer, intent (in) :: j\n    integer, intent (in) :: n\n    logical :: res\n    integer :: i_min\n    integer :: j_min\n    if (grid (i, j) == n) then\n      res = .true.\n      return\n    end if\n    if (grid (i, j) /= 0) then\n      res = .false.\n      return\n    end if\n    if (any (grid (i, :) == n)) then\n      res = .false.\n      return\n    end if\n    if (any (grid (:, j) == n)) then\n      res = .false.\n      return\n    end if\n    i_min = 1 + 3 * ((i - 1) / 3)\n    j_min = 1 + 3 * ((j - 1) / 3)\n    if (any (grid (i_min : i_min + 2, j_min : j_min + 2) == n)) then\n      res = .false.\n      return\n    end if\n    res = .true.\n  end function is_safe\n\n  subroutine pretty_print (grid)\n    implicit none\n    integer, dimension (9, 9), intent (in) :: grid\n    integer :: i\n    integer :: j\n    character (*), parameter :: bar = '+-----+-----+-----+'\n    character (*), parameter :: fmt = '(3 (\"|\", i0, 1x, i0, 1x, i0), \"|\")'\n    write (*, '(a)') bar\n    do j = 0, 6, 3\n      do i = j + 1, j + 3\n        write (*, fmt) grid (i, :)\n      end do\n      write (*, '(a)') bar\n    end do\n  end subroutine pretty_print\n\nend program sudoku\n\n\nOutput:\n\n+-----+-----+-----+\n|0 0 3|0 2 0|6 0 0|\n|9 0 0|3 0 5|0 0 1|\n|0 0 1|8 0 6|4 0 0|\n+-----+-----+-----+\n|0 0 8|1 0 2|9 0 0|\n|7 0 0|0 0 0|0 0 8|\n|0 0 6|7 0 8|2 0 0|\n+-----+-----+-----+\n|0 0 2|6 0 9|5 0 0|\n|8 0 0|2 0 3|0 0 9|\n|0 0 5|0 1 0|3 0 0|\n+-----+-----+-----+\n\n+-----+-----+-----+\n|4 8 3|9 2 1|6 5 7|\n|9 6 7|3 4 5|8 2 1|\n|2 5 1|8 7 6|4 9 3|\n+-----+-----+-----+\n|5 4 8|1 3 2|9 7 6|\n|7 2 9|5 6 4|1 3 8|\n|1 3 6|7 9 8|2 4 5|\n+-----+-----+-----+\n|3 7 2|6 8 9|5 1 4|\n|8 1 4|2 5 3|7 6 9|\n|6 9 5|4 1 7|3 8 2|\n\n +-----+-----+-----+\n\n", "explain": "This implementation uses a brute force method. The subroutine solve recursively checks valid entries using the rules defined in the function is_safe. When solve is called beyond the end of the sudoku, we know that all the currently entered values are valid. Then the result is displayed.\n\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\n// sudoku puzzle representation is an 81 character string \nvar puzzle = \"\" +\n    \"394  267 \" +\n    \"   3  4  \" +\n    \"5  69  2 \" +\n    \" 45   9  \" +\n    \"6       7\" +\n    \"  7   58 \" +\n    \" 1  67  8\" +\n    \"  9  8   \" +\n    \" 264  735\"\n\nfunc main() {\n    printGrid(\"puzzle:\", puzzle)\n    if s := solve(puzzle); s == \"\" {\n        fmt.Println(\"no solution\")\n    } else {\n        printGrid(\"solved:\", s)\n    }\n}\n\n// print grid (with title) from 81 character string\nfunc printGrid(title, s string) {\n    fmt.Println(title)\n    for r, i := 0, 0; r < 9; r, i = r+1, i+9 {\n        fmt.Printf(\"%c %c %c | %c %c %c | %c %c %c\\n\", s[i], s[i+1], s[i+2],\n            s[i+3], s[i+4], s[i+5], s[i+6], s[i+7], s[i+8])\n        if r == 2 || r == 5 {\n            fmt.Println(\"------+-------+------\")\n        }\n    }\n}   \n    \n// solve puzzle in 81 character string format.\n// if solved, result is 81 character string.\n// if not solved, result is the empty string.\nfunc solve(u string) string {\n    // construct an dlx object with 324 constraint columns.\n    // other than the number 324, this is not specific to sudoku.\n    d := newDlxObject(324)\n    // now add constraints that define sudoku rules.\n    for r, i := 0, 0; r < 9; r++ {\n        for c := 0; c < 9; c, i = c+1, i+1 {\n            b := r/3*3 + c/3\n            n := int(u[i] - '1')\n            if n >= 0 && n < 9 {\n                d.addRow([]int{i, 81 + r*9 + n, 162 + c*9 + n,\n                    243 + b*9 + n})\n            } else {\n                for n = 0; n < 9; n++ {\n                    d.addRow([]int{i, 81 + r*9 + n, 162 + c*9 + n,\n                        243 + b*9 + n})\n                }\n            }\n        }\n    }\n    // run dlx.  not sudoku specific.\n    d.search()\n    // extract the sudoku-specific 81 character result from the dlx solution.\n    return d.text()\n}\n\n// Knuth's data object\ntype x struct {\n    c          *y\n    u, d, l, r *x\n    // except x0 is not Knuth's.  it's pointer to first constraint in row,\n    // so that the sudoku string can be constructed from the dlx solution.\n    x0 *x\n}\n\n// Knuth's column object\ntype y struct {\n    x\n    s int // size\n    n int // name\n}\n\n// an object to hold the matrix and solution\ntype dlx struct {\n    ch []y  // all column headers\n    h  *y   // ch[0], the root node\n    o  []*x // solution\n}\n\n// constructor creates the column headers but no rows.\nfunc newDlxObject(nCols int) *dlx {\n    ch := make([]y, nCols+1)\n    h := &ch[0]\n    d := &dlx{ch, h, nil}\n    h.c = h\n    h.l = &ch[nCols].x\n    ch[nCols].r = &h.x\n    nh := ch[1:]\n    for i := range ch[1:] {\n        hi := &nh[i]\n        ix := &hi.x\n        hi.n = i\n        hi.c = hi\n        hi.u = ix\n        hi.d = ix\n        hi.l = &h.x\n        h.r = ix\n        h = hi\n    }\n    return d\n}   \n    \n// rows define constraints\nfunc (d *dlx) addRow(nr []int) {\n    if len(nr) == 0 {\n        return\n    }\n    r := make([]x, len(nr))\n    x0 := &r[0]\n    for x, j := range nr {\n        ch := &d.ch[j+1]\n        ch.s++\n        np := &r[x]\n        np.c = ch\n        np.u = ch.u\n        np.d = &ch.x\n        np.l = &r[(x+len(r)-1)%len(r)]\n        np.r = &r[(x+1)%len(r)]\n        np.u.d, np.d.u, np.l.r, np.r.l = np, np, np, np\n        np.x0 = x0\n    }\n}\n\n// extracts 81 character sudoku string\nfunc (d *dlx) text() string {\n    b := make([]byte, len(d.o))\n    for _, r := range d.o {\n        x0 := r.x0\n        b[x0.c.n] = byte(x0.r.c.n%9) + '1'\n    }\n    return string(b)\n}   \n    \n// the dlx algorithm \nfunc (d *dlx) search() bool {\n    h := d.h\n    j := h.r.c\n    if j == h {\n        return true\n    }\n    c := j \n    for minS := j.s; ; {\n        j = j.r.c\n        if j == h {\n            break\n        }\n        if j.s < minS {\n            c, minS = j, j.s\n        }\n    }\n\n    cover(c)\n    k := len(d.o)\n    d.o = append(d.o, nil)\n    for r := c.d; r != &c.x; r = r.d {\n        d.o[k] = r\n        for j := r.r; j != r; j = j.r {\n            cover(j.c)\n        }\n        if d.search() {\n            return true\n        }\n        r = d.o[k]\n        c = r.c\n        for j := r.l; j != r; j = j.l {\n            uncover(j.c)\n        }\n    }\n    d.o = d.o[:len(d.o)-1]\n    uncover(c)\n    return false\n}\n\nfunc cover(c *y) {\n    c.r.l, c.l.r = c.l, c.r\n    for i := c.d; i != &c.x; i = i.d {\n        for j := i.r; j != i; j = j.r {\n            j.d.u, j.u.d = j.u, j.d\n            j.c.s--\n        }\n    }\n}\n\nfunc uncover(c *y) {\n    for i := c.u; i != &c.x; i = i.u {\n        for j := i.l; j != i; j = j.l {\n            j.c.s++\n            j.d.u, j.u.d = j, j\n        }\n    }\n    c.r.l, c.l.r = &c.x, &c.x\n}\n\n\nOutput:\npuzzle:\n3 9 4 |     2 | 6 7  \n      | 3     | 4    \n5     | 6 9   |   2  \n------+-------+------\n  4 5 |       | 9    \n6     |       |     7\n    7 |       | 5 8  \n------+-------+------\n  1   |   6 7 |     8\n    9 |     8 |      \n  2 6 | 4     | 7 3 5\nsolved:\n3 9 4 | 8 5 2 | 6 7 1\n2 6 8 | 3 7 1 | 4 5 9\n5 7 1 | 6 9 4 | 8 2 3\n------+-------+------\n1 4 5 | 7 8 3 | 9 6 2\n6 8 2 | 9 4 5 | 3 1 7\n9 3 7 | 1 2 6 | 5 8 4\n------+-------+------\n4 1 3 | 5 6 7 | 2 9 8\n7 5 9 | 2 3 8 | 1 4 6\n8 2 6 | 4 1 9 | 7 3 5\n\n", "explain": "Solution using Knuth's DLX.  \nThis code follows his paper fairly closely.  \nInput to function solve is an 81 character string.  \nThis seems to be a conventional computer representation for Sudoku puzzles.\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Delphi", "code": "\n\ntype\n  TIntArray = array of Integer;\n\n  { TSudokuSolver }\n\n  TSudokuSolver = class\n  private\n    FGrid: TIntArray;\n\n    function CheckValidity(val: Integer; x: Integer; y: Integer): Boolean;\n    function ToString: string; reintroduce;\n    function PlaceNumber(pos: Integer): Boolean;\n  public\n    constructor Create(s: string);\n\n    procedure Solve;\n  end;\n\nimplementation\n\nuses\n  Dialogs;\n\n{ TSudokuSolver }\n\nfunction TSudokuSolver.CheckValidity(val: Integer; x: Integer; y: Integer\n  ): Boolean;\nvar\n  i: Integer;\n  j: Integer;\n  StartX: Integer;\n  StartY: Integer;\nbegin\n  for i := 0 to 8 do\n  begin\n    if (FGrid[y * 9 + i] = val) or\n       (FGrid[i * 9 + x] = val) then\n    begin\n      Result := False;\n      Exit;\n    end;\n  end;\n  StartX := (x div 3) * 3;\n  StartY := (y div 3) * 3;\n  for i := StartY to Pred(StartY + 3) do\n  begin\n    for j := StartX to Pred(StartX + 3) do\n    begin\n      if FGrid[i * 9 + j] = val then\n      begin\n        Result := False;\n        Exit;\n      end;\n    end;\n  end;\n  Result := True;\nend;\n\nfunction TSudokuSolver.ToString: string;\nvar\n  sb: string;\n  i: Integer;\n  j: Integer;\n  c: char;\nbegin\n  sb := '';\n  for i := 0 to 8 do\n  begin\n    for j := 0 to 8 do\n    begin\n      c := (IntToStr(FGrid[i * 9 + j]) + '0')[1];\n      sb := sb + c + ' ';\n      if (j = 2) or (j = 5) then sb := sb + '| ';\n    end;\n    sb := sb + #13#10;\n    if (i = 2) or (i = 5) then\n      sb := sb + '-----+-----+-----' + #13#10;\n  end;\n  Result := sb;\nend;\n\nfunction TSudokuSolver.PlaceNumber(pos: Integer): Boolean;\nvar\n  n: Integer;\nbegin\n  Result := False;\n  if Pos = 81 then\n  begin\n    Result := True;\n    Exit;\n  end;\n  if FGrid[pos] > 0 then\n  begin\n    Result := PlaceNumber(Succ(pos));\n    Exit;\n  end;\n  for n := 1 to 9 do\n  begin\n    if CheckValidity(n, pos mod 9, pos div 9) then\n    begin\n      FGrid[pos] := n;\n      Result := PlaceNumber(Succ(pos));\n      if not Result then\n        FGrid[pos] := 0;\n    end;\n  end;\nend;\n\nconstructor TSudokuSolver.Create(s: string);\nvar\n  lcv: Cardinal;\nbegin\n  SetLength(FGrid, 81);\n  for lcv := 0 to Pred(Length(s)) do\n    FGrid[lcv] := StrToInt(s[Succ(lcv)]);\nend;\n\nprocedure TSudokuSolver.Solve;\nbegin\n  if not PlaceNumber(0) then\n    ShowMessage('Unsolvable')\n  else\n    ShowMessage('Solved!');\n  end;\nend;\n\n\nvar\n  SudokuSolver: TSudokuSolver;\nbegin\n  SudokuSolver := TSudokuSolver.Create('850002400' +\n                                       '720000009' +\n                                       '004000000' +\n                                       '000107002' +\n                                       '305000900' +\n                                       '040000000' +\n                                       '000080070' +\n                                       '017000000' +\n                                       '000036040');\n  try\n    SudokuSolver.Solve;\n  finally\n    FreeAndNil(SudokuSolver);\n  end;\nend;\n\n", "explain": "Example taken from C++\nUsage:\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Ruby", "code": "\n\nWorks with: Ruby version 2.0+\ndef read_matrix(data)\n  lines = data.lines\n  9.times.collect { |i| 9.times.collect { |j| lines[i][j].to_i } }\nend\n\ndef permissible(matrix, i, j)\n  ok = [nil, *1..9]\n  check = ->(x,y) { ok[matrix[x][y]] = nil  if matrix[x][y].nonzero? }\n  # Same as another in the column isn't permissible...\n  9.times { |x| check[x, j] }\n  # Same as another in the row isn't permissible...\n  9.times { |y| check[i, y] }\n  # Same as another in the 3x3 block isn't permissible...\n  xary = [ *(x = (i / 3) * 3) .. x + 2 ]        #=> [0,1,2], [3,4,5] or [6,7,8]\n  yary = [ *(y = (j / 3) * 3) .. y + 2 ]\n  xary.product(yary).each { |x, y| check[x, y] }\n  # Gathering only permitted one\n  ok.compact\nend\n\ndef deep_copy_sudoku(matrix)\n  matrix.collect { |row| row.dup }\nend\n\ndef solve_sudoku(matrix)\n  loop do\n    options = []\n    9.times do |i|\n      9.times do |j|\n        next if matrix[i][j].nonzero?\n        p = permissible(matrix, i, j)\n        # If nothing is permissible, there is no solution at this level.\n        return if p.empty?              # return nil\n        options << [i, j, p]\n      end\n    end\n    # If the matrix is complete, we have a solution...\n    return matrix if options.empty?\n    \n    i, j, permissible = options.min_by { |x| x.last.length }\n    \n    # If there is an option with only one solution, set it and re-check permissibility\n    if permissible.length == 1\n      matrix[i][j] = permissible[0]\n      next\n    end\n    \n    # We have two or more choices. We need to search both...\n    permissible.each do |v|\n      mtmp = deep_copy_sudoku(matrix)\n      mtmp[i][j] = v\n      ret = solve_sudoku(mtmp)\n      return ret if ret\n    end\n    \n    # We did an exhaustive search on this branch and nothing worked out.\n    return\n  end\nend\n\ndef print_matrix(matrix)\n  puts \"Impossible\" or return  unless matrix\n  \n  border = \"+-----+-----+-----+\"\n  9.times do |i|\n    puts border if i%3 == 0\n    9.times do |j|\n      print j%3 == 0 ? \"|\" : \" \"\n      print matrix[i][j] == 0 ? \".\" : matrix[i][j]\n    end\n    puts \"|\"\n  end\n  puts border\nend\n\ndata = <<EOS\n394__267_\n___3__4__\n5__69__2_\n_45___9__\n6_______7\n__7___58_\n_1__67__8\n__9__8___\n_264__735\nEOS\n\nmatrix = read_matrix(data)\nprint_matrix(matrix)\nputs\nprint_matrix(solve_sudoku(matrix))\n\n\nOutput:\n+-----+-----+-----+\n|3 9 4|. . 2|6 7 .|\n|. . .|3 . .|4 . .|\n|5 . .|6 9 .|. 2 .|\n+-----+-----+-----+\n|. 4 5|. . .|9 . .|\n|6 . .|. . .|. . 7|\n|. . 7|. . .|5 8 .|\n+-----+-----+-----+\n|. 1 .|. 6 7|. . 8|\n|. . 9|. . 8|. . .|\n|. 2 6|4 . .|7 3 5|\n+-----+-----+-----+\n\n+-----+-----+-----+\n|3 9 4|8 5 2|6 7 1|\n|2 6 8|3 7 1|4 5 9|\n|5 7 1|6 9 4|8 2 3|\n+-----+-----+-----+\n|1 4 5|7 8 3|9 6 2|\n|6 8 2|9 4 5|3 1 7|\n|9 3 7|1 2 6|5 8 4|\n+-----+-----+-----+\n|4 1 3|5 6 7|2 9 8|\n|7 5 9|2 3 8|1 4 6|\n|8 2 6|4 1 9|7 3 5|\n+-----+-----+-----+\n", "explain": "Example of a back-tracking solver, from wp:Algorithmics of sudoku\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Rust", "code": "\nTranslation of: Ada\ntype Sudoku = [u8; 81];\n\nfn is_valid(val: u8, x: usize, y: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (0..9).all(|i| sudoku_ar[y * 9 + i] != val && sudoku_ar[i * 9 + x] != val) && {\n        let (start_x, start_y) = ((x / 3) * 3, (y / 3) * 3);\n        (start_y..start_y + 3).all(|i| (start_x..start_x + 3).all(|j| sudoku_ar[i * 9 + j] != val))\n    }\n}\n\nfn place_number(pos: usize, sudoku_ar: &mut Sudoku) -> bool {\n    (pos..81).find(|&p| sudoku_ar[p] == 0).map_or(true, |pos| {\n        let (x, y) = (pos % 9, pos / 9);\n        for n in 1..10 {\n            if is_valid(n, x, y, sudoku_ar) {\n                sudoku_ar[pos] = n;\n                if place_number(pos + 1, sudoku_ar) {\n                    return true;\n                }\n                sudoku_ar[pos] = 0;\n            }\n        }\n        false\n    })\n}\n\nfn pretty_print(sudoku_ar: Sudoku) {\n    let line_sep = \"------+-------+------\";\n    println!(\"{}\", line_sep);\n    for (i, e) in sudoku_ar.iter().enumerate() {\n        print!(\"{} \", e);\n        if (i + 1) % 3 == 0 && (i + 1) % 9 != 0 {\n            print!(\"| \");\n        }\n        if (i + 1) % 9 == 0 {\n            println!(\" \");\n        }\n        if (i + 1) % 27 == 0 {\n            println!(\"{}\", line_sep);\n        }\n    }\n}\n\nfn solve(sudoku_ar: &mut Sudoku) -> bool {\n    place_number(0, sudoku_ar)\n}\n\nfn main() {\n    let mut sudoku_ar: Sudoku = [\n        8, 5, 0, 0, 0, 2, 4, 0, 0,\n        7, 2, 0, 0, 0, 0, 0, 0, 9,\n        0, 0, 4, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 7, 0, 0, 2,\n        3, 0, 5, 0, 0, 0, 9, 0, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 0, 0, 7, 0,\n        0, 1, 7, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 3, 6, 0, 4, 0\n    ];\n    if solve(&mut sudoku_ar) {\n        pretty_print(sudoku_ar);\n    } else {\n        println!(\"Unsolvable\");\n    }\n}\n\n\nOutput:\n------+-------+------\n8 5 9 | 6 1 2 | 4 3 7  \n7 2 3 | 8 5 4 | 1 6 9  \n1 6 4 | 3 7 9 | 5 2 8  \n------+-------+------\n9 8 6 | 1 4 7 | 3 5 2  \n3 7 5 | 2 6 8 | 9 1 4  \n2 4 1 | 5 9 3 | 7 8 6  \n------+-------+------\n4 3 2 | 9 8 1 | 6 7 5  \n6 1 7 | 4 2 5 | 8 9 3  \n5 9 8 | 7 3 6 | 2 4 1  \n------+-------+------\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Swift", "code": "\nTranslation of: Java\nimport Foundation\n\ntypealias SodukuPuzzle = [[Int]]\n\nclass Soduku {\n    let mBoardSize:Int!\n    let mBoxSize:Int!\n    var mBoard:SodukuPuzzle!\n    var mRowSubset:[[Bool]]!\n    var mColSubset:[[Bool]]!\n    var mBoxSubset:[[Bool]]!\n    \n    init(board:SodukuPuzzle) {\n        mBoard = board\n        mBoardSize = board.count\n        mBoxSize = Int(sqrt(Double(mBoardSize)))\n        mRowSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mColSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        mBoxSubset = [[Bool]](count: mBoardSize, repeatedValue: [Bool](count: mBoardSize, repeatedValue: false))\n        initSubsets()\n    }\n    \n    func computeBoxNo(i:Int, _ j:Int) -> Int {\n        let boxRow = i / mBoxSize\n        let boxCol = j / mBoxSize\n        \n        return boxRow * mBoxSize + boxCol\n    }\n    \n    func initSubsets() {\n        for i in 0..<mBoard.count {\n            for j in 0..<mBoard.count {\n                let value = mBoard[i][j]\n                \n                if value != 0 {\n                    setSubsetValue(i, j, value, true);\n                }\n            }\n        }\n    }\n    \n    func isValid(i:Int, _ j:Int, var _ val:Int) -> Bool {\n        val--\n        let isPresent = mRowSubset[i][val] || mColSubset[j][val] || mBoxSubset[computeBoxNo(i, j)][val]\n        return !isPresent\n    }\n    \n    func printBoard() {\n        for i in 0..<mBoardSize {\n            if i % mBoxSize == 0 {\n                println(\" -----------------------\")\n            }\n            \n            for j in 0..<mBoardSize {\n                if j % mBoxSize == 0 {\n                    print(\"| \")\n                }\n                \n                print(mBoard[i][j] != 0 ? String(mBoard[i][j]) : \" \")\n                print(\" \")\n            }\n            \n            println(\"|\")\n        }\n        \n        println(\" -----------------------\")\n    }\n    \n    func setSubsetValue(i:Int, _ j:Int, _ value:Int, _ present:Bool) {\n        mRowSubset[i][value - 1] = present\n        mColSubset[j][value - 1] = present\n        mBoxSubset[computeBoxNo(i, j)][value - 1] = present\n    }\n    \n    func solve() {\n        solve(0, 0)\n    }\n    \n    func solve(var i:Int, var _ j:Int) -> Bool {\n        if i == mBoardSize {\n            i = 0\n            j++\n            if j == mBoardSize {\n                return true\n            }\n        }\n        \n        if mBoard[i][j] != 0 {\n            return solve(i + 1, j)\n        }\n        \n        for value in 1...mBoardSize {\n            if isValid(i, j, value) {\n                mBoard[i][j] = value\n                setSubsetValue(i, j, value, true)\n                \n                if solve(i + 1, j) {\n                    return true\n                }\n                \n                setSubsetValue(i, j, value, false)\n            }\n        }\n        \n        mBoard[i][j] = 0\n        return false\n    }\n}\n\nlet board = [\n    [4, 0, 0, 0, 0, 0, 0, 6, 0],\n    [5, 0, 0, 0, 8, 0, 9, 0, 0],\n    [3, 0, 0, 0, 0, 1, 0, 0, 0],\n    [0, 2, 0, 7, 0, 0, 0, 0, 1],\n    [0, 9, 0, 0, 0, 0, 0, 4, 0],\n    [8, 0, 0, 0, 0, 3, 0, 5, 0],\n    [0, 0, 0, 2, 0, 0, 0, 0, 7],\n    [0, 0, 6, 0, 5, 0, 0, 0, 8],\n    [0, 1, 0, 0, 0, 0, 0, 0, 6]\n]\n\nlet puzzle = Soduku(board: board)\npuzzle.solve()\npuzzle.printBoard()\n\n\nOutput:\n -----------------------\n| 4 8 2 | 9 7 5 | 1 6 3 |\n| 5 6 1 | 3 8 2 | 9 7 4 |\n| 3 7 9 | 6 4 1 | 8 2 5 |\n -----------------------\n| 6 2 5 | 7 9 4 | 3 8 1 |\n| 1 9 3 | 5 6 8 | 7 4 2 |\n| 8 4 7 | 1 2 3 | 6 5 9 |\n -----------------------\n| 9 5 8 | 2 1 6 | 4 3 7 |\n| 7 3 6 | 4 5 9 | 2 1 8 |\n| 2 1 4 | 8 3 7 | 5 9 6 |\n -----------------------\n\nWorks with: Swift 3\nfunc solving(board: [[Int]]) -> [[Int]] {\n\tvar board = board\n\tvar isSolved = false\n\twhile !isSolved {\n\t\tfor x in 0 ..< 9  {\n\t\t\tfor y in 0 ..< 9 {\n\t\t\t\tif board[x][y] == 0 {\n\t\t\t\t\tlet known = Set(board.map { $0[y] } + board[x] + subgrid(board, pos: (x, y)))\n\t\t\t\t\tlet possible = Set(Array(1...9)).subtracting(known)\n\t\t\t\t\tif possible.count == 1  {\n\t\t\t\t\t\tboard[x][y] = possible.first!\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t\tisSolved = 45 == board[x].reduce(0, +)\n\t\t}\n\t}\n\treturn board\n}\n\nfunc subgrid(_ board: [[Int]], pos: (Int, Int)) -> [Int] {\n\tvar r = [Int]()\n\tvar (x, y) = pos\n\tx = x / 3 * 3\n\ty = y / 3 * 3\n\tfor i in x ..< x + 3 {\n\t\tfor j in y ..< y + 3 {\n\t\t\tr.append(board[i][j])\n\t\t}\n\t}\n\treturn r\n}\n\nfunc print(_ board: [[Int]]) {\n\tfor i in board.indices {\n\t\tif i % 9 == 0 {\n\t\t\tprint(\" -------------------\")\n\t\t}\n\t\tfor j in board.indices {\n\t\t\tif j % board.count == 0 {\n\t\t\t\tprint(\"| \", terminator: \"\")\n\t\t\t}\n\t\t\tlet digit = board[i][j]\n\t\t\tprint(digit != 0 ? digit : \" \", terminator: \"\")\n\t\t\tprint(\" \", terminator: \"\")\n\t\t}\n\t\tprint(\"|\")\n\t}\n\tprint(\" -------------------\")\n}\n\nlet puzzle = [\n\t[0,2,0,4,5,0,7,0,9],\n\t[0,0,0,1,0,9,0,3,0],\n\t[0,0,8,0,0,0,1,0,4],\n\t[0,4,0,0,6,1,0,7,0],\n\t[5,0,6,0,3,0,0,1,0],\n\t[0,3,0,0,0,2,0,9,0],\n\t[3,0,4,0,7,5,0,6,8],\n\t[0,9,0,0,1,0,3,0,7],\n\t[0,0,2,0,0,3,0,0,1]\n]\n\nprint(solving(board: puzzle))\n\n\nOutput:\n -------------------\n| 1 2 3 4 5 6 7 8 9 |\n| 4 5 7 1 8 9 2 3 6 |\n| 9 6 8 3 2 7 1 5 4 |\n| 2 4 9 5 6 1 8 7 3 |\n| 5 7 6 9 3 8 4 1 2 |\n| 8 3 1 7 4 2 6 9 5 |\n| 3 1 4 2 7 5 9 6 8 |\n| 6 9 5 8 1 4 3 2 7 |\n| 7 8 2 6 9 3 5 4 1 |\n -------------------\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Ada", "code": "\nTranslation of: C++\nwith Ada.Text_IO;\n\nprocedure Sudoku is\n   type sudoku_ar_t is array ( integer range 0..80 ) of integer range 0..9;\n   FINISH_EXCEPTION : exception;\n\n   procedure prettyprint(sudoku_ar: sudoku_ar_t);\n   function checkValidity( val : integer; x : integer; y : integer;  sudoku_ar: in  sudoku_ar_t) return Boolean;\n   procedure placeNumber(pos: Integer; sudoku_ar: in out sudoku_ar_t);\n   procedure solve(sudoku_ar: in out sudoku_ar_t);\n\n\n   function checkValidity( val : integer; x : integer; y : integer;  sudoku_ar: in  sudoku_ar_t) return Boolean\n   is\n   begin\n      for i in 0..8 loop\n\n         if ( sudoku_ar( y * 9 + i ) = val or sudoku_ar( i * 9 + x ) = val ) then\n            return False;\n         end if;\n      end loop;\n\n      declare\n         startX : constant integer := ( x / 3 ) * 3;\n         startY : constant integer := ( y / 3 ) * 3;\n      begin\n         for i in startY..startY+2 loop\n            for j in startX..startX+2 loop\n               if ( sudoku_ar( i * 9 +j ) = val ) then\n                  return False;\n               end if;\n            end loop;\n         end loop;\n         return True;\n      end;\n   end checkValidity;\n\n\n\n   procedure placeNumber(pos: Integer; sudoku_ar: in out sudoku_ar_t)\n   is\n   begin\n      if ( pos = 81 ) then\n         raise FINISH_EXCEPTION;\n      end if;\n      if (  sudoku_ar(pos) > 0 ) then\n         placeNumber(pos+1, sudoku_ar);\n         return;\n      end if;\n      for n in 1..9 loop\n         if( checkValidity( n,  pos mod 9, pos / 9 , sudoku_ar ) ) then\n            sudoku_ar(pos) := n;\n            placeNumber(pos + 1, sudoku_ar );\n            sudoku_ar(pos) := 0;\n         end if;\n      end loop;\n   end placeNumber;\n\n\n   procedure solve(sudoku_ar: in out sudoku_ar_t)\n   is\n   begin\n      placeNumber( 0, sudoku_ar );\n      Ada.Text_IO.Put_Line(\"Unresolvable\u00a0!\");\n   exception\n      when FINISH_EXCEPTION =>\n         Ada.Text_IO.Put_Line(\"Finished\u00a0!\");\n         prettyprint(sudoku_ar);\n   end solve;\n\n\n\n\n   procedure prettyprint(sudoku_ar: sudoku_ar_t)\n   is\n      line_sep   : constant String  := \"------+------+------\";\n   begin\n      for i in sudoku_ar'Range loop\n         Ada.Text_IO.Put(sudoku_ar(i)'Image);\n         if (i+1) mod 3 = 0 and not((i+1) mod 9 = 0) then\n            Ada.Text_IO.Put(\"|\");\n         end if;\n         if (i+1) mod 9 = 0 then\n            Ada.Text_IO.Put_Line(\"\");\n         end if;\n         if (i+1) mod 27 = 0 then\n            Ada.Text_IO.Put_Line(line_sep);\n         end if;\n      end loop;\n   end prettyprint;\n\n   \n   sudoku_ar : sudoku_ar_t :=\n     (\n      8,5,0,0,0,2,4,0,0,\n      7,2,0,0,0,0,0,0,9,\n      0,0,4,0,0,0,0,0,0,\n      0,0,0,1,0,7,0,0,2,\n      3,0,5,0,0,0,9,0,0,\n      0,4,0,0,0,0,0,0,0,\n      0,0,0,0,8,0,0,7,0,\n      0,1,7,0,0,0,0,0,0,\n      0,0,0,0,3,6,0,4,0\n     );\n\nbegin\n   solve( sudoku_ar );\nend Sudoku;\n\n\nOutput:\nFinished\u00a0!\n 8 5 9| 6 1 2| 4 3 7\n 7 2 3| 8 5 4| 1 6 9\n 1 6 4| 3 7 9| 5 2 8\n------+------+------\n 9 8 6| 1 4 7| 3 5 2\n 3 7 5| 2 6 8| 9 1 4\n 2 4 1| 5 9 3| 7 8 6\n------+------+------\n 4 3 2| 9 8 1| 6 7 5\n 6 1 7| 4 2 5| 8 9 3\n 5 9 8| 7 3 6| 2 4 1\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Julia", "code": "\nfunction check(i, j)\n    id, im = div(i, 9), mod(i, 9)\n    jd, jm = div(j, 9), mod(j, 9)\n\n    jd == id && return true\n    jm == im && return true\n\n    div(id, 3) == div(jd, 3) &&\n    div(jm, 3) == div(im, 3)\nend\n\nconst lookup = zeros(Bool, 81, 81)\n\nfor i in 1:81\n    for j in 1:81\n        lookup[i,j] = check(i-1, j-1)\n    end\nend\n\nfunction solve_sudoku(callback::Function, grid::Array{Int64})\n    (function solve()\n        for i in 1:81\n            if grid[i] == 0\n                t = Dict{Int64, Nothing}()\n\n                for j in 1:81\n                    if lookup[i,j]\n                        t[grid[j]] = nothing\n                    end\n                end\n\n                for k in 1:9\n                    if !haskey(t, k)\n                        grid[i] = k\n                        solve()\n                    end\n                end\n\n                grid[i] = 0\n                return\n            end\n        end\n\n        callback(grid)\n    end)()\nend\n\nfunction display(grid)\n    for i in 1:length(grid)\n        print(grid[i], \" \")\n        i %  3 == 0 && print(\" \")\n        i %  9 == 0 && print(\"\\n\")\n        i % 27 == 0 && print(\"\\n\")\n    end\nend\n\ngrid = Int64[5, 3, 0, 0, 2, 4, 7, 0, 0,\n             0, 0, 2, 0, 0, 0, 8, 0, 0,\n             1, 0, 0, 7, 0, 3, 9, 0, 2,\n             0, 0, 8, 0, 7, 2, 0, 4, 9,\n             0, 2, 0, 9, 8, 0, 0, 7, 0,\n             7, 9, 0, 0, 0, 0, 0, 8, 0,\n             0, 0, 0, 0, 3, 0, 5, 0, 6,\n             9, 6, 0, 0, 1, 0, 3, 0, 0,\n             0, 5, 0, 6, 9, 0, 0, 1, 0]\n\nsolve_sudoku(display, grid)\n\n\nOutput:\n5 3 9  8 2 4  7 6 1  \n6 7 2  1 5 9  8 3 4  \n1 8 4  7 6 3  9 5 2  \n\n3 1 8  5 7 2  6 4 9  \n4 2 5  9 8 6  1 7 3  \n7 9 6  3 4 1  2 8 5  \n\n8 4 1  2 3 7  5 9 6  \n9 6 7  4 1 5  3 2 8  \n2 5 3  6 9 8  4 1 7  \n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "SAS", "code": "\n\n/* define SAS data set */\ndata Indata;\n   input C1-C9;\n   datalines;\n. . 5 . . 7 . . 1\n. 7 . . 9 . . 3 .\n. . . 6 . . . . .\n. . 3 . . 1 . . 5\n. 9 . . 8 . . 2 .\n1 . . 2 . . 4 . .\n. . 2 . . 6 . . 9\n. . . . 4 . . 8 .\n8 . . 1 . . 5 . .\n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare variables */\n   set ROWS = 1..9;\n   set COLS = ROWS;\n   var X {ROWS, COLS} >= 1 <= 9 integer;\n\n   /* declare nine row constraints */\n   con RowCon {i in ROWS}:\n      alldiff({j in COLS} X[i,j]);\n\n   /* declare nine column constraints */\n   con ColCon {j in COLS}:\n      alldiff({i in ROWS} X[i,j]);\n\n   /* declare nine 3x3 block constraints */\n   con BlockCon {s in 0..2, t in 0..2}:\n      alldiff({i in 3*s+1..3*s+3, j in 3*t+1..3*t+3} X[i,j]);\n\n   /* fix variables to cell values */\n   /* X[i,j] = c[i,j] if c[i,j] is not missing */\n   num c {ROWS, COLS};\n   read data indata into [_N_] {j in COLS} <c[_N_,j]=col('C'||j)>;\n   for {i in ROWS, j in COLS: c[i,j] ne .}\n      fix X[i,j] = c[i,j];\n\n   /* call CLP solver */\n   solve;\n\n   /* print solution */\n   print X;\nquit;\n\n\nX \n  1 2 3 4 5 6 7 8 9 \n1 9 8 5 3 2 7 6 4 1 \n2 6 7 1 5 9 4 2 3 8 \n3 3 2 4 6 1 8 9 5 7 \n4 2 4 3 7 6 1 8 9 5 \n5 5 9 7 4 8 3 1 2 6 \n6 1 6 8 2 5 9 4 7 3 \n7 4 5 2 8 3 6 7 1 9 \n8 7 1 6 9 4 5 3 8 2 \n9 8 3 9 1 7 2 5 6 4 \n\n", "explain": "Use CLP solver in SAS/OR:\nOutput:\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Kotlin", "code": "\nTranslation of: C++\n// version 1.2.10\n\nclass Sudoku(rows: List<String>) {\n    private val grid = IntArray(81)\n    private var solved = false\n\n    init {\n        require(rows.size == 9 && rows.all { it.length == 9 }) {\n            \"Grid must be 9 x 9\"\n        }\n        for (i in 0..8) {\n            for (j in 0..8 ) grid[9 * i + j] = rows[i][j] - '0'\n        }\n    }\n\n    fun solve() {\n        println(\"Starting grid:\\n\\n$this\")\n        placeNumber(0)\n        println(if (solved) \"Solution:\\n\\n$this\" else \"Unsolvable!\")\n    }\n\n    private fun placeNumber(pos: Int) {\n        if (solved) return\n        if (pos == 81) {\n            solved = true\n            return\n        }\n        if (grid[pos] > 0) {\n            placeNumber(pos + 1)\n            return\n        }\n        for (n in 1..9) {\n            if (checkValidity(n, pos % 9, pos / 9)) {\n                grid[pos] = n\n                placeNumber(pos + 1)\n                if (solved) return\n                grid[pos] = 0\n            }\n        }\n    }\n\n    private fun checkValidity(v: Int, x: Int, y: Int): Boolean {\n        for (i in 0..8) {\n            if (grid[y * 9 + i] == v || grid[i * 9 + x] == v) return false\n        }\n        val startX = (x / 3) * 3\n        val startY = (y / 3) * 3\n        for (i in startY until startY + 3) {\n            for (j in startX until startX + 3) {\n                if (grid[i * 9 + j] == v) return false\n            }\n        }\n        return true\n    }\n\n    override fun toString(): String {\n        val sb = StringBuilder()\n        for (i in 0..8) {\n            for (j in 0..8) {\n                sb.append(grid[i * 9 + j])\n                sb.append(\" \")\n                if (j == 2 || j == 5) sb.append(\"| \")\n            }\n            sb.append(\"\\n\")\n            if (i == 2 || i == 5) sb.append(\"------+-------+------\\n\")\n        }\n        return sb.toString()\n    }\n}\n\nfun main(args: Array<String>) {\n    val rows = listOf(\n        \"850002400\",\n        \"720000009\",\n        \"004000000\",\n        \"000107002\",\n        \"305000900\",\n        \"040000000\",\n        \"000080070\",\n        \"017000000\",\n        \"000036040\"\n    )\n    Sudoku(rows).solve()\n}\n\n\nOutput:\nStarting grid:\n\n8 5 0 | 0 0 2 | 4 0 0 \n7 2 0 | 0 0 0 | 0 0 9 \n0 0 4 | 0 0 0 | 0 0 0 \n------+-------+------\n0 0 0 | 1 0 7 | 0 0 2 \n3 0 5 | 0 0 0 | 9 0 0 \n0 4 0 | 0 0 0 | 0 0 0 \n------+-------+------\n0 0 0 | 0 8 0 | 0 7 0 \n0 1 7 | 0 0 0 | 0 0 0 \n0 0 0 | 0 3 6 | 0 4 0 \n\nSolution:\n\n8 5 9 | 6 1 2 | 4 3 7 \n7 2 3 | 8 5 4 | 1 6 9 \n1 6 4 | 3 7 9 | 5 2 8 \n------+-------+------\n9 8 6 | 1 4 7 | 3 5 2 \n3 7 5 | 2 6 8 | 9 1 4 \n2 4 1 | 5 9 3 | 7 8 6 \n------+-------+------\n4 3 2 | 9 8 1 | 6 7 5 \n6 1 7 | 4 2 5 | 8 9 3 \n5 9 8 | 7 3 6 | 2 4 1 \n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Perl", "code": "\n#!/usr/bin/perl\nuse integer;\nuse strict;\n\nmy @A = qw(\n    5 3 0  0 2 4  7 0 0 \n    0 0 2  0 0 0  8 0 0 \n    1 0 0  7 0 3  9 0 2 \n\n    0 0 8  0 7 2  0 4 9 \n    0 2 0  9 8 0  0 7 0 \n    7 9 0  0 0 0  0 8 0 \n\n    0 0 0  0 3 0  5 0 6 \n    9 6 0  0 1 0  3 0 0 \n    0 5 0  6 9 0  0 1 0\n);\n\nsub solve {\n    my $i;\n    foreach $i ( 0 .. 80 ) {\n\tnext if $A[$i];\n\tmy %t = map {\n\t\t$_ / 9 == $i / 9 ||\n\t\t$_ % 9 == $i % 9 ||\n\t\t$_ / 27 == $i / 27 && $_ % 9 / 3 == $i\u00a0% 9 / 3\n\t\t? $A[$_] : 0,\n\t\t1;\n\t    } 0 .. 80;\n\tsolve( $A[$i] = $_ ) for grep !$t{$_}, 1 .. 9;\n\treturn $A[$i] = 0;\n    }\n    $i = 0;\n    foreach (@A) {\n\tprint \"-----+-----+-----\\n\" if !($i%27) && $i;\n\tprint !($i%9) ? '': $i%3 ? ' ' : '|', $_;\n\tprint \"\\n\" unless ++$i%9;\n    }\n}\nsolve();\n\n\nOutput:\n5 3 9|8 2 4|7 6 1\n6 7 2|1 5 9|8 3 4\n1 8 4|7 6 3|9 5 2\n-----+-----+-----\n3 1 8|5 7 2|6 4 9\n4 2 5|9 8 6|1 7 3\n7 9 6|3 4 1|2 8 5\n-----+-----+-----\n8 4 1|2 3 7|5 9 6\n9 6 7|4 1 5|3 2 8\n2 5 3|6 9 8|4 1 7\n\n", "explain": ""}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Prolog", "code": "\n:- use_module(library(clpfd)).\n \nsudoku(Rows) :-\n        length(Rows, 9), maplist(length_(9), Rows),\n        append(Rows, Vs), Vs ins 1..9,\n        maplist(all_distinct, Rows),\n        transpose(Rows, Columns), maplist(all_distinct, Columns),\n        Rows = [A,B,C,D,E,F,G,H,I],\n        blocks(A, B, C), blocks(D, E, F), blocks(G, H, I).\n \nlength_(L, Ls) :- length(Ls, L).\n \nblocks([], [], []).\nblocks([A,B,C|Bs1], [D,E,F|Bs2], [G,H,I|Bs3]) :-\n        all_distinct([A,B,C,D,E,F,G,H,I]),\n        blocks(Bs1, Bs2, Bs3).\n \nproblem(1, [[_,_,_,_,_,_,_,_,_],\n            [_,_,_,_,_,3,_,8,5],\n            [_,_,1,_,2,_,_,_,_],\n            [_,_,_,5,_,7,_,_,_],\n            [_,_,4,_,_,_,1,_,_],\n            [_,9,_,_,_,_,_,_,_],\n            [5,_,_,_,_,_,_,7,3],\n            [_,_,2,_,1,_,_,_,_],\n            [_,_,_,_,4,_,_,_,9]]).\n\nGNU Prolog version[edit]\nWorks with: GNU Prolog version 1.4.4\n:- initialization(main).\n\n\nsolve(Rows) :-\n    maplist(domain_1_9, Rows)\n  , different(Rows)\n  , transpose(Rows,Cols), different(Cols)\n  , blocks(Rows,Blocks) , different(Blocks)\n  , maplist(fd_labeling, Rows)\n  .\n\ndomain_1_9(Rows) :- fd_domain(Rows,1,9).\ndifferent(Rows)  :- maplist(fd_all_different, Rows).\n\nblocks(Rows,Blocks) :-\n    maplist(split3,Rows,Xs), transpose(Xs,Ys)\n  , concat(Ys,Zs), concat_map(split3,Zs,Blocks)\n  . % where\n    split3([X,Y,Z|L],[[X,Y,Z]|R]) :- split3(L,R).\n    split3([],[]).\n\n\n% utils/list\nconcat_map(F,Xs,Ys) :- call(F,Xs,Zs), maplist(concat,Zs,Ys).\n\nconcat([],[]).\nconcat([X|Xs],Ys) :- append(X,Zs,Ys), concat(Xs,Zs).\n\ntranspose([],[]).\ntranspose([[X]|Col], [[X|Row]]) :- transpose(Col,[Row]).\ntranspose([[X|Row]], [[X]|Col]) :- transpose([Row],Col).\ntranspose([[X|Row]|Xs], [[X|Col]|Ys]) :-\n    maplist(bind_head, Row, Ys, YX)\n  , maplist(bind_head, Col, Xs, XY)\n  , transpose(XY,YX)\n  . % where\n    bind_head(H,[H|T],T).\n    bind_head([],[],[]).\n\n\n% tests\ntest([ [_,_,3,_,_,_,_,_,_]\n     , [4,_,_,_,8,_,_,3,6]\n     , [_,_,8,_,_,_,1,_,_]\n     , [_,4,_,_,6,_,_,7,3]\n     , [_,_,_,9,_,_,_,_,_]\n     , [_,_,_,_,_,2,_,_,5]\n     , [_,_,4,_,7,_,_,6,8]\n     , [6,_,_,_,_,_,_,_,_]\n     , [7,_,_,6,_,_,5,_,_]\n     ]).\n\nmain :- test(T), solve(T), maplist(show,T), halt.\nshow(X) :- write(X), nl.\n\n\nOutput:\n[1,2,3,4,5,6,7,8,9]\n[4,5,7,1,8,9,2,3,6]\n[9,6,8,3,2,7,1,5,4]\n[2,4,9,5,6,1,8,7,3]\n[5,7,6,9,3,8,4,1,2]\n[8,3,1,7,4,2,6,9,5]\n[3,1,4,2,7,5,9,6,8]\n[6,9,5,8,1,4,3,2,7]\n[7,8,2,6,9,3,5,4,1]\n\n", "explain": "Runs in: time: 0.02 memory: 68352 (adapted for gprolog 1.3.1)\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Lua", "code": "\nwithout FFI, slow[edit]\n--9x9 sudoku solver in lua\n--based on a branch and bound solution\n--fields are not tried in plain order\n--but in a way to detect dead ends earlier\nconcat=table.concat\ninsert=table.insert\nconstraints = { }   --contains a table with 3 constraints for every field\n-- a contraint \"cons\" is a table containing all fields which must not have the same value\n-- a field \"f\" is an integer from 1 to 81\ncolumns = { }       --contains all column-constraints   variable \"c\"\nrows = { }          --contains all row-constraints      variable \"r\"\nblocks = { }        --contains all block-constraints    variable \"b\"\n\n--initialize all constraints\nfor f = 1, 81 do\n  constraints[f] = { }\nend\nall_constraints = { } --union of colums, rows and blocks\nfor i = 1, 9 do\n  columns[i] = {\n    unknown = 9, --number of fields not yet solved\n    unknowns = { } --fields not yet solved\n  }\n  insert(all_constraints, columns[i])\n  rows[i] = {\n    unknown = 9, -- see l.15\n    unknowns = { } -- see l.16\n  }\n  insert(all_constraints, rows[i])\n  blocks[i] = {\n    unknown = 9, --see l.15\n    unknowns = { } --see l.16\n  }\n  insert(all_constraints, blocks[i])\nend\nconstraints_by_unknown = { } --contraints sorted by their number of unknown fields\nfor i = 0, 9 do\n  constraints_by_unknown[i] = {\n    count = 0 --how many contraints are in here\n  }\nend\nfor r = 1, 9 do\n  for c = 1, 9 do\n    local f = (r - 1) * 9 + c\n    insert(rows[r], f)\n    insert(constraints[f], rows[r])\n    insert(columns[c], f)\n    insert(constraints[f], columns[c])\n  end\nend\nfor i = 1, 3 do\n  for j = 1, 3 do\n    local r = (i - 1) * 3 + j\n    for k = 1, 3 do\n      for l = 1, 3 do\n        local c = (k - 1) * 3 + l\n        local f = (r - 1) * 9 + c\n        local b = (i - 1) * 3 + k\n        insert(blocks[b], f)\n        insert(constraints[f], blocks[b])\n      end\n    end\n  end\nend\nworking = { } --save the read values in here\nfunction read() --read the values from stdin\n  local f = 1\n  local l = io.read(\"*a\")\n  for d in l:gmatch(\"(%d)\") do\n    local n = tonumber(d)\n    if n > 0 then\n      working[f] = n\n      for _,cons in pairs(constraints[f]) do\n        cons.unknown = cons.unknown - 1\n      end\n    else\n      for _,cons in pairs(constraints[f]) do\n        cons.unknowns[f] = f\n      end\n    end\n    f = f + 1\n  end\n  assert((f == 82), \"Wrong number of digits\")\nend\nread()\nfunction printer(t) --helper function for printing a 1-81 table \n  local pattern = {1,2,3,false,4,5,6,false,7,8,9} --place seperators for better readability\n  for _,r in pairs(pattern) do\n    if r then\n      local function p(c)\n        return c and t[(r - 1) * 9 + c] or \"|\" \n      end\n      local line={}\n      for k,v in pairs(pattern) do\n        line[k]=p(v)\n      end\n      print(concat(line))\n    else\n      print(\"---+---+---\")\n    end\n  end\nend\norder = { } --when to try a field\nfor _,cons in pairs(all_constraints) do --put all constraints in the corresponding constraints_by_unknown set\n  local level = constraints_by_unknown[cons.unknown]\n  level[cons] = cons\n  level.count = level.count + 1\nend\nfunction first(t) --helper function to get a value from a set\n  for k, v in pairs(t) do\n    if k == v then\n      return k\n    end\n  end\nend\nfunction establish_order() -- determine the sequence in which the fields are to be tried\n  local solved = constraints_by_unknown[0].count\n  while solved < 27 do --there 27 constraints\n  --contraints with no unknown fields are considered \"solved\"\n  --keep in mind the actual solving happens in function branch\n    local i = 1\n    while constraints_by_unknown[i].count == 0 do\n      i = i + 1\n      -- find a unsolved contraint with the least number of unsolved fields\n    end\n    local cons = first(constraints_by_unknown[i])\n    local f = first(cons.unknowns)\n    -- take one of its unknown fields and append it to \"order\"\n    insert(order, f)\n    for _,c in pairs(constraints[f]) do\n    --each constraint \"c\" of \"f\" is moved up one \"level\"\n    --delete \"f\" from the constraints unknown fields\n    --decrease unknown of \"c\"\n      c.unknowns[f] = nil\n      local level = constraints_by_unknown[c.unknown]\n      level[c] = nil\n      level.count = level.count - 1\n      c.unknown = c.unknown - 1\n      level = constraints_by_unknown[c.unknown]\n      level[c] = c\n      level.count = level.count + 1\n      constraints_by_unknown[c.unknown][c] = c\n    end\n    solved = constraints_by_unknown[0].count\n  end\nend\nestablish_order()\nmax = #order --how many fields are to be solved\nfunction bound(f,i)\n  for _,c in pairs(constraints[f]) do\n    for _,x in pairs(c) do\n      if i == working[x] then \n        return false --i is already used in fs column/row/block\n      end\n    end\n  end\n  return true\nend\nfunction branch(n)\n  local f = order[n] --recursively iterate over fields in order\n  if n > max then\n    return working --all fields solved without collision\n  else\n    for i = 1, 9 do --check all values\n      if bound(f, i) then --if there is no collision\n        working[f] = i\n        local res = branch(n + 1) --try next field\n        if res then\n          return res --all fields solved without collision\n        else\n          working[f] = nil --this lead to a dead end\n        end\n      else\n        working[f] = nil --reset field because of a collision\n      end\n    end\n    return false --this is a dead end\n  end\nend\nx = branch(1)\nif x then\n  return printer(x)\nend\n\n\n003 000 000\n400 080 036\n008 000 100\n\n040 060 073\n000 900 000\n000 002 005\n\n004 070 068\n600 000 000\n700 600 500\n\n\nOutput:\n123|456|789\n457|189|236\n968|327|154\n---+---+---\n249|561|873\n576|938|412\n831|742|695\n---+---+---\n314|275|968\n695|814|327\n782|693|541\n\n\nwith FFI, fast[edit]\n#!/usr/bin/env luajit\nffi=require\"ffi\"\nlocal printf=function(fmt, ...) io.write(string.format(fmt, ...)) end\nlocal band, bor, lshift, rshift=bit.band, bit.bor, bit.lshift, bit.rshift\nlocal function show(x)\n\tfor i=0,8 do\n\t\tif i%3==0 then print() end\n\t\tfor j=0,8 do\n\t\t\tprintf(j%3~=0 and \"%2d\" or \"%3d\", x[j+9*i])\n\t\tend\n\t\tprint()\n\tend\nend\nlocal function trycell(x, pos)\n\tlocal row=math.floor(pos/9)\n\tlocal col=pos%9\n\tlocal used=0\n\tif pos==81 then return true end\n\tif x[pos]~=0 then return trycell(x, pos+1) end\n\tfor i=0,8 do\n\t\tused=bor(used,lshift(1,x[i*9+col]-1))\n\tend\n\tfor j=0,8 do\n\t\tused=bor(used,lshift(1,x[row*9+j]-1))\n\tend\n\trow=math.floor(row/3)*3\n\tcol=math.floor(col/3)*3\n\tfor i=row,row+2 do\n\t\tfor j=col,col+2 do\n\t\t\tused=bor(used, lshift(1, x[i*9+j]-1))\n\t\tend\n\tend\n\tx[pos]=1\n\twhile x[pos]<=9 do\n\t\tif band(used,1)==0 and trycell(x, pos+1) then return true end\n\t\tused=rshift(used,1)\n\t\tx[pos]=x[pos]+1\n\tend\n\tx[pos]=0\n\treturn false\nend\nlocal function solve(str)\n\tlocal x=ffi.new(\"char[?]\", 81)\n\tstr=str:gsub(\"[%c%s]\",\"\")\n\tfor i=0,81 do\n\t\tx[i]=tonumber(str:sub(i+1, i+1)) or 0\n\tend\n\tif trycell(x, 0) then\n\t\tshow(x)\n\telse\n\t\tprint(\"no solution\")\n\tend\nend\n\ndo -- MAIN\n\tsolve([[\n\t\t5.. .7. ...\n\t\t6.. 195 ...\n\t\t.98 ... .6.\n\n\t\t8.. .6. ..3\n\t\t4.. 8.3 ..1\n\t\t7.. .2. ..6\n\n\t\t.6. ... 28.\n\t\t... 419 ..5\n\t\t... .8. .79\n\t\t]])\nend\n\n\nOutput:\n> time ./sudoku_fast.lua\n\n  5 3 4  6 7 8  9 1 2\n  6 7 2  1 9 5  3 4 8\n  1 9 8  3 4 2  5 6 7\n\n  8 5 9  7 6 1  4 2 3\n  4 2 6  8 5 3  7 9 1\n  7 1 3  9 2 4  8 5 6\n\n  9 6 1  5 3 7  2 8 4\n  2 8 7  4 1 9  6 3 5\n  3 4 5  2 8 6  1 7 9\n./sudoku_fast.lua  0,01s user 0,00s system 90% cpu 0,007 total\n\n", "explain": "Input:\nTime with luajit: 9.245s\nSpeed is about the speed of unoptimized C, half as fast as optimized C (C normal=0.007 C opt=0.004)\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Scala", "code": "\n\nWorks with: Scala version 2.9.1\nobject SudokuSolver extends App {\n\n  class Solver {\n\n    var solution = new Array[Int](81)   //listOfFields toArray\n\n    val fp2m: Int => Tuple2[Int,Int] = pos => Pair(pos/9+1,pos%9+1) //get row, col from array position\n    val setAll = (1 to 9) toSet //all possibilities\n\n    val arrayGroups = new Array[List[List[Int]]](81)\n    val sv: Int => Int = (row: Int) => (row-1)*9 //start value group row\n    val ev: Int => Int = (row: Int) => sv(row)+8 //end value group row\n    val fgc: (Int,Int) => Int = (i,col) => i*9+col-1 //get group col\n    val fgs: Int => (Int,Int) = p => Pair(p, p/(27)*3+p%9/3) //get group square box\n    for (pos <- 0 to 80) {\n      val (row,col) = fp2m(pos)\n      val gRow = (sv(row) to ev(row)).toList\n      val gCol = ((0 to 8) toList) map (fgc(_,col))\n      val gSquare = (0 to 80 toList) map fgs filter (_._2==(fgs(pos))._2) map (_._1)\n      arrayGroups(pos) = List(gRow,gCol,gSquare)\n    }\n    val listGroups = arrayGroups toList \n    \n    val fpv4s: (Int) => List[Int] = pos => {   //get possible values for solving\n      val setRow = (listGroups(pos)(0) map (solution(_))).toSet\n      val setCol = listGroups(pos)(1).map(solution(_)).toSet\n      val setSquare = listGroups(pos)(2).map(solution(_)).toSet\n      val setG = setRow++setCol++setSquare--Set(0)\n      val setPossible = setAll--setG\n      setPossible.toList.sortWith(_<_)\n    }\n    \n    \n    //solve the riddle: Nil ==> solution does not exist\n    def solve(listOfFields: List[Int]): List[Int] = {\n      solution = listOfFields toArray\n\n      def checkSol(uncheckedSol: List[Int]): List[Int] = {\n        if (uncheckedSol == Nil) return Nil\n        solution = uncheckedSol toArray\n        val check = (0 to 80).map(fpv4s(_)).filter(_.size>0)\n        if (check == Nil) return uncheckedSol\n        return Nil\n      }\n    \n      val f1: Int => Pair[Int,Int] = p => Pair(p,listOfFields(p))\n      val numFields = (0 to 80 toList) map f1 filter (_._2==0)\n      val iter = numFields map ((_: (Int,Int))._1)\n      var p_iter = 0\n\n      val first: () => Int = () => {\n        val ret = numFields match {\n          case Nil => -1\n          case _   => numFields(0)._1\n        }\n        ret\n      }\n  \n      val last: () => Int = () => {\n        val ret = numFields match {\n          case Nil => -1\n          case _   => numFields(numFields.size-1)._1\n        }\n        ret\n      }\n  \n      val hasPrev: () => Boolean = () => p_iter > 0\n      val prev: () => Int = () => {p_iter -= 1; iter(p_iter)}\n      val hasNext: () => Boolean = () => p_iter < iter.size-1\n      val next: () => Int = () => {p_iter += 1; iter(p_iter)}\n      val fixed: Int => Boolean = pos => listOfFields(pos) != 0  \n      val possiArray = new Array[List[Int]](numFields.size)\n      val firstUF = first() //first unfixed\n      if (firstUF < 0) return checkSol(solution.toList) //that is it!\n      var pif = iter(p_iter) //pos in fields\n      val lastUF = last() //last unfixed\n      val (row,col) = fp2m(pif)\n      possiArray(p_iter) = fpv4s(pif).toList.sortWith(_<_)\n\n      while(pif <= lastUF) {\n        val (row,col) = fp2m(pif)\n        if (possiArray(p_iter) == null) possiArray(p_iter) = fpv4s(pif).toList.sortWith(_<_)\n        val possis = possiArray(p_iter)\n        if (possis.isEmpty) {\n          if (hasPrev()) {\n            possiArray(p_iter) = null\n            solution(pif) = 0\n            pif = prev()\n          } else {\n            return Nil\n          }\n        } else {\n          solution(pif) = possis(0)\n          possiArray(p_iter) = (possis.toSet - possis(0)).toList.sortWith(_<_)\n          if (hasNext()) {\n            pif = next()\n          } else {\n            return checkSol(solution.toList)\n          }\n        }\n      }\n      checkSol(solution.toList)\n    }\n  }  \n\n  val f2Str: List[Int] => String = fields => {\n    val sepLine = \"+---+---+---+\"\n    val sepPoints = Set(2,5,8)\n    val fs: (Int, Int) => String = (i, v) => v.toString.replace(\"0\",\" \")+(if (sepPoints.contains(i%9)) \"|\" else \"\")\n    sepLine+\"\\n\"+(0 to fields.size-1).map(i => (if (i%9==0) \"|\" else \"\")+fs(i,fields(i))+(if (i%9==8) if (sepPoints.contains(i/9)) \"\\n\"+sepLine+\"\\n\" else \"\\n\" else \"\")).foldRight(\"\")(_+_)\n  }\n  \n  val solver = new Solver()\n\n  val riddle = List(3,9,4,0,0,2,6,7,0,\n                    0,0,0,3,0,0,4,0,0,\n                    5,0,0,6,9,0,0,2,0,\n                    0,4,5,0,0,0,9,0,0,\n                    6,0,0,0,0,0,0,0,7,\n                    0,0,7,0,0,0,5,8,0,\n                    0,1,0,0,6,7,0,0,8,\n                    0,0,9,0,0,8,0,0,0,\n                    0,2,6,4,0,0,7,3,5)\n\n  println(\"riddle:\")\n  println(f2Str(riddle))\n  var solution = solver.solve(riddle)\n\n  println(\"solution:\")\n  println(solution match {case Nil => \"no solution!!!\" case _ => f2Str(solution)})\n \n}\n\n\nOutput:\nriddle:\n+---+---+---+\n|394|  2|67 |\n|   |3  |4  |\n|5  |69 | 2 |\n+---+---+---+\n| 45|   |9  |\n|6  |   |  7|\n|  7|   |58 |\n+---+---+---+\n| 1 | 67|  8|\n|  9|  8|   |\n| 26|4  |735|\n+---+---+---+\n\nsolution:\n+---+---+---+\n|394|852|671|\n|268|371|459|\n|571|694|823|\n+---+---+---+\n|145|783|962|\n|682|945|317|\n|937|126|584|\n+---+---+---+\n|413|567|298|\n|759|238|146|\n|826|419|735|\n+---+---+---+\n\nWorks with: Scala version 2.9.1\nobject SudokuSolver extends App {\n\n  object Solver {\n    var solution = new Array[Int](81)\n\n    val fap: (Int, Int) => Int = (row, col) => (row)*9+col //function array position\n\n    def solve(listOfFields: List[Int]): List[Int] = {\n      solution = listOfFields toArray\n      \n      val mRowSubset = new Array[Boolean](81)\n      val mColSubset = new Array[Boolean](81)\n      val mBoxSubset = new Array[Boolean](81)\n\n      def initSubsets: Unit = {\n        for (row <- 0 to 8) {\n          for (col <- 0 to 8) {\n            val value = solution(fap(row, col))\n            if (value != 0)\n              setSubsetValue(row, col, value, true)\n          }\n        }\n      }\n      \n      def setSubsetValue(r: Int, c: Int, value: Int, present: Boolean): Unit = {\n        mRowSubset(fap(r, value - 1)) = present\n        mColSubset(fap(c, value - 1)) = present\n        mBoxSubset(fap(computeBoxNo(r, c), value - 1)) = present\n      }\n\n      def computeBoxNo(r: Int, c: Int): Int = {\n        val boxRow = r / 3\n        val boxCol = c / 3\n        return boxRow * 3 + boxCol \n      }\n\n      def isValid(r: Int, c: Int, value: Int): Boolean = {\n        val vVal = value - 1\n        val isPresent = mRowSubset(fap(r, vVal)) || mColSubset(fap(c, vVal)) || mBoxSubset(fap(computeBoxNo(r, c), vVal))\n        return !isPresent\n      }\n\n      def solve(row: Int, col: Int): Boolean = {\n        var r = row\n        var c = col\n\n        if (r == 9) {\n          r = 0\n          c += 1\n          if (c == 9)\n            return true\n        }\n        \n        if(solution(fap(r,c)) != 0)\n          return solve(r+1,c)\n        for(value <- 1 to 9) \n          if(isValid(r, c, value)) {\n            solution(fap(r,c)) = value\n            setSubsetValue(r, c, value, true)\n            if(solve(r+1,c))\n              return true\n            setSubsetValue(r, c, value, false)\n          }\n        solution(fap(r,c)) = 0\n        return false\n      }\n \n      def checkSol: Boolean = {\n        initSubsets\n        if ((mRowSubset.exists(_==false)) || (mColSubset.exists(_==false)) || (mBoxSubset.exists(_==false))) return false\n        true\n      }\n\n      initSubsets\n      val ret = solve(0,0)\n      if (ret) \n        if (checkSol) return solution.toList else Nil\n      else\n        return Nil\n    }\n  }\n  \n  val f2Str: List[Int] => String = fields => {\n    val f2Stri: List[Int] => String = fields => {\n      val sepLine = \"+---+---+---+\"\n      val sepPoints = Set(2,5,8)\n      val fs: (Int, Int) => String = (i, v) => v.toString.replace(\"0\",\" \")+(if (sepPoints.contains(i%9)) \"|\" else \"\")\n      val s = sepLine+\"\\n\"+(0 to fields.size-1).map(i => (if (i%9==0) \"|\" else \"\")+fs(i,fields(i))+(if (i%9==8) if (sepPoints.contains(i/9)) \"\\n\"+sepLine+\"\\n\" else \"\\n\" else \"\")).foldRight(\"\")(_+_)\n      s\n    }\n    val s = fields match {case Nil => \"no solution!!!\" case _ => f2Stri(fields)}\n    s\n  }\n\n  val elapsedtime: (=> Unit) => Long = f => {val s = System.currentTimeMillis; f; (System.currentTimeMillis - s)/1000}\n\n  var sol = List[Int]()\n  \n  val sudokus = List(\n      (\"riddle used in Ada section:\",\n       \"394..267....3..4..5..69..2..45...9..6.......7..7...58..1..67..8..9..8....264..735\"),\n      (\"riddle used in Bracmat section:\",\n       \"..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9\"),\n      (\"riddle from Groovy section: 4th exceptionally difficult example in Wikipedia: ~80 seconds\",\n       \"..3......4...8..36..8...1...4..6..73...9..........2..5..4.7..686........7..6..5..\"),\n      (\"riddle used in Ada section with incorrect modifactions - it should fail:\",\n       \"3943.267....3..4..5..69..2..45...9..6.......7..7...58..1..67..8..9..8....264..735\"),       \n      (\"riddle constructed with mess - it should fail too:\",\n       \"123456789456789123789123456.45..89..6.......72.7...58.31..67..8..9..8....264..735\"))\n\n  for (sudoku <- sudokus) {\n    val desc = sudoku._1\n    val riddle = sudoku._2.replace(\".\",\"0\").toList.map(_.toString.toInt)\n    println(desc+\"\\n\"+f2Str(riddle)+\"\\n\"\n      +\"elapsed time: \"+elapsedtime(sol = Solver.solve(riddle))+\" sec\"+\"\\n\"+\"solution:\"+\"\\n\"+f2Str(sol)\n      +(\"\\n\"*2))\n  }\n}\n\n\nOutput:\nriddle used in Ada section:\n+---+---+---+\n|394|  2|67 |\n|   |3  |4  |\n|5  |69 | 2 |\n+---+---+---+\n| 45|   |9  |\n|6  |   |  7|\n|  7|   |58 |\n+---+---+---+\n| 1 | 67|  8|\n|  9|  8|   |\n| 26|4  |735|\n+---+---+---+\nelapsed time: 0 sec\nsolution:\n+---+---+---+\n|394|852|671|\n|268|371|459|\n|571|694|823|\n+---+---+---+\n|145|783|962|\n|682|945|317|\n|937|126|584|\n+---+---+---+\n|413|567|298|\n|759|238|146|\n|826|419|735|\n+---+---+---+\n\nriddle used in Bracmat section:\n+---+---+---+\n|   |   |   |\n|   |  3| 85|\n|  1| 2 |   |\n+---+---+---+\n|   |5 7|   |\n|  4|   |1  |\n| 9 |   |   |\n+---+---+---+\n|5  |   | 73|\n|  2| 1 |   |\n|   | 4 |  9|\n+---+---+---+\nelapsed time: 43 sec\nsolution:\n+---+---+---+\n|987|654|321|\n|246|173|985|\n|351|928|746|\n+---+---+---+\n|128|537|694|\n|634|892|157|\n|795|461|832|\n+---+---+---+\n|519|286|473|\n|472|319|568|\n|863|745|219|\n+---+---+---+\n\nriddle from Groovy section: 4th exceptionally difficult example in Wikipedia: ~80 seconds\n+---+---+---+\n|  3|   |   |\n|4  | 8 | 36|\n|  8|   |1  |\n+---+---+---+\n| 4 | 6 | 73|\n|   |9  |   |\n|   |  2|  5|\n+---+---+---+\n|  4| 7 | 68|\n|6  |   |   |\n|7  |6  |5  |\n+---+---+---+\nelapsed time: 3 sec\nsolution:\n+---+---+---+\n|123|456|789|\n|457|189|236|\n|968|327|154|\n+---+---+---+\n|249|561|873|\n|576|938|412|\n|831|742|695|\n+---+---+---+\n|314|275|968|\n|695|814|327|\n|782|693|541|\n+---+---+---+\n\nriddle used in Ada section with incorrect modifactions - it should fail:\n+---+---+---+\n|394|3 2|67 |\n|   |3  |4  |\n|5  |69 | 2 |\n+---+---+---+\n| 45|   |9  |\n|6  |   |  7|\n|  7|   |58 |\n+---+---+---+\n| 1 | 67|  8|\n|  9|  8|   |\n| 26|4  |735|\n+---+---+---+\nelapsed time: 0 sec\nsolution:\nno solution!!!\n\nriddle constructed with mess - it should fail too:\n+---+---+---+\n|123|456|789|\n|456|789|123|\n|789|123|456|\n+---+---+---+\n| 45|  8|9  |\n|6  |   |  7|\n|2 7|   |58 |\n+---+---+---+\n|31 | 67|  8|\n|  9|  8|   |\n| 26|4  |735|\n+---+---+---+\nelapsed time: 0 sec\nsolution:\nno solution!!!\n", "explain": "I use the following slightly modified code for creating new sudokus and it seems to me usable for solving given sudokus. It doesn't look like elegant and functional programming - so what! it works!\nThis solver works with normally 9x9 sudokus as well as with sudokus of jigsaw type or sudokus with additional condition like diagonal constraint. \nThe implementation above doesn't work so effective for sudokus like Bracmat version, therefore I implemented a second version inspired by Java section:\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "D", "code": "\nTranslation of: C++\n\nimport std.stdio, std.range, std.string, std.algorithm, std.array,\n       std.ascii, std.typecons;\n\nstruct Digit {\n    immutable char d;\n\n    this(in char d_) pure nothrow @safe @nogc\n    in { assert(d_ >= '0' && d_ <= '9'); }\n    body { this.d = d_; }\n\n    this(in int d_) pure nothrow @safe @nogc\n    in { assert(d_ >= '0' && d_ <= '9'); }\n    body { this.d = cast(char)d_; } // Required cast.\n\n    alias d this;\n}\n\nenum size_t sudokuUnitSide = 3;\nenum size_t sudokuSide = sudokuUnitSide ^^ 2; // Sudoku grid side.\nalias SudokuTable = Digit[sudokuSide ^^ 2];\n\n\nNullable!SudokuTable sudokuSolver(in ref SudokuTable problem)\npure nothrow {\n    alias Tgrid = uint;\n    Tgrid[SudokuTable.length] grid = void;\n    problem[].map!(c => c - '0').copy(grid[]);\n\n    // DMD doesn't inline this function. Performance loss.\n    Tgrid access(in size_t x, in size_t y) nothrow @safe @nogc {\n        return grid[y * sudokuSide + x];\n    }\n\n    // DMD doesn't inline this function. If you want to retain\n    // the same performance as the C++ entry and you use the DMD\n    // compiler then this function must be manually inlined.\n    bool checkValidity(in Tgrid val, in size_t x, in size_t y)\n    pure nothrow @safe @nogc {\n        /*static*/ foreach (immutable i; staticIota!(0, sudokuSide))\n            if (access(i, y) == val || access(x, i) == val)\n                return false;\n\n        immutable startX = (x / sudokuUnitSide) * sudokuUnitSide;\n        immutable startY = (y / sudokuUnitSide) * sudokuUnitSide;\n\n        /*static*/ foreach (immutable i; staticIota!(0, sudokuUnitSide))\n            /*static*/ foreach (immutable j; staticIota!(0, sudokuUnitSide))\n                if (access(startX + j, startY + i) == val)\n                    return false;\n\n        return true;\n    }\n\n    bool canPlaceNumbers(in size_t pos=0) nothrow @safe @nogc {\n        if (pos == SudokuTable.length)\n            return true;\n        if (grid[pos] > 0)\n            return canPlaceNumbers(pos + 1);\n\n        foreach (immutable n; 1 .. sudokuSide + 1)\n            if (checkValidity(n, pos % sudokuSide, pos / sudokuSide)) {\n                grid[pos] = n;\n                if (canPlaceNumbers(pos + 1))\n                    return true;\n                grid[pos] = 0;\n            }\n\n        return false;\n    }\n\n    if (canPlaceNumbers) {\n        //return typeof(return)(grid[]\n        //                      .map!(c => Digit(c + '0'))\n        //                      .array);\n        immutable SudokuTable result = grid[]\n                                       .map!(c => Digit(c + '0'))\n                                       .array;\n        return typeof(return)(result);\n    } else\n        return typeof(return)();\n}\n\nstring representSudoku(in ref SudokuTable sudo)\npure nothrow @safe out(result) {\n    assert(result.countchars(\"1-9\") == sudo[].count!q{a != '0'});\n    assert(result.countchars(\".\") == sudo[].count!q{a == '0'});\n} body {\n    static assert(sudo.length == 81,\n        \"representSudoku works only with a 9x9 Sudoku.\");\n    string result;\n\n    foreach (immutable i; 0 .. sudokuSide) {\n        foreach (immutable j; 0 .. sudokuSide) {\n            result ~= sudo[i * sudokuSide + j];\n            result ~= ' ';\n            if (j == 2 || j == 5)\n                result ~= \"| \";\n        }\n        result ~= \"\\n\";\n        if (i == 2 || i == 5)\n            result ~= \"------+-------+------\\n\";\n    }\n\n    return result.replace(\"0\", \".\");\n}\n\nvoid main() {\n    enum ValidateCells(string s) = s.map!Digit.array;\n\n    immutable SudokuTable problem = ValidateCells!(\"\n        850002400\n        720000009\n        004000000\n        000107002\n        305000900\n        040000000\n        000080070\n        017000000\n        000036040\".removechars(whitespace));\n    problem.representSudoku.writeln;\n\n    immutable solution = problem.sudokuSolver;\n    if (solution.isNull)\n        writeln(\"Unsolvable!\");\n    else\n        solution.get.representSudoku.writeln;\n}\n\n\nOutput:\n8 5 . | . . 2 | 4 . .\n7 2 . | . . . | . . 9\n. . 4 | . . . | . . .\n------+-------+------\n. . . | 1 . 7 | . . 2\n3 . 5 | . . . | 9 . .\n. 4 . | . . . | . . .\n------+-------+------\n. . . | . 8 . | . 7 .\n. 1 7 | . . . | . . .\n. . . | . 3 6 | . 4 . \n\n8 5 9 | 6 1 2 | 4 3 7 \n7 2 3 | 8 5 4 | 1 6 9 \n1 6 4 | 3 7 9 | 5 2 8 \n------+-------+------\n9 8 6 | 1 4 7 | 3 5 2 \n3 7 5 | 2 6 8 | 9 1 4 \n2 4 1 | 5 9 3 | 7 8 6 \n------+-------+------\n4 3 2 | 9 8 1 | 6 7 5 \n6 1 7 | 4 2 5 | 8 9 3 \n5 9 8 | 7 3 6 | 2 4 1 \nShort Version[edit]\n\nimport std.stdio, std.algorithm, std.range;\n\nconst(int)[] solve(immutable int[] s) pure nothrow @safe {\n    immutable i = s.countUntil(0);\n    if (i == -1)\n        return s;\n\n    enum B = (int i, int j) => i / 27 ^ j / 27 | (i%9 / 3 ^ j%9 / 3);\n    immutable c = iota(81)\n                  .filter!(j => !((i - j) % 9 * (i/9 ^ j/9) * B(i, j)))\n                  .map!(j => s[j]).array;\n\n    foreach (immutable v; 1 .. 10)\n        if (!c.canFind(v)) {\n            const r = solve(s[0 .. i] ~ v ~ s[i + 1 .. $]);\n            if (!r.empty)\n                return r;\n        }\n    return null;\n}\n\nvoid main() {\n    immutable problem = [\n        8, 5, 0, 0, 0, 2, 4, 0, 0,\n        7, 2, 0, 0, 0, 0, 0, 0, 9,\n        0, 0, 4, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 7, 0, 0, 2,\n        3, 0, 5, 0, 0, 0, 9, 0, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 0, 0, 7, 0,\n        0, 1, 7, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 3, 6, 0, 4, 0];\n    writefln(\"%(%s\\n%)\", problem.solve.chunks(9));\n}\n\n\nOutput:\n[8, 5, 9, 6, 1, 2, 4, 3, 7]\n[7, 2, 3, 8, 5, 4, 1, 6, 9]\n[1, 6, 4, 3, 7, 9, 5, 2, 8]\n[9, 8, 6, 1, 4, 7, 3, 5, 2]\n[3, 7, 5, 2, 6, 8, 9, 1, 4]\n[2, 4, 1, 5, 9, 3, 7, 8, 6]\n[4, 3, 2, 9, 8, 1, 6, 7, 5]\n[6, 1, 7, 4, 2, 5, 8, 9, 3]\n[5, 9, 8, 7, 3, 6, 2, 4, 1]\nNo-Heap Version[edit]\n\nimport std.stdio, std.algorithm, std.range, std.typecons;\n\nNullable!(const ubyte[81]) solve(in ubyte[81] s) pure nothrow @safe @nogc {\n    immutable i = s[].countUntil(0);\n    if (i == -1)\n        return typeof(return)(s);\n\n    static immutable B = (in int i, in int j) pure nothrow @safe @nogc =>\n        i / 27 ^ j / 27 | (i % 9 / 3 ^ j % 9 / 3);\n\n    ubyte[81] c = void;\n    size_t len = 0;\n    foreach (immutable int j; 0 .. c.length)\n        if (!((i - j) % 9 * (i/9 ^ j/9) * B(i, j)))\n            c[len++] = s[j];\n\n    foreach (immutable ubyte v; 1 .. 10)\n        if (!c[0 .. len].canFind(v)) {\n            ubyte[81] s2 = void;\n            s2[0 .. i] = s[0 .. i];\n            s2[i] = v;\n            s2[i + 1 .. $] = s[i + 1 .. $];\n            const r = solve(s2);\n            if (!r.isNull)\n                return typeof(return)(r);\n        }\n    return typeof(return)();\n}\n\nvoid main() {\n    immutable ubyte[81] problem = [\n        8, 5, 0, 0, 0, 2, 4, 0, 0,\n        7, 2, 0, 0, 0, 0, 0, 0, 9,\n        0, 0, 4, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 1, 0, 7, 0, 0, 2,\n        3, 0, 5, 0, 0, 0, 9, 0, 0,\n        0, 4, 0, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 8, 0, 0, 7, 0,\n        0, 1, 7, 0, 0, 0, 0, 0, 0,\n        0, 0, 0, 0, 3, 6, 0, 4, 0];\n    writefln(\"%(%s\\n%)\", problem.solve.get[].chunks(9));\n}\n\n\n", "explain": "A little over-engineered solution, that shows some strong static typing useful in larger programs.\nAdapted from: http://code.activestate.com/recipes/576725-brute-force-sudoku-solver/\nThis version is similar to the precedent one, but it shows idioms to avoid memory allocations on the heap. This is enforced by the use of the @nogc attribute.\nSame output.\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Haskell", "code": "\n\n", "explain": "Visit the Haskell wiki Sudoku\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "VBScript", "code": "\nTranslation of: VBA\n\nDim grid(9, 9)\nDim gridSolved(9, 9)\n \nPublic Sub Solve(i, j)\n    If i > 9 Then\n        'exit with gridSolved = Grid\n        For r = 1 To 9\n\t    For c = 1 To 9\n\t        gridSolved(r, c) = grid(r, c)\n\t    Next 'c \n        Next 'r\n        Exit Sub\n    End If\n    For n = 1 To 9\n        If isSafe(i, j, n) Then\n          nTmp = grid(i, j)\n          grid(i, j) = n\n          If j = 9 Then\n                Solve i + 1, 1\n          Else\n                Solve i, j + 1\n          End If\n          grid(i, j) = nTmp\n        End If\n    Next 'n\nEnd Sub 'Solve\n \nPublic Function isSafe(i, j, n) \n    If grid(i, j) <> 0 Then\n        isSafe = (grid(i, j) = n)\n        Exit Function\n    End If\n    'grid(i,j) is an empty cell. Check if n is OK\n    'first check the row i\n    For c = 1 To 9\n        If grid(i, c) = n Then\n            isSafe = False\n            Exit Function\n        End If\n    Next 'c\n    'now check the column j\n    For r = 1 To 9\n        If grid(r, j) = n Then\n            isSafe = False\n            Exit Function\n        End If\n    Next 'r\n    'finally, check the 3x3 subsquare containing grid(i,j)\n    iMin = 1 + 3 * Int((i - 1) / 3)\n    jMin = 1 + 3 * Int((j - 1) / 3)\n    For r = iMin To iMin + 2\n        For c = jMin To jMin + 2\n            If grid(r, c) = n Then\n                isSafe = False\n                Exit Function\n            End If\n        Next 'c\n    Next 'r\n    'all tests were OK\n    isSafe = True\nEnd Function 'isSafe\n \nPublic Sub Sudoku()\n    'main routine\n   Dim s(9) \n    s(1) = \"001005070\"\n    s(2) = \"920600000\"\n    s(3) = \"008000600\"\n    s(4) = \"090020401\"\n    s(5) = \"000000000\"\n    s(6) = \"304080090\"\n    s(7) = \"007000300\"\n    s(8) = \"000007069\"\n    s(9) = \"010800700\"\n    For i = 1 To 9\n        For j = 1 To 9\n            grid(i, j) = Int(Mid(s(i), j, 1))\n        Next 'j\n    Next 'j\n    'print problem\n    Wscript.echo \"Problem:\"\n    For i = 1 To 9\n\t    c=\"\"\n        For j = 1 To 9\n            c=c & grid(i, j) & \" \"\n        Next 'j\n\t    Wscript.echo c\n    Next 'i\n    'solve it!\n    Solve 1, 1\n    'print solution\n    Wscript.echo \"Solution:\"\n    For i = 1 To 9\n\t    c=\"\"\n        For j = 1 To 9\n            c=c & gridSolved(i, j) & \" \"\n        Next 'j\n\t    Wscript.echo c\n    Next 'i\nEnd Sub 'Sudoku\n\nCall sudoku\n\n\nOutput:\nProblem:\n0 0 1 0 0 5 0 7 0\n9 2 0 6 0 0 0 0 0\n0 0 8 0 0 0 6 0 0\n0 9 0 0 2 0 4 0 1\n0 0 0 0 0 0 0 0 0\n3 0 4 0 8 0 0 9 0\n0 0 7 0 0 0 3 0 0\n0 0 0 0 0 7 0 6 9\n0 1 0 8 0 0 7 0 0\nSolution:\n6 3 1 2 4 5 9 7 8\n9 2 5 6 7 8 1 4 3\n4 7 8 3 1 9 6 5 2\n7 9 6 5 2 3 4 8 1\n1 8 2 9 6 4 5 3 7\n3 5 4 7 8 1 2 9 6\n8 6 7 4 9 2 3 1 5\n2 4 3 1 5 7 8 6 9\n5 1 9 8 3 6 7 2 4\nAlternate version[edit]\n\n'VBScript Sudoku solver. Fast recursive algorithm adapted from the C version\n'It can read a problem passed in the command line or  from a file /f:textfile\n'if no problem passed it solves a hardwired problem (See the prob0 string)\n'problem string can have 0's or dots in the place of unknown values. All chars different from .0123456789 are ignored\n\nOption explicit\n  Sub print(s): \n    On Error Resume Next\n    WScript.stdout.Write (s)  \n    If  err= &h80070006& Then WScript.Echo \" Please run this script with CScript\": WScript.quit\n  End Sub\n\nfunction parseprob(s)'problem string to array\n  Dim i,j,m\n  print \"parsing: \" & s & vbCrLf & vbcrlf\n  j=0\n   For i=1 To Len(s)\n      m=Mid(s,i,1) \n      Select Case m\n      Case \"0\",\"1\",\"2\",\"3\",\"4\",\"5\",\"6\",\"7\",\"8\",\"9\"\n         sdku(j)=cint(m)\n         j=j+1\n      Case \".\"\n         sdku(j)=0\n         j=j+1\n      Case Else  'all other chars are ignored as separators\n      End Select\n   Next\n  ' print j\n   If j<>81 Then parseprob=false Else parseprob=True\n End function      \n\nsub getprob  'get problem from file or from command line or from \n Dim s,s1\n With WScript.Arguments.Named\n    If .exists(\"f\") Then\n        s1=.item(\"f\")\n        If InStr(s1,\"\\\")=0 Then s1= Left(WScript.ScriptFullName, InStrRev(WScript.ScriptFullName, \"\\\"))&s1\n       On Error Resume Next\n       s= CreateObject(\"Scripting.FileSystemObject\").OpenTextFile (s1, 1).readall\n       If err Then  print \"can't open file \" & s1 :  parseprob(prob0): Exit sub\n       If parseprob(s) =True Then Exit sub\n    End if   \n End With\n With WScript.Arguments.Unnamed            \n    If .count<>0 Then\n    s1=.Item(0)\n     If parseprob(s1)=True Then exit sub\n    End if  \n End With   \n parseprob(prob0)\n End sub \n\nfunction solve(x,ByVal pos)\n 'print pos & vbcrlf\n 'display(x)\n \n Dim row,col,i,j,used\n solve=False\n If pos=81 Then solve= true :Exit function\n row= pos\\9\n col=pos mod 9\n If x(pos) Then solve=solve(x,pos+1):Exit Function\n used=0\n For i=0 To 8\n   used=used Or pwr(x(i * 9 + col))\n Next\nFor i=0 To 8   \n   used=used Or pwr(x(row*9 + i))\nnext\nrow = (row\\ 3) * 3\ncol = (col \\3) * 3\nFor i=row To row+2\n  For j=col To col+2 \n   ' print i & \" \" & j &vbcrlf\n    used = used Or pwr(x(i*9+j))\n  Next\nNext\n'print pos & \" \" & Hex(used) & vbcrlf\nFor i=1 To 9\n  If (used And pwr(i))=0 Then \n     x(pos)=i\n     'print pos & \" \" & i & \" \" & num2bin((used)) & vbcrlf\n     solve= solve(x,pos+1) \n     If solve=True Then Exit Function\n     'x(pos)=0\n  End If   \nNext\nx(pos)=0\n solve=False\nEnd Function\n\nSub display(x)\n  Dim i,s \n  For i=0 To 80\n    If i mod 9=0  Then print s & vbCrLf :s=\"\"\n    If i mod 27=0 Then print vbCrLf\n    If i mod 3=0 Then s=s & \" \"\n    s=s& x(i)& \" \"\n  Next\n  print s & vbCrLf\nEnd Sub\n\nDim pwr:pwr=Array(1,2,4,8,16,32,64,128,256,512,1024,2048)\nDim prob0:prob0= \"001005070\"&\"920600000\"& \"008000600\"&\"090020401\"& \"000000000\" & \"304080090\" & \"007000300\" & \"000007069\" &  \"010800700\"\nDim sdku(81),Time\ngetprob\nprint \"The problem\"  \ndisplay(sdku)\nTime=Timer\nIf solve (sdku,0) Then\n print vbcrlf &\"solution found\"  & vbcrlf\n display(sdku)\nElse\n  print \"no solution found \" & vbcrlf\nEnd if  \nprint vbcrlf & \"time: \" & Timer-Time & \" seconds\" & vbcrlf\n\n\nOutput:\n\nparsing: 001005070920600000008000600090020401000000000304080090007000300000007069010800700\n\nThe problem\n\n 0 0 1  0 0 5  0 7 0 \n 9 2 0  6 0 0  0 0 0 \n 0 0 8  0 0 0  6 0 0 \n\n 0 9 0  0 2 0  4 0 1 \n 0 0 0  0 0 0  0 0 0 \n 3 0 4  0 8 0  0 9 0 \n\n 0 0 7  0 0 0  3 0 0 \n 0 0 0  0 0 7  0 6 9 \n 0 1 0  8 0 0  7 0 0 \n\nsolution found\n\n 6 3 1  2 4 5  9 7 8 \n 9 2 5  6 7 8  1 4 3 \n 4 7 8  3 1 9  6 5 2 \n\n 7 9 6  5 2 3  4 8 1 \n 1 8 2  9 6 4  5 3 7 \n 3 5 4  7 8 1  2 9 6 \n\n 8 6 7  4 9 2  3 1 5 \n 2 4 3  1 5 7  8 6 9 \n 5 1 9  8 3 6  7 2 4 \n\ntime: 0.3710938 seconds\n\n\n", "explain": "To run in console mode with cscript.\nA faster version adapted from the C solution\n\n\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "F#", "code": "\nBacktracking[edit]\nmodule SudokuBacktrack\n\n//Helpers\nlet tuple2 a b = a,b\nlet flip  f a b = f b a\nlet (>>=) f g = Option.bind g f\n\n/// \"A1\" to \"I9\" squares as key in values dictionary\nlet key a b = $\"{a}{b}\"\n\n/// Cross product of elements in ax and elements in bx\nlet cross ax bx = [| for a in ax do for b in bx do key a b |]\n\n// constants\nlet valid   = \"1234567890.,\"\nlet rows    = \"ABCDEFGHI\"\nlet cols    = \"123456789\"    \nlet squares = cross rows cols\n\n// List of all row, cols and boxes:  aka units\nlet unitList = \n    [for c in cols do cross rows (string c) ]@ // row units\n    [for r in rows do cross (string r) cols ]@ // col units\n    [for rs in [\"ABC\";\"DEF\";\"GHI\"] do for cs in [\"123\";\"456\";\"789\"] do cross rs cs ] // box units\n\n/// Dictionary of units for each square\nlet units = \n    [for s in squares do s, [| for u in unitList do if u |> Array.contains s then u |] ] |> Map.ofSeq \n\n/// Dictionary of all peer squares in the relevant units wrt square in question\nlet peers = \n    [for s in squares do units[s] |> Array.concat |> Array.distinct |> Array.except [s] |> tuple2 s] |> Map.ofSeq\n\n/// Should parse grid in many input formats or return None\nlet parseGrid grid = \n    let ints = [for c in grid do if valid |> Seq.contains c then if \",.\" |> Seq.contains c then 0 else (c |> string |> int)]\n    if Seq.length ints = 81 then ints |> Seq.zip squares |> Map.ofSeq |> Some else None\n\n/// Outputs single line puzzle with 0 as empty squares\nlet asString  =  function\n    | Some values -> values |> Map.toSeq |> Seq.map (snd>>string) |> String.concat \"\" \n    | _ ->  \"No solution or Parse Failure\"  \n\n/// Outputs puzzle in 2D format with 0 as empty squares\nlet prettyPrint = function\n    | Some (values:Map<_,_>) -> \n        [for r in rows do [for c in cols do (values[key r c] |> string) ] |> String.concat \" \" ] |> String.concat \"\\n\"        \n    | _ ->  \"No solution or Parse Failure\"  \n\n/// Is digit allowed in the square in question?\u00a0!!! hot path\u00a0!!!! \n/// Array/Array2D no faster and they need explicit copy since not immutable\nlet constraints (values:Map<_,_>) s d = peers[s] |> Seq.map (fun p -> values[p]) |> Seq.exists ((=) d) |> not \n\n/// Move to next square or None if out of bounds\nlet next s = squares |> Array.tryFindIndex ((=)s) |> function Some i when i + 1 < 81 -> Some squares[i + 1] | _ -> None\n\n/// Backtrack recursively and immutably from index \nlet rec backtracker (values:Map<_,_>) = function\n    | None -> Some values // solved!\n    | Some s when values[s] > 0 -> backtracker values (next s)  // square not empty\n    | Some s -> \n        let rec tracker  = function\n            | [] -> None\n            | d::dx ->\n                values\n                |> Map.change s (Option.map (fun _ -> d)) \n                |> flip backtracker (next s) \n                |> function\n                | None ->  tracker dx \n                | success -> success\n        [for d in 1..9 do if constraints values s d then d] |> tracker\n    \n/// solve sudoku using simple backtracking\nlet solve grid = grid |> parseGrid >>= flip backtracker (Some \"A1\")\n\n\nopen System\nopen SudokuBacktrack \n\n[<EntryPoint>]\nlet main argv =\n     let puzzle =  \"000028000800010000000000700000600403200004000100700000030400500000000010060000000\"\n     puzzle |> printfn \"Puzzle:\\n%s\"\n     puzzle |> parseGrid |> prettyPrint |> printfn \"Formatted:\\n%s\"\n     puzzle |> solve |> prettyPrint |> printfn \"Solution:\\n%s\"\n\n     printfn \"Press any key to exit\"\n     Console.ReadKey() |> ignore\n     0\n\n\nOutput:\n\nPuzzle:\n000028000800010000000000700000600403200004000100700000030400500000000010060000000\nFormatted:\n0 0 0 0 2 8 0 0 0\n8 0 0 0 1 0 0 0 0\n0 0 0 0 0 0 7 0 0\n0 0 0 6 0 0 4 0 3\n2 0 0 0 0 4 0 0 0\n1 0 0 7 0 0 0 0 0\n0 3 0 4 0 0 5 0 0\n0 0 0 0 0 0 0 1 0\n0 6 0 0 0 0 0 0 0\nSolution:\n6 1 7 3 2 8 9 4 5\n8 9 4 5 1 7 2 3 6\n3 2 5 9 4 6 7 8 1\n9 7 8 6 5 1 4 2 3\n2 5 6 8 3 4 1 7 9\n1 4 3 7 9 2 6 5 8\n7 3 1 4 8 9 5 6 2\n4 8 9 2 6 5 3 1 7\n5 6 2 1 7 3 8 9 4\nPress any key to exit\n\n\nConstraint Satisfaction (Norvig)[edit]\n// https://norvig.com/sudoku.html\n// using array O(1) lookup & mutable  instead of map O(logn) immutable - now 6 times faster\nmodule SudokuCPSArray      \nopen System\n\n/// from 11 to 99 as squares key maps to 0 to 80 in arrays \nlet key a b = (9*a + b) - 10\n\n/// Keys generator\nlet cross ax bx = [| for a in ax do for b in bx do key a b |]\n\nlet digits  = [|1..9|]\nlet rows    = digits \nlet cols    = digits \nlet empty   = \"0,.\"\nlet valid   = \"123456789\"+empty\nlet boxi    = [for b in 1..3..9 -> [|b..b+2|]]\nlet squares = cross rows cols\n\n/// List of all row, cols and boxes:  aka units\nlet unitlist = \n    [for c in cols -> cross rows [|c|] ]@\n    [for r in rows -> cross [|r|] cols ]@\n    [for rs in boxi do for cs in boxi do cross rs cs ]\n   \n/// Dictionary of units for each square\nlet units = \n    [|for s in squares do [| for u in unitlist do if u |> Array.contains s then u |] |] \n    \n/// Dictionary of all peer squares in the relevant units wrt square in question\nlet peers = \n    [| for s in squares do units[s] |> Array.concat |> Array.distinct |> Array.except [s] |] \n\n/// folds folder returning Some on completion or returns None if not\nlet rec all folder state source = \n    match state, source with\n    | None, _ -> None \n    | Some st, [] -> Some st\n    | Some st , hd::rest -> folder st hd |> (fun st1 -> all folder st1 rest)\n\n/// Assign digit d to values[s] and propagate (via eliminate)\n/// Return Some values, except None if a contradiction is detected.\nlet rec assign (values:int[][]) (s) d =\n    values[s]\n    |> Array.filter ((<>)d)\n    |> List.ofArray |> all (fun vx d1 -> eliminate vx s d1) (Some values) \n    \n/// Eliminate digit d from values[s] and propagate when values[s] size is 1.\n/// Return Some values, except return None if a contradiction is detected.\nand eliminate (values:int[][]) s d =  \n    let peerElim (values1:int[][]) = // If a square s is reduced to one value d, then *eliminate* d from the peers. \n        match Seq.length values1[s] with \n        | 0 -> None // contradiction - removed last value\n        | 1 -> peers[s] |> List.ofArray |> all (fun vx1 s1 ->  eliminate vx1 s1 (values1[s] |> Seq.head) ) (Some values1)\n        | _ -> Some values1\n    \n    let unitsElim values1 = // If a unit u is reduced to only one place for a value d, then *assign* it there.\n        units[s] \n        |> List.ofArray \n        |> all (fun (vx1:int[][]) u -> \n           let sx = [for s in u do if vx1[s] |> Seq.contains d then s] \n           match Seq.length sx with\n           | 0 -> None\n           | 1 -> assign vx1 (Seq.head sx) d\n           | _ -> Some vx1) (Some values1) \n\n    match values[s] |> Seq.contains d with \n    | false ->  Some values // Already eliminated, nothing to do\n    | true ->  \n        values[s] <- values[s]|> Array.filter ((<>)d)\n        values \n        |> peerElim \n        |> Option.bind unitsElim\n\n/// Convert grid into a Map of {square: char} with \"0\",\".\"or\",\" for empties.\nlet parseGrid grid = \n    let cells = [for c in grid do if valid |> Seq.contains c then if empty |> Seq.contains c then 0 else ((string>>int)c)]\n    if Seq.length cells = 81 then cells |> Seq.zip squares |> Map.ofSeq |> Some  else None\n\n/// Convert grid to a Map of constraint propagated possible values, or return None if a contradiction is detected.\nlet applyCPS (parsedGrid:Map<_,_>) =\n    let values = [| for s in squares do digits |]\n    parsedGrid \n    |> Seq.filter (fun (KeyValue(_,d)) -> digits |> Seq.contains d) \n    |> List.ofSeq \n    |> all (fun vx (KeyValue(s,d)) -> assign vx s d) (Some values)   \n\n/// Calculate string centre for each square - which can contain more than 1 digit when debugging\nlet centre s width = \n    let n = width - (Seq.length s)\n    if n <= 0 then s\n    else\n        let half = n/2 + (if (n%2>0 && width%2>0) then 1 else 0)\n        sprintf \"%s%s%s\" (String(' ',half)) s (String(' ', n - half))\n\n/// Display these values as a 2-D grid. Used for debugging \nlet prettyPrint (values:int[][]) = \n    let asString = Seq.map string >> String.concat \"\"\n    let width = 1 + ([for s in squares do Seq.length values[s]] |> List.max)\n    let line = sprintf \"%s\\n\" ((String('-',width*3) |> Seq.replicate 3) |> String.concat \"+\") \n    [for r in rows do \n        for c in cols do \n            sprintf \"%s%s\" (centre (asString values[key r c]) width) (if List.contains c [3;6] then \"|\" else \"\") \n        sprintf \"\\n%s\"(if List.contains r [3;6] then line else \"\") ]\n    |> String.concat \"\"\n\n/// Outputs single line puzzle with 0 as empty squares\nlet asString values = values |> Map.toSeq |> Seq.map (snd>>string) |> String.concat \"\" \n\nlet copy values = values |> Array.map Array.copy \n\n/// Using depth-first search and propagation, try all possible values.\nlet rec search (values:int[][])= \n    [for s in squares do if Seq.length values[s] > 1 then Seq.length values[s] ,s] \n    |> function  \n    | [] -> Some values // Solved!\n    | list -> // tryPick ~ Norvig's `some`\n        list |> List.minBy fst \n        |> fun (_,s) -> values[s] |> Seq.tryPick (fun d -> assign (copy values) s d |> (Option.bind search)) \n\nlet run n g f = parseGrid >> function None -> n | Some m -> f m |> g \nlet solver = run \"Parse Error\" (Option.fold (fun _ t -> t |> prettyPrint) \"No Solution\")\nlet solveNoSearch: string -> string = solver applyCPS    \nlet solveWithSearch: string -> string = solver (applyCPS >> (Option.bind search)) \nlet solveWithSearchToMapOnly:string -> int[][] option = run None id (applyCPS >> (Option.bind search))\n\nUsageopen System\nopen SudokuCPSArray\nopen System.Diagnostics\nopen System.IO\n\n[<EntryPoint>]\nlet main argv =     \n     printfn \"Easy board solution automatic with constraint propagation\"\n     let easy = \"..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..\"\n     easy |> solveNoSearch |> printfn \"%s\"\n\n     printfn \"Simple elimination not possible\"\n     let simple = \"4.....8.5.3..........7......2.....6.....8.4......1.......6.3.7.5..2.....1.4......\"\n     simple |> run \"Parse Error\" asString id |> printfn \"%s\"\n     simple |> solveNoSearch |> printfn \"%s\"\n          \n     printfn \"Try again with search:\"\n     simple |> solveWithSearch |> printfn \"%s\"\n    \n     let watch = Stopwatch()\n\n     let hard = \"85...24..72......9..4.........1.7..23.5...9...4...........8..7..17..........36.4.\"\n     printfn \"Hard\"\n     watch.Start()\n     hard |> solveWithSearch |> printfn \"%s\"\n     watch.Stop()\n     printfn $\"Elapsed milliseconds = {watch.ElapsedMilliseconds } ms\"\n     watch.Reset()\n     \n     let puzzles  = \n        if Seq.length argv = 1 then \n            let num = argv[0] |> int\n            printfn $\"First {num} puzzles in sudoku17 (http://staffhome.ecm.uwa.edu.au/~00013890/sudoku17)\"     \n            File.ReadLines(@\"sudoku17.txt\") |> Seq.take num |>Array.ofSeq\n        else \n            printfn $\"All puzzles in sudoku17 (http://staffhome.ecm.uwa.edu.au/~00013890/sudoku17)\"     \n            File.ReadLines(@\"sudoku17.txt\") |>Array.ofSeq\n     watch.Start()\n     let result = puzzles |> Array.map solveWithSearchToMapOnly\n     watch.Stop()\n     if result |> Seq.forall Option.isSome then\n        let total = watch.ElapsedMilliseconds\n        let avg = (float total) /(float result.Length)\n        printfn $\"\\nPuzzles:{result.Length}, Total:%.2f{((float)total)/1000.0} s, Average:%.2f{avg} ms\"\n     else\n        printfn \"Some sudoku17 puzzles failed\"\n     Console.ReadKey() |> ignore\n     0\n\n\nOutput:Timings run on i7500U @2.75Ghz CPU, 16GB RAMEasy board solution automatic with constraint propagation\n4 8 3 |9 2 1 |6 5 7\n9 6 7 |3 4 5 |8 2 1\n2 5 1 |8 7 6 |4 9 3\n------+------+------\n5 4 8 |1 3 2 |9 7 6\n7 2 9 |5 6 4 |1 3 8\n1 3 6 |7 9 8 |2 4 5\n------+------+------\n3 7 2 |6 8 9 |5 1 4\n8 1 4 |2 5 3 |7 6 9\n6 9 5 |4 1 7 |3 8 2\nSimple elimination not possible\n400000805030000000000700000020000060000080400000010000000603070500200000104000000\n\n   4      1679   12679  |  139     2369    269   |   8      1239     5\n 26789     3    1256789 | 14589   24569   245689 | 12679    1249   124679\n  2689   15689   125689 |   7     234569  245689 | 12369   12349   123469\n------------------------+------------------------+------------------------\n  3789     2     15789  |  3459   34579    4579  | 13579     6     13789\n  3679   15679   15679  |  359      8     25679  |   4     12359   12379\n 36789     4     56789  |  359      1     25679  | 23579   23589   23789\n------------------------+------------------------+------------------------\n  289      89     289   |   6      459      3    |  1259     7     12489\n   5      6789     3    |   2      479      1    |   69     489     4689\n   1      6789     4    |  589     579     5789  | 23569   23589   23689\n\nTry again with search:\n4 1 7 |3 6 9 |8 2 5\n6 3 2 |1 5 8 |9 4 7\n9 5 8 |7 2 4 |3 1 6\n------+------+------\n8 2 5 |4 3 7 |1 6 9\n7 9 1 |5 8 6 |4 3 2\n3 4 6 |9 1 2 |7 5 8\n------+------+------\n2 8 9 |6 4 3 |5 7 1\n5 7 3 |2 9 1 |6 8 4\n1 6 4 |8 7 5 |2 9 3\nHard\n8 5 9 |6 1 2 |4 3 7\n7 2 3 |8 5 4 |1 6 9\n1 6 4 |3 7 9 |5 2 8\n------+------+------\n9 8 6 |1 4 7 |3 5 2\n3 7 5 |2 6 8 |9 1 4\n2 4 1 |5 9 3 |7 8 6\n------+------+------\n4 3 2 |9 8 1 |6 7 5\n6 1 7 |4 2 5 |8 9 3\n5 9 8 |7 3 6 |2 4 1\nElapsed milliseconds = 8 ms\nAll puzzles in sudoku17 (http://staffhome.ecm.uwa.edu.au/~00013890/sudoku17)\n\nPuzzles:49151, Total:80.99 s, Average:1.65 ms\nSLPsolve[edit]\n// Solve Sudoku Like Puzzles. Nigel Galloway: September 6th., 2018\nlet fN y n g=let _q n' g'=[for n in n*n'..n*n'+n-1 do for g in g*g'..g*g'+g-1 do yield (n,g)]\n             let N=[|for n in 0..(y/n)-1 do for g in 0..(y/g)-1 do yield _q n g|]\n             (fun n' g'->N.[((n'/n)*n+g'/g)])\nlet fI n=let _q g=[for n in 0..n-1 do yield (g,n)]\n         let N=[|for n in 0..n-1 do yield _q n|]\n         (fun g (_:int)->N.[g])\nlet fG n=let _q g=[for n in 0..n-1 do yield (n,g)]\n         let N=[|for n in 0..n-1 do yield _q n|]\n         (fun (_:int) n->N.[n])\nlet fE v z n g fn=let N,G,B,fn=fI z,fG z,fN z n g,readCSV ',' fn|>List.ofSeq\n                  let fG n g mask=List.except (N n g@G n g@B n g) mask\n                  let b=List.except(List.map(fun n->(n.row,n.col))fn)[for n in 0..z-1 do for g in 0..z-1 do yield (n,g)]\n                  let q=Map.ofList[for v' in v do yield ((v'),List.choose(fun n->if n.value=v' then Some(n.row,n.col) else None)fn|>List.fold(fun z (n,g)->(n,g)::fG n g z)b)]\n                  (fG,(fun n->Map.find n q),z,v)\nlet SLPsolve (N,G,z,l)=\n  let rec nQueens col mask res=[\n    if col=z then yield res else\n    yield! List.filter(fun(n,_)->n=col)mask|>List.collect(fun(n,g)->nQueens (col+1) (N n g mask) ((n,g)::res))]\n  let rec sudoku l res=seq{\n    match l with\n    |h::t->let n=nQueens 0 (List.except (List.concat res) (G h)) []\n           yield! n|>Seq.collect(fun n->sudoku t (n::res))\n    |_->yield res}\n  sudoku l []\nlet printSLP n g=\n  List.map2(fun n g->List.map(fun(n',g')->((n',g'),n))g) (List.rev n) g|>List.concat|>List.sortBy (fun ((_,n),_)->n)|>List.groupBy(fun ((n,_),_)->n)|>List.sortBy(fun(n,_)->n)\n  |>List.iter(fun (_,n)->n|>Seq.fold(fun z ((_,g),v)->[z..g-1]|>Seq.iter(fun _->printf \" |\");printf \"%s|\" v; g+1 ) 0 |>ignore;printfn \"\")\n\n\n7,1,,4,,6,,2\n,,,,7,,,,3\n4,,,,,1,,8\n,,,,1,3,,,9\n,,1,,,,7\n2,,,8,6\n,2,,1,,,,,4\n9,,,,8\n,7,,6,,4,,5,2\n\n\nlet n=SLPsolve (fE ([1..9]|>List.map(string)) 9 3 3 \"sud1.csv\")\nprintSLP ([1..9]|>List.map(string)) (Seq.item 0 n)\n\n\nOutput:\n7|1|8|4|3|6|9|2|5|\n5|6|2|9|7|8|4|1|3|\n4|3|9|5|2|1|6|8|7|\n6|8|5|7|1|3|2|4|9|\n3|9|1|2|4|5|7|6|8|\n2|4|7|8|6|9|5|3|1|\n8|2|6|1|5|7|3|9|4|\n9|5|4|3|8|2|1|7|6|\n1|7|3|6|9|4|8|5|2|\n\n", "explain": "Usage:\nUsage:\nGiven sud1.csv:\nthen\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "Groovy", "code": "\n\nfinal CELL_VALUES = ('1'..'9')\n \nclass GridException extends Exception {\n    GridException(String message) { super(message) }\n}\n \ndef string2grid = { string ->\n    assert string.size() == 81\n    (0..8).collect { i -> (0..8).collect { j -> string[9*i+j] } }\n}\n \ndef gridRow = { grid, slot -> grid[slot.i] as Set }\n \ndef gridCol = { grid, slot -> grid.collect { it[slot.j] } as Set }\n \ndef gridBox = { grid, slot ->\n    def t, l; (t, l) = [slot.i.intdiv(3)*3, slot.j.intdiv(3)*3]\n    (0..2).collect { row -> (0..2).collect { col -> grid[t+row][l+col] } }.flatten() as Set\n}\n \ndef slotList = { grid ->\n    def slots = (0..8).collect { i -> (0..8).findAll { j -> grid[i][j] == '.' } \\\n            .collect {j -> [i: i, j: j] } }.flatten()\n}\n \ndef assignCandidates = { grid, slots = slotList(grid) ->\n    slots.each { slot ->\n        def unavailable = [gridRow, gridCol, gridBox].collect { it(grid, slot) }.sum() as Set\n        slot.candidates = CELL_VALUES - unavailable\n    }\n    slots.sort { - it.candidates.size() }\n    if (slots && ! slots[-1].candidates) {\n        throw new GridException('Invalid Sudoku Grid, overdetermined slot: ' + slots[-1])\n    }\n    slots\n}\n \ndef isSolved = { grid -> ! (grid.flatten().find { it == '.' }) }\n \ndef solve \nsolve = { grid ->\n    def slots = assignCandidates(grid)\n    if (! slots) { return grid }\n    while (slots[-1].candidates.size() == 1) {\n        def slot = slots.pop()\n        grid[slot.i][slot.j] = slot.candidates[0]\n        if (! slots) { return grid }\n        slots = assignCandidates(grid, slots)\n    }\n    if (! slots) { return grid } \n    def slot = slots.pop()\n    slot.candidates.each {\n        if (! isSolved(grid)) {\n            try {\n                def sGrid = grid.collect { row -> row.collect { cell -> cell } }\n                sGrid[slot.i][slot.j] = it\n                grid = solve(sGrid)\n            } catch (GridException ge) {\n                grid[slot.i][slot.j] = '.'\n            }\n        }\n    }\n    if (!isSolved(grid)) {\n        slots = assignCandidates(grid)\n        throw new GridException('Invalid Sudoku Grid, underdetermined slots: ' + slots)\n    }\n    grid\n}\n\n\ndef sudokus = [\n  //Used in Curry solution:                             ~ 0.1 seconds\n    '819..5.....2...75..371.4.6.4..59.1..7..3.8..2..3.62..7.5.7.921..64...9.....2..438',\n \n  //Used in Perl and PicoLisp solutions:                ~ 0.1 seconds\n    '53..247....2...8..1..7.39.2..8.72.49.2.98..7.79.....8.....3.5.696..1.3...5.69..1.',\n \n  //Used in Fortran solution:                           ~ 0.1 seconds\n    '..3.2.6..9..3.5..1..18.64....81.29..7.......8..67.82....26.95..8..2.3..9..5.1.3..',\n \n  //Used in many other solutions, notably Algol 68:     ~ 0.1 seconds\n    '394..267....3..4..5..69..2..45...9..6.......7..7...58..1..67..8..9..8....264..735',\n \n  //Used in C# solution:                                ~ 0.2 seconds\n    '97.3...6..6.75.........8.5.......67.....3.....539..2..7...25.....2.1...8.4...73..',\n \n  //Used in Oz solution:                                ~ 0.2 seconds\n    '4......6.5...8.9..3....1....2.7....1.9.....4.8....3.5....2....7..6.5...8.1......6',\n \n  //Used in many other solutions, notably C++:          ~ 0.3 seconds\n    '85...24..72......9..4.........1.7..23.5...9...4...........8..7..17..........36.4.',\n \n  //Used in VBA solution:                               ~ 0.3 seconds\n    '..1..5.7.92.6.......8...6...9..2.4.1.........3.4.8..9...7...3.......7.69.1.8..7..',\n \n  //Used in Forth solution:                             ~ 0.8 seconds\n    '.9...4..7.....79..8........4.58.....3.......2.....97.6........4..35.....2..6...8.',\n \n  //3rd \"exceptionally difficult\" example in Wikipedia: ~ 2.3 seconds\n    '12.3....435....1....4........54..2..6...7.........8.9...31..5.......9.7.....6...8',\n \n  //Used in Curry solution:                             ~ 2.4 seconds\n    '9..2..5...4..6..3...3.....6...9..2......5..8...7..4..37.....1...5..2..4...1..6..9',\n \n  //\"AL Escargot\", so-called \"hardest sudoku\" (HA!):    ~ 3.0 seconds\n    '1....7.9..3..2...8..96..5....53..9...1..8...26....4...3......1..4......7..7...3..',\n \n  //1st \"exceptionally difficult\" example in Wikipedia: ~ 6.5 seconds\n    '12.4..3..3...1..5...6...1..7...9.....4.6.3.....3..2...5...8.7....7.....5.......98',\n \n  //Used in Bracmat and Scala solutions:                ~ 6.7 seconds\n    '..............3.85..1.2.......5.7.....4...1...9.......5......73..2.1........4...9',\n \n  //2nd \"exceptionally difficult\" example in Wikipedia: ~ 8.8 seconds\n    '.......39.....1..5..3.5.8....8.9...6.7...2...1..4.......9.8..5..2....6..4..7.....',\n \n  //Used in MATLAB solution:                            ~15   seconds\n    '....839..1......3...4....7..42.3....6.......4....7..1..2........8...92.....25...6',\n \n  //4th \"exceptionally difficult\" example in Wikipedia: ~29   seconds\n    '..3......4...8..36..8...1...4..6..73...9..........2..5..4.7..686........7..6..5..']\n \nsudokus.each { sudoku ->\n    def grid = string2grid(sudoku)\n    println '\\nPUZZLE'\n    grid.each { println it }\n \n    println '\\nSOLUTION'\n    def start = System.currentTimeMillis()\n    def solution = solve(grid)\n    def elapsed = (System.currentTimeMillis() - start)/1000\n    solution.each { println it }\n    println \"\\nELAPSED: ${elapsed} seconds\"\n}\n\n\nOutput: (last only)\n\nPUZZLE\n[., ., 3, ., ., ., ., ., .]\n[4, ., ., ., 8, ., ., 3, 6]\n[., ., 8, ., ., ., 1, ., .]\n[., 4, ., ., 6, ., ., 7, 3]\n[., ., ., 9, ., ., ., ., .]\n[., ., ., ., ., 2, ., ., 5]\n[., ., 4, ., 7, ., ., 6, 8]\n[6, ., ., ., ., ., ., ., .]\n[7, ., ., 6, ., ., 5, ., .]\n\nSOLUTION\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[4, 5, 7, 1, 8, 9, 2, 3, 6]\n[9, 6, 8, 3, 2, 7, 1, 5, 4]\n[2, 4, 9, 5, 6, 1, 8, 7, 3]\n[5, 7, 6, 9, 3, 8, 4, 1, 2]\n[8, 3, 1, 7, 4, 2, 6, 9, 5]\n[3, 1, 4, 2, 7, 5, 9, 6, 8]\n[6, 9, 5, 8, 1, 4, 3, 2, 7]\n[7, 8, 2, 6, 9, 3, 5, 4, 1]\n\nELAPSED: 28.978 seconds\n", "explain": "Adaptive \"Non-guessing Then Guessing\" Solution\nNon-guessing part is iterative. Guessing part is recursive. Implementation uses exception handling to back out of bad guesses.\nI consider this a \"brute force\" solution of sorts, in that it is the same method I use when solving Sudokus manually.\nTest/Benchmark Cases\nMentions of \"exceptionally difficult\" example in Wikipedia refer to this (former) page: [Exceptionally difficult Sudokus]\n"}, {"task_name": "Sudoku", "task_url": "https://rosettacode.org/wiki/Sudoku", "task_cat": "Games", "lang": "AWK", "code": "\n# syntax: GAWK -f SUDOKU_RC.AWK\nBEGIN {\n#             row1      row2      row3      row4      row5      row6      row7      row8      row9\n#   puzzle = \"111111111 111111111 111111111 111111111 111111111 111111111 111111111 111111111 111111111\" # NG duplicate hints\n#   puzzle = \"1........ ..274.... ...5....4 .3....... 75....... .....96.. .4...6... .......71 .....1.30\" # NG can't use zero\n#   puzzle = \"1........ ..274.... ...5....4 .3....... 75....... .....96.. .4...6... .......71 .....1.39\" # no solution\n#   puzzle = \"1........ ..274.... ...5....4 .3....... 75....... .....96.. .4...6... .......71 .....1.3.\" # OK\n    puzzle = \"123456789 456789123 789123456 ......... ......... ......... ......... ......... .........\" # OK\n    gsub(/ /,\"\",puzzle)\n    if (length(puzzle) != 81) { error(\"length of puzzle is not 81\") }\n    if (puzzle !~ /^[1-9\\.]+$/) { error(\"only 1-9 and . are valid\") }\n    if (gsub(/[1-9]/,\"&\",puzzle) < 17) { error(\"too few hints\") }\n    if (errors > 0) {\n      exit(1)\n    }\n    plot(puzzle,\"unsolved\")\n    if (dup_hints_check(puzzle) == 1) {\n      if (solve(puzzle) == 1) {\n        dup_hints_check(sos)\n        plot(sos,\"solved\")\n        printf(\"\\nbef: %s\\naft: %s\\n\",puzzle,sos)\n        exit(0)\n      }\n      else {\n        error(\"no solution\")\n      }\n    }\n    exit(1)\n}\nfunction dup_hints_check(ss,  esf,msg,Rarr,Carr,Barr,i,r_row,r_col,r_pos,r_hint,c_row,c_col,c_pos,c_hint,box) {\n    esf = errors                       # errors so far\n    for (i=0; i<81; i++) {\n      # row\n      r_row = int(i/9) + 1             # determine row: 1..9\n      r_col = i%9 + 1                  # determine column: 1..9\n      r_pos = i + 1                    # determine hint position: 1..81\n      r_hint = substr(ss,r_pos,1)      # extract 1 character; the hint\n      Rarr[r_row,r_hint]++             # save row\n      # column\n      c_row = i%9 + 1                  # determine row: 1..9\n      c_col = int(i/9) + 1             # determine column: 1..9\n      c_pos = (c_row-1) * 9 + c_col    # determine hint position: 1..81\n      c_hint = substr(ss,c_pos,1)      # extract 1 character; the hint\n      Carr[c_col,c_hint]++             # save column\n      # box (there has to be a better way)\n      if      ((r_row r_col) ~ /[123][123]/) { box = 1 }\n      else if ((r_row r_col) ~ /[123][456]/) { box = 2 }\n      else if ((r_row r_col) ~ /[123][789]/) { box = 3 }\n      else if ((r_row r_col) ~ /[456][123]/) { box = 4 }\n      else if ((r_row r_col) ~ /[456][456]/) { box = 5 }\n      else if ((r_row r_col) ~ /[456][789]/) { box = 6 }\n      else if ((r_row r_col) ~ /[789][123]/) { box = 7 }\n      else if ((r_row r_col) ~ /[789][456]/) { box = 8 }\n      else if ((r_row r_col) ~ /[789][789]/) { box = 9 }\n      else { box = 0 }\n      Barr[box,r_hint]++               # save box\n    }\n    dup_hints_print(Rarr,\"row\")\n    dup_hints_print(Carr,\"column\")\n    dup_hints_print(Barr,\"box\")\n    return((errors == esf) ? 1 : 0)\n}\nfunction dup_hints_print(arr,rcb,  hint,i) {\n# rcb - Row Column Box\n    for (i=1; i<=9; i++) {             # \"i\" is either the row, column, or box\n      for (hint=1; hint<=9; hint++) {  # 1..9 only; don't care about \".\" place holder\n        if (arr[i,hint]+0 > 1) {       # was a digit specified more than once\n          error(sprintf(\"duplicate hint in %s %d\",rcb,i))\n        }\n      }\n    }\n}\nfunction plot(ss,text1,text2,  a,b,c,d,ou) {\n# 1st call prints the unsolved puzzle.\n# 2nd call prints the solved puzzle\n    printf(\"| - - - + - - - + - - - | %s\\n\",text1)\n    for (a=0; a<3; a++) {\n      for (b=0; b<3; b++) {\n        ou = \"|\"\n        for (c=0; c<3; c++) {\n          for (d=0; d<3; d++) {\n            ou = sprintf(\"%s %1s\",ou,substr(ss,1+d+3*c+9*b+27*a,1))\n          }\n          ou = ou \" |\"\n        }\n        print(ou)\n      }\n      printf(\"| - - - + - - - + - - - | %s\\n\",(a==2)?text2:\"\")\n    }\n}\nfunction solve(ss,  a,b,c,d,e,r,co,ro,bi,bl,nss) {\n    i = 0\n# first, use some simple logic to fill grid as much as possible\n    do {\n      i++\n      didit = 0\n      delete nr\n      delete nc\n      delete nb\n      delete ca\n      for (a=0; a<81; a++) {\n        b = substr(ss,a+1,1)\n        if (b == \".\") {                # construct row, column and block at cell\n          c = a % 9\n          r = int(a/9)\n          ro = substr(ss,r*9+1,9)\n          co = \"\"\n          for (d=0; d<9; d++) { co = co substr(ss,d*9+c+1,1) }\n          bi = int(c/3)*3+(int(r/3)*3)*9+1\n          bl = \"\"\n          for (d=0; d<3; d++) { bl = bl substr(ss,bi+d*9,3) }\n          e = 0\n# count non-occurrences of digits 1-9 in combined row, column and block, per row, column and block, and flag cell/digit as candidate\n          for (d=1; d<10; d++) {\n            if (index(ro co bl, d) == 0) {\n              e++\n              nr[r,d]++\n              nc[c,d]++\n              nb[bi,d]++\n              ca[c,r,d] = bi\n            }\n          }\n          if (e == 0) {                # in case no candidate is available, give up\n            return(0)\n          }\n        }\n      }\n# go through all cell/digit candidates\n# hidden singles\n      for (crd in ca) {\n# a candidate may have been deleted after the loop started\n        if (ca[crd] != \"\") {\n          split(crd,spl,SUBSEP)\n          c = spl[1]\n          r = spl[2]\n          d = spl[3]\n          bi = ca[crd]\n          a = c + r * 9\n# unique solution if at least one non-occurrence counter is exactly 1\n          if ((nr[r,d] == 1) || (nc[c,d] == 1) || (nb[bi,d] == 1)) {\n            ss = substr(ss,1,a) d substr(ss,a+2,length(ss))\n            didit = 1\n# remove candidates from current row, column, block\n            for (e=0; e<9; e++) {\n              delete ca[c,e,d]\n              delete ca[e,r,d]\n            }\n            for (e=0; e<3; e++) {\n              for (b=0; b<3; b++) {\n                delete ca[int(c/3)*3+b,int(r/3)*3+e,d]\n              }\n            }\n          }\n        }\n      }\n    } while (didit == 1)\n# second, pick a viable solution for the next empty cell and see if it leads to a solution\n    a = index(ss,\".\")-1\n    if (a == -1) {                     # no more empty cells, done\n      sos = ss\n      return(1)\n    }\n    else {\n      c = a % 9\n      r = int(a/9)\n# concatenate current row, column and block\n# row\n      co = substr(ss,r*9+1,9)\n# column\n      for (d=0; d<9; d++) { co = co substr(ss,d*9+c+1,1) }\n# block\n      c = int(c/3)*3+(int(r/3)*3)*9+1\n      for (d=0; d<3; d++) { co = co substr(ss,c+d*9,3) }\n      for (b=1; b<10; b++) {           # get a viable digit\n        if (index(co,b) == 0) {        # check if candidate digit already exists\n# is viable, put in cell\n          nss = substr(ss,1,a) b substr(ss,a+2,length(ss))\n          d = solve(nss)               # try to solve\n          if (d == 1) {                # if successful, return\n            return(1)\n          }\n        }\n      }\n    }\n    return(0)                          # no digits viable, no solution\n}\nfunction error(message) { printf(\"error: %s\\n\",message) ; errors++ }\n\n\nOutput:\n| - - - + - - - + - - - | unsolved\n| 1 2 3 | 4 5 6 | 7 8 9 |\n| 4 5 6 | 7 8 9 | 1 2 3 |\n| 7 8 9 | 1 2 3 | 4 5 6 |\n| - - - + - - - + - - - |\n| . . . | . . . | . . . |\n| . . . | . . . | . . . |\n| . . . | . . . | . . . |\n| - - - + - - - + - - - |\n| . . . | . . . | . . . |\n| . . . | . . . | . . . |\n| . . . | . . . | . . . |\n| - - - + - - - + - - - |\n| - - - + - - - + - - - | solved\n| 1 2 3 | 4 5 6 | 7 8 9 |\n| 4 5 6 | 7 8 9 | 1 2 3 |\n| 7 8 9 | 1 2 3 | 4 5 6 |\n| - - - + - - - + - - - |\n| 2 1 4 | 3 6 5 | 8 9 7 |\n| 3 6 5 | 8 9 7 | 2 1 4 |\n| 8 9 7 | 2 1 4 | 3 6 5 |\n| - - - + - - - + - - - |\n| 5 3 1 | 6 4 2 | 9 7 8 |\n| 6 4 2 | 9 7 8 | 5 3 1 |\n| 9 7 8 | 5 3 1 | 6 4 2 |\n| - - - + - - - + - - - |\n\nbef: 123456789456789123789123456......................................................\naft: 123456789456789123789123456214365897365897214897214365531642978642978531978531642\n\n", "explain": ""}]