[{"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nPython: Explicitly recursive[edit]\nWorks with: Python version 2.5\ndef ack1(M, N):\n   return (N + 1) if M == 0 else (\n      ack1(M-1, 1) if N == 0 else ack1(M-1, ack1(M, N-1)))\n\nfrom functools import lru_cache\n\n@lru_cache(None)\ndef ack2(M, N):\n    if M == 0:\n        return N + 1\n    elif N == 0:\n        return ack2(M - 1, 1)\n    else:\n        return ack2(M - 1, ack2(M, N - 1))\n\nExample of use:\n>>> import sys\n>>> sys.setrecursionlimit(3000)\n>>> ack1(0,0)\n1\n>>> ack1(3,4)\n125\n>>> ack2(0,0)\n1\n>>> ack2(3,4)\n125\n\ndef ack2(M, N):\n   return (N + 1)   if M == 0 else (\n          (N + 2)   if M == 1 else (\n          (2*N + 3) if M == 2 else (\n          (8*(2**N - 1) + 5) if M == 3 else (\n          ack2(M-1, 1) if N == 0 else ack2(M-1, ack2(M, N-1))))))\n\nPython: Without recursive function calls[edit]\n\nfrom collections import deque\n\ndef ack_ix(m, n):\n    \"Paddy3118's iterative with optimisations on m\"\n\n    stack = deque([])\n    stack.extend([m, n])\n\n    while  len(stack) > 1:\n        n, m = stack.pop(), stack.pop()\n\n        if   m == 0:\n            stack.append(n + 1)\n        elif m == 1:\n            stack.append(n + 2)\n        elif m == 2:\n            stack.append(2*n + 3)\n        elif m == 3:\n            stack.append(2**(n + 3) - 3)\n        elif n == 0:\n            stack.extend([m-1, 1])\n        else:\n            stack.extend([m-1, m, n-1])\n\n    return stack[0]\n\nOutput:\n\nIn [26]: %time a_4_2 = ack_ix(4, 2)\nWall time: 0 ns\n\nIn [27]: # How big is the answer?\n\nIn [28]: float(a_4_2)\nTraceback (most recent call last):\n\n  File \"<ipython-input-28-af4ad951eff8>\", line 1, in <module>\n    float(a_4_2)\n\nOverflowError: int too large to convert to float\n\n\nIn [29]: # How many decimal digits in the answer?\n\nIn [30]: len(str(a_4_2))\nOut[30]: 19729\n\n", "explain": "Another version:\nFrom the Mathematica ack3 example:\nResults confirm those of Mathematica for ack(4,1) and ack(4,2)\nThe heading is more correct than saying the following is iterative as an explicit stack is used to replace explicit recursive function calls. I don't think this is what Comp. Sci. professors mean by iterative.\n(From an ipython shell)\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdio.h>\n\nint ackermann(int m, int n)\n{\n        if (!m) return n + 1;\n        if (!n) return ackermann(m - 1, 1);\n        return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main()\n{\n        int m, n;\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n\n\nOutput:\nA(0, 0) = 1\nA(0, 1) = 2\nA(0, 2) = 3\nA(0, 3) = 4\nA(0, 4) = 5\nA(0, 5) = 6\nA(1, 0) = 2\nA(1, 1) = 3\nA(1, 2) = 4\nA(1, 3) = 5\nA(1, 4) = 6\nA(2, 0) = 3\nA(2, 1) = 5\nA(2, 2) = 7\nA(2, 3) = 9\nA(3, 0) = 5\nA(3, 1) = 13\nA(3, 2) = 29\nA(4, 0) = 13\nA(4, 1) = 65533\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\nint m_bits, n_bits;\nint *cache;\n\nint ackermann(int m, int n)\n{\n        int idx, res;\n        if (!m) return n + 1;\n\n        if (n >= 1<<n_bits) {\n                printf(\"%d, %d\\n\", m, n);\n                idx = 0;\n        } else {\n                idx = (m << n_bits) + n;\n                if (cache[idx]) return cache[idx];\n        }\n\n        if (!n) res = ackermann(m - 1, 1);\n        else    res = ackermann(m - 1, ackermann(m, n - 1));\n\n        if (idx) cache[idx] = res;\n        return res;\n}\nint main()\n{\n        int m, n;\n\n        m_bits = 3;\n        n_bits = 20;  /* can save n values up to 2**20 - 1, that's 1 meg */\n        cache = malloc(sizeof(int) * (1 << (m_bits + n_bits)));\n        memset(cache, 0, sizeof(int) * (1 << (m_bits + n_bits)));\n\n        for (m = 0; m <= 4; m++)\n                for (n = 0; n < 6 - m; n++)\n                        printf(\"A(%d, %d) = %d\\n\", m, n, ackermann(m, n));\n\n        return 0;\n}\n\n\nOutput:\nA(0, 0) = 1\nA(0, 1) = 2\nA(0, 2) = 3\nA(0, 3) = 4\nA(0, 4) = 5\nA(0, 5) = 6\nA(1, 0) = 2\nA(1, 1) = 3\nA(1, 2) = 4\nA(1, 3) = 5\nA(1, 4) = 6\nA(2, 0) = 3\nA(2, 1) = 5\nA(2, 2) = 7\nA(2, 3) = 9\nA(3, 0) = 5\nA(3, 1) = 13\nA(3, 2) = 29\nA(4, 0) = 13\nA(4, 1) = 65533\n\n/* Thejaka Maldeniya */\n\n#include <conio.h>\n\nunsigned long long HR(unsigned int n, unsigned long long a, unsigned long long b) {\n\t// (Internal) Recursive Hyperfunction: Perform a Hyperoperation...\n\n\tunsigned long long r = 1;\n\n\twhile(b--)\n\t\tr = n - 3 ? HR(n - 1, a, r) : /* Exponentiation */ r * a;\n\n\treturn r;\n}\n\nunsigned long long H(unsigned int n, unsigned long long a, unsigned long long b) {\n\t// Hyperfunction (Recursive-Iterative-O(1) Hybrid): Perform a Hyperoperation...\n\n\tswitch(n) {\n\t\tcase 0:\n\t\t\t// Increment\n\t\t\treturn ++b;\n\t\tcase 1:\n\t\t\t// Addition\n\t\t\treturn a + b;\n\t\tcase 2:\n\t\t\t// Multiplication\n\t\t\treturn a * b;\n\t}\n\n\treturn HR(n, a, b);\n}\n\nunsigned long long APH(unsigned int m, unsigned int n) {\n\t// Ackermann-P\u00e9ter Function (Recursive-Iterative-O(1) Hybrid)\n\treturn H(m, 2, n + 3) - 3;\n}\n\nunsigned long long * p = 0;\n\nunsigned long long APRR(unsigned int m, unsigned int n) {\n\tif (!m) return ++n;\n\n\tunsigned long long r = p ? p[m] : APRR(m - 1, 1);\n\n\t--m;\n\twhile(n--)\n\t\tr = APRR(m, r);\n\n\treturn r;\n}\n\nunsigned long long APRA(unsigned int m, unsigned int n) {\n\treturn\n\t\tm ?\n\t\t\tn ?\n\t\t\t\tAPRR(m, n)\n\t\t\t\t: p ? p[m] : APRA(--m, 1)\n\t\t\t: ++n\n\t\t;\n}\n\nunsigned long long APR(unsigned int m, unsigned int n) {\n\tunsigned long long r = 0;\n\n\t// Allocate\n\tp = (unsigned long long *) malloc(sizeof(unsigned long long) * (m + 1));\n\n\t// Initialize\n\tfor(; r <= m; ++r)\n\t\tp[r] = r ? APRA(r - 1, 1) : APRA(r, 0);\n\n\t// Calculate\n\tr = APRA(m, n);\n\n\t// Free\n\tfree(p);\n\n\treturn r;\n}\n\nunsigned long long AP(unsigned int m, unsigned int n) {\n\treturn APH(m, n);\n\treturn APR(m, n);\n}\n\nint main(int n, char ** a) {\n\tunsigned int M, N;\n\n\tif (n != 3) {\n\t\tprintf(\"Usage: %s <m> <n>\\n\", *a);\n\t\treturn 1;\n\t}\n\n\tprintf(\"AckermannPeter(%u, %u) = %llu\\n\", M = atoi(a[1]), N = atoi(a[2]), AP(M, N));\n\n\t//printf(\"\\nPress any key...\");\n\t//getch();\n\treturn 0;\n}\n\n\n/* Thejaka Maldeniya */\n\n#include <conio.h>\n\nunsigned long long HI(unsigned int n, unsigned long long a, unsigned long long b) {\n\t// Hyperfunction (Iterative): Perform a Hyperoperation...\n\n\tunsigned long long *I, r = 1;\n\tunsigned int N = n - 3;\n\n\tif (!N)\n\t\t// Exponentiation\n\t\twhile(b--)\n\t\t\tr *= a;\n\telse if(b) {\n\t\tn -= 2;\n\n\t\t// Allocate\n\t\tI = (unsigned long long *) malloc(sizeof(unsigned long long) * n--);\n\n\t\t// Initialize\n\t\tI[n] = b;\n\n\t\t// Calculate\n\t\tfor(;;) {\n\t\t\tif(I[n]) {\n\t\t\t\t--I[n];\n\t\t\t\tif (n)\n\t\t\t\t\tI[--n] = r, r = 1;\n\t\t\t\telse\n\t\t\t\t\tr *= a;\n\t\t\t} else\n\t\t\t\tfor(;;)\n\t\t\t\t\tif (n == N)\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\telse if(I[++n])\n\t\t\t\t\t\tbreak;\n\t\t}\na:\n\n\t\t// Free\n\t\tfree(I);\n\t}\n\n\treturn r;\n}\n\nunsigned long long H(unsigned int n, unsigned long long a, unsigned long long b) {\n\t// Hyperfunction (Iterative-O(1) Hybrid): Perform a Hyperoperation...\n\n\tswitch(n) {\n\t\tcase 0:\n\t\t\t// Increment\n\t\t\treturn ++b;\n\t\tcase 1:\n\t\t\t// Addition\n\t\t\treturn a + b;\n\t\tcase 2:\n\t\t\t// Multiplication\n\t\t\treturn a * b;\n\t}\n\n\treturn HI(n, a, b);\n}\n\nunsigned long long APH(unsigned int m, unsigned int n) {\n\t// Ackermann-P\u00e9ter Function (Recursive-Iterative-O(1) Hybrid)\n\treturn H(m, 2, n + 3) - 3;\n}\n\nunsigned long long * p = 0;\n\nunsigned long long APIA(unsigned int m, unsigned int n) {\n\tif (!m) return ++n;\n\n\t// Initialize\n\tunsigned long long *I, r = p ? p[m] : APIA(m - 1, 1);\n\tunsigned int M = m;\n\n\tif (n) {\n\t\t// Allocate\n\t\tI = (unsigned long long *) malloc(sizeof(unsigned long long) * (m + 1));\n\n\t\t// Initialize\n\t\tI[m] = n;\n\n\t\t// Calculate\n\t\tfor(;;) {\n\t\t\tif(I[m]) {\n\t\t\t\tif (m)\n\t\t\t\t\t--I[m], I[--m] = r, r = p ? p[m] : APIA(m - 1, 1);\n\t\t\t\telse\n\t\t\t\t\tr += I[m], I[m] = 0;\n\t\t\t} else\n\t\t\t\tfor(;;)\n\t\t\t\t\tif (m == M)\n\t\t\t\t\t\tgoto a;\n\t\t\t\t\telse if(I[++m])\n\t\t\t\t\t\tbreak;\n\t\t}\na:\n\n\t\t// Free\n\t\tfree(I);\n\t}\n\n\treturn r;\n}\n\nunsigned long long API(unsigned int m, unsigned int n) {\n\tunsigned long long r = 0;\n\n\t// Allocate\n\tp = (unsigned long long *) malloc(sizeof(unsigned long long) * (m + 1));\n\n\t// Initialize\n\tfor(; r <= m; ++r)\n\t\tp[r] = r ? APIA(r - 1, 1) : APIA(r, 0);\n\n\t// Calculate\n\tr = APIA(m, n);\n\n\t// Free\n\tfree(p);\n\n\treturn r;\n}\n\nunsigned long long AP(unsigned int m, unsigned int n) {\n\treturn APH(m, n);\n\treturn API(m, n);\n}\n\nint main(int n, char ** a) {\n\tunsigned int M, N;\n\n\tif (n != 3) {\n\t\tprintf(\"Usage: %s <m> <n>\\n\", *a);\n\t\treturn 1;\n\t}\n\n\tprintf(\"AckermannPeter(%u, %u) = %llu\\n\", M = atoi(a[1]), N = atoi(a[2]), AP(M, N));\n\n\t//printf(\"\\nPress any key...\");\n\t//getch();\n\treturn 0;\n}\n\n\n", "explain": "Straightforward implementation per Ackermann definition:\nAckermann function makes a lot of recursive calls, so the above program is a bit naive.  We need to be slightly less naive, by doing some simple caching:\nWhee.  Well, with some extra work, we calculated one more n value, big deal, right?\nBut see, A(4, 2) = A(3, A(4, 1)) = A(3, 65533) = A(2, A(3, 65532)) = ... you can see how fast it blows up.  In fact, no amount of caching will help you calculate large m values;  on the machine I use A(4, 2) segfaults because the recursions run out of stack space--not a whole lot I can do about it.  At least it runs out of stack space quickly, unlike the first solution...\nA couple of alternative approaches...\nA couple of more iterative techniques...\nA few further tweaks/optimizations may be possible.\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\nBasic version[edit]\n#include <iostream>\n\nunsigned int ackermann(unsigned int m, unsigned int n) {\n  if (m == 0) {\n    return n + 1;\n  }\n  if (n == 0) {\n    return ackermann(m - 1, 1);\n  }\n  return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nint main() {\n  for (unsigned int m = 0; m < 4; ++m) {\n    for (unsigned int n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n}\n\nEfficient version[edit]\nTranslation of: D\n\ng++ -std=c++11 -I /path/to/boost ackermann.cpp.\n\n#include <iostream>\n#include <sstream>\n#include <string>\n#include <boost/multiprecision/cpp_int.hpp>\n\nusing big_int = boost::multiprecision::cpp_int;\n\nbig_int ipow(big_int base, big_int exp) {\n  big_int result(1);\n  while (exp) {\n    if (exp & 1) {\n      result *= base;\n    }\n    exp >>= 1;\n    base *= base;\n  }\n  return result;\n}\n\nbig_int ackermann(unsigned m, unsigned n) {\n  static big_int (*ack)(unsigned, big_int) =\n      [](unsigned m, big_int n)->big_int {\n    switch (m) {\n    case 0:\n      return n + 1;\n    case 1:\n      return n + 2;\n    case 2:\n      return 3 + 2 * n;\n    case 3:\n      return 5 + 8 * (ipow(big_int(2), n) - 1);\n    default:\n      return n == 0 ? ack(m - 1, big_int(1)) : ack(m - 1, ack(m, n - 1));\n    }\n  };\n  return ack(m, big_int(n));\n}\n\nint main() {\n  for (unsigned m = 0; m < 4; ++m) {\n    for (unsigned n = 0; n < 10; ++n) {\n      std::cout << \"A(\" << m << \", \" << n << \") = \" << ackermann(m, n) << \"\\n\";\n    }\n  }\n\n  std::cout << \"A(4, 1) = \" << ackermann(4, 1) << \"\\n\";\n\n  std::stringstream ss;\n  ss << ackermann(4, 2);\n  auto text = ss.str();\n  std::cout << \"A(4, 2) = (\" << text.length() << \" digits)\\n\"\n            << text.substr(0, 80) << \"\\n...\\n\"\n            << text.substr(text.length() - 80) << \"\\n\";\n}\n\n<pre>\nA(0, 0) = 1\nA(0, 1) = 2\nA(0, 2) = 3\nA(0, 3) = 4\nA(0, 4) = 5\nA(0, 5) = 6\nA(0, 6) = 7\nA(0, 7) = 8\nA(0, 8) = 9\nA(0, 9) = 10\nA(1, 0) = 2\nA(1, 1) = 3\nA(1, 2) = 4\nA(1, 3) = 5\nA(1, 4) = 6\nA(1, 5) = 7\nA(1, 6) = 8\nA(1, 7) = 9\nA(1, 8) = 10\nA(1, 9) = 11\nA(2, 0) = 3\nA(2, 1) = 5\nA(2, 2) = 7\nA(2, 3) = 9\nA(2, 4) = 11\nA(2, 5) = 13\nA(2, 6) = 15\nA(2, 7) = 17\nA(2, 8) = 19\nA(2, 9) = 21\nA(3, 0) = 5\nA(3, 1) = 13\nA(3, 2) = 29\nA(3, 3) = 61\nA(3, 4) = 125\nA(3, 5) = 253\nA(3, 6) = 509\nA(3, 7) = 1021\nA(3, 8) = 2045\nA(3, 9) = 4093\nA(4, 1) = 65533\nA(4, 2) = (19729 digits)\n2003529930406846464979072351560255750447825475569751419265016973710894059556311\n...\n4717124577965048175856395072895337539755822087777506072339445587895905719156733\n\n", "explain": "C++11 with boost's big integer type. Compile with:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nimport java.math.BigInteger;\n\npublic static BigInteger ack(BigInteger m, BigInteger n) {\n    return m.equals(BigInteger.ZERO)\n            ? n.add(BigInteger.ONE)\n            : ack(m.subtract(BigInteger.ONE),\n                        n.equals(BigInteger.ZERO) ? BigInteger.ONE : ack(m, n.subtract(BigInteger.ONE)));\n}\n\nWorks with: Java version 8+\n@FunctionalInterface\npublic interface FunctionalField<FIELD extends Enum<?>> {\n  public Object untypedField(FIELD field);\n\n  @SuppressWarnings(\"unchecked\")\n  public default <VALUE> VALUE field(FIELD field) {\n    return (VALUE) untypedField(field);\n  }\n}\n\nimport java.util.function.BiFunction;\nimport java.util.function.Function;\nimport java.util.function.Predicate;\nimport java.util.function.UnaryOperator;\nimport java.util.stream.Stream;\n\npublic interface TailRecursive {\n  public static <INPUT, INTERMEDIARY, OUTPUT> Function<INPUT, OUTPUT> new_(Function<INPUT, INTERMEDIARY> toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> toOutput) {\n    return input ->\n      $.new_(\n        Stream.iterate(\n          toIntermediary.apply(input),\n          unaryOperator\n        ),\n        predicate,\n        toOutput\n      )\n    ;\n  }\n\n  public static <INPUT1, INPUT2, INTERMEDIARY, OUTPUT> BiFunction<INPUT1, INPUT2, OUTPUT> new_(BiFunction<INPUT1, INPUT2, INTERMEDIARY> toIntermediary, UnaryOperator<INTERMEDIARY> unaryOperator, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> toOutput) {\n    return (input1, input2) ->\n      $.new_(\n        Stream.iterate(\n          toIntermediary.apply(input1, input2),\n          unaryOperator\n        ),\n        predicate,\n        toOutput\n      )\n    ;\n  }\n\n  public enum $ {\n    $$;\n\n    private static <INTERMEDIARY, OUTPUT> OUTPUT new_(Stream<INTERMEDIARY> stream, Predicate<INTERMEDIARY> predicate, Function<INTERMEDIARY, OUTPUT> function) {\n      return stream\n        .filter(predicate)\n        .map(function)\n        .findAny()\n        .orElseThrow(RuntimeException::new)\n      ;\n    }\n  }\n}\n\nimport java.math.BigInteger;\nimport java.util.Stack;\nimport java.util.function.BinaryOperator;\nimport java.util.stream.Collectors;\nimport java.util.stream.Stream;\n\npublic interface Ackermann {\n  public static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\n    return $.new_(number1, number2, stack, flag);\n  }\n  public static void main(String... arguments) {\n    $.main(arguments);\n  }\n  public BigInteger number1();\n  public BigInteger number2();\n\n  public Stack<BigInteger> stack();\n\n  public boolean flag();\n\n  public enum $ {\n    $$;\n\n    private static final BigInteger ZERO = BigInteger.ZERO;\n    private static final BigInteger ONE = BigInteger.ONE;\n    private static final BigInteger TWO = BigInteger.valueOf(2);\n    private static final BigInteger THREE = BigInteger.valueOf(3);\n    private static final BigInteger FOUR = BigInteger.valueOf(4);\n\n    private static Ackermann new_(BigInteger number1, BigInteger number2, Stack<BigInteger> stack, boolean flag) {\n      return (FunctionalAckermann) field -> {\n        switch (field) {\n          case number1: return number1;\n          case number2: return number2;\n          case stack: return stack;\n          case flag: return flag;\n          default: throw new UnsupportedOperationException(\n            field instanceof Field\n              ? \"Field checker has not been updated properly.\"\n              : \"Field is not of the correct type.\"\n          );\n        }\n      };\n    }\n\n    private static final BinaryOperator<BigInteger> ACKERMANN = \n      TailRecursive.new_(\n        (BigInteger number1, BigInteger number2) ->\n          new_(\n            number1,\n            number2,\n            Stream.of(number1).collect(\n              Collectors.toCollection(Stack::new)\n            ),\n            false\n          )\n        ,\n        ackermann -> {\n          BigInteger number1 = ackermann.number1();\n          BigInteger number2 = ackermann.number2();\n          Stack<BigInteger> stack = ackermann.stack();\n          if (!stack.empty() && !ackermann.flag()) {\n            number1 = stack.pop();\n          }\n          switch (number1.intValue()) {\n            case 0:\n              return new_(\n                number1,\n                number2.add(ONE),\n                stack,\n                false\n              );\n            case 1:\n              return new_(\n                number1,\n                number2.add(TWO),\n                stack,\n                false\n              );\n            case 2:\n              return new_(\n                number1,\n                number2.multiply(TWO).add(THREE),\n                stack,\n                false\n              );\n            default:\n              if (ZERO.equals(number2)) {\n                return new_(\n                  number1.subtract(ONE),\n                  ONE,\n                  stack,\n                  true\n                );\n              } else {\n                stack.push(number1.subtract(ONE));\n                return new_(\n                  number1,\n                  number2.subtract(ONE),\n                  stack,\n                  true\n                );\n              }\n          }\n        },\n        ackermann -> ackermann.stack().empty(),\n        Ackermann::number2\n      )::apply\n    ;\n\n    private static void main(String... arguments) {\n      System.out.println(ACKERMANN.apply(FOUR, TWO));\n    }\n\n    private enum Field {\n      number1,\n      number2,\n      stack,\n      flag\n    }\n\n    @FunctionalInterface\n    private interface FunctionalAckermann extends FunctionalField<Field>, Ackermann {\n      @Override\n      public default BigInteger number1() {\n        return field(Field.number1);\n      }\n\n      @Override\n      public default BigInteger number2() {\n        return field(Field.number2);\n      }\n\n      @Override\n      public default Stack<BigInteger> stack() {\n        return field(Field.stack);\n      }\n\n      @Override\n      public default boolean flag() {\n        return field(Field.flag);\n      }\n    }\n  }\n}\n\n\n/*\n * Source https://stackoverflow.com/a/51092690/5520417\n */\n\npackage matematicas;\n\nimport java.math.BigInteger;\nimport java.util.HashMap;\nimport java.util.Stack;\n\n/**\n * @author rodri\n *\n */\n\npublic class IterativeAckermannMemoryOptimization extends Thread {\n\n  /**\n   * Max percentage of free memory that the program will use. Default is 10% since\n   * the majority of the used devices are mobile and therefore it is more likely\n   * that the user will have more opened applications at the same time than in a\n   * desktop device\n   */\n  private static Double SYSTEM_MEMORY_LIMIT_PERCENTAGE = 0.1;\n\n  /**\n   * Attribute of the type IterativeAckermann\n   */\n  private IterativeAckermann iterativeAckermann;\n\n  /**\n   * @param iterativeAckermann\n   */\n  public IterativeAckermannMemoryOptimization(IterativeAckermann iterativeAckermann) {\n    super();\n    this.iterativeAckermann = iterativeAckermann;\n  }\n\n  /**\n   * @return\n   */\n  public IterativeAckermann getIterativeAckermann() {\n    return iterativeAckermann;\n  }\n\n  /**\n   * @param iterativeAckermann\n   */\n  public void setIterativeAckermann(IterativeAckermann iterativeAckermann) {\n    this.iterativeAckermann = iterativeAckermann;\n  }\n\n  public static Double getSystemMemoryLimitPercentage() {\n    return SYSTEM_MEMORY_LIMIT_PERCENTAGE;\n  }\n\n  /**\n   * Principal method of the thread. Checks that the memory used doesn't exceed or\n   * equal the limit, and informs the user when that happens.\n   */\n  @Override\n  public void run() {\n    String operating_system = System.getProperty(\"os.name\").toLowerCase();\n    if ( operating_system.equals(\"windows\") || operating_system.equals(\"linux\") || operating_system.equals(\"macintosh\") ) {\n      SYSTEM_MEMORY_LIMIT_PERCENTAGE = 0.25;\n    }\n\n    while ( iterativeAckermann.getConsumed_heap() >= SYSTEM_MEMORY_LIMIT_PERCENTAGE * Runtime.getRuntime().freeMemory() ) {\n      try {\n        wait();\n      }\n      catch ( InterruptedException e ) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n    if ( ! iterativeAckermann.isAlive() )\n      iterativeAckermann.start();\n    else\n      notifyAll();\n\n  }\n\n}\n\n\npublic class IterativeAckermann extends Thread {\n\n  /*\n   * Adjust parameters conveniently\n   */\n  /**\n   * \n   */\n  private static final int HASH_SIZE_LIMIT = 636;\n\n  /**\n   * \n   */\n  private BigInteger m;\n\n  /**\n   * \n   */\n  private BigInteger n;\n\n  /**\n   * \n   */\n  private Integer hash_size;\n\n  /**\n   * \n   */\n  private Long consumed_heap;\n\n  /**\n   * @param m\n   * @param n\n   * @param invalid\n   * @param invalid2\n   */\n  public IterativeAckermann(BigInteger m, BigInteger n, Integer invalid, Long invalid2) {\n    super();\n    this.m = m;\n    this.n = n;\n    this.hash_size = invalid;\n    this.consumed_heap = invalid2;\n  }\n\n  /**\n   * \n   */\n  public IterativeAckermann() {\n    // TODO Auto-generated constructor stub\n    super();\n    m = null;\n    n = null;\n    hash_size = 0;\n    consumed_heap = 0l;\n  }\n\n  /**\n   * @return\n   */\n  public static BigInteger getLimit() {\n    return LIMIT;\n  }\n\n  /**\n   * @author rodri\n   *\n   * @param <T1>\n   * @param <T2>\n   */\n  /**\n   * @author rodri\n   *\n   * @param <T1>\n   * @param <T2>\n   */\n  static class Pair<T1, T2> {\n\n    /**\n     * \n     */\n    /**\n     * \n     */\n    T1 x;\n\n    /**\n     * \n     */\n    /**\n     * \n     */\n    T2 y;\n\n    /**\n     * @param x_\n     * @param y_\n     */\n    /**\n     * @param x_\n     * @param y_\n     */\n    Pair(T1 x_, T2 y_) {\n      x = x_;\n      y = y_;\n    }\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    @Override\n    public int hashCode() {\n      return x.hashCode() ^ y.hashCode();\n    }\n\n    /**\n     *\n     */\n    /**\n     *\n     */\n    @Override\n    public boolean equals(Object o_) {\n\n      if ( o_ == null ) {\n        return false;\n      }\n      if ( o_.getClass() != this.getClass() ) {\n        return false;\n      }\n      Pair<?, ?> o = (Pair<?, ?>) o_;\n      return x.equals(o.x) && y.equals(o.y);\n    }\n  }\n\n  /**\n   * \n   */\n  private static final BigInteger LIMIT = new BigInteger(\"6\");\n\n  /**\n   * @param m\n   * @param n\n   * @return\n   */\n\n  /**\n   *\n   */\n  @Override\n  public void run() {\n    while ( hash_size >= HASH_SIZE_LIMIT ) {\n      try {\n        this.wait();\n      }\n      catch ( InterruptedException e ) {\n        // TODO Auto-generated catch block\n        e.printStackTrace();\n      }\n    }\n    for ( BigInteger i = BigInteger.ZERO; i.compareTo(LIMIT) == - 1; i = i.add(BigInteger.ONE) ) {\n      for ( BigInteger j = BigInteger.ZERO; j.compareTo(LIMIT) == - 1; j = j.add(BigInteger.ONE) ) {\n        IterativeAckermann iterativeAckermann = new IterativeAckermann(i, j, null, null);\n        System.out.printf(\"Ackmermann(%d, %d) = %d\\n\", i, j, iterativeAckermann.iterative_ackermann(i, j));\n\n      }\n    }\n  }\n\n  /**\n   * @return\n   */\n  public BigInteger getM() {\n    return m;\n  }\n\n  /**\n   * @param m\n   */\n  public void setM(BigInteger m) {\n    this.m = m;\n  }\n\n  /**\n   * @return\n   */\n  public BigInteger getN() {\n    return n;\n  }\n\n  /**\n   * @param n\n   */\n  public void setN(BigInteger n) {\n    this.n = n;\n  }\n\n  /**\n   * @return\n   */\n  public Integer getHash_size() {\n    return hash_size;\n  }\n\n  /**\n   * @param hash_size\n   */\n  public void setHash_size(Integer hash_size) {\n    this.hash_size = hash_size;\n  }\n\n  /**\n   * @return\n   */\n  public Long getConsumed_heap() {\n    return consumed_heap;\n  }\n\n  /**\n   * @param consumed_heap\n   */\n  public void setConsumed_heap(Long consumed_heap) {\n    this.consumed_heap = consumed_heap;\n  }\n\n  /**\n   * @param m\n   * @param n\n   * @return\n   */\n  public BigInteger iterative_ackermann(BigInteger m, BigInteger n) {\n    if ( m.compareTo(BigInteger.ZERO) != - 1 && m.compareTo(BigInteger.ZERO) != - 1 )\n      try {\n        HashMap<Pair<BigInteger, BigInteger>, BigInteger> solved_set = new HashMap<Pair<BigInteger, BigInteger>, BigInteger>(900000);\n        Stack<Pair<BigInteger, BigInteger>> to_solve = new Stack<Pair<BigInteger, BigInteger>>();\n        to_solve.push(new Pair<BigInteger, BigInteger>(m, n));\n\n        while ( ! to_solve.isEmpty() ) {\n          Pair<BigInteger, BigInteger> head = to_solve.peek();\n          if ( head.x.equals(BigInteger.ZERO) ) {\n            solved_set.put(head, head.y.add(BigInteger.ONE));\n            to_solve.pop();\n          }\n          else if ( head.y.equals(BigInteger.ZERO) ) {\n            Pair<BigInteger, BigInteger> next = new Pair<BigInteger, BigInteger>(head.x.subtract(BigInteger.ONE), BigInteger.ONE);\n            BigInteger result = solved_set.get(next);\n            if ( result == null ) {\n              to_solve.push(next);\n            }\n            else {\n              solved_set.put(head, result);\n              to_solve.pop();\n            }\n          }\n          else {\n            Pair<BigInteger, BigInteger> next0 = new Pair<BigInteger, BigInteger>(head.x, head.y.subtract(BigInteger.ONE));\n            BigInteger result0 = solved_set.get(next0);\n            if ( result0 == null ) {\n              to_solve.push(next0);\n            }\n            else {\n              Pair<BigInteger, BigInteger> next = new Pair<BigInteger, BigInteger>(head.x.subtract(BigInteger.ONE), result0);\n              BigInteger result = solved_set.get(next);\n              if ( result == null ) {\n                to_solve.push(next);\n              }\n              else {\n                solved_set.put(head, result);\n                to_solve.pop();\n              }\n            }\n          }\n        }\n        this.hash_size = solved_set.size();\n        System.out.println(\"Hash Size: \" + hash_size);\n        consumed_heap = (Runtime.getRuntime().totalMemory() / (1024 * 1024));\n        System.out.println(\"Consumed Heap: \" + consumed_heap + \"m\");\n        setHash_size(hash_size);\n        setConsumed_heap(consumed_heap);\n        return solved_set.get(new Pair<BigInteger, BigInteger>(m, n));\n\n      }\n      catch ( OutOfMemoryError e ) {\n        // TODO: handle exception\n        e.printStackTrace();\n      }\n    throw new IllegalArgumentException(\"The arguments must be non-negative integers.\");\n  }\n\n  /**\n   * @param args\n   */\n  /**\n   * @param args\n   */\n  public static void main(String[] args) {\n    IterativeAckermannMemoryOptimization iterative_ackermann_memory_optimization = new IterativeAckermannMemoryOptimization(\n        new IterativeAckermann());\n    iterative_ackermann_memory_optimization.start();\n  }\n}\n\n", "explain": "Template:Iterative version\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nBasic Version[edit]\nusing System;\nclass Program\n{\n    public static long Ackermann(long m, long n)\n    {\n        if(m > 0)\n        {\n            if (n > 0)\n                return Ackermann(m - 1, Ackermann(m, n - 1));\n            else if (n == 0)\n                return Ackermann(m - 1, 1);\n        }\n        else if(m == 0)\n        {\n            if(n >= 0) \n                return n + 1;\n        }\n\n        throw new System.ArgumentOutOfRangeException();\n    }\n    \n    static void Main()\n    {\n        for (long m = 0; m <= 3; ++m)\n        {\n            for (long n = 0; n <= 4; ++n)\n            {\n                Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            }\n        }\n    }\n}\n\n\nOutput:\nAckermann(0, 0) = 1\nAckermann(0, 1) = 2\nAckermann(0, 2) = 3\nAckermann(0, 3) = 4\nAckermann(0, 4) = 5\nAckermann(1, 0) = 2\nAckermann(1, 1) = 3\nAckermann(1, 2) = 4\nAckermann(1, 3) = 5\nAckermann(1, 4) = 6\nAckermann(2, 0) = 3\nAckermann(2, 1) = 5\nAckermann(2, 2) = 7\nAckermann(2, 3) = 9\nAckermann(2, 4) = 11\nAckermann(3, 0) = 5\nAckermann(3, 1) = 13\nAckermann(3, 2) = 29\nAckermann(3, 3) = 61\nAckermann(3, 4) = 125\n\nEfficient Version[edit]\nusing System;\nusing System.Numerics;\nusing System.IO;\nusing System.Diagnostics;\n\nnamespace Ackermann_Function\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            int _m = 0;\n            int _n = 0;\n            Console.Write(\"m = \");\n            try\n            {\n                _m = Convert.ToInt32(Console.ReadLine());\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"Please enter a number.\");\n            }\n            Console.Write(\"n = \");\n            try\n            {\n                _n = Convert.ToInt32(Console.ReadLine());\n            }\n            catch (Exception)\n            {\n                Console.WriteLine(\"Please enter a number.\");\n            }\n            //for (long m = 0; m <= 10; ++m)\n            //{\n            //    for (long n = 0; n <= 10; ++n)\n            //    {\n            //        DateTime now = DateTime.Now;\n            //        Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", m, n, Ackermann(m, n));\n            //        Console.WriteLine(\"Time taken:{0}\", DateTime.Now - now);\n            //    }\n            //}\n\n            DateTime now = DateTime.Now;\n            Console.WriteLine(\"Ackermann({0}, {1}) = {2}\", _m, _n, Ackermann(_m, _n));\n            Console.WriteLine(\"Time taken:{0}\", DateTime.Now - now);\n            File.WriteAllText(\"number.txt\", Ackermann(_m, _n).ToString());\n            Process.Start(\"number.txt\");\n            Console.ReadKey();\n        }\n        public class OverflowlessStack<T>\n        {\n            internal sealed class SinglyLinkedNode\n            {\n                private const int ArraySize = 2048;\n                T[] _array;\n                int _size;\n                public SinglyLinkedNode Next;\n                public SinglyLinkedNode()\n                {\n                    _array = new T[ArraySize];\n                }\n                public bool IsEmpty { get { return _size == 0; } }\n                public SinglyLinkedNode Push(T item)\n                {\n                    if (_size == ArraySize - 1)\n                    {\n                        SinglyLinkedNode n = new SinglyLinkedNode();\n                        n.Next = this;\n                        n.Push(item);\n                        return n;\n                    }\n                    _array[_size++] = item;\n                    return this;\n                }\n                public T Pop()\n                {\n                    return _array[--_size];\n                }\n            }\n            private SinglyLinkedNode _head = new SinglyLinkedNode();\n\n            public T Pop()\n            {\n                T ret = _head.Pop();\n                if (_head.IsEmpty && _head.Next != null)\n                    _head = _head.Next;\n                return ret;\n            }\n            public void Push(T item)\n            {\n                _head = _head.Push(item);\n            }\n            public bool IsEmpty\n            {\n                get { return _head.Next == null && _head.IsEmpty; }\n            }\n        }\n        public static BigInteger Ackermann(BigInteger m, BigInteger n)\n        {\n            var stack = new OverflowlessStack<BigInteger>();\n            stack.Push(m);\n            while (!stack.IsEmpty)\n            {\n                m = stack.Pop();\n            skipStack:\n                if (m == 0)\n                    n = n + 1;\n                else if (m == 1)\n                    n = n + 2;\n                else if (m == 2)\n                    n = n * 2 + 3;\n                else if (n == 0)\n                {\n                    --m;\n                    n = 1;\n                    goto skipStack;\n                }\n                else\n                {\n                    stack.Push(m - 1);\n                    --n;\n                    goto skipStack;\n                }\n            }\n            return n;\n        }\n    }\n}\n\n\n", "explain": "Possibly the most efficient implementation of Ackermann in C#. It successfully runs Ack(4,2) when executed in Visual Studio. Don't forget to add a reference to System.Numerics.\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\nfunction ack(m, n) {\n return m === 0 ? n + 1 : ack(m - 1, n === 0  ? 1 : ack(m, n - 1));\n}\n\nEliminating Tail Calls[edit]\nfunction ack(M,N) {\n  for (; M > 0; M--) {\n    N = N === 0 ? 1 : ack(M,N-1);\n  }\n  return N+1;\n}\n\nIterative, With Explicit Stack[edit]\nfunction stackermann(M, N) {\n  const stack = [];\n  for (;;) {\n    if (M === 0) {\n      N++;\n      if (stack.length === 0) return N;\n      const r = stack[stack.length-1];\n      if (r[1] === 1) stack.length--;\n      else r[1]--;\n      M = r[0];\n    } else if (N === 0) {\n      M--;\n      N = 1;\n    } else {\n      M--\n      stack.push([M, N]);\n      N = 1;\n    }\n  }\n}\n\nStackless Iterative[edit]\n#!/usr/bin/env nodejs\nfunction ack(M, N){\n\tconst next = new Float64Array(M + 1);\n\tconst goal = new Float64Array(M + 1).fill(1, 0, M);\n\tconst n = N + 1;\n\n\t// This serves as a sentinel value;\n\t// next[M] never equals goal[M] == -1,\n\t// so we don't need an extra check for\n\t// loop termination below.\n\tgoal[M] = -1;\n\n\tlet v;\n\tdo {\n\t\tv = next[0] + 1;\n\t\tlet m = 0;\n\t\twhile (next[m] === goal[m]) {\n\t\t\tgoal[m] = v;\n\t\t\tnext[m++]++;\n\t\t}\n\t\tnext[m]++;\n\t} while (next[M] !== n);\n\treturn v;\n}\nvar args = process.argv;\nconsole.log(ack(parseInt(args[2]), parseInt(args[3])));\n\n\nOutput:\n> time ./ack.js 4 1            \n65533\n./ack.js 4 1  0,48s user 0,03s system 100% cpu 0,505 total\u00a0; AMD FX-8350 @ 4 GHz\n\nES6[edit]\n(() => {\n    'use strict';\n\n    // ackermann\u00a0:: Int -> Int -> Int\n    const ackermann = m => n => {\n        const go = (m, n) =>\n            0 === m ? (\n                succ(n)\n            ) : go(pred(m), 0 === n ? (\n                1\n            ) : go(m, pred(n)));\n        return go(m, n);\n    };\n\n    // TEST -----------------------------------------------\n    const main = () => console.log(JSON.stringify(\n        [0, 1, 2, 3].map(\n            flip(ackermann)(3)\n        )\n    ));\n\n\n    // GENERAL FUNCTIONS ----------------------------------\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        x => y => f(y)(x);\n\n    // pred\u00a0:: Enum a => a -> a\n    const pred = x => x - 1;\n\n    // succ\u00a0:: Enum a => a -> a\n    const succ = x => 1 + x;\n\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[4,5,9,61]\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nfunction ackermann( $m , $n )\n{\n    if ( $m==0 )\n    {\n        return $n + 1;\n    }\n    elseif ( $n==0 )\n    {\n        return ackermann( $m-1 , 1 );\n    }\n    return ackermann( $m-1, ackermann( $m , $n-1 ) );\n}\n\necho ackermann( 3, 4 );\n// prints 125\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\nfunction A = ackermannFunction(m,n)\n    if m == 0\n        A = n+1;\n    elseif (m > 0) && (n == 0)\n        A = ackermannFunction(m-1,1);\n    else\n        A = ackermannFunction( m-1,ackermannFunction(m,n-1) );\n    end\nend\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nPROGRAM EXAMPLE  \n  IMPLICIT NONE\n \n  INTEGER :: i, j\n \n  DO i = 0, 3\n    DO j = 0, 6\n       WRITE(*, \"(I10)\", ADVANCE=\"NO\") Ackermann(i, j)\n    END DO\n    WRITE(*,*)\n  END DO\n \nCONTAINS\n \n  RECURSIVE FUNCTION Ackermann(m, n) RESULT(ack)\n    INTEGER :: ack, m, n\n\n    IF (m == 0) THEN\n      ack = n + 1\n    ELSE IF (n == 0) THEN\n      ack = Ackermann(m - 1, 1)\n    ELSE\n      ack = Ackermann(m - 1, Ackermann(m, n - 1))\n    END IF\n  END FUNCTION Ackermann\n\nEND PROGRAM EXAMPLE\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\nClassic version[edit]\nfunc Ackermann(m, n uint) uint {\n\tswitch 0 {\n\tcase m:\n\t\treturn n + 1\n\tcase n:\n\t\treturn Ackermann(m - 1, 1)\n\t}\n\treturn Ackermann(m - 1, Ackermann(m, n - 1))\n}\n\nExpanded version[edit]\nfunc Ackermann2(m, n uint) uint {\n  switch {\n    case m == 0:\n      return n + 1\n    case m == 1:\n      return n + 2\n    case m == 2:\n      return 2*n + 3\n    case m == 3:\n      return 8 << n - 3\n    case n == 0:\n      return Ackermann2(m - 1, 1)\n  }\n  return Ackermann2(m - 1, Ackermann2(m, n - 1))\n}\n\nExpanded version with arbitrary precision[edit]\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/big\"\n\t\"math/bits\" // Added in Go 1.9\n)\n\nvar one = big.NewInt(1)\nvar two = big.NewInt(2)\nvar three = big.NewInt(3)\nvar eight = big.NewInt(8)\n\nfunc Ackermann2(m, n *big.Int) *big.Int {\n\tif m.Cmp(three) <= 0 {\n\t\tswitch m.Int64() {\n\t\tcase 0:\n\t\t\treturn new(big.Int).Add(n, one)\n\t\tcase 1:\n\t\t\treturn new(big.Int).Add(n, two)\n\t\tcase 2:\n\t\t\tr := new(big.Int).Lsh(n, 1)\n\t\t\treturn r.Add(r, three)\n\t\tcase 3:\n\t\t\tif nb := n.BitLen(); nb > bits.UintSize {\n\t\t\t\t// n is too large to represent as a\n\t\t\t\t// uint for use in the Lsh method.\n\t\t\t\tpanic(TooBigError(nb))\n\n\t\t\t\t// If we tried to continue anyway, doing\n\t\t\t\t// 8*2^n-3 as bellow, we'd use hundreds\n\t\t\t\t// of megabytes and lots of CPU time\n\t\t\t\t// without the Exp call even returning.\n\t\t\t\tr := new(big.Int).Exp(two, n, nil)\n\t\t\t\tr.Mul(eight, r)\n\t\t\t\treturn r.Sub(r, three)\n\t\t\t}\n\t\t\tr := new(big.Int).Lsh(eight, uint(n.Int64()))\n\t\t\treturn r.Sub(r, three)\n\t\t}\n\t}\n\tif n.BitLen() == 0 {\n\t\treturn Ackermann2(new(big.Int).Sub(m, one), one)\n\t}\n\treturn Ackermann2(new(big.Int).Sub(m, one),\n\t\tAckermann2(m, new(big.Int).Sub(n, one)))\n}\n\ntype TooBigError int\n\nfunc (e TooBigError) Error() string {\n\treturn fmt.Sprintf(\"A(m,n) had n of %d bits; too large\", int(e))\n}\n\nfunc main() {\n\tshow(0, 0)\n\tshow(1, 2)\n\tshow(2, 4)\n\tshow(3, 100)\n\tshow(3, 1e6)\n\tshow(4, 1)\n\tshow(4, 2)\n\tshow(4, 3)\n}\n\nfunc show(m, n int64) {\n\tdefer func() {\n\t\t// Ackermann2 could/should have returned an error\n\t\t// instead of a panic. But here's how to recover\n\t\t// from the panic, and report \"expected\" errors.\n\t\tif e := recover(); e != nil {\n\t\t\tif err, ok := e.(TooBigError); ok {\n\t\t\t\tfmt.Println(\"Error:\", err)\n\t\t\t} else {\n\t\t\t\tpanic(e)\n\t\t\t}\n\t\t}\n\t}()\n\n\tfmt.Printf(\"A(%d, %d) = \", m, n)\n\ta := Ackermann2(big.NewInt(m), big.NewInt(n))\n\tif a.BitLen() <= 256 {\n\t\tfmt.Println(a)\n\t} else {\n\t\ts := a.String()\n\t\tfmt.Printf(\"%d digits starting/ending with: %s...%s\\n\",\n\t\t\tlen(s), s[:20], s[len(s)-20:],\n\t\t)\n\t}\n}\n\n\nOutput:\nA(0, 0) = 1\nA(1, 2) = 4\nA(2, 4) = 11\nA(3, 100) = 10141204801825835211973625643005\nA(3, 1000000) = 301031 digits starting/ending with: 79205249834367186005...39107225301976875005\nA(4, 1) = 65533\nA(4, 2) = 19729 digits starting/ending with: 20035299304068464649...45587895905719156733\nA(4, 3) = Error: A(m,n) had n of 65536 bits; too large\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program ackermann.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MMAXI,   4\n.equ NMAXI,   10\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:        .asciz \"Result for @  @ \u00a0: @ \\n\"\nszMessError:        .asciz \"Overflow\u00a0!!.\\n\"\nszCarriageReturn:   .asciz \"\\n\"\n \n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                           @ entry of program \n    mov r3,#0\n    mov r4,#0\n1:\n    mov r0,r3\n    mov r1,r4\n    bl ackermann\n    mov r5,r0\n    mov r0,r3\n    ldr r1,iAdrsZoneConv        @ else display odd message\n    bl conversion10             @ call decimal conversion\n    ldr r0,iAdrsMessResult\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    mov r6,r0\n    mov r0,r4\n    ldr r1,iAdrsZoneConv        @ else display odd message\n    bl conversion10             @ call decimal conversion\n    mov r0,r6\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    mov r6,r0\n    mov r0,r5\n    ldr r1,iAdrsZoneConv        @ else display odd message\n    bl conversion10             @ call decimal conversion\n    mov r0,r6\n    ldr r1,iAdrsZoneConv        @ insert value conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    add r4,#1\n    cmp r4,#NMAXI\n    blt 1b\n    mov r4,#0\n    add r3,#1\n    cmp r3,#MMAXI\n    blt 1b\n100:                            @ standard end of the program \n    mov r0, #0                  @ return code\n    mov r7, #EXIT               @ request to exit program\n    svc #0                      @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrsZoneConv:            .int sZoneConv\n/***************************************************/\n/*     fonction ackermann              */\n/***************************************************/\n// r0 contains a number m\n// r1 contains a number n\n// r0 return r\u00e9sult\nackermann:\n    push {r1-r2,lr}             @ save  registers \n    cmp r0,#0\n    beq 5f\n    movlt r0,#-1               @ error\n    blt 100f\n    cmp r1,#0\n    movlt r0,#-1               @ error\n    blt 100f\n    bgt 1f\n    sub r0,r0,#1\n    mov r1,#1\n    bl ackermann\n    b 100f\n1:\n    mov r2,r0\n    sub r1,r1,#1\n    bl ackermann\n    mov r1,r0\n    sub r0,r2,#1\n    bl ackermann\n    b 100f\n5:\n    adds r0,r1,#1\n    bcc 100f\n    ldr r0,iAdrszMessError\n    bl affichageMess\n    bkpt\n100:\n    pop {r1-r2,lr}             @ restaur registers\n    bx lr                      @ return\niAdrszMessError:        .int szMessError\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nResult for 0            0           \u00a0: 1\nResult for 0            1           \u00a0: 2\nResult for 0            2           \u00a0: 3\nResult for 0            3           \u00a0: 4\nResult for 0            4           \u00a0: 5\nResult for 0            5           \u00a0: 6\nResult for 0            6           \u00a0: 7\nResult for 0            7           \u00a0: 8\nResult for 0            8           \u00a0: 9\nResult for 0            9           \u00a0: 10\nResult for 1            0           \u00a0: 2\nResult for 1            1           \u00a0: 3\nResult for 1            2           \u00a0: 4\nResult for 1            3           \u00a0: 5\nResult for 1            4           \u00a0: 6\nResult for 1            5           \u00a0: 7\nResult for 1            6           \u00a0: 8\nResult for 1            7           \u00a0: 9\nResult for 1            8           \u00a0: 10\nResult for 1            9           \u00a0: 11\nResult for 2            0           \u00a0: 3\nResult for 2            1           \u00a0: 5\nResult for 2            2           \u00a0: 7\nResult for 2            3           \u00a0: 9\nResult for 2            4           \u00a0: 11\nResult for 2            5           \u00a0: 13\nResult for 2            6           \u00a0: 15\nResult for 2            7           \u00a0: 17\nResult for 2            8           \u00a0: 19\nResult for 2            9           \u00a0: 21\nResult for 3            0           \u00a0: 5\nResult for 3            1           \u00a0: 13\nResult for 3            2           \u00a0: 29\nResult for 3            3           \u00a0: 61\nResult for 3            4           \u00a0: 125\nResult for 3            5           \u00a0: 253\nResult for 3            6           \u00a0: 509\nResult for 3            7           \u00a0: 1021\nResult for 3            8           \u00a0: 2045\nResult for 3            9           \u00a0: 4093\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "X86_Assembly", "code": "\nWorks with: nasm\nWorks with: windows\nsection .text\n\nglobal _main\n_main:\n    mov eax, 3 ;m\n    mov ebx, 4 ;n\n    call ack ;returns number in ebx\n    ret\n    \nack:\n    cmp eax, 0\n    je M0 ;if M == 0\n    cmp ebx, 0\n    je N0 ;if N == 0\n    dec ebx ;else N-1\n    push eax ;save M\n    call ack1 ;ack(m,n) -> returned in ebx so no further instructions needed\n    pop eax ;restore M\n    dec eax ;M - 1\n    call ack1 ;return ack(m-1,ack(m,n-1))\n    ret\n    M0:\n        inc ebx ;return n + 1\n        ret\n    N0:\n        dec eax\n        inc ebx ;ebx always 0: inc -> ebx = 1\n        call ack1 ;return ack(M-1,1)\n        ret\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nfunction Ackermann(m,n:Int64):Int64;\nbegin\n    if m = 0 then\n        Result := n + 1\n    else if n = 0 then\n        Result := Ackermann(m-1, 1)\n    else\n        Result := Ackermann(m-1, Ackermann(m, n - 1));\nend;\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nTranslation of: Ada\ndef ack(m, n)\n  if m == 0\n    n + 1\n  elsif n == 0\n    ack(m-1, 1)\n  else\n    ack(m-1, ack(m, n-1))\n  end\nend\n\n(0..3).each do |m|\n  puts (0..6).map { |n| ack(m, n) }.join(' ')\nend\n\nOutput:\n 1 2 3 4 5 6 7 \n 2 3 4 5 6 7 8 \n 3 5 7 9 11 13 15 \n 5 13 29 61 125 253 509\n", "explain": "Example:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nfn ack(m: isize, n: isize) -> isize {\n    if m == 0 {\n        n + 1\n    } else if n == 0 {\n        ack(m - 1, 1)\n    } else {\n        ack(m - 1, ack(m, n - 1))\n    }\n}\n\nfn main() {\n    let a = ack(3, 4);\n    println!(\"{}\", a); // 125\n}\n\nfn ack(m: u64, n: u64) -> u64 {\n\tmatch (m, n) {\n\t\t(0, n) => n + 1,\n\t\t(m, 0) => ack(m - 1, 1),\n\t\t(m, n) => ack(m - 1, ack(m, n - 1)),\n\t}\n}\n", "explain": "Or: \n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nfunc ackerman(m:Int, n:Int) -> Int {\n    if m == 0 {\n        return n+1\n    } else if n == 0 {\n        return ackerman(m-1, 1)\n    } else {\n        return ackerman(m-1, ackerman(m, n-1))\n    }\n}\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nackermann <- function(m, n) {\n  if ( m == 0 ) {\n    n+1\n  } else if ( n == 0 ) {\n    ackermann(m-1, 1)\n  } else {\n    ackermann(m-1, ackermann(m, n-1))\n  }\n}\nfor ( i in 0:3 ) {\n  print(ackermann(i, 4))\n}\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Ackermann.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  M          USAGE UNSIGNED-LONG.\n       01  N          USAGE UNSIGNED-LONG.\n\n       01  Return-Val USAGE UNSIGNED-LONG.\n\n       PROCEDURE DIVISION USING M N Return-Val.\n           EVALUATE M ALSO N\n               WHEN 0 ALSO ANY\n                   ADD 1 TO N GIVING Return-Val\n\n               WHEN NOT 0 ALSO 0\n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT 1\n                       BY REFERENCE Return-Val\n\n               WHEN NOT 0 ALSO NOT 0\n                   SUBTRACT 1 FROM N\n                   CALL \"Ackermann\" USING BY CONTENT M BY CONTENT N\n                       BY REFERENCE Return-Val\n                       \n                   SUBTRACT 1 FROM M\n                   CALL \"Ackermann\" USING BY CONTENT M\n                       BY CONTENT Return-Val BY REFERENCE Return-Val\n           END-EVALUATE\n\n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic", "code": "\nTranslation of: Rexx\nWorks with: Visual Basic version VB6 Standard\nOption Explicit\nDim calls As Long\nSub main()\n    Const maxi = 4\n    Const maxj = 9\n    Dim i As Long, j As Long\n    For i = 0 To maxi\n        For j = 0 To maxj\n            Call print_acker(i, j)\n        Next j\n    Next i\nEnd Sub 'main\nSub print_acker(m As Long, n As Long)\n    calls = 0\n    Debug.Print \"ackermann(\"; m; \",\"; n; \")=\";\n    Debug.Print ackermann(m, n), \"calls=\"; calls\nEnd Sub 'print_acker\nFunction ackermann(m As Long, n As Long) As Long\n    calls = calls + 1\n    If m = 0 Then\n        ackermann = n + 1\n    Else\n        If n = 0 Then\n            ackermann = ackermann(m - 1, 1)\n        Else\n            ackermann = ackermann(m - 1, ackermann(m, n - 1))\n        End If\n    End If\nEnd Function 'ackermann\n\nOutput:\nackermann( 0 , 0 )= 1       calls= 1 \nackermann( 0 , 1 )= 2       calls= 1 \nackermann( 0 , 2 )= 3       calls= 1 \nackermann( 0 , 3 )= 4       calls= 1 \nackermann( 0 , 4 )= 5       calls= 1 \nackermann( 0 , 5 )= 6       calls= 1 \nackermann( 0 , 6 )= 7       calls= 1 \nackermann( 0 , 7 )= 8       calls= 1 \nackermann( 0 , 8 )= 9       calls= 1 \nackermann( 0 , 9 )= 10      calls= 1 \nackermann( 1 , 0 )= 2       calls= 2 \nackermann( 1 , 1 )= 3       calls= 4 \nackermann( 1 , 2 )= 4       calls= 6 \nackermann( 1 , 3 )= 5       calls= 8 \nackermann( 1 , 4 )= 6       calls= 10 \nackermann( 1 , 5 )= 7       calls= 12 \nackermann( 1 , 6 )= 8       calls= 14 \nackermann( 1 , 7 )= 9       calls= 16 \nackermann( 1 , 8 )= 10      calls= 18 \nackermann( 1 , 9 )= 11      calls= 20 \nackermann( 2 , 0 )= 3       calls= 5 \nackermann( 2 , 1 )= 5       calls= 14 \nackermann( 2 , 2 )= 7       calls= 27 \nackermann( 2 , 3 )= 9       calls= 44 \nackermann( 2 , 4 )= 11      calls= 65 \nackermann( 2 , 5 )= 13      calls= 90 \nackermann( 2 , 6 )= 15      calls= 119 \nackermann( 2 , 7 )= 17      calls= 152 \nackermann( 2 , 8 )= 19      calls= 189 \nackermann( 2 , 9 )= 21      calls= 230 \nackermann( 3 , 0 )= 5       calls= 15 \nackermann( 3 , 1 )= 13      calls= 106 \nackermann( 3 , 2 )= 29      calls= 541 \nackermann( 3 , 3 )= 61      calls= 2432 \nackermann( 3 , 4 )= 125     calls= 10307 \nackermann( 3 , 5 )= 253     calls= 42438 \nackermann( 3 , 6 )= 509     calls= 172233 \nackermann( 3 , 7 )= 1021    calls= 693964 \nackermann( 3 , 8 )= 2045    calls= 2785999 \nackermann( 3 , 9 )= 4093    calls= 11164370 \nackermann( 4 , 0 )= 13      calls= 107 \nackermann( 4 , 1 )= out of stack space\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Ackermann is\n   function Ackermann (M, N : Natural) return Natural is\n   begin\n      if M = 0 then\n         return N + 1;\n      elsif N = 0 then\n         return Ackermann (M - 1, 1);\n      else\n         return Ackermann (M - 1, Ackermann (M, N - 1));\n      end if;\n   end Ackermann;\nbegin\n   for M in 0..3 loop\n      for N in 0..6 loop\n         Put (Natural'Image (Ackermann (M, N)));\n      end loop;\n      New_Line;\n   end loop;\nend Test_Ackermann;\n\n\n\nOutput: the first 4x7 Ackermann's numbers\n\n 1 2 3 4 5 6 7\n 2 3 4 5 6 7 8\n 3 5 7 9 11 13 15\n 5 13 29 61 125 253 509\n", "explain": "The implementation does not care about arbitrary precision numbers because the Ackermann function does not only grow, but also slow quickly, when computed recursively. \n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nfunction ack(m,n)\n    if m == 0\n        return n + 1\n    elseif n == 0\n        return ack(m-1,1)\n    else\n        return ack(m-1,ack(m,n-1))\n    end\nend\n\nack2(m::Integer, n::Integer) = m == 0\u00a0? n + 1\u00a0: n == 0\u00a0? ack2(m - 1, 1)\u00a0: ack2(m - 1, ack2(m, n - 1))\n\nusing Memoize\n@memoize ack3(m::Integer, n::Integer) = m == 0\u00a0? n + 1\u00a0: n == 0\u00a0? ack3(m - 1, 1)\u00a0: ack3(m - 1, ack3(m, n - 1))\n\njulia> @time ack2(4,1)\nelapsed time: 71.98668457 seconds (96 bytes allocated)\n65533\n\njulia> @time ack3(4,1)\nelapsed time: 0.49337724 seconds (30405308 bytes allocated)\n65533\n", "explain": "One-liner:\nUsing memoization, source:\nBenchmarking:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\ntailrec fun A(m: Long, n: Long): Long {\n    require(m >= 0L) { \"m must not be negative\" }\n    require(n >= 0L) { \"n must not be negative\" }\n    if (m == 0L) {\n        return n + 1L\n    }\n    if (n == 0L) {\n        return A(m - 1L, 1L)\n    }\n    return A(m - 1L, A(m, n - 1L))\n}\n\ninline fun<T> tryOrNull(block: () -> T): T? = try { block() } catch (e: Throwable) { null }\n\nconst val N = 10L\nconst val M = 4L\n\nfun main() {\n    (0..M)\n        .map { it to 0..N }\n        .map { (m, Ns) -> (m to Ns) to Ns.map { n -> tryOrNull { A(m, n) } } }\n        .map { (input, output) -> \"A(${input.first}, ${input.second})\" to output.map { it?.toString()\u00a0?: \"?\" } }\n        .map { (input, output) -> \"$input = $output\" }\n        .forEach(::println)\n}\n\nOutput:\nA(0, 0..10) = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11]\nA(1, 0..10) = [2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12]\nA(2, 0..10) = [3, 5, 7, 9, 11, 13, 15, 17, 19, 21, 23]\nA(3, 0..10) = [5, 13, 29, 61, 125, 253, 509, 1021, 2045, 4093, 8189]\nA(4, 0..10) = [13,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?,\u00a0?]\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\n{\n    my @memo;\n    sub A {\n        my( $m, $n ) = @_;\n        $memo[ $m ][ $n ] and return $memo[ $m ][ $n ];\n        $m or return $n + 1;\n        return $memo[ $m ][ $n ] = (\n            $n\n              \u00a0? A( $m - 1, A( $m, $n - 1 ) )\n              \u00a0: A( $m - 1, 1 )\n        );\n    }\n}\n\nsub A {\n    my ($m, $n) = @_;\n    if    ($m == 0) { $n + 1 }\n    elsif ($n == 0) { A($m - 1, 1) }\n    else            { A($m - 1, A($m, $n - 1)) }\n}\n\nsub A {\n  my ($m, $n) = @_;\n  $m == 0\u00a0? $n + 1\u00a0:\n  $n == 0\u00a0? A($m - 1, 1)\u00a0:\n            A($m - 1, A($m, $n - 1))\n}\n\nuse Memoize;  memoize('ack2');\nuse bigint try=>\"GMP\";\n\nsub ack2 {\n   my ($m, $n) = @_;\n   $m == 0\u00a0? $n + 1\u00a0:\n   $m == 1\u00a0? $n + 2\u00a0:\n   $m == 2\u00a0? 2*$n + 3\u00a0:\n   $m == 3\u00a0? 8 * (2**$n - 1) + 5\u00a0:\n   $n == 0\u00a0? ack2($m-1, 1)\n          \u00a0: ack2($m-1, ack2($m, $n-1));\n}\nprint \"ack2(3,4) is \", ack2(3,4), \"\\n\";\nprint \"ack2(4,1) is \", ack2(4,1), \"\\n\";\nprint \"ack2(4,2) has \", length(ack2(4,2)), \" digits\\n\";\n\nOutput:\nack2(3,4) is 125\nack2(4,1) is 65533\nack2(4,2) has 19729 digits\n\nuse strict;\nuse warnings;\nuse Math::BigInt;\n\nuse constant two => Math::BigInt->new(2);\n\nsub ack {\n\tmy $n = pop;\n\twhile( @_ ) {\n\t\tmy $m = pop;\n\t\tif( $m > 3 ) {\n\t\t\tpush @_, (--$m) x $n;\n\t\t\tpush @_, reverse 3 .. --$m;\n\t\t\t$n = 13;\n\t\t} elsif( $m == 3 ) {\n\t\t\tif( $n < 29 ) {\n\t\t\t\t$n = ( 1 << ( $n + 3 ) ) - 3;\n\t\t\t} else {\n\t\t\t\t$n = two ** ( $n + 3 ) - 3;\n\t\t\t}\n\t\t} elsif( $m == 2 ) {\n\t\t\t$n = 2 * $n + 3;\n\t\t} elsif( $m >= 0 ) {\n\t\t\t$n = $n + $m + 1;\n\t\t} else {\n\t\t\tdie \"negative m!\";\n\t\t}\n\t}\n\t$n;\n}\n \nprint \"ack(3,4) is \", ack(3,4), \"\\n\";\nprint \"ack(4,1) is \", ack(4,1), \"\\n\";\nprint \"ack(4,2) has \", length(ack(4,2)), \" digits\\n\";\n", "explain": "We memoize calls to A to make A(2, n) and A(3, n) feasible for larger values of n.\nAn implementation using the conditional statements 'if', 'elsif' and 'else':\nAn implementation using ternary chaining: \nAdding memoization and extra terms:\nAn optimized version, which uses @_ as a stack,\ninstead of recursion.  Very fast.\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\n:- table ack/3.\u00a0% memoization reduces the execution time of ack(4,1,X) from several\n               \u00a0% minutes to about one second on a typical desktop computer.\nack(0, N, Ans)\u00a0:- Ans is N+1.\nack(M, 0, Ans)\u00a0:- M>0, X is M-1, ack(X, 1, Ans).\nack(M, N, Ans)\u00a0:- M>0, N>0, X is M-1, Y is N-1, ack(M, Y, Ans2), ack(X, Ans2, Ans).\n\nack(0,N,s(N)).\nack(s(M),0,P):- ack(M,s(0),P).\nack(s(M),s(N),P):- ack(s(M),N,S), ack(M,S,P).\n\n% Peano's first axiom in Prolog is that s(0) AND s(s(N)):- s(N)\n% Thanks to this we don't need explicit N > 0 checks.\n% Nor explicit arithmetic operations like X is M-1.\n% Recursion and unification naturally decrement s(N) to N.\n% But: Prolog clauses are relations and cannot be replaced by their result, like functions.\n% Because of this we do need an extra argument to hold the output of the function.\n% And we also need an additional call to the function in the last clause.\n\n% Example input/output:\n%\u00a0?- ack(s(0),s(s(0)),P).\n% P = s(s(s(s(0))))\u00a0;\n% false.\n", "explain": "\"Pure\" Prolog Version (Uses Peano arithmetic instead of is/2):\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction ack(M,N)\n    if M == 0 then return N + 1 end\n    if N == 0 then return ack(M-1,1) end\n    return ack(M-1,ack(M, N-1))\nend\nStackless iterative solution with multiple precision, fast[edit]\n \n#!/usr/bin/env luajit\nlocal gmp = require 'gmp' ('libgmp')\nlocal mpz, \t\tz_mul, \t\tz_add, \t\tz_add_ui, \t\tz_set_d = \n\tgmp.types.z, gmp.z_mul,\tgmp.z_add,\tgmp.z_add_ui, \tgmp.z_set_d\nlocal z_cmp, \tz_cmp_ui, \t\tz_init_d, \t\t\tz_set=\n\tgmp.z_cmp,\tgmp.z_cmp_ui, \tgmp.z_init_set_d, \tgmp.z_set\nlocal printf = gmp.printf\n\nlocal function ack(i,n)\n\tlocal nxt=setmetatable({},  {__index=function(t,k) local z=mpz() z_init_d(z, 0) t[k]=z return z end})\n\tlocal goal=setmetatable({}, {__index=function(t,k) local o=mpz() z_init_d(o, 1) t[k]=o return o end})\n\tgoal[i]=mpz() z_init_d(goal[i], -1)\n\tlocal v=mpz() z_init_d(v, 0) \n\tlocal ic\n\tlocal END=n+1\n\tlocal ntmp,gtmp\n\trepeat\n\t\tic=0\n\t\tntmp,gtmp=nxt[ic], goal[ic]\n\t\tz_add_ui(v, ntmp, 1)\n\t\twhile z_cmp(ntmp, gtmp) == 0 do\n\t\t\tz_set(gtmp,v)\n\t\t\tz_add_ui(ntmp, ntmp, 1)\n\t\t\tnxt[ic], goal[ic]=ntmp, gtmp\n\t\t\tic=ic+1\n\t\t\tntmp,gtmp=nxt[ic], goal[ic]\n\t\tend\n\t\tz_add_ui(ntmp, ntmp, 1)\n\t\tnxt[ic]=ntmp\n\tuntil z_cmp_ui(nxt[i], END) == 0\n\treturn v\nend\n\nif #arg<1 then\n\tprint(\"Ackermann: \"..arg[0]..\" <num1> [num2]\")\nelse\n\tprintf(\"%Zd\\n\", ack(tonumber(arg[1]), arg[2] and tonumber(arg[2]) or 0))\nend\n\nOutput:\n> time ./ackermann_iter.lua 4 1\n65533\n./ackermann_iter.lua 4 1  0,01s user 0,01s system 95% cpu 0,015 total // AMD FX-8350@4 GHz\n> time ./ackermann.lua 3 10                                              \u23ce\n8189\n./ackermann.lua 3 10  0,22s user 0,00s system 98% cpu 0,222 total // recursive solution\n> time ./ackermann_iter.lua 3 10\n8189\n./ackermann_iter.lua 3 10  0,00s user 0,00s system 92% cpu 0,009 total\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef ack(m: BigInt, n: BigInt): BigInt = {\n  if (m==0) n+1\n  else if (n==0) ack(m-1, 1)\n  else ack(m-1, ack(m, n-1))\n}\n\nExample:\nscala> for ( m <- 0 to 3; n <- 0 to 6 ) yield ack(m,n)\nres0: Seq.Projection[BigInt] = RangeG(1, 2, 3, 4, 5, 6, 7, 2, 3, 4, 5, 6, 7, 8, 3, 5, 7, 9, 11, 13, 15, 5, 13, 29, 61, 125, 253, 509)\n\n\nval ackMap = new mutable.HashMap[(BigInt,BigInt),BigInt]\ndef ackMemo(m: BigInt, n: BigInt): BigInt = {\n  ackMap.getOrElseUpdate((m,n), ack(m,n))\n}\n", "explain": "Memoized version using a mutable hash map:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\n\nint A(int m, int n) => m==0 ? n+1 : n==0 ? A(m-1,1) : A(m-1,A(m,n-1));\n\nmain() {\n  print(A(0,0));\n  print(A(1,0));\n  print(A(0,1));\n  print(A(2,2));\n  print(A(2,3));\n  print(A(3,3));\n  print(A(3,4));\n  print(A(3,5));\n  print(A(4,0));\n}\n\n", "explain": "no caching, the implementation takes ages even for A(4,1)\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nBasic version[edit]\nulong ackermann(in ulong m, in ulong n) pure nothrow @nogc {\n    if (m == 0)\n        return n + 1;\n    if (n == 0)\n        return ackermann(m - 1, 1);\n    return ackermann(m - 1, ackermann(m, n - 1));\n}\n\nvoid main() {\n    assert(ackermann(2, 4) == 11);\n}\n\nMore Efficient Version[edit]\nTranslation of: Mathematica\nimport std.stdio, std.bigint, std.conv;\n\nBigInt ipow(BigInt base, BigInt exp) pure nothrow {\n    auto result = 1.BigInt;\n    while (exp) {\n        if (exp & 1)\n            result *= base;\n        exp >>= 1;\n        base *= base;\n    }\n\n    return result;\n}\n\nBigInt ackermann(in uint m, in uint n) pure nothrow\nout(result) {\n    assert(result >= 0);\n} body {\n    static BigInt ack(in uint m, in BigInt n) pure nothrow {\n        switch (m) {\n            case 0: return n + 1;\n            case 1: return n + 2;\n            case 2: return 3 + 2 * n;\n            //case 3: return 5 + 8 * (2 ^^ n - 1);\n            case 3: return 5 + 8 * (ipow(2.BigInt, n) - 1);\n            default: return (n == 0) ?\n                        ack(m - 1, 1.BigInt) :\n                        ack(m - 1, ack(m, n - 1));\n        }\n    }\n\n    return ack(m, n.BigInt);\n}\n\nvoid main() {\n    foreach (immutable m; 1 .. 4)\n        foreach (immutable n; 1 .. 9)\n            writefln(\"ackermann(%d, %d): %s\", m, n, ackermann(m, n));\n    writefln(\"ackermann(4, 1): %s\", ackermann(4, 1));\n\n    immutable a = ackermann(4, 2).text;\n    writefln(\"ackermann(4, 2)) (%d digits):\\n%s...\\n%s\",\n             a.length, a[0 .. 94], a[$ - 96 .. $]);\n}\n\n\nOutput:\nackermann(1, 1): 3\nackermann(1, 2): 4\nackermann(1, 3): 5\nackermann(1, 4): 6\nackermann(1, 5): 7\nackermann(1, 6): 8\nackermann(1, 7): 9\nackermann(1, 8): 10\nackermann(2, 1): 5\nackermann(2, 2): 7\nackermann(2, 3): 9\nackermann(2, 4): 11\nackermann(2, 5): 13\nackermann(2, 6): 15\nackermann(2, 7): 17\nackermann(2, 8): 19\nackermann(3, 1): 13\nackermann(3, 2): 29\nackermann(3, 3): 61\nackermann(3, 4): 125\nackermann(3, 5): 253\nackermann(3, 6): 509\nackermann(3, 7): 1021\nackermann(3, 8): 2045\nackermann(4, 1): 65533\nackermann(4, 2)) (19729 digits):\n2003529930406846464979072351560255750447825475569751419265016973710894059556311453089506130880...\n699146577530041384717124577965048175856395072895337539755822087777506072339445587895905719156733\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nack :: Int -> Int -> Int\nack 0 n = succ n\nack m 0 = ack (pred m) 1\nack m n = ack (pred m) (ack m (pred n))\n\nmain :: IO ()\nmain = mapM_ print $ uncurry ack <$> [(0, 0), (3, 4)]\n\n\nOutput:\n1\n125\n\nimport Data.List (mapAccumL)\n\n-- everything here are [Int] or [[Int]], which would overflow\n-- * had it not overrun the stack first *\nackermann = iterate ack [1..] where\n\tack a = s where\n\t\ts = snd $ mapAccumL f (tail a) (1 : zipWith (-) s (1:s))\n\tf a b = (aa, head aa) where aa = drop b a\n\nmain = mapM_ print $ map (\\n -> take (6 - n) $ ackermann !! n) [0..5]\n\n", "explain": "Generating a list instead:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "PL/SQL", "code": "\nDECLARE\n\n  FUNCTION ackermann(pi_m IN NUMBER,\n                     pi_n IN NUMBER) RETURN NUMBER IS\n  BEGIN\n    IF pi_m = 0 THEN\n      RETURN pi_n + 1;\n    ELSIF pi_n = 0 THEN\n      RETURN ackermann(pi_m - 1, 1);\n    ELSE\n      RETURN ackermann(pi_m - 1, ackermann(pi_m, pi_n - 1));\n    END IF;\n  END ackermann;\n\nBEGIN\n  FOR n IN 0 .. 6 LOOP\n    FOR m IN 0 .. 3 LOOP\n      dbms_output.put_line('A(' || m || ',' || n || ') = ' || ackermann(m, n));\n    END LOOP;\n  END LOOP;\nEND;\n\nOutput:\nA(0,0) = 1\nA(1,0) = 2\nA(2,0) = 3\nA(3,0) = 5\nA(0,1) = 2\nA(1,1) = 3\nA(2,1) = 5\nA(3,1) = 13\nA(0,2) = 3\nA(1,2) = 4\nA(2,2) = 7\nA(3,2) = 29\nA(0,3) = 4\nA(1,3) = 5\nA(2,3) = 9\nA(3,3) = 61\nA(0,4) = 5\nA(1,4) = 6\nA(2,4) = 11\nA(3,4) = 125\nA(0,5) = 6\nA(1,5) = 7\nA(2,5) = 13\nA(3,5) = 253\nA(0,6) = 7\nA(1,6) = 8\nA(2,6) = 15\nA(3,6) = 509\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\n\nImplementation\noption explicit\n'~ dim depth\nfunction ack(m, n)\n\t'~ wscript.stdout.write depth & \" \"\n\tif m = 0 then \n\t\t'~ depth = depth + 1\n\t\tack = n + 1\n\t\t'~ depth = depth - 1\n\telseif m > 0 and n = 0 then\n\t\t'~ depth = depth + 1\n\t\tack = ack(m - 1, 1)\n\t\t'~ depth = depth - 1\n\t'~ elseif m > 0 and n > 0 then\n\telse\n\t\t'~ depth = depth + 1\n\t\tack = ack(m - 1, ack(m, n - 1))\n\t\t'~ depth = depth - 1\n\tend if\n\t\nend function\nInvocation\nwscript.echo ack( 1, 10 )\n'~ depth = 0\nwscript.echo ack( 2, 1 )\n'~ depth = 0\nwscript.echo ack( 4, 4 )\n\nOutput:\n12\n5\nC:\\foo\\ackermann.vbs(16, 3) Microsoft VBScript runtime error: Out of stack space: 'ack'\n\n", "explain": "Based on BASIC version. Uncomment all the lines referring to depth and see just how deep the recursion goes.\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n(define (A m n)\n    (cond\n        ((= m 0) (+ n 1))\n        ((= n 0) (A (- m 1) 1))\n        (else (A (- m 1) (A m (- n 1))))))\n\n(define (A m n)\n  (letrec ((A-stream\n    (cons-stream\n      (ints-from 1)\u00a0;; m = 0\n      (cons-stream\n        (ints-from 2)\u00a0;; m = 1\n        (cons-stream\n         \u00a0;; m = 2\n          (stream-map (lambda (n)\n                        (1+ (* 2 (1+ n))))\n                      (ints-from 0))\n          (cons-stream\n           \u00a0;; m = 3\n            (stream-map (lambda (n)\n                          (- (knuth-up-arrow 2 (- m 2) (+ n 3)) 3))\n                        (ints-from 0))\n            \u00a0;; m = 4...\n            (stream-tail A-stream 3)))))))\n    (stream-ref (stream-ref A-stream m) n)))\n\n(define (ints-from n)\n  (letrec ((ints-rec (cons-stream n (stream-map 1+ ints-rec))))\n    ints-rec))\n\n(define (knuth-up-arrow a n b)\n  (let loop ((n n) (b b))\n    (cond ((= b 0) 1)\n          ((= n 1) (expt a b))\n          (else    (loop (-1+ n) (loop n (-1+ b)))))))\n", "explain": "An improved solution that uses a lazy data structure, streams, and defines Knuth up-arrows to calculate iterative exponentiation:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nTranslation of: PHP\nfunction ackermann ([long] $m, [long] $n) {\n    if ($m -eq 0) {\n        return $n + 1\n    }\n    \n    if ($n -eq 0) {\n        return (ackermann ($m - 1) 1)\n    }\n    \n    return (ackermann ($m - 1) (ackermann $m ($n - 1)))\n}\n\nforeach ($m in 0..3) {\n    foreach ($n in 0..6) {\n        Write-Host -NoNewline (\"{0,5}\" -f (ackermann $m $n))\n    }\n    Write-Host\n}\n\nOutput:\n    1    2    3    4    5    6    7\n    2    3    4    5    6    7    8\n    3    5    7    9   11   13   15\n    5   13   29   61  125  253  509\nA More \"PowerShelly\" Way[edit]\nfunction Get-Ackermann ([int64]$m, [int64]$n)\n{\n    if ($m -eq 0)\n    {\n        return $n + 1\n    }\n \n    if ($n -eq 0)\n    {\n        return Get-Ackermann ($m - 1) 1\n    }\n \n    return (Get-Ackermann ($m - 1) (Get-Ackermann $m ($n - 1)))\n}\n\n$ackermann = 0..3 | ForEach-Object {$m = $_; 0..6 | ForEach-Object {Get-Ackermann $m  $_}}\n\n$ackermann | Format-Wide {\"{0,3}\" -f $_} -Column 7 -Force\n\nOutput:\n  1                   2                  3                  4                  5                  6                  7               \n  2                   3                  4                  5                  6                  7                  8               \n  3                   5                  7                  9                 11                 13                 15               \n  5                  13                 29                 61                125                253                509               \n\n", "explain": "Building an example table (takes a while to compute, though, especially for the last three numbers; also it fails with the last line in Powershell v1 since the maximum recursion depth is only 100 there):\nSave the result to an array (for possible future use?), then display it using the Format-Wide cmdlet:\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto ack :i :j\n  if :i = 0 [output :j+1]\n  if :j = 0 [output ack :i-1 1]\n  output ack :i-1 ack :i :j-1\nend\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "ABAP", "code": "\nREPORT  zhuberv_ackermann.\n\nCLASS zcl_ackermann DEFINITION.\n  PUBLIC SECTION.\n    CLASS-METHODS ackermann IMPORTING m TYPE i\n                                      n TYPE i\n                            RETURNING value(v) TYPE i.\nENDCLASS.            \"zcl_ackermann DEFINITION\n\n\nCLASS zcl_ackermann IMPLEMENTATION.\n\n  METHOD: ackermann.\n\n    DATA: lv_new_m TYPE i,\n          lv_new_n TYPE i.\n\n    IF m = 0.\n      v = n + 1.\n    ELSEIF m > 0 AND n = 0.\n      lv_new_m = m - 1.\n      lv_new_n = 1.\n      v = ackermann( m = lv_new_m n = lv_new_n ).\n    ELSEIF m > 0 AND n > 0.\n      lv_new_m = m - 1.\n\n      lv_new_n = n - 1.\n      lv_new_n = ackermann( m = m n = lv_new_n ).\n\n      v = ackermann( m = lv_new_m n = lv_new_n ).\n    ENDIF.\n\n  ENDMETHOD.                    \"ackermann\n\nENDCLASS.                    \"zcl_ackermann IMPLEMENTATION\n\n\nPARAMETERS: pa_m TYPE i,\n            pa_n TYPE i.\n\nDATA: lv_result TYPE i.\n\nSTART-OF-SELECTION.\n  lv_result = zcl_ackermann=>ackermann( m = pa_m n = pa_n ).\n  WRITE: / lv_result.\n\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nlet rec ackermann m n = \n    match m, n with\n    | 0, n -> n + 1\n    | m, 0 -> ackermann (m - 1) 1\n    | m, n -> ackermann (m - 1) ackermann m (n - 1)\n\ndo\n    printfn \"%A\" (ackermann (int fsi.CommandLineArgs.[1]) (int fsi.CommandLineArgs.[2]))\n\n\nlet ackermann M N =\n    let rec acker (m, n, k) =\n        match m,n with\n            | 0, n -> k(n + 1)\n            | m, 0 -> acker ((m - 1), 1, k)\n            | m, n -> acker (m, (n - 1), (fun x -> acker ((m - 1), x, k)))\n    acker (M, N, (fun x -> x))\n\n", "explain": "The following program implements the Ackermann function in F# but is not tail-recursive and so runs out of stack space quite fast.\nTransforming this into continuation passing style avoids limited stack space by permitting tail-recursion.\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\ndef ack ( m, n ) {\n    assert m >= 0 && n >= 0 : 'both arguments must be non-negative'\n    m == 0 ? n + 1 : n == 0 ? ack(m-1, 1) : ack(m-1, ack(m, n-1))\n}\n\n\ndef ackMatrix = (0..3).collect { m -> (0..8).collect { n -> ack(m, n) } }\nackMatrix.each { it.each { elt -> printf \"%7d\", elt }; println() }\n\n\nOutput:\n      1      2      3      4      5      6      7      8      9\n      2      3      4      5      6      7      8      9     10\n      3      5      7      9     11     13     15     17     19\n      5     13     29     61    125    253    509   1021   2045\n\n", "explain": "Test program:\nNote: In the default groovyConsole configuration for WinXP, \"ack(4,1)\" caused a stack overflow error!\n"}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "Zig", "code": "\npub fn ack(m: u64, n: u64) u64 {\n    if (m == 0) return n + 1;\n    if (n == 0) return ack(m - 1, 1);\n    return ack(m - 1, ack(m, n - 1));\n}\n\npub fn main() !void {\n    const stdout = @import(\"std\").io.getStdOut().writer();\n\n    var m: u8 = 0;\n    while (m <= 3)\u00a0: (m += 1) {\n        var n: u8 = 0;\n        while (n <= 8)\u00a0: (n += 1)\n            try stdout.print(\"{d:>8}\", .{ack(m, n)});\n        try stdout.print(\"\\n\", .{});\n    }\n}\n\nOutput:\n       1       2       3       4       5       6       7       8       9\n       2       3       4       5       6       7       8       9      10\n       3       5       7       9      11      13      15      17      19\n       5      13      29      61     125     253     509    1021    2045\n", "explain": ""}, {"task_name": "Ackermann function", "task_url": "https://rosettacode.org/wiki/Ackermann_function", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\nfunction ackermann(m, n) \n{\n  if ( m == 0 ) { \n    return n+1\n  }\n  if ( n == 0 ) { \n    return ackermann(m-1, 1)\n  }\n  return ackermann(m-1, ackermann(m, n-1))\n}\n\nBEGIN {\n  for(n=0; n < 7; n++) {\n    for(m=0; m < 4; m++) {\n      print \"A(\" m \",\" n \") = \" ackermann(m,n)\n    }\n  }\n}\n\n", "explain": ""}]