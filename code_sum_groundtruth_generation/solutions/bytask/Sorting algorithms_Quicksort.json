[{"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Python", "code": "\ndef quickSort(arr):\n    less = []\n    pivotList = []\n    more = []\n    if len(arr) <= 1:\n        return arr\n    else:\n        pivot = arr[0]\n        for i in arr:\n            if i < pivot:\n                less.append(i)\n            elif i > pivot:\n                more.append(i)\n            else:\n                pivotList.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + pivotList + more\n\na = [4, 65, 2, -31, 0, 99, 83, 782, 1]\na = quickSort(a)\n\ndef qsort(L):\n    return (qsort([y for y in L[1:] if y <  L[0]]) + \n            [L[0]] + \n            qsort([y for y in L[1:] if y >= L[0]])) if len(L) > 1 else L\n\ndef qsort(list):\n    if not list:\n        return []\n    else:\n        pivot = list[0]\n        less = [x for x in list[1:]   if x <  pivot]\n        more = [x for x in list[1:] if x >= pivot]\n        return qsort(less) + [pivot] + qsort(more)\n\nfrom random import *\n\ndef qSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        q = choice(a)\n        return qSort([elem for elem in a if elem < q]) + [q] * a.count(q) + qSort([elem for elem in a if elem > q])\n\ndef quickSort(a):\n    if len(a) <= 1:\n        return a\n    else:\n        less = []\n        more = []\n        pivot = choice(a)\n        for i in a:\n            if i < pivot:\n                less.append(i)\n            if i > pivot:\n                more.append(i)\n        less = quickSort(less)\n        more = quickSort(more)\n        return less + [pivot] * a.count(pivot) + more\n\ndef qsort(array):\n    if len(array) < 2:\n        return array\n    head, *tail = array\n    less = qsort([i for i in tail if i < head])\n    more = qsort([i for i in tail if i >= head])\n    return less + [head] + more\n\ndef quicksort(array):\n    _quicksort(array, 0, len(array) - 1)\n\ndef _quicksort(array, start, stop):\n    if stop - start > 0:\n        pivot, left, right = array[start], start, stop\n        while left <= right:\n            while array[left] < pivot:\n                left += 1\n            while array[right] > pivot:\n                right -= 1\n            if left <= right:\n                array[left], array[right] = array[right], array[left]\n                left += 1\n                right -= 1\n        _quicksort(array, start, right)\n        _quicksort(array, left, stop)\n", "explain": "In a Haskell fashion --\nMore readable, but still using list comprehensions:\nMore correctly in some tests:\n\nReturning a new list:\nSorting a list in place:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "C", "code": "\n#include <stdio.h>\n\nvoid quicksort(int *A, int len);\n\nint main (void) {\n  int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};\n  int n = sizeof a / sizeof a[0];\n\n  int i;\n  for (i = 0; i < n; i++) {\n    printf(\"%d \", a[i]);\n  }\n  printf(\"\\n\");\n\n  quicksort(a, n);\n\n  for (i = 0; i < n; i++) {\n    printf(\"%d \", a[i]);\n  }\n  printf(\"\\n\");\n\n  return 0;\n}\n\nvoid quicksort(int *A, int len) {\n  if (len < 2) return;\n\n  int pivot = A[len / 2];\n\n  int i, j;\n  for (i = 0, j = len - 1; ; i++, j--) {\n    while (A[i] < pivot) i++;\n    while (A[j] > pivot) j--;\n\n    if (i >= j) break;\n\n    int temp = A[i];\n    A[i]     = A[j];\n    A[j]     = temp;\n  }\n\n  quicksort(A, i);\n  quicksort(A + i, len - i);\n}\n\n\nOutput:\n4 65 2 -31 0 99 2 83 782 1\n-31 0 1 2 2 4 65 83 99 782\n\n\n#include <stdlib.h>     // REQ: rand()\n\nvoid swap(int *a, int *b) {\n  int c = *a;\n  *a = *b;\n  *b = c;\n}\n\nint partition(int A[], int p, int q) {\n  swap(&A[p + (rand() % (q - p + 1))], &A[q]);   // PIVOT = A[q]\n\n  int i = p - 1;\n  for(int j = p; j <= q; j++) {\n    if(A[j] <= A[q]) {\n      swap(&A[++i], &A[j]);\n    }\n  }\n\n  return i;\n}\n\nvoid quicksort(int A[], int p, int q) {\n  if(p < q) {\n    int pivotIndx = partition(A, p, q);\n\n    quicksort(A, p, pivotIndx - 1);\n    quicksort(A, pivotIndx + 1, q);\n  }\n}\n\n", "explain": "Randomized sort with separated components.\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "C++", "code": "\n\n#include <iterator>\n#include <algorithm> // for std::partition\n#include <functional> // for std::less\n\n// helper function for median of three\ntemplate<typename T>\n T median(T t1, T t2, T t3)\n{\n  if (t1 < t2)\n  {\n    if (t2 < t3)\n      return t2;\n    else if (t1 < t3)\n      return t3;\n    else\n      return t1;\n  }\n  else\n  {\n    if (t1 < t3)\n      return t1;\n    else if (t2 < t3)\n      return t3;\n    else\n      return t2;\n  }\n}\n\n// helper object to get <= from <\ntemplate<typename Order> struct non_strict_op:\n  public std::binary_function<typename Order::second_argument_type,\n                              typename Order::first_argument_type,\n                              bool>\n{\n  non_strict_op(Order o): order(o) {}\n  bool operator()(typename Order::second_argument_type arg1,\n                  typename Order::first_argument_type arg2) const\n  {\n    return !order(arg2, arg1);\n  }\nprivate:\n  Order order;\n};\n\ntemplate<typename Order> non_strict_op<Order> non_strict(Order o)\n{\n  return non_strict_op<Order>(o);\n}\n\ntemplate<typename RandomAccessIterator,\n         typename Order>\n void quicksort(RandomAccessIterator first, RandomAccessIterator last, Order order)\n{\n  if (first != last && first+1 != last)\n  {\n    typedef typename std::iterator_traits<RandomAccessIterator>::value_type value_type;\n    RandomAccessIterator mid = first + (last - first)/2;\n    value_type pivot = median(*first, *mid, *(last-1));\n    RandomAccessIterator split1 = std::partition(first, last, std::bind2nd(order, pivot));\n    RandomAccessIterator split2 = std::partition(split1, last, std::bind2nd(non_strict(order), pivot));\n    quicksort(first, split1, order);\n    quicksort(split2, last, order);\n  }\n}\n\ntemplate<typename RandomAccessIterator>\n void quicksort(RandomAccessIterator first, RandomAccessIterator last)\n{\n  quicksort(first, last, std::less<typename std::iterator_traits<RandomAccessIterator>::value_type>());\n}\n\n\n#include <iterator>\n#include <algorithm> // for std::partition\n#include <functional> // for std::less\n\ntemplate<typename RandomAccessIterator,\n         typename Order>\n void quicksort(RandomAccessIterator first, RandomAccessIterator last, Order order)\n{\n  if (last - first > 1)\n  {\n    RandomAccessIterator split = std::partition(first+1, last, std::bind2nd(order, *first));\n    std::iter_swap(first, split-1);\n    quicksort(first, split-1, order);\n    quicksort(split, last, order);\n  }\n}\n\ntemplate<typename RandomAccessIterator>\n void quicksort(RandomAccessIterator first, RandomAccessIterator last)\n{\n  quicksort(first, last, std::less<typename std::iterator_traits<RandomAccessIterator>::value_type>());\n}\n\n", "explain": "The following implements quicksort with a median-of-three pivot. As idiomatic in C++, the argument last is a one-past-end iterator. Note that this code takes advantage of std::partition, which is O(n). Also note that it needs a random-access iterator for efficient calculation of the median-of-three pivot (more exactly, for O(1) calculation of the iterator mid).\nA simpler version of the above that just uses the first element as the pivot and only does one \"partition\".\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Java", "code": "\nImperative[edit]\nWorks with: Java version 1.5+\nTranslation of: Python\npublic static <E extends Comparable<? super E>> List<E> quickSort(List<E> arr) {\n    if (arr.isEmpty())\n        return arr;\n    else {\n        E pivot = arr.get(0);\n\n        List<E> less = new LinkedList<E>();\n        List<E> pivotList = new LinkedList<E>();\n        List<E> more = new LinkedList<E>();\n\n        // Partition\n        for (E i: arr) {\n            if (i.compareTo(pivot) < 0)\n                less.add(i);\n            else if (i.compareTo(pivot) > 0)\n                more.add(i);\n            else\n                pivotList.add(i);\n        }\n\n        // Recursively sort sublists\n        less = quickSort(less);\n        more = quickSort(more);\n\n        // Concatenate results\n        less.addAll(pivotList);\n        less.addAll(more);\n        return less;\n    }\n}\n\nFunctional[edit]\nWorks with: Java version 1.8\npublic static <E extends Comparable<E>> List<E> sort(List<E> col) {\n    if (col == null || col.isEmpty())\n        return Collections.emptyList();\n    else {\n        E pivot = col.get(0);\n        Map<Integer, List<E>> grouped = col.stream()\n                .collect(Collectors.groupingBy(pivot::compareTo));\n        return Stream.of(sort(grouped.get(1)), grouped.get(0), sort(grouped.get(-1)))\n                .flatMap(Collection::stream).collect(Collectors.toList());\n    }\n}\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "C#", "code": "\n//\n// The Tripartite conditional enables Bentley-McIlroy 3-way Partitioning.\n// This performs additional compares to isolate islands of keys equal to\n// the pivot value.  Use unless key-equivalent classes are of small size.\n//\n#define Tripartite\n\nnamespace RosettaCode {\n  using System;\n  using System.Diagnostics;\n\n  public class QuickSort<T> where T : IComparable {\n    #region Constants\n    public const UInt32 INSERTION_LIMIT_DEFAULT = 12;\n    private const Int32 SAMPLES_MAX = 19;\n    #endregion\n\n    #region Properties\n    public UInt32 InsertionLimit { get; }\n    private T[] Samples { get; }\n    private Int32 Left { get; set; }\n    private Int32 Right { get; set; }\n    private Int32 LeftMedian { get; set; }\n    private Int32 RightMedian { get; set; }\n    #endregion\n\n    #region Constructors\n    public QuickSort(UInt32 insertionLimit = INSERTION_LIMIT_DEFAULT) {\n      this.InsertionLimit = insertionLimit;\n      this.Samples = new T[SAMPLES_MAX];\n    }\n    #endregion\n\n    #region Sort Methods\n    public void Sort(T[] entries) {\n      Sort(entries, 0, entries.Length - 1);\n    }\n\n    public void Sort(T[] entries, Int32 first, Int32 last) {\n      var length = last + 1 - first;\n      while (length > 1) {\n        if (length < InsertionLimit) {\n          InsertionSort<T>.Sort(entries, first, last);\n          return;\n        }\n\n        Left = first;\n        Right = last;\n        var median = pivot(entries);\n        partition(median, entries);\n        //[Note]Right < Left\n\n        var leftLength = Right + 1 - first;\n        var rightLength = last + 1 - Left;\n\n        //\n        // First recurse over shorter partition, then loop\n        // on the longer partition to elide tail recursion.\n        //\n        if (leftLength < rightLength) {\n          Sort(entries, first, Right);\n          first = Left;\n          length = rightLength;\n        }\n        else {\n          Sort(entries, Left, last);\n          last = Right;\n          length = leftLength;\n        }\n      }\n    }\n\n    /// <summary>Return an odd sample size proportional to the log of a large interval size.</summary>\n    private static Int32 sampleSize(Int32 length, Int32 max = SAMPLES_MAX) {\n      var logLen = (Int32)Math.Log10(length);\n      var samples = Math.Min(2 * logLen + 1, max);\n      return Math.Min(samples, length);\n    }\n\n    /// <summary>Estimate the median value of entries[Left:Right]</summary>\n    /// <remarks>A sample median is used as an estimate the true median.</remarks>\n    private T pivot(T[] entries) {\n      var length = Right + 1 - Left;\n      var samples = sampleSize(length);\n      // Sample Linearly:\n      for (var sample = 0; sample < samples; sample++) {\n        // Guard against Arithmetic Overflow:\n        var index = (Int64)length * sample / samples + Left;\n        Samples[sample] = entries[index];\n      }\n\n      InsertionSort<T>.Sort(Samples, 0, samples - 1);\n      return Samples[samples / 2];\n    }\n\n    private void partition(T median, T[] entries) {\n      var first = Left;\n      var last = Right;\n#if Tripartite\n      LeftMedian = first;\n      RightMedian = last;\n#endif\n      while (true) {\n        //[Assert]There exists some index >= Left where entries[index] >= median\n        //[Assert]There exists some index <= Right where entries[index] <= median\n        // So, there is no need for Left or Right bound checks\n        while (median.CompareTo(entries[Left]) > 0) Left++;\n        while (median.CompareTo(entries[Right]) < 0) Right--;\n\n        //[Assert]entries[Right] <= median <= entries[Left]\n        if (Right <= Left) break;\n\n        Swap(entries, Left, Right);\n        swapOut(median, entries);\n        Left++;\n        Right--;\n        //[Assert]entries[first:Left - 1] <= median <= entries[Right + 1:last]\n      }\n\n      if (Left == Right) {\n        Left++;\n        Right--;\n      }\n      //[Assert]Right < Left\n      swapIn(entries, first, last);\n\n      //[Assert]entries[first:Right] <= median <= entries[Left:last]\n      //[Assert]entries[Right + 1:Left - 1] == median when non-empty\n    }\n    #endregion\n\n    #region Swap Methods\n    [Conditional(\"Tripartite\")]\n    private void swapOut(T median, T[] entries) {\n      if (median.CompareTo(entries[Left]) == 0) Swap(entries, LeftMedian++, Left);\n      if (median.CompareTo(entries[Right]) == 0) Swap(entries, Right, RightMedian--);\n    }\n\n    [Conditional(\"Tripartite\")]\n    private void swapIn(T[] entries, Int32 first, Int32 last) {\n      // Restore Median entries\n      while (first < LeftMedian) Swap(entries, first++, Right--);\n      while (RightMedian < last) Swap(entries, Left++, last--);\n    }\n\n    /// <summary>Swap entries at the left and right indicies.</summary>\n    public void Swap(T[] entries, Int32 left, Int32 right) {\n      Swap(ref entries[left], ref entries[right]);\n    }\n\n    /// <summary>Swap two entities of type T.</summary>\n    public static void Swap(ref T e1, ref T e2) {\n      var e = e1;\n      e1 = e2;\n      e2 = e;\n    }\n    #endregion\n  }\n\n  #region Insertion Sort\n  static class InsertionSort<T> where T : IComparable {\n    public static void Sort(T[] entries, Int32 first, Int32 last) {\n      for (var next = first + 1; next <= last; next++)\n        insert(entries, first, next);\n    }\n\n    /// <summary>Bubble next entry up to its sorted location, assuming entries[first:next - 1] are already sorted.</summary>\n    private static void insert(T[] entries, Int32 first, Int32 next) {\n      var entry = entries[next];\n      while (next > first && entries[next - 1].CompareTo(entry) > 0)\n        entries[next] = entries[--next];\n      entries[next] = entry;\n    }\n  }\n  #endregion\n}\n\n\n  using Sort;\n  using System;\n\n  class Program {\n    static void Main(String[] args) {\n      var entries = new Int32[] { 1, 3, 5, 7, 9, 8, 6, 4, 2 };\n      var sorter = new QuickSort<Int32>();\n      sorter.Sort(entries);\n      Console.WriteLine(String.Join(\" \", entries));\n    }\n  }\n\n\nOutput:\n1 2 3 4 5 6 7 8 9\n\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace QSort\n{\n    class QSorter\n    {\n        private static IEnumerable<IComparable> empty = new List<IComparable>();\n\n        public static IEnumerable<IComparable> QSort(IEnumerable<IComparable> iEnumerable)\n        {\n            if(iEnumerable.Any())\n            {\n                var pivot = iEnumerable.First();\n                return QSort(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) > 0)).\n                    Concat(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) == 0)).\n                    Concat(QSort(iEnumerable.Where((anItem) => pivot.CompareTo(anItem) < 0)));\n            }\n            return empty;\n        }\n    }\n}\n\n", "explain": "Example:\nA very inefficient way to do qsort in C# to prove C# code can be just as compact and readable as any dynamic code\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nImperative[edit]\nfunction sort(array, less) {\n\n  function swap(i, j) {\n    var t = array[i];\n    array[i] = array[j];\n    array[j] = t;\n  }\n\n  function quicksort(left, right) {\n\n    if (left < right) {\n      var pivot = array[left + Math.floor((right - left) / 2)],\n          left_new = left,\n          right_new = right;\n\n      do {\n        while (less(array[left_new], pivot)) {\n          left_new += 1;\n        }\n        while (less(pivot, array[right_new])) {\n          right_new -= 1;\n        }\n        if (left_new <= right_new) {\n          swap(left_new, right_new);\n          left_new += 1;\n          right_new -= 1;\n        }\n      } while (left_new <= right_new);\n\n      quicksort(left, right_new);\n      quicksort(left_new, right);\n\n    }\n  }\n\n  quicksort(0, array.length - 1);\n\n  return array;\n}\n\nExample:var test_array = [10, 3, 11, 15, 19, 1];\nvar sorted_array = sort(test_array, function(a,b) { return a<b; });\n\n\nOutput:[ 1, 3, 10, 11, 15, 19 ]\n\nFunctional[edit]\nES6[edit]\n\nconst qsort = ([pivot, ...others]) => \n  pivot === void 0 ? [] : [\n    ...qsort(others.filter(n => n < pivot)),\n    pivot,\n    ...qsort(others.filter(n => n >= pivot))\n  ];\n\nqsort( [ 11.8, 14.1, 21.3, 8.5, 16.7, 5.7 ] )\n\n\nOutput:\n[ 5.7, 8.5, 11.8, 14.1, 16.7, 21.3 ]\n\nES5[edit]\n\nfunction qsort( xs ){\n  return xs.length === 0 ? [] : [].concat(\n    qsort( xs.slice(1).filter(function(x){ return x< xs[0] })),\n    xs[0],\n    qsort( xs.slice(1).filter(function(x){ return x>= xs[0] }))\n  )\n}\nqsort( [ 11.8, 14.1, 21.3, 8.5, 16.7, 5.7 ] )\n\n\nOutput:\n[5.7, 8.5, 11.8, 14.1, 16.7, 21.3]\n", "explain": "Using destructuring and satisfying immutability we can propose a single expresion solution (from https://github.com/ddcovery/expressive_sort) \nUnlike what happens with ES6, there are no destructuring nor lambdas, but we can ensure immutability and propose a single expression solution with standard anonymous functions\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "PHP", "code": "\nfunction quicksort($arr){\n\t$lte = $gt = array();\n\tif(count($arr) < 2){\n\t\treturn $arr;\n\t}\n\t$pivot_key = key($arr);\n\t$pivot = array_shift($arr);\n\tforeach($arr as $val){\n\t\tif($val <= $pivot){\n\t\t\t$lte[] = $val;\n\t\t} else {\n\t\t\t$gt[] = $val;\n\t\t}\n\t}\n\treturn array_merge(quicksort($lte),array($pivot_key=>$pivot),quicksort($gt));\n}\n\n$arr = array(1, 3, 5, 7, 9, 8, 6, 4, 2);\n$arr = quicksort($arr);\necho implode(',',$arr);\n1,2,3,4,5,6,7,8,9\nfunction quickSort(array $array) {\n    // base case\n    if (empty($array)) {\n        return $array;\n    }\n    $head = array_shift($array);\n    $tail = $array;\n    $lesser = array_filter($tail, function ($item) use ($head) {\n        return $item <= $head;\n    });\n    $bigger = array_filter($tail, function ($item) use ($head) {\n        return $item > $head;\n    });\n    return array_merge(quickSort($lesser), [$head], quickSort($bigger));\n}\n$testCase = [1, 4, 8, 2, 8, 0, 2, 8];\n$result = quickSort($testCase);\necho sprintf(\"[%s] ==> [%s]\\n\", implode(', ', $testCase), implode(', ', $result));\n[1, 4, 8, 2, 8, 0, 2, 8] ==> [0, 1, 2, 2, 4, 8, 8, 8]\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "MATLAB", "code": "\n\nfunction sortedArray = quickSort(array)\n\n    if numel(array) <= 1 %If the array has 1 element then it can't be sorted       \n        sortedArray = array;\n        return\n    end\n    \n    pivot = array(end);\n    array(end) = [];\n        \n    %Create two new arrays which contain the elements that are less than or\n    %equal to the pivot called \"less\" and greater than the pivot called\n    %\"greater\"\n    less = array( array <= pivot );\n    greater = array( array > pivot );\n    \n    %The sorted array is the concatenation of the sorted \"less\" array, the\n    %pivot and the sorted \"greater\" array in that order\n    sortedArray = [quickSort(less) pivot quickSort(greater)];\n    \nend\n\n\nfunction sortedArray = quickSort(array)\n\n    if numel(array) <= 1 %If the array has 1 element then it can't be sorted       \n        sortedArray = array;\n        return\n    end\n    \n    pivot = array(end);\n    array(end) = [];\n    \n    sortedArray = [quickSort( array(array <= pivot) ) pivot quickSort( array(array > pivot) )];\n    \nend\n\n\nquickSort([4,3,7,-2,9,1])\n\nans =\n\n    -2     1     3     4     7     9\n", "explain": "This implements the pseudo-code in the specification. The input can be either a row or column vector, but the returned vector will always be a row vector. This can be modified to operate on any built-in primitive or user defined class by replacing the \"<=\" and \">\" comparisons with \"le\" and \"gt\" functions respectively. This is because operators can not be overloaded, but the functions that are equivalent to the operators can be overloaded in class definitions.\nThis should be placed in a file named quickSort.m.\nA slightly more vectorized version of the above code that removes the need for the less and greater arrays:\nSample usage:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nIf the largest element is in the last slot, the call to QSort(A(marker:),nA-marker+1) goes beyond the end of the array. This can cause exceptions and bad results.\nThe use of a random number causes non reproducible performance.\n\nMODULE qsort_mod\n\n  IMPLICIT NONE\n\n  TYPE group\n     INTEGER :: order    ! original order of unsorted data\n     REAL    :: VALUE    ! values to be sorted by\n  END TYPE group\n\nCONTAINS\n\n  RECURSIVE SUBROUTINE QSort(a,na)\n\n    ! DUMMY ARGUMENTS\n    INTEGER, INTENT(in) :: nA\n    TYPE (group), DIMENSION(nA), INTENT(in out) :: A\n\n    ! LOCAL VARIABLES\n    INTEGER :: left, right\n    REAL :: random\n    REAL :: pivot\n    TYPE (group) :: temp\n    INTEGER :: marker\n\n    IF (nA > 1) THEN\n\n       CALL random_NUMBER(random)\n       pivot = A(INT(random*REAL(nA-1))+1)%VALUE   ! Choice a random pivot (not best performance, but avoids worst-case)\n       left = 1\n       right = nA\n       ! Partition loop\n       DO\n          IF (left >= right) EXIT\n          DO\n             IF (A(right)%VALUE <= pivot) EXIT\n             right = right - 1\n          END DO\n          DO\n             IF (A(left)%VALUE >= pivot) EXIT\n             left = left + 1\n          END DO\n          IF (left < right) THEN\n             temp = A(left)\n             A(left) = A(right)\n             A(right) = temp\n          END IF\n       END DO\n\n       IF (left == right) THEN\n          marker = left + 1\n       ELSE\n          marker = left\n       END IF\n\n       CALL QSort(A(:marker-1),marker-1)\n       CALL QSort(A(marker:),nA-marker+1)  WARNING CAN GO BEYOND END OF ARRAY DO NOT USE THIS IMPLEMENTATION\n\n    END IF\n\n  END SUBROUTINE QSort\n\nEND MODULE qsort_mod\n     \n! Test Qsort Module\nPROGRAM qsort_test\n  USE qsort_mod\n  IMPLICIT NONE\n\n  INTEGER, PARAMETER :: nl = 10, nc = 5, l = nc*nl, ns=33\n  TYPE (group), DIMENSION(l) :: A\n  INTEGER, DIMENSION(ns) :: seed\n  INTEGER :: i\n  REAL :: random\n  CHARACTER(LEN=80) :: fmt1, fmt2\n  ! Using the Fibonacci sequence to initialize seed:\n  seed(1) = 1 ; seed(2) = 1\n  DO i = 3,ns\n     seed(i) = seed(i-1)+seed(i-2)\n  END DO\n  ! Formats of the outputs\n  WRITE(fmt1,'(A,I2,A)') '(', nc, '(I5,2X,F6.2))'\n  WRITE(fmt2,'(A,I2,A)') '(3x', nc, '(\"Ord.  Num.\",3x))' \n  PRINT *, \"Unsorted Values:\"\n  PRINT fmt2,\n  CALL random_SEED(put = seed)\n  DO i = 1, l\n     CALL random_NUMBER(random)\n     A(i)%VALUE = NINT(1000*random)/10.0\n     A(i)%order = i\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  PRINT *\n  CALL QSort(A,l)\n  PRINT *, \"Sorted Values:\"\n  PRINT fmt2,\n  DO i = nc, l, nc\n     IF (MOD(i,nc) == 0) WRITE (*,fmt1) A(i-nc+1:i)\n  END DO\n  STOP\nEND PROGRAM qsort_test\n\n\nOutput:\nCompiled with GNU Fortran 9.3.0 \n Unsorted Values:\n   Ord.  Num.   Ord.  Num.   Ord.  Num.   Ord.  Num.   Ord.  Num.\n    1   47.10    2   11.70    3   35.80    4   35.20    5   55.30\n    6   74.60    7   28.40    8   30.10    9   70.60   10   66.90\n   11   15.90   12   71.70   13   49.80   14    2.60   15   12.80\n   16   93.00   17   45.20   18   21.50   19   20.70   20   39.50\n   21    9.20   22   21.60   23   18.60   24   22.80   25   98.50\n   26   97.50   27   43.90   28    8.30   29   84.10   30   88.80\n   31   10.30   32   30.50   33   79.30   34   24.40   35   45.00\n   36   48.30   37   69.80   38   86.00   39   68.40   40   22.90\n   41    7.50   42   18.50   43   80.40   44   29.60   45   43.60\n   46   11.20   47   36.20   48   23.20   49   45.30   50   12.30\n\n Sorted Values:\n   Ord.  Num.   Ord.  Num.   Ord.  Num.   Ord.  Num.   Ord.  Num.\n   14    2.60   41    7.50   28    8.30   21    9.20   31   10.30\n   46   11.20    2   11.70   50   12.30   15   12.80   11   15.90\n   42   18.50   23   18.60   19   20.70   18   21.50   22   21.60\n   24   22.80   40   22.90   48   23.20   34   24.40    7   28.40\n   44   29.60    8   30.10   32   30.50    4   35.20    3   35.80\n   47   36.20   20   39.50   45   43.60   27   43.90   35   45.00\n   17   45.20   49   45.30    1   47.10   36   48.30   13   49.80\n    5   55.30   10   66.90   39   68.40   37   69.80    9   70.60\n   12   71.70    6   74.60   33   79.30   43   80.40   29   84.10\n   38   86.00   30   88.80   16   93.00   26   97.50   25   98.50\n\n\n", "explain": "WARNING: The implementation of QuickSort in Fortran below is flawed:\nInstead of this algorithm rather use https://gist.github.com/t-nissie/479f0f16966925fa29ea\nA discussion about Quicksort pivot options, free source code for an optimized quicksort using insertion sort as a finisher, and an OpenMP multi-threaded quicksort is found at balfortran.org\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    list := []int{31, 41, 59, 26, 53, 58, 97, 93, 23, 84}\n    fmt.Println(\"unsorted:\", list)\n\n    quicksort(list)\n    fmt.Println(\"sorted!  \", list)\n}\n\nfunc quicksort(a []int) {\n    var pex func(int, int)\n    pex = func(lower, upper int) {\n        for {\n            switch upper - lower {\n            case -1, 0: // 0 or 1 item in segment.  nothing to do here!\n                return\n            case 1: // 2 items in segment\n                // < operator respects strict weak order\n                if a[upper] < a[lower] {\n                    // a quick exchange and we're done.\n                    a[upper], a[lower] = a[lower], a[upper]\n                }\n                return\n            // Hoare suggests optimized sort-3 or sort-4 algorithms here,\n            // but does not provide an algorithm.\n            }\n\n            // Hoare stresses picking a bound in a way to avoid worst case\n            // behavior, but offers no suggestions other than picking a\n            // random element.  A function call to get a random number is\n            // relatively expensive, so the method used here is to simply\n            // choose the middle element.  This at least avoids worst case\n            // behavior for the obvious common case of an already sorted list.\n            bx := (upper + lower) / 2\n            b := a[bx]  // b = Hoare's \"bound\" (aka \"pivot\")\n            lp := lower // lp = Hoare's \"lower pointer\"\n            up := upper // up = Hoare's \"upper pointer\"\n        outer:\n            for {\n                // use < operator to respect strict weak order\n                for lp < upper && !(b < a[lp]) {\n                    lp++\n                }\n                for {\n                    if lp > up {\n                        // \"pointers crossed!\"\n                        break outer\n                    }\n                    // < operator for strict weak order\n                    if a[up] < b {\n                        break // inner\n                    }\n                    up--\n                }\n                // exchange\n                a[lp], a[up] = a[up], a[lp]\n                lp++\n                up--\n            }\n            // segment boundary is between up and lp, but lp-up might be\n            // 1 or 2, so just call segment boundary between lp-1 and lp.\n            if bx < lp {\n                // bound was in lower segment\n                if bx < lp-1 {\n                    // exchange bx with lp-1\n                    a[bx], a[lp-1] = a[lp-1], b\n                }\n                up = lp - 2\n            } else {\n                // bound was in upper segment\n                if bx > lp {\n                    // exchange\n                    a[bx], a[lp] = a[lp], b\n                }\n                up = lp - 1\n                lp++\n            }\n            // \"postpone the larger of the two segments\" = recurse on\n            // the smaller segment, then iterate on the remaining one.\n            if up-lower < upper-lp {\n                pex(lower, up)\n                lower = lp\n            } else {\n                pex(lp, upper)\n                upper = up\n            }\n        }\n    }\n    pex(0, len(a)-1)\n}\n\n\nOutput:\nunsorted: [31 41 59 26 53 58 97 93 23 84]\nsorted!   [23 26 31 41 53 58 59 84 93 97]\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n    \"math/rand\"\n)\n\nfunc partition(a sort.Interface, first int, last int, pivotIndex int) int {\n    a.Swap(first, pivotIndex) // move it to beginning\n    left := first+1\n    right := last\n    for left <= right {\n        for left <= last && a.Less(left, first) {\n            left++\n        }\n        for right >= first && a.Less(first, right) {\n            right--\n        }\n        if left <= right {\n            a.Swap(left, right)\n            left++\n            right--\n        }\n    }\n    a.Swap(first, right) // swap into right place\n    return right    \n}\n\nfunc quicksortHelper(a sort.Interface, first int, last int) {\n    if first >= last {\n        return\n    }\n    pivotIndex := partition(a, first, last, rand.Intn(last - first + 1) + first)\n    quicksortHelper(a, first, pivotIndex-1)\n    quicksortHelper(a, pivotIndex+1, last)\n}\n\nfunc quicksort(a sort.Interface) {\n    quicksortHelper(a, 0, a.Len()-1)\n}\n\nfunc main() {\n    a := []int{1, 3, 5, 7, 9, 8, 6, 4, 2}\n    fmt.Printf(\"Unsorted: %v\\n\", a)\n    quicksort(sort.IntSlice(a))\n    fmt.Printf(\"Sorted: %v\\n\", a)\n    b := []string{\"Emil\", \"Peg\", \"Helen\", \"Juergen\", \"David\", \"Rick\", \"Barb\", \"Mike\", \"Tom\"}\n    fmt.Printf(\"Unsorted: %v\\n\", b)\n    quicksort(sort.StringSlice(b))\n    fmt.Printf(\"Sorted: %v\\n\", b)\n}\n\n\nOutput:\nUnsorted: [1 3 5 7 9 8 6 4 2]\nSorted: [1 2 3 4 5 6 7 8 9]\nUnsorted: [Emil Peg Helen Juergen David Rick Barb Mike Tom]\nSorted: [Barb David Emil Helen Juergen Mike Peg Rick Tom]\n\n", "explain": "Note that Go's sort.Sort function is a Quicksort so in practice it would be just be used.\nIt's actually a combination of quick sort, heap sort, and insertion sort.\nIt starts with a quick sort, after a depth of 2*ceil(lg(n+1)) it switches to heap sort, or once a partition becomes small (less than eight items) it switches to insertion sort.\n\nOld school, following Hoare's 1962 paper.\nAs a nod to the task request to work for all types with weak strict ordering, code below uses the < operator when comparing key values.  The three points are noted in the code below.\nActually supporting arbitrary types would then require at a minimum a user supplied less-than function, and values referenced from an array of interface{} types.  More efficient and flexible though is the sort interface of the Go sort package.  Replicating that here seemed beyond the scope of the task so code was left written to sort an array of ints.\nGo has no language support for indexing with discrete types other than integer types, so this was not coded.\nFinally, the choice of a recursive closure over passing slices to a recursive function is really just a very small optimization.  Slices are cheap because they do not copy the underlying array, but there's still a tiny bit of overhead in constructing the slice object.  Passing just the two numbers is in the interest of avoiding that overhead.\nMore traditional version of quicksort. It work generically with any container that conforms to sort.Interface.\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program quickSort.s   */\n/* look pseudo code in wikipedia  quicksort */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessSortOk:       .asciz \"Table sorted.\\n\"\nszMessSortNok:      .asciz \"Table not sorted\u00a0!!!!!.\\n\"\nsMessResult:        .ascii \"Value \u00a0: \"\nsMessValeur:        .fill 11, 1, ' '            @ size => 11\nszCarriageReturn:   .asciz \"\\n\"\n \n.align 4\niGraine:  .int 123456\n.equ NBELEMENTS,      10\n#TableNumber:\t     .int   9,5,6,1,2,3,10,8,4,7\n#TableNumber:\t     .int   1,3,5,2,4,6,10,8,4,7\n#TableNumber:\t     .int   1,3,5,2,4,6,10,8,4,7\n#TableNumber:\t     .int   1,2,3,4,5,6,10,8,4,7\nTableNumber:\t     .int   10,9,8,7,6,5,4,3,2,1\n#TableNumber:\t     .int   13,12,11,10,9,8,7,6,5,4,3,2,1\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                              @ entry of program \n \n1:\n    ldr r0,iAdrTableNumber                         @ address number table\n\n    mov r1,#0                                      @ indice first item\n    mov r2,#NBELEMENTS                             @ number of \u00e9lements \n    bl triRapide                                   @ call quicksort\n    ldr r0,iAdrTableNumber                         @ address number table\n    bl displayTable\n \n    ldr r0,iAdrTableNumber                         @ address number table\n    mov r1,#NBELEMENTS                             @ number of \u00e9lements \n    bl isSorted                                    @ control sort\n    cmp r0,#1                                      @ sorted\u00a0?\n    beq 2f                                    \n    ldr r0,iAdrszMessSortNok                       @ no\u00a0!! error sort\n    bl affichageMess\n    b 100f\n2:                                                 @ yes\n    ldr r0,iAdrszMessSortOk\n    bl affichageMess\n100:                                               @ standard end of the program \n    mov r0, #0                                     @ return code\n    mov r7, #EXIT                                  @ request to exit program\n    svc #0                                         @ perform the system call\n \niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:    .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrTableNumber:          .int TableNumber\niAdrszMessSortOk:         .int szMessSortOk\niAdrszMessSortNok:        .int szMessSortNok\n/******************************************************************/\n/*     control sorted table                                   */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains the number of elements  > 0  */\n/* r0 return 0  if not sorted   1  if sorted */\nisSorted:\n    push {r2-r4,lr}                                    @ save registers\n    mov r2,#0\n    ldr r4,[r0,r2,lsl #2]\n1:\n    add r2,#1\n    cmp r2,r1\n    movge r0,#1\n    bge 100f\n    ldr r3,[r0,r2, lsl #2]\n    cmp r3,r4\n    movlt r0,#0\n    blt 100f\n    mov r4,r3\n    b 1b\n100:\n    pop {r2-r4,lr}\n    bx lr                                              @ return \n\n\n/***************************************************/\n/*   Appel r\u00e9cursif Tri Rapide quicksort           */\n/***************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains the number of elements  > 0  */\ntriRapide:\n    push {r2-r5,lr}                                   @ save registers\n    sub r2,#1                                         @ last item index\n    cmp r1,r2                                         @ first > last\u00a0? \n    bge 100f                                          @ yes -> end\n    mov r4,r0                                         @ save r0\n    mov r5,r2                                         @ save r2\n    bl partition1                                     @ cutting into 2 parts\n    mov r2,r0                                         @ index partition\n    mov r0,r4                                         @ table address\n    bl triRapide                                      @ sort lower part\n    add r1,r2,#1                                      @ index begin = index partition + 1\n    add r2,r5,#1                                      @ number of elements\n    bl triRapide                                      @ sort higter part\n   \n 100:                                                 @ end function\n    pop {r2-r5,lr}                                    @ restaur  registers \n    bx lr                                             @ return\n\n\n/******************************************************************/\n/*      Partition table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains index of last item   */\n\npartition1:\n    push {r1-r7,lr}                                    @ save registers\n    ldr r3,[r0,r2,lsl #2]                              @ load value last index\n    mov r4,r1                                          @ init with first index\n    mov r5,r1                                          @ init with first index\n1:                                                     @ begin loop\n    ldr r6,[r0,r5,lsl #2]                              @ load value\n    cmp r6,r3                                          @ compare value\n    ldrlt r7,[r0,r4,lsl #2]                            @ if < swap value table\n    strlt r6,[r0,r4,lsl #2]\n    strlt r7,[r0,r5,lsl #2]\n    addlt r4,#1                                        @ and increment index 1\n    add    r5,#1                                       @ increment index 2\n    cmp r5,r2                                          @ end\u00a0?\n    blt 1b                                             @ no loop\n    ldr r7,[r0,r4,lsl #2]                              @ swap value\n    str r3,[r0,r4,lsl #2]\n    str r7,[r0,r2,lsl #2]\n    mov r0,r4                                          @ return index partition\n100:\n    pop {r1-r7,lr}\n    bx lr\n\n/******************************************************************/\n/*      Display table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\ndisplayTable:\n    push {r0-r3,lr}                                    @ save registers\n    mov r2,r0                                          @ table address\n    mov r3,#0\n1:                                                     @ loop display table\n    ldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                             @ display value\n    bl conversion10                                    @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                                   @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 1b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n100:\n    pop {r0-r3,lr}\n    bx lr\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n \n1:\t                                            @ start loop\n    bl divisionpar10U                               @ unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b\t                                    @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n \n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    //mov r3,#0xCCCD                                   @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                  @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\n{Dynamic array of pointers}\n\ntype TPointerArray = array of Pointer;\n\nprocedure QuickSort(SortList: TPointerArray; L, R: Integer; SCompare: TListSortCompare);\n{Do quick sort on items held in TPointerArray}\n{SCompare controls how the pointers are interpreted}\nvar I, J: Integer;\nvar P,T: Pointer;\nbegin\nrepeat\n\tbegin\n\tI := L;\n\tJ := R;\n\tP := SortList[(L + R) shr 1];\n\trepeat\n\t\tbegin\n\t\twhile SCompare(SortList[I], P) < 0 do Inc(I);\n\t\twhile SCompare(SortList[J], P) > 0 do Dec(J);\n\t\tif I <= J then\n\t\t\tbegin\n\t\t\t{Exchange itesm}\n\t\t\tT:=SortList[I];\n\t\t\tSortList[I]:=SortList[J];\n\t\t\tSortList[J]:=T;\n\t\t\tif P = SortList[I] then P := SortList[J]\n\t\t\telse if P = SortList[J] then P := SortList[I];\n\t\t\tInc(I);\n\t\t\tDec(J);\n\t\t\tend;\n\t\tend\n\tuntil I > J;\n\tif L < J then QuickSort(SortList, L, J, SCompare);\n\tL := I;\n\tend\nuntil I >= R;\nend;\n\n\n\nprocedure DisplayStrings(Memo: TMemo; PA: TPointerArray);\n{Display pointers as strings}\nvar I: integer;\nvar S: string;\nbegin\nS:='[';\nfor I:=0 to High(PA) do\n\tbegin\n\tif I>0 then S:=S+' ';\n\tS:=S+string(PA[I]^);\n\tend;\nS:=S+']';\nMemo.Lines.Add(S);\nend;\n\n\nprocedure DisplayIntegers(Memo: TMemo; PA: TPointerArray);\n{Display pointer array as integers}\nvar I: integer;\nvar S: string;\nbegin\nS:='[';\nfor I:=0 to High(PA) do\n\tbegin\n\tif I>0 then S:=S+' ';\n\tS:=S+IntToStr(Integer(PA[I]));\n\tend;\nS:=S+']';\nMemo.Lines.Add(S);\nend;\n\n\nfunction IntCompare(Item1, Item2: Pointer): Integer;\n{Compare for integer sort}\nbegin\nResult:=Integer(Item1)-Integer(Item2);\nend;\n\n\n\nfunction StringCompare(Item1, Item2: Pointer): Integer;\n{Compare for alphabetical string sort}\nbegin\nResult:=AnsiCompareText(string(Item1^),string(Item2^));\nend;\n\nfunction StringRevCompare(Item1, Item2: Pointer): Integer;\n{Compare for reverse alphabetical order}\nbegin\nResult:=AnsiCompareText(string(Item2^),string(Item1^));\nend;\n\n\nfunction StringLenCompare(Item1, Item2: Pointer): Integer;\n{Compare for string length sort}\nbegin\nResult:=Length(string(Item1^))-Length(string(Item2^));\nend;\n\n{Arrays of strings and integers}\n\nvar IA: array [0..9] of integer = (23, 14, 62, 28, 56, 91, 33, 30, 75, 5);\nvar SA: array [0..15] of string = ('Now','is','the','time','for','all','good','men','to','come','to','the','aid','of','the','party.');\n\nprocedure ShowQuickSort(Memo: TMemo);\nvar L: TStringList;\nvar PA: TPointerArray;\nvar I: integer;\nbegin\nMemo.Lines.Add('Integer Sort');\nSetLength(PA,Length(IA));\nfor I:=0 to High(IA) do PA[I]:=Pointer(IA[I]);\nMemo.Lines.Add('Before Sorting');\nDisplayIntegers(Memo,PA);\nQuickSort(PA,0,High(PA),IntCompare);\nMemo.Lines.Add('After Sorting');\nDisplayIntegers(Memo,PA);\n\nMemo.Lines.Add('');\nMemo.Lines.Add('String Sort - Alphabetical');\nSetLength(PA,Length(SA));\nfor I:=0 to High(SA) do PA[I]:=Pointer(@SA[I]);\nMemo.Lines.Add('Before Sorting');\nDisplayStrings(Memo,PA);\nQuickSort(PA,0,High(PA),StringCompare);\nMemo.Lines.Add('After Sorting');\nDisplayStrings(Memo,PA);\n\nMemo.Lines.Add('');\nMemo.Lines.Add('String Sort - Reverse Alphabetical');\nQuickSort(PA,0,High(PA),StringRevCompare);\nMemo.Lines.Add('After Sorting');\nDisplayStrings(Memo,PA);\n\nMemo.Lines.Add('');\nMemo.Lines.Add('String Sort - By Length');\nQuickSort(PA,0,High(PA),StringLenCompare);\nMemo.Lines.Add('After Sorting');\nDisplayStrings(Memo,PA);\nend;\n\n\nOutput:\nInteger Sort\nBefore Sorting\n[23 14 62 28 56 91 33 30 75 5]\nAfter Sorting\n[5 14 23 28 30 33 56 62 75 91]\n\nString Sort - Alphabetical\nBefore Sorting\n[Now is the time for all good men to come to the aid of the party.]\nAfter Sorting\n[aid all come for good is men Now party. of the the the time to to]\n\nString Sort - Reverse Alphabetical\nAfter Sorting\n[to to time the the the party. of Now men is good for come all aid]\n\nString Sort - By Length\nAfter Sorting\n[of is to to men aid all for Now the the the time come good party.]\nElapsed Time: 16.478 ms.\n\n\n", "explain": "This quick sort routine is infinitely versatile. It sorts an array of pointers. The advantage of this is that pointers can contain anything, ranging from integers, to strings, to floating point numbers to objects. The way each pointer is interpreted is through the compare routine, which is customized for the particular situation. The compare routine can interpret each pointer as a string, an integer, a float or an object and it can treat those items in different ways. For example, the order in which it compares strings controls whether the sort is alphabetical or reverse alphabetical. In this case, I show an integer sort, an alphabetic string sort, a reverse alphabetical string sort and a string sort by length. \n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Ruby", "code": "\nclass Array\n  def quick_sort\n    return self if length <= 1\n    pivot = self[0]\n    less, greatereq = self[1..-1].partition { |x| x < pivot }\n    less.quick_sort + [pivot] + greatereq.quick_sort\n  end\nend\n\nclass Array\n  def quick_sort\n    return self if length <= 1\n    pivot = sample\n    group = group_by{ |x| x <=> pivot }\n    group.default = []\n    group[-1].quick_sort + group[0] + group[1].quick_sort\n  end\nend\n\nclass Array\n  def quick_sort\n    h, *t = self\n    h\u00a0? t.partition { |e| e < h }.inject { |l, r| l.quick_sort + [h] + r.quick_sort }\u00a0: []\n  end\nend\n", "explain": "or\nor functionally\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Rust", "code": "\nfn main() {\n    println!(\"Sort numbers in descending order\");\n    let mut numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n\n    quick_sort(&mut numbers, &|x,y| x > y);\n    println!(\"After:  {:?}\\n\", numbers);\n\n    println!(\"Sort strings alphabetically\");\n    let mut strings = [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"];\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x < y);\n    println!(\"After:  {:?}\\n\", strings);\n    \n    println!(\"Sort strings by length\");\n    println!(\"Before: {:?}\", strings);\n\n    quick_sort(&mut strings, &|x,y| x.len() < y.len());\n    println!(\"After:  {:?}\", strings);    \n}\n\nfn quick_sort<T,F>(v: &mut [T], f: &F) \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    if len >= 2 {\n        let pivot_index = partition(v, f);\n        quick_sort(&mut v[0..pivot_index], f);\n        quick_sort(&mut v[pivot_index + 1..len], f);\n    }\n}\n\nfn partition<T,F>(v: &mut [T], f: &F) -> usize \n    where F: Fn(&T,&T) -> bool\n{\n    let len = v.len();\n    let pivot_index = len / 2;\n    let last_index = len - 1;\n\n    v.swap(pivot_index, last_index);\n\n    let mut store_index = 0;\n    for i in 0..last_index {\n        if f(&v[i], &v[last_index]) {\n            v.swap(i, store_index);\n            store_index += 1;\n        }\n    }\n\n    v.swap(store_index, len - 1);\n    store_index\n}\n\nOutput:\nSort numbers in descending order\nBefore: [4, 65, 2, -31, 0, 99, 2, 83, 782, 1]\nAfter:  [782, 99, 83, 65, 4, 2, 2, 1, 0, -31]\n\nSort strings alphabetically\nBefore: [\"beach\", \"hotel\", \"airplane\", \"car\", \"house\", \"art\"]\nAfter:  [\"airplane\", \"art\", \"beach\", \"car\", \"hotel\", \"house\"]\n\nSort strings by length\nBefore: [\"airplane\", \"art\", \"beach\", \"car\", \"hotel\", \"house\"]\nAfter:  [\"car\", \"art\", \"house\", \"hotel\", \"beach\", \"airplane\"]\n\nfn main() {\n    let numbers = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"{:?}\\n\", quick_sort(numbers.iter()));\n}\n\nfn quick_sort<T, E>(mut v: T) -> Vec<E>\nwhere\n    T: Iterator<Item = E>,\n    E: PartialOrd,\n{\n    match v.next() {\n        None => Vec::new(),\n\n        Some(pivot) => {\n            let (lower, higher): (Vec<_>, Vec<_>) = v.partition(|it| it < &pivot);\n            let lower = quick_sort(lower.into_iter());\n            let higher = quick_sort(higher.into_iter());\n            lower.into_iter()\n                .chain(core::iter::once(pivot))\n                .chain(higher.into_iter())\n                .collect()\n        }\n    }\n}\n\n", "explain": "Or, using functional style (slower than the imperative style but faster than functional style in other languages):\nBy the way this implementation needs only O(n) memory because the partition(...) call already \"consumes\" v. This means that the memory of v will be freed here, before the recursive calls to quick_sort(...). If we tried to use v later, we would get a compilation error.\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Swift", "code": "\nfunc quicksort<T where T\u00a0: Comparable>(inout elements: [T], range: Range<Int>) {\n  if (range.endIndex - range.startIndex > 1) {\n    let pivotIndex = partition(&elements, range)\n    quicksort(&elements, range.startIndex ..< pivotIndex)\n    quicksort(&elements, pivotIndex+1 ..< range.endIndex)\n  }\n}\n\nfunc quicksort<T where T\u00a0: Comparable>(inout elements: [T]) {\n  quicksort(&elements, indices(elements))\n}\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "R", "code": "\nTranslation of: Octave\nqsort <- function(v) {\n  if ( length(v) > 1 ) \n  {\n    pivot <- (min(v) + max(v))/2.0                            # Could also use pivot <- median(v)\n    c(qsort(v[v < pivot]), v[v == pivot], qsort(v[v > pivot])) \n  } else v\n}\n\nN <- 100\nvs <- runif(N)\nsystem.time(u <- qsort(vs))\nprint(u)\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "COBOL", "code": "\nWorks with: Visual COBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. quicksort RECURSIVE.\n       \n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                   PIC S9(8).\n       \n       01  pivot                  PIC S9(8).\n       \n       01  left-most-idx          PIC 9(5).\n       01  right-most-idx         PIC 9(5).\n       \n       01  left-idx               PIC 9(5).\n       01  right-idx              PIC 9(5).\n       \n       LINKAGE SECTION.\n       78  Arr-Length             VALUE 50.\n       \n       01  arr-area.\n           03  arr                PIC S9(8) OCCURS Arr-Length TIMES.\n           \n       01  left-val               PIC 9(5).\n       01  right-val              PIC 9(5).  \n       \n       PROCEDURE DIVISION USING REFERENCE arr-area, OPTIONAL left-val,\n               OPTIONAL right-val.\n           IF left-val IS OMITTED OR right-val IS OMITTED\n               MOVE 1 TO left-most-idx, left-idx\n               MOVE Arr-Length TO right-most-idx, right-idx\n           ELSE\n               MOVE left-val TO left-most-idx, left-idx\n               MOVE right-val TO right-most-idx, right-idx\n           END-IF\n           \n           IF right-most-idx - left-most-idx < 1\n               GOBACK\n           END-IF\n       \n           COMPUTE pivot = arr ((left-most-idx + right-most-idx) / 2)\n       \n           PERFORM UNTIL left-idx > right-idx\n               PERFORM VARYING left-idx FROM left-idx BY 1\n                   UNTIL arr (left-idx) >= pivot\n               END-PERFORM\n               \n               PERFORM VARYING right-idx FROM right-idx BY -1\n                   UNTIL arr (right-idx) <= pivot\n               END-PERFORM\n               \n               IF left-idx <= right-idx\n                   MOVE arr (left-idx) TO temp\n                   MOVE arr (right-idx) TO arr (left-idx)\n                   MOVE temp TO arr (right-idx)\n                   \n                   ADD 1 TO left-idx\n                   SUBTRACT 1 FROM right-idx\n               END-IF\n           END-PERFORM\n       \n           CALL \"quicksort\" USING REFERENCE arr-area,\n               CONTENT left-most-idx, right-idx\n           CALL \"quicksort\" USING REFERENCE arr-area, CONTENT left-idx,\n               right-most-idx\n               \n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\n\nSub QuickSort(arr() As Integer, ByVal f As Integer, ByVal l As Integer)\n    i = f 'First\n    j = l 'Last\n    Key = arr(i) 'Pivot\n    Do While i < j\n        Do While i < j And Key < arr(j)\n            j = j - 1\n        Loop\n        If i < j Then arr(i) = arr(j): i = i + 1\n        Do While i < j And Key > arr(i)\n            i = i + 1\n        Loop\n        If i < j Then arr(j) = arr(i): j = j - 1\n    Loop\n    arr(i) = Key\n    If i - 1 > f Then QuickSort arr(), f, i - 1\n    If j + 1 < l Then QuickSort arr(), j + 1, l\nEnd Sub\n", "explain": "QuickSort without swapping\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Ada", "code": "\n\n-----------------------------------------------------------------------\n-- Generic Quick_Sort procedure\n-----------------------------------------------------------------------\ngeneric\n   type Element is private;\n   type Index is (<>);\n   type Element_Array is array(Index range <>) of Element;\n   with function \"<\" (Left, Right : Element) return Boolean is <>;\nprocedure Quick_Sort(A : in out Element_Array);\n\n\n-----------------------------------------------------------------------\n-- Generic Quick_Sort procedure\n----------------------------------------------------------------------- \n\nprocedure Quick_Sort (A : in out Element_Array) is\n   \n   procedure Swap(Left, Right : Index) is\n      Temp : Element := A (Left);\n   begin\n      A (Left) := A (Right);\n      A (Right) := Temp;\n   end Swap;\n  \nbegin\n   if A'Length > 1 then\n   declare\n      Pivot_Value : Element := A (A'First);\n      Right       : Index := A'Last;\n      Left        : Index := A'First;\n   begin\n       loop\n          while Left < Right and not (Pivot_Value < A (Left)) loop\n             Left := Index'Succ (Left);\n          end loop;\n          while Pivot_Value < A (Right) loop\n             Right := Index'Pred (Right);\n          end loop;\n          exit when Right <= Left;\n          Swap (Left, Right);\n          Left := Index'Succ (Left);\n          Right := Index'Pred (Right);\n       end loop;\n       if Right = A'Last then\n          Right := Index'Pred (Right);\n          Swap (A'First, A'Last);\n       end if;\n       if Left = A'First then\n          Left := Index'Succ (Left);\n       end if;\n       Quick_Sort (A (A'First .. Right));\n       Quick_Sort (A (Left .. A'Last));\n   end;\n   end if;\nend Quick_Sort;\n\n\nwith Ada.Text_Io;\nwith Ada.Float_Text_IO; use Ada.Float_Text_IO; \nwith Quick_Sort;\n\nprocedure Sort_Test is\n   type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n   type Sales is array (Days range <>) of Float;\n   procedure Sort_Days is new Quick_Sort(Float, Days, Sales);\n   \n   procedure Print (Item : Sales) is\n   begin\n      for I in Item'range loop\n         Put(Item => Item(I), Fore => 5, Aft => 2, Exp => 0);\n      end loop;\n   end Print;\n  \n   Weekly_Sales : Sales := (Mon => 300.0, \n      Tue => 700.0, \n      Wed => 800.0, \n      Thu => 500.0, \n      Fri => 200.0, \n      Sat => 100.0, \n      Sun => 900.0);\n  \nbegin\n  \n   Print(Weekly_Sales);\n   Ada.Text_Io.New_Line(2);\n   Sort_Days(Weekly_Sales);\n   Print(Weekly_Sales);\n  \nend Sort_Test;\n\n", "explain": "This example is implemented as a generic procedure.\nThe procedure specification is:\nThe procedure body deals with any discrete index type, either an integer type or an enumerated type.\nAn example of how this procedure may be used is:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Julia", "code": "\n\nsort!(A, alg=QuickSort)\n\n\nfunction quicksort!(A,i=1,j=length(A))\n    if j > i\n        pivot = A[rand(i:j)] # random element of A\n        left, right = i, j\n        while left <= right\n            while A[left] < pivot\n                left += 1\n            end\n            while A[right] > pivot\n                right -= 1\n            end\n            if left <= right\n                A[left], A[right] = A[right], A[left]\n                left += 1\n                right -= 1\n            end\n        end\n        quicksort!(A,i,right)\n        quicksort!(A,left,j)\n    end\n    return A\nend\n\n\nqsort(L) = isempty(L) ? L : vcat(qsort(filter(x -> x < L[1], L[2:end])), L[1:1], qsort(filter(x -> x >= L[1], L[2:end])))\n\n\nOutput:\njulia> A = [84,77,20,60,47,20,18,97,41,49,31,39,73,68,65,52,1,92,15,9]\n\njulia> qsort(A)\n[1,9,15,18,20,20,31,39,41,47,49,52,60,65,68,73,77,84,92,97]\n\njulia> quicksort!(copy(A))\n[1,9,15,18,20,20,31,39,41,47,49,52,60,65,68,73,77,84,92,97]\n\njulia> qsort(A) == quicksort!(copy(A)) == sort(A) == sort(A, alg=QuickSort)\ntrue\n", "explain": "Built-in function for in-place sorting via quicksort (the code from the standard library is quite readable):\nA simple polymorphic implementation of an in-place recursive quicksort (based on the pseudocode above):\nA one-line (but rather inefficient) implementation based on the Haskell version, which operates out-of-place and allocates temporary arrays:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Kotlin", "code": "\n\nfun <E : Comparable<E>> List<E>.qsort(): List<E> =\n        if (size < 2) this\n        else filter { it < first() }.qsort() +\n                filter { it == first() } +\n                filter { it > first() }.qsort()\n\n\nfun <E : Comparable<E>> List<E>.qsort(): List<E> =\n        if (size < 2) this\n        else {\n            val (less, high) = subList(1, size).partition { it < first() }\n            less.qsort() + first() + high.qsort()\n        }\n\n", "explain": "A version that reflects the algorithm directly:\nA more efficient version that does only one comparison per element:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Perl", "code": "\nsub quick_sort {\n    return @_ if @_ < 2;\n    my $p = splice @_, int rand @_, 1;\n    quick_sort(grep $_ < $p, @_), $p, quick_sort(grep $_ >= $p, @_);\n}\n\nmy @a = (4, 65, 2, -31, 0, 99, 83, 782, 1);\n@a = quick_sort @a;\nprint \"@a\\n\";\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Objective-C", "code": "\n\nvoid quicksortInPlace(NSMutableArray *array, NSInteger first, NSInteger last, NSComparator comparator) {\n    if (first >= last) return;\n    id pivot = array[(first + last) / 2];\n    NSInteger left = first;\n    NSInteger right = last;\n    while (left <= right) {\n        while (comparator(array[left], pivot) == NSOrderedAscending)\n            left++;\n        while (comparator(array[right], pivot) == NSOrderedDescending)\n            right--;\n        if (left <= right)\n            [array exchangeObjectAtIndex:left++ withObjectAtIndex:right--];\n    }\n    quicksortInPlace(array, first, right, comparator);\n    quicksortInPlace(array, left, last, comparator);\n}\n\nNSArray* quicksort(NSArray *unsorted, NSComparator comparator) {\n    NSMutableArray *a = [NSMutableArray arrayWithArray:unsorted];\n    quicksortInPlace(a, 0, a.count - 1, comparator);\n    return a;\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n        NSArray *a = @[ @1, @3, @5, @7, @9, @8, @6, @4, @2 ];\n        NSLog(@\"Unsorted:\u00a0%@\", a);\n        NSLog(@\"Sorted:\u00a0%@\", quicksort(a, ^(id x, id y) { return [x compare:y]; }));\n        NSArray *b = @[ @\"Emil\", @\"Peg\", @\"Helen\", @\"Juergen\", @\"David\", @\"Rick\", @\"Barb\", @\"Mike\", @\"Tom\" ];\n        NSLog(@\"Unsorted:\u00a0%@\", b);\n        NSLog(@\"Sorted:\u00a0%@\", quicksort(b, ^(id x, id y) { return [x compare:y]; }));\n    }\n    return 0;\n}\n\nOutput:\nUnsorted: (\n    1,\n    3,\n    5,\n    7,\n    9,\n    8,\n    6,\n    4,\n    2\n)\nSorted: (\n    1,\n    2,\n    3,\n    4,\n    5,\n    6,\n    7,\n    8,\n    9\n)\nUnsorted: (\n    Emil,\n    Peg,\n    Helen,\n    Juergen,\n    David,\n    Rick,\n    Barb,\n    Mike,\n    Tom\n)\nSorted: (\n    Barb,\n    David,\n    Emil,\n    Helen,\n    Juergen,\n    Mike,\n    Peg,\n    Rick,\n    Tom\n)\n", "explain": "The latest XCode compiler is assumed with ARC enabled.\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Prolog", "code": "\nqsort( [], [] ).\nqsort( [H|U], S )\u00a0:- splitBy(H, U, L, R), qsort(L, SL), qsort(R, SR), append(SL, [H|SR], S).\n\n% splitBy( H, U, LS, RS )\n% True if LS = { L in U | L <= H }; RS = { R in U | R > H }\nsplitBy( _, [], [], []).\nsplitBy( H, [U|T], [U|LS], RS )\u00a0:- U =< H, splitBy(H, T, LS, RS).\nsplitBy( H, [U|T], LS, [U|RS] )\u00a0:- U  > H, splitBy(H, T, LS, RS).\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Lua", "code": "\nNOTE: If you want to use quicksort in a Lua script, you don't need to implement it yourself. Just do: table.sort(tableName)\nin-place[edit]\n--in-place quicksort\nfunction quicksort(t, start, endi)\n  start, endi = start or 1, endi or #t\n  --partition w.r.t. first element\n  if(endi - start < 1) then return t end\n  local pivot = start\n  for i = start + 1, endi do\n    if t[i] <= t[pivot] then\n      if i == pivot + 1 then\n        t[pivot],t[pivot+1] = t[pivot+1],t[pivot]\n      else\n        t[pivot],t[pivot+1],t[i] = t[i],t[pivot],t[pivot+1]\n      end\n      pivot = pivot + 1\n    end\n  end\n  t = quicksort(t, start, pivot - 1)\n  return quicksort(t, pivot + 1, endi)\nend\n\n--example\nprint(unpack(quicksort{5, 2, 7, 3, 4, 7, 1}))\n\nnon in-place[edit]\nfunction quicksort(t)\n  if #t<2 then return t end\n  local pivot=t[1]\n  local a,b,c={},{},{}\n  for _,v in ipairs(t) do\n    if     v<pivot then a[#a+1]=v\n    elseif v>pivot then c[#c+1]=v\n    else                b[#b+1]=v\n    end\n  end\n  a=quicksort(a)\n  c=quicksort(c)\n  for _,v in ipairs(b) do a[#a+1]=v end\n  for _,v in ipairs(c) do a[#a+1]=v end\n  return a\nend\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Scala", "code": "\n\n  def sort(xs: List[Int]): List[Int] = xs match {\n    case Nil => Nil\n    case head\u00a0:: tail =>\n      val (less, notLess) = tail.partition(_ < head) // Arbitrarily partition list in two\n      sort(less) ++ (head\u00a0:: sort(notLess))          // Sort each half\n  }\n\n  def sort[T](xs: List[T], lessThan: (T, T) => Boolean): List[T] = xs match {\n    case Nil => Nil\n    case x\u00a0:: xx =>\n      val (lo, hi) = xx.partition(lessThan(_, x))\n      sort(lo, lessThan) ++ (x\u00a0:: sort(hi, lessThan))\n  }\n\n  def sort[T](xs: List[T])(implicit ord: Ordering[T]): List[T] = xs match {\n    case Nil => Nil\n    case x\u00a0:: xx =>\n      val (lo, hi) = xx.partition(ord.lt(_, x))\n      sort[T](lo) ++ (x\u00a0:: sort[T](hi))\n  }\n\n  def sort[T <: Ordered[T]](xs: List[T]): List[T] = xs match {\n    case Nil => Nil\n    case x\u00a0:: xx =>\n      val (lo, hi) = xx.partition(_ < x)\n      sort(lo) ++ (x\u00a0:: sort(hi))\n  }\n\n  def sort[T, C[T] <: scala.collection.TraversableLike[T, C[T]]]\n    (xs: C[T])\n    (implicit ord: scala.math.Ordering[T],\n      cbf: scala.collection.generic.CanBuildFrom[C[T], T, C[T]]): C[T] = {\n    // Some collection types can't pattern match\n    if (xs.isEmpty) {\n      xs\n    } else {\n      val (lo, hi) = xs.tail.partition(ord.lt(_, xs.head))\n      val b = cbf()\n      b.sizeHint(xs.size)\n      b ++= sort(lo)\n      b += xs.head\n      b ++= sort(hi)\n      b.result()\n    }\n  }\n\n", "explain": "What follows is a progression on genericity here.\nFirst, a quick sort of a list of integers:\nNext, a quick sort of a list of some type T, given a lessThan function:\nTo take advantage of known orderings, a quick sort of a list of some type T,\nfor which exists an implicit (or explicit) Ordering[T]:\nThat last one could have worked with Ordering, but Ordering is Java, and doesn't have\nthe less than operator. Ordered is Scala-specific, and provides it.\nWhat hasn't changed in all these examples is ordering a list. It is possible\nto write a generic quicksort in Scala, which will order any kind of collection. To do\nso, however, requires that the type of the collection, itself, be made a parameter to\nthe function. Let's see it below, and then remark upon it:\nThe type of our collection is \"C[T]\", and,\nby providing C[T] as a type parameter to TraversableLike, we ensure C[T] is capable\nof returning instances of type C[T]. Traversable is the base type of all collections,\nand TraversableLike is a trait which contains the implementation of most Traversable\nmethods.\nWe need another parameter, though, which is a factory capable of building a C[T] collection.\nThat is being passed implicitly, so callers to this method do not need to provide them, as\nthe collection they are using should already provide one as such implicitly. Because we need that\nimplicitly, then we need to ask for the \"T => Ordering[T]\" as well, as the \"T <: Ordered[T]\"\nwhich provides it cannot be used in conjunction with implicit parameters.\nThe body of the function is from the list variant, since many of the Traversable\ncollection types don't support pattern matching, \"+:\" or \"::\".\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Dart", "code": "\nquickSort(List a) {\n  if (a.length <= 1) {\n    return a;\n  }\n  \n  var pivot = a[0];\n  var less = [];\n  var more = [];\n  var pivotList = [];\n  \n  // Partition\n  a.forEach((var i){    \n    if (i.compareTo(pivot) < 0) {\n      less.add(i);\n    } else if (i.compareTo(pivot) > 0) {\n      more.add(i);\n    } else {\n      pivotList.add(i);\n    }\n  });\n  \n  // Recursively sort sublists\n  less = quickSort(less);\n  more = quickSort(more);\n  \n  // Concatenate results\n  less.addAll(pivotList);\n  less.addAll(more);\n  return less;\n}\n\nvoid main() {\n  var arr=[1,5,2,7,3,9,4,6,8];\n  print(\"Before sort\");\n  arr.forEach((var i)=>print(\"$i\"));\n  arr = quickSort(arr);\n  print(\"After sort\");\n  arr.forEach((var i)=>print(\"$i\"));\n}\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "D", "code": "\n\nimport std.stdio : writefln, writeln;\nimport std.algorithm: filter;\nimport std.array;\n\nT[] quickSort(T)(T[] xs) => \n  xs.length == 0 ? [] :  \n    xs[1 .. $].filter!(x => x< xs[0]).array.quickSort ~  \n    xs[0 .. 1] ~  \n    xs[1 .. $].filter!(x => x>=xs[0]).array.quickSort; \n\nvoid main() =>\n  [4, 65, 2, -31, 0, 99, 2, 83, 782, 1].quickSort.writeln;\n\n\nOutput:\n[-31, 0, 1, 2, 2, 4, 65, 83, 99, 782]\n\nimport std.stdio, std.array;\n\nT[] quickSort(T)(T[] items) pure nothrow {\n    if (items.empty)\n        return items;\n    T[] less, notLess;\n    foreach (x; items[1 .. $])\n        (x < items[0] ? less : notLess) ~= x;\n    return less.quickSort ~ items[0] ~ notLess.quickSort;\n}\n\nvoid main() {\n    [4, 65, 2, -31, 0, 99, 2, 83, 782, 1].quickSort.writeln;\n}\n\n\nimport std.stdio, std.algorithm;\n\nvoid quickSort(T)(T[] items) pure nothrow @safe @nogc {\n    if (items.length >= 2) {\n        auto parts = partition3(items, items[$ / 2]);\n        parts[0].quickSort;\n        parts[2].quickSort;\n    }\n}\n\nvoid main() {\n    auto items = [4, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    items.quickSort;\n    items.writeln;\n}\n\n", "explain": "A Functional version\nA simple high-level version (same output):\nOften short functional sieves are not a true implementations of the Sieve of Eratosthenes:\nhttp://www.cs.hmc.edu/~oneill/papers/Sieve-JFP.pdf\nSimilarly, one could argue that a true QuickSort is in-place, \nas this more efficient version (same output):\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Haskell", "code": "\n\nqsort [] = []\nqsort (x:xs) = qsort [y | y <- xs, y < x] ++ [x] ++ qsort [y | y <- xs, y >= x]\n\n\nimport Data.List (partition)\n\nqsort :: Ord a => [a] -> [a]\nqsort [] = []\nqsort (x:xs) = qsort ys ++ [x] ++ qsort zs where\n    (ys, zs) = partition (< x) xs\n\n", "explain": "The famous two-liner, reflecting the underlying algorithm directly:\nA more efficient version, doing only one comparison per element:\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "VBScript", "code": "\nTranslation of: BBC BASIC\nFunction quicksort(arr,s,n)\n\tIf n < 2 Then\n\t\tExit Function\n\tEnd If\n\tt = s + n - 1\n\tl = s\n\tr = t\n\tp = arr(Int((l + r)/2))\n\tDo Until l > r\n\t\tDo While arr(l) < p\n\t\t\tl = l + 1\n\t\tLoop\n\t\tDo While arr(r) > p\n\t\t\tr = r -1\n\t\tLoop\n\t\tIf l <= r Then\n\t\t\ttmp = arr(l)\n\t\t\tarr(l) = arr(r)\n\t\t\tarr(r) = tmp\n\t\t\tl = l + 1\n\t\t\tr = r - 1\n\t\tEnd If\n\tLoop\n\tIf s < r Then\n\t\tCall quicksort(arr,s,r-s+1)\n\tEnd If\n\tIf l < t Then\n\t\tCall quicksort(arr,l,t-l+1)\n\tEnd If\n\tquicksort = arr\nEnd Function\n\nmyarray=Array(9,8,7,6,5,5,4,3,2,1,0,-1)\nm = quicksort(myarray,0,12)\nWScript.Echo Join(m,\",\")\n\nOutput:\n-1,0,1,2,3,4,5,5,6,7,8,9\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Scheme", "code": "\nList quicksort[edit]\n(define (split-by l p k)\n  (let loop ((low '())\n             (high '())\n             (l l))\n    (cond ((null? l)\n           (k low high))\n          ((p (car l))\n           (loop low (cons (car l) high) (cdr l)))\n          (else\n           (loop (cons (car l) low) high (cdr l))))))\n \n(define (quicksort l gt?)\n  (if (null? l)\n      '()\n      (split-by (cdr l) \n                (lambda (x) (gt? x (car l)))\n                (lambda (low high)\n                  (append (quicksort low gt?)\n                          (list (car l))\n                          (quicksort high gt?))))))\n\n(quicksort '(1 3 5 7 9 8 6 4 2) >)\n\n(define (quicksort l gt?)\n  (if (null? l)\n      '()\n      (append (quicksort (filter (lambda (x) (gt? (car l) x)) (cdr l)) gt?)\n              (list (car l))\n              (quicksort (filter (lambda (x) (not (gt? (car l) x))) (cdr l)) gt?))))\n\n(quicksort '(1 3 5 7 9 8 6 4 2) >)\n\nVector quicksort (in place)[edit]\nWorks with: Chibi Scheme\nWorks with: Gauche Scheme\nWorks with: CHICKEN Scheme version 5.3.0\nFor CHICKEN:Library: r7rs\n\n;;;-------------------------------------------------------------------\n;;;\n;;; Quicksort in R7RS Scheme, working in-place on vectors (that is,\n;;; arrays). I closely follow the \"better quicksort algorithm\"\n;;; pseudocode, and thus the code is more \"procedural\" than\n;;; \"functional\".\n;;;\n;;; I use a random pivot. If you can generate a random number quickly,\n;;; this is a good method, but for this demonstration I have taken a\n;;; fast linear congruential generator and made it brutally slow. It's\n;;; just a demonstration.\u00a0:)\n;;;\n\n(import (scheme base))\n(import (scheme case-lambda))\n(import (scheme write))\n\n;;;-------------------------------------------------------------------\n;;;\n;;; Add \"while\" loops to the language.\n;;;\n\n(define-syntax while\n  (syntax-rules ()\n    ((_ pred? body ...)\n     (let loop ()\n       (when pred?\n         (begin body ...)\n         (loop))))))\n\n;;;-------------------------------------------------------------------\n;;;\n;;; In-place quicksort.\n;;;\n\n(define vector-quicksort!\n  (case-lambda\n\n   \u00a0;; Use a default pivot selector.\n    ((<? vec)\n    \u00a0;; Random pivot.\n     (vector-quicksort! (lambda (vec i-first i-last)\n                          (vector-ref vec (randint i-first i-last)))\n                        <? vec))\n\n   \u00a0;; Specify a pivot selector.\n    ((pivot-select <? vec)\n    \u00a0;;\n    \u00a0;; The recursion:\n    \u00a0;;\n     (let quicksort! ((i-first 0)\n                      (i-last (- (vector-length vec) 1)))\n       (let ((n (- i-last i-first -1)))\n         (when (> n 1)\n           (let* ((pivot (pivot-select vec i-first i-last)))\n             (let ((left i-first)\n                   (right i-last))\n               (while (<= left right)\n                 (while (< (vector-ref vec left) pivot)\n                   (set! left (+ left 1)))\n                 (while (> (vector-ref vec right) pivot)\n                   (set! right (- right 1)))\n                 (when (<= left right)\n                   (let ((lft (vector-ref vec left))\n                         (rgt (vector-ref vec right)))\n                     (vector-set! vec left rgt)\n                     (vector-set! vec right lft)\n                     (set! left (+ left 1))\n                     (set! right (- right 1)))))\n               (quicksort! i-first right)\n               (quicksort! left i-last)))))))))\n\n;;;-------------------------------------------------------------------\n;;;\n;;; A simple linear congruential generator, attributed by\n;;; https://en.wikipedia.org/w/index.php?title=Linear_congruential_generator&oldid=1083800601\n;;; to glibc and GCC. No attempt has been made to optimize this code.\n;;;\n\n(define seed 1)\n(define two**31 (expt 2 31))\n(define (random-integer)\n  (let* ((s0 seed)\n         (s1 (truncate-remainder (+ (* 1103515245 s0) 12345)\n                                 two**31)))\n    (set! seed s1)\n    s0))\n(define randint\n  (case-lambda\n    ((n) (truncate-remainder (random-integer) n))\n    ((i-first i-last) (+ i-first (randint (- i-last i-first -1))))))\n\n;;;-------------------------------------------------------------------\n;;;\n;;; A demonstration of in-place vector quicksort.\n;;;\n\n(define vec1 (vector-copy #(60 53 100 72 19 67 14\n                               31 4 1 5 9 2 6 5 3 5 8\n                               28 9 95 22 67 55 20 41\n                               42 29 20 74 39)))\n(vector-quicksort! < vec1)\n(write vec1)\n(newline)\n\n;;;-------------------------------------------------------------------\n\nOutput:\n$ gosh vector-quicksort.scm\n#(1 2 3 4 5 5 5 6 8 9 9 14 19 20 20 22 28 29 31 39 41 42 53 55 60 67 67 72 74 95 100)\n", "explain": "With srfi-1:\n\n\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "TypeScript", "code": "\n/**\n  Generic quicksort function using typescript generics.\n  Follows quicksort as done in CLRS.\n*/\nexport type Comparator<T> = (o1: T, o2: T) => number;\n\n\nexport function quickSort<T>(array: T[], compare: Comparator<T>) {\n  if (array.length <= 1 || array == null) {\n    return;\n  }\n  sort(array, compare, 0, array.length - 1);\n}\n\nfunction sort<T>(\n    array: T[], compare: Comparator<T>, low: number, high: number) {\n  if (low < high) {\n    const partIndex = partition(array, compare, low, high);\n    sort(array, compare, low, partIndex - 1);\n    sort(array, compare, partIndex + 1, high);\n  }\n}\n\nfunction partition<T>(\n    array: T[], compare: Comparator<T>, low: number, high: number): number {\n  const pivot: T = array[high];\n  let i: number = low - 1;\n  for (let j = low; j <= high - 1; j++) {\n    if (compare(array[j], pivot) == -1) {\n      i = i + 1;\n      swap(array, i, j)\n    }\n  }\n  if (compare(array[high], array[i + 1]) == -1) {\n    swap(array, i + 1, high);\n  }\n  return i + 1;\n}\n\nfunction swap<T>(array: T[], i: number, j: number) {\n  const newJ: T = array[i];\n  array[i] = array[j];\n  array[j] = newJ;\n}\n\nexport function testQuickSort(): void {\n  function numberComparator(o1: number, o2: number): number {\n    if (o1 < o2) {\n      return -1;\n    } else if (o1 == o2) {\n      return 0;\n    }\n    return 1;\n  }\n  let tests: number[][] = [\n    [], [1], [2, 1], [-1, 2, -3], [3, 16, 8, -5, 6, 4], [1, 2, 3, 4, 5, 6],\n    [1, 2, 3, 4, 5]\n  ];\n\n  for (let testArray of tests) {\n    quickSort(testArray, numberComparator);\n    console.log(testArray);\n  }\n}\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "PowerShell", "code": "\nFirst solution[edit]\nFunction SortThree( [Array] $data )\n{\n\tif( $data[ 0 ] -gt $data[ 1 ] )\n\t{\n\t\tif( $data[ 0 ] -lt $data[ 2 ] )\n\t\t{\n\t\t\t$data = $data[ 1, 0, 2 ]\n\t\t} elseif ( $data[ 1 ] -lt $data[ 2 ] ){\n\t\t\t$data = $data[ 1, 2, 0 ]\n\t\t} else {\n\t\t\t$data = $data[ 2, 1, 0 ]\n\t\t}\n\t} else {\n\t\tif( $data[ 0 ] -gt $data[ 2 ] )\n\t\t{\n\t\t\t$data = $data[ 2, 0, 1 ]\n\t\t} elseif( $data[ 1 ] -gt $data[ 2 ] ) {\n\t\t\t$data = $data[ 0, 2, 1 ]\n\t\t}\n\t}\n\t$data\n}\n\nFunction QuickSort( [Array] $data, $rand = ( New-Object Random ) )\n{\n\t$datal = $data.length\n\tif( $datal -gt 3 )\n\t{\n\t\t[void] $datal--\n\t\t$median = ( SortThree $data[ 0, ( $rand.Next( 1, $datal - 1 ) ), -1 ] )[ 1 ]\n\t\t$lt = @()\n\t\t$eq = @()\n\t\t$gt = @()\n\t\t$data | ForEach-Object { if( $_ -lt $median ) { $lt += $_ } elseif( $_ -eq $median ) { $eq += $_ } else { $gt += $_ } }\n\t\t$lt = ( QuickSort $lt $rand )\n\t\t$gt = ( QuickSort $gt $rand )\n\t\t$data = @($lt) + $eq + $gt\n\t} elseif( $datal -eq 3 ) {\n\t\t$data = SortThree( $data )\n\t} elseif( $datal -eq 2 ) {\n\t\tif( $data[ 0 ] -gt $data[ 1 ] )\n\t\t{\n\t\t\t$data = $data[ 1, 0 ]\n\t\t}\n\t}\n\t$data\n}\n\nQuickSort 5,3,1,2,4 \nQuickSort 'e','c','a','b','d' \nQuickSort 0.5,0.3,0.1,0.2,0.4 \n$l = 100; QuickSort ( 1..$l | ForEach-Object { $Rand = New-Object Random }{ $Rand.Next( 0, $l - 1 ) } )\n\nAnother solution[edit]\nfunction quicksort($array) {\n    $less, $equal, $greater = @(), @(), @()\n    if( $array.Count -gt 1 ) { \n        $pivot = $array[0]\n        foreach( $x in $array) {\n            if($x -lt $pivot) { $less += @($x) }\n            elseif ($x -eq $pivot) { $equal += @($x)}\n            else { $greater += @($x) }\n        }    \n        $array = (@(quicksort $less) + @($equal) + @(quicksort $greater))\n    }\n    $array\n}\n$array = @(60, 21, 19, 36, 63, 8, 100, 80, 3, 87, 11)\n\"$(quicksort $array)\"\nThe output is: 3 8 11 19 21 36 60 63 80 87 100\n\nYet another solution[edit]\nfunction quicksort($in) {\n    $n = $in.count\n    switch ($n) {\n        0 {}\n        1 { $in[0] }\n        2 { if ($in[0] -lt $in[1]) {$in[0], $in[1]} else {$in[1], $in[0]} }\n        default {\n            $pivot = $in | get-random\n            $lt = $in |\u00a0? {$_ -lt $pivot}\n            $eq = $in |\u00a0? {$_ -eq $pivot}\n            $gt = $in |\u00a0? {$_ -gt $pivot}\n            @(quicksort $lt) + @($eq) + @(quicksort $gt)\n        }\n    }\n}\n", "explain": "\n\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "Logo", "code": "\n; quicksort (lists, functional)\n\nto small? :list\n  output or [empty? :list] [empty? butfirst :list]\nend\nto quicksort :list\n  if small? :list [output :list]\n  localmake \"pivot first :list\n  output (sentence\n    quicksort filter [? < :pivot] butfirst :list\n              filter [? = :pivot]          :list\n    quicksort filter [? > :pivot] butfirst :list\n  )\nend\n\nshow quicksort [1 3 5 7 9 8 6 4 2]\n; quicksort (arrays, in-place)\n\nto incr :name\n  make :name (thing :name) + 1\nend\nto decr :name\n  make :name (thing :name) - 1\nend\nto swap :i :j :a\n  localmake \"t item :i :a\n  setitem :i :a item :j :a\n  setitem :j :a :t\nend\n\nto quick :a :low :high\n  if :high <= :low [stop]\n  localmake \"l :low\n  localmake \"h :high\n  localmake \"pivot item ashift (:l + :h) -1  :a\n  do.while [\n    while [(item :l :a) < :pivot] [incr \"l]\n    while [(item :h :a) > :pivot] [decr \"h]\n    if :l <= :h [swap :l :h :a  incr \"l  decr \"h]\n  ] [:l <= :h]\n  quick :a :low :h\n  quick :a :l :high\nend\nto sort :a\n  quick :a first :a count :a\nend\n\nmake \"test {1 3 5 7 9 8 6 4 2}\nsort :test\nshow :test\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "ABAP", "code": "\n\nreport z_quicksort.\n\ndata(numbers) = value int4_table( ( 4 ) ( 65 ) ( 2 ) ( -31 ) ( 0 ) ( 99 ) ( 2 ) ( 83 ) ( 782 ) ( 1 ) ).\nperform quicksort changing numbers.\n\nwrite `[`.\nloop at numbers assigning field-symbol(<numbers>).\n  write <numbers>.\nendloop.\nwrite `]`.\n\nform quicksort changing numbers type int4_table.\n  data(less) = value int4_table( ).\n  data(equal) = value int4_table( ).\n  data(greater) = value int4_table( ).\n\n  if lines( numbers ) > 1.\n    data(pivot) = numbers[ lines( numbers ) / 2 ].\n\n    loop at numbers assigning field-symbol(<number>).\n      if <number> < pivot.\n        append <number> to less.\n      elseif <number> = pivot.\n        append <number> to equal.\n      elseif <number> > pivot.\n        append <number> to greater.\n      endif.\n    endloop.\n\n    perform quicksort changing less.\n    perform quicksort changing greater.\n\n    clear numbers.\n    append lines of less to numbers.\n    append lines of equal to numbers.\n    append lines of greater to numbers.\n  endif.\nendform.\n\n\nOutput:\n[        31-         0          1          2          2          4         65         83         99        782  ]\n\n", "explain": "This works for ABAP Version 7.40 and above\n"}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "F#", "code": "\nlet rec qsort = function\n    hd :: tl ->\n        let less, greater = List.partition ((>=) hd) tl\n        List.concat [qsort less; [hd]; qsort greater]\n    | _ -> []\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Quicksort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Quicksort", "task_cat": "Sorting", "lang": "AWK", "code": "\n# the following qsort implementation extracted from:\n#\n#       ftp://ftp.armory.com/pub/lib/awk/qsort\n#\n# Copyleft GPLv2 John DuBois\n#\n# @(#) qsort 1.2.1 2005-10-21\n# 1990 john h. dubois iii (john@armory.com)\n#\n# qsortArbIndByValue(): Sort an array according to the values of its elements.\n#\n# Input variables:\n#\n# Arr[] is an array of values with arbitrary (associative) indices.\n#\n# Output variables:\n#\n# k[] is returned with numeric indices 1..n.  The values assigned to these\n# indices are the indices of Arr[], ordered so that if Arr[] is stepped\n# through in the order Arr[k[1]] .. Arr[k[n]], it will be stepped through in\n# order of the values of its elements.\n#\n# Return value: The number of elements in the arrays (n).\n#\n# NOTES:\n#\n# Full example for accessing results:\n#\n#       foolist[\"second\"] = 2;\n#       foolist[\"zero\"] = 0;\n#       foolist[\"third\"] = 3;\n#       foolist[\"first\"] = 1;\n#\n#       outlist[1] = 0;\n#       n = qsortArbIndByValue(foolist, outlist)\n#\n#       for (i = 1; i <= n; i++) {\n#               printf(\"item at %s has value %d\\n\", outlist[i], foolist[outlist[i]]);\n#       }\n#      delete outlist; \n#\nfunction qsortArbIndByValue(Arr, k,\n                            ArrInd, ElNum)\n{\n        ElNum = 0;\n        for (ArrInd in Arr) {\n                k[++ElNum] = ArrInd;\n        }\n        qsortSegment(Arr, k, 1, ElNum);\n        return ElNum;\n}\n#\n# qsortSegment(): Sort a segment of an array.\n#\n# Input variables:\n#\n# Arr[] contains data with arbitrary indices.\n#\n# k[] has indices 1..nelem, with the indices of Arr[] as values.\n#\n# Output variables:\n#\n# k[] is modified by this function.  The elements of Arr[] that are pointed to\n# by k[start..end] are sorted, with the values of elements of k[] swapped\n# so that when this function returns, Arr[k[start..end]] will be in order.\n#\n# Return value: None.\n#\nfunction qsortSegment(Arr, k, start, end,\n                      left, right, sepval, tmp, tmpe, tmps)\n{\n        if ((end - start) < 1) {        # 0 or 1 elements\n                return;\n        }\n        # handle two-element case explicitly for a tiny speedup\n        if ((end - start) == 1) {\n                if (Arr[tmps = k[start]] > Arr[tmpe = k[end]]) {\n                        k[start] = tmpe;\n                        k[end] = tmps;\n                }\n                return;\n        }\n        # Make sure comparisons act on these as numbers\n        left = start + 0;\n        right = end + 0;\n        sepval = Arr[k[int((left + right) / 2)]];\n        # Make every element <= sepval be to the left of every element > sepval\n        while (left < right) {\n                while (Arr[k[left]] < sepval) {\n                        left++;\n                }\n                while (Arr[k[right]] > sepval) {\n                        right--;\n                }\n                if (left < right) {\n                        tmp = k[left];\n                        k[left++] = k[right];\n                        k[right--] = tmp;\n                }\n        }\n        if (left == right)\n                if (Arr[k[left]] < sepval) {\n                        left++;\n                } else {\n                        right--;\n                }\n        if (start < right) {\n                qsortSegment(Arr, k, start, right);\n        }\n        if (left < end) {\n                qsortSegment(Arr, k, left, end);\n        }\n}\n\n", "explain": ""}]