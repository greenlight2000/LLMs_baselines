[{"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nimport copy\n\nguyprefers = {\n 'abe':  ['abi', 'eve', 'cath', 'ivy', 'jan', 'dee', 'fay', 'bea', 'hope', 'gay'],\n 'bob':  ['cath', 'hope', 'abi', 'dee', 'eve', 'fay', 'bea', 'jan', 'ivy', 'gay'],\n 'col':  ['hope', 'eve', 'abi', 'dee', 'bea', 'fay', 'ivy', 'gay', 'cath', 'jan'],\n 'dan':  ['ivy', 'fay', 'dee', 'gay', 'hope', 'eve', 'jan', 'bea', 'cath', 'abi'],\n 'ed':   ['jan', 'dee', 'bea', 'cath', 'fay', 'eve', 'abi', 'ivy', 'hope', 'gay'],\n 'fred': ['bea', 'abi', 'dee', 'gay', 'eve', 'ivy', 'cath', 'jan', 'hope', 'fay'],\n 'gav':  ['gay', 'eve', 'ivy', 'bea', 'cath', 'abi', 'dee', 'hope', 'jan', 'fay'],\n 'hal':  ['abi', 'eve', 'hope', 'fay', 'ivy', 'cath', 'jan', 'bea', 'gay', 'dee'],\n 'ian':  ['hope', 'cath', 'dee', 'gay', 'bea', 'abi', 'fay', 'ivy', 'jan', 'eve'],\n 'jon':  ['abi', 'fay', 'jan', 'gay', 'eve', 'bea', 'dee', 'cath', 'ivy', 'hope']}\ngalprefers = {\n 'abi':  ['bob', 'fred', 'jon', 'gav', 'ian', 'abe', 'dan', 'ed', 'col', 'hal'],\n 'bea':  ['bob', 'abe', 'col', 'fred', 'gav', 'dan', 'ian', 'ed', 'jon', 'hal'],\n 'cath': ['fred', 'bob', 'ed', 'gav', 'hal', 'col', 'ian', 'abe', 'dan', 'jon'],\n 'dee':  ['fred', 'jon', 'col', 'abe', 'ian', 'hal', 'gav', 'dan', 'bob', 'ed'],\n 'eve':  ['jon', 'hal', 'fred', 'dan', 'abe', 'gav', 'col', 'ed', 'ian', 'bob'],\n 'fay':  ['bob', 'abe', 'ed', 'ian', 'jon', 'dan', 'fred', 'gav', 'col', 'hal'],\n 'gay':  ['jon', 'gav', 'hal', 'fred', 'bob', 'abe', 'col', 'ed', 'dan', 'ian'],\n 'hope': ['gav', 'jon', 'bob', 'abe', 'ian', 'dan', 'hal', 'ed', 'col', 'fred'],\n 'ivy':  ['ian', 'col', 'hal', 'gav', 'fred', 'bob', 'abe', 'ed', 'jon', 'dan'],\n 'jan':  ['ed', 'hal', 'gav', 'abe', 'bob', 'jon', 'col', 'ian', 'fred', 'dan']}\n\nguys = sorted(guyprefers.keys())\ngals = sorted(galprefers.keys())\n\n\ndef check(engaged):\n    inverseengaged = dict((v,k) for k,v in engaged.items())\n    for she, he in engaged.items():\n        shelikes = galprefers[she]\n        shelikesbetter = shelikes[:shelikes.index(he)]\n        helikes = guyprefers[he]\n        helikesbetter = helikes[:helikes.index(she)]\n        for guy in shelikesbetter:\n            guysgirl = inverseengaged[guy]\n            guylikes = guyprefers[guy]\n            if guylikes.index(guysgirl) > guylikes.index(she):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (she, guy, he, guysgirl))\n                return False\n        for gal in helikesbetter:\n            girlsguy = engaged[gal]\n            gallikes = galprefers[gal]\n            if gallikes.index(girlsguy) > gallikes.index(he):\n                print(\"%s and %s like each other better than \"\n                      \"their present partners: %s and %s, respectively\"\n                      % (he, gal, she, girlsguy))\n                return False\n    return True\n\ndef matchmaker():\n    guysfree = guys[:]\n    engaged  = {}\n    guyprefers2 = copy.deepcopy(guyprefers)\n    galprefers2 = copy.deepcopy(galprefers)\n    while guysfree:\n        guy = guysfree.pop(0)\n        guyslist = guyprefers2[guy]\n        gal = guyslist.pop(0)\n        fiance = engaged.get(gal)\n        if not fiance:\n            # She's free\n            engaged[gal] = guy\n            print(\"  %s and %s\" % (guy, gal))\n        else:\n            # The bounder proposes to an engaged lass!\n            galslist = galprefers2[gal]\n            if galslist.index(fiance) > galslist.index(guy):\n                # She prefers new guy\n                engaged[gal] = guy\n                print(\"  %s dumped %s for %s\" % (gal, fiance, guy))\n                if guyprefers2[fiance]:\n                    # Ex has more girls to try\n                    guysfree.append(fiance)\n            else:\n                # She is faithful to old fiance\n                if guyslist:\n                    # Look again\n                    guysfree.append(guy)\n    return engaged\n\n\nprint('\\nEngagements:')\nengaged = matchmaker()\n\nprint('\\nCouples:')\nprint('  ' + ',\\n  '.join('%s is engaged to %s' % couple\n                          for couple in sorted(engaged.items())))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\nprint('\\n\\nSwapping two fiances to introduce an error')\nengaged[gals[0]], engaged[gals[1]] = engaged[gals[1]], engaged[gals[0]]\nfor gal in gals[:2]:\n    print('  %s is now engaged to %s' % (gal, engaged[gal]))\nprint()\nprint('Engagement stability check PASSED'\n      if check(engaged) else 'Engagement stability check FAILED')\n\n\nOutput:\nEngagements:\n  abe and abi\n  bob and cath\n  col and hope\n  dan and ivy\n  ed and jan\n  fred and bea\n  gav and gay\n  hope dumped col for ian\n  abi dumped abe for jon\n  hal and eve\n  col and dee\n  ivy dumped dan for abe\n  dan and fay\n\nCouples:\n  abi is engaged to jon,\n  bea is engaged to fred,\n  cath is engaged to bob,\n  dee is engaged to col,\n  eve is engaged to hal,\n  fay is engaged to dan,\n  gay is engaged to gav,\n  hope is engaged to ian,\n  ivy is engaged to abe,\n  jan is engaged to ed\n\nEngagement stability check PASSED\n\n\nSwapping two fiances to introduce an error\n  abi is now engaged to fred\n  bea is now engaged to jon\n\nfay and jon like each other better than their present partners: dan and bea, respectively\nEngagement stability check FAILED\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdio.h>\n\nint verbose = 0;\nenum {\n\tclown = -1,\n\tabe, bob, col, dan, ed, fred, gav, hal, ian, jon,\n\tabi, bea, cath, dee, eve, fay, gay, hope, ivy, jan,\n};\nconst char *name[] = {\n\t\"Abe\", \"Bob\", \"Col\",  \"Dan\", \"Ed\",  \"Fred\", \"Gav\", \"Hal\",  \"Ian\", \"Jon\",\n\t\"Abi\", \"Bea\", \"Cath\", \"Dee\", \"Eve\", \"Fay\",  \"Gay\", \"Hope\", \"Ivy\", \"Jan\"\n};\nint pref[jan + 1][jon + 1] = {\n\t{ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay },\n\t{ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay },\n\t{ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan },\n\t{ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi },\n\t{ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay },\n\t{ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay },\n\t{ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay },\n\t{ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee },\n\t{ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve },\n\t{ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope },\n\n\t{ bob, fred, jon, gav, ian, abe, dan, ed, col, hal   },\n\t{ bob, abe, col, fred, gav, dan, ian, ed, jon, hal   },\n\t{ fred, bob, ed, gav, hal, col, ian, abe, dan, jon   },\n\t{ fred, jon, col, abe, ian, hal, gav, dan, bob, ed   },\n\t{ jon, hal, fred, dan, abe, gav, col, ed, ian, bob   },\n\t{ bob, abe, ed, ian, jon, dan, fred, gav, col, hal   },\n\t{ jon, gav, hal, fred, bob, abe, col, ed, dan, ian   },\n\t{ gav, jon, bob, abe, ian, dan, hal, ed, col, fred   },\n\t{ ian, col, hal, gav, fred, bob, abe, ed, jon, dan   },\n\t{ ed, hal, gav, abe, bob, jon, col, ian, fred, dan   },\n};\nint pairs[jan + 1], proposed[jan + 1];\n\nvoid engage(int man, int woman)\n{\n\tpairs[man] = woman;\n\tpairs[woman] = man;\n\tif (verbose) printf(\"%4s is engaged to %4s\\n\", name[man], name[woman]);\n}\n\nvoid dump(int woman, int man)\n{\n\tpairs[man] = pairs[woman] = clown;\n\tif (verbose) printf(\"%4s dumps %4s\\n\", name[woman], name[man]);\n}\n\n/* how high this person ranks that: lower is more preferred */\nint rank(int this, int that)\n{\n\tint i;\n\tfor (i = abe; i <= jon && pref[this][i] != that; i++);\n\treturn i;\n}\n\nvoid propose(int man, int woman)\n{\n\tint fiance = pairs[woman];\n\tif (verbose) printf(\"%4s proposes to %4s\\n\", name[man], name[woman]);\n\n\tif (fiance == clown) {\n\t\tengage(man, woman);\n\t} else if (rank(woman, man) < rank(woman, fiance)) {\n\t\tdump(woman, fiance);\n\t\tengage(man, woman);\n\t}\n}\n\nint covet(int man1, int wife2)\n{\n\tif (rank(man1, wife2) < rank(man1, pairs[man1]) &&\n\t\t\trank(wife2, man1) < rank(wife2, pairs[wife2])) {\n\t\tprintf( \"    %4s (w/ %4s) and %4s (w/ %4s) prefer each other\"\n\t\t\t\" over current pairing.\\n\",\n\t\t\tname[man1], name[pairs[man1]], name[wife2], name[pairs[wife2]]\n\t\t);\n\t\treturn 1;\n\t}\n\treturn 0;\n}\n\nint thy_neighbors_wife(int man1, int man2)\n{\t/* +: force checking all pairs; \"||\" would shortcircuit */\n\treturn covet(man1, pairs[man2]) + covet(man2, pairs[man1]);\n}\n\nint unstable()\n{\n\tint i, j, bad = 0;\n\tfor (i = abe; i < jon; i++) {\n\t\tfor (j = i + 1; j <= jon; j++)\n\t\t\tif (thy_neighbors_wife(i, j)) bad = 1;\n\t}\n\treturn bad;\n}\n\nint main()\n{\n\tint i, unengaged;\n\t/* init: everyone marries the clown */\n\tfor (i = abe; i <= jan; i++)\n\t\tpairs[i] = proposed[i] = clown;\n\n\t/* rounds */\n\tdo {\n\t\tunengaged = 0;\n\t\tfor (i = abe; i <= jon; i++) {\n\t\t//for (i = abi; i <= jan; i++) { /* could let women propose */\n\t\t\tif (pairs[i] != clown) continue;\n\t\t\tunengaged = 1;\n\t\t\tpropose(i, pref[i][++proposed[i]]);\n\t\t}\n\t} while (unengaged);\n\n\tprintf(\"Pairing:\\n\");\n\tfor (i = abe; i <= jon; i++)\n\t\tprintf(\"  %4s - %s\\n\", name[i],\n\t\t\tpairs[i] == clown ? \"clown\" : name[pairs[i]]);\n\n\tprintf(unstable()\n\t\t? \"Marriages not stable\\n\" /* draw sad face here */\n\t\t: \"Stable matchup\\n\");\n\n\tprintf(\"\\nBut if Bob and Fred were to swap:\\n\");\n\ti = pairs[bob];\n\tengage(bob, pairs[fred]);\n\tengage(fred, i);\n\tprintf(unstable() ? \"Marriages not stable\\n\" : \"Stable matchup\\n\");\n\n\treturn 0;\n}\n\n\nOutput:\nPairing:\n   Abe - Ivy\n   Bob - Cath\n   Col - Dee\n   Dan - Fay\n    Ed - Jan\n  Fred - Bea\n   Gav - Gay\n   Hal - Eve\n   Ian - Hope\n   Jon - Abi\nStable matchup\n\nBut if Bob and Fred were to swap:\n    Fred (w/ Cath) and  Ivy (w/  Abe) prefer each other over current pairing.\n     Bob (w/  Bea) and  Fay (w/  Dan) prefer each other over current pairing.\n     Bob (w/  Bea) and Hope (w/  Ian) prefer each other over current pairing.\n     Bob (w/  Bea) and  Abi (w/  Jon) prefer each other over current pairing.\n    Fred (w/ Cath) and  Dee (w/  Col) prefer each other over current pairing.\n    Fred (w/ Cath) and  Abi (w/  Jon) prefer each other over current pairing.\nMarriages not stable\n", "explain": "Oddly enough (or maybe it should be that way, only that I don't know): if the women were proposing instead of the men, the resulting pairs are exactly the same.\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include <algorithm>\n#include <iostream>\n#include <map>\n#include <queue>\n#include <string>\n#include <vector>\nusing namespace std;\n\nconst char *men_data[][11] = {\n    { \"abe\",  \"abi\",\"eve\",\"cath\",\"ivy\",\"jan\",\"dee\",\"fay\",\"bea\",\"hope\",\"gay\" },\n    { \"bob\",  \"cath\",\"hope\",\"abi\",\"dee\",\"eve\",\"fay\",\"bea\",\"jan\",\"ivy\",\"gay\" },\n    { \"col\",  \"hope\",\"eve\",\"abi\",\"dee\",\"bea\",\"fay\",\"ivy\",\"gay\",\"cath\",\"jan\" },\n    { \"dan\",  \"ivy\",\"fay\",\"dee\",\"gay\",\"hope\",\"eve\",\"jan\",\"bea\",\"cath\",\"abi\" },\n    { \"ed\",   \"jan\",\"dee\",\"bea\",\"cath\",\"fay\",\"eve\",\"abi\",\"ivy\",\"hope\",\"gay\" },\n    { \"fred\", \"bea\",\"abi\",\"dee\",\"gay\",\"eve\",\"ivy\",\"cath\",\"jan\",\"hope\",\"fay\" },\n    { \"gav\",  \"gay\",\"eve\",\"ivy\",\"bea\",\"cath\",\"abi\",\"dee\",\"hope\",\"jan\",\"fay\" },\n    { \"hal\",  \"abi\",\"eve\",\"hope\",\"fay\",\"ivy\",\"cath\",\"jan\",\"bea\",\"gay\",\"dee\" },\n    { \"ian\",  \"hope\",\"cath\",\"dee\",\"gay\",\"bea\",\"abi\",\"fay\",\"ivy\",\"jan\",\"eve\" },\n    { \"jon\",  \"abi\",\"fay\",\"jan\",\"gay\",\"eve\",\"bea\",\"dee\",\"cath\",\"ivy\",\"hope\" }\n};\n \nconst char *women_data[][11] = {\n    { \"abi\",  \"bob\",\"fred\",\"jon\",\"gav\",\"ian\",\"abe\",\"dan\",\"ed\",\"col\",\"hal\" },\n    { \"bea\",  \"bob\",\"abe\",\"col\",\"fred\",\"gav\",\"dan\",\"ian\",\"ed\",\"jon\",\"hal\" },\n    { \"cath\", \"fred\",\"bob\",\"ed\",\"gav\",\"hal\",\"col\",\"ian\",\"abe\",\"dan\",\"jon\" },\n    { \"dee\",  \"fred\",\"jon\",\"col\",\"abe\",\"ian\",\"hal\",\"gav\",\"dan\",\"bob\",\"ed\" },\n    { \"eve\",  \"jon\",\"hal\",\"fred\",\"dan\",\"abe\",\"gav\",\"col\",\"ed\",\"ian\",\"bob\" },\n    { \"fay\",  \"bob\",\"abe\",\"ed\",\"ian\",\"jon\",\"dan\",\"fred\",\"gav\",\"col\",\"hal\" },\n    { \"gay\",  \"jon\",\"gav\",\"hal\",\"fred\",\"bob\",\"abe\",\"col\",\"ed\",\"dan\",\"ian\" },\n    { \"hope\", \"gav\",\"jon\",\"bob\",\"abe\",\"ian\",\"dan\",\"hal\",\"ed\",\"col\",\"fred\" },\n    { \"ivy\",  \"ian\",\"col\",\"hal\",\"gav\",\"fred\",\"bob\",\"abe\",\"ed\",\"jon\",\"dan\" },\n    { \"jan\",  \"ed\",\"hal\",\"gav\",\"abe\",\"bob\",\"jon\",\"col\",\"ian\",\"fred\",\"dan\" }\n};\n\ntypedef vector<string> PrefList;\ntypedef map<string, PrefList> PrefMap;\ntypedef map<string, string> Couples;\n\n// Does 'first' appear before 'second' in preference list?\nbool prefers(const PrefList &prefer, const string &first, const string &second)\n{\n    for (PrefList::const_iterator it = prefer.begin(); it != prefer.end(); ++it)\n    {\n        if (*it == first) return true;\n        if (*it == second) return false;\n    }\n    return false; // no preference\n}\n\nvoid check_stability(const Couples &engaged, const PrefMap &men_pref, const PrefMap &women_pref)\n{\n    cout << \"Stablility:\\n\";\n    bool stable = true;\n    for (Couples::const_iterator it = engaged.begin(); it != engaged.end(); ++it)\n    {\n        const string &bride = it->first;\n        const string &groom = it->second;\n        const PrefList &preflist = men_pref.at(groom);\n\n        for (PrefList::const_iterator it = preflist.begin(); it != preflist.end(); ++it)\n        {\n            if (*it == bride) // he prefers his bride\n                break;\n            if (prefers(preflist, *it, bride) && // he prefers another woman\n                prefers(women_pref.at(*it), groom, engaged.at(*it))) // other woman prefers him\n            {\n                cout << \"\\t\" << *it <<\n                    \" prefers \" << groom <<\n                    \" over \" << engaged.at(*it) <<\n                    \" and \" << groom <<\n                    \" prefers \" << *it <<\n                    \" over \" << bride << \"\\n\";\n                stable = false;\n            }\n        }\n    }\n    if (stable) cout << \"\\t(all marriages stable)\\n\";\n}\n\nint main()\n{\n    PrefMap men_pref, women_pref;\n    queue<string> bachelors;\n\n    // init data structures\n    for (int i = 0; i < 10; ++i) // person\n    {\n        for (int j = 1; j < 11; ++j) // preference\n        {\n              men_pref[  men_data[i][0]].push_back(  men_data[i][j]);\n            women_pref[women_data[i][0]].push_back(women_data[i][j]);\n        }\n        bachelors.push(men_data[i][0]);\n    }\n\n    Couples engaged; // <woman,man>\n\n    cout << \"Matchmaking:\\n\";\n    while (!bachelors.empty())\n    {\n        const string &suitor = bachelors.front();\n        const PrefList &preflist = men_pref[suitor];\n\n        for (PrefList::const_iterator it = preflist.begin(); it != preflist.end(); ++it)\n        {\n            const string &bride = *it;\n\n            if (engaged.find(bride) == engaged.end()) // she's available\n            {\n                cout << \"\\t\" << bride << \" and \" << suitor << \"\\n\";\n                engaged[bride] = suitor; // hook up\n                break;\n            }\n\n            const string &groom = engaged[bride];\n\n            if (prefers(women_pref[bride], suitor, groom))\n            {\n                cout << \"\\t\" << bride << \" dumped \" << groom << \" for \" << suitor << \"\\n\";\n                bachelors.push(groom); // dump that zero\n                engaged[bride] = suitor; // get a hero\n                break;\n            }\n        }\n        bachelors.pop(); // pop at the end to not invalidate suitor reference\n    }\n\n    cout << \"Engagements:\\n\";\n    for (Couples::const_iterator it = engaged.begin(); it != engaged.end(); ++it)\n    {\n        cout << \"\\t\" << it->first << \" and \" << it->second << \"\\n\";\n    }\n\n    check_stability(engaged, men_pref, women_pref);\n\n    cout << \"Perturb:\\n\";\n    std::swap(engaged[\"abi\"], engaged[\"bea\"]);\n    cout << \"\\tengage abi with \" << engaged[\"abi\"] << \" and bea with \" << engaged[\"bea\"] << \"\\n\";\n\n    check_stability(engaged, men_pref, women_pref);\n}\n\n\nOutput:\nMatchmaking:\n\tabi and abe\n\tcath and bob\n\thope and col\n\tivy and dan\n\tjan and ed\n\tbea and fred\n\tgay and gav\n\teve and hal\n\thope dumped col for ian\n\tabi dumped abe for jon\n\tdee and col\n\tivy dumped dan for abe\n\tfay and dan\nEngagements:\n\tabi and jon\n\tbea and fred\n\tcath and bob\n\tdee and col\n\teve and hal\n\tfay and dan\n\tgay and gav\n\thope and ian\n\tivy and abe\n\tjan and ed\nStablility:\n\t(all marriages stable)\nPerturb:\n\tengage abi with fred and bea with jon\nStablility:\n\tbea prefers fred over jon and fred prefers bea over abi\n\tfay prefers jon over dan and jon prefers fay over bea\n\tgay prefers jon over gav and jon prefers gay over bea\n\teve prefers jon over hal and jon prefers eve over bea\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\nimport java.util.*;\n\npublic class Stable {\n    static List<String> guys = Arrays.asList(\n            new String[]{\n        \"abe\", \"bob\", \"col\", \"dan\", \"ed\", \"fred\", \"gav\", \"hal\", \"ian\", \"jon\"});\n    static List<String> girls = Arrays.asList(\n            new String[]{\n        \"abi\", \"bea\", \"cath\", \"dee\", \"eve\", \"fay\", \"gay\", \"hope\", \"ivy\", \"jan\"});\n    static Map<String, List<String>> guyPrefers =\n            new HashMap<String, List<String>>(){{\n        put(\"abe\",\n            Arrays.asList(\"abi\", \"eve\", \"cath\", \"ivy\", \"jan\", \"dee\", \"fay\",\n            \"bea\", \"hope\", \"gay\"));\n        put(\"bob\",\n            Arrays.asList(\"cath\", \"hope\", \"abi\", \"dee\", \"eve\", \"fay\", \"bea\",\n            \"jan\", \"ivy\", \"gay\"));\n        put(\"col\",\n            Arrays.asList(\"hope\", \"eve\", \"abi\", \"dee\", \"bea\", \"fay\", \"ivy\",\n            \"gay\", \"cath\", \"jan\"));\n        put(\"dan\",\n            Arrays.asList(\"ivy\", \"fay\", \"dee\", \"gay\", \"hope\", \"eve\", \"jan\",\n            \"bea\", \"cath\", \"abi\"));\n        put(\"ed\",\n            Arrays.asList(\"jan\", \"dee\", \"bea\", \"cath\", \"fay\", \"eve\", \"abi\",\n            \"ivy\", \"hope\", \"gay\"));\n        put(\"fred\",\n            Arrays.asList(\"bea\", \"abi\", \"dee\", \"gay\", \"eve\", \"ivy\", \"cath\",\n            \"jan\", \"hope\", \"fay\"));\n        put(\"gav\",\n            Arrays.asList(\"gay\", \"eve\", \"ivy\", \"bea\", \"cath\", \"abi\", \"dee\",\n            \"hope\", \"jan\", \"fay\"));\n        put(\"hal\",\n            Arrays.asList(\"abi\", \"eve\", \"hope\", \"fay\", \"ivy\", \"cath\", \"jan\",\n            \"bea\", \"gay\", \"dee\"));\n        put(\"ian\",\n            Arrays.asList(\"hope\", \"cath\", \"dee\", \"gay\", \"bea\", \"abi\", \"fay\",\n            \"ivy\", \"jan\", \"eve\"));\n        put(\"jon\",\n            Arrays.asList(\"abi\", \"fay\", \"jan\", \"gay\", \"eve\", \"bea\", \"dee\",\n            \"cath\", \"ivy\", \"hope\"));\n    }};\n    static Map<String, List<String>> girlPrefers =\n            new HashMap<String, List<String>>(){{\n        put(\"abi\",\n            Arrays.asList(\"bob\", \"fred\", \"jon\", \"gav\", \"ian\", \"abe\", \"dan\",\n            \"ed\", \"col\", \"hal\"));\n        put(\"bea\",\n            Arrays.asList(\"bob\", \"abe\", \"col\", \"fred\", \"gav\", \"dan\", \"ian\",\n            \"ed\", \"jon\", \"hal\"));\n        put(\"cath\",\n            Arrays.asList(\"fred\", \"bob\", \"ed\", \"gav\", \"hal\", \"col\", \"ian\",\n            \"abe\", \"dan\", \"jon\"));\n        put(\"dee\",\n            Arrays.asList(\"fred\", \"jon\", \"col\", \"abe\", \"ian\", \"hal\", \"gav\",\n            \"dan\", \"bob\", \"ed\"));\n        put(\"eve\",\n            Arrays.asList(\"jon\", \"hal\", \"fred\", \"dan\", \"abe\", \"gav\", \"col\",\n            \"ed\", \"ian\", \"bob\"));\n        put(\"fay\",\n            Arrays.asList(\"bob\", \"abe\", \"ed\", \"ian\", \"jon\", \"dan\", \"fred\",\n            \"gav\", \"col\", \"hal\"));\n        put(\"gay\",\n            Arrays.asList(\"jon\", \"gav\", \"hal\", \"fred\", \"bob\", \"abe\", \"col\",\n            \"ed\", \"dan\", \"ian\"));\n        put(\"hope\",\n            Arrays.asList(\"gav\", \"jon\", \"bob\", \"abe\", \"ian\", \"dan\", \"hal\",\n            \"ed\", \"col\", \"fred\"));\n        put(\"ivy\",\n            Arrays.asList(\"ian\", \"col\", \"hal\", \"gav\", \"fred\", \"bob\", \"abe\",\n            \"ed\", \"jon\", \"dan\"));\n        put(\"jan\",\n            Arrays.asList(\"ed\", \"hal\", \"gav\", \"abe\", \"bob\", \"jon\", \"col\",\n            \"ian\", \"fred\", \"dan\"));\n    }};\n    public static void main(String[] args){\n        Map<String, String> matches = match(guys, guyPrefers, girlPrefers);\n        for(Map.Entry<String, String> couple:matches.entrySet()){\n            System.out.println(\n                    couple.getKey() + \" is engaged to \" + couple.getValue());\n        }\n        if(checkMatches(guys, girls, matches, guyPrefers, girlPrefers)){\n            System.out.println(\"Marriages are stable\");\n        }else{\n            System.out.println(\"Marriages are unstable\");\n        }\n        String tmp = matches.get(girls.get(0));\n        matches.put(girls.get(0), matches.get(girls.get(1)));\n        matches.put(girls.get(1), tmp);\n        System.out.println(\n                girls.get(0) +\" and \" + girls.get(1) + \" have switched partners\");\n        if(checkMatches(guys, girls, matches, guyPrefers, girlPrefers)){\n            System.out.println(\"Marriages are stable\");\n        }else{\n            System.out.println(\"Marriages are unstable\");\n        }\n    }\n\n    private static Map<String, String> match(List<String> guys,\n            Map<String, List<String>> guyPrefers,\n            Map<String, List<String>> girlPrefers){\n        Map<String, String> engagedTo = new TreeMap<String, String>();\n        List<String> freeGuys = new LinkedList<String>();\n        freeGuys.addAll(guys);\n        while(!freeGuys.isEmpty()){\n            String thisGuy = freeGuys.remove(0); //get a load of THIS guy\n            List<String> thisGuyPrefers = guyPrefers.get(thisGuy);\n            for(String girl:thisGuyPrefers){\n                if(engagedTo.get(girl) == null){//girl is free\n                    engagedTo.put(girl, thisGuy); //awww\n                    break;\n                }else{\n                    String otherGuy = engagedTo.get(girl);\n                    List<String> thisGirlPrefers = girlPrefers.get(girl);\n                    if(thisGirlPrefers.indexOf(thisGuy) <\n                            thisGirlPrefers.indexOf(otherGuy)){\n                        //this girl prefers this guy to the guy she's engaged to\n                        engagedTo.put(girl, thisGuy);\n                        freeGuys.add(otherGuy);\n                        break;\n                    }//else no change...keep looking for this guy\n                }\n            }\n        }\n        return engagedTo;\n    }\n\n    private static boolean checkMatches(List<String> guys, List<String> girls,\n            Map<String, String> matches, Map<String, List<String>> guyPrefers,\n            Map<String, List<String>> girlPrefers) {\n        if(!matches.keySet().containsAll(girls)){\n            return false;\n        }\n\n        if(!matches.values().containsAll(guys)){\n            return false;\n        }\n\n        Map<String, String> invertedMatches = new TreeMap<String, String>();\n        for(Map.Entry<String, String> couple:matches.entrySet()){\n            invertedMatches.put(couple.getValue(), couple.getKey());\n        }\n\n        for(Map.Entry<String, String> couple:matches.entrySet()){\n            List<String> shePrefers = girlPrefers.get(couple.getKey());\n            List<String> sheLikesBetter = new LinkedList<String>();\n            sheLikesBetter.addAll(shePrefers.subList(0, shePrefers.indexOf(couple.getValue())));\n            List<String> hePrefers = guyPrefers.get(couple.getValue());\n            List<String> heLikesBetter = new LinkedList<String>();\n            heLikesBetter.addAll(hePrefers.subList(0, hePrefers.indexOf(couple.getKey())));\n\n            for(String guy : sheLikesBetter){\n                String guysFinace = invertedMatches.get(guy);\n                List<String> thisGuyPrefers = guyPrefers.get(guy);\n                if(thisGuyPrefers.indexOf(guysFinace) >\n                        thisGuyPrefers.indexOf(couple.getKey())){\n                    System.out.printf(\"%s likes %s better than %s and %s\"\n                            + \" likes %s better than their current partner\\n\",\n                       couple.getKey(), guy, couple.getValue(),\n                       guy, couple.getKey());\n                    return false;\n                }\n            }\n\n            for(String girl : heLikesBetter){\n                String girlsFinace = matches.get(girl);\n                List<String> thisGirlPrefers = girlPrefers.get(girl);\n                if(thisGirlPrefers.indexOf(girlsFinace) >\n                        thisGirlPrefers.indexOf(couple.getValue())){\n                    System.out.printf(\"%s likes %s better than %s and %s\"\n                            + \" likes %s better than their current partner\\n\",\n                       couple.getValue(), girl, couple.getKey(),\n                       girl, couple.getValue());\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n}\n\n\nOutput:\nabi is engaged to jon\nbea is engaged to fred\ncath is engaged to bob\ndee is engaged to col\neve is engaged to hal\nfay is engaged to dan\ngay is engaged to gav\nhope is engaged to ian\nivy is engaged to abe\njan is engaged to ed\nMarriages are stable\nabi and bea have switched partners\nfred likes bea better than abi and bea likes fred better than their current partner\nMarriages are unstable\n", "explain": "This is not a direct translation of Python, but it's fairly close (especially the stability check).\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nusing System;\nusing System.Collections.Generic;\n\nnamespace StableMarriage\n{\n    class Person\n    {\n        private int _candidateIndex;\n        public string Name { get; set; }\n        public List<Person> Prefs { get; set; }\n        public Person Fiance { get; set; }\n        \n        public Person(string name) {\n            Name = name;\n            Prefs = null;\n            Fiance = null;\n            _candidateIndex = 0;\n        }\n        public bool Prefers(Person p) {\n            return Prefs.FindIndex(o => o == p) < Prefs.FindIndex(o => o == Fiance);\n        }\n        public Person NextCandidateNotYetProposedTo() {\n            if (_candidateIndex >= Prefs.Count) return null;\n            return Prefs[_candidateIndex++];\n        }\n        public void EngageTo(Person p) {\n            if (p.Fiance != null) p.Fiance.Fiance = null;\n            p.Fiance = this;\n            if (Fiance != null) Fiance.Fiance = null;\n            Fiance = p;\n        }\n    }\n    \n    static class MainClass\n    {\n        static public bool IsStable(List<Person> men) {\n            List<Person> women = men[0].Prefs;\n            foreach (Person guy in men) {\n                foreach (Person gal in women) {\n                    if (guy.Prefers(gal) && gal.Prefers(guy))\n                        return false;\n                }\n            }\n            return true;\n        }\n        \n        static void DoMarriage() {\n            Person abe  = new Person(\"abe\");\n            Person bob  = new Person(\"bob\");\n            Person col  = new Person(\"col\");\n            Person dan  = new Person(\"dan\");\n            Person ed   = new Person(\"ed\");\n            Person fred = new Person(\"fred\");\n            Person gav  = new Person(\"gav\");\n            Person hal  = new Person(\"hal\");\n            Person ian  = new Person(\"ian\");\n            Person jon  = new Person(\"jon\");\n            Person abi  = new Person(\"abi\");\n            Person bea  = new Person(\"bea\");\n            Person cath = new Person(\"cath\");\n            Person dee  = new Person(\"dee\");\n            Person eve  = new Person(\"eve\");\n            Person fay  = new Person(\"fay\");\n            Person gay  = new Person(\"gay\");\n            Person hope = new Person(\"hope\");\n            Person ivy  = new Person(\"ivy\");\n            Person jan  = new Person(\"jan\");\n            \n            abe.Prefs  = new List<Person>() {abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay};\n            bob.Prefs  = new List<Person>() {cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay};\n            col.Prefs  = new List<Person>() {hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan};\n            dan.Prefs  = new List<Person>() {ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi};\n            ed.Prefs   = new List<Person>() {jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay};\n            fred.Prefs = new List<Person>() {bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay};\n            gav.Prefs  = new List<Person>() {gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay};\n            hal.Prefs  = new List<Person>() {abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee};\n            ian.Prefs  = new List<Person>() {hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve};\n            jon.Prefs  = new List<Person>() {abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope};\n            abi.Prefs  = new List<Person>() {bob, fred, jon, gav, ian, abe, dan, ed, col, hal};\n            bea.Prefs  = new List<Person>() {bob, abe, col, fred, gav, dan, ian, ed, jon, hal};\n            cath.Prefs = new List<Person>() {fred, bob, ed, gav, hal, col, ian, abe, dan, jon};\n            dee.Prefs  = new List<Person>() {fred, jon, col, abe, ian, hal, gav, dan, bob, ed};\n            eve.Prefs  = new List<Person>() {jon, hal, fred, dan, abe, gav, col, ed, ian, bob};\n            fay.Prefs  = new List<Person>() {bob, abe, ed, ian, jon, dan, fred, gav, col, hal};\n            gay.Prefs  = new List<Person>() {jon, gav, hal, fred, bob, abe, col, ed, dan, ian};\n            hope.Prefs = new List<Person>() {gav, jon, bob, abe, ian, dan, hal, ed, col, fred};\n            ivy.Prefs  = new List<Person>() {ian, col, hal, gav, fred, bob, abe, ed, jon, dan};\n            jan.Prefs  = new List<Person>() {ed, hal, gav, abe, bob, jon, col, ian, fred, dan};\n            \n            List<Person> men = new List<Person>(abi.Prefs);\n            \n            int freeMenCount = men.Count;\n            while (freeMenCount > 0) {\n                foreach (Person guy in men) {\n                    if (guy.Fiance == null) {\n                        Person gal = guy.NextCandidateNotYetProposedTo();\n                        if (gal.Fiance == null) {\n                            guy.EngageTo(gal);\n                            freeMenCount--;\n                        } else if (gal.Prefers(guy)) {\n                            guy.EngageTo(gal);\n                        }\n                    }\n                }\n            }\n            \n            foreach (Person guy in men) {\n                Console.WriteLine(\"{0} is engaged to {1}\", guy.Name, guy.Fiance.Name);\n            }\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n            \n            Console.WriteLine(\"\\nSwitching fred & jon's partners\");\n            Person jonsFiance = jon.Fiance;\n            Person fredsFiance = fred.Fiance;\n            fred.EngageTo(jonsFiance);\n            jon.EngageTo(fredsFiance);\n            Console.WriteLine(\"Stable = {0}\", IsStable(men));\n        }\n        \n        public static void Main(string[] args)\n        {\n            DoMarriage();\n        }\n    }\n}\n\n\nOutput:\nbob is engaged to cath\nfred is engaged to bea\njon is engaged to abi\ngav is engaged to gay\nian is engaged to hope\nabe is engaged to ivy\ndan is engaged to fay\ned is engaged to jan\ncol is engaged to dee\nhal is engaged to eve\nStable = True\n\nSwitching fred & jon's partners\nStable = False\n", "explain": "(This is a straight-up translation of the Objective-C version.)\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nfunction Person(name) {\n\n    var candidateIndex = 0;\n\n    this.name = name;\n    this.fiance = null;\n    this.candidates = [];\n\n    this.rank = function(p) {\n        for (i = 0; i < this.candidates.length; i++)\n            if (this.candidates[i] === p) return i;\n        return this.candidates.length + 1;\n    }\n\n    this.prefers = function(p) {\n        return this.rank(p) < this.rank(this.fiance);\n    }\n\n    this.nextCandidate = function() {\n        if (candidateIndex >= this.candidates.length) return null;\n        return this.candidates[candidateIndex++];\n    }\n\n    this.engageTo = function(p) {\n        if (p.fiance) p.fiance.fiance = null;\n        p.fiance = this;\n        if (this.fiance) this.fiance.fiance = null;\n        this.fiance = p;\n    }\n\n    this.swapWith = function(p) {\n        console.log(\"%s & %s swap partners\", this.name, p.name);\n        var thisFiance = this.fiance;\n        var pFiance = p.fiance;\n        this.engageTo(pFiance);\n        p.engageTo(thisFiance);\n    }\n}\n\nfunction isStable(guys, gals) {\n    for (var i = 0; i < guys.length; i++)\n        for (var j = 0; j < gals.length; j++)\n            if (guys[i].prefers(gals[j]) && gals[j].prefers(guys[i]))\n                return false;\n    return true;\n}\n\nfunction engageEveryone(guys) {\n    var done;\n    do {\n        done = true;\n        for (var i = 0; i < guys.length; i++) {\n            var guy = guys[i];\n            if (!guy.fiance) {\n                done = false;\n                var gal = guy.nextCandidate();\n                if (!gal.fiance || gal.prefers(guy))\n                    guy.engageTo(gal);\n            }\n        }\n    } while (!done);\n}\n\nfunction doMarriage() {\n\n    var abe  = new Person(\"Abe\");\n    var bob  = new Person(\"Bob\");\n    var col  = new Person(\"Col\");\n    var dan  = new Person(\"Dan\");\n    var ed   = new Person(\"Ed\");\n    var fred = new Person(\"Fred\");\n    var gav  = new Person(\"Gav\");\n    var hal  = new Person(\"Hal\");\n    var ian  = new Person(\"Ian\");\n    var jon  = new Person(\"Jon\");\n    var abi  = new Person(\"Abi\");\n    var bea  = new Person(\"Bea\");\n    var cath = new Person(\"Cath\");\n    var dee  = new Person(\"Dee\");\n    var eve  = new Person(\"Eve\");\n    var fay  = new Person(\"Fay\");\n    var gay  = new Person(\"Gay\");\n    var hope = new Person(\"Hope\");\n    var ivy  = new Person(\"Ivy\");\n    var jan  = new Person(\"Jan\");\n\n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay];\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay];\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan];\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi];\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay];\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay];\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay];\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee];\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve];\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope];\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal];\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal];\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon];\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed];\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob];\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal];\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian];\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred];\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan];\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan];\n\n    var guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon];\n    var gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan];\n\n    engageEveryone(guys);\n\n    for (var i = 0; i < guys.length; i++) {\n        console.log(\"%s is engaged to %s\", guys[i].name, guys[i].fiance.name);\n    }\n    console.log(\"Stable = %s\", isStable(guys, gals) ? \"Yes\" : \"No\");\n    jon.swapWith(fred);\n    console.log(\"Stable = %s\", isStable(guys, gals) ? \"Yes\" : \"No\");\n}\n\ndoMarriage();\n\n\nOutput:\nAbe is engaged to Ivy\nBob is engaged to Cath\nCol is engaged to Dee\nDan is engaged to Fay\nEd is engaged to Jan\nFred is engaged to Bea\nGav is engaged to Gay\nHal is engaged to Eve\nIan is engaged to Hope\nJon is engaged to Abi\nStable = Yes\nJon & Fred swap partners\nStable = No\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\n// Asymetry in the algorithm suggests different data structures for the\n// map value types of the proposers and the recipients.  Proposers go down\n// their list of preferences in order, and do not need random access.\n// Recipients on the other hand must compare their preferences to arbitrary\n// proposers.  A slice is adequate for proposers, but a map allows direct\n// lookups for recipients and avoids looping code.\ntype proposers map[string][]string\n    \nvar mPref = proposers{\n    \"abe\": []string{\n        \"abi\", \"eve\", \"cath\", \"ivy\", \"jan\",\n        \"dee\", \"fay\", \"bea\", \"hope\", \"gay\"},\n    \"bob\": []string{\n        \"cath\", \"hope\", \"abi\", \"dee\", \"eve\",\n        \"fay\", \"bea\", \"jan\", \"ivy\", \"gay\"},\n    \"col\": []string{\n        \"hope\", \"eve\", \"abi\", \"dee\", \"bea\",\n        \"fay\", \"ivy\", \"gay\", \"cath\", \"jan\"},\n    \"dan\": []string{\n        \"ivy\", \"fay\", \"dee\", \"gay\", \"hope\",\n        \"eve\", \"jan\", \"bea\", \"cath\", \"abi\"},\n    \"ed\": []string{\n        \"jan\", \"dee\", \"bea\", \"cath\", \"fay\",\n        \"eve\", \"abi\", \"ivy\", \"hope\", \"gay\"},\n    \"fred\": []string{\n        \"bea\", \"abi\", \"dee\", \"gay\", \"eve\",\n        \"ivy\", \"cath\", \"jan\", \"hope\", \"fay\"},\n    \"gav\": []string{\n        \"gay\", \"eve\", \"ivy\", \"bea\", \"cath\",\n        \"abi\", \"dee\", \"hope\", \"jan\", \"fay\"},\n    \"hal\": []string{\n        \"abi\", \"eve\", \"hope\", \"fay\", \"ivy\",\n        \"cath\", \"jan\", \"bea\", \"gay\", \"dee\"},\n    \"ian\": []string{\n        \"hope\", \"cath\", \"dee\", \"gay\", \"bea\",\n        \"abi\", \"fay\", \"ivy\", \"jan\", \"eve\"},\n    \"jon\": []string{\n        \"abi\", \"fay\", \"jan\", \"gay\", \"eve\",\n        \"bea\", \"dee\", \"cath\", \"ivy\", \"hope\"},\n}\n\ntype recipients map[string]map[string]int\n\nvar wPref = recipients{\n    \"abi\": map[string]int{\n        \"bob\": 1, \"fred\": 2, \"jon\": 3, \"gav\": 4, \"ian\": 5,\n        \"abe\": 6, \"dan\": 7, \"ed\": 8, \"col\": 9, \"hal\": 10},\n    \"bea\": map[string]int{\n        \"bob\": 1, \"abe\": 2, \"col\": 3, \"fred\": 4, \"gav\": 5,\n        \"dan\": 6, \"ian\": 7, \"ed\": 8, \"jon\": 9, \"hal\": 10},\n    \"cath\": map[string]int{\n        \"fred\": 1, \"bob\": 2, \"ed\": 3, \"gav\": 4, \"hal\": 5,\n        \"col\": 6, \"ian\": 7, \"abe\": 8, \"dan\": 9, \"jon\": 10},\n    \"dee\": map[string]int{\n        \"fred\": 1, \"jon\": 2, \"col\": 3, \"abe\": 4, \"ian\": 5,\n        \"hal\": 6, \"gav\": 7, \"dan\": 8, \"bob\": 9, \"ed\": 10},\n    \"eve\": map[string]int{\n        \"jon\": 1, \"hal\": 2, \"fred\": 3, \"dan\": 4, \"abe\": 5,\n        \"gav\": 6, \"col\": 7, \"ed\": 8, \"ian\": 9, \"bob\": 10},\n    \"fay\": map[string]int{\n        \"bob\": 1, \"abe\": 2, \"ed\": 3, \"ian\": 4, \"jon\": 5,\n        \"dan\": 6, \"fred\": 7, \"gav\": 8, \"col\": 9, \"hal\": 10},\n    \"gay\": map[string]int{\n        \"jon\": 1, \"gav\": 2, \"hal\": 3, \"fred\": 4, \"bob\": 5,\n        \"abe\": 6, \"col\": 7, \"ed\": 8, \"dan\": 9, \"ian\": 10},\n    \"hope\": map[string]int{\n        \"gav\": 1, \"jon\": 2, \"bob\": 3, \"abe\": 4, \"ian\": 5,\n        \"dan\": 6, \"hal\": 7, \"ed\": 8, \"col\": 9, \"fred\": 10},\n    \"ivy\": map[string]int{\n        \"ian\": 1, \"col\": 2, \"hal\": 3, \"gav\": 4, \"fred\": 5,\n        \"bob\": 6, \"abe\": 7, \"ed\": 8, \"jon\": 9, \"dan\": 10},\n    \"jan\": map[string]int{\n        \"ed\": 1, \"hal\": 2, \"gav\": 3, \"abe\": 4, \"bob\": 5,\n        \"jon\": 6, \"col\": 7, \"ian\": 8, \"fred\": 9, \"dan\": 10},\n}\n\nfunc main() {\n    // get parings by Gale/Shapley algorithm\n    ps := pair(mPref, wPref)\n    // show results\n    fmt.Println(\"\\nresult:\")\n    if !validateStable(ps, mPref, wPref) {\n        return \n    }\n    // perturb\n    for {\n        i := 0 \n        var w2, m2 [2]string\n        for w, m := range ps {\n            w2[i] = w\n            m2[i] = m\n            if i == 1 {\n                break\n            }\n            i++\n        }\n        fmt.Println(\"\\nexchanging partners of\", m2[0], \"and\", m2[1])\n        ps[w2[0]] = m2[1]\n        ps[w2[1]] = m2[0] \n        // validate perturbed parings\n        if !validateStable(ps, mPref, wPref) {\n            return\n        }\n        // if those happened to be stable as well, perturb more\n    }\n}   \n\ntype parings map[string]string // map[recipient]proposer (or map[w]m)\n    \n// Pair implements the Gale/Shapley algorithm.\nfunc pair(pPref proposers, rPref recipients) parings {\n    // code is destructive on the maps, so work with copies\n    pFree := proposers{}\n    for k, v := range pPref {\n        pFree[k] = append([]string{}, v...)\n    }\n    rFree := recipients{}\n    for k, v := range rPref {\n        rFree[k] = v\n    }\n    // struct only used in this function.\n    // preferences must be saved in case engagement is broken.\n    type save struct {\n        proposer string\n        pPref    []string\n        rPref    map[string]int\n    }\n    proposals := map[string]save{} // key is recipient (w)\n\n    // WP pseudocode comments prefaced with WP: m is proposer, w is recipient.\n    // WP: while \u2203 free man m who still has a woman w to propose to\n    for len(pFree) > 0 { // while there is a free proposer,\n        var proposer string\n        var ppref []string\n        for proposer, ppref = range pFree {\n            break // pick a proposer at random, whatever range delivers first.\n        }\n        if len(ppref) == 0 {\n            continue // if proposer has no possible recipients, skip\n        }\n        // WP: w = m's highest ranked such woman to whom he has not yet proposed\n        recipient := ppref[0] // highest ranged is first in list.\n        ppref = ppref[1:]     // pop from list\n        var rpref map[string]int\n        var ok bool\n        // WP: if w is free\n        if rpref, ok = rFree[recipient]; ok {\n            // WP: (m, w) become engaged\n            // (common code follows if statement)\n        } else {\n            // WP: else some pair (m', w) already exists\n            s := proposals[recipient] // get proposal saved preferences\n            // WP: if w prefers m to m'\n            if s.rPref[proposer] < s.rPref[s.proposer] {\n                fmt.Println(\"engagement broken:\", recipient, s.proposer)\n                // WP: m' becomes free\n                pFree[s.proposer] = s.pPref // return proposer to the map\n                // WP: (m, w) become engaged\n                rpref = s.rPref\n                // (common code follows if statement)\n            } else {\n                // WP: else (m', w) remain engaged\n                pFree[proposer] = ppref // update preferences in map\n                continue\n            } \n        }\n        fmt.Println(\"engagement:\", recipient, proposer)\n        proposals[recipient] = save{proposer, ppref, rpref}\n        delete(pFree, proposer)\n        delete(rFree, recipient)\n    }\n    // construct return value \n    ps := parings{}\n    for recipient, s := range proposals {\n        ps[recipient] = s.proposer\n    }\n    return ps\n}\n\nfunc validateStable(ps parings, pPref proposers, rPref recipients) bool {\n    for r, p := range ps {\n        fmt.Println(r, p)\n    }\n    for r, p := range ps {\n        for _, rp := range pPref[p] {\n            if rp == r {\n                break\n            }\n            rprefs := rPref[rp]\n            if rprefs[p] < rprefs[ps[rp]] {\n                fmt.Println(\"unstable.\")\n                fmt.Printf(\"%s and %s would prefer each other over\"+\n                    \" their current pairings.\\n\", p, rp)\n                return false\n            }\n        }\n    }\n    fmt.Println(\"stable.\")\n    return true\n}\n\n\nOutput:\nengagement: hope col\nengagement: bea fred\nengagement: ivy dan\nengagement: cath bob\nengagement: abi abe\nengagement broken: abi abe\nengagement: abi jon\nengagement: gay gav\nengagement: eve abe\nengagement: jan ed\nengagement broken: hope col\nengagement: hope ian\nengagement: dee col\nengagement broken: eve abe\nengagement: eve hal\nengagement broken: ivy dan\nengagement: ivy abe\nengagement: fay dan\n\nresult:\nfay dan\ndee col\ncath bob\nhope ian\neve hal\njan ed\nabi jon\ngay gav\nivy abe\nbea fred\nstable.\n\nexchanging partners of fred and dan\nivy abe\nbea dan\nfay fred\ndee col\ncath bob\nhope ian\neve hal\njan ed\nabi jon\ngay gav\nunstable.\ndan and fay would prefer each other over their current pairings.\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nclass Person\n  def initialize(name)\n    @name = name\n    @fiance = nil\n    @preferences = []\n    @proposals = []\n  end\n  attr_reader :name, :proposals\n  attr_accessor :fiance, :preferences\n\n  def to_s\n    @name\n  end\n\n  def free\n    @fiance = nil\n  end\n\n  def single?\n    @fiance == nil\n  end\n\n  def engage(person)\n    self.fiance = person\n    person.fiance = self\n  end\n\n  def better_choice?(person)\n    @preferences.index(person) < @preferences.index(@fiance)\n  end\n\n  def propose_to(person)\n    puts \"#{self} proposes to #{person}\" if $DEBUG\n    @proposals << person\n    person.respond_to_proposal_from(self)\n  end\n\n  def respond_to_proposal_from(person)\n    if single?\n      puts \"#{self} accepts proposal from #{person}\" if $DEBUG\n      engage(person)\n    elsif better_choice?(person)\n      puts \"#{self} dumps #{@fiance} for #{person}\" if $DEBUG\n      @fiance.free\n      engage(person)\n    else\n      puts \"#{self} rejects proposal from #{person}\" if $DEBUG\n    end\n  end\nend\n\n########################################################################\n# initialize data\n\nprefs = {\n  'abe'  => %w[abi eve cath ivy jan dee fay bea hope gay],\n  'bob'  => %w[cath hope abi dee eve fay bea jan ivy gay],\n  'col'  => %w[hope eve abi dee bea fay ivy gay cath jan],\n  'dan'  => %w[ivy fay dee gay hope eve jan bea cath abi],\n  'ed'   => %w[jan dee bea cath fay eve abi ivy hope gay],\n  'fred' => %w[bea abi dee gay eve ivy cath jan hope fay],\n  'gav'  => %w[gay eve ivy bea cath abi dee hope jan fay],\n  'hal'  => %w[abi eve hope fay ivy cath jan bea gay dee],\n  'ian'  => %w[hope cath dee gay bea abi fay ivy jan eve],\n  'jon'  => %w[abi fay jan gay eve bea dee cath ivy hope],\n  'abi'  => %w[bob fred jon gav ian abe dan ed col hal],\n  'bea'  => %w[bob abe col fred gav dan ian ed jon hal],\n  'cath' => %w[fred bob ed gav hal col ian abe dan jon],\n  'dee'  => %w[fred jon col abe ian hal gav dan bob ed],\n  'eve'  => %w[jon hal fred dan abe gav col ed ian bob],\n  'fay'  => %w[bob abe ed ian jon dan fred gav col hal],\n  'gay'  => %w[jon gav hal fred bob abe col ed dan ian],\n  'hope' => %w[gav jon bob abe ian dan hal ed col fred],\n  'ivy'  => %w[ian col hal gav fred bob abe ed jon dan],\n  'jan'  => %w[ed hal gav abe bob jon col ian fred dan],\n}\n\n@men = Hash[\n  %w[abe bob col dan ed fred gav hal ian jon].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@women = Hash[\n  %w[abi bea cath dee eve fay gay hope ivy jan].collect do |name|\n    [name, Person.new(name)]\n  end\n]\n\n@men.each {|name, man| man.preferences = @women.values_at(*prefs[name])}\n@women.each {|name, woman| woman.preferences = @men.values_at(*prefs[name])}\n\n########################################################################\n# perform the matching\n\ndef match_couples(men, women)\n  men.each_value {|man| man.free}\n  women.each_value {|woman| woman.free}\n\n  while m = men.values.find {|man| man.single?} do\n    puts \"considering single man #{m}\" if $DEBUG\n    w = m.preferences.find {|woman| not m.proposals.include?(woman)}\n    m.propose_to(w)\n  end\nend\n\nmatch_couples @men, @women\n\n@men.each_value.collect {|man| puts \"#{man} + #{man.fiance}\"}\n\n########################################################################\n# check for stability\n\nclass Person\n  def more_preferable_people\n    ( @preferences.partition {|p| better_choice?(p)} ).first\n  end\nend\n\nrequire 'set'\n\ndef stability(men)\n  unstable = Set.new\n  men.each_value do |man|\n    woman = man.fiance\n    puts \"considering #{man} and #{woman}\" if $DEBUG\n\n    man.more_preferable_people.each do |other_woman|\n      if other_woman.more_preferable_people.include?(man)\n        puts \"an unstable pairing: #{man} and #{other_woman}\" if $DEBUG\n        unstable << [man, other_woman]\n      end\n    end\n    woman.more_preferable_people.each do |other_man|\n      if other_man.more_preferable_people.include?(woman)\n        puts \"an unstable pairing: #{woman} and #{other_man}\" if $DEBUG\n        unstable << [other_man, woman]\n      end\n    end\n  end\n\n  if unstable.empty?\n    puts \"these couples are stable\"\n  else\n    puts \"uh oh\"\n    unstable.each do |a,b|\n      puts \"#{a} is engaged to #{a.fiance} but would prefer #{b}, and #{b} is engaged to #{b.fiance} but would prefer #{a}\"\n    end\n  end\nend\n\nstability @men\n\n########################################################################\n# perturb\n\nputs \"\\nwhat if abe and bob swap...\"\n\ndef swap(m1, m2)\n  w1 = m1.fiance\n  w2 = m2.fiance\n  m1.fiance = w2\n  w1.fiance = m2\n  m2.fiance = w1\n  w2.fiance = m1\nend\n\nswap *@men.values_at('abe','bob')\n\n@men.each_value.collect {|man| puts \"#{man} + #{man.fiance}\"}\nstability @men\n\n\nOutput:\nabe + ivy\nbob + cath\ncol + dee\ndan + fay\ned + jan\nfred + bea\ngav + gay\nhal + eve\nian + hope\njon + abi\nthese couples are stable\n\nwhat if abe and bob swap...\nabe + cath\nbob + ivy\ncol + dee\ndan + fay\ned + jan\nfred + bea\ngav + gay\nhal + eve\nian + hope\njon + abi\nuh oh\nbob is engaged to ivy but would prefer cath, and cath is engaged to abe but would prefer bob\nbob is engaged to ivy but would prefer hope, and hope is engaged to ian but would prefer bob\nbob is engaged to ivy but would prefer abi, and abi is engaged to jon but would prefer bob\nbob is engaged to ivy but would prefer fay, and fay is engaged to dan but would prefer bob\nbob is engaged to ivy but would prefer bea, and bea is engaged to fred but would prefer bob\n\n", "explain": "Hmm, turns out Bob is a popular guy...\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nTranslation of: JavaScript\nclass Person {\n    let name:String\n    var candidateIndex = 0\n    var fiance:Person?\n    var candidates = [Person]()\n    \n    init(name:String) {\n        self.name = name\n    }\n    \n    func rank(p:Person) -> Int {\n        for (i, candidate) in enumerate(self.candidates) {\n            if candidate === p {\n                return i\n            }\n        }\n        return self.candidates.count + 1\n    }\n    \n    func prefers(p:Person) -> Bool {\n        if let fiance = self.fiance {\n            return self.rank(p) < self.rank(fiance)\n        }\n        return false\n    }\n    \n    func nextCandidate() -> Person? {\n        if self.candidateIndex >= self.candidates.count {\n            return nil\n        }\n        return self.candidates[candidateIndex++]\n    }\n    \n    func engageTo(p:Person) {\n        p.fiance?.fiance = nil\n        p.fiance = self\n        self.fiance?.fiance = nil\n        self.fiance = p\n    }\n    \n    func swapWith(p:Person) {\n        let thisFiance = self.fiance\n        let pFiance = p.fiance\n        println(\"\\(self.name) swapped partners with \\(p.name)\")\n        if pFiance != nil && thisFiance != nil {\n            self.engageTo(pFiance!)\n            p.engageTo(thisFiance!)\n        }\n    }\n}\n\nfunc isStable(guys:[Person], gals:[Person]) -> Bool {\n    for guy in guys {\n        for gal in gals {\n            if guy.prefers(gal) && gal.prefers(guy) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\nfunc engageEveryone(guys:[Person]) {\n    var done = false\n    while !done {\n        done = true\n        for guy in guys {\n            if guy.fiance == nil {\n                done = false\n                if let gal = guy.nextCandidate() {\n                    if gal.fiance == nil || gal.prefers(guy) {\n                        guy.engageTo(gal)\n                    }\n                }\n            }\n        }\n    }\n}\n\nfunc doMarriage() {\n    let abe  = Person(name: \"Abe\")\n    let bob  = Person(name: \"Bob\")\n    let col  = Person(name: \"Col\")\n    let dan  = Person(name: \"Dan\")\n    let ed   = Person(name: \"Ed\")\n    let fred = Person(name: \"Fred\")\n    let gav  = Person(name: \"Gav\")\n    let hal  = Person(name: \"Hal\")\n    let ian  = Person(name: \"Ian\")\n    let jon  = Person(name: \"Jon\")\n    let abi  = Person(name: \"Abi\")\n    let bea  = Person(name: \"Bea\")\n    let cath = Person(name: \"Cath\")\n    let dee  = Person(name: \"Dee\")\n    let eve  = Person(name: \"Eve\")\n    let fay  = Person(name: \"Fay\")\n    let gay  = Person(name: \"Gay\")\n    let hope = Person(name: \"Hope\")\n    let ivy  = Person(name: \"Ivy\")\n    let jan  = Person(name: \"Jan\")\n    \n    abe.candidates  = [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]\n    bob.candidates  = [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]\n    col.candidates  = [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]\n    dan.candidates  = [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]\n    ed.candidates   = [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]\n    fred.candidates = [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]\n    gav.candidates  = [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]\n    hal.candidates  = [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]\n    ian.candidates  = [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]\n    jon.candidates  = [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n    abi.candidates  = [bob, fred, jon, gav, ian, abe, dan, ed, col, hal]\n    bea.candidates  = [bob, abe, col, fred, gav, dan, ian, ed, jon, hal]\n    cath.candidates = [fred, bob, ed, gav, hal, col, ian, abe, dan, jon]\n    dee.candidates  = [fred, jon, col, abe, ian, hal, gav, dan, bob, ed]\n    eve.candidates  = [jon, hal, fred, dan, abe, gav, col, ed, ian, bob]\n    fay.candidates  = [bob, abe, ed, ian, jon, dan, fred, gav, col, hal]\n    gay.candidates  = [jon, gav, hal, fred, bob, abe, col, ed, dan, ian]\n    hope.candidates = [gav, jon, bob, abe, ian, dan, hal, ed, col, fred]\n    ivy.candidates  = [ian, col, hal, gav, fred, bob, abe, ed, jon, dan]\n    jan.candidates  = [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n    \n    let guys = [abe, bob, col, dan, ed, fred, gav, hal, ian, jon]\n    let gals = [abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan]\n    \n    engageEveryone(guys)\n    \n    for guy in guys {\n        println(\"\\(guy.name) is engaged to \\(guy.fiance!.name)\")\n    }\n    \n    println(\"Stable = \\(isStable(guys, gals))\")\n    jon.swapWith(fred)\n    println(\"Stable = \\(isStable(guys, gals))\")\n    \n}\n\ndoMarriage()\n\n\nOutput:\nAbe is engaged to Ivy\nBob is engaged to Cath\nCol is engaged to Dee\nDan is engaged to Fay\nEd is engaged to Jan\nFred is engaged to Bea\nGav is engaged to Gay\nHal is engaged to Eve\nIan is engaged to Hope\nJon is engaged to Abi\nStable = true\nJon swapped partners with Fred\nStable = false\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\n# This is not optimized, but tries to follow the pseudocode given the Wikipedia entry below.\n# Reference: https://en.wikipedia.org/wiki/Stable_marriage_problem#Algorithm\n\nconst males = [\"abe\", \"bob\", \"col\", \"dan\", \"ed\", \"fred\", \"gav\", \"hal\", \"ian\", \"jon\"]\nconst females = [\"abi\", \"bea\", \"cath\", \"dee\", \"eve\", \"fay\", \"gay\", \"hope\", \"ivy\", \"jan\"]\n\nconst malepreferences = Dict(\n  \"abe\" => [\"abi\", \"eve\", \"cath\", \"ivy\", \"jan\", \"dee\", \"fay\", \"bea\", \"hope\", \"gay\"],\n  \"bob\" => [\"cath\", \"hope\", \"abi\", \"dee\", \"eve\", \"fay\", \"bea\", \"jan\", \"ivy\", \"gay\"],\n  \"col\" => [\"hope\", \"eve\", \"abi\", \"dee\", \"bea\", \"fay\", \"ivy\", \"gay\", \"cath\", \"jan\"],\n  \"dan\" => [\"ivy\", \"fay\", \"dee\", \"gay\", \"hope\", \"eve\", \"jan\", \"bea\", \"cath\", \"abi\"],\n   \"ed\" => [\"jan\", \"dee\", \"bea\", \"cath\", \"fay\", \"eve\", \"abi\", \"ivy\", \"hope\", \"gay\"],\n \"fred\" => [\"bea\", \"abi\", \"dee\", \"gay\", \"eve\", \"ivy\", \"cath\", \"jan\", \"hope\", \"fay\"],\n  \"gav\" => [\"gay\", \"eve\", \"ivy\", \"bea\", \"cath\", \"abi\", \"dee\", \"hope\", \"jan\", \"fay\"],\n  \"hal\" => [\"abi\", \"eve\", \"hope\", \"fay\", \"ivy\", \"cath\", \"jan\", \"bea\", \"gay\", \"dee\"],\n  \"ian\" => [\"hope\", \"cath\", \"dee\", \"gay\", \"bea\", \"abi\", \"fay\", \"ivy\", \"jan\", \"eve\"],\n  \"jon\" => [\"abi\", \"fay\", \"jan\", \"gay\", \"eve\", \"bea\", \"dee\", \"cath\", \"ivy\", \"hope\"]\n)\n\nconst femalepreferences = Dict(\n  \"abi\"=> [\"bob\", \"fred\", \"jon\", \"gav\", \"ian\", \"abe\", \"dan\", \"ed\", \"col\", \"hal\"],\n  \"bea\"=> [\"bob\", \"abe\", \"col\", \"fred\", \"gav\", \"dan\", \"ian\", \"ed\", \"jon\", \"hal\"],\n \"cath\"=> [\"fred\", \"bob\", \"ed\", \"gav\", \"hal\", \"col\", \"ian\", \"abe\", \"dan\", \"jon\"],\n  \"dee\"=> [\"fred\", \"jon\", \"col\", \"abe\", \"ian\", \"hal\", \"gav\", \"dan\", \"bob\", \"ed\"],\n  \"eve\"=> [\"jon\", \"hal\", \"fred\", \"dan\", \"abe\", \"gav\", \"col\", \"ed\", \"ian\", \"bob\"],\n  \"fay\"=> [\"bob\", \"abe\", \"ed\", \"ian\", \"jon\", \"dan\", \"fred\", \"gav\", \"col\", \"hal\"],\n  \"gay\"=> [\"jon\", \"gav\", \"hal\", \"fred\", \"bob\", \"abe\", \"col\", \"ed\", \"dan\", \"ian\"],\n \"hope\"=> [\"gav\", \"jon\", \"bob\", \"abe\", \"ian\", \"dan\", \"hal\", \"ed\", \"col\", \"fred\"],\n  \"ivy\"=> [\"ian\", \"col\", \"hal\", \"gav\", \"fred\", \"bob\", \"abe\", \"ed\", \"jon\", \"dan\"],\n  \"jan\"=> [\"ed\", \"hal\", \"gav\", \"abe\", \"bob\", \"jon\", \"col\", \"ian\", \"fred\", \"dan\"]\n)\n\nfunction pshuf(d)\n    ret = Dict()\n    for (k,v) in d\n        ret[k] = shuffle(v)\n    end\n    ret\nend\n\n# helper functions for the verb: p1 \"prefers\" p2 over p3\npindexin(a, p) = ([i for i in 1:length(a) if a[i] == p])[1]\nprefers(d, p1, p2, p3) = (pindexin(d[p1], p2) < pindexin(d[p1], p3))\n\nfunction isstable(mmatchup, fmatchup, mpref, fpref)\n    for (mmatch, fmatch) in mmatchup\n        for f in mpref[mmatch]\n            if(f != fmatch && prefers(mpref, mmatch, f, fmatch)\n                           && prefers(fpref, f, mmatch, fmatchup[f]))\n                println(\"$mmatch prefers $f and $f prefers $mmatch over their current partners.\")\n                return false\n            end\n        end\n    end\n    true\nend\n\nfunction galeshapley(men, women, malepref, femalepref)\n    # Initialize all m \u2208 M and w \u2208 W to free\n    mfree = Dict([(p, true) for p in men])\n    wfree = Dict([(p, true) for p in women])\n    mpairs = Dict()\n    wpairs = Dict()\n    while true                    # while \u2203 free man m who still has a woman w to propose to\n        bachelors = [p for p in keys(mfree) if mfree[p]]\n        if(length(bachelors) == 0)\n            return mpairs, wpairs\n        end\n        for m in bachelors\n            for w in malepref[m]  # w = first woman on m\u2019s list to whom m has not yet proposed\n                if(wfree[w])      # if w is free (else some pair (m', w) already exists)\n                    #println(\"Free match: $m, $w\")\n                    mpairs[m] = w # (m, w) become engaged\n                    wpairs[w] = m # double entry bookeeping\n                    mfree[m] = false\n                    wfree[w] = false\n                    break\n                elseif(prefers(femalepref, w, m, wpairs[w])) # if w prefers m to m'\n                    #println(\"Unmatch $(wpairs[w]), match: $m, $w\")\n                    mfree[wpairs[w]] = true # m' becomes free\n                    mpairs[m] = w           # (m, w) become engaged\n                    wpairs[w] = m\n                    mfree[m] = false\n                    break\n                end                         # else (m', w) remain engaged, so continue\n            end\n        end\n    end\nend\n\nfunction tableprint(txt, ans, stab)\n    println(txt)\n    println(\"   Man     Woman\")\n    println(\"   -----   -----\")\n    show(STDOUT, \"text/plain\", ans)\n    if(stab)\n        println(\"\\n  ----STABLE----\\n\\n\")\n    else\n        println(\"\\n  ---UNSTABLE---\\n\\n\")\n    end\nend\n\nprintln(\"Use the Gale Shapley algorithm to find a stable set of engagements.\")\nanswer = galeshapley(males, females, malepreferences, femalepreferences)\nstabl = isstable(answer[1], answer[2], malepreferences, femalepreferences)\ntableprint(\"Original Data Table\", answer[1], stabl)\n\nprintln(\"To check this is not a one-off solution, run the function on a randomized sample.\")\nnewmpref = pshuf(malepreferences)\nnewfpref = pshuf(femalepreferences)\nanswer = galeshapley(males, females, newmpref, newfpref)\nstabl = isstable(answer[1], answer[2], newmpref, newfpref)\ntableprint(\"Shuffled Preferences\", answer[1], stabl)\n\n# trade abe with bob\nprintln(\"Perturb this set of engagements to form an unstable set of engagements then check this new set for stability.\")\nanswer = galeshapley(males, females, malepreferences, femalepreferences)\nfia1 = (answer[1])[\"abe\"]\nfia2 = (answer[1])[\"bob\"]\nanswer[1][\"abe\"] = fia2\nanswer[1][\"bob\"] = fia1\nanswer[2][fia1] = \"bob\"\nanswer[2][fia2] = \"abe\"\nstabl = isstable(answer[1], answer[2], malepreferences, femalepreferences)\ntableprint(\"Original Data With Bob and Abe Switched\", answer[1], stabl)\n\n\nOutput:\nUse the Gale Shapley algorithm to find a stable set of engagements.\nOriginal Data Table\n   Man     Woman\n   -----   -----\nDict{Any,Any} with 10 entries:\n  \"bob\" => \"cath\"\n  \"dan\" => \"fay\"\n  \"fred\" => \"bea\"\n  \"jon\" => \"abi\"\n  \"ian\" => \"hope\"\n  \"gav\" => \"gay\"\n  \"ed\" => \"jan\"\n  \"col\" => \"dee\"\n  \"hal\" => \"eve\"\n  \"abe\" => \"ivy\"\n  ----STABLE----\n\n\nTo check this is not a one-off solution, run the function on a randomized sample.\nShuffled Preferences\n   Man     Woman\n   -----   -----\nDict{Any,Any} with 10 entries:\n  \"bob\" => \"abi\"\n  \"dan\" => \"bea\"\n  \"fred\" => \"jan\"\n  \"jon\" => \"dee\"\n  \"ian\" => \"fay\"\n  \"gav\" => \"ivy\"\n  \"ed\" => \"gay\"\n  \"col\" => \"cath\"\n  \"hal\" => \"hope\"\n  \"abe\" => \"eve\"\n  ----STABLE----\n\n\nPerturb this set of engagements to form an unstable set of engagements then check this new set for stability.\nbob prefers cath and cath prefers bob over their current partners.\nOriginal Data With Bob and Abe Switched\n   Man     Woman\n   -----   -----\nDict{Any,Any} with 10 entries:\n  \"bob\" => \"ivy\"\n  \"dan\" => \"fay\"\n  \"fred\" => \"bea\"\n  \"jon\" => \"abi\"\n  \"ian\" => \"hope\"\n  \"gav\" => \"gay\"\n  \"ed\" => \"jan\"\n  \"col\" => \"dee\"\n  \"hal\" => \"eve\"\n  \"abe\" => \"cath\"\n  ---UNSTABLE---\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\ndata class Person(val name: String) {\n    val preferences = mutableListOf<Person>()\n    var matchedTo: Person? = null\n\n    fun trySwap(p: Person) {\n        if (prefers(p)) {\n            matchedTo?.matchedTo = null\n            matchedTo = p\n            p.matchedTo = this\n        }\n    }\n\n    fun prefers(p: Person) = when (matchedTo) {\n        null -> true\n        else -> preferences.indexOf(p) < preferences.indexOf(matchedTo!!)\n    }\n\n    fun showMatch() = \"$name <=> ${matchedTo?.name}\"\n}\n\nfun match(males: Collection<Person>) {\n    while (males.find { it.matchedTo == null }?.also { match(it) } != null) {\n    }\n}\n\nfun match(male: Person) {\n    while (male.matchedTo == null) {\n        male.preferences.removeAt(0).trySwap(male)\n    }\n}\n\nfun isStableMatch(males: Collection<Person>, females: Collection<Person>): Boolean {\n    return males.all { isStableMatch(it, females) }\n}\n\nfun isStableMatch(male: Person, females: Collection<Person>): Boolean {\n\n    val likesBetter = females.filter { !male.preferences.contains(it) }\n    val stable = !likesBetter.any { it.prefers(male) }\n\n    if (!stable) {\n        println(\"#### Unstable pair: ${male.showMatch()}\")\n    }\n    return stable\n}\n\n\nfun main(args: Array<String>) {\n    val inMales = mapOf(\n            \"abe\" to mutableListOf(\"abi\", \"eve\", \"cath\", \"ivy\", \"jan\", \"dee\", \"fay\", \"bea\", \"hope\", \"gay\"),\n            \"bob\" to mutableListOf(\"cath\", \"hope\", \"abi\", \"dee\", \"eve\", \"fay\", \"bea\", \"jan\", \"ivy\", \"gay\"),\n            \"col\" to mutableListOf(\"hope\", \"eve\", \"abi\", \"dee\", \"bea\", \"fay\", \"ivy\", \"gay\", \"cath\", \"jan\"),\n            \"dan\" to mutableListOf(\"ivy\", \"fay\", \"dee\", \"gay\", \"hope\", \"eve\", \"jan\", \"bea\", \"cath\", \"abi\"),\n            \"ed\" to mutableListOf(\"jan\", \"dee\", \"bea\", \"cath\", \"fay\", \"eve\", \"abi\", \"ivy\", \"hope\", \"gay\"),\n            \"fred\" to mutableListOf(\"bea\", \"abi\", \"dee\", \"gay\", \"eve\", \"ivy\", \"cath\", \"jan\", \"hope\", \"fay\"),\n            \"gav\" to mutableListOf(\"gay\", \"eve\", \"ivy\", \"bea\", \"cath\", \"abi\", \"dee\", \"hope\", \"jan\", \"fay\"),\n            \"hal\" to mutableListOf(\"abi\", \"eve\", \"hope\", \"fay\", \"ivy\", \"cath\", \"jan\", \"bea\", \"gay\", \"dee\"),\n            \"ian\" to mutableListOf(\"hope\", \"cath\", \"dee\", \"gay\", \"bea\", \"abi\", \"fay\", \"ivy\", \"jan\", \"eve\"),\n            \"jon\" to mutableListOf(\"abi\", \"fay\", \"jan\", \"gay\", \"eve\", \"bea\", \"dee\", \"cath\", \"ivy\", \"hope\"))\n\n    val inFemales = mapOf(\n            \"abi\" to listOf(\"bob\", \"fred\", \"jon\", \"gav\", \"ian\", \"abe\", \"dan\", \"ed\", \"col\", \"hal\"),\n            \"bea\" to listOf(\"bob\", \"abe\", \"col\", \"fred\", \"gav\", \"dan\", \"ian\", \"ed\", \"jon\", \"hal\"),\n            \"cath\" to listOf(\"fred\", \"bob\", \"ed\", \"gav\", \"hal\", \"col\", \"ian\", \"abe\", \"dan\", \"jon\"),\n            \"dee\" to listOf(\"fred\", \"jon\", \"col\", \"abe\", \"ian\", \"hal\", \"gav\", \"dan\", \"bob\", \"ed\"),\n            \"eve\" to listOf(\"jon\", \"hal\", \"fred\", \"dan\", \"abe\", \"gav\", \"col\", \"ed\", \"ian\", \"bob\"),\n            \"fay\" to listOf(\"bob\", \"abe\", \"ed\", \"ian\", \"jon\", \"dan\", \"fred\", \"gav\", \"col\", \"hal\"),\n            \"gay\" to listOf(\"jon\", \"gav\", \"hal\", \"fred\", \"bob\", \"abe\", \"col\", \"ed\", \"dan\", \"ian\"),\n            \"hope\" to listOf(\"gav\", \"jon\", \"bob\", \"abe\", \"ian\", \"dan\", \"hal\", \"ed\", \"col\", \"fred\"),\n            \"ivy\" to listOf(\"ian\", \"col\", \"hal\", \"gav\", \"fred\", \"bob\", \"abe\", \"ed\", \"jon\", \"dan\"),\n            \"jan\" to listOf(\"ed\", \"hal\", \"gav\", \"abe\", \"bob\", \"jon\", \"col\", \"ian\", \"fred\", \"dan\"))\n\n\n    fun buildPrefs(person: Person, stringPrefs: List<String>, population: List<Person>) {\n        person.preferences.addAll(\n                stringPrefs.map { name -> population.single { it.name == name } }\n        )\n    }\n\n    val males = inMales.keys.map { Person(it) }\n    val females = inFemales.keys.map { Person(it) }\n\n    males.forEach { buildPrefs(it, inMales[it.name]!!, females) }\n    females.forEach { buildPrefs(it, inFemales[it.name]!!, males) }\n\n\n    match(males)\n    males.forEach { println(it.showMatch()) }\n    println(\"#### match is stable: ${isStableMatch(males, females)}\")\n\n\n    fun swapMatch(male1: Person, male2: Person) {\n        val female1 = male1.matchedTo!!\n        val female2 = male2.matchedTo!!\n\n        male1.matchedTo = female2\n        male2.matchedTo = female1\n\n        female1.matchedTo = male2\n        female2.matchedTo = male1\n    }\n\n    swapMatch(males.single { it.name == \"fred\" }, males.single { it.name == \"jon\" })\n    males.forEach { println(it.showMatch()) }\n    println(\"#### match is stable: ${isStableMatch(males, females)}\")\n}\n\n\nOutput:\nabe <=> ivy\nbob <=> cath\ncol <=> dee\ndan <=> fay\ned <=> jan\nfred <=> bea\ngav <=> gay\nhal <=> eve\nian <=> hope\njon <=> abi\n##### match is stable: true\nabe <=> ivy\nbob <=> cath\ncol <=> dee\ndan <=> fay\ned <=> jan\nfred <=> abi\ngav <=> gay\nhal <=> eve\nian <=> hope\njon <=> bea\n#### Unstable pair: fred <=> abi\n##### match is stable: false\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n#!/usr/bin/env perl \nuse strict;\nuse warnings;\nuse feature qw/say/;\nuse List::Util qw(first);\n\nmy %Likes = (\n  M => {\n    abe  => [qw/ abi eve cath ivy jan dee fay bea hope gay /],\n    bob  => [qw/ cath hope abi dee eve fay bea jan ivy gay /],\n    col  => [qw/ hope eve abi dee bea fay ivy gay cath jan /],\n    dan  => [qw/ ivy fay dee gay hope eve jan bea cath abi /],\n    ed   => [qw/ jan dee bea cath fay eve abi ivy hope gay /],\n    fred => [qw/ bea abi dee gay eve ivy cath jan hope fay /],\n    gav  => [qw/ gay eve ivy bea cath abi dee hope jan fay /],\n    hal  => [qw/ abi eve hope fay ivy cath jan bea gay dee /],\n    ian  => [qw/ hope cath dee gay bea abi fay ivy jan eve /],\n    jon  => [qw/ abi fay jan gay eve bea dee cath ivy hope /],\n  },\n\n  W => {\n    abi  => [qw/ bob fred jon gav ian abe dan ed col hal /],\n    bea  => [qw/ bob abe col fred gav dan ian ed jon hal /],\n    cath => [qw/ fred bob ed gav hal col ian abe dan jon /],\n    dee  => [qw/ fred jon col abe ian hal gav dan bob ed /],\n    eve  => [qw/ jon hal fred dan abe gav col ed ian bob /],\n    fay  => [qw/ bob abe ed ian jon dan fred gav col hal /],\n    gay  => [qw/ jon gav hal fred bob abe col ed dan ian /],\n    hope => [qw/ gav jon bob abe ian dan hal ed col fred /],\n    ivy  => [qw/ ian col hal gav fred bob abe ed jon dan /],\n    jan  => [qw/ ed hal gav abe bob jon col ian fred dan /],\n  },\n);\n\nmy %Engaged;\nmy %Proposed;\n\nmatch_them();\ncheck_stability();\nperturb();\ncheck_stability();\n\nsub match_them {\n    say 'Matchmaking:';\n    while(my $man = unmatched_man()) {\n        my $woman = preferred_choice($man);\n        $Proposed{$man}{$woman} = 1;\n        if(! $Engaged{W}{$woman}) {\n            engage($man, $woman);\n            say \"\\t$woman and $man\";\n        }\n        else {\n            if(woman_prefers($woman, $man)) {\n                my $engaged_man = $Engaged{W}{$woman};\n                engage($man, $woman);\n                undef $Engaged{M}{$engaged_man};\n                say \"\\t$woman dumped $engaged_man for $man\";\n            }\n        }\n    }\n}\n\nsub check_stability {\n    say 'Stablility:';\n    my $stable = 1;\n    foreach my $m (men()) {\n        foreach my $w (women()) {\n            if(man_prefers($m, $w) && woman_prefers($w, $m)) {\n                say \"\\t$w prefers $m to $Engaged{W}{$w} and $m prefers $w to $Engaged{M}{$m}\";\n                $stable = 0;\n            }\n        }\n    }\n    if($stable) {\n        say \"\\t(all marriages stable)\";\n    }\n}\n\nsub unmatched_man {\n    return first { ! $Engaged{M}{$_} } men();\n}\n\nsub preferred_choice {\n    my $man = shift;\n    return first { ! $Proposed{$man}{$_} } @{ $Likes{M}{$man} };\n}\n\nsub engage {\n    my ($man, $woman) = @_;\n    $Engaged{W}{$woman} = $man;\n    $Engaged{M}{$man} = $woman;\n}\n\nsub prefers {\n    my $sex = shift;\n    return sub {\n        my ($person, $prospect) = @_;\n\n        my $choices = join ' ', @{ $Likes{$sex}{$person} };\n        return index($choices, $prospect) < index($choices, $Engaged{$sex}{$person});\n    }\n}\n\nBEGIN {\n    *woman_prefers = prefers('W');\n    *man_prefers   = prefers('M');\n}\n\nsub perturb {\n    say 'Perturb:';\n    say \"\\tengage abi with fred and bea with jon\";\n    engage('fred' => 'abi');\n    engage('jon'  => 'bea');\n}\n\nsub men   { keys %{ $Likes{M} } }\nsub women { keys %{ $Likes{W} } }\n\n\nOutput:\nMatchmaking:\n        abi and abe\n        ivy and dan\n        abi dumped abe for jon\n        eve and abe\n        eve dumped abe for hal\n        cath and abe\n        gay and gav\n        jan and ed\n        hope and ian\n        dee and col\n        cath dumped abe for bob\n        ivy dumped dan for abe\n        fay and dan\n        bea and fred\nStablility:\n        (all marriages stable)\nPerturb:\n        engage abi with fred and bea with jon\nStablility:\n        eve prefers jon to hal and jon prefers eve to bea\n        gay prefers jon to gav and jon prefers gay to bea\n        fay prefers jon to dan and jon prefers fay to bea\n        bea prefers fred to jon and fred prefers bea to abi\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\nWorks with: XCode 4.5.1\n\n//--------------------------------------------------------------------\n// Person class\n\n@interface Person\u00a0: NSObject {\n    NSUInteger _candidateIndex;\n}\n@property (nonatomic, strong)   NSString*   name;\n@property (nonatomic, strong)   NSArray*    prefs;\n@property (nonatomic, weak)     Person*     fiance;\n@end\n\n@implementation Person\n+ (instancetype)named:(NSString *)name {\n    return [[self alloc] initWithName:name];\n}\n- (instancetype)initWithName:(NSString *)name {\n    if ((self = [super init])) {\n        _name = name;\n        _prefs = nil;\n        _fiance = nil;\n        _candidateIndex = 0;\n    }\n    return self;\n}\n- (BOOL)prefers:(Person *)p {\n    return [_prefs indexOfObject:p] < [_prefs indexOfObject:_fiance];\n}\n- (Person *)nextCandidateNotYetProposedTo {\n    if (_candidateIndex >= _prefs.count) return nil;\n    return _prefs[_candidateIndex++];\n}\n- (void)engageTo:(Person *)p {\n    if (p.fiance) p.fiance.fiance = nil;\n    p.fiance = self;\n    if (self.fiance) self.fiance.fiance = nil;\n    self.fiance = p;\n}\n- (NSString *)description {\n    return _name;\n}\n@end\n\n//--------------------------------------------------------------------\n\nBOOL isStable(NSArray *men) {\n    NSArray *women = ((Person *)men[0]).prefs;\n    for (Person *guy in men) {\n        for (Person *gal in women) {\n            if ([guy prefers:gal] && [gal prefers:guy])\n                return NO;\n        }\n    }\n    return YES;\n}\n\n//--------------------------------------------------------------------\n\nvoid doMarriage() {\n    Person *abe  = [Person named:@\"abe\"];\n    Person *bob  = [Person named:@\"bob\"];\n    Person *col  = [Person named:@\"col\"];\n    Person *dan  = [Person named:@\"dan\"];\n    Person *ed   = [Person named:@\"ed\"];\n    Person *fred = [Person named:@\"fred\"];\n    Person *gav  = [Person named:@\"gav\"];\n    Person *hal  = [Person named:@\"hal\"];\n    Person *ian  = [Person named:@\"ian\"];\n    Person *jon  = [Person named:@\"jon\"];\n    Person *abi  = [Person named:@\"abi\"];\n    Person *bea  = [Person named:@\"bea\"];\n    Person *cath = [Person named:@\"cath\"];\n    Person *dee  = [Person named:@\"dee\"];\n    Person *eve  = [Person named:@\"eve\"];\n    Person *fay  = [Person named:@\"fay\"];\n    Person *gay  = [Person named:@\"gay\"];\n    Person *hope = [Person named:@\"hope\"];\n    Person *ivy  = [Person named:@\"ivy\"];\n    Person *jan  = [Person named:@\"jan\"];\n    \n    abe.prefs  = @[ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay ];\n    bob.prefs  = @[ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay ];\n    col.prefs  = @[ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan ];\n    dan.prefs  = @[ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi ];\n    ed.prefs   = @[ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay ];\n    fred.prefs = @[ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay ];\n    gav.prefs  = @[ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay ];\n    hal.prefs  = @[ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee ];\n    ian.prefs  = @[ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve ];\n    jon.prefs  = @[ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope ];\n    abi.prefs  = @[ bob, fred, jon, gav, ian, abe, dan, ed, col, hal ];\n    bea.prefs  = @[ bob, abe, col, fred, gav, dan, ian, ed, jon, hal ];\n    cath.prefs = @[ fred, bob, ed, gav, hal, col, ian, abe, dan, jon ];\n    dee.prefs  = @[ fred, jon, col, abe, ian, hal, gav, dan, bob, ed ];\n    eve.prefs  = @[ jon, hal, fred, dan, abe, gav, col, ed, ian, bob ];\n    fay.prefs  = @[ bob, abe, ed, ian, jon, dan, fred, gav, col, hal ];\n    gay.prefs  = @[ jon, gav, hal, fred, bob, abe, col, ed, dan, ian ];\n    hope.prefs = @[ gav, jon, bob, abe, ian, dan, hal, ed, col, fred ];\n    ivy.prefs  = @[ ian, col, hal, gav, fred, bob, abe, ed, jon, dan ];\n    jan.prefs  = @[ ed, hal, gav, abe, bob, jon, col, ian, fred, dan ];\n    \n    NSArray *men = abi.prefs;\n    \n    NSUInteger freeMenCount = men.count;\n    while (freeMenCount > 0) {\n        for (Person *guy in men) {\n            if (guy.fiance == nil) {\n                Person *gal = [guy nextCandidateNotYetProposedTo];\n                if (gal.fiance == nil) {\n                    [guy engageTo:gal];\n                    freeMenCount--;\n                } else if ([gal prefers:guy]) {\n                    [guy engageTo:gal];\n                }\n            }\n        }\n    }\n    \n    for (Person *guy in men) {\n        printf(\"%s is engaged to %s\\n\", [guy.name UTF8String], [guy.fiance.name UTF8String]);\n    }\n    printf(\"Stable = %d\\n\", (int)isStable(men));\n\n    printf(\"\\nSwitching fred & jon's partners\\n\");\n    [fred engageTo:abi];\n    [jon engageTo:bea];\n    printf(\"Stable = %d\\n\", (int)isStable(men));\n}\n\n//--------------------------------------------------------------------\n\nint main(int argc, const char * argv[])\n{\n    @autoreleasepool {\n        doMarriage();\n    }\n    return 0;\n}\n\n\nOutput:\nbob is engaged to cath\nfred is engaged to bea\njon is engaged to abi\ngav is engaged to gay\nian is engaged to hope\nabe is engaged to ivy\ndan is engaged to fay\ned is engaged to jan\ncol is engaged to dee\nhal is engaged to eve\nStable = 1\n\nSwitching fred & jon's partners\nStable = 0\n", "explain": "(The C# version is essentially the same as this.)\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI-PrologLibrary: XPCE\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% facts\nprefere(abe,[ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]).\nprefere(  bob,[ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]).\nprefere(  col,[ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]).\nprefere(  dan,[ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]).\nprefere(   ed,[ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]).\nprefere( fred,[ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]).\nprefere(  gav,[ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]).\nprefere(  hal,[ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]).\nprefere(  ian,[ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]).\nprefere(  jon,[ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]).\n\nprefere(  abi,[ bob, fred, jon, gav, ian, abe, dan, ed, col, hal]).\nprefere(  bea,[ bob, abe, col, fred, gav, dan, ian, ed, jon, hal]).\nprefere( cath,[ fred, bob, ed, gav, hal, col, ian, abe, dan, jon]).\nprefere(  dee,[ fred, jon, col, abe, ian, hal, gav, dan, bob, ed]).\nprefere(  eve,[ jon, hal, fred, dan, abe, gav, col, ed, ian, bob]).\nprefere(  fay,[ bob, abe, ed, ian, jon, dan, fred, gav, col, hal]).\nprefere(  gay,[ jon, gav, hal, fred, bob, abe, col, ed, dan, ian]).\nprefere( hope,[ gav, jon, bob, abe, ian, dan, hal, ed, col, fred]).\nprefere(  ivy,[ ian, col, hal, gav, fred, bob, abe, ed, jon, dan]).\nprefere(  jan,[ ed, hal, gav, abe, bob, jon, col, ian, fred, dan]).\n\n\nman(abe).\nman(bob).\nman(col).\nman(dan).\nman(ed).\nman(fred).\nman(gav).\nman(hal).\nman(ian).\nman(jon).\n\nwoman(abi).\nwoman(bea).\nwoman(cath).\nwoman(dee).\nwoman(eve).\nwoman(fay).\nwoman(gay).\nwoman(hope).\nwoman(ivy).\nwoman(jan).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% rules\n\nstable_mariage :-\n\tnew(LstMan, chain),\n\tforall(man(X),\n\t       (   prefere(X, Lst),\n\t\t   new(P, man(X, Lst)),\n\t\t   send(LstMan, append, P))),\n\n\tnew(LstWoman, chain),\n\tforall(woman(X),\n\t       (   prefere(X, Lst),\n\t\t   new(P, woman(X, Lst)),\n\t\t   send(LstWoman, append, P))),\n\tsend(LstMan, for_all, message(@arg1, init_liste, LstWoman)),\n\tsend(LstWoman, for_all, message(@arg1, init_liste, LstMan)),\n\n\tround(LstMan, LstWoman),\n\tnew(LstCouple, chain),\n\t% creation of the couple.\n\tsend(LstWoman, for_all, and(message(@prolog, create_couple, @arg1, LstCouple),\n\t\t\t\t   message(@pce, write_ln, @arg1?name, with, @arg1?elu?name))),\n\n\tnl,\n\t\n\t% test of the stability of couples\n\tstability(LstCouple),\n\tnl,\n\n\t% Perturbation of couples\n\tget(LstCouple, size, Len),\n\tget_two_random_couples(Len, V1, V2),\n\n\tget(LstCouple, nth0, V1, C1),\n\tget(LstCouple, nth0, V2, C2),\n\tnew(NC1, tuple(C1?first, C2?second)),\n\tnew(NC2, tuple(C2?first, C1?second)),\n\tsend(LstCouple, nth0, V1, NC1),\n\tsend(LstCouple, nth0, V2, NC2),\n\n\tsend(@pce, write_ln, 'perturbation of couples'),\n\tsend(@pce, write_ln, NC1?second, with, NC1?first),\n\tsend(@pce, write_ln, NC2?second, with, NC2?first),\n\tnl,\n\t\n\tstability(LstCouple).\n\nget_two_random_couples(Len, C1, C2) :-\n\tC1 is random(Len),\n\trepeat,\n\tC2 is random(Len),\n\tC1 \\= C2.\n\ncreate_couple(Woman, LstCouple ) :-\n\tsend(LstCouple, append, new(_, tuple(Woman?elu?name, Woman?name))).\n\n% iterations of the algorithm\nround(LstMan, LstWoman) :-\n\tsend(LstMan, for_some, message(@arg1, propose)),\n\tsend(LstWoman, for_some, message(@arg1, dispose)),\n\t(   \\+send(LstWoman, for_all, @arg1?status == maybe)\n\t->\n\t    round(LstMan, LstWoman)\n\t;\n\t    true\n\t).\n\n:-pce_begin_class(person, object, \"description of a person\").\nvariable(name, object, both, \"name of the person\").\nvariable(preference, chain, both, \"list of priority\").\nvariable(status, object, both, \"statut of engagement\u00a0: maybe / free\").\n\ninitialise(P, Name, Pref) :->\n\tsend(P, send_super, initialise),\n\tsend(P, slot, name, Name),\n\tsend(P, slot, preference, Pref),\n\tsend(P, slot, status, free).\n\n% reception of the list of partners\ninit_liste(P, Lst) :->\n\t% we replace the list of name of partners\n\t% with the list of persons partners.\n\tnew(NLP, chain),\n\tget(P, slot, preference, LP),\n\tsend(LP, for_all, message(@prolog, find_person,@arg1, Lst, NLP)),\n\tsend(P, slot, preference, NLP).\n\n:- pce_end_class(person).\n\n\n\nfind_person(Name, LstPerson, LstPref) :-\n\tget(LstPerson, find, @arg1?name == Name, Elem),\n\tsend(LstPref, append, Elem).\n\n:-pce_begin_class(man, person, \"description of a man\").\n\ninitialise(P, Name, Pref) :->\n\tsend(P, send_super, initialise, Name, Pref).\n\n% a man propose \"la botte\" to a woman\npropose(P) :->\n\tget(P, slot, status, free),\n\tget(P, slot, preference, XPref),\n\tget(XPref, delete_head, Pref),\n\tsend(P, slot, preference, XPref),\n\tsend(Pref, proposition, P).\n\nrefuse(P) :->\n\tsend(P, slot, status, free).\n\naccept(P) :->\n\tsend(P, slot, status, maybe).\n\n:- pce_end_class(man).\n\n:-pce_begin_class(woman, person, \"description of a woman\").\nvariable(elu, object, both, \"name of the elu\").\nvariable(contact, chain, both, \"men that have contact this woman\").\n\ninitialise(P, Name, Pref) :->\n\tsend(P, send_super, initialise, Name, Pref),\n\tsend(P, slot, contact, new(_, chain)),\n\tsend(P, slot, elu, @nil).\n\n% a woman decide Maybe/No\ndispose(P) :->\n\tget(P, slot, contact, Contact),\n\tget(P, slot, elu, Elu),\n\n\t(   Elu \\= @nil\n\t->\n\t    send(Contact, append, Elu)\n\t;\n\t    true),\n\n\tnew(R, chain),\n\tsend(Contact, for_all, message(P, fetch, @arg1, R)),\n\tsend(R, sort, ?(@arg1?first, compare, @arg2?first)),\n\tget(R, delete_head, Tete),\n\tsend(Tete?second, accept),\n\tsend(P, slot, status, maybe),\n\tsend(P, slot, elu, Tete?second),\n\tsend(R, for_some, message(@arg1?second, refuse)),\n\tsend(P, slot, contact, new(_, chain)) .\n\n\n% looking for the person of the given name  Contact\n% Adding it in the chain Chain\nfetch(P, Contact, Chain) :->\n\tget(P, slot, preference, Lst),\n\tget(Lst, find, @arg1?name == Contact?name, Elem),\n\tget(Lst, index, Elem, Ind),\n\tsend(Chain, append, new(_, tuple(Ind, Contact))).\n\n% a woman receive a proposition from a man\nproposition(P, Name) :->\n\tget(P, slot, contact, C),\n\tsend(C, append, Name),\n\tsend(P, slot, contact, C).\n\n:- pce_end_class(woman).\n\n% computation of the stability od couple\nstability(LstCouple) :-\n\tchain_list(LstCouple, LstPceCouple),\n\tmaplist(transform, LstPceCouple, PrologLstCouple),\n\tstudy_couples(PrologLstCouple, [], UnstableCouple),\n\t(   UnstableCouple = []\n\t->\n\t    writeln('Couples are stable')\n\t;\n\t    sort(UnstableCouple, SortUnstableCouple),\n\t    writeln('Unstable couples are'),\n\t    maplist(print_unstable_couple, SortUnstableCouple),\n\t    nl\n\t).\n\n\nprint_unstable_couple((C1, C2)) :-\n\tformat('~w and ~w~n', [C1, C2]).\n\ntransform(PceCouple, couple(First, Second)):-\n\tget(PceCouple?first, value, First),\n\tget(PceCouple?second, value, Second).\n\nstudy_couples([], UnstableCouple, UnstableCouple).\n\nstudy_couples([H | T], CurrentUnstableCouple, UnstableCouple):-\n\tinclude(unstable_couple(H), T, Lst),\n\t(   Lst \\= []\n\t->\n\t    maplist(build_one_couple(H), Lst, Lst1),\n\t    append(CurrentUnstableCouple, Lst1,CurrentUnstableCouple1)\n\t;\n\t    CurrentUnstableCouple1 = CurrentUnstableCouple\n\t),\n\tstudy_couples(T, CurrentUnstableCouple1, UnstableCouple).\n\n\nbuild_one_couple(C1, C2, (C1, C2)).\n\nunstable_couple(couple(X1, Y1), couple(X2, Y2)) :-\n\tprefere(X1, PX1),\n\tprefere(X2, PX2),\n\tprefere(Y1, PY1),\n\tprefere(Y2, PY2),\n\n\t% index of women for X1\n\tnth0(IY12, PX1, Y2),\n\tnth0(IY11, PX1, Y1),\n\t% index of men for Y2\n\tnth0(IX21, PY2, X1),\n\tnth0(IX22, PY2, X2),\n\n\t% index of women for X2\n\tnth0(IY21, PX2, Y1),\n\tnth0(IY22, PX2, Y2),\n\t% index of men for Y1\n\tnth0(IX11, PY1, X1),\n\tnth0(IX12, PY1, X2),\n\n\t% A couple is unstable\n\t( (IY12 < IY11 , IX21 < IX22);\n\t  (IY21 < IY22 , IX12 < IX11)).\n\n\nOutput:\n\u00a0?- stable_mariage.\nabi with jon\nbea with fred\ncath with bob\ndee with col\neve with hal\nfay with dan\ngay with gav\nhope with ian\nivy with abe\njan with ed\n\nCouples are stable\n\nperturbation of couples\ngay with jon\nabi with gav\n\nUnstable couples are\ncouple(gav,abi) and couple(abe,ivy)\ncouple(jon,gay) and couple(dan,fay)\ncouple(jon,gay) and couple(gav,abi)\n\ntrue \n\n:- dynamic person/4, prop/2.\n% person(Name, Preference, Status, Candidate)\n% prop(Name, List_of_Candidates) (for a woman)\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% facts\nprefere(abe,[ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay]).\nprefere(  bob,[ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay]).\nprefere(  col,[ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan]).\nprefere(  dan,[ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi]).\nprefere(   ed,[ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay]).\nprefere( fred,[ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay]).\nprefere(  gav,[ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay]).\nprefere(  hal,[ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee]).\nprefere(  ian,[ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve]).\nprefere(  jon,[ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]).\n\nprefere(  abi,[ bob, fred, jon, gav, ian, abe, dan, ed, col, hal]).\nprefere(  bea,[ bob, abe, col, fred, gav, dan, ian, ed, jon, hal]).\nprefere( cath,[ fred, bob, ed, gav, hal, col, ian, abe, dan, jon]).\nprefere(  dee,[ fred, jon, col, abe, ian, hal, gav, dan, bob, ed]).\nprefere(  eve,[ jon, hal, fred, dan, abe, gav, col, ed, ian, bob]).\nprefere(  fay,[ bob, abe, ed, ian, jon, dan, fred, gav, col, hal]).\nprefere(  gay,[ jon, gav, hal, fred, bob, abe, col, ed, dan, ian]).\nprefere( hope,[ gav, jon, bob, abe, ian, dan, hal, ed, col, fred]).\nprefere(  ivy,[ ian, col, hal, gav, fred, bob, abe, ed, jon, dan]).\nprefere(  jan,[ ed, hal, gav, abe, bob, jon, col, ian, fred, dan]).\n\n\nman(abe).\nman(bob).\nman(col).\nman(dan).\nman(ed).\nman(fred).\nman(gav).\nman(hal).\nman(ian).\nman(jon).\n\nwoman(abi).\nwoman(bea).\nwoman(cath).\nwoman(dee).\nwoman(eve).\nwoman(fay).\nwoman(gay).\nwoman(hope).\nwoman(ivy).\nwoman(jan).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% rules\nstable_mariage :-\n\t%initialization\n\tretractall(person(_,_,_,_)),\n\tretractall(prop(_,_)),\n\tforall(prefere(P, Pref), assert(person(P, Pref, free, none))),\n\tbagof(X, man(X), LstMen),\n\tbagof(Y, woman(Y), LstWomen),\n\tforall(member(Z, LstWomen), assert(prop(Z, []))),\n\n\t% compute the mariages\n\titeration(LstMen, LstWomen, LstCouple),\n\tmaplist(print_couple,LstCouple),\n\tnl,\n\n\t% test of the stability of couples\n\tstability(LstCouple),\n\tnl,\n\n\t% Perturbation of couples\n\tlength(LstCouple, Len),\n\tget_two_random_couples(Len, V1, V2),\n\n\tnth0(V1, LstCouple, C1),\n\tselect(C1, LstCouple, Lst1),\n\t(   V2 > 0 -> V22 is V2 - 1; V22 = V2),\n\tnth0(V22, Lst1, C2),\n\tselect(C2, Lst1, Lst2),\n\tC1 = couple(M1, W1),\n\tC2 = couple(M2, W2),\n\n\twriteln('perturbation of couples'),\n\tformat('~w with ~w~n', [W1, M2]),\n\tformat('~w with ~w~n', [W2, M1]),\n\tnl,\n\tstability([couple(M1, W2), couple(M2, W1)| Lst2]).\n\n\n% the algorithm\niteration(Men, Women, LstCouples) :-\n\t% Men propose\n\tbagof(M,  X^Y^(member(M, Men),person(M, X, free, Y)), LM),\n\tforall(member(X, LM),\n\t       (   retract(person(X, [W|Pref], free, Elu)),\n\t\t   assert(person(X, Pref, free, Elu)),\n\t\t   retract(prop(W, Prop)),\n\t\t   assert(prop(W, [X| Prop])))),\n\t\n\t% women dispose\n\tbagof(W, L^(prop(W, L), L \\= []), LW),\n\tforall(member(W, LW),\n\t       (   retract(prop(W, Prop)),\n\t           retract(person(W, Pref, _, Elu)),\n\t\t   (   Elu = none -> Prop1 = Prop; Prop1 = [Elu|Prop]),\n\t           order_prop(Pref, Prop1, [M | Prop2]),\n\t\t   retract(person(M, PrefM, _, _)),\n\t\t   assert(person(M, PrefM, maybe, W)),\n\t\t   forall(member(Y, Prop2),\n\t\t\t  (   retract(person(Y, Pref1, _, _TE)),\n\t\t\t      assert(person(Y, Pref1, free, none)))),\n\t\t   assert(prop(W, [])),\n\t\t   assert(person(W, Pref, maybe, M))\n\t       )),\n\t\n\t% finished\u00a0?\n\t(   bagof(X, T^Z^(member(X, Women), person(X, T, free, Z)), _LW1) ->\n\t    iteration(Men, Women, LstCouples)\n\t;\n\t    make_couple(Women, LstCouples)\n\t).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% compute order preference of candidates.\norder_prop(Pref, Prop, Res) :-\n\tmaplist(index(Pref), Prop, Rtemp),\n\tsort(Rtemp, Rtemp1),\n\tmaplist(simplifie,Rtemp1, Res).\n\nindex(Lst, Value, [Ind, Value]) :-\n\tnth0(Ind, Lst, Value).\n\nsimplifie([_, V], V).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nprint_couple(couple(M, W)) :-\n\tformat('~w with ~w~n', [W, M]).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% creation of couples\nmake_couple([], []).\n\nmake_couple([W | LW], [couple(M, W) | LC]) :-\n\tmake_couple(LW, LC),\n\tperson(W, _, _, M).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% miscellaneous\nget_two_random_couples(Len, C1, C2) :-\n\tC1 is random(Len),\n\trepeat,\n\tC2 is random(Len),\n\tC1 \\= C2.\n\nprint_unstable_couple((C1, C2)) :-\n\tformat('~w and ~w~n', [C1, C2]).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% test the stability of couples\nstability(LstCouple) :-\n\tstudy_couples(LstCouple, [], CoupleInstable),\n\t(   CoupleInstable = []\n\t->\n\t    writeln('Couples are stable')\n\t;\n\t    sort(CoupleInstable, SortCoupleInstable),\n\t    writeln('Unstable couples are'),\n\t    maplist(print_unstable_couple, SortCoupleInstable),\n\t    nl\n\t).\n\n\n% compute the stability od couple\nstudy_couples([], UnstableCouple, UnstableCouple).\n\nstudy_couples([H | T], CurrentUnstableCouple, UnstableCouple):-\n\tinclude(unstable_couple(H), T, Lst),\n\t(   Lst \\= []\n\t->\n\t    maplist(build_one_couple(H), Lst, Lst1),\n\t   append(CurrentUnstableCouple, Lst1,CurrentUnstableCouple1)\n\t;\n\t   CurrentUnstableCouple1 = CurrentUnstableCouple\n\t),\n\tstudy_couples(T, CurrentUnstableCouple1, UnstableCouple).\n\n\nbuild_one_couple(C1, C2, (C1, C2)).\n\nunstable_couple(couple(X1, Y1), couple(X2, Y2)) :-\n\tprefere(X1, PX1),\n\tprefere(X2, PX2),\n\tprefere(Y1, PY1),\n\tprefere(Y2, PY2),\n\n\t% index of women for X1\n\tnth0(IY12, PX1, Y2),\n\tnth0(IY11, PX1, Y1),\n\t% index of men for Y2\n\tnth0(IX21, PY2, X1),\n\tnth0(IX22, PY2, X2),\n\n\t% index of women for X2\n\tnth0(IY21, PX2, Y1),\n\tnth0(IY22, PX2, Y2),\n\t% index of men for Y1\n\tnth0(IX11, PY1, X1),\n\tnth0(IX12, PY1, X2),\n\n\t% A couple is unstable\n\t( (IY12 < IY11 , IX21 < IX22);\n\t  (IY21 < IY22 , IX12 < IX11)).\n\n", "explain": "XPCE is used for its integrated messaging system.\nA more Prolog-ish version (working with SWI-Prolog) could be\u00a0:\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nTranslation of: C#\nlocal Person = {}\nPerson.__index = Person\n\nfunction Person.new(inName)\n    local o = {\n        name            = inName,\n        prefs           = nil,\n        fiance          = nil,\n        _candidateIndex = 1,\n    }\n    return setmetatable(o, Person)\nend\n\nfunction Person:indexOf(other)\n    for i, p in pairs(self.prefs) do\n        if p == other then return i end\n    end\n    return 999\nend\n\nfunction Person:prefers(other)\n    return self:indexOf(other) < self:indexOf(self.fiance)\nend\n\nfunction Person:nextCandidateNotYetProposedTo()\n    if self._candidateIndex >= #self.prefs then return nil end\n    local c = self.prefs[self._candidateIndex];\n    self._candidateIndex = self._candidateIndex + 1\n    return c;\nend\n\nfunction Person:engageTo(other)\n    if other.fiance then\n        other.fiance.fiance = nil\n    end\n    other.fiance = self\n    if self.fiance then\n        self.fiance.fiance = nil\n    end\n    self.fiance = other;\nend\n\nlocal function isStable(men)\n    local women = men[1].prefs\n    local stable = true\n    for _, guy in pairs(men) do\n        for _, gal in pairs(women) do\n            if guy:prefers(gal) and gal:prefers(guy) then\n                stable = false\n                print(guy.name .. ' and ' .. gal.name ..\n                      ' prefer each other over their partners ' ..\n                      guy.fiance.name .. ' and ' .. gal.fiance.name)\n            end\n        end\n    end\n    return stable\nend\n\nlocal abe  = Person.new(\"Abe\")\nlocal bob  = Person.new(\"Bob\")\nlocal col  = Person.new(\"Col\")\nlocal dan  = Person.new(\"Dan\")\nlocal ed   = Person.new(\"Ed\")\nlocal fred = Person.new(\"Fred\")\nlocal gav  = Person.new(\"Gav\")\nlocal hal  = Person.new(\"Hal\")\nlocal ian  = Person.new(\"Ian\")\nlocal jon  = Person.new(\"Jon\")\n\nlocal abi  = Person.new(\"Abi\")\nlocal bea  = Person.new(\"Bea\")\nlocal cath = Person.new(\"Cath\")\nlocal dee  = Person.new(\"Dee\")\nlocal eve  = Person.new(\"Eve\")\nlocal fay  = Person.new(\"Fay\")\nlocal gay  = Person.new(\"Gay\")\nlocal hope = Person.new(\"Hope\")\nlocal ivy  = Person.new(\"Ivy\")\nlocal jan  = Person.new(\"Jan\")\n\nabe.prefs  = { abi,  eve,  cath, ivy,  jan,  dee,  fay,  bea,  hope, gay  }\nbob.prefs  = { cath, hope, abi,  dee,  eve,  fay,  bea,  jan,  ivy,  gay  }\ncol.prefs  = { hope, eve,  abi,  dee,  bea,  fay,  ivy,  gay,  cath, jan  }\ndan.prefs  = { ivy,  fay,  dee,  gay,  hope, eve,  jan,  bea,  cath, abi  }\ned.prefs   = { jan,  dee,  bea,  cath, fay,  eve,  abi,  ivy,  hope, gay  }\nfred.prefs = { bea,  abi,  dee,  gay,  eve,  ivy,  cath, jan,  hope, fay  }\ngav.prefs  = { gay,  eve,  ivy,  bea,  cath, abi,  dee,  hope, jan,  fay  }\nhal.prefs  = { abi,  eve,  hope, fay,  ivy,  cath, jan,  bea,  gay,  dee  }\nian.prefs  = { hope, cath, dee,  gay,  bea,  abi,  fay,  ivy,  jan,  eve  }\njon.prefs  = { abi,  fay,  jan,  gay,  eve,  bea,  dee,  cath, ivy,  hope }\n\nabi.prefs  = { bob,  fred, jon,  gav,  ian,  abe,  dan,  ed,   col,  hal  }\nbea.prefs  = { bob,  abe,  col,  fred, gav,  dan,  ian,  ed,   jon,  hal  }\ncath.prefs = { fred, bob,  ed,   gav,  hal,  col,  ian,  abe,  dan,  jon  }\ndee.prefs  = { fred, jon,  col,  abe,  ian,  hal,  gav,  dan,  bob,  ed   }\neve.prefs  = { jon,  hal,  fred, dan,  abe,  gav,  col,  ed,   ian,  bob  }\nfay.prefs  = { bob,  abe,  ed,   ian,  jon,  dan,  fred, gav,  col,  hal  }\ngay.prefs  = { jon,  gav,  hal,  fred, bob,  abe,  col,  ed,   dan,  ian  }\nhope.prefs = { gav,  jon,  bob,  abe,  ian,  dan,  hal,  ed,   col,  fred }\nivy.prefs  = { ian,  col,  hal,  gav,  fred, bob,  abe,  ed,   jon,  dan  }\njan.prefs  = { ed,   hal,  gav,  abe,  bob,  jon,  col,  ian,  fred, dan  }\n\nlocal men = abi.prefs\nlocal freeMenCount = #men\nwhile freeMenCount > 0 do\n    for _, guy in pairs(men) do\n        if not guy.fiance then\n            local gal = guy:nextCandidateNotYetProposedTo()\n            if not gal.fiance then\n                guy:engageTo(gal)\n                freeMenCount = freeMenCount - 1\n            elseif gal:prefers(guy) then\n                guy:engageTo(gal)\n            end\n        end\n    end\nend\n\nprint(' ')\nfor _, guy in pairs(men) do\n    print(guy.name .. ' is engaged to ' .. guy.fiance.name)\nend\nprint('Stable: ', isStable(men))\n\nprint(' ')\nprint('Switching ' .. fred.name .. \"'s & \" .. jon.name .. \"'s partners\")\njon.fiance, fred.fiance = fred.fiance, jon.fiance\nprint('Stable: ', isStable(men))\n\n\nOutput:\nBob is engaged to Cath\nFred is engaged to Bea\nJon is engaged to Abi\nGav is engaged to Gay\nIan is engaged to Hope\nAbe is engaged to Ivy\nDan is engaged to Fay\nEd is engaged to Jan\nCol is engaged to Dee\nHal is engaged to Eve\nStable:   true\n\nSwitching Fred's & Jon's partners\nJon and Eve prefer each other over their partners Bea and Hal\nJon and Fay prefer each other over their partners Bea and Dan\nJon and Gay prefer each other over their partners Bea and Gav\nStable:   false\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nTranslation of: Java\nobject SMP extends App {\n    private def checkMarriages(): Unit =\n        if (check)\n            println(\"Marriages are stable\")\n        else\n            println(\"Marriages are unstable\")\n\n    private def swap() {\n        val girl1 = girls.head\n        val girl2 = girls(1)\n        val tmp = girl2 -> matches(girl1)\n        matches += girl1 -> matches(girl2)\n        matches += tmp\n        println(girl1 + \" and \" + girl2 + \" have switched partners\")\n    }\n\n    private type TM = scala.collection.mutable.TreeMap[String, String]\n\n    private def check: Boolean = {\n        if (!girls.toSet.subsetOf(matches.keySet) || !guys.toSet.subsetOf(matches.values.toSet))\n            return false\n\n        val invertedMatches = new TM\n        matches foreach { invertedMatches += _.swap }\n\n        for ((k, v) <- matches) {\n            val shePrefers = girlPrefers(k)\n            val sheLikesBetter = shePrefers.slice(0, shePrefers.indexOf(v))\n            val hePrefers = guyPrefers(v)\n            val heLikesBetter = hePrefers.slice(0, hePrefers.indexOf(k))\n\n            for (guy <- sheLikesBetter) {\n                val fiance = invertedMatches(guy)\n                val guy_p = guyPrefers(guy)\n                if (guy_p.indexOf(fiance) > guy_p.indexOf(k)) {\n                    println(s\"$k likes $guy better than $v and $guy likes $k better than their current partner\")\n                    return false\n                }\n            }\n\n            for (girl <- heLikesBetter) {\n                val fiance = matches(girl)\n                val girl_p = girlPrefers(girl)\n                if (girl_p.indexOf(fiance) > girl_p.indexOf(v)) {\n                    println(s\"$v likes $girl better than $k and $girl likes $v better than their current partner\")\n                    return false\n                }\n            }\n        }\n        true\n    }\n\n    private val guys = \"abe\" :: \"bob\" :: \"col\" :: \"dan\" :: \"ed\" :: \"fred\" :: \"gav\" :: \"hal\" :: \"ian\" :: \"jon\" :: Nil\n    private val girls = \"abi\" :: \"bea\" :: \"cath\" :: \"dee\" :: \"eve\" :: \"fay\" :: \"gay\" :: \"hope\" :: \"ivy\" :: \"jan\" :: Nil\n    private val guyPrefers = Map(\"abe\" -> List(\"abi\", \"eve\", \"cath\", \"ivy\", \"jan\", \"dee\", \"fay\", \"bea\", \"hope\", \"gay\"),\n        \"bob\" -> List(\"cath\", \"hope\", \"abi\", \"dee\", \"eve\", \"fay\", \"bea\", \"jan\", \"ivy\", \"gay\"),\n        \"col\" -> List(\"hope\", \"eve\", \"abi\", \"dee\", \"bea\", \"fay\", \"ivy\", \"gay\", \"cath\", \"jan\"),\n        \"dan\" -> List(\"ivy\", \"fay\", \"dee\", \"gay\", \"hope\", \"eve\", \"jan\", \"bea\", \"cath\", \"abi\"),\n        \"ed\" -> List(\"jan\", \"dee\", \"bea\", \"cath\", \"fay\", \"eve\", \"abi\", \"ivy\", \"hope\", \"gay\"),\n        \"fred\" -> List(\"bea\", \"abi\", \"dee\", \"gay\", \"eve\", \"ivy\", \"cath\", \"jan\", \"hope\", \"fay\"),\n        \"gav\" -> List(\"gay\", \"eve\", \"ivy\", \"bea\", \"cath\", \"abi\", \"dee\", \"hope\", \"jan\", \"fay\"),\n        \"hal\" -> List(\"abi\", \"eve\", \"hope\", \"fay\", \"ivy\", \"cath\", \"jan\", \"bea\", \"gay\", \"dee\"),\n        \"ian\" -> List(\"hope\", \"cath\", \"dee\", \"gay\", \"bea\", \"abi\", \"fay\", \"ivy\", \"jan\", \"eve\"),\n        \"jon\" -> List(\"abi\", \"fay\", \"jan\", \"gay\", \"eve\", \"bea\", \"dee\", \"cath\", \"ivy\", \"hope\"))\n    private val girlPrefers = Map(\"abi\" -> List(\"bob\", \"fred\", \"jon\", \"gav\", \"ian\", \"abe\", \"dan\", \"ed\", \"col\", \"hal\"),\n        \"bea\" -> List(\"bob\", \"abe\", \"col\", \"fred\", \"gav\", \"dan\", \"ian\", \"ed\", \"jon\", \"hal\"),\n        \"cath\" -> List(\"fred\", \"bob\", \"ed\", \"gav\", \"hal\", \"col\", \"ian\", \"abe\", \"dan\", \"jon\"),\n        \"dee\" -> List(\"fred\", \"jon\", \"col\", \"abe\", \"ian\", \"hal\", \"gav\", \"dan\", \"bob\", \"ed\"),\n        \"eve\" -> List(\"jon\", \"hal\", \"fred\", \"dan\", \"abe\", \"gav\", \"col\", \"ed\", \"ian\", \"bob\"),\n        \"fay\" -> List(\"bob\", \"abe\", \"ed\", \"ian\", \"jon\", \"dan\", \"fred\", \"gav\", \"col\", \"hal\"),\n        \"gay\" -> List(\"jon\", \"gav\", \"hal\", \"fred\", \"bob\", \"abe\", \"col\", \"ed\", \"dan\", \"ian\"),\n        \"hope\" -> List(\"gav\", \"jon\", \"bob\", \"abe\", \"ian\", \"dan\", \"hal\", \"ed\", \"col\", \"fred\"),\n        \"ivy\" -> List(\"ian\", \"col\", \"hal\", \"gav\", \"fred\", \"bob\", \"abe\", \"ed\", \"jon\", \"dan\"),\n        \"jan\" -> List(\"ed\", \"hal\", \"gav\", \"abe\", \"bob\", \"jon\", \"col\", \"ian\", \"fred\", \"dan\"))\n    \n    private lazy val matches = {\n        val engagements = new TM\n        val freeGuys = scala.collection.mutable.Queue.empty ++ guys\n        while (freeGuys.nonEmpty) {\n            val guy = freeGuys.dequeue()\n            val guy_p = guyPrefers(guy)\n            var break = false\n            for (girl <- guy_p)\n                if (!break)\n                    if (!engagements.contains(girl)) {\n                        engagements(girl) = guy\n                        break = true\n                    }\n                    else {\n                        val other_guy = engagements(girl)\n                        val girl_p = girlPrefers(girl)\n                        if (girl_p.indexOf(guy) < girl_p.indexOf(other_guy)) {\n                            engagements(girl) = guy\n                            freeGuys += other_guy\n                            break = true\n                        }\n                    }\n        }\n\n        engagements foreach { e => println(s\"${e._1} is engaged to ${e._2}\") }\n        engagements\n    }\n    \n    checkMarriages()\n    swap()\n    checkMarriages()\n}\n\n\nOutput:\n\n", "explain": "See Java output.\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\n\nimport std.stdio, std.array, std.algorithm, std.string;\n\n\nstring[string] matchmaker(string[][string] guyPrefers,\n                          string[][string] girlPrefers) /*@safe*/ {\n    string[string] engagedTo;\n    string[] freeGuys = guyPrefers.keys;\n\n    while (freeGuys.length) {\n        const string thisGuy = freeGuys[0];\n        freeGuys.popFront();\n        const auto thisGuyPrefers = guyPrefers[thisGuy];\n        foreach (girl; thisGuyPrefers) {\n            if (girl !in engagedTo) { // girl is free\n                engagedTo[girl] = thisGuy;\n                break;\n            } else {\n                string otherGuy = engagedTo[girl];\n                string[] thisGirlPrefers = girlPrefers[girl];\n                if (thisGirlPrefers.countUntil(thisGuy) <\n                    thisGirlPrefers.countUntil(otherGuy)) {\n                    // this girl prefers this guy to\n                    // the guy she's engagedTo to.\n                    engagedTo[girl] = thisGuy;\n                    freeGuys ~= otherGuy;\n                    break;\n                }\n                // else no change, keep looking for this guy\n            }\n        }\n    }\n\n    return engagedTo;\n}\n\n\nbool check(bool doPrint=false)(string[string] engagedTo,\n                               string[][string] guyPrefers,\n                               string[][string] galPrefers) @safe {\n    enum MSG = \"%s likes %s better than %s and %s \" ~\n               \"likes %s better than their current partner\";\n    string[string] inverseEngaged;\n    foreach (k, v; engagedTo)\n        inverseEngaged[v] = k;\n\n    foreach (she, he; engagedTo) {\n        auto sheLikes = galPrefers[she];\n        auto sheLikesBetter = sheLikes[0 .. sheLikes.countUntil(he)];\n        auto heLikes = guyPrefers[he];\n        auto heLikesBetter = heLikes[0 .. heLikes.countUntil(she)];\n        foreach (guy; sheLikesBetter) {\n            auto guysGirl = inverseEngaged[guy];\n            auto guyLikes = guyPrefers[guy];\n\n            if (guyLikes.countUntil(guysGirl) >\n                guyLikes.countUntil(she)) {\n                static if (doPrint)\n                    writefln(MSG, she, guy, he, guy, she);\n                return false;\n            }\n        }\n\n        foreach (gal; heLikesBetter) {\n            auto girlsGuy = engagedTo[gal];\n            auto galLikes = galPrefers[gal];\n\n            if (galLikes.countUntil(girlsGuy) >\n                galLikes.countUntil(he)) {\n                static if (doPrint)\n                    writefln(MSG, he, gal, she, gal, he);\n                return false;\n            }\n        }\n    }\n\n    return true;\n}\n\n\nvoid main() /*@safe*/ {\n    auto guyData = \"abe  abi eve cath ivy jan dee fay bea hope gay\n                    bob  cath hope abi dee eve fay bea jan ivy gay\n                    col  hope eve abi dee bea fay ivy gay cath jan\n                    dan  ivy fay dee gay hope eve jan bea cath abi\n                    ed   jan dee bea cath fay eve abi ivy hope gay\n                    fred bea abi dee gay eve ivy cath jan hope fay\n                    gav  gay eve ivy bea cath abi dee hope jan fay\n                    hal  abi eve hope fay ivy cath jan bea gay dee\n                    ian  hope cath dee gay bea abi fay ivy jan eve\n                    jon  abi fay jan gay eve bea dee cath ivy hope\";\n\n    auto galData = \"abi  bob fred jon gav ian abe dan ed col hal\n                    bea  bob abe col fred gav dan ian ed jon hal\n                    cath fred bob ed gav hal col ian abe dan jon\n                    dee  fred jon col abe ian hal gav dan bob ed\n                    eve  jon hal fred dan abe gav col ed ian bob\n                    fay  bob abe ed ian jon dan fred gav col hal\n                    gay  jon gav hal fred bob abe col ed dan ian\n                    hope gav jon bob abe ian dan hal ed col fred\n                    ivy  ian col hal gav fred bob abe ed jon dan\n                    jan  ed hal gav abe bob jon col ian fred dan\";\n\n    string[][string] guyPrefers, galPrefers;\n    foreach (line; guyData.splitLines())\n        guyPrefers[split(line)[0]] = split(line)[1..$];\n    foreach (line; galData.splitLines())\n        galPrefers[split(line)[0]] = split(line)[1..$];\n\n    writeln(\"Engagements:\");\n    auto engagedTo = matchmaker(guyPrefers, galPrefers);\n\n    writeln(\"\\nCouples:\");\n    string[] parts;\n    foreach (k; engagedTo.keys.sort())\n        writefln(\"%s is engagedTo to %s\", k, engagedTo[k]);\n    writeln();\n\n    bool c = check!(true)(engagedTo, guyPrefers, galPrefers);\n    writeln(\"Marriages are \", c ? \"stable\" : \"unstable\");\n\n    writeln(\"\\n\\nSwapping two fiances to introduce an error\");\n    auto gals = galPrefers.keys.sort();\n    swap(engagedTo[gals[0]], engagedTo[gals[1]]);\n    foreach (gal; gals[0 .. 2])\n        writefln(\"  %s is now engagedTo to %s\", gal, engagedTo[gal]);\n    writeln();\n\n    c = check!(true)(engagedTo, guyPrefers, galPrefers);\n    writeln(\"Marriages are \", c ? \"stable\" : \"unstable\");\n}\n\n\nOutput:\nEngagements:\n\nCouples:\nabi is engagedTo to jon\nbea is engagedTo to fred\ncath is engagedTo to bob\ndee is engagedTo to col\neve is engagedTo to hal\nfay is engagedTo to dan\ngay is engagedTo to gav\nhope is engagedTo to ian\nivy is engagedTo to abe\njan is engagedTo to ed\n\nMarriages are stable\n\n\nSwapping two fiances to introduce an error\n  abi is now engagedTo to fred\n  bea is now engagedTo to jon\n\nfred likes bea better than abi and bea likes fred better than their current partner\nMarriages are unstable\nStronger Version[edit]\nimport std.stdio, std.algorithm, std.array;\n\nenum F { abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan }\nenum M { abe, bob, col, dan, ed, fred, gav, hal, ian, jon }\n\nalias PrefMapF = M[][F];\nalias PrefMapM = F[][M];\nalias Couples = M[F];\n\nimmutable PrefMapF womenPref;\nimmutable PrefMapM menPref;\n\nstatic this() pure nothrow @safe {\n    with (F) with (M) {\n        womenPref = [\n             abi:  [bob, fred, jon, gav, ian, abe, dan, ed, col, hal],\n             bea:  [bob, abe, col, fred, gav, dan, ian, ed, jon, hal],\n             cath: [fred, bob, ed, gav, hal, col, ian, abe, dan, jon],\n             dee:  [fred, jon, col, abe, ian, hal, gav, dan, bob, ed],\n             eve:  [jon, hal, fred, dan, abe, gav, col, ed, ian, bob],\n             fay:  [bob, abe, ed, ian, jon, dan, fred, gav, col, hal],\n             gay:  [jon, gav, hal, fred, bob, abe, col, ed, dan, ian],\n             hope: [gav, jon, bob, abe, ian, dan, hal, ed, col, fred],\n             ivy:  [ian, col, hal, gav, fred, bob, abe, ed, jon, dan],\n             jan:  [ed, hal, gav, abe, bob, jon, col, ian, fred, dan]\n        ];\n\n        menPref = [\n             abe:  [abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay],\n             bob:  [cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay],\n             col:  [hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan],\n             dan:  [ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi],\n             ed:   [jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay],\n             fred: [bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay],\n             gav:  [gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay],\n             hal:  [abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee],\n             ian:  [hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve],\n             jon:  [abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope]\n        ];\n    }\n}\n\n/// Does 'first' appear before 'second' in preference list?\nbool prefers(T)(in T[] preference, in T first, in T second)\npure nothrow @safe @nogc if (is(T == F) || is(T == M)) {\n    //const found = preference.findAmong([first, second]);\n    immutable T[2] two = [first, second];\n    const found = preference.findAmong(two[]);\n    return !(found.empty || found.front == second);\n}\n\nvoid checkStability(in Couples engaged, in PrefMapM menPref,\n                    in PrefMapF womenPref) @safe {\n    \"Stablility:\".writeln;\n    bool stable = true;\n    foreach (immutable bride, immutable groom; engaged) {\n        const prefList = menPref[groom];\n\n        foreach (immutable pr; prefList) {\n            if (pr == bride) // He prefers his bride.\n                break;\n\n            if (prefers(prefList, pr, bride) &&\n                // He prefers another woman.\n                prefers(womenPref[pr], groom, engaged[pr])) {\n                // Other woman prefers him.\n                writeln(\"\\t\", pr, \" prefers \", groom, \" over \",\n                        engaged[pr], \" and \", groom, \" prefers \",\n                        pr, \" over \", bride);\n                stable = false;\n            }\n        }\n    }\n\n    if (stable)\n        \"\\t(all marriages stable)\".writeln;\n}\n\nvoid main() /*@safe*/ {\n    auto bachelors = menPref.keys.sort().release;// No queue in Phobos.\n    Couples engaged;\n\n    \"Matchmaking:\".writeln;\n    while (!bachelors.empty) {\n        immutable suitor = bachelors[0];\n        bachelors.popFront;\n        immutable prefList = menPref[suitor];\n\n        foreach (immutable bride; prefList) {\n            if (bride !in engaged) { // She's available.\n                writeln(\"\\t\", bride, \" and \", suitor);\n                engaged[bride] = suitor; // Hook up.\n                break;\n            }\n\n            immutable groom = engaged[bride];\n            if (prefers(womenPref[bride], suitor, groom)) {\n                writeln(\"\\t\", bride, \" dumped \", groom,\n                        \" for \", suitor);\n                bachelors ~= groom; // Dump that zero.\n                engaged[bride] = suitor; // Get a hero.\n                break;\n            }\n        }\n    }\n\n    \"Engagements:\".writeln;\n    foreach (immutable first, immutable second; engaged)\n        writeln(\"\\t\", first, \" and \", second);\n\n    checkStability(engaged, menPref, womenPref);\n\n    \"Perturb:\".writeln;\n    engaged[F.abi].swap(engaged[F.bea]);\n    writeln(\"\\tengage abi with \", engaged[F.abi],\n            \" and bea with \", engaged[F.bea]);\n\n    checkStability(engaged, menPref, womenPref);\n}\n\n\nOutput:\nMatchmaking:\n    abi and abe\n    cath and bob\n    hope and col\n    ivy and dan\n    jan and ed\n    bea and fred\n    gay and gav\n    eve and hal\n    hope dumped col for ian\n    abi dumped abe for jon\n    dee and col\n    ivy dumped dan for abe\n    fay and dan\nEngagements:\n    abi and jon\n    ivy and abe\n    eve and hal\n    jan and ed\n    bea and fred\n    fay and dan\n    cath and bob\n    gay and gav\n    hope and ian\n    dee and col\nStablility:\n    (all marriages stable)\nPerturb:\n    engage abi with fred and bea with jon\nStablility:\n    bea prefers fred over jon and fred prefers bea over abi\n    fay prefers jon over dan and jon prefers fay over bea\n    gay prefers jon over gav and jon prefers gay over bea\n    eve prefers jon over hal and jon prefers eve over bea\n", "explain": "From the Python and Java versions:\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nThe solution[edit]\n\n{-# LANGUAGE TemplateHaskell #-}\nimport Lens.Micro\nimport Lens.Micro.TH\nimport Data.List (union, delete)\n\ntype Preferences a = (a, [a])\ntype Couple a = (a,a)\ndata State a = State { _freeGuys :: [a]\n                     , _guys :: [Preferences a]\n                     , _girls :: [Preferences a]}\n\nmakeLenses ''State\n\n\nname n = lens get set\n  where get = head . dropWhile ((/= n).fst)\n        set assoc (_,v) = let (prev, _:post) = break ((== n).fst) assoc\n                      in prev ++ (n, v):post\n\nfianceesOf n = guys.name n._2\nfiancesOf n = girls.name n._2\n\n\n ^.  -- access to a field\n\u00a0%~  -- modification of a field\n .~  -- setting a field the value\n\n\nstableMatching :: Eq a => State a -> [Couple a]\nstableMatching = getPairs . until (null._freeGuys) step\n  where\n    getPairs s = map (_2 %~ head) $ s^.guys \n\nstep :: Eq a => State a -> State a\nstep s = foldl propose s (s^.freeGuys)\n  where\n    propose s guy =\n      let girl                = s^.fianceesOf guy & head\n          bestGuy : otherGuys = s^.fiancesOf girl\n          modify\n            | guy == bestGuy       = freeGuys %~ delete guy\n            | guy `elem` otherGuys = (fiancesOf girl %~ dropWhile (/= guy)) .\n                                     (freeGuys %~ guy `replaceBy` bestGuy)\n            | otherwise            = fianceesOf guy %~ tail\n      in modify s\n\n    replaceBy x y [] = []\n    replaceBy x y (h:t) | h == x = y:t\n                        | otherwise = h:replaceBy x y t\n\nunstablePairs :: Eq a => State a -> [Couple a] -> [(Couple a, Couple a)]\nunstablePairs s pairs =\n  [ ((m1, w1), (m2,w2)) | (m1, w1) <- pairs\n                        , (m2,w2) <- pairs\n                        , m1 /= m2\n                        , let fm = s^.fianceesOf m1\n                        , elemIndex w2 fm < elemIndex w1 fm\n                        , let fw = s^.fiancesOf w2\n                        , elemIndex m2 fw < elemIndex m1 fw ]\n\n\nThe task[edit]\n\nguys0 =\n  [(\"abe\", [\"abi\", \"eve\", \"cath\", \"ivy\", \"jan\", \"dee\", \"fay\", \"bea\", \"hope\", \"gay\"]),\n   (\"bob\", [\"cath\", \"hope\", \"abi\", \"dee\", \"eve\", \"fay\", \"bea\", \"jan\", \"ivy\", \"gay\"]),\n   (\"col\", [\"hope\", \"eve\", \"abi\", \"dee\", \"bea\", \"fay\", \"ivy\", \"gay\", \"cath\", \"jan\"]),\n   (\"dan\", [\"ivy\", \"fay\", \"dee\", \"gay\", \"hope\", \"eve\", \"jan\", \"bea\", \"cath\", \"abi\"]),\n   (\"ed\",  [\"jan\", \"dee\", \"bea\", \"cath\", \"fay\", \"eve\", \"abi\", \"ivy\", \"hope\", \"gay\"]),\n   (\"fred\",[\"bea\", \"abi\", \"dee\", \"gay\", \"eve\", \"ivy\", \"cath\", \"jan\", \"hope\", \"fay\"]),\n   (\"gav\", [\"gay\", \"eve\", \"ivy\", \"bea\", \"cath\", \"abi\", \"dee\", \"hope\", \"jan\", \"fay\"]),\n   (\"hal\", [\"abi\", \"eve\", \"hope\", \"fay\", \"ivy\", \"cath\", \"jan\", \"bea\", \"gay\", \"dee\"]),\n   (\"ian\", [\"hope\", \"cath\", \"dee\", \"gay\", \"bea\", \"abi\", \"fay\", \"ivy\", \"jan\", \"eve\"]),\n   (\"jon\", [\"abi\", \"fay\", \"jan\", \"gay\", \"eve\", \"bea\", \"dee\", \"cath\", \"ivy\", \"hope\"])]\n  \ngirls0 = \n  [(\"abi\",  [\"bob\", \"fred\", \"jon\", \"gav\", \"ian\", \"abe\", \"dan\", \"ed\", \"col\", \"hal\"]),\n   (\"bea\",  [\"bob\", \"abe\", \"col\", \"fred\", \"gav\", \"dan\", \"ian\", \"ed\", \"jon\", \"hal\"]),\n   (\"cath\", [\"fred\", \"bob\", \"ed\", \"gav\", \"hal\", \"col\", \"ian\", \"abe\", \"dan\", \"jon\"]),\n   (\"dee\",  [\"fred\", \"jon\", \"col\", \"abe\", \"ian\", \"hal\", \"gav\", \"dan\", \"bob\", \"ed\"]),\n   (\"eve\",  [\"jon\", \"hal\", \"fred\", \"dan\", \"abe\", \"gav\", \"col\", \"ed\", \"ian\", \"bob\"]),\n   (\"fay\",  [\"bob\", \"abe\", \"ed\", \"ian\", \"jon\", \"dan\", \"fred\", \"gav\", \"col\", \"hal\"]),\n   (\"gay\",  [\"jon\", \"gav\", \"hal\", \"fred\", \"bob\", \"abe\", \"col\", \"ed\", \"dan\", \"ian\"]),\n   (\"hope\", [\"gav\", \"jon\", \"bob\", \"abe\", \"ian\", \"dan\", \"hal\", \"ed\", \"col\", \"fred\"]),\n   (\"ivy\",  [\"ian\", \"col\", \"hal\", \"gav\", \"fred\", \"bob\", \"abe\", \"ed\", \"jon\", \"dan\"]),\n   (\"jan\",  [\"ed\", \"hal\", \"gav\", \"abe\", \"bob\", \"jon\", \"col\", \"ian\", \"fred\", \"dan\"])]\n\n\ns0 = State (fst <$> guys0) guys0 ((_2 %~ reverse) <$> girls0)\n\n\n\u03bb> let pairs = stableMatching s0\n\u03bb> mapM_ print pairs\n(\"abe\",\"ivy\")\n(\"bob\",\"cath\")\n(\"col\",\"dee\")\n(\"dan\",\"fay\")\n(\"ed\",\"jan\")\n(\"fred\",\"bea\")\n(\"gav\",\"gay\")\n(\"hal\",\"eve\")\n(\"ian\",\"hope\")\n(\"jon\",\"abi\")\n\u03bb> unstablePairs s0 pairs\n[]\n\n\u03bb> let fiance n = name n._2\n\u03bb> let pairs' = pairs & (fiance \"abe\" .~ \"cath\") & (fiance \"bob\" .~ \"ivy\")\n\u03bb> mapM_ print $ unstablePairs s0 pairs'\n((\"bob\",\"ivy\"),(\"abe\",\"cath\"))\n((\"bob\",\"ivy\"),(\"dan\",\"fay\"))\n((\"bob\",\"ivy\"),(\"fred\",\"bea\"))\n((\"bob\",\"ivy\"),(\"ian\",\"hope\"))\n((\"bob\",\"ivy\"),(\"jon\",\"abi\"))\n", "explain": "The Gale/Shapley algorithm is formulated via iterative changing of the state. In Haskell it is possible to implement this approach by pure function iterations.\nThe state here consists of the list of free guys and associative preferences lists for guys and girls correspondingly. In order to simplify the access to elements of the state we use lenses.\nLenses allow us to get access to each person in the state, and even to the associated preference list:\nNote that in following we use lens operators:\nFurther we use a trick: guys list girls in a descending order of preference (the most liked is the first), while girls expect guys in opposite order -- the most liked is the last. In any case, we assume that the current best choice for guys and for girls is expected to appear on the top of their preference lists.\nWith these tools and notes we are ready to implement the Gale/Shapley algorithm and the stability test as they are given in a textbook:\nThis solution works not only for strings, but for any equable data.\nHere are the given preferences:\nThe initial state:\nAnd the solution:\nLets' make some perturbations: swap fiancees of abe and bob:\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nusing namespace System.Collections.Generic\n$ErrorActionPreference = 'Stop'\nclass Person{\n    #private\n    hidden [int] $_candidateIndex;\n    [string] $Name\n    #[System.Collections.Generic.List[Person]] $Prefs\n    [List[Person]] $Prefs\n    [Person] $Fiance\n    \n    Person([string] $name) {\n            $this.Name = $name;\n            $this.Prefs = $null;\n            $this.Fiance = $null;\n            $this._candidateIndex = 0;\n        }\n    [bool] Prefers([Person] $p) {\n            return $this.Prefs.FindIndex({ param($o) $o -eq $p }) -lt $this.Prefs.FindIndex({ param($o) $o -eq $this.Fiance });\n        }\n    \n    [Person] NextCandidateNotYetProposedTo() {\n            if ($this._candidateIndex -ge $this.Prefs.Count) {return $null;}\n            return $this.Prefs[$this._candidateIndex++];\n        }\n    \n    [void] EngageTo([Person] $p) {\n            if ($p.Fiance -ne $null) {$p.Fiance.Fiance = $null};\n            $p.Fiance = $this;\n            if ($this.Fiance -ne $null){$this.Fiance.Fiance = $null};\n            $this.Fiance = $p;\n        }\n\n    \n    }\n\n\n    class MainClass\n    {\n        static  [bool] IsStable([List[Person]] $men) {\n            [List[Person]] $women = $men[0].Prefs;\n            foreach ($guy in $men){ \n                foreach ($gal in $women) {\n                    if ($guy.Prefers($gal) -and $gal.Prefers($guy))\n                        {return $false};\n                }\n            }\n            return $true;\n        }\n\n        static [void] DoMarriage() {\n            [Person] $abe  = [Person]::new(\"abe\");\n            [Person] $bob  = [Person]::new(\"bob\");\n            [Person] $col  = [Person]::new(\"col\");\n            [Person] $dan  = [Person]::new(\"dan\");\n            [Person] $ed   = [Person]::new(\"ed\");\n            [Person] $fred = [Person]::new(\"fred\");\n            [Person] $gav  = [Person]::new(\"gav\");\n            [Person] $hal  = [Person]::new(\"hal\");\n            [Person] $ian  = [Person]::new(\"ian\");\n            [Person] $jon  = [Person]::new(\"jon\");\n            [Person] $abi  = [Person]::new(\"abi\");\n            [Person] $bea  = [Person]::new(\"bea\");\n            [Person] $cath = [Person]::new(\"cath\");\n            [Person] $dee  = [Person]::new(\"dee\");\n            [Person] $eve  = [Person]::new(\"eve\");\n            [Person] $fay  = [Person]::new(\"fay\");\n            [Person] $gay  = [Person]::new(\"gay\");\n            [Person] $hope = [Person]::new(\"hope\");\n            [Person] $ivy  = [Person]::new(\"ivy\");\n            [Person] $jan  = [Person]::new(\"jan\");\n\n            $abe.Prefs =[Person[]]@($abi, $eve, $cath, $ivy, $jan, $dee, $fay, $bea, $hope, $gay)\n            $bob.Prefs  = [Person[]] @($cath, $hope, $abi, $dee, $eve, $fay, $bea, $jan, $ivy, $gay);\n            $col.Prefs  = [Person[]] @($hope, $eve, $abi, $dee, $bea, $fay, $ivy, $gay, $cath, $jan);\n            $dan.Prefs  = [Person[]] @($ivy, $fay, $dee, $gay, $hope, $eve, $jan, $bea, $cath, $abi);\n            $ed.Prefs   = [Person[]] @($jan, $dee, $bea, $cath, $fay, $eve, $abi, $ivy, $hope, $gay);\n            $fred.Prefs = [Person[]] @($bea, $abi, $dee, $gay, $eve, $ivy, $cath, $jan, $hope, $fay);\n            $gav.Prefs  = [Person[]] @($gay, $eve, $ivy, $bea, $cath, $abi, $dee, $hope, $jan, $fay);\n            $hal.Prefs  = [Person[]] @($abi, $eve, $hope, $fay, $ivy, $cath, $jan, $bea, $gay, $dee);\n            $ian.Prefs  = [Person[]] @($hope, $cath, $dee, $gay, $bea, $abi, $fay, $ivy, $jan, $eve);\n            $jon.Prefs  = [Person[]] @($abi, $fay, $jan, $gay, $eve, $bea, $dee, $cath, $ivy, $hope);\n            $abi.Prefs  = [Person[]] @($bob, $fred, $jon, $gav, $ian, $abe, $dan, $ed, $col, $hal);\n            $bea.Prefs  = [Person[]] @($bob, $abe, $col, $fred, $gav, $dan, $ian, $ed, $jon, $hal);\n            $cath.Prefs = [Person[]] @($fred, $bob, $ed, $gav, $hal, $col, $ian, $abe, $dan, $jon);\n            $dee.Prefs  = [Person[]] @($fred, $jon, $col, $abe, $ian, $hal, $gav, $dan, $bob, $ed);\n            $eve.Prefs  = [Person[]] @($jon, $hal, $fred, $dan, $abe, $gav, $col, $ed, $ian, $bob);\n            $fay.Prefs  = [Person[]] @($bob, $abe, $ed, $ian, $jon, $dan, $fred, $gav, $col, $hal);\n            $gay.Prefs  = [Person[]] @($jon, $gav, $hal, $fred, $bob, $abe, $col, $ed, $dan, $ian);\n            $hope.Prefs = [Person[]] @($gav, $jon, $bob, $abe, $ian, $dan, $hal, $ed, $col, $fred);\n            $ivy.Prefs  = [Person[]] @($ian, $col, $hal, $gav, $fred, $bob, $abe, $ed, $jon, $dan);\n            $jan.Prefs  = [Person[]] @($ed, $hal, $gav, $abe, $bob, $jon, $col, $ian, $fred, $dan);\n\n            [List[Person]] $men = [List[Person]]::new($abi.Prefs);\n\n            [int] $freeMenCount = $men.Count;\n            while ($freeMenCount -gt 0) {\n                foreach ($guy in $men) {\n                    if ($guy.Fiance -eq $null) {\n                        [Person]$gal = $guy.NextCandidateNotYetProposedTo();\n                        if ($gal.Fiance -eq $null) {\n                            $guy.EngageTo($gal);\n                            $freeMenCount--;\n                        }\n                        else{\n                            if ($gal.Prefers($guy)) {\n                                $guy.EngageTo($gal);\n                            }\n                        }\n                        \n                    }\n                }\n            }\n\n            foreach ($guy in $men) {\n                write-host $guy.Name \" is engaged to \" $guy.Fiance.Name\n               \n            }\n            write-host \"Stable = \" ([MainClass]::IsStable($men))\n            \n            write-host \"Switching fred & jon's partners\";\n            [Person] $jonsFiance = $jon.Fiance;\n            [Person] $fredsFiance = $fred.Fiance;\n            $fred.EngageTo($jonsFiance);\n            $jon.EngageTo($fredsFiance);\n            write-host \"Stable = \" ([MainClass]::IsStable($men));\n\n        }\n     static [void] Main([string[]] $args)\n        {\n            [MainClass]::DoMarriage();\n        }\n\n\n    }\n\n[MainClass]::DoMarriage()\n\n\nOutput:\n \nbob  is engaged to  cath\nfred  is engaged to  bea\njon  is engaged to  abi\ngav  is engaged to  gay\nian  is engaged to  hope\nabe  is engaged to  ivy\ndan  is engaged to  fay\ned  is engaged to  jan\ncol  is engaged to  dee\nhal  is engaged to  eve\nStable =  True\nSwitching fred & jon's partners\nStable =  False\n\n\n", "explain": "\n"}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "ColdFusion", "code": "\nPERSON.CFC\n\ncomponent displayName=\"Person\" accessors=\"true\" {\n    property name=\"Name\" type=\"string\";\n    property name=\"MrOrMrsGoodEnough\" type=\"Person\";\n    property name=\"UnrealisticExpectations\" type=\"array\";\n    property name=\"PersonalHistory\" type=\"array\";\n\n    public Person function init( required String name ) {\n        setName( arguments.name );\n        setPersonalHistory([ getName() & \" is on the market.\" ]);\n        this.HotnessScale = 0;\n        return this;\n    }\n\n    public Boolean function hasSettled() {\n        // if we have settled, return true;\n        return isInstanceOf( getMrOrMrsGoodEnough(), \"Person\" );\n    }\n\n    public Person function getBestOfWhatIsLeft() {\n        // increment the hotness scale...1 is best, 10 is...well...VERY settling.\n        this.HotnessScale++;\n        // get the match from the current rung in the barrel\n        var bestChoice = getUnrealisticExpectations()[ this.HotnessScale ];\n        return bestChoice;\n    }\n\n    public Boolean function wouldRatherBeWith( required Person person ) {\n        // only compare if we've already settled on a potential mate\n        if( isInstanceOf( this.getMrOrMrsGoodEnough(), \"Person\" ) ) {\n            // if the new person's hotness is greater (numerically smaller) than our current beau...\n            return getHotness( this, arguments.person ) < getHotness( this, this.getMrOrMrsGoodEnough() );\n        }\n        return false; \n    }\n\n    public Void function settle( required Person person ) {\n        if( person.hasSettled() ) {\n            // this is the match we want. Force a break up of a previous relationship (sorry!)\n            dumpLikeATonOfBricks( person );\n        }\n        person.setMrOrMrsGoodEnough( this );\n        if( hasSettled() ) {\n            // this is the match we want, so write a dear john to our current match\n            dumpLikeATonOfBricks( this );\n        }\n        logHookup( arguments.person );\n        // we've found the mate of our dreams!\n        setMrOrMrsGoodEnough( arguments.person );\n    }\n\n    public Void function swing( required Person person ) {\n        // get our spouses\n        var mySpouse = getMrOrMrsGoodEnough();\n        var notMySpouse = arguments.person.getMrOrMrsGoodEnough();\n        // swap em'\n        setMrOrMrsGoodEnough( notMySpouse );\n        person.setMrOrMrsGoodEnough( mySpouse );\n    }\n\n    public Void function dumpLikeATonOfBricks( required Person person ) {\n        logBreakup( arguments.person );\n        person.getMrOrMrsGoodEnough().setMrOrMrsGoodEnough( JavaCast( \"null\", \"\" ) );\n    }\n\n    public String function psychoAnalyze() {\n        logNuptuals();\n        logRegrets();\n        var personalJourney = \"\";\n        for( var entry in getPersonalHistory() ) {\n            personalJourney = personalJourney & entry & \"<br />\";\n        }\n        return personalJourney;\n    }\n\n    private Numeric function getHotness( required Person pursuer, required Person pursued ) {\n        var pursuersExpectations = pursuer.getUnrealisticExpectations();\n        var hotnessFactor = 1;\n        for( var hotnessFactor=1; hotnessFactor<=arrayLen( pursuersExpectations ); hotnessFactor++ ) {\n            if( pursuersExpectations[ hotnessFactor ].getName()==arguments.pursued.getName() ) {\n                return hotnessFactor;\n            }\n        }\n    }\n\n    private Void function logRegrets() {\n        var spouse = getMrOrMrsGoodEnough();\n        var spouseHotness = getHotness( this, spouse );\n        var myHotness = getHotness( spouse, this );\n        if( spouseHotness == 1 && myHotness == 1 ) {\n            arrayAppend( getPersonalHistory(), \"Yes, yes, the beautiful people always find happy endings: #getName()# (her ###myHotness#), #spouse.getName()# (his ###spouseHotness#)\");\n        }\n        else if( spouseHotness == myHotness ) {\n            arrayAppend( getPersonalHistory(), \"#getName()# (her ###myHotness#) was made for #spouse.getName()# (his ###spouseHotness#). How precious.\");\n        }\n        else if( spouseHotness > myHotness ) {\n            arrayAppend( getPersonalHistory(), \"#getName()# (her ###myHotness#) could have done better than #spouse.getName()# (his ###spouseHotness#). Poor slob.\");\n        }\n        else {\n            arrayAppend( getPersonalHistory(), \"#getName()# (her ###myHotness#) is a lucky bastard to have landed #spouse.getName()# (his ###spouseHotness#).\");\n        }\n    }\n\n    private Void function logNuptuals() {\n        arrayAppend( getPersonalHistory(), \"#getName()# has settled for #getMrOrMrsGoodEnough().getName()#.\" );\n    }\n\n    private Void function logHookup( required Person person ) {\n        var winnerHotness = getHotness( this, arguments.person );\n        var myHotness = getHotness( arguments.person, this );\n        arrayAppend( getPersonalHistory(), \"#getName()# (her ###myHotness#) is checking out #arguments.person.getName()# (his ###winnerHotness#), but wants to keep his options open.\");\n    }\n\n    private Void function logBreakup( required Person person ) {\n        var scrub = person.getMrOrMrsGoodEnough();\n        var scrubHotness = getHotness( person, scrub );\n        var myHotness = getHotness( person, this );\n        arrayAppend( getPersonalHistory(), \"#getName()# is so hot (her ###myHotness#) that #person.getName()# is dumping #scrub.getName()# (her ###scrubHotness#)\");\n    }\n}\n\nINDEX.CFM\n\n<cfscript>\n    /**\n     * Let's get these crazy kids married!\n     * @men.hint The men who want to get married\n     */\n    function doCreepyMassMarriages( required Array men ) {\n        marriagesAreStable = false;\n        while( !marriagesAreStable ) {\n            marriagesAreStable = true;\n            for( man in men ) {\n                if( !man.hasSettled() ) {\n                    marriagesAreStable = false;\n                    sexyLady = man.getBestOfWhatIsLeft();\n                    if( !sexyLady.hasSettled() || sexyLady.wouldRatherBeWith( man ) ) {\n                        man.settle( sexyLady );\n                    }\n                }\n            }\n        }\n        return men;\n    }\n\n    /**\n     * We played God...now let's see if society is going to survive\n     * @men.hint The married men\n     * @women.hint The married women\n     */\n    function isSocietyStable( required Array men, required Array women ) {\n        // loop over married men\n        for( var man in arguments.men ) {\n            // loop over married women\n            for( var woman in arguments.women ) {\n                // if the man does not prefer this woman to his current spouse, and the women\n                // doesn't prefer the man to her current spouse, this is the best possible match\n                if( man.wouldRatherBeWith( woman ) && woman.wouldRatherBeWith( man ) ) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    // the men\n    abe = new Person( \"Abe\" );\n    bob = new Person( \"Bob\" );\n    col = new Person( \"Col\" );\n    dan = new Person( \"Dan\" );\n    ed = new Person( \"Ed\" );\n    fred = new Person( \"Fred\" );\n    gav = new Person( \"Gav\" );\n    hal = new Person( \"Hal\" );\n    ian = new Person( \"Ian\" );\n    jon = new Person( \"Jon\" );\n\n    men = [ abe, bob, col, dan, ed, fred, gav, hal, ian, jon ];\n\n    // the women\n    abi = new Person( \"Abi\" );\n    bea = new Person( \"Bea\" );\n    cath = new Person( \"Cath\" );\n    dee = new Person( \"Dee\" );\n    eve = new Person( \"Eve\" );\n    fay = new Person( \"Fay\" );\n    gay = new Person( \"Gay\" );\n    hope = new Person( \"Hope\" );\n    ivy = new Person( \"Ivy\" );\n    jan = new Person( \"Jan\" );\n\n    women = [ abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan ];\n\n    // set unrealistic expectations for the men\n    abe.setUnrealisticExpectations([ abi, eve, cath, ivy, jan, dee, fay, bea, hope, gay ]);\n    bob.setUnrealisticExpectations([ cath, hope, abi, dee, eve, fay, bea, jan, ivy, gay ]);\n    col.setUnrealisticExpectations([ hope, eve, abi, dee, bea, fay, ivy, gay, cath, jan ]);\n    dan.setUnrealisticExpectations([ ivy, fay, dee, gay, hope, eve, jan, bea, cath, abi ]);\n    ed.setUnrealisticExpectations([ jan, dee, bea, cath, fay, eve, abi, ivy, hope, gay ]);\n    fred.setUnrealisticExpectations([ bea, abi, dee, gay, eve, ivy, cath, jan, hope, fay ]);\n    gav.setUnrealisticExpectations([ gay, eve, ivy, bea, cath, abi, dee, hope, jan, fay ]);\n    hal.setUnrealisticExpectations([ abi, eve, hope, fay, ivy, cath, jan, bea, gay, dee ]);\n    ian.setUnrealisticExpectations([ hope, cath, dee, gay, bea, abi, fay, ivy, jan, eve ]);\n    jon.setUnrealisticExpectations([ abi, fay, jan, gay, eve, bea, dee, cath, ivy, hope ]);\n    // set unrealistic expectations for the women\n    abi.setUnrealisticExpectations([ bob, fred, jon, gav, ian, abe, dan, ed, col, hal ]);\n    bea.setUnrealisticExpectations([ bob, abe, col, fred, gav, dan, ian, ed, jon, hal ]);\n    cath.setUnrealisticExpectations([ fred, bob, ed, gav, hal, col, ian, abe, dan, jon ]);\n    dee.setUnrealisticExpectations([ fred, jon, col, abe, ian, hal, gav, dan, bob, ed ]);\n    eve.setUnrealisticExpectations([ jon, hal, fred, dan, abe, gav, col, ed, ian, bob ]);\n    fay.setUnrealisticExpectations([ bob, abe, ed, ian, jon, dan, fred, gav, col, hal ]);\n    gay.setUnrealisticExpectations([ jon, gav, hal, fred, bob, abe, col, ed, dan, ian ]);\n    hope.setUnrealisticExpectations([ gav, jon, bob, abe, ian, dan, hal, ed, col, fred ]);\n    ivy.setUnrealisticExpectations([ ian, col, hal, gav, fred, bob, abe, ed, jon, dan ]);\n    jan.setUnrealisticExpectations([ ed, hal, gav, abe, bob, jon, col, ian, fred, dan ]);\n\n    // here comes the bride, duhn, duhn, duh-duhn\n    possiblyHappilyMarriedMen = doCreepyMassMarriages( men );\n    // let's see who shacked up!\n    for( man in possiblyHappilyMarriedMen ) {\n        writeoutput( man.psychoAnalyze() & \"<br />\" );\n    }\n    // check if society is stable\n    if( isSocietyStable( men, women ) ) {\n        writeoutput( \"Hey, look at that. Creepy social engineering works. Sort of...<br /><br />\" );\n    }\n    // what happens if couples start swingin'?\n    jon.swing( fred );\n    writeoutput( \"Swapping Jon and Fred's wives...will society survive?<br /><br />\" );\n    // check if society is still stable after the swingers\n    if( !isSocietyStable( men, women ) ) {\n        writeoutput( \"Nope, now everything is broken. Sharing spouses doesn't work, kids.<br />\" );\n    }\n</cfscript>\n\n\nOutput:\nAbe is on the market.\nAbe (her #6) is checking out Abi (his #1), but wants to keep his options open.\nAbe (her #5) is checking out Eve (his #2), but wants to keep his options open.\nAbe is so hot (her #7) that Ivy is dumping Dan (her #10)\nAbe (her #7) is checking out Ivy (his #4), but wants to keep his options open.\nAbe has settled for Ivy.\nAbe (her #7) is lucky to have landed Ivy (his #4).\n\nBob is on the market.\nBob (her #2) is checking out Cath (his #1), but wants to keep his options open.\nBob has settled for Cath.\nBob (her #2) is lucky to have landed Cath (his #1).\n\nCol is on the market.\nCol (her #9) is checking out Hope (his #1), but wants to keep his options open.\nCol (her #3) is checking out Dee (his #4), but wants to keep his options open.\nCol has settled for Dee.\nCol (her #3) could have done better than Dee (his #4).\n\nDan is on the market.\nDan (her #10) is checking out Ivy (his #1), but wants to keep his options open.\nDan (her #6) is checking out Fay (his #2), but wants to keep his options open.\nDan has settled for Fay.\nDan (her #6) is lucky to have landed Fay (his #2).\n\nEd is on the market.\nEd (her #1) is checking out Jan (his #1), but wants to keep his options open.\nEd has settled for Jan.\nYes, yes, the beautiful people always find happy endings: Ed (her #1), Jan (his #1)\n\nFred is on the market.\nFred (her #4) is checking out Bea (his #1), but wants to keep his options open.\nFred has settled for Bea.\nFred (her #4) is lucky to have landed Bea (his #1).\n\nGav is on the market.\nGav (her #2) is checking out Gay (his #1), but wants to keep his options open.\nGav has settled for Gay.\nGav (her #2) is lucky to have landed Gay (his #1).\n\nHal is on the market.\nHal is so hot (her #2) that Eve is dumping Abe (her #5)\nHal (her #2) is checking out Eve (his #2), but wants to keep his options open.\nHal has settled for Eve.\nHal (her #2) was made for Eve (his #2). How precious.\n\nIan is on the market.\nIan is so hot (her #5) that Hope is dumping Col (her #9)\nIan (her #5) is checking out Hope (his #1), but wants to keep his options open.\nIan has settled for Hope.\nIan (her #5) is lucky to have landed Hope (his #1).\n\nJon is on the market.\nJon is so hot (her #3) that Abi is dumping Abe (her #6)\nJon (her #3) is checking out Abi (his #1), but wants to keep his options open.\nJon has settled for Abi.\nJon (her #3) is lucky to have landed Abi (his #1).\n// Is society stable?\nHey, look at that. Creepy social engineering works. Sort of...\n\nSwapping Jon and Fred's wives...will society survive?\n// How about now? Still stable?\nNope, now everything is broken. Sharing spouses doesn't work, kids.\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nlet menPrefs =\n  Map.ofList\n            [\"abe\",  [\"abi\";\"eve\";\"cath\";\"ivy\";\"jan\";\"dee\";\"fay\";\"bea\";\"hope\";\"gay\"];\n             \"bob\",  [\"cath\";\"hope\";\"abi\";\"dee\";\"eve\";\"fay\";\"bea\";\"jan\";\"ivy\";\"gay\"];\n             \"col\",  [\"hope\";\"eve\";\"abi\";\"dee\";\"bea\";\"fay\";\"ivy\";\"gay\";\"cath\";\"jan\"];\n             \"dan\",  [\"ivy\";\"fay\";\"dee\";\"gay\";\"hope\";\"eve\";\"jan\";\"bea\";\"cath\";\"abi\"];\n             \"ed\",   [\"jan\";\"dee\";\"bea\";\"cath\";\"fay\";\"eve\";\"abi\";\"ivy\";\"hope\";\"gay\"];\n             \"fred\", [\"bea\";\"abi\";\"dee\";\"gay\";\"eve\";\"ivy\";\"cath\";\"jan\";\"hope\";\"fay\"];\n             \"gav\",  [\"gay\";\"eve\";\"ivy\";\"bea\";\"cath\";\"abi\";\"dee\";\"hope\";\"jan\";\"fay\"];\n             \"hal\",  [\"abi\";\"eve\";\"hope\";\"fay\";\"ivy\";\"cath\";\"jan\";\"bea\";\"gay\";\"dee\"];\n             \"ian\",  [\"hope\";\"cath\";\"dee\";\"gay\";\"bea\";\"abi\";\"fay\";\"ivy\";\"jan\";\"eve\"];\n             \"jon\",  [\"abi\";\"fay\";\"jan\";\"gay\";\"eve\";\"bea\";\"dee\";\"cath\";\"ivy\";\"hope\"];\n            ]\n\nlet womenPrefs =\n   Map.ofList\n              [\"abi\",  [\"bob\";\"fred\";\"jon\";\"gav\";\"ian\";\"abe\";\"dan\";\"ed\";\"col\";\"hal\"];\n               \"bea\",  [\"bob\";\"abe\";\"col\";\"fred\";\"gav\";\"dan\";\"ian\";\"ed\";\"jon\";\"hal\"];\n               \"cath\", [\"fred\";\"bob\";\"ed\";\"gav\";\"hal\";\"col\";\"ian\";\"abe\";\"dan\";\"jon\"];\n               \"dee\",  [\"fred\";\"jon\";\"col\";\"abe\";\"ian\";\"hal\";\"gav\";\"dan\";\"bob\";\"ed\"];\n               \"eve\",  [\"jon\";\"hal\";\"fred\";\"dan\";\"abe\";\"gav\";\"col\";\"ed\";\"ian\";\"bob\"];\n               \"fay\",  [\"bob\";\"abe\";\"ed\";\"ian\";\"jon\";\"dan\";\"fred\";\"gav\";\"col\";\"hal\"];\n               \"gay\",  [\"jon\";\"gav\";\"hal\";\"fred\";\"bob\";\"abe\";\"col\";\"ed\";\"dan\";\"ian\"];\n               \"hope\", [\"gav\";\"jon\";\"bob\";\"abe\";\"ian\";\"dan\";\"hal\";\"ed\";\"col\";\"fred\"];\n               \"ivy\",  [\"ian\";\"col\";\"hal\";\"gav\";\"fred\";\"bob\";\"abe\";\"ed\";\"jon\";\"dan\"];\n               \"jan\",  [\"ed\";\"hal\";\"gav\";\"abe\";\"bob\";\"jon\";\"col\";\"ian\";\"fred\";\"dan\"];\n              ]\n\nlet men = menPrefs |> Map.toList |> List.map fst |> List.sort\nlet women = womenPrefs |> Map.toList |> List.map fst |> List.sort\n\n\ntype Configuration =\n {\n   proposed: Map<string,string list>; // man -> list of women\n   wifeOf: Map<string, string>; // man -> woman\n   husbandOf: Map<string, string>;  // woman -> man\n }\n\n\n// query functions\n\nlet isFreeMan config man = config.wifeOf.TryFind man = None\n\nlet isFreeWoman config woman = config.husbandOf.TryFind woman = None\n\nlet hasProposedTo config man woman =\n  defaultArg (config.proposed.TryFind(man)) []\n  |> List.exists ((=) woman)\n\n// helper\nlet negate f = fun x -> not (f x)\n\n// returns those 'women' who 'man' has not proposed to before\nlet notProposedBy config man women = List.filter (negate (hasProposedTo config man)) women\n \nlet prefers (prefs:Map<string,string list>) w m1 m2 =\n  let order = prefs.[w]\n  let m1i = List.findIndex ((=) m1) order\n  let m2i = List.findIndex ((=) m2) order\n  m1i < m2i\n\nlet womanPrefers = prefers womenPrefs\nlet manPrefers = prefers menPrefs\n\n// returns the women that m likes better than his current fianc\u00e9e\nlet preferredWomen config m =\n  let w = config.wifeOf.[m]\n  women\n  |> List.filter (fun w' -> manPrefers m w' w)  // '\n\n// whether there is a woman who m likes better than his current fianc\u00e9e\n// and who also likes him better than her current fianc\u00e9\nlet prefersAWomanWhoAlsoPrefersHim config m =\n  preferredWomen config m\n  |> List.exists (fun w -> womanPrefers w m config.husbandOf.[w])\n\nlet isStable config =\n  not (List.exists (prefersAWomanWhoAlsoPrefersHim config) men)\n\n\n// modifiers (return new configurations)\n\nlet engage config man woman =\n  { config with wifeOf = config.wifeOf.Add(man, woman);\n                husbandOf = config.husbandOf.Add(woman, man) }\n\nlet breakOff config man =\n  let woman = config.wifeOf.[man]\n  { config with wifeOf = config.wifeOf.Remove(man);\n                husbandOf = config.husbandOf.Remove(woman) }\n\nlet propose config m w =\n  // remember the proposition\n  let proposedByM = defaultArg (config.proposed.TryFind m) []\n  let proposed' = config.proposed.Add(m, w::proposedByM) // '\n  let config = { config with proposed = proposed'}  // '\n  // actually try to engage\n  if isFreeWoman config w then engage config m w\n  else\n    let m' = config.husbandOf.[w] // '\n    if womanPrefers w m m' then // '\n      let config = breakOff config m' // '\n      engage config m w\n    else\n      config\n\n// do one step of the algorithm; returns None if no more steps are possible\nlet step config : Configuration option =\n  let freeMen = men |> List.filter (isFreeMan config)\n  let menWhoCanPropose =\n    freeMen |>\n    List.filter (fun man -> (notProposedBy config man women) <> [] )\n  match menWhoCanPropose with\n  | [] -> None\n  | m::_ -> let unproposedByM = menPrefs.[m] |> notProposedBy config m\n            // w is automatically the highest ranked because menPrefs.[m] is the source\n            let w = List.head unproposedByM\n            Some( propose config m w )\n              \nlet rec loop config =\n  match step config with\n  | None -> config\n  | Some config' -> loop config' // '\n\n\n// find solution and print it\nlet solution = loop { proposed = Map.empty<string, string list>;\n                      wifeOf = Map.empty<string, string>;\n                      husbandOf = Map.empty<string, string> }\n\nfor woman, man in Map.toList solution.husbandOf do\n  printfn \"%s is engaged to %s\" woman man\n\nprintfn \"Solution is stable: %A\" (isStable solution)\n\n\n// create unstable configuration by perturbing the solution\nlet perturbed = \n  let gal0 = women.[0]\n  let gal1 = women.[1]\n  let guy0 = solution.husbandOf.[gal0]\n  let guy1 = solution.husbandOf.[gal1]\n  { solution with wifeOf = solution.wifeOf.Add( guy0, gal1 ).Add( guy1, gal0 );\n                  husbandOf = solution.husbandOf.Add( gal0, guy1 ).Add( gal1, guy0 ) }\n\nprintfn \"Perturbed is stable: %A\" (isStable perturbed)\n\n\nOutput:\nabi is engaged to jon\nbea is engaged to fred\ncath is engaged to bob\ndee is engaged to col\neve is engaged to hal\nfay is engaged to dan\ngay is engaged to gav\nhope is engaged to ian\nivy is engaged to abe\njan is engaged to ed\nSolution is stable: true\nPerturbed is stable: false\n\n", "explain": ""}, {"task_name": "Stable marriage problem", "task_url": "https://rosettacode.org/wiki/Stable_marriage_problem", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\nTranslation of: Java (more or less) Uses explicit maps for preference ranking rather than list position. Uses Man and Woman enumerated types instead of string names, in order to take advantage of compile time type and constant checking to help keep the playas straight without a scorecard.\n\nimport static Man.*\nimport static Woman.*\n\nMap<Woman,Man> match(Map<Man,Map<Woman,Integer>> guysGalRanking, Map<Woman,Map<Man,Integer>> galsGuyRanking) {\n    Map<Woman,Man> engagedTo = new TreeMap()\n    List<Man> freeGuys = (Man.values()).clone()\n    while(freeGuys) {\n        Man thisGuy = freeGuys[0]\n        freeGuys -= thisGuy\n        List<Woman> guyChoices = Woman.values().sort{ she -> - guysGalRanking[thisGuy][she] }\n        for(Woman girl in guyChoices) {\n            if(! engagedTo[girl]) {\n                engagedTo[girl] = thisGuy\n                break\n            } else {\n                Man thatGuy = engagedTo[girl]\n                if (galsGuyRanking[girl][thisGuy] > galsGuyRanking[girl][thatGuy]) {\n                    engagedTo[girl] = thisGuy\n                    freeGuys << thatGuy\n                    break\n                }\n            }\n        }\n    }\n    engagedTo\n}\n\n\nboolean isStable(Map<Woman,Man> matches, Map<Man,Map<Woman,Integer>> guysGalRanking, Map<Woman,Map<Man,Integer>> galsGuyRanking) {\n    matches.collect{ girl, guy ->\n        int guysRank = galsGuyRanking[girl][guy]\n        List<Man> sheLikesBetter = Man.values().findAll{ he -> galsGuyRanking[girl][he] > guysRank }\n        for(Man otherGuy : sheLikesBetter) {\n            Woman otherGuyFiancee = matches.find{ pair -> pair.value == otherGuy }.key\n            if(guysGalRanking[otherGuy][girl] > guysGalRanking[otherGuy][otherGuyFiancee]) {\n                println \"\"\"O. M. G. ... ${otherGuy} likes ${girl} better than ${otherGuyFiancee}, and ${girl} likes ${otherGuy} better than ${guy}!\n                            I am TOTALLY 'shipping ${girl} and ${otherGuy} now!\"\"\"\n                return false\n            } \n        }\n        \n        int galsRank = guysGalRanking[guy][girl]\n        List<Woman> heLikesBetter = Woman.values().findAll{ she -> guysGalRanking[guy][she] > galsRank }\n        for(Woman otherGal : heLikesBetter) {\n            Man otherGalFiance = matches[otherGal]\n            if(galsGuyRanking[otherGal][guy] > galsGuyRanking[otherGal][otherGalFiance]) {\n                println \"\"\"O. M. G. ... ${otherGal} likes ${guy} better than ${otherGalFiance}, and ${guy} likes ${otherGal} better than ${girl}!\n                            I am TOTALLY 'shipping ${guy} and ${otherGal} now!\"\"\"\n                return false\n            } \n        }\n        true\n    }.every()\n}\n\n\nenum Man {\n    abe, bob, col, dan, ed, fred, gav, hal, ian, jon\n}\n\nenum Woman {\n    abi, bea, cath, dee, eve, fay, gay, hope, ivy, jan\n}\n\nMap<Man,Map<Woman,Integer>> mansWomanRanking = [\n    (abe): [(abi):10, (eve):9, (cath):8, (ivy):7, (jan):6, (dee):5, (fay):4, (bea):3, (hope):2, (gay):1],\n    (bob): [(cath):10, (hope):9, (abi):8, (dee):7, (eve):6, (fay):5, (bea):4, (jan):3, (ivy):2, (gay):1],\n    (col): [(hope):10, (eve):9, (abi):8, (dee):7, (bea):6, (fay):5, (ivy):4, (gay):3, (cath):2, (jan):1],\n    (dan): [(ivy):10, (fay):9, (dee):8, (gay):7, (hope):6, (eve):5, (jan):4, (bea):3, (cath):2, (abi):1],\n    (ed):  [(jan):10, (dee):9, (bea):8, (cath):7, (fay):6, (eve):5, (abi):4, (ivy):3, (hope):2, (gay):1],\n    (fred):[(bea):10, (abi):9, (dee):8, (gay):7, (eve):6, (ivy):5, (cath):4, (jan):3, (hope):2, (fay):1],\n    (gav): [(gay):10, (eve):9, (ivy):8, (bea):7, (cath):6, (abi):5, (dee):4, (hope):3, (jan):2, (fay):1],\n    (hal): [(abi):10, (eve):9, (hope):8, (fay):7, (ivy):6, (cath):5, (jan):4, (bea):3, (gay):2, (dee):1],\n    (ian): [(hope):10, (cath):9, (dee):8, (gay):7, (bea):6, (abi):5, (fay):4, (ivy):3, (jan):2, (eve):1],\n    (jon): [(abi):10, (fay):9, (jan):8, (gay):7, (eve):6, (bea):5, (dee):4, (cath):3, (ivy):2, (hope):1],\n]\n \nMap<Woman,List<Man>> womansManRanking = [\n    (abi): [(bob):10, (fred):9, (jon):8, (gav):7, (ian):6, (abe):5, (dan):4, (ed):3, (col):2, (hal):1],\n    (bea): [(bob):10, (abe):9, (col):8, (fred):7, (gav):6, (dan):5, (ian):4, (ed):3, (jon):2, (hal):1],\n    (cath):[(fred):10, (bob):9, (ed):8, (gav):7, (hal):6, (col):5, (ian):4, (abe):3, (dan):2, (jon):1],\n    (dee): [(fred):10, (jon):9, (col):8, (abe):7, (ian):6, (hal):5, (gav):4, (dan):3, (bob):2, (ed):1],\n    (eve): [(jon):10, (hal):9, (fred):8, (dan):7, (abe):6, (gav):5, (col):4, (ed):3, (ian):2, (bob):1],\n    (fay): [(bob):10, (abe):9, (ed):8, (ian):7, (jon):6, (dan):5, (fred):4, (gav):3, (col):2, (hal):1],\n    (gay): [(jon):10, (gav):9, (hal):8, (fred):7, (bob):6, (abe):5, (col):4, (ed):3, (dan):2, (ian):1],\n    (hope):[(gav):10, (jon):9, (bob):8, (abe):7, (ian):6, (dan):5, (hal):4, (ed):3, (col):2, (fred):1],\n    (ivy): [(ian):10, (col):9, (hal):8, (gav):7, (fred):6, (bob):5, (abe):4, (ed):3, (jon):2, (dan):1],\n    (jan): [(ed):10, (hal):9, (gav):8, (abe):7, (bob):6, (jon):5, (col):4, (ian):3, (fred):2, (dan):1],\n]\n\n// STABLE test\nMap<Woman,Man> matches = match(mansWomanRanking, womansManRanking)\nmatches.each { w, m ->\n    println \"${w} (his '${mansWomanRanking[m][w]}' girl) is engaged to ${m} (her '${womansManRanking[w][m]}' guy)\"\n}\nassert matches.keySet() == Woman.values() as Set\nassert matches.values() as Set == Man.values() as Set\nprintln ''\n\nassert isStable(matches, mansWomanRanking, womansManRanking)\n\n// PERTURBED test\nprintln 'Swapping partners now ...'\ndef temp = matches[abi]\nmatches[abi] = matches[bea]\nmatches[bea] = temp\nmatches.each { w, m ->\n    println \"${w} (his '${mansWomanRanking[m][w]}' girl) is engaged to ${m} (her '${womansManRanking[w][m]}' guy)\"\n}\nprintln ''\n\nassert ! isStable(matches, mansWomanRanking, womansManRanking)\n\n\nOutput:\nabi (his '10' girl) is engaged to jon (her '8' guy)\nbea (his '10' girl) is engaged to fred (her '7' guy)\ncath (his '10' girl) is engaged to bob (her '9' guy)\ndee (his '7' girl) is engaged to col (her '8' guy)\neve (his '9' girl) is engaged to hal (her '9' guy)\nfay (his '9' girl) is engaged to dan (her '5' guy)\ngay (his '10' girl) is engaged to gav (her '9' guy)\nhope (his '10' girl) is engaged to ian (her '6' guy)\nivy (his '7' girl) is engaged to abe (her '4' guy)\njan (his '10' girl) is engaged to ed (her '10' guy)\n\nSwapping partners now ...\nabi (his '9' girl) is engaged to fred (her '9' guy)\nbea (his '5' girl) is engaged to jon (her '2' guy)\ncath (his '10' girl) is engaged to bob (her '9' guy)\ndee (his '7' girl) is engaged to col (her '8' guy)\neve (his '9' girl) is engaged to hal (her '9' guy)\nfay (his '9' girl) is engaged to dan (her '5' guy)\ngay (his '10' girl) is engaged to gav (her '9' guy)\nhope (his '10' girl) is engaged to ian (her '6' guy)\nivy (his '7' girl) is engaged to abe (her '4' guy)\njan (his '10' girl) is engaged to ed (her '10' guy)\n\nO. M. G. ... bea likes fred better than jon, and fred likes bea better than abi!\n                            I am TOTALLY 'shipping fred and bea now!\nO. M. G. ... fred likes bea better than abi, and bea likes fred better than jon!\n                            I am TOTALLY 'shipping bea and fred now!\nO. M. G. ... jon likes eve better than bea, and eve likes jon better than hal!\n                            I am TOTALLY 'shipping eve and jon now!\nO. M. G. ... jon likes fay better than bea, and fay likes jon better than dan!\n                            I am TOTALLY 'shipping fay and jon now!\nO. M. G. ... jon likes gay better than bea, and gay likes jon better than gav!\n                            I am TOTALLY 'shipping gay and jon now!\n\n", "explain": "\"Stable Matching\" Solution:\n\"Stability Checking\" Solution:\n(Could do more to eliminate common code. Maybe later.)\nTest (Stable and Perturbed):\n"}]