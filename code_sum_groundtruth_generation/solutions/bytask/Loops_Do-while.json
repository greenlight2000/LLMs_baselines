[{"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Python", "code": "\n\nval = 0\nwhile True:\n   val +=1\n   print val\n   if val\u00a0% 6 == 0: break\n\nval = 1\nprint val\nwhile val\u00a0% 6\u00a0!= 0:\n   val += 1\n   print val\n", "explain": "Python doesn't have a do-while loop.\nor repeat the body of the loop before a standard while.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "C", "code": "\nint val = 0;\ndo{\n   val++;\n   printf(\"%d\\n\",val);\n}while(val % 6 != 0);\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "C++", "code": "\nint val = 0;\ndo{\n   val++;\n   std::cout << val << std::endl;\n}while(val % 6 != 0);\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Java", "code": "\nint val = 0;\ndo{\n   val++;\n   System.out.println(val);\n}while(val % 6 != 0);\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "C#", "code": "\nint a = 0;\n\ndo\n{\n    a += 1;\n    Console.WriteLine(a);\n} while (a % 6 != 0);\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "JavaScript", "code": "\nJavascript: Imperative[edit]\nvar val = 0;\ndo {\n  print(++val);\n} while (val % 6);\n\nJavascript: Functional[edit]\nES5[edit]\n\nAn initial value,\na Do function which transforms that value repetitively, corresponding to the body of the loop,\nand a conditional While function.\nfunction doWhile(varValue, fnBody, fnTest) {\n  'use strict';\n  var d = fnBody(varValue); // a transformed value\n\n  return fnTest(d) ? [d].concat(\n    doWhile(d, fnBody, fnTest)\n  ) : [d];\n}\n\nconsole.log(\n  doWhile(0,           // initial value\n    function (x) {     // Do body, returning transformed value\n      return x + 1;\n    },\n    function (x) {     // While condition\n      return x % 6;\n    }\n  ).join('\\n')\n);\n\n\n1\n2\n3\n4\n5\n6\n\n\nfunction range(m, n) {\n  'use strict';\n  return Array.apply(null, Array(n - m + 1)).map(\n    function (x, i) {\n      return m + i;\n    }\n  );\n}\n \nfunction takeWhile(lst, fnTest) {\n 'use strict';\n  var varHead = lst.length ? lst[0] : null;\n \n  return varHead ? (\n    fnTest(varHead) ? [varHead].concat(\n      takeWhile(lst.slice(1), fnTest)\n    ) : []\n  ) : []\n}\n \nconsole.log(\n  takeWhile(\n    range(1, 100),\n    function (x) {\n      return x % 6;\n    }\n  ).join('\\n')\n);\n\n\n1\n2\n3\n4\n5\n\nES6[edit]\n\n(() => {\n    'use strict';\n\n    // unfoldr\u00a0:: (b -> Maybe (a, b)) -> b -> [a]\n    function unfoldr(mf, v) {\n        for (var lst = [], a = v, m;\n            (m = mf(a)) && m.valid;) {\n            lst.push(m.value), a = m.new;\n        }\n        return lst;\n    }\n\n    // until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\n    function until(p, f, x) {\n        let v = x;\n        while(!p(v)) v = f(v);\n        return v;\n    }\n\n    let result1 = unfoldr(\n        x => {\n            return {\n                value: x,\n                valid: (x % 6) !== 0,\n                new: x + 1\n            }\n        },\n        1\n    );\n\n    let result2 = until(\n        m => (m.n % 6) === 0,\n        m => {\n            return {\n                n : m.n + 1,\n                xs : m.xs.concat(m.n)\n            };\n        },\n        {\n            n: 1,\n            xs: []\n        }\n    ).xs;\n    \n    return [result1, result2];\n})();\n\n[[1, 2, 3, 4, 5], [1, 2, 3, 4, 5]]\n\n\n// generator with the do while loop\nfunction* getValue(stop) {\n    var i = 0;\n    do {\n        yield ++i;\n    } while (i % stop != 0);\n}\n\n// function to print the value and invoke next\nfunction printVal(g, v) {\n    if (!v.done) {\n        console.log(v.value);\n        setImmediate(printVal, g, g.next());\n    }\n}\n\n(() => {\n    var gen = getValue(6);\n    printVal(gen, gen.next());\n})();\n\n1\n2\n3\n4\n5\n6\n\n", "explain": "In a functional idiom of JavaScript we cannot use a Do While statement, as it returns no value and is not a composable expression. We can, however achieve the same effect with a composable doWhile function, which takes three arguments, and returns the output series as a value.\nOutput:\nAlternatively, if we assume instead that the unstated problem was not to produce repetitive computation, but to derive the membership of a set we could interpret the task as a request for a JavaScript implementation of the takeWhile function \u2013 a familiar staple of functional list processing.\nSo, for example, something like:\nOutput:\nA process or value of this kind might be better expressed (in functionally composed JavaScript) with an unfold or until function, returning a list.\nES6 is a superset of Javascript so the Javascript and ES5 solution is valid.  An example of a do-while loop in a generator follows that produces correct output:\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "PHP", "code": "\n$val = 0;\ndo {\n   $val++;\n   print \"$val\\n\";\n} while ($val\u00a0% 6\u00a0!= 0);\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nINTEGER :: i = 0\nDO \n  i = i + 1\n  WRITE(*, *) i\n  IF (MOD(i, 6) == 0) EXIT\nEND DO\n\nWorks with: Fortran version 77 and later\n      PROGRAM DOWHILE\nC Initialize modulus and value.\n        INTEGER MODLUS, IVALUE\n        PARAMETER (MODLUS = 6)\n        IVALUE = 0\n\nC FORTRAN 77 has no do-while structure -- not semantically. It is not\nC difficult to simulate it using GOTO, however:\n   10   CONTINUE\n          IVALUE = IVALUE + 1\n          WRITE (*,*) IVALUE\n        IF (.NOT. (MOD(IVALUE, MODLUS) .EQ. 0)) GOTO 10\n\n        STOP\n      END\n\nWorks with: Fortran version IV and later\n      IVALUE = 0\n   10 CONTINUE\n        IVALUE=IVALUE+1\n        WRITE(6,301) IVALUE\n  301   FORMAT(I5)          \n      IF(MOD(IVALUE,6).NE.0) GOTO 10\n      END\n\nWorks with: Fortran version I and later\n      IVALUE = 0\n   10 IVALUE=IVALUE+1\n      WRITE 301,IVALUE\n  301 FORMAT(I5)          \n      IF(IVALUE-IVALUE/6*6) 10,20,10\n   20 STOP\n      END\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar value int\n\tfor {\n\t\tvalue++\n\t\tfmt.Println(value)\n                if value%6 != 0 {\n                        break\n                }\n\t}\n}\n\n\nOutput:\n1\n2\n3\n4\n5\n6\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\tvar value int\n\tfor ok := true; ok; ok = value%6 != 0 {\n\t\tvalue++\n\t\tfmt.Println(value)\n\t}\n}\n\n\nOutput:\nSame as before.\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\t// do-while loop 1\n\tn1 := 2\n\tfor n1 < 6 {\n\t\tn1 *= 2\n\t}\n\tfmt.Println(n1) // prt 8\n\t// do-while loop 2\n\tn2 := 2\n\tfor ok := true; ok; ok = n2%8 != 0 {\n\t\t\tn2 *= 2\n\t}\n\tfmt.Println(n2) // prt 8\n\t// do-while loop 3\n\tn3 := 2\n\tfor {\n\t\tn3 *= 2\n\t\tif n3 >= 6 {\n\t\t\tbreak\n\t\t}\n\t}\n\tfmt.Println(n3) // prt 8\n}\n\n", "explain": "There is no explicit do-while in Go, but it can be simulated with a range-based for loop and the break statement.\nIt can also be simulated without using a break statement as follows:\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program loopdowhile.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult:  .ascii \"Counter = \"      @ message result\nsMessValeur:   .fill 12, 1, ' '\n                   .asciz \"\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                @ entry of program \n    push {fp,lr}      @ saves 2 registers \n    mov r4,#0\n1:    @ begin loop \n    mov r0,r4\n\n    ldr r1,iAdrsMessValeur     @ display value\n    bl conversion10             @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    add r4,#1                   @ increment counter\n    mov r0,r4\n    mov r1,#6              @ division conuter by 6\n    bl division\n    cmp r3,#0              @ remainder = z\u00e9ro\u00a0?\n    bne 1b                @ no ->begin loop one\n\n100:   @ standard end of the program \n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    svc #0                       @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszMessResult:         .int szMessResult\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}      @ save  registres\n    mov r2,#0                  @ counter length \n1:      @ loop length calculation \n    ldrb r1,[r0,r2]           @ read octet start position + index \n    cmp r1,#0                  @ if 0 its over \n    addne r2,r2,#1            @ else add 1 in the length \n    bne 1b                    @ and loop \n                                @ so here r2 contains the length of the message \n    mov r1,r0        \t\t\t@ address message in r1 \n    mov r0,#STDOUT      \t\t@ code to write to the standard output Linux \n    mov r7, #WRITE             @ code call system \"write\" \n    svc #0                      @ call systeme \n    pop {r0,r1,r2,r7,lr}        @ restaur des  2 registres */ \n    bx lr                       @ return  \n/******************************************************************/\n/*     Converting a register to a decimal                                 */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\nconversion10:\n    push {r1-r4,lr}    @ save registers \n    mov r3,r1\n    mov r2,#10\n\n1:\t   @ start loop\n    bl divisionpar10 @ r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48        @ digit\t\n    strb r1,[r3,r2]  @ store digit on area\n    sub r2,#1         @ previous position\n    cmp r0,#0         @ stop if quotient = 0 */\n    bne 1b\t          @ else loop\n    @ and move spaces in first on area\n    mov r1,#' '   @ space\t\n2:\t\n    strb r1,[r3,r2]  @ store space in area\n    subs r2,#1       @ @ previous position\n    bge 2b           @ loop if r2 >= z\u00e9ro \n\n100:\t\n    pop {r1-r4,lr}    @ restaur registres \n    bx lr\t          @return\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}   /* save registers  */\n    mov r4,r0 \n    mov r3,#0x6667   @ r3 <- magic_number  lower\n    movt r3,#0x6666  @ r3 <- magic_number  upper\n    smull r1, r2, r3, r0   @ r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) \n    mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n    mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n    add r0, r2, r1         /* r0 <- r2 + r1 */\n    add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n    sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n    pop {r2-r4}\n    bx lr                  /* leave function */\n/***************************************************/\n/* integer division unsigned                       */\n/***************************************************/\ndivision:\n    /* r0 contains dividend */\n    /* r1 contains divisor */\n    /* r2 returns quotient */\n    /* r3 returns remainder */\n    push {r4, lr}\n    mov r2, #0                @ init quotient\n    mov r3, #0                @ init remainder\n    mov r4, #32               @ init counter bits\n    b 2f\n1:          @ loop \n    movs r0, r0, LSL #1     @ r0 <- r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1)\n    adc r3, r3, r3           @ r3 <- r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C \n    cmp r3, r1               @ compute r3 - r1 and update cpsr \n    subhs r3, r3, r1        @ if r3 >= r1 (C=1) then r3\u00a0? r3 - r1 \n    adc r2, r2, r2           @ r2 <- r2 + r2 + C. This is equivalent to r2 <- (r2 << 1) + C \n2:\n    subs r4, r4, #1          @ r4 <- r4 - 1 \n    bpl 1b                  @ if r4 >= 0 (N=0) then loop\n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "MIPS_Assembly", "code": "\n\t.text\nmain:\tli \t$s0, 0\t\t# start at 0. \n\tli\t$s1, 6 \nloop:\taddi\t$s0, $s0, 1\t# add 1 to $s0\n\tdiv\t$s0, $s1\t# divide $s0 by $s1. Result is in the multiplication/division registers\n\tmfhi\t$s3\t\t# copy the remainder from the higher multiplication register to $s3\n\tmove\t$a0, $s0\t# variable must be in $a0 to print\n\tli\t$v0, 1\t\t# 1 must be in $v0 to tell the assembler to print an integer\n\tsyscall\t\t\t# print the integer in $a0\n\tbnez\t$s3, loop\t# if $s3 is not 0, jump to loop\n\t\n\tli\t$v0, 10\n\tsyscall\t\t\t# syscall to end the program\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "X86_Assembly", "code": "\nWorks with: nasm\nWorks with: windows\nextern _printf\n\nsection .data\n    output db 0,0\n    \nsection .text\nglobal _main\n_main:\n    mov bl, 0\n    looping:\n        add bl, 0x31 ;0x30 to 0x39 is 0 to 9 in ASCII\n        mov [output], bl\n        sub bl, 0x30\n        push output\n        call _printf\n        add esp, 4\n        xor eax, eax\n        xor edx, edx\n        mov al, bl\n        mov ecx, 6\n        div ecx\u00a0; remainder is saved in edx\n        cmp edx, 0\n        jne looping\u00a0; if n & 6\u00a0!= 0 do looping again\n    xor eax, eax\n    ret\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Delphi", "code": "\nprogram Loop;\n\n{$APPTYPE CONSOLE}\n\nvar\n  I: Integer;\n\nbegin\n  I:= 0;\n  repeat\n    Inc(I);\n    Write(I:2);\n  until I mod 6 = 0;\n  Writeln;\n  Readln;\nend.\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Ruby", "code": "\n\n\n\nwhile\n\nuntil\n\n\nval = 0\nbegin\n   val += 1\n   puts val\nend while val\u00a0% 6\u00a0!= 0\n\nval = 0\nbegin\n   val += 1\n   puts val\nend until val\u00a0% 6 == 0\n\n\n\n\nbreak unless\n\nbreak if\n\n\nval = 0\nloop do\n   val += 1\n   puts val\n   break unless val %6\u00a0!= 0\nend\n\nval = 0\nloop do\n   val += 1\n   puts val\n   break if val %6 == 0\nend\n\n\n", "explain": "The while statement modifier normally checks the condition before entering the loop. But if the while statement modifier is on a begin ... end statement, then it loops at least once. Same with the until statement modifier.\nDuring November 2005, Yukihiro Matsumoto, the creator of Ruby, regretted this loop feature and suggested using Kernel#loop.\nAll four of these examples print the numbers 1, 2, 3, 4, 5, 6.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Rust", "code": "\n\nlet mut x = 0;\n\nloop {\n    x += 1;\n    println!(\"{}\", x);\n\n    if x\u00a0% 6 == 0 { break; }\n}\n", "explain": "Rust does not have a do...while loop. Instead, the keyword loop is used with a termination condition.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Swift", "code": "\nWorks with: Swift version 3.x+\nvar val = 0\nrepeat {\n  val += 1\n  print(val)\n} while val\u00a0% 6\u00a0!= 0\nWorks with: Swift version 2.x\nvar val = 0\nrepeat {\n  val++\n  print(val)\n} while val\u00a0% 6\u00a0!= 0\nWorks with: Swift version 1.x\nvar val = 0\ndo {\n   val++\n   println(val)\n} while val\u00a0% 6\u00a0!= 0\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "R", "code": "\ni <- 0\nrepeat\n{\n   i <- i + 1\n   print(i)\n   if(i\u00a0%% 6 == 0) break\n}\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "COBOL", "code": "\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. loop-do-while.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  i PIC 99 VALUE 0.\n\n       PROCEDURE DIVISION.\n           PERFORM WITH TEST AFTER UNTIL FUNCTION MOD(i, 6) = 0\n               ADD 1 TO i\n               DISPLAY i\n           END-PERFORM\n\n           GOBACK\n           .\n\n", "explain": "The COBOL equivalent of a do-while loop is PERFORM WITH TEST AFTER UNTIL some-condition.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Ada", "code": "\nloop\n   Value := Value + 1;\n   Put (Value);\n   exit when Value mod 6 = 0;\nend loop;\n\n\nfor Value in 0..Integer'Last loop\n   Put (Value);\n   exit when Value mod 6 = 0;\nend loop;\n\n", "explain": "Here is an alternative version:\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Julia", "code": "\n\njulia> i = 0\n0\n\njulia> while true\n           println(i)\n           i += 1\n           i % 6 == 0 && break\n       end\n0\n1\n2\n3\n4\n5\n\n\njulia> @eval macro $(:do)(block, when::Symbol, condition)\n           when \u2260 :when && error(\"@do expected `when` got `$s`\")\n           quote\n               let\n                   $block\n                   while $condition\n                       $block\n                   end\n               end\n           end |> esc\n       end\n@do (macro with 1 method)\n\njulia> i = 0\n0\n\njulia> @do begin\n           @show i\n           i += 1\n       end when i % 6 \u2260 0\ni = 0\ni = 1\ni = 2\ni = 3\ni = 4\ni = 5\n\n\njulia> macro do_while(condition, block)\n           quote\n               let\n                   $block\n                   while $condition\n                       $block\n                   end\n               end\n           end |> esc\n       end\n@do_while (macro with 1 method)\n\njulia> i = 0\n0\n\njulia> @do_while i % 6 \u2260 0 begin\n           @show i\n           i += 1\n       end\ni = 0\ni = 1\ni = 2\ni = 3\ni = 4\ni = 5\n\n", "explain": "Julia has no do-while construct.  Here is one of several ways to implement do-while behavior.\nUsing a macro that mimics the classic C style do-while.\nNotice that the symbol while cannot be used as it is a keyword, which is why when is used instead, also the macro definition is wrapped in a @eval macro invocation since do is also a keyword, but in Julia macro calls are prefixed by @ so this is only an issue during the macro definition, not when invoked, ie. @do block when condition).\nHere is mostly the same macro, but with the conditional clause used first, which is arguably more readable.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "SAS", "code": "\n/* using DO UNTIL so that the loop executes at least once */\ndata _null_;\nn=0;\ndo until(mod(n,6)=0);\n    n+1;\n    put n;\nend;\nrun;\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    var value = 0\n    do {\n        println(++value)\n    }\n    while (value % 6 != 0)\n}\n\n\nOutput:\n1\n2\n3\n4\n5\n6\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Perl", "code": "\nmy $val = 0;\ndo {\n   $val++;\n   print \"$val\\n\";\n} while ($val\u00a0% 6);\n\nmy $val = 0;\ndo {\n   $val++;\n   print \"$val\\n\";\n} until ($val\u00a0% 6 == 0);\n", "explain": "do ... until (condition) is equivalent to do ... while (not condition).\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Prolog", "code": "\n% initial condition\ndo(0):- write(0),nl,do(1).\n\n% control condition\ndo(V):- 0 is mod(V,6),\u00a0!, fail.\n\n% loop\ndo(V)\u00a0:-\n    write(V),nl,\n    Y is V + 1,\n    do(Y).\n\nwloop\u00a0:-\n   do(0).\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Lua", "code": "\n\ni=0\nrepeat\n  i=i+1\n  print(i)\nuntil i%6 == 0\n\n", "explain": "Lua doesn't have a do .. while construct.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Scala", "code": "\nLibrary: Scala\nImperative[edit]\n  {\n    var (x, l) = (0, List[Int]())\n    do {\n      x += 1\n      l\u00a0:+= x // A new copy of this list with List(x) appended.\n    } while (x\u00a0% 6\u00a0!= 0)\n    l\n  }.foreach(println(_))\nTail recursive[edit]\n\tdef loop(iter: Int, cond: (Int) => Boolean, accu: List[Int]): List[Int] = {\n\t  val succ = iter + 1\n\t  val temp = accu\u00a0:+ succ\n\t  if (cond(succ)) loop(succ, cond, temp) else temp\n\t}\n\tprintln(loop(0, (_\u00a0% 6\u00a0!= 0), Nil))\nStream[edit]\n  def loop(i: Int, cond: (Int) => Boolean): Stream[Int] = {\n    val succ = i + 1;\n    succ #:: (if (cond(succ)) loop(succ, cond) else Stream.empty)\n  }\n  loop(0, (_\u00a0% 6\u00a0!= 0)).foreach(println(_))\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Dart", "code": "\nvoid main() {\n  int val = 0;\n  do {\n    val++;\n    print(val);\n  } while (val % 6 != 0);\n}\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main() {\n    int val;\n    do {\n        val++;\n        write(val, \" \");\n    } while (val % 6 != 0);\n}\n\n\nOutput:\n1 2 3 4 5 6 \n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Haskell", "code": "\nimport Data.List\nimport Control.Monad\nimport Control.Arrow\n\ndoWhile p f n = (n:) $ takeWhile p $ unfoldr (Just.(id &&& f)) $ succ n\n\n\n*Main> mapM_ print $ doWhile ((/=0).(`mod`6)) succ 0\n0\n1\n2\n3\n4\n5\n\n\nmain :: IO ()\nmain =\n  mapM_ print . reverse $\n  until\n    (\\(x:_) -> (x > 0) && (mod x 6 == 0)) \n    (\\xs@(x:_) -> succ x : xs) \n    [0]\n\n\nOutput:\n0\n1\n2\n3\n4\n5\n6\n\nWith mutable references[edit]\n\nimport Data.IORef\nimport Control.Monad.Loops\n\nmain = do\n  x <- newIORef 0;\n  iterateWhile (\\val -> val `mod` 6 /= 0 ) $ do\n    modifyIORef x (+1)\n    val <- readIORef x\n    print val\n    return val\n\n", "explain": "Example executed in GHCi:\nThe standard Prelude also includes, without further import or definition, an until function, which takes three arguments \u2013 a predicate function, a transformation function, and an initial value.\nUsing iterateWhile from monad-loops package\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Scheme", "code": "\n(let loop ((i 1))\n  (display i)\n  (if (positive? (modulo i 6))\n      (loop (+ i 1))))\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "PowerShell", "code": "\n$n = 0\ndo {\n    $n++\n    $n\n} while ($n\u00a0% 6 -ne 0)\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Logo", "code": "\nmake \"val 0\ndo.while [make \"val :val + 1  print :val] [notequal? 0 modulo :val 6]\ndo.until [make \"val :val + 1  print :val] [equal? 0 modulo :val 6]\n\nto my.loop :n\n  make \"n :n + 1\n  print :n\n  if notequal? 0 modulo :n 6 [my.loop :n]\nend\nmy.loop 0\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "ColdFusion", "code": "\n<cfscript>\n  value = 0;\n  do\n  {\n    value += 1;\n    writeOutput( value );\n  } while( value % 6 != 0 );\t\t\t\n</cfscript>\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "F#", "code": "\n\nlet rec loop n =\n  printfn \"%d \" n\n  if (n+1)%6 > 0 then loop (n+1)\nloop 0\n\n\nSeq.initInfinite id |> Seq.takeWhile(fun n->n=0 || n%6>0) |> Seq.iter (fun n-> printfn \"%d\" n)\n\n\n\nOutput:\n0\n1\n2\n3\n4\n5\n\n\n// Loops/Do-while. Nigel Galloway: February 14th., 2022\nSeq.unfold(fun n->match n with Some n->let n=n+1 in Some(n,if n%6=0 then None else Some(n)) |_->None)(Some 0)|>Seq.iter(printfn \"%d\")\n\n\nOutput:\n\n\n1\n2\n3\n4\n5\n6\n\n", "explain": "If you must have a loop then this is acceptable F#\nBut I prefer this way:\nEither produces:\nMany of the solutions to this task show no output in spite of it being required in the task dexcription, so who knows what they do? Of some that have output they think it should be 1 to 6, who can tell from the task description? The following produces 1..6.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Groovy", "code": "\n\ndef i = 0\ndo {\n    i++\n    println i\n} while (i % 6 != 0)\n\n\ndef i = 0\nwhile (true) {\n    i++\n    println i\n    if (i % 6 == 0) break\n}\n\n\nOutput:\n1\n2\n3\n4\n5\n6\n", "explain": "For Groovy 3.0.0 and later.\nPrevious versions of Groovy did not have a bottom-checking loop construct. Workaround is to use an \"infinite\" while loop with a conditional break as the last statement.\n"}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\npub fn main() !void {\n    var a: u8 = 0;\n    // no do-while in syntax, trust the optimizer to do\n    // correct Loop inversion https://en.wikipedia.org/wiki/Loop_inversion\n    // If the variable `alive` is independent to other variables and not in\n    // diverging control flow, then the optimization is possible in general.\n    var alive = true;\n    while (alive == true or a\u00a0% 6\u00a0!= 0) {\n        alive = false;\n        a += 1;\n        try std.io.getStdOut().writer().print(\"{d}\\n\", .{a});\n    }\n}\n\n\n\n", "explain": ""}, {"task_name": "Loops/Do-while", "task_url": "https://rosettacode.org/wiki/Loops/Do-while", "task_cat": "Conditional loops", "lang": "AWK", "code": "\nBEGIN {\n  val = 0\n  do {\n    val++\n    print val\n  } while( val % 6 != 0)\n}\n\n", "explain": ""}]