[{"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Python", "code": "\n\nfrom fractions import gcd\n\n\ndef pt1(maxperimeter=100):\n    '''\n# Naive method\n    '''\n    trips = []\n    for a in range(1, maxperimeter):\n        aa = a*a\n        for b in range(a, maxperimeter-a+1):\n            bb = b*b\n            for c in range(b, maxperimeter-b-a+1):\n                cc = c*c\n                if a+b+c > maxperimeter or cc > aa + bb: break\n                if aa + bb == cc:\n                    trips.append((a,b,c, gcd(a, b) == 1))\n    return trips\n\ndef pytrip(trip=(3,4,5),perim=100, prim=1):\n    a0, b0, c0 = a, b, c = sorted(trip)\n    t, firstprim = set(), prim>0\n    while a + b + c <= perim:\n        t.add((a, b, c, firstprim>0))\n        a, b, c, firstprim = a+a0, b+b0, c+c0, False\n    #\n    t2 = set()\n    for a, b, c, firstprim in t:\n        a2, a5, b2, b5, c2, c3, c7 = a*2, a*5, b*2, b*5, c*2, c*3, c*7\n        if  a5 - b5 + c7 <= perim:\n            t2 |= pytrip(( a - b2 + c2,  a2 - b + c2,  a2 - b2 + c3), perim, firstprim)\n        if  a5 + b5 + c7 <= perim:\n            t2 |= pytrip(( a + b2 + c2,  a2 + b + c2,  a2 + b2 + c3), perim, firstprim)\n        if -a5 + b5 + c7 <= perim:\n            t2 |= pytrip((-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3), perim, firstprim)\n    return t | t2\n\ndef pt2(maxperimeter=100):\n    '''\n# Parent/child relationship method:\n# http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples#XI.\n    '''\n    trips = pytrip((3,4,5), maxperimeter, 1)\n    return trips\n\ndef printit(maxperimeter=100, pt=pt1):\n    trips = pt(maxperimeter)\n    print(\"  Up to a perimeter of %i there are %i triples, of which %i are primitive\"\n          % (maxperimeter,\n             len(trips),\n             len([prim for a,b,c,prim in trips if prim])))\n  \nfor algo, mn, mx in ((pt1, 250, 2500), (pt2, 500, 20000)):\n    print(algo.__doc__)\n    for maxperimeter in range(mn, mx+1, mn):\n        printit(maxperimeter, algo)\n\nOutput\n\n# Naive method\n    \n  Up to a perimeter of 250 there are 56 triples, of which 18 are primitive\n  Up to a perimeter of 500 there are 137 triples, of which 35 are primitive\n  Up to a perimeter of 750 there are 227 triples, of which 52 are primitive\n  Up to a perimeter of 1000 there are 325 triples, of which 70 are primitive\n  Up to a perimeter of 1250 there are 425 triples, of which 88 are primitive\n  Up to a perimeter of 1500 there are 527 triples, of which 104 are primitive\n  Up to a perimeter of 1750 there are 637 triples, of which 123 are primitive\n  Up to a perimeter of 2000 there are 744 triples, of which 140 are primitive\n  Up to a perimeter of 2250 there are 858 triples, of which 156 are primitive\n  Up to a perimeter of 2500 there are 969 triples, of which 175 are primitive\n\n# Parent/child relationship method:\n# http://en.wikipedia.org/wiki/Formulas_for_generating_Pythagorean_triples#XI.\n    \n  Up to a perimeter of 500 there are 137 triples, of which 35 are primitive\n  Up to a perimeter of 1000 there are 325 triples, of which 70 are primitive\n  Up to a perimeter of 1500 there are 527 triples, of which 104 are primitive\n  Up to a perimeter of 2000 there are 744 triples, of which 140 are primitive\n  Up to a perimeter of 2500 there are 969 triples, of which 175 are primitive\n  Up to a perimeter of 3000 there are 1204 triples, of which 211 are primitive\n  Up to a perimeter of 3500 there are 1443 triples, of which 245 are primitive\n  Up to a perimeter of 4000 there are 1687 triples, of which 280 are primitive\n  Up to a perimeter of 4500 there are 1931 triples, of which 314 are primitive\n  Up to a perimeter of 5000 there are 2184 triples, of which 349 are primitive\n  Up to a perimeter of 5500 there are 2442 triples, of which 385 are primitive\n  Up to a perimeter of 6000 there are 2701 triples, of which 422 are primitive\n  Up to a perimeter of 6500 there are 2963 triples, of which 457 are primitive\n  Up to a perimeter of 7000 there are 3224 triples, of which 492 are primitive\n  Up to a perimeter of 7500 there are 3491 triples, of which 527 are primitive\n  Up to a perimeter of 8000 there are 3763 triples, of which 560 are primitive\n  Up to a perimeter of 8500 there are 4029 triples, of which 597 are primitive\n  Up to a perimeter of 9000 there are 4304 triples, of which 631 are primitive\n  Up to a perimeter of 9500 there are 4577 triples, of which 667 are primitive\n  Up to a perimeter of 10000 there are 4858 triples, of which 703 are primitive\n  Up to a perimeter of 10500 there are 5138 triples, of which 736 are primitive\n  Up to a perimeter of 11000 there are 5414 triples, of which 770 are primitive\n  Up to a perimeter of 11500 there are 5699 triples, of which 804 are primitive\n  Up to a perimeter of 12000 there are 5980 triples, of which 839 are primitive\n  Up to a perimeter of 12500 there are 6263 triples, of which 877 are primitive\n  Up to a perimeter of 13000 there are 6559 triples, of which 913 are primitive\n  Up to a perimeter of 13500 there are 6843 triples, of which 949 are primitive\n  Up to a perimeter of 14000 there are 7129 triples, of which 983 are primitive\n  Up to a perimeter of 14500 there are 7420 triples, of which 1019 are primitive\n  Up to a perimeter of 15000 there are 7714 triples, of which 1055 are primitive\n  Up to a perimeter of 15500 there are 8004 triples, of which 1089 are primitive\n  Up to a perimeter of 16000 there are 8304 triples, of which 1127 are primitive\n  Up to a perimeter of 16500 there are 8595 triples, of which 1159 are primitive\n  Up to a perimeter of 17000 there are 8884 triples, of which 1192 are primitive\n  Up to a perimeter of 17500 there are 9189 triples, of which 1228 are primitive\n  Up to a perimeter of 18000 there are 9484 triples, of which 1264 are primitive\n  Up to a perimeter of 18500 there are 9791 triples, of which 1301 are primitive\n  Up to a perimeter of 19000 there are 10088 triples, of which 1336 are primitive\n  Up to a perimeter of 19500 there are 10388 triples, of which 1373 are primitive\n  Up to a perimeter of 20000 there are 10689 triples, of which 1408 are primitive\nBarebone minimum for this task:from sys import setrecursionlimit\nsetrecursionlimit(2000) # 2000 ought to be big enough for everybody\n\ndef triples(lim, a = 3, b = 4, c = 5):\n    l = a + b + c\n    if l > lim: return (0, 0)\n    return reduce(lambda x, y: (x[0] + y[0], x[1] + y[1]), [\n        (1, lim / l),\n        triples(lim,  a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c),\n        triples(lim,  a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c),\n        triples(lim, -a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c) ])\n\nfor peri in [10 ** e for e in range(1, 8)]:\n    print peri, triples(peri)\nOutput:10 (0, 0)\n100 (7, 17)\n1000 (70, 325)\n10000 (703, 4858)\n100000 (7026, 64741)\n1000000 (70229, 808950)\n10000000 (702309, 9706567)\n\n", "explain": "Two methods, the second of which is much faster\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n \ntypedef unsigned long long xint;\ntypedef unsigned long ulong;\n\ninline ulong gcd(ulong m, ulong n)\n{\n    ulong t;\n    while (n) { t = n; n = m % n; m = t; }\n    return m;\n}\n \nint main()\n{\n    ulong a, b, c, pytha = 0, prim = 0, max_p = 100;\n    xint aa, bb, cc;\n\n    for (a = 1; a <= max_p / 3; a++) {\n        aa = (xint)a * a;\n        printf(\"a = %lu\\r\", a); /* show that we are working */\n        fflush(stdout);\n\n        /*  max_p/2: valid limit, because one side of triangle\n         *  must be less than the sum of the other two\n         */\n        for (b = a + 1; b < max_p/2; b++) {\n            bb = (xint)b * b;\n            for (c = b + 1; c < max_p/2; c++) {\n                cc = (xint)c * c;\n                if (aa + bb < cc) break;\n                if (a + b + c > max_p) break;\n\n                if (aa + bb == cc) {\n                    pytha++;\n                    if (gcd(a, b) == 1) prim++;\n                }\n            }\n        }\n    }\n \n    printf(\"Up to %lu, there are %lu triples, of which %lu are primitive\\n\",\n        max_p, pytha, prim);\n\n    return 0;\n}\noutput:Up to 100, there are 17 triples, of which 7 are primitive\n\nEfficient method, generating primitive triples only as described in the same WP article:#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n/* should be 64-bit integers if going over 1 billion */\ntypedef unsigned long xint;\n#define FMT \"%lu\"\n\nxint total, prim, max_peri;\nxint U[][9] =  {{ 1, -2, 2,  2, -1, 2,  2, -2, 3},\n        { 1,  2, 2,  2,  1, 2,  2,  2, 3},\n        {-1,  2, 2, -2,  1, 2, -2,  2, 3}};\n\nvoid new_tri(xint in[])\n{\n    int i;\n    xint t[3], p = in[0] + in[1] + in[2];\n\n    if (p > max_peri) return;\n\n    prim ++;\n\n    /* for every primitive triangle, its multiples would be right-angled too;\n     * count them up to the max perimeter */\n    total += max_peri / p;\n\n    /* recursively produce next tier by multiplying the matrices */\n    for (i = 0; i < 3; i++) {\n        t[0] = U[i][0] * in[0] + U[i][1] * in[1] + U[i][2] * in[2];\n        t[1] = U[i][3] * in[0] + U[i][4] * in[1] + U[i][5] * in[2];\n        t[2] = U[i][6] * in[0] + U[i][7] * in[1] + U[i][8] * in[2];\n        new_tri(t);\n    }\n}\n\nint main()\n{\n    xint seed[3] = {3, 4, 5};\n\n    for (max_peri = 10; max_peri <= 100000000; max_peri *= 10) {\n        total = prim = 0;\n        new_tri(seed);\n\n        printf( \"Up to \"FMT\": \"FMT\" triples, \"FMT\" primitives.\\n\",\n            max_peri, total, prim);\n    }\n    return 0;\n}\nOutputUp to 10: 0 triples, 0 primitives.\nUp to 100: 17 triples, 7 primitives.\nUp to 1000: 325 triples, 70 primitives.\nUp to 10000: 4858 triples, 703 primitives.\nUp to 100000: 64741 triples, 7026 primitives.\nUp to 1000000: 808950 triples, 70229 primitives.\nUp to 10000000: 9706567 triples, 702309 primitives.\nUp to 100000000: 113236940 triples, 7023027 primitives.\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\n/* should be 64-bit integers if going over 1 billion */\ntypedef unsigned long xint;\n#define FMT \"%lu\"\n\nxint total, prim, max_peri;\n\nvoid new_tri(xint in[])\n{\n    int i;\n    xint t[3], p;\n    xint x = in[0], y = in[1], z = in[2];\n\nrecur:  p = x + y + z;\n    if (p > max_peri) return;\n\n    prim ++;\n    total += max_peri / p;\n\n    t[0] = x - 2 * y + 2 * z;\n    t[1] = 2 * x - y + 2 * z;\n    t[2] = t[1] - y + z;\n    new_tri(t);\n\n    t[0] += 4 * y;\n    t[1] += 2 * y;\n    t[2] += 4 * y;\n    new_tri(t);\n\n    z = t[2] - 4 * x;\n    y = t[1] - 4 * x;\n    x = t[0] - 2 * x;\n    goto recur;\n}\n\nint main()\n{\n    xint seed[3] = {3, 4, 5};\n\n    for (max_peri = 10; max_peri <= 100000000; max_peri *= 10) {\n        total = prim = 0;\n        new_tri(seed);\n\n        printf( \"Up to \"FMT\": \"FMT\" triples, \"FMT\" primitives.\\n\",\n            max_peri, total, prim);\n    }\n    return 0;\n}\n\n", "explain": "Sample implemention; naive method, patentedly won't scale to larger numbers, despite the attempt to optimize it.  Calculating up to 10000 is already a test of patience.\nSame as above, but with loop unwound and third recursion eliminated:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "C++", "code": "\n#include <cmath>\n#include <iostream>\n#include <numeric>\n#include <tuple>\n#include <vector>\n\nusing namespace std;\n\nauto CountTriplets(unsigned long long maxPerimeter)\n{\n    unsigned long long totalCount = 0;\n    unsigned long long primitveCount = 0;\n    auto max_M = (unsigned long long)sqrt(maxPerimeter/2) + 1;\n    for(unsigned long long m = 2; m < max_M; ++m)\n    {\n        for(unsigned long long n = 1 + m % 2; n < m; n+=2)\n        {\n            if(gcd(m,n) != 1)\n            {\n                continue;\n            }\n            \n            // The formulas below will generate primitive triples if:\n            //   0 < n < m\n            //   m and n are relatively prime (gcd == 1)\n            //   m + n is odd\n            \n            auto a = m * m - n * n;\n            auto b = 2 * m * n;\n            auto c = m * m + n * n;\n            auto perimeter = a + b + c;\n            if(perimeter <= maxPerimeter)\n            {\n                primitveCount++;\n                totalCount+= maxPerimeter / perimeter;\n            }\n        }\n    }\n    \n    return tuple(totalCount, primitveCount);\n}\n\n\nint main()\n{\n    vector<unsigned long long> inputs{100, 1000, 10'000, 100'000,\n        1000'000, 10'000'000, 100'000'000, 1000'000'000,\n        10'000'000'000};  // This last one takes almost a minute\n    for(auto maxPerimeter : inputs)\n    {\n        auto [total, primitive] = CountTriplets(maxPerimeter);\n        cout << \"\\nMax Perimeter: \" << maxPerimeter << \", Total: \" << total << \", Primitive: \" << primitive ;\n    }\n}\n\n\nOutput:\nMax Perimeter: 100, Total: 17, Primitive: 7\nMax Perimeter: 1000, Total: 325, Primitive: 70\nMax Perimeter: 10000, Total: 4858, Primitive: 703\nMax Perimeter: 100000, Total: 64741, Primitive: 7026\nMax Perimeter: 1000000, Total: 808950, Primitive: 70229\nMax Perimeter: 10000000, Total: 9706567, Primitive: 702309\nMax Perimeter: 100000000, Total: 113236940, Primitive: 7023027\nMax Perimeter: 1000000000, Total: 1294080089, Primitive: 70230484\nMax Perimeter: 10000000000, Total: 14557915466, Primitive: 702304875\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Java", "code": "\nBrute force[edit]Theoretically, this can go \"forever\", but it takes a while, so only the minimum is shown. Luckily, BigInteger has a GCD method built in.\nimport java.math.BigInteger;\nimport static java.math.BigInteger.ONE;\n\npublic class PythTrip{\n\n    public static void main(String[] args){\n        long tripCount = 0, primCount = 0;\n\n        //change this to whatever perimeter limit you want;the RAM's the limit\n        BigInteger periLimit = BigInteger.valueOf(100),\n                peri2 = periLimit.divide(BigInteger.valueOf(2)),\n                peri3 = periLimit.divide(BigInteger.valueOf(3));\n\n        for(BigInteger a = ONE; a.compareTo(peri3) < 0; a = a.add(ONE)){\n            BigInteger aa = a.multiply(a);\n            \n            for(BigInteger b = a.add(ONE);\n                    b.compareTo(peri2) < 0; b = b.add(ONE)){\n                BigInteger bb = b.multiply(b);\n                BigInteger ab = a.add(b);\n                BigInteger aabb = aa.add(bb);\n                \n                for(BigInteger c = b.add(ONE);\n                        c.compareTo(peri2) < 0; c = c.add(ONE)){\n\n                    int compare = aabb.compareTo(c.multiply(c));\n                    //if a+b+c > periLimit\n                    if(ab.add(c).compareTo(periLimit) > 0){\n                        break;\n                    }\n                    //if a^2 + b^2\u00a0!= c^2\n                    if(compare < 0){\n                        break;\n                    }else if (compare == 0){\n                        tripCount++;\n                        System.out.print(a + \", \" + b + \", \" + c);\n\n                        //does binary GCD under the hood\n                        if(a.gcd(b).equals(ONE)){\n                            System.out.print(\" primitive\");\n                            primCount++;\n                        }\n                        System.out.println();\n                    }\n                }\n            }\n        }\n        System.out.println(\"Up to a perimeter of \" + periLimit + \", there are \"\n                + tripCount + \" triples, of which \" + primCount + \" are primitive.\");\n    }\n}\n\n\n3, 4, 5 primitive\n5, 12, 13 primitive\n6, 8, 10\n7, 24, 25 primitive\n8, 15, 17 primitive\n9, 12, 15\n9, 40, 41 primitive\n10, 24, 26\n12, 16, 20\n12, 35, 37 primitive\n15, 20, 25\n15, 36, 39\n16, 30, 34\n18, 24, 30\n20, 21, 29 primitive\n21, 28, 35\n24, 32, 40\nUp to a perimeter of 100, there are 17 triples, of which 7 are primitive.\nBrute force primitives with scaling[edit]\n\nParent/child[edit]\nTranslation of: Raku (with limited modification for saving a few BigInteger operations)\nWorks with: Java version 1.5+\n\nimport java.math.BigInteger;\n\npublic class Triples{\n    public static BigInteger LIMIT;\n    public static final BigInteger TWO = BigInteger.valueOf(2);\n    public static final BigInteger THREE = BigInteger.valueOf(3);\n    public static final BigInteger FOUR = BigInteger.valueOf(4);\n    public static final BigInteger FIVE = BigInteger.valueOf(5);\n    public static long primCount = 0;\n    public static long tripCount = 0;\n\n    //I don't know Japanese :p\n    public static void parChild(BigInteger a, BigInteger b, BigInteger c){\n        BigInteger perim = a.add(b).add(c);\n        if(perim.compareTo(LIMIT) > 0) return;\n        primCount++; tripCount += LIMIT.divide(perim).longValue();\n        BigInteger a2 = TWO.multiply(a), b2 = TWO.multiply(b), c2 = TWO.multiply(c),\n                   c3 = THREE.multiply(c);\n        parChild(a.subtract(b2).add(c2),\n                 a2.subtract(b).add(c2),\n                 a2.subtract(b2).add(c3));\n        parChild(a.add(b2).add(c2),\n                 a2.add(b).add(c2),\n                 a2.add(b2).add(c3));\n        parChild(a.negate().add(b2).add(c2),\n                 a2.negate().add(b).add(c2),\n                 a2.negate().add(b2).add(c3));\n    }\n\n    public static void main(String[] args){\n        for(long i = 100; i <= 10000000; i*=10){\n            LIMIT = BigInteger.valueOf(i);\n            primCount = tripCount = 0;\n            parChild(THREE, FOUR, FIVE);\n            System.out.println(LIMIT + \": \" + tripCount + \" triples, \" + primCount + \" primitive.\");\n        }\n    }\n}\n\n\n100: 17 triples, 7 primitive.\n1000: 325 triples, 70 primitive.\n10000: 4858 triples, 703 primitive.\n100000: 64741 triples, 7026 primitive.\n1000000: 808950 triples, 70229 primitive.\n10000000: 9706567 triples, 702309 primitive.\n", "explain": "Output:\nPythagorean triples/Java/Brute force primitives\nThis can also go \"forever\" theoretically. Letting it go to another order of magnitude overflowed the stack on the computer this was tested on. This version also does not show the triples as it goes, it only counts them.\nOutput:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "C#", "code": "\n\nusing System;\n\nnamespace RosettaCode.CSharp\n{\n    class Program\n    {\n        static void Count_New_Triangle(ulong A, ulong B, ulong C, ulong Max_Perimeter, ref ulong Total_Cnt, ref ulong Primitive_Cnt)\n        {\n            ulong Perimeter = A + B + C;\n\n            if (Perimeter <= Max_Perimeter)\n            {\n                Primitive_Cnt = Primitive_Cnt + 1;\n                Total_Cnt = Total_Cnt + Max_Perimeter / Perimeter;\n                Count_New_Triangle(A + 2 * C - 2 * B, 2 * A + 2 * C - B, 2 * A + 3 * C - 2 * B, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);\n                Count_New_Triangle(A + 2 * B + 2 * C, 2 * A + B + 2 * C, 2 * A + 2 * B + 3 * C, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);\n                Count_New_Triangle(2 * B + 2 * C - A, B + 2 * C - 2 * A, 2 * B + 3 * C - 2 * A, Max_Perimeter, ref Total_Cnt, ref Primitive_Cnt);\n            }\n        }\n\n        static void Count_Pythagorean_Triples()\n        {\n            ulong T_Cnt, P_Cnt;\n\n            for (int I = 1; I <= 8; I++)\n            {\n                T_Cnt = 0;\n                P_Cnt = 0;\n                ulong ExponentNumberValue = (ulong)Math.Pow(10, I);\n                Count_New_Triangle(3, 4, 5, ExponentNumberValue, ref T_Cnt, ref P_Cnt);\n                Console.WriteLine(\"Perimeter up to 10E\" + I + \"\u00a0: \" + T_Cnt + \" Triples, \" + P_Cnt + \" Primitives\");\n            }\n        }\n\n        static void Main(string[] args)\n        {\n            Count_Pythagorean_Triples();\n        }\n    }\n}\n\nPerimeter up to 10E1\u00a0: 0 Triples, 0 Primitives\nPerimeter up to 10E2\u00a0: 17 Triples, 7 Primitives\nPerimeter up to 10E3\u00a0: 325 Triples, 70 Primitives\nPerimeter up to 10E4\u00a0: 4858 Triples, 703 Primitives\nPerimeter up to 10E5\u00a0: 64741 Triples, 7026 Primitives\nPerimeter up to 10E6\u00a0: 808950 Triples, 70229 Primitives\nPerimeter up to 10E7\u00a0: 9706567 Triples, 702309 Primitives\nPerimeter up to 10E8\u00a0: 113236940 Triples, 7023027 Primitives\n", "explain": "Based on Ada example, which is a translation of efficient method from C, see the WP article. \nOutput:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nES6[edit]\n\n(() => {\n    \"use strict\";\n\n    // Arguments: predicate, maximum perimeter\n    // pythTripleCount\u00a0:: ((Int, Int, Int) -> Bool) -> Int -> Int\n    const pythTripleCount = p =>\n        maxPerim => {\n            const\n                xs = enumFromTo(1)(\n                    Math.floor(maxPerim / 2)\n                );\n\n            return xs.flatMap(\n                x => xs.slice(x).flatMap(\n                    y => xs.slice(y).flatMap(\n                        z => ((x + y + z <= maxPerim) &&\n                            ((x * x) + (y * y) === z * z) &&\n                            p(x, y, z)) ? [\n                            [x, y, z]\n                        ] : []\n                    )\n                )\n            ).length;\n        };\n\n    // ---------------------- TEST -----------------------\n    const main = () => [10, 100, 1000]\n        .map(n => ({\n            maxPerimeter: n,\n            triples: pythTripleCount(() => true)(n),\n            primitives: pythTripleCount(\n                (x, y) => gcd(x)(y) === 1\n            )(n)\n        }));\n\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // abs\u00a0:: Num -> Num\n    const abs =\n        // Absolute value of a given number\n        // without the sign.\n        x => 0 > x ? (\n            -x\n        ) : x;\n\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = m =>\n        n => Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n\n    // gcd\u00a0:: Integral a => a -> a -> a\n    const gcd = x =>\n        y => {\n            const zero = x.constructor(0);\n            const go = (a, b) =>\n                zero === b ? (\n                    a\n                ) : go(b, a % b);\n\n            return go(abs(x), abs(y));\n        };\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[{\"maxPerimeter\":10, \"triples\":0, \"primitives\":0}, \n {\"maxPerimeter\":100, \"triples\":17, \"primitives\":7}, \n {\"maxPerimeter\":1000, \"triples\":325, \"primitives\":70}]\n\n", "explain": "Exhaustive search of a full cartesian product. Not scalable.\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "PHP", "code": "\n<?php\n \nfunction gcd($a, $b)\n{\n    if ($a == 0)\n       return $b;\n    if ($b == 0)\n       return $a;\n    if($a == $b)\n        return $a;\n    if($a > $b)\n        return gcd($a-$b, $b);\n    return gcd($a, $b-$a);\n}\n\n$pytha = 0;\n$prim = 0;\n$max_p = 100;\n\nfor ($a = 1; $a <= $max_p / 3; $a++) {\n    $aa = $a**2;\n    for ($b = $a + 1; $b < $max_p/2; $b++) {\n        $bb = $b**2;\n        for ($c = $b + 1; $c < $max_p/2; $c++) {\n            $cc = $c**2;\n            if ($aa + $bb < $cc) break;\n            if ($a + $b + $c > $max_p) break;\n\n            if ($aa + $bb == $cc) {\n                $pytha++;\n                if (gcd($a, $b) == 1) $prim++;\n            }\n        }\n    }\n}\n\necho 'Up to ' . $max_p . ', there are ' . $pytha . ' triples, of which ' . $prim . ' are primitive.';\n\n\nOutput:Up to 100, there are 17 triples, of which 7 are primitive.\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nTranslation of: C efficient method\nmodule triples\n  implicit none\n  \n  integer :: max_peri, prim, total\n  integer :: u(9,3) = reshape((/ 1, -2, 2,  2, -1, 2,  2, -2, 3, &\n                                 1,  2, 2,  2,  1, 2,  2,  2, 3, &\n                                -1,  2, 2, -2,  1, 2, -2,  2, 3 /), &\n                                (/ 9, 3 /))\n                                \ncontains\n\nrecursive subroutine new_tri(in)\n  integer, intent(in) :: in(:)\n  integer :: i\n  integer :: t(3), p\n\n  p = sum(in)\n  if (p > max_peri) return\n\n  prim = prim + 1\n  total = total + max_peri / p\n  do i = 1, 3\n    t(1) = sum(u(1:3, i) * in)\n    t(2) = sum(u(4:6, i) * in)\n    t(3) = sum(u(7:9, i) * in)\n    call new_tri(t);\n  end do\nend subroutine new_tri\nend module triples\n\nprogram Pythagorean\n  use triples\n  implicit none\n\n  integer :: seed(3) = (/ 3, 4, 5 /)\n  \n  max_peri = 10\n  do\n    total = 0\n    prim = 0\n    call new_tri(seed)\n    write(*, \"(a, i10, 2(i10, a))\") \"Up to\", max_peri, total, \" triples\",  prim, \" primitives\"\n    if(max_peri == 100000000) exit\n    max_peri = max_peri * 10\n  end do\nend program Pythagorean\n\nOutput:Up to         10          0 triples         0 primitives\nUp to        100         17 triples         7 primitives\nUp to       1000        325 triples        70 primitives\nUp to      10000       4858 triples       703 primitives\nUp to     100000      64741 triples      7026 primitives\nUp to    1000000     808950 triples     70229 primitives\nUp to   10000000    9706567 triples    702309 primitives\nUp to  100000000  113236940 triples   7023027 primitives\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Scratch", "code": "\n\n", "explain": "Scratch is a visual programming language. Click the link, then \"see inside\" to see the code.\nhttps://scratch.mit.edu/projects/79066598/\nOutput: 17 Pythagorean triples with a perimeter less than 100, 7 of which are primitive.\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nvar total, prim, maxPeri int64\n\nfunc newTri(s0, s1, s2 int64) {\n    if p := s0 + s1 + s2; p <= maxPeri {\n        prim++\n        total += maxPeri / p\n        newTri(+1*s0-2*s1+2*s2, +2*s0-1*s1+2*s2, +2*s0-2*s1+3*s2)\n        newTri(+1*s0+2*s1+2*s2, +2*s0+1*s1+2*s2, +2*s0+2*s1+3*s2)\n        newTri(-1*s0+2*s1+2*s2, -2*s0+1*s1+2*s2, -2*s0+2*s1+3*s2)\n    }\n}\n\nfunc main() {\n    for maxPeri = 100; maxPeri <= 1e11; maxPeri *= 10 {\n        prim = 0\n        total = 0\n        newTri(3, 4, 5)\n        fmt.Printf(\"Up to %d:  %d triples, %d primitives\\n\",\n            maxPeri, total, prim)\n    }\n}\n\n\nUp to 100:  17 triples, 7 primitives\nUp to 1000:  325 triples, 70 primitives\nUp to 10000:  4858 triples, 703 primitives\nUp to 100000:  64741 triples, 7026 primitives\nUp to 1000000:  808950 triples, 70229 primitives\nUp to 10000000:  9706567 triples, 702309 primitives\nUp to 100000000:  113236940 triples, 7023027 primitives\nUp to 1000000000:  1294080089 triples, 70230484 primitives\nUp to 10000000000:  14557915466 triples, 702304875 primitives\nUp to 100000000000:  161750315680 triples, 7023049293 primitives\n\n", "explain": "Output:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Ruby", "code": "\nTranslation of: Java\nclass PythagoranTriplesCounter\n  def initialize(limit)\n    @limit = limit\n    @total = 0\n    @primitives = 0\n    generate_triples(3, 4, 5)\n  end\n  attr_reader :total, :primitives\n  \n  private\n  def generate_triples(a, b, c)\n    perim = a + b + c\n    return if perim > @limit\n\n    @primitives += 1\n    @total += @limit / perim\n\n    generate_triples( a-2*b+2*c, 2*a-b+2*c, 2*a-2*b+3*c)\n    generate_triples( a+2*b+2*c, 2*a+b+2*c, 2*a+2*b+3*c)\n    generate_triples(-a+2*b+2*c,-2*a+b+2*c,-2*a+2*b+3*c)\n  end\nend\n\nperim = 10\nwhile perim <= 100_000_000 \n  c = PythagoranTriplesCounter.new perim\n  p [perim, c.total, c.primitives]\n  perim *= 10\nend\n\n\n[10, 0, 0]\n[100, 17, 7]\n[1000, 325, 70]\n[10000, 4858, 703]\n[100000, 64741, 7026]\n[1000000, 808950, 70229]\n[10000000, 9706567, 702309]\n[100000000, 113236940, 7023027]\n", "explain": "output\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Rust", "code": "\nuse std::thread;\n\nfn f1 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut primitive_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        primitive_count +=  1 + f1(triangle[0], triangle[1], triangle[2], d);\n    }\n    primitive_count\n}\n\nfn f2 (a : u64, b : u64, c : u64, d : u64) -> u64 {\n    let mut triplet_count = 0;\n    for triangle in [[a - 2*b + 2*c, 2*a - b + 2*c, 2*a - 2*b + 3*c], \n                     [a + 2*b + 2*c, 2*a + b + 2*c, 2*a + 2*b + 3*c],\n                     [2*b + 2*c - a, b + 2*c - 2*a, 2*b + 3*c - 2*a]] .iter() {\n        let l  = triangle[0] + triangle[1] + triangle[2];\n        if l > d { continue; }\n        triplet_count +=  (d/l) + f2(triangle[0], triangle[1], triangle[2], d);\n    }\n    triplet_count\n}\n\nfn main () {\n    let new_th_1 = thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Primitive triples below {}\u00a0: {}\", i, f1(3, 4, 5, i) + 1);\n            i *= 10;\n        }\n    }).unwrap();\n\n    let new_th_2 =thread::Builder::new().stack_size(32 * 1024 * 1024).spawn (move || {\n        let mut i = 100;\n        while i <= 100_000_000_000 {\n            println!(\" Triples below {}\u00a0: {}\", i, f2(3, 4, 5, i) + i/12);\n            i *= 10;\n        }\n    }).unwrap();\n\n    new_th_1.join().unwrap();\n    new_th_2.join().unwrap();\n}\n\n\nOutput:\n Primitive triples below 100\u00a0: 7\n Triples below 100\u00a0: 17\n Primitive triples below 1000\u00a0: 70\n Triples below 1000\u00a0: 325\n Primitive triples below 10000\u00a0: 703\n Triples below 10000\u00a0: 4858\n Primitive triples below 100000\u00a0: 7026\n Triples below 100000\u00a0: 64741\n Primitive triples below 1000000\u00a0: 70229\n Triples below 1000000\u00a0: 808950\n Primitive triples below 10000000\u00a0: 702309\n Triples below 10000000\u00a0: 9706567\n Primitive triples below 100000000\u00a0: 7023027\n Triples below 100000000\u00a0: 113236940\n Primitive triples below 1000000000\u00a0: 70230484\n Triples below 1000000000\u00a0: 1294080089\n Primitive triples below 10000000000\u00a0: 702304875\n Triples below 10000000000\u00a0: 14557915466\n Primitive triples below 100000000000\u00a0: 7023049293\n Triples below 100000000000\u00a0: 161750315680\n\nreal\t2m22.676s\nuser\t3m39.239s\nsys\t0m0.024s\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Swift", "code": "\nTranslation of: Pascal\nvar total = 0\nvar prim = 0\nvar maxPeri = 100\n\nfunc newTri(s0:Int, _ s1:Int, _ s2: Int) -> () {\n    \n    let p = s0 + s1 + s2\n    if p <= maxPeri {\n        prim += 1\n        total += maxPeri / p\n        newTri( s0 + 2*(-s1+s2), 2*( s0+s2) - s1, 2*( s0-s1+s2) + s2)\n        newTri( s0 + 2*( s1+s2), 2*( s0+s2) + s1, 2*( s0+s1+s2) + s2)\n        newTri(-s0 + 2*( s1+s2), 2*(-s0+s2) + s1, 2*(-s0+s1+s2) + s2)\n    }\n}\n\nwhile maxPeri <= 100_000_000 {\n    prim = 0\n    total = 0\n    newTri(3, 4, 5)\n    print(\"Up to \\(maxPeri)\u00a0: \\(total) triples \\( prim) primitives.\")\n    maxPeri *= 10\n}\n\n\nOutput:\nUp to 100\u00a0: 17 triples 7 primitives.\nUp to 1000\u00a0: 325 triples 70 primitives.\nUp to 10000\u00a0: 4858 triples 703 primitives.\nUp to 100000\u00a0: 64741 triples 7026 primitives.\nUp to 1000000\u00a0: 808950 triples 70229 primitives.\nUp to 10000000\u00a0: 9706567 triples 702309 primitives.\nUp to 100000000\u00a0: 113236940 triples 7023027 primitives.\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Visual_Basic", "code": "\nTranslation of: VBA\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\nWorks with: VBA version Access 97\nWorks with: VBA version 6.5\nWorks with: VBA version 7.1\nOption Explicit\n\nDim total As Long, prim As Long, maxPeri As Long\n\nPublic Sub NewTri(ByVal s0 As Long, ByVal s1 As Long, ByVal s2 As Long)\nDim p As Long, x1 As Long, x2 As Long\n    p = s0 + s1 + s2\n    If p <= maxPeri Then\n        prim = prim + 1\n        total = total + maxPeri \\ p\n        x1 = s0 + s2\n        x2 = s1 + s2\n        NewTri s0 + 2 * (-s1 + s2), 2 * x1 - s1, 2 * (x1 - s1) + s2\n        NewTri s0 + 2 * x2, 2 * x1 + s1, 2 * (x1 + s1) + s2\n        NewTri -s0 + 2 * x2, 2 * (-s0 + s2) + s1, 2 * (-s0 + x2) + s2\n    End If\nEnd Sub\n\nPublic Sub Main()\n    maxPeri = 100\n    Do While maxPeri <= 10& ^ 8\n        prim = 0\n        total = 0\n        NewTri 3, 4, 5\n        Debug.Print \"Up to \"; maxPeri; \": \"; total; \" triples, \"; prim; \" primitives.\"\n        maxPeri = maxPeri * 10\n    Loop\nEnd Sub\n\n\nOutput:\nUp to  100\u00a0:  17  triples,  7  primitives.\nUp to  1000\u00a0:  325  triples,  70  primitives.\nUp to  10000\u00a0:  4858  triples,  703  primitives.\nUp to  100000\u00a0:  64741  triples,  7026  primitives.\nUp to  1000000\u00a0:  808950  triples,  70229  primitives.\nUp to  10000000\u00a0:  9706567  triples,  702309  primitives.\nUp to  100000000\u00a0:  113236940  triples,  7023027  primitives.\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;\n\nprocedure Pythagorean_Triples is\n\n   type Large_Natural is range 0 .. 2**63-1;\n     -- this is the maximum for gnat\n\n   procedure New_Triangle(A, B, C: Large_Natural;\n                          Max_Perimeter: Large_Natural;\n                          Total_Cnt, Primitive_Cnt: in out Large_Natural) is\n      Perimeter: constant Large_Natural := A + B + C;\n   begin\n      if Perimeter <= Max_Perimeter then\n         Primitive_Cnt := Primitive_Cnt + 1;\n         Total_Cnt     := Total_Cnt + Max_Perimeter / Perimeter;\n         New_Triangle(A-2*B+2*C,     2*A-B+2*C,    2*A-2*B+3*C,   Max_Perimeter, Total_Cnt, Primitive_Cnt);\n         New_Triangle(A+2*B+2*C,     2*A+B+2*C,    2*A+2*B+3*C,   Max_Perimeter, Total_Cnt, Primitive_Cnt);\n         New_Triangle(2*B+2*C-A,     B+2*C-2*A,    2*B+3*C-2*A,   Max_Perimeter, Total_Cnt, Primitive_Cnt);\n      end if;\n   end New_Triangle;\n\n   T_Cnt, P_Cnt: Large_Natural;\n\nbegin\n   for I in 1 .. 9 loop\n      T_Cnt := 0;\n      P_Cnt := 0;\n      New_Triangle(3,4,5, 10**I, Total_Cnt => T_Cnt, Primitive_Cnt => P_Cnt);\n      Ada.Text_IO.Put_Line(\"Up to 10 **\" & Integer'Image(I) & \"\u00a0:\" &\n                             Large_Natural'Image(T_Cnt) & \" Triples,\" &\n                             Large_Natural'Image(P_Cnt) & \" Primitives\");\n   end loop;\nend Pythagorean_Triples;\n\n\nUp to 10 ** 1\u00a0: 0 Triples, 0 Primitives\nUp to 10 ** 2\u00a0: 17 Triples, 7 Primitives\nUp to 10 ** 3\u00a0: 325 Triples, 70 Primitives\nUp to 10 ** 4\u00a0: 4858 Triples, 703 Primitives\nUp to 10 ** 5\u00a0: 64741 Triples, 7026 Primitives\nUp to 10 ** 6\u00a0: 808950 Triples, 70229 Primitives\nUp to 10 ** 7\u00a0: 9706567 Triples, 702309 Primitives\nUp to 10 ** 8\u00a0: 113236940 Triples, 7023027 Primitives\nUp to 10 ** 9\u00a0: 1294080089 Triples, 70230484 Primitives\n", "explain": "Translation of efficient method from C, see the WP article. Compiles on gnat/gcc. \nOutput:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Julia", "code": "\n\nfunction primitiven{T<:Integer}(m::T)\n    1 < m || return T[]\n    m != 2 || return T[1]\n    !isprime(m) || return T[2:2:m-1]\n    rp = trues(m-1)\n    if isodd(m)\n        rp[1:2:m-1] = false\n    end\n    for p in keys(factor(m))\n        rp[p:p:m-1] = false\n    end\n    T[1:m-1][rp]\nend\n\nfunction pythagoreantripcount{T<:Integer}(plim::T)\n    primcnt = 0\n    fullcnt = 0\n    11 < plim || return (primcnt, fullcnt)\n    for m in 2:plim\n        p = 2m^2\n        p+2m <= plim || break\n        for n in primitiven(m)\n            q = p + 2m*n\n            q <= plim || break\n            primcnt += 1\n            fullcnt += div(plim, q)\n        end\n    end\n    return (primcnt, fullcnt)\nend\n\nprintln(\"Counting Pythagorian Triplets within perimeter limits:\")\nprintln(\"    Limit          All   Primitive\")\nfor om in 1:10\n    (pcnt, fcnt) = pythagoreantripcount(10^om)\n    println(@sprintf \"    10^%02d  %11d   %9d\" om fcnt pcnt)\nend\n\n\nOutput:\nCounting Pythagorian Triplets within perimeter limits:\n    Limit          All   Primitive\n    10^01            0           0\n    10^02           17           7\n    10^03          325          70\n    10^04         4858         703\n    10^05        64741        7026\n    10^06       808950       70229\n    10^07      9706567      702309\n    10^08    113236940     7023027\n    10^09   1294080089    70230484\n    10^10  14557915466   702304875\n\n", "explain": "This solution uses the the Euclidian concept of m and n as generators of Pythagorean triplets.  When m and n are coprime and have opposite parity, the generated triplets are primitive.  It works reasonably well up to a limit of 10^10.\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Kotlin", "code": "\nTranslation of: Go\n\n// version 1.1.2\n\nvar total = 0L\nvar prim = 0L\nvar maxPeri = 0L\n\nfun newTri(s0: Long, s1: Long, s2: Long) {\n    val p = s0 + s1 + s2\n    if (p <= maxPeri) {\n        prim++\n        total += maxPeri / p\n        newTri( s0 - 2 * s1 + 2 * s2,  2 * s0 - s1 + 2 * s2,  2 * s0 - 2 * s1 + 3 * s2)\n        newTri( s0 + 2 * s1 + 2 * s2,  2 * s0 + s1 + 2 * s2,  2 * s0 + 2 * s1 + 3 * s2)\n        newTri(-s0 + 2 * s1 + 2 * s2, -2 * s0 + s1 + 2 * s2, -2 * s0 + 2 * s1 + 3 * s2)\n    }\n}\n\nfun main(args: Array<String>) {\n    maxPeri = 100\n    while (maxPeri <= 10_000_000_000L) {\n        prim = 0\n        total = 0\n        newTri(3, 4, 5)\n        println(\"Up to $maxPeri: $total triples, $prim primatives\")\n        maxPeri *= 10\n    }\n}\n\n\nOutput:\nUp to 100: 17 triples, 7 primatives\nUp to 1000: 325 triples, 70 primatives\nUp to 10000: 4858 triples, 703 primatives\nUp to 100000: 64741 triples, 7026 primatives\nUp to 1000000: 808950 triples, 70229 primatives\nUp to 10000000: 9706567 triples, 702309 primatives\nUp to 100000000: 113236940 triples, 7023027 primatives\nUp to 1000000000: 1294080089 triples, 70230484 primatives\nUp to 10000000000: 14557915466 triples, 702304875 primatives\n\n", "explain": "Due to deep recursion, I needed to increase the stack size to 4MB to get up to a maximum perimeter of 10 billion. Expect a run time of around 30 seconds on a typical laptop.\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Perl", "code": "\nsub gcd {\n    my ($n, $m) = @_;\n    while($n){\n        my $t = $n;\n        $n = $m % $n;\n        $m = $t;\n    }\n    return $m;\n}\n\nsub tripel {\n    my $pmax  = shift;\n    my $prim  = 0;\n    my $count = 0;\n    my $nmax = sqrt($pmax)/2;\n    for( my $n=1; $n<=$nmax; $n++ ) {\n        for( my $m=$n+1; (my $p = 2*$m*($m+$n)) <= $pmax; $m+=2 ) {\n            next unless 1==gcd($m,$n);\n            $prim++;\n            $count += int $pmax/$p;\n        }\n    }\n    printf \"Max. perimeter: %d, Total: %d, Primitive: %d\\n\", $pmax, $count, $prim;\n}\n\ntripel 10**$_ for 1..8;\n\n\nOutput:\nMax. perimeter: 10, Total: 0, Primitive: 0\nMax. perimeter: 100, Total: 17, Primitive: 7\nMax. perimeter: 1000, Total: 325, Primitive: 70\nMax. perimeter: 10000, Total: 4858, Primitive: 703\nMax. perimeter: 100000, Total: 64741, Primitive: 7026\nMax. perimeter: 1000000, Total: 808950, Primitive: 70229\nMax. perimeter: 10000000, Total: 9706567, Primitive: 702309\nMax. perimeter: 100000000, Total: 113236940, Primitive: 7023027\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Prolog", "code": "\nshow :-\n    Data = [100, 1_000, 10_000, 100_000, 1_000_000, 10_000_000, 100_000_000],\n    forall(\n        member(Max, Data),\n        (count_triples(Max, Total, Prim),\n         format(\"upto ~D, there are ~D Pythagorean triples (~D primitive.)~n\", [Max, Total, Prim]))).\n\ndiv(A, B, C) :- C is A div B.\n\ncount_triples(Max, Total, Prims) :-\n    findall(S, (triple(Max, A, B, C), S is A + B + C), Ps),\n    length(Ps, Prims),\n    maplist(div(Max), Ps, Counts), sumlist(Counts, Total).\n\n% - between_by/4\n\nbetween_by(A, B, N, K) :-\n    C is (B - A) div N,\n    between(0, C, J),\n    K is N*J + A.\n\n% - Pythagorean triple generator\n\ntriple(P, A, B, C) :-\n    Max is floor(sqrt(P/2)) - 1,\n    between(0, Max, M),\n    Start is (M /\\ 1) + 1, succ(Pm, M),\n    between_by(Start, Pm, 2, N),\n    gcd(M, N) =:= 1,\n    X is M*M - N*N,\n    Y is 2*M*N,\n    C is M*M + N*N,\n    order2(X, Y, A, B),\n    (A + B + C) =< P.\n\norder2(A, B, A, B) :- A < B, !.\norder2(A, B, B, A).\n\n\nOutput:\n?- show.\nupto 100, there are 17 Pythagorean triples (7 primitive.)\nupto 1,000, there are 325 Pythagorean triples (70 primitive.)\nupto 10,000, there are 4,857 Pythagorean triples (702 primitive.)\nupto 100,000, there are 64,741 Pythagorean triples (7,026 primitive.)\nupto 1,000,000, there are 808,950 Pythagorean triples (70,229 primitive.)\nupto 10,000,000, there are 9,706,567 Pythagorean triples (702,309 primitive.)\nupto 100,000,000, there are 113,236,940 Pythagorean triples (7,023,027 primitive.)\ntrue.\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Scala", "code": "\n\nOutput:Best seen running in your browser either by ScalaFiddle (ES aka JavaScript, non JVM) or Scastie (remote JVM).\nobject PythagoreanTriples extends App {\n\n  println(\"               Limit Primatives          All\")\n\n  for {e <- 2 to 7\n       limit = math.pow(10, e).longValue()\n  } {\n    var primCount, tripCount = 0\n\n    def parChild(a: BigInt, b: BigInt, c: BigInt): Unit = {\n      val perim = a + b + c\n      val (a2, b2, c2, c3) = (2 * a, 2 * b, 2 * c, 3 * c)\n      if (limit >= perim) {\n        primCount += 1\n        tripCount += (limit / perim).toInt\n        parChild(a - b2 + c2, a2 - b + c2, a2 - b2 + c3)\n        parChild(a + b2 + c2, a2 + b + c2, a2 + b2 + c3)\n        parChild(-a + b2 + c2, -a2 + b + c2, -a2 + b2 + c3)\n      }\n    }\n\n    parChild(BigInt(3), BigInt(4), BigInt(5))\n    println(f\"a + b + c <= ${limit.toFloat}%3.1e  $primCount%9d $tripCount%12d\")\n  }\n}\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "D", "code": "\nLazy Functional Version[edit]\n\nvoid main() @safe {\n    import std.stdio, std.range, std.algorithm, std.typecons, std.numeric;\n\n    enum triples = (in uint n) pure nothrow @safe /*@nogc*/ =>\n        iota(1, n + 1)\n        .map!(z => iota(1, z + 1)\n                   .map!(x => iota(x, z + 1).map!(y => tuple(x, y, z))))\n        .joiner.joiner\n        .filter!(t => t[0] ^^ 2 + t[1] ^^ 2 == t[2] ^^ 2 && t[].only.sum <= n)\n        .map!(t => tuple(t[0 .. 2].gcd == 1, t[]));\n\n    auto xs = triples(100);\n    writeln(\"Up to 100 there are \", xs.count, \" triples, \",\n            xs.filter!q{ a[0] }.count, \" are primitive.\");\n}\n\n\nOutput:\nUp to 100 there are 17 triples, 7 are primitive.\nShorter Version[edit]\nulong[2] tri(ulong lim, ulong a=3, ulong b=4, ulong c=5)\npure nothrow @safe @nogc {\n    immutable l = a + b + c;\n    if (l > lim)\n        return [0, 0];\n    typeof(return) r = [1, lim / l];\n    r[] += tri(lim,  a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c)[];\n    r[] += tri(lim,  a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c)[];\n    r[] += tri(lim, -a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c)[];\n    return r;\n}\n\nvoid main() /*@safe*/ {\n    import std.stdio;\n    foreach (immutable p; 1 .. 9)\n        writeln(10 ^^ p, ' ', tri(10 ^^ p));\n}\n\n\nOutput:\n10 [0, 0]\n100 [7, 17]\n1000 [70, 325]\n10000 [703, 4858]\n100000 [7026, 64741]\n1000000 [70229, 808950]\n10000000 [702309, 9706567]\n100000000 [7023027, 113236940]\n\nShort SIMD Version[edit]\n\nimport std.stdio, core.simd;\n\nulong2 tri(in ulong lim, in ulong a=3, in ulong b=4, in ulong c=5)\npure nothrow @safe @nogc {\n    immutable l = a + b + c;\n    if (l > lim)\n        return [0, 0];\n    typeof(return) r = [1, lim / l];\n    r += tri(lim,  a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c);\n    r += tri(lim,  a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c);\n    r += tri(lim, -a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c);\n    return r;\n}\n\nvoid main() /*@safe*/ {\n    foreach (immutable p; 1 .. 9)\n        writeln(10 ^^ p, ' ', tri(10 ^^ p).array);\n}\n\n\nFaster Version[edit]\nTranslation of: C\nimport std.stdio;\n\nalias Xuint = uint; // ulong if going over 1 billion.\n\n__gshared Xuint nTriples, nPrimitives, limit;\n\nvoid countTriples(Xuint x, Xuint y, Xuint z) nothrow @nogc {\n    while (true) {\n        immutable p = x + y + z;\n        if (p > limit)\n            return;\n\n        nPrimitives++;\n        nTriples += limit / p;\n\n        auto t0 = x - 2 * y + 2 * z;\n        auto t1 = 2 * x - y + 2 * z;\n        auto t2 = t1 - y + z;\n        countTriples(t0, t1, t2);\n\n        t0 += 4 * y;\n        t1 += 2 * y;\n        t2 += 4 * y;\n        countTriples(t0, t1, t2);\n\n        z = t2 - 4 * x;\n        y = t1 - 4 * x;\n        x = t0 - 2 * x;\n    }\n}\n\nvoid main() {\n    foreach (immutable p; 1 .. 9) {\n        limit = Xuint(10) ^^ p;\n        nTriples = nPrimitives = 0;\n        countTriples(3, 4, 5);\n        writefln(\"Up to %11d: %11d triples, %9d primitives.\",\n                 limit, nTriples, nPrimitives);\n    }\n}\n\n\nOutput:\nUp to          10:           0 triples,         0 primitives.\nUp to         100:          17 triples,         7 primitives.\nUp to        1000:         325 triples,        70 primitives.\nUp to       10000:        4858 triples,       703 primitives.\nUp to      100000:       64741 triples,      7026 primitives.\nUp to     1000000:      808950 triples,     70229 primitives.\nUp to    10000000:     9706567 triples,    702309 primitives.\nUp to   100000000:   113236940 triples,   7023027 primitives.\n\nUp to          10:           0 triples,         0 primitives.\nUp to         100:          17 triples,         7 primitives.\nUp to        1000:         325 triples,        70 primitives.\nUp to       10000:        4858 triples,       703 primitives.\nUp to      100000:       64741 triples,      7026 primitives.\nUp to     1000000:      808950 triples,     70229 primitives.\nUp to    10000000:     9706567 triples,    702309 primitives.\nUp to   100000000:   113236940 triples,   7023027 primitives.\nUp to  1000000000:  1294080089 triples,  70230484 primitives.\nUp to 10000000000: 14557915466 triples, 702304875 primitives.\n\nUp to           10:            0 triples,         0 primitives.\nUp to          100:           17 triples,         7 primitives.\nUp to         1000:          325 triples,        70 primitives.\nUp to        10000:         4858 triples,       703 primitives.\nUp to       100000:        64741 triples,      7026 primitives.\nUp to      1000000:       808950 triples,     70229 primitives.\nUp to     10000000:      9706567 triples,    702309 primitives.\nUp to    100000000:    113236940 triples,   7023027 primitives.\nUp to   1000000000:   1294080089 triples,  70230484 primitives.\nUp to  10000000000:  14557915466 triples, 702304875 primitives.\nUp to 100000000000: 161750315680 triples, 7023049293 primitives.\n", "explain": "With hints from the Haskell solution.\nRun-time (32 bit system): about 0.80 seconds with ldc2.\nWith LDC compiler this is a little faster than the precedent version (remove @nogc to compile it with the current version of LDC compiler).\nThe output is the same. Run-time (32 bit system): about 0.67 seconds with ldc2.\nRun-time: about 0.27 seconds with ldc2.\nUsing the power p up to 11, using ulong for xuint, and compiling with the dmd -L/STACK:10000000 switch to increase the stack size to about 10MB:\nTotal run-time up to 10_000_000_000: about 63 seconds.\nWaiting less than half an hour:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Haskell", "code": "\npytr :: Int -> [(Bool, Int, Int, Int)]\npytr n =\n  filter\n    (\\(_, a, b, c) -> a + b + c <= n)\n    [ (prim a b c, a, b, c)\n      | a <- xs,\n        b <- drop a xs,\n        c <- drop b xs,\n        a ^ 2 + b ^ 2 == c ^ 2\n    ]\n  where\n    xs = [1 .. n]\n    prim a b _ = gcd a b == 1\n\nmain :: IO ()\nmain =\n  putStrLn $\n    \"Up to 100 there are \"\n      <> show (length xs)\n      <> \" triples, of which \"\n      <> show (length $ filter (\\(x, _, _, _) -> x) xs)\n      <> \" are primitive.\"\n  where\n    xs = pytr 100\n\n\nOutput:\nUp to 100 there are 17 triples, of which 7 are primitive.\n\n------------------- PYTHAGOREAN TRIPLES ------------------\n\npythagoreanTriplesBelow :: Int -> [[Int]]\npythagoreanTriplesBelow n =\n  concatMap\n    ( \\x ->\n        concatMap\n          (\\y -> concatMap (go x y) [y + 1 .. m])\n          [x + 1 .. m]\n    )\n    [1 .. m]\n  where\n    m = quot n 2\n    go x y z\n      | x + y + z <= n && x ^ 2 + y ^ 2 == z ^ 2 =\n        [[x, y, z]]\n      | otherwise = []\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_\n    (print . length)\n    ( [id, filter (\\[x, y, _] -> gcd x y == 1)]\n        <*> [pythagoreanTriplesBelow 100]\n    )\n\n\nOutput:\n17\n7\n\ntriangles :: Int -> [[Int]]\ntriangles max_peri\n  | max_peri < 12 = []\n  | otherwise = concat tiers\n  where\n    tiers = takeWhile (not . null) $ iterate tier [[3, 4, 5]]\n    tier = concatMap (filter ((<= max_peri) . sum) . tmul)\n    tmul t =\n      map\n        (map (sum . zipWith (*) t))\n        [ [[1, -2, 2], [2, -1, 2], [2, -2, 3]],\n          [[1, 2, 2], [2, 1, 2], [2, 2, 3]],\n          [[-1, 2, 2], [-2, 1, 2], [-2, 2, 3]]\n        ]\n\ntriangleCount max_p = (length t, sum $ map ((max_p `div`) . sum) t)\n  where\n    t = triangles max_p\n\nmain :: IO ()\nmain =\n  mapM_\n    ((putStrLn . (\\n -> show n <> \" \" <> show (triangleCount n))) . (10 ^))\n    [1 .. 7]\n\n\nOutput:\n10 (0,0)\n100 (7,17)\n1000 (70,325)\n10000 (703,4858)\n100000 (7026,64741)\n1000000 (70229,808950)\n10000000 (702309,9706567)\n", "explain": "Or equivalently (desugaring the list comprehension down to nested concatMaps, and pruning back the search space a little):\nRecursive primitive generation:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "VBScript", "code": "\nTranslation of: Perl\nFor i=1 To 8\n\tWScript.StdOut.WriteLine triples(10^i)\nNext\n\nFunction triples(pmax)\n\tprim=0 : count=0 : nmax=Sqr(pmax)/2 : n=1\n\tDo While n <= nmax\n\t\tm=n+1 : p=2*m*(m+n)\n\t\tDo While p <= pmax\n\t\t\tIf gcd(m,n)=1 Then\n\t\t\t\tprim=prim+1\n\t\t\t\tcount=count+Int(pmax/p)\n\t\t\tEnd If\n\t\t\tm=m+2\n\t\t\tp=2*m*(m+n)\n\t\tLoop\n\t\tn=n+1\n\tLoop \n\ttriples = \"Max Perimeter: \" & pmax &_\n\t\t\t\t\", Total: \" & count &_\n\t\t\t\t\", Primitive: \" & prim\nEnd Function\n\nFunction gcd(a,b)\n\tc = a : d = b\n\tDo\n\t\tIf c Mod d > 0 Then\n\t\t\te = c Mod d\n\t\t\tc = d\n\t\t\td = e\n\t\tElse\n\t\t\tgcd = d\n\t\t\tExit Do\n\t\tEnd If\n\tLoop\nEnd Function\n\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Scheme", "code": "\nWorks with: Gauche Scheme\n(use srfi-42)\n\n(define (py perim)\n  (define prim 0)\n  (values\n    (sum-ec\n      (: c perim) (: b c) (: a b)\n      (if (and (<= (+ a b c) perim)\n               (= (square c) (+ (square b) (square a)))))\n      (begin (when (= 1 (gcd a b)) (inc! prim)))\n      1)\n    prim))\n\n\ngosh> (py 100)\n17\n7\n\n", "explain": "Testing:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "PowerShell", "code": "\nfunction triples($p) {\n    if($p -gt 4) {\n        # ai + bi + ci = pi <= p\n        # ai < bi < ci --> 3ai < pi <= p and ai + 2bi < pi <= p\n        $pa = [Math]::Floor($p/3)\n        1..$pa | foreach {\n            $ai = $_\n            $pb = [Math]::Floor(($p-$ai)/2)\n            ($ai+1)..$pb | foreach {\n                $bi = $_\n                $pc = $p-$ai-$bi\n                ($bi+1)..$pc | where {\n                    $ci = $_\n                    $pi = $ai + $bi + $ci\n                    $ci*$ci -eq $ai*$ai + $bi*$bi\n                 } | \n                foreach { \n                    [pscustomobject]@{\n                        a = \"$ai\"\n                        b = \"$bi\"\n                        c = \"$ci\"\n                        p = \"$pi\"\n                    }\n                }\n            }\n        }\n    }\n    else {\n        Write-Error \"$p is not greater than 4\"\n    }   \n}\nfunction gcd ($a, $b)  {\n    function pgcd ($n, $m)  {\n        if($n -le $m) { \n            if($n -eq 0) {$m}\n            else{pgcd $n ($m%$n)}\n        }\n        else {pgcd $m $n}\n    }\n    $n = [Math]::Abs($a)\n    $m = [Math]::Abs($b)\n    (pgcd $n $m)\n}\n$triples = (triples 100)\n \n$coprime = $triples | \nwhere {((gcd $_.a $_.b) -eq 1) -and ((gcd $_.a $_.c) -eq 1) -and  ((gcd $_.b $_.c) -eq 1)}\n \n\"There are $(($triples).Count) Pythagorean triples with perimeter no larger than 100\n and $(($coprime).Count) of them are coprime.\"\n\n\nThere are 17 Pythagorean triples with perimeter no larger than 100 and 7 of them are coprime.\n\n", "explain": "Output:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "F#", "code": "\nTranslation of: OCaml\nlet isqrt n =\n    let rec iter t =\n        let d = n - t*t\n        if (0 <= d) && (d < t+t+1) // t*t <= n < (t+1)*(t+1)\n        then t else iter ((t+(n/t))/2)\n    iter 1\n \nlet rec gcd a b =\n    let t = a % b\n    if t = 0 then b else gcd b t\n \nlet coprime a b = gcd a b = 1\n \nlet num_to ms =\n    let mutable ctr = 0\n    let mutable prim_ctr = 0\n    let max_m = isqrt (ms/2)\n    for m = 2 to max_m do\n        for j = 0 to (m/2) - 1 do\n            let n = m-(2*j+1)\n            if coprime m n then\n                let s = 2*m*(m+n)\n                if s <= ms then\n                    ctr <- ctr + (ms/s)\n                    prim_ctr <- prim_ctr + 1\n    (ctr, prim_ctr)\n \nlet show i =\n    let s, p = num_to i in\n    printfn \"For perimeters up to %d there are %d total and %d primitive\" i s p;;\n \nList.iter show [ 100; 1000; 10000; 100000; 1000000; 10000000; 100000000 ]\n\n\nOutput:\nFor perimeters up to 100 there are 17 total and 7 primitive\nFor perimeters up to 1000 there are 325 total and 70 primitive\nFor perimeters up to 10000 there are 4858 total and 703 primitive\nFor perimeters up to 100000 there are 64741 total and 7026 primitive\nFor perimeters up to 1000000 there are 808950 total and 70229 primitive\nFor perimeters up to 10000000 there are 9706567 total and 702309 primitive\nFor perimeters up to 100000000 there are 113236940 total and 7023027 primitive\n", "explain": ""}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "Groovy", "code": "\nParent/Child Algorithm[edit]\n\nclass Triple {\n    BigInteger a, b, c\n    def getPerimeter() { this.with { a + b + c } }\n    boolean isValid() { this.with { a*a + b*b == c*c } }\n}\n\ndef initCounts (def n = 10) {\n    (n..1).collect { 10g**it }.inject ([:]) { Map map, BigInteger perimeterLimit ->\n        map << [(perimeterLimit): [primative: 0g, total: 0g]]\n    }\n}\n\ndef findPythagTriples, findChildTriples\n\nfindPythagTriples = {Triple t = new Triple(a:3, b:4, c:5), Map counts = initCounts() ->\n    def p = t.perimeter\n    def currentCounts = counts.findAll { pLimit, tripleCounts -> p <= pLimit }\n    if (! currentCounts || ! t.valid) { return }\n    currentCounts.each { pLimit, tripleCounts ->\n        tripleCounts.with { primative ++; total += pLimit.intdiv(p) }\n    }\n    findChildTriples(t, currentCounts)\n    counts\n}\n\nfindChildTriples = { Triple t, Map counts ->\n    t.with {\n        [\n            [ a - 2*b + 2*c,  2*a - b + 2*c,  2*a - 2*b + 3*c],\n            [ a + 2*b + 2*c,  2*a + b + 2*c,  2*a + 2*b + 3*c],\n            [-a + 2*b + 2*c, -2*a + b + 2*c, -2*a + 2*b + 3*c]\n        ]*.sort().each { aa, bb, cc ->\n            findPythagTriples(new Triple(a:aa, b:bb, c:cc), counts)\n        }\n    }\n}\n\n\nprintf ('    LIMIT       PRIMATIVE          ALL\\n')\nfindPythagTriples().sort().each { perimeterLimit, result ->\n    def exponent = perimeterLimit.toString().size() - 1\n    printf ('a+b+c <= 10E%2d  %9d %12d\\n', exponent, result.primative, result.total)\n}\n\n\n    LIMIT       PRIMATIVE          ALL\na+b+c <= 10E 1          0            0\na+b+c <= 10E 2          7           17\na+b+c <= 10E 3         70          325\na+b+c <= 10E 4        703         4858\na+b+c <= 10E 5       7026        64741\na+b+c <= 10E 6      70229       808950\na+b+c <= 10E 7     702309      9706567\na+b+c <= 10E 8    7023027    113236940\na+b+c <= 10E 9   70230484   1294080089\na+b+c <= 10E10  702304875  14557915466\n", "explain": "Solution:\nTest:\nOutput:\n"}, {"task_name": "Pythagorean triples", "task_url": "https://rosettacode.org/wiki/Pythagorean_triples", "task_cat": "Geometry", "lang": "AWK", "code": "\n# syntax: GAWK -f PYTHAGOREAN_TRIPLES.AWK\n# converted from Go\nBEGIN {\n    printf(\"%5s %11s %11s %11s %s\\n\",\"limit\",\"limit\",\"triples\",\"primitives\",\"seconds\")\n    for (max_peri=10; max_peri<=1E9; max_peri*=10) {\n      t = systime()\n      prim = 0\n      total = 0\n      new_tri(3,4,5)\n      printf(\"10^%-2d %11d %11d %11d %d\\n\",++n,max_peri,total,prim,systime()-t)\n    }\n    exit(0)\n}\nfunction new_tri(s0,s1,s2,  p) {\n    p = s0 + s1 + s2\n    if (p <= max_peri) {\n      prim++\n      total += int(max_peri / p)\n      new_tri(+1*s0-2*s1+2*s2,+2*s0-1*s1+2*s2,+2*s0-2*s1+3*s2)\n      new_tri(+1*s0+2*s1+2*s2,+2*s0+1*s1+2*s2,+2*s0+2*s1+3*s2)\n      new_tri(-1*s0+2*s1+2*s2,-2*s0+1*s1+2*s2,-2*s0+2*s1+3*s2)\n    }\n}\n\n\nOutput:\nlimit       limit     triples  primitives seconds\n10^1           10           0           0 0\n10^2          100          17           7 0\n10^3         1000         325          70 0\n10^4        10000        4858         703 0\n10^5       100000       64741        7026 0\n10^6      1000000      808950       70229 0\n10^7     10000000     9706567      702309 2\n10^8    100000000   113236940     7023027 12\n10^9   1000000000  1294080089    70230484 116\n\n", "explain": ""}]