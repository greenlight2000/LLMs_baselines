[{"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Python", "code": "\nPython: Iterative, with tests[edit]\n'''\nNote that this code is broken, e.g., it won't work when \nblocks = [(\"A\", \"B\"), (\"A\",\"C\")] and the word is \"AB\", where the answer\nshould be True, but the code returns False.\n'''\nblocks = [(\"B\", \"O\"),\n          (\"X\", \"K\"),\n          (\"D\", \"Q\"),\n          (\"C\", \"P\"),\n          (\"N\", \"A\"),\n          (\"G\", \"T\"),\n          (\"R\", \"E\"),\n          (\"T\", \"G\"),\n          (\"Q\", \"D\"),\n          (\"F\", \"S\"),\n          (\"J\", \"W\"),\n          (\"H\", \"U\"),\n          (\"V\", \"I\"),\n          (\"A\", \"N\"),\n          (\"O\", \"B\"),\n          (\"E\", \"R\"),\n          (\"F\", \"S\"),\n          (\"L\", \"Y\"),\n          (\"P\", \"C\"),\n          (\"Z\", \"M\")]\n\n\ndef can_make_word(word, block_collection=blocks):\n    \"\"\"\n    Return True if `word` can be made from the blocks in `block_collection`.\n\n    >>> can_make_word(\"\")\n    False\n    >>> can_make_word(\"a\")\n    True\n    >>> can_make_word(\"bark\")\n    True\n    >>> can_make_word(\"book\")\n    False\n    >>> can_make_word(\"treat\")\n    True\n    >>> can_make_word(\"common\")\n    False\n    >>> can_make_word(\"squad\")\n    True\n    >>> can_make_word(\"coNFused\")\n    True\n    \"\"\"\n    if not word:\n        return False\n\n    blocks_remaining = block_collection[:]\n    for char in word.upper():\n        for block in blocks_remaining:\n            if char in block:\n                blocks_remaining.remove(block)\n                break\n        else:\n            return False\n    return True\n\n\nif __name__ == \"__main__\":\n    import doctest\n    doctest.testmod()\n    print(\", \".join(\"'%s': %s\" % (w, can_make_word(w)) for w in\n                    [\"\", \"a\", \"baRk\", \"booK\", \"treat\", \n                     \"COMMON\", \"squad\", \"Confused\"]))\n\n\nOutput:\n'': False, 'a': True, 'baRk': True, 'booK': False, 'treat': True, 'COMMON': False, 'squad': True, 'Confused': True\nPython: Recursive[edit]\nBLOCKS = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\ndef _abc(word, blocks):\n    for i, ch in enumerate(word):\n        for blk in (b for b in blocks if ch in b):\n            whatsleft = word[i + 1:]\n            blksleft = blocks[:]\n            blksleft.remove(blk)\n            if not whatsleft: \n                return True, blksleft\n            if not blksleft: \n                return False, blksleft\n            ans, blksleft = _abc(whatsleft, blksleft)\n            if ans:\n                return ans, blksleft\n        else:\n            break\n    return False, blocks\n\ndef abc(word, blocks=BLOCKS):\n    return _abc(word.upper(), blocks)[0]\n\nif __name__ == '__main__':\n    for word in [''] + 'A BARK BoOK TrEAT COmMoN SQUAD conFUsE'.split():\n        print('Can we spell %9r? %r' % (word, abc(word)))\n\n\nOutput:\nCan we spell       ''? False\nCan we spell       'A'? True\nCan we spell    'BARK'? True\nCan we spell    'BoOK'? False\nCan we spell   'TrEAT'? True\nCan we spell  'COmMoN'? False\nCan we spell   'SQUAD'? True\nCan we spell 'conFUsE'? True\nPython: Recursive, telling how[edit]\ndef mkword(w, b):\n    if not w: return []\n\n    c,w = w[0],w[1:]\n    for i in range(len(b)):\n        if c in b[i]:\n            m = mkword(w, b[0:i] + b[i+1:])\n            if m != None: return [b[i]] + m\n\ndef abc(w, blk):\n    return mkword(w.upper(), [a.upper() for a in blk])\n\nblocks = 'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM'.split()\n\nfor w in \", A, bark, book, treat, common, SQUAD, conFUsEd\".split(', '):\n    print '\\'' + w + '\\'' + ' ->', abc(w, blocks)\n\n\nOutput:\n\n'' -> []\n'A' -> ['NA']\n'bark' -> ['BO', 'NA', 'RE', 'XK']\n'book' -> None\n'treat' -> ['GT', 'RE', 'ER', 'NA', 'TG']\n'common' -> None\n'SQUAD' -> ['FS', 'DQ', 'HU', 'NA', 'QD']\n'conFUsEd' -> ['CP', 'BO', 'NA', 'FS', 'HU', 'FS', 'RE', 'DQ']\n\n", "explain": "Note the case of empty list returned for empty string; whether it means true or false is up to you.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <ctype.h>\n\nint can_make_words(char **b, char *word)\n{\n\tint i, ret = 0, c = toupper(*word);\n\n#define SWAP(a, b) if (a\u00a0!= b) { char * tmp = a; a = b; b = tmp; }\n\n\tif (!c) return 1;\n\tif (!b[0]) return 0;\n\n\tfor (i = 0; b[i] && !ret; i++) {\n\t\tif (b[i][0] != c && b[i][1] != c) continue;\n\t\tSWAP(b[i], b[0]);\n\t\tret = can_make_words(b + 1, word + 1);\n\t\tSWAP(b[i], b[0]);\n\t}\n\n\treturn ret;\n}\n\nint main(void)\n{\n\tchar* blocks[] = {\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \n\t\t\"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \n\t\t\"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n\t\t0 };\n\n\tchar *words[] = {\n\t\t\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\", 0\n\t};\n\n\tchar **w;\n\tfor (w = words; *w; w++)\n\t\tprintf(\"%s\\t%d\\n\", *w, can_make_words(blocks, *w));\n\n\treturn 0;\n}\n\n\nOutput:\n        1\nA       1\nBARK    1\nBOOK    0\nTREAT   1\nCOMMON  0\nSQUAD   1\nConfuse 1\n\n", "explain": "Recursive solution. Empty string returns true.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "C++", "code": "\nWorks with: C++11\n\ng++-4.7 -Wall -std=c++0x abc.cpp\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <set>\n#include <cctype>\n\ntypedef std::pair<char,char> item_t;\ntypedef std::vector<item_t> list_t;\n\nbool can_make_word(const std::string& w, const list_t& vals) {\n    std::set<uint32_t> used;\n    while (used.size() < w.size()) {\n        const char c = toupper(w[used.size()]);\n        uint32_t x = used.size();\n        for (uint32_t i = 0, ii = vals.size(); i < ii; ++i) {\n            if (used.find(i) == used.end()) {\n                if (toupper(vals[i].first) == c || toupper(vals[i].second) == c) {\n                    used.insert(i);\n                    break;\n                }\n            }\n        }\n        if (x == used.size()) break;\n    }\n    return used.size() == w.size();\n}\n\nint main() {\n    list_t vals{ {'B','O'}, {'X','K'}, {'D','Q'}, {'C','P'}, {'N','A'}, {'G','T'}, {'R','E'}, {'T','G'}, {'Q','D'}, {'F','S'}, {'J','W'}, {'H','U'}, {'V','I'}, {'A','N'}, {'O','B'}, {'E','R'}, {'F','S'}, {'L','Y'}, {'P','C'}, {'Z','M'} };\n    std::vector<std::string> words{\"A\",\"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"};\n    for (const std::string& w : words) {\n        std::cout << w << \": \" << std::boolalpha << can_make_word(w,vals) << \".\\n\";\n    }\n}\n\n\nOutput:\nA: true.\nBARK: true.\nBOOK: false.\nTREAT: true.\nCOMMON: false.\nSQUAD: true.\nCONFUSE: true.\n\n", "explain": "Build with:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Java", "code": "\nTranslation of: C\nWorks with: Java version 1.6+\nimport java.util.Arrays;\nimport java.util.Collections;\nimport java.util.List;\n\npublic class ABC {\n\n    public static void main(String[] args) {\n        List<String> blocks = Arrays.asList(\n                \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n                \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n                \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\");\n\n        for (String word : Arrays.asList(\"\", \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\")) {\n            System.out.printf(\"%s: %s%n\", word.isEmpty() ? \"\\\"\\\"\" : word, canMakeWord(word, blocks));\n        }\n    }\n\n    public static boolean canMakeWord(String word, List<String> blocks) {\n        if (word.isEmpty())\n            return true;\n\n        char c = word.charAt(0);\n        for (int i = 0; i < blocks.size(); i++) {\n            String b = blocks.get(i);\n            if (b.charAt(0) != c && b.charAt(1) != c)\n                continue;\n            Collections.swap(blocks, 0, i);\n            if (canMakeWord(word.substring(1), blocks.subList(1, blocks.size())))\n                return true;\n            Collections.swap(blocks, 0, i);\n        }\n\n        return false;\n    }\n}\n\n\nOutput:\n\"\": true\nA: true\nBARK: true\nbook: false\ntreat: true\nCOMMON: false\nSQuAd: true\nCONFUSE: true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "C#", "code": "\nRegex[edit]\n\nusing System;\nusing System.IO;\n// Needed for the method.\nusing System.Text.RegularExpressions;\nusing System.Collections.Generic;\n\nvoid Main()\n{\n   string blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n   List<string> words = new List<string>() {\n      \"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"\n   };\n\n   foreach(var word in words)\n   {\n      Console.WriteLine(\"{0}: {1}\", word, CheckWord(blocks, word));\n   }\n}\n\nbool CheckWord(string blocks, string word)\n{\n   for(int i = 0; i < word.Length; ++i)\n   {\n      int length = blocks.Length;\n      Regex rgx = new Regex(\"([a-z]\"+word[i]+\"|\"+word[i]+\"[a-z])\", RegexOptions.IgnoreCase);\n      blocks = rgx.Replace(blocks, \"\", 1);\n      if(blocks.Length == length) return false;\n   }\n   return true;\n}\n\n\nOutput:\nA: True\nBARK: True\nBOOK: False\nTREAT: True\nCOMMON: False\nSQUAD: True\nCONFUSE: True\n\n\nusing System.Collections.Generic;\nusing System.Linq;\n\nvoid Main()\n{\n\tList<string> blocks =\n\tnew List<string>() { \"bo\", \"xk\", \"dq\", \"cp\", \"na\", \"gt\", \"re\", \"tg\", \"qd\", \"fs\",\n\t\t\"jw\", \"hu\", \"vi\", \"an\", \"ob\", \"er\", \"fs\", \"ly\", \"pc\", \"zm\" };\n\tList<string> words = new List<string>() {\n\t\t\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"};\n\t\n\tvar solver = new ABC(blocks);\n\t\n\tforeach( var word in words)\n\t{\n\t\tConsole.WriteLine(\"{0}\u00a0:{1}\", word, solver.CanMake(word));\n\t}\n}\n\nclass ABC\n{\n\treadonly Dictionary<char, List<int>> _blockDict = new Dictionary<char, List<int>>();\n\tbool[] _used;\n\tint _nextBlock;\n\n\treadonly List<string> _blocks;\n\n\tprivate void AddBlockChar(char c)\n\t{\n\t\tif (!_blockDict.ContainsKey(c))\n\t\t{\n\t\t\t_blockDict[c] = new List<int>();\n\t\t}\n\t\t_blockDict[c].Add(_nextBlock);\n\t}\n\n\tprivate void AddBlock(string block)\n\t{\n\t\tAddBlockChar(block[0]);\n\t\tAddBlockChar(block[1]);\n\t\t_nextBlock++;\n\t}\n\n\tpublic ABC(List<string> blocks)\n\t{\n\t\t_blocks = blocks;\n\t\tforeach (var block in blocks)\n\t\t{\n\t\t\tAddBlock(block);\n\t\t}\n\t}\n\n\tpublic bool CanMake(string word)\n\t{\n\t\tword = word.ToLower();\n\t\tif (word.Length > _blockDict.Count)\n\t\t{\n\t\t\treturn false;\n\t\t}\n\t\t_used = new bool[_blocks.Count];\n\t\treturn TryMake(word);\n\t}\n\n\tpublic bool TryMake(string word)\n\t{\n\t\tif (word == string.Empty)\n\t\t{\n\t\t\treturn true;\n\t\t}\n\t\tvar blocks = _blockDict[word[0]].Where(b => !_used[b]);\n\t\tforeach (var block in blocks)\n\t\t{\n\t\t\t_used[block] = true;\n\t\t\tif (TryMake(word.Substring(1)))\n\t\t\t{\n\t\t\t\treturn true;\n\t\t\t}\n\t\t\t_used[block] = false;\n\t\t}\n\t\treturn false;\n\t}\n}\n\n\nOutput:\nA :True\nBARK :True\nBOOK :False\nTREAT :True\nCOMMON :False\nSQUAD :True\nCONFUSE :True\n", "explain": "This Method uses regular expressions to do the checking. Given that n = length of blocks string and \nm = length of word string, then CheckWord's time complexity comes out to about m*(n - (m-1)/2).\nUnoptimized\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\nES5[edit]\nImperative[edit]\n\nvar blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\n\nfunction CheckWord(blocks, word) {\n   // Makes sure that word only contains letters.\n   if(word !== /([a-z]*)/i.exec(word)[1]) return false;\n   // Loops through each character to see if a block exists.\n   for(var i = 0; i < word.length; ++i)\n   {\n      // Gets the ith character.\n      var letter = word.charAt(i);\n      // Stores the length of the blocks to determine if a block was removed.\n      var length = blocks.length;\n      // The regexp gets constructed by eval to allow more browsers to use the function.\n      var reg = eval(\"/([a-z]\"+letter+\"|\"+letter+\"[a-z])/i\");\n      // This does the same as above, but some browsers do not support...\n      //var reg = new RegExp(\"([a-z]\"+letter+\"|\"+letter+\"[a-z])\", \"i\");\n      // Removes all occurrences of the match. \n      blocks = blocks.replace(reg, \"\");\n      // If the length did not change then a block did not exist.\n      if(blocks.length === length) return false;\n   }\n   // If every character has passed then return true.\n   return true;\n};\n\nvar words = [\n   \"A\",\n   \"BARK\", \n   \"BOOK\", \n   \"TREAT\", \n   \"COMMON\", \n   \"SQUAD\", \n   \"CONFUSE\" \n];\n\nfor(var i = 0;i<words.length;++i)\n   console.log(words[i] + \": \" + CheckWord(blocks, words[i]));\n\n\nA: true\nBARK: true\nBOOK: false\nTREAT: true\nCOMMON: false\nSQUAD: true\nCONFUSE: true\n\nFunctional[edit]\n(function (strWords) {\n\n    var strBlocks =\n        'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM',\n        blocks = strBlocks.split(' ');\n\n    function abc(lstBlocks, strWord) {\n        var lngChars = strWord.length;\n\n        if (!lngChars) return [];\n\n        var b = lstBlocks[0],\n            c = strWord[0];\n\n        return chain(lstBlocks, function (b) {\n            return (b.indexOf(c.toUpperCase()) !== -1) ? [\n                (b + ' ').concat(\n                    abc(removed(b, lstBlocks), strWord.slice(1)))\n            ] : [];\n        })\n    }\n\n    // Monadic bind (chain) for lists\n    function chain(xs, f) {\n        return [].concat.apply([], xs.map(f));\n    }\n\n    // a -> [a] -> [a]\n    function removed(x, xs) {\n        var h = xs.length ? xs[0] : null,\n            t = h ? xs.slice(1) : [];\n\n        return h ? (\n            h === x ? t : [h].concat(removed(x, t))\n        ) : [];\n    }\n\n    function solution(strWord) {\n        var strAttempt = abc(blocks, strWord)[0].split(',')[0];\n\n        // two chars per block plus one space -> 3\n        return strWord + ((strAttempt.length === strWord.length * 3) ?\n            ' -> ' + strAttempt : ': [no solution]');\n    }\n\n    return strWords.split(' ').map(solution).join('\\n');\n\n})('A bark BooK TReAT COMMON squAD conFUSE');\n\n\nOutput:\nA -> NA \nbark -> BO NA RE XK \nBooK: [no solution]\nTReAT -> GT RE ER NA TG \nCOMMON: [no solution]\nsquAD -> FS DQ HU NA QD \nconFUSE -> CP BO NA FS HU FS RE\n\nES6[edit]\nImperative[edit]\nlet characters = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\";\nlet blocks = characters.split(\" \").map(pair => pair.split(\"\"));\n \nfunction isWordPossible(word) {\n  var letters = [...word.toUpperCase()];\n  var length = letters.length;\n  var copy = new Set(blocks);\n\n  for (let letter of letters) {\n    for (let block of copy) {\n      let index = block.indexOf(letter);\n \n      if (index !== -1) {\n        length--;\n        copy.delete(block);\n        break;  \n      }\n    }\n\n  }\n  return !length;\n}    \n \n[ \n  \"A\", \n  \"BARK\", \n  \"BOOK\", \n  \"TREAT\", \n  \"COMMON\", \n  \"SQUAD\", \n  \"CONFUSE\" \n].forEach(word => console.log(`${word}: ${isWordPossible(word)}`));\n\n\nA: true\nBARK: true\nBOOK: false\nTREAT: true\nCOMMON: false\nSQUAD: true\nCONFUSE: true\n\nFunctional[edit]\nTranslation of: Haskell\n(() => {\n    \"use strict\";\n\n    // ------------------- ABC BLOCKS --------------------\n\n    // spellWith\u00a0:: [(Char, Char)] -> [Char] -> [[(Char, Char)]]\n    const spellWith = blocks =>\n        wordChars => !Boolean(wordChars.length) ? [\n            []\n        ] : (() => {\n            const [x, ...xs] = wordChars;\n\n            return blocks.flatMap(\n                b => b.includes(x) ? (\n                    spellWith(\n                        deleteBy(\n                            p => q => (p[0] === q[0]) && (\n                                p[1] === q[1]\n                            )\n                        )(b)(blocks)\n                    )(xs)\n                    .flatMap(bs => [b, ...bs])\n                ) : []\n            );\n        })();\n\n\n    // ---------------------- TEST -----------------------\n    const main = () => {\n        const blocks = (\n            \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n        ).split(\" \");\n\n        return [\n                \"\", \"A\", \"BARK\", \"BoOK\", \"TrEAT\",\n                \"COmMoN\", \"SQUAD\", \"conFUsE\"\n            ]\n            .map(\n                x => JSON.stringify([\n                    x, !Boolean(\n                        spellWith(blocks)(\n                            [...x.toLocaleUpperCase()]\n                        )\n                        .length\n                    )\n                ])\n            )\n            .join(\"\\n\");\n    };\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // deleteBy\u00a0:: (a -> a -> Bool) -> a -> [a] -> [a]\n    const deleteBy = fEq =>\n        x => {\n            const go = xs => Boolean(xs.length) ? (\n                fEq(x)(xs[0]) ? (\n                    xs.slice(1)\n                ) : [xs[0], ...go(xs.slice(1))]\n            ) : [];\n\n            return go;\n        };\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[\"\",true]\n[\"A\",true]\n[\"BARK\",true]\n[\"BoOK\",false]\n[\"TrEAT\",true]\n[\"COmMoN\",false]\n[\"SQUAD\",true]\n[\"conFUsE\",true]\n", "explain": "The following method uses regular expressions and the string replace function to allow more support for older browsers.\nResult:\nResult: \n\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "PHP", "code": "\n<?php\n$words = array(\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"Confuse\");\n\nfunction canMakeWord($word) {\n    $word = strtoupper($word);\n    $blocks = array(\n            \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\",\n            \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n            \"JW\", \"HU\", \"VI\", \"AN\", \"OB\",\n            \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\",\n    );\n\n    foreach (str_split($word) as $char) {\n        foreach ($blocks as $k => $block) {\n            if (strpos($block, $char) !== FALSE) {\n                unset($blocks[$k]);\n                continue(2);\n            }\n        }\n        return false;\n    }\n    return true;\n}\n\nforeach ($words as $word) {\n    echo $word.': ';\n    echo canMakeWord($word) ? \"True\" : \"False\";\n    echo \"\\r\\n\";\n}\n\n\nOutput:\nA: True\nBARK: True\nBOOK: False\nTREAT: True\nCOMMON: False\nSQUAD: True\nConfuse: True\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Fortran", "code": "\n\n!-*- mode: compilation; default-directory: \"/tmp/\" -*-\n!Compilation started at Thu Jun  5 01:52:03\n!\n!make f && for a in '' a bark book treat common squad confuse\u00a0; do echo $a | ./f\u00a0; done\n!gfortran -std=f2008 -Wall -fopenmp -ffree-form -fall-intrinsics -fimplicit-none -g f.f08 -o f\n! T                      \n! T  A                    NA\n! T  BARK                 BO NA RE XK\n! F  BOOK                 OB BO -- --\n! T  TREAT                GT RE ER NA TG\n! F  COMMON               PC OB ZM -- -- --\n! T  SQUAD                FS DQ HU NA QD\n! T  CONFUSE              CP BO NA FS HU FS RE\n!\n!Compilation finished at Thu Jun  5 01:52:03\n\nprogram abc\n  implicit none\n  integer, parameter :: nblocks = 20\n  character(len=nblocks) :: goal\n  integer, dimension(nblocks) :: solution\n  character(len=2), dimension(0:nblocks) :: blocks_copy, blocks = &\n       &(/'--','BO','XK','DQ','CP','NA','GT','RE','TG','QD','FS','JW','HU','VI','AN','OB','ER','FS','LY','PC','ZM'/)\n  logical :: valid\n  integer :: i, iostat\n  read(5,*,iostat=iostat) goal\n  if (iostat .ne. 0) goal = ''\n  call ucase(goal)\n  solution = 0\n  blocks_copy = blocks\n  valid = assign_block(goal(1:len_trim(goal)), blocks, solution, 1)\n  write(6,*) valid, ' '//goal, (' '//blocks_copy(solution(i)), i=1,len_trim(goal))\n\ncontains\n\n  recursive function assign_block(goal, blocks, solution, n) result(valid)\n    implicit none\n    logical :: valid\n    character(len=*), intent(in) :: goal\n    character(len=2), dimension(0:), intent(inout) :: blocks\n    integer, dimension(:), intent(out) :: solution\n    integer, intent(in) :: n\n    integer :: i\n    character(len=2) :: backing_store\n    valid = .true.\n    if (len(goal)+1 .eq. n) return\n    do i=1, size(blocks)\n       if (index(blocks(i),goal(n:n)) .ne. 0) then\n          backing_store = blocks(i)\n          blocks(i) = ''\n          solution(n) = i\n          if (assign_block(goal, blocks, solution, n+1)) return\n          blocks(i) = backing_store\n       end if\n    end do\n    valid = .false.\n    return\n  end function assign_block\n\n  subroutine ucase(a)\n    implicit none\n    character(len=*), intent(inout) :: a\n    integer :: i, j\n    do i = 1, len_trim(a)\n       j = index('abcdefghijklmnopqrstuvwxyz',a(i:i))\n       if (j .ne. 0) a(i:i) = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'(j:j)\n    end do\n  end subroutine ucase\n\nend program abc\n\nBut if backtracking might be needed[edit]\n\n      MODULE PLAYPEN\t!Messes with a set of alphabet blocks.\n       INTEGER MSG\t\t!Output unit number.\n       PARAMETER (MSG = 6)\t!Standard output.\n       INTEGER MS\t\t!I dislike unidentified constants...\n       PARAMETER (MS = 2)\t!So this is the maximum number of lettered sides.\n       INTEGER LETTER(26),SUPPLY(26)\t!For counting the alphabet.\n       CONTAINS\n        SUBROUTINE SWAP(I,J)\t!This really should be known to the compiler.\n         INTEGER I,J,K\t\t!Which could generate in-place code,\n          K = I\t\t\t!Using registers, maybe.\n          I = J\t\t\t!Or maybe, there are special op-codes.\n          J = K\t\t\t!Rather than this clunkiness.\n        END SUBROUTINE SWAP\t!And it should be for any type of thingy.\n\n        INTEGER FUNCTION LSTNB(TEXT)  !Sigh. Last Not Blank.\nConcocted yet again by R.N.McLean (whom God preserve) December MM.\nCode checking reveals that the Compaq compiler generates a copy of the string and then finds the length of that when using the latter-day intrinsic LEN_TRIM. Madness!\nCan't   DO WHILE (L.GT.0 .AND. TEXT(L:L).LE.' ')\t!Control chars. regarded as spaces.\nCurse the morons who think it good that the compiler MIGHT evaluate logical expressions fully.\nCrude GO TO rather than a DO-loop, because compilers use a loop counter as well as updating the index variable.\nComparison runs of GNASH showed a saving of ~3% in its mass-data reading through the avoidance of DO in LSTNB alone.\nCrappy code for character comparison of varying lengths is avoided by using ICHAR which is for single characters only.\nChecking the indexing of CHARACTER variables for bounds evoked astounding stupidities, such as calculating the length of TEXT(L:L) by subtracting L from L!\nComparison runs of GNASH showed a saving of ~25-30% in its mass data scanning for this, involving all its two-dozen or so single-character comparisons, not just in LSTNB.\n         CHARACTER*(*),INTENT(IN):: TEXT\t!The bumf. If there must be copy-in, at least there need not be copy back.\n         INTEGER L\t\t!The length of the bumf.\n          L = LEN(TEXT)\t\t!So, what is it?\n    1     IF (L.LE.0) GO TO 2\t!Are we there yet?\n          IF (ICHAR(TEXT(L:L)).GT.ICHAR(\" \")) GO TO 2\t!Control chars are regarded as spaces also.\n          L = L - 1\t\t!Step back one.\n          GO TO 1\t\t!And try again.\n    2     LSTNB = L\t\t!The last non-blank, possibly zero.\n         RETURN\t\t\t!Unsafe to use LSTNB as a variable.\n        END FUNCTION LSTNB\t!Compilers can bungle it.\n\n        SUBROUTINE LETTERCOUNT(TEXT)\t!Count the occurrences of A-Z.\n         CHARACTER*(*) TEXT\t!The text to inspect.\n         INTEGER I,K\t\t!Assistants.\n          DO I = 1,LEN(TEXT)\t\t!Step through the text.\n            K = ICHAR(TEXT(I:I)) - ICHAR(\"A\") + 1\t!This presumes that A-Z have contiguous codes!\n            IF (K.GE.1 .AND. K.LE.26) LETTER(K) = LETTER(K) + 1\t!Not so with EBCDIC!!\n          END DO\t\t\t!On to the next letter.\n        END SUBROUTINE LETTERCOUNT\t!Be careful with LETTER.\n\n        SUBROUTINE UPCASE(TEXT)\t!In the absence of an intrinsic...\nConverts any lower case letters in TEXT to upper case...\nConcocted yet again by R.N.McLean (whom God preserve) December MM.\nConverting from a DO loop evades having both an iteration counter to decrement and an index variable to adjust.\n         CHARACTER*(*) TEXT\t!The stuff to be modified.\nc        CHARACTER*26 LOWER,UPPER\t!Tables. a-z may not be contiguous codes.\nc        PARAMETER (LOWER = \"abcdefghijklmnopqrstuvwxyz\")\nc        PARAMETER (UPPER = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\nCAREFUL!! The below relies on a-z and A-Z being contiguous, as is NOT the case with EBCDIC.\n         INTEGER I,L,IT\t\t!Fingers.\n          L = LEN(TEXT)\t\t!Get a local value, in case LEN engages in oddities.\n          I = L\t\t\t!Start at the end and work back..\n    1     IF (I.LE.0) RETURN \t!Are we there yet? Comparison against zero should not require a subtraction.\nc         IT = INDEX(LOWER,TEXT(I:I))\t!Well?\nc         IF (IT .GT. 0) TEXT(I:I) = UPPER(IT:IT)\t!One to convert?\n          IT = ICHAR(TEXT(I:I)) - ICHAR(\"a\")\t\t!More symbols precede \"a\" than \"A\".\n          IF (IT.GE.0 .AND. IT.LE.25) TEXT(I:I) = CHAR(IT + ICHAR(\"A\"))\t!In a-z? Convert!\n          I = I - 1\t\t\t!Back one.\n          GO TO 1\t\t\t!Inspect..\n        END SUBROUTINE UPCASE\t!Easy.\n\n        SUBROUTINE ORDERSIDE(LETTER)\t!Puts the letters into order.\n         CHARACTER*(*) LETTER\t!The letters.\n         INTEGER I,N,H\t\t!Assistants.\n         CHARACTER*1 T\t\t!A scratchpad.\n         LOGICAL CURSE\t\t!A bit.\n          N = LEN(LETTER)\t!So, how many letters?\n          H = N - 1\t\t!Last - First, and not +1.\n          IF (H.LE.0) RETURN\t!Ha ha.\n    1     H = MAX(1,H*10/13)\t\t!The special feature.\n          IF (H.EQ.9 .OR. H.EQ.10) H = 11\t!A twiddle.\n          CURSE = .FALSE.\t\t!So far, so good.\n          DO I = N - H,1,-1\t\t!If H = 1, this is a BubbleSort.\n            IF (LETTER(I:I).LT.LETTER(I + H:I + H)) THEN\t!One compare.\n              T = LETTER(I:I)\t\t\t!One swap.\n              LETTER(I:I) = LETTER(I + H:I + H)\t!Alas, no SWAP(A,B)\n              LETTER(I + H:I + H) = T\t\t!Is recognised by the compiler.\n              CURSE = .TRUE.\t\t!If once a tiger is seen...\n            END IF\t\t\t!So much for that comparison.\n          END DO\t\t\t!On to the next.\n          IF (CURSE .OR. H.GT.1) GO TO 1!Another pass?\n        END SUBROUTINE ORDERSIDE\t!Simple enough.\n        SUBROUTINE ORDERBLOCKS(N,SOME)\t!Puts the collection of blocks into order.\n         INTEGER N\t\t!The number of blocks.\n         CHARACTER*(*) SOME(:)\t!Their lists of letters.\n         INTEGER I,H\t\t!Assistants.\n         CHARACTER*(LEN(SOME(1))) T\t!A scratchpad matching an element of SOME.\n         LOGICAL CURSE\t\t\t!Since there is still no SWAP(SOME(I),SOME(I + H)).\n          H = N - 1\t\t!So here comes another CombSort.\n          IF (H.LE.0) RETURN\t!With standard suspicion.\n    1     H = MAX(1,H*10/13)\t\t!This is the outer loop.\n          IF (H.EQ.9 .OR. H.EQ.10) H = 11\t!This is a fiddle.\n          CURSE = .FALSE.\t\t!Start the next pass in hope.\n          DO I = N - H,1,-1\t\t!Going backwards, just for fun.\n            IF (SOME(I).LT.SOME(I + H)) THEN\t!So then?\n              T = SOME(I)\t\t!Disorder.\n              SOME(I) = SOME(I + H)\t!So once again,\n              SOME(I + H) = T\t\t!Swap the two miscreants.\n              CURSE = .TRUE.\t\t!And remember.\n            END IF\t\t\t!So much for that comparison.\n          END DO\t\t\t!On to the next.\n          IF (CURSE .OR. H.GT.1) GO TO 1!Are we there yet?\n        END SUBROUTINE ORDERBLOCKS\t!Not much code, but ringing the changes is still tedious.\n\n        SUBROUTINE PLAY(N,SOME)\t!Mess about with the collection of blocks.\n         INTEGER N\t\t!Their number.\n         CHARACTER*(*) SOME(:)\t!Their letters.\n         INTEGER NH,HIT(N)\t!A list of blocks.\n         INTEGER B,I,J,K,L,M\t!Assistants.\n         CHARACTER*1 C\t\t!A letter of the moment.\n          L = LEN(SOME(1))\t!The maximum number of letters to any block.\nCast the collection on to the floor.\n          WRITE (MSG,1) N,L,SOME\t!Announce the set as it is supplied.\n    1     FORMAT (I7,\" blocks, with at most\",I2,\" letters:\",66(1X,A))\nChange the \"orientation\" of some blocks.\n          DO B = 1,N\t\t!Step through each block.\n            CALL UPCASE(SOME(B))\t!Paranoia rules.\n            CALL ORDERSIDE(SOME(B))\t!Put its letter list into order.\n          END DO\t\t!On to the next block.\n          WRITE (MSG,2) SOME\t!Reveal the orderly array.\n    2     FORMAT (6X,\"... the letters in reverse order:\",66(1X,A))\nCollate the collection of blocks.\n          CALL ORDERBLOCKS(N,SOME)\t!Now order the blocks by their letters.\n          WRITE (MSG,3) SOME\t\t!Reveal them in neato order.\n    3     FORMAT (7X,\"... the blocks in reverse order:\",66(1X,A))\nCount the appearances of the letters of the alphabet.\n          LETTER = 0\t\t!Enough of shuffling blocks around.\n          DO B = 1,N\t\t!Now inspect their collective letters.\n            CALL LETTERCOUNT(SOME(B))\t!A block's worth at a go.\n          END DO\t\t!On to the next block.\n          SUPPLY = LETTER\t!Save the counts of supplied letters.\n          WRITE (MSG,4) (CHAR(ICHAR(\"A\") + I - 1),I = 1,26),SUPPLY\t!Results.\n    4     FORMAT (15X,\"Letters of the alphabet:\",26A<MS + 1>,/,\t!First, a line with A ... Z.\n     1     11X,\"... number thereof supplied:\",26I<MS + 1>)\t!Then a line of the associated counts.\nCheck for blocks with duplicated letters.\n          WRITE (MSG,5)\t\t!Announce.\n    5     FORMAT (8X,\"Blocks with duplicated letters:\",$)\t!Further output impends.\n          M = 0\t\t\t!No duplication found.\n          DO B = 1,N\t\t!So step through each block.\n         JJ:DO J = 2,L\t\t\t!Inspecting successive letters of the block,\n              IF (SOME(B)(J:J).LE.\" \") EXIT JJ\t!Provided they've not run out.\n              DO K = 1,J - 1\t\t\t!To see if it has appeared earlier.\n                IF (SOME(B)(K:K).LE.\" \") EXIT JJ!Reverse order means that spaces will be at the end!\n                IF (SOME(B)(J:J).EQ.SOME(B)(K:K)) THEN\t!Well?\n                  M = M + 1\t\t!A match!\n                  WRITE (MSG,6) SOME(B)\t!Name the block.\n    6             FORMAT (1X,A,$)\t!With further output still impending,\n                  EXIT JJ\t\t!And give up on this block.\n                END IF\t\t\t!One duplicated letter is sufficient for its downfall.\n              END DO\t\t\t!Next letter up.\n            END DO JJ\t\t\t!On to the next letter of the block.\n          END DO\t\t!On to the next block.\n          CALL HIC(M)\t\t!Show the count and end the line.\nCheck for duplicate blocks, knowing that the array of blocks is ordered.\n          WRITE (MSG,7)\t\t!Announce.\n    7     FORMAT (21X,\"Duplicated blocks:\",$)\t!Again, leave the line dangling.\n          K = 0\t\t\t!No duplication found.\n          B = 1\t\t\t!Syncopation.\n   70     B = B + 1\t\t!Advance one.\n          IF (B.GT.N) GO TO 72\t!Are we there yet?\n          IF (SOME(B).NE.SOME(B - 1)) GO TO 70\t!No match? Search on.\n          K = K + 1\t\t!A match is counted.\n          WRITE (MSG,6) SOME(B)\t!Name it.\n   71     B = B + 1\t\t!And speed through continued matching.\n          IF (B.GT.N) GO TO 72\t!Unless we're of the end.\n          IF (SOME(B).EQ.SOME(B - 1)) GO TO 71\t!Continued matching?\n          GO TO 70\t\t!Mismatch: resume the normal scan.\n   72     CALL HIC(K)\t\t!So much for that.\nCheck for duplicated letters across different blocks.\n          IF (ALL(SUPPLY.LE.1)) RETURN\t!Unless there are no duplicated letters.\n          WRITE (MSG,8)\t\t!Announce.\n    8     FORMAT (\"Duplicated letters on different blocks:\",$)\t!More to come.\n          K = 0\t\t!Start another count.\n          DO I = 1,26\t\t!A well-known span.\n            IF (SUPPLY(I).LE.1) CYCLE\t!Any duplicated letters?\n            C = CHAR(ICHAR(\"A\") + I - 1)!Yes. This is the character.\n            NH = 0\t\t!So, how many blocks contribute?\n            DO B = 1,N\t\t!Find out.\n              IF (INDEX(SOME(B),C).GT.0) THEN\t!On this block?\n                NH = NH + 1\t\t!Yes.\n                HIT(NH) = B\t\t!Keep track of which.\n              END IF\t\t\t!So much for that block.\n            END DO\t\t!On to the next.\n            IF (ANY(SOME(HIT(2:NH)) .NE. SOME(HIT(1)))) THEN\t!All have the same collection of letters?\n              K = K + 1\t\t\t!No!\n              WRITE (MSG,9) C\t\t!Name the heterogenously supported letter.\n    9         FORMAT (A<MS + 1>,$)\t!Use the same spacing even though one character only.\n            END IF\t\t!So much for that letter's search.\n          END DO\t\t!On to the next letter.\n          CALL HIC(K)\t!Finish the line with the count report.\n         CONTAINS\t!This is used often enough.\n          SUBROUTINE HIC(N)\t!But has very specific context.\n           INTEGER N\t\t\t!The count.\n            IF (N.LE.0) WRITE (MSG,*) \"None.\"\t!Yes, we have no bananas.\n            IF (N.GT.0) WRITE (MSG,*) N\t\t!Either way, end the line.\n          END SUBROUTINE HIC\t!This service routine is not needed elsewhere.\n        END SUBROUTINE PLAY\t!Look mummy! All the blockses are neatened!\n\n        LOGICAL FUNCTION CANBLOCK(WORD,N,SOME)\t!Can the blocks spell out the word?\nCreates a move tree based on the letters of WORD and for each, the blocks available.\n         CHARACTER*(*) WORD\t!The word to spell out.\n         INTEGER N\t\t!The number of blocks.\n         CHARACTER*(*) SOME(:)\t!The blocks and their letters.\n         INTEGER NA,AVAIL(N)\t!Say not the struggle naught availeth!\n         INTEGER NMOVE(LEN(WORD))\t!I need a list of acceptable blocks,\n         INTEGER MOVE(LEN(WORD),N)\t!One list for each letter of WORD.\n         INTEGER I,L,S\t\t!Assistants.\n         CHARACTER*1 C\t\t!The letter of the moment.\n          CANBLOCK = .FALSE.\t\t!Initial pessimism.\n          L = LSTNB(WORD)\t\t!Ignore trailing spaces.\n          IF (L.GT.N) RETURN\t\t!Enough blocks?\n          LETTER = 0\t\t\t\t!To make rabbit stew,\n          CALL LETTERCOUNT(WORD(1:L))\t\t!First catch your rabbit.\n          IF (ANY(SUPPLY .LT. LETTER)) RETURN\t!The larder is lacking.\n          NA = N\t\t\t!Prepare a list.\n          FORALL (I = 1:N) AVAIL(I) = I\t!That fingers every block.\n          I = 0\t\t!Step through the letters of the WORD.\nChug through the letters of the WORD.\n    1     I = I + 1\t!One letter after the other.\n          IF (I.GT.L) GO TO 100\t!Yay! We're through!\n          C = WORD(I:I)\t\t!The letter of the moment.\n          NMOVE(I) = 0\t\t!No moves known at this new level.\n          DO S = 1,NA\t\t!So, look for them amongst the available slots.\n            IF (INDEX(SOME(AVAIL(S)),C) .GT. 0) THEN\t!A hit?\n              NMOVE(I) = NMOVE(I) + 1\t!Yes! Count up another possible move.\n              MOVE(I,NMOVE(I)) = S\t!Remember its slot.\n            END IF\t\t\t!So much for that block.\n          END DO\t\t!On to the next.\n    2     IF (NMOVE(I).GT.0) THEN\t!Have we any moves?\n            S = MOVE(I,NMOVE(I))\t!Yes! Recover the last found.\n            NMOVE(I) = NMOVE(I) - 1\t!Uncount, as it is about to be used.\n            IF (S.NE.NA) CALL SWAP(AVAIL(S),AVAIL(NA))\t!This block is no longer available.\n            NA = NA - 1\t\t\t!Shift the boundary back.\n            GO TO 1\t\t\t!Try the next letter!\n          END IF\t\t!But if we can't find a move at that level...\n          I = I - 1\t\t!Retreat a level.\n          IF (I.LE.0) RETURN\t!Oh dear!\n          S = MOVE(I,NMOVE(I) + 1)\t!Undo the move that had been made at this level.\n          NA = NA + 1\t\t\t!And make its block is re-available.\n          IF (S.NE.NA) CALL SWAP(AVAIL(S),AVAIL(NA))\t!Move it back.\n          GO TO 2\t\t!See what moves remain at this level.\nCompleted!\n  100     CANBLOCK = .TRUE.\t!That's a relief.\n        END FUNCTION CANBLOCK\t!Some revisions might have been made.\n      END MODULE PLAYPEN\t!No sand here.\n\n      USE PLAYPEN\t!Just so.\n      INTEGER HAVE,TESTS\t\t!Parameters for the specified problem.\n      PARAMETER (HAVE = 20, TESTS = 7)\t!Number of blocks, number of tests.\n      CHARACTER*(MS) BLOCKS(HAVE)\t!Have blocks, will juggle.\n      DATA BLOCKS/\"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\t!The specified set\n     1            \"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"/\t!Of letter blocks.\n      CHARACTER*8 WORD(TESTS)\t\t!Now for the specified test words.\n      LOGICAL ANS(TESTS),T,F\t\t!And the given results.\n      PARAMETER (T = .TRUE., F = .FALSE.)\t!Enable a more compact specification.\n      DATA WORD/\"A\",\"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"/\t!So that these\n      DATA  ANS/ T ,    T ,    F ,     T ,      F ,     T ,       T /\t!Can be aligned.\n      LOGICAL YAY\n      INTEGER I\n\n      WRITE (MSG,1)\n    1 FORMAT (\"Arranges alphabet blocks, attending only to the \",\n     1 \"letters on the blocks, and ignoring case and orientation.\",/)\n\n      CALL PLAY(HAVE,BLOCKS)\t!Some fun first.\n\n      WRITE (MSG,'(/\"Now to see if some words can be spelled out.\")')\n      DO I = 1,TESTS\n        CALL UPCASE(WORD(I))\n        YAY = CANBLOCK(WORD(I),HAVE,BLOCKS)\n        WRITE (MSG,*) YAY,ANS(I),YAY.EQ.ANS(I),WORD(I)\n      END DO\n      END\n\n\nArranges alphabet blocks, attending only to the letters on the blocks, and ignoring case and orientation.\n\n     20 blocks, with at most 2 letters: BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\n      ... the letters in reverse order: OB XK QD PC NA TG RE TG QD SF WJ UH VI NA OB RE SF YL PC ZM\n       ... the blocks in reverse order: ZM YL XK WJ VI UH TG TG SF SF RE RE QD QD PC PC OB OB NA NA\n               Letters of the alphabet:  A  B  C  D  E  F  G  H  I  J  K  L  M  N  O  P  Q  R  S  T  U  V  W  X  Y  Z\n           ... number thereof supplied:  2  2  2  2  2  2  2  1  1  1  1  1  1  2  2  2  2  2  2  2  1  1  1  1  1  1\n        Blocks with duplicated letters: None.\n                     Duplicated blocks: TG SF RE QD PC OB NA           7\nDuplicated letters on different blocks: None.\n\nNow to see if some words can be spelled out.\n T T T A\n T T T BARK\n F F T BOOK\n T T T TREAT\n F F T COMMON\n T T T SQUAD\n T T T CONFUSE\n\n", "explain": "Attempts to write the word read from unit 5.  Please find the output, bash command, and gfortran compilation instructions as commentary at the start of the source, which starts right away!\nThe example set does not exercise the possible need for backtracking, as when an initial selection of blocks prevents completion because available letters have been used up. This can only arise when the same letter appears on more than one block and does so with different partners. The example set does contain duplicated letters, but they appear only via blocks with the same letters. Suppose instead that the block collection was AB, BC, CD, ... XY, YZ so that every letter appears twice except for A and Z. If the target word was STOPPED then both OP and PQ would be needed to supply P, but if the O had been supplied via OP then the second P would be unavailable. If instead the O were to be supplied by NO then all would be well.\nThe method involves the stack-style usage of array MOVE, but there is no explicit attempt at recursion. The array contains the possible moves at each level, and if necessary, a move made can later be retracted and an alternative sought. This is the standard style of playing board games such as chess via developing a \"game tree\", but in this case the tree traversal is not a large task.\nThe following source begins with some support routines. Subroutine PLAY inspects the collection of blocks to make various remarks, and function CANBLOCK reports on whether a word can be spelled out with the supplied blocks. The source requires only a few of the F90 features. The MODULE protocol eases communication, but the key feature is that subprograms can now declare arrays of a size determined on entry via parameters. Previously, a constant with the largest-possible size would be required.\nOutput: the first column of T/F is the report from CANBLOCK, the second is the expected answer from the example, and the third is whether the two are in agreement.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n\t\"strings\"\n)\n\nfunc newSpeller(blocks string) func(string) bool {\n\tbl := strings.Fields(blocks)\n\treturn func(word string) bool {\n\t\treturn r(word, bl)\n\t}\n}\n\nfunc r(word string, bl []string) bool {\n\tif word == \"\" {\n\t\treturn true\n\t}\n\tc := word[0] | 32\n\tfor i, b := range bl {\n\t\tif c == b[0]|32 || c == b[1]|32 {\n\t\t\tbl[i], bl[0] = bl[0], b\n\t\t\tif r(word[1:], bl[1:]) == true {\n\t\t\t\treturn true\n\t\t\t}\n\t\t\tbl[i], bl[0] = bl[0], bl[i]\n\t\t}\n\t}\n\treturn false\n}\n\nfunc main() {\n\tsp := newSpeller(\n\t\t\"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\")\n\tfor _, word := range []string{\n\t\t\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"} {\n\t\tfmt.Println(word, sp(word))\n\t}\n}\n\n\nOutput:\nA true\nBARK true\nBOOK false\nTREAT true\nCOMMON false\nSQUAD true\nCONFUSE true\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program problemABC.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ TRUE, 1\n.equ FALSE, 0\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessTitre1:        .asciz \"Can_make_word: @ \\n\"\nszMessTrue:          .asciz \"True.\\n\"\nszMessFalse:         .asciz \"False.\\n\"\nszCarriageReturn:    .asciz \"\\n\"\n\nszTablBloc:          .asciz \"BO\"\n                     .asciz \"XK\"\n                     .asciz \"DQ\"\n                     .asciz \"CP\"\n                     .asciz \"NA\"\n                     .asciz \"GT\"\n                     .asciz \"RE\"\n                     .asciz \"TG\"\n                     .asciz \"QD\"\n                     .asciz \"FS\"\n                     .asciz \"JW\"\n                     .asciz \"HU\"\n                     .asciz \"VI\"\n                     .asciz \"AN\"\n                     .asciz \"OB\"\n                     .asciz \"ER\"\n                     .asciz \"FS\"\n                     .asciz \"LY\"\n                     .asciz \"PC\"\n                     .asciz \"ZM\"\n                     .equ NBBLOC, (. -  szTablBloc) / 3\n                     \nszWord1:             .asciz \"A\"\nszWord2:             .asciz \"BARK\"\nszWord3:             .asciz \"BOOK\"\nszWord4:             .asciz \"TREAT\"\nszWord5:             .asciz \"COMMON\"\nszWord6:             .asciz \"SQUAD\"\nszWord7:             .asciz \"CONFUSE\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\n.align 4\nitabTopBloc:         .skip 4 * NBBLOC\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                @ entry of program \n    ldr r0,iAdrszWord1\n    bl traitBlock                    @ control word\n\n    ldr r0,iAdrszWord2\n    bl traitBlock                    @ control word\n    \n    ldr r0,iAdrszWord3\n    bl traitBlock                    @ control word\n    \n    ldr r0,iAdrszWord4\n    bl traitBlock                    @ control word\n        \n    ldr r0,iAdrszWord5\n    bl traitBlock                    @ control word\n        \n    ldr r0,iAdrszWord6\n    bl traitBlock                    @ control word\n        \n    ldr r0,iAdrszWord7\n    bl traitBlock                    @ control word\n\n100:                                  @ standard end of the program \n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszWord1:              .int szWord1\niAdrszWord2:              .int szWord2\niAdrszWord3:              .int szWord3\niAdrszWord4:              .int szWord4\niAdrszWord5:              .int szWord5\niAdrszWord6:              .int szWord6\niAdrszWord7:              .int szWord7\n/******************************************************************/\n/*          traitement                                           */ \n/******************************************************************/\n/* r0 contains word */\ntraitBlock:\n    push {r1,lr}        @ save registers\n    mov r1,r0\n    ldr r0,iAdrszMessTitre1   @ insertion word in message\n    bl strInsertAtCharInc\n    bl affichageMess          @ display title message\n    mov r0,r1\n    bl controlBlock           @ control \n    cmp r0,#TRUE              @ ok\u00a0?\n    bne 1f\n    ldr r0,iAdrszMessTrue     @ yes\n    bl affichageMess\n    b 100f\n1:                            @ no\n    ldr r0,iAdrszMessFalse\n    bl affichageMess\n100:\n    pop {r1,lr}\n    bx lr                     @ return \niAdrszMessTitre1:         .int szMessTitre1\niAdrszMessFalse:          .int szMessFalse\niAdrszMessTrue:           .int szMessTrue\n/******************************************************************/\n/*        control if letters are in block                       */ \n/******************************************************************/\n/* r0 contains word */\ncontrolBlock:\n    push {r1-r9,lr}        @ save registers\n    mov r5,r0              @ save word address\n    ldr r4,iAdritabTopBloc\n    ldr r6,iAdrszTablBloc\n    mov r2,#0\n    mov r3,#0\n1:                          @ init table top block used\n    str r3,[r4,r2,lsl #2]\n    add r2,r2,#1\n    cmp r2,#NBBLOC\n    blt 1b\n    mov r2,#0\n2:                          @ loop to load letters \n    ldrb r3,[r5,r2]\n    cmp r3,#0\n    beq 10f                 @ end\n    and r3,r3,#0xDF         @ transform in capital letter\n    mov r8,#0\n3:                          @ begin loop control block\n    ldr r7,[r4,r8,lsl #2]   @ block already used\u00a0?\n    cmp r7,#0\n    bne 5f                  @ yes\n    add r9,r8,r8,lsl #1     @ no -> index * 3\n    ldrb r7,[r6,r9]         @ first block letter\n    cmp r3,r7               @ equal\u00a0?\n    beq 4f\n    add r9,r9,#1\n    ldrb r7,[r6,r9]         @ second block letter\n    cmp r3,r7               @ equal\u00a0?\n    beq 4f\n    b 5f\n4:\n    mov r7,#1               @ top block\n    str r7,[r4,r8,lsl #2]   @ block used\n    add r2,r2,#1\n    b 2b                    @ next letter\n5:\n    add r8,r8,#1\n    cmp r8,#NBBLOC\n    blt 3b\n    mov r0,#FALSE           @ no letter find on block -> false\n    b 100f \n10:                         @ all letters are ok\n    mov r0,#TRUE\n100:\n    pop {r1-r9,lr}\n    bx lr                   @ return \niAdritabTopBloc:   .int itabTopBloc\niAdrszTablBloc:    .int szTablBloc\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nCan_make_word: A\nTrue.\nCan_make_word: BARK\nTrue.\nCan_make_word: BOOK\nFalse.\nCan_make_word: TREAT\nTrue.\nCan_make_word: COMMON\nFalse.\nCan_make_word: SQUAD\nTrue.\nCan_make_word: CONFUSE\nTrue.\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Delphi", "code": "\n\nprogram ABC;\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\ntype\n  TBlock = set of char;\n\nconst\n  TheBlocks : array [0..19] of TBlock =\n  (\n    [ 'B', 'O' ],    [ 'X', 'K' ],    [ 'D', 'Q' ],    [ 'C', 'P' ],    [ 'N', 'A' ],\n    [ 'G', 'T' ],    [ 'R', 'E' ],    [ 'T', 'G' ],    [ 'Q', 'D' ],    [ 'F', 'S' ],\n    [ 'J', 'W' ],    [ 'H', 'U' ],    [ 'V', 'I' ],    [ 'A', 'N' ],    [ 'O', 'B' ],\n    [ 'E', 'R' ],    [ 'F', 'S' ],    [ 'L', 'Y' ],    [ 'P', 'C' ],    [ 'Z', 'M' ]\n  );\n\nfunction SolveABC(Target : string; Blocks : array of TBlock) : boolean;\nvar\n  iChr : integer;\n  Used : array [0..19] of boolean;\n\n  function FindUnused(TargetChr : char) : boolean;  // Nested routine\n  var\n    iBlock : integer;\n  begin\n    Result := FALSE;\n    for iBlock := low(Blocks) to high(Blocks) do\n      if (not Used[iBlock]) and ( TargetChr in Blocks[iBlock] ) then\n      begin\n        Result := TRUE;\n        Used[iBlock] := TRUE;\n        Break;\n      end;\n  end;\n\nbegin\n  FillChar(Used, sizeof(Used), ord(FALSE));\n  Result := TRUE;\n  iChr := 1;\n  while Result and (iChr <= length(Target)) do\n    if FindUnused(Target[iChr]) then inc(iChr)\n                                else Result := FALSE;\nend;\n\nprocedure CheckABC(Target : string);\nbegin\n  if SolveABC(uppercase(Target), TheBlocks) then\n    writeln('Can make ' + Target)\n  else\n    writeln('Can NOT make ' + Target);\nend;\n\nbegin\n  CheckABC('A');\n  CheckABC('BARK');\n  CheckABC('BOOK');\n  CheckABC('TREAT');\n  CheckABC('COMMON');\n  CheckABC('SQUAD');\n  CheckABC('CONFUSE');\n  readln;\nend.\n\n\nOutput:\nOutput:\nCan make A\nCan make BARK\nCan NOT make BOOK\nCan make TREAT\nCan NOT make COMMON\nCan make SQUAD\nCan make CONFUSE\n\n", "explain": "Just to be different I implemented a block as a set of (2) char rather than as an array of (2) char.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Ruby", "code": "\n\nwords = %w(A BaRK BOoK tREaT COmMOn SqUAD CoNfuSE) << \"\"\n\nwords.each do |word|\n  blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n  res = word.each_char.all?{|c| blocks.sub!(/\\w?#{c}\\w?/i, \"\")}  #regexps can be interpolated like strings\n  puts \"#{word.inspect}: #{res}\"\nend\n\nOutput:\n\"A\": true\n\"BaRK\": true\n\"BOoK\": false\n\"tREaT\": true\n\"COmMOn\": false\n\"SqUAD\": true\n\"CoNfuSE\": true\n\"\": true\n\n", "explain": "This one uses a case insensitive regular expression. The 'sub!' method substitutes the first substring it finds and returns nil if nothing is found.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Rust", "code": "\n\nuse std::iter::repeat;\n\nfn rec_can_make_word(index: usize, word: &str, blocks: &[&str], used: &mut[bool]) -> bool {\n    let c = word.chars().nth(index).unwrap().to_uppercase().next().unwrap();\n    for i in 0..blocks.len() {\n        if !used[i] && blocks[i].chars().any(|s| s == c) {\n            used[i] = true;\n            if index == 0 || rec_can_make_word(index - 1, word, blocks, used) {\n                return true;\n            }\n            used[i] = false;\n        }\n    }\n    false\n}\n\nfn can_make_word(word: &str, blocks: &[&str]) -> bool {\n    return rec_can_make_word(word.chars().count() - 1, word, blocks, \n                             &mut repeat(false).take(blocks.len()).collect::<Vec<_>>());\n}\n\nfn main() {\n    let blocks = [(\"BO\"), (\"XK\"), (\"DQ\"), (\"CP\"), (\"NA\"), (\"GT\"), (\"RE\"), (\"TG\"), (\"QD\"), (\"FS\"), \n                  (\"JW\"), (\"HU\"), (\"VI\"), (\"AN\"), (\"OB\"), (\"ER\"), (\"FS\"), (\"LY\"), (\"PC\"), (\"ZM\")];\n    let words = [\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSE\"];\n    for word in &words {\n        println!(\"{} -> {}\", word, can_make_word(word, &blocks))\n    }\n}\n\nOutput:\nA -> true\nBARK -> true\nBOOK -> false\nTREAT -> true\nCOMMON -> false\nSQUAD -> true\nCONFUSE -> true\n\n", "explain": "This implementation uses a backtracking search.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Swift", "code": "\nimport Foundation\n\nfunc Blockable(str: String) -> Bool {\n\n    var blocks = [\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\" ]\n\n    var strUp = str.uppercaseString\n    var final = \"\"\n\n    for char: Character in strUp {\n        var CharString: String = \"\"; CharString.append(char)\n        for j in 0..<blocks.count {\n            if blocks[j].hasPrefix(CharString) ||\n               blocks[j].hasSuffix(CharString) {\n                final.append(char)\n                blocks[j] = \"\"\n                break\n            }\n        }\n    }\n\n    return final == strUp\n}\n\nfunc CanOrNot(can: Bool) -> String {\n    return can\u00a0? \"can\"\u00a0: \"cannot\"\n}\n\nfor str in [ \"A\", \"BARK\", \"BooK\", \"TrEaT\", \"comMON\", \"sQuAd\", \"Confuse\" ] {\n    println(\"'\\(str)' \\(CanOrNot(Blockable(str))) be spelled with blocks.\")\n}\n\nOutput:\n'A' can be spelled with blocks.\n'BARK' can be spelled with blocks.\n'BooK' cannot be spelled with blocks.\n'TrEaT' can be spelled with blocks.\n'comMON' cannot be spelled with blocks.\n'sQuAd' can be spelled with blocks.\n'Confuse' can be spelled with blocks.\n\nWorks with: Swift version 3.0.2\nimport Swift\n\nfunc canMake(word: String) -> Bool {\n\tvar blocks = [\n\t\t\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \n\t\t\"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t]\n\t\n\tfor letter in word.uppercased().characters {\n\t\tguard let index = blocks.index(where: { $0.characters.contains(letter) }) else {\n\t\t\treturn false\n\t\t}\n\t\t\n\t\tblocks.remove(at: index)\n\t}\n\t\n\treturn true\n}\n\nlet words = [\"a\", \"bARK\", \"boOK\", \"TreAt\", \"CoMmon\", \"SquAd\", \"CONFUse\"]\n\nwords.forEach { print($0, canMake(word: $0)) }\n\nOutput:\nA true\nBARK true\nBooK false\nTrEaT true\ncomMON false\nsQuAd true\nConfuse true\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "R", "code": "\nWith recursion[edit]\n\nblocks <- rbind(c(\"B\",\"O\"),\n c(\"X\",\"K\"), \n c(\"D\",\"Q\"), \n c(\"C\",\"P\"), \n c(\"N\",\"A\"), \n c(\"G\",\"T\"), \n c(\"R\",\"E\"), \n c(\"T\",\"G\"), \n c(\"Q\",\"D\"), \n c(\"F\",\"S\"), \n c(\"J\",\"W\"), \n c(\"H\",\"U\"), \n c(\"V\",\"I\"), \n c(\"A\",\"N\"), \n c(\"O\",\"B\"), \n c(\"E\",\"R\"), \n c(\"F\",\"S\"), \n c(\"L\",\"Y\"), \n c(\"P\",\"C\"), \n c(\"Z\",\"M\"))\n\ncanMake <- function(x) {\n  x <- toupper(x)\n  used <- rep(FALSE, dim(blocks)[1L])\n  charList <- strsplit(x, character(0))\n  tryChars <- function(chars, pos, used, inUse=NA) {\n    if (pos > length(chars)) {\n      TRUE\n    } else {\n      used[inUse] <- TRUE\n      possible <- which(blocks == chars[pos] & !used, arr.ind=TRUE)[, 1L]\n      any(vapply(possible, function(possBlock) tryChars(chars, pos + 1, used, possBlock), logical(1)))\n    }\n  }\n  setNames(vapply(charList, tryChars, logical(1), 1L, used), x)\n}\ncanMake(c(\"A\",\n           \"BARK\",\n           \"BOOK\",\n           \"TREAT\",\n           \"COMMON\",\n           \"SQUAD\",\n           \"CONFUSE\"))\n\n\nOutput:\n      A    BARK    BOOK   TREAT  COMMON   SQUAD CONFUSE \n   TRUE    TRUE   FALSE    TRUE   FALSE    TRUE    TRUE\nWithout recursion[edit]\n\ncanMakeNoRecursion <- function(x) {\n  x <- toupper(x)\n  charList <- strsplit(x, character(0))\n  getCombos <- function(chars) {\n    charBlocks <-  data.matrix(expand.grid(lapply(chars, function(char) which(blocks == char, arr.ind=TRUE)[, 1L])))\n    charBlocks <- charBlocks[!apply(charBlocks, 1, function(row) any(duplicated(row))), , drop=FALSE]\n    if (dim(charBlocks)[1L] > 0L) {\n      t(apply(charBlocks, 1, function(row) apply(blocks[row, , drop=FALSE], 1, paste, collapse=\"\")))\n    } else {\n      character(0)\n    }\n  }\n  setNames(lapply(charList, getCombos), x)\n}\ncanMakeNoRecursion(c(\"A\",\n           \"BARK\",\n           \"BOOK\",\n           \"TREAT\",\n           \"COMMON\",\n           \"SQUAD\",\n           \"CONFUSE\"))\n\nOutput:\n$A\n     [,1] [,2]\n[1,] \"AN\" \"NA\"\n\n$BARK\n     [,1] [,2] [,3] [,4]\n[1,] \"BO\" \"AN\" \"RE\" \"XK\"\n[2,] \"OB\" \"AN\" \"RE\" \"XK\"\n[3,] \"BO\" \"NA\" \"RE\" \"XK\"\n[4,] \"OB\" \"NA\" \"RE\" \"XK\"\n[5,] \"BO\" \"AN\" \"ER\" \"XK\"\n[6,] \"OB\" \"AN\" \"ER\" \"XK\"\n[7,] \"BO\" \"NA\" \"ER\" \"XK\"\n[8,] \"OB\" \"NA\" \"ER\" \"XK\"\n\n$BOOK\ncharacter(0)\n\n$TREAT\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"GT\" \"RE\" \"ER\" \"AN\" \"TG\"\n[2,] \"GT\" \"ER\" \"RE\" \"AN\" \"TG\"\n[3,] \"GT\" \"RE\" \"ER\" \"NA\" \"TG\"\n[4,] \"GT\" \"ER\" \"RE\" \"NA\" \"TG\"\n[5,] \"TG\" \"RE\" \"ER\" \"AN\" \"GT\"\n[6,] \"TG\" \"ER\" \"RE\" \"AN\" \"GT\"\n[7,] \"TG\" \"RE\" \"ER\" \"NA\" \"GT\"\n[8,] \"TG\" \"ER\" \"RE\" \"NA\" \"GT\"\n\n$COMMON\ncharacter(0)\n\n$SQUAD\n     [,1] [,2] [,3] [,4] [,5]\n[1,] \"FS\" \"QD\" \"HU\" \"AN\" \"DQ\"\n[2,] \"FS\" \"QD\" \"HU\" \"AN\" \"DQ\"\n[3,] \"FS\" \"QD\" \"HU\" \"NA\" \"DQ\"\n[4,] \"FS\" \"QD\" \"HU\" \"NA\" \"DQ\"\n[5,] \"FS\" \"DQ\" \"HU\" \"AN\" \"QD\"\n[6,] \"FS\" \"DQ\" \"HU\" \"AN\" \"QD\"\n[7,] \"FS\" \"DQ\" \"HU\" \"NA\" \"QD\"\n[8,] \"FS\" \"DQ\" \"HU\" \"NA\" \"QD\"\n\n$CONFUSE\n      [,1] [,2] [,3] [,4] [,5] [,6] [,7]\n [1,] \"CP\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n [2,] \"PC\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n [3,] \"CP\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n [4,] \"PC\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n [5,] \"CP\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n [6,] \"PC\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n [7,] \"CP\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n [8,] \"PC\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n [9,] \"CP\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n[10,] \"PC\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n[11,] \"CP\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n[12,] \"PC\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"ER\"\n[13,] \"CP\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n[14,] \"PC\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n[15,] \"CP\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n[16,] \"PC\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"ER\"\n[17,] \"CP\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[18,] \"PC\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[19,] \"CP\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[20,] \"PC\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[21,] \"CP\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[22,] \"PC\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[23,] \"CP\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[24,] \"PC\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[25,] \"CP\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[26,] \"PC\" \"OB\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[27,] \"CP\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[28,] \"PC\" \"BO\" \"NA\" \"FS\" \"HU\" \"FS\" \"RE\"\n[29,] \"CP\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[30,] \"PC\" \"OB\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[31,] \"CP\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n[32,] \"PC\" \"BO\" \"AN\" \"FS\" \"HU\" \"FS\" \"RE\"\n", "explain": "Vectorised function for R which will take a character vector and return a logical vector of equal length with TRUE and FALSE as appropriate for words which can/cannot be made with the blocks.\nSecond version without recursion and giving every unique combination of blocks for each word:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Ada", "code": "\nBuild with gnatchop abc.ada; gnatmake abc_problem\n\nwith Ada.Characters.Handling;\nuse Ada.Characters.Handling;\n\n\npackage Abc is\n    type Block_Faces is array(1..2) of Character;\n    type Block_List is array(positive range <>) of Block_Faces;\n    function Can_Make_Word(W: String; Blocks: Block_List) return Boolean;\nend Abc;\n\n\npackage body Abc is\n\nfunction Can_Make_Word(W: String; Blocks: Block_List) return Boolean is\n    Used : array(Blocks'Range) of Boolean := (Others => False);\n    subtype wIndex is Integer range W'First..W'Last;\n    wPos : wIndex;\nbegin\n    if W'Length = 0 then\n        return True;\n    end if;\n    wPos := W'First;\n    while True loop\n        declare\n            C : Character := To_Upper(W(wPos));\n            X : constant wIndex := wPos;\n        begin\n            for I in Blocks'Range loop\n                if (not Used(I)) then\n                    if C = To_Upper(Blocks(I)(1)) or C = To_Upper(Blocks(I)(2)) then\n                        Used(I) := True;\n                        if wPos = W'Last then\n                            return True;\n                        end if;\n                        wPos := wIndex'Succ(wPos);\n                        exit;\n                    end if;\n                end if;\n            end loop;\n            if X = wPos then\n                return False;\n            end if;\n        end;\n    end loop;\n    return False;\nend Can_Make_Word;\n\nend Abc;\n\nwith Ada.Text_IO, Ada.Strings.Unbounded, Abc;\nuse Ada.Text_IO, Ada.Strings.Unbounded, Abc;\n\nprocedure Abc_Problem is\n    Blocks : Block_List := (\n          ('B','O'), ('X','K'), ('D','Q'), ('C','P')\n        , ('N','A'), ('G','T'), ('R','E'), ('T','G')\n        , ('Q','D'), ('F','S'), ('J','W'), ('H','U')\n        , ('V','I'), ('A','N'), ('O','B'), ('E','R')\n        , ('F','S'), ('L','Y'), ('P','C'), ('Z','M')\n    );\n    function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n    words : array(positive range <>) of Unbounded_String := (\n          +\"A\"\n        , +\"BARK\"\n        , +\"BOOK\"\n        , +\"TREAT\"\n        , +\"COMMON\"\n        , +\"SQUAD\"\n        , +\"CONFUSE\"\n        -- Border cases:\n        -- , +\"CONFUSE2\"\n        -- , +\"\"\n    );\nbegin\n    for I in words'Range loop\n        Put_Line ( To_String(words(I)) & \": \" & Boolean'Image(Can_Make_Word(To_String(words(I)),Blocks)) );\n    end loop;\nend Abc_Problem;\n\n\nOutput:\nA: TRUE\nBARK: TRUE\nBOOK: FALSE\nTREAT: TRUE\nCOMMON: FALSE\nSQUAD: TRUE\nCONFUSE: TRUE\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Julia", "code": "\nusing Printf\n\nfunction abc(str::AbstractString, list)\n    isempty(str) && return true\n    for i in eachindex(list)\n        str[end] in list[i] &&\n            any([abc(str[1:end-1], deleteat!(copy(list), i))]) &&\n            return true\n    end\n    return false\nend\n\nlet test = [\"A\", \"BARK\",\"BOOK\",\"TREAT\",\"COMMON\",\"SQUAD\",\"CONFUSE\"],\n    list = [\"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\n            \"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"]\n    for str in test\n        @printf(\"%-8s |  %s\\n\", str, abc(str, list))\n    end\nend\n\n\nOutput:\nA        |  true\nBARK     |  true\nBOOK     |  false\nTREAT    |  true\nCOMMON   |  false\nSQUAD    |  true\nCONFUSE  |  true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\nTranslation of: Java\nobject ABC_block_checker {\n    fun run() {\n        println(\"\\\"\\\": \" + blocks.canMakeWord(\"\"))\n        for (w in words) println(\"$w: \" + blocks.canMakeWord(w))\n    }\n\n    private fun Array<String>.swap(i: Int, j: Int) {\n        val tmp = this[i]\n        this[i] = this[j]\n        this[j] = tmp\n    }\n\n    private fun Array<String>.canMakeWord(word: String): Boolean {\n        if (word.isEmpty())\n            return true\n\n        val c = word.first().toUpperCase()\n        var i = 0\n        forEach { b ->\n            if (b.first().toUpperCase() == c || b[1].toUpperCase() == c) {\n                swap(0, i)\n                if (drop(1).toTypedArray().canMakeWord(word.substring(1)))\n                    return true\n                swap(0, i)\n            }\n            i++\n        }\n\n        return false\n    }\n\n    private val blocks = arrayOf(\n        \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n        \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n    )\n    private val words = arrayOf(\"A\", \"BARK\", \"book\", \"treat\", \"COMMON\", \"SQuAd\", \"CONFUSE\")\n}\n\nfun main(args: Array<String>) = ABC_block_checker.run()\n\n\nOutput:\n\"\": true\nA: true\nBARK: true\nbook: false\ntreat: true\nCOMMON: false\nSQuAd: true\nCONFUSE: true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Perl", "code": "\n\n#!/usr/bin/perl\nuse warnings;\nuse strict;\n\n\nsub can_make_word {\n    my ($word, @blocks) = @_;\n    $_ = uc join q(), sort split // for @blocks;\n    my %blocks;\n    $blocks{$_}++ for @blocks;\n    return _can_make_word(uc $word, %blocks)\n}\n\n\nsub _can_make_word {\n    my ($word, %blocks) = @_;\n    my $char = substr $word, 0, 1, q();\n\n    my @candidates = grep 0 <= index($_, $char), keys %blocks;\n    for my $candidate (@candidates) {\n        next if $blocks{$candidate} <= 0;\n        local $blocks{$candidate} = $blocks{$candidate} - 1;\n        return 1 if q() eq $word or _can_make_word($word, %blocks);\n    }\n    return\n}\n\nuse Test::More tests => 8;\n\nmy @blocks1 = qw(BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM);\nis(can_make_word(\"A\",       @blocks1), 1);\nis(can_make_word(\"BARK\",    @blocks1), 1);\nis(can_make_word(\"BOOK\",    @blocks1), undef);\nis(can_make_word(\"TREAT\",   @blocks1), 1);\nis(can_make_word(\"COMMON\",  @blocks1), undef);\nis(can_make_word(\"SQUAD\",   @blocks1), 1);\nis(can_make_word(\"CONFUSE\", @blocks1), 1);\n\nmy @blocks2 = qw(US TZ AO QA);\nis(can_make_word('auto', @blocks2), 1);\n\nRegex based alternate[edit]\n#!/usr/bin/perl\n\nuse strict; # https://rosettacode.org/wiki/ABC_Problem\nuse warnings;\n\nprintf \"%30s  %s\\n\", $_, can_make_word( $_,\n  'BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM' )\n  for qw( A BARK BOOK TREAT COMMON SQUAD CONFUSE );\n\nsub can_make_word\n  {\n  my ($word, $blocks) = @_;\n  my $letter = chop $word or return 'True';\n  can_make_word( $word, $` . $' ) eq 'True' and return 'True'\n    while $blocks =~ /\\w?$letter\\w?/gi;\n  return 'False';\n  }\n\n\nOutput:\n                             A  True\n                          BARK  True\n                          BOOK  False\n                         TREAT  True\n                        COMMON  False\n                         SQUAD  True\n                       CONFUSE  True\n\n", "explain": "Recursive solution that can handle characters appearing on different blocks:\nTesting:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Prolog", "code": "\nTraditional[edit]\n\nabc_problem :-\n\tmaplist(abc_problem, ['', 'A', bark, bOOk, treAT, 'COmmon', sQuaD, 'CONFUSE']).\n\n\nabc_problem(Word) :-\n\tL = [[b,o],[x,k],[d,q],[c,p],[n,a],[g,t],[r,e],[t,g],[q,d],[f,s],\n\t     [j,w],[h,u],[v,i],[a,n],[o,b],[e,r],[f,s],[l,y],[p,c],[z,m]],\n\n\t(   abc_problem(L, Word)\n\t->  format('~w OK~n', [Word])\n\t;   format('~w KO~n', [Word])).\n\nabc_problem(L, Word) :-\n\tatom_chars(Word, C_Words),\n\tmaplist(downcase_atom, C_Words, D_Words),\n\tcan_makeword(L, D_Words).\n\ncan_makeword(_L, []).\n\ncan_makeword(L, [H | T]) :-\n\t(   select([H, _], L, L1); select([_, H], L, L1)),\n\tcan_makeword(L1, T).\n\n\nOutput:\n\u00a0?- abc_problem.\n OK\nA OK\nbark OK\nbOOk KO\ntreAT OK\nCOmmon KO\nsQuaD OK\nCONFUSE OK\ntrue.\n\n\nConstraint Handling Rules[edit]\n\nWorks with: SWI Prolog 7\n:- use_module([ library(chr),\n                abathslib(protelog/composer) ]).\n\n:- chr_constraint blocks, block/1, letter/1, word_built.\n\ncan_build_word(Word) :-\n    maplist(block, [(b,o),(x,k),(d,q),(c,p),(n,a),(g,t),(r,e),(t,g),(q,d),(f,s),\n                    (j,w),(h,u),(v,i),(a,n),(o,b),(e,r),(f,s),(l,y),(p,c),(z,m)]),\n    maplist(letter) <- string_chars <- string_lower(Word),     %% using the `composer` module\n    word_built,\n    !.\n\n'take letter and block'  @ letter(L), block((A,B)) <=> L == A ; L == B | true.\n'fail if letters remain' @ word_built, letter(_)   <=> false.\n\n%% These rules, removing remaining constraints from the store, are just cosmetic:\n'clean up blocks' @ word_built \\ block(_) <=> true.\n'word was built'  @ word_built            <=> true.\n\n\n?- can_build_word(\"A\").\ntrue.\n?- can_build_word(\"BARK\").\ntrue.\n?- can_build_word(\"BOOK\").\nfalse.\n?- can_build_word(\"TREAT\").\ntrue.\n?- can_build_word(\"COMMON\").\nfalse.\n?- can_build_word(\"SQUAD\").\ntrue.\n?- can_build_word(\"CONFUSE\").\ntrue.\n\n", "explain": "Works with SWI-Prolog 6.5.3\n\nAn approach using [CHR https://dtai.cs.kuleuven.be/CHR/] via SWI-Prolog's [library(chr) http://www.swi-prolog.org/pldoc/man?section=chr] and a module I'm working on for composing predicates composer:\n\nDemonstration:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Lua", "code": "\nblocks = {\n\t{\"B\",\"O\"};\t{\"X\",\"K\"};\t{\"D\",\"Q\"};\t{\"C\",\"P\"};\n\t{\"N\",\"A\"};\t{\"G\",\"T\"};\t{\"R\",\"E\"};\t{\"T\",\"G\"};\n\t{\"Q\",\"D\"};\t{\"F\",\"S\"};\t{\"J\",\"W\"};\t{\"H\",\"U\"};\n\t{\"V\",\"I\"};\t{\"A\",\"N\"};\t{\"O\",\"B\"};\t{\"E\",\"R\"};\n\t{\"F\",\"S\"};\t{\"L\",\"Y\"};\t{\"P\",\"C\"};\t{\"Z\",\"M\"};\n\t};\n\nfunction canUse(table, letter)\n\tfor i,v in pairs(blocks) do\n\t\tif (v[1] == letter:upper() or v[2] == letter:upper())  and table[i] then\n\t\t\ttable[i] = false;\n\t\t\treturn true;\n\t\tend\n\tend\n\treturn false;\nend\n\nfunction canMake(Word)\n\tlocal Taken = {};\n\tfor i,v in pairs(blocks) do\n\t\ttable.insert(Taken,true);\n\tend\n\tlocal found = true;\n\tfor i = 1,#Word do\n\t\tif not canUse(Taken,Word:sub(i,i)) then\n\t\t\tfound = false;\n\t\tend\n\tend\n\tprint(found)\nend\n\n\nOutput:\ncanMake(\"A\"): true\ncanMake(\"BARK\"): true\ncanMake(\"BOOK\"): false\ncanMake(\"TREAT\"): true\ncanMake(\"COMMON\"): false\ncanMake(\"SQUAD\"): true\ncanMake(\"CONFUSE\"): true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Scala", "code": "\nLibrary: Scalaobject AbcBlocks extends App {\n\n  protected class Block(face1: Char, face2: Char) {\n\n    def isFacedWith(that: Char) = { that == face1 || that == face2 }\n    override def toString() = face1.toString + face2\n  }\n  protected object Block {\n    def apply(faces: String) = new Block(faces.head, faces.last)\n  }\n\n  type word = Seq[Block]\n\n  private val blocks = List(Block(\"BO\"), Block(\"XK\"), Block(\"DQ\"), Block(\"CP\"), Block(\"NA\"),\n    Block(\"GT\"), Block(\"RE\"), Block(\"TG\"), Block(\"QD\"), Block(\"FS\"),\n    Block(\"JW\"), Block(\"HU\"), Block(\"VI\"), Block(\"AN\"), Block(\"OB\"),\n    Block(\"ER\"), Block(\"FS\"), Block(\"LY\"), Block(\"PC\"), Block(\"ZM\"))\n\n  private def isMakeable(word: String, blocks: word) = {\n\n    def getTheBlocks(word: String, blocks: word) = {\n\n      def inner(word: String, toCompare: word, rest: word, accu: word): word = {\n        if (word.isEmpty || rest.isEmpty || toCompare.isEmpty) accu\n        else if (toCompare.head.isFacedWith(word.head)) {\n          val restant = rest diff List(toCompare.head)\n          inner(word.tail, restant, restant, accu\u00a0:+ toCompare.head)\n        } else inner(word, toCompare.tail, rest, accu)\n      }\n      inner(word, blocks, blocks, Nil)\n    }\n\n    word.lengthCompare(getTheBlocks(word, blocks).size) == 0\n  }\n\n  val words = List(\"A\", \"BARK\", \"BOOK\", \"TREAT\", \"COMMON\", \"SQUAD\", \"CONFUSED\", \"ANBOCPDQERSFTGUVWXLZ\")\n  // Automatic tests\n  assert(isMakeable(words(0), blocks))\n  assert(isMakeable(words(1), blocks))\n  assert(!isMakeable(words(2), blocks)) // BOOK not\n  assert(isMakeable(words(3), blocks))\n  assert(!isMakeable(words(4), blocks)) // COMMON not\n  assert(isMakeable(words(5), blocks))\n  assert(isMakeable(words(6), blocks))\n  assert(isMakeable(words(7), blocks))\n\n  //words(7).mkString.permutations.foreach(s => assert(isMakeable(s, blocks)))\n\n  words.foreach(w => println(s\"$w can${if (isMakeable(w, blocks)) \" \" else \"not \"}be made.\"))\n}\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "D", "code": "\nBasic Version[edit]\nTranslation of: Python\n\nimport std.stdio, std.algorithm, std.string;\n\nbool canMakeWord(in string word, in string[] blocks) pure /*nothrow*/ @safe {\n    auto bs = blocks.dup;\n    outer: foreach (immutable ch; word.toUpper) {\n        foreach (immutable block; bs)\n            if (block.canFind(ch)) {\n                bs = bs.remove(bs.countUntil(block));\n                continue outer;\n            }\n        return false;\n    }\n    return true;\n}\n\nvoid main() @safe {\n    immutable blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI\n                        AN OB ER FS LY PC ZM\".split;\n\n    foreach (word; \"\" ~ \"A BARK BoOK TrEAT COmMoN SQUAD conFUsE\".split)\n        writefln(`\"%s\" %s`, word, canMakeWord(word, blocks));\n}\n\n\nOutput:\n\"\" true\n\"A\" true\n\"BARK\" true\n\"BoOK\" false\n\"TrEAT\" true\n\"COmMoN\" false\n\"SQUAD\" true\n\"conFUsE\" true\n@nogc Version[edit]\n\nimport std.ascii, core.stdc.stdlib;\n\nbool canMakeWord(in string word, in string[] blocks) nothrow @nogc\nin {\n    foreach (immutable char ch; word)\n        assert(ch.isASCII);\n    foreach (const block; blocks)\n        assert(block.length == 2 && block[0].isASCII && block[1].isASCII);\n} body {\n    auto ptr = cast(string*)alloca(blocks.length * string.sizeof);\n    if (ptr == null)\n        exit(1);\n    auto blocks2 = ptr[0 .. blocks.length];\n    blocks2[] = blocks[];\n\n    outer: foreach (immutable i; 0 .. word.length) {\n        immutable ch = word[i].toUpper;\n        foreach (immutable j; 0 .. blocks2.length) {\n            if (blocks2[j][0] == ch || blocks2[j][1] == ch) {\n                if (blocks2.length > 1)\n                    blocks2[j] = blocks2[$ - 1];\n                blocks2 = blocks2[0 .. $ - 1];\n                continue outer;\n            }\n        }\n        return false;\n    }\n    return true;\n}\n\nvoid main() {\n    import std.stdio, std.string;\n\n    immutable blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI\n                        AN OB ER FS LY PC ZM\".split;\n\n    foreach (word; \"\" ~ \"A BARK BoOK TrEAT COmMoN SQUAD conFUsE\".split)\n        writefln(`\"%s\" %s`, word, canMakeWord(word, blocks));\n}\n\nRecursive Version[edit]\n\nTranslation of: C\nimport std.stdio, std.ascii, std.algorithm, std.array;\n\nalias Block = char[2];\n\n// Modifies the order of the given blocks.\nbool canMakeWord(Block[] blocks, in string word) pure nothrow\nin {\n    assert(blocks.all!(w => w[].all!isAlpha));\n    assert(word.all!isAlpha);\n} body {\n    if (word.empty)\n        return true;\n\n    immutable c = word[0].toUpper;\n    foreach (ref b; blocks) {\n        if (b[0].toUpper != c && b[1].toUpper != c)\n            continue;\n        blocks[0].swap(b);\n        if (blocks[1 .. $].canMakeWord(word[1 .. $]))\n            return true;\n        blocks[0].swap(b);\n    }\n\n    return false;\n}\n\nvoid main() {\n    enum Block[] blocks = \"BO XK DQ CP NA GT RE TG QD FS\n                           JW HU VI AN OB ER FS LY PC ZM\".split;\n\n    foreach (w; \"\" ~ \"A BARK BoOK TrEAT COmMoN SQUAD conFUsE\".split)\n        writefln(`\"%s\" %s`, w, blocks.canMakeWord(w));\n\n    // Extra test.\n    Block[] blocks2 = [\"AB\", \"AB\", \"AC\", \"AC\"];\n    immutable word = \"abba\";\n    writefln(`\"%s\" %s`, word, blocks2.canMakeWord(word));\n}\n\n\nOutput:\n\"\" true\n\"A\" true\n\"BARK\" true\n\"BoOK\" false\n\"TrEAT\" true\n\"COmMoN\" false\n\"SQUAD\" true\n\"conFUsE\" true\n\"abba\" true\nAlternative Recursive Version[edit]\n\nimport std.stdio, std.ascii, std.algorithm, std.array, std.range;\n\nalias Block = char[2];\n\nbool canMakeWord(immutable Block[] blocks, in string word) pure nothrow\nin {\n    assert(blocks.all!(w => w[].all!isAlpha));\n    assert(word.all!isAlpha);\n} body {\n    bool inner(size_t[] indexes, in string w) pure nothrow {\n        if (w.empty)\n            return true;\n\n        immutable c = w[0].toUpper;\n        foreach (ref idx; indexes) {\n            if (blocks[idx][0].toUpper != c &&\n                blocks[idx][1].toUpper != c)\n                continue;\n            indexes[0].swap(idx);\n            if (inner(indexes[1 .. $], w[1 .. $]))\n                return true;\n            indexes[0].swap(idx);\n        }\n\n        return false;\n    }\n\n    return inner(blocks.length.iota.array, word);\n}\n\nvoid main() {\n    enum Block[] blocks = \"BO XK DQ CP NA GT RE TG QD FS\n                           JW HU VI AN OB ER FS LY PC ZM\".split;\n\n    foreach (w; \"\" ~ \"A BARK BoOK TrEAT COmMoN SQUAD conFUsE\".split)\n        writefln(`\"%s\" %s`, w, blocks.canMakeWord(w));\n\n    // Extra test.\n    immutable Block[] blocks2 = [\"AB\", \"AB\", \"AC\", \"AC\"];\n    immutable word = \"abba\";\n    writefln(`\"%s\" %s`, word, blocks2.canMakeWord(word));\n}\n\n\n", "explain": "A simple greedy algorithm is enough for the given sequence of blocks. canMakeWord is true on an empty word because you can compose it using zero blocks.\nThe same as the precedent version, but it avoids all heap allocations and it's lower-level and ASCII-only.\nThis version is able to find the solution for the word \"abba\" given the blocks AB AB AC AC.\nThis version doesn't shuffle the input blocks, but it's more complex and it allocates an array of indexes.\nThe output is the same.\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Haskell", "code": "\n\nimport Data.List (delete)\nimport Data.Char (toUpper)\n\n-- returns list of all solutions, each solution being a list of blocks\nabc :: (Eq a) => [[a]] -> [a] -> [[[a]]]\nabc _ [] = [[]]\nabc blocks (c:cs) = [b:ans | b <- blocks, c `elem` b,\n                             ans <- abc (delete b blocks) cs]\n\nblocks = [\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n          \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"]\n\nmain :: IO ()\nmain = mapM_ (\\w -> print (w, not . null $ abc blocks (map toUpper w)))\n         [\"\", \"A\", \"BARK\", \"BoOK\", \"TrEAT\", \"COmMoN\", \"SQUAD\", \"conFUsE\"]\n\n\nOutput:\n(\"\",True)\n(\"A\",True)\n(\"BARK\",True)\n(\"BoOK\",False)\n(\"TrEAT\",True)\n(\"COmMoN\",False)\n(\"SQUAD\",True)\n(\"conFUsE\",True)\n\n\nimport Data.Char (toUpper)\nimport Data.List (delete)\n\n\n----------------------- ABC PROBLEM ----------------------\n\nspellWith :: [String] -> String -> [[String]]\nspellWith _ [] = [[]]\nspellWith blocks (x : xs) = blocks >>= go\n  where\n    go b\n      | x `elem` b = (b :) <$> spellWith (delete b blocks) xs\n      | otherwise = []\n\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_\n    ( print\n        . ((,) <*>)\n          (not . null . spellWith blocks . fmap toUpper)\n    )\n    [ \"\",\n      \"A\",\n      \"BARK\",\n      \"BoOK\",\n      \"TrEAT\",\n      \"COmMoN\",\n      \"SQUAD\",\n      \"conFUsE\"\n    ]\n\nblocks :: [String]\nblocks =\n  words $\n    \"BO XK DQ CP NA GT RE TG QD FS JW\"\n      <> \" HU VI AN OB ER FS LY PC ZM\"\n\n\nOutput:\n(\"\",True)\n(\"A\",True)\n(\"BARK\",True)\n(\"BoOK\",False)\n(\"TrEAT\",True)\n(\"COmMoN\",False)\n(\"SQUAD\",True)\n(\"conFUsE\",True)\n", "explain": "The following function returns a list of all the solutions. Since Haskell is lazy, testing whether the list is null will only do the minimal amount of work necessary to determine whether a solution exists.\nOr, in terms of the bind operator:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Scheme", "code": "\n\n(define *blocks*\n  '((#\\B #\\O) (#\\X #\\K) (#\\D #\\Q) (#\\C #\\P) (#\\N #\\A)\n    (#\\G #\\T) (#\\R #\\E) (#\\T #\\G) (#\\Q #\\D) (#\\F #\\S)\n    (#\\J #\\W) (#\\H #\\U) (#\\V #\\I) (#\\A #\\N) (#\\O #\\B)\n    (#\\E #\\R) (#\\F #\\S) (#\\L #\\Y) (#\\P #\\C) (#\\Z #\\M)))\n\n(define (exists p? li)\n  (and (not (null? li))\n       (or (p? (car li))\n           (exists p? (cdr li)))))\n\n(define (remove-one x li)\n  (cond\n    ((null? li) '())\n    ((equal? (car li) x) (cdr li))\n    (else (cons (car li) (remove-one x (cdr li))))))\n\n(define (can-make-list? li blocks)\n  (or (null? li)\n      (exists\n       (lambda (block)\n         (and\n          (member (char-upcase (car li)) block)\n          (can-make-list? (cdr li) (remove-one block blocks))))\n       blocks)))\n\n(define (can-make-word? word)\n  (can-make-list? (string->list word) *blocks*))\n \n \n(define *words*\n  '(\"A\" \"Bark\" \"book\" \"TrEaT\" \"COMMON\" \"squaD\" \"CONFUSE\"))\n \n(for-each\n (lambda (word)\n   (display (if (can-make-word? word)\n                \"   Can make word: \"\n                \"Cannot make word: \"))\n   (display word)\n   (newline))\n *words*)\n\nOutput:\n   Can make word: A\n   Can make word: Bark\nCannot make word: book\n   Can make word: TrEaT\nCannot make word: COMMON\n   Can make word: squaD\n   Can make word: CONFUSE\n\n", "explain": "In R5RS:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Apex", "code": "\nstatic Boolean canMakeWord(List<String> src_blocks, String word) {\n    if (String.isEmpty(word)) {\n        return true;\n    }\n\n    List<String> blocks = new List<String>();\n    for (String block : src_blocks) {\n        blocks.add(block.toUpperCase());\n    }\n    \n    for (Integer i = 0; i < word.length(); i++) {\n        Integer blockIndex = -1;\n        String c = word.mid(i, 1).toUpperCase();\n        \n        for (Integer j = 0; j < blocks.size(); j++) {\n            if (blocks.get(j).contains(c)) {\n                blockIndex = j;\n                break;\n            }\n        }\n        \n        if (blockIndex == -1) {\n            return false;\n        } else {\n            blocks.remove(blockIndex);\n        }\n    }\n        \n    return true;\n}\n\nList<String> blocks = new List<String>{\n    'BO', 'XK', 'DQ', 'CP', 'NA',\n    'GT', 'RE', 'TG', 'QD', 'FS', \n    'JW', 'HU', 'VI', 'AN', 'OB', \n    'ER', 'FS', 'LY', 'PC', 'ZM'\n};\nSystem.debug('\"\": ' + canMakeWord(blocks, ''));\nSystem.debug('\"A\": ' + canMakeWord(blocks, 'A'));\nSystem.debug('\"BARK\": ' + canMakeWord(blocks, 'BARK'));\nSystem.debug('\"book\": ' + canMakeWord(blocks, 'book'));\nSystem.debug('\"treat\": ' + canMakeWord(blocks, 'treat'));\nSystem.debug('\"COMMON\": ' + canMakeWord(blocks, 'COMMON'));\nSystem.debug('\"SQuAd\": ' + canMakeWord(blocks, 'SQuAd'));\nSystem.debug('\"CONFUSE\": ' + canMakeWord(blocks, 'CONFUSE'));\n\n\nOutput:\n\"\": true\n\"A\": true\n\"BARK\": true\n\"book\": false\n\"treat\": true\n\"COMMON\": false\n\"SQuAd\": true\n\"CONFUSE\": true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "PowerShell", "code": "\n<#\n.Synopsis\n  ABC Problem\n.DESCRIPTION\n   You are given a collection of ABC blocks. Just like the ones you had when you were a kid. \n   There are twenty blocks with two letters on each block. You are guaranteed to have a \n   complete alphabet amongst all sides of the blocks\n   blocks = \"BO\",\"XK\",\"DQ\",\"CP\",\"NA\",\"GT\",\"RE\",\"TG\",\"QD\",\"FS\",\"JW\",\"HU\",\"VI\",\"AN\",\"OB\",\"ER\",\"FS\",\"LY\",\"PC\",\"ZM\"\n   The goal of this task is to write a function that takes a string and can determine whether \n   you can spell the word with the given collection of blocks. \n\n   The rules are simple: \n        1.Once a letter on a block is used that block cannot be used again \n        2.The function should be case-insensitive \n        3. Show your output on this page for the following words:\n        >>> can_make_word(\"A\")\n        True\n        >>> can_make_word(\"BARK\")\n        True\n        >>> can_make_word(\"BOOK\")\n        False\n        >>> can_make_word(\"TREAT\")\n        True\n        >>> can_make_word(\"COMMON\")\n        False\n        >>> can_make_word(\"SQUAD\")\n        True\n        >>> can_make_word(\"CONFUSE\")\n        True\n\n   Using the examples below  you can either see just the value or \n   status and the values using the verbose switch\n\n.EXAMPLE\n   test-blocks -testword confuse\n\n.EXAMPLE\n   test-blocks -testword confuse -verbose\n\n#>\n\nfunction test-blocks\n{\n\t[CmdletBinding()]\n\t#  [OutputType([int])]\n\tParam\n\t(\n\t\t# word to test against blocks\n\t\t[Parameter(Mandatory = $true,\n\t\t\t\t   ValueFromPipelineByPropertyName = $true)]\n\t\t$testword\n\t\t\n\t)\n\n\t$word = $testword\n\t\n\t#define array of blocks\n\t[System.Collections.ArrayList]$blockarray = \"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\", \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"\n\t\n\t#send word to chararray\n\t$chararray = $word.ToCharArray()\n\t$chars = $chararray\n\t\n\t#get the character count\n\t$charscount = $chars.count\n\t\n\t#get the initial count of the blocks\n\t$blockcount = $blockarray.Count\n\t\n\t#find out how many blocks should be left from the difference\n\t#of the blocks and characters in the word - 1 letter/1 block\n\t$correctblockcount = $blockcount - $charscount\n\t\n\t#loop through the characters in the word\n\tforeach ($char in $chars)\n\t{\n\t\t\n\t\t#loop through the blocks\n\t\tforeach ($block in $blockarray)\n\t\t{\n\t\t\t\n\t\t\t#check the current character against each letter on the current block\n\t\t\t#and break if found so the array can reload\n\t\t\tif ($char -in $block[0] -or $char -in $block[1])\n\t\t\t{\n\t\t\t\t\n\t\t\t\twrite-verbose \"match for letter - $char - removing block $block\"\n\t\t\t\t$blockarray.Remove($block)\n\t\t\t\tbreak\n\t\t\t\t\n\t\t\t}\n\t\t\t\n\t\t}\n\t\t\n\t}\n\t#get final count of blocks left in array to determine if the word was\n\t#correctly made\n\t$finalblockcount = $blockarray.count\n\tif ($finalblockcount -ne $correctblockcount)\n\t{\n\t\twrite-verbose \"$word\u00a0: $false \"\n\t\treturn $false\n\t}\n\telse\n\t{\n\t\twrite-verbose \"$word\u00a0: $true \"\n\t\treturn $true\n\t}\n\t\n}\n\n#loop all the words and pass them to the function\n$wordlist = \"a\", \"bark\", \"book\", \"treat\", \"common\", \"squad\", \"confuse\"\nforeach ($word in $wordlist)\n{\n\ttest-blocks -testword $word -Verbose\n}\n\n\nOutput:\nVERBOSE: match for letter - a - removing block NA\nVERBOSE: a\u00a0: True \nTrue\nVERBOSE: match for letter - b - removing block BO\nVERBOSE: match for letter - a - removing block NA\nVERBOSE: match for letter - r - removing block RE\nVERBOSE: match for letter - k - removing block XK\nVERBOSE: bark\u00a0: True \nTrue\nVERBOSE: match for letter - b - removing block BO\nVERBOSE: match for letter - o - removing block OB\nVERBOSE: match for letter - k - removing block XK\nVERBOSE: book\u00a0: False \nFalse\nVERBOSE: match for letter - t - removing block GT\nVERBOSE: match for letter - r - removing block RE\nVERBOSE: match for letter - e - removing block ER\nVERBOSE: match for letter - a - removing block NA\nVERBOSE: match for letter - t - removing block TG\nVERBOSE: treat\u00a0: True \nTrue\nVERBOSE: match for letter - c - removing block CP\nVERBOSE: match for letter - o - removing block BO\nVERBOSE: match for letter - m - removing block ZM\nVERBOSE: match for letter - o - removing block OB\nVERBOSE: match for letter - n - removing block NA\nVERBOSE: common\u00a0: False \nFalse\nVERBOSE: match for letter - s - removing block FS\nVERBOSE: match for letter - q - removing block DQ\nVERBOSE: match for letter - u - removing block HU\nVERBOSE: match for letter - a - removing block NA\nVERBOSE: match for letter - d - removing block QD\nVERBOSE: squad\u00a0: True \nTrue\nVERBOSE: match for letter - c - removing block CP\nVERBOSE: match for letter - o - removing block BO\nVERBOSE: match for letter - n - removing block NA\nVERBOSE: match for letter - f - removing block FS\nVERBOSE: match for letter - u - removing block HU\nVERBOSE: match for letter - s - removing block FS\nVERBOSE: match for letter - e - removing block RE\nVERBOSE: confuse\u00a0: True \nTrue\n\nor without verbose\n\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Logo", "code": "\nmake \"blocks [[B O] [X K] [D Q] [C P] [N A] [G T] [R E] [T G] [Q D] [F S]\n              [J W] [H U] [V I] [A N] [O B] [E R] [F S] [L Y] [P C] [Z M]]\n\nto can_make? :word [:avail :blocks]\n  if empty? :word [output \"true]\n  local \"letter make \"letter first :word\n  foreach :avail [\n    local \"i     make \"i     #\n    local \"block make \"block\u00a0?\n    if member? :letter :block [\n      if (can_make? bf :word filter [notequal? # :i] :avail) [output \"true]\n    ]\n  ]\n  output \"false\nend\n\nforeach [A BARK BOOK TREAT COMMON SQUAD CONFUSE] [\n  print sentence word\u00a0? \": can_make?\u00a0?\n]\n\nbye\n\nOutput:\nA: true\nBARK: true\nBOOK: false\nTREAT: true\nCOMMON: false\nSQUAD: true\nCONFUSE: true\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "ABAP", "code": "\nREPORT z_rosetta_abc.\n\n\" Type declaration for blocks of letters\nTYPES: BEGIN OF block,\n         s1 TYPE char1,\n         s2 TYPE char1,\n       END OF block,\n\n       blocks_table TYPE STANDARD TABLE OF block.\n\nDATA: blocks TYPE blocks_table.\n\nCLASS word_maker DEFINITION.\n  PUBLIC SECTION.\n    CLASS-METHODS:\n      can_make_word\n        IMPORTING word          TYPE string\n                  letter_blocks TYPE blocks_table\n        RETURNING VALUE(found)  TYPE abap_bool.\nENDCLASS.\n\nCLASS word_maker IMPLEMENTATION.\n  METHOD can_make_word.\n\n    \" Create a reader stream that reads 1 character at a time\n    DATA(reader) = NEW cl_abap_string_c_reader( word ).\n\n    DATA(blocks) = letter_blocks.\n\n    WHILE reader->data_available( ).\n\n      DATA(ch) = to_upper( reader->read( 1 ) ).\n      found = abap_false.\n\n      LOOP AT blocks REFERENCE INTO DATA(b).\n        IF ch = b->s1 OR ch = b->s2.\n          found = abap_true.\n          DELETE blocks INDEX sy-tabix.\n          EXIT. \" the inner loop once a character is found\n        ENDIF.\n      ENDLOOP.\n\n      \" If a character could not be found, stop looking further\n      IF found = abap_false.\n        RETURN.\n      ENDIF.\n    ENDWHILE.\n\n  ENDMETHOD.\nENDCLASS.\n\nSTART-OF-SELECTION.\n\n  blocks = VALUE #( ( s1 = 'B' s2 = 'O' ) ( s1 = 'X' s2 = 'K' )\n                    ( s1 = 'D' s2 = 'Q' ) ( s1 = 'C' s2 = 'P' )\n                    ( s1 = 'N' s2 = 'A' ) ( s1 = 'G' s2 = 'T' )\n                    ( s1 = 'R' s2 = 'E' ) ( s1 = 'T' s2 = 'G' )\n                    ( s1 = 'Q' s2 = 'D' ) ( s1 = 'F' s2 = 'S' )\n                    ( s1 = 'J' s2 = 'W' ) ( s1 = 'H' s2 = 'U' )\n                    ( s1 = 'V' s2 = 'I' ) ( s1 = 'A' s2 = 'N' )\n                    ( s1 = 'O' s2 = 'B' ) ( s1 = 'E' s2 = 'R' )\n                    ( s1 = 'F' s2 = 'S' ) ( s1 = 'L' s2 = 'Y' )\n                    ( s1 = 'P' s2 = 'C' ) ( s1 = 'Z' s2 = 'M' )\n                  ).\n\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'A'        letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'BARK'     letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'BOOK'     letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'TREAT'    letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'COMMON'   letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'SQUAD'    letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n  WRITE:/ COND string( WHEN word_maker=>can_make_word( word = 'CONFUSE'  letter_blocks = blocks ) = abap_true THEN 'True' ELSE 'False' ).\n\n\nOutput:\nTrue\nTrue\nFalse\nTrue\nFalse\nTrue\nTrue\n\n", "explain": ""}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "F#", "code": "\n\nlet rec spell_word_with blocks w =\n    let rec look_for_right_candidate candidates noCandidates c rest =\n        match candidates with\n        | [] -> false\n        | c0::cc -> \n            if spell_word_with (cc@noCandidates) rest then true\n            else look_for_right_candidate cc (c0::noCandidates) c rest\n\n    match w with\n    | \"\" -> true\n    | w ->\n        let c = w.[0]\n        let rest = w.Substring(1)\n        let (candidates, noCandidates) = List.partition(fun (c1,c2) -> c = c1 || c = c2) blocks\n        look_for_right_candidate candidates noCandidates c rest\n\n[<EntryPoint>]\nlet main argv =\n    let default_blocks = \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\"\n    let blocks =\n        (if argv.Length > 0 then argv.[0] else default_blocks).Split()\n        |> List.ofArray\n        |> List.map(fun s -> s.ToUpper())\n        |> List.map(fun s2 -> s2.[0], s2.[1])\n    let words =\n        (if argv.Length > 0 then List.ofArray(argv).Tail else [])\n        |> List.map(fun s -> s.ToUpper())\n\n    List.iter (fun w -> printfn \"Using the blocks we can make the word '%s': %b\" w (spell_word_with blocks w)) words\n    0\n\n\nOutput:\nh:\\RosettaCode\\ABC\\Fsharp>RosettaCode \"BO XK DQ CP NA GT RE TG QD FS JW HU VI AN OB ER FS LY PC ZM\" a bark book threat common squad confuse\nUsing the blocks we can make the word 'A': true\nUsing the blocks we can make the word 'BARK': true\nUsing the blocks we can make the word 'BOOK': false\nUsing the blocks we can make the word 'THREAT': true\nUsing the blocks we can make the word 'COMMON': false\nUsing the blocks we can make the word 'SQUAD': true\nUsing the blocks we can make the word 'CONFUSE': true\n\nh:\\RosettaCode\\ABC\\Fsharp>RosettaCode  \"aB aB Ac Ac\" abba\nUsing the blocks we can make the word 'ABBA': true\n\nh:\\RosettaCode\\ABC\\Fsharp>RosettaCode \"US TZ AO QA\" Auto\nUsing the blocks we can make the word 'AUTO': true\nTranslation of: OCaml\nlet blocks = [\n  ('B', 'O');  ('X', 'K');  ('D', 'Q');  ('C', 'P');\n  ('N', 'A');  ('G', 'T');  ('R', 'E');  ('T', 'G');\n  ('Q', 'D');  ('F', 'S');  ('J', 'W');  ('H', 'U');\n  ('V', 'I');  ('A', 'N');  ('O', 'B');  ('E', 'R');\n  ('F', 'S');  ('L', 'Y');  ('P', 'C');  ('Z', 'M');\n]\n\nlet find_letter blocks c =\n  let found, remaining =\n    List.partition (fun (c1, c2) -> c1 = c || c2 = c) blocks\n  in\n  match found with\n  | _ :: res -> Some (res @ remaining)\n  | _ -> None\n\nlet can_make_word w =\n  let n = String.length w in\n  let rec aux i _blocks =\n    if i >= n then true else\n      match find_letter _blocks w.[i] with\n      | None -> false\n      | Some rem_blocks ->\n          aux (i+1) rem_blocks\n  in\n  aux 0 blocks\n\nlet test label f (word, should) =\n  printfn \"- %s %s = %A  (should: %A)\" label word (f word) should\n\nlet () =\n  List.iter (test \"can make word\" can_make_word) [\n    \"A\", true;\n    \"BARK\", true;\n    \"BOOK\", false;\n    \"TREAT\", true;\n    \"COMMON\", false;\n    \"SQUAD\", true;\n    \"CONFUSE\", true;\n  ]\n\n", "explain": "This solution does not depend on the order of the blocks, neither on the symmetry of blocks we see in the example block set. (Symmetry: if AB is a block, an A comes only with another AB|BA)"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "Groovy", "code": "\n\nclass ABCSolver {\n    def blocks\n\n    ABCSolver(blocks = []) { this.blocks = blocks }\n\n    boolean canMakeWord(rawWord) {\n        if (rawWord == '' || rawWord == null) { return true; }\n        def word = rawWord.toUpperCase()\n        def blocksLeft = [] + blocks\n        word.every { letter -> blocksLeft.remove(blocksLeft.find { block -> block.contains(letter) }) }\n    }\n}\n\n\ndef a = new ABCSolver([\"BO\", \"XK\", \"DQ\", \"CP\", \"NA\", \"GT\", \"RE\", \"TG\", \"QD\", \"FS\",\n                      \"JW\", \"HU\", \"VI\", \"AN\", \"OB\", \"ER\", \"FS\", \"LY\", \"PC\", \"ZM\"])\n\n['', 'A', 'BARK', 'book', 'treat', 'COMMON', 'SQuAd', 'CONFUSE'].each {\n    println \"'${it}': ${a.canMakeWord(it)}\"\n}\n\n\nOutput:\n'': true\n'A': true\n'BARK': true\n'book': false\n'treat': true\n'COMMON': false\n'SQuAd': true\n'CONFUSE': true\n", "explain": "Solution:\nTest:\n"}, {"task_name": "ABC problem", "task_url": "https://rosettacode.org/wiki/ABC_problem", "task_cat": "Puzzles", "lang": "AWK", "code": "\n\n#!/usr/bin/awk -f\n# tested with mawk 1.3.3 on Raspberry Pi 3\n#        also GNU awk 3.1.5, busybox 1.21.1 and 1.27.1 on AMD Sempron 2800+\n#\nfunction setblocks() {\n# key to the algorithm is the representation of a block\n# each block is represented by 4 characters in the string \"blocks\"\n# for example, the \"BO\" block becomes \"-BO-\"\n#\nblocks=\"-BO--XK--DQ--CP--NA--GT--RE--TG--QD--FS--JW--HU--VI--AN--OB--ER--FS--LY--PC--ZM-\"\ntrue=1\nfalse=0\n}\nfunction found(letter){\n#\n# the function \"found\" scans for the letter on the top of a block\n# using the pattern \"-B\", for example, to find a \"B\",\n# returning \"true\" (or 1) if found\n# if not found on the top, look on the bottoms using the pattern \"B-\"\n# again returning \"true\" if found\n# if the letter is found on either top or bottom, the 4 character block is set to \"----\"\n# so that block is unavailable \n# finally, if no available copy of letter is found,\n# the function returns \"false\" (0)\nposition= index(blocks,\"-\" letter)\nif (position > 0)\n   { \n  blocks = substr(blocks,1,position-1) \"----\" substr(blocks,position+4)\n  return true\n   }\nposition = index(blocks,letter \"-\")\nif (position > 0)\n   {blocks = substr(blocks,1,position-3) \"----\" substr(blocks,position+2)\n     return true\n    }\nreturn false\n}\n# awk's BEGIN statement allows for initialization before processing input;\n# in this case, initializing the string \"blocks\"\n#\nBEGIN{\nsetblocks()\n}\n# in awk, the input record is contained in the string variable \"$0\"\n# the main process checks each letter in turn to see if it is on a usable block,\n# summing the values returned by \"found\"\n# if the sum equals the number of input characters the word can be spelled with the blocks\n# otherwise it is not possible\n#\n{\nnchars=length($0)\npossible=false\nfor (i=1;i<=nchars;i++){\n     possible=possible + found(substr($0,i,1))\n}\nif (possible==nchars) print $0 \" is possible\"\n   else print $0 \" is not possible\"\nsetblocks()\n}\n\n and -----------------\n#!/usr/bin/awk -f\n# tested with mawk 1.3.3 on Raspberry Pi 3\n#        also GNU awk 3.1.5, busybox 1.21.1 and 1.27.1 on AMD Sempron 2800+\n#\nfunction setblocks() {\n#\n#  key to the algorithm is the representation of the blocks\n# each block is represented by 1 character in the string \"tops\"\n# and by 1 character in the string \"bottoms\"\n#\n   tops=\"BXDCNGRTQFJHVAOEFLPZ\"\nbottoms=\"OKQPATEGDSWUINBRSYCM\"\ntrue=1\nfalse=0\n}\nfunction found(letter){\n#\n# the function \"found\" scans first the string \"tops\" for a letter and\n# then the string \"bottoms\" if the letter is not in \"tops\"\n# if the letter is found, it marks \"tops\" and \"bottoms\" to show\n# the block is unavailable by changing the letters on the block to \"-\"\n# and returns \"true\" (1); if the letter is not found\n# the function returns \"false\" (0)\n#\nposition= index(tops,letter)\nif (position > 0)\n   { \n  tops = substr(tops,1,position-1) \"-\" substr(tops,position+1)\n  bottoms = substr(bottoms,1,position-1) \"-\" substr(bottoms,position+1)\n  return true\n   }\nposition = index(bottoms,letter)\nif (position > 0)\n   {bottoms = substr(bottoms,1,position-1) \"-\" substr(bottoms,position+1)\n    tops = substr(tops,1,position-1) \"-\" substr(tops,position+1)\n     return true\n    }\nreturn false\n}\n# awk's BEGIN statement allows for initialization before processing input;\n# in this case, initializing the string \"blocks\"\n#\nBEGIN{\nsetblocks()\n}\n# in awk, the input record is contained in the string variable \"$0\"\n# the main process checks each letter in turn to see if it is on a usable block,\n# summing the values returned by \"found\"\n# if the sum equals the number of input characters the word can be spelled with the blocks\n# otherwise it is not possible\n#\n{\nnchars=length($0)\npossible=false\nfor (i=1;i<=nchars;i++){\n     possible=possible + found(substr($0,i,1))\n}\nif (possible==nchars) print $0 \" is possible\"\n   else print $0 \" is not possible\"\nsetblocks()\n}\n\n\nOutput:\npi@raspberrypi:~/Documents/rosettacode $ ./abcProblem.awk \nA\nA is possible\nBARK\nBARK is possible\nBOOK\nBOOK is not possible\nTREAT\nTREAT is possible\nCOMMON\nCOMMON is not possible\nSQUAD\nSQUAD is possible\nCONFUSE\nCONFUSE is possible\n^C\npi@raspberrypi:~/Documents/rosettacode $ \n\n", "explain": "Here are 2 slightly different versions:\n"}]