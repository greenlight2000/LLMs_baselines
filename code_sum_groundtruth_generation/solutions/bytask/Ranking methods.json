[{"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Python", "code": "\ndef mc_rank(iterable, start=1):\n    \"\"\"Modified competition ranking\"\"\"\n    lastresult, fifo = None, []\n    for n, item in enumerate(iterable, start-1):\n        if item[0] == lastresult:\n            fifo += [item]\n        else:\n            while fifo:\n                yield n, fifo.pop(0)\n            lastresult, fifo = item[0], fifo + [item]\n    while fifo:\n        yield n+1, fifo.pop(0)\n\n\ndef sc_rank(iterable, start=1):\n    \"\"\"Standard competition ranking\"\"\"\n    lastresult, lastrank = None, None\n    for n, item in enumerate(iterable, start):\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            yield n, item\n            lastresult, lastrank = item[0], n\n\n\ndef d_rank(iterable, start=1):\n    \"\"\"Dense ranking\"\"\"\n    lastresult, lastrank = None, start - 1,\n    for item in iterable:\n        if item[0] == lastresult:\n            yield lastrank, item\n        else:\n            lastresult, lastrank = item[0], lastrank + 1\n            yield lastrank, item\n\n\ndef o_rank(iterable, start=1):\n    \"\"\"Ordinal  ranking\"\"\"\n    yield from enumerate(iterable, start)\n\n\ndef f_rank(iterable, start=1):\n    \"\"\"Fractional ranking\"\"\"\n    last, fifo = None, []\n    for n, item in enumerate(iterable, start):\n        if item[0] != last:\n            if fifo:\n                mean = sum(f[0] for f in fifo) / len(fifo)\n                while fifo:\n                    yield mean, fifo.pop(0)[1]\n        last = item[0]\n        fifo.append((n, item))\n    if fifo:\n        mean = sum(f[0] for f in fifo) / len(fifo)\n        while fifo:\n            yield mean, fifo.pop(0)[1]\n\n\nif __name__ == '__main__':\n    scores = [(44, 'Solomon'),\n              (42, 'Jason'),\n              (42, 'Errol'),\n              (41, 'Garry'),\n              (41, 'Bernard'),\n              (41, 'Barry'),\n              (39, 'Stephen')]\n\n    print('\\nScores to be ranked (best first):')\n    for s in scores:\n        print('        %2i %s' % (s ))\n    for ranker in [sc_rank, mc_rank, d_rank, o_rank, f_rank]:\n        print('\\n%s:' % ranker.__doc__)\n        for rank, score in ranker(scores):\n            print('  %3g, %r' % (rank, score))\n\n\nOutput:\nScores to be ranked (best first):\n        44 Solomon\n        42 Jason\n        42 Errol\n        41 Garry\n        41 Bernard\n        41 Barry\n        39 Stephen\n\nStandard competition ranking:\n    1, (44, 'Solomon')\n    2, (42, 'Jason')\n    2, (42, 'Errol')\n    4, (41, 'Garry')\n    4, (41, 'Bernard')\n    4, (41, 'Barry')\n    7, (39, 'Stephen')\n\nModified competition ranking:\n    1, (44, 'Solomon')\n    3, (42, 'Jason')\n    3, (42, 'Errol')\n    6, (41, 'Garry')\n    6, (41, 'Bernard')\n    6, (41, 'Barry')\n    7, (39, 'Stephen')\n\nDense ranking:\n    1, (44, 'Solomon')\n    2, (42, 'Jason')\n    2, (42, 'Errol')\n    3, (41, 'Garry')\n    3, (41, 'Bernard')\n    3, (41, 'Barry')\n    4, (39, 'Stephen')\n\nOrdinal  ranking:\n    1, (44, 'Solomon')\n    2, (42, 'Jason')\n    3, (42, 'Errol')\n    4, (41, 'Garry')\n    5, (41, 'Bernard')\n    6, (41, 'Barry')\n    7, (39, 'Stephen')\n\nFractional ranking:\n    1, (44, 'Solomon')\n  2.5, (42, 'Jason')\n  2.5, (42, 'Errol')\n    5, (41, 'Garry')\n    5, (41, 'Bernard')\n    5, (41, 'Barry')\n    7, (39, 'Stephen')\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "C", "code": "\n\n#include<stdlib.h>\n#include<stdio.h>\n\ntypedef struct{\n\tint score;\n\tchar name[100];\n}entry;\n\nvoid ordinalRanking(entry* list,int len){\n\t\n\tint i;\n\t\n\tprintf(\"\\n\\nOrdinal Ranking\\n---------------\");\n\t\n\tfor(i=0;i<len;i++)\n\t\tprintf(\"\\n%d\\t%d\\t%s\",i+1,list[i].score,list[i].name);\n}\n\nvoid standardRanking(entry* list,int len){\n\t\n\tint i,j=1;\n\t\n\tprintf(\"\\n\\nStandard Ranking\\n----------------\");\n\t\n\tfor(i=0;i<len;i++){\n\t\tprintf(\"\\n%d\\t%d\\t%s\",j,list[i].score,list[i].name);\n\t\tif(list[i+1].score<list[i].score)\n\t\t\tj = i+2;\n\t}\n}\n\nvoid denseRanking(entry* list,int len){\n\t\n\tint i,j=1;\n\t\n\tprintf(\"\\n\\nDense Ranking\\n-------------\");\n\t\n\tfor(i=0;i<len;i++){\n\t\tprintf(\"\\n%d\\t%d\\t%s\",j,list[i].score,list[i].name);\n\t\tif(list[i+1].score<list[i].score)\n\t\t\tj++;\n\t}\n}\n\nvoid modifiedRanking(entry* list,int len){\n\t\n\tint i,j,count;\n\t\n\tprintf(\"\\n\\nModified Ranking\\n----------------\");\n\t\n\tfor(i=0;i<len-1;i++){\n\t\tif(list[i].score!=list[i+1].score){\n\t\t\tprintf(\"\\n%d\\t%d\\t%s\",i+1,list[i].score,list[i].name);\n\t\t\tcount = 1;\n\t\t\tfor(j=i+1;list[j].score==list[j+1].score && j<len-1;j++)\n\t\t\t\tcount ++;\n\t\t\tfor(j=0;j<count-1;j++)\n\t\t\t\tprintf(\"\\n%d\\t%d\\t%s\",i+count+1,list[i+j+1].score,list[i+j+1].name);\n\t\t\ti += (count-1);\n\t\t}\n\t}\n\tprintf(\"\\n%d\\t%d\\t%s\",len,list[len-1].score,list[len-1].name);\n}\n\nvoid fractionalRanking(entry* list,int len){\n\t\n\tint i,j,count;\n\tfloat sum = 0;\n\t\n\tprintf(\"\\n\\nFractional Ranking\\n------------------\");\n\t\n\tfor(i=0;i<len;i++){\n\t\tif(i==len-1 || list[i].score!=list[i+1].score)\n\t\t\tprintf(\"\\n%.1f\\t%d\\t%s\",(float)(i+1),list[i].score,list[i].name);\n\t\telse if(list[i].score==list[i+1].score){\n\t\t\tsum = i;\n\t\t\tcount = 1;\n\t\t\tfor(j=i;list[j].score==list[j+1].score;j++){\n\t\t\t\tsum += (j+1);\n\t\t\t\tcount ++;\n\t\t\t}\n\t\t\tfor(j=0;j<count;j++)\n\t\t\t\tprintf(\"\\n%.1f\\t%d\\t%s\",sum/count + 1,list[i+j].score,list[i+j].name);\n\t\t\ti += (count-1);\n\t\t}\n\t}\n}\n\nvoid processFile(char* fileName){\n\tFILE* fp = fopen(fileName,\"r\");\n\tentry* list;\n\tint i,num;\n\t\n\tfscanf(fp,\"%d\",&num);\n\t\n\tlist = (entry*)malloc(num*sizeof(entry));\n\t\n\tfor(i=0;i<num;i++)\n\t\tfscanf(fp,\"%d%s\",&list[i].score,list[i].name);\n\t\n\tfclose(fp);\n\t\n\tordinalRanking(list,num);\n\tstandardRanking(list,num);\n\tdenseRanking(list,num);\n\tmodifiedRanking(list,num);\n\tfractionalRanking(list,num);\n}\n\nint main(int argC,char* argV[])\n{\n\tif(argC!=2)\n\t\tprintf(\"Usage %s <score list file>\");\n\telse\n\t\tprocessFile(argV[1]);\n\treturn 0;\n}\n\n\n7\n44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\n\n\nC:\\rosettaCode>ranking.exe rankData.txt\n\n\nOrdinal Ranking\n---------------\n1       44      Solomon\n2       42      Jason\n3       42      Errol\n4       41      Garry\n5       41      Bernard\n6       41      Barry\n7       39      Stephen\n\nStandard Ranking\n----------------\n1       44      Solomon\n2       42      Jason\n2       42      Errol\n4       41      Garry\n4       41      Bernard\n4       41      Barry\n7       39      Stephen\n\nDense Ranking\n-------------\n1       44      Solomon\n2       42      Jason\n2       42      Errol\n3       41      Garry\n3       41      Bernard\n3       41      Barry\n4       39      Stephen\n\nModified Ranking\n----------------\n1       44      Solomon\n3       42      Jason\n3       42      Errol\n6       41      Garry\n6       41      Bernard\n6       41      Barry\n7       39      Stephen\n\nFractional Ranking\n------------------\n1.0     44      Solomon\n2.5     42      Jason\n2.5     42      Errol\n5.0     41      Garry\n5.0     41      Bernard\n5.0     41      Barry\n7.0     39      Stephen\n\n", "explain": "Takes the scores as input via a file, prints out usage on incorrect invocation.\nInput file, first row is number of records\u00a0:\nOutput\u00a0:\n"}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "C++", "code": "\nTranslation of: C#\n#include <algorithm>\n#include <iomanip>\n#include <iostream>\n#include <map>\n#include <ostream>\n#include <set>\n#include <vector>\n\ntemplate<typename T>\nstd::ostream& print(std::ostream& os, const T& src) {\n    auto it = src.cbegin();\n    auto end = src.cend();\n\n    os << \"[\";\n    if (it != end) {\n        os << *it;\n        it = std::next(it);\n    }\n    while (it != end) {\n        os << \", \" << *it;\n        it = std::next(it);\n    }\n\n    return os << \"]\";\n}\n\ntypedef std::map<std::string, int> Map;\ntypedef Map::value_type MapEntry;\n\nvoid standardRank(const Map& scores) {\n    std::cout << \"Standard Rank\" << std::endl;\n\n    std::vector<int> list;\n    for (auto& elem : scores) {\n        list.push_back(elem.second);\n    }\n    std::sort(list.begin(), list.end(), std::greater<int>{});\n    list.erase(std::unique(list.begin(), list.end()), list.end());\n\n    int rank = 1;\n    for (auto value : list) {\n        int temp = rank;\n        for (auto& e : scores) {\n            if (e.second == value) {\n                std::cout << temp << \" \" << value << \" \" << e.first.c_str() << std::endl;\n                rank++;\n            }\n        }\n    }\n\n    std::cout << std::endl;\n}\n\nvoid modifiedRank(const Map& scores) {\n    std::cout << \"Modified Rank\" << std::endl;\n\n    std::vector<int> list;\n    for (auto& elem : scores) {\n        list.push_back(elem.second);\n    }\n    std::sort(list.begin(), list.end(), std::greater<int>{});\n    list.erase(std::unique(list.begin(), list.end()), list.end());\n\n    int rank = 0;\n    for (auto value : list) {\n        rank += std::count_if(scores.begin(), scores.end(), [value](const MapEntry& e) { return e.second == value; });\n        for (auto& e : scores) {\n            if (e.second == value) {\n                std::cout << rank << \" \" << value << \" \" << e.first.c_str() << std::endl;\n            }\n        }\n    }\n\n    std::cout << std::endl;\n}\n\nvoid denseRank(const Map& scores) {\n    std::cout << \"Dense Rank\" << std::endl;\n\n    std::vector<int> list;\n    for (auto& elem : scores) {\n        list.push_back(elem.second);\n    }\n    std::sort(list.begin(), list.end(), std::greater<int>{});\n    list.erase(std::unique(list.begin(), list.end()), list.end());\n\n    int rank = 1;\n    for (auto value : list) {\n        for (auto& e : scores) {\n            if (e.second == value) {\n                std::cout << rank << \" \" << value << \" \" << e.first.c_str() << std::endl;\n            }\n        }\n        rank++;\n    }\n\n    std::cout << std::endl;\n}\n\nvoid ordinalRank(const Map& scores) {\n    std::cout << \"Ordinal Rank\" << std::endl;\n\n    std::vector<int> list;\n    for (auto& elem : scores) {\n        list.push_back(elem.second);\n    }\n    std::sort(list.begin(), list.end(), std::greater<int>{});\n    list.erase(std::unique(list.begin(), list.end()), list.end());\n\n    int rank = 1;\n    for (auto value : list) {\n        for (auto& e : scores) {\n            if (e.second == value) {\n                std::cout << rank++ << \" \" << value << \" \" << e.first.c_str() << std::endl;\n            }\n        }\n    }\n\n    std::cout << std::endl;\n}\n\nvoid fractionalRank(const Map& scores) {\n    std::cout << \"Ordinal Rank\" << std::endl;\n\n    std::vector<int> list;\n    for (auto& elem : scores) {\n        list.push_back(elem.second);\n    }\n    std::sort(list.begin(), list.end(), std::greater<int>{});\n    list.erase(std::unique(list.begin(), list.end()), list.end());\n\n    int rank = 0;\n    for (auto value : list) {\n        double avg = 0.0;\n        int cnt = 0;\n\n        for (auto& e : scores) {\n            if (e.second == value) {\n                rank++;\n                cnt++;\n                avg += rank;\n            }\n        }\n        avg /= cnt;\n\n        for (auto& e : scores) {\n            if (e.second == value) {\n                std::cout << std::setprecision(1) << std::fixed << avg << \" \" << value << \" \" << e.first.c_str() << std::endl;\n            }\n        }\n    }\n\n    std::cout << std::endl;\n}\n\nint main() {\n    using namespace std;\n\n    map<string, int> scores{\n        {\"Solomon\", 44},\n        {\"Jason\", 42},\n        {\"Errol\", 42},\n        {\"Gary\", 41},\n        {\"Bernard\", 41},\n        {\"Barry\", 41},\n        {\"Stephen\", 39}\n    };\n\n    standardRank(scores);\n    modifiedRank(scores);\n    denseRank(scores);\n    ordinalRank(scores);\n    fractionalRank(scores);\n\n    return 0;\n}\n\n\nOutput:\nStandard Rank\n1 44 Solomon\n2 42 Errol\n2 42 Jason\n4 41 Barry\n4 41 Bernard\n4 41 Gary\n7 39 Stephen\n\nModified Rank\n1 44 Solomon\n3 42 Errol\n3 42 Jason\n6 41 Barry\n6 41 Bernard\n6 41 Gary\n7 39 Stephen\n\nDense Rank\n1 44 Solomon\n2 42 Errol\n2 42 Jason\n3 41 Barry\n3 41 Bernard\n3 41 Gary\n4 39 Stephen\n\nOrdinal Rank\n1 44 Solomon\n2 42 Errol\n3 42 Jason\n4 41 Barry\n5 41 Bernard\n6 41 Gary\n7 39 Stephen\n\nOrdinal Rank\n1.0 44 Solomon\n2.5 42 Errol\n2.5 42 Jason\n5.0 41 Barry\n5.0 41 Bernard\n5.0 41 Gary\n7.0 39 Stephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Java", "code": "\nWorks with: Java version 8\nimport java.util.*;\n\npublic class RankingMethods {\n\n    final static String[] input = {\"44 Solomon\", \"42 Jason\", \"42 Errol\",\n        \"41 Garry\", \"41 Bernard\", \"41 Barry\", \"39 Stephen\"};\n\n    public static void main(String[] args) {\n        int len = input.length;\n\n        Map<String, int[]> map = new TreeMap<>((a, b) -> b.compareTo(a));\n        for (int i = 0; i < len; i++) {\n            String key = input[i].split(\"\\\\s+\")[0];\n            int[] arr;\n            if ((arr = map.get(key)) == null)\n                arr = new int[]{i, 0};\n            arr[1]++;\n            map.put(key, arr);\n        }\n        int[][] groups = map.values().toArray(new int[map.size()][]);\n\n        standardRanking(len, groups);\n        modifiedRanking(len, groups);\n        denseRanking(len, groups);\n        ordinalRanking(len);\n        fractionalRanking(len, groups);\n    }\n\n    private static void standardRanking(int len, int[][] groups) {\n        System.out.println(\"\\nStandard ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                rank = i + 1;\n                group++;\n            }\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void modifiedRanking(int len, int[][] groups) {\n        System.out.println(\"\\nModified ranking\");\n        for (int i = 0, rank = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0])\n                rank += groups[group++][1];\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void denseRanking(int len, int[][] groups) {\n        System.out.println(\"\\nDense ranking\");\n        for (int i = 0, rank = 0; i < len; i++) {\n            if (rank < groups.length && i == groups[rank][0])\n                rank++;\n            System.out.printf(\"%d %s%n\", rank, input[i]);\n        }\n    }\n\n    private static void ordinalRanking(int len) {\n        System.out.println(\"\\nOrdinal ranking\");\n        for (int i = 0; i < len; i++)\n            System.out.printf(\"%d %s%n\", i + 1, input[i]);\n    }\n\n    private static void fractionalRanking(int len, int[][] groups) {\n        System.out.println(\"\\nFractional ranking\");\n        float rank = 0;\n        for (int i = 0, tmp = 0, group = 0; i < len; i++) {\n            if (group < groups.length && i == groups[group][0]) {\n                tmp += groups[group++][1];\n                rank = (i + 1 + tmp) / 2.0F;\n            }\n            System.out.printf(\"%2.1f %s%n\", rank, input[i]);\n        }\n    }\n}\n\nStandard ranking\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n4 41 Garry\n4 41 Bernard\n4 41 Barry\n7 39 Stephen\n\nModified ranking\n1 44 Solomon\n3 42 Jason\n3 42 Errol\n6 41 Garry\n6 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nDense ranking\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n3 41 Garry\n3 41 Bernard\n3 41 Barry\n4 39 Stephen\n\nOrdinal ranking\n1 44 Solomon\n2 42 Jason\n3 42 Errol\n4 41 Garry\n5 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nFractional ranking\n1,0 44 Solomon\n2,5 42 Jason\n2,5 42 Errol\n5,0 41 Garry\n5,0 41 Bernard\n5,0 41 Barry\n7,0 39 Stephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "C#", "code": "\nTranslation of: D\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nnamespace RankingMethods {\n    class Program {\n        static void Main(string[] args) {\n            Dictionary<string, int> scores = new Dictionary<string, int> {\n                [\"Solomon\"] = 44,\n                [\"Jason\"] = 42,\n                [\"Errol\"] = 42,\n                [\"Gary\"] = 41,\n                [\"Bernard\"] = 41,\n                [\"Barry\"] = 41,\n                [\"Stephen\"] = 39,\n            };\n\n            StandardRank(scores);\n            ModifiedRank(scores);\n            DenseRank(scores);\n            OrdinalRank(scores);\n            FractionalRank(scores);\n        }\n\n        static void StandardRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Standard Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                int temp = rank;\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", temp, value, k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void ModifiedRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Modified Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                    }\n                }\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void DenseRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Dense Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                    }\n                }\n                rank++;\n            }\n\n            Console.WriteLine();\n        }\n\n        static void OrdinalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Ordinal Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 1;\n            foreach (var value in list) {\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0} {1} {2}\", rank, data[k], k);\n                        rank++;\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n\n        static void FractionalRank(Dictionary<string, int> data) {\n            Console.WriteLine(\"Fractional Rank\");\n\n            var list = data.Values.Distinct().ToList();\n            list.Sort((a, b) => b.CompareTo(a));\n\n            int rank = 0;\n            foreach (var value in list) {\n                double avg = 0;\n                int cnt = 0;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        rank++;\n                        cnt++;\n                        avg += rank;\n                    }\n                }\n                avg /= cnt;\n\n                foreach (var k in data.Keys) {\n                    if (data[k] == value) {\n                        Console.WriteLine(\"{0:F1} {1} {2}\", avg, data[k], k);\n                    }\n                }\n            }\n\n            Console.WriteLine();\n        }\n    }\n}\n\n\nOutput:\nStandard Rank\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n4 41 Gary\n4 41 Bernard\n4 41 Barry\n7 39 Stephen\n\nModified Rank\n1 44 Solomon\n3 42 Jason\n3 42 Errol\n6 41 Gary\n6 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nDense Rank\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n3 41 Gary\n3 41 Bernard\n3 41 Barry\n4 39 Stephen\n\nOrdinal Rank\n1 44 Solomon\n2 42 Jason\n3 42 Errol\n4 41 Gary\n5 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nFractional Rank\n1.0 44 Solomon\n2.5 42 Jason\n2.5 42 Errol\n5.0 41 Gary\n5.0 41 Bernard\n5.0 41 Barry\n7.0 39 Stephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nES5[edit]\n\n(function () {\n \n    var xs = 'Solomon Jason Errol Garry Bernard Barry Stephen'.split(' '),\n        ns = [44, 42, 42, 41, 41, 41, 39],\n \n        sorted = xs.map(function (x, i) {\n            return { name: x, score: ns[i] };\n        }).sort(function (a, b) {\n            var c = b.score - a.score;\n            return c ? c : a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n        }),\n \n        names = sorted.map(function (x) { return x.name; }),\n        scores = sorted.map(function (x) { return x.score; }),\n \n        reversed = scores.slice(0).reverse(),\n        unique = scores.filter(function (x, i) {\n            return scores.indexOf(x) === i;\n        });\n \n    // RANKINGS AS FUNCTIONS OF SCORES: SORTED, REVERSED AND UNIQUE\n \n    var rankings = function (score, index) {\n            return {\n                name: names[index],\n                score: score,\n\n                Ordinal: index + 1,\n\n                Standard: function (n) {\n                    return scores.indexOf(n) + 1;\n                }(score),\n\n                Modified: function (n) {\n                    return reversed.length - reversed.indexOf(n);\n                }(score),\n\n                Dense: function (n) {\n                    return unique.indexOf(n) + 1;\n                }(score),\n\n                Fractional: function (n) {\n                    return (\n                        (scores.indexOf(n) + 1) +\n                        (reversed.length - reversed.indexOf(n))\n                    ) / 2;\n                }(score)\n            };\n        },\n \n        tbl = [\n            'Name Score Standard Modified Dense Ordinal Fractional'.split(' ')\n        ].concat(scores.map(rankings).reduce(function (a, x) {\n            return a.concat([\n                [x.name, x.score,\n                    x.Standard, x.Modified, x.Dense, x.Ordinal, x.Fractional\n                ]\n            ]);\n        }, [])),\n \n        //[[a]] -> bool -> s -> s\n        wikiTable = function (lstRows, blnHeaderRow, strStyle) {\n            return '{| class=\"wikitable\" ' + (\n                strStyle ? 'style=\"' + strStyle + '\"' : ''\n            ) + lstRows.map(function (lstRow, iRow) {\n                var strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');\n \n                return '\\n|-\\n' + strDelim + ' ' + lstRow.map(function (v) {\n                    return typeof v === 'undefined' ? ' ' : v;\n                }).join(' ' + strDelim + strDelim + ' ');\n            }).join('') + '\\n|}';\n        };\n \n    return wikiTable(tbl, true, 'text-align:center');\n \n})();\n\n\nOutput:\n\n\nName\nScore\nStandard\nModified\nDense\nOrdinal\nFractional\n\n\nSolomon\n44\n1\n1\n1\n1\n1\n\n\nErrol\n42\n2\n3\n2\n2\n2.5\n\n\nJason\n42\n2\n3\n2\n3\n2.5\n\n\nBarry\n41\n4\n6\n3\n4\n5\n\n\nBernard\n41\n4\n6\n3\n5\n5\n\n\nGarry\n41\n4\n6\n3\n6\n5\n\n\nStephen\n39\n7\n7\n4\n7\n7\n\nES6[edit]\n((() => {\n    const xs = 'Solomon Jason Errol Garry Bernard Barry Stephen'.split(' '),\n        ns = [44, 42, 42, 41, 41, 41, 39];\n\n    const sorted = xs.map((x, i) => ({\n            name: x,\n            score: ns[i]\n        }))\n        .sort((a, b) => {\n            const c = b.score - a.score;\n            return c ? c : a.name < b.name ? -1 : a.name > b.name ? 1 : 0;\n        });\n\n    const names = sorted.map(x => x.name),\n        scores = sorted.map(x => x.score),\n        reversed = scores.slice(0)\n        .reverse(),\n        unique = scores.filter((x, i) => scores.indexOf(x) === i);\n\n    // RANKINGS AS FUNCTIONS OF SCORES: SORTED, REVERSED AND UNIQUE\n\n    // rankings\u00a0:: Int -> Int -> Dictonary\n    const rankings = (score, index) => ({\n        name: names[index],\n        score,\n        Ordinal: index + 1,\n        Standard: scores.indexOf(score) + 1,\n        Modified: reversed.length - reversed.indexOf(score),\n        Dense: unique.indexOf(score) + 1,\n\n        Fractional: (n => (\n            (scores.indexOf(n) + 1) +\n            (reversed.length - reversed.indexOf(n))\n        ) / 2)(score)\n    });\n\n    // tbl\u00a0:: [[[a]]]\n    const tbl = [\n            'Name Score Standard Modified Dense Ordinal Fractional'.split(' ')\n        ].concat(scores.map(rankings)\n        .reduce((a, x) => a.concat([\n            [x.name, x.score,\n                x.Standard, x.Modified, x.Dense, x.Ordinal, x.Fractional\n            ]\n        ]), []));\n\n    // wikiTable\u00a0:: [[[a]]] -> Bool -> String -> String\n    const wikiTable = (lstRows, blnHeaderRow, strStyle) =>\n        `{| class=\"wikitable\" ${strStyle ? 'style=\"' + strStyle + '\"' : ''}\n        ${lstRows.map((lstRow, iRow) => {\n            const strDelim = ((blnHeaderRow && !iRow) ? '!' : '|');\n\n            return '\\n|-\\n' + strDelim + ' ' + lstRow\n            .map(v => typeof v === 'undefined' ? ' ' : v)\n            .join(' ' + strDelim + strDelim + ' ');\n        }).join('')}\\n|}`;\n\n    return wikiTable(tbl, true, 'text-align:center');\n}))();\n\n\n\nName\nScore\nStandard\nModified\nDense\nOrdinal\nFractional\n\n\nSolomon\n44\n1\n1\n1\n1\n1\n\n\nErrol\n42\n2\n3\n2\n2\n2.5\n\n\nJason\n42\n2\n3\n2\n3\n2.5\n\n\nBarry\n41\n4\n6\n3\n4\n5\n\n\nBernard\n41\n4\n6\n3\n5\n5\n\n\nGarry\n41\n4\n6\n3\n6\n5\n\n\nStephen\n39\n7\n7\n4\n7\n7\n\n\nOutput:\n", "explain": "The task formulation doesn't seem to directly explain or determine the order of listing for players whose score is the same.\n( This version chooses to use a secondary (alphabetic) sort after the numeric sort by score. That does, of course, affect the ordinal placements for some players)\n"}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n\t\"sort\"\n)\n\ntype rankable interface {\n\tLen() int\n\tRankEqual(int, int) bool\n}\n\nfunc StandardRank(d rankable) []float64 {\n\tr := make([]float64, d.Len())\n\tvar k int\n\tfor i := range r {\n\t\tif i == 0 || !d.RankEqual(i, i-1) {\n\t\t\tk = i + 1\n\t\t}\n\t\tr[i] = float64(k)\n\t}\n\treturn r\n}\n\nfunc ModifiedRank(d rankable) []float64 {\n\tr := make([]float64, d.Len())\n\tfor i := range r {\n\t\tk := i + 1\n\t\tfor j := i + 1; j < len(r) && d.RankEqual(i, j); j++ {\n\t\t\tk = j + 1\n\t\t}\n\t\tr[i] = float64(k)\n\t}\n\treturn r\n}\n\nfunc DenseRank(d rankable) []float64 {\n\tr := make([]float64, d.Len())\n\tvar k int\n\tfor i := range r {\n\t\tif i == 0 || !d.RankEqual(i, i-1) {\n\t\t\tk++\n\t\t}\n\t\tr[i] = float64(k)\n\t}\n\treturn r\n}\n\nfunc OrdinalRank(d rankable) []float64 {\n\tr := make([]float64, d.Len())\n\tfor i := range r {\n\t\tr[i] = float64(i + 1)\n\t}\n\treturn r\n}\n\nfunc FractionalRank(d rankable) []float64 {\n\tr := make([]float64, d.Len())\n\tfor i := 0; i < len(r); {\n\t\tvar j int\n\t\tf := float64(i + 1)\n\t\tfor j = i + 1; j < len(r) && d.RankEqual(i, j); j++ {\n\t\t\tf += float64(j + 1)\n\t\t}\n\t\tf /= float64(j - i)\n\t\tfor ; i < j; i++ {\n\t\t\tr[i] = f\n\t\t}\n\t}\n\treturn r\n}\n\ntype scores []struct {\n\tscore int\n\tname  string\n}\n\nfunc (s scores) Len() int                { return len(s) }\nfunc (s scores) RankEqual(i, j int) bool { return s[i].score == s[j].score }\nfunc (s scores) Swap(i, j int)           { s[i], s[j] = s[j], s[i] }\nfunc (s scores) Less(i, j int) bool {\n\tif s[i].score != s[j].score {\n\t\treturn s[i].score > s[j].score\n\t}\n\treturn s[i].name < s[j].name\n}\n\nvar data = scores{\n\t{44, \"Solomon\"},\n\t{42, \"Jason\"},\n\t{42, \"Errol\"},\n\t{41, \"Garry\"},\n\t{41, \"Bernard\"},\n\t{41, \"Barry\"},\n\t{39, \"Stephen\"},\n}\n\nfunc main() {\n\tshow := func(name string, fn func(rankable) []float64) {\n\t\tfmt.Println(name, \"Ranking:\")\n\t\tr := fn(data)\n\t\tfor i, d := range data {\n\t\t\tfmt.Printf(\"%4v - %2d %s\\n\", r[i], d.score, d.name)\n\t\t}\n\t}\n\n\tsort.Sort(data)\n\tshow(\"Standard\", StandardRank)\n\tshow(\"\\nModified\", ModifiedRank)\n\tshow(\"\\nDense\", DenseRank)\n\tshow(\"\\nOrdinal\", OrdinalRank)\n\tshow(\"\\nFractional\", FractionalRank)\n}\n\n\nOutput:\nStandard Ranking:\n   1 - 44 Solomon\n   2 - 42 Errol\n   2 - 42 Jason\n   4 - 41 Barry\n   4 - 41 Bernard\n   4 - 41 Garry\n   7 - 39 Stephen\n\nModified Ranking:\n   1 - 44 Solomon\n   3 - 42 Errol\n   3 - 42 Jason\n   6 - 41 Barry\n   6 - 41 Bernard\n   6 - 41 Garry\n   7 - 39 Stephen\n\nDense Ranking:\n   1 - 44 Solomon\n   2 - 42 Errol\n   2 - 42 Jason\n   3 - 41 Barry\n   3 - 41 Bernard\n   3 - 41 Garry\n   4 - 39 Stephen\n\nOrdinal Ranking:\n   1 - 44 Solomon\n   2 - 42 Errol\n   3 - 42 Jason\n   4 - 41 Barry\n   5 - 41 Bernard\n   6 - 41 Garry\n   7 - 39 Stephen\n\nFractional Ranking:\n   1 - 44 Solomon\n 2.5 - 42 Errol\n 2.5 - 42 Jason\n   5 - 41 Barry\n   5 - 41 Bernard\n   5 - 41 Garry\n   7 - 39 Stephen\n\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Ruby", "code": "\nar = \"44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\".lines.map{|line| line.split}\ngrouped = ar.group_by{|pair| pair.shift.to_i}\ns_rnk = 1\nm_rnk = o_rnk = 0\nputs \"stand.\\tmod.\\tdense\\tord.\\tfract.\"\n\ngrouped.each.with_index(1) do |(score, names), d_rnk|\n  m_rnk += names.flatten!.size\n  f_rnk = (s_rnk + m_rnk)/2.0\n  names.each do |name|\n    o_rnk += 1\n    puts \"#{s_rnk}\\t#{m_rnk}\\t#{d_rnk}\\t#{o_rnk}\\t#{f_rnk.to_s.sub(\".0\",\"\")}\\t#{score} #{name}\"\n  end\n  s_rnk += names.size\nend\n\n\nOutput:\nstand.\tmod.\tdense\tord.\tfract.\n1\t1\t1\t1\t1\t44 Solomon\n2\t3\t2\t2\t2.5\t42 Jason\n2\t3\t2\t3\t2.5\t42 Errol\n4\t6\t3\t4\t5\t41 Garry\n4\t6\t3\t5\t5\t41 Bernard\n4\t6\t3\t6\t5\t41 Barry\n7\t7\t4\t7\t7\t39 Stephen\n\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Visual_FoxPro", "code": "\n#DEFINE CTAB CHR(9)\n#DEFINE CRLF CHR(13) + CHR(10)\nLOCAL lcTxt As String, i As Integer\nCLOSE DATABASES ALL\nSET SAFETY OFF\nCLEAR\nCREATE CURSOR scores (score I, name V(8), rownum I AUTOINC)\nINDEX ON score TAG score COLLATE \"Machine\"\nSET ORDER TO 0\nINSERT INTO scores (score, name) VALUES (44, \"Solomon\")\nINSERT INTO scores (score, name) VALUES (42, \"Jason\")\nINSERT INTO scores (score, name) VALUES (42, \"Errol\")\nINSERT INTO scores (score, name) VALUES (41, \"Garry\")\nINSERT INTO scores (score, name) VALUES (41, \"Bernard\")\nINSERT INTO scores (score, name) VALUES (41, \"Barry\")\nINSERT INTO scores (score, name) VALUES (39, \"Stephen\")\n\nCREATE CURSOR ranks (sc_rank I, mod_rank I, dense I, ordinal I, fractional B(1), score I, name V(8))\nINDEX ON score TAG score COLLATE \"Machine\"\nSET ORDER TO 0\nAPPEND FROM DBF(\"scores\") FIELDS score, name\nStd_Comp()\nModified()\nDense()\nOrdinal()\nFractional()\nCOPY TO ranks.txt TYPE DELIMITED WITH TAB\nlcTxt = \"\"\nFOR i = 1 TO FCOUNT()\n    lcTxt = lcTxt + FIELD(i) + CTAB\nENDFOR\nlcTxt = LEFT(lcTxt, LEN(lcTxt) - 1) + CRLF + FILETOSTR(\"ranks.txt\")\nSTRTOFILE(lcTxt, \"ranks.txt\")\nMODIFY FILE ranks.txt\nSET SAFETY ON\n\nFUNCTION ScoreGroup(aa)\nLOCAL n As Integer\nSELECT score, COUNT(*) As num FROM scores ;\nGROUP BY score ORDER BY score DESC INTO ARRAY aa\nn = _TALLY\nRETURN n\nENDFUNC\n\nPROCEDURE Std_Comp\nLOCAL n, i, nn\nLOCAL ARRAY a[1]\nSELECT ranks\nBLANK FIELDS sc_rank ALL\nnn = ScoreGroup(@a)\nn = 1\nFOR i = 1 TO nn\n    REPLACE sc_rank WITH n FOR score = a[i,1]\n    n = n + a[i,2] \nENDFOR\t\nENDPROC\n\nPROCEDURE Modified\nLOCAL n, i, nn\nLOCAL ARRAY a[1]\nSELECT ranks\nBLANK FIELDS mod_rank ALL\nnn = ScoreGroup(@a)\nn = 0\nFOR i = 1 TO nn\n    n = n + a[i,2]\n    REPLACE mod_rank WITH n FOR score = a[i,1]\nENDFOR\t\nENDPROC\n\nPROCEDURE Dense\nLOCAL n, i, nn\nLOCAL ARRAY a[1]\nSELECT ranks\nBLANK FIELDS dense ALL\nnn = ScoreGroup(@a)\nSELECT ranks\nn = 0\nFOR i = 1 TO nn\n    n = n + a[i,2]\n    REPLACE dense WITH i FOR score = a[i,1]\nENDFOR\t\nENDPROC\n\nPROCEDURE Ordinal\nSELECT ranks\nBLANK FIELDS ordinal ALL\nREPLACE ordinal WITH RECNO() ALL\nENDPROC\n\nPROCEDURE Fractional\nLOCAL i As Integer, nn As Integer\nLOCAL ARRAY a[1]\nSELECT ranks\nBLANK FIELDS fractional ALL\nSELECT CAST(AVG(rownum) As B(1)), score FROM scores ;\nGROUP BY score ORDER BY score DESC INTO ARRAY a\nnn = _TALLY\nFOR i = 1 TO nn\n    REPLACE fractional WITH a[i,1] FOR score = a[i,2]\nENDFOR\t\nENDPROC\n\n\nOutput:\nSC_RANK\tMOD_RANK\tDENSE\tORDINAL\tFRACTIONAL\tSCORE\tNAME\n1\t1\t1\t1\t1.0\t44\t\"Solomon\"\n2\t3\t2\t2\t2.5\t42\t\"Jason\"\n2\t3\t2\t3\t2.5\t42\t\"Errol\"\n4\t6\t3\t4\t5.0\t41\t\"Garry\"\n4\t6\t3\t5\t5.0\t41\t\"Bernard\"\n4\t6\t3\t6\t5.0\t41\t\"Barry\"\n7\t7\t4\t7\t7.0\t39\t\"Stephen\"\n\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Julia", "code": "\n\nfunction ties{T<:Real}(a::Array{T,1})\n    unique(a[2:end][a[2:end] .== a[1:end-1]])\nend\n\n\nfunction rankstandard{T<:Real}(a::Array{T,1})\n    r = collect(1:length(a))\n    1 < r[end] || return r\n    for i in ties(a)\n        r[a.==i] = r[a.==i][1]\n    end\n    return r\nend\n\n\nfunction rankmodified{T<:Real}(a::Array{T,1})\n    indexin(a, a)\nend\n\n\nfunction rankdense{T<:Real}(a::Array{T,1})\n    indexin(a, unique(a))\nend\n\n\nfunction rankordinal{T<:Real}(a::Array{T,1})\n    collect(1:length(a))\nend\n\n\nfunction rankfractional{T<:Real}(a::Array{T,1})\n    r = float64(collect(1:length(a)))\n    1.0 < r[end] || return r\n    for i in ties(a)\n        r[a.==i] = mean(r[a.==i])\n    end\n    return r\nend\n\n\nscores = [44, 42, 42, 41, 41, 41, 39]\nnames = [\"Solomon\", \"Jason\", \"Errol\", \"Garry\",\n         \"Bernard\", \"Barry\", \"Stephen\"]\n\nsrank = rankstandard(scores)\nmrank = rankmodified(scores)\ndrank = rankdense(scores)\norank = rankordinal(scores)\nfrank = rankfractional(scores)\n\nprintln(\"    Name    Score  Std  Mod  Den  Ord  Frac\")\nfor i in 1:length(scores)\n    print(@sprintf(\"   %-7s\", names[i]))\n    print(@sprintf(\"%5d \", scores[i]))\n    print(@sprintf(\"%5d\", srank[i]))\n    print(@sprintf(\"%5d\", mrank[i]))\n    print(@sprintf(\"%5d\", drank[i]))\n    print(@sprintf(\"%5d\", orank[i]))\n    print(@sprintf(\"%7.2f\", frank[i]))\n    println()\nend\n\n\nOutput:\n    Name    Score  Std  Mod  Den  Ord  Frac\n   Solomon   44     1    1    1    1   1.00\n   Jason     42     2    3    2    2   2.50\n   Errol     42     2    3    2    3   2.50\n   Garry     41     4    6    3    4   5.00\n   Bernard   41     4    6    3    5   5.00\n   Barry     41     4    6    3    6   5.00\n   Stephen   39     7    7    4    7   7.00\n\n", "explain": "ties, a helper function used by some of the ranking methods.  It lists any duplicated scores.\nties assumes that the there are at least 2 scores in the list to be checked, and the calling functions are designed to avoid calls to it in this case.\nStandard Ranking Function\nModified Ranking Function\nDense Ranking Function\nOrdinal Ranking Function\nFor ordinal ranking, there are a variety of ways of handling tied scores.  I've taken the easy way out and assumed that the position in the list already reflects any tie-breaking policy.  In this case, there is not much that needs to be done.\nFractional Ranking Function\nMain\n"}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Kotlin", "code": "\n// version 1.0.6\n\n/* all ranking functions assume the array of Pairs is non-empty and already sorted by decreasing order of scores\n   and then, if the scores are equal, by reverse alphabetic order of names\n*/\n\nfun standardRanking(scores: Array<Pair<Int, String>>): IntArray {   \n    val rankings = IntArray(scores.size)\n    rankings[0] = 1\n    for (i in 1 until scores.size) rankings[i] = if (scores[i].first == scores[i - 1].first) rankings[i - 1] else i + 1\n    return rankings\n}\n\nfun modifiedRanking(scores: Array<Pair<Int, String>>): IntArray {   \n    val rankings = IntArray(scores.size)\n    rankings[0] = 1 \n    for (i in 1 until scores.size) {\n        rankings[i] = i + 1 \n        val currScore = scores[i].first         \n        for (j in i - 1 downTo 0) {\n            if (currScore != scores[j].first) break\n            rankings[j] = i + 1\n        }       \n    }\n    return rankings\n}\n\nfun denseRanking(scores: Array<Pair<Int, String>>): IntArray {   \n    val rankings = IntArray(scores.size)\n    rankings[0] = 1\n    var prevRanking = 1\n    for (i in 1 until scores.size) rankings[i] = if (scores[i].first == scores[i - 1].first) prevRanking else ++prevRanking\n    return rankings\n}\n\nfun ordinalRanking(scores: Array<Pair<Int, String>>) = IntArray(scores.size) { it + 1 }  \n\nfun fractionalRanking(scores: Array<Pair<Int, String>>): DoubleArray {\n    val rankings = DoubleArray(scores.size)\n    rankings[0] = 1.0 \n    for (i in 1 until scores.size) {\n        var k = i \n        val currScore = scores[i].first         \n        for (j in i - 1 downTo 0) {\n            if (currScore != scores[j].first) break\n            k = j\n        }\n        val avg = (k..i).average() + 1.0\n        for (m in k..i) rankings[m] = avg       \n    }\n    return rankings\n}    \n\nfun printRankings(title: String, rankings: IntArray, scores: Array<Pair<Int, String>>) {\n    println(title + \":\")\n    for (i in 0 until rankings.size) { \n        print (\"${rankings[i]}  \")  \n        println(scores[i].toString().removeSurrounding(\"(\", \")\").replace(\",\", \"\"))\n    }\n    println()\n}\n\nfun printFractionalRankings(title: String, rankings: DoubleArray, scores: Array<Pair<Int, String>>) {\n    println(title + \":\")\n    for (i in 0 until rankings.size) { \n        print (\"${\"%3.2f\".format(rankings[i])}  \")  \n        println(scores[i].toString().removeSurrounding(\"(\", \")\").replace(\",\", \"\"))\n    }\n    println()\n}\n\nfun main(args: Array<String>) {\n    val scores = arrayOf(44 to \"Solomon\",  42 to \"Jason\", 42 to \"Errol\",  41 to \"Garry\",\n                         41 to \"Bernard\",  41 to \"Barry\", 39 to \"Stephen\")\n    printRankings(\"Standard ranking\", standardRanking(scores), scores)\n    printRankings(\"Modified ranking\", modifiedRanking(scores), scores)\n    printRankings(\"Dense ranking\", denseRanking(scores), scores)\n    printRankings(\"Ordinal ranking\", ordinalRanking(scores), scores)\n    printFractionalRankings(\"Fractional ranking\", fractionalRanking(scores), scores)\n}\n\n\nOutput:\nStandard ranking:\n1  44 Solomon\n2  42 Jason\n2  42 Errol\n4  41 Garry\n4  41 Bernard\n4  41 Barry\n7  39 Stephen\n\nModified ranking:\n1  44 Solomon\n3  42 Jason\n3  42 Errol\n6  41 Garry\n6  41 Bernard\n6  41 Barry\n7  39 Stephen\n\nDense ranking:\n1  44 Solomon\n2  42 Jason\n2  42 Errol\n3  41 Garry\n3  41 Bernard\n3  41 Barry\n4  39 Stephen\n\nOrdinal ranking:\n1  44 Solomon\n2  42 Jason\n3  42 Errol\n4  41 Garry\n5  41 Bernard\n6  41 Barry\n7  39 Stephen\n\nFractional ranking:\n1.00  44 Solomon\n2.50  42 Jason\n2.50  42 Errol\n5.00  41 Garry\n5.00  41 Bernard\n5.00  41 Barry\n7.00  39 Stephen\n\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Perl", "code": "\nTranslation of: Raku\nmy %scores = (\n    'Solomon' => 44,\n    'Jason'   => 42,\n    'Errol'   => 42,\n    'Garry'   => 41,\n    'Bernard' => 41,\n    'Barry'   => 41,\n    'Stephen' => 39\n);\n\nsub tiers {\n    my(%s) = @_; my(%h);\n    push @{$h{$s{$_}}}, $_ for keys %s;\n    @{\\%h}{reverse sort keys %h};\n}\n\nsub standard {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n        $rank += @$players;\n    }\n    return $result;\n}\n\nsub modified {\n    my(%s) = @_; my($result);\n    my $rank = 0;\n    for my $players (tiers %s) {\n        $rank += @$players;\n        $result .= \"$rank \" . join(', ', sort @$players) . \"\\n\";\n    }\n    return $result;\n}\n\nsub dense {\n    my(%s) = @_; my($n,$result);\n    $result .= sprintf \"%d %s\\n\", ++$n, join(', ', sort @$_) for tiers %s;\n    return $result;\n}\n\nsub ordinal {\n    my(%s) = @_; my($n,$result);\n    for my $players (tiers %s) {\n        $result .= sprintf \"%d %s\\n\", ++$n, $_ for sort @$players;\n    }\n    return $result;\n}\n\nsub fractional {\n    my(%s) = @_; my($result);\n    my $rank = 1;\n    for my $players (tiers %s) {\n        my $beg = $rank;\n        my $end = $rank += @$players;\n        my $avg = 0;\n        $avg += $_/@$players for $beg .. $end-1;\n        $result .= sprintf \"%3.1f %s\\n\", $avg, join ', ', sort @$players;\n    }\n    return $result;\n}\n\nprint \"Standard:\\n\"    .   standard(%scores) . \"\\n\";\nprint \"Modified:\\n\"    .   modified(%scores) . \"\\n\";\nprint \"Dense:\\n\"       .      dense(%scores) . \"\\n\";\nprint \"Ordinal:\\n\"     .    ordinal(%scores) . \"\\n\";\nprint \"Fractional:\\n\"  . fractional(%scores) . \"\\n\";\n\n\nOutput:\nStandard:\n1 Solomon\n2 Errol, Jason\n4 Barry, Bernard, Garry\n7 Stephen\n\nModified:\n1 Solomon\n3 Errol, Jason\n6 Barry, Bernard, Garry\n7 Stephen\n\nDense:\n1 Solomon\n2 Errol, Jason\n3 Barry, Bernard, Garry\n4 Stephen\n\nOrdinal:\n1 Solomon\n2 Errol\n3 Jason\n4 Barry\n5 Bernard\n6 Garry\n7 Stephen\n\nFractional:\n1.0 Solomon\n2.5 Errol, Jason\n5.0 Barry, Bernard, Garry\n7.0 Stephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Scala", "code": "\n\nobject RankingMethods extends App {\n    case class Score(score: Int, name: String) // incoming data\n    case class Rank[Precision](rank: Precision, names: List[String]) // outgoing results (can be int or double)\n    case class State[Precision](n: Int, done: List[Rank[Precision]]) { // internal state, no mutable variables\n        def next(n: Int, next: Rank[Precision]) = State(n, next :: done)\n    }\n    def grouped[Precision](list: List[Score]) = // group names together by score, with highest first\n        (scala.collection.immutable.TreeMap[Int, List[Score]]() ++ list.groupBy(-_.score))\n        .values.map(_.map(_.name)).foldLeft(State[Precision](1, Nil)) _\n\n    // Ranking methods:\n\n    def rankStandard(list: List[Score]) =\n        grouped[Int](list){case (state, names) => state.next(state.n+names.length, Rank(state.n, names))}.done.reverse\n\n    def rankModified(list: List[Score]) =\n        rankStandard(list).map(r => Rank(r.rank+r.names.length-1, r.names))\n\n    def rankDense(list: List[Score]) =\n        grouped[Int](list){case (state, names) => state.next(state.n+1, Rank(state.n, names))}.done.reverse\n\n    def rankOrdinal(list: List[Score]) =\n        list.zipWithIndex.map{case (score, n) => Rank(n+1, List(score.name))}\n\n    def rankFractional(list: List[Score]) =\n        rankStandard(list).map(r => Rank((2*r.rank+r.names.length-1.0)/2, r.names))\n\n    // Tests:\n\n    def parseScores(s: String) = s split \"\\\\s+\" match {case Array(s,n) => Score(s.toInt, n)}\n    val test = List(\"44 Solomon\", \"42 Jason\", \"42 Errol\", \"41 Garry\", \"41 Bernard\", \"41 Barry\", \"39 Stephen\").map(parseScores)\n\n    println(\"Standard:\")\n    println(rankStandard(test) mkString \"\\n\")\n    println(\"\\nModified:\")\n    println(rankModified(test) mkString \"\\n\")\n    println(\"\\nDense:\")\n    println(rankDense(test) mkString \"\\n\")\n    println(\"\\nOrdinal:\")\n    println(rankOrdinal(test) mkString \"\\n\")\n    println(\"\\nFractional:\")\n    println(rankFractional(test) mkString \"\\n\")\n\n}\n\n\nOutput:\nStandard:\nRank(1,List(Solomon))\nRank(2,List(Jason, Errol))\nRank(4,List(Garry, Bernard, Barry))\nRank(7,List(Stephen))\n\nModified:\nRank(1,List(Solomon))\nRank(3,List(Jason, Errol))\nRank(6,List(Garry, Bernard, Barry))\nRank(7,List(Stephen))\n\nDense:\nRank(1,List(Solomon))\nRank(2,List(Jason, Errol))\nRank(3,List(Garry, Bernard, Barry))\nRank(4,List(Stephen))\n\nOrdinal:\nRank(1,List(Solomon))\nRank(2,List(Jason))\nRank(3,List(Errol))\nRank(4,List(Garry))\nRank(5,List(Bernard))\nRank(6,List(Barry))\nRank(7,List(Stephen))\n\nFractional:\nRank(1.0,List(Solomon))\nRank(2.5,List(Jason, Errol))\nRank(5.0,List(Garry, Bernard, Barry))\nRank(7.0,List(Stephen))\n", "explain": "This example uses a type-safe singly-linked object model with no mutable state variables, which makes it longer than the Ruby version above, but demonstrates an object-oriented functional programming approach.\n"}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "D", "code": "\nimport std.algorithm;\nimport std.stdio;\n\nvoid main() {\n    immutable scores = [\n        \"Solomon\": 44,\n        \"Jason\": 42,\n        \"Errol\": 42,\n        \"Garry\": 41,\n        \"Bernard\": 41,\n        \"Barry\": 41,\n        \"Stephen\": 39\n    ];\n\n    scores.standardRank;\n    scores.modifiedRank;\n    scores.denseRank;\n    scores.ordinalRank;\n    scores.fractionalRank;\n}\n\n/*\nStandard ranking\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n4 41 Garry\n4 41 Bernard\n4 41 Barry\n7 39 Stephen\n*/\nvoid standardRank(const int[string] data) {\n    writeln(\"Standard Rank\");\n\n    int rank = 1;\n    foreach (value; data.values.dup.sort!\"a>b\".uniq) {\n        int temp = rank;\n        foreach(k,v; data) {\n            if (v==value) {\n                writeln(temp, \" \", v, \" \", k);\n                rank++;\n            }\n        }\n    }\n\n    writeln;\n}\n\n/*\nModified ranking\n1 44 Solomon\n3 42 Jason\n3 42 Errol\n6 41 Garry\n6 41 Bernard\n6 41 Barry\n7 39 Stephen\n*/\nvoid modifiedRank(const int[string] data) {\n    writeln(\"Modified Rank\");\n\n    int rank = 0;\n    foreach (value; data.values.dup.sort!\"a>b\".uniq) {\n        foreach(k,v; data) {\n            if (v==value) {\n                rank++;\n            }\n        }\n        foreach(k,v; data) {\n            if (v==value) {\n                writeln(rank, \" \", v, \" \", k);\n            }\n        }\n    }\n\n    writeln;\n}\n\n/*\nDense ranking\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n3 41 Garry\n3 41 Bernard\n3 41 Barry\n4 39 Stephen\n*/\nvoid denseRank(const int[string] data) {\n    writeln(\"Dense Rank\");\n\n    int rank = 1;\n    foreach (value; data.values.dup.sort!\"a>b\".uniq) {\n        foreach(k,v; data) {\n            if (v==value) {\n                writeln(rank, \" \", v, \" \", k);\n            }\n        }\n        rank++;\n    }\n\n    writeln;\n}\n\n/*\nOrdinal ranking\n1 44 Solomon\n2 42 Jason\n3 42 Errol\n4 41 Garry\n5 41 Bernard\n6 41 Barry\n7 39 Stephen\n*/\nvoid ordinalRank(const int[string] data) {\n    writeln(\"Ordinal Rank\");\n\n    int rank = 1;\n    foreach (value; data.values.dup.sort!\"a>b\".uniq) {\n        foreach(k,v; data) {\n            if (v==value) {\n                writeln(rank, \" \", v, \" \", k);\n                rank++;\n            }\n        }\n    }\n\n    writeln;\n}\n\n/*\nFractional ranking\n1,0 44 Solomon\n2,5 42 Jason\n2,5 42 Errol\n5,0 41 Garry\n5,0 41 Bernard\n5,0 41 Barry\n7,0 39 Stephen\n*/\nvoid fractionalRank(const int[string] data) {\n    writeln(\"Fractional Rank\");\n\n    int rank = 0;\n    foreach (value; data.values.dup.sort!\"a>b\".uniq) {\n        real avg = 0;\n        int cnt;\n\n        foreach(k,v; data) {\n            if (v==value) {\n                rank++;\n                cnt++;\n                avg+=rank;\n            }\n        }\n        avg /= cnt;\n\n        foreach(k,v; data) {\n            if (v==value) {\n                writef(\"%0.1f \", avg);\n                writeln(v, \" \", k);\n            }\n        }\n    }\n\n    writeln;\n}\n\n\nOutput:\nStandard Rank\n1 44 Solomon\n2 42 Errol\n2 42 Jason\n4 41 Garry\n4 41 Bernard\n4 41 Barry\n7 39 Stephen\n\nModified Rank\n1 44 Solomon\n3 42 Errol\n3 42 Jason\n6 41 Garry\n6 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nDense Rank\n1 44 Solomon\n2 42 Errol\n2 42 Jason\n3 41 Garry\n3 41 Bernard\n3 41 Barry\n4 39 Stephen\n\nOrdinal Rank\n1 44 Solomon\n2 42 Errol\n3 42 Jason\n4 41 Garry\n5 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nFractional Rank\n1.0 44 Solomon\n2.5 42 Errol\n2.5 42 Jason\n5.0 41 Garry\n5.0 41 Bernard\n5.0 41 Barry\n7.0 39 Stephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "Haskell", "code": "\nimport Data.List (groupBy, sortBy, intercalate)\n\ntype Item = (Int, String)\n\ntype ItemList = [Item]\n\ntype ItemGroups = [ItemList]\n\ntype RankItem a = (a, Int, String)\n\ntype RankItemList a = [RankItem a]\n\n-- make sure the input is ordered and grouped by score\nprepare :: ItemList -> ItemGroups\nprepare = groupBy gf . sortBy (flip compare)\n  where\n    gf (a, _) (b, _) = a == b\n\n-- give an item a rank\nrank\n  :: Num a\n  => a -> Item -> RankItem a\nrank n (a, b) = (n, a, b)\n\n-- ranking methods\nstandard, modified, dense, ordinal :: ItemGroups -> RankItemList Int\nstandard = ms 1\n  where\n    ms _ [] = []\n    ms n (x:xs) = (rank n <$> x) ++ ms (n + length x) xs\n\nmodified = md 1\n  where\n    md _ [] = []\n    md n (x:xs) =\n      let l = length x\n          nl = n + l\n          nl1 = nl - 1\n      in (rank nl1 <$> x) ++ md (n + l) xs\n\ndense = md 1\n  where\n    md _ [] = []\n    md n (x:xs) = map (rank n) x ++ md (n + 1) xs\n\nordinal = zipWith rank [1 ..] . concat\n\nfractional :: ItemGroups -> RankItemList Double\nfractional = mf 1.0\n  where\n    mf _ [] = []\n    mf n (x:xs) =\n      let l = length x\n          o = take l [n ..]\n          ld = fromIntegral l\n          a = sum o / ld\n      in map (rank a) x ++ mf (n + ld) xs\n\n-- sample data\ntest :: ItemGroups\ntest =\n  prepare\n    [ (44, \"Solomon\")\n    , (42, \"Jason\")\n    , (42, \"Errol\")\n    , (41, \"Garry\")\n    , (41, \"Bernard\")\n    , (41, \"Barry\")\n    , (39, \"Stephen\")\n    ]\n\n-- print rank items nicely\nnicePrint\n  :: Show a\n  => String -> RankItemList a -> IO ()\nnicePrint xs items = do\n  putStrLn xs\n  mapM_ np items\n  putStr \"\\n\"\n  where\n    np (a, b, c) = putStrLn $ intercalate \"\\t\" [show a, show b, c]\n\nmain :: IO ()\nmain = do\n  nicePrint \"Standard:\" $ standard test\n  nicePrint \"Modified:\" $ modified test\n  nicePrint \"Dense:\" $ dense test\n  nicePrint \"Ordinal:\" $ ordinal test\n  nicePrint \"Fractional:\" $ fractional test\n\n\nOutput:\nStandard:\n1\t44\tSolomon\n2\t42\tJason\n2\t42\tErrol\n4\t41\tGarry\n4\t41\tBernard\n4\t41\tBarry\n7\t39\tStephen\n\nModified:\n1\t44\tSolomon\n3\t42\tJason\n3\t42\tErrol\n6\t41\tGarry\n6\t41\tBernard\n6\t41\tBarry\n7\t39\tStephen\n\nDense:\n1\t44\tSolomon\n2\t42\tJason\n2\t42\tErrol\n3\t41\tGarry\n3\t41\tBernard\n3\t41\tBarry\n4\t39\tStephen\n\nOrdinal:\n1\t44\tSolomon\n2\t42\tJason\n3\t42\tErrol\n4\t41\tGarry\n5\t41\tBernard\n6\t41\tBarry\n7\t39\tStephen\n\nFractional:\n1.0\t44\tSolomon\n2.5\t42\tJason\n2.5\t42\tErrol\n5.0\t41\tGarry\n5.0\t41\tBernard\n5.0\t41\tBarry\n7.0\t39\tStephen\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "PowerShell", "code": "\nfunction Get-Ranking\n{\n    [CmdletBinding(DefaultParameterSetName=\"Standard\")]\n    [OutputType([PSCustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   ValueFromPipeline=$true,\n                   ValueFromPipelineByPropertyName=$true,\n                   Position=0)]\n        [string]\n        $InputObject,\n\n        [Parameter(Mandatory=$false,\n                   ParameterSetName=\"Standard\")]\n        [switch]\n        $Standard,\n\n        [Parameter(Mandatory=$false,\n                   ParameterSetName=\"Modified\")]\n        [switch]\n        $Modified,\n\n        [Parameter(Mandatory=$false,\n                   ParameterSetName=\"Dense\")]\n        [switch]\n        $Dense,\n\n        [Parameter(Mandatory=$false,\n                   ParameterSetName=\"Ordinal\")]\n        [switch]\n        $Ordinal,\n\n        [Parameter(Mandatory=$false,\n                   ParameterSetName=\"Fractional\")]\n        [switch]\n        $Fractional\n    )\n\n    Begin\n    {\n        function Get-OrdinalRank ([PSCustomObject[]]$Values)\n        {\n            for ($i = 0; $i -lt $Values.Count; $i++)\n            { \n                $Values[$i].Rank = $i + 1\n            }\n\n            $Values\n        }\n\n        function Get-Rank ([PSCustomObject[]]$Scores)\n        {\n            foreach ($score in $Scores)\n            {\n                $score.Group | ForEach-Object {$_.Rank = $score.Rank}\n            }\n\n            $Scores.Group\n        }\n\n        function New-Competitor ([string]$Name, [int]$Score, [int]$Rank = 0)\n        {\n            [PSCustomObject]@{\n                Name  = $Name\n                Score = $Score\n                Rank  = $Rank\n            }\n        }\n\n        $competitors = @()\n        $scores = @()\n    }\n    Process\n    {\n        @($input) | ForEach-Object {$competitors += New-Competitor -Name $_.Split()[1] -Score $_.Split()[0]}\n    }\n    End\n    {\n        $scores = $competitors |\n            Sort-Object   -Property Score -Descending |\n            Group-Object  -Property Score |\n            Select-Object -Property @{Name=\"Score\"; Expression={[int]$_.Name}}, @{Name=\"Rank\"; Expression={0}}, Count, Group\n\n        switch ($PSCmdlet.ParameterSetName)\n        {\n            \"Standard\"\n            {\n                $rank = 1\n\n                for ($i = 0; $i -lt $scores.Count; $i++)\n                { \n                    $scores[$i].Rank = $rank\n                    $rank += $scores[$i].Count\n                }\n\n                Get-Rank $scores\n            }\n            \"Modified\"\n            {\n                $rank = 0\n\n                foreach ($score in $scores)\n                {\n                    $rank = $score.Count + $rank\n                    $score.Rank = $rank\n                }\n\n                Get-Rank $scores\n            }\n            \"Dense\"\n            {\n                for ($i = 0; $i -lt $scores.Count; $i++)\n                { \n                    $scores[$i].Rank = $i + 1\n                }\n\n                Get-Rank $scores\n            }\n            \"Ordinal\"\n            {\n                Get-OrdinalRank $competitors\n            }\n            \"Fractional\"\n            {\n                Get-OrdinalRank $competitors | Group-Object -Property Score | ForEach-Object {\n                    if ($_.Count -gt 1)\n                    {\n                        $rank = ($_.Group.Rank | Measure-Object -Average).Average\n\n                        foreach ($competitor in $_.Group)\n                        {\n                            $competitor.Rank = $rank\n                        }\n                    }\n                }\n\n                $competitors\n            }\n        }\n    }\n}\n\n$scores = \"44 Solomon\",\"42 Jason\",\"42 Errol\",\"41 Garry\",\"41 Bernard\",\"41 Barry\",\"39 Stephen\"\n\n$scores | Get-Ranking -Standard\n\n\nOutput:\nName    Score Rank\n----    ----- ----\nSolomon    44    1\nJason      42    2\nErrol      42    2\nGarry      41    4\nBernard    41    4\nBarry      41    4\nStephen    39    7\n\n$scores | Get-Ranking -Modified\n\n\nOutput:\nName    Score Rank\n----    ----- ----\nSolomon    44    1\nJason      42    3\nErrol      42    3\nGarry      41    6\nBernard    41    6\nBarry      41    6\nStephen    39    7\n\n$scores | Get-Ranking -Dense\n\n\nOutput:\nName    Score Rank\n----    ----- ----\nSolomon    44    1\nJason      42    2\nErrol      42    2\nGarry      41    3\nBernard    41    3\nBarry      41    3\nStephen    39    4\n\n$scores | Get-Ranking -Ordinal\n\n\nOutput:\nName    Score Rank\n----    ----- ----\nSolomon    44    1\nJason      42    2\nErrol      42    3\nGarry      41    4\nBernard    41    5\nBarry      41    6\nStephen    39    7\n\n$scores | Get-Ranking -Fractional\n\n\nOutput:\nName    Score Rank\n----    ----- ----\nSolomon    44    1\nJason      42  2.5\nErrol      42  2.5\nGarry      41    5\nBernard    41    5\nBarry      41    5\nStephen    39    7\n\n", "explain": ""}, {"task_name": "Ranking methods", "task_url": "https://rosettacode.org/wiki/Ranking_methods", "task_cat": "Sorting", "lang": "AWK", "code": "\nTranslation of: Python\n\n##\n## Dense ranking in file: ranking_d.awk\n##\n\nBEGIN{ lastresult = \"!\"; lastrank = 0 }\n\nfunction d_rank(){\n    if($1==lastresult){\n        print lastrank, $0\n    }else{\n        lastresult = $1\n        print ++lastrank, $0 }\n}\n//{d_rank() }\n\n##\n## Fractional ranking in file: ranking_f.awk\n##\n\nBEGIN{\n    last = \"!\"\n    flen = 0 }\n\nfunction f_rank(){\n    item = $0\n    if($1!=last){\n        if(flen){\n            sum = 0\n            for(fl=0; fl < flen;){\n                $0 = fifo[fl++]\n                sum += $1 }\n            mean = sum / flen\n            for(fl=0; fl < flen;){\n                $0 = fifo[fl++]\n                $1 = \"\"\n                printf(\"%3g %s\\n\", mean, $0) }\n            flen = 0\n    }}\n    $0 = item\n    last = $1\n    fifo[flen++] = sprintf(\"%i %s\", FNR, item)\n}\n//{f_rank()}\n\nEND{ if(flen){\n        sum = 0\n        for(fl=0; fl < flen;){\n            $0 = fifo[fl++]\n            sum += $1 }\n        mean = sum / flen\n        for(fl=0; fl < flen;){\n            $0 = fifo[fl++]\n            $1 = \"\"\n            printf(\"%3g %s\\n\", mean, $0) }}}\n\n##\n## Modified competition ranking in file: ranking_mc.awk\n##\n\nBEGIN{\n    lastresult = \"!\"\n    flen = 0 }\n\nfunction mc_rank(){\n    if($1==lastresult){\n        fifo[flen++] = $0\n    }else{\n        for(fl=0; fl < flen;){\n            print FNR-1, fifo[fl++]}\n        flen = 0\n        fifo[flen++] = $0\n        lastresult = $1}\n}\n//{mc_rank()}\n\nEND{ for(fl=0; fl < flen;){\n        print FNR, fifo[fl++]} }\n\n##\n## Ordinal ranking in file: ranking_o.awk\n##\n\nfunction o_rank(){ print FNR, $0 }\n//{o_rank() }\n\n##\n## Standard competition ranking in file: ranking_sc.awk\n##\n\nBEGIN{ lastresult = lastrank = \"!\" }\n\nfunction sc_rank(){\n    if($1==lastresult){\n        print lastrank, $0\n    }else{\n        print FNR, $0\n        lastresult = $1\n        lastrank = FNR}\n}\n//{sc_rank()}\n\n\n44 Solomon\n42 Jason\n42 Errol\n41 Garry\n41 Bernard\n41 Barry\n39 Stephen\n\nOutput:\nC:\\Users\\RC\\Code>awk -f ranking_sc.awk ranking.txt\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n4 41 Garry\n4 41 Bernard\n4 41 Barry\n7 39 Stephen\n\nC:\\Users\\RC\\Code>awk -f ranking_mc.awk ranking.txt\n1 44 Solomon\n3 42 Jason\n3 42 Errol\n6 41 Garry\n6 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nC:\\Users\\RC\\Code>awk -f ranking_d.awk ranking.txt\n1 44 Solomon\n2 42 Jason\n2 42 Errol\n3 41 Garry\n3 41 Bernard\n3 41 Barry\n4 39 Stephen\n\nC:\\Users\\RC\\Code>awk -f ranking_o.awk ranking.txt\n1 44 Solomon\n2 42 Jason\n3 42 Errol\n4 41 Garry\n5 41 Bernard\n6 41 Barry\n7 39 Stephen\n\nC:\\Users\\RC\\Code>awk -f ranking_f.awk ranking.txt\n  1  44 Solomon\n2.5  42 Jason\n2.5  42 Errol\n  5  41 Garry\n  5  41 Bernard\n  5  41 Barry\n  7  39 Stephen\n\nC:\\Users\\RC\\Code>\n", "explain": "This uses separate files for each method of ranking:\nThe input as a file ranking.txt:\n"}]