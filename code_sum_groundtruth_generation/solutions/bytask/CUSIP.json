[{"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Python", "code": "\nProcedural[edit]\n\n#!/usr/bin/env python3\n\nimport math\n\ndef cusip_check(cusip):\n    if len(cusip) != 9:\n        raise ValueError('CUSIP must be 9 characters')\n\n    cusip = cusip.upper()\n    total = 0\n    for i in range(8):\n        c = cusip[i]\n        if c.isdigit():\n            v = int(c)\n        elif c.isalpha():\n            p = ord(c) - ord('A') + 1\n            v = p + 9\n        elif c == '*':\n            v = 36\n        elif c == '@':\n            v = 37\n        elif c == '#':\n            v = 38\n\n        if i % 2 != 0:\n            v *= 2\n\n        total += int(v / 10) + v % 10\n    check = (10 - (total % 10)) % 10\n    return str(check) == cusip[-1]\n\nif __name__ == '__main__':\n    codes = [\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n            ]\n    for code in codes:\n        print(f'{code} -> {cusip_check(code)}')\n\n\n037833100 -> True\n17275R102 -> True\n38259P508 -> True\n594918104 -> True\n68389X106 -> False\n68389X105 -> True\n\nComposition of pure functions[edit]\nWorks with: Python version 3.7\n\n'''CUSIP'''\n\nfrom itertools import (cycle, islice, starmap)\nfrom functools import (reduce)\nfrom operator import (add)\nfrom enum import (Enum)\n\n\n# isCusip\u00a0:: Dict -> String -> Bool\ndef isCusip(dct):\n    '''Test for the validity of a CUSIP string in the\n       context of a supplied dictionary of char values'''\n    def go(s):\n        ns = [dct[c] for c in list(s) if c in dct]\n        return 9 == len(ns) and (\n            ns[-1] == (\n                10 - (\n                    sum(zipWith(\n                        lambda f, x: add(*divmod(f(x), 10))\n                    )(cycle([identity, double]))(\n                        take(8)(ns)\n                    )) % 10\n                )\n            ) % 10\n        )\n    return go\n\n\n# cusipCharDict\u00a0:: () -> Dict Char Int\ndef cusipCharDict():\n    '''Dictionary of integer values for CUSIP characters'''\n    def kv(a, ic):\n        i, c = ic\n        a[c] = i\n        return a\n    return reduce(\n        kv,\n        enumerate(\n            enumFromTo('0')('9') + (\n                enumFromTo('A')('Z') + list('*&#')\n            )\n        ),\n        {}\n    )\n\n\n# TEST -------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Tests'''\n\n    # cusipTest\u00a0:: String -> Bool\n    cusipTest = isCusip(cusipCharDict())\n\n    print(\n        tabulated('Valid as CUSIP string:')(\n            cusipTest\n        )([\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n        ])\n    )\n\n# GENERIC -------------------------------------------------\n\n\n# double\u00a0:: Num -> Num\ndef double(x):\n    '''Wrapped here as a function for the zipWith expression'''\n    return 2 * x\n\n\n# enumFromTo\u00a0:: Enum a => a -> a -> [a]\ndef enumFromTo(m):\n    '''Enumeration of values [m..n]'''\n    def go(x, y):\n        t = type(m)\n        i = fromEnum(x)\n        d = 0 if t != float else (x - i)\n        return list(map(\n            lambda x: toEnum(t)(d + x),\n            range(i, 1 + fromEnum(y))\n        ) if int != t else range(x, 1 + y))\n    return lambda n: go(m, n)\n\n\n# fromEnum\u00a0:: Enum a => a -> Int\ndef fromEnum(x):\n    '''Index integer for enumerable value.'''\n    return ord(x) if str == type(x) else (\n        x.value if isinstance(x, Enum) else int(x)\n    )\n\n\n# mul\u00a0:: Num -> Num -> Num\ndef mul(x):\n    '''Function version of (*) operator;\n       a curried equivalent of operator.mul'''\n    return lambda y: x * y\n\n\n# identity\u00a0:: a -> a\ndef identity(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# tabulated\u00a0:: String -> (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''heading -> function -> input List -> tabulated output string'''\n    def go(f, xs):\n        def width(x):\n            return len(str(x))\n        w = width(max(xs, key=width))\n        return s + '\\n' + '\\n'.join([\n            str(x).rjust(w, ' ') + ' -> ' + str(f(x)) for x in xs\n        ])\n    return lambda f: lambda xs: go(f, xs)\n\n\n# take\u00a0:: Int -> [a] -> [a]\n# take\u00a0:: Int -> String -> String\ndef take(n):\n    '''The prefix of xs of length n,\n       or xs itself if n > length xs.'''\n    return lambda xs: (\n        xs[0:n]\n        if isinstance(xs, list)\n        else list(islice(xs, n))\n    )\n\n\n# toEnum\u00a0:: Type -> Int -> a\ndef toEnum(t):\n    '''Enumerable value from index integer'''\n    dct = {\n        int: int,\n        float: float,\n        str: chr,\n        bool: bool\n    }\n    return lambda x: dct[t](x) if t in dct else t(x)\n\n\n# zipWith\u00a0:: (a -> b -> c) -> [a] -> [b] -> [c]\ndef zipWith(f):\n    '''Zipping with a custom (rather than tuple) function'''\n    return lambda xs: lambda ys: (\n        list(starmap(f, zip(xs, ys)))\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nTest for validity as a CUSIP string:\n\n'037833100' -> True\n'17275R102' -> True\n'38259P508' -> True\n'594918104' -> True\n'68389X106' -> False\n'68389X105' -> True\n", "explain": "Requires Python 3.6 for the string template literal in the print statement.\nOutput:\nComposing a set of pure functions, including a number of general and reusable abstractions:\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "C", "code": "\n\n#include<stdlib.h>\n#include<stdio.h>\n\nint cusipCheck(char str[10]){\n\tint sum=0,i,v;\n\t\n\tfor(i=0;i<8;i++){\n\t\tif(str[i]>='0'&&str[i]<='9')\n\t\t\tv = str[i]-'0';\n\t\telse if(str[i]>='A'&&str[i]<='Z')\n\t\t\tv = (str[i] - 'A' + 10);\n\t\telse if(str[i]=='*')\n\t\t\tv = 36;\n\t\telse if(str[i]=='@')\n\t\t\tv = 37;\n\t\telse if(str[i]=='#')\n\t\t\tv = 38;\n\t\tif(i%2!=0)\n\t\t\tv*=2;\n\t\t\n\t\tsum += ((int)(v/10) + v%10);\n\t}\n\treturn ((10 - (sum%10))%10);\n}\n\nint main(int argC,char* argV[])\n{\n\tchar cusipStr[10];\n\t\n\tint i,numLines;\n\t\n\tif(argC==1)\n\t\tprintf(\"Usage\u00a0: %s <full path of CUSIP Data file>\",argV[0]);\n\t\n\telse{\n\t\tFILE* fp = fopen(argV[1],\"r\");\n\t\n\t\tfscanf(fp,\"%d\",&numLines);\n\t\t\n\t\tprintf(\"CUSIP       Verdict\\n\");\n\t\tprintf(\"-------------------\");\n\t\t\n\t\tfor(i=0;i<numLines;i++){\n\t\t\n\t\t\tfscanf(fp,\"%s\",cusipStr);\n\t\t\n\t\t\tprintf(\"\\n%s\u00a0: %s\",cusipStr,(cusipCheck(cusipStr)==(cusipStr[8]-'0'))?\"Valid\":\"Invalid\");\n\t\t}\n\t\n\t\tfclose(fp);\n\t}\n\treturn 0;\n}\n\n\n6\n037833100\n17275R102\n38259P508\n594918104\n68389X106\n68389X105\n\n\nC:\\rosettaCode>cusipCheck.exe cusipData.txt\nCUSIP       Verdict\n-------------------\n037833100\u00a0: Valid\n17275R102\u00a0: Valid\n38259P508\u00a0: Valid\n594918104\u00a0: Valid\n68389X106\u00a0: Invalid\n68389X105\u00a0: Valid\n\n", "explain": "Reads CUSIP strings from a file and prints results to console, usage printed on incorrect invocation.\nInput file\u00a0:\nInvocation and output\u00a0:\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "C++", "code": "\nTranslation of: C#\n#include <iostream>\n#include <vector>\n\nbool isCusip(const std::string& s) {\n    if (s.size() != 9) return false;\n\n    int sum = 0;\n    for (int i = 0; i <= 7; ++i) {\n        char c = s[i];\n\n        int v;\n        if ('0' <= c && c <= '9') {\n            v = c - '0';\n        } else if ('A' <= c && c <= 'Z') {\n            v = c - '@';\n        } else if (c = '*') {\n            v = 36;\n        } else if (c = '#') {\n            v = 38;\n        } else {\n            return false;\n        }\n        if (i % 2 == 1) {\n            v *= 2;\n        }\n        sum += v / 10 + v % 10;\n    }\n    return s[8] - '0' == (10 - (sum % 10)) % 10;\n}\n\nint main() {\n    using namespace std;\n\n    vector<string> candidates{\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\"\n    };\n\n    for (auto str : candidates) {\n        auto res = isCusip(str) ? \"correct\" : \"incorrect\";\n        cout << str.c_str() << \" -> \" << res << \"\\n\";\n    }\n\n    return 0;\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Java", "code": "\nTranslation of: Kotlin\n\nimport java.util.List;\n\npublic class Cusip {\n    private static Boolean isCusip(String s) {\n        if (s.length() != 9) return false;\n        int sum = 0;\n        for (int i = 0; i <= 7; i++) {\n            char c = s.charAt(i);\n\n            int v;\n            if (c >= '0' && c <= '9') {\n                v = c - 48;\n            } else if (c >= 'A' && c <= 'Z') {\n                v = c - 55;  // lower case letters apparently invalid\n            } else if (c == '*') {\n                v = 36;\n            } else if (c == '@') {\n                v = 37;\n            } else if (c == '#') {\n                v = 38;\n            } else {\n                return false;\n            }\n            if (i % 2 == 1) v *= 2;  // check if odd as using 0-based indexing\n            sum += v / 10 + v % 10;\n        }\n        return s.charAt(8) - 48 == (10 - (sum % 10)) % 10;\n    }\n\n    public static void main(String[] args) {\n        List<String> candidates = List.of(\n                \"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\", \"EXTRACRD8\",\n                \"EXTRACRD9\", \"BADCUSIP!\", \"683&9X106\", \"68389x105\", \"683$9X106\", \"68389}105\", \"87264ABE4\"\n        );\n        for (String candidate : candidates) {\n            System.out.printf(\"%s -> %s%n\", candidate, isCusip(candidate) ? \"correct\" : \"incorrect\");\n        }\n    }\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\nEXTRACRD8 -> incorrect\nEXTRACRD9 -> correct\nBADCUSIP! -> incorrect\n683&9X106 -> incorrect\n68389x105 -> incorrect\n683$9X106 -> incorrect\n68389}105 -> incorrect\n87264ABE4 -> correct\n\n", "explain": "Uses Java 9\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "C#", "code": "\nTranslation of: Java\nusing System;\nusing System.Collections.Generic;\n\nnamespace CUSIP {\n    class Program {\n        static bool IsCusip(string s) {\n            if (s.Length != 9) return false;\n            int sum = 0;\n            for (int i = 0; i <= 7; i++) {\n                char c = s[i];\n\n                int v;\n                if (c >= '0' && c <= '9') {\n                    v = c - 48;\n                }\n                else if (c >= 'A' && c <= 'Z') {\n                    v = c - 55;  // lower case letters apparently invalid\n                }\n                else if (c == '*') {\n                    v = 36;\n                }\n                else if (c == '#') {\n                    v = 38;\n                }\n                else {\n                    return false;\n                }\n                if (i % 2 == 1) v *= 2;  // check if odd as using 0-based indexing\n                sum += v / 10 + v % 10;\n            }\n            return s[8] - 48 == (10 - (sum % 10)) % 10;\n        }\n\n        static void Main(string[] args) {\n            List<string> candidates = new List<string>() {\n                \"037833100\",\n                \"17275R102\",\n                \"38259P508\",\n                \"594918104\",\n                \"68389X106\",\n                \"68389X105\"\n            };\n            foreach (var candidate in candidates) {\n                Console.WriteLine(\"{0} -> {1}\", candidate, IsCusip(candidate) ? \"correct\" : \"incorrect\");\n            }\n        }\n    }\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "JavaScript", "code": "\n(() => {\n    'use strict';\n\n    // cusipValid = Dict Char Int -> String -> Bool\n    const cusipValid = charMap => s => {\n        const\n            ns = fromMaybe([])(\n                traverse(flip(lookupDict)(charMap))(\n                    chars(s)\n                )\n            );\n        return 9 === ns.length && (\n            last(ns) === rem(\n                10 - rem(\n                    sum(apList(\n                        apList([quot, rem])(\n                            zipWith(identity)(\n                                cycle([identity, x => 2 * x])\n                            )(take(8)(ns))\n                        )\n                    )([10]))\n                )(10)\n            )(10)\n        );\n    };\n\n    //----------------------- TEST ------------------------\n    // main\u00a0:: IO ()\n    const main = () => {\n\n        // cusipMap\u00a0:: Dict Char Int\n        const cusipMap = dictFromList(\n            zip(chars(\n                \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#\"\n            ))(enumFrom(0)));\n\n        console.log(unlines(map(\n            apFn(\n                s => validity => s + ' -> ' + str(validity)\n            )(cusipValid(cusipMap))\n        )([\n            '037833100',\n            '17275R102',\n            '38259P508',\n            '594918104',\n            '68389X106',\n            '68389X105'\n        ])));\n    };\n\n\n    //----------------- GENERIC FUNCTIONS -----------------\n\n    // Just\u00a0:: a -> Maybe a\n    const Just = x => ({\n        type: 'Maybe',\n        Nothing: false,\n        Just: x\n    });\n\n\n    // Nothing\u00a0:: Maybe a\n    const Nothing = () => ({\n        type: 'Maybe',\n        Nothing: true,\n    });\n\n\n    // Tuple (,)\u00a0:: a -> b -> (a, b)\n    const Tuple = a =>\n        b => ({\n            type: 'Tuple',\n            '0': a,\n            '1': b,\n            length: 2\n        });\n\n\n    // apFn\u00a0:: (a -> b -> c) -> (a -> b) -> a -> c\n    const apFn = f =>\n        // Applicative instance for functions.\n        // f(x) applied to g(x).\n        g => x => f(x)(\n            g(x)\n        );\n\n\n    // apList (<*>)\u00a0:: [(a -> b)] -> [a] -> [b]\n    const apList = fs =>\n        // The sequential application of each of a list\n        // of functions to each of a list of values.\n        xs => fs.flatMap(\n            f => xs.map(f)\n        );\n\n\n    // append (++)\u00a0:: [a] -> [a] -> [a]\n    // append (++)\u00a0:: String -> String -> String\n    const append = xs =>\n        // A list or string composed by\n        // the concatenation of two others.\n        ys => xs.concat(ys);\n\n\n    // chars\u00a0:: String -> [Char]\n    const chars = s =>\n        s.split('');\n\n\n    // cons\u00a0:: a -> [a] -> [a]\n    const cons = x =>\n        xs => Array.isArray(xs) ? (\n            [x].concat(xs)\n        ) : 'GeneratorFunction' !== xs\n        .constructor.constructor.name ? (\n            x + xs\n        ) : ( // cons(x)(Generator)\n            function*() {\n                yield x;\n                let nxt = xs.next()\n                while (!nxt.done) {\n                    yield nxt.value;\n                    nxt = xs.next();\n                }\n            }\n        )();\n\n\n    // cycle\u00a0:: [a] -> Generator [a]\n    function* cycle(xs) {\n        const lng = xs.length;\n        let i = 0;\n        while (true) {\n            yield(xs[i])\n            i = (1 + i) % lng;\n        }\n    }\n\n\n    // dictFromList\u00a0:: [(k, v)] -> Dict\n    const dictFromList = kvs =>\n        Object.fromEntries(kvs);\n\n\n    // enumFrom\u00a0:: Enum a => a -> [a]\n    function* enumFrom(x) {\n        // A non-finite succession of enumerable\n        // values, starting with the value x.\n        let v = x;\n        while (true) {\n            yield v;\n            v = succ(v);\n        }\n    }\n\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        1 < f.length ? (\n            (a, b) => f(b, a)\n        ) : (x => y => f(y)(x));\n\n\n    // fromEnum\u00a0:: Enum a => a -> Int\n    const fromEnum = x =>\n        typeof x !== 'string' ? (\n            x.constructor === Object ? (\n                x.value\n            ) : parseInt(Number(x))\n        ) : x.codePointAt(0);\n\n\n    // fromMaybe\u00a0:: a -> Maybe a -> a\n    const fromMaybe = def =>\n        // A default value if mb is Nothing\n        // or the contents of mb.\n        mb => mb.Nothing ? def : mb.Just;\n\n\n    // fst\u00a0:: (a, b) -> a\n    const fst = tpl =>\n        // First member of a pair.\n        tpl[0];\n\n\n    // identity\u00a0:: a -> a\n    const identity = x =>\n        // The identity function. (`id`, in Haskell)\n        x;\n\n\n    // last\u00a0:: [a] -> a\n    const last = xs =>\n        // The last item of a list.\n        0 < xs.length ? xs.slice(-1)[0] : undefined;\n\n\n    // length\u00a0:: [a] -> Int\n    const length = xs =>\n        // Returns Infinity over objects without finite\n        // length. This enables zip and zipWith to choose\n        // the shorter argument when one is non-finite,\n        // like cycle, repeat etc\n        (Array.isArray(xs) || 'string' === typeof xs) ? (\n            xs.length\n        ) : Infinity;\n\n\n    // liftA2\u00a0:: (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n    const liftA2 = f => a => b =>\n        a.Nothing ? a : b.Nothing ? b : Just(f(a.Just)(b.Just));\n\n\n    // lookupDict\u00a0:: a -> Dict -> Maybe b\n    const lookupDict = k => dct => {\n        const v = dct[k];\n        return undefined !== v ? (\n            Just(v)\n        ) : Nothing();\n    };\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => (\n            Array.isArray(xs) ? (\n                xs\n            ) : xs.split('')\n        ).map(f);\n\n\n    // pureMay\u00a0:: a -> Maybe a\n    const pureMay = x => Just(x);\n\n    // Given a type name string, returns a\n    // specialised 'pure', where\n    // 'pure' lifts a value into a particular functor.\n\n    // pureT\u00a0:: String -> f a -> (a -> f a)\n    const pureT = t => x =>\n        'List' !== t ? (\n            'Either' === t ? (\n                pureLR(x)\n            ) : 'Maybe' === t ? (\n                pureMay(x)\n            ) : 'Node' === t ? (\n                pureTree(x)\n            ) : 'Tuple' === t ? (\n                pureTuple(x)\n            ) : pureList(x)\n        ) : pureList(x);\n\n\n    // pureTuple\u00a0:: a -> (a, a)\n    const pureTuple = x =>\n        Tuple('')(x);\n\n    // quot\u00a0:: Int -> Int -> Int\n    const quot = n =>\n        m => Math.floor(n / m);\n\n    // rem\u00a0:: Int -> Int -> Int\n    const rem = n => m => n % m;\n\n    // snd\u00a0:: (a, b) -> b\n    const snd = tpl => tpl[1];\n\n    // str\u00a0:: a -> String\n    const str = x =>\n        x.toString();\n\n    // succ\u00a0:: Enum a => a -> a\n    const succ = x => {\n        const t = typeof x;\n        return 'number' !== t ? (() => {\n            const [i, mx] = [x, maxBound(x)].map(fromEnum);\n            return i < mx ? (\n                toEnum(x)(1 + i)\n            ) : Error('succ\u00a0:: enum out of range.')\n        })() : x < Number.MAX_SAFE_INTEGER ? (\n            1 + x\n        ) : Error('succ\u00a0:: Num out of range.')\n    };\n\n    // sum\u00a0:: [Num] -> Num\n    const sum = xs =>\n        // The numeric sum of all values in xs.\n        xs.reduce((a, x) => a + x, 0);\n\n    // take\u00a0:: Int -> [a] -> [a]\n    // take\u00a0:: Int -> String -> String\n    const take = n =>\n        // The first n elements of a list,\n        // string of characters, or stream.\n        xs => 'GeneratorFunction' !== xs\n        .constructor.constructor.name ? (\n            xs.slice(0, n)\n        ) : [].concat.apply([], Array.from({\n            length: n\n        }, () => {\n            const x = xs.next();\n            return x.done ? [] : [x.value];\n        }));\n\n    // The first argument is a sample of the type\n    // allowing the function to make the right mapping\n\n    // toEnum\u00a0:: a -> Int -> a\n    const toEnum = e => x =>\n        ({\n            'number': Number,\n            'string': String.fromCodePoint,\n            'boolean': Boolean,\n            'object': v => e.min + v\n        } [typeof e])(x);\n\n\n    // traverse\u00a0:: (Applicative f) => (a -> f b) -> [a] -> f [b]\n    const traverse = f =>\n        // Collected results of mapping each element\n        // of a structure to an action, and evaluating\n        // these actions from left to right.\n        xs => 0 < xs.length ? (() => {\n            const\n                vLast = f(xs.slice(-1)[0]),\n                t = vLast.type || 'List';\n            return xs.slice(0, -1).reduceRight(\n                (ys, x) => liftA2(cons)(f(x))(ys),\n                liftA2(cons)(vLast)(pureT(t)([]))\n            );\n        })() : [\n            []\n        ];\n\n\n    // uncons\u00a0:: [a] -> Maybe (a, [a])\n    const uncons = xs => {\n        // Just a tuple of the head of xs and its tail,\n        // Or Nothing if xs is an empty list.\n        const lng = length(xs);\n        return (0 < lng) ? (\n            Infinity > lng ? (\n                Just(Tuple(xs[0])(xs.slice(1))) // Finite list\n            ) : (() => {\n                const nxt = take(1)(xs);\n                return 0 < nxt.length ? (\n                    Just(Tuple(nxt[0])(xs))\n                ) : Nothing();\n            })() // Lazy generator\n        ) : Nothing();\n    };\n\n\n    // uncurry\u00a0:: (a -> b -> c) -> ((a, b) -> c)\n    const uncurry = f =>\n        // A function over a pair, derived\n        // from a curried function.\n        x => ((...args) => {\n            const\n                xy = 1 < args.length ? (\n                    args\n                ) : args[0];\n            return f(xy[0])(xy[1]);\n        })(x);\n\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join('\\n');\n\n\n    // zip\u00a0:: [a] -> [b] -> [(a, b)]\n    const zip = xs =>\n        // Use of `take` and `length` here allows for zipping with non-finite\n        // lists - i.e. generators like cycle, repeat, iterate.\n        ys => {\n            const\n                lng = Math.min(length(xs), length(ys)),\n                vs = take(lng)(ys);\n            return take(lng)(xs).map(\n                (x, i) => Tuple(x)(vs[i])\n            );\n        };\n\n    // Use of `take` and `length` here allows zipping with non-finite lists\n    // i.e. generators like cycle, repeat, iterate.\n\n    // zipWith\u00a0:: (a -> b -> c) -> [a] -> [b] -> [c]\n    const zipWith = f => xs => ys => {\n        const lng = Math.min(length(xs), length(ys));\n        return Infinity > lng ? (() => {\n            const\n                as = take(lng)(xs),\n                bs = take(lng)(ys);\n            return Array.from({\n                length: lng\n            }, (_, i) => f(as[i])(\n                bs[i]\n            ));\n        })() : zipWithGen(f)(xs)(ys);\n    };\n\n\n    // zipWithGen\u00a0:: (a -> b -> c) ->\n    // Gen [a] -> Gen [b] -> Gen [c]\n    const zipWithGen = f => ga => gb => {\n        function* go(ma, mb) {\n            let\n                a = ma,\n                b = mb;\n            while (!a.Nothing && !b.Nothing) {\n                let\n                    ta = a.Just,\n                    tb = b.Just\n                yield(f(fst(ta))(fst(tb)));\n                a = uncons(snd(ta));\n                b = uncons(snd(tb));\n            }\n        }\n        return go(uncons(ga), uncons(gb));\n    };\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n037833100 -> true\n17275R102 -> true\n38259P508 -> true\n594918104 -> true\n68389X106 -> false\n68389X105 -> true\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "PHP", "code": "\nfunction IsCusip(string $s) {\n    if (strlen($s) != 9) return false;\n    $sum = 0;\n    for ($i = 0; $i <= 7; $i++) {\n        $c = $s[$i];\n        if (ctype_digit($c)) {\n            // if character is numeric, get character's numeric value\n            $v = intval($c);\n        } elseif (ctype_alpha($c)) {\n            // if character is alphabetic, get character's ordinal position in alphabet\n            $position = ord(strtoupper($c)) - ord('A') + 1;\n            $v = $position + 9;\n        } elseif ($c == \"*\") {\n            $v = 36;\n        } elseif ($c == \"@\") {\n            $v = 37;\n        } elseif ($c == \"#\") {\n            $v = 38;\n        } else {\n            return false;\n        }\n        // is this character position even?\n        if ($i % 2 == 1) {\n            $v *= 2;\n        }\n        // calculate the checksum digit\n        $sum += floor($v / 10 ) + ( $v % 10 );\n    }\n    return ord($s[8]) - 48 == (10 - ($sum % 10)) % 10;\n}\n\n$cusips = array(\"037833100\",\n                \"17275R102\",\n                \"38259P508\",\n                \"594918104\",\n                \"68389X106\",\n                \"68389X105\");\n\nforeach ($cusips as $cusip) echo $cusip . \" -> \" . (IsCusip($cusip) ? \"valid\" : \"invalid\") . \"\\n\";\n\n\nOutput:\n037833100 -> valid\n17275R102 -> valid\n38259P508 -> valid\n594918104 -> valid\n68389X106 -> invalid\n68389X105 -> valid\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Fortran", "code": "\n\nThere is no checking that only valid characters are presented, nor that eight-character codes only are offered, though the compiler might complain if the function were to be invoked with a text literal of the wrong size. In the absence of such checks, there need be no added complications to support a scheme for reporting such errors.       CHARACTER*1 FUNCTION CUSIPCHECK(TEXT)\t!Determines the check sum character.\nCommittee on Uniform Security Identification Purposes, of the American (i.e. USA) Bankers' Association.\n       CHARACTER*8 TEXT\t\t!Specifically, an eight-symbol code.\n       CHARACTER*(*) VALID\t!These only are valid.\n       PARAMETER (VALID = \"0123456789ABCDEFGHIJKLMNOPQRSTUVWXYZ*@#\")\n       INTEGER I,V,S\t\t!Assistants.\n        S = 0\t\t!Start the checksum.\n        DO I = 1,LEN(TEXT)\t!Step through the text.\n          V = INDEX(VALID,TEXT(I:I)) - 1\t!Since counting starts with one.\n          IF (MOD(I,2).EQ.0) V = V*2\t\t!V = V*(2 - MOD(I,2))?\n          S = S + V/10 + MOD(V,10)\t\t!Specified calculation.\n        END DO\t\t\t!On to the next character.\n        I = MOD(10 - MOD(S,10),10) + 1\t!Again, counting starts with one.\n        CUSIPCHECK = VALID(I:I)\t!Thanks to the MOD 10, surely a digit.\n      END FUNCTION CUSIPCHECK\t!No checking for invalid input...\n\n      PROGRAM POKE\t!Just to try it out.\n      INTEGER I,N\t!Assistants.\n      PARAMETER (N = 6)\t\t!A whole lot of blather\n      CHARACTER*9 CUSIP(N)\t!Just to have an array of test codes.\n      DATA CUSIP/\t\t!Here they are, as specified.\n     1  \"037833100\",\n     2  \"17275R102\",\n     3  \"38259P508\",\n     4  \"594918104\",\n     5  \"68389X106\",\n     6  \"68389X105\"/\n      CHARACTER*1 CUSIPCHECK\t!Needed as no use of the MODULE protocol.\n\n      DO I = 1,N\t!\"More than two? Use a DO...\"\n        WRITE (6,*) CUSIP(I),CUSIPCHECK(CUSIP(I)(1:8)).EQ.CUSIP(I)(9:9)\n      END DO\n\n      END\n\n\n037833100 T\n17275R102 T\n38259P508 T\n594918104 T\n68389X106 F\n68389X105 T\n\n\n", "explain": "The key notion here is to employ a single sequence of valid characters, VALID, and for each character C of the code under test, use function INDEX(VALID,C) to find its position within that sequence, which turns out to be the desired v of the example pseudocode. The only slight difficulty is that INDEX starts its counting with one for the first character of VALID, which is zero, so one must be subtracted; similarly, to return a digit character code via indexing into VALID, one must be added. By using a list of valid characters rather than peculiar character arithmetic (such as c <= \"9\" & c >= \"0\" or similar) there is no reliance on the ASCII way of things. Recall that EBCDIC encodements have different orderings and notably, non-alphabetic characters between A and Z.\nThe source does not bother with the MODULE protocol of F90 and later, and so the type of function CUSIPCHECK must be declared in all routines wishing to invoke it. However, the F90 feature of having the END statement of a subroutine or function give its name is to valuable to ignore. The function returns a character code rather than an integer, since the presumption is that it is to be compared to the check character of the code being inspected, which is known as a character not an integer. This means some blather when extracting the eight characters to be presented to CUSIPCHECK and comparing the result to the ninth character, but the test can be done in one expression. \nOutput: standard output is to I/O unit 6, and free-format (the *) will suffice for this. Each line output starts with a space (in case it is to go to a lineprinter, with carriage control), which is convenient for layout here.\nThis would have worked first time, except that a fymgre frmble caused the omission of the digit 2 from the text of VALID. The benefits of checking checksums reach to unexpected places!\n\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc isCusip(s string) bool {\n    if len(s) != 9 { return false }\n    sum := 0\n    for i := 0; i < 8; i++ {\n        c := s[i]\n        var v int\n        switch {\n            case c >= '0' && c <= '9':\n                v = int(c) - 48\n            case c >= 'A' && c <= 'Z':\n                v = int(c) - 55\n            case c == '*':\n                v = 36\n            case c == '@':\n                v = 37\n            case c == '#':\n                v = 38\n            default:\n                return false\n        }\n        if i % 2 == 1 { v *= 2 }  // check if odd as using 0-based indexing\n        sum += v/10 + v%10\n    }\n    return int(s[8]) - 48 == (10 - (sum%10)) % 10\n}\n\nfunc main() {\n    candidates := []string {\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\",\n    }\n\n    for _, candidate := range candidates {\n        var b string\n        if isCusip(candidate) {\n            b = \"correct\"\n        } else {\n            b = \"incorrect\"\n        }\n        fmt.Printf(\"%s -> %s\\n\", candidate, b)\n    }\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\ntype TCUSIPInfo = record\n ID,Company: string;\n end;\n\nvar CUSIPArray: array [0..5] of TCUSIPInfo = (\n  (ID:'037833100'; Company: 'Apple Incorporated'),\n  (ID:'17275R102'; Company: 'Cisco Systems'),\n  (ID:'38259P508'; Company: 'Google Incorporated'),\n  (ID:'594918104'; Company: 'Microsoft Corporation'),\n  (ID:'68389X106'; Company: 'Oracle Corporation'),\n  (ID:'68389X105'; Company: 'Oracle Corporation'));\n\nfunction IsValidCUSIP(Info: TCUSIPInfo): boolean;\n{Calculate checksum on first 7 chars of CUSIP }\n{And compare with the last char - the checksum char}\nvar I,V,Sum: integer;\nvar C: char;\nbegin\nSum:=0;\nfor I:=1 to Length(Info.ID)-1 do\n\tbegin\n\tC:=Info.ID[I];\n\tif C in ['0'..'9'] then V:=byte(C)-$30\n\telse if C in ['A'..'Z'] then V:=(byte(C)-$40) + 9\n\telse case C of\n\t '*': V:=36;\n\t '@': V:=37;\n\t '#': V:=38;\n\t end;\n\tif (I and 1)=0 then V:=V*2;\n\tSum:=Sum + (V div 10) + (V mod 10);\n\tend;\nSum:=(10 - (Sum mod 10)) mod 10;\nResult:=StrToInt(Info.ID[Length(Info.ID)])=Sum;\nend;\n\n\nprocedure TestCUSIPList(Memo: TMemo);\n{Test every item in the CSUIP array}\nvar I: integer;\nvar S: string;\nbegin\nfor I:=0 to High(CUSIPArray) do\n\tbegin\n\tif IsValidCUSIP(CUSIPArray[I]) then S:='Valid' else S:='Invalid';\n\tMemo.Lines.Add(CUSIPArray[I].ID+'\t'+CUSIPArray[I].Company+':\t'+S);\n\tend;\nend;\n\n\nOutput:\n037833100\tApple Incorporated:\tValid\n17275R102\tCisco Systems:\t\tValid\n38259P508\tGoogle Incorporated:\tValid\n594918104\tMicrosoft Corporation:\tValid\n68389X106\tOracle Corporation:\tInvalid\n68389X105\tOracle Corporation:\tValid\n\n\n\n", "explain": "Using sets to simplify string parsing\n\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Ruby", "code": "\nFollowing pseudocode[edit]\n#!/usr/bin/env ruby\n\ndef check_cusip(cusip)\n  abort('CUSIP must be 9 characters') if cusip.size != 9\n\n  sum = 0\n  cusip.split('').each_with_index do |char, i|\n    next if i == cusip.size - 1\n    case\n    when char.scan(/\\D/).empty?\n      v = char.to_i\n    when char.scan(/\\D/).any?\n      pos = char.upcase.ord - 'A'.ord + 1\n      v = pos + 9\n    when char == '*'\n      v = 36\n    when char == '@'\n      v = 37\n    when char == '#'\n      v = 38\n    end\n\n    v *= 2 unless (i % 2).zero?\n    sum += (v/10).to_i + (v % 10)\n  end\n\n  check = (10 - (sum % 10)) % 10\n  return 'VALID' if check.to_s == cusip.split('').last\n  'INVALID'\nend\n\nCUSIPs = %w[\n  037833100 17275R102 38259P508 594918104 68389X106 68389X105\n]\n\nCUSIPs.each do |cusip|\n  puts \"#{cusip}: #{check_cusip(cusip)}\"\nend\n\n\n037833100: VALID\n17275R102: VALID\n38259P508: VALID\n594918104: VALID\n68389X106: INVALID\n68389X105: VALID\n\nMore concise[edit]\n\nTABLE = (\"0\"..\"9\").chain(\"A\"..\"Z\", %w(* @ #)).zip(0..).to_h\n\ndef valid_CUSIP?(str)\n  sum = str[0..-2].chars.each_slice(2).sum do |c1,c2|\n    TABLE[c1].divmod(10).sum + (TABLE[c2]*2).divmod(10).sum\n  end\n  str[-1].to_i == (10 - (sum % 10)) % 10\nend\n\nCUSIPs = %w(037833100 17275R102 38259P508 594918104 68389X106 68389X105)\nCUSIPs.each{|cusip| puts \"#{cusip}: #{valid_CUSIP? cusip}\"}\n\n", "explain": "Output:\nSince it uses methods like chain, to_h, sum, and infinite Range syntax (0..), this needs a Ruby version > 2.5\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Rust", "code": "\nfn cusip_check(cusip: &str) -> bool {\n    if cusip.len() != 9 {\n        return false;\n    }\n\n    let mut v = 0;\n    let capital_cusip = cusip.to_uppercase();\n    let char_indices = capital_cusip.as_str().char_indices().take(7);\n\n    let total = char_indices.fold(0, |total, (i, c)| {\n        v = match c {\n            '*' => 36,\n            '@' => 37,\n            '#' => 38,\n            _ if c.is_digit(10) => c.to_digit(10).unwrap() as u8,\n            _ if c.is_alphabetic() => (c as u8) - b'A' + 1 + 9,\n            _ => v,\n        };\n\n        if i % 2 != 0 {\n            v *= 2\n        }\n        total + (v / 10) + v % 10\n    });\n\n    let check = (10 - (total % 10)) % 10;\n    (check.to_string().chars().nth(0).unwrap()) == cusip.chars().nth(cusip.len() - 1).unwrap()\n}\n\nfn main() {\n    let codes = [\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\",\n    ];\n    for code in &codes {\n        println!(\"{} -> {}\", code, cusip_check(code))\n    }\n}\n\n\n037833100 -> True\n17275R102 -> True\n38259P508 -> True\n594918104 -> True\n68389X106 -> False\n68389X105 -> True\n\n", "explain": "Output:\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Swift", "code": "\nstruct CUSIP {\n  var value: String\n\n  private static let alphabet = Array(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n\n  init?(value: String) {\n    if value.count == 9 && String(value.last!) == CUSIP.checkDigit(cusipString: String(value.dropLast())) {\n      self.value = value\n    } else if value.count == 8, let checkDigit = CUSIP.checkDigit(cusipString: value) {\n      self.value = value + checkDigit\n    } else {\n      return nil\n    }\n  }\n\n  static func checkDigit(cusipString: String) -> String? {\n    guard cusipString.count == 8, cusipString.allSatisfy({ $0.isASCII }) else {\n      return nil\n    }\n\n    let sum = cusipString.uppercased().enumerated().reduce(0, {sum, pair in\n      let (i, char) = pair\n      var v: Int\n\n      switch char {\n      case \"*\":\n        v = 36\n      case \"@\":\n        v = 37\n      case \"#\":\n        v = 38\n      case _ where char.isNumber:\n        v = char.wholeNumberValue!\n      case _:\n        v = Int(char.asciiValue! - 65) + 10\n      }\n\n      if i & 1 == 1 {\n        v *= 2\n      }\n\n      return sum + (v / 10) + (v % 10)\n    })\n\n    return String((10 - (sum % 10)) % 10)\n  }\n}\n\nlet testCases = [\n  \"037833100\",\n  \"17275R102\",\n  \"38259P508\",\n  \"594918104\",\n  \"68389X106\",\n  \"68389X105\"\n]\n\nfor potentialCUSIP in testCases {\n  print(\"\\(potentialCUSIP) -> \", terminator: \"\")\n\n  switch CUSIP(value: potentialCUSIP) {\n  case nil:\n    print(\"Invalid\")\n  case _:\n    print(\"Valid\")\n  }\n}\n\n\nOutput:\n037833100 -> Valid\n17275R102 -> Valid\n38259P508 -> Valid\n594918104 -> Valid\n68389X106 -> Invalid\n68389X105 -> Valid\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Cusip_Test is\n   use Ada.Text_IO;\n\n   subtype Cusip is String (1 .. 9);\n\n   function Check_Cusip (Code : Cusip) return Boolean is\n      Sum : Integer := 0;\n      V   : Integer;\n\n   begin\n      for I in Code'First .. Code'Last - 1 loop\n         case Code (I) is\n            when '0' .. '9' =>\n               V := Character'Pos (Code (I)) - Character'Pos ('0');\n            when 'A' .. 'Z' =>\n               V := Character'Pos (Code (I)) - Character'Pos ('A') + 10;\n            when '*' => V := 36;\n            when '@' => V := 37;\n            when '#' => V := 38;\n            when others => return False;\n         end case;\n\n         if I mod 2 = 0 then\n            V := V * 2;\n         end if;\n\n         Sum := Sum + V / 10 + (V mod 10);\n      end loop;\n\n      return (10 - (Sum mod 10)) mod 10 =\n        Character'Pos (Code (Code'Last)) - Character'Pos ('0');\n   end Check_Cusip;\n\n   type Cusip_Array is array (Natural range <>) of Cusip;\n\n   Test_Array : Cusip_Array :=\n     (\"037833100\",\n      \"17275R102\",\n      \"38259P508\",\n      \"594918104\",\n      \"68389X106\",\n      \"68389X105\");\nbegin\n   for I in Test_Array'Range loop\n      Put (Test_Array (I) & \": \");\n      if Check_Cusip (Test_Array (I)) then\n         Put_Line (\"valid\");\n      else\n         Put_Line (\"not valid\");\n      end if;\n   end loop;\nend Cusip_Test;\n\n\nOutput:\n037833100: valid\n17275R102: valid\n38259P508: valid\n594918104: valid\n68389X106: not valid\n68389X105: valid\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nmodule CUSIP\n\nfunction _lastdigitcusip(input::AbstractString)\n    input = uppercase(input)\n    s = 0\n\n    for (i, c) in enumerate(input)\n        if isdigit(c)\n            v = Int(c) - 48\n        elseif isalpha(c)\n            v = Int(c) - 64 + 9\n        elseif c == '*'\n            v = 36\n        elseif c == '@'\n            v = 37\n        elseif c == '#'\n            v = 38\n        end\n\n        if iseven(i); v *= 2 end\n        s += div(v, 10) + rem(v, 10)\n    end\n\n    return Char(rem(10 - rem(s, 10), 10) + 48)\nend\n\ncheckdigit(input::AbstractString) = input[9] == _lastdigitcusip(input[1:8])\n\nend  # module CUSIP\n\nfor code in (\"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\")\n    println(\"$code is \", CUSIP.checkdigit(code) ? \"correct.\" : \"not correct.\")\nend\n\n\nOutput:\n037833100 is correct.\n17275R102 is correct.\n38259P508 is correct.\n594918104 is correct.\n68389X106 is not correct.\n68389X105 is correct.\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Kotlin", "code": "\n// version 1.1.0\n\nfun isCusip(s: String): Boolean {\n    if (s.length != 9) return false\n    var sum = 0\n    for (i in 0..7) {\n        val c = s[i]\n        var v = when (c) {\n            in '0'..'9'  -> c.toInt() - 48\n            in 'A'..'Z'  -> c.toInt() - 55  // lower case letters apparently invalid\n            '*'          -> 36\n            '@'          -> 37\n            '#'          -> 38\n            else         -> return false\n        }\n        if (i % 2 == 1) v *= 2  // check if odd as using 0-based indexing\n        sum += v / 10 + v % 10\n    }\n    return s[8].toInt() - 48  == (10 - (sum % 10)) % 10\n}\n\nfun main(args: Array<String>) {\n    val candidates = listOf(\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\"\n    )\n    for (candidate in candidates) \n        println(\"$candidate -> ${if(isCusip(candidate)) \"correct\" else \"incorrect\"}\")\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Perl", "code": "\n$cv{$_} = $i++ for '0'..'9', 'A'..'Z', '*', '@', '#';\n\nsub cusip_check_digit {\n    my @cusip = split m{}xms, shift;\n    my $sum = 0;\n\n    for $i (0..7) {\n        return 'Invalid character found' unless $cusip[$i] =~ m{\\A [[:digit:][:upper:]*@#] \\z}xms;\n        $v  = $cv{ $cusip[$i] };\n        $v *= 2 if $i%2;\n        $sum += int($v/10) + $v%10;\n    }\n\n    $check_digit = (10 - ($sum%10)) % 10;\n    $check_digit == $cusip[8] ? '' : ' (incorrect)';\n}\n\nmy %test_data = (\n    '037833100' => 'Apple Incorporated',\n    '17275R102' => 'Cisco Systems',\n    '38259P508' => 'Google Incorporated',\n    '594918104' => 'Microsoft Corporation',\n    '68389X106' => 'Oracle Corporation',\n    '68389X105' => 'Oracle Corporation',\n);\n\nprint \"$_ $test_data{$_}\" . cusip_check_digit($_) . \"\\n\" for sort keys %test_data;\n\n\nOutput:\n037833100 Apple Incorporated\n17275R102 Cisco Systems\n38259P508 Google Incorporated\n594918104 Microsoft Corporation\n68389X105 Oracle Corporation\n68389X106 Oracle Corporation (incorrect)\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Lua", "code": "\n\nfunction checkDigit (cusip)\n  if #cusip ~= 8 then return false end\n  \n  local sum, c, v, p = 0\n  for i = 1, 8 do\n    c = cusip:sub(i, i)\n    if c:match(\"%d\") then\n      v = tonumber(c)\n    elseif c:match(\"%a\") then\n      p = string.byte(c) - 55\n      v = p + 9\n    elseif c == \"*\" then\n      v = 36\n    elseif c == \"@\" then\n      v = 37\n    elseif c == \"#\" then\n      v = 38\n    end\n    if i % 2 == 0 then\n      v = v * 2\n    end\n    \n    sum = sum + math.floor(v / 10) + v % 10\n  end\n  \n  return tostring((10 - (sum % 10)) % 10)\nend\n\nlocal testCases = {\n  \"037833100\",\n  \"17275R102\",\n  \"38259P508\",\n  \"594918104\",\n  \"68389X106\",\n  \"68389X105\"\n}\nfor _, CUSIP in pairs(testCases) do\n  io.write(CUSIP .. \": \")\n  if checkDigit(CUSIP:sub(1, 8)) == CUSIP:sub(9, 9) then\n    print(\"VALID\")\n  else\n    print(\"INVALID\")\n  end\nend\n\n\nOutput:\n037833100: VALID\n17275R102: VALID\n38259P508: VALID\n594918104: VALID\n68389X106: INVALID\n68389X105: VALID\n", "explain": "The checkDigit function is a line-for-line translation of the pseudo-code algorithm.\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Scala", "code": "\n\nOutput:See it running in your browser by ScalaFiddle (JavaScript, non JVM) or by Scastie (JVM).\nobject Cusip extends App {\n\n  val candidates = Seq(\"037833100\", \"17275R102\", \"38259P508\", \"594918104\", \"68389X106\", \"68389X105\")\n\n  for (candidate <- candidates)\n    printf(f\"$candidate%s -> ${if (isCusip(candidate)) \"correct\" else \"incorrect\"}%s%n\")\n\n  private def isCusip(s: String): Boolean = {\n    if (s.length != 9) false\n    else {\n      var sum = 0\n      for (i <- 0 until 7) {\n        val c = s(i)\n        var v = 0\n        if (c >= '0' && c <= '9') v = c - 48\n        else if (c >= 'A' && c <= 'Z') v = c - 55 // lower case letters apparently invalid\n        else if (c == '*') v = 36\n        else if (c == '@') v = 37\n        else if (c == '#') v = 38\n        else return false\n        if (i % 2 == 1) v *= 2 // check if odd as using 0-based indexing\n        sum += v / 10 + v % 10\n      }\n      s(8) - 48 == (10 - (sum % 10)) % 10\n    }\n  }\n\n}\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main(string[] args) {\n    writeln(\"CUSIP       Verdict\");\n    foreach(arg; args[1..$]) {\n        writefln(\"%9s\u00a0: %s\", arg, isValidCusip(arg) ? \"Valid\" : \"Invalid\");\n    }\n}\n\nclass IllegalCharacterException : Exception {\n    this(string msg) {\n        super(msg);\n    }\n}\n\nbool isValidCusip(string cusip) in {\n    assert(cusip.length == 9, \"Incorrect cusip length\");\n} body {\n    try {\n        auto check = cusipCheckDigit(cusip);\n        return cusip[8] == ('0' + check);\n    } catch (IllegalCharacterException e) {\n        return false;\n    }\n}\n\nunittest {\n    // Oracle Corporation\n    assertEquals(isValidCusip(\"68389X105\"), true);\n\n    // Oracle Corporation (invalid)\n    assertEquals(isValidCusip(\"68389X106\"), false);\n}\n\nint cusipCheckDigit(string cusip) in {\n    assert(cusip.length == 9, \"Incorrect cusip length\");\n} body {\n    int sum;\n    for (int i=0; i<8; ++i) {\n        char c = cusip[i];\n        int v;\n\n        switch(c) {\n            case '0': .. case '9':\n                v = c - '0';\n                break;\n            case 'A': .. case 'Z':\n                v = c - 'A' + 10;\n                break;\n            case '*':\n                v = 36;\n                break;\n            case '@':\n                v = 37;\n                break;\n            case '#':\n                v = 38;\n                break;\n            default:\n                throw new IllegalCharacterException(\"Saw character: \" ~ c);\n        }\n        if (i%2 == 1) {\n            v = 2 * v;\n        }\n\n        sum = sum + (v / 10) + (v % 10);\n    }\n\n   return (10 - (sum % 10)) % 10;\n}\n\nunittest {\n    // Apple Incorporated\n    assertEquals(cusipCheckDigit(\"037833100\"), 0);\n\n    // Cisco Systems\n    assertEquals(cusipCheckDigit(\"17275R102\"), 2);\n\n    // Google Incorporated\n    assertEquals(cusipCheckDigit(\"38259P508\"), 8);\n\n    // Microsoft Corporation\n    assertEquals(cusipCheckDigit(\"594918104\"), 4);\n\n    // Oracle Corporation\n    assertEquals(cusipCheckDigit(\"68389X105\"), 5);\n}\n\nversion(unittest) {\n    void assertEquals(T)(T actual, T expected) {\n        import core.exception;\n        import std.conv;\n        if (actual != expected) {\n            throw new AssertError(\"Actual [\" ~ to!string(actual) ~ \"]; Expected [\" ~ to!string(expected) ~ \"]\");\n        }\n    }\n}\n\n/// Invoke with `cusip 037833100 17275R102 38259P508 594918104 68389X106 68389X105`\n\n\nOutput:\nCUSIP       Verdict\n037833100\u00a0: Valid\n17275R102\u00a0: Valid\n38259P508\u00a0: Valid\n594918104\u00a0: Valid\n68389X106\u00a0: Invalid\n68389X105\u00a0: Valid\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Haskell", "code": "\nimport Data.List(elemIndex)\n\ndata Result = Valid | BadCheck | TooLong | TooShort | InvalidContent deriving Show\n\n-- convert a list of Maybe to a Maybe list.\n-- result is Nothing if any of values from the original list are Nothing\nallMaybe :: [Maybe a] -> Maybe [a]\nallMaybe = sequence\n\ntoValue :: Char -> Maybe Int\ntoValue c = elemIndex c $ ['0'..'9'] ++ ['A'..'Z'] ++ \"*@#\" \n\n-- check a list of ints to see if they represent a valid CUSIP\nvalid :: [Int] -> Bool\nvalid ns0 = \n    let -- multiply values with even index by 2\n        ns1 = zipWith (\\i n -> (if odd i then n else 2*n)) [1..] $ take 8 ns0\n\n        -- apply div/mod formula from site and sum up results\n        sm = sum $ fmap (\\s -> ( s `div` 10 ) + s `mod` 10) ns1\n\n    in  -- apply mod/mod formula from site and compare to last value in list\n        ns0!!8 == (10 - (sm `mod` 10)) `mod` 10\n\n-- check a String to see if it represents a valid CUSIP\ncheckCUSIP :: String -> Result\ncheckCUSIP cs \n       | l < 9     = TooShort\n       | l > 9     = TooLong\n       | otherwise = case allMaybe (fmap toValue cs) of\n                         Nothing -> InvalidContent\n                         Just ns -> if valid ns then Valid else BadCheck\n    where l = length cs\n\ntestData =  \n    [ \"037833100\"\n    , \"17275R102\"\n    , \"38259P508\"\n    , \"594918104\"\n    , \"68389X106\"\n    , \"68389X105\"\n    ]\n\nmain = mapM_ putStrLn (fmap (\\s -> s ++ \": \" ++ show (checkCUSIP s)) testData)\n\n\nOutput:\n037833100: Valid\n17275R102: Valid\n38259P508: Valid\n594918104: Valid\n68389X106: BadCheck\n68389X105: Valid\n\n\nimport qualified Data.Map as M (Map, fromList, lookup)\nimport Data.Maybe (fromMaybe)\n\n-------------------------- CUSIP -------------------------\n\ncusipMap :: M.Map Char Int\ncusipMap =\n  M.fromList $\n    zip (['0' .. '9'] <> ['A' .. 'Z'] <> \"*@#\") [0 ..]\n\ncusipValid :: String -> Bool\ncusipValid s =\n  let ns = (fromMaybe [] . traverse (`M.lookup` cusipMap)) s\n   in (9 == length ns)\n        && let qrSum =\n                 sum $\n                   ( [quot, rem]\n                       <*> zipWith\n                         id\n                         (cycle [id, (* 2)])\n                         (take 8 ns)\n                   )\n                     <*> [10]\n            in last ns == rem (10 - rem qrSum 10) 10\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_\n    (print . ((,) <*> cusipValid))\n    [ \"037833100\",\n      \"17275R102\",\n      \"38259P508\",\n      \"594918104\",\n      \"68389X106\",\n      \"68389X105\"\n    ]\n\n\nOutput:\n(\"037833100\",True)\n(\"17275R102\",True)\n(\"38259P508\",True)\n(\"594918104\",True)\n(\"68389X106\",False)\n(\"68389X105\",True)\n", "explain": "Or, picking some other possibilities from Haskell's rich libraries:\n"}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "PowerShell", "code": "\nfunction Get-CheckDigitCUSIP {\n    [CmdletBinding()]\n    [OutputType([int])]\n    Param ( #  Validate input\n        [Parameter(Mandatory=$true, Position=0)]\n        [ValidatePattern( '^[A-Z0-9@#*]{8}\\d$' )] # @#*\n        [ValidateScript({$_.Length -eq 9})]\n        [string]\n        $cusip\n    )\n    $sum = 0\n    0..7 | ForEach { $c = $cusip[$_] ; $v = $null\n        if ([Char]::IsDigit($c)) { $v = [char]::GetNumericValue($c) }\n        if ([Char]::IsLetter($c)) { $v = [int][char]$c - [int][char]'A' +10 }\n        if ($c -eq '*') { $v = 36 }\n        if ($c -eq '@') { $v = 37 }\n        if ($c -eq '#') { $v = 38 }\n        if($_ % 2){ $v += $v }\n        $sum += [int][Math]::Floor($v / 10 ) + ($v % 10)\n    }\n    [int]$checkDigit_calculated = ( 10 - ($sum % 10) ) % 10\n    return( $checkDigit_calculated )\n}\n\nfunction Test-IsCUSIP {\n    [CmdletBinding()]\n    [OutputType([bool])]\n    Param (\n        [Parameter(Mandatory=$true, Position=0)]\n        [ValidatePattern( '^[A-Z0-9@#*]{8}\\d$' )]\n        [ValidateScript({$_.Length -eq 9})]\n        [string]\n        $cusip\n    )\n    [int]$checkDigit_told = $cusip[-1].ToString()\n    $checkDigit_calculated = Get-CheckDigitCUSIP $cusip\n    ($checkDigit_calculated -eq $checkDigit_told)\n}\n\n$data = @\"\n037833100`tApple Incorporated\n17275R102`tCisco Systems\n38259P508`tGoogle Incorporated\n594918104`tMicrosoft Corporation\n68389X106`tOracle Corporation   (incorrect)\n68389X105`tOracle Corporation\n\"@ -split \"`n\"\n$data |%{ Test-IsCUSIP $_.Split(\"`t\")[0] }\n\nOutput:\n\nTrue\nTrue\nTrue\nTrue\nFalse\nTrue\n\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "F#", "code": "\n// Validate CUSIP: Nigel Galloway. June 2nd., 2021\nlet fN=function n when n>47 && n<58->n-48 |n when n>64 && n<91->n-55 |42->36 |64->37 |_->38\nlet cD(n:string)=(10-(fst((n.[0..7])|>Seq.fold(fun(z,n)g->let g=(fN(int g))*(n+1) in (z+g/10+g%10,(n+1)%2))(0,0)))%10)%10=int(n.[8])-48\n[\"037833100\";\"17275R102\";\"38259P508\";\"594918104\";\"68389X103\";\"68389X105\"]|>List.iter(fun n->printfn \"CUSIP %s is %s\" n (if cD n then \"valid\" else \"invalid\"))\n\n\nOutput:\nCUSIP 037833100 is valid\nCUSIP 17275R102 is valid\nCUSIP 38259P508 is valid\nCUSIP 594918104 is valid\nCUSIP 68389X103 is invalid\nCUSIP 68389X105 is valid\nReal: 00:00:00.009\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Groovy", "code": "\nTranslation of: Java\nclass Cusip {\n    private static Boolean isCusip(String s) {\n        if (s.length() != 9) return false\n        int sum = 0\n        for (int i = 0; i <= 7; i++) {\n            char c = s.charAt(i)\n\n            int v\n            if (c >= ('0' as char) && c <= ('9' as char)) {\n                v = c - 48\n            } else if (c >= ('A' as char) && c <= ('Z' as char)) {\n                v = c - 55  // lower case letters apparently invalid\n            } else if (c == '*' as char) {\n                v = 36\n            } else if (c == '@' as char) {\n                v = 37\n            } else if (c == '#' as char) {\n                v = 38\n            } else {\n                return false\n            }\n            if (i % 2 == 1) v *= 2  // check if odd as using 0-based indexing\n            sum += v / 10 + v % 10\n        }\n        return s.charAt(8) - 48 == (10 - (sum % 10)) % 10\n    }\n\n    static void main(String[] args) {\n        List<String> candidates=new ArrayList<>()\n        candidates.add(\"037833100\")\n        candidates.add(\"17275R102\")\n        candidates.add(\"38259P508\")\n        candidates.add(\"594918104\")\n        candidates.add(\"68389X106\")\n        candidates.add(\"68389X105\")\n        for (String candidate : candidates) {\n            System.out.printf(\"%s -> %s%n\", candidate, isCusip(candidate) ? \"correct\" : \"incorrect\")\n        }\n    }\n}\n\n\nOutput:\n037833100 -> correct\n17275R102 -> correct\n38259P508 -> correct\n594918104 -> correct\n68389X106 -> incorrect\n68389X105 -> correct\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "Zig", "code": "\nconst std = @import(\"std\");\nconst print = std.debug.print;\n\npub fn CusipCheckDigit(cusip: *const [9:0]u8) bool {\n    var i: usize = 0;\n    var sum: i32 = 0;\n    while (i < 8) {\n        const c = cusip[i];\n        var v: i32 = undefined;\n        if (c <= '9' and c >= '0') {\n            v = c - 48;\n        }\n        else if (c <= 'Z' and c >= 'A') {\n            v = c - 55;\n        }\n        else if (c == '*') {\n            v = 36;\n        }\n        else if (c == '@') {\n            v = 37;\n        }\n        else if (c == '#') {\n            v = 38;\n        }\n        else {\n            return false;\n        }\n        if (i % 2 == 1) {\n            v *= 2;\n        }\n        sum = sum + @divFloor(v, 10) + @mod(v, 10);\n        i += 1;\n    }\n    return (cusip[8] - 48 == @mod((10 - @mod(sum, 10)), 10));\n}\n\npub fn main() void {\n    const cusips = [_]*const [9:0]u8 {\n        \"037833100\",\n        \"17275R102\",\n        \"38259P508\",\n        \"594918104\",\n        \"68389X106\",\n        \"68389X105\"\n    };\n    for (cusips) |cusip| {\n        print(\"{s} -> {}\\n\", .{cusip, CusipCheckDigit(cusip)});\n    }\n}\n\n", "explain": ""}, {"task_name": "CUSIP", "task_url": "https://rosettacode.org/wiki/CUSIP", "task_cat": "Checksums", "lang": "AWK", "code": "\n# syntax: GAWK -f CUSIP.AWK\nBEGIN {\n    n = split(\"037833100,17275R102,38259P508,594918104,68389X106,68389X105\",arr,\",\")\n    for (i=1; i<=n; i++) {\n      printf(\"%9s %s\\n\",arr[i],cusip(arr[i]))\n    }\n    exit(0)\n}\nfunction cusip(n,  c,i,sum,v,x) {\n# returns: 1=OK, 0=NG, -1=bad data\n    if (length(n) != 9) {\n      return(-1)\n    }\n    for (i=1; i<=8; i++) {\n      c = substr(n,i,1)\n      if (c ~ /[0-9]/) {\n        v = c\n      }\n      else if (c ~ /[A-Z]/) {\n        v = index(\"ABCDEFGHIJKLMNOPQRSTUVWXYZ\",c) + 9\n      }\n      else if (c == \"*\") {\n        v = 36\n      }\n      else if (c == \"@\") {\n        v = 37\n      }\n      else if (c == \"#\") {\n        v = 38\n      }\n      else {\n        return(-1)\n      }\n      if (i ~ /[02468]/) {\n        v *= 2\n      }\n      sum += int(v / 10) + (v % 10)\n    }\n    x = (10 - (sum % 10)) % 10\n    return(substr(n,9,1) == x ? 1 : 0)\n}\n\n\nOutput:\n037833100 1\n17275R102 1\n38259P508 1\n594918104 1\n68389X106 0\n68389X105 1\n\n", "explain": ""}]