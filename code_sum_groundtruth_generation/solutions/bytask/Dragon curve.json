[{"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Python", "code": "\nTranslation of: Logo\nLibrary: turtle\nfrom turtle import *\n\ndef dragon(step, length):\n    dcr(step, length)\n\ndef dcr(step, length):\n    step -= 1\n    length /= 1.41421\n    if step > 0:\n        right(45)\n        dcr(step, length)\n        left(90)\n        dcl(step, length)\n        right(45)\n    else:\n        right(45)\n        forward(length)\n        left(90)\n        forward(length)\n        right(45)\n\ndef dcl(step, length):\n    step -= 1\n    length /= 1.41421\n\n    if step > 0:\n        left(45)\n        dcr(step, length)\n        right(90)\n        dcl(step, length)\n        left(45)\n    else:\n        left(45)\n        forward(length)\n        right(90)\n        forward(length)\n        left(45)\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, zig=right, zag=left):\n    if level <= 0:\n        forward(size)\n        return\n\n    size /= 1.41421\n    zig(45)\n    dragon(level-1, size, right, left)\n    zag(90)\n    dragon(level-1, size, left, right)\n    zig(45)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n\nfrom turtle import right, left, forward, speed, exitonclick, hideturtle\n\ndef dragon(level=4, size=200, direction=45):\n    if level:\n        right(direction)\n        dragon(level-1, size/1.41421356237, 45)\n        left(direction * 2)\n        dragon(level-1, size/1.41421356237, -45)\n        right(direction)\n    else:\n        forward(size)\n\nspeed(0)\nhideturtle()\ndragon(6)\nexitonclick() # click to exit\n\n", "explain": "A more pythonic version:\nOther version:\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "C", "code": "\n\nC by IFS Drawing[edit]\n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <math.h>\n\n/* x, y: coordinates of current point; dx, dy: direction of movement.\n * Think turtle graphics.  They are divided by scale, so as to keep\n * very small coords/increments without losing precission. clen is\n * the path length travelled, which should equal to scale at the end\n * of the curve.\n */\nlong long x, y, dx, dy, scale, clen;\ntypedef struct { double r, g, b; } rgb;\nrgb ** pix;\n\n/* for every depth increase, rotate 45 degrees and scale up by sqrt(2)\n * Note how coords can still be represented by integers.\n */\nvoid sc_up()\n{\n\tlong long tmp = dx - dy; dy = dx + dy; dx = tmp;\n\tscale *= 2; x *= 2; y *= 2;\n}\n\n/* Hue changes from 0 to 360 degrees over entire length of path; Value\n * oscillates along the path to give some contrast between segments\n * close to each other spatially.  RGB derived from HSV gets *added*\n * to each pixel reached; they'll be dealt with later.\n */\nvoid h_rgb(long long x, long long y)\n{\n\trgb *p = &pix[y][x];\n\n#\tdefine SAT 1\n\tdouble h = 6.0 * clen / scale;\n\tdouble VAL = 1 - (cos(3.141592653579 * 64 * clen / scale) - 1) / 4;\n\tdouble c = SAT * VAL;\n\tdouble X = c * (1 - fabs(fmod(h, 2) - 1));\n\n\tswitch((int)h) {\n\tcase 0: p->r += c; p->g += X; return;\n\tcase 1:\tp->r += X; p->g += c; return;\n\tcase 2: p->g += c; p->b += X; return;\n\tcase 3: p->g += X; p->b += c; return;\n\tcase 4: p->r += X; p->b += c; return;\n\tdefault:\n\t\tp->r += c; p->b += X;\n\t}\n}\n\n/* string rewriting.  No need to keep the string itself, just execute\n * its instruction recursively.\n */\nvoid iter_string(const char * str, int d)\n{\n\tlong tmp;\n#\tdefine LEFT  tmp = -dy; dy = dx; dx = tmp\n#\tdefine RIGHT tmp = dy; dy = -dx; dx = tmp\n\twhile (*str != '\\0') {\n\t\tswitch(*(str++)) {\n\t\tcase 'X':\tif (d) iter_string(\"X+YF+\", d - 1); continue;\n\t\tcase 'Y':\tif (d) iter_string(\"-FX-Y\", d - 1); continue;\n\t\tcase '+':\tRIGHT; continue;\n\t\tcase '-':\tLEFT;  continue;\n\t\tcase 'F':\n                        /* draw: increment path length; add color; move. Here\n                         * is why the code does not allow user to choose arbitrary\n                         * image size: if it's not a power of two, aliasing will\n                         * occur and grid-like bright or dark lines will result\n                         * when normalized later.  It can be gotten rid of, but that\n                         * involves computing multiplicative order and would be a huge\n                         * bore.\n                         */\n\t\t\t\tclen ++;\n\t\t\t\th_rgb(x/scale, y/scale);\n\t\t\t\tx += dx; y += dy;\n\t\t\t\tcontinue;\n\t\t}\n\t}\n}\n\nvoid dragon(long leng, int depth)\n{\n\tlong i, d = leng / 3 + 1;\n\tlong h = leng + 3, w = leng + d * 3 / 2 + 2;\n\n\t/* allocate pixel buffer */\n\trgb *buf = malloc(sizeof(rgb) * w * h);\n\tpix = malloc(sizeof(rgb *) * h);\n\tfor (i = 0; i < h; i++)\n\t\tpix[i] = buf + w * i;\n\tmemset(buf, 0, sizeof(rgb) * w * h);\n\n        /* init coords; scale up to desired; exec string */\n\tx = y = d; dx = leng; dy = 0; scale = 1; clen = 0;\n\tfor (i = 0; i < depth; i++) sc_up();\n\titer_string(\"FX\", depth);\n\n\t/* write color PNM file */\n\tunsigned char *fpix = malloc(w * h * 3);\n\tdouble maxv = 0, *dbuf = (double*)buf;\n\n        /* find highest value among pixels; normalize image according\n         * to it.  Highest value would be at points most travelled, so\n         * this ends up giving curve edge a nice fade -- it's more apparaent\n         * if we increase iteration depth by one or two.\n         */\n\tfor (i = 3 * w * h - 1; i >= 0; i--)\n\t\tif (dbuf[i] > maxv) maxv = dbuf[i];\n\tfor (i = 3 * h * w - 1; i >= 0; i--)\n\t\tfpix[i] = 255 * dbuf[i] / maxv;\n\n\tprintf(\"P6\\n%ld %ld\\n255\\n\", w, h);\n\tfflush(stdout); /* printf and fwrite may treat buffer differently */\n\tfwrite(fpix, h * w * 3, 1, stdout);\n}\n\nint main(int c, char ** v)\n{\n\tint size, depth;\n\n\tdepth  = (c > 1) ? atoi(v[1]) : 10;\n\tsize = 1 << depth;\n\n\tfprintf(stderr, \"size: %d depth: %d\\n\", size, depth);\n\tdragon(size, depth * 2);\n\n\treturn 0;\n}\n\n", "explain": "See: Dragon curve/C\nC code that writes PNM of dragon curve.  run as a.out [depth] > dragon.pnm.  Sample image was with depth 9 (512 pixel length).\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "C++", "code": "\n\n#include <windows.h>\n#include <iostream>\n\n//-----------------------------------------------------------------------------------------\nusing namespace std;\n\n//-----------------------------------------------------------------------------------------\nconst int BMP_SIZE = 800, NORTH = 1, EAST = 2, SOUTH = 4, WEST = 8, LEN = 1;\n\n//-----------------------------------------------------------------------------------------\nclass myBitmap\n{\npublic:\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\n    ~myBitmap()\n    {\n\tDeleteObject( pen ); DeleteObject( brush );\n\tDeleteDC( hdc ); DeleteObject( bmp );\n    }\n\n    bool create( int w, int h )\n    {\n\tBITMAPINFO bi;\n\tZeroMemory( &bi, sizeof( bi ) );\n\tbi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\n\tbi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\n\tbi.bmiHeader.biCompression = BI_RGB;\n\tbi.bmiHeader.biPlanes      = 1;\n\tbi.bmiHeader.biWidth       =  w;\n\tbi.bmiHeader.biHeight      = -h;\n\n\tHDC dc = GetDC( GetConsoleWindow() );\n\tbmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n\tif( !bmp ) return false;\n\n\thdc = CreateCompatibleDC( dc );\n\tSelectObject( hdc, bmp );\n\tReleaseDC( GetConsoleWindow(), dc );\n\n\twidth = w; height = h;\n\treturn true;\n    }\n\n    void clear( BYTE clr = 0 )\n    {\n\tmemset( pBits, clr, width * height * sizeof( DWORD ) );\n    }\n\n    void setBrushColor( DWORD bClr )\n    {\n\tif( brush ) DeleteObject( brush );\n\tbrush = CreateSolidBrush( bClr );\n\tSelectObject( hdc, brush );\n    }\n\n    void setPenColor( DWORD c )\n    {\n\tclr = c; createPen();\n    }\n\n    void setPenWidth( int w )\n    {\n\twid = w; createPen();\n    }\n\n    void saveBitmap( string path )\n     {\n\tBITMAPFILEHEADER fileheader;\n\tBITMAPINFO       infoheader;\n\tBITMAP           bitmap;\n\tDWORD            wb;\n\n\tGetObject( bmp, sizeof( bitmap ), &bitmap );\n\tDWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n\n\tZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n\tZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n\tZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n\n\tinfoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n\tinfoheader.bmiHeader.biCompression = BI_RGB;\n\tinfoheader.bmiHeader.biPlanes = 1;\n\tinfoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n\tinfoheader.bmiHeader.biHeight = bitmap.bmHeight;\n\tinfoheader.bmiHeader.biWidth = bitmap.bmWidth;\n\tinfoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n\n\tfileheader.bfType    = 0x4D42;\n\tfileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n\tfileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n\n\tGetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n\n\tHANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\tWriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n\tWriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n\tWriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n\tCloseHandle( file );\n\n\tdelete [] dwpBits;\n    }\n\n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\n\nprivate:\n    void createPen()\n    {\n\tif( pen ) DeleteObject( pen );\n\tpen = CreatePen( PS_SOLID, wid, clr );\n\tSelectObject( hdc, pen );\n    }\n\n    HBITMAP bmp;\n    HDC     hdc;\n    HPEN    pen;\n    HBRUSH  brush;\n    void    *pBits;\n    int     width, height, wid;\n    DWORD   clr;\n};\n//-----------------------------------------------------------------------------------------\nclass dragonC\n{\npublic:\n    dragonC() { bmp.create( BMP_SIZE, BMP_SIZE ); dir = WEST; }\n    void draw( int iterations ) { generate( iterations ); draw(); }\n\nprivate:\n    void generate( int it )\n    {\n\tgenerator.push_back( 1 );\n\tstring temp;\n\n\tfor( int y = 0; y < it - 1; y++ )\n\t{\n\t    temp = generator; temp.push_back( 1 );\n\t    for( string::reverse_iterator x = generator.rbegin(); x != generator.rend(); x++ )\n\t\ttemp.push_back( !( *x ) );\n\n\t    generator = temp;\n\t}\n    }\n\n    void draw()\n    {\n\tHDC dc = bmp.getDC();\n\tunsigned int clr[] = { 0xff, 0xff00, 0xff0000, 0x00ffff };\n\tint mov[] = { 0, 0, 1, -1, 1, -1, 1, 0 }; int i = 0;\n\n\tfor( int t = 0; t < 4; t++ )\n\t{\n\t    int a = BMP_SIZE / 2, b = a; a += mov[i++]; b += mov[i++];\n\t    MoveToEx( dc, a, b, NULL );\n\n\t    bmp.setPenColor( clr[t] );\n\t    for( string::iterator x = generator.begin(); x < generator.end(); x++ )\n\t    {\n\t\tswitch( dir )\n\t\t{\n\t\t    case NORTH:\n\t\t\tif( *x ) { a += LEN; dir = EAST; }\n\t\t\telse { a -= LEN; dir = WEST; }\t\t\t\t\n\t\t    break;\n\t\t    case EAST:\n\t\t\tif( *x ) { b += LEN; dir = SOUTH; }\n\t\t\telse { b -= LEN; dir = NORTH; }\n\t\t    break;\n\t\t    case SOUTH:\n\t\t\tif( *x ) { a -= LEN; dir = WEST; }\n\t\t\telse { a += LEN; dir = EAST; }\n\t\t    break;\n\t\t    case WEST:\n\t\t\tif( *x ) { b -= LEN; dir = NORTH; }\n\t\t\telse { b += LEN; dir = SOUTH; }\n\t\t}\n\t        LineTo( dc, a, b );\n\t    }\n\t}\n\t//\u00a0!!! change this path\u00a0!!!\n\tbmp.saveBitmap( \"f:/rc/dragonCpp.bmp\" );\n    }\n\t\n    int dir;\n    myBitmap bmp;\n    string generator;\n};\n//-----------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    dragonC d; d.draw( 17 );\n    return system( \"pause\" );\n}\n//-----------------------------------------------------------------------------------------\n\n", "explain": "\nThis program will generate the curve and save it to your hard drive.\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Java", "code": "\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.util.*;\nimport javax.swing.JFrame;\n\npublic class DragonCurve extends JFrame {\n\n    private List<Integer> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter) {\n        super(\"Dragon Curve\");\n        setBounds(100, 100, 800, 600);\n        setDefaultCloseOperation(EXIT_ON_CLOSE);\n        turns = getSequence(iter);\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.pow(2, iter / 2.);\n    }\n\n    public List<Integer> getSequence(int iterations) {\n        List<Integer> turnSequence = new ArrayList<Integer>();\n        for (int i = 0; i < iterations; i++) {\n            List<Integer> copy = new ArrayList<Integer>(turnSequence);\n            Collections.reverse(copy);\n            turnSequence.add(1);\n            for (Integer turn : copy) {\n                turnSequence.add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    @Override\n    public void paint(Graphics g) {\n        g.setColor(Color.BLACK);\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int) (Math.cos(angle) * side);\n        int y2 = y1 + (int) (Math.sin(angle) * side);\n        g.drawLine(x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        for (Integer turn : turns) {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int) (Math.cos(angle) * side);\n            y2 = y1 + (int) (Math.sin(angle) * side);\n            g.drawLine(x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    public static void main(String[] args) {\n        new DragonCurve(14).setVisible(true);\n    }\n}\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "C#", "code": "\nTranslation of: Java\nusing System;\nusing System.Collections.Generic;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class DragonCurve : Form\n{\n    private List<int> turns;\n    private double startingAngle, side;\n\n    public DragonCurve(int iter)\n    {\n        Size = new Size(800, 600);\n        StartPosition = FormStartPosition.CenterScreen;\n        DoubleBuffered = true;\n        BackColor = Color.White;\n\n        startingAngle = -iter * (Math.PI / 4);\n        side = 400 / Math.Pow(2, iter / 2.0);\n\n        turns = getSequence(iter);\n    }\n\n    private List<int> getSequence(int iter)\n    {\n        var turnSequence = new List<int>();\n        for (int i = 0; i < iter; i++)\n        {\n            var copy = new List<int>(turnSequence);\n            copy.Reverse();\n            turnSequence.Add(1);\n            foreach (int turn in copy)\n            {\n                turnSequence.Add(-turn);\n            }\n        }\n        return turnSequence;\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        double angle = startingAngle;\n        int x1 = 230, y1 = 350;\n        int x2 = x1 + (int)(Math.Cos(angle) * side);\n        int y2 = y1 + (int)(Math.Sin(angle) * side);\n        e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n        x1 = x2;\n        y1 = y2;\n        foreach (int turn in turns)\n        {\n            angle += turn * (Math.PI / 2);\n            x2 = x1 + (int)(Math.Cos(angle) * side);\n            y2 = y1 + (int)(Math.Sin(angle) * side);\n            e.Graphics.DrawLine(Pens.Black, x1, y1, x2, y2);\n            x1 = x2;\n            y1 = y2;\n        }\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new DragonCurve(14));\n    }\n}\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "JavaScript", "code": "\nES5 plus HTML DOM[edit]\nVersion #1.[edit]\nWorks with: Chrome 8.0\n\nvar DRAGON = (function () {\n   // MATRIX MATH\n   // -----------\n\n   var matrix = {\n      mult: function ( m, v ) {\n         return [ m[0][0] * v[0] + m[0][1] * v[1],\n                  m[1][0] * v[0] + m[1][1] * v[1] ];\n      },\n\n      minus: function ( a, b ) {\n         return [ a[0]-b[0], a[1]-b[1] ];\n      },\n\n      plus: function ( a, b ) {\n         return [ a[0]+b[0], a[1]+b[1] ];\n      }\n   };\n\n\n   // SVG STUFF\n   // ---------\n\n   // Turn a pair of points into an SVG path like \"M1 1L2 2\".\n   var toSVGpath = function (a, b) {  // type system fail\n      return \"M\" + a[0] + \" \" + a[1] + \"L\" + b[0] + \" \" + b[1];\n   };\n\n\n   // DRAGON MAKING\n   // -------------\n\n   // Make a dragon with a better fractal algorithm\n   var fractalMakeDragon = function (svgid, ptA, ptC, state, lr, interval) {\n\n      // make a new <path>\n      var path = document.createElementNS('http://www.w3.org/2000/svg', 'path');\n      path.setAttribute( \"class\",  \"dragon\"); \n      path.setAttribute( \"d\", toSVGpath(ptA, ptC) );\n\n      // append the new path to the existing <svg>\n      var svg = document.getElementById(svgid); // call could be eliminated\n      svg.appendChild(path);\n\n      // if we have more iterations to go...\n      if (state > 1) {\n\n         // make a new point, either to the left or right\n         var growNewPoint = function (ptA, ptC, lr) {\n            var left  = [[ 1/2,-1/2 ], \n                         [ 1/2, 1/2 ]]; \n\n            var right = [[ 1/2, 1/2 ],\n                         [-1/2, 1/2 ]];\n\n            return matrix.plus(ptA, matrix.mult( lr ? left : right, \n                                                 matrix.minus(ptC, ptA) ));\n         }; \n\n         var ptB = growNewPoint(ptA, ptC, lr, state);\n\n         // then recurse using each new line, one left, one right\n         var recurse = function () {\n            // when recursing deeper, delete this svg path\n            svg.removeChild(path);\n\n            // then invoke again for new pair, decrementing the state\n            fractalMakeDragon(svgid, ptB, ptA, state-1, lr, interval);\n            fractalMakeDragon(svgid, ptB, ptC, state-1, lr, interval);\n         };\n\n         window.setTimeout(recurse, interval);\n      }\n   };\n\n\n   // Export these functions\n   // ----------------------\n   return {\n      fractal: fractalMakeDragon\n\n      // ARGUMENTS\n      // ---------\n      //    svgid    id of <svg> element\n      //    ptA      first point [x,y] (from top left)\n      //    ptC      second point [x,y]\n      //    state    number indicating how many steps to recurse\n      //    lr       true/false to make new point on left or right\n\n      // CONFIG\n      // ------\n      // CSS rules should be made for the following\n      //    svg#fractal\n      //    svg path.dragon\n   };\n\n}());\n\n\n...\n<script src='./dragon.js'></script>\n...\n<div>\n   <svg xmlns='http://www.w3.org/2000/svg' id='fractal'></svg> \n</div>\n<script>\n   DRAGON.fractal('fractal', [100,300], [500,300], 15, false, 700);\n</script>\n...\n\nVersion #2.[edit]\nWorks with: Chrome\nFile:DC11.pngOutput DC11.png\nFile:DC19.pngOutput DC19.png\nFile:DC25.pngOutput DC25.png\n<!-- DragonCurve.html -->\n<html>\n<head>\n<script type='text/javascript'>\nfunction pDragon(cId) {\n  // Plotting Dragon curves. 2/25/17 aev\n  var n=document.getElementById('ord').value;\n  var sc=document.getElementById('sci').value;\n  var hsh=document.getElementById('hshi').value;\n  var vsh=document.getElementById('vshi').value;\n  var clr=document.getElementById('cli').value;\n  var c=c1=c2=c2x=c2y=x=y=0, d=1, n=1<<n;\n  var cvs=document.getElementById(cId);\n  var ctx=cvs.getContext(\"2d\");\n  hsh=Number(hsh); vsh=Number(vsh);\n  x=y=cvs.width/2;\n  // Cleaning canvas, init plotting\n  ctx.fillStyle=\"white\"; ctx.fillRect(0,0,cvs.width,cvs.height);\n  ctx.beginPath();\n  for(i=0; i<=n;) {\n    ctx.lineTo((x+hsh)*sc,(y+vsh)*sc);\n    c1=c&1; c2=c&2;\n    c2x=1*d; if(c2>0) {c2x=(-1)*d}; c2y=(-1)*c2x;\n    if(c1>0) {y+=c2y} else {x+=c2x}\n    i++; c+=i/(i&-i);\n  }\n  ctx.strokeStyle = clr;  ctx.stroke();\n}\n</script>\n</head>\n<body>\n<p><b>Please input order, scale, x-shift, y-shift, color:</></p>\n<input id=ord value=11 type=\"number\" min=\"7\" max=\"25\" size=\"2\">\n<input id=sci value=7.0 type=\"number\" min=\"0.001\" max=\"10\" size=\"5\">\n<input id=hshi value=-265 type=\"number\" min=\"-50000\" max=\"50000\" size=\"6\">\n<input id=vshi value=-260 type=\"number\" min=\"-50000\" max=\"50000\" size=\"6\">\n<input id=cli value=\"red\" type=\"text\" size=\"14\">\n<button onclick=\"pDragon('canvId')\">Plot it!</button>\n<h3>Dragon curve</h3>\n<canvas id=\"canvId\" width=640 height=640 style=\"border: 2px inset;\"></canvas>\n</body>\n</html>\n\n\nInput parameters:\n\nord scale x-shift y-shift color   [File name to save]\n-------------------------------------------\n11  7.    -265   -260   red       DC11.png\n15  2.    -205   -230   brown     DC15.png\n17  1.    -135    70    green     DC17.png\n19  0.6    380    440   navy      DC19.png\n21  0.22   1600   800   blue      DC21.png\n23  0.15   1100   800   violet    DC23.png\n25  0.07   2100   5400  darkgreen DC25.png\n===========================================\n\n\nOutput:\nPage with different plotted Dragon curves. Right-clicking on the canvas you can save each of them\nas a png-file. \nES6[edit]\n\n(() => {\n    'use strict';\n\n    // ------------------ DRAGON CURVE -------------------\n\n    // dragonCurve\u00a0:: [[Int]] -> [[Int]]\n    const dragonCurve = xs => {\n        const\n            pivot = op => map(\n                zipWith(op)(last(xs))\n            ),\n            r90 = [\n                [0, 1],\n                [-1, 0]\n            ];\n        return compose(\n            append(xs),\n            pivot(add),\n            flip(matrixMultiply)(r90),\n            pivot(subtract),\n            reverse,\n            init\n        )(xs);\n    };\n\n\n    // ---------------------- TEST -----------------------\n    // main\u00a0:: IO ()\n    const main = () =>\n        // SVG of 12th iteration.\n        console.log(\n            svgFromPointLists(512)(512)(\n                index(iterate(dragonCurve)([\n                    [0, 0],\n                    [0, -1]\n                ]))(12)\n            )\n        );\n\n\n    // ----------------------- SVG -----------------------\n\n    // svgFromPointLists\u00a0:: Int -> Int ->\n    // [[(Int, Int)]] -> String\n    const svgFromPointLists = cw => ch =>\n        xyss => {\n            const\n                polyline = xs =>\n                `<polyline points=\"${unwords(concat(xs).map(showJSON))}\"/>`,\n                [x, y, mx, my] = ap([minimum, maximum])(\n                    Array.from(unzip(concat(xyss)))\n                ),\n                [wd, hd] = map(x => Math.floor(x / 10))([\n                    mx - x, my - y\n                ]);\n            return unlines([\n                '<?xml version=\"1.0\" encoding=\"UTF-8\"?>',\n                unwords([\n                    '<svg',\n                    `width=\"${cw}\" height=\"${ch}\"`,\n                    `viewBox=\"${x - wd} ${y - hd} ${12 * wd} ${12 * hd}\"`,\n                    'xmlns=\"http://www.w3.org/2000/svg\">'\n                ]),\n                '<g stroke-width=\"0.2\" stroke=\"red\" fill=\"none\">',\n                unlines(map(polyline)(xyss)),\n                '</g>',\n                '</svg>'\n            ]);\n        };\n\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // Just\u00a0:: a -> Maybe a\n    const Just = x => ({\n        type: 'Maybe',\n        Nothing: false,\n        Just: x\n    });\n\n\n    // Nothing\u00a0:: Maybe a\n    const Nothing = () => ({\n        type: 'Maybe',\n        Nothing: true,\n    });\n\n\n    // Tuple (,)\u00a0:: a -> b -> (a, b)\n    const Tuple = a =>\n        b => ({\n            type: 'Tuple',\n            '0': a,\n            '1': b,\n            length: 2\n        });\n\n\n    // add (+)\u00a0:: Num a => a -> a -> a\n    const add = a =>\n        // Curried addition.\n        b => a + b;\n\n\n    // ap (<*>)\u00a0:: [(a -> b)] -> [a] -> [b]\n    const ap = fs =>\n        // The sequential application of each of a list\n        // of functions to each of a list of values.\n        xs => fs.flatMap(\n            f => xs.map(f)\n        );\n\n    // append (++)\u00a0:: [a] -> [a] -> [a]\n    // append (++)\u00a0:: String -> String -> String\n    const append = xs =>\n        // A list or string composed by\n        // the concatenation of two others.\n        ys => xs.concat(ys);\n\n\n    // compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\n    const compose = (...fs) =>\n        fs.reduce(\n            (f, g) => x => f(g(x)),\n            x => x\n        );\n\n\n    // concat\u00a0:: [[a]] -> [a]\n    const concat = xs => [].concat(...xs);\n\n\n    // dotProduct\u00a0:: Num a => [[a]] -> [[a]] -> [[a]]\n    const dotProduct = xs =>\n        compose(sum, zipWith(mul)(xs));\n\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = m =>\n        n => Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        x => y => f(y)(x);\n\n\n    // index (!!)\u00a0:: [a] -> Int -> Maybe a\n    // index (!!)\u00a0:: Generator (a) -> Int -> Maybe a\n    // index (!!)\u00a0:: String -> Int -> Maybe Char\n    const index = xs =>\n        i => (\n            drop(i)(xs),\n            take(1)(xs)\n        );\n\n\n    // drop\u00a0:: Int -> [a] -> [a]\n    // drop\u00a0:: Int -> Generator [a] -> Generator [a]\n    // drop\u00a0:: Int -> String -> String\n    const drop = n =>\n        xs => Infinity > length(xs) ? (\n            xs.slice(n)\n        ) : (take(n)(xs), xs);\n\n\n    // init\u00a0:: [a] -> [a]\n    const init = xs =>\n        // All elements of a list except the last.\n        0 < xs.length ? (\n            xs.slice(0, -1)\n        ) : undefined;\n\n\n    // iterate\u00a0:: (a -> a) -> a -> Gen [a]\n    const iterate = f =>\n        function* (x) {\n            let v = x;\n            while (true) {\n                yield(v);\n                v = f(v);\n            }\n        };\n\n\n    // last\u00a0:: [a] -> a\n    const last = xs =>\n        // The last item of a list.\n        0 < xs.length ? xs.slice(-1)[0] : undefined;\n\n\n    // length\u00a0:: [a] -> Int\n    const length = xs =>\n        // Returns Infinity over objects without finite\n        // length. This enables zip and zipWith to choose\n        // the shorter argument when one is non-finite,\n        // like cycle, repeat etc\n        (Array.isArray(xs) || 'string' === typeof xs) ? (\n            xs.length\n        ) : Infinity;\n\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => xs.map(f);\n\n\n    // matrixMultiply\u00a0:: Num a => [[a]] -> [[a]] -> [[a]]\n    const matrixMultiply = a =>\n        b => {\n            const cols = transpose(b);\n            return map(\n                compose(\n                    flip(map)(cols),\n                    dotProduct\n                )\n            )(a);\n        };\n\n    // minimum\u00a0:: Ord a => [a] -> a\n    const minimum = xs =>\n        0 < xs.length ? (\n            xs.slice(1)\n            .reduce((a, x) => x < a ? x : a, xs[0])\n        ) : undefined;\n\n\n    // maximum\u00a0:: Ord a => [a] -> a\n    const maximum = xs =>\n        // The largest value in a non-empty list.\n        0 < xs.length ? (\n            xs.slice(1).reduce(\n                (a, x) => x > a ? (\n                    x\n                ) : a, xs[0]\n            )\n        ) : undefined;\n\n\n    // mul (*)\u00a0:: Num a => a -> a -> a\n    const mul = a =>\n        b => a * b;\n\n\n    // reverse\u00a0:: [a] -> [a]\n    const reverse = xs =>\n        xs.slice(0).reverse();\n\n\n    // showJSON\u00a0:: a -> String\n    const showJSON = x =>\n        // Indented JSON representation of the value x.\n        JSON.stringify(x, null, 2);\n\n\n    // subtract\u00a0:: Num -> Num -> Num\n    const subtract = x =>\n        y => y - x;\n\n\n    // sum\u00a0:: [Num] -> Num\n    const sum = xs =>\n        // The numeric sum of all values in xs.\n        xs.reduce((a, x) => a + x, 0);\n\n\n    // take\u00a0:: Int -> [a] -> [a]\n    // take\u00a0:: Int -> String -> String\n    const take = n =>\n        // The first n elements of a list,\n        // string of characters, or stream.\n        xs => 'GeneratorFunction' !== xs\n        .constructor.constructor.name ? (\n            xs.slice(0, n)\n        ) : [].concat.apply([], Array.from({\n            length: n\n        }, () => {\n            const x = xs.next();\n            return x.done ? [] : [x.value];\n        }));\n\n\n    // transpose\u00a0:: [[a]] -> [[a]]\n    const transpose = rows =>\n        // The columns of the input transposed\n        // into new rows.\n        // Simpler version of transpose, assuming input\n        // rows of even length.\n        0 < rows.length ? rows[0].map(\n            (x, i) => rows.flatMap(\n                x => x[i]\n            )\n        ) : [];\n\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join('\\n');\n\n\n    // until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\n    const until = p => f => x => {\n        let v = x;\n        while (!p(v)) v = f(v);\n        return v;\n    };\n\n\n    // unwords\u00a0:: [String] -> String\n    const unwords = xs =>\n        // A space-separated string derived\n        // from a list of words.\n        xs.join(' ');\n\n\n    // unzip\u00a0:: [(a,b)] -> ([a],[b])\n    const unzip = xys =>\n        xys.reduce(\n            (ab, xy) => Tuple(ab[0].concat(xy[0]))(\n                ab[1].concat(xy[1])\n            ),\n            Tuple([])([])\n        );\n\n\n    // zipWith\u00a0:: (a -> b -> c) -> [a] -> [b] -> [c]\n    const zipWith = f =>\n        // A list constructed by zipping with a\n        // custom function, rather than with the\n        // default tuple constructor.\n        xs => ys => {\n            const\n                lng = Math.min(length(xs), length(ys)),\n                vs = take(lng)(ys);\n            return take(lng)(xs)\n                .map((x, i) => f(x)(vs[i]));\n        };\n\n    // MAIN ---\n    return main();\n})();\n\n", "explain": "I'm sure this can be simplified further, but I have this working here!\nThough there is an impressive SVG example further below, this uses JavaScript to recurse through the expansion and simply displays each line with SVG.  It is invoked as a method DRAGON.fractal(...) as described.\nMy current demo page includes the following to invoke this: \nTesting cases:\nDeclarative definition of an SVG file, in terms of functional primitives.\n(To test, generate and save SVG as file, and open in a browser or graphics application).\n(Pure JS, without HTML or DOM)\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Go", "code": "\nOutput png\n\npackage main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/draw\"\n    \"image/png\"\n    \"math\"\n    \"os\"\n)\n\n// separation of the the two endpoints\n// make this a power of 2 for prettiest output\nconst sep = 512\n// depth of recursion.  adjust as desired for different visual effects.\nconst depth = 14\n\nvar s = math.Sqrt2 / 2\nvar sin = []float64{0, s, 1, s, 0, -s, -1, -s}\nvar cos = []float64{1, s, 0, -s, -1, -s, 0, s}\nvar p = color.NRGBA{64, 192, 96, 255}\nvar b *image.NRGBA\n\nfunc main() {\n    width := sep * 11 / 6\n    height := sep * 4 / 3\n    bounds := image.Rect(0, 0, width, height)\n    b = image.NewNRGBA(bounds)\n    draw.Draw(b, bounds, image.NewUniform(color.White), image.ZP, draw.Src)\n    dragon(14, 0, 1, sep, sep/2, sep*5/6)\n    f, err := os.Create(\"dragon.png\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    if err = png.Encode(f, b); err != nil {\n        fmt.Println(err)\n    }\n    if err = f.Close(); err != nil {\n        fmt.Println(err)\n    }\n}\n\nfunc dragon(n, a, t int, d, x, y float64) {\n    if n <= 1 {\n        // Go packages used here do not have line drawing functions\n        // so we implement a very simple line drawing algorithm here.\n        // We take advantage of knowledge that we are always drawing\n        // 45 degree diagonal lines.\n        x1 := int(x + .5)\n        y1 := int(y + .5)\n        x2 := int(x + d*cos[a] + .5)\n        y2 := int(y + d*sin[a] + .5)\n        xInc := 1\n        if x1 > x2 {\n            xInc = -1\n        }\n        yInc := 1\n        if y1 > y2 {\n            yInc = -1\n        }\n        for x, y := x1, y1; ; x, y = x+xInc, y+yInc {\n            b.Set(x, y, p)\n            if x == x2 {\n                break\n            }\n        }\n        return\n    }\n    d *= s\n    a1 := (a - t) & 7\n    a2 := (a + t) & 7\n    dragon(n-1, a1, 1, d, x, y)\n    dragon(n-1, a2, -1, d, x+d*cos[a1], y+d*sin[a1])\n}\n\n\npackage main\n\n// Files required to build supporting package raster are found in:\n// * Bitmap\n// * Write a PPM file\n\nimport (\n    \"math\"\n    \"raster\"\n)\n\n// separation of the the two endpoints\n// make this a power of 2 for prettiest output\nconst sep = 512\n// depth of recursion.  adjust as desired for different visual effects.\nconst depth = 14\n\nvar s = math.Sqrt2 / 2\nvar sin = []float64{0, s, 1, s, 0, -s, -1, -s}\nvar cos = []float64{1, s, 0, -s, -1, -s, 0, s}\nvar p = raster.Pixel{64, 192, 96}\nvar b *raster.Bitmap\n\nfunc main() {\n    width := sep * 11 / 6\n    height := sep * 4 / 3\n    b = raster.NewBitmap(width, height)\n    b.Fill(raster.Pixel{255, 255, 255})\n    dragon(14, 0, 1, sep, sep/2, sep*5/6)\n    b.WritePpmFile(\"dragon.ppm\")\n}\n\nfunc dragon(n, a, t int, d, x, y float64) {\n    if n <= 1 {\n        b.Line(int(x+.5), int(y+.5), int(x+d*cos[a]+.5), int(y+d*sin[a]+.5), p)\n        return\n    }\n    d *= s\n    a1 := (a - t) & 7\n    a2 := (a + t) & 7\n    dragon(n-1, a1, 1, d, x, y)\n    dragon(n-1, a2, -1, d, x+d*cos[a1], y+d*sin[a1])\n}\n\n", "explain": "Version using standard image libriary is an adaptation of the version below using the Bitmap task.  The only major change is that line drawing code was needed.  See comments in code.\nOriginal version written to Bitmap task:\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "X86_Assembly", "code": "\n\n\n        .model  tiny\n        .code\n        .486\n        org     100h            ;assume ax=0, bx=0, sp=-2\nstart:  mov     al, 13h         ;(ah=0) set 320x200 video graphics mode\n        int     10h\n        push    0A000h\n        pop     es\n        mov     si, 8000h       ;color\n\n        mov     cx, 75*256+100  ;coordinates of initial horizontal line segment\n        mov     dx, 75*256+164  ;use power of 2 for length\n\n        call    dragon\n        mov     ah, 0           ;wait for keystroke\n        int     16h\n        mov     ax, 0003h       ;restore normal text mode\n        int     10h\n        ret\n\ndragon: cmp     sp, -100        ;at maximum recursion depth?\n        jne     drag30          ;skip if not\n        mov     bl, dh          ;draw at max depth to get solid image\n        imul    di, bx, 320     ;(bh=0) plot point at X=dl, Y=dh\n        mov     bl, dl\n        add     di, bx\n        mov     ax, si          ;color\n        shr     ax, 13\n        or      al, 8           ;use bright colors 8..F\n        stosb                   ;es:[di++]:= al\n        inc     si\n        ret\ndrag30:\n        push    cx              ;preserve points P and Q\n        push    dx\n\n        xchg    ax, dx          ;DX:= Q(0)-P(0);\n        sub     al, cl\n        sub     ah, ch          ;DY:= Q(1)-P(1);\n\n        mov     dx, ax          ;new point\n        sub     dl, ah          ;R(0):= P(0) + (DX-DY)/2\n        jns     drag40\n         inc    dl\ndrag40: sar     dl, 1           ;dl:= (al-ah)/2 + cl\n        add     dl, cl\n\n        add     dh, al          ;R(1):= P(1) + (DX+DY)/2;\n        jns     drag45\n         inc    dh\ndrag45: sar     dh, 1           ;dh:= (al+ah)/2 + ch\n        add     dh, ch\n\n        call    dragon          ;Dragon(P, R);\n        pop     cx              ;get Q\n        push    cx\n        call    dragon          ;Dragon(Q, R);\n\n        pop     dx              ;restore points\n        pop     cx\n        ret\n        end     start\n\n", "explain": "Translation of XPL0. Assemble with tasm, tlink /t\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Delphi", "code": "\nLibrary:  Winapi.Windows\nLibrary:  System.SysUtils\nLibrary:  System.Classes\nLibrary:  Vcl.Graphics\nTranslation of: Go\nprogram Dragon_curve;\n\n{$APPTYPE CONSOLE}\n\nuses\n  Winapi.Windows,\n  System.SysUtils,\n  System.Classes,\n  Vcl.Graphics;\n\ntype\n  TDragon = class\n  private\n    p: TColor;\n    _sin: TArray<double>;\n    _cos: TArray<double>;\n    s: double;\n    b: TBitmap;\n    FAsBitmap: TBitmap;\n    const\n      sep = 512;\n      depth = 14;\n    procedure Dragon(n, a, t: Integer; d, x, y: Double; var b: TBitmap);\n  public\n    constructor Create;\n    destructor Destroy; override;\n    property AsBitmap: TBitmap read b;\n  end;\n\n{ TDragon }\n\nprocedure TDragon.Dragon(n, a, t: Integer; d, x, y: Double; var b: TBitmap);\nbegin\n  if n <= 1 then\n  begin\n    with b.Canvas do\n    begin\n      Pen.Color := p;\n      MoveTo(Trunc(x + 0.5), Trunc(y + 0.5));\n      LineTo(Trunc(x + d * _cos[a] + 0.5), Trunc(y + d * _sin[a] + 0.5));\n      exit;\n    end;\n  end;\n\n  d := d * s;\n  var a1 := (a - t) and 7;\n  var a2 := (a + t) and 7;\n\n  dragon(n - 1, a1, 1, d, x, y, b);\n  dragon(n - 1, a2, -1, d, x + d * _cos[a1], y + d * _sin[a1], b);\nend;\n\nconstructor TDragon.Create;\nbegin\n  s := sqrt(2) / 2;\n  _sin := [0, s, 1, s, 0, -s, -1, -s];\n  _cos := [1.0, s, 0.0, -s, -1.0, -s, 0.0, s];\n  p := Rgb(64, 192, 96);\n  b := TBitmap.create;\n\n  var width := Trunc(sep * 11 / 6);\n  var height := Trunc(sep * 4 / 3);\n  b.SetSize(width, height);\n  with b.Canvas do\n  begin\n    Brush.Color := clWhite;\n    Pen.Width := 3;\n    FillRect(Rect(0, 0, width, height));\n  end;\n  dragon(14, 0, 1, sep, sep / 2, sep * 5 / 6, b);\nend;\n\ndestructor TDragon.Destroy;\nbegin\n  b.Free;\n  inherited;\nend;\n\nvar\n  Dragon: TDragon;\n\nbegin\n  Dragon := TDragon.Create;\n  Dragon.AsBitmap.SaveToFile('dragon.bmp');\n  Dragon.Free;\nend.\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Ruby", "code": "\nLibrary: Shoes\nPoint = Struct.new(:x, :y)\nLine = Struct.new(:start, :stop)\n\nShoes.app(:width => 800, :height => 600, :resizable => false) do\n\n  def split_segments(n)\n    dir = 1\n    @segments = @segments.inject([]) do |new, l|\n      a, b, c, d = l.start.x, l.start.y, l.stop.x, l.stop.y\n\n      mid_x = a + (c-a)/2.0 - (d-b)/2.0*dir\n      mid_y = b + (d-b)/2.0 + (c-a)/2.0*dir\n      mid_p = Point.new(mid_x, mid_y)\n\n      dir *= -1\n      new << Line.new(l.start, mid_p)\n      new << Line.new(mid_p, l.stop)\n    end\n  end\n\n  @segments = [Line.new(Point.new(200,200), Point.new(600,200))]\n  15.times do |n|\n    info \"calculating frame #{n}\"\n    split_segments(n)\n  end\n\n  stack do\n    @segments.each do |l|\n      line l.start.x, l.start.y, l.stop.x, l.stop.y\n    end\n  end\nend\n\nLibrary: RubyGems\nLibrary: JRubyArt\nLEN = 3\nGEN = 14\nattr_reader :angle\n\ndef setup\n  sketch_title 'Heighway Dragon'\n  background(0, 0, 255)\n  translate(170, 170)\n  stroke(255)\n  @angle = 90.radians\n  turn_left(GEN)\nend\n\ndef draw_line\n  line(0, 0, 0, -LEN)\n  translate(0, -LEN)\nend\n\ndef turn_right(gen)\n  return draw_line if gen.zero?\n\n  turn_left(gen - 1)\n  rotate(angle)\n  turn_right(gen - 1)\nend\n\ndef turn_left(gen)\n  return draw_line if gen.zero?\n\n  turn_left(gen - 1)\n  rotate(-angle)\n  turn_right(gen - 1)\nend\n\ndef settings\n  size(700, 600)\nend\n\nLibrary: RubyGems\nLibrary: JRubyArt\nLibrary: cf3ruby\n\nrequire 'cf3'\n\nINV_SQRT = 1 / Math.sqrt(2)\n\ndef setup_the_dragon\n  @dragon = ContextFree.define do\n    shape :start do\n      dragon alpha: 1\n    end\n\n    shape :dragon do\n      square hue: 0, brightness: 0, saturation: 1, alpha: 0.02\n      split do\n        dragon size: INV_SQRT, rotation: -45, x: 0.25, y: 0.25\n        rewind\n        dragon size: INV_SQRT, rotation: 135, x: 0.25, y: 0.25\n        rewind\n      end\n    end\n  end\nend\n\ndef settings\n  size 800, 500\nend\n\ndef setup\n  sketch_title 'Heighway Dragon'\n  setup_the_dragon\n  draw_it\nend\n\ndef draw_it\n  background 255\n  @dragon.render :start, size: width * 0.8, stop_size: 2,\n                         start_x: width / 3, start_y: height / 3.5\nend\n\n", "explain": "Context Free Art version\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Rust", "code": "\nuse ggez::{\n    conf::{WindowMode, WindowSetup},\n    error::GameResult,\n    event,\n    graphics::{clear, draw, present, Color, MeshBuilder},\n    nalgebra::Point2,\n    Context,\n};\nuse std::time::Duration;\n\n// L-System to create the sequence needed for a Dragon Curve.\n// This function creates the next generation given the current one\n// L-System from https://www.cs.unm.edu/~joel/PaperFoldingFractal/L-system-rules.html\n//\nfn l_system_next_generation(current_generation: &str) -> String {\n    let f_rule = \"f-h\";\n    let h_rule = \"f+h\";\n    let mut next_gen = String::new();\n    for char in current_generation.chars() {\n        match char {\n            'f' => next_gen.push_str(f_rule),\n            'h' => next_gen.push_str(h_rule),\n            '-' | '+' => next_gen.push(char),\n            _ => panic!(\"Unknown char {}\", char),\n        }\n    }\n    next_gen\n}\n\n// The rest of the code is for drawing the output and is specific to using the\n// ggez 2d game library: https://ggez.rs/\n\nconst WINDOW_WIDTH: f32 = 700.0;\nconst WINDOW_HEIGHT: f32 = 700.0;\nconst START_X: f32 = WINDOW_WIDTH / 6.0;\nconst START_Y: f32 = WINDOW_HEIGHT / 6.0;\nconst MAX_DEPTH: i32 = 15;\nconst LINE_LENGTH: f32 = 20.0;\n\nstruct MainState {\n    start_gen: String,\n    next_gen: String,\n    line_length: f32,\n    max_depth: i32,\n    current_depth: i32,\n}\n\nimpl MainState {\n    fn new() -> GameResult<MainState> {\n        let start_gen = \"f\";\n        let next_gen = String::new();\n        let line_length = LINE_LENGTH;\n        let max_depth = MAX_DEPTH;\n        let current_depth = 0;\n        Ok(MainState {\n            start_gen: start_gen.to_string(),\n            next_gen,\n            line_length,\n            max_depth,\n            current_depth,\n        })\n    }\n}\n\nimpl event::EventHandler for MainState {\n    // In each repetition of the event loop a new generation of the L-System\n    // is generated and drawn, until the maximum depth is reached.\n    // Each time the line length is reduced so that the overall dragon curve\n    // can be seen in the window as it spirals and gets bigger.\n    // The update sleeps for 0.5 seconds just so that its pogression can be watched.\n    //\n    fn update(&mut self, _ctx: &mut Context) -> GameResult {\n        if self.current_depth < self.max_depth {\n            self.next_gen = l_system_next_generation(&self.start_gen);\n            self.start_gen = self.next_gen.clone();\n            self.line_length -= (self.line_length / self.max_depth as f32) * 1.9;\n            self.current_depth += 1;\n        }\n        ggez::timer::sleep(Duration::from_millis(500));\n        Ok(())\n    }\n\n    fn draw(&mut self, ctx: &mut Context) -> GameResult {\n        let grey = Color::from_rgb(77, 77, 77);\n        let blue = Color::from_rgb(51, 153, 255);\n        let initial_point_blue = Point2::new(START_X, START_Y);\n        clear(ctx, grey);\n        draw_lines(\n            &self.next_gen,\n            ctx,\n            self.line_length,\n            blue,\n            initial_point_blue,\n        )?;\n        present(ctx)?;\n        Ok(())\n    }\n}\n\nfn next_point(current_point: Point2<f32>, heading: f32, line_length: f32) -> Point2<f32> {\n    let next_point = (\n        (current_point.x + (line_length * heading.to_radians().cos().trunc() as f32)),\n        (current_point.y + (line_length * heading.to_radians().sin().trunc() as f32)),\n    );\n    Point2::new(next_point.0, next_point.1)\n}\n\nfn draw_lines(\n    instructions: &str,\n    ctx: &mut Context,\n    line_length: f32,\n    colour: Color,\n    initial_point: Point2<f32>,\n) -> GameResult {\n    let line_width = 2.0;\n    let mut heading = 0.0;\n    let turn_angle = 90.0;\n    let mut start_point = initial_point;\n    let mut line_builder = MeshBuilder::new();\n    for char in instructions.chars() {\n        let end_point = next_point(start_point, heading, line_length);\n        match char {\n            'f' | 'h' => {\n                line_builder.line(&[start_point, end_point], line_width, colour)?;\n                start_point = end_point;\n            }\n            '+' => heading += turn_angle,\n            '-' => heading -= turn_angle,\n            _ => panic!(\"Unknown char {}\", char),\n        }\n    }\n    let lines = line_builder.build(ctx)?;\n    draw(ctx, &lines, (initial_point,))?;\n    Ok(())\n}\n\nfn main() -> GameResult {\n    let cb = ggez::ContextBuilder::new(\"dragon curve\", \"huw\")\n        .window_setup(WindowSetup::default().title(\"Dragon curve\"))\n        .window_mode(WindowMode::default().dimensions(WINDOW_WIDTH, WINDOW_HEIGHT));\n    let (ctx, event_loop) = &mut cb.build()?;\n    let state = &mut MainState::new()?;\n    event::run(ctx, event_loop, state)\n}\n\nFile:Dragon curve rust.gif\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "R", "code": "\nVersion #1.[edit]\nDragon<-function(Iters){\n  Rotation<-matrix(c(0,-1,1,0),ncol=2,byrow=T) ########Rotation multiplication matrix\n  Iteration<-list() ###################################Set up list for segment matrices for 1st\n  Iteration[[1]] <- matrix(rep(0,16), ncol = 4)\n  Iteration[[1]][1,]<-c(0,0,1,0)\n  Iteration[[1]][2,]<-c(1,0,1,-1)\n  Moveposition<-rep(0,Iters) ##########################Which point should be shifted to origin\n  Moveposition[1]<-4\n  if(Iters > 1){#########################################where to move to get to origin\n    for(l in 2:Iters){#####################################only if >1, because 1 set before for loop\n      Moveposition[l]<-(Moveposition[l-1]*2)-2#############sets vector of all positions in matrix where last point is\n    }}\n  Move<-list() ########################################vector to add to all points to shift start at origin\nfor (i in 1:Iters){\nhalf<-dim(Iteration[[i]])[1]/2\nhalf<-1:half\nfor(j in half){########################################Rotate all points 90 degrees clockwise\n  Iteration[[i]][j+length(half),]<-c(Iteration[[i]][j,1:2]%*%Rotation,Iteration[[i]][j,3:4]%*%Rotation)\n}\nMove[[i]]<-matrix(rep(0,4),ncol=4)\nMove[[i]][1,1:2]<-Move[[i]][1,3:4]<-(Iteration[[i]][Moveposition[i],c(3,4)]*-1)\nIteration[[i+1]]<-matrix(rep(0,2*dim(Iteration[[i]])[1]*4),ncol=4)##########move the dragon, set next Iteration's matrix\nfor(k in 1:dim(Iteration[[i]])[1]){#########################################move dragon by shifting all previous iterations point \n  Iteration[[i+1]][k,]<-Iteration[[i]][k,]+Move[[i]]###so the start is at the origin\n}\nxlimits<-c(min(Iteration[[i]][,3])-2,max(Iteration[[i]][,3]+2))#Plot\nylimits<-c(min(Iteration[[i]][,4])-2,max(Iteration[[i]][,4]+2))\nplot(0,0,type='n',axes=FALSE,xlab=\"\",ylab=\"\",xlim=xlimits,ylim=ylimits)\ns<-dim(Iteration[[i]])[1]\ns<-1:s\nsegments(Iteration[[i]][s,1], Iteration[[i]][s,2], Iteration[[i]][s,3], Iteration[[i]][s,4], col= 'red')\n}}#########################################################################\n\n\nVersion #2.[edit]\n\nTranslation of: JavaScript v.#2\nWorks with: R version 3.3.1 and above\nFile:DCR7.pngOutput DCR7.png\nFile:DCR13.pngOutput DCR13.png\nFile:DCR16.pngOutput DCR16.png\n# Generate and plot Dragon curve.\n# translation of JavaScript v.#2: http://rosettacode.org/wiki/Dragon_curve#JavaScript\n# 2/27/16 aev \n# gpDragonCurve(ord, clr, fn, d, as, xsh, ysh)\n# Where: ord - order (defines the number of line segments); \n#   clr - color, fn - file name (.ext will be added), d - segment length,\n#   as - axis scale, xsh - x-shift, ysh - y-shift\ngpDragonCurve <- function(ord, clr, fn, d, as, xsh, ysh) {\n  cat(\" *** START:\", date(), \"order=\",ord, \"color=\",clr, \"\\n\");\n  d=10; m=640; ms=as*m; n=bitwShiftL(1, ord);\n  c=c1=c2=c2x=c2y=i1=0; x=y=x1=y1=0;\n  if(fn==\"\") {fn=\"DCR\"}\n  pf=paste0(fn, ord, \".png\");\n  ttl=paste0(\"Dragon curve, ord=\",ord);\n  cat(\" *** Plot file -\", pf, \"title:\", ttl, \"n=\",n, \"\\n\");\n  plot(NA, xlim=c(-ms,ms), ylim=c(-ms,ms), xlab=\"\", ylab=\"\", main=ttl);\n  for (i in 0:n) {\n    segments(x1+xsh, y1+ysh, x+xsh, y+ysh, col=clr); x1=x; y1=y;\n    c1=bitwAnd(c, 1); c2=bitwAnd(c, 2);\n    c2x=d; if(c2>0) {c2x=(-1)*d}; c2y=(-1)*c2x;\n    if(c1>0) {y=y+c2y} else {x=x+c2x}\n    i1=i+1; ii=bitwAnd(i1, -i1); c=c+i1/ii;\n  }\n  dev.copy(png, filename=pf, width=m, height=m); # plot to png-file\n  dev.off(); graphics.off();  # Cleaning\n  cat(\" *** END:\",date(),\"\\n\");\n}\n## Testing samples:\ngpDragonCurve(7, \"red\", \"\", 20, 0.2, -30, -30)\n##gpDragonCurve(11, \"red\", \"\", 10, 0.6, 100, 200)\ngpDragonCurve(13, \"navy\", \"\", 10, 1, 300, -200)\n##gpDragonCurve(15, \"darkgreen\", \"\", 10, 2, -450, -500)\ngpDragonCurve(16, \"darkgreen\", \"\", 10, 3, -1050, -500)\n\n\nOutput:\n> gpDragonCurve(7, \"red\", \"\", 20, 0.2, -30, -30)\n *** START: Mon Feb 27 12:53:57 2017 order= 7 color= red \n *** Plot file - DCR7.png title: Dragon curve, ord=7 n= 128 \n *** END: Mon Feb 27 12:53:57 2017 \n\n> gpDragonCurve(13, \"navy\", \"\", 10, 1, 300, -200)\n *** START: Mon Feb 27 12:44:04 2017 order= 13 color= navy \n *** Plot file - DCR13.png title: Dragon curve, ord=13 n= 8192 \n *** END: Mon Feb 27 12:44:06 2017 \n\n> gpDragonCurve(16, \"darkgreen\", \"\", 10, 3, -1050, -500)\n *** START: Mon Feb 27 12:18:56 2017 order= 16 color= darkgreen \n *** Plot file - DCR16.png title: Dragon curve, ord=16  n= 65536 \n *** END: Mon Feb 27 12:19:03 2017 \n\n", "explain": "[2]\nNote: This algorithm in R works only for orders <= 16. For bigger values it returns error\nin bitwAnd() [bit-wise AND]. It means: 32-bit integer is not long enough. This is true even on 64-bit computer.\nSee samples using the same algorithm in JavaScript version #2 (order is up to 25, may be even greater).\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "COBOL", "code": "\nWorks with: GnuCOBOL\n         >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\nidentification division.\nprogram-id. dragon.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  segment-length pic 9 value 2.\n01  mark pic x value '.'.\n01  segment-count pic 9999 value 513.\n\n01  segment pic 9999.\n01  point pic 9999 value 1.\n01  point-max pic 9999.\n01  point-lim pic 9999 value 8192.\n01  dragon-curve.\n    03  filler occurs 8192.\n        05  ydragon pic s9999.\n        05  xdragon pic s9999.\n\n01  x pic s9999 value 1.\n01  y pic S9999 value 1.\n\n01  xdelta pic s9 value 1. *> start pointing east\n01  ydelta pic s9 value 0.\n\n01  x-max pic s9999 value -9999.\n01  x-min pic s9999 value 9999.\n01  y-max pic s9999 value -9999.\n01  y-min pic s9999 value 9999.\n\n01  n pic 9999.\n01  r pic 9.\n\n01  xupper pic s9999.\n01  yupper pic s9999.\n\n01  window-line-number pic 99.\n01  window-width pic 99 value 64.\n01  window-height pic 99 value 22.\n01  window.\n    03  window-line occurs 22.\n        05  window-point occurs 64 pic x.\n\n01  direction pic x.\n\nprocedure division.\nstart-dragon.\n\n    if segment-count * segment-length > point-lim\n        *> too many segments for the point-table\n        compute segment-count = point-lim / segment-length\n    end-if\n\n    perform varying segment from 1 by 1\n    until segment > segment-count\n\n        *>===========================================\n        *> segment = n * 2 ** b\n        *> if mod(n,4) = 3, turn left else turn right\n        *>===========================================\n\n        *> calculate the turn\n        divide 2 into segment giving n remainder r\n        perform until r <> 0\n            divide 2 into n giving n remainder r\n        end-perform\n        divide 2 into n giving n remainder r\n\n        *> perform the turn\n        evaluate r also xdelta also ydelta\n        when 0 also 1 also 0  *> turn right from east\n        when 1 also -1 also 0 *> turn left from west\n            *> turn to south\n            move 0 to xdelta\n            move 1 to ydelta\n        when 1 also 1 also 0  *> turn left from east\n        when 0 also -1 also 0 *> turn right from west\n            *> turn to north\n            move 0 to xdelta\n            move -1 to ydelta\n        when 0 also 0 also 1  *> turn right from south\n        when 1 also 0 also -1 *> turn left from north\n            *> turn to west\n            move 0 to ydelta\n            move -1 to xdelta\n        when 1 also 0 also 1  *> turn left from south\n        when 0 also 0 also -1 *> turn right from north\n            *> turn to east\n            move 0 to ydelta\n            move 1 to xdelta\n        end-evaluate\n\n        *> plot the segment points\n        perform segment-length times\n            add xdelta to x\n            add ydelta to y\n\n            move x to xdragon(point)\n            move y to ydragon(point)\n\n            add 1 to point\n        end-perform\n\n        *> update the limits for the display\n        compute x-max = max(x, x-max)\n        compute x-min = min(x, x-min)\n        compute y-max = max(y, y-max)\n        compute y-min = min(y, y-min)\n        move point to point-max\n\n    end-perform\n\n    *>==========================================\n    *> display the curve\n    *> hjkl corresponds to left, up, down, right\n    *> anything else ends the program\n    *>==========================================\n\n    move 1 to yupper xupper\n\n    perform with test after\n    until direction <> 'h' and 'j' and 'k' and 'l'\n\n        *>==========================================\n        *> (yupper,xupper) maps to window-point(1,1)\n        *>==========================================\n\n        *> move the window\n        evaluate true\n        when direction = 'h' *> move window left\n        and xupper > x-min + window-width\n           subtract 1 from xupper\n        when direction = 'j' *> move window up\n        and yupper < y-max - window-height\n           add 1 to yupper\n        when direction = 'k' *> move window down\n        and yupper > y-min + window-height\n           subtract 1 from yupper\n        when direction = 'l' *> move window right\n        and xupper < x-max - window-width\n            add 1 to xupper\n        end-evaluate\n\n        *> plot the dragon points in the window\n        move spaces to window\n        perform varying point from 1 by 1\n        until point > point-max\n            if ydragon(point) >= yupper and < yupper + window-height\n            and xdragon(point) >= xupper and < xupper + window-width\n                *> we're in the window\n                compute y = ydragon(point) - yupper + 1\n                compute x =  xdragon(point) - xupper + 1\n                move mark to window-point(y, x)\n            end-if\n         end-perform\n\n         *> display the window\n         perform varying window-line-number from 1 by 1\n         until window-line-number > window-height\n             display window-line(window-line-number)\n         end-perform\n\n         *> get the next window move or terminate\n         display 'hjkl?' with no advancing\n         accept direction\n    end-perform\n\n    stop run\n    .\nend program dragon.\n\n\nOutput:\n                  . . .         . . . .\n                  ....... ... .........\n                    . . . . . . . . .\n              ... ...................\n              . . . . . . . . . . .\n              ....................... ...\n                . . . . . . . . . . . . .\n          ... ...........................\n          . . . . . . . . . . . . . . .\n          ..................... ... ...\n            . . . . . . . . .\n          ..... .............\n          . .     . . . . .\n          .....   ........... ...\n            . .     . . . . . . .\n            ...   ...............\n                  . . . . . . .\n                  ..... ... ...\n                    .\n              ... ...\n              . . .\n              ....... ...\nhjkl?q\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Ada", "code": "\n\n\n-- FILE: dragon_curve.gpr --\nwith \"gtkada\";\n\nproject Dragon_Curve is\n   Adaflags    := External_As_List (\"ADAFLAGS\", \" \");\n   Ldflags     := External_As_List (\"LDFLAGS\", \" \");\n\n   for Languages use (\"Ada\");\n   for Main use (\"dragon_curve.adb\");\n   for Source_Dirs use (\"./\");\n   for Object_Dir use \"obj/\";\n   for Exec_Dir use \".\";\n\n   package Compiler is\n      for Switches (\"Ada\") use (\"-g\", \"-O0\", \"-gnaty-s\", \"-gnatwJ\")\n         & Adaflags;\n   end Compiler;\n\n   package Linker is\n      for Leading_Switches (\"Ada\") use Ldflags;\n   end Linker;\n\nend Dragon_Curve;\n\n-- FILE: dragon_curve.adb --\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Events; use Events;\nwith GLib.Main; use GLib.Main;\nwith GTK;\nwith GTK.Drawing_Area; use GTK.Drawing_Area;\nwith GTK.Main;\nwith GTK.Window; use GTK.Window;\n\nprocedure Dragon_Curve is\n   Window : GTK_Window;\nbegin\n   GTK.Main.Init; \n   GTK_New (Window);\n   GTK_New (Drawing_Area);\n   Window.Add (Drawing_Area);\n   Drawing_Area.On_Draw (Events.Draw'Access, Drawing_Area);\n   Show_All (Window);\n   Resize (Window, 800, 800);\n   GTK.Main.Main;\nend Dragon_Curve;\n\n-- FILE: events.ads --\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Cairo;\nwith GLib; use Glib;\nwith GTK.Drawing_Area; use GTK.Drawing_Area;\nwith GTK.Widget; use GTK.Widget;\nwith GLib.Object; use GLib.Object;\n\npackage Events is\n   Drawing_Area : GTK_Drawing_Area;\n\n   package GDouble_Elementary_Functions is new Ada.Numerics.Generic_Elementary_Functions (Float);\n   use GDouble_Elementary_Functions;\n\n   function Draw (Self : access GObject_Record'Class;\n                  CC   : Cairo.Cairo_Context)\n                  return Boolean;\nend Events;\n\n-- FILE: events.adb --\nwith Cairo;\nwith GTK;\n\npackage body Events is\n   function Draw (Self : access GObject_Record'Class;\n                  CC   : Cairo.Cairo_Context)\n                  return Boolean\n   is\n      type Rotate_Type is (Counterclockwise, Clockwise);\n\n      type Point is record\n         X, Y : GDouble;\n      end record;\n   \n      procedure Heighway_Branch (CC     : Cairo.Cairo_Context;\n                                 A, B   : Point;\n                                 Rotate : Rotate_Type;\n                                 N      : Natural)\n      is\n         R, RU, C : Point;\n      begin\n         if N = 0 then\n            Cairo.Move_To (CC, A.X, A.Y);          \n            Cairo.Line_To (CC, B.X, B.Y);\n            Cairo.Stroke (CC);\n         else  \n            -- Rotate 45 degrees --\n            case Rotate is\n               when Clockwise =>\n                  R.X := GDouble ((1.0 / Sqrt (2.0)) * Float (B.X - A.X)\n                                   - (1.0 / Sqrt (2.0)) * Float (B.Y - A.Y));\n                  R.Y := GDouble ((1.0 / Sqrt (2.0)) * Float (B.X - A.X)\n                                   + (1.0 / Sqrt (2.0)) * Float (B.Y - A.Y));\n               when Counterclockwise =>\n                  R.X := GDouble ((1.0 / Sqrt (2.0)) * Float (B.X - A.X) \n                                   + (1.0 / Sqrt (2.0)) * Float (B.Y - A.Y));\n                  R.Y := GDouble (-(1.0 / Sqrt (2.0)) * Float (B.X - A.X)\n                                   + (1.0 / Sqrt (2.0)) * Float (B.Y - A.Y));\n            end case;\n\n            -- Make unit vector from rotation --\n            RU.X := GDouble (Float (R.X) / Sqrt ( Float (R.X ** 2 + R.Y ** 2)));\n            RU.Y := GDouble (Float (R.Y) / Sqrt ( Float (R.X ** 2 + R.Y ** 2)));\n\n            -- Scale --\n            R.X := RU.X * GDouble (Sqrt (Float (B.X - A.X) ** 2 + Float (B.Y - A.Y) ** 2) / Sqrt (2.0));\n            R.Y := RU.Y * GDouble (Sqrt (Float (B.X - A.X) ** 2 + Float (B.Y - A.Y) ** 2) / Sqrt (2.0));\n\n            C := (R.X + A.X, R.Y + A.Y);\n       \n            Heighway_Branch (CC, A, C, Clockwise, N - 1);\n            Heighway_Branch (CC, C, B, Counterclockwise, N - 1);\n         end if;\n      end Heighway_Branch;\n\n      Depth : constant := 14;\n      Center, Right, Bottom, Left: Point;\n      Width  : GDouble := GDouble (Drawing_Area.Get_Allocated_Width);\n      Height : GDouble := GDouble (Drawing_Area.Get_Allocated_Height);\n\n   begin\n      Center := (Width / 2.0, Height / 2.0);\n      Right  := (Width,       Height / 2.0);\n      Left   := (0.0,         Height / 2.0);\n      Bottom := (Width / 2.0, Height);\n\n      Cairo.Set_Source_RGB (CC, 0.0, 1.0, 0.0);\n      Heighway_Branch (CC, Center, Right, Clockwise, Depth);\n      Cairo.Set_Source_RGB (CC, 0.0, 1.0, 1.0);\n      Heighway_Branch (CC, Center, Left, Clockwise, Depth);\n      Cairo.Set_Source_RGB (CC, 0.0, 1.0, 0.5);\n      Heighway_Branch (CC, Center, Bottom, Clockwise, Depth);\n      \n      return True;\n   end Draw;\nend Events;\n\n", "explain": "This example uses GTKAda and Cairo.\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nusing Luxor\nfunction dragon(turtle::Turtle, level=4, size=200, direction=45)\n    if level != 0\n        Turn(turtle, -direction)\n        dragon(turtle, level-1, size/sqrt(2), 45)\n        Turn(turtle, direction*2)\n        dragon(turtle, level-1, size/sqrt(2), -45)\n        Turn(turtle, -direction)\n    else\n        Forward(turtle, size)\n    end\nend\n\nDrawing(900, 500, \"./Dragon.png\")\nt = Turtle(300, 300, true, 0, (0., 0.0, 0.0)); \ndragon(t, 10,400)\nfinish()\npreview()\n\n\n", "explain": "Code uses Luxor library[1].\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.0.6\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport javax.swing.JFrame\n\nclass DragonCurve(iter: Int) : JFrame(\"Dragon Curve\") {\n    private val turns: MutableList<Int>\n    private val startingAngle: Double\n    private val side: Double\n\n    init {\n        setBounds(100, 100, 800, 600)\n        defaultCloseOperation = EXIT_ON_CLOSE\n        turns = getSequence(iter)\n        startingAngle = -iter * Math.PI / 4\n        side = 400.0 / Math.pow(2.0, iter / 2.0)\n    }\n\n    fun getSequence(iterations: Int): MutableList<Int> {\n        val turnSequence = mutableListOf<Int>()\n        for (i in 0 until iterations) {\n            val copy = mutableListOf<Int>()\n            copy.addAll(turnSequence)\n            copy.reverse()\n            turnSequence.add(1)\n            copy.mapTo(turnSequence) { -it }\n        }\n        return turnSequence\n    }\n\n    override fun paint(g: Graphics) {\n        g.color = Color.BLUE\n        var angle = startingAngle\n        var x1 = 230\n        var y1 = 350\n        var x2 = x1 + (Math.cos(angle) * side).toInt()\n        var y2 = y1 + (Math.sin(angle) * side).toInt()\n        g.drawLine(x1, y1, x2, y2)\n        x1 = x2\n        y1 = y2\n        for (turn in turns) {\n            angle += turn * Math.PI / 2.0\n            x2 = x1 + (Math.cos(angle) * side).toInt()\n            y2 = y1 + (Math.sin(angle) * side).toInt()\n            g.drawLine(x1, y1, x2, y2)\n            x1 = x2\n            y1 = y2\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    DragonCurve(14).isVisible = true\n}\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Perl", "code": "\n\nuse SVG;\nuse List::Util qw(max min);\n\nuse constant pi => 2 * atan2(1, 0);\n\n# Compute the curve with a Lindemayer-system\nmy %rules = (\n    X => 'X+YF+',\n    Y => '-FX-Y'\n);\nmy $dragon = 'FX';\n$dragon =~ s/([XY])/$rules{$1}/eg for 1..10;\n\n# Draw the curve in SVG\n($x, $y) = (0, 0);\n$theta   = 0;\n$r       = 6;\n\nfor (split //, $dragon) {\n    if (/F/) {\n        push @X, sprintf \"%.0f\", $x;\n        push @Y, sprintf \"%.0f\", $y;\n        $x += $r * cos($theta);\n        $y += $r * sin($theta);\n    }\n    elsif (/\\+/) { $theta += pi/2; }\n    elsif (/\\-/) { $theta -= pi/2; }\n}\n\n$xrng =  max(@X) - min(@X);\n$yrng =  max(@Y) - min(@Y);\n$xt   = -min(@X)+10;\n$yt   = -min(@Y)+10;\n$svg = SVG->new(width=>$xrng+20, height=>$yrng+20);\n$points = $svg->get_path(x=>\\@X, y=>\\@Y, -type=>'polyline');\n$svg->rect(width=>\"100%\", height=>\"100%\", style=>{'fill'=>'black'});\n$svg->polyline(%$points, style=>{'stroke'=>'orange', 'stroke-width'=>1}, transform=>\"translate($xt,$yt)\");\n\nopen  $fh, '>', 'dragon_curve.svg';\nprint $fh  $svg->xmlify(-namespace=>'svg');\nclose $fh;\n\n\n", "explain": "As in the Raku solution, we'll use a Lindenmayer system and draw the dragon in SVG.\nDragon curve  (offsite image)\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Prolog", "code": "\n\ndragonCurve(N) :-\n\tdcg_dg(N, [left], DCL, []),\n\tSide = 4,\n\tAngle is -N * (pi/4),\n\tdcg_computePath(Side, Angle, DCL, point(180,400), P, []),\n\tnew(D, window('Dragon Curve')),\n\tsend(D, size, size(800,600)),\n\tnew(Path, path(poly)),\n\tsend_list(Path, append, P),\n\tsend(D, display, Path),\n\tsend(D, open).\n\n\n% compute the list of points of the Dragon Curve\ndcg_computePath(Side, Angle, [left | DCT], point(X1, Y1)) -->\n\t   [point(X1, Y1)],\n\t   {\tX2 is X1 + Side * cos(Angle),\n\t\tY2 is Y1 + Side * sin(Angle),\n\t\tAngle1 is Angle + pi / 2\n\t   },\n\t   dcg_computePath(Side, Angle1, DCT, point(X2, Y2)).\n\ndcg_computePath(Side, Angle, [right | DCT], point(X1, Y1)) -->\n\t   [point(X1, Y1)],\n\t   {\tX2 is X1 + Side * cos(Angle),\n\t\tY2 is Y1 + Side * sin(Angle),\n\t\tAngle1 is Angle - pi / 2\n\t   },\n\t   dcg_computePath(Side, Angle1, DCT, point(X2, Y2)).\n\n\ndcg_computePath(_Side, _Angle, [], point(X1, Y1)) -->\n\t[ point(X1, Y1)].\n\n\n% compute the list of the \"turns\" of the Dragon Curve\ndcg_dg(1, L) --> L.\n\ndcg_dg(N, L) -->\n\t{dcg_dg(L, L1, []),\n\t  N1 is N - 1},\n\t  dcg_dg(N1, L1).\n\n% one interation of the process\ndcg_dg(L) -->\n\tL,\n\t[left],\n\tinverse(L).\n\ninverse([H | T]) -->\n\tinverse(T),\n\tinverse(H).\n\ninverse([]) --> [].\n\ninverse(left) -->\n\t[right].\n\ninverse(right) -->\n\t[left].\n\n\n1\u00a0?- dragonCurve(13).\ntrue \n", "explain": "Works with SWI-Prolog which has a Graphic interface XPCE.\nDCG are used to compute the list of \"turns\" of the Dragon Curve and the list of points.\nOutput \u00a0:\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Lua", "code": "\nWorks with: Lua version 5.1.4\n\nfunction dragon()\n    local l = \"l\"\n    local r = \"r\"\n    local inverse = {l = r, r = l}\n    local field = {r}\n    local num = 1 \n    local loop_limit = 6 --increase this number to render a bigger curve\n    for discard=1,loop_limit do \n        field[num+1] = r\n        for i=1,num do\n            field[i+num+1] = inverse[field[num-i+1]]\n        end\n        num = num*2+1\n    end\n    return field\nend\n\nfunction render(field, w, h, l)\n    local x = 0\n    local y = 0\n    local points = {}\n    local highest_x = 0\n    local highest_y = 0\n    local lowest_x = 0\n    local lowest_y = 0\n    local l = \"l\"\n    local r = \"r\"\n    local u = \"u\"\n    local d = \"d\"\n    local heading = u\n    local turn = {r = {r = d, d = l, l = u, u = r}, l = {r = u, u = l, l = d, d = r}}\n    for k, v in ipairs(field) do\n        heading = turn[v][heading]\n        for i=1,3 do\n            points[#points+1] = {x, y}\n            if heading == l then\n                x = x-w\n            elseif heading == r then\n                x = x+w\n            elseif heading == u then\n                y = y-h\n            elseif heading == d then\n                y = y+h\n            end\n            if x > highest_x then\n                highest_x = x\n            elseif x < lowest_x then\n                lowest_x = x\n            end\n            if y > highest_y then\n                highest_y = y\n            elseif y < lowest_y then\n                lowest_y = y\n            end\n        end\n    end\n    points[#points+1] = {x, y}\n    highest_x = highest_x - lowest_x + 1\n    highest_y = highest_y - lowest_y + 1\n    for k, v in ipairs(points) do\n        v[1] = v[1] - lowest_x + 1\n        v[2] = v[2] - lowest_y + 1\n    end\n    return highest_x, highest_y, points\nend\n\nfunction render_text_mode()\n    local width, height, points = render(dragon(), 1, 1, 1)\n    local rows = {}\n    for i=1,height do\n        rows[i] = {}\n        for j=1,width do\n            rows[i][j] = ' '\n        end\n    end\n    for k, v in ipairs(points) do\n        rows[v[2]][v[1]] = \"*\"\n    end\n\n    for i=1,height do\n        print(table.concat(rows[i], \"\"))\n    end\nend\n\nfunction dump_points()\n    local width, height, points = render(dragon(), 4, 4, 1)\n    for k, v in ipairs(points) do\n        print(unpack(v))\n    end\nend\n\n--replace this line with dump_points() to output a list of coordinates:\nrender_text_mode()\n\n\n      ****  ****                     \n      *  *  *  *                     \n      *  *  *  *                     \n   ****  *******                     \n   *        *                        \n   *        *                        \n   ****     ****  ****               \n               *  *  *               \n               *  *  *               \n            **********               \n            *  *  *                  \n            *  *  *                  \n            *******                  \n               *                     \n               *                     \n      ****  ****                     \n      *  *  *                        \n      *  *  *                        \n      **********  ****               \n         *  *  *  *  *               \n         *  *  *  *  *               \n****  ****************               \n*  *  *  *  *  *  *                  \n*  *  *  *  *  *  *                  \n*******************                  \n   *  *  *  *  *                     \n   *  *  *  *  *                     \n*******  *******              ****   \n*  *        *                    *   \n*  *        *                    *   \n*******     ****  ****           ****\n   *  *        *  *  *              *\n   *  *        *  *  *              *\n   ****     **********           ****\n            *  *  *              *   \n            *  *  *              *   \n            **********  ****  *******\n               *  *  *  *  *  *  *  *\n               *  *  *  *  *  *  *  *\n            *******  **********  ****\n            *  *        *  *         \n            *  *        *  *         \n            *******     *******      \n               *  *        *  *      \n               *  *        *  *      \n               ****        ****      \n\n", "explain": "Could be made much more compact, but this was written for speed. It has two rendering modes, one which renders the curve in text mode (default,) and one which just dumps all the coordinates for use by an external rendering application.\nOutput:\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Scala", "code": "\nimport javax.swing.JFrame\nimport java.awt.Graphics\n\nclass DragonCurve(depth: Int) extends JFrame(s\"Dragon Curve (depth $depth)\") {\n  \n  setBounds(100, 100, 800, 600);\n  setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n  \n  val len = 400 / Math.pow(2, depth / 2.0);\n  val startingAngle = -depth * (Math.PI / 4);\n  val steps = getSteps(depth).filterNot(c => c == 'X' || c == 'Y')\n  \n  def getSteps(depth: Int): Stream[Char] = {\n    if (depth == 0) {\n      \"FX\".toStream\n    } else {\n      getSteps(depth - 1).flatMap{\n        case 'X' => \"XRYFR\"\n        case 'Y' => \"LFXLY\"\n        case c => c.toString\n      }\n    }\n  }\n  \n  override def paint(g: Graphics): Unit = {\n    var (x, y) = (230, 350)\n    var (dx, dy) = ((Math.cos(startingAngle) * len).toInt, (Math.sin(startingAngle) * len).toInt)\n    for (c <- steps) c match {\n      case 'F' => {\n        g.drawLine(x, y, x + dx, y + dy)\n        x = x + dx\n        y = y + dy\n      }\n      case 'L' => {\n        val temp = dx\n        dx = dy\n        dy = -temp\n      }\n      case 'R' => {\n        val temp = dx\n        dx = -dy\n        dy = temp\n      }\n    }\n  }\n\n}\n\nobject DragonCurve extends App {\n  new DragonCurve(14).setVisible(true);\n}\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "D", "code": "\nText mode[edit]\n\nvariables\u00a0: X Y F\nconstants\u00a0: + \u2212\nstart \u00a0: FX\nrules \u00a0: (X \u2192 X+YF+),(Y \u2192 -FX-Y)\nangle \u00a0: 90\u00b0\nimport std.stdio, std.string;\n\nstruct Board {\n    enum char spc = ' ';\n    char[][] b = [[' ']]; // Set at least 1x1 board.\n    int shiftx, shifty;\n\n    void clear() pure nothrow {\n        shiftx = shifty = 0;\n        b = [['\\0']];\n    }\n\n    void check(in int x, in int y) pure nothrow {\n        while (y + shifty < 0) {\n            auto newr = new char[b[0].length];\n            newr[] = spc;\n            b = newr ~ b;\n            shifty++;\n        }\n\n        while (y + shifty >= b.length) {\n            auto newr = new char[b[0].length];\n            newr[] = spc;\n            b ~= newr;\n        }\n\n        while (x + shiftx < 0) {\n            foreach (ref c; b)\n                c = [spc] ~ c;\n            shiftx++;\n        }\n\n        while (x + shiftx >= b[0].length)\n            foreach (ref c; b)\n                c ~= [spc];\n    }\n\n    char opIndexAssign(in char value, in int x, in int y)\n    pure nothrow {\n        check(x, y);\n        b[y + shifty][x + shiftx] = value;\n        return value;\n    }\n\n    string toString() const pure {\n        return format(\"%-(%s\\n%)\", b);\n    }\n}\n\nstruct Turtle {\n    static struct TState {\n        int[2] xy;\n        int heading;\n    }\n\n    enum int[2][] dirs = [[1, 0],  [1,   1], [0,  1], [-1,  1],\n                          [-1, 0], [-1, -1], [0, -1],  [1, -1]];\n    enum string trace = r\"-\\|/-\\|/\";\n    TState t;\n\n    void reset() pure nothrow {\n        t = typeof(t).init;\n    }\n\n    void turn(in int dir) pure nothrow {\n        t.heading = (t.heading + 8 + dir) % 8;\n    }\n\n    void forward(ref Board b) pure nothrow {\n        with (t) {\n            xy[] += dirs[heading][];\n            b[xy[0], xy[1]] = trace[heading];\n            xy[] += dirs[heading][];\n            b[xy[0], xy[1]] = b.spc;\n        }\n    }\n}\n\nvoid dragonX(in int n, ref Turtle t, ref Board b) pure nothrow {\n    if (n >= 0) { // X -> X+YF+\n        dragonX(n - 1, t, b);\n        t.turn(2);\n        dragonY(n - 1, t, b);\n        t.forward(b);\n        t.turn(2);\n    }\n}\n\nvoid dragonY(in int n, ref Turtle t, ref Board b) pure nothrow {\n    if (n >= 0) { // Y -> -FX-Y\n        t.turn(-2);\n        t.forward(b);\n        dragonX(n - 1, t, b);\n        t.turn(-2);\n        dragonY(n - 1, t, b);\n    }\n}\n\nvoid main() {\n    Turtle t;\n    Board b;\n                      // Seed\u00a0: FX\n    t.forward(b);     // <- F\n    dragonX(7, t, b); // <- X\n    writeln(b);\n}\n\n\nOutput:\n           -   -           -   -               \n          | | | |         | | | |              \n         - - - -         - - - -               \n        | | | |         | | | |                \n         -   - -   -     -   - -   -           \n              | | | |         | | | |          \n             - - - -         - - - -           \n            | | | |         | | | |            \n   -   -   - - - - -   -   - - - -             \n  | | | | | | | | | | | | | | | |              \n - - - - -   - - -   - - - - - -               \n| | | | |     | |     | | | | |                \n -   - - -     - -     - - - - -   -           \n      | | |     | |     | | | | | | |          \n     -   -       -     - - - - - - -           \n    |                 | | | | | | |            \n   - -                 - - - - - -             \n  | | |                 | | | | |              \n - - -                 - -   - -           -   \n| | |                 | |     |           | |  \n -   -     -           - -     -   -         - \n      |     |           | |     | | |         |\n     - -   -             -     - - -         - \n    | | | |                   | | |         |  \n     -   -                     - - -   -   - - \n                                | | | | | | | |\n                               - -   - - -   - \n                              | |     | |      \n                               - -     - -     \n                                | |     | |    \n                                 -       -     \nPostScript Output Version[edit]\nTranslation of: Haskell\nimport std.stdio, std.string;\n\nstring drx(in size_t n) pure nothrow {\n    return n ? (drx(n - 1) ~ \" +\" ~ dry(n - 1) ~ \" f +\") : \"\";\n}\n\nstring dry(in size_t n) pure nothrow {\n    return n ? (\" - f\" ~ drx(n - 1) ~ \" -\" ~ dry(n - 1)) : \"\";\n}\n\nstring dragonCurvePS(in size_t n) pure nothrow {\n    return [\"0 setlinewidth 300 400 moveto\",\n            \"/f{2 0 rlineto}def/+{90 rotate}def/-{-90 rotate}def\\n\",\n            \"f\", drx(n), \" stroke showpage\"].join();\n}\n\nvoid main() {\n    writeln(dragonCurvePS(9)); // Increase this for a bigger curve.\n}\n\nOn a Bitmap[edit]\n\nmodule turtle;\n\nimport bitmap_bresenhams_line_algorithm, grayscale_image, std.math;\n\n// Minimal turtle graphics.\nstruct Turtle {\n    real x = 100, y = 100, angle = -90;\n\n    void left(in real a) pure nothrow { angle -= a; }\n    void right(in real a) pure nothrow { angle += a; }\n\n    void forward(Color)(Image!Color img, in real len) pure nothrow {\n        immutable r = angle * (PI / 180.0);\n        immutable dx = r.cos * len;\n        immutable dy = r.sin * len;\n        img.drawLine(cast(uint)x, cast(uint)y,\n                     cast(uint)(x + dx), cast(uint)(y + dy),\n                     Color.white);\n        x += dx;\n        y += dy;\n    }\n}\n\n\nTranslation of: PicoLisp\nimport grayscale_image, turtle;\n\nvoid drawDragon(Color)(Image!Color img, ref Turtle t, in uint depth,\n                       in real dir, in uint step) {\n    if (depth == 0)\n        return t.forward(img, step);\n    t.right(dir);\n    img.drawDragon(t, depth - 1, 45.0, step);\n    t.left(dir * 2);\n    img.drawDragon(t, depth - 1, -45.0, step);\n    t.right(dir);\n}\n\nvoid main() {\n    auto img = new Image!Gray(500, 700);\n    auto t = Turtle(180, 510, -90);\n    img.drawDragon(t, 14, 45.0, 3);\n    img.savePGM(\"dragon_curve.pgm\");\n}\n\nWith QD[edit]\n\nWith DFL[edit]\n\n", "explain": "A textual version of Dragon curve.\nThe Dragon curve drawn using an L-system.\nThis uses the modules from the bresenhams line algorithm and Grayscale Image tasks.\nFirst a small \"turtle.d\" module, useful for other tasks:\nThen the implementation is simple:\nSee: Dragon curve/D/QD\nSee: Dragon curve/D/DFL\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Haskell", "code": "\nimport Data.List\nimport Graphics.Gnuplot.Simple\n\n-- diamonds\n-- pl = [[0,1],[1,0]]\n\npl = [[0,0],[0,1]]\nr_90 = [[0,1],[-1,0]]\n\nip :: [Int] -> [Int] -> Int\nip xs = sum . zipWith (*) xs\nmatmul xss yss = map (\\xs -> map (ip xs ). transpose $ yss) xss\n\nvmoot xs = (xs++).map (zipWith (+) lxs). flip matmul r_90.\n          map (flip (zipWith (-)) lxs) .reverse . init $ xs\n   where lxs = last xs\n\ndragoncurve = iterate vmoot pl\n\n\nplotPath [] . map (\\[x,y] -> (x,y)) $ dragoncurve!!13\n\n\nx 0 = \"\"\nx n = (x$n-1)++\" +\"++(y$n-1)++\" f +\"\ny 0 = \"\"\ny n = \" - f\"++(x$n-1)++\" -\"++(y$n-1)\n\ndragon n =\n\tconcat [\"0 setlinewidth 300 400 moveto\",\n\t\t\"/f{2 0 rlineto}def/+{90 rotate}def/-{-90 rotate}def\\n\",\n\t\t\"f\", x n, \" stroke showpage\"]\n\nmain = putStrLn $ dragon 14\n\n", "explain": "For plotting I use the gnuplot interface module from hackageDB\nUse:\nString rewrite, and outputs a postscript:\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "PowerShell", "code": "\nWinForms[edit]\nTranslation of: Logo\nLibrary: turtle\n# handy constants with script-wide scope\n[Single]$script:QUARTER_PI=0.7853982\n[Single]$script:HALF_PI=1.570796\n\n# leverage GDI (Forms and Drawing)\nAdd-Type -AssemblyName System.Drawing\nAdd-Type -AssemblyName System.Windows.Forms\n$script:TurtlePen = New-Object Drawing.Pen darkGreen\n$script:Form = New-Object Windows.Forms.Form\n$script:Canvas = $Form.CreateGraphics()\n\n# implement a turtle graphics model\nClass Turtle { # relies on the script-scoped $TurtlePen and $Canvas\n  # member properties for turtle's position and orientation\n  [Single]$TurtleX\n  [Single]$TurtleY\n  [Single]$TurtleAngle\n\n  # constructors\n  Turtle() {\n    $this.TurtleX, $this.TurtleY = 44.0, 88.0\n    $this.TurtleAngle = 0.0\n  }\n  Turtle([Single]$InitX, [Single]$InitY, [Single]$InitAngle) {\n    $this.TurtleX, $this.TurtleY = $InitX, $InitY\n    $this.TurtleAngle = $InitAngle\n  }\n\n  # methods for turning and drawing\n  [Void]Turn([Single]$Angle) {  # $Angle measured in radians\n    $this.TurtleAngle += $Angle  # use positive $Angle for right turn, negative for left turn\n  }\n  [Void]Forward([Single]$Distance) {\n    # draw line segment\n    $TargetX = $this.TurtleX + $Distance * [Math]::Cos($this.TurtleAngle)\n    $TargetY = $this.TurtleY + $Distance * [Math]::Sin($this.TurtleAngle)\n    $script:Canvas.DrawLine($script:TurtlePen, $this.TurtleX, $this.TurtleY, $TargetX, $TargetY)\n    # relocate turtle to other end of segment\n    $this.TurtleX = $TargetX\n    $this.TurtleY = $TargetY\n  }\n} # end of Turtle class definition\n\n# Implement dragon curve drawing methods in a subclass that inherits Turtle\nClass DragonTurtle : Turtle {\n\n  # DCL: recursive dragon curve, starting with left turns\n  [Void]DCL([Byte]$Step, [Single]$Length) {\n    $AdjustedStep = $Step - 1\n    $AdjustedLength = $Length / [Math]::Sqrt(2.0)\n\n    $this.Turn(-$script:QUARTER_PI)\n    if ($AdjustedStep -gt 0) {\n      $this.DCR($AdjustedStep, $AdjustedLength)\n    } else {\n      $this.Forward($AdjustedLength)\n    }\n    $this.Turn($script:HALF_PI)\n    if ($AdjustedStep -gt 0) {\n      $this.DCL($AdjustedStep, $AdjustedLength)\n    } else {\n      $this.Forward($AdjustedLength)\n    }\n    $this.Turn(-$script:QUARTER_PI)\n  }\n\n  # DCR: recursive dragon curve, starting with right turns\n  [Void]DCR([Byte]$Step, [Single]$Length) {\n    $AdjustedStep = $Step - 1\n    $AdjustedLength = $Length / [Math]::Sqrt(2.0)\n\n    $this.Turn($script:QUARTER_PI)\n    if ($AdjustedStep -gt 0) {\n      $this.DCR($AdjustedStep, $AdjustedLength)\n    } else {\n      $this.Forward($AdjustedLength)\n    }\n    $this.Turn(-$script:HALF_PI)\n    if ($AdjustedStep -gt 0) {\n      $this.DCL($AdjustedStep, $AdjustedLength)\n    } else {\n      $this.Forward($AdjustedLength)\n    }\n    $this.Turn($script:QUARTER_PI)\n  }\n} # end of DragonTurtle subclass definition\n\n# prepare anonymous dragon-curve painting function for WinForms dialog\n$Form.add_paint({\n  [DragonTurtle]$Dragon = [DragonTurtle]::new()\n  $Dragon.DCR(14,128)\n})\n\n# display the GDI Form window, which triggers its prepared anonymous drawing function\n$Form.ShowDialog()\n\n", "explain": ""}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "Logo", "code": "\nRecursive[edit]\nto dcr :step :length\n  make \"step :step - 1\n  make \"length :length / 1.41421\n  if :step > 0 [rt 45 dcr :step :length lt 90 dcl :step :length rt 45]\n  if :step = 0 [rt 45 fd :length lt 90 fd :length rt 45]\nend\n\nto dcl :step :length\n  make \"step :step - 1\n  make \"length :length / 1.41421\n  if :step > 0 [lt 45 dcr :step :length rt 90 dcl :step :length lt 45]\n  if :step = 0 [lt 45 fd :length rt 90 fd :length lt 45]\nend\n\nto dc :step :length :dir\n  if :step = 0 [fd :length stop]\n  rt :dir\n  dc :step-1 :length/1.41421  45\n  lt :dir lt :dir\n  dc :step-1 :length/1.41421 -45\n  rt :dir\nend\nto dragon :step :length\n  dc :step :length 45\nend\n\nto O :step :length\n  if :step=1 [Rt 90 fd :length Lt 90] [O (:step - 1) (:length / 1.41421) N (:step - 1) (:length / 1.41421)]\nend\n\nto N :step :length\n  if :step=1 [fd :length] [W (:step - 1) (:length / 1.41421) N (:step - 1) (:length / 1.41421)]\nend\n\nto W :step :length\n  if :step=1 [Lt 90 fd :length Rt 90] [W (:step - 1) (:length / 1.41421) S (:step - 1) (:length / 1.41421)]\nend \n\nto S :step :length\n  if :step=1 [Rt 180 fd :length Lt 180] [O (:step - 1) (:length / 1.41421) S (:step - 1) (:length / 1.41421)]\nend\nIterative[edit]\n\nWorks with: UCB Logo\n; Return the bit above the lowest 1-bit in :n.\n; If :n = binary \"...z100..00\" then the return is \"z000..00\".\n; Eg. n=22 is binary 10110 the lowest 1-bit is the \"...1.\" and the return is\n; bit above that \"..1.,\" which is 4.\nto bit.above.lowest.1bit :n\n  output bitand :n (1 + (bitxor :n (:n - 1)))\nend\n\n; Return angle +90 or -90 for dragon curve turn at point :n.\n; The curve is reckoned as starting from n=0 so the first turn is at n=1.\nto dragon.turn.angle :n\n  output ifelse (bit.above.lowest.1bit :n) = 0  [90] [-90]\nend\n\n; Draw :steps many segments of the dragon curve.\nto dragon :steps\n  localmake \"step.len 12 \u00a0; length of each step\n  repeat :steps [\n    forward :step.len\n    left    dragon.turn.angle repcount \u00a0; repcount = 1 to :steps inclusive\n  ]\nend\n\ndragon 256\n; Draw :steps many segments of the dragon curve, with corners chamfered\n; off with little 45-degree diagonals.\n; Done this way the vertices don't touch.\nto dragon.chamfer :steps\n  localmake \"step.len       12 \u00a0; length of each step\n  localmake \"straight.frac  0.5\u00a0; fraction of the step to go straight\n\n  localmake \"straight.len   :step.len * :straight.frac\n  localmake \"diagonal.len   (:step.len - :straight.len) * sqrt(1/2)\n\n  repeat :steps [\n     localmake \"turn  (dragon.turn.angle repcount)/2  \u00a0; +45 or -45\n     forward :straight.len\n     left    :turn\n     forward :diagonal.len\n     left    :turn\n  ]\nend\n\ndragon.chamfer 256\n", "explain": "The program can be started using dcr 4 300 or dcl 4 300.\nOr removing duplication:\nAn alternative approach by using sentence-like grammar using four productions o->on, n->wn, w->ws, s->os. O, S, N and W mean cardinal points.\nOr drawing iteratively by making a turn left or right at each point calculated by bit-twiddling.  This allows any length to be drawn, not just powers-of-2.\n"}, {"task_name": "Dragon curve", "task_url": "https://rosettacode.org/wiki/Dragon_curve", "task_cat": "Recursion", "lang": "F#", "code": "\nUsing Library: Windows Presentation Foundation for visualization:\nopen System.Windows\nopen System.Windows.Media\n\nlet m = Matrix(0.0, 0.5, -0.5, 0.0, 0.0, 0.0)\n\nlet step segs =\n  seq { for a: Point, b: Point in segs do\n          let x = a + 0.5 * (b - a) + (b - a) * m\n          yield! [a, x; b, x] }\n\nlet rec nest n f x =\n  if n=0 then x else nest (n-1) f (f x)\n\n[<System.STAThread>]\ndo\n  let path = Shapes.Path(Stroke=Brushes.Black, StrokeThickness=0.001)\n  path.Data <-\n    PathGeometry\n      [ for a, b in nest 13 step (seq [Point(0.0, 0.0), Point(1.0, 0.0)]) ->\n          PathFigure(a, [(LineSegment(b, true) :> PathSegment)], false) ]\n  (Application()).Run(Window(Content=Controls.Viewbox(Child=path))) |> ignore\n\n", "explain": ""}]