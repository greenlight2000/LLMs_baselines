[{"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Python", "code": "\nWorks with: Python version 2.5\n\ncollection = [0, '1']                 # Lists are mutable (editable) and can be sorted in place\nx = collection[0]                     # accessing an item (which happens to be a numeric 0 (zero)\ncollection.append(2)                  # adding something to the end of the list\ncollection.insert(0, '-1')            # inserting a value into the beginning\ny = collection[0]                     # now returns a string of \"-1\"\ncollection.extend([2,'3'])            # same as [collection.append(i) for i in [2,'3']] ... but faster\ncollection += [2,'3']                 # same as previous line\ncollection[2:6]                       # a \"slice\" (collection of the list elements from the third up to but not including the sixth)\nlen(collection)                       # get the length of (number of elements in) the collection\ncollection = (0, 1)                   # Tuples are immutable (not editable)\ncollection[:]                         # ... slices work on these too; and this is equivalent to collection[0:len(collection)]\ncollection[-4:-1]                     # negative slices count from the end of the string\ncollection[::2]                       # slices can also specify a stride --- this returns all even elements of the collection\ncollection=\"some string\"              # strings are treated as sequences of characters\nx = collection[::-1]                  # slice with negative step returns reversed sequence (string in this case).\ncollection[::2] == \"some string\"[::2] # True, literal objects don't need to be bound to name/variable to access slices or object methods\ncollection.__getitem__(slice(0,len(collection),2))  # same as previous expressions.\ncollection = {0: \"zero\", 1: \"one\"}    # Dictionaries (Hash)\ncollection['zero'] = 2                # Dictionary members accessed using same syntax as list/array indexes.\ncollection = set([0, '1'])            # sets (Hash)\n\n", "explain": "Python supports lists, tuples, dictionaries and now sets as built-in collection types.  See http://docs.python.org/tut/node7.html for further details.\nIn addition Python classes support a number of methods allowing them to implement indexing, slicing, and attribute management features as collections. Thus many modules in the Python standard libraries allow one to treat files contents, databases, and other data using the same syntax as the native collection types. Some Python modules (such as Numeric and NumPy) provide low-level implementations of additional collections (such as efficient n-dimensional arrays).\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "C", "code": "\n\n#define cSize( a )  ( sizeof(a)/sizeof(a[0]) ) /* a.size() */\nint ar[10];               /* Collection<Integer> ar = new ArrayList<Integer>(10); */\nar[0] = 1;                /* ar.set(0, 1); */\nar[1] = 2;\n\nint* p;                   /* Iterator<Integer> p; Integer pValue; */\nfor (p=ar;                /* for( p = ar.itereator(), pValue=p.next(); */\n       p<(ar+cSize(ar));  /*        p.hasNext(); */\n       p++) {             /*        pValue=p.next() ) { */\n  printf(\"%d\\n\",*p);      /*   System.out.println(pValue); */\n}                         /* } */\n\n\nint* ar;                  /* Collection<Integer> ar; */\nint arSize;\narSize = (rand() % 6) + 1; \nar = calloc(arSize, sizeof(int) ); /* ar = new ArrayList<Integer>(arSize); */\nar[0] = 1;                /* ar.set(0, 1); */\n\nint* p;                   /* Iterator<Integer> p; Integer pValue; */\nfor (p=ar;                /* p=ar.itereator(); for( pValue=p.next(); */\n       p<(ar+arSize);     /*                         p.hasNext(); */\n       p++) {             /*                         pValue=p.next() ) { */\n  printf(\"%d\\n\",*p);      /*   System.out.println(pValue); */\n}                         /* }    */\n\n\n", "explain": "See Also foreach\nOne thing in C language proper that can be said to be a collection is array type.\nAn array has a length known at compile time.\nPlease note that c built-in pointer-arithmetic support which helps this logic.  An integer may be 4 bytes, and a char 1 byte: the plus operator (+) is overloaded to multiply a incement by 4 for integer pointers and by 1 for char pointers (etc).\nAnother construct which can be seen as a collection is a malloced array.  The size of a malloced array is not known at compile time.\nA string is another C language construct (when looked at with its standard libraries) that behaves like a collection.\nA C language string is an array of char, and it's size may or may not be known at compile time, however a c string is terminated with a ASCII NUL (which may be stated as a constant, '\\0' or ((char)0) in the C language).  The String standard library \"class\" has many \"methods\", however instead of being called String.method(), they are usually called strmethod().\nArbitrarily complex data structures can be constructed, normally via language features struct and pointers.  They are everywhere, but not provided by the C language itself per se.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "C++", "code": "\n\nbuilt-in array[edit]\n\nint a[5]; // array of 5 ints (since int is POD, the members are not initialized)\na[0] = 1; // indexes start at 0\n\nint primes[10] = { 2, 3, 5, 7, 11, 13, 17, 19, 23, 29 }; // arrays can be initialized on creation\n\n#include <string>\nstd::string strings[4]; // std::string is no POD, therefore all array members are default-initialized\n                        // (for std::string this means initialized with empty strings)\n\nvector[edit]\n\n#include <vector>\n\nstd::vector<int> v;       // empty vector\nv.push_back(5);           // insert a 5 at the end\nv.insert(v.begin(), 7);   // insert a 7 at the beginning\n\ndeque[edit]\n\n#include <deque>\n\nstd::deque<int> d;        // empty deque\nd.push_back(5);           // insert a 5 at the end\nd.push_front(7);          // insert a 7 at the beginning\nd.insert(v.begin()+1, 6); // insert a 6 in the middle\n\nlist[edit]\n\n#include <list>\n\nstd::list<int> l;         // empty list\nl.push_back(5);           // insert a 5 at the end\nl.push_front(7);          // insert a 7 at the beginning\nstd::list::iterator i = l.begin();\n++l;\nl.insert(i, 6);           // insert a 6 in the middle\n\nset[edit]\n\n#include <set>\n\nstd::set<int> s;          // empty set\ns.insert(5);              // insert a 5\ns.insert(7);              // insert a 7 (automatically placed after the 5)\ns.insert(5);              // try to insert another 5 (will not change the set)\n\nmultiset[edit]\n\n#include <multiset>\n\nstd::multiset<int> m;     // empty multiset\nm.insert(5);              // insert a 5\nm.insert(7);              // insert a 7 (automatically placed after the 5)\nm.insert(5);              // insert a second 5 (now m contains two 5s, followed by one 7)\n\n", "explain": "C++ has a range of different collections optimized for different use cases. Note that in C++, objects of user-defined types are mostly treated just like objects of built-in types; especially there's no different treatment for collections. Thus all collections can simply be demonstrated with the built-in type int. For user-defined types, just replace int with the user-defined type. Any type which goes into a collection must be copyable and assignable (which in general is automatically the case unless you explicitly disallow it).\nNote however that C++ collections store copies of the objects given to them, so you'll lose any polymorphic behaviour. If you need polymorphism, use a collection of pointers (or smart pointers like boost::shared_ptr).\nThe simplest collection in C++ is the built-in array. Built-in arrays have a fixed size, and except for POD types (i.e. basically any type you culd also write in C), the members are all initialized at array creation time (if no explicit initialization is done, the default constructr is used).\nA vector is basically a resizable array. It is optimized for adding/removing elements on the end, and fast access to elements anywhere. Inserting elements at the beginning or in the middle is possible, but in general inefficient.\nA deque is optimized for appending and removing elements on both ends ofd the array. Accessing random elements is still efficient, but slightly less than with vector.\nA list is optimized for insertion at an arbitrary place (provided you already have an iterator pointing to that place). Element access is efficient only in linear order.\nA set keeps the inserted elements sorted, and also makes sure that each element occurs only once. Of course, if you want to put something into a set, it must be less-than-comparable, i.e. you must be able to compare which of two objects a and b is smaller using a<b (there's also a way to define sets with an user-defined order, in which case this restriction doesn't apply).\nA multiset is like a set, except the same element may occur multiple times.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Java", "code": "\nNative collection library[edit]\nWorks with: Java version 1.5+\n\nList arrayList = new ArrayList();\narrayList.add(new Integer(0));\n// alternative with primitive autoboxed to an Integer object automatically\narrayList.add(0); \n\n//other features of ArrayList\n//define the type in the arraylist, you can substitute a proprietary class in the \"<>\"\nList<Integer> myarrlist = new ArrayList<Integer>();\n\n//add several values to the arraylist to be summed later\nint sum;\nfor(int i = 0; i < 10; i++) {\n    myarrlist.add(i);\n}\n\n//loop through myarrlist to sum each entry\nfor ( i = 0; i < myarrlist.size(); i++) {\n    sum += myarrlist.get(i);\n}\n\n\nfor(int i : myarrlist) {\n    sum += i;\n}\n\n//remove the last entry in the ArrayList\nmyarrlist.remove(myarrlist.size()-1)\n\n//clear the ArrayList\nmyarrlist.clear();\n\n\n\n\nCollection class\n\nrandom access\n\norder\n\niterator direction\n\n\nHashMap\n\nby key\n\nhash\n\nforward (separate iterators for entries, keys and values)\n\n\nTreeMap\n\nby key\n\nascending(key)\n\nforward (separate iterators for entries, keys and values)\n\n\nLinkedHashMap\n\nby key\n\ninsertion\n\nforward (separate iterators for entries, keys and values)\n\n\nLinkedList\n\nby index\n\ninsertion/to index\n\nboth\n\n\nArrayList\n\nby index\n\ninsertion/to index (ArrayList also has a defined but expandable size)\n\nboth\n\n\nHashSet\n\nonly remove (returns the element that was removed)\n\nhash\n\nforward\n\n\nTreeSet\n\nonly remove (returns the element that was removed)\n\nascending(element)\n\nforward\n\nUsing the Scala collection classes[edit]\nThe Scala libraries are valid Java byte-code libraries. The collection part of these are rich because the multiple inheritance by traits. E.g. an ArrayBuffer has properties inherent of 9 traits such as Buffer[A], IndexedSeqOptimized[A, ArrayBuffer[A]], Builder[A, ArrayBuffer[A]], ResizableArray[A] and Serializable. Another collection e.g. TrieMap uses some of these and other added traits. A TrieMap -a hashmap- is the most advanced of all. It supports parallel processing without blocking.import scala.Tuple2;\nimport scala.collection.concurrent.TrieMap;\nimport scala.collection.immutable.HashSet;\nimport scala.collection.mutable.ArrayBuffer;\n\npublic class Collections {\n\n\tpublic static void main(String[] args) {\n\t\tArrayBuffer<Integer> myarrlist = new ArrayBuffer<Integer>();\n\t\tArrayBuffer<Integer> myarrlist2 = new ArrayBuffer<Integer>(20);\n\n\t\tmyarrlist.$plus$eq(new Integer(42)); // $plus$eq is Scala += operator\n\t\tmyarrlist.$plus$eq(13); // to add an element.\n\t\tmyarrlist.$plus$eq(-1);\n\n\t\tmyarrlist2 = (ArrayBuffer<Integer>) myarrlist2.$minus(-1);\n\n\t\tfor (int i = 0; i < 10; i++)\n\t\t\tmyarrlist2.$plus$eq(i);\n\n\t\t// loop through myarrlist to sum each entry\n\t\tint sum = 0;\n\t\tfor (int i = 0; i < myarrlist2.size(); i++) {\n\t\t\tsum += myarrlist2.apply(i);\n\t\t}\n\t\tSystem.out.println(\"List is: \" + myarrlist2 + \" with head: \"\n\t\t\t\t+ myarrlist2.head() + \" sum is: \" + sum);\n\t\tSystem.out.println(\"Third element is: \" + myarrlist2.apply$mcII$sp(2));\n\n\t\tTuple2<String, String> tuple = new Tuple2<String, String>(\"US\",\n\t\t\t\t\"Washington\");\n\t\tSystem.out.println(\"Tuple2 is\u00a0: \" + tuple);\n\n\t\tArrayBuffer<Tuple2<String, String>> capList = new ArrayBuffer<Tuple2<String, String>>();\n\t\tcapList.$plus$eq(new Tuple2<String, String>(\"US\", \"Washington\"));\n\t\tcapList.$plus$eq(new Tuple2<String, String>(\"France\", \"Paris\"));\n\t\tSystem.out.println(capList);\n\n\t\tTrieMap<String, String> trieMap = new TrieMap<String, String>();\n\t\ttrieMap.put(\"US\", \"Washington\");\n\t\ttrieMap.put(\"France\", \"Paris\");\n\n\t\tHashSet<Character> set = new HashSet<Character>();\n\n\t\tArrayBuffer<Tuple2<String, String>> capBuffer = new ArrayBuffer<Tuple2<String, String>>();\n\t\ttrieMap.put(\"US\", \"Washington\");\n\n\t\tSystem.out.println(trieMap);\n\t}\n}\n\n", "explain": "When creating a List of any kind in Java (Arraylist or LinkedList), the type of the variable is a style choice. It is sometimes considered good practice to make the pointer of type List and the new object of a List subclass. Doing this will ensure two things: if you need to change the type of list you want you only need to change one line and all of your methods will still work, and you will not be able to use any methods that are specific to the List type you chose. So in this example, all instances of \"ArrayList\" can be changed to \"LinkedList\" and it will still work, but you will not be able to use a method like \"ensureCapactiy()\" because the variable is of type List.\nor\nHere is a reference table for characteristics of commonly used Collections classes:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "C#", "code": "\nArrays[edit]\n// Creates and initializes a new integer Array\nint[] intArray = new int[5] { 1, 2, 3, 4, 5 };\n//same as\nint[] intArray = new int[]{ 1, 2, 3, 4, 5 };\n//same as\nint[] intArray = { 1, 2, 3, 4, 5 };\n\n//Arrays are zero-based\nstring[] stringArr = new string[5];\nstringArr[0] = \"string\";\n\nArrayList and List[edit]\n\n//Create and initialize ArrayList\nArrayList myAl = new ArrayList { \"Hello\", \"World\", \"!\" };\n\n//Create ArrayList and add some values\nArrayList myAL = new ArrayList();\n      myAL.Add(\"Hello\");\n      myAL.Add(\"World\");\n      myAL.Add(\"!\");\n\n\n//Create and initialize List\nList<string> myList = new List<string> { \"Hello\", \"World\", \"!\" };\n\n//Create List and add some values\nList<string> myList2 = new List<string>();\n            myList2.Add(\"Hello\");\n            myList2.Add(\"World\");\n            myList2.Add(\"!\");\n\nHashtable and Dictionary[edit]\n\n//Create an initialize Hashtable\nHashtable myHt = new Hashtable() { { \"Hello\", \"World\" }, { \"Key\", \"Value\" } };\n\n//Create Hashtable and add some Key-Value pairs.\nHashtable myHt2 = new Hashtable();\n\tmyHt2.Add(\"Hello\", \"World\");\n\tmyHt2.Add(\"Key\", \"Value\");\n\n\n//Create an initialize Dictionary\nDictionary<string, string> dict = new Dictionary<string, string>() { { \"Hello\", \"World\" }, { \"Key\", \"Value\" } };\n//Create Dictionary and add some Key-Value pairs.\nDictionary<string, string> dict2 = new Dictionary<string, string>();\n\tdict2.Add(\"Hello\", \"World\");\n\tdict2.Add(\"Key\", \"Value\");\n\n", "explain": "The size of ArrayList is dynamically increased as required. ArrayLists are zero-based.\nThe List class is the generic equivalent of the ArrayList class.\nA List is a strongly typed list of objects that can be accessed by index ( zero-based again).\nHashtables represent a collection of key/value pairs that are organized based on the hash code of the key. \nKeys must be unique.\nDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\nvar array = [];\narray.push('abc');\narray.push(123);\narray.push(new MyClass);\nconsole.log( array[2] );\n\nvar obj = {};\nobj['foo'] = 'xyz'; //equivalent to: obj.foo = 'xyz';\nobj['bar'] = new MyClass; //equivalent to: obj.bar = new MyClass;\nobj['1x; ~~:-b'] = 'text'; //no equivalent\nconsole.log(obj['1x; ~~:-b']);\n\n", "explain": ""}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Visual_Basic_.NET", "code": "\nDim toys As New List(Of String)\ntoys.Add(\"Car\")\ntoys.Add(\"Boat\")\ntoys.Add(\"Train\")\n", "explain": ""}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "PHP", "code": "\n\n<?php\n$a = array();\n# add elements \"at the end\"\narray_push($a, 55, 10, 20);\nprint_r($a);\n# using an explicit key\n$a['one'] = 1;\n$a['two'] = 2;\nprint_r($a);\n?>\n\nOutput:\nArray\n(\n    [0] => 55\n    [1] => 10\n    [2] => 20\n)\nArray\n(\n    [0] => 55\n    [1] => 10\n    [2] => 20\n    [one] => 1\n    [two] => 2\n)\n", "explain": "PHP has associative arrays as collection\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Fortran", "code": "\nStandard[edit]\nThe only facility for a collection more organised than a collection of separately-named variables (even if with a system for the names) is the array, which is a collection of items of identical type, indexed by an integer only, definitely not by a text as in say Snobol. Thus  REAL A(36)   !Declares a one-dimensional array A(1), A(2), ... A(36)\n  A(1) = 1           !Assigns a value to the first element.\n  A(2) = 3*A(1) + 5  !The second element gets 8.\n\nWith F90 came a large expansion in the facilities for manipulating arrays. They can now have any lower bound, as in REAL A(-6:+12) and their size can be defined at run time, not just compile time. Further, programmer-defined data aggregates can be defined via the TYPE statement, and arrays of such types can be manipulated. However, type-matching remains rigid: all elements of an array must be of the same type. So,  TYPE(MIXED)           !Name the \"type\".\n  INTEGER COUNTER        !Its content is listed.\n  REAL WEIGHT,DEPTH\n  CHARACTER*28 MARKNAME\n  COMPLEX PATH(6)        !The mixed collection includes an array.\n END TYPE MIXED\n TYPE(MIXED) TEMP,A(6) !Declare some items of that type.\n\n\nCoarray[edit]\n\n", "explain": "would define a collection of variables constituting a \"type\", then a simple variable TEMP whose parts would be accessed via the likes of TEMP.DEPTH or TEMP%DEPTH, and an array of such aggregates where  A(3).PATH(1) = (2.7,3.1) assigns a complex number to the first step of the PATH of the third element of array A. The indexing must be associated with the item having an array aspect, but in pl/i A.PATH(3,1) - or other groupings - would be acceptable.\nThere is a sense in which the CHARACTER type is flexible, in that multiple and different types can be represented as texts so that \"Pi, 3.14159, 4*atan(1)\" might be considered a collection of three items (yet be contained in one, possibly large variable) and be processed in various ways, or one might prepare a battery of variables and arrays referring to each other and disc files in such a way as to present a database containing a collection of information.\nFortran normally uses only ( ) with no appeal to {[ ]} usage even for complex formulae. The co-array concept of the 1990s that was standardised in F2008 extends the syntax to use [k] to specify the k'th \"image\" executing in parallel. Loosely, if X is a variable, manipulated as in normal statements, a reference to X[3] would be to that X value held by the third running \"image\", while X would be in each image a reference to that image's own X value. In other words, there is a collection of X variables.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Go", "code": "\nBuilt in, resizable[edit]\nSlices\nMaps\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a []interface{}\n    a = append(a, 3)\n    a = append(a, \"apples\", \"oranges\")\n    fmt.Println(a)\n}\n\n\nOutput:\n[3 apples oranges]\n\nBuilt in, less conventional[edit]\nGo has arrays that can be used as collections, but arrays are declared with constant size and cannot be resized.\nStrings are a special case of slice.  Strings are immutable and are handled specially in other ways.\nA struct with a number of members might be considered a collection in some sense.\nA buffered channel might be closer to the familiar concept of a collection, as it represents a FIFO queue.  Buffered channels have a fixed size and cannot be resized after creation.\nLibrary[edit]\nThe container directory of the standard library has the packages heap, list, and ring.\nAnything that implements bufio.ReadWriter can be used as a FIFO queue.  This includes bytes.Buffer, which makes a useful in-memory collection.\nThe sort package also contains search functions which perform a binary search on a sorted collection.  For these functions the collection implementation is abstracted through sort.Interface.  It is typically a slice, but could be anything that is indexable with an integer index.\n", "explain": "Built in resizable collections are slices and maps.  The value type for these collections can be any Go type, including interface.  An empty interface can reference an object of any type, providing a kind of polymorphic collection.  Here the variable a is a slice of interface{} objects.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Delphi", "code": "\nArrays[edit]\n\n// Creates and initializes a new integer Array\nvar\n    // Dynamics arrays can be initialized, if it's global variable in declaration scope \n    intArray: TArray<Integer> = [1, 2, 3, 4, 5];\n    intArray2: array of Integer = [1, 2, 3, 4, 5];\n    \n    //Cann't initialize statics arrays in declaration scope\n    intArray3: array [0..4]of Integer;\n    intArray4: array [10..14]of Integer;\n\nprocedure \nvar\n    // Any arrays can't be initialized, if it's local variable in declaration scope\n    intArray5: TArray<Integer>;\nbegin\n  // Dynamics arrays can be full assigned in routine scope\n  intArray := [1,2,3];\n  intArray2 := [1,2,3];\n\n  // Dynamics arrays zero-based  \n  intArray[0] := 1;\n\n  // Dynamics arrays must set size, if it not was initialized before\n  SetLength(intArray,5);\n\n  // Inline dynamics arrays can be created and initialized routine scope\n  // only for version after 10.3 Tokyo\n  var intArray6 := [1, 2, 3];\n  var intArray7: TArray<Integer> := [1, 2, 3];\nend;\n\nList[edit]\n\nvar\n    // TLists can't be initialized or created in declaration scope\n    List1, List2:TList<Integer>;\nbegin\n    List1 := TList<Integer>.Create;\n    List1.Add(1);\n    list1.AddRange([2, 3]);\n    List1.free;\n\n    // TList can be initialized using a class derivative from TEnumerable, like it self\n    List1 := TList<Integer>.Create;    \n    list1.AddRange([1,2, 3]);\n\n    List2 := TList<Integer>.Create(list1);\n    Writeln(List2[2]); // 3\n    List1.free;\n    List2.free;\n    \n\n    // Inline TList can be created in routine scope\n    // only for version after 10.3 Tokyo\n    var List3:= TList<Integer>.Create;\n    List3.Add(2);\n    List3.free;\n\n    var List4: TList<Integer>:= TList<Integer>.Create;\n    List4.free;\nend;\n\nDictionary[edit]\n\n var\n    // TDictionary can't be initialized or created in declaration scope\n    Dic1: TDictionary<string, Integer>;\nbegin\n    Dic1 := TDictionary<string, Integer>.Create;\n    Dic1.Add('one',1);\n    Dic1.free;\n\n    // Inline TDictionary can be created in routine scope\n    // only for version after 10.3 Tokyo\n    var Dic2:= TDictionary<string, Integer>.Create;\n    Dic2.Add('one',1);\n    Dic2.free;\n\n    var Dic3: TDictionary<string, Integer>:= TDictionary<string, Integer>.Create.Create;\n    Dic3.Add('one',1);\n    Dic3.free;\nend;\n\nQueue[edit]\n\nvar\n    Queue1, Queue2: TQueue<Integer>;\n    List1:TList<Integer>;\nbegin\n    Queue1 := TQueue<Integer>.Create;\n    Queue1.Enqueue(1);\n    Queue1.Enqueue(2);\n    Writeln(Queue1.Dequeue); // 1\n    Writeln(Queue1.Dequeue); // 2\n    Queue1.free;\n\n    // TQueue can be initialized using a class derivative from TEnumerable, like TList<T>\n    List1 := TList<Integer>.Create;\n    List1.Add(3);    \n    Queue2:= TQueue<Integer>.Create(List1);\n    Writeln(Queue2.Dequeue); // 3\n    List1.free;\n    Queue2.free;\n\n    // Inline TQueue can be created in routine scope\n    // only for version after 10.3 Tokyo\n    var Queue3 := TQueue<Integer>.Create;\n    Queue3.free;\nend;\n\nStack[edit]\n\nvar\n    Stack1, Stack2: TStack<Integer>;    \n    List1:TList<Integer>;\nbegin\n    Stack1:= TStack<Integer>.Create;\n    Stack1.Push(1);\n    Stack1.Push(2);\n    Writeln(Stack1.Pop); // 2\n    Writeln(Stack1.Pop); // 1\n    Stack1.free;\n    \n    // TStack can be initialized using a class derivative from TEnumerable, like TList<T>\n    List1 := TList<Integer>.Create;\n    List1.Add(3);\n    Stack2:= TStack<Integer>.Create(List1);\n    Writeln(Stack2.Pop); // 3\n    List1.free;\n    Stack2.free;\n\n    // Inline TStack can be created in routine scope\n    // only for version after 10.3 Tokyo\n    var Stack3:= TStack<Integer>.Create;\n    Stack3.free;\nend;\n\nStrings[edit]\n\nvar\n    Str1:String;  // default WideString\n    Str2:WideString;\n    Str3:UnicodeString;\n    Str4:AnsiString;\n    Str5: PChar; //PWideChar is the same\n    Str6: PAnsiChar;\n\n    // Strings can be initialized, if it's global variable in declaration scope \n    Str4: string = 'orange';\nbegin\n    Str1 := 'apple';\n\n    // WideString and AnsiString can be converted implicitly, but in some times can lost information about char\n    Str4 := Str1;\n\n    // PChar is a poiter to string (WideString), must be converted using type cast\n    Str5 := Pchar(Str1);\n    \n    // PChar not must type cast to convert back string\n    Str2 := Str5;\n\n    //In any string, index start in 1 and end on length of string\n    Writeln(Str1[1]); // 'a'\n    Writeln(Str1[5]); // 'e'\n    Writeln(Str1[length(str1)]); // the same above\nend;\n\n\n", "explain": "Arrays are collection of values with memory self managed, can be static (size fixed and index not need start in zero) or dynamic (size scaled by user in run time and away start index in zero). \nLists are objects and need be release from memory after use.\nTDictionary is a generic class.It represents a collection of key/value pairs. Keys must be unique.\nIt need be release from memory after use.\nTQueue is a generic class.It represents a collection of data, stored in fist-in fist-out mode.\nIt need be release from memory after use.\nTStack is a generic class.It represents a collection of data, stored in last-in first-out mode.\nIt need be release from memory after use.\nString are array of chars, start index is one (not zero like almost languages).\nCan store ansichar (one byte char) or widechar (two bytes char), the default for newer versions is widestring;\nSee #Pascal for more info.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Ruby", "code": "\nArray[edit]\n\n# creating an empty array and adding values\na = []              #=> []\na[0] = 1            #=> [1]\na[3] = \"abc\"        #=> [1, nil, nil, \"abc\"]\na << 3.14           #=> [1, nil, nil, \"abc\", 3.14]\n\n# creating an array with the constructor\na = Array.new               #=> []\na = Array.new(3)            #=> [nil, nil, nil]\na = Array.new(3, 0)         #=> [0, 0, 0]\na = Array.new(3){|i| i*2}   #=> [0, 2, 4]\nHash[edit]\n\n# creating an empty hash\nh = {}              #=> {}\nh[\"a\"] = 1          #=> {\"a\"=>1}\nh[\"test\"] = 2.4     #=> {\"a\"=>1, \"test\"=>2.4}\nh[3] = \"Hello\"      #=> {\"a\"=>1, \"test\"=>2.4, 3=>\"Hello\"}\nh = {a:1, test:2.4, World!:\"Hello\"}\n                    #=> {:a=>1, :test=>2.4, :World!=>\"Hello\"}\n\n# creating a hash with the constructor\nh = Hash.new        #=> {}   (default value\u00a0: nil)\np h[1]              #=> nil\nh = Hash.new(0)     #=> {}   (default value\u00a0: 0)\np h[1]              #=> 0\np h                 #=> {}\nh = Hash.new{|hash, key| key.to_s}\n                    #=> {}\np h[123]            #=> \"123\"\np h                 #=> {}\nh = Hash.new{|hash, key| hash[key] = \"foo#{key}\"}\n                    #=> {}\np h[1]              #=> \"foo1\"\np h                 #=> {1=>\"foo1\"}\nStruct[edit]\n\n# creating a struct\n\nPerson = Struct.new(:name, :age, :sex)\n\na = Person.new(\"Peter\", 15, :Man)\np a[0]              #=> \"Peter\"\np a[:age]           #=> 15\np a.sex             #=> :Man\np a.to_a            #=> [\"Peter\", 15, :Man]\np a.to_h            #=> {:name=>\"Peter\", :age=>15, :sex=>:Man}\n\nb = Person.new\np b                 #=> #<struct Person name=nil, age=nil, sex=nil>\nb.name = \"Margaret\"\nb[\"age\"] = 18\nb[-1] = :Woman\np b.values          #=> [\"Margaret\", 18, :Woman]\np b.members         #=> [:name, :age, :sex]\np b.size            #=> 3\n\nc = Person[\"Daniel\", 22, :Man]\np c.to_h            #=> {:name=>\"Daniel\", :age=>22, :sex=>:Man}\nSet[edit]\n\nrequire 'set'\n\n# different ways of creating a set\np s1 = Set[1, 2, 3, 4]          #=> #<Set: {1, 2, 3, 4}>\np s2 = [8, 6, 4, 2].to_set      #=> #<Set: {8, 6, 4, 2}>\np s3 = Set.new(1..4) {|x| x*2}  #=> #<Set: {2, 4, 6, 8}>\n\n# Union\np s1 | s2                       #=> #<Set: {1, 2, 3, 4, 8, 6}>\n# Intersection\np s1 & s2                       #=> #<Set: {4, 2}>\n# Difference\np s1 - s2                       #=> #<Set: {1, 3}>\n\np s1 ^ s2                       #=> #<Set: {8, 6, 1, 3}>\n\np s2 == s3                      #=> true\n\np s1.add(5)                     #=> #<Set: {1, 2, 3, 4, 5}>\np s1 << 0                       #=> #<Set: {1, 2, 3, 4, 5, 0}>\np s1.delete(3)                  #=> #<Set: {1, 2, 4, 5, 0}>\nMatrix and Vector[edit]\n\nrequire 'matrix'\n\n# creating a matrix\np m0 = Matrix.zero(3)       #=> Matrix[[0, 0, 0], [0, 0, 0], [0, 0, 0]]\np m1 = Matrix.identity(3)   #=> Matrix[[1, 0, 0], [0, 1, 0], [0, 0, 1]]\np m2 = Matrix[[11, 12], [21, 22]]\n                            #=> Matrix[[11, 12], [21, 22]]\np m3 = Matrix.build(3) {|row, col| row - col}\n                            #=> Matrix[[0, -1, -2], [1, 0, -1], [2, 1, 0]]\n\np m2[0,0]               #=> 11\np m1 * 5                #=> Matrix[[5, 0, 0], [0, 5, 0], [0, 0, 5]]\np m1 + m3               #=> Matrix[[1, -1, -2], [1, 1, -1], [2, 1, 1]]\np m1 * m3               #=> Matrix[[0, -1, -2], [1, 0, -1], [2, 1, 0]]\n\n# creating a Vector\np v1 = Vector[1,3,5]    #=> Vector[1, 3, 5]\np v2 = Vector[0,1,2]    #=> Vector[0, 1, 2]\np v1[1]                 #=> 3\np v1 * 2                #=> Vector[2, 6, 10]\np v1 + v2               #=> Vector[1, 4, 7]\n\np m1 * v1               #=> Vector[1, 3, 5]\np m3 * v1               #=> Vector[-13, -4, 5]\nOpenStruct[edit]\n\nrequire 'ostruct'\n\n# creating a OpenStruct\nab = OpenStruct.new\np ab                #=> #<OpenStruct>\nab.foo = 25\np ab.foo            #=> 25\nab[:bar] = 2\np ab[\"bar\"]         #=> 2\np ab                #=> #<OpenStruct foo=25, bar=2>\nab.delete_field(\"foo\")\np ab.foo            #=> nil\np ab                #=> #<OpenStruct bar=2>\n\np son = OpenStruct.new({ :name => \"Thomas\", :age => 3 })\n                    #=> #<OpenStruct name=\"Thomas\", age=3>\np son.name          #=> \"Thomas\"\np son[:age]         #=> 3\nson.age += 1\np son.age           #=> 4\nson.items = [\"candy\",\"toy\"]\np son.items         #=> [\"candy\",\"toy\"]\np son               #=> #<OpenStruct name=\"Thomas\", age=4, items=[\"candy\", \"toy\"]\n", "explain": "Arrays are ordered, integer-indexed collections of any object.\nA Hash is a dictionary-like collection of unique keys and their values. Also called associative arrays, they are similar to Arrays, but where an Array uses integers as its index, a Hash allows you to use any object type.\nA Struct is a convenient way to bundle a number of attributes together, using accessor methods, without having to write an explicit class.\nSet implements a collection of unordered values with no duplicates. This is a hybrid of Array's intuitive inter-operation facilities and Hash's fast lookup.\nThe Matrix and Vector class represents a mathematical matrix and vector.\nAn OpenStruct is a data structure, similar to a Hash, that allows the definition of arbitrary attributes with their accompanying values.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Rust", "code": "\n\nStack-allocated collections[edit]\nArray[edit]\n\nlet a = [1u8,2,3,4,5]; // a is of type [u8; 5];\nlet b = [0;256] // Equivalent to `let b = [0,0,0,0,0,0... repeat 256 times]`\nSlice[edit]\n\nlet array = [1,2,3,4,5];\nlet slice = &array[0..2]\nprintln!(\"{:?}\", slice);\n\nOutput:\n[1,2]\nString slice[edit]\n\nHeap-allocated collections[edit]\nVector[edit]\n\nYou want to collect items up to be processed or sent elsewhere later, and don't care about any properties of the actual values being stored.\nYou want a sequence of elements in a particular order, and will only be appending to (or near) the end.\nYou want a stack.\nYou want a resizable array.\nYou want a heap-allocated array.\nlet mut v = Vec::new();\nv.push(1);\nv.push(2);\nv.push(3);\n// Or (mostly) equivalently via a convenient macro in the standard library\nlet v = vec![1,2,3];\nString[edit]\n\nlet x = \"abc\"; // x is of type &str (a borrowed string slice)\nlet s = String::from(x);\n// or alternatively\nlet s = x.to_owned();\nVecDequeue[edit]\n\nYou want a Vec that supports efficient insertion at both ends of the sequence.\nYou want a queue.\nYou want a double-ended queue (deque).\nLinked List[edit]\n\nYou want a Vec or VecDeque of unknown size, and can't tolerate amortization.\nYou want to efficiently split and append lists.\nYou are absolutely certain you really, truly, want a doubly linked list.\nHashMap[edit]\n\nYou want to associate arbitrary keys with an arbitrary value.\nYou want a cache.\nYou want a map, with no extra functionality.\nBTreeMap[edit]\n\nYou're interested in what the smallest or largest key-value pair is.\nYou want to find the largest or smallest key that is smaller or larger than something.\nYou want to be able to get all of the entries in order on-demand.\nYou want a sorted map.\nHashSet/BTreeSet[edit]\n\nYou just want to remember which keys you've seen.\nThere is no meaningful value to associate with your keys.\nYou just want a set.\nBinaryHeap[edit]\n\nYou want to store a bunch of elements, but only ever want to process the \"biggest\" or \"most important\" one at any given time.\nYou want a priority queue.\n", "explain": "Rust has quite a few collections built in.\nArrays ([T]) are stack allocated, fixed size collections of items of the same type.\nSlices (&[T]) are dynamically sized views into contiguous sequences (arrays, vectors, strings)\nString slices are (str) are slices of Unicode characters. Plain strs are almost never seen in Rust. Instead either heap-allocated Strings or borrowed string slices (&str which is basically equivalent to a slice of bytes: &[u8]) are more often used. It should be noted that strings are not indexable as they are UTF-8 (meaning that characters are not necessarily of a fixed size) however iterators can be created over codepoints or graphemes.\nVectors (Vec<T>) are a growable list type. According to the Rust documentation, you want to use a Vector if: \nStrings are growable strings stored as a UTF-8 buffer which are just Vec<u8>s under the hood. Like strs, they are not indexable (for the same reasons) but iterators can be created over the graphemes, codepoints or bytes therein.\nA growable ring buffer. According to the Rust documentation you should use VecDequeue<T> when:\nA doubly-linked list. According to the Rust documentation, you should use it when:\nA hash map implementation which uses linear probing with Robin Hood bucket stealing. According to the Rust documentation, you should use it when: \nA map based on a B-Tree. According to the Rust documentation, you should use it when: \nSet implementations that use an empty tuple () as the value of their respective maps (and implement different methods). They should be used when: \nA priority queue implemented with a binary heap. You should use it when\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "R", "code": "\n\nVectors[edit]\n\nnumeric(5)\n1:10\nc(1, 3, 6, 10, 7 + 8, sqrt(441))\n[1] 0 0 0 0 0\n[1]  1  2  3  4  5  6  7  8  9 10\n[1]  1  3  6 10 15 21\n\n\ninteger(5)\nc(1L, -2L, 99L);\n[1] 0 0 0 0 0\n[1]  1 -2 99\n\n\nlogical(5)\nc(TRUE, FALSE)\n[1] FALSE FALSE FALSE FALSE FALSE\n[1]  TRUE FALSE\n\n\ncharacter(5)\nc(\"abc\", \"defg\", \"\")\n[1] \"\" \"\" \"\" \"\" \"\"\n[1] \"abc\"  \"defg\" \"\"\n\nArrays and Matrices[edit]\n\nmatrix(1:12, nrow=3)\n\narray(1:24, dim=c(2,3,4)) #output not shown\n     [,1] [,2] [,3] [,4]\n[1,]    1    4    7   10\n[2,]    2    5    8   11\n[3,]    3    6    9   12\n\nLists[edit]\n\nlist(a=123, b=\"abc\", TRUE, 1:5, c=list(d=runif(5), e=5+6))\n$a\n[1] 123\n$b\n[1] \"abc\"\n[[3]]\n[1] TRUE\n[[4]]\n[1] 1 2 3 4 5 \n$c\n$c$d\n[1] 0.6013157 0.5011909 0.7106448 0.3882265 0.1274939\n$c$e\n[1] 11\nData Frames[edit]\n\ndata.frame(name=c(\"Alice\", \"Bob\", \"Carol\"), age=c(23, 35, 17))\n   name age\n1 Alice  23\n2   Bob  35\n3 Carol  17\n\n", "explain": "R has several types that can be considered collections.\nNumeric (floating point)\nInteger\nLogical\nCharacter\nThese are essentially vectors with a dimension attribute.  Matrices are just arrays with two dimensions (and a different class).\nLists are collections of other variables (that can include other lists).  \nData frames are like a cross between a list and a matrix.  Each row represents one \"record\", or a collection of variables.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "COBOL", "code": "\n\nWorks with: GnuCOBOL\n       identification division.\n       program-id. collections.\n\n       data division.\n       working-storage section.\n       01 sample-table.\n          05 sample-record occurs 1 to 3 times depending on the-index.\n             10 sample-alpha   pic x(4).\n             10 filler         pic x value \":\".\n             10 sample-number  pic 9(4).\n             10 filler         pic x value space.\n       77 the-index            usage index.\n\n       procedure division.\n       collections-main.\n\n       set the-index to 3\n       move 1234 to sample-number(1)\n       move \"abcd\" to sample-alpha(1)\n\n       move \"test\" to sample-alpha(2)\n\n       move 6789 to sample-number(3)\n       move \"wxyz\" to sample-alpha(3)\n\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(1): \" sample-number(1)\n       display \"sample-record(2): \" sample-record(2)\n       display \"sample-number(3): \" sample-number(3)\n\n      *> abend: out of bounds subscript, -debug turns on bounds check\n       set the-index down by 1\n       display \"sample-table   \u00a0: \" sample-table\n       display \"sample-number(3): \" sample-number(3)\n\n       goback.\n       end program collections.\n\n\nOutput:\nprompt$ cobc -xj collections.cob\nsample-table   \u00a0: abcd:1234 test:0000 wxyz:6789\nsample-number(1): 1234\nsample-record(2): test:0000\nsample-number(3): 6789\nsample-table   \u00a0: abcd:1234 test:0000\nsample-number(3): 6789\n\nprompt$ cobc -xj -debug collections.cob\nsample-table   \u00a0: abcd:1234 test:0000 wxyz:6789\nsample-number(1): 1234\nsample-record(2): test:0000\nsample-number(3): 6789\nsample-table   \u00a0: abcd:1234 test:0000\ncollections.cob: 33: libcob: Subscript of 'sample-number' out of bounds: 3\n\n", "explain": "COBOL is very much a fixed length programming environment.  Hierarchical fixed length records are the main data grouping in many COBOL applications.\nArrays are historically called tables in COBOL literature and are usually defined within a hierarchy.  Tables are defined with the reserved word phrases OCCURS n TIMES, and OCCURS FROM n TO m TIMES DEPENDING ON x, (commonly referred to as ODO for short).\nThis example shows a small record layout inside a very small table.  The last line of the output sample is a debug enabled run-time bounds check abend, caused after the table is decreased in size.  The first run, without bounds check, runs to an erroneous completion; the second, with debug enabled, does not.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Visual_FoxPro", "code": "\n\nLOCAL loColl As Collection, o, a1, a2, a3\na1 = CREATEOBJECT(\"animal\", \"dog\", 4)\na2 = CREATEOBJECT(\"animal\", \"chicken\", 2)\na3 = CREATEOBJECT(\"animal\", \"snake\", 0)\nloColl = NEWOBJECT(\"Collection\")\nloColl.Add(a1)\nloColl.Add(a2)\nloColl.Add(a3)\n\nFOR EACH o IN loColl FOXOBJECT\n   \u00a0? o.Name, o.Legs\nENDFOR\t\n\nDEFINE CLASS animal As Custom\nLegs = 0\n\nPROCEDURE Init(tcName, tnLegs)\nTHIS.Name = tcName\nTHIS.Legs = tnLegs\nENDPROC\n\nENDDEFINE\n", "explain": "Visual FoxPro has a built in Collection class.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Ada", "code": "\n\nanonymous arrays[edit]\n\nprocedure Array_Collection is\n\n   A : array (-3 .. -1) of Integer := (1, 2, 3);\n   \nbegin\n   \n   A (-3) := 3;\n   A (-2) := 2;\n   A (-1) := 1;\n   \nend Array_Collection;\n\narray types[edit]\n\nprocedure Array_Collection is\n\n   type Array_Type is array (1 .. 3) of Integer;\n   A : Array_Type := (1, 2, 3);\n   \nbegin\n   \n   A (1) := 3;\n   A (2) := 2;\n   A (3) := 1;\n   \nend Array_Collection;\n\nunconstrained arrays[edit]\n\nprocedure Array_Collection is\n\n   type Array_Type is array (positive range <>) of Integer; -- may be indexed with any positive\n                                                            -- Integer value\n   A : Array_Type(1 .. 3);  -- creates an array of three integers, indexed from 1 to 3\n   \nbegin\n   \n   A (1) := 3;\n   A (2) := 2;\n   A (3) := 1;\n   \nend Array_Collection;\n\ndoubly linked lists[edit]\nWorks with: Ada 2005\nLibrary: Ada.Containers.Doubly_Linked_Lists\nwith Ada.Containers.Doubly_Linked_Lists;\nuse  Ada.Containers;\n\nprocedure Doubly_Linked_List is\n\n   package DL_List_Pkg is new Doubly_Linked_Lists (Integer);\n   use     DL_List_Pkg;\n   \n   DL_List : List;\n   \nbegin\n   \n   DL_List.Append (1);\n   DL_List.Append (2);\n   DL_List.Append (3);\n   \nend Doubly_Linked_List;\n\nvectors[edit]\nWorks with: Ada 2005\nLibrary: Ada.Containers.Vectors\nwith Ada.Containers.Vectors;\nuse  Ada.Containers;\n\nprocedure Vector_Example is\n\n   package Vector_Pkg is new Vectors (Natural, Integer);\n   use     Vector_Pkg;\n   \n   V : Vector;\n   \nbegin\n   \n   V.Append (1);\n   V.Append (2);\n   V.Append (3);\n   \nend Vector_Example;\n\n", "explain": "Ada 95 and earlier offers arrays.  Ada 2005 adds the Ada.Containers package and its children.  Examples of Doubly Linked Lists and Vectors are given.  \nAda 2005 also provides hashed and ordered Maps and Sets (not shown).\nIn Ada, arrays can be indexed on any range of discrete values.  The example below creates an anonymous array indexed from -3 to -1.  It initializes the three elements of the array at declaration.  Then it reverses their order in the array.  \n\nAnonymous arrays have no type associated with them that is accessible to the programmer.  This means that anonymous arrays cannot be compared in the aggregate to other arrays (even those with the same index structure and contained type) or passed as a parameter to a subprogram.  For these reasons, anonymous arrays are best used as singletons and global constants.\nBecause of the limitations of anonymous arrays noted above, arrays are more typically defined in Ada as array types, as in the example below.\nDynamic arrays can be created through the use of pointers to unconstrained arrays.  While an unconstrained array's index type is defined, it does not have a pre-defined range of indices - they are specified at the time of declaration or, as would be the case in a dynamic array, at the time the memory for the array is allocated.  The creation of a dynamic array is not shown here, but below is an example declaration of an unconstrained array in Ada.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Julia", "code": "\n\njulia> collection = []\n0-element Array{Any,1}\n\njulia> push!(collection, 1,2,4,7)\n4-element Array{Any,1}:\n 1\n 2\n 4\n 7\n\n", "explain": "Julia has a wide variety of collections, including vectors, matrices, lists of Any data type, associative arrays, and bitsets. \nThere is a slicing notation and list comprehensions similar to those in Python, but the base index is by default 1, not 0. In Julia, a collection is a just variable length array:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\n\nimport java.util.PriorityQueue\n\nfun main(args: Array<String>) {\n    // generic array\n    val ga = arrayOf(1, 2, 3)\n    println(ga.joinToString(prefix = \"[\", postfix = \"]\"))\n\n    // specialized array (one for each primitive type)\n    val da = doubleArrayOf(4.0, 5.0, 6.0)\n    println(da.joinToString(prefix = \"[\", postfix = \"]\"))\n\n    // immutable list\n    val li = listOf<Byte>(7, 8, 9)\n    println(li)\n\n    // mutable list\n    val ml = mutableListOf<Short>()\n    ml.add(10); ml.add(11); ml.add(12)\n    println(ml)\n\n    // immutable map\n    val hm = mapOf('a' to 97, 'b' to 98, 'c' to 99)\n    println(hm)\n\n    // mutable map\n    val mm = mutableMapOf<Char, Int>()\n    mm.put('d', 100); mm.put('e', 101); mm.put('f', 102)\n    println(mm)\n\n    // immutable set (duplicates not allowed)\n    val se = setOf(1, 2, 3)\n    println(se)\n\n    // mutable set (duplicates not allowed)\n    val ms = mutableSetOf<Long>()\n    ms.add(4L); ms.add(5L); ms.add(6L)\n    println(ms)\n\n    // priority queue (imported from Java)\n    val pq = PriorityQueue<String>()\n    pq.add(\"First\"); pq.add(\"Second\"); pq.add(\"Third\")\n    println(pq)\n}\n\n\nOutput:\n[1, 2, 3]\n[4.0, 5.0, 6.0]\n[7, 8, 9]\n[10, 11, 12]\n{a=97, b=98, c=99}\n{d=100, e=101, f=102}\n[1, 2, 3]\n[4, 5, 6]\n[First, Second, Third]\n\n", "explain": "Apart from arrays whose length is immutable but content mutable, Kotlin distinguishes between mutable and immutable collection types in its standard library. Examples of each are given below. Where possible, the type parameter(s) of generic collection types are inferred from the content.\nIn addition, Kotlin can also access other types of Java collection such as LinkedList, Queue, Deque and Stack by simply importing the appropriate type:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Perl", "code": "\n\nuse strict;\nmy @c = (); # create an empty \"array\" collection\n\n# fill it\npush @c, 10, 11, 12;\npush @c, 65;\n# print it\nprint join(\" \",@c) . \"\\n\";\n\n# create an empty hash\nmy %h = ();\n# add some pair\n$h{'one'} = 1;\n$h{'two'} = 2;\n# print it\nforeach my $i ( keys %h ) {\n    print $i . \" -> \" . $h{$i} . \"\\n\";\n}\n", "explain": "Perl has array and hashes.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\n\na set: a collection of unique elements (like mathematical set). Possible operations on a set are not shown;\na counted set (also known as bag): each elements have a counter that says how many time that element appears;\na dictionary: pairs key-value.\n\n#import <Foundation/Foundation.h>\n\nvoid show_collection(id coll)\n{\n  for ( id el in coll )\n  {\n    if ( [coll isKindOfClass: [NSCountedSet class]] ) {\n      NSLog(@\"%@ appears %lu times\", el, [coll countForObject: el]);\n    } else if ( [coll isKindOfClass: [NSDictionary class]] ) {\n      NSLog(@\"%@ ->\u00a0%@\", el, coll[el]);\n    } else {\n      NSLog(@\"%@\", el);\n    }\n  }\n  printf(\"\\n\");\n}\n\nint main()\n{\n  @autoreleasepool {\n  \n    // create an empty set\n    NSMutableSet *set = [[NSMutableSet alloc] init];\n    // populate it\n    [set addObject: @\"one\"];\n    [set addObject: @10];\n    [set addObjectsFromArray: @[@\"one\", @20, @10, @\"two\"] ];\n    // let's show it\n    show_collection(set);\n\n    // create an empty counted set (a bag)\n    NSCountedSet *cset = [[NSCountedSet alloc] init];\n    // populate it\n    [cset addObject: @\"one\"];\n    [cset addObject: @\"one\"];\n    [cset addObject: @\"two\"];\n    // show it\n    show_collection(cset);\n\n    // create a dictionary\n    NSMutableDictionary *dict = [[NSMutableDictionary alloc] init];\n    // populate it\n    dict[@\"four\"] = @4;\n    dict[@\"eight\"] = @8;\n    // show it\n    show_collection(dict);\n\n  }\n  return EXIT_SUCCESS;\n}\n\nOutput: (stripped the left-sided log info)\n\ntwo\n20\n10\none\n\ntwo appears 1 times\none appears 2 times\n\neight -> 8\nfour -> 4\n", "explain": "OpenStep (and derivates like GNUstep and Cocoa) has several collection classes; here we show\nArrays (indexed by an integer), which are also collections, are not shown here.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Prolog", "code": "\n\n% create a list\nL = [a,b,c,d],\n \n% prepend to the list\nL2 = [before_a|L],\n \n% append to the list\nappend(L2, ['Hello'], L3),\n\n% delete from list\nexclude(=(b), L3, L4).\n\nL = [a, b, c, d],\nL2 = [before_a, a, b, c, d],\nL3 = [before_a, a, b, c, d, 'Hello'],\nL4 = [before_a, a, c, d, 'Hello'].\n\n\n% create an empty dict call 'point'\nD1 = point{},\n\n% add a value\t\nD2 = D1.put(x, 20).put(y, 30).put(z, 20),\n\n% update a value\nD3 = D2.put([x=25]),\n\n% remove a value\ndel_dict(z, D3, _, D4),\n\n% access a value randomly\nformat('x = ~w, y = ~w~n', [D4.x, D4.y]).\n\nx = 25, y = 30\nD1 = point{},\nD2 = point{x:20, y:30, z:20},\nD3 = point{x:25, y:30, z:20},\nD4 = point{x:25, y:30}.\n\n", "explain": "Traditionally Prolog supports only lists.\nOutput:\nSWI-Prolog supports some other collection types as built in libraries, the most notable is the Dict.\nDicts can be accessed using a special notation and can be added and removed from in an immutable way.\nOutput:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Lua", "code": "\n\ncollection = {0, '1'}\nprint(collection[1]) -- prints 0\n\ncollection = {[\"foo\"] = 0, [\"bar\"] = '1'} -- a collection of key/value pairs\nprint(collection[\"foo\"]) -- prints 0\nprint(collection.foo) -- syntactic sugar, also prints 0\n\ncollection = {0, '1', [\"foo\"] = 0, [\"bar\"] = '1'}\n\n\n", "explain": "Lua has only one type of collection, the table. But Lua's table has features of both, traditional arrays and hash maps (dictionaries). You can even mix both within one table. Note, that the numeric indices of Lua's table start at 1, not at 0 as with most other languages.\nIt is idiomatic in Lua to represent a Set data structure with a table of keys to the true value.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Scala", "code": "\nLibrary: ScalaScala has in his run-time library a rich set set of collections. Due to use of traits is this library easily realized and consistent. Collections provide the same operations on any type where it makes sense to do so. For instance, a string is conceptually a sequence of characters. Consequently, in Scala collections, strings support all sequence operations. The same holds for arrays.\n\nThese examples were taken from a Scala REPL session. The second lines are the REPL responces.Windows PowerShell\nCopyright (C) 2012 Microsoft Corporation. All rights reserved.\n\nPS C:\\Users\\FransAdm> scala\nWelcome to Scala version 2.10.1 (Java HotSpot(TM) 64-Bit Server VM, Java 1.7.0_25).\nType in expressions to have them evaluated.\nType :help for more information.\n\nscala> // Immutable collections do not and cannot change the instantiated object\n\nscala> // Lets start with Lists\n\nscala> val list = Nil // Empty List\nlist: scala.collection.immutable.Nil.type = List()\n\nscala> val list2 = List(\"one\", \"two\") // List with two elements (Strings)\nlist2: List[String] = List(one, two)\n\nscala> val list3 = 3\u00a0:: list2 // prepend 3 to list2, using a special operator\nlist3: List[Any] = List(3, one, two)\n\nscala> // The result was a mixture with a Int and Strings, so the common superclass Any is used.\n\nscala> // Let test the Set collection\n\nscala> val set = Set.empty[Char] // Empty Set of Char type\nset: scala.collection.immutable.Set[Char] = Set()\n\nscala> val set1 = set + 'c' // add an element\nset1: scala.collection.immutable.Set[Char] = Set(c)\n\nscala> val set2 = set + 'a' + 'c' + 'c' // try to add another and  the same element twice\nset2: scala.collection.immutable.Set[Char] = Set(a, c)\n\nscala> // Let's look at the most universal map: TrieMap (Cache-aware lock-free concurrent hash trie)\n\nscala> val capital = collection.concurrent.TrieMap(\"US\" -> \"Washington\", \"France\" -> \"Paris\") // This map is mutable\ncapital: scala.collection.concurrent.TrieMap[String,String] = TrieMap(US -> Washington, France -> Paris)\n\nscala> capital - \"France\" // This is only an expression, does not modify the map itself\nres0: scala.collection.concurrent.TrieMap[String,String] = TrieMap(US -> Washington)\n\nscala> capital += (\"Tokio\" -> \"Japan\") // Adding an element, object is changed - not the val capital\nres1: capital.type = TrieMap(US -> Washington, Tokio -> Japan, France -> Paris)\n\nscala> capital // Check what we have sofar\nres2: scala.collection.concurrent.TrieMap[String,String] = TrieMap(US -> Washington, Tokio -> Japan, France -> Paris)\n\nscala>  val queue = new scala.collection.mutable.Queue[String]\nqueue: scala.collection.mutable.Queue[String] = Queue()\n\nscala> queue += \"first\"\nres17: queue.type = Queue(\"first\")\n\nscala> queue += \"second\"\nres19: queue.type = Queue(\"first\", \"second\")\n\nscala>\n    import collection.concurrent.TrieMap\n\n    // super concurrent mutable hashmap\n    val map = TrieMap(\"Amsterdam\" -> \"Netherlands\",\n      \"New York\" -> \"USA\",\n      \"Heemstede\" -> \"Netherlands\")\n\n    map(\"Laussanne\") = \"Switzerland\" // 2 Ways of updating\n    map += (\"Tokio\" -> \"Japan\")\n\n    assert(map(\"New York\") == \"USA\")\n    assert(!map.isDefinedAt(\"Gent\")) // isDefinedAt is false\n    assert(map.isDefinedAt(\"Laussanne\")) // true\n\n    val hash = new TrieMap[Int, Int]\n    hash(1) = 2\n    hash += (1 -> 2) // same as hash(1) = 2\n    hash += (3 -> 4, 5 -> 6, 44 -> 99)\n    hash(44) // 99\n    hash.contains(33) // false\n    hash.isDefinedAt(33) // same as contains\n    hash.contains(44) // true\n    // iterate over key/value\n    //    hash.foreach { case (key, val) => println(  \"key \" + e._1 + \" value \" + e._2) } // e is a 2 element Tuple\n    // same with for syntax\n    for ((k, v) <- hash) println(\"key \" + k + \" value \" + v)\n    //    // items in map where the key is greater than 3\n        map.filter { k => k._1 > 3 } //  Map(5 -> 6, 44 -> 99)\n    //    // same with for syntax\n        for ((k, v) <- map; if k > 3) yield (k, v)\n", "explain": "The collections are available in two flavors; immutable (these have no methods to modify or update) and mutable. With these properties they are also available in concurrent version for parallel processing. Switching between sequential and parallel can easily be done by adding a .seq or .par post-fix. \n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "D", "code": "\n\nint[3] array;\narray[0] = 5;\n// array.length = 4; // compile-time error\n\n\nint[] array;\narray ~= 5; // append 5\narray.length = 3;\narray[3] = 17; // runtime error: out of bounds. check removed in release mode.\narray = [2, 17, 3];\nwritefln(array.sort); // 2, 3, 17\n\n\nint[int] array;\n// array ~= 5; // it doesn't work that way!\narray[5] = 17;\narray[6] = 20;\n// prints \"[5, 6]\" -> \"[17, 20]\" - although the order is not specified.\nwritefln(array.keys, \" -> \", array.values);\nassert(5 in array); // returns a pointer, by the way\nif (auto ptr = 6 in array) writefln(*ptr); // 20\n\n", "explain": "D has static arrays.\nD has dynamic arrays.\nD has associative arrays.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Haskell", "code": "\nData.List[edit]\n\n[1, 2, 3, 4, 5]\n\n\n1 : [2, 3, 4]\n\n\n[1, 2] ++ [3, 4]\n\n\nconcat [[1, 2], [3, 4], [5, 6, 7]]\n\nData.Array[edit]\n\nimport Data.Array (Array, listArray, Ix, (!))\n\ntriples :: Array Int (Char, String, String)\ntriples =\n  listArray (0, 11) $\n  zip3\n    \"\u9f20\u725b\u864e\u5154\u9f8d\u86c7\u99ac\u7f8a\u7334\u9e21\u72d7\u8c6c\" -- \u751f\u8096 shengxiao \u2013 symbolic animals\n    (words \"sh\u01d4 ni\u00fa h\u01d4 t\u00f9 l\u00f3ng sh\u00e9 m\u01ce y\u00e1ng h\u00f3u j\u012b g\u01d2u zh\u016b\")\n    (words \"rat ox tiger rabbit dragon snake horse goat monkey rooster dog pig\")\n\nindexedItem\n  :: Ix i\n  => Array i (Char, String, String) -> i -> String\nindexedItem a n =\n  let (c, w, w1) = a ! n\n  in c : unwords [\"\\t\", w, w1]\n\nmain :: IO ()\nmain = (putStrLn . unlines) $ indexedItem triples <$> [2, 4, 6]\n\n\nOutput:\n\u864e     h\u01d4 tiger\n\u9f8d     l\u00f3ng dragon\n\u99ac     m\u01ce horse\nData.Map[edit]\n\nimport qualified Data.Map as M\nimport Data.Maybe (isJust)\n\nmapSample :: M.Map String Int\nmapSample =\n  M.fromList\n    [ (\"alpha\", 1)\n    , (\"beta\", 2)\n    , (\"gamma\", 3)\n    , (\"delta\", 4)\n    , (\"epsilon\", 5)\n    , (\"zeta\", 6)\n    ]\n\nmaybeValue :: String -> Maybe Int\nmaybeValue = flip M.lookup mapSample\n\nmain :: IO ()\nmain =\n  print $ sequence $ filter isJust (maybeValue <$> [\"beta\", \"delta\", \"zeta\"])\n\n\nOutput:\nJust [2,4,6]\nData.Set[edit]\n\nimport qualified Data.Set as S\n\nsetA :: S.Set String\nsetA = S.fromList [\"alpha\", \"beta\", \"gamma\", \"delta\", \"epsilon\"]\n\nsetB :: S.Set String\nsetB = S.fromList [\"delta\", \"epsilon\", \"zeta\", \"eta\", \"theta\"]\n\nmain :: IO ()\nmain = (print . S.toList) (S.intersection setA setB)\n\n\nOutput:\n[\"delta\",\"epsilon\"]\n", "explain": "The list is typically the first collection type to be encountered in textbooks, but other types may tend to be more efficient, or more flexibly accessed; see the Data hierarchy of GHC's standard library. New collection types may be defined with data.\nTo prepend a single element to a list, use the : operator:\nTo concatenate two lists, use ++:\nTo concatenate a whole list of lists, use concat:\nFaster retrieval by index:\nFlexible key-value indexing and efficient retrieval:\nRepertoire of efficient set operations:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Scheme", "code": "\nlist[edit]\n(list obj ...)\n\n(display (list 1 2 3))\n(newline)\n(display (list))\n(newline)\n\nOutput:\n(1 2 3)\n()\ncons[edit]\n(cons obj lst)\n\n(display (cons 0 (list 1 2 3)))\n(newline)\n\nOutput:\n(0 1 2 3)\nappend[edit]\n(append lst ...)\n\n(display (append (list 1 2 3) (list 4 5 6)))\n(newline)\n\nOutput:\n(1 2 3 4 5 6)\n", "explain": "returns a newly allocated list of its arguments.\nExample:\nreturns a newly allocated list consisting of obj prepended to lst.\nExample:\nreturns a newly allocated list consisting of the elements of lst followed by the elements of the other lists.\nExample:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Apex", "code": "\nLists[edit]\n\n// Create an empty list of String\nList<String> my_list = new List<String>();\n// Create a nested list\nList<List<Set<Integer>>> my_list_2 = new List<List<Set<Integer>>>();\n\nList<Integer> myList = new List<Integer>(); // Define a new list\nmyList.add(47);                    // Adds a second element of value 47 to the end \n                                       // of the list\nInteger i = myList.get(0);                   // Retrieves the element at index 0\nmyList.set(0, 1);                           // Adds the integer 1 to the list at index 0\nmyList.clear();                    // Removes all elements from the list\n\nString[] colors = new List<String>();\nList<String> colors = new String[1];\ncolors[0] = 'Green';\nSets[edit]\n\nSet<String> s1 = new Set<String>{'a', 'b + c'}; // Defines a new set with two elements\nSet<String> s2 = new Set<String>(s1); // Defines a new set that contains the \n                                     // elements of the set created in the previous step\n\nSet<Integer> s = new Set<Integer>(); // Define a new set\ns.add(1);                            // Add an element to the set\nSystem.assert(s.contains(1));        // Assert that the set contains an element\ns.remove(1);                         // Remove the element from the set\n\nUnlike Java, Apex developers do not need to reference the algorithm that is used to implement a set in their declarations (for example, HashSet or TreeSet). Apex uses a hash structure for all sets.\nA set is an unordered collection\u2014you can\u2019t access a set element at a specific index. You can only iterate over set elements.\nThe iteration order of set elements is deterministic, so you can rely on the order being the same in each subsequent execution of the same code.\nMaps[edit]\n\nMap<String, String> country_currencies = new Map<String, String>();\nMap<ID, Set<String>> m = new Map<ID, Set<String>>();\nMap<String, String> MyStrings = new Map<String, String>{'a' => 'b', 'c' => 'd'.toUpperCase()};\n\nMap<Integer, String> m = new Map<Integer, String>(); // Define a new map\nm.put(1, 'First entry');                  // Insert a new key-value pair in the map\nm.put(2, 'Second entry');                  // Insert a new key-value pair in the map\nSystem.assert(m.containsKey(1));  // Assert that the map contains a key\nString value = m.get(2);               // Retrieve a value, given a particular key\nSystem.assertEquals('Second entry', value);\nSet<Integer> s = m.keySet();       // Return a set that contains all of the keys in the map\n\nUnlike Java, Apex developers do not need to reference the algorithm that is used to implement a map in their declarations (for example, HashMap or TreeMap). Apex uses a hash structure for all maps.\nThe iteration order of map elements is deterministic. You can rely on the order being the same in each subsequent execution of the same code. However, we recommend to always access map elements by key.\nA map key can hold the null value.\nAdding a map entry with a key that matches an existing key in the map overwrites the existing entry with that key with the new entry.\n\nUniqueness of map keys of user-defined types is determined by the equals and hashCode methods, which you provide in your classes. Uniqueness of keys of all other non-primitive types, such as sObject keys, is determined by comparing the objects\u2019 field values.\nA Map object is serializable into JSON only if it uses one of the following data types as a key.\n\n", "explain": "A list is an ordered collection of elements that are distinguished by their indices\nCreating Lists\nAccess elements in a list\nUsing Array Notation for One-dimensional list\nA set is an unordered collection of elements that do not contain any duplicates.\nDefining a set:\nAccess elements in a set:\nNote the following limitations on sets:\nA map is a collection of key-value pairs where each unique key maps to a single value\nDeclaring a map:\nAccessing a Map:\nMap Considerations:\nMap keys of type String are case-sensitive. Two keys that differ only by the case are considered unique and have corresponding distinct Map entries.Subsequently, the Map methods, including put, get, containsKey, and remove treat these keys as distinct.\nBoolean, Date, DateTime, Decimal, Double, Enum, Id, Integer, Long, String, Time\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "PowerShell", "code": "\n\nArray[edit]\n\n# Create an Array by separating the elements with commas:\n$array = \"one\", 2, \"three\", 4\n\n# Using explicit syntax:\n$array = @(\"one\", 2, \"three\", 4)\n\n# Send the values back into individual variables:\n$var1, $var2, $var3, $var4 = $array\n\n# An array of several integer ([int]) values:\n$array = 0, 1, 2, 3, 4, 5, 6, 7\n\n# Using the range operator (..):\n$array = 0..7\n\n# Strongly typed:\n[int[]] $stronglyTypedArray = 1, 2, 4, 8, 16, 32, 64, 128\n\n# An empty array:\n$array = @()\n\n# An array with a single element:\n$array = @(\"one\")\n\n# I suppose this would be a jagged array:\n$jaggedArray = @((11, 12, 13),\n                 (21, 22, 23),\n                 (31, 32, 33))\n\n$jaggedArray | Format-Wide {$_} -Column 3 -Force\n\n$jaggedArray[1][1] # returns 22\n\n# A Multi-dimensional array:\n$multiArray = New-Object -TypeName \"System.Object[,]\" -ArgumentList 6,6\n\nfor ($i = 0; $i -lt 6; $i++)\n{ \n    for ($j = 0; $j -lt 6; $j++)\n    { \n        $multiArray[$i,$j] = ($i + 1) * 10 + ($j + 1)\n    }\n}\n\n$multiArray | Format-Wide {$_} -Column 6 -Force\n\n$multiArray[2,2] # returns 33\nHash Table[edit]\n\n# An empty Hash Table:\n$hash = @{}\n\n# A Hash table populated with some values:\n$nfcCentralDivision = @{\n    Packers = \"Green Bay\"\n    Bears   = \"Chicago\"\n    Lions   = \"Detroit\"\n}\n\n# Add items to a Hash Table:\n$nfcCentralDivision.Add(\"Vikings\",\"Minnesota\")\n$nfcCentralDivision.Add(\"Buccaneers\",\"Tampa Bay\")\n\n# Remove an item from a Hash Table:\n$nfcCentralDivision.Remove(\"Buccaneers\")\n\n# Searching for items\n$nfcCentralDivision.ContainsKey(\"Packers\")\n$nfcCentralDivision.ContainsValue(\"Green Bay\")\n\n# A bad value...\n$hash1 = @{\n    One = 1\n    Two = 3\n}\n\n# Edit an item in a Hash Table:\n$hash1.Set_Item(\"Two\",2)\n\n# Combine Hash Tables:\n\n$hash2 = @{\n    Three = 3\n    Four  = 4\n}\n\n$hash1 + $hash2\n\n# Using the ([ordered]) accelerator the items in the Hash Table retain the order in which they were input:\n$nfcCentralDivision = [ordered]@{\n    Bears   = \"Chicago\"\n    Lions   = \"Detroit\"\n    Packers = \"Green Bay\"\n    Vikings = \"Minnesota\"\n}\nOther Collection Types[edit]\n\n$list = New-Object -TypeName System.Collections.ArrayList -ArgumentList 1,2,3\n\n# or...\n\n$list = [System.Collections.ArrayList]@(1,2,3)\n\n\n$list.Add(4) | Out-Null\n$list.RemoveAt(2)\n", "explain": "The most common collection types in PowerShell are arrays and hash tables.\nThe array index is zero based.\nHash tables come in two varieties: normal and ordered, where of course, the order of entry is retained.\nPowerShell is a .NET language so all of the collection types in .NET are available to PowerShell.  The most commonly used would probably be [System.Collections.ArrayList].\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Logo", "code": "\n\nmembers of a list: [one two three]\nitems in an array: {one two three}\ncharacters in a word: \"123\n", "explain": "Logo has a list-like protocol (first, butfirst, etc.) which works on three different data types:\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "ABAP", "code": "\nREPORT z_test_rosetta_collection.\n\nCLASS lcl_collection DEFINITION CREATE PUBLIC.\n\n  PUBLIC SECTION.\n    METHODS: start.\nENDCLASS.\n\nCLASS lcl_collection IMPLEMENTATION.\n  METHOD start.\n    DATA(itab) = VALUE int4_table( ( 1 ) ( 2 ) ( 3 ) ).\n\n    cl_demo_output=>display( itab ).\n  ENDMETHOD.\nENDCLASS.\n\nSTART-OF-SELECTION.\n  NEW lcl_collection( )->start( ).\n\n", "explain": ""}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\ndef emptyList = []\nassert emptyList.isEmpty() : \"These are not the items you're looking for\"\nassert emptyList.size() == 0 : \"Empty list has size 0\"\nassert ! emptyList : \"Empty list evaluates as boolean 'false'\"\n\ndef initializedList = [ 1, \"b\", java.awt.Color.BLUE ]\nassert initializedList.size() == 3\nassert initializedList : \"Non-empty list evaluates as boolean 'true'\"\nassert initializedList[2] == java.awt.Color.BLUE : \"referencing a single element (zero-based indexing)\"\nassert initializedList[-1] == java.awt.Color.BLUE : \"referencing a single element (reverse indexing of last element)\"\n\ndef combinedList = initializedList + [ \"more stuff\", \"even more stuff\" ]\nassert combinedList.size() == 5\nassert combinedList[1..3] == [\"b\", java.awt.Color.BLUE, \"more stuff\"] : \"referencing a range of elements\"\n\ncombinedList << \"even more stuff\"\nassert combinedList.size() == 6\nassert combinedList[-1..-3] == \\\n        [\"even more stuff\", \"even more stuff\", \"more stuff\"] \\\n                : \"reverse referencing last 3 elements\"\nprintln ([combinedList: combinedList])\n\n\nOutput:\n[combinedList:[1, b, java.awt.Color[r=0,g=0,b=255], more stuff, even more stuff, even more stuff]]\n\ndef emptyMap = [:]\nassert emptyMap.isEmpty() : \"These are not the items you're looking for\"\nassert emptyMap.size() == 0 : \"Empty map has size 0\"\nassert ! emptyMap : \"Empty map evaluates as boolean 'false'\"\n\ndef initializedMap = [ count: 1, initial: \"B\", eyes: java.awt.Color.BLUE ]\nassert initializedMap.size() == 3\nassert initializedMap : \"Non-empty map evaluates as boolean 'true'\"\nassert initializedMap[\"eyes\"] == java.awt.Color.BLUE : \"referencing a single element (array syntax)\"\nassert initializedMap.eyes == java.awt.Color.BLUE : \"referencing a single element (member syntax)\"\nassert initializedMap.height == null : \\\n        \"references to non-existant keys generally evaluate to null (implementation dependent)\"\n\ndef combinedMap = initializedMap \\\n        + [hair: java.awt.Color.BLACK, birthdate: Date.parse(\"yyyy-MM-dd\", \"1960-05-17\") ]\nassert combinedMap.size() == 5\n\ncombinedMap[\"weight\"] = 185        // array syntax\ncombinedMap.lastName = \"Smith\"     // member syntax\ncombinedMap << [firstName: \"Joe\"]  // entry syntax\nassert combinedMap.size() == 8\nassert combinedMap.keySet().containsAll(\n        [\"lastName\", \"count\", \"eyes\", \"hair\", \"weight\", \"initial\", \"firstName\", \"birthdate\"])\nprintln ([combinedMap: combinedMap])\n\n\nOutput:\n[combinedMap:[count:1, initial:B, eyes:java.awt.Color[r=0,g=0,b=255], hair:java.awt.Color[r=0,g=0,b=0], birthdate:Tue May 17 00:00:00 CDT 1960, weight:185, lastName:Smith, firstName:Joe]]\n\ndef emptySet = new HashSet()\nassert emptySet.isEmpty() : \"These are not the items you're looking for\"\nassert emptySet.size() == 0 : \"Empty set has size 0\"\nassert ! emptySet : \"Empty set evaluates as boolean 'false'\"\n\ndef initializedSet = new HashSet([ 1, \"b\", java.awt.Color.BLUE ])\nassert initializedSet.size() == 3\nassert initializedSet : \"Non-empty list evaluates as boolean 'true'\"\n//assert initializedSet[2] == java.awt.Color.BLUE  // SYNTAX ERROR!!! No indexing of set elements!\n\ndef combinedSet = initializedSet + new HashSet([ \"more stuff\", \"even more stuff\" ])\nassert combinedSet.size() == 5\n\ncombinedSet << \"even more stuff\"\nassert combinedSet.size() == 5 : \"No duplicate elements allowed!\"\nprintln ([combinedSet: combinedSet])\n\n\nOutput:\n[combinedSet:[1, java.awt.Color[r=0,g=0,b=255], b, even more stuff, more stuff]]\n", "explain": "Lists are just variable-length, integer-indexed arrays.\nMaps are just variable-length, associative arrays. They are not necessarily order preserving.\nSets are unique, not indexed at all (contents can only be discovered by traversal), and are not necessarily order preserving. There is no particular special language support for denoting a Set, although a Set may be initialized from a List, and Sets share many of the same operations and methods that are available in Lists.\n"}, {"task_name": "Collections", "task_url": "https://rosettacode.org/wiki/Collections", "task_cat": "Data Structures", "lang": "AWK", "code": "\n\na[0]=\"hello\"\n\n\nsplit(\"one two three\",a)\n\n\nprint a[0]\n\n\nfor(i in a) print i\":\"a[i]\n\n", "explain": "In awk, the closest thing to collections would be arrays. They are created when needed at assignment\nor by splitting a string\nSingle elements are accessible with the bracket notation, like in C:\nOne can iterate over the elements of an array:\n"}]