[{"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Python", "code": "\nimport calendar\ncalendar.isleap(year)\n\ndef is_leap_year(year):\n    return not year\u00a0% (4 if year\u00a0% 100 else 400)\n\nimport datetime\n\ndef is_leap_year(year):\n    try:\n        datetime.date(year, 2, 29)\n    except ValueError:\n        return False\n    return True\n", "explain": "or\nAsking for forgiveness instead of permission:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "C", "code": "\n#include <stdio.h>\n\nint is_leap_year(unsigned year)\n{\n    return !(year & (year % 100 ? 3 : 15));\n}\n\nint main(void)\n{\n    const unsigned test_case[] = {\n        1900, 1994, 1996, 1997, 2000, 2024, 2025, 2026, 2100\n    };\n    const unsigned n = sizeof test_case / sizeof test_case[0];\n\n    for (unsigned i = 0; i != n; ++i) {\n        unsigned year = test_case[i];\n        printf(\"%u is %sa leap year.\\n\", year, is_leap_year(year) ? \"\" : \"not \");\n    }\n    return 0;\n}\n\n\nOutput:\n1900 is not a leap year.\n1994 is not a leap year.\n1996 is a leap year.\n1997 is not a leap year.\n2000 is a leap year.\n2024 is a leap year.\n2025 is not a leap year.\n2026 is not a leap year.\n2100 is not a leap year.\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "C++", "code": "\n\ng++ -std=c++11 leap_year.cpp\n\n#include <iostream>\n\nbool is_leap_year(int year) {\n  return year % 4 == 0 && (year % 100 != 0 || year % 400 == 0);\n}\n\nint main() {\n  for (auto year : {1900, 1994, 1996, 1997, 2000}) {\n    std::cout << year << (is_leap_year(year) ? \" is\" : \" is not\") << \" a leap year.\\n\";\n  }\n}\n\n\nOutput:\n1900 is not a leap year.\n1994 is not a leap year.\n1996 is a leap year.\n1997 is not a leap year.\n2000 is a leap year.\n\n", "explain": "Uses C++11. Compile with\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Java", "code": "\n\nimport java.util.GregorianCalendar;\nimport java.text.MessageFormat;\n\npublic class Leapyear{\n        public static void main(String[] argv){\n                int[] yrs = {1800,1900,1994,1998,1999,2000,2001,2004,2100};\n                GregorianCalendar cal = new GregorianCalendar();\n                for(int year : yrs){\n                        System.err.println(MessageFormat.format(\"The year {0,number,#} is leaper: {1} / {2}.\",\n                                                                 year, cal.isLeapYear(year), isLeapYear(year)));\n                }\n\n        }\n        public static boolean isLeapYear(int year){\n                return (year % 100 == 0) ? (year % 400 == 0) : (year % 4 == 0);\n        }\n}\n\n\nOutput:\nThe year 1800 is leaper: false / false.\nThe year 1900 is leaper: false / false.\nThe year 1994 is leaper: false / false.\nThe year 1998 is leaper: false / false.\nThe year 1999 is leaper: false / false.\nThe year 2000 is leaper: true / true.\nThe year 2001 is leaper: false / false.\nThe year 2004 is leaper: true / true.\nThe year 2100 is leaper: false / false.\nWorks with: Java version 8\nimport java.time.Year;\n\npublic class IsLeap {\n\n    public static void main(String[] args) {\n        System.out.println(Year.isLeap(2004));\n    }\n}\n\n", "explain": "By default, java.util.GregorianCalendar switches from Julian calendar to Gregorian calendar at 15 October 1582.\nThe code below uses both the GregorianCalendar class \nand the algorithm from the wiki. \nBoth values are printed in the output.\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var year in new[] { 1900, 1994, 1996, DateTime.Now.Year })\n        {\n            Console.WriteLine(\"{0} is {1}a leap year.\",\n                              year,\n                              DateTime.IsLeapYear(year) ? string.Empty : \"not \");\n        }\n    }\n}\n\n\nOutput:\n1900 is not a leap year.\n1994 is not a leap year.\n1996 is a leap year.\n2010 is not a leap year.\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "JavaScript", "code": "\nvar isLeapYear = function (year) { return (year % 100 === 0) ? (year % 400 === 0) : (year % 4 === 0); };\n\n\n// Month values start at 0, so 1 is for February\nvar isLeapYear = function (year) { return new Date(year, 1, 29).getDate() === 29; };\n\n", "explain": "Or, by setting the day to the 29th and checking if the day remains\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "PHP", "code": "\n<?php\nfunction isLeapYear($year) {\n    if ($year\u00a0% 100 == 0) {\n        return ($year\u00a0% 400 == 0);\n    }\n    return ($year\u00a0% 4 == 0);\n}\n\n<?php\nfunction isLeapYear($year) {\n    return (date('L', mktime(0, 0, 0, 2, 1, $year)) === '1')\n}\n", "explain": "With date('L'):\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Fortran", "code": "\nprogram leap\n implicit none\n\n write(*,*) leap_year([1900, 1996, 1997, 2000])\n\n contains\n\n\tpure elemental function leap_year(y) result(is_leap)\n\timplicit none\n\tlogical :: is_leap\n\tinteger,intent(in) :: y\t\n\t\n\tis_leap = (mod(y,4)==0 .and. .not. mod(y,100)==0) .or. (mod(y,400)==0)\t\n\t\n\tend function leap_year\n\t\nend program leap\n\n\nOutput:\n  F T F T \n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Go", "code": "\nfunc isLeap(year int) bool {\n    return year%400 == 0 || year%4 == 0 && year%100 != 0\n}\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "MIPS_Assembly", "code": "\n\nIsLeap:\tandi $a1, $a0, 3 #a0 is year to test\n\tbnez $a1 NotLeap\n\tli $a1, 100\n\tdiv $a0, $a1\n\tmfhi $a1\n\tbnez $a1, Leap\n\tmflo $a1\n\tandi $a1, $a1, 3\n\tbnez $a1, NotLeap\nLeap:\tli $v0, 1\n\tjr $ra\nNotLeap:li $v0, 0\n\tjr $ra\n", "explain": "Pass year in a0, returns boolean in v0.\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "X86_Assembly", "code": "\n\n    align 16\n; Input year as signed dword in EAX    \nIsLeapYear:\n    test eax,11b\n    jz .4\n    retn\u00a0; 75%\u00a0: ZF=0, not a leap year\n.4:\n    mov ecx,100\n    cdq\n    idiv ecx\n    test edx,edx\n    jz .100\n    cmp edx,edx\n    retn\u00a0; 24%\u00a0: ZF=1, leap year\n.100:\n    test eax,11b\n    retn\u00a0; 1%\u00a0: ZF=?, leap year if EAX%400=0\n", "explain": "Using FASM syntax. Leaf function fits nicely into your program.\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Ruby", "code": "\nrequire 'date'\n\nDate.leap?(year)\n\n", "explain": "The leap? method is aliased as gregorian_leap? And yes, there is a julian_leap? method.\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Rust", "code": "\nfn is_leap(year: i32) -> bool {\n    let factor = |x| year\u00a0% x == 0;\n    factor(4) && (!factor(100) || factor(400))\n}\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Swift", "code": "\nfunc isLeapYear(year: Int) -> Bool {\n    return year.isMultiple(of: 100)\u00a0? year.isMultiple(of: 400)\u00a0: year.isMultiple(of: 4)\n}\n\n[1900, 1994, 1996, 1997, 2000].forEach { year in\n    print(\"\\(year): \\(isLeapYear(year: year)\u00a0? \"YES\"\u00a0: \"NO\")\")\n}\n\nOutput:\n1900: NO\n1994: NO\n1996: YES\n1997: NO\n2000: YES\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "R", "code": "\nisLeapYear <- function(year) {\n    ifelse(year%%100==0, year%%400==0, year%%4==0)\n}\n\nfor (y in c(1900, 1994, 1996, 1997, 2000)) {\n  cat(y, ifelse(isLeapYear(y), \"is\", \"isn't\"), \"a leap year.\\n\")\n}\n\nOutput:\n1900 isn't a leap year.\n1994 isn't a leap year.\n1996 is a leap year.\n1997 isn't a leap year.\n2000 is a leap year.\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. leap-year.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  examples VALUE \"19001994199619972000\".\n           03  year PIC 9(4) OCCURS 5 TIMES\n               INDEXED BY year-index.\n\n       01  remainders.\n           03 400-rem   PIC 9(4).\n           03 100-rem   PIC 9(4).\n           03 4-rem     PIC 9(4).\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING year-index FROM 1 BY 1 UNTIL 5 < year-index\n               MOVE FUNCTION MOD(year (year-index), 400) TO 400-rem\n               MOVE FUNCTION MOD(year (year-index), 100) TO 100-rem\n               MOVE FUNCTION MOD(year (year-index), 4) TO 4-rem\n\n               IF 400-rem = 0 OR ((100-rem NOT = 0) AND 4-rem = 0)\n                   DISPLAY year (year-index) \" is a leap year.\"\n               ELSE\n                   DISPLAY year (year-index) \" is not a leap year.\"\n               END-IF\n           END-PERFORM\n\n           GOBACK\n           .\n\n\n       program-id. leap-yr.\n           *> Given a year, where 1601 <= year <= 9999\n           *> Determine if the year is a leap year\n       data division.\n       working-storage section.\n       1 input-year pic 9999.\n       1 binary.\n        2 int-date pic 9(8).\n        2 cal-mo-day pic 9(4).\n       procedure division.\n           display \"Enter calendar year (1601 thru 9999): \"\n               with no advancing\n           accept input-year\n           if input-year >= 1601 and <= 9999\n           then\n                   *> if the 60th day of a year is Feb 29\n                   *> then the year is a leap year\n               compute int-date = function integer-of-day\n                   ( input-year * 1000 + 60 )\n               compute cal-mo-day = function mod (\n                   (function date-of-integer ( int-date )) 10000 )\n               display \"Year \" input-year space with no advancing\n               if cal-mo-day = 229\n                   display \"is a leap year\"\n               else\n                   display \"is NOT a leap year\"\n               end-if\n           else\n               display \"Input date is not within range\"\n           end-if\n           stop run\n           .\n       end program leap-yr.\n\n\nOutput:\nEnter calendar year (1601 thru 9999): 2016\nYear 2016 is a leap year\nEnter calendar year (1601 thru 9999): 2017\nYear 2017 is NOT a leap year\nEnter calendar year (1601 thru 9999): 2100\nYear 2100 is NOT a leap year\nEnter calendar year (1601 thru 9999): 2400\nYear 2400 is a leap year\nEnter calendar year (1601 thru 9999): 3000\nYear 3000 is NOT a leap year\nEnter calendar year (1601 thru 9999): 4000\nYear 4000 is a leap year\n\n", "explain": "Using Date Intrinsic Functions\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Ada", "code": "\n-- Incomplete code, just a sniplet to do the task. Can be used in any package or method.\n-- Adjust the type of Year if you use a different one.\nfunction Is_Leap_Year (Year : Integer) return Boolean is\nbegin\n   if Year rem 100 = 0 then\n      return Year rem 400 = 0;\n   else\n      return Year rem 4 = 0;\n   end if;\nend Is_Leap_Year;\n\n\n-- An enhanced, more efficient version:\n-- This version only does the 2 bit comparison (rem 4) if false.\n-- It then checks rem 16 (a 4 bit comparison), and only if those are not\n-- conclusive, calls rem 100, which is the most expensive operation.\n-- I failed to be convinced of the accuracy of the algorithm at first,\n-- so I rephrased it below.\n-- FYI: 400 is evenly divisible by 16 whereas 100,200 and 300 are not. Ergo, the\n-- set of integers evenly divisible by 16 and 100 are all evenly divisible by 400.\n-- 1. If a year is not divisible by 4 => not a leap year. Skip other checks.\n-- 2. If a year is evenly divisible by 16, it is either evenly divisible by 400 or \n--    not evenly divisible by 100 => leap year. Skip further checks.\n-- 3. If a year evenly divisible by 100 => not a leap year. \n-- 4. Otherwise a leap year. \n \nfunction Is_Leap_Year (Year : Integer) return Boolean is\nbegin\n   return (Year rem 4 = 0) and then ((Year rem 16 = 0) or else (Year rem 100 /= 0));\nend Is_Leap_Year;\n\n\n\n-- To improve speed a bit more, use with\npragma Inline (Is_Leap_Year);\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nisleap(yr::Integer) = yr % 4 == 0 && (yr < 1582 || yr % 400 == 0 || yr % 100 != 0)\n\n@assert all(isleap, [2400, 2012, 2000, 1600, 1500, 1400])\n@assert !any(isleap, [2100, 2014, 1900, 1800, 1700, 1499])\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Kotlin", "code": "\nfun isLeapYear(year: Int) = year % 400 == 0 || (year % 100 != 0 && year % 4 == 0)\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Perl", "code": "\nsub isleap {\n    my $year = shift;\n    if ($year\u00a0% 100 == 0) {\n        return ($year\u00a0% 400 == 0);\n    }\n    return ($year\u00a0% 4 == 0);\n}\n\nsub isleap { not $_[0]\u00a0% ($_[0]\u00a0% 100\u00a0? 4\u00a0: 400) }\n\nuse Date::Manip;\nprint Date_LeapYear(2000);\n\nuse Date::Manip::Base;\nmy $dmb = new Date::Manip::Base;\nprint $dmb->leapyear(2000);\n\nuse DateTime;\nmy $date = DateTime->new(year => 2000);\nprint $date->is_leap_year();\n", "explain": "Or more concisely:\nAlternatively, using functions/methods from CPAN modules:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog\nleap_year(L)\u00a0:-\n\tpartition(is_leap_year, L, LIn, LOut),\n\tformat('leap years\u00a0: ~w~n', [LIn]),\n\tformat('not leap years\u00a0: ~w~n', [LOut]).\n\nis_leap_year(Year)\u00a0:-\n\tR4 is Year mod 4,\n\tR100 is Year mod 100,\n\tR400 is Year mod 400,\n\t(   (R4 = 0, R100 \\= 0); R400 = 0).\n\nOutput:\n\u00a0?- leap_year([1900,1994,1996,1997,2000 ]).\nleap years\u00a0: [1996,2000]\nnot leap years\u00a0: [1900,1994,1997]\nL = [1900,1994,1996,1997,2000].\n\n?- findall(Y, (between(1990,2030,Y),day_of_the_year(date(Y,12,31),366)), L).\nL = [1992, 1996, 2000, 2004, 2008, 2012, 2016, 2020, 2024, 2028].\n", "explain": "There is an handy builtin that simplifies a lot, ending up in a simple query:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Lua", "code": "\nfunction isLeapYear(year)\n  return year%4==0 and (year%100~=0 or year%400==0)\nend\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Scala", "code": "\nJDK 7 (not recommended)[edit]\n\n//use Java's calendar class\nnew java.util.GregorianCalendar().isLeapYear(year)\nJDK 8[edit]\n\njava.time.LocalDate.ofYearDay(year, 1).isLeapYear()\nImplementation[edit]\n\ndef isLeapYear(year:Int)=if (year%100==0) year%400==0 else year%4==0;\n\n//or use Java's calendar class\ndef isLeapYear(year:Int):Boolean = {\n  val c = new java.util.GregorianCalendar\n  c.setGregorianChange(new java.util.Date(Long.MinValue))\n  c.isLeapYear(year)\n}\n", "explain": "By default, java.util.GregorianCalendar switches from Julian calendar to Gregorian calendar at 15 October 1582.\nUsing JSR-310 java.time.\nFor proleptic Gregorian calendar:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Dart", "code": "\nclass Leap {\n  bool leapYear(num year) {\n    return (year % 400 == 0) || (( year % 100 != 0) && (year % 4 == 0));\n\n  bool isLeapYear(int year) =>\n    (year % 4 == 0) && ((year % 100 != 0) || (year % 400 == 0));\n  // Source: https://api.flutter.dev/flutter/quiver.time/isLeapYear.html\n  }\n}\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "D", "code": "\nimport std.algorithm;\n\nbool leapYear(in uint y) pure nothrow {\n    return (y % 4) == 0 && (y % 100 || (y % 400) == 0);\n}\n\nvoid main() {\n    auto good = [1600, 1660, 1724, 1788, 1848, 1912, 1972, 2032,\n                 2092, 2156, 2220, 2280, 2344, 2348];\n    auto bad =  [1698, 1699, 1700, 1750, 1800, 1810, 1900, 1901,\n                 1973, 2100, 2107, 2200, 2203, 2289];\n    assert(filter!leapYear(bad ~ good).equal(good));\n}\n\n\nimport std.datetime;\n\nvoid main() {\n    assert(yearIsLeapYear(1724));\n    assert(!yearIsLeapYear(1973));\n    assert(!Date(1900, 1, 1).isLeapYear);\n    assert(DateTime(2000, 1, 1).isLeapYear);\n}\n\n", "explain": "\nUsing the datetime library:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Haskell", "code": "\n\nimport Data.List\nimport Control.Monad\nimport Control.Arrow\n\nleaptext x b | b = show x ++ \" is a leap year\"\n\t     | otherwise = show x ++  \" is not a leap year\"\n\nisleapsf j | 0==j`mod`100 = 0 == j`mod`400\n\t   | otherwise    = 0 == j`mod`4\n\n\nisleap = foldl1 ((&&).not).flip map [400, 100, 4]. ((0==).).mod\n\n\n*Main> mapM_ (putStrLn. (ap leaptext isleap)) [1900,1994,1996,1997,2000]\n1900 is not a leap year\n1994 is not a leap year\n1996 is a leap year\n1997 is not a leap year\n2000 is a leap year\n\n\nimport Test.HUnit\n\nisLeapYear::Int->Bool\nisLeapYear y\n  | mod y 400 == 0 = True\n  | mod y 100 == 0 = False\n  | mod y 4 == 0 = True\n  | otherwise = False \n\ntests = TestList[TestCase $ assertEqual \"4 is a leap year\" True $ isLeapYear 4\n                ,TestCase $ assertEqual \"1 is not a leap year\" False $ isLeapYear 1\n                ,TestCase $ assertEqual \"64 is a leap year\" True $ isLeapYear 64\n                ,TestCase $ assertEqual \"2000 is a leap year\" True $ isLeapYear 2000\n                ,TestCase $ assertEqual \"1900 is not a leap year\" False $ isLeapYear 1900]\n\n", "explain": "Simple version\nAlgorithmic\nExample using isleap\nTDD version\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Scheme", "code": "\n(define (leap-year? n)\n(apply (lambda (a b c) (or a (and (not b) c)))\n       (map (lambda (m) (zero? (remainder n m)))\n            '(400 100 4))))\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "PowerShell", "code": "\n$Year = 2016\n[System.DateTime]::IsLeapYear( $Year )\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Logo", "code": "\nto multiple? :n :d\n  output equal? 0 modulo :n :d\nend\nto leapyear? :y\n  output ifelse multiple? :y 100 [multiple? :y 400] [multiple? :y 4]\nend\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "F#", "code": "\nlet isLeapYear = System.DateTime.IsLeapYear\nassert isLeapYear 1996\nassert isLeapYear 2000\nassert not (isLeapYear 2001)\nassert not (isLeapYear 1900)\n\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Groovy", "code": "\n\n(1900..2012).findAll {new GregorianCalendar().isLeapYear(it)}.each {println it}\n\n\nOutput:\n1904\n1908\n1912\n1916\n1920\n1924\n1928\n1932\n1936\n1940\n1944\n1948\n1952\n1956\n1960\n1964\n1968\n1972\n1976\n1980\n1984\n1988\n1992\n1996\n2000\n2004\n2008\n2012\n", "explain": "Solution:\n"}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "RPG", "code": "\nWorks with: RPGIII\n     C*0N01N02N03Factor1+++OpcdeFactor2+++ResultLenDHHiLoEqComments+++++++\n     C           *ENTRY    PLIST\n     C                     PARM           YEAR    40       input (year)\n     C                     PARM           ISLEAP  1        output (Y/N)\n     C*\n     C                     MOVE 'N'       ISLEAP\n     C           YEAR      CABLE1752      DONE             not Gregorian\n     C*\n     C           YEAR      DIV  4         RESULT  40\n     C                     MVR            REMAIN  40\n     C           REMAIN    CABNE0         DONE\n     C*\n     C* If we got here, year is divisible by 4.\n     C           YEAR      DIV  100       RESULT\n     C                     MVR            REMAIN\n     C           REMAIN    CABNE0         LEAPYR\n     C*\n     C* If we got here, year is divisible by 100.\n     C           YEAR      DIV  400       RESULT\n     C                     MVR            REMAIN\n     C           REMAIN    CABNE0         DONE\n     C*\n     C           LEAPYR    TAG\n     C                     MOVE 'Y'       ISLEAP\n     C*\n     C           DONE      TAG\n     C                     SETON                     LR\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "Zig", "code": "\npub fn isLeapYear(year: anytype) bool {\n  const inttype = @TypeOf(year);\n  if (@typeInfo(inttype)\u00a0!= .Int) {\n    @compileError(\"non-integer type used on leap year: \" ++ @typeName(inttype));\n  }\n  return (if (@mod(year, @as(inttype, 100)) == 0)\n    @mod(year, @as(inttype, 400)) == 0\n  else\n    @mod(year, @as(inttype, 4)) == 0);\n}\n", "explain": ""}, {"task_name": "Leap year", "task_url": "https://rosettacode.org/wiki/Leap_year", "task_cat": "Date and time", "lang": "AWK", "code": "\nfunction leapyear( year )\n{\n    if ( year % 100 == 0 )\n        return ( year % 400 == 0 )\n    else\n        return ( year % 4 == 0 )            \n}\n\n", "explain": ""}]