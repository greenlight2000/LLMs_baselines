[{"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "C", "code": "\nLibrary: SQLite\n#include <stdio.h>\n#include <stdlib.h>\n#include <sqlite3.h>\n\nconst char *code = \n\"CREATE TABLE address (\\n\"\n\"       addrID\t\tINTEGER PRIMARY KEY AUTOINCREMENT,\\n\"\n\"\taddrStreet\tTEXT NOT NULL,\\n\"\n\"\taddrCity\tTEXT NOT NULL,\\n\"\n\"\taddrState\tTEXT NOT NULL,\\n\"\n\"\taddrZIP\t\tTEXT NOT NULL)\\n\" ;\n\nint main()\n{\n  sqlite3 *db = NULL;\n  char *errmsg;\n  \n  if ( sqlite3_open(\"address.db\", &db) == SQLITE_OK ) {\n    if ( sqlite3_exec(db, code, NULL, NULL,  &errmsg) != SQLITE_OK ) {\n      fprintf(stderr, errmsg);\n      sqlite3_free(errmsg);\n      sqlite3_close(db);\n      exit(EXIT_FAILURE);\n    }\n    sqlite3_close(db);\n  } else {\n    fprintf(stderr, \"cannot open db...\\n\");\n    sqlite3_close(db);\n    exit(EXIT_FAILURE);\n  }\n  return EXIT_SUCCESS;\n}\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"database/sql\"\n    \"fmt\"\n    \"log\"\n\n    _ \"github.com/mattn/go-sqlite3\"\n)\n\nfunc main() {\n    // task req: show database connection\n    db, err := sql.Open(\"sqlite3\", \"rc.db\")\n    if err != nil {\n        log.Print(err)\n        return\n    }\n    defer db.Close()\n    // task req: create table with typed fields, including a unique id\n    _, err = db.Exec(`create table addr (\n        id     int unique,\n        street text,\n        city   text,\n        state  text,\n        zip    text\n    )`)\n    if err != nil {\n        log.Print(err)\n        return\n    }\n    // show output:  query the created field names and types\n    rows, err := db.Query(`pragma table_info(addr)`)\n    if err != nil {\n        log.Print(err)\n        return\n    }\n    var field, storage string\n    var ignore sql.RawBytes\n    for rows.Next() {\n        err = rows.Scan(&ignore, &field, &storage, &ignore, &ignore, &ignore)\n        if err != nil {\n            log.Print(err)\n            return\n        }\n        fmt.Println(field, storage)\n    }\n}\n\n\nOutput:\nid int\nstreet text\ncity text\nstate text\nzip text\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Ruby", "code": "\nWith PStore[edit]\n\nrequire 'pstore'\nrequire 'set'\n\nAddress = Struct.new :id, :street, :city, :state, :zip\n\ndb = PStore.new(\"addresses.pstore\")\ndb.transaction do\n  db[:next] ||= 0       # Next available Address#id\n  db[:ids] ||= Set[]    # Set of all ids in db\nend\n\n\ndb.transaction do\n  id = (db[:next] += 1)\n  db[id] = Address.new(id,\n                       \"1600 Pennsylvania Avenue NW\",\n                       \"Washington\", \"DC\", 20500)\n  db[:ids].add id\nend\n\nWith SQLite[edit]\nTranslation of: Python\nLibrary: sqlite3-ruby\nrequire 'sqlite3'\n\ndb = SQLite3::Database.new(':memory:')\ndb.execute(\"\n    CREATE TABLE address (\n        addrID     INTEGER PRIMARY KEY AUTOINCREMENT,\n        addrStreet TEXT NOT NULL,\n        addrCity   TEXT NOT NULL,\n        addrState  TEXT NOT NULL,\n        addrZIP    TEXT NOT NULL\n    )\n\")\n\n", "explain": "PStore implements a persistent key store with transactions. This is a NoSQL database. Each transaction reads the entire database into memory, and then writes it again, so PStore is not good for large databases.\nTo put an Address inside this PStore:\n"}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Visual_FoxPro", "code": "\nCLOSE DATABASES ALL\nCREATE DATABASE usdata.dbc\nSET NULL OFF\nCREATE TABLE address.dbf ;\n(id I AUTOINC NEXTVALUE 1 STEP 1 PRIMARY KEY COLLATE \"Machine\", ;\n street V(50), city V(25), state C(2), zipcode C(10))\nCLOSE DATABASES ALL\n*!* To use \nCLOSE DATABASES ALL \nOPEN DATABASE usdata.dbc\nUSE address.dbf SHARED\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nusing SQLite\n\ndb = SQLite.DB()\nSQLite.execute!(db, \"\"\"\\\n\tCREATE TABLE address (\n\taddrID\t\tINTEGER PRIMARY KEY AUTOINCREMENT,\n\taddrStreet\tTEXT NOT NULL,\n\taddrCity\tTEXT NOT NULL,\n\taddrState\tTEXT NOT NULL,\n\taddrZIP\t\tTEXT NOT NULL)\n\t\"\"\")\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "SAS", "code": "\nPROC SQL;\nCREATE TABLE ADDRESS \n(\nADDRID CHAR(8)\n,STREET CHAR(50) \n,CITY CHAR(25)\n,STATE CHAR(2)\n,ZIP  CHAR(20)\n) \n;QUIT;\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Kotlin", "code": "\n\n// Version 1.2.41\n\nimport java.io.File\nimport java.io.RandomAccessFile\n\nfun String.toFixedLength(len: Int) = this.padEnd(len).substring(0, len)\n\nclass Address(\n    var name: String,\n    var street: String = \"\",\n    var city: String = \"\",\n    var state: String = \"\",\n    var zipCode: String = \"\",\n    val autoId: Boolean = true\n) {\n    var id = 0L\n        private set\n\n    init {\n        if (autoId) id = ++nextId\n    }\n\n    companion object {\n        private var nextId = 0L\n\n        const val RECORD_LENGTH = 127  // including 2 bytes for UTF string length\n\n        fun readRecord(file: File, id: Long): Address {\n            val raf = RandomAccessFile(file, \"r\")\n            val seekPoint = (id - 1) * RECORD_LENGTH\n            raf.use {\n                it.seek(seekPoint)\n                val id2 = it.readLong()\n                if (id != id2) {\n                    println(\"Database is corrupt\")\n                    System.exit(1)\n                }\n                val text    = it.readUTF()\n                val name    = text.substring(0, 30).trimEnd()\n                val street  = text.substring(30, 80).trimEnd()\n                val city    = text.substring(80, 105).trimEnd()\n                val state   = text.substring(105, 107)\n                val zipCode = text.substring(107).trimEnd()\n                val a = Address(name, street, city, state, zipCode, false)\n                a.id = id\n                return a\n            }\n        }\n    }\n\n    override fun toString() =\n        \"Id      \u00a0: ${this.id}\\n\" +\n        \"Name    \u00a0: $name\\n\" +\n        \"Street  \u00a0: $street\\n\" +\n        \"City    \u00a0: $city\\n\" +\n        \"State   \u00a0: $state\\n\" +\n        \"Zip Code\u00a0: $zipCode\\n\"\n\n    fun writeRecord(file: File) {\n        val raf = RandomAccessFile(file, \"rw\")\n        val text =\n            name.toFixedLength(30) +\n            street.toFixedLength(50) +\n            city.toFixedLength(25) +\n            state +\n            zipCode.toFixedLength(10)\n        val seekPoint = (id - 1) * RECORD_LENGTH\n        raf.use {\n            it.seek(seekPoint)\n            it.writeLong(id)\n            it.writeUTF(text)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val file = File(\"addresses.dat\")\n    val addresses = listOf(\n        Address(\"FSF Inc.\", \"51 Franklin Street\", \"Boston\", \"MA\", \"02110-1301\"),\n        Address(\"The White House\", \"The Oval Office, 1600 Pennsylvania Avenue NW\", \"Washington\", \"DC\", \"20500\")\n    )\n    // write the address records to the file\n    addresses.forEach { it.writeRecord(file) }\n\n    // now read them back in reverse order and print them out\n    for (i in 2 downTo 1) {\n        println(Address.readRecord(file, i.toLong()))\n    }\n}\n\n\nOutput:\nId      \u00a0: 2\nName    \u00a0: The White House\nStreet  \u00a0: The Oval Office, 1600 Pennsylvania Avenue NW\nCity    \u00a0: Washington\nState   \u00a0: DC\nZip Code\u00a0: 20500\n\nId      \u00a0: 1\nName    \u00a0: FSF Inc.\nStreet  \u00a0: 51 Franklin Street\nCity    \u00a0: Boston\nState   \u00a0: MA\nZip Code\u00a0: 02110-1301\n\n", "explain": "Rather than use an external database, we use the built-in RandomAccessFile class for his task. The data used is the same as for the REXX entry.\n"}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Perl", "code": "\nuse DBI;\n\nmy $db = DBI->connect('DBI:mysql:database:server','login','password');\n\nmy $statment = <<EOF;\nCREATE TABLE `Address` (\n    `addrID`       int(11)     NOT NULL   auto_increment,\n    `addrStreet`   varchar(50) NOT NULL   default '',\n    `addrCity`     varchar(25) NOT NULL   default '',\n    `addrState`    char(2)     NOT NULL   default '',\n    `addrZIP`      char(10)    NOT NULL   default '',\n    PRIMARY KEY (`addrID`)\n);\nEOF\n\nmy $exec = $db->prepare($statment);\n$exec->execute;\n\n\n", "explain": "This example uses mysql, but DBI supports a extensive list of database drivers. See dbi.perl.org for more info.\n"}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Lua", "code": "\n\n-- Import module\nlocal sql = require(\"ljsqlite3\")\n\n-- Open connection to database file\nlocal conn = sql.open(\"address.sqlite\")\n\n-- Create address table unless it already exists\nconn:exec[[\nCREATE TABLE IF NOT EXISTS address(\n  id INTEGER PRIMARY KEY AUTOINCREMENT,\n  street TEXT NOT NULL, \n  city TEXT NOT NULL, \n  state TEXT NOT NULL, \n  zip TEXT NOT NULL)\n]]\n\n-- Explicitly close connection\nconn:close()\n\n", "explain": "Using LJSQLite3 - compatible with LuaJIT and supplied in the ULua distribution.\n"}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Haskell", "code": "\nTranslation of: Python\nLibrary: SQLite\nLibrary: sqlite-simple\n{-# LANGUAGE OverloadedStrings #-}\n\nimport Database.SQLite.Simple\n\nmain = do\n     db <- open \"postal.db\"\n     execute_ db \"\\ \n     \\CREATE TABLE address (\\\n        \\addrID     INTEGER PRIMARY KEY AUTOINCREMENT, \\\n        \\addrStreet TEXT NOT NULL, \\\n        \\addrCity   TEXT NOT NULL, \\\n        \\addrState  TEXT NOT NULL, \\\n        \\addrZIP    TEXT NOT NULL  \\\n     \\)\"\n     close db\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "VBScript", "code": "\nOption Explicit\n\nDim objFSO, DBSource \n\nSet objFSO = CreateObject(\"Scripting.FileSystemObject\")\n\nDBSource = objFSO.GetParentFolderName(WScript.ScriptFullName) & \"\\postal_address.accdb\"\n\nWith CreateObject(\"ADODB.Connection\")\n\t.Open \"Provider=Microsoft.ACE.OLEDB.12.0;Data Source=\" & DBSource\n\t.Execute \"CREATE TABLE ADDRESS (STREET VARCHAR(30) NOT NULL,\" &_\n\t\t\t\"CITY VARCHAR(30) NOT NULL, STATE CHAR(2) NOT NULL,ZIP CHAR(5) NOT NULL)\"\n\t.Close\nEnd With\n\n", "explain": ""}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "Scheme", "code": "\nLibrary: SQLite\n\n(use sql-de-lite)\n\n(define *db* (open-database \"addresses\"))\n\n(exec ; create and run the SQL statement\n  (sql *db*\n       \"CREATE TABLE address (\n        addrID     INTEGER PRIMARY KEY AUTOINCREMENT,\n        addrStreet TEXT NOT NULL,\n        addrCity   TEXT NOT NULL,\n        addrState  TEXT NOT NULL,\n        addrZIP    TEXT NOT NULL\n    )\"\n))\n\n(close-database *db*) ; finally, close database\n\n", "explain": "This example works with Chicken Scheme, using its sql-de-lite library:\n"}, {"task_name": "Table creation/Postal addresses", "task_url": "https://rosettacode.org/wiki/Table_creation/Postal_addresses", "task_cat": "Database operations", "lang": "AWK", "code": "\nSQLite3[edit]\n\n#!/bin/sh -f\nawk '\nBEGIN {\n    print \"Creating table...\"\n    dbExec(\"address.db\", \"create table address (street, city, state, zip);\")\n    print \"Done.\"\n    exit\n}\n\nfunction dbExec(db, qry,      result) {\n    dbMakeQuery(db, qry) | getline result\n    dbErrorCheck(result)\n}\n\nfunction dbMakeQuery(db, qry,      q) {\n    q = dbEscapeQuery(qry) \";\"\n    return \"echo \\\"\" q \"\\\" | sqlite3 \" db\n}\n\nfunction dbEscapeQuery(qry,      q) {\n    q = qry\n    gsub(/\"/, \"\\\\\\\"\", q)\n    return q\n}\n\nfunction dbErrorCheck(res) {\n    if (res ~ \"SQL error\") {\n        print res\n        exit\n    }\n}\n\n'\n\n", "explain": "This version uses the AWK pipe, 'getline' function, and the sqlite3 command line program. \n"}]