[{"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Python", "code": "\nfrom math import radians, sin, cos, sqrt, asin\n\n\ndef haversine(lat1, lon1, lat2, lon2):\n    R = 6372.8  # Earth radius in kilometers\n\n    dLat = radians(lat2 - lat1)\n    dLon = radians(lon2 - lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n\n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n\n    return R * c\n\n>>> haversine(36.12, -86.67, 33.94, -118.40)\n2887.2599506071106\n>>>\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define R 6371\n#define TO_RAD (3.1415926536 / 180)\ndouble dist(double th1, double ph1, double th2, double ph2)\n{\n\tdouble dx, dy, dz;\n\tph1 -= ph2;\n\tph1 *= TO_RAD, th1 *= TO_RAD, th2 *= TO_RAD;\n\n\tdz = sin(th1) - sin(th2);\n\tdx = cos(ph1) * cos(th1) - cos(th2);\n\tdy = sin(ph1) * cos(th1);\n\treturn asin(sqrt(dx * dx + dy * dy + dz * dz) / 2) * 2 * R;\n}\n\nint main()\n{\n\tdouble d = dist(36.12, -86.67, 33.94, -118.4);\n\t/* Americans don't know kilometers */\n\tprintf(\"dist:\u00a0%.1f km (%.1f mi.)\\n\", d, d / 1.609344);\n\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "C++", "code": "\n#define _USE_MATH_DEFINES\n\n#include <math.h>\n#include <iostream>\n\nconst static double EarthRadiusKm = 6372.8;\n\ninline double DegreeToRadian(double angle)\n{\n\treturn M_PI * angle / 180.0;\n}\n\nclass Coordinate\n{\npublic:\n\tCoordinate(double latitude ,double longitude):myLatitude(latitude), myLongitude(longitude)\n\t{}\n\n\tdouble Latitude() const\n\t{\n\t\treturn myLatitude;\n\t}\n\n\tdouble Longitude() const\n\t{\n\t\treturn myLongitude;\n\t}\n\nprivate:\n\n\tdouble myLatitude;\n\tdouble myLongitude;\n};\n\ndouble HaversineDistance(const Coordinate& p1, const Coordinate& p2)\n{\n\tdouble latRad1 = DegreeToRadian(p1.Latitude());\n\tdouble latRad2 = DegreeToRadian(p2.Latitude());\n\tdouble lonRad1 = DegreeToRadian(p1.Longitude());\n\tdouble lonRad2 = DegreeToRadian(p2.Longitude());\n\n\tdouble diffLa = latRad2 - latRad1;\n\tdouble doffLo = lonRad2 - lonRad1;\n\n\tdouble computation = asin(sqrt(sin(diffLa / 2) * sin(diffLa / 2) + cos(latRad1) * cos(latRad2) * sin(doffLo / 2) * sin(doffLo / 2)));\n\treturn 2 * EarthRadiusKm * computation;\n}\n\nint main()\n{\n\tCoordinate c1(36.12, -86.67);\n\tCoordinate c2(33.94, -118.4);\n\n\tstd::cout << \"Distance = \" << HaversineDistance(c1, c2) << std::endl;\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Java", "code": "\nTranslation of: Groovy\npublic class Haversine {\n    public static final double R = 6372.8; // In kilometers\n\n    public static double haversine(double lat1, double lon1, double lat2, double lon2) {\n        lat1 = Math.toRadians(lat1);\n        lat2 = Math.toRadians(lat2);\n        double dLat = lat2 - lat1;\n        double dLon = Math.toRadians(lon2 - lon1);\n\n        double a = Math.pow(Math.sin(dLat / 2), 2) + Math.pow(Math.sin(dLon / 2), 2) * Math.cos(lat1) * Math.cos(lat2);\n        double c = 2 * Math.asin(Math.sqrt(a));\n        return R * c;\n    }\n\n    public static void main(String[] args) {\n        System.out.println(haversine(36.12, -86.67, 33.94, -118.40));\n    }\n}\n\n\nOutput:\n2887.2599506071106\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "C#", "code": "\nTranslation of: Groovy\npublic static class Haversine {\n  public static double calculate(double lat1, double lon1, double lat2, double lon2) {\n    var R = 6372.8; // In kilometers\n    var dLat = toRadians(lat2 - lat1);\n    var dLon = toRadians(lon2 - lon1);\n    lat1 = toRadians(lat1);\n    lat2 = toRadians(lat2);\n   \n    var a = Math.Sin(dLat / 2) * Math.Sin(dLat / 2) + Math.Sin(dLon / 2) * Math.Sin(dLon / 2) * Math.Cos(lat1) * Math.Cos(lat2);\n    var c = 2 * Math.Asin(Math.Sqrt(a));\n    return R * 2 * Math.Asin(Math.Sqrt(a));\n  }\n  \n  public static double toRadians(double angle) {\n    return Math.PI * angle / 180.0;\n  }\n}\n\nvoid Main() {\n  Console.WriteLine(String.Format(\"The distance between coordinates {0},{1} and {2},{3} is: {4}\", 36.12, -86.67, 33.94, -118.40, Haversine.calculate(36.12, -86.67, 33.94, -118.40)));\n}\n\n// Returns: The distance between coordinates 36.12,-86.67 and 33.94,-118.4 is: 2887.25995060711\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "JavaScript", "code": "\nES5[edit]\nTranslation of: Java\nfunction haversine() {\n       var radians = Array.prototype.map.call(arguments, function(deg) { return deg/180.0 * Math.PI; });\n       var lat1 = radians[0], lon1 = radians[1], lat2 = radians[2], lon2 = radians[3];\n       var R = 6372.8; // km\n       var dLat = lat2 - lat1;\n       var dLon = lon2 - lon1;\n       var a = Math.sin(dLat / 2) * Math.sin(dLat /2) + Math.sin(dLon / 2) * Math.sin(dLon /2) * Math.cos(lat1) * Math.cos(lat2);\n       var c = 2 * Math.asin(Math.sqrt(a));\n       return R * c;\n}\nconsole.log(haversine(36.12, -86.67, 33.94, -118.40));\n\n\nOutput:\n2887.2599506071124\nES6[edit]\n((x, y) => {\n    'use strict';\n\n    // haversine\u00a0:: (Num, Num) -> (Num, Num) -> Num\n    const haversine = ([lat1, lon1], [lat2, lon2]) => {\n        // Math lib function names\n        const [pi, asin, sin, cos, sqrt, pow, round] = [\n            'PI', 'asin', 'sin', 'cos', 'sqrt', 'pow', 'round'\n        ]\n        .map(k => Math[k]),\n\n            // degrees as radians\n            [rlat1, rlat2, rlon1, rlon2] = [lat1, lat2, lon1, lon2]\n            .map(x => x / 180 * pi),\n\n            dLat = rlat2 - rlat1,\n            dLon = rlon2 - rlon1,\n            radius = 6372.8; // km\n\n        // km\n        return round(\n            radius * 2 * asin(\n                sqrt(\n                    pow(sin(dLat / 2), 2) +\n                    pow(sin(dLon / 2), 2) *\n                    cos(rlat1) * cos(rlat2)\n                )\n            ) * 100\n        ) / 100;\n    };\n\n    // TEST\n    return haversine(x, y);\n\n    // --> 2887.26\n\n})([36.12, -86.67], [33.94, -118.40]);\n\n\nOutput:\n2887.26\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#If you read the fine print in the Wikipedia article, you will find that the Haversine method of finding distances may have an error of up to 0.5%.  This could lead one to believe that discussion about whether to use 6371.0 km or 6372.8 km for an approximation of the Earth's radius is moot.\nImports System.Math\n\nModule Module1\n\n  Const deg2rad As Double = PI / 180\n\n  Structure AP_Loc\n    Public IATA_Code As String, Lat As Double, Lon As Double\n\n    Public Sub New(ByVal iata_code As String, ByVal lat As Double, ByVal lon As Double)\n      Me.IATA_Code = iata_code\u00a0: Me.Lat = lat * deg2rad\u00a0: Me.Lon = lon * deg2rad\n    End Sub\n\n    Public Overrides Function ToString() As String\n      Return String.Format(\"{0}: ({1}, {2})\", IATA_Code, Lat / deg2rad, Lon / deg2rad)\n    End Function\n  End Structure\n\n  Function Sin2(ByVal x As Double) As Double\n    Return Pow(Sin(x / 2), 2)\n  End Function\n\n  Function calculate(ByVal one As AP_Loc, ByVal two As AP_Loc) As Double\n    Dim R As Double = 6371, ' In kilometers, (as recommended by the International Union of Geodesy and Geophysics)\n        a As Double = Sin2(two.Lat - one.Lat) + Sin2(two.Lon - one.Lon) * Cos(one.Lat) * Cos(two.Lat)\n    Return R * 2 * Asin(Sqrt(a))\n  End Function\n\n  Sub ShowOne(pntA As AP_Loc, pntB as AP_Loc)\n    Dim adst As Double = calculate(pntA, pntB), sfx As String = \"km\"\n    If adst < 1000 Then adst *= 1000\u00a0: sfx = \"m\"\n    Console.WriteLine(\"The approximate distance between airports {0} and {1} is {2:n2} {3}.\", pntA, pntB, adst, sfx)\n    Console.WriteLine(\"The uncertainty is under 0.5%, or {0:n1} {1}.\" & vbLf, adst / 200, sfx)\n  End Sub\n\n' Airport coordinate data excerpted from the data base at http://www.partow.net/miscellaneous/airportdatabase/\n\n' The four additional airports are the furthest and closest pairs, according to the \"Fun Facts...\" section.\n\n' KBNA, BNA, NASHVILLE INTERNATIONAL, NASHVILLE, USA, 036, 007, 028, N, 086, 040, 041, W, 00183, 36.124, -86.678\n' KLAX, LAX, LOS ANGELES INTERNATIONAL, LOS ANGELES, USA, 033, 056, 033, N, 118, 024, 029, W, 00039, 33.942, -118.408\n' SKNV, NVA, BENITO SALAS, NEIVA, COLOMBIA, 002, 057, 000, N, 075, 017, 038, W, 00439, 2.950, -75.294\n' WIPP, PLM, SULTAN MAHMUD BADARUDDIN II, PALEMBANG, INDONESIA, 002, 053, 052, S, 104, 042, 004, E, 00012, -2.898, 104.701 \n' LOWL, LNZ, HORSCHING INTERNATIONAL AIRPORT (AUS - AFB), LINZ, AUSTRIA, 048, 014, 000, N, 014, 011, 000, E, 00096, 48.233, 14.183\n' LOXL, N/A, LINZ, LINZ, AUSTRIA, 048, 013, 059, N, 014, 011, 015, E, 00299, 48.233, 14.188\n\n  Sub Main()\n    ShowOne(New AP_Loc(\"BNA\", 36.124, -86.678),  New AP_Loc(\"LAX\", 33.942, -118.408))\n    ShowOne(New AP_Loc(\"NVA\",  2.95,  -75.294),  New AP_Loc(\"PLM\", -2.898,  104.701))\n    ShowOne(New AP_Loc(\"LNZ\", 48.233,  14.183),  New AP_Loc(\"N/A\", 48.233,   14.188))\n  End Sub\nEnd Module\n\nOutput:\nThe approximate distance between airports BNA: (36.124, -86.678) and LAX: (33.942, -118.408) is 2,886.36 km.\nThe uncertainty is under 0.5%, or 14.4 km.\n\nThe approximate distance between airports NVA: (2.95, -75.294) and PLM: (-2.898, 104.701) is 20,009.28 km.\nThe uncertainty is under 0.5%, or 100.0 km.\n\nThe approximate distance between airports LNZ: (48.233, 14.183) and N/A: (48.233, 14.188) is 370.34 m.\nThe uncertainty is under 0.5%, or 1.9 m.Looking at the altitude difference between the last two airports, (299 - 96 = 203), the reported distance of 370 meters ought to be around 422 meters if you actually went there and saw it for yourself.\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "PHP", "code": "\nclass POI {\n    private $latitude;\n    private $longitude;\n\n    public function __construct($latitude, $longitude) {\n        $this->latitude = deg2rad($latitude);\n        $this->longitude = deg2rad($longitude);\n    }\n\n    public function getLatitude() {\n        return $this->latitude;\n    }\n\n    public function getLongitude() {\n        return $this->longitude;\n    }\n\n    public function getDistanceInMetersTo(POI $other) {\n        $radiusOfEarth = 6371; // Earth's radius in kilometers.\n\n        $diffLatitude = $other->getLatitude() - $this->latitude;\n        $diffLongitude = $other->getLongitude() - $this->longitude;\n\n        $a = sin($diffLatitude / 2) ** 2 +\n             cos($this->latitude) *\n             cos($other->getLatitude()) *\n             sin($diffLongitude / 2) ** 2;\n\n        $c = 2 * asin(sqrt($a));\n        $distance = $radiusOfEarth * $c;\n\n        return $distance;\n    }\n}\n\n\n$bna = new POI(36.12, -86.67); // Nashville International Airport\n$lax = new POI(33.94, -118.40); // Los Angeles International Airport\nprintf('%.2f km', $bna->getDistanceInMetersTo($lax));\n\n\nOutput:\n2886.44 km\n", "explain": "Test:\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Fortran", "code": "\nprogram example\nimplicit none\nreal :: d\n\nd = haversine(36.12,-86.67,33.94,-118.40) ! BNA to LAX\nprint '(A,F9.4,A)', 'distance: ',d,' km' ! distance: 2887.2600 km\n\ncontains\n\n      function to_radian(degree) result(rad)\n          ! degrees to radians\n          real,intent(in) :: degree\n          real, parameter :: deg_to_rad = atan(1.0)/45 ! exploit intrinsic atan to generate pi/180 runtime constant\n          real :: rad\n\n          rad = degree*deg_to_rad\n      end function to_radian\n \n      function haversine(deglat1,deglon1,deglat2,deglon2) result (dist)\n          ! great circle distance -- adapted from Matlab \n          real,intent(in) :: deglat1,deglon1,deglat2,deglon2\n          real :: a,c,dist,dlat,dlon,lat1,lat2\n          real,parameter :: radius = 6372.8 \n\n          dlat = to_radian(deglat2-deglat1)\n          dlon = to_radian(deglon2-deglon1)\n          lat1 = to_radian(deglat1)\n          lat2 = to_radian(deglat2)\n          a = (sin(dlat/2))**2 + cos(lat1)*cos(lat2)*(sin(dlon/2))**2\n          c = 2*asin(sqrt(a))\n          dist = radius*c\n      end function haversine\n\nend program example\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc haversine(\u03b8 float64) float64 {\n    return .5 * (1 - math.Cos(\u03b8))\n}\n\ntype pos struct {\n    \u03c6 float64 // latitude, radians\n    \u03c8 float64 // longitude, radians\n}\n\nfunc degPos(lat, lon float64) pos {\n    return pos{lat * math.Pi / 180, lon * math.Pi / 180}\n}\n\nconst rEarth = 6372.8 // km\n\nfunc hsDist(p1, p2 pos) float64 {\n    return 2 * rEarth * math.Asin(math.Sqrt(haversine(p2.\u03c6-p1.\u03c6)+\n        math.Cos(p1.\u03c6)*math.Cos(p2.\u03c6)*haversine(p2.\u03c8-p1.\u03c8)))\n}\n\nfunc main() {\n    fmt.Println(hsDist(degPos(36.12, -86.67), degPos(33.94, -118.40)))\n}\n\n\nOutput:\n2887.2599506071097\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "X86_Assembly", "code": "\n\n0000                                 .model  tiny\n0000                                 .code\n                                     .486\n                                     org     100h           \u00a0;.com files start here\n0100  9B DB E3               start:  finit                   ;initialize floating-point unit (FPU)\n                             ;Great circle distance =\n                            \u00a0; 2.0*Radius * ASin( sqrt( Haversine(Lat2-Lat1) +\n                            \u00a0;                          Haversine(Lon2-Lon1)*Cos(Lat1)*Cos(Lat2) ) )\n0103  D9 06 0191r                    fld     Lat2            ;push real onto FPU stack\n0107  D8 26 018Dr                    fsub    Lat1            ;subtract real from top of stack (st(0) = st)\n010B  E8 0070                        call    Haversine      \u00a0;(1.0-cos(st)) / 2.0\n010E  D9 06 0199r                    fld     Lon2            ;repeat for longitudes\n0112  D8 26 0195r                    fsub    Lon1\n0116  E8 0065                        call    Haversine       ;st(1)=Lats; st=Lons\n0119  D9 06 018Dr                    fld     Lat1\n011D  D9 FF                          fcos                    ;replace st with its cosine\n011F  D9 06 0191r                    fld     Lat2\n0123  D9 FF                          fcos            ;st=cos(Lat2); st(1)=cos(Lat1); st(2)=Lats; st(3)=Lons\n0125  DE C9                          fmul            ;st=cos(Lat2)*cos(Lat1); st(1)=Lats; st(2)=Lons\n0127  DE C9                          fmul            ;st=cos(Lat2)*cos(Lat1)*Lats; st(1)=Lons\n0129  DE C1                          fadd            ;st=cos(Lat2)*cos(Lat1)*Lats + Lons\n012B  D9 FA                          fsqrt                   ;replace st with its square root\n                             ;asin(x) = atan(x/sqrt(1-x^2))\n012D  D9 C0                          fld     st              ;duplicate tos\n012F  D8 C8                          fmul    st, st          ;x^2\n0131  D9 E8                          fld1                    ;get 1.0\n0133  DE E1                          fsubr                   ;1 - x^2\n0135  D9 FA                          fsqrt                   ;sqrt(1-x^2)\n0137  D9 F3                          fpatan                  ;take atan(st(1)/st)\n0139  D8 0E 019Dr                    fmul    Radius2        \u00a0;*2.0*Radius\n\n                             ;Display value in FPU's top of stack (st)\n      =0004                  before  equ     4               ;places before\n      =0002                  after   equ     2              \u00a0; and after decimal point\n      =0001                  scaler  =       1              \u00a0;\"=\" allows scaler to be redefined, unlike equ\n                                     rept    after           ;repeat block \"after\" times\n                             scaler  =       scaler*10\n                                     endm                    ;scaler now = 10^after\n\n013D  66| 6A 64                      push    dword ptr scaler;use stack for convenient memory location\n0140  67| DA 0C 24                   fimul   dword ptr [esp] ;st:= st*scaler\n0144  67| DB 1C 24                   fistp   dword ptr [esp] ;round st to nearest integer\n0148  66| 58                         pop     eax            \u00a0; and put it into eax\n\n014A  66| BB 0000000A                mov     ebx, 10         ;set up for idiv instruction\n0150  B9 0006                        mov     cx, before+after;set up loop counter\n0153  66| 99                 ro10:   cdq                     ;convert double to quad; i.e: edx:= 0\n0155  66| F7 FB                      idiv    ebx             ;eax:= edx:eax/ebx; remainder in edx\n0158  52                             push    dx              ;save least significant digit on stack\n0159  E2 F8                          loop    ro10            ;cx--; loop back if not zero\n\n015B  B1 06                          mov     cl, before+after;(ch=0)\n015D  B3 00                          mov     bl, 0           ;used to suppress leading zeros\n015F  58                     ro20:   pop     ax              ;get digit\n0160  0A D8                          or      bl, al          ;turn off suppression if not a zero\n0162  80 F9 03                       cmp     cl, after+1     ;is digit immediately to left of decimal point?\n0165  75 01                          jne     ro30            ;skip if not\n0167  43                              inc    bx              ;turn off leading zero suppression\n0168  04 30                  ro30:   add     al, '0'         ;if leading zero then ' ' else add 0\n016A  84 DB                          test    bl, bl\n016C  75 02                          jne     ro40\n016E  B0 20                           mov    al, ' '\n0170  CD 29                  ro40:   int     29h             ;display character in al register\n0172  80 F9 03                       cmp     cl, after+1     ;is digit immediately to left of decimal point?\n0175  75 04                          jne     ro50            ;skip if not\n0177  B0 2E                           mov    al, '.'         ;display decimal point\n0179  CD 29                           int    29h\n017B  E2 E2                  ro50:   loop    ro20            ;loop until all digits displayed\n017D  C3                             ret                     ;return to OS\n\n017E                         Haversine:                      ;return (1.0-Cos(Ang)) / 2.0 in st\n017E  D9 FF                          fcos\n0180  D9 E8                          fld1\n0182  DE E1                          fsubr\n0184  D8 36 0189r                    fdiv    N2\n0188  C3                             ret\n\n0189  40000000               N2      dd       2.0\n018D  3F21628D               Lat1    dd       0.63041        ;36.12*pi/180\n0191  3F17A4E8               Lat2    dd       0.59236        ;33.94*pi/180\n0195  BFC19F80               Lon1    dd      -1.51268       \u00a0;-86.67*pi/180\n0199  C004410B               Lon2    dd      -2.06647       \u00a0;-118.40*pi/180\n019D  46472666               Radius2 dd      12745.6         ;6372.8 average radius of Earth (km) times 2\n                            \u00a0;(TASM isn't smart enough to do floating point constant calculations)\n                                     end     start\n\nOutput:\n2887.25\n\n", "explain": "Assemble with tasm /m /l; tlink /t\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Delphi", "code": "\nprogram HaversineDemo;\nuses Math;\n\nfunction HaversineDist(th1, ph1, th2, ph2:double):double;\nconst diameter = 2 * 6372.8;\nvar   dx, dy, dz:double;\nbegin\n  ph1    := degtorad(ph1 - ph2);\n  th1    := degtorad(th1);\n  th2    := degtorad(th2);\n\n  dz     := sin(th1) - sin(th2);\n  dx     := cos(ph1) * cos(th1) - cos(th2);\n  dy     := sin(ph1) * cos(th1);\n  Result := arcsin(sqrt(sqr(dx) + sqr(dy) + sqr(dz)) / 2) * diameter;\nend;\n\nbegin\n  Writeln('Haversine distance: ', HaversineDist(36.12, -86.67, 33.94, -118.4):7:2, ' km.');\nend.\n\n\nOutput:\nHaversine distance: 2887.26 km.\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Ruby", "code": "\ninclude Math\n\nRadius = 6372.8  # rough radius of the Earth, in kilometers\n\ndef spherical_distance(start_coords, end_coords)\n  lat1, long1 = deg2rad *start_coords\n  lat2, long2 = deg2rad *end_coords\n  2 * Radius * asin(sqrt(sin((lat2-lat1)/2)**2 + cos(lat1) * cos(lat2) * sin((long2 - long1)/2)**2))\nend\n\ndef deg2rad(lat, long)\n  [lat * PI / 180, long * PI / 180]\nend\n\nbna = [36.12, -86.67]\nlax = [33.94, -118.4]\n\nputs \"%.1f\" % spherical_distance(bna, lax)\n\n\nOutput:\n2887.3\n\nTranslation of: Python\ninclude Math\n \ndef haversine(lat1, lon1, lat2, lon2)\n    r = 6372.8        # Earth radius in kilometers\n    deg2rad = PI/180  # convert degress to radians\n \n    dLat = (lat2 - lat1) * deg2rad\n    dLon = (lon2 - lon1) * deg2rad\n    lat1 = lat1 * deg2rad\n    lat2 = lat2 * deg2rad\n \n    a = sin(dLat / 2)**2 + cos(lat1) * cos(lat2) * sin(dLon / 2)**2\n    c = 2 * asin(sqrt(a))\n    r * c\nend\n\nputs \"distance is #{haversine(36.12, -86.67, 33.94, -118.40)} km \"\n\n\nOutput:\ndistance is 2887.2599506071106 km \n\n", "explain": "Alternatively:\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Rust", "code": "\nstruct Point {\n    lat: f64,\n    lon: f64,\n}\n\nfn haversine(origin: Point, destination: Point) -> f64 {\n    const R: f64 = 6372.8;\n\n    let lat1 = origin.lat.to_radians();\n    let lat2 = destination.lat.to_radians();\n    let d_lat = lat2 - lat1;\n    let d_lon = (destination.lon - origin.lon).to_radians();\n\n    let a = (d_lat / 2.0).sin().powi(2) + (d_lon / 2.0).sin().powi(2) * lat1.cos() * lat2.cos();\n    let c = 2.0 * a.sqrt().asin();\n    R * c\n}\n\n#[cfg(test)]\nmod test {\n    use super::{Point, haversine};\n\n    #[test]\n    fn test_haversine() {\n        let origin: Point = Point {\n            lat: 36.12,\n            lon: -86.67\n        };\n        let destination: Point = Point {\n            lat: 33.94,\n            lon: -118.4\n        };\n        let d: f64 = haversine(origin, destination);\n        println!(\"Distance: {} km ({} mi)\", d, d / 1.609344);\n        assert_eq!(d, 2887.2599506071106);\n    }\n\n}\nOutput Distance: 2887.2599506071106 km (1794.060157807846 mi)\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Swift", "code": "\nTranslation of: Objective-C\nimport Foundation\n\nfunc haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double) -> Double {\n    let lat1rad = lat1 * Double.pi/180\n    let lon1rad = lon1 * Double.pi/180\n    let lat2rad = lat2 * Double.pi/180\n    let lon2rad = lon2 * Double.pi/180\n    \n    let dLat = lat2rad - lat1rad\n    let dLon = lon2rad - lon1rad\n    let a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad)\n    let c = 2 * asin(sqrt(a))\n    let R = 6372.8\n    \n    return R * c\n}\n\nprint(haversine(lat1:36.12, lon1:-86.67, lat2:33.94, lon2:-118.40))\n\n\nOutput:\n2887.25995060711\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "R", "code": "\ndms_to_rad <- function(d, m, s) (d + m / 60 + s / 3600) * pi / 180\n\n# Volumetric mean radius is 6371 km, see http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html\n# The diameter is thus 12742 km\n\ngreat_circle_distance <- function(lat1, long1, lat2, long2) {\n   a <- sin(0.5 * (lat2 - lat1))\n   b <- sin(0.5 * (long2 - long1))\n   12742 * asin(sqrt(a * a + cos(lat1) * cos(lat2) * b * b))\n}\n\n# Coordinates are found here:\n#     http://www.airport-data.com/airport/BNA/\n#     http://www.airport-data.com/airport/LAX/\n\ngreat_circle_distance(\n   dms_to_rad(36,  7, 28.10), dms_to_rad( 86, 40, 41.50),   # Nashville International Airport (BNA)\n   dms_to_rad(33, 56, 32.98), dms_to_rad(118, 24, 29.05))  # Los Angeles International Airport (LAX)\n\n# Output:  2886.327\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Ada", "code": "\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Ada.Long_Float_Text_IO; use Ada.Long_Float_Text_IO;\nwith Ada.Numerics.Generic_Elementary_Functions;\n\nprocedure Haversine_Formula is\n\n   package Math is new Ada.Numerics.Generic_Elementary_Functions (Long_Float); use Math;\n\n   -- Compute great circle distance, given latitude and longitude of two points, in radians\n   function Great_Circle_Distance (lat1, long1, lat2, long2 : Long_Float) return Long_Float is\n      Earth_Radius : constant := 6371.0; -- in kilometers\n      a : Long_Float := Sin (0.5 * (lat2 - lat1));\n      b : Long_Float := Sin (0.5 * (long2 - long1));\n   begin\n      return 2.0 * Earth_Radius * ArcSin (Sqrt (a * a + Cos (lat1) * Cos (lat2) * b * b));\n   end Great_Circle_Distance;\n\n   -- convert degrees, minutes and seconds to radians\n   function DMS_To_Radians (Deg, Min, Sec : Long_Float := 0.0) return Long_Float is\n      Pi_Over_180 : constant := 0.017453_292519_943295_769236_907684_886127;\n   begin\n      return (Deg + Min/60.0 + Sec/3600.0) * Pi_Over_180;\n   end DMS_To_Radians;\n\nbegin\n   Put_Line(\"Distance in kilometers between BNA and LAX\");\n   Put (Great_Circle_Distance (\n         DMS_To_Radians (36.0, 7.2), DMS_To_Radians (86.0, 40.2),       -- Nashville International Airport (BNA)\n         DMS_To_Radians (33.0, 56.4), DMS_To_Radians (118.0, 24.0)),    -- Los Angeles International Airport (LAX)\n      Aft=>3, Exp=>0);\nend Haversine_Formula;\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nhaversine(lat1, lon1, lat2, lon2) =\n    2 * 6372.8 * asin(sqrt(sind((lat2 - lat1) / 2) ^ 2 +\n    cosd(lat1) * cosd(lat2) * sind((lon2 - lon1) / 2) ^ 2))\n\n@show haversine(36.12, -86.67, 33.94, -118.4)\n\n\nOutput:\nhaversine(36.12, -86.67, 33.94, -118.4) = 2887.2599506071106\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "SAS", "code": "\noptions minoperator;\n\n%macro haver(lat1, long1, lat2, long2, type=D, dist=K);\n\n\t%if %upcase(&type) in (D DEG DEGREE DEGREES) %then %do;\n\t\t%let convert = constant('PI')/180;\n\t\t%end;\n\t%else %if %upcase(&type) in (R RAD RADIAN RADIANS) %then %do;\n\t\t%let convert = 1;\n\t\t%end;\n\t%else %do;\n\t\t%put ERROR - Enter RADIANS or DEGREES for type.;\n\t\t%goto exit;\n\t\t%end;\n\n\t%if %upcase(&dist) in (M MILE MILES) %then %do;\n\t\t%let distrat = 1.609344;\n\t\t%end;\n\t%else %if %upcase(&dist) in (K KM KILOMETER KILOMETERS) %then %do;\n\t\t%let distrat = 1;\n\t\t%end;\n\t%else %do;\n\t\t%put ERROR - Enter M on KM for dist;\n\t\t%goto exit;\n\t\t%end;\n\t\t\n\t\tdata _null_;\n\t\t\tconvert = &convert;\n\t\t\tlat1 = &lat1 * convert;\n\t\t\tlat2 = &lat2 * convert;\n\t\t\tlong1 = &long1 * convert;\n\t\t\tlong2 = &long2 * convert;\n\n\t\t\tdiff1 = lat2 - lat1;\n\t\t\tdiff2 = long2 - long1;\n\n\t\t\tpart1 = sin(diff1/2)**2;\n\t\t\tpart2 = cos(lat1)*cos(lat2);\n\t\t\tpart3 = sin(diff2/2)**2;\n\n\t\t\troot = sqrt(part1 + part2*part3);\n\n\t\t\tdist = 2 * 6372.8 / &distrat * arsin(root);\n\n\t\t\tput \"Distance is \" dist \"%upcase(&dist)\";\n\t\trun;\n\n\t%exit:\n%mend;\n\n%haver(36.12, -86.67, 33.94, -118.40);\n\n\nOutput:\nDistance is 2887.2599506 K\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Kotlin", "code": "\nTranslation of: Groovy\n\nimport java.lang.Math.*\n\nconst val R = 6372.8 // in kilometers\n\nfun haversine(lat1: Double, lon1: Double, lat2: Double, lon2: Double): Double {\n    val \u03bb1 = toRadians(lat1)\n    val \u03bb2 = toRadians(lat2)\n    val \u0394\u03bb = toRadians(lat2 - lat1)\n    val \u0394\u03c6 = toRadians(lon2 - lon1)\n    return 2 * R * asin(sqrt(pow(sin(\u0394\u03bb / 2), 2.0) + pow(sin(\u0394\u03c6 / 2), 2.0) * cos(\u03bb1) * cos(\u03bb2)))\n}\n\nfun main(args: Array<String>) = println(\"result: \" + haversine(36.12, -86.67, 33.94, -118.40))\n\n", "explain": "Use Unicode characters.\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Perl", "code": "\nLow-Level[edit]\nLibrary: ntheory\nuse ntheory qw/Pi/;\n\nsub asin { my $x = shift; atan2($x, sqrt(1-$x*$x)); }\n\nsub surfacedist {\n  my($lat1, $lon1, $lat2, $lon2) = @_;\n  my $radius = 6372.8;\n  my $radians = Pi() / 180;;\n  my $dlat = ($lat2 - $lat1) * $radians;\n  my $dlon = ($lon2 - $lon1) * $radians;\n  $lat1 *= $radians;\n  $lat2 *= $radians;\n  my $a = sin($dlat/2)**2 + cos($lat1) * cos($lat2) * sin($dlon/2)**2;\n  my $c = 2 * asin(sqrt($a));\n  return $radius * $c;\n}\nmy @BNA = (36.12, -86.67);\nmy @LAX = (33.94, -118.4);\nprintf \"Distance:\u00a0%.3f km\\n\", surfacedist(@BNA, @LAX);\n\n\nOutput:\nDistance: 2887.260 km\nIdiomatic[edit]\n\nuse Math::Trig qw(great_circle_distance deg2rad);\n \n# Notice the 90 - latitude: phi zero is at the North Pole.\n# Parameter order is: LON, LAT\nmy @BNA = (deg2rad(-86.67), deg2rad(90 - 36.12));\nmy @LAX = (deg2rad(-118.4), deg2rad(90 - 33.94));\n\nprint \"Distance: \", great_circle_distance(@BNA, @LAX, 6372.8), \" km\\n\";\n\n\nOutput:\nDistance: 2887.25995060711 km\n", "explain": "Contrary to ntheory, Math::Trig is part of the Perl core distribution.\nIt comes with a great circle distance built-in.\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Objective-C", "code": "\n+ (double) distanceBetweenLat1:(double)lat1 lon1:(double)lon1\n                          lat2:(double)lat2 lon2:(double)lon2 {\n    //degrees to radians\n    double lat1rad = lat1 * M_PI/180; \n    double lon1rad = lon1 * M_PI/180;\n    double lat2rad = lat2 * M_PI/180;\n    double lon2rad = lon2 * M_PI/180;\n    \n    //deltas\n    double dLat = lat2rad - lat1rad;\n    double dLon = lon2rad - lon1rad;\n\n    double a = sin(dLat/2) * sin(dLat/2) + sin(dLon/2) * sin(dLon/2) * cos(lat1rad) * cos(lat2rad);\n    double c = 2 * asin(sqrt(a));\n    double R = 6372.8;\n    return R * c;\n}\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Lua", "code": "\nlocal function haversine(x1, y1, x2, y2)\nr=0.017453292519943295769236907684886127;\nx1= x1*r; x2= x2*r; y1= y1*r; y2= y2*r; dy = y2-y1; dx = x2-x1;\na = math.pow(math.sin(dx/2),2) + math.cos(x1) * math.cos(x2) * math.pow(math.sin(dy/2),2); c = 2 * math.asin(math.sqrt(a)); d = 6372.8 * c;\nreturn d;\nend\n\n\nprint(haversine(36.12, -86.67, 33.94, -118.4));\n\n\n2887.2599506071\n", "explain": "Usage:\nOutput:\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Scala", "code": "\nimport math._\n\nobject Haversine {\n   val R = 6372.8  //radius in km\n\n   def haversine(lat1:Double, lon1:Double, lat2:Double, lon2:Double)={\n      val dLat=(lat2 - lat1).toRadians\n      val dLon=(lon2 - lon1).toRadians\n \n      val a = pow(sin(dLat/2),2) + pow(sin(dLon/2),2) * cos(lat1.toRadians) * cos(lat2.toRadians)\n      val c = 2 * asin(sqrt(a))\n      R * c\n   }\n\t\n   def main(args: Array[String]): Unit = {\n      println(haversine(36.12, -86.67, 33.94, -118.40))\n  }\n}\n\n\nOutput:\n2887.2599506071106\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Dart", "code": "\nTranslation of: Java\nimport 'dart:math';\n\nclass Haversine {\n  static final R = 6372.8; // In kilometers\n\n  static double haversine(double lat1, lon1, lat2, lon2) {\n    double dLat = _toRadians(lat2 - lat1);\n    double dLon = _toRadians(lon2 - lon1);\n    lat1 = _toRadians(lat1);\n    lat2 = _toRadians(lat2);\n    double a = pow(sin(dLat / 2), 2) + pow(sin(dLon / 2), 2) * cos(lat1) * cos(lat2);\n    double c = 2 * asin(sqrt(a));\n    return R * c;\n  }\n\n  static double _toRadians(double degree) {\n    return degree * pi / 180;\n  }\n\n  static void main() {\n    print(haversine(36.12, -86.67, 33.94, -118.40));\n  }\n}\n\n\nOutput:\n2887.2599506071106\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Transact-SQL", "code": "\nTranslation of: C#\nCREATE FUNCTION [dbo].[Haversine](@Lat1 AS DECIMAL(9,7), @Lon1 AS DECIMAL(10,7), @Lat2 AS DECIMAL(9,7), @Lon2 AS DECIMAL(10,7))\nRETURNS DECIMAL(12,7)\nAS\nBEGIN\n\tDECLARE @R\tDECIMAL(11,7);\n\tDECLARE @dLat\tDECIMAL(9,7);\n\tDECLARE @dLon\tDECIMAL(10,7);\n\tDECLARE @a\tDECIMAL(10,7);\n\tDECLARE @c\tDECIMAL(10,7);\n\n\tSET @R\t\t= 6372.8;\n\tSET @dLat\t= RADIANS(@Lat2 - @Lat1);\n\tSET @dLon\t= RADIANS(@Lon2 - @Lon1);\n\tSET @Lat1\t= RADIANS(@Lat1);\n\tSET @Lat2\t= RADIANS(@Lat2);\n\tSET @a\t\t= SIN(@dLat / 2) * SIN(@dLat / 2) + SIN(@dLon / 2) * SIN(@dLon / 2) * COS(@Lat1) * COS(@Lat2);\n\tSET @c\t\t= 2 * ASIN(SQRT(@a));\n\n\tRETURN @R * @c;\nEND\nGO\n\nSELECT dbo.Haversine(36.12,-86.67,33.94,-118.4)\n\n\nOutput:\n 2887.2594934\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "D", "code": "\nimport std.stdio, std.math;\n\nreal haversineDistance(in real dth1, in real dph1,\n                       in real dth2, in real dph2)\npure nothrow @nogc {\n    enum real R = 6371;\n    enum real TO_RAD = PI / 180;\n\n    alias imr = immutable real;\n    imr ph1d = dph1 - dph2;\n    imr ph1 = ph1d * TO_RAD;\n    imr th1 = dth1 * TO_RAD;\n    imr th2 = dth2 * TO_RAD;\n\n    imr dz = th1.sin - th2.sin;\n    imr dx = ph1.cos * th1.cos - th2.cos;\n    imr dy = ph1.sin * th1.cos;\n    return asin(sqrt(dx ^^ 2 + dy ^^ 2 + dz ^^ 2) / 2) * 2 * R;\n}\n\nvoid main() {\n    writefln(\"Haversine distance:\u00a0%.1f km\",\n             haversineDistance(36.12, -86.67, 33.94, -118.4));\n}\n\n\nOutput:\nHaversine distance: 2887.3 km\nAlternative Version[edit]\n\nimport std.stdio, std.math;\n\nreal toRad(in real degrees) pure nothrow @safe @nogc {\n    return degrees * PI / 180;\n}\n\nreal haversin(in real theta) pure nothrow @safe @nogc {\n    return (1 - theta.cos) / 2;\n}\n\nreal greatCircleDistance(in real lat1, in real lng1,\n                         in real lat2, in real lng2,\n                         in real radius)\npure nothrow @safe @nogc {\n    immutable h = haversin(lat2.toRad - lat1.toRad) +\n                  lat1.toRad.cos * lat2.toRad.cos *\n                  haversin(lng2.toRad - lng1.toRad);\n    return 2 * radius * h.sqrt.asin;\n}\n\nvoid main() {\n    enum real earthRadius = 6372.8L; // Average earth radius.\n\n    writefln(\"Great circle distance:\u00a0%.1f km\",\n             greatCircleDistance(36.12, -86.67, 33.94, -118.4,\n                                 earthRadius));\n}\n\n\nOutput:\nGreat circle distance: 2887.3 km\n\n", "explain": "An alternate direct implementation of the haversine formula as shown at wikipedia. The same length, but perhaps a little more clear about what is being done.\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Haskell", "code": "\nimport Control.Monad (join)\nimport Data.Bifunctor (bimap)\nimport Text.Printf (printf)\n\n-------------------- HAVERSINE FORMULA -------------------\n\n-- The haversine of an angle.\nhaversine :: Float -> Float\nhaversine = (^ 2) . sin . (/ 2)\n\n-- The approximate distance, in kilometers,\n-- between two points on Earth.\n-- The latitude and longtitude are assumed to be in degrees.\ngreatCircleDistance ::\n  (Float, Float) ->\n  (Float, Float) ->\n  Float\ngreatCircleDistance = distDeg 6371\n  where\n    distDeg radius p1 p2 =\n      distRad\n        radius\n        (deg2rad p1)\n        (deg2rad p2)\n    distRad radius (lat1, lng1) (lat2, lng2) =\n      (2 * radius)\n        * asin\n          ( min\n              1.0\n              ( sqrt $\n                  haversine (lat2 - lat1)\n                    + ( (cos lat1 * cos lat2)\n                          * haversine (lng2 - lng1)\n                      )\n              )\n          )\n    deg2rad = join bimap ((/ 180) . (pi *))\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  printf\n    \"The distance between BNA and LAX is about %0.f km.\\n\"\n    (greatCircleDistance bna lax)\n  where\n    bna = (36.12, -86.67)\n    lax = (33.94, -118.40)\n\n\nOutput:\nThe distance between BNA and LAX is about 2886 km.\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Scheme", "code": "\n(define earth-radius 6371)\n(define pi (acos -1))\n\n(define (distance lat1 long1 lat2 long2)\n(define (h a b) (expt (sin (/ (- b a) 2)) 2))\n(* 2 earth-radius (asin (sqrt (+ (h lat1 lat2) (* (cos lat1) (cos lat2) (h long1 long2)))))))\n\n(define (deg-to-rad d m s) (* (/ pi 180) (+ d (/ m 60) (/ s 3600))))\n\n(distance (deg-to-rad 36  7.2 0) (deg-to-rad  86 40.2 0)\n          (deg-to-rad 33 56.4 0) (deg-to-rad 118 24.0 0))\n; 2886.444442837984\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "TypeScript", "code": "\nTranslation of: Matlab\nlet radians = function (degree: number) {\n\n    // degrees to radians\n    let rad: number = degree * Math.PI / 180;\n\n    return rad;\n}\n\nexport const haversine = (lat1: number, lon1: number, lat2: number, lon2: number) => {\n\n    // var dlat: number, dlon: number, a: number, c: number, R: number;\n    let dlat, dlon, a, c, R: number;\n\n    R = 6372.8; // km\n    dlat = radians(lat2 - lat1);\n    dlon = radians(lon2 - lon1);\n    lat1 = radians(lat1);\n    lat2 = radians(lat2);\n    a = Math.sin(dlat / 2) * Math.sin(dlat / 2) + Math.sin(dlon / 2) * Math.sin(dlon / 2) * Math.cos(lat1) * Math.cos(lat2)\n    c = 2 * Math.asin(Math.sqrt(a));\n    return R * c;\n}\n\nconsole.log(\"Distance:\" + haversine(36.12, -86.67, 33.94, -118.40));\n\n\nOutput:\nDistance: 2887.2599506071106\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 3\nAdd-Type -AssemblyName System.Device\n \n$BNA = New-Object System.Device.Location.GeoCoordinate 36.12, -86.67\n$LAX = New-Object System.Device.Location.GeoCoordinate 33.94, -118.40\n \n$BNA.GetDistanceTo( $LAX ) / 1000\n\n\nOutput:\n2888.93627213254\n\nWorks with: PowerShell version 2\nfunction Get-GreatCircleDistance ( $Coord1, $Coord2 )\n    {\n    #  Convert decimal degrees to radians\n    $Lat1  = $Coord1[0] / 180 * [math]::Pi\n    $Long1 = $Coord1[1] / 180 * [math]::Pi\n    $Lat2  = $Coord2[0] / 180 * [math]::Pi\n    $Long2 = $Coord2[1] / 180 * [math]::Pi\n \n    #  Mean Earth radius (km)\n    $R = 6371\n   \n    #  Haversine formula\n    $ArcLength = 2 * $R *\n                    [math]::Asin(\n                        [math]::Sqrt(\n                            [math]::Sin( ( $Lat1 - $Lat2 ) / 2 ) *\n                            [math]::Sin( ( $Lat1 - $Lat2 ) / 2 ) +\n                            [math]::Cos( $Lat1 ) *\n                            [math]::Cos( $Lat2 ) *\n                            [math]::Sin( ( $Long1 - $Long2 ) / 2 ) *\n                            [math]::Sin( ( $Long1 - $Long2 ) / 2 ) ) )\n    return $ArcLength\n    }\n \n$BNA = 36.12,  -86.67\n$LAX = 33.94, -118.40\n \nGet-GreatCircleDistance $BNA $LAX\n\n\nOutput:\n2886.44444283799\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "ABAP", "code": "\n  DATA: X1 TYPE F, Y1 TYPE F,\n        X2 TYPE F, Y2 TYPE F, YD TYPE F,\n        PI TYPE F,\n        PI_180 TYPE F,\n        MINUS_1 TYPE F VALUE '-1'.\n\nPI     = ACOS( MINUS_1 ).\nPI_180 = PI / 180.\n\nLATITUDE1 = 36,12 . LONGITUDE1 = -86,67 .\nLATITUDE2 = 33,94 . LONGITUDE2 = -118,4 .\n\n  X1 = LATITUDE1  * PI_180.\n  Y1 = LONGITUDE1 * PI_180.\n  X2 = LATITUDE2  * PI_180.\n  Y2 = LONGITUDE2 * PI_180.\n  YD = Y2 - Y1.\n\n  DISTANCE = 20000 / PI *\n    ACOS( SIN( X1 ) * SIN( X2 ) + COS( X1 ) * COS( X2 ) * COS( YD ) ).\n\nWRITE : 'Distance between given points = ' , distance , 'km .' .\n\n\nOutput:\nDistance between given points = 2.884,2687 km . \n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "F#", "code": "\nTranslation of: Go using units of measure\nopen System\n\n[<Measure>] type deg\n[<Measure>] type rad\n[<Measure>] type km\n\nlet haversine (\u03b8: float<rad>) = 0.5 * (1.0 - Math.Cos(\u03b8/1.0<rad>))\n\nlet radPerDeg =  (Math.PI / 180.0) * 1.0<rad/deg>\n\ntype pos(latitude: float<deg>, longitude: float<deg>) =\n    member this.\u03c6 = latitude * radPerDeg\n    member this.\u03c8 = longitude * radPerDeg\n\nlet rEarth = 6372.8<km>\n\nlet hsDist (p1: pos) (p2: pos) =\n    2.0 * rEarth *\n        Math.Asin(Math.Sqrt(haversine(p2.\u03c6 - p1.\u03c6)+\n                    Math.Cos(p1.\u03c6/1.0<rad>)*Math.Cos(p2.\u03c6/1.0<rad>)*haversine(p2.\u03c8 - p1.\u03c8)))\n\n[<EntryPoint>]\nlet main argv =\n    printfn \"%A\" (hsDist (pos(36.12<deg>, -86.67<deg>)) (pos(33.94<deg>, -118.40<deg>)))\n    0\n\n\nOutput:\n2887.259951\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Groovy", "code": "\ndef haversine(lat1, lon1, lat2, lon2) {\n  def R = 6372.8\n  // In kilometers\n  def dLat = Math.toRadians(lat2 - lat1)\n  def dLon = Math.toRadians(lon2 - lon1)\n  lat1 = Math.toRadians(lat1)\n  lat2 = Math.toRadians(lat2)\n\n  def a = Math.sin(dLat / 2) * Math.sin(dLat / 2) + Math.sin(dLon / 2) * Math.sin(dLon / 2) * Math.cos(lat1) * Math.cos(lat2)\n  def c = 2 * Math.asin(Math.sqrt(a))\n  R * c\n}\n\nhaversine(36.12, -86.67, 33.94, -118.40)\n\n> 2887.25995060711\n\n", "explain": ""}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "Zig", "code": "\nTranslation of: R\n\nconst std = @import(\"std\");\nconst math = std.math; // Save some typing, reduce clutter. Otherwise math.sin() would be std.math.sin() etc.\n\npub fn main() !void {\n    // Coordinates are found here:\n    //     http://www.airport-data.com/airport/BNA/\n    //     http://www.airport-data.com/airport/LAX/\n\n    const bna = LatLong{\n        .lat = .{ .d = 36, .m = 7, .s = 28.10 },\n        .long = .{ .d = 86, .m = 40, .s = 41.50 },\n    };\n\n    const lax = LatLong{\n        .lat = .{ .d = 33, .m = 56, .s = 32.98 },\n        .long = .{ .d = 118, .m = 24, .s = 29.05 },\n    };\n\n    const distance = calcGreatCircleDistance(bna, lax);\n\n    std.debug.print(\"Output: {d:.6} km\\n\", .{distance});\n\n    // Output: 2886.326609 km\n}\n\nconst LatLong = struct { lat: DMS, long: DMS };\n\n/// degrees, minutes, decimal seconds\nconst DMS = struct {\n    d: f64,\n    m: f64,\n    s: f64,\n\n    fn toRadians(self: DMS) f64 {\n        return (self.d + self.m / 60 + self.s / 3600) * math.pi / 180;\n    }\n};\n\n// Volumetric mean radius is 6371 km, see http://nssdc.gsfc.nasa.gov/planetary/factsheet/earthfact.html\n// The diameter is thus 12742 km\nfn calcGreatCircleDistance(lat_long1: LatLong, lat_long2: LatLong) f64 {\n    const lat1 = lat_long1.lat.toRadians();\n    const lat2 = lat_long2.lat.toRadians();\n    const long1 = lat_long1.long.toRadians();\n    const long2 = lat_long2.long.toRadians();\n\n    const a = math.sin(0.5 * (lat2 - lat1));\n    const b = math.sin(0.5 * (long2 - long1));\n\n    return 12742 * math.asin(math.sqrt(a * a + math.cos(lat1) * math.cos(lat2) * b * b));\n}\n", "explain": "When a Zig struct type can be inferred then anonymous structs .{} can be used for initialisation. \nThis can be seen on the lines where the constants bna and lax are instantiated.\nA Zig struct can have methods, the same as an enum and or a union.\nThey are only namespaced functions that can be called with dot syntax.\n"}, {"task_name": "Haversine formula", "task_url": "https://rosettacode.org/wiki/Haversine_formula", "task_cat": "Geometry", "lang": "AWK", "code": "\n# syntax: GAWK -f HAVERSINE_FORMULA.AWK\n# converted from Python\nBEGIN {\n    distance(36.12,-86.67,33.94,-118.40) # BNA to LAX\n    exit(0)\n}\nfunction distance(lat1,lon1,lat2,lon2,  a,c,dlat,dlon) {\n    dlat = radians(lat2-lat1)\n    dlon = radians(lon2-lon1)\n    lat1 = radians(lat1)\n    lat2 = radians(lat2)\n    a = (sin(dlat/2))^2 + cos(lat1) * cos(lat2) * (sin(dlon/2))^2\n    c = 2 * atan2(sqrt(a),sqrt(1-a))\n    printf(\"distance:\u00a0%.4f km\\n\",6372.8 * c)\n}\nfunction radians(degree) { # degrees to radians\n    return degree * (3.1415926 / 180.)\n}\n\n\nOutput:\ndistance: 2887.2599 km\n", "explain": ""}]