[{"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Python", "code": "\nWorks with: Python version 2.3 or above\nimport SocketServer\n\nHOST = \"localhost\"\nPORT = 12321\n\n# this server uses ThreadingMixIn - one thread per connection\n# replace with ForkMixIn to spawn a new process per connection\n\nclass EchoServer(SocketServer.ThreadingMixIn, SocketServer.TCPServer):\n    # no need to override anything - default behavior is just fine\n    pass\n\nclass EchoRequestHandler(SocketServer.StreamRequestHandler):\n    \"\"\"\n    Handles one connection to the client.\n    \"\"\"\n    def handle(self):\n        print \"connection from %s\" % self.client_address[0]\n        while True:\n            line = self.rfile.readline()\n            if not line: break\n            print \"%s wrote: %s\" % (self.client_address[0], line.rstrip())\n            self.wfile.write(line)\n        print \"%s disconnected\" % self.client_address[0]\n\n\n# Create the server\nserver = EchoServer((HOST, PORT), EchoRequestHandler)\n\n# Activate the server; this will keep running until you\n# interrupt the program with Ctrl-C\nprint \"server listening on %s:%s\" % server.server_address\nserver.serve_forever()\n\nWorks with: Python version 3.5 or above\n#!/usr/bin/env python\n# $ printf 'echo\\r\\n' | nc localhost 12321\n# echo\nimport asyncio\nimport logging\nimport os\n\nlogger = logging.getLogger('echoserver')\n\nasync def echo_handler(reader, writer):\n  address = writer.get_extra_info('peername')\n  logger.debug('accept: %s', address)\n  message = await reader.readline()\n  writer.write(message)\n  await writer.drain()\n  writer.close()\n\nif __name__ == '__main__':\n  logging.basicConfig()\n  logger.setLevel(logging.DEBUG)\n  loop = asyncio.get_event_loop()\n  factory = asyncio.start_server(\n    echo_handler,\n    os.environ.get('HOST'),\n    os.environ.get('PORT', 12321)\n  )\n  server = loop.run_until_complete(factory)\n  try:\n    loop.run_forever()\n  except KeyboardInterrupt:\n    pass\n  server.close()\n  loop.run_until_complete(server.wait_closed())\n  loop.close()\n\nWorks with: Python version 2 and 3\n\n    #!usr/bin/env python\n    import socket\n    import threading\n\n    HOST = 'localhost'\n    PORT = 12321\n    SOCKET_TIMEOUT = 30\n\n    # This function handles reading data sent by a client, echoing it back\n    # and closing the connection in case of timeout (30s) or \"quit\" command\n    # This function is meant to be started in a separate thread\n    # (one thread per client)\n    def handle_echo(client_connection, client_address):\n        client_connection.settimeout(SOCKET_TIMEOUT)\n        try:\n            while True:\n                data = client_connection.recv(1024)\n                # Close connection if \"quit\" received from client\n                if data == b'quit\\r\\n' or data == b'quit\\n':\n                    print('{} disconnected'.format(client_address))\n                    client_connection.shutdown(1)\n                    client_connection.close()\n                    break\n                # Echo back to client\n                elif data:\n                    print('FROM {}\u00a0: {}'.format(client_address,data))\n                    client_connection.send(data)\n        # Timeout and close connection after 30s of inactivity\n        except socket.timeout:\n            print('{} timed out'.format(client_address))\n            client_connection.shutdown(1)\n            client_connection.close()\n\n    # This function opens a socket and listens on specified port. As soon as a\n    # connection is received, it is transfered to another socket so that the main\n    # socket is not blocked and can accept new clients.\n    def listen(host, port):\n        # Create the main socket (IPv4, TCP)\n        connection = socket.socket(socket.AF_INET, socket.SOCK_STREAM)\n        connection.setsockopt(socket.SOL_SOCKET, socket.SO_REUSEADDR, 1)\n        connection.bind((host, port))\n        # Listen for clients (max 10 clients in waiting)\n        connection.listen(10)\n        # Every time a client connects, allow a dedicated socket and a dedicated\n        # thread to handle communication with that client without blocking others.\n        # Once the new thread has taken over, wait for the next client.\n        while True:\n            current_connection, client_address = connection.accept()\n            print('{} connected'.format(client_address))\n            handler_thread = threading.Thread( \\\n                target = handle_echo, \\\n                args = (current_connection,client_address) \\\n            )\n            # daemon makes sure all threads are killed if the main server process\n            # gets killed\n            handler_thread.daemon = True\n            handler_thread.start()\n\n    if __name__ == \"__main__\":\n        try:\n            listen(HOST, PORT)\n        except KeyboardInterrupt:\n            print('exiting')\n            pass\n\n", "explain": "Using only the low-level socket and threading modules. Supports timing out inactive clients\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "C", "code": "\nWorks with: POSIX\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <errno.h>\n#include <sys/types.h>\n#include <sys/socket.h>\n#include <netdb.h>\n#include <unistd.h>\n#include <sys/wait.h>\n#include <signal.h>\n\n#define MAX_ENQUEUED 20\n#define BUF_LEN 256\n#define PORT_STR \"12321\"\n\n/* ------------------------------------------------------------ */\n/* How to clean up after dead child processes                   */\n/* ------------------------------------------------------------ */\n\nvoid wait_for_zombie(int s)\n{\n    while(waitpid(-1, NULL, WNOHANG) > 0) ;\n}\n\n/* ------------------------------------------------------------ */\n/* Core of implementation of a child process                    */\n/* ------------------------------------------------------------ */\n\nvoid echo_lines(int csock)\n{\n    char buf[BUF_LEN];\n    int r;\n\n    while( (r = read(csock, buf, BUF_LEN)) > 0 ) {\n        (void)write(csock, buf, r);\n    }\n    exit(EXIT_SUCCESS);\n}\n\n/* ------------------------------------------------------------ */\n/* Core of implementation of the parent process                 */\n/* ------------------------------------------------------------ */\n\nvoid take_connections_forever(int ssock)\n{\n    for(;;) {\n        struct sockaddr addr;\n        socklen_t addr_size = sizeof(addr);\n        int csock;\n\n        /* Block until we take one connection to the server socket */\n        csock = accept(ssock, &addr, &addr_size);\n\n        /* If it was a successful connection, spawn a worker process to service it */\n        if ( csock == -1 ) {\n            perror(\"accept\");\n        } else if ( fork() == 0 ) {\n            close(ssock);\n            echo_lines(csock);\n        } else {\n            close(csock);\n        }\n    }\n}\n\n/* ------------------------------------------------------------ */\n/* The server process's one-off setup code                      */\n/* ------------------------------------------------------------ */\n\nint main()\n{\n    struct addrinfo hints, *res;\n    struct sigaction sa;\n    int sock;\n\n    /* Look up the address to bind to */\n    memset(&hints, 0, sizeof(struct addrinfo));\n    hints.ai_family = AF_UNSPEC;\n    hints.ai_socktype = SOCK_STREAM;\n    hints.ai_flags = AI_PASSIVE;\n    if ( getaddrinfo(NULL, PORT_STR, &hints, &res) != 0 ) {\n        perror(\"getaddrinfo\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Make a socket */\n    if ( (sock = socket(res->ai_family, res->ai_socktype, res->ai_protocol)) == -1 ) {\n        perror(\"socket\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Arrange to clean up child processes (the workers) */\n    sa.sa_handler = wait_for_zombie;\n    sigemptyset(&sa.sa_mask);\n    sa.sa_flags = SA_RESTART;\n    if ( sigaction(SIGCHLD, &sa, NULL) == -1 ) {\n        perror(\"sigaction\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Associate the socket with its address */\n    if ( bind(sock, res->ai_addr, res->ai_addrlen) != 0 ) {\n        perror(\"bind\");\n        exit(EXIT_FAILURE);\n    }\n\n    freeaddrinfo(res);\n\n    /* State that we've opened a server socket and are listening for connections */\n    if ( listen(sock, MAX_ENQUEUED) != 0 ) {\n        perror(\"listen\");\n        exit(EXIT_FAILURE);\n    }\n\n    /* Serve the listening socket until killed */\n    take_connections_forever(sock);\n    return EXIT_SUCCESS;\n}\n\n", "explain": "This is a rather standard code (details apart); the reference guide for such a code is the Beej's Guide to Network programming. The dependency from POSIX is mainly in the use of the read and write functions, (using the socket as a file descriptor sometimes make things simpler).\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Java", "code": "\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.OutputStreamWriter;\nimport java.io.PrintWriter;\nimport java.net.ServerSocket;\nimport java.net.Socket;\nimport java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\n\npublic class EchoServer {\n\n    public static void main(String[] args) throws IOException {\n        try (ServerSocket listener = new ServerSocket(12321)) {\n            while (true) {\n                Socket conn = listener.accept();\n                Thread clientThread = new Thread(() -> handleClient(conn));\n                clientThread.start();\n            }\n        }\n    }\n\n    private static void handleClient(Socket connArg) {\n        Charset utf8 = StandardCharsets.UTF_8;\n\n        try (Socket conn = connArg) {\n            BufferedReader in = new BufferedReader(\n                    new InputStreamReader(conn.getInputStream(), utf8));\n\n            PrintWriter out = new PrintWriter(\n                    new OutputStreamWriter(conn.getOutputStream(), utf8),\n                    true);\n\n            String line;\n            while ((line = in.readLine()) != null) {\n                out.println(line);\n            }\n        } catch (IOException e) {\n            e.printStackTrace();\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "C#", "code": "\nusing System.Net.Sockets;\nusing System.Threading;\n\nnamespace ConsoleApplication1\n{\n    class Program\n    {\n        static TcpListener listen;\n        static Thread serverthread;\n\n        static void Main(string[] args)\n        {\n            listen = new TcpListener(System.Net.IPAddress.Parse(\"127.0.0.1\"), 12321);\n            serverthread = new Thread(new ThreadStart(DoListen));\n            serverthread.Start();\n        }\n\n        private static void DoListen()\n        {\n            // Listen\n            listen.Start();\n            Console.WriteLine(\"Server: Started server\");\n\n            while (true)\n            {\n                Console.WriteLine(\"Server: Waiting...\");\n                TcpClient client = listen.AcceptTcpClient();\n                Console.WriteLine(\"Server: Waited\");\n\n                // New thread with client\n                Thread clientThread = new Thread(new ParameterizedThreadStart(DoClient));\n                clientThread.Start(client);\n            }\n        }\n\n        private static void DoClient(object client)\n        {\n            // Read data\n            TcpClient tClient = (TcpClient)client;\n\n            Console.WriteLine(\"Client (Thread: {0}): Connected!\", Thread.CurrentThread.ManagedThreadId);\n            do\n            {\n                if (!tClient.Connected)\n                { \n                    tClient.Close();\n                    Thread.CurrentThread.Abort();       // Kill thread.\n                }\n\n                if (tClient.Available > 0)\n                {\n                    // Resend\n                    byte pByte = (byte)tClient.GetStream().ReadByte();\n                    Console.WriteLine(\"Client (Thread: {0}): Data {1}\", Thread.CurrentThread.ManagedThreadId, pByte);\n                    tClient.GetStream().WriteByte(pByte);\n                }\n\n                // Pause\n                Thread.Sleep(100);\n            } while (true);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "JavaScript", "code": "\nWorks with: Node.js\nconst net = require('net');\n\nfunction handleClient(conn) {\n    console.log('Connection from ' + conn.remoteAddress + ' on port ' + conn.remotePort);\n\n    conn.setEncoding('utf-8');\n\n    let buffer = '';\n\n    function handleData(data) {\n        for (let i = 0; i < data.length; i++) {\n            const char = data.charAt(i);\n            buffer += char;\n            if (char === '\\n') {\n                conn.write(buffer);\n                buffer = '';\n            }\n        }\n    }\n\n    conn.on('data', handleData);\n}\n\nnet.createServer(handleClient).listen(12321, 'localhost');\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "PHP", "code": "\n$socket = socket_create(AF_INET,SOCK_STREAM,SOL_TCP);\nsocket_bind($socket, '127.0.0.1', 12321);\nsocket_listen($socket);\n\n$client_count = 0;\nwhile (true){\n  if (($client = socket_accept($socket)) === false) continue;\n  $client_count++;\n\n  $client_name = 'Unknown';\n  socket_getpeername($client, $client_name);\n  echo \"Client {$client_count} ({$client_name}) connected\\n\";\n  $pid = pcntl_fork();\n  if($pid == -1) die('Could not fork');\n  if($pid){\n    pcntl_waitpid(-1, $status, WNOHANG);\n    continue;\n  }\n\n  //In a child process\n  while(true){\n    if($input = socket_read($client, 1024)){\n      socket_write($client, $input);\n    } else {\n      socket_shutdown($client);\n      socket_close($client);\n      echo \"Client {$client_count} ({$client_name}) disconnected\\n\";\n      exit();\n    }\n  }\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n\t\"net\"\n\t\"bufio\"\n)\n\nfunc echo(s net.Conn, i int) {\n\tdefer s.Close();\n\n\tfmt.Printf(\"%d: %v <-> %v\\n\", i, s.LocalAddr(), s.RemoteAddr())\n\tb := bufio.NewReader(s)\n\tfor {\n\t\tline, e := b.ReadBytes('\\n')\n\t\tif e != nil {\n\t\t\tbreak\n\t\t}\n\t\ts.Write(line)\n\t}\n\tfmt.Printf(\"%d: closed\\n\", i)\n}\n\nfunc main() {\n\tl, e := net.Listen(\"tcp\", \":12321\")\n\tfor i := 0; e == nil; i++ {\n\t\tvar s net.Conn\n\t\ts, e = l.Accept()\n\t\tgo echo(s, i)\n\t}\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "X86_Assembly", "code": "\n; x86_64 Linux NASM\n\nglobal _start\n\n%define af_inet 2\n%define sock_stream 1\n%define default_proto 0\n%define sol_sock 1\n%define reuse_addr 2\n%define reuse_port 15\n%define server_port 9001\n%define addr_any 0\n%define family_offset 0\n%define port_offset 2\n%define addr_offset 4\n%define unused_offset 8\n%define addr_len 16\n%define buffer_len 64\n%define max_connections 3\n\n\nsection .text\n\n; rdi - 16 bit value to be byte swapped\n; return - byte swapped value\nhtn_swap16:\n\n  xor rax, rax\n  mov rdx, 0x000000ff\n\n  mov rsi, rdi\n  and rsi, rdx\n  shl rsi, 8\n  or rax, rsi\n  shl rdx, 8\n\n  mov rsi, rdi\n  and rsi, rdx\n  shr rsi, 8\n  or rax, rsi\n  ret\n\n; return - server socket\ncreate_server_socket:\n\n  mov rax, 41\n  mov rdi, af_inet\n  mov rsi, sock_stream\n  mov rdx, default_proto\n  syscall\n  push rax\n\n  mov rax, 54\n  mov rdi, qword [rsp]\n  mov rsi, sol_sock\n  mov rdx, reuse_addr\n  mov qword [rsp - 16], 1\n  lea r10, [rsp - 16]\n  mov r8, 4\n  syscall\n\n  mov rax, 54\n  mov rdi, qword [rsp]\n  mov rsi, sol_sock\n  mov rdx, reuse_port\n  mov qword [rsp - 16], 1\n  lea r10, [rsp - 16]\n  mov r8, 4\n  syscall\n\n\n  pop rax\n  ret\n\n; rdi - socket\n; rsi - port\n; rdx - connections\n; return - void\nbind_and_listen:\n\n  push rdi\n  push rdx\n\n  mov rdi, rsi\n  call htn_swap16\n\n  lea rsi, [rsp - 16]\n  mov word [rsi + family_offset], af_inet\n  mov word [rsi + port_offset], ax\n  mov dword [rsi + addr_offset], addr_any\n  mov qword [rsi + unused_offset], 0\n\n  mov rax, 49\n  mov rdi, qword [rsp + 8]\n  mov rdx, addr_len\n  syscall\n\n  mov rax, 50\n  pop rsi\n  pop rdi\n  syscall\n  ret\n\n; rdi - server socket\n; return - client socket\naccept:\n\n  mov rax, 43\n  lea rsi, [rsp - 16]\n  lea rdx, [rsp - 24]\n  syscall\n  ret\n\n; rdi - client socket\n; return - void\necho:\n\n  push rdi\n  mov rax, 0\n  lea rsi, [rsp - 104]\n  mov rdx, buffer_len\n  syscall\n\n  pop rdi\n  mov rdx, rax \n  lea rsi, [rsp - 112]\n  mov rax, 1\n  syscall\n  ret\n\n\n_start:\n\n  call create_server_socket\n  mov r14, rax\n\n  mov rdi, rax\n  mov rsi, server_port\n  mov rdx, max_connections\n  call bind_and_listen\n\naccept_connection:\n\n  mov rdi, r14\n  call accept\n\n  mov r15, rax\n  mov rax, 57\n  syscall\n\n  test rax, rax\n  jz handle_connection\n\n \u00a0; close client socket\n  mov rax, 3\n  mov rdi, r15\n  syscall\n  jmp accept_connection\n    \nhandle_connection:\n\n  mov rdi, r15\n  call echo\n\n  close_client:\n    mov rax, 3\n    mov rdi, r15\n    syscall\n\n  close_server:\n    mov rax, 3\n    mov rdi, r14\n    syscall\n\n  exit:\n    mov rax, 60\n    xor rdi, rdi\n    syscall\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Delphi", "code": "\nprogram EchoServer;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, IdContext, IdTCPServer;\n\ntype\n  TEchoServer = class\n  private\n    FTCPServer: TIdTCPServer;\n  public\n    constructor Create;\n    destructor Destroy; override;\n    procedure TCPServerExecute(AContext: TIdContext);\n  end;\n\nconstructor TEchoServer.Create;\nbegin\n  FTCPServer := TIdTCPServer.Create(nil);\n  FTCPServer.DefaultPort := 12321;\n  FTCPServer.OnExecute := TCPServerExecute;\n  FTCPServer.Active := True;\nend;\n\ndestructor TEchoServer.Destroy;\nbegin\n  FTCPServer.Active := False;\n  FTCPServer.Free;\n  inherited Destroy;\nend;\n\nprocedure TEchoServer.TCPServerExecute(AContext: TIdContext);\nvar\n  lCmdLine: string;\nbegin\n  lCmdLine := AContext.Connection.IOHandler.ReadLn;\n  Writeln('>' + lCmdLine);\n  AContext.Connection.IOHandler.Writeln('>' + lCmdLine);\n\n  if SameText(lCmdLine, 'QUIT') then\n  begin\n    AContext.Connection.IOHandler.Writeln('Disconnecting');\n    AContext.Connection.Disconnect;\n  end;\nend;\n\nvar\n  lEchoServer: TEchoServer;\nbegin\n  lEchoServer := TEchoServer.Create;\n  try\n    Writeln('Delphi Echo Server');\n    Writeln('Press Enter to quit');\n    Readln;\n  finally\n    lEchoServer.Free;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Ruby", "code": "\nrequire 'socket'\nserver = TCPServer.new(12321)\n\nwhile (connection = server.accept)\n  Thread.new(connection) do |conn|\n    port, host = conn.peeraddr[1,2]\n    client = \"#{host}:#{port}\"\n    puts \"#{client} is connected\"\n    begin\n      loop do\n        line = conn.readline\n        puts \"#{client} says: #{line}\"\n        conn.puts(line)\n      end\n    rescue EOFError\n      conn.close\n      puts \"#{client} has disconnected\"\n    end\n  end\nend\n\n\nWorks with: Ruby version 1.9.2\nrequire 'socket'\n\nSocket.tcp_server_loop(12321) do |conn, addr|\n  Thread.new do\n    client = \"#{addr.ip_address}:#{addr.ip_port}\"\n    puts \"#{client} is connected\"\n    begin\n      loop do\n        line = conn.readline\n        puts \"#{client} says: #{line}\"\n        conn.puts(line)\n      end\n    rescue EOFError\n      conn.close\n      puts \"#{client} has disconnected\"\n    end\n  end\nend\n\n", "explain": "Ruby 1.9.2 introduced an alternate method to create TCP server sockets. The Socket.tcp_server_loop method encapsulates the guts of the server into a block.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Rust", "code": "\nuse std::net::{TcpListener, TcpStream};\nuse std::io::{BufReader, BufRead, Write};\nuse std::thread;\n\nfn main() {\n    let listener = TcpListener::bind(\"127.0.0.1:12321\").unwrap();\n    println!(\"server is running on 127.0.0.1:12321 ...\");\n    \n    for stream in listener.incoming() {\n        let stream = stream.unwrap();\n        thread::spawn(move || handle_client(stream));\n    }\n}\n\nfn handle_client(stream: TcpStream) {\n    let mut stream = BufReader::new(stream);\n    loop {\n        let mut buf = String::new();\n        if stream.read_line(&mut buf).is_err() {\n            break;\n        }\n        stream\n            .get_ref()\n            .write(buf.as_bytes())\n            .unwrap();\n    }\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Ada", "code": "\nWorks with: GNAT\n\nwith Ada.Text_IO;\nwith Ada.IO_Exceptions;\nwith GNAT.Sockets;\nprocedure Echo_Server is\n   Receiver   : GNAT.Sockets.Socket_Type;\n   Connection : GNAT.Sockets.Socket_Type;\n   Client     : GNAT.Sockets.Sock_Addr_Type;\n   Channel    : GNAT.Sockets.Stream_Access;\nbegin\n   GNAT.Sockets.Create_Socket (Socket => Receiver);\n   GNAT.Sockets.Set_Socket_Option\n     (Socket => Receiver,\n      Level  => GNAT.Sockets.Socket_Level,\n      Option => (Name    => GNAT.Sockets.Reuse_Address, Enabled => True));\n   GNAT.Sockets.Bind_Socket\n     (Socket  => Receiver,\n      Address => (Family => GNAT.Sockets.Family_Inet,\n                  Addr   => GNAT.Sockets.Inet_Addr (\"127.0.0.1\"),\n                  Port   => 12321));\n   GNAT.Sockets.Listen_Socket (Socket => Receiver);\n   loop\n      GNAT.Sockets.Accept_Socket\n        (Server  => Receiver,\n         Socket  => Connection,\n         Address => Client);\n      Ada.Text_IO.Put_Line\n        (\"Client connected from \" & GNAT.Sockets.Image (Client));\n      Channel := GNAT.Sockets.Stream (Connection);\n      begin\n         loop\n            Character'Output (Channel, Character'Input (Channel));\n         end loop;\n      exception\n         when Ada.IO_Exceptions.End_Error =>\n            null;\n      end;\n      GNAT.Sockets.Close_Socket (Connection);\n   end loop;\nend Echo_Server;\n\n\nwith Ada.Text_IO;\nwith Ada.IO_Exceptions;\nwith GNAT.Sockets;\nprocedure echo_server_multi is\n-- Multiple socket connections example based on Rosetta Code echo server.\n\n   Tasks_To_Create : constant := 3; -- simultaneous socket connections.\n\n-------------------------------------------------------------------------------\n-- Use stack to pop the next free task index. When a task finishes its\n-- asynchronous (no rendezvous) phase, it pushes the index back on the stack.\n   type Integer_List is array (1..Tasks_To_Create) of integer;\n   subtype Counter is integer range 0 .. Tasks_To_Create;\n   subtype Index is integer range 1 .. Tasks_To_Create;\n   protected type Info is\n      procedure Push_Stack (Return_Task_Index : in Index);\n      procedure Initialize_Stack;\n      entry Pop_Stack (Get_Task_Index : out Index);\n   private\n      Task_Stack   : Integer_List; -- Stack of free-to-use tasks.\n      Stack_Pointer: Counter := 0;\n   end Info;\n\n   protected body Info is\n      procedure Push_Stack (Return_Task_Index : in Index) is\n      begin -- Performed by tasks that were popped, so won't overflow.\n         Stack_Pointer := Stack_Pointer + 1;\n         Task_Stack(Stack_Pointer) := Return_Task_Index;\n      end;\n\n      entry Pop_Stack (Get_Task_Index : out Index) when Stack_Pointer /= 0 is\n      begin -- guarded against underflow.\n         Get_Task_Index := Task_Stack(Stack_Pointer);\n         Stack_Pointer := Stack_Pointer -  1;\n      end;         \n\n      procedure Initialize_Stack is\n      begin\n         for I in Task_Stack'range loop\n            Push_Stack (I);\n         end loop;\n      end;\n   end Info;\n\n   Task_Info : Info;\n     \n-------------------------------------------------------------------------------\n   task type SocketTask is\n      -- Rendezvous the setup, which sets the parameters for entry Echo.\n      entry Setup (Connection : GNAT.Sockets.Socket_Type;\n                   Client     : GNAT.Sockets.Sock_Addr_Type;\n                   Channel    : GNAT.Sockets.Stream_Access;\n                   Task_Index : Index);\n      -- Echo accepts the asynchronous phase, i.e. no rendezvous. When the\n      -- communication is over, push the task number back on the stack.\n      entry Echo;\n   end SocketTask;\n\n   task body SocketTask is\n      my_Connection : GNAT.Sockets.Socket_Type;\n      my_Client     : GNAT.Sockets.Sock_Addr_Type;\n      my_Channel    : GNAT.Sockets.Stream_Access;\n      my_Index      : Index;\n   begin\n      loop -- Infinitely reusable\n         accept Setup (Connection : GNAT.Sockets.Socket_Type; \n                       Client  : GNAT.Sockets.Sock_Addr_Type; \n                       Channel : GNAT.Sockets.Stream_Access;\n                       Task_Index   : Index) do\n            -- Store parameters and mark task busy.\n            my_Connection := Connection;\n            my_Client     := Client;\n            my_Channel    := Channel;\n            my_Index      := Task_Index;\n         end;\n   \n         accept Echo; -- Do the echo communications.\n         begin\n            Ada.Text_IO.Put_Line (\"Task \" & integer'image(my_Index));\n            loop\n               Character'Output (my_Channel, Character'Input(my_Channel));\n            end loop;\n         exception\n            when Ada.IO_Exceptions.End_Error =>\n              Ada.Text_IO.Put_Line (\"Echo \" & integer'image(my_Index) & \" end\");\n            when others => \n              Ada.Text_IO.Put_Line (\"Echo \" & integer'image(my_Index) & \" err\");\n         end;\n         GNAT.Sockets.Close_Socket (my_Connection);\n         Task_Info.Push_Stack (my_Index); -- Return to stack of unused tasks.\n      end loop;\n   end SocketTask;\n\n-------------------------------------------------------------------------------\n-- Setup the socket receiver, initialize the task stack, and then loop,\n-- blocking on Accept_Socket, using Pop_Stack for the next free task from the\n-- stack, waiting if necessary.\n   task type SocketServer (my_Port : GNAT.Sockets.Port_Type) is\n      entry Listen;\n   end SocketServer;\n\n   task body SocketServer is\n   Receiver   : GNAT.Sockets.Socket_Type;\n   Connection : GNAT.Sockets.Socket_Type;\n   Client     : GNAT.Sockets.Sock_Addr_Type;\n   Channel    : GNAT.Sockets.Stream_Access;\n   Worker     : array (1..Tasks_To_Create) of SocketTask;\n   Use_Task   : Index;\n\n   begin\n      accept Listen;\n      GNAT.Sockets.Create_Socket (Socket => Receiver);\n      GNAT.Sockets.Set_Socket_Option\n        (Socket => Receiver,\n         Level  => GNAT.Sockets.Socket_Level,\n         Option => (Name    => GNAT.Sockets.Reuse_Address, Enabled => True));\n      GNAT.Sockets.Bind_Socket\n        (Socket  => Receiver,\n         Address => (Family => GNAT.Sockets.Family_Inet,\n                     Addr   => GNAT.Sockets.Inet_Addr (\"127.0.0.1\"),\n                     Port   => my_Port));\n      GNAT.Sockets.Listen_Socket (Socket => Receiver);\n      Task_Info.Initialize_Stack;\nFind: loop -- Block for connection and take next free task.\n         GNAT.Sockets.Accept_Socket\n           (Server  => Receiver,\n            Socket  => Connection,\n            Address => Client);\n         Ada.Text_IO.Put_Line (\"Connect \" & GNAT.Sockets.Image(Client));\n         Channel := GNAT.Sockets.Stream (Connection);\n         Task_Info.Pop_Stack(Use_Task); -- Protected guard waits if full house.\n         -- Setup the socket in this task in rendezvous.\n         Worker(Use_Task).Setup(Connection,Client, Channel,Use_Task);\n         -- Run the asynchronous task for the socket communications.\n         Worker(Use_Task).Echo; -- Start echo loop.\n      end loop Find;\n   end SocketServer;\n\n   Echo_Server : SocketServer(my_Port => 12321);\n\n-------------------------------------------------------------------------------\nbegin\n   Echo_Server.Listen;\nend echo_server_multi;\n\n", "explain": "single-threaded, one client served at a time.\nMulti-threaded, multiple clients served. On OS X 10.10.5 with gcc 4.9.1, serves a maximum of about 2000 threads (communication tasks) per process.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Julia", "code": "\nusing Sockets # for version 1.0\nprintln(\"Echo server on port 12321\")\ntry\n    server = listen(12321)\n    instance = 0\n    while true\n        sock = accept(server)\n        instance += 1\n        socklabel = \"$(getsockname(sock)) number $instance\"\n        @async begin \n            println(\"Server connected to socket $socklabel\")\n            write(sock, \"Connected to echo server.\\r\\n\")\n            while isopen(sock)\n                str = readline(sock)\n                write(sock,\"$str\\r\\n\")\n                println(\"Echoed $str to socket $socklabel\")\n            end\n            println(\"Closed socket $socklabel\")\n        end\n    end\ncatch y\n    println(\"Caught exception: $y\")\nend\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Kotlin", "code": "\nTranslation of: Java\nimport java.net.ServerSocket\nimport java.net.Socket\n\nfun main() {\n\n    fun handleClient(conn: Socket) {\n        conn.use {\n            val input = conn.inputStream.bufferedReader()\n            val output = conn.outputStream.bufferedWriter()\n\n            input.forEachLine { line ->\n                output.write(line)\n                output.newLine()\n                output.flush()\n            }\n        }\n    }\n\n    ServerSocket(12321).use { listener ->\n        while (true) {\n            val conn = listener.accept()\n            Thread { handleClient(conn) }.start()\n        }\n    }\n}\n\n\nOutput:\n\nnc localhost 12321\nHello\nHello\nGoodbye\nGoodbye\n\n", "explain": "Quick test using netcat:\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Perl", "code": "\n\nuse IO::Socket;\nmy $use_fork = 1;\n\nmy $sock = new IO::Socket::INET (\n                                 LocalHost => '127.0.0.1',\n                                 LocalPort => '12321',\n                                 Proto => 'tcp',\n                                 Listen => 1,   # maximum queued connections\n                                 Reuse => 1,\n                                )\n\t\tor die \"socket: $!\";\t# no newline, so perl appends stuff\n\n$SIG{CHLD} = 'IGNORE' if $use_fork;\t# let perl deal with zombies\n\nprint \"listening...\\n\";\nwhile (1) {\n\t# declare $con 'my' so it's closed by parent every loop\n        my $con = $sock->accept()\n\t\tor die \"accept: $!\";\n\tfork and next if $use_fork;\t# following are for child only\n\n\tprint \"incoming..\\n\";\n\tprint $con $_ while(<$con>);\t# read each line and write back\n\tprint \"done\\n\";\n\n\tlast\tif $use_fork;\t# if not forking, loop\n}\n\n# child will reach here and close its copy of $sock before exit\n\n\npackage Echo;\nuse base 'Net::Server::Fork';\nsub process_request {\n    print while <STDIN>;\n}\nEcho->run(port => 12321, log_level => 3);\n\n\npackage Echo;\nuse base 'Net::Server::PreFork';\nsub process_request {\n    print while <STDIN>;\n}\nEcho->run(port => 12321, log_level => 3);\n\n\n", "explain": "This server will run indefinitely listening in the port 12321 and forking every time a client connects, the childs listen to the client and write back.\nThis is an example using the IO::Socket module:\nThis is an equivalent program using the Net::Server module:\nIt also prints the IP address and port number of every connection.\nThis is a more complicated example using preforking:\nBy default it spawns 5 child processes at startup, makes sure there are always at least 2 and at most 10 spare children available for new requests, each of which will be killed after processing 1000 requests and new ones will take their place.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Lua", "code": "\nWorks with: Lua version 5.3\nLibrary: LuaSocket\nlocal socket = require(\"socket\")\n\nlocal function has_value(tab, value)\n    for i, v in ipairs(tab) do\n        if v == value then return i end\n    end\n    return false\nend\n\nlocal function checkOn(client)\n   local line, err = client:receive()\n\tif line then\n\t\tclient:send(line .. \"\\n\")\n\tend\n\tif err and err ~= \"timeout\" then\n\t\tprint(tostring(client) .. \" \" .. err)\n\t\tclient:close()\n\t\treturn true  -- end this connection\n   end\n\treturn false  -- do not end this connection\nend\n\nlocal server = assert(socket.bind(\"*\",12321))\nserver:settimeout(0)  -- make non-blocking\nlocal connections = { }  -- a list of the client connections\nwhile true do\n\tlocal newClient = server:accept()\n\tif newClient then\n\t\tnewClient:settimeout(0)  -- make non-blocking\n\t\ttable.insert(connections, newClient)\n\tend\n\tlocal readList = socket.select({server, table.unpack(connections)})\n\tfor _, conn in ipairs(readList) do\n\t\tif conn ~= server and checkOn(conn) then\n\t\t\ttable.remove(connections, has_value(connections, conn))\n\t\tend\n\tend\nend\n\n\n\nlocal socket=require(\"socket\")\n\nfunction checkOn (client)\n    local line, err = client:receive()\n    if line then\n        print(tostring(client) .. \" said \" .. line)\n        client:send(line .. \"\\n\")\n    end\n    if err and err ~= \"timeout\" then\n        print(tostring(client) .. \" \" .. err)\n        client:close()\n        return true  -- end this connection\n    end\n    return false    -- do not end this connection\nend\n\nlocal delay = 0.004  -- anything less than this uses up my CPU\nlocal connections = {}  -- an array of connections\nlocal newClient\nlocal server = assert(socket.bind(\"*\", 12321))\nserver:settimeout(delay)\nwhile true do\n    repeat\n        newClient = server:accept()\n        for idx, client in ipairs(connections) do\n            if checkOn(client) then table.remove(connections, idx) end\n        end\n    until newClient\n    newClient:settimeout(delay)\n    print(tostring(newClient) .. \" connected\")\n    table.insert(connections, newClient)\nend\n\n\nWorks with: Luvit\nlocal http = require(\"http\")\n\nhttp.createServer(function(req, res)\n\tprint((\"Connection from %s\"):format(req.socket:address().ip))\n\n\tlocal chunks = {}\n\tlocal function dumpChunks()\n\t\tfor i=1,#chunks do\n\t\t\tres:write(table.remove(chunks, 1))\n\t\tend\n\tend\n\n\treq:on(\"data\", function(data)\n\t\tfor line, nl in data:gmatch(\"([^\\n]+)(\\n?)\") do\n\t\t\tif nl == \"\\n\" then\n\t\t\t\tdumpChunks()\n\t\t\t\tres:write(line)\n\t\t\t\tres:write(\"\\n\")\n\t\t\telse\n\t\t\t\ttable.insert(chunks, line)\n\t\t\tend\n\t\tend\n\tend)\n\n\treq:on(\"end\", function()\n\t\tdumpChunks()\n\t\tres:finish()\n\tend)\nend):listen(12321, \"127.0.0.1\")\n\nprint(\"Server running at http://127.0.0.1:12321/\")\n\n", "explain": "The following implementation uses tiny delays rather than socket.select.  It uses a table of not-quite-non-blocking socket client objects (they block for 4 milliseconds), which is iterated over to check on whether each one has either a line to echo or an error to warrant deletion.  Without the millisecond delays, the whole thing would become one 'hot' loop and eat all the CPU time for one core.  With them, it uses close to zero percent.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Scala", "code": "\nimport java.io.PrintWriter\nimport java.net.{ServerSocket, Socket}\n\nimport scala.io.Source\n\nobject EchoServer extends App {\n  private val serverSocket = new ServerSocket(23)\n  private var numConnections = 0\n\n  class ClientHandler(clientSocket: Socket) extends Runnable {\n    private val (connectionId, closeCmd) = ({numConnections += 1; numConnections}, \":exit\")\n\n    override def run(): Unit =\n      new PrintWriter(clientSocket.getOutputStream, true) {\n        println(s\"Connection opened, close with entering '$closeCmd'.\")\n        Source.fromInputStream(clientSocket.getInputStream).getLines\n          .takeWhile(!_.toLowerCase.startsWith(closeCmd))\n          .foreach { line =>\n            Console.println(s\"Received on #$connectionId: $line\")\n            println(line)  // Echo\n          }\n        Console.println(s\"Gracefully closing connection, #$connectionId\")\n        clientSocket.close()\n    }\n\n    println(s\"Handling connection, $connectionId\")\n  }\n\n  while (true) new Thread(new ClientHandler(serverSocket.accept())).start()\n}\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "D", "code": "\n\nimport std.array, std.socket;\n\nvoid main() {\n    auto listener = new TcpSocket;\n    assert(listener.isAlive);\n    listener.bind(new InternetAddress(12321));\n    listener.listen(10);\n\n    Socket currSock;\n    uint bytesRead;\n    ubyte[1] buff;\n\n    while (true) {\n        currSock = listener.accept();\n        while ((bytesRead = currSock.receive(buff)) > 0)\n            currSock.send(buff);\n        currSock.close();\n        buff.clear();\n    }\n}\n\n\nimport std.stdio, std.socket, std.array;\n\nvoid main() {\n    enum ushort port = 7;\n    enum int backlog = 10;\n    enum int max_connections = 60;\n    enum BUFFER_SIZE = 16;\n\n    auto listener = new TcpSocket;\n    assert(listener.isAlive);\n    listener.bind(new InternetAddress(port));\n    listener.listen(backlog);\n    debug writeln(\"Listening on port \", port);\n\n    // Room for listener.\n    auto sset = new SocketSet(max_connections + 1);\n\n    Socket[] sockets;\n    char[BUFFER_SIZE] buf;\n\n    for (;; sset.reset()) {\n        sset.add(listener);\n        foreach (each; sockets)\n            sset.add(each);\n\n        // Update socket set with only those sockets that have data\n        // avaliable for reading. Options are for read, write,\n        // and error.\n        Socket.select(sset, null, null);\n\n        // Read the data from each socket remaining, and handle\n        // the request.\n        for (int i = 0; ; i++) {\nNEXT:\n            if (i == sockets.length)\n                break;\n            if (sset.isSet(sockets[i])) {\n                int read = sockets[i].receive(buf);\n                if (Socket.ERROR == read) {\n                    debug writeln(\"Connection error.\");\n                    goto SOCK_DOWN;\n                } else if (read == 0) {\n                    debug {\n                        try {\n                            // If the connection closed due to an\n                            // error, remoteAddress() could fail.\n                            writefln(\"Connection from %s closed.\",\n                                     sockets[i].remoteAddress()\n                                     .toString());\n                        } catch (SocketException) {\n                            writeln(\"Connection closed.\");\n                        }\n                    }\nSOCK_DOWN:\n                    sockets[i].close(); //Release socket resources now.\n\n                    // Remove from socket from sockets, and id from\n                    // threads.\n                    if (i != sockets.length - 1)\n                        sockets[i] = sockets.back;\n                    sockets.length--;\n                    debug writeln(\"\\tTotal connections: \",\n                                  sockets.length);\n                    goto NEXT; // -i- is still the NEXT index.\n                } else {\n                    debug\n                        writefln(\"Received %d bytes from %s:\"\n                                 ~ \"\\n-----\\n%s\\n-----\",\n                                 read,\n                                 sockets[i].remoteAddress().toString(),\n                                 buf[0 .. read]);\n\n                    // Echo what was sent.\n                    sockets[i].send(buf[0 .. read]);\n                }\n            }\n        }\n\n        // Connection request.\n        if (sset.isSet(listener)) {\n            Socket sn;\n            try {\n                if (sockets.length < max_connections) {\n                    sn = listener.accept();\n                    debug writefln(\"Connection from %s established.\",\n                                   sn.remoteAddress().toString());\n                    assert(sn.isAlive);\n                    assert(listener.isAlive);\n                    sockets ~= sn;\n                    debug writefln(\"\\tTotal connections: %d\",\n                                   sockets.length);\n                } else {\n                    sn = listener.accept();\n                    debug writefln(\"Rejected connection from %s;\"\n                                   ~ \" too many connections.\",\n                                   sn.remoteAddress().toString());\n                    assert(sn.isAlive);\n                    sn.close();\n                    assert(!sn.isAlive);\n                    assert(listener.isAlive);\n                }\n            } catch (Exception e) {\n                debug writefln(\"Error accepting: %s\", e.toString());\n                if (sn)\n                    sn.close();\n            }\n        }\n    }\n}\n\n", "explain": "This is a very basic server that processes the buffers one character at a time.  In a real-world application, the buffers would be larger. More seriously, it processes one listener at a time. If the currSock.receive() blocks, the loop will not process other clients. This opens the door for a trivial denial-of-service attack. A realistic echo service must multiplex clients.\nThis example will handle many connections.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Haskell", "code": "\nmodule Main where\nimport Network (withSocketsDo, accept, listenOn, sClose, PortID(PortNumber))\nimport Control.Monad (forever)\nimport System.IO (hGetLine, hPutStrLn, hFlush, hClose)\nimport System.IO.Error (isEOFError)\nimport Control.Concurrent (forkIO)\nimport Control.Exception (bracket)\n\n-- For convenience in testing, ensure that the listen socket is closed if the main loop is aborted\nwithListenOn port body = bracket (listenOn port) sClose body\n\necho (handle, host, port) = catch (forever doOneLine) stop where\n  doOneLine = do line <- hGetLine handle\n                 print (host, port, init line)\n                 hPutStrLn handle line\n                 hFlush handle\n  stop error = do putStrLn $ \"Closed connection from \" ++ show (host, port) ++ \" due to \" ++ show error\n                  hClose handle\n\nmain = withSocketsDo $\n  withListenOn (PortNumber 12321) $ \\listener ->\n    forever $ do\n      acc@(_, host, port) <- accept listener\n      putStrLn $ \"Accepted connection from \" ++ show (host, port)\n      forkIO (echo acc)\n\n", "explain": ""}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "Scheme", "code": "\nWorks with: Guile\n\n; Needed in Guile for read-line\n(use-modules (ice-9 rdelim))\n\n; Variable used to hold child PID returned from forking\n(define child #f)\n\n; Start listening on port 12321 for connections from any address\n(let ((s (socket PF_INET SOCK_STREAM 0)))\n  (setsockopt s SOL_SOCKET SO_REUSEADDR 1)\n  (bind s AF_INET INADDR_ANY 12321)\n  (listen s 5) ; Queue size of 5\n\n  (simple-format #t \"Listening for clients in pid: ~S\" (getpid))\n  (newline)\n\n; Wait for connections forever\n  (while #t\n    (let* ((client-connection (accept s))\n        (client-details (cdr client-connection))\n        (client (car client-connection)))\n; Once something connects fork\n      (set! child (primitive-fork))\n      (if (zero? child)\n      (begin\n; Then have child fork to avoid zombie children (grandchildren aren't our responsibility)\n        (set! child (primitive-fork))\n        (if (zero? child)\n          (begin\n; Display some connection details\n          (simple-format #t \"Got new client connection: ~S\" client-details)\n          (newline)\n          (simple-format #t \"Client address: ~S\"\n            (gethostbyaddr (sockaddr:addr client-details)))\n          (newline)\n; Wait for input from client and then echo the input back forever (or until client quits)\n          (do ((line (read-line client)(read-line client))) ((zero? 1))\n            (display line client)(newline client))))\n; Child exits after spawning grandchild.\n        (primitive-exit))\n; Parent waits for child to finish spawning grandchild\n      (waitpid child)))))\n\n", "explain": "Based on the Guile Internet Socket Server Example.\n"}, {"task_name": "Echo server", "task_url": "https://rosettacode.org/wiki/Echo_server", "task_cat": "Networking and Web Interaction", "lang": "F#", "code": "\nopen System.IO\nopen System.Net\nopen System.Net.Sockets\n\nlet service (client:TcpClient) =\n    use stream = client.GetStream()\n    use out = new StreamWriter(stream, AutoFlush = true)\n    use inp = new StreamReader(stream)\n    while not inp.EndOfStream do\n        match inp.ReadLine() with\n        | line -> printfn \"< %s\" line\n                  out.WriteLine(line)\n    printfn \"closed %A\" client.Client.RemoteEndPoint\n    client.Close |> ignore\n\nlet EchoService = \n    let socket = new TcpListener(IPAddress.Loopback, 12321)\n    do socket.Start()\n    printfn \"echo service listening on %A\" socket.Server.LocalEndPoint\n    while true do\n        let client = socket.AcceptTcpClient()\n        printfn \"connect from %A\" client.Client.RemoteEndPoint\n        let job = async {\n            use c = client in try service client with _ -> () }\n        Async.Start job\n\n[<EntryPoint>]\nlet main _ =\n    EchoService\n    0\n\n", "explain": ""}]