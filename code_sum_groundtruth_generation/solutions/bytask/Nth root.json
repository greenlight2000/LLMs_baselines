[{"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nfrom decimal import Decimal, getcontext\n\ndef nthroot (n, A, precision):\n    getcontext().prec = precision\n    \n    n = Decimal(n)\n    x_0 = A / n #step 1: make a while guess.\n    x_1 = 1     #need it to exist before step 2\n    while True:\n        #step 2:\n        x_0, x_1 = x_1, (1 / n)*((n - 1)*x_0 + (A / (x_0 ** (n - 1))))\n        if x_0 == x_1:\n            return x_1\n\nprint nthroot(5, 34, 10)\nprint nthroot(10,42, 20)\nprint nthroot(2, 5, 400)\n\n\nWorks with: Python version 3.7\n'''Nth Root'''\n\nfrom decimal import Decimal, getcontext\nfrom operator import eq\n\n\n# nthRoot\u00a0:: Int -> Int -> Int -> Real\ndef nthRoot(precision):\n    '''The nth root of x at the given precision.'''\n    def go(n, x):\n        getcontext().prec = precision\n        dcn = Decimal(n)\n\n        def same(ab):\n            return eq(*ab)\n\n        def step(ab):\n            a, b = ab\n            predn = pred(dcn)\n            return (\n                b,\n                reciprocal(dcn) * (\n                    predn * a + (\n                        x / (a ** predn)\n                    )\n                )\n            )\n        return until(same)(step)(\n            (x / dcn, 1)\n        )[0]\n    return lambda n: lambda x: go(n, x)\n\n\n# --------------------------TEST---------------------------\ndef main():\n    '''Nth roots at various precisions'''\n\n    def xShow(tpl):\n        p, n, x = tpl\n        return rootName(n) + (\n            ' of ' + str(x) + ' at precision ' + str(p)\n        )\n\n    def f(tpl):\n        p, n, x = tpl\n        return nthRoot(p)(n)(x)\n\n    print(\n        fTable(main.__doc__ + ':\\n')(xShow)(str)(f)(\n            [(10, 5, 34), (20, 10, 42), (30, 2, 5)]\n        )\n    )\n\n\n# -------------------------DISPLAY-------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n# (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n       f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# -------------------------GENERIC-------------------------\n\n# rootName\u00a0:: Int -> String\ndef rootName(n):\n    '''English ordinal suffix.'''\n    return ['identity', 'square root', 'cube root'][n - 1] if (\n        4 > n or 1 > n\n    ) else (str(n) + 'th root')\n\n\n# pred\u00a0::  Enum a => a -> a\ndef pred(x):\n    '''The predecessor of a value. For numeric types, (- 1).'''\n    return x - 1\n\n\n# reciprocal\u00a0:: Num -> Num\ndef reciprocal(x):\n    '''Arithmetic reciprocal of x.'''\n    return 1 / x\n\n\n# until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\ndef until(p):\n    '''The result of repeatedly applying f until p holds.\n       The initial seed value is x.\n    '''\n    def go(f, x):\n        v = x\n        while not p(v):\n            v = f(v)\n        return v\n    return lambda f: lambda x: go(f, x)\n\n\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nNth roots at various precisions:\n\n  5th root of 34 at precision 10 -> 2.024397458\n 10th root of 42 at precision 20 -> 1.4531984602822678165\nsquare root of 5 at precision 30 -> 2.23606797749978969640917366873\n", "explain": "Or, in terms of a general until function:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <float.h>\n\ndouble pow_ (double x, int e) {\n    int i;\n    double r = 1;\n    for (i = 0; i < e; i++) {\n        r *= x;\n    }\n    return r;\n}\n\ndouble root (int n, double x) {\n    double d, r = 1;\n    if (!x) {\n        return 0;\n    }\n    if (n < 1 || (x < 0 && !(n&1))) {\n        return 0.0 / 0.0; /* NaN */\n    }\n    do {\n        d = (x / pow_(r, n - 1) - r) / n;\n        r += d;\n    }\n    while (d >= DBL_EPSILON * 10 || d <= -DBL_EPSILON * 10);\n    return r;\n}\n\nint main () {\n    int n = 15;\n    double x = pow_(-3.14159, 15);\n    printf(\"root(%d, %g) = %g\\n\", n, x, root(n, x));\n    return 0;\n}\n\n", "explain": "Implemented without using math library, because if we were to use pow(), the whole exercise wouldn't make sense.\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\ndouble NthRoot(double m_nValue, double index, double guess, double pc)\n   {\n       double result = guess;\n       double result_next;\n       do\n       {\n           result_next = (1.0/index)*((index-1.0)*result+(m_nValue)/(pow(result,(index-1.0))));\n           result = result_next;\n           pc--;\n       }while(pc>1);\n       return result;\n   };\n\ndouble NthRoot(double value, double degree)\n{\n    return pow(value, (double)(1 / degree));\n};\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nTranslation of: Fortran\npublic static double nthroot(int n, double A) {\n\treturn nthroot(n, A, .001);\n}\npublic static double nthroot(int n, double A, double p) {\n\tif(A < 0) {\n\t\tSystem.err.println(\"A < 0\");// we handle only real positive numbers\n\t\treturn -1;\n\t} else if(A == 0) {\n\t\treturn 0;\n\t}\n\tdouble x_prev = A;\n\tdouble x = A / n;  // starting \"guessed\" value...\n\twhile(Math.abs(x - x_prev) > p) {\n\t\tx_prev = x;\n\t\tx = ((n - 1.0) * x + A / Math.pow(x, n - 1.0)) / n;\n\t}\n\treturn x;\n}\n\nTranslation of: E\npublic static double nthroot(int n, double x) {\n  assert (n > 1 && x > 0);\n  int np = n - 1;\n  double g1 = x;\n  double g2 = iter(g1, np, n, x);\n  while (g1 != g2) {\n    g1 = iter(g1, np, n, x);\n    g2 = iter(iter(g2, np, n, x), np, n, x);\n  }\n  return g1;\n}\n\nprivate static double iter(double g, int np, int n, double x) {\n  return (np * g + x / Math.pow(g, np)) / n;\n}\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nstatic void Main(string[] args)\n{\n\tConsole.WriteLine(NthRoot(81,2,.001));\n        Console.WriteLine(NthRoot(1000,3,.001));\n        Console.ReadLine();\n}\n\npublic static double NthRoot(double A,int n,  double p)\n{\n\tdouble _n= (double) n;\n\tdouble[] x = new double[2];\t\t\n\tx[0] = A;\n\tx[1] = A/_n;\n\twhile(Math.Abs(x[0] -x[1] ) > p)\n\t{\n\t\tx[1] = x[0];\n\t\tx[0] = (1/_n)*(((_n-1)*x[1]) + (A/Math.Pow(x[1],_n-1)));\n\t\t\t\n\t}\n\treturn x[0];\n}\n\n", "explain": "Almost exactly how C works.\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\nfunction nthRoot(num, nArg, precArg) {\n  var n = nArg || 2;\n  var prec = precArg || 12;\n  \n  var x = 1; // Initial guess.\n  for (var i=0; i<prec; i++) {\n    x = 1/n * ((n-1)*x + (num / Math.pow(x, n-1)));\n  }\n  \n  return x;\n}\n\n", "explain": "Gives the n:nth root of num, with precision prec. (n defaults to 2 [e.g. sqrt], prec defaults to 12.)\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nfunction nthroot($number, $root, $p = P)\n{\n    $x[0] = $number;\n    $x[1] = $number/$root;\n    while(abs($x[1]-$x[0]) > $p)\n    {\n        $x[0] = $x[1];\n        $x[1] = (($root-1)*$x[1] + $number/pow($x[1], $root-1))/$root;\n    }\n    return $x[1];\n}\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\nfunction answer = nthRoot(number,root)\n\n    format long\n\n    answer = number / root;\n    guess = number;\n    \n    while not(guess == answer)\n       guess = answer;\n       answer = (1/root)*( ((root - 1)*guess) + ( number/(guess^(root - 1)) ) ); \n    end\n\nend\n\n\n>> nthRoot(2,2)\n\nans =\n\n   1.414213562373095\n\n", "explain": "Sample Output:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nprogram NthRootTest\n  implicit none\n\n  print *, nthroot(10, 7131.5**10)\n  print *, nthroot(5, 34.0)\n\ncontains\n\n  function nthroot(n, A, p)\n    real :: nthroot\n    integer, intent(in)        :: n\n    real, intent(in)           :: A\n    real, intent(in), optional :: p\n\n    real :: rp, x(2)\n\n    if ( A < 0 ) then\n       stop \"A < 0\"       ! we handle only real positive numbers\n    elseif ( A == 0 ) then\n       nthroot = 0\n       return\n    end if\n\n    if ( present(p) ) then\n       rp = p\n    else\n       rp = 0.001\n    end if\n\n    x(1) = A\n    x(2) = A/n   ! starting \"guessed\" value...\n\n    do while ( abs(x(2) - x(1)) > rp )\n       x(1) = x(2)\n       x(2) = ((n-1.0)*x(2) + A/(x(2) ** (n-1.0)))/real(n)\n    end do\n\n    nthroot = x(2)\n\n  end function nthroot\n\nend program NthRootTest\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\nfunc root(a float64, n int) float64 {\n    n1 := n - 1\n    n1f, rn := float64(n1), 1/float64(n)\n    x, x0 := 1., 0.\n    for {\n        potx, t2 := 1/x, a\n        for b := n1; b > 0; b >>= 1 {\n            if b&1 == 1 {\n                t2 *= potx\n            }\n            potx *= potx\n        }\n        x0, x = x, rn*(n1f*x+t2)\n        if math.Abs(x-x0)*1e15 < x {\n            break\n        }\n    }\n    return x\n}\n\n\nimport \"math/big\"\n\nfunc Root(a *big.Float, n uint64) *big.Float {\n\tlimit := Exp(New(2), 256) \n\tn1 := n-1\n\tn1f, rn := New(float64(n1)), Div(New(1.0), New(float64(n)))\n\tx, x0 := New(1.0), Zero()\n\t_ = x0\n\tfor {\n\t\tpotx, t2 := Div(New(1.0), x), a\n\t\tfor b:=n1; b>0; b>>=1 {\n\t\t\tif b&1 == 1 {\n\t\t\t\tt2 = Mul(t2, potx)\n\t\t\t}\n\t\t\tpotx = Mul(potx, potx)\n\t\t}\n\t\tx0, x = x, Mul(rn, Add(Mul(n1f, x), t2) )\n\t\tif Lesser(Mul(Abs(Sub(x, x0)), limit), x) { break } \n\t}\n\treturn x\n}\n\nfunc Abs(a *big.Float) *big.Float {\n\treturn Zero().Abs(a)\n}\n\nfunc Exp(a *big.Float, e uint64) *big.Float {\n\tresult := Zero().Copy(a)\n\tfor i:=uint64(0); i<e-1; i++ {\n\t\tresult = Mul(result, a)\n\t}\n\treturn result\n}\n\nfunc New(f float64) *big.Float {\n\tr := big.NewFloat(f)\n\tr.SetPrec(256)\n\treturn r\n}\n\nfunc Div(a, b *big.Float) *big.Float {\n\treturn Zero().Quo(a, b)\n}\n\nfunc Zero() *big.Float {\n\tr := big.NewFloat(0.0)\n\tr.SetPrec(256)\n\treturn r\n}\n\nfunc Mul(a, b *big.Float) *big.Float {\n\treturn Zero().Mul(a, b)\n}\n\nfunc Add(a, b *big.Float) *big.Float {\n\treturn Zero().Add(a, b)\n}\n\nfunc Sub(a, b *big.Float) *big.Float {\n\treturn Zero().Sub(a, b)\n}\n\nfunc Lesser(x, y *big.Float) bool {\n\treturn x.Cmp(y) == -1\n}\n\n", "explain": "The above version is for 64 bit wide floating point numbers. The following uses `math/big` Float to implement this same function with 256 bits of precision.\nA set of wrapper functions around the somewhat muddled big math library functions is used to make the main function more readable, and also it was necessary to create a power function (Exp) as the library also lacks this function. The exponent in the limit must be at least one less than the number of bits of precision of the input value or the function will enter an infinite loop!\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program nroot.s   */\n/* compile with option -mfpu=vfpv3 -mfloat-abi=hard */ \n/* link with gcc. Use C function for display float */  \n\n/* Constantes               */\n.equ EXIT,   1                         @ Linux syscall\n\n/* Initialized data */\n.data\nszFormat1:         .asciz \"\u00a0%+09.15f\\n\"\n.align 4\niNumberA:          .int 1024\n\n/* UnInitialized data */\n.bss \n.align 4\n\n/*  code section */\n.text\n.global main \nmain:                                   @ entry of program\n    push {fp,lr}                        @ saves registers\n\n    /* root 10ieme de 1024  */\n    ldr r0,iAdriNumberA                 @ number address\n    ldr r0,[r0]\n    vmov s0,r0                          @ \n    vcvt.f64.s32 d0, s0                 @conversion in float single pr\u00e9cision (32 bits)\n    mov r0,#10                          @ N\n    bl nthRoot\n    ldr r0,iAdrszFormat1                @ format\n    vmov r2,r3,d0\n    bl printf                           @ call C function\u00a0!!!\n                                        @ Attention register dn lost\u00a0!!!\n    /* square root of 2   */ \n    vmov.f64 d1,#2.0                    @ conversion 2 in float register d1\n    mov r0,#2                           @ N\n    bl nthRoot\n    ldr r0,iAdrszFormat1                @ format\n    vmov r2,r3,d0\n    bl printf                           @ call C function\u00a0!!!\n\n100:                                    @ standard end of the program\n    mov r0, #0                          @ return code\n    pop {fp,lr}                         @restaur  registers\n    mov r7, #EXIT                       @ request to exit program\n    swi 0                               @ perform the system call\n\niAdrszFormat1:           .int szFormat1\niAdriNumberA:            .int iNumberA\n\n/******************************************************************/\n/*     compute  nth root                                          */ \n/******************************************************************/\n/* r0 contains N   */\n/* d0 contains the value                 */\n/* d0 return result                      */\nnthRoot:\n    push {r1,r2,lr}                    @ save  registers \n    vpush {d1-d8}                         @ save float registers\n    FMRX    r1,FPSCR                   @ copy FPSCR into r1\n    BIC     r1,r1,#0x00370000          @ clears STRIDE and LEN\n    FMXR    FPSCR,r1                   @ copy r1 back into FPSCR\n\n    vmov s2,r0                         @ \n    vcvt.f64.s32 d6, s2                @ N conversion in float double pr\u00e9cision (64 bits)\n    sub r1,r0,#1                       @ N - 1\n    vmov s8,r1                         @ \n    vcvt.f64.s32 d4, s8                @conversion in float double pr\u00e9cision (64 bits)\n    vmov.f64 d2,d0                     @ a = A\n    vdiv.F64 d3,d0,d6                  @ b = A/n\n    adr r2,dfPrec                      @ load pr\u00e9cision\n    vldr d8,[r2]                  \n1:                                     @ begin loop\n    vmov.f64 d2,d3                     @ a <- b\n    vmul.f64 d5,d3,d4                  @ (N-1)*b\n\n    vmov.f64 d1,#1.0                   @ constante 1 -> float\n    mov r2,#0                          @ loop indice\n2:                                     @ compute pow (n-1)\n    vmul.f64 d1,d1,d3                  @ \n    add r2,#1\n    cmp r2,r1                          @ n -1\u00a0?\n    blt 2b                             @ no -> loop\n    vdiv.f64 d7,d0,d1                  @ A / b pow (n-1)\n    vadd.f64 d7,d7,d5                  @ + (N-1)*b\n    vdiv.f64 d3,d7,d6                  @ / N -> new b\n    vsub.f64 d1,d3,d2                  @ compute gap\n    vabs.f64 d1,d1                     @ absolute value\n    vcmp.f64 d1,d8                     @ compare float maj FPSCR\n    fmstat                             @ transfert FPSCR -> APSR\n                                       @ or use VMRS APSR_nzcv, FPSCR\n    bgt 1b                             @ if gap > pr\u00e9cision -> loop \n    vmov.f64 d0,d3                     @ end return result in d0\n\n100:\n    vpop {d1-d8}                       @ restaur float registers\n    pop {r1,r2,lr}                     @ restaur arm registers\n    bx lr\ndfPrec:            .double 0f1E-10     @ pr\u00e9cision\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nUSES\n   Math;\n\nfunction NthRoot(A, Precision: Double; n: Integer): Double;\nvar\n   x_p, X: Double;\nbegin\n   x_p := Sqrt(A);\n   while Abs(A - Power(x_p, n)) > Precision do\n   begin\n      x := (1/n) * (((n-1) * x_p) + (A/(Power(x_p, n - 1))));\n      x_p := x;\n   end;\n   Result := x_p;\nend;\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\ndef nthroot(n, a, precision = 1e-5)\n  x = Float(a)\n  begin\n    prev = x\n    x = ((n - 1) * prev + a / (prev ** (n - 1))) / n\n  end while (prev - x).abs > precision\n  x \nend\n\np nthroot(5,34)  # => 2.02439745849989\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nTranslation of: Raku\n// 20210212 Rust programming solution\n\nfn nthRoot(n: f64, A: f64) -> f64 {\n\n   let      p  =  1e-9_f64 ;\n   let mut x0  =     A / n ;\n\n   loop {\n      let mut x1 = ( (n-1.0) * x0 + A / f64::powf(x0, n-1.0) ) / n;\n      if (x1-x0).abs() < (x0*p).abs() { return x1 };\n      x0 = x1\n   }\n}\n\nfn main() {\n   println!(\"{}\", nthRoot(3. , 8. ));\n}\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nextension FloatingPoint where Self: ExpressibleByFloatLiteral {\n  @inlinable\n  public func power(_ e: Int) -> Self {\n    var res = Self(1)\n\n    for _ in 0..<e {\n      res *= self\n    }\n\n    return res\n  }\n\n  @inlinable\n  public func root(n: Int, epsilon: Self = 2.220446049250313e-16) -> Self {\n    var d = Self(0)\n    var res = Self(1)\n\n    guard self != 0 else {\n      return 0\n    }\n\n    guard n >= 1 else {\n      return .nan\n    }\n\n    repeat {\n      d = (self / res.power(n - 1) - res) / Self(n)\n      res += d\n    } while d >= epsilon * 10 || d <= -epsilon * 10\n\n    return res\n  }\n}\n\nprint(81.root(n: 4))\nprint(13.root(n: 5))\n\n\nOutput:\n3.0\n1.6702776523348104\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nnthroot <- function(A, n, tol=sqrt(.Machine$double.eps))\n{\n   ifelse(A < 1, x0 <- A * n, x0 <- A / n)\n   repeat\n   {\n      x1 <- ((n-1)*x0 + A / x0^(n-1))/n\n      if(abs(x1 - x0) > tol) x0 <- x1 else break\n   }\n   x1\n}\nnthroot(7131.5^10, 10)   # 7131.5\nnthroot(7, 0.5)          # 49\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Nth-Root.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  \n       DATE-WRITTEN.  4 Feb 2020.\n      ************************************************************\n      ** Program Abstract:\n      **   Compute the Nth Root of a positive real number.\n      **   \n      **   Takes values from console.  If Precision is left\n      **   blank defaults to 0.001.\n      **   \n      **   Enter 0 for first value to terminate program.\n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Root-File ASSIGN TO \"Root-File\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Root-File\n           DATA RECORD IS Parameters.\n       01  Parameters.\n           05 Root                       PIC 9(5).\n           05 Num                        PIC 9(5)V9(5).\n           05 Precision                  PIC 9V9(9).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01  TEMP0                         PIC 9(9)V9(9).\n       01  TEMP1                         PIC 9(9)V9(9).\n       01  RESULTS.\n           05  Field1                        PIC ZZZZZ.ZZZZZ.\n           05  FILLER                        PIC X(5).\n           05  Field2                        PIC ZZZZ9.\n           05  FILLER                        PIC X(14).\n           05  Field3                        PIC 9.999999999.\n\n       01  HEADER.\n           05  FILLER                        PIC X(72) \n               VALUE \"   Number           Root           Precision.\".\n       \n       01  Disp-Root                         PIC ZZZZZ.ZZZZZ.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           PERFORM FOREVER\n           \n              PERFORM Get-Input\n              IF Precision = 0.0 \n                  THEN MOVE 0.001 to Precision\n              END-IF\n\n              PERFORM Compute-Root\n\n              MOVE Root TO Field2\n              MOVE Num TO Field1\n              MOVE Precision TO Field3\n              DISPLAY HEADER\n              DISPLAY RESULTS\n              DISPLAY \" \"\n              MOVE TEMP1 TO Disp-Root\n              DISPLAY \"The Root is: \" Disp-Root\n           END-PERFORM.\n       \n       Get-Input.\n           DISPLAY \"Input Base Number: \" WITH NO ADVANCING\n           ACCEPT Num\n           IF Num EQUALS ZERO\n              THEN \n                   DISPLAY \"Good Bye.\"\n                   STOP RUN\n           END-IF\n           DISPLAY \"Input Root: \" WITH NO ADVANCING\n           ACCEPT Root\n           DISPLAY \"Input Desired Precision: \" WITH NO ADVANCING\n           ACCEPT Precision.\n\n       Compute-Root.\n          MOVE Root TO TEMP0\n          DIVIDE Num BY Root GIVING TEMP1\n\n          PERFORM UNTIL FUNCTION ABS(TEMP0 - TEMP1) \n                                    LESS THAN Precision \n               MOVE TEMP1 TO TEMP0\n               COMPUTE TEMP1 = (( Root - 1.0) * TEMP1 + Num / \n                                        TEMP1 ** (Root - 1.0)) / Root\n          END-PERFORM.\n       \n       END-PROGRAM.\n\n\nOutput:\n     \nInput Base Number: 25.0\nInput Root: 2\nInput Desired Precision: 0.0001\n   Root             Number         Precision.                           \n   25.00000         2              0.000100000\n \nThe Root is:     5.00000\nInput Base Number: 5642.0\nInput Root: 125\nInput Desired Precision: \n   Root             Number         Precision.                           \n 5642.00000       125              0.001000000\n \nThe Root is:     1.07155\nInput Base Number: 0\nGood Bye.\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Nth_Root is\n   generic\n      type Real is digits <>;\n   function Nth_Root (Value : Real; N : Positive) return Real;\n   \n   function Nth_Root (Value : Real; N : Positive) return Real is\n      type Index is mod 2;\n      X : array (Index) of Real := (Value, Value);\n      K : Index := 0;\n   begin\n      loop\n         X (K + 1) := ( (Real (N) - 1.0) * X (K) + Value / X (K) ** (N-1) ) / Real (N);\n         exit when X (K + 1) >= X (K);\n         K := K + 1;\n      end loop;\n      return X (K + 1);\n   end Nth_Root;\n\n   function Long_Nth_Root is new Nth_Root (Long_Float);\nbegin\n   Put_Line (\"1024.0 10th  =\" & Long_Float'Image (Long_Nth_Root (1024.0, 10)));\n   Put_Line (\"  27.0 3rd   =\" & Long_Float'Image (Long_Nth_Root (27.0, 3)));\n   Put_Line (\"   2.0 2nd   =\" & Long_Float'Image (Long_Nth_Root (2.0, 2)));\n   Put_Line (\"5642.0 125th =\" & Long_Float'Image (Long_Nth_Root (5642.0, 125)));\nend Test_Nth_Root;\n\n\n1024.0 10th  = 2.00000000000000E+00\n  27.0 3rd   = 3.00000000000000E+00\n   2.0 2nd   = 1.41421356237310E+00\n5642.0 125th = 1.07154759194477E+00\n\n", "explain": "The implementation is generic and supposed to work with any floating-point type. There is no result accuracy argument of Nth_Root, because the iteration is supposed to be monotonically descending to the root when starts at A. Thus it should converge when this condition gets violated, i.e. when xk+1\u2265xk.\nSample output:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 1.2\n\nfunction nthroot(n::Integer, r::Real)\n    r < 0 || n == 0 && throw(DomainError())\n    n < 0 && return 1 / nthroot(-n, r)\n    r > 0 || return 0\n    x = r / n\n    prevdx = r\n    while true\n        y = x ^ (n - 1)\n        dx = (r - y * x) / (n * y)\n        abs(dx) \u2265 abs(prevdx) && return x\n        x += dx\n        prevdx = dx\n    end\nend\n\n@show nthroot.(-5:2:5, 5.0)\n@show nthroot.(-5:2:5, 5.0) - 5.0 .^ (1 ./ (-5:2:5))\n\n\nOutput:\nnthroot.(-5:2:5, 5.0) = [0.7247796636776955, 0.5848035476425731, 0.2, 5.0, 1.709975946676697, 1.379729661461215]\nnthroot.(-5:2:5, 5.0) - 5.0 .^ (1 ./ (-5:2:5)) = [0.0, -1.1102230246251565e-16, 0.0, 0.0, 0.0, 0.0]\n", "explain": "Julia has a built-in exponentiation function A^(1 / n), but the specification calls for us to use Newton's method (which we iterate until the limits of machine precision are reached):\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nTranslation of: E\n// version 1.0.6\n\nfun nthRoot(x: Double, n: Int): Double {\n    if (n < 2) throw IllegalArgumentException(\"n must be more than 1\")\n    if (x <= 0.0) throw IllegalArgumentException(\"x must be positive\")\n    val np = n - 1\n    fun iter(g: Double) = (np * g + x / Math.pow(g, np.toDouble())) / n\n    var g1 = x\n    var g2 = iter(g1)\n    while (g1 != g2) {\n        g1 = iter(g1)\n        g2 = iter(iter(g2))\n    }\n    return g1\n}\n\nfun main(args: Array<String>) {\n   val numbers = arrayOf(1728.0 to 3, 1024.0 to 10, 2.0 to 2) \n   for (number in numbers)  \n       println(\"${number.first} ^ 1/${number.second}\\t = ${nthRoot(number.first, number.second)}\")\n}\n\n\nOutput:\n1728.0 ^ 1/3     = 12.0\n1024.0 ^ 1/10    = 2.0\n2.0 ^ 1/2        = 1.414213562373095\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nTranslation of: Tcl\nuse strict;\n\nsub nthroot ($$)\n{\n    my ( $n, $A ) = @_;\n\n    my $x0 = $A / $n;\n    my $m = $n - 1.0;\n    while(1) {\n\tmy $x1 = ($m * $x0 + $A / ($x0 ** $m)) / $n;\n\treturn $x1 if abs($x1 - $x0) < abs($x0 * 1e-9);\n\t$x0 = $x1;\n    }\n}\n\nprint nthroot(5, 34), \"\\n\";\nprint nthroot(10, 7131.5 ** 10), \"\\n\";\nprint nthroot(0.5, 7), \"\\n\";\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\niroot(_, 0, 0) :- !.\niroot(M, N, R) :-\n    M > 1,\n    (N > 0 ->\n        irootpos(M, N, R)\n    ;\n        N /\\ 1 =:= 1,\n        NegN is -N, irootpos(M, NegN, R0), R is -R0).\n\nirootpos(N, A, R) :-\n    X0 is 1 << (msb(A) div N),  % initial guess is 2^(log2(A) / N)\n    newton(N, A, X0, X1),\n    iroot_loop(A, X1, N, A, R).\n\niroot_loop(X1, X2, _, _, X1) :- X1 =< X2, !.\niroot_loop(_, X1, N, A, R) :-\n    newton(N, A, X1, X2),\n    iroot_loop(X1, X2, N, A, R).\n\nnewton(2, A, X0, X1) :- X1 is (X0 + A div X0) >> 1, !.  % fast special case\nnewton(N, A, X0, X1) :- X1 is ((N - 1)*X0 + A div X0**(N - 1)) div N.\n\n\nOutput:\n?- iroot(3, 10000, X).\nX = 21.\n\n?- A is 2**(1/12). \u00a0% 12-root of 2 via built-in\nA = 1.0594630943592953.\n\n?- A is 2 * 10**(12 * 15), iroot(12, A, R), format(\"~15d\", [R]).\u00a0% 12-root of 2 via scaled int\n1.059463094359295\nA = 2000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000,\nR = 1059463094359295.\n\n?- iroot(2, 81, X).\nX = 9.\n\n?- iroot(4, -256, X). \u00a0% fails for negative even roots\nfalse.\n\n?- iroot(3, -27, X). \u00a0% succeeds for negative odd roots\nX = -3.\n\n", "explain": "Uses integer math, though via scaling, it can approximate non-integral roots to arbitrary precision.\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction nroot(root, num)\n  return num^(1/root)\nend\n\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\n\ndef nroot(n: Int, a: Double): Double = {\n  @tailrec\n  def rec(x0: Double) : Double = {\n    val x1 = ((n - 1) * x0 + a/math.pow(x0, n-1))/n\n    if (x0 <= x1) x0 else rec(x1)\n  }\n  \n  rec(a)\n}\n\n\ndef fallPrefix(itr: Iterator[Double]): Iterator[Double] = itr.sliding(2).dropWhile(p => p(0) > p(1)).map(_.head)\ndef nrootLazy(n: Int)(a: Double): Double = fallPrefix(Iterator.iterate(a){r => (((n - 1)*r) + (a/math.pow(r, n - 1)))/n}).next\n\n", "explain": "Using tail recursion:\nAlternatively, you can implement the iteration with an iterator like so:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport std.stdio, std.math;\n\nreal nthroot(in int n, in real A, in real p=0.001) pure nothrow {\n    real[2] x = [A, A / n];\n    while (abs(x[1] - x[0]) > p)\n        x = [x[1], ((n - 1) * x[1] + A / (x[1] ^^ (n-1))) / n];\n    return x[1];\n}\n\nvoid main() {\n    writeln(nthroot(10, 7131.5 ^^ 10));\n    writeln(nthroot(6, 64));\n}\n\n\nOutput:\n7131.5\n2\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nn `nthRoot` x = fst $ until (uncurry(==)) (\\(_,x0) -> (x0,((n-1)*x0+x/x0**(n-1))/n)) (x,x/n)\n\n\n*Main> 2 `nthRoot` 2\n1.414213562373095\n\n*Main> 5 `nthRoot` 34\n2.024397458499885\n\n*Main> 10 `nthRoot` (734^10)\n734.0\n\n*Main> 0.5 `nthRoot` 7\n49.0\n\nnthRoot :: Double -> Double -> Double\nnthRoot n x =\n  fst $\n  until\n    (uncurry (==))\n    (((,) <*> ((/ n) . ((+) . (pn *) <*> (x /) . (** pn)))) . snd)\n    (x, x / n)\n  where\n    pn = pred n\n\n-------------------------- TESTS --------------------------\nmain :: IO ()\nmain =\n  putStrLn $\n  fTable\n    \"Nth roots:\"\n    (\\(a, b) -> show a ++ \" `nthRoot` \" ++ show b)\n    show\n    (uncurry nthRoot)\n    [(2, 2), (5, 34), (10, 734 ^ 10), (0.5, 7)]\n\n-------------------- FORMAT OF RESULTS --------------------\nfTable :: String -> (a -> String) -> (b -> String) -> (a -> b) -> [a] -> String\nfTable s xShow fxShow f xs =\n  let w = maximum (length . xShow <$> xs)\n      rjust n c = drop . length <*> (replicate n c ++)\n  in unlines $\n     s : fmap (((++) . rjust w ' ' . xShow) <*> ((\"  ->  \" ++) . fxShow . f)) xs\n\n\nOutput:\nNth roots:\n                  2.0 `nthRoot` 2.0  ->  1.414213562373095\n                 5.0 `nthRoot` 34.0  ->  2.0243974584998847\n10.0 `nthRoot` 4.539004352165717e28  ->  734.0\n                  0.5 `nthRoot` 7.0  ->  49.0\n", "explain": "Function exits when there's no difference between two successive values.\nUse:\n\nOr, in applicative terms, with formatted output:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n(define (root number degree tolerance)\n  (define (good-enough? next guess)\n    (< (abs (- next guess)) tolerance))\n  (define (improve guess)\n    (/ (+ (* (- degree 1) guess) (/ number (expt guess (- degree 1)))) degree))\n  (define (*root guess)\n    (let ((next (improve guess)))\n      (if (good-enough? next guess)\n          guess\n          (*root next))))\n  (*root 1.0))\n\n(display (root (expt 2 10) 10 0.1))\n(newline)\n(display (root (expt 2 10) 10 0.01))\n(newline)\n(display (root (expt 2 10) 10 0.001))\n(newline)\n\n\n2.04732932236839\n2.00463204835482\n2.00004786858167\n\n", "explain": "Output:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\n\n#NoTeS: This sample code does not validate inputs\n#\tThus, if there are errors the 'scary' red-text\n#\terror messages will appear.\n#\n#\tThis code will not work properly in floating point values of n,\n#\tand negative values of A.\n#\n#\tSupports negative values of n by reciprocating the root.\n\n$epsilon=1E-10\t\t#Sample Epsilon (Precision)\n\nfunction power($x,$e){\t#As I said in the comment\n\t$ret=1\n\tfor($i=1;$i -le $e;$i++){\n\t\t$ret*=$x\n\t}\n\treturn $ret\n}\nfunction root($y,$n){\t\t\t\t\t#The main Function\n\tif (0+$n -lt 0){$tmp=-$n} else {$tmp=$n}\t#This checks if n is negative.\n\t$ans=1\n\n\tdo{\n\t\t$d = ($y/(power $ans ($tmp-1)) - $ans)/$tmp\n\t\t$ans+=$d\n\t} while ($d -lt -$epsilon -or $d -gt $epsilon)\n\n\tif (0+$n -lt 0){return 1/$ans} else {return $ans}\n}\n\n#Sample Inputs\nroot 625 2\nroot 2401 4\nroot 2 -2\nroot 1.23456789E-20 34\nroot 9.87654321E20 10\t#Quite slow here, I admit...\n\n((root 5 2)+1)/2\t#Extra: Computes the golden ratio\n((root 5 2)-1)/2\n\n\nOutput:\nPS> .\\NTH.PS1\n25\n7\n0.707106781186548\n0.259690655650288\n125.736248016373\n1.61803398874989\n0.618033988749895\nPS>\n", "explain": "This sample implementation does not use [System.Math] classes.\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto about :a :b\n  output and [:a - :b < 1e-5] [:a - :b > -1e-5]\nend\n\nto root :n :a [:guess :a]\n  localmake \"next ((:n-1) * :guess + :a / power :guess (:n-1)) / n\n  if about :guess :next [output :next]\n  output (root :n :a :next)\nend\n\nshow root 5 34  \u00a0; 2.02439745849989\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nlet nthroot n A =\n    let rec f x =\n        let m = n - 1.\n        let x' = (m * x + A/x**m) / n\n        match abs(x' - x) with\n        | t when t < abs(x * 1e-9) -> x'\n        | _ -> f x'\n    f (A / double n)\n\n[<EntryPoint>]\nlet main args =\n    if args.Length <> 2 then\n        eprintfn \"usage: nthroot n A\"\n        exit 1\n    let (b, n) = System.Double.TryParse(args.[0])\n    let (b', A) = System.Double.TryParse(args.[1])\n    if (not b) || (not b') then\n        eprintfn \"error: parameter must be a number\"\n        exit 1\n    printf \"%A\" (nthroot n A)\n    0\n\nCompiled using fsc nthroot.fs example output:nthroot 0.5 7\n49.0\n", "explain": ""}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\nimport static Constants.tolerance\nimport static java.math.RoundingMode.HALF_UP\n\ndef root(double base, double n) {\n    double xOld = 1\n    double xNew = 0\n    while (true) {\n        xNew = ((n - 1) * xOld + base/(xOld)**(n - 1))/n\n    if ((xNew - xOld).abs() < tolerance) { break }\n        xOld = xNew\n    }\n    (xNew as BigDecimal).setScale(7, HALF_UP)\n}\n\n\nclass Constants {\n    static final tolerance = 0.00001\n}\n\nprint '''\n   Base   Power  Calc'd Root  Actual Root\n-------  ------  -----------  -----------\n'''\ndef testCases = [\n    [b:32.0, n:5.0, r:2.0],\n    [b:81.0, n:4.0, r:3.0],\n    [b:Math.PI**2, n:4.0, r:Math.PI**(0.5)],\n    [b:7.0, n:0.5, r:49.0],\n]\n\ntestCases.each {\n    def r = root(it.b, it.n)\n    printf('%7.4f  %6.4f  %11.4f  %11.4f\\n',\n        it.b, it.n, r, it.r)\n    assert (r - it.r).abs() <= tolerance\n}\n\n\n   Base   Power  Calc'd Root  Actual Root\n-------  ------  -----------  -----------\n32.0000  5.0000       2.0000       2.0000\n81.0000  4.0000       3.0000       3.0000\n 9.8696  4.0000       1.7725       1.7725\n 7.0000  0.5000      49.0000      49.0000\n", "explain": "Solution:\nTest:\nOutput:\n"}, {"task_name": "Nth root", "task_url": "https://rosettacode.org/wiki/Nth_root", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\nBEGIN {\n        # test\n\tprint nthroot(8,3)\n\tprint nthroot(16,2)\n\tprint nthroot(16,4)\n\tprint nthroot(125,3)\n\tprint nthroot(3,3)\n\tprint nthroot(3,2)\n}\n\nfunction nthroot(y,n) {\n        eps = 1e-15;   # relative accuracy\n        x   = 1; \n\tdo {\n\t\td  = ( y / ( x^(n-1) ) - x ) / n ;\n\t\tx += d; \n\t\te = eps*x;   # absolute accuracy\t\n\t} while ( d < -e  || d > e )\n\n\treturn x\n}\n\n\n 2\n 4 \n 2\n 5\n 1.44225\n 1.73205\n\n", "explain": "Sample output:\n"}]