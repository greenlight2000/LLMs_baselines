[{"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Python", "code": "\n\nfrom collections import namedtuple, deque\nfrom pprint import pprint as pp\n \n \ninf = float('inf')\nEdge = namedtuple('Edge', ['start', 'end', 'cost'])\n \nclass Graph():\n    def __init__(self, edges):\n        self.edges = [Edge(*edge) for edge in edges]\n        # print(dir(self.edges[0]))\n        self.vertices = {e.start for e in self.edges} | {e.end for e in self.edges}\n \n    def dijkstra(self, source, dest):\n        assert source in self.vertices\n        dist = {vertex: inf for vertex in self.vertices}\n        previous = {vertex: None for vertex in self.vertices}\n        dist[source] = 0\n        q = self.vertices.copy()\n        neighbours = {vertex: set() for vertex in self.vertices}\n        for start, end, cost in self.edges:\n            neighbours[start].add((end, cost))\n            neighbours[end].add((start, cost))\n\n        #pp(neighbours)\n \n        while q:\n            # pp(q)\n            u = min(q, key=lambda vertex: dist[vertex])\n            q.remove(u)\n            if dist[u] == inf or u == dest:\n                break\n            for v, cost in neighbours[u]:\n                alt = dist[u] + cost\n                if alt < dist[v]:                                  # Relax (u,v,a)\n                    dist[v] = alt\n                    previous[v] = u\n        #pp(previous)\n        s, u = deque(), dest\n        while previous[u]:\n            s.appendleft(u)\n            u = previous[u]\n        s.appendleft(u)\n        return s\n \n \ngraph = Graph([(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n               (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n               (\"e\", \"f\", 9)])\npp(graph.dijkstra(\"a\", \"e\"))\n\n\nOutput:\ndeque(['a', 'c', 'f', 'e'])\n", "explain": "Starts from the wp:Dijkstra's_algorithm#Pseudocode recognising that their function dist_between is what this task calls cost; and that their action decrease-key v in Q at their line 24 should be omitted if their Q is a set as stated in their line 9. The wp back-tracking pseudocode also misses a final insert of u at the beginning of S that must occur after exiting their while loop.\nNote: q could be changed to be a priority queue instead of a set as mentioned here.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <limits.h>\n\ntypedef struct {\n    int vertex;\n    int weight;\n} edge_t;\n\ntypedef struct {\n    edge_t **edges;\n    int edges_len;\n    int edges_size;\n    int dist;\n    int prev;\n    int visited;\n} vertex_t;\n\ntypedef struct {\n    vertex_t **vertices;\n    int vertices_len;\n    int vertices_size;\n} graph_t;\n\ntypedef struct {\n    int *data;\n    int *prio;\n    int *index;\n    int len;\n    int size;\n} heap_t;\n\nvoid add_vertex (graph_t *g, int i) {\n    if (g->vertices_size < i + 1) {\n        int size = g->vertices_size * 2 > i\u00a0? g->vertices_size * 2\u00a0: i + 4;\n        g->vertices = realloc(g->vertices, size * sizeof (vertex_t *));\n        for (int j = g->vertices_size; j < size; j++)\n            g->vertices[j] = NULL;\n        g->vertices_size = size;\n    }\n    if (!g->vertices[i]) {\n        g->vertices[i] = calloc(1, sizeof (vertex_t));\n        g->vertices_len++;\n    }\n}\n\nvoid add_edge (graph_t *g, int a, int b, int w) {\n    a = a - 'a';\n    b = b - 'a';\n    add_vertex(g, a);\n    add_vertex(g, b);\n    vertex_t *v = g->vertices[a];\n    if (v->edges_len >= v->edges_size) {\n        v->edges_size = v->edges_size\u00a0? v->edges_size * 2\u00a0: 4;\n        v->edges = realloc(v->edges, v->edges_size * sizeof (edge_t *));\n    }\n    edge_t *e = calloc(1, sizeof (edge_t));\n    e->vertex = b;\n    e->weight = w;\n    v->edges[v->edges_len++] = e;\n}\n\nheap_t *create_heap (int n) {\n    heap_t *h = calloc(1, sizeof (heap_t));\n    h->data = calloc(n + 1, sizeof (int));\n    h->prio = calloc(n + 1, sizeof (int));\n    h->index = calloc(n, sizeof (int));\n    return h;\n}\n\nvoid push_heap (heap_t *h, int v, int p) {\n    int i = h->index[v] == 0\u00a0? ++h->len\u00a0: h->index[v];\n    int j = i / 2;\n    while (i > 1) {\n        if (h->prio[j] < p)\n            break;\n        h->data[i] = h->data[j];\n        h->prio[i] = h->prio[j];\n        h->index[h->data[i]] = i;\n        i = j;\n        j = j / 2;\n    }\n    h->data[i] = v;\n    h->prio[i] = p;\n    h->index[v] = i;\n}\n\nint min (heap_t *h, int i, int j, int k) {\n    int m = i;\n    if (j <= h->len && h->prio[j] < h->prio[m])\n        m = j;\n    if (k <= h->len && h->prio[k] < h->prio[m])\n        m = k;\n    return m;\n}\n\nint pop_heap (heap_t *h) {\n    int v = h->data[1];\n    int i = 1;\n    while (1) {\n        int j = min(h, h->len, 2 * i, 2 * i + 1);\n        if (j == h->len)\n            break;\n        h->data[i] = h->data[j];\n        h->prio[i] = h->prio[j];\n        h->index[h->data[i]] = i;\n        i = j;\n    }\n    h->data[i] = h->data[h->len];\n    h->prio[i] = h->prio[h->len];\n    h->index[h->data[i]] = i;\n    h->len--;\n    return v;\n}\n\nvoid dijkstra (graph_t *g, int a, int b) {\n    int i, j;\n    a = a - 'a';\n    b = b - 'a';\n    for (i = 0; i < g->vertices_len; i++) {\n        vertex_t *v = g->vertices[i];\n        v->dist = INT_MAX;\n        v->prev = 0;\n        v->visited = 0;\n    }\n    vertex_t *v = g->vertices[a];\n    v->dist = 0;\n    heap_t *h = create_heap(g->vertices_len);\n    push_heap(h, a, v->dist);\n    while (h->len) {\n        i = pop_heap(h);\n        if (i == b)\n            break;\n        v = g->vertices[i];\n        v->visited = 1;\n        for (j = 0; j < v->edges_len; j++) {\n            edge_t *e = v->edges[j];\n            vertex_t *u = g->vertices[e->vertex];\n            if (!u->visited && v->dist + e->weight <= u->dist) {\n                u->prev = i;\n                u->dist = v->dist + e->weight;\n                push_heap(h, e->vertex, u->dist);\n            }\n        }\n    }\n}\n\nvoid print_path (graph_t *g, int i) {\n    int n, j;\n    vertex_t *v, *u;\n    i = i - 'a';\n    v = g->vertices[i];\n    if (v->dist == INT_MAX) {\n        printf(\"no path\\n\");\n        return;\n    }\n    for (n = 1, u = v; u->dist; u = g->vertices[u->prev], n++)\n       \u00a0;\n    char *path = malloc(n);\n    path[n - 1] = 'a' + i;\n    for (j = 0, u = v; u->dist; u = g->vertices[u->prev], j++)\n        path[n - j - 2] = 'a' + u->prev;\n    printf(\"%d\u00a0%.*s\\n\", v->dist, n, path);\n}\n\nint main () {\n    graph_t *g = calloc(1, sizeof (graph_t));\n    add_edge(g, 'a', 'b', 7);\n    add_edge(g, 'a', 'c', 9);\n    add_edge(g, 'a', 'f', 14);\n    add_edge(g, 'b', 'c', 10);\n    add_edge(g, 'b', 'd', 15);\n    add_edge(g, 'c', 'd', 11);\n    add_edge(g, 'c', 'f', 2);\n    add_edge(g, 'd', 'e', 6);\n    add_edge(g, 'e', 'f', 9);\n    dijkstra(g, 'a', 'e');\n    print_path(g, 'e');\n    return 0;\n}\n\n", "explain": "The priority queue is implemented as a binary heap. The heap stores an index into its data array, so it can quickly update the weight of an item already in it.\noutput\n26 acde\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "C++", "code": "\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\n#include <limits> // for numeric_limits\n\n#include <set>\n#include <utility> // for pair\n#include <algorithm>\n#include <iterator>\n\n\ntypedef int vertex_t;\ntypedef double weight_t;\n\nconst weight_t max_weight = std::numeric_limits<double>::infinity();\n\nstruct neighbor {\n    vertex_t target;\n    weight_t weight;\n    neighbor(vertex_t arg_target, weight_t arg_weight)\n        : target(arg_target), weight(arg_weight) { }\n};\n\ntypedef std::vector<std::vector<neighbor> > adjacency_list_t;\n\n\nvoid DijkstraComputePaths(vertex_t source,\n                          const adjacency_list_t &adjacency_list,\n                          std::vector<weight_t> &min_distance,\n                          std::vector<vertex_t> &previous)\n{\n    int n = adjacency_list.size();\n    min_distance.clear();\n    min_distance.resize(n, max_weight);\n    min_distance[source] = 0;\n    previous.clear();\n    previous.resize(n, -1);\n    std::set<std::pair<weight_t, vertex_t> > vertex_queue;\n    vertex_queue.insert(std::make_pair(min_distance[source], source));\n\n    while (!vertex_queue.empty()) \n    {\n        weight_t dist = vertex_queue.begin()->first;\n        vertex_t u = vertex_queue.begin()->second;\n        vertex_queue.erase(vertex_queue.begin());\n\n        // Visit each edge exiting u\n\tconst std::vector<neighbor> &neighbors = adjacency_list[u];\n        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();\n             neighbor_iter != neighbors.end();\n             neighbor_iter++)\n        {\n            vertex_t v = neighbor_iter->target;\n            weight_t weight = neighbor_iter->weight;\n            weight_t distance_through_u = dist + weight;\n\t    if (distance_through_u < min_distance[v]) {\n\t        vertex_queue.erase(std::make_pair(min_distance[v], v));\n\n\t        min_distance[v] = distance_through_u;\n\t        previous[v] = u;\n\t        vertex_queue.insert(std::make_pair(min_distance[v], v));\n\n\t    }\n\n        }\n    }\n}\n\n\nstd::list<vertex_t> DijkstraGetShortestPathTo(\n    vertex_t vertex, const std::vector<vertex_t> &previous)\n{\n    std::list<vertex_t> path;\n    for ( ; vertex != -1; vertex = previous[vertex])\n        path.push_front(vertex);\n    return path;\n}\n\n\nint main()\n{\n    // remember to insert edges both ways for an undirected graph\n    adjacency_list_t adjacency_list(6);\n    // 0 = a\n    adjacency_list[0].push_back(neighbor(1, 7));\n    adjacency_list[0].push_back(neighbor(2, 9));\n    adjacency_list[0].push_back(neighbor(5, 14));\n    // 1 = b\n    adjacency_list[1].push_back(neighbor(0, 7));\n    adjacency_list[1].push_back(neighbor(2, 10));\n    adjacency_list[1].push_back(neighbor(3, 15));\n    // 2 = c\n    adjacency_list[2].push_back(neighbor(0, 9));\n    adjacency_list[2].push_back(neighbor(1, 10));\n    adjacency_list[2].push_back(neighbor(3, 11));\n    adjacency_list[2].push_back(neighbor(5, 2));\n    // 3 = d\n    adjacency_list[3].push_back(neighbor(1, 15));\n    adjacency_list[3].push_back(neighbor(2, 11));\n    adjacency_list[3].push_back(neighbor(4, 6));\n    // 4 = e\n    adjacency_list[4].push_back(neighbor(3, 6));\n    adjacency_list[4].push_back(neighbor(5, 9));\n    // 5 = f\n    adjacency_list[5].push_back(neighbor(0, 14));\n    adjacency_list[5].push_back(neighbor(2, 2));\n    adjacency_list[5].push_back(neighbor(4, 9));\n\n    std::vector<weight_t> min_distance;\n    std::vector<vertex_t> previous;\n    DijkstraComputePaths(0, adjacency_list, min_distance, previous);\n    std::cout << \"Distance from 0 to 4: \" << min_distance[4] << std::endl;\n    std::list<vertex_t> path = DijkstraGetShortestPathTo(4, previous);\n    std::cout << \"Path\u00a0: \";\n    std::copy(path.begin(), path.end(), std::ostream_iterator<vertex_t>(std::cout, \" \"));\n    std::cout << std::endl;\n\n    return 0;\n}\n\n\n\n#include <iostream>\n#include <vector>\n#include <string>\n#include <list>\n\n#include <limits> // for numeric_limits\n\n#include <queue>\n#include <utility> // for pair\n#include <algorithm>\n#include <iterator>\n\n\ntypedef int vertex_t;\ntypedef double weight_t;\n\nconst weight_t max_weight = std::numeric_limits<double>::infinity();\n\nstruct neighbor {\n    vertex_t target;\n    weight_t weight;\n    neighbor(vertex_t arg_target, weight_t arg_weight)\n        : target(arg_target), weight(arg_weight) { }\n};\n\ntypedef std::vector<std::vector<neighbor> > adjacency_list_t;\ntypedef std::pair<weight_t, vertex_t> weight_vertex_pair_t;\n\nvoid DijkstraComputePaths(vertex_t source,\n                          const adjacency_list_t &adjacency_list,\n                          std::vector<weight_t> &min_distance,\n                          std::vector<vertex_t> &previous)\n{\n    int n = adjacency_list.size();\n    min_distance.clear();\n    min_distance.resize(n, max_weight);\n    min_distance[source] = 0;\n    previous.clear();\n    previous.resize(n, -1);\n    // we use greater instead of less to turn max-heap into min-heap\n    std::priority_queue<weight_vertex_pair_t,\n\t\t\tstd::vector<weight_vertex_pair_t>,\n\t\t\tstd::greater<weight_vertex_pair_t> > vertex_queue;\n    vertex_queue.push(std::make_pair(min_distance[source], source));\n\n    while (!vertex_queue.empty()) \n    {\n        weight_t dist = vertex_queue.top().first;\n        vertex_t u = vertex_queue.top().second;\n        vertex_queue.pop();\n\n\t// Because we leave old copies of the vertex in the priority queue\n\t// (with outdated higher distances), we need to ignore it when we come\n\t// across it again, by checking its distance against the minimum distance\n\tif (dist > min_distance[u])\n\t    continue;\n\n        // Visit each edge exiting u\n\tconst std::vector<neighbor> &neighbors = adjacency_list[u];\n        for (std::vector<neighbor>::const_iterator neighbor_iter = neighbors.begin();\n             neighbor_iter != neighbors.end();\n             neighbor_iter++)\n        {\n            vertex_t v = neighbor_iter->target;\n            weight_t weight = neighbor_iter->weight;\n            weight_t distance_through_u = dist + weight;\n\t    if (distance_through_u < min_distance[v]) {\n\t        min_distance[v] = distance_through_u;\n\t        previous[v] = u;\n\t        vertex_queue.push(std::make_pair(min_distance[v], v));\n\n\t    }\n\n        }\n    }\n}\n\n\nstd::list<vertex_t> DijkstraGetShortestPathTo(\n    vertex_t vertex, const std::vector<vertex_t> &previous)\n{\n    std::list<vertex_t> path;\n    for ( ; vertex != -1; vertex = previous[vertex])\n        path.push_front(vertex);\n    return path;\n}\n\n\nint main()\n{\n    // remember to insert edges both ways for an undirected graph\n    adjacency_list_t adjacency_list(6);\n    // 0 = a\n    adjacency_list[0].push_back(neighbor(1, 7));\n    adjacency_list[0].push_back(neighbor(2, 9));\n    adjacency_list[0].push_back(neighbor(5, 14));\n    // 1 = b\n    adjacency_list[1].push_back(neighbor(0, 7));\n    adjacency_list[1].push_back(neighbor(2, 10));\n    adjacency_list[1].push_back(neighbor(3, 15));\n    // 2 = c\n    adjacency_list[2].push_back(neighbor(0, 9));\n    adjacency_list[2].push_back(neighbor(1, 10));\n    adjacency_list[2].push_back(neighbor(3, 11));\n    adjacency_list[2].push_back(neighbor(5, 2));\n    // 3 = d\n    adjacency_list[3].push_back(neighbor(1, 15));\n    adjacency_list[3].push_back(neighbor(2, 11));\n    adjacency_list[3].push_back(neighbor(4, 6));\n    // 4 = e\n    adjacency_list[4].push_back(neighbor(3, 6));\n    adjacency_list[4].push_back(neighbor(5, 9));\n    // 5 = f\n    adjacency_list[5].push_back(neighbor(0, 14));\n    adjacency_list[5].push_back(neighbor(2, 2));\n    adjacency_list[5].push_back(neighbor(4, 9));\n\n    std::vector<weight_t> min_distance;\n    std::vector<vertex_t> previous;\n    DijkstraComputePaths(0, adjacency_list, min_distance, previous);\n    std::cout << \"Distance from 0 to 4: \" << min_distance[4] << std::endl;\n    std::list<vertex_t> path = DijkstraGetShortestPathTo(4, previous);\n    std::cout << \"Path\u00a0: \";\n    std::copy(path.begin(), path.end(), std::ostream_iterator<vertex_t>(std::cout, \" \"));\n    std::cout << std::endl;\n\n    return 0;\n}\n\n", "explain": "(Modified from LiteratePrograms, which is MIT/X11 licensed.)\nSolution follows Dijkstra's algorithm as described elsewhere. Data like min-distance, previous node, neighbors, are kept in separate data structures instead of part of the vertex. We number the vertexes starting from 0, and represent the graph using an adjacency list (vector whose i'th element is the vector of neighbors that vertex i has edges to) for simplicity.\nFor the priority queue of vertexes, we use a self-balancing binary search tree (std::set), which should bound time complexity by O(E log V). Although C++ has heaps, without knowing the index of an element it would take linear time to find it to re-order it for a changed weight. It is not easy to keep the index of vertexes in the heap because the heap operations are opaque without callbacks. On the other hand, using a self-balancing binary search tree is efficient because it has the same log(n) complexity for insertion and removal of the head element as a binary heap. In addition, a self-balancing binary search tree also allows us to find and remove any other element in log(n) time, allowing us to perform the decrease-key step in logarithmic time by removing and re-inserting.\nWe do not need to keep track of whether a vertex is \"done\" (\"visited\") as in the Wikipedia description, since re-reaching such a vertex will always fail the relaxation condition (when re-reaching a \"done\" vertex, the new distance will never be less than it was originally), so it will be skipped anyway.\nThe time complexity of this algorithm is O(E log V), as described on Wikipedia. Each vertex is added to the priority queue at most once (re-ordering doesn't count as adding), because once it's in the priority queue, we only re-order it, never add it again. And when it's popped from the priority queue, that means we already have the real minimum distance to this vertex, so the relaxation condition will always fail in the future for this vertex, and it will never be added to the priority queue again. Therefore, we will only pop each vertex at most once from the priority queue, and the size of the priority queue is bounded by V (the number of vertexes).\nThe outer loop executes once for each element popped from the priority queue, so it will execute at most once for each vertex, so at most V times. Each iteration of the outer loop executes one pop from the priority queue, which has time complexity O(log V). The inner loop executes at most once for each directed edge, since each directed edge has one originating vertex, and there is only at most one iteration of the outer loop for each vertex. Each iteration of the inner loop potentially performs one push or re-order on the priority queue (where re-order is a pop and a push), which has complexity O(log V). There is also the O(V) complexity for initializing the data structures. Combining these, we have a complexity of O(V log V + E log V), and assuming this is a connected graph, V <= E+1 = O(E), so we can write it as O(E log V).\nNote that it is possible to use C++ built-in heaps (or the abstract std::priority_queue datatype) to implement this without changing the time complexity. Although the previous section noted that, without knowing the position of the element in the heap, it would take linear time to search for it in order to re-order it, the trick here is that we can insert the new updated element (with the vertex and updated lower distance), and simply leave the old element (with the vertex and old higher distance) in the priority queue without removing it, thereby eliminating the need to find it.\nSince we now leave multiple elements with the same vertex in the priority queue, in order to ensure we still only process a vertex's edges only once, we add a check when we retrieve an element from the priority queue, to check whether its distance is greater than the known minimum distance to that vertex. If this element is the most updated version for this vertex (i.e. the vertex's minimum distance has not been decreased since this element was added to the priority queue), then its distance must be equal to the current known minimum distance, since we only update the minimum distance in the decrease-key step. So if the element's distance is greater, we know that this is not the most updated version for this vertex -- i.e. we have already processed the edges for this vertex -- and we should ignore it.\nThe only downside to this strategy is that many old \"garbage\" elements will be left in the priority queue, increasing its size, and thus also increasing the time it takes to push and pop, as well as increasing the number of times we have to pop. However, we argue that the time complexity remains the same.\nThe main difference with the time complexity analysis for the previous algorithm is that here, we may add a vertex to the priority queue more than once. However, it is still true that the inner loop executes at most once for each directed edge. This is because in the outer loop, we added a check to ignore vertexes that we've already processed, so we will still only proceed down to the processing the edges at most once for each vertex. Therefore, the number of times that push is done on the priority queue (which happens at most once per iteration of the inner loop) is bounded by E, and the size of the priority queue is also bounded by E.\nThe number of times the outer loop executes (the number of times an element is popped from the priority queue) is bounded by E, and in each iteration, the popping operation takes time complexity O(log E). The number of times the inner loop executes is also bounded by E, and the pushing operation inside it also takes time complexity O(log E). So in total, the time complexity is O(E log E). But not that, for a simple graph, E < V^2, so log E < 2 log V = O(log V). So O(E log E) can also be written as O(E log V), which is the same as for the preceding algorithm.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Java", "code": "\n\nimport java.io.*;\nimport java.util.*;\n\npublic class Dijkstra {\n   private static final Graph.Edge[] GRAPH = {\n      new Graph.Edge(\"a\", \"b\", 7),\n      new Graph.Edge(\"a\", \"c\", 9),\n      new Graph.Edge(\"a\", \"f\", 14),\n      new Graph.Edge(\"b\", \"c\", 10),\n      new Graph.Edge(\"b\", \"d\", 15),\n      new Graph.Edge(\"c\", \"d\", 11),\n      new Graph.Edge(\"c\", \"f\", 2),\n      new Graph.Edge(\"d\", \"e\", 6),\n      new Graph.Edge(\"e\", \"f\", 9),\n   };\n   private static final String START = \"a\";\n   private static final String END = \"e\";\n   \n   public static void main(String[] args) {\n      Graph g = new Graph(GRAPH);\n      g.dijkstra(START);\n      g.printPath(END);\n      //g.printAllPaths();\n   }\n}\n\nclass Graph {\n   private final Map<String, Vertex> graph; // mapping of vertex names to Vertex objects, built from a set of Edges\n   \n   /** One edge of the graph (only used by Graph constructor) */\n   public static class Edge {\n      public final String v1, v2;\n      public final int dist;\n      public Edge(String v1, String v2, int dist) {\n         this.v1 = v1;\n         this.v2 = v2;\n         this.dist = dist;\n      }\n   }\n   \n   /** One vertex of the graph, complete with mappings to neighbouring vertices */\n  public static class Vertex implements Comparable<Vertex>{\n\tpublic final String name;\n\tpublic int dist = Integer.MAX_VALUE; // MAX_VALUE assumed to be infinity\n\tpublic Vertex previous = null;\n\tpublic final Map<Vertex, Integer> neighbours = new HashMap<>();\n\n\tpublic Vertex(String name)\n\t{\n\t\tthis.name = name;\n\t}\n\n\tprivate void printPath()\n\t{\n\t\tif (this == this.previous)\n\t\t{\n\t\t\tSystem.out.printf(\"%s\", this.name);\n\t\t}\n\t\telse if (this.previous == null)\n\t\t{\n\t\t\tSystem.out.printf(\"%s(unreached)\", this.name);\n\t\t}\n\t\telse\n\t\t{\n\t\t\tthis.previous.printPath();\n\t\t\tSystem.out.printf(\" -> %s(%d)\", this.name, this.dist);\n\t\t}\n\t}\n\n\tpublic int compareTo(Vertex other)\n\t{\n\t\tif (dist == other.dist)\n\t\t\treturn name.compareTo(other.name);\n\n\t\treturn Integer.compare(dist, other.dist);\n\t}\n\n\t@Override public String toString()\n\t{\n\t\treturn \"(\" + name + \", \" + dist + \")\";\n\t}\n}\n   \n   /** Builds a graph from a set of edges */\n   public Graph(Edge[] edges) {\n      graph = new HashMap<>(edges.length);\n      \n      //one pass to find all vertices\n      for (Edge e : edges) {\n         if (!graph.containsKey(e.v1)) graph.put(e.v1, new Vertex(e.v1));\n         if (!graph.containsKey(e.v2)) graph.put(e.v2, new Vertex(e.v2));\n      }\n      \n      //another pass to set neighbouring vertices\n      for (Edge e : edges) {\n         graph.get(e.v1).neighbours.put(graph.get(e.v2), e.dist);\n         //graph.get(e.v2).neighbours.put(graph.get(e.v1), e.dist); // also do this for an undirected graph\n      }\n   }\n   \n   /** Runs dijkstra using a specified source vertex */ \n   public void dijkstra(String startName) {\n      if (!graph.containsKey(startName)) {\n         System.err.printf(\"Graph doesn't contain start vertex \\\"%s\\\"\\n\", startName);\n         return;\n      }\n      final Vertex source = graph.get(startName);\n      NavigableSet<Vertex> q = new TreeSet<>();\n      \n      // set-up vertices\n      for (Vertex v : graph.values()) {\n         v.previous = v == source ? source : null;\n         v.dist = v == source ? 0 : Integer.MAX_VALUE;\n         q.add(v);\n      }\n      \n      dijkstra(q);\n   }\n   \n   /** Implementation of dijkstra's algorithm using a binary heap. */\n   private void dijkstra(final NavigableSet<Vertex> q) {      \n      Vertex u, v;\n      while (!q.isEmpty()) {\n         \n         u = q.pollFirst(); // vertex with shortest distance (first iteration will return source)\n         if (u.dist == Integer.MAX_VALUE) break; // we can ignore u (and any other remaining vertices) since they are unreachable\n         \n         //look at distances to each neighbour\n         for (Map.Entry<Vertex, Integer> a : u.neighbours.entrySet()) {\n            v = a.getKey(); //the neighbour in this iteration\n            \n            final int alternateDist = u.dist + a.getValue();\n            if (alternateDist < v.dist) { // shorter path to neighbour found\n               q.remove(v);\n               v.dist = alternateDist;\n               v.previous = u;\n               q.add(v);\n            } \n         }\n      }\n   }\n   \n   /** Prints a path from the source to the specified vertex */\n   public void printPath(String endName) {\n      if (!graph.containsKey(endName)) {\n         System.err.printf(\"Graph doesn't contain end vertex \\\"%s\\\"\\n\", endName);\n         return;\n      }\n      \n      graph.get(endName).printPath();\n      System.out.println();\n   }\n   /** Prints the path from the source to every vertex (output order is not guaranteed) */\n   public void printAllPaths() {\n      for (Vertex v : graph.values()) {\n         v.printPath();\n         System.out.println();\n      }\n   }\n}\n\nOutput:\n\na -> c(9) -> d(20) -> e(26)\n\n\n", "explain": "Algorithm is derived from Wikipedia section 'Using a priority queue'.\nThis implementation finds the single path from a source to all reachable vertices.\nBuilding the graph from a set of edges takes O(E log V) for each pass.\nVertices are stored in a TreeSet (self-balancing binary search tree) instead of a PriorityQueue (a binary heap) in order to get O(log n) performance for removal of any element, not just the head.\nDecreasing the distance of a vertex is accomplished by removing it from the tree and later re-inserting it.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "C#", "code": "\nWorks with: C sharp version 7\nusing static System.Linq.Enumerable;\nusing static System.String;\nusing static System.Console;\nusing System.Collections.Generic;\nusing System;\nusing EdgeList = System.Collections.Generic.List<(int node, double weight)>;\n\npublic static class Dijkstra\n{\n    public static void Main() {\n        Graph graph = new Graph(6);\n        Func<char, int> id = c => c - 'a';\n        Func<int , char> name = i => (char)(i + 'a');\n        foreach (var (start, end, cost) in new [] {\n            ('a', 'b', 7),\n            ('a', 'c', 9),\n            ('a', 'f', 14),\n            ('b', 'c', 10),\n            ('b', 'd', 15),\n            ('c', 'd', 11),\n            ('c', 'f', 2),\n            ('d', 'e', 6),\n            ('e', 'f', 9),\n        }) {\n            graph.AddEdge(id(start), id(end), cost);\n        }\n\n        var path = graph.FindPath(id('a'));\n        for (int d = id('b'); d <= id('f'); d++) {\n            WriteLine(Join(\" -> \", Path(id('a'), d).Select(p => $\"{name(p.node)}({p.distance})\").Reverse()));\n        }\n        \n        IEnumerable<(double distance, int node)> Path(int start, int destination) {\n            yield return (path[destination].distance, destination);\n            for (int i = destination; i != start; i = path[i].prev) {\n                yield return (path[path[i].prev].distance, path[i].prev);\n            }\n        }\n    }\n\n}\n\nsealed class Graph\n{\n    private readonly List<EdgeList> adjacency;\n\n    public Graph(int vertexCount) => adjacency = Range(0, vertexCount).Select(v => new EdgeList()).ToList();\n\n    public int Count => adjacency.Count;\n    public bool HasEdge(int s, int e) => adjacency[s].Any(p => p.node == e);\n    public bool RemoveEdge(int s, int e) => adjacency[s].RemoveAll(p => p.node == e) > 0;\n\n    public bool AddEdge(int s, int e, double weight) {\n        if (HasEdge(s, e)) return false;\n        adjacency[s].Add((e, weight));\n        return true;\n    }\n\n    public (double distance, int prev)[] FindPath(int start) {\n        var info = Range(0, adjacency.Count).Select(i => (distance: double.PositiveInfinity, prev: i)).ToArray();\n        info[start].distance = 0;\n        var visited = new System.Collections.BitArray(adjacency.Count);\n\n        var heap = new Heap<(int node, double distance)>((a, b) => a.distance.CompareTo(b.distance));\n        heap.Push((start, 0));\n        while (heap.Count > 0) {\n            var current = heap.Pop();\n            if (visited[current.node]) continue;\n            var edges = adjacency[current.node];\n            for (int n = 0; n < edges.Count; n++) {\n                int v = edges[n].node;\n                if (visited[v]) continue;\n                double alt = info[current.node].distance + edges[n].weight;\n                if (alt < info[v].distance) {\n                    info[v] = (alt, current.node);\n                    heap.Push((v, alt));\n                }\n            }\n            visited[current.node] = true;\n        }\n        return info;\n    }\n\n}\n\nsealed class Heap<T>\n{\n    private readonly IComparer<T> comparer;\n    private readonly List<T> list = new List<T> { default };\n\n    public Heap() : this(default(IComparer<T>)) { }\n\n    public Heap(IComparer<T> comparer) {\n        this.comparer = comparer ?? Comparer<T>.Default;\n    }\n\n    public Heap(Comparison<T> comparison) : this(Comparer<T>.Create(comparison)) { }\n\n    public int Count => list.Count - 1;\n\n    public void Push(T element) {\n        list.Add(element);\n        SiftUp(list.Count - 1);\n    }\n\n    public T Pop() {\n        T result = list[1];\n        list[1] = list[list.Count - 1];\n        list.RemoveAt(list.Count - 1);\n        SiftDown(1);\n        return result;\n    }\n\n    private static int Parent(int i) => i / 2;\n    private static int Left(int i) => i * 2;\n    private static int Right(int i) => i * 2 + 1;\n\n    private void SiftUp(int i) {\n        while (i > 1) {\n            int parent = Parent(i);\n            if (comparer.Compare(list[i], list[parent]) > 0) return;\n            (list[parent], list[i]) = (list[i], list[parent]);\n            i = parent;\n        }\n    }\n\n    private void SiftDown(int i) {\n        for (int left = Left(i); left < list.Count; left = Left(i)) {\n            int smallest = comparer.Compare(list[left], list[i]) <= 0 ? left : i;\n            int right = Right(i);\n            if (right < list.Count && comparer.Compare(list[right], list[smallest]) <= 0) smallest = right;\n            if (smallest == i) return;\n            (list[i], list[smallest]) = (list[smallest], list[i]);\n            i = smallest;\n        }\n    }\n\n}\n\n\nOutput:\na(0) -> b(7)\na(0) -> c(9)\na(0) -> c(9) -> d(20)\na(0) -> c(9) -> d(20) -> e(26)\na(0) -> c(9) -> f(11)\n\n", "explain": ""}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "JavaScript", "code": "\n\nconst dijkstra = (edges,source,target) => {\n    const Q = new Set(),\n          prev = {},\n          dist = {},\n          adj = {}\n\n    const vertex_with_min_dist = (Q,dist) => {\n        let min_distance = Infinity,\n            u = null\n\n        for (let v of Q) {\n            if (dist[v] < min_distance) {\n                min_distance = dist[v]\n                u = v\n            }\n        }\n        return u\n    }\n\n    for (let i=0;i<edges.length;i++) {\n        let v1 = edges[i][0], \n            v2 = edges[i][1],\n            len = edges[i][2]\n\n        Q.add(v1)\n        Q.add(v2)\n\n        dist[v1] = Infinity\n        dist[v2] = Infinity\n\n        if (adj[v1] === undefined) adj[v1] = {}\n        if (adj[v2] === undefined) adj[v2] = {}\n\n        adj[v1][v2] = len\n        adj[v2][v1] = len\n    }\n     \n    dist[source] = 0\n\n    while (Q.size) {\n        let u = vertex_with_min_dist(Q,dist),\n            neighbors = Object.keys(adj[u]).filter(v=>Q.has(v)) //Neighbor still in Q \n\n        Q.delete(u)\n\n        if (u===target) break //Break when the target has been found\n\n        for (let v of neighbors) {\n            let alt = dist[u] + adj[u][v]\n            if (alt < dist[v]) {\n                dist[v] = alt\n                prev[v] = u\n            }\n        }\n    }\n\n    {\n        let u = target,\n        S = [u],\n        len = 0\n            \n        while (prev[u] !== undefined) {\n            S.unshift(prev[u])\n            len += adj[u][prev[u]]\n            u = prev[u]\n        }\n        return [S,len]\n    }   \n}\n\n//Testing algorithm\nlet graph = []\ngraph.push([\"a\", \"b\", 7])\ngraph.push([\"a\", \"c\", 9])\ngraph.push([\"a\", \"f\", 14])\ngraph.push([\"b\", \"c\", 10])\ngraph.push([\"b\", \"d\", 15])\ngraph.push([\"c\", \"d\", 11])\ngraph.push([\"c\", \"f\", 2])\ngraph.push([\"d\", \"e\", 6])\ngraph.push([\"e\", \"f\", 9])\n\nlet [path,length] = dijkstra(graph, \"a\", \"e\");\nconsole.log(path) //[ 'a', 'c', 'f', 'e' ]\nconsole.log(length) //20\n\n", "explain": "Using the wp:Dijkstra's_algorithm#Pseudocode\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "PHP", "code": "\n\n<?php\nfunction dijkstra($graph_array, $source, $target) {\n    $vertices = array();\n    $neighbours = array();\n    foreach ($graph_array as $edge) {\n        array_push($vertices, $edge[0], $edge[1]);\n        $neighbours[$edge[0]][] = array(\"end\" => $edge[1], \"cost\" => $edge[2]);\n        $neighbours[$edge[1]][] = array(\"end\" => $edge[0], \"cost\" => $edge[2]);\n    }\n    $vertices = array_unique($vertices);\n\n    foreach ($vertices as $vertex) {\n        $dist[$vertex] = INF;\n        $previous[$vertex] = NULL;\n    }\n\n    $dist[$source] = 0;\n    $Q = $vertices;\n    while (count($Q) > 0) {\n    \n        // TODO - Find faster way to get minimum\n        $min = INF;\n        foreach ($Q as $vertex){\n            if ($dist[$vertex] < $min) {\n                $min = $dist[$vertex];\n                $u = $vertex;\n            }\n        }\n        \n        $Q = array_diff($Q, array($u));\n        if ($dist[$u] == INF or $u == $target) {\n            break;\n        }\n\n        if (isset($neighbours[$u])) {\n            foreach ($neighbours[$u] as $arr) {\n                $alt = $dist[$u] + $arr[\"cost\"];\n                if ($alt < $dist[$arr[\"end\"]]) {\n                    $dist[$arr[\"end\"]] = $alt;\n                    $previous[$arr[\"end\"]] = $u;\n                }\n            }\n        }\n    }\n    $path = array();\n    $u = $target;\n    while (isset($previous[$u])) {\n        array_unshift($path, $u);\n        $u = $previous[$u];\n    }\n    array_unshift($path, $u);\n    return $path;\n}\n\n$graph_array = array(\n                    array(\"a\", \"b\", 7),\n                    array(\"a\", \"c\", 9),\n                    array(\"a\", \"f\", 14),\n                    array(\"b\", \"c\", 10),\n                    array(\"b\", \"d\", 15),\n                    array(\"c\", \"d\", 11),\n                    array(\"c\", \"f\", 2),\n                    array(\"d\", \"e\", 6),\n                    array(\"e\", \"f\", 9)\n               );\n\n$path = dijkstra($graph_array, \"a\", \"e\");\n\necho \"path is: \".implode(\", \", $path).\"\\n\";\n\n\npath is: a, c, f, e\n", "explain": "There are parts of this algorithm that could be optimized which have been marked TODO.\nOutput is:\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"container/heap\"\n\t\"fmt\"\n)\n\n// A PriorityQueue implements heap.Interface and holds Items.\ntype PriorityQueue struct {\n\titems []Vertex\n\tm     map[Vertex]int // value to index\n\tpr    map[Vertex]int // value to priority\n}\n\nfunc (pq *PriorityQueue) Len() int           { return len(pq.items) }\nfunc (pq *PriorityQueue) Less(i, j int) bool { return pq.pr[pq.items[i]] < pq.pr[pq.items[j]] }\nfunc (pq *PriorityQueue) Swap(i, j int) {\n\tpq.items[i], pq.items[j] = pq.items[j], pq.items[i]\n\tpq.m[pq.items[i]] = i\n\tpq.m[pq.items[j]] = j\n}\nfunc (pq *PriorityQueue) Push(x interface{}) {\n\tn := len(pq.items)\n\titem := x.(Vertex)\n\tpq.m[item] = n\n\tpq.items = append(pq.items, item)\n}\nfunc (pq *PriorityQueue) Pop() interface{} {\n\told := pq.items\n\tn := len(old)\n\titem := old[n-1]\n\tpq.m[item] = -1\n\tpq.items = old[0 : n-1]\n\treturn item\n}\n\n// update modifies the priority of an item in the queue.\nfunc (pq *PriorityQueue) update(item Vertex, priority int) {\n\tpq.pr[item] = priority\n\theap.Fix(pq, pq.m[item])\n}\nfunc (pq *PriorityQueue) addWithPriority(item Vertex, priority int) {\n\theap.Push(pq, item)\n\tpq.update(item, priority)\n}\n\nconst (\n\tInfinity      = int(^uint(0) >> 1)\n\tUninitialized = -1\n)\n\nfunc Dijkstra(g Graph, source Vertex) (dist map[Vertex]int, prev map[Vertex]Vertex) {\n\tvs := g.Vertices()\n\tdist = make(map[Vertex]int, len(vs))\n\tprev = make(map[Vertex]Vertex, len(vs))\n\tsid := source\n\tdist[sid] = 0\n\tq := &PriorityQueue{\n\t\titems: make([]Vertex, 0, len(vs)),\n\t\tm:     make(map[Vertex]int, len(vs)),\n\t\tpr:    make(map[Vertex]int, len(vs)),\n\t}\n\tfor _, v := range vs {\n\t\tif v != sid {\n\t\t\tdist[v] = Infinity\n\t\t}\n\t\tprev[v] = Uninitialized\n\t\tq.addWithPriority(v, dist[v])\n\t}\n\tfor len(q.items) != 0 {\n\t\tu := heap.Pop(q).(Vertex)\n\t\tfor _, v := range g.Neighbors(u) {\n\t\t\talt := dist[u] + g.Weight(u, v)\n\t\t\tif alt < dist[v] {\n\t\t\t\tdist[v] = alt\n\t\t\t\tprev[v] = u\n\t\t\t\tq.update(v, alt)\n\t\t\t}\n\t\t}\n\t}\n\treturn dist, prev\n}\n\n// A Graph is the interface implemented by graphs that\n// this algorithm can run on.\ntype Graph interface {\n\tVertices() []Vertex\n\tNeighbors(v Vertex) []Vertex\n\tWeight(u, v Vertex) int\n}\n\n// Nonnegative integer ID of vertex\ntype Vertex int\n\n// sg is a graph of strings that satisfies the Graph interface.\ntype sg struct {\n\tids   map[string]Vertex\n\tnames map[Vertex]string\n\tedges map[Vertex]map[Vertex]int\n}\n\nfunc newsg(ids map[string]Vertex) sg {\n\tg := sg{ids: ids}\n\tg.names = make(map[Vertex]string, len(ids))\n\tfor k, v := range ids {\n\t\tg.names[v] = k\n\t}\n\tg.edges = make(map[Vertex]map[Vertex]int)\n\treturn g\n}\nfunc (g sg) edge(u, v string, w int) {\n\tif _, ok := g.edges[g.ids[u]]; !ok {\n\t\tg.edges[g.ids[u]] = make(map[Vertex]int)\n\t}\n\tg.edges[g.ids[u]][g.ids[v]] = w\n}\nfunc (g sg) path(v Vertex, prev map[Vertex]Vertex) (s string) {\n\ts = g.names[v]\n\tfor prev[v] >= 0 {\n\t\tv = prev[v]\n\t\ts = g.names[v] + s\n\t}\n\treturn s\n}\nfunc (g sg) Vertices() []Vertex {\n\tvs := make([]Vertex, 0, len(g.ids))\n\tfor _, v := range g.ids {\n\t\tvs = append(vs, v)\n\t}\n\treturn vs\n}\nfunc (g sg) Neighbors(u Vertex) []Vertex {\n\tvs := make([]Vertex, 0, len(g.edges[u]))\n\tfor v := range g.edges[u] {\n\t\tvs = append(vs, v)\n\t}\n\treturn vs\n}\nfunc (g sg) Weight(u, v Vertex) int { return g.edges[u][v] }\n\nfunc main() {\n\tg := newsg(map[string]Vertex{\n\t\t\"a\": 1,\n\t\t\"b\": 2,\n\t\t\"c\": 3,\n\t\t\"d\": 4,\n\t\t\"e\": 5,\n\t\t\"f\": 6,\n\t})\n\tg.edge(\"a\", \"b\", 7)\n\tg.edge(\"a\", \"c\", 9)\n\tg.edge(\"a\", \"f\", 14)\n\tg.edge(\"b\", \"c\", 10)\n\tg.edge(\"b\", \"d\", 15)\n\tg.edge(\"c\", \"d\", 11)\n\tg.edge(\"c\", \"f\", 2)\n\tg.edge(\"d\", \"e\", 6)\n\tg.edge(\"e\", \"f\", 9)\n\n\tdist, prev := Dijkstra(g, g.ids[\"a\"])\n\tfmt.Printf(\"Distance to %s: %d, Path: %s\\n\", \"e\", dist[g.ids[\"e\"]], g.path(g.ids[\"e\"], prev))\n\tfmt.Printf(\"Distance to %s: %d, Path: %s\\n\", \"f\", dist[g.ids[\"f\"]], g.path(g.ids[\"f\"], prev))\n}\n\n\n\nOutput:\nDistance to e: 26, Path: acde\nDistance to f: 11, Path: acf\n\n", "explain": "Runable on the Go playground.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Delphi", "code": "\n\nprogram Rosetta_Dijkstra_Console;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils; // for printing the result\n\n// Conventional values (any negative values would do)\nconst\n  INFINITY  = -1;\n  NO_VERTEX = -2;\n\nconst\n  NR_VERTICES = 6;\n\n// DISTANCE_MATRIX[u, v] = length of directed edge from u to v, or -1 if no such edge exists.\n// A simple way to represent a directed graph with not many vertices.\nconst DISTANCE_MATRIX : array [0..(NR_VERTICES - 1), 0..(NR_VERTICES - 1)] of integer\n= ((-1,  7,  9, -1, -1, -1),\n   (-1, -1, 10, 15, -1, -1),\n   (-1, -1, -1, 11, -1,  2),\n   (-1, -1, -1, -1,  6, -1),\n   (-1, -1, -1, -1, -1,  9),\n   (-1, -1, -1, -1, -1, -1));\n\ntype TVertex = record\n  Distance : integer; // distance from vertex 0; infinity if a path has not yet been found\n  Previous : integer; // previous vertex in the path from vertex 0\n  Visited  : boolean; // as defined in the algorithm\nend;\n\n// For distances x and y, test whether x < y, using the convention that -1 means infinity.\nfunction IsLess( x, y : integer) : boolean;\nbegin\n  result := (x <> INFINITY)\n        and ( (y = INFINITY) or (x < y) );\nend;\n\n// Main routine\nvar\n  v : array [0..NR_VERTICES - 1] of TVertex; // array of vertices\n  c : integer; // index of current vertex\n  j : integer; // loop counter\n  trialDistance : integer;\n  minDistance : integer;\n  // Variables for printing the result\n  p : integer;\n  lineOut : string;\nbegin\n  // Initialize the vertices\n  for j := 0 to NR_VERTICES - 1 do begin\n    v[j].Distance := INFINITY;\n    v[j].Previous := NO_VERTEX;\n    v[j].Visited  := false;\n  end;\n\n  // Start with vertex 0 as the current vertex\n  c := 0;\n  v[c].Distance := 0;\n\n  // Main loop of Dijkstra's algorithm\n  repeat\n\n    // Work through unvisited neighbours of the current vertex, updating them where possible.\n    // \"Neighbour\" means the end of a directed edge from the current vertex.\n    // Note that v[c].Distance is always finite.\n    for j := 0 to NR_VERTICES - 1 do begin\n      if (not v[j].Visited) and (DISTANCE_MATRIX[c, j] >= 0) then begin\n        trialDistance := v[c].Distance + DISTANCE_MATRIX[c, j];\n        if IsLess( trialDistance, v[j].Distance) then begin\n          v[j].Distance := trialDistance;\n          v[j].Previous := c;\n        end;\n      end;\n    end;\n\n    // When all neighbours have been tested, mark the current vertex as visited.\n    v[c].Visited := true;\n\n    // The new current vertex is the unvisited vertex with the smallest finite distance.\n    // If there is no such vertex, the algorithm is finished.\n    c := NO_VERTEX;\n    minDistance := INFINITY;\n    for j := 0 to NR_VERTICES - 1 do begin\n      if (not v[j].Visited) and IsLess( v[j].Distance, minDistance) then begin\n        minDistance := v[j].Distance;\n        c := j;\n      end;\n    end;\n  until (c = NO_VERTEX);\n\n  // Print the result\n  for j := 0 to NR_VERTICES - 1 do begin\n    if (v[j].Distance = INFINITY) then begin\n      // The algorithm never found a path to v[j]\n      lineOut := SysUtils.Format( '%2d: inaccessible', [j]);\n    end\n    else begin\n      // Build up the path of vertices, working backwards from v[j]\n      lineOut := SysUtils.Format( '%2d', [j]);\n      p := v[j].Previous;\n      while (p <> NO_VERTEX) do begin\n        lineOut := SysUtils.Format( '%2d --> ', [p]) + lineOut;\n        p := v[p].Previous;\n      end;\n      // Print the path of vertices, preceded by distance from vertex 0\n      lineOut := SysUtils.Format( '%2d: distance = %3d, ', [j, v[j].Distance]) + lineOut;\n    end;\n    WriteLn( lineOut);\n  end;\nend.\n\n\nOutput:\n 0: distance =   0,  0\n 1: distance =   7,  0 -->  1\n 2: distance =   9,  0 -->  2\n 3: distance =  20,  0 -->  2 -->  3\n 4: distance =  26,  0 -->  2 -->  3 -->  4\n 5: distance =  11,  0 -->  2 -->  5\n\n", "explain": "A console program written in Delphi 7. It runs from the Windows command prompt.\nAn infinite distance is here represented by -1, which complicates the code when comparing distances, but ensures that infinity can't be equalled or exceeded by any finite distance.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Ruby", "code": "\n\nWorks with: Ruby version 1.9.2+ (for INFINITY)\n\nAt every iteration, the next minimum distance node found by linear traversal of all nodes, which is inefficient.\nclass Graph\n  Vertex = Struct.new(:name, :neighbours, :dist, :prev)\n \n  def initialize(graph)\n    @vertices = Hash.new{|h,k| h[k]=Vertex.new(k,[],Float::INFINITY)}\n    @edges = {}\n    graph.each do |(v1, v2, dist)|\n      @vertices[v1].neighbours << v2\n      @vertices[v2].neighbours << v1\n      @edges[[v1, v2]] = @edges[[v2, v1]] = dist\n    end\n    @dijkstra_source = nil\n  end\n \n  def dijkstra(source)\n    return  if @dijkstra_source == source\n    q = @vertices.values\n    q.each do |v|\n      v.dist = Float::INFINITY\n      v.prev = nil\n    end\n    @vertices[source].dist = 0\n    until q.empty?\n      u = q.min_by {|vertex| vertex.dist}\n      break if u.dist == Float::INFINITY\n      q.delete(u)\n      u.neighbours.each do |v|\n        vv = @vertices[v]\n        if q.include?(vv)\n          alt = u.dist + @edges[[u.name, v]]\n          if alt < vv.dist\n            vv.dist = alt\n            vv.prev = u.name\n          end\n        end\n      end\n    end\n    @dijkstra_source = source\n  end\n \n  def shortest_path(source, target)\n    dijkstra(source)\n    path = []\n    u = target\n    while u\n      path.unshift(u)\n      u = @vertices[u].prev\n    end\n    return path, @vertices[target].dist\n  end\n \n  def to_s\n    \"#<%s vertices=%p edges=%p>\" % [self.class.name, @vertices.values, @edges] \n  end\nend\n\ng = Graph.new([ [:a, :b, 7],\n                [:a, :c, 9],\n                [:a, :f, 14],\n                [:b, :c, 10],\n                [:b, :d, 15],\n                [:c, :d, 11],\n                [:c, :f, 2],\n                [:d, :e, 6],\n                [:e, :f, 9],\n              ])\n\nstart, stop = :a, :e\npath, dist = g.shortest_path(start, stop)\nputs \"shortest path from #{start} to #{stop} has cost #{dist}:\"\nputs path.join(\" -> \")\n\n\nOutput:\nshortest path from a to e has cost 20:\na -> c -> f -> e\n", "explain": "This solution is incorrect.  Since the path is directed and f is only a sink, f cannot be in the middle of a path.\nNotes for this solution: \n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Rust", "code": "\n\nuse std::cmp::Ordering;\nuse std::collections::BinaryHeap;\nuse std::usize;\n\n\nstruct Grid<T> {\n    nodes: Vec<Node<T>>,\n}\n\nstruct Node<T> {\n    data: T,\n    edges: Vec<(usize,usize)>,\n}\n\n#[derive(Copy, Clone, Eq, PartialEq)]\nstruct State {\n    node: usize,\n    cost: usize,\n}\n\n// Manually implement Ord so we get a min-heap instead of a max-heap\nimpl Ord for State {\n    fn cmp(&self, other: &Self) -> Ordering {\n        other.cost.cmp(&self.cost)\n    }\n}\n\nimpl PartialOrd for State {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\ntype WeightedEdge = (usize, usize, usize);\n\nimpl<T> Grid<T> {\n    fn new() -> Self {\n        Grid { nodes: Vec::new() }\n    }\n\n    fn add_node(&mut self, data: T) -> usize {\n        let node = Node {\n            edges: Vec::new(),\n            data: data,\n        };\n        self.nodes.push(node);\n        self.nodes.len() - 1\n    }\n\n    fn create_edges<'a, I>(&mut self, iterator: I) where I: IntoIterator<Item=&'a WeightedEdge> {\n        for &(start,end,weight) in iterator.into_iter() {\n            self.nodes[start].edges.push((end,weight));\n            self.nodes[end].edges.push((start,weight));\n        }\n    \n    }\n\n    fn find_path(&self, start: usize, end: usize) -> Option<(Vec<usize>, usize)> {\n        let mut dist = vec![(usize::MAX, None); self.nodes.len()];\n\n        let mut heap = BinaryHeap::new();\n        dist[start] = (0, None);\n        heap.push(State {\n            node: start,\n            cost: 0,\n        });\n\n        while let Some(State { node, cost }) = heap.pop() {\n            if node == end {\n                let mut path = Vec::with_capacity(dist.len() / 2);\n                let mut current_dist = dist[end];\n                path.push(end);\n                while let Some(prev) = current_dist.1 {\n                    path.push(prev);\n                    current_dist = dist[prev];\n                }\n                path.reverse();\n                return Some((path, cost));\n            }\n\n            if cost > dist[node].0 {\n                continue;\n            }\n            for edge in &self.nodes[node].edges {\n                let next = State {\n                    node: edge.0,\n                    cost: cost + edge.1,\n                };\n                if next.cost < dist[next.node].0 {\n                    dist[next.node] = (next.cost, Some(node));\n                    heap.push(next);\n                }\n            }\n        }\n        None\n    }\n}\n\nfn main() {\n    let mut grid = Grid::new();\n    let (a,b,c,d,e,f) = (grid.add_node(\"a\"), grid.add_node(\"b\"),\n                         grid.add_node(\"c\"), grid.add_node(\"d\"),\n                         grid.add_node(\"e\"), grid.add_node(\"f\"));\n\n    grid.create_edges(&[\n        (a,b,7) ,(a,c,9) ,(a,f,14),\n        (b,c,10),(b,d,15),(c,d,11),\n        (c,f,2) ,(d,e,6) ,(e,f,9) ,\n    ]);\n\n    let (path, cost) = grid.find_path(a,e).unwrap();\n\n    print!(\"{}\", grid.nodes[path[0]].data);\n    for i in path.iter().skip(1) {\n        print!(\" -> {}\", grid.nodes[*i].data);\n    }\n    println!(\"\\nCost: {}\", cost);\n\n}\n\n\nOutput:\nCost: 20\na -> c -> f -> e\n\n", "explain": "This solution uses a very bare-bones, naive implementation of an adjacency list to represent the graph.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Swift", "code": "\n\nTranslation of: Rust\ntypealias WeightedEdge = (Int, Int, Int)\n\nstruct Grid<T> {\n  var nodes: [Node<T>]\n\n  mutating func addNode(data: T) -> Int {\n    nodes.append(Node(data: data, edges: []))\n\n    return nodes.count - 1\n  }\n\n  mutating func createEdges(weights: [WeightedEdge]) {\n    for (start, end, weight) in weights {\n      nodes[start].edges.append((end, weight))\n      nodes[end].edges.append((start, weight))\n    }\n  }\n\n  func findPath(start: Int, end: Int) -> ([Int], Int)? {\n    var dist = Array(repeating: (Int.max, nil as Int?), count: nodes.count)\n    var heap = Heap<State>(sort: { $0.cost < $1.cost })\n\n    dist[start] = (0, nil)\n    heap.insert(State(node: start, cost: 0))\n\n    while let state = heap.remove(at: 0) {\n      if state.node == end {\n        var path = [end]\n        var currentDist = dist[end]\n\n        while let prev = currentDist.1 {\n          path.append(prev)\n          currentDist = dist[prev]\n        }\n\n        return (path.reversed(), state.cost)\n      }\n\n      guard state.cost <= dist[state.node].0 else {\n        continue\n      }\n\n      for edge in nodes[state.node].edges {\n        let next = State(node: edge.0, cost: state.cost + edge.1)\n\n        if next.cost < dist[next.node].0 {\n          dist[next.node] = (next.cost, state.node)\n          heap.insert(next)\n        }\n      }\n    }\n\n    return nil\n  }\n}\n\nstruct Node<T> {\n  var data: T\n  var edges: [(Int, Int)]\n}\n\nstruct State {\n  var node: Int\n  var cost: Int\n}\n\nvar grid = Grid<String>(nodes: [])\n\nlet (a, b, c, d, e, f) = (\n  grid.addNode(data: \"a\"),\n  grid.addNode(data: \"b\"),\n  grid.addNode(data: \"c\"),\n  grid.addNode(data: \"d\"),\n  grid.addNode(data: \"e\"),\n  grid.addNode(data: \"f\")\n)\n\ngrid.createEdges(weights: [\n  (a, b, 7), (a, c, 9), (a, f, 14),\n  (b, c, 10), (b, d, 15), (c, d, 11),\n  (c, f, 2), (d, e, 6), (e, f, 9)\n])\n\nguard let (path, cost) = grid.findPath(start: a, end: e) else {\n  fatalError(\"Could not find path\")\n}\n\nprint(\"Cost: \\(cost)\")\nprint(path.map({ grid.nodes[$0].data }).joined(separator: \" -> \"))\n\n\nOutput:\nCost: 20\na -> c -> f -> e\n", "explain": "Uses the Heap type from the Swift Algorithm Club.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Ada", "code": "\nWorks with: GNAT\n\nprivate with Ada.Containers.Ordered_Maps;\ngeneric\n   type t_Vertex is (<>);\npackage Dijkstra is\n   \n   type t_Graph is limited private;\n   \n   -- Defining a graph (since limited private, only way to do this is to use the Build function)\n   type t_Edge is record\n      From, To : t_Vertex;\n      Weight   : Positive;\n   end record;\n   type t_Edges is array (Integer range <>) of t_Edge;\n   function Build (Edges : in t_Edges; Oriented : in Boolean := True) return t_Graph;\n   \n   -- Computing path and distance\n   type t_Path is array (Integer range <>) of t_Vertex;\n   function Shortest_Path (Graph    : in out t_Graph;\n                           From, To : in t_Vertex) return t_Path;\n   function Distance      (Graph    : in out t_Graph;\n                           From, To : in t_Vertex) return Natural;\n   \nprivate\n   package Neighbor_Lists is new Ada.Containers.Ordered_Maps (Key_Type => t_Vertex, Element_Type => Positive);\n   type t_Vertex_Data is record\n      Neighbors : Neighbor_Lists.Map; -- won't be affected after build\n      -- Updated each time a function is called with a new source\n      Previous  : t_Vertex;\n      Distance  : Natural;\n   end record;\n   type t_Graph is array (t_Vertex) of t_Vertex_Data;\nend Dijkstra;\n\nwith Ada.Containers.Ordered_Sets;\npackage body Dijkstra is\n\n   Infinite : constant Natural := Natural'Last;\n   \n   -- ----- Graph constructor\n   function Build (Edges : in t_Edges; Oriented : in Boolean := True) return t_Graph is\n   begin\n      return Answer : t_Graph := (others => (Neighbors => Neighbor_Lists.Empty_Map,\n                                             Previous  => t_Vertex'First,\n                                             Distance  => Natural'Last)) do\n         for Edge of Edges loop\n            Answer(Edge.From).Neighbors.Insert (Key => Edge.To, New_Item => Edge.Weight);\n            if not Oriented then\n               Answer(Edge.To).Neighbors.Insert (Key => Edge.From, New_Item => Edge.Weight);\n            end if;\n         end loop;\n      end return;\n   end Build;\n   \n   -- ----- Paths / distances data updating in case of computation request for a new source\n   procedure Update_For_Source (Graph : in out t_Graph;\n                                From  : in t_Vertex) is\n      function Nearer (Left, Right : in t_Vertex) return Boolean is\n        (Graph(Left).Distance < Graph(Right).Distance or else\n         (Graph(Left).Distance = Graph(Right).Distance and then Left < Right));\n      package Ordered is new Ada.Containers.Ordered_Sets (Element_Type => t_Vertex, \"<\" => Nearer);\n      use Ordered;\n      Remaining : Set := Empty_Set;\n   begin\n      -- First, let's check if vertices data are already computed for this source\n      if Graph(From).Distance /= 0 then\n         -- Reset distances and remaining vertices for a new source\n         for Vertex in Graph'range loop\n            Graph(Vertex).Distance := (if Vertex = From then 0 else Infinite);\n            Remaining.Insert (Vertex);\n         end loop;\n         -- ----- The Dijkstra algorithm itself\n         while not Remaining.Is_Empty\n               -- If some targets are not connected to source, at one point, the remaining\n               -- distances will all be infinite, hence the folllowing stop condition\n               and then Graph(Remaining.First_Element).Distance /= Infinite loop\n            declare\n               Nearest : constant t_Vertex := Remaining.First_Element;\n               procedure Update_Neighbor (Position : in Neighbor_Lists.Cursor) is\n                  use Neighbor_Lists;\n                  Neighbor     : constant t_Vertex := Key (Position); \n                  In_Remaining : Ordered.Cursor    := Remaining.Find (Neighbor);\n                  Try_Distance : constant Natural  :=\n                    (if In_Remaining = Ordered.No_Element\n                     then Infinite -- vertex already reached, this distance will fail the update test below\n                     else Graph(Nearest).Distance + Element (Position)); \n               begin\n                  if Try_Distance < Graph(Neighbor).Distance then\n                     -- Update distance/path data and reorder the remaining set\n                     Remaining.Delete (In_Remaining);\n                     Graph(Neighbor).Distance := Try_Distance;\n                     Graph(Neighbor).Previous := Nearest;\n                     Remaining.Insert (Neighbor);\n                  end if;\n               end Update_Neighbor;\n            begin\n               Remaining.Delete_First;\n               Graph(Nearest).Neighbors.Iterate (Update_Neighbor'Access);\n            end;\n         end loop;\n      end if;\n   end Update_For_Source;\n   \n   -- ----- Bodies for the interfaced functions\n   function Shortest_Path (Graph    : in out t_Graph;\n                           From, To : in t_Vertex) return t_Path is\n      function Recursive_Build (From, To : in t_Vertex) return t_Path is\n        (if From = To then (1 => From)\n         else Recursive_Build(From, Graph(To).Previous) & (1 => To));\n   begin\n      Update_For_Source (Graph, From);\n      if Graph(To).Distance = Infinite then\n         raise Constraint_Error with \"No path from \" & From'Img & \" to \" & To'Img;\n      end if;\n      return Recursive_Build (From, To);\n   end Shortest_Path;\n\n   function Distance (Graph    : in out t_Graph;\n                      From, To : in t_Vertex) return Natural is\n   begin\n      Update_For_Source (Graph, From);\n      return Graph(To).Distance;\n   end Distance;\n\nend Dijkstra;\n\n\nwith Ada.Text_IO; use Ada.Text_IO;\nwith Dijkstra;\nprocedure Test_Dijkstra is\n   subtype t_Tested_Vertices is Character range 'a'..'f';\n   package Tested is new Dijkstra (t_Vertex => t_Tested_Vertices);\n   use Tested;\n   Graph : t_Graph := Build (Edges => (('a', 'b', 7),\n                                       ('a', 'c', 9),\n                                       ('a', 'f', 14),\n                                       ('b', 'c', 10),\n                                       ('b', 'd', 15),\n                                       ('c', 'd', 11),\n                                       ('c', 'f', 2),\n                                       ('d', 'e', 6),\n                                       ('e', 'f', 9)));\n   procedure Display_Path (From, To : in t_Tested_Vertices) is\n      function Path_Image (Path : in t_Path; Start : Boolean := True) return String is\n        ((if Start then \"[\"\n          elsif Path'Length /= 0 then \",\"\n          else \"\") &\n         (if Path'Length = 0 then \"]\"\n          else Path(Path'First) & Path_Image(Path(Path'First+1..Path'Last), Start => False)));\n   begin\n      Put      (\"Path from '\" & From & \"' to '\" & To & \"' = \");\n      Put_Line (Path_Image (Shortest_Path (Graph, From, To))\n                & \" distance =\" & Distance (Graph, From, To)'Img);\n   exception\n      when others => Put_Line(\"no path\");\n   end Display_Path;\nbegin\n   Display_Path ('a', 'e');\n   Display_Path ('a', 'f');\n   New_Line;\n   for From in t_Tested_Vertices loop\n      for To in t_Tested_Vertices loop\n         Display_Path (From, To);\n      end loop;\n   end loop;            \nend Test_Dijkstra;\n\n\nOutput:\nPath from 'a' to 'e' = [a,c,d,e] distance = 26\nPath from 'a' to 'f' = [a,c,f] distance = 11\n\nPath from 'a' to 'a' = [a] distance = 0\nPath from 'a' to 'b' = [a,b] distance = 7\nPath from 'a' to 'c' = [a,c] distance = 9\nPath from 'a' to 'd' = [a,c,d] distance = 20\nPath from 'a' to 'e' = [a,c,d,e] distance = 26\nPath from 'a' to 'f' = [a,c,f] distance = 11\nPath from 'b' to 'a' = no path\nPath from 'b' to 'b' = [b] distance = 0\nPath from 'b' to 'c' = [b,c] distance = 10\nPath from 'b' to 'd' = [b,d] distance = 15\nPath from 'b' to 'e' = [b,d,e] distance = 21\nPath from 'b' to 'f' = [b,c,f] distance = 12\nPath from 'c' to 'a' = no path\nPath from 'c' to 'b' = no path\nPath from 'c' to 'c' = [c] distance = 0\nPath from 'c' to 'd' = [c,d] distance = 11\nPath from 'c' to 'e' = [c,d,e] distance = 17\nPath from 'c' to 'f' = [c,f] distance = 2\nPath from 'd' to 'a' = no path\nPath from 'd' to 'b' = no path\nPath from 'd' to 'c' = no path\nPath from 'd' to 'd' = [d] distance = 0\nPath from 'd' to 'e' = [d,e] distance = 6\nPath from 'd' to 'f' = [d,e,f] distance = 15\nPath from 'e' to 'a' = no path\nPath from 'e' to 'b' = no path\nPath from 'e' to 'c' = no path\nPath from 'e' to 'd' = no path\nPath from 'e' to 'e' = [e] distance = 0\nPath from 'e' to 'f' = [e,f] distance = 9\nPath from 'f' to 'a' = no path\nPath from 'f' to 'b' = no path\nPath from 'f' to 'c' = no path\nPath from 'f' to 'd' = no path\nPath from 'f' to 'e' = no path\nPath from 'f' to 'f' = [f] distance = 0\n", "explain": "This solution uses a generic package and Ada 2012 (containers, extended return statements, expression functions).\nThe very convenient 'Img attribute is a GNAT feature.\nThe testing main procedure\u00a0:\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Julia", "code": "\nWorks with: Julia version 1.8\nusing Printf\n\nstruct Digraph{T <: Real,U}\n    edges::Dict{Tuple{U,U},T}\n    verts::Set{U}\nend\n\nfunction Digraph(edges::Vector{Tuple{U,U,T}}) where {T <: Real,U}\n    vnames = Set{U}(v for edge in edges for v in edge[1:2])\n    adjmat = Dict((edge[1], edge[2]) => edge[3] for edge in edges)\n    return Digraph(adjmat, vnames)\nend\n\nvertices(g::Digraph) = g.verts\nedges(g::Digraph)    = g.edges\n\nneighbours(g::Digraph, v) = Set((b, c) for ((a, b), c) in edges(g) if a == v)\n\nfunction dijkstrapath(g::Digraph{T,U}, source::U, dest::U) where {T, U}\n    @assert source \u2208 vertices(g) \"$source is not a vertex in the graph\"\n\n    # Easy case\n    if source == dest return [source], 0 end\n    # Initialize variables\n    inf  = typemax(T)\n    dist = Dict(v => inf for v in vertices(g))\n    prev = Dict(v => v   for v in vertices(g))\n    dist[source] = 0\n    Q = copy(vertices(g))\n    neigh = Dict(v => neighbours(g, v) for v in vertices(g))\n\n    # Main loop\n    while !isempty(Q)\n        u = reduce((x, y) -> dist[x] < dist[y] ? x : y, Q)\n        pop!(Q, u)\n        if dist[u] == inf || u == dest break end\n        for (v, cost) in neigh[u]\n            alt = dist[u] + cost\n            if alt < dist[v]\n                dist[v] = alt\n                prev[v] = u\n            end\n        end\n    end\n\n    # Return path\n    rst, cost = U[], dist[dest]\n    if prev[dest] == dest\n        return rst, cost\n    else\n        while dest != source\n            pushfirst!(rst, dest)\n            dest = prev[dest]\n        end\n        pushfirst!(rst, dest)\n        return rst, cost\n    end\nend\n\n# testgraph = [(\"a\", \"b\", 1), (\"b\", \"e\", 2), (\"a\", \"e\", 4)]\nconst testgraph = [(\"a\", \"b\", 7),  (\"a\", \"c\", 9),  (\"a\", \"f\", 14), (\"b\", \"c\", 10),\n             (\"b\", \"d\", 15), (\"c\", \"d\", 11), (\"c\", \"f\", 2),  (\"d\", \"e\", 6),\n             (\"e\", \"f\", 9)]\n\nfunction testpaths()\n    g = Digraph(testgraph)\n    src, dst = \"a\", \"e\"\n    path, cost = dijkstrapath(g, src, dst)\n    println(\"Shortest path from $src to $dst: \", isempty(path) ?\n       \"no possible path\" : join(path, \" \u2192 \"), \" (cost $cost)\")\n    # Print all possible paths\n    @printf(\"\\n%4s | %3s | %s\\n\", \"src\", \"dst\", \"path\")\n    @printf(\"----------------\\n\")\n    for src in vertices(g), dst in vertices(g)\n        path, cost = dijkstrapath(g, src, dst)\n        @printf(\"%4s | %3s | %s\\n\", src, dst, isempty(path) ? \"no possible path\" : join(path, \" \u2192 \") * \" ($cost)\")\n    end\nend\n\ntestpaths()\n\nOutput:\nShortest path from a to e: a \u2192 c \u2192 d \u2192 e (cost 26)\n\n src | dst | path\n----------------\n   f |   f | f (0)\n   f |   c | no possible path\n   f |   e | no possible path\n   f |   b | no possible path\n   f |   a | no possible path\n   f |   d | no possible path\n   c |   f | c \u2192 f (2)\n   c |   c | c (0)\n   c |   e | c \u2192 d \u2192 e (17)\n   c |   b | no possible path\n   c |   a | no possible path\n   c |   d | c \u2192 d (11)\n   e |   f | e \u2192 f (9)\n   e |   c | no possible path\n   e |   e | e (0)\n   e |   b | no possible path\n   e |   a | no possible path\n   e |   d | no possible path\n   b |   f | b \u2192 c \u2192 f (12)\n   b |   c | b \u2192 c (10)\n   b |   e | b \u2192 d \u2192 e (21)\n   b |   b | b (0)\n   b |   a | no possible path\n   b |   d | b \u2192 d (15)\n   a |   f | a \u2192 c \u2192 f (11)\n   a |   c | a \u2192 c (9)\n   a |   e | a \u2192 c \u2192 d \u2192 e (26)\n   a |   b | a \u2192 b (7)\n   a |   a | a (0)\n   a |   d | a \u2192 c \u2192 d (20)\n   d |   f | d \u2192 e \u2192 f (15)\n   d |   c | no possible path\n   d |   e | d \u2192 e (6)\n   d |   b | no possible path\n   d |   a | no possible path\n   d |   d | d (0)\n", "explain": ""}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "SAS", "code": "\n\n/* create SAS data set */\ndata Edges;\n   input Start $ End $ Cost; \n   datalines;\na  b  7  \na  c  9  \na  f  14  \nb  c  10  \nb  d  15  \nc  d  11  \nc  f  2  \nd  e  6  \ne  f  9  \n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare sets and parameters, and read input data */\n   set <str,str> LINKS;\n   num cost {LINKS};\n   read data Edges into LINKS=[start end] cost;\n   set NODES = union {<i,j> in LINKS} {i,j};\n   set SOURCES = {'a'};\n   set SINKS = {'e'};\n   /* <source,sink,order,from,to> */\n   set <str,str,num,str,str> PATHS;\n\n   /* call network solver */\n   solve with network /\n      shortpath=(source=SOURCES sink=SINKS) links=(weight=cost) out=(sppaths=PATHS);\n\n   /* write shortest path to SAS data set */\n   create data path from [source sink order from to]=PATHS cost[from,to];\nquit;\n\n/* print shortest path */\nproc print data=path;\nrun;\n\n\nObs source sink order from to cost \n1 a e 1 a c 9 \n2 a e 2 c f 2 \n3 a e 3 e f 9 \n\n", "explain": "Use network solver in SAS/OR:\nOutput:\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.51\n\nimport java.util.TreeSet\n\nclass Edge(val v1: String, val v2: String, val dist: Int)\n\n /** One vertex of the graph, complete with mappings to neighbouring vertices */\nclass Vertex(val name: String) : Comparable<Vertex> {\n\n    var dist = Int.MAX_VALUE  // MAX_VALUE assumed to be infinity\n    var previous: Vertex? = null\n    val neighbours = HashMap<Vertex, Int>()\n\n    fun printPath() {\n        if (this == previous) {\n            print(name)\n        }\n        else if (previous == null) {\n            print(\"$name(unreached)\")\n        }\n        else {\n            previous!!.printPath()\n            print(\" -> $name($dist)\")\n        }\n    }\n\n    override fun compareTo(other: Vertex): Int {\n        if (dist == other.dist) return name.compareTo(other.name)\n        return dist.compareTo(other.dist)\n    }\n\n    override fun toString() = \"($name, $dist)\"\n}\n\nclass Graph(\n    val edges: List<Edge>, \n    val directed: Boolean,\n    val showAllPaths: Boolean = false\n) {\n    // mapping of vertex names to Vertex objects, built from a set of Edges\n    private val graph = HashMap<String, Vertex>(edges.size)\n\n    init {\n        // one pass to find all vertices\n        for (e in edges) {\n            if (!graph.containsKey(e.v1)) graph.put(e.v1, Vertex(e.v1))\n            if (!graph.containsKey(e.v2)) graph.put(e.v2, Vertex(e.v2))\n        }\n\n        // another pass to set neighbouring vertices\n        for (e in edges) {\n            graph[e.v1]!!.neighbours.put(graph[e.v2]!!, e.dist)\n            // also do this for an undirected graph if applicable\n            if (!directed) graph[e.v2]!!.neighbours.put(graph[e.v1]!!, e.dist)\n        }\n    }\n\n    /** Runs dijkstra using a specified source vertex */\n    fun dijkstra(startName: String) {\n        if (!graph.containsKey(startName)) {\n            println(\"Graph doesn't contain start vertex '$startName'\")\n            return\n        }\n        val source = graph[startName]\n        val q = TreeSet<Vertex>()\n\n        // set-up vertices\n        for (v in graph.values) {\n            v.previous = if (v == source) source else null\n            v.dist = if (v == source)  0 else Int.MAX_VALUE\n            q.add(v)\n        }\n\n        dijkstra(q)\n    }\n\n    /** Implementation of dijkstra's algorithm using a binary heap */\n    private fun dijkstra(q: TreeSet<Vertex>) {\n        while (!q.isEmpty()) {\n            // vertex with shortest distance (first iteration will return source)\n            val u = q.pollFirst()\n            // if distance is infinite we can ignore 'u' (and any other remaining vertices)\n            // since they are unreachable\n            if (u.dist == Int.MAX_VALUE) break\n\n            //look at distances to each neighbour\n            for (a in u.neighbours) {\n                val v = a.key // the neighbour in this iteration\n\n                val alternateDist = u.dist + a.value\n                if (alternateDist < v.dist) { // shorter path to neighbour found\n                    q.remove(v)\n                    v.dist = alternateDist\n                    v.previous = u\n                    q.add(v)\n                }\n            }\n        }\n    }\n\n    /** Prints a path from the source to the specified vertex */\n    fun printPath(endName: String) {\n        if (!graph.containsKey(endName)) {\n            println(\"Graph doesn't contain end vertex '$endName'\")\n            return\n        }\n        print(if (directed) \"Directed  \u00a0: \" else \"Undirected\u00a0: \")\n        graph[endName]!!.printPath()\n        println()\n        if (showAllPaths) printAllPaths() else println()\n    }\n\n    /** Prints the path from the source to every vertex (output order is not guaranteed) */\n    private fun printAllPaths() {\n        for (v in graph.values) {\n            v.printPath()\n            println()\n        }\n        println()\n    }\n}\n\nval GRAPH = listOf(\n    Edge(\"a\", \"b\", 7),\n    Edge(\"a\", \"c\", 9),\n    Edge(\"a\", \"f\", 14),\n    Edge(\"b\", \"c\", 10),\n    Edge(\"b\", \"d\", 15),\n    Edge(\"c\", \"d\", 11),\n    Edge(\"c\", \"f\", 2),\n    Edge(\"d\", \"e\", 6),\n    Edge(\"e\", \"f\", 9)\n)\n\nconst val START = \"a\"\nconst val END = \"e\"\n\nfun main(args: Array<String>) {\n    with (Graph(GRAPH, true)) {   // directed\n        dijkstra(START)\n        printPath(END)\n    }\n    with (Graph(GRAPH, false)) {  // undirected\n        dijkstra(START)\n        printPath(END)\n    }\n}\n\n\nOutput:\nDirected  \u00a0: a -> c(9) -> d(20) -> e(26)\n\nUndirected\u00a0: a -> c(9) -> f(11) -> e(20)\n\n", "explain": ""}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Perl", "code": "\nuse strict;\nuse warnings;\nuse constant True => 1;\n\nsub add_edge {\n    my ($g, $a, $b, $weight) = @_;\n    $g->{$a} ||= {name => $a};\n    $g->{$b} ||= {name => $b};\n    push @{$g->{$a}{edges}}, {weight => $weight, vertex => $g->{$b}};\n}\n\nsub push_priority {\n    my ($a, $v) = @_;\n    my $i = 0;\n    my $j = $#{$a};\n    while ($i <= $j) {\n        my $k = int(($i + $j) / 2);\n        if ($a->[$k]{dist} >= $v->{dist}) { $j = $k - 1 }\n        else                              { $i = $k + 1 }\n    }\n    splice @$a, $i, 0, $v;\n}\n\nsub dijkstra {\n    my ($g, $a, $b) = @_;\n    for my $v (values %$g) {\n        $v->{dist} = 10e7; # arbitrary large value\n        delete @$v{'prev', 'visited'}\n     }\n    $g->{$a}{dist} = 0;\n    my $h = [];\n    push_priority($h, $g->{$a});\n    while () {\n        my $v = shift @$h;\n        last if !$v or $v->{name} eq $b;\n        $v->{visited} = True;\n        for my $e (@{$v->{edges}}) {\n            my $u = $e->{vertex};\n            if (!$u->{visited} && $v->{dist} + $e->{weight} <= $u->{dist}) {\n                $u->{prev} = $v;\n                $u->{dist} = $v->{dist} + $e->{weight};\n                push_priority($h, $u);\n            }\n        }\n    }\n}\n\nmy $g = {};\nadd_edge($g, @$_) for\n (['a', 'b',  7], ['a', 'c',  9], ['a', 'f', 14],\n  ['b', 'c', 10], ['b', 'd', 15], ['c', 'd', 11],\n  ['c', 'f',  2], ['d', 'e',  6], ['e', 'f',  9]);\n\ndijkstra($g, 'a', 'e');\n\nmy $v = $g->{e};\nmy @a;\nwhile ($v) {\n    push @a, $v->{name};\n    $v = $v->{prev};\n}\nmy $path = join '', reverse @a;\nprint \"$g->{e}{dist} $path\\n\";\n\n\nOutput:\n26 acde\n", "explain": ""}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Prolog", "code": "\n\n    rpath([target|reversed_path], distance)   \n\n   - arbitrarily selects a node (Qi) neighboring origin (o), and for that node\n   - if o->Qi is the shortest known path:\n       - update path and distance\n       - traverse Qi\n   - if o->Qi is not the shortest, select the next node.\n\n\n   - We use this list to ensure that we do not loop endlessly.\n   - This path is recorded as the shortest if the distance is indeed shorter than a known path.\n   - Leaf nodes in the traversal tree are processed completely before the origin node processing \n     is completed. \n     - This implies that the first stage in our algorithm involves allocating each node\n       in the traversal tree a path and 'shortest known distance from origin' value.\n     - ...Which is arguably better than assigning an initial 'infinite distance' value.\n\n\n%___________________________________________________________________________\n\n:-dynamic\n\trpath/2.      % A reversed path\n\nedge(a,b,7).\nedge(a,c,9).\nedge(b,c,10).\nedge(b,d,15).\nedge(c,d,11).\nedge(d,e,6).\nedge(a,f,14).\nedge(c,f,2).\nedge(e,f,9).\n\npath(From,To,Dist) :- edge(To,From,Dist).\npath(From,To,Dist) :- edge(From,To,Dist).\n\nshorterPath([H|Path], Dist) :-\t\t       % path < stored path? replace it\n\trpath([H|T], D), !, Dist < D,          % match target node [H|_]\n\tretract(rpath([H|_],_)),\n\twritef('%w is closer than %w\\n', [[H|Path], [H|T]]),\n\tassert(rpath([H|Path], Dist)).\nshorterPath(Path, Dist) :-\t\t       % Otherwise store a new path\n\twritef('New path:%w\\n', [Path]),\n\tassert(rpath(Path,Dist)).\n\ntraverse(From, Path, Dist) :-\t\t    % traverse all reachable nodes\n\tpath(From, T, D),\t\t    % For each neighbor\n\tnot(memberchk(T, Path)),\t    %\twhich is unvisited\n\tshorterPath([T,From|Path], Dist+D), %\tUpdate shortest path and distance\n\ttraverse(T,[From|Path],Dist+D).\t    %\tThen traverse the neighbor\n\ntraverse(From) :-\n\tretractall(rpath(_,_)),           % Remove solutions\n\ttraverse(From,[],0).              % Traverse from origin\ntraverse(_).\n\ngo(From, To) :-\n\ttraverse(From),                   % Find all distances\n\trpath([To|RPath], Dist)->         % If the target was reached\n\t  reverse([To|RPath], Path),      % Report the path and distance\n\t  Distance is round(Dist),\n\t  writef('Shortest path is %w with distance %w = %w\\n',\n\t       [Path, Dist, Distance]);\n\twritef('There is no route from %w to %w\\n', [From, To]).\n\n\n?- go(a,e).\nNew path:[b,a]\nNew path:[c,b,a]\nNew path:[d,c,b,a]\nNew path:[e,d,c,b,a]\nNew path:[f,e,d,c,b,a]\n[f,c,b,a] is closer than [f,e,d,c,b,a]\n[e,f,c,b,a] is closer than [e,d,c,b,a]\n[d,b,a] is closer than [d,c,b,a]\n[c,a] is closer than [c,b,a]\n[d,c,a] is closer than [d,b,a]\n[e,d,c,a] is closer than [e,f,c,b,a]\n[f,c,a] is closer than [f,c,b,a]\n[e,f,c,a] is closer than [e,d,c,a]\nShortest path is [a,c,f,e] with distance 0+9+2+9 = 20\ntrue.\n", "explain": "An implementation of Dijkstra's algorithm in Prolog\nDijkstra's algorithm starts with a set of all unvisited nodes, assigning an initial distance value for each as infinite.  It then attempts to minimise the distance for each node from the origin.\nStarting at the origin (distance 0), the algorithm checks each neighbor's distance value and if larger than the current path distance, replaces the neighboring node's distance value. It then marks the current node as visited, and repeats the process for each of the neighbors. When the current node becomes the destination, the distance to the origin is known.\nThis implementation is a slight variation on Dijkstra, which lends itself to Prolog's strengths while retaining approximate algorithmic equivalence.\nProlog is not good at modifying memory in place, but is quite good at handling facts, pattern matching, recursion and backtracking to find all possible solutions.\nA dynamic database predicate, namely:\nstores the currently known shortest distance and best path to a destination from the origin. Since the path is a reversed list, the first item in the list is the destination node, and the predicate is\nefficiently matched.\nInstead of using unvisited flags on nodes, we test whether neighbors are already in the traversed path. This achieves the same thing as 'visited' flags, but in a way that is more efficient for Prolog.\nAfter the graph traversal is complete, we are left with a single rpath/2 predicate for each reachable node, containing the shortest path and distance from the origin.\nSubtle differences\n1) Dijkstra visits each node only once, starting with the origin.  This algorithm:\nIt is possible therefore, contrary to Dijkstra, that we may visit a node more than once whilst discovering a shorter path. It is also possible that the first path we choose is already the shortest eliminating processing.\n2) As traversal spreads outwards, the path is built as a list of traversed nodes.  \nWe could possibly improve our algorithm by processing the neighbor with the shortest distance first, rather than an arbitrary selection as is currently the case.  There is nothing though, to suggest that the eventual shortest path found would necessarily follow the shortest initial path, unless the target node is already the closest neighbor.\n\nfor example:\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Lua", "code": "\n\n-- Graph definition\nlocal edges = {\n    a = {b = 7, c = 9, f = 14},\n    b = {c = 10, d = 15},\n    c = {d = 11, f = 2},\n    d = {e = 6},\n    e = {f = 9}\n}\n\n-- Fill in paths in the opposite direction to the stated edges\nfunction complete (graph)\n    for node, edges in pairs(graph) do\n        for edge, distance in pairs(edges) do\n            if not graph[edge] then graph[edge] = {} end\n            graph[edge][node] = distance\n        end\n    end\nend\n\n-- Create path string from table of previous nodes\nfunction follow (trail, destination)\n    local path, nextStep = destination, trail[destination]\n    while nextStep do\n        path = nextStep .. \" \" .. path \n        nextStep = trail[nextStep]\n    end\n    return path\nend\n\n-- Find the shortest path between the current and destination nodes\nfunction dijkstra (graph, current, destination, directed)\n    if not directed then complete(graph) end\n    local unvisited, distanceTo, trail = {}, {}, {}\n    local nearest, nextNode, tentative\n    for node, edgeDists in pairs(graph) do\n        if node == current then\n            distanceTo[node] = 0\n            trail[current] = false\n        else\n            distanceTo[node] = math.huge\n            unvisited[node] = true\n        end\n    end\n    repeat\n        nearest = math.huge\n        for neighbour, pathDist in pairs(graph[current]) do\n            if unvisited[neighbour] then\n                tentative = distanceTo[current] + pathDist\n                if tentative < distanceTo[neighbour] then\n                    distanceTo[neighbour] = tentative\n                    trail[neighbour] = current\n                end\n                if tentative < nearest then\n                    nearest = tentative\n                    nextNode = neighbour\n                end\n            end\n        end\n        unvisited[current] = false\n        current = nextNode\n    until unvisited[destination] == false or nearest == math.huge\n    return distanceTo[destination], follow(trail, destination)\nend\n\n-- Main procedure\nprint(\"Directed:\", dijkstra(edges, \"a\", \"e\", true))\nprint(\"Undirected:\", dijkstra(edges, \"a\", \"e\", false))\n\n\nOutput:\nDirected:       26      a c d e\nUndirected:     20      a c f e\n", "explain": "Hopefully the variable names here make the process as clear as possible...\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Scala", "code": "\n\nobject Dijkstra {\n  \n  type Path[Key] = (Double, List[Key])\n  \n  def Dijkstra[Key](lookup: Map[Key, List[(Double, Key)]], fringe: List[Path[Key]], dest: Key, visited: Set[Key]): Path[Key] = fringe match {\n    case (dist, path) :: fringe_rest => path match {case key :: path_rest =>\n      if (key == dest) (dist, path.reverse)\n      else {\n        val paths = lookup(key).flatMap {case (d, key) => if (!visited.contains(key)) List((dist + d, key :: path)) else Nil}\n        val sorted_fringe = (paths ++ fringe_rest).sortWith {case ((d1, _), (d2, _)) => d1 < d2}\n        Dijkstra(lookup, sorted_fringe, dest, visited + key)\n      }\n    }\n    case Nil => (0, List())\n  }\n\n  def main(x: Array[String]): Unit = {\n    val lookup = Map(\n      \"a\" -> List((7.0, \"b\"), (9.0, \"c\"), (14.0, \"f\")),\n      \"b\" -> List((10.0, \"c\"), (15.0, \"d\")),\n      \"c\" -> List((11.0, \"d\"), (2.0, \"f\")),\n      \"d\" -> List((6.0, \"e\")),\n      \"e\" -> List((9.0, \"f\")),\n      \"f\" -> Nil\n    )\n    val res = Dijkstra[String](lookup, List((0, List(\"a\"))), \"e\", Set())\n    println(res)\n  }\n}\n\n\nOutput:\n(26.0,List(a, c, d, e))\n\nimport scala.collection.mutable\n\nclass Dijkstra[Key] {\n\n  type PathInfo = (Double, List[Key])\n  type Path = List[Key]\n  type MinHeap[PathInfo] = mutable.PriorityQueue[PathInfo]\n\n  final def dijkstra(weightedGraph: Map[Key, List[(Double, Key)]],\n                      start: Key,\n                      dest: Key)(implicit ord: Ordering[PathInfo]): PathInfo =\n    dijkstraHelper(weightedGraph, mutable.PriorityQueue((0.0, List(start))), dest)\n\n  @annotation.tailrec\n  private final def dijkstraHelper(weightedGraph: Map[Key, List[(Double, Key)]],\n                                     fringe: MinHeap[PathInfo],\n                                     dest: Key,\n                                     visited: Set[Key] = Set.empty[Key])(implicit ord: Ordering[PathInfo]): PathInfo = {\n\n    def updateFringe(frng: MinHeap[PathInfo], currentDist: Double, currentPath: Path): MinHeap[PathInfo] =\n      (currentPath : @unchecked) match {\n        case keys @ key :: _ =>\n          weightedGraph(key)\n            .withFilter { case (_, k) => !visited.contains(k) }\n            .map { case (d, k) => (currentDist + d, k :: keys) }  // updated PathInfo's\n            .foreach { p => frng.enqueue(p) }\n\n          frng\n      }\n\n    if (fringe.isEmpty)\n      (0, Nil)\n    else {\n      (fringe.dequeue() : @unchecked) match {\n        case (dist, path @ `dest` :: _) =>\n          (dist, path.reverse)\n\n        case (dist, path @ key :: _) =>\n          dijkstraHelper(weightedGraph, updateFringe(fringe, dist, path), dest, visited + key)\n      }\n    }\n  }\n\n  def main(x: Array[String]): Unit = {\n    val weightedGraph = Map(\n      \"a\" -> List((7.0, \"b\"), (9.0, \"c\"), (14.0, \"f\")),\n      \"b\" -> List((10.0, \"c\"), (15.0, \"d\")),\n      \"c\" -> List((11.0, \"d\"), (2.0, \"f\")),\n      \"d\" -> List((6.0, \"e\")),\n      \"e\" -> List((9.0, \"f\")),\n      \"f\" -> Nil\n    )\n  \n    val res = dijkstra[String](weightedGraph, \"a\", \"e\")\n    println(res)\n  }\n}\n\n\nOutput:\n(26.0,List(a, c, d, e))\n", "explain": "A functional implementation of Dijkstras Algorithm:\n\nAn implementation based on the functional version above that uses PriorityQueue. It is made functional-look:\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "D", "code": "\nTranslation of: C++\n\nimport std.stdio, std.typecons, std.algorithm, std.container;\n\nalias Vertex = string;\nalias Weight = int;\n\nstruct Neighbor {\n    Vertex target;\n    Weight weight;\n}\n\nalias AdjacencyMap = Neighbor[][Vertex];\n\npure dijkstraComputePaths(Vertex source, Vertex target, AdjacencyMap adjacencyMap){\n    Weight[Vertex] minDistance;\n    Vertex[Vertex] previous;\n\n    foreach(v, neighs; adjacencyMap){\n        minDistance[v] = Weight.max;\n        foreach(n; neighs) minDistance[n.target] = Weight.max;\n    }\n\n    minDistance[source] = 0;\n    auto vertexQueue = redBlackTree(tuple(minDistance[source], source));\n\n    foreach(_, u; vertexQueue){\n        if (u == target)\n            break;\n\n        // Visit each edge exiting u.\n        foreach(n; adjacencyMap.get(u, null)){\n            const v = n.target;\n            const distanceThroughU = minDistance[u] + n.weight;\n            if(distanceThroughU < minDistance[v]){\n                vertexQueue.removeKey(tuple(minDistance[v], v));\n                minDistance[v] = distanceThroughU;\n                previous[v] = u;\n                vertexQueue.insert(tuple(minDistance[v], v));\n            }\n        }\n    }\n\n    return tuple(minDistance, previous);\n}\n\npure dijkstraGetShortestPathTo(Vertex v, Vertex[Vertex] previous){\n    Vertex[] path = [v];\n\n    while (v in previous) {\n        v = previous[v];\n        if (v == path[$ - 1])\n            break;\n        path ~= v;\n    }\n\n    path.reverse();\n    return path;\n}\n\nvoid main() {\n    immutable arcs = [tuple(\"a\", \"b\", 7),\n                      tuple(\"a\", \"c\", 9),\n                      tuple(\"a\", \"f\", 14),\n                      tuple(\"b\", \"c\", 10),\n                      tuple(\"b\", \"d\", 15),\n                      tuple(\"c\", \"d\", 11),\n                      tuple(\"c\", \"f\", 2),\n                      tuple(\"d\", \"e\", 6),\n                      tuple(\"e\", \"f\", 9)];\n\n    AdjacencyMap adj;\n    foreach (immutable arc; arcs) {\n        adj[arc[0]] ~= Neighbor(arc[1], arc[2]);\n        // Add this if you want an undirected graph:\n        //adj[arc[1]] ~= Neighbor(arc[0], arc[2]);\n    }\n\n    const minDist_prev = dijkstraComputePaths(\"a\", \"e\", adj);\n    const minDistance = minDist_prev[0];\n    const previous = minDist_prev[1];\n\n    writeln(`Distance from \"a\" to \"e\": `, minDistance[\"e\"]);\n    writeln(\"Path: \", dijkstraGetShortestPathTo(\"e\", previous));\n}\n\n\nOutput:\nDistance from \"a\" to \"e\": 26\nPath: [\"a\", \"c\", \"d\", \"e\"]\n", "explain": "The algorithm and the important data structures are essentially the same as in the C++ version, so the same comments apply (built-in D associative arrays are unsorted).\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "Haskell", "code": "\nTranslation of: C++\n\n{-# LANGUAGE FlexibleContexts #-}\nimport Data.Array\nimport Data.Array.MArray\nimport Data.Array.ST\nimport Control.Monad.ST\nimport Control.Monad (foldM)\nimport Data.Set as S\n\ndijkstra :: (Ix v, Num w, Ord w, Bounded w) => v -> v -> Array v [(v,w)] -> (Array v w, Array v v)\ndijkstra src invalid_index adj_list = runST $ do\n  min_distance <- newSTArray b maxBound\n  writeArray min_distance src 0\n  previous <- newSTArray b invalid_index\n  let aux vertex_queue =\n        case S.minView vertex_queue of\n          Nothing -> return ()\n          Just ((dist, u), vertex_queue') ->\n            let edges = adj_list ! u\n                f vertex_queue (v, weight) = do\n                  let dist_thru_u = dist + weight\n                  old_dist <- readArray min_distance v\n                  if dist_thru_u >= old_dist then\n                    return vertex_queue\n                  else do\n                    let vertex_queue' = S.delete (old_dist, v) vertex_queue\n                    writeArray min_distance v dist_thru_u\n                    writeArray previous v u\n                    return $ S.insert (dist_thru_u, v) vertex_queue'\n            in\n            foldM f vertex_queue' edges >>= aux  -- note that aux is being called within its own definition (i.e. aux is recursive). The foldM only iterates on the neighbours of v, it does not execute the while loop itself in Dijkstra's\n  aux (S.singleton (0, src))\n  m <- freeze min_distance\n  p <- freeze previous\n  return (m, p)\n  where b = bounds adj_list\n        newSTArray :: Ix i => (i,i) -> e -> ST s (STArray s i e)\n        newSTArray = newArray\n\nshortest_path_to :: (Ix v) => v -> v -> Array v v -> [v]\nshortest_path_to target invalid_index previous =\n  aux target [] where\n    aux vertex acc | vertex == invalid_index = acc\n                   | otherwise = aux (previous ! vertex) (vertex : acc)\n\nadj_list :: Array Char [(Char, Int)]\nadj_list = listArray ('a', 'f') [ [('b',7), ('c',9), ('f',14)],\n                                  [('a',7), ('c',10), ('d',15)],\n                                  [('a',9), ('b',10), ('d',11), ('f',2)],\n                                  [('b',15), ('c',11), ('e',6)],\n                                  [('d',6), ('f',9)],\n                                  [('a',14), ('c',2), ('e',9)] ]\n\nmain :: IO ()\nmain = do\n  let (min_distance, previous) = dijkstra 'a' ' ' adj_list\n  putStrLn $ \"Distance from a to e: \" ++ show (min_distance ! 'e')\n  let path = shortest_path_to 'e' ' ' previous\n  putStrLn $ \"Path: \" ++ show path\n\n", "explain": "Translation of the C++ solution, and all the complexities are the same as in the C++ solution. In particular, we again use a self-balancing binary search tree (Data.Set) to implement the priority queue, which results in an optimal complexity.\n"}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "F#", "code": "\nDijkstra's algorithm[edit]\n//Dijkstra's algorithm: Nigel Galloway, August 5th., 2018\n[<CustomEquality;CustomComparison>]\ntype Dijkstra<'N,'G when 'G:comparison>={toN:'N;cost:Option<'G>;fromN:'N}\n                                        override g.Equals n =match n with| :? Dijkstra<'N,'G> as n->n.cost=g.cost|_->false\n                                        override g.GetHashCode() = hash g.cost\n                                        interface System.IComparable with\n                                          member n.CompareTo g =\n                                            match g with\n                                            | :? Dijkstra<'N,'G> as n when n.cost=None -> (-1)\n                                            | :? Dijkstra<'N,'G>      when n.cost=None -> 1\n                                            | :? Dijkstra<'N,'G> as g                  -> compare n.cost g.cost\n                                            | _-> invalidArg \"n\" \"expecting type Dijkstra<'N,'G>\"\nlet inline Dijkstra N G y =\n  let rec fN l f=\n    if List.isEmpty l then f\n    else let n=List.min l\n         if n.cost=None then f else\n         fN(l|>List.choose(fun n'->if n'.toN=n.toN then None else match n.cost,n'.cost,Map.tryFind (n.toN,n'.toN) G with\n                                                                  |Some g,None,Some wg                ->Some {toN=n'.toN;cost=Some(g+wg);fromN=n.toN}\n                                                                  |Some g,Some g',Some wg when g+wg<g'->Some {toN=n'.toN;cost=Some(g+wg);fromN=n.toN}\n                                                                  |_                                  ->Some n'))((n.fromN,n.toN)::f)\n  let r = fN (N|>List.map(fun n->{toN=n;cost=(Map.tryFind(y,n)G);fromN=y})) []\n  (fun n->let rec fN z l=match List.tryFind(fun (_,g)->g=z) r with\n                         |Some(n',g') when y=n'->Some(n'::g'::l)\n                         |Some(n',g')          ->fN n' (g'::l)\n                         |_                    ->None\n          fN n [])\n\nThe Task[edit]\ntype Node= |A|B|C|D|E|F\nlet G=Map[((A,B),7);((A,C),9);((A,F),14);((B,C),10);((B,D),15);((C,D),11);((C,F),2);((D,E),6);((E,F),9)]\nlet paths=Dijkstra [B;C;D;E;F] G A\nprintfn \"%A\" (paths E)\nprintfn \"%A\" (paths F)\n\n\nOutput:\nSome [A; C; D; E]\nSome [A; C; F]\n\n", "explain": ""}, {"task_name": "Dijkstra's algorithm", "task_url": "https://rosettacode.org/wiki/Dijkstra%27s_algorithm", "task_cat": "Routing algorithms", "lang": "AWK", "code": "\n\nNF == 3 { graph[$1,$2] = $3 }\nNF == 2 {\n    weight = shortest($1, $2)\n    n = length(path)\n    p = $1\n    for (i = 2; i < n; i++)\n        p = p \"-\" path[i]\n    print p \"-\" $2 \" (\" weight \")\"\n}\n\n# Edge weights are in graph[node1,node2]\n# Returns the weight of the shortest path\n# Shortest path is in path[1] ... path[n]\nfunction shortest(from, to,    queue, q, dist, v, i, min, edge, e, prev, n) {\n    delete path\n    dist[from] = 0\n    queue[q=1] = from\n\n    while (q > 0) {\n        min = 1\n        for (i = 2; i <= q; i++)\n            if (dist[queue[i]] < dist[queue[min]])\n                min = i\n        v = queue[min]\n        queue[min] = queue[q--]\n\n        if (v == to)\n            break\n        for (edge in graph) {\n            split(edge, e, SUBSEP)\n            if (e[1] != v)\n                continue\n            if (!(e[2] in dist) || dist[e[1]] + graph[edge] < dist[e[2]]) {\n                dist[e[2]] = dist[e[1]] + graph[edge]\n                prev[e[2]] = e[1]\n                queue[++q] = e[2]\n            }\n        }\n    }\n    if (v != to)\n        return \"n/a\"\n\n    # Build the path\n    n = 1\n    for (v = to; v != from; v = prev[v])\n        n++\n    for (v = to; n > 0; v = prev[v])\n       path[n--] = v \n    return dist[to]\n}\n\n\n$ cat dijkstra.txt\na b 7\na c 9\na f 14\nb c 10\nb d 15\nc d 11\nc f 2\nd e 6\ne f 9\na e\na f\nf a\n\n$ awk -f dijkstra.awk dijkstra.txt\na-c-d-e (26)\na-c-f (11)\nf-a (n/a)\n\n", "explain": "A very basic implementation in AWK. Minimum element in the queue is found by a linear search.\nExample:\n"}]