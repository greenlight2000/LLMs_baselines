[{"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Python", "code": "\nWorks with: Python version 2.5\nfrom xml.dom.minidom import getDOMImplementation\n\ndom = getDOMImplementation()\ndocument = dom.createDocument(None, \"root\", None)\n\ntopElement = document.documentElement\nfirstElement = document.createElement(\"element\")\ntopElement.appendChild(firstElement)\ntextNode = document.createTextNode(\"Some text here\")\nfirstElement.appendChild(textNode)\n\nxmlString = document.toprettyxml(\" \" * 4)\n\nfrom xml.etree import ElementTree as et\n\nroot = et.Element(\"root\")\net.SubElement(root, \"element\").text = \"Some text here\"\nxmlString = et.tostring(root)\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "C", "code": "\nLibrary: LibXML[edit]\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n  \nint main()\n{\n  xmlDoc *doc = xmlNewDoc(\"1.0\");\n  xmlNode *root = xmlNewNode(NULL, BAD_CAST \"root\");\n  xmlDocSetRootElement(doc, root);\n\n  xmlNode *node = xmlNewNode(NULL, BAD_CAST \"element\");\n  xmlAddChild(node, xmlNewText(BAD_CAST \"some text here\"));\n  xmlAddChild(root, node);\n\n  xmlSaveFile(\"myfile.xml\", doc);\n \n  xmlFreeDoc(doc);\n  xmlCleanupParser();\n}\n\nLibrary: Gadget[edit]\n\n#include <gadget/gadget.h>\n\nLIB_GADGET_START\n\nMain\n   String XML, body;\n   Stack{\n       Store ( XML, Parser( \"element\", \"\",\"Some text here\", NORMAL_TAG) );\n       Store ( XML, Parser( \"root\", \"\",XML, NORMAL_TAG) );\n   } Stack_off;\n   \n   body = Multi_copy( body,\"<?xml version=\\\"1.0\\\"\u00a0?>\", XML, NULL);\n   Print \"%s\\n\", body;\n   \n   Free secure XML, body;\nEnd\n\n\n#include <gadget/gadget.h>\n\nLIB_GADGET_START\n\nMain\n   String XML, body;\n   \n   Get_fn_let( XML, Parser( \"element\", \"\",\"Some text here\", NORMAL_TAG) );\n   Get_fn_let( XML, Parser( \"root\", \"\",XML, NORMAL_TAG) );\n   \n   body = Multi_copy( body,\"<?xml version=\\\"1.0\\\"\u00a0?>\", XML, NULL);\n   Print \"%s\\n\", body;\n   \n   Free secure XML, body;\nEnd\n\n\n#include <gadget/gadget.h>\n\nLIB_GADGET_START\n\nMain\n   String XML, body;\n   Stack{\n       Store ( XML, Parser( \"root\", \"\", \n                    Parser( \"element\", \"\",\"Some text here\", NORMAL_TAG), \n                    NORMAL_TAG) );\n   } Stack_off;\n   \n   body = Multi_copy( body,\"<?xml version=\\\"1.0\\\"\u00a0?>\", XML, NULL);\n   Print \"%s\\n\", body;\n   \n   Free secure XML, body;\nEnd\n\n\n#include <gadget/gadget.h>\n\nLIB_GADGET_START\n\nMain\n   String body;\n   Stack{\n       Store ( body, Multi_copy( body,\"<?xml version=\\\"1.0\\\"\u00a0?>\", \n                                 Parser( \"root\", \"\", Parser( \"element\", \"\",\"Some text here\", \n                                 NORMAL_TAG), NORMAL_TAG), \n                                 NULL) );\n   }\n\n   Print \"%s\\n\", body;\n   \n   Free secure body;\nEnd\n\n\nOutput:\n$ ./tests/RC_dom \n<?xml version=\"1.0\"\u00a0?><root><element>Some text here</element></root>\n\n", "explain": "Version 1 (48 allocs):Version 2 (46 allocs):Version 3 (47 allocs):Version 4 (50 allocs):"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "C++", "code": "\nLibrary: LibXML\n#include <cassert>\n#include <cstdlib>\n#include <iostream>\n#include <stdexcept>\n#include <utility>\n#include <vector>\n\n#include <libxml/parser.h>\n#include <libxml/tree.h>\n#include <libxml/xmlerror.h>\n#include <libxml/xmlsave.h>\n#include <libxml/xmlstring.h>\n#include <libxml/xmlversion.h>\n\n#ifndef LIBXML_TREE_ENABLED\n#   error libxml was not configured with DOM tree support\n#endif\n\n#ifndef LIBXML_OUTPUT_ENABLED\n#   error libxml was not configured with serialization support\n#endif\n\n// Because libxml2 is a C library, we need a couple things to make it work\n// well with modern C++:\n//   1) a ScopeGuard-like type to handle cleanup functions; and\n//   2) an exception type that transforms the library's errors.\n\n// ScopeGuard-like type to handle C library cleanup functions.\ntemplate <typename F>\nclass [[nodiscard]] scope_exit\n{\npublic:\n    // C++20: Constructor can (and should) be [[nodiscard]].\n    /*[[nodiscard]]*/ constexpr explicit scope_exit(F&& f) :\n        f_{std::move(f)}\n    {}\n\n    ~scope_exit()\n    {\n        f_();\n    }\n\n    // Non-copyable, non-movable.\n    scope_exit(scope_exit const&) = delete;\n    scope_exit(scope_exit&&) = delete;\n    auto operator=(scope_exit const&) -> scope_exit& = delete;\n    auto operator=(scope_exit&&) -> scope_exit& = delete;\n\nprivate:\n    F f_;\n};\n\n// Exception that gets last libxml2 error.\nclass libxml_error : public std::runtime_error\n{\npublic:\n    libxml_error() : libxml_error(std::string{}) {}\n\n    explicit libxml_error(std::string message) :\n        std::runtime_error{make_message_(std::move(message))}\n    {}\n\nprivate:\n    static auto make_message_(std::string message) -> std::string\n    {\n        if (auto const last_error = ::xmlGetLastError(); last_error)\n        {\n            if (not message.empty())\n                message += \": \";\n            message += last_error->message;\n        }\n\n        return message;\n    }\n};\n\nauto add_text(::xmlNode* node, ::xmlChar const* content)\n{\n    // Create a new text node with the desired content.\n    auto const text_node = ::xmlNewText(content);\n    if (not text_node)\n        throw libxml_error{\"failed to create text node\"};\n\n    // Try to add it to the node. If it succeeds, that node will take\n    // ownership of the text node. If it fails, we have to clean up the text\n    // node ourselves first, then we can throw.\n    if (auto const res = ::xmlAddChild(node, text_node); not res)\n    {\n        ::xmlFreeNode(text_node);\n        throw libxml_error{\"failed to add text node\"};\n    }\n    \n    return text_node;\n}\n\nauto main() -> int\n{\n    // Set this to true if you don't want the XML declaration.\n    constexpr auto no_xml_declaration = false;\n\n    try\n    {\n        // Initialize libxml.\n        ::xmlInitParser();\n        LIBXML_TEST_VERSION\n        auto const libxml_cleanup = scope_exit{[] { ::xmlCleanupParser(); }};\n\n        // Create a new document.\n        auto doc = ::xmlNewDoc(reinterpret_cast<::xmlChar const*>(u8\"1.0\"));\n        if (not doc)\n            throw libxml_error{\"failed to create document\"};\n        auto const doc_cleanup = scope_exit{[doc] { ::xmlFreeDoc(doc); }};\n\n        // Create the root element.\n        auto root = ::xmlNewNode(nullptr,\n            reinterpret_cast<::xmlChar const*>(u8\"root\"));\n        if (not root)\n            throw libxml_error{\"failed to create root element\"};\n        ::xmlDocSetRootElement(doc, root); // doc now owns root\n\n        // Add whitespace. Unless you know the whitespace is not significant,\n        // you should do this manually, rather than relying on automatic\n        // indenting.\n        add_text(root, reinterpret_cast<::xmlChar const*>(u8\"\\n    \"));\n\n        // Add the child element.\n        if (auto const res = ::xmlNewTextChild(root, nullptr,\n                reinterpret_cast<::xmlChar const*>(u8\"element\"),\n                reinterpret_cast<::xmlChar const*>(\n                    u8\"\\n        Some text here\\n    \"));\n                not res)\n            throw libxml_error{\"failed to create child text element\"};\n\n        // Add whitespace.\n        add_text(root, reinterpret_cast<::xmlChar const*>(u8\"\\n\"));\n\n        // Output tree. Note that the output is UTF-8 in all cases. If you\n        // want something different, use xmlSaveFileEnc() or the second\n        // argument of xmlSaveDoc().\n        if constexpr (no_xml_declaration)\n        {\n            auto const save_context = ::xmlSaveToFilename(\"-\", nullptr,\n                XML_SAVE_NO_DECL);\n            auto const save_context_cleanup = scope_exit{[save_context] {\n                ::xmlSaveClose(save_context); }};\n\n            if (auto const res = ::xmlSaveDoc(save_context, doc); res == -1)\n                throw libxml_error{\"failed to write tree to stdout\"};\n        }\n        else\n        {\n            if (auto const res = ::xmlSaveFile(\"-\", doc); res == -1)\n                throw libxml_error{\"failed to write tree to stdout\"};\n        }\n    }\n    catch (std::exception const& x)\n    {\n        std::cerr << \"ERROR: \" << x.what() << '\\n';\n        return EXIT_FAILURE;\n    }\n}\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Java", "code": "\n\nimport java.io.StringWriter;\n\nimport javax.xml.parsers.DocumentBuilder;\nimport javax.xml.parsers.DocumentBuilderFactory;\nimport javax.xml.parsers.ParserConfigurationException;\nimport javax.xml.transform.OutputKeys;\nimport javax.xml.transform.Transformer;\nimport javax.xml.transform.TransformerConfigurationException;\nimport javax.xml.transform.TransformerException;\nimport javax.xml.transform.TransformerFactory;\nimport javax.xml.transform.TransformerFactoryConfigurationError;\nimport javax.xml.transform.dom.DOMSource;\nimport javax.xml.transform.stream.StreamResult;\n\nimport org.w3c.dom.DOMImplementation;\nimport org.w3c.dom.Document;\nimport org.w3c.dom.Element;\n\npublic class RDOMSerialization {\n\n  private Document domDoc;\n\n  public RDOMSerialization() {\n    return;\n  }\n\n  protected void buildDOMDocument() {\n\n    DocumentBuilderFactory factory;\n    DocumentBuilder builder;\n    DOMImplementation impl;\n    Element elmt1;\n    Element elmt2;\n\n    try {\n      factory = DocumentBuilderFactory.newInstance();\n      builder = factory.newDocumentBuilder();\n      impl = builder.getDOMImplementation();\n      domDoc = impl.createDocument(null, null, null);\n      elmt1 = domDoc.createElement(\"root\");\n      elmt2 = domDoc.createElement(\"element\");\n      elmt2.setTextContent(\"Some text here\");\n\n      domDoc.appendChild(elmt1);\n      elmt1.appendChild(elmt2);\n    }\n    catch (ParserConfigurationException ex) {\n      ex.printStackTrace();\n    }\n\n    return;\n  }\n\n  protected void serializeXML() {\n\n    DOMSource domSrc;\n    Transformer txformer;\n    StringWriter sw;\n    StreamResult sr;\n\n    try {\n      domSrc = new DOMSource(domDoc);\n\n      txformer = TransformerFactory.newInstance().newTransformer();\n      txformer.setOutputProperty(OutputKeys.OMIT_XML_DECLARATION, \"no\");\n      txformer.setOutputProperty(OutputKeys.METHOD, \"xml\");\n      txformer.setOutputProperty(OutputKeys.ENCODING, \"UTF-8\");\n      txformer.setOutputProperty(OutputKeys.INDENT, \"yes\");\n      txformer.setOutputProperty(OutputKeys.STANDALONE, \"yes\");\n      txformer.setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"2\");\n\n      sw = new StringWriter();\n      sr = new StreamResult(sw);\n\n      txformer.transform(domSrc, sr);\n\n      System.out.println(sw.toString());\n    }\n    catch (TransformerConfigurationException ex) {\n      ex.printStackTrace();\n    }\n    catch (TransformerFactoryConfigurationError ex) {\n      ex.printStackTrace();\n    }\n    catch (TransformerException ex) {\n      ex.printStackTrace();\n    }\n\n    return;\n  }\n\n  public static void serializationDriver(String[] args) {\n\n    RDOMSerialization lcl = new RDOMSerialization();\n    lcl.buildDOMDocument();\n    lcl.serializeXML();\n\n    return;\n  }\n\n  public static void main(String[] args) {\n    serializationDriver(args);\n    return;\n  }\n}\n\n\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"yes\"?>\n<root>\n  <element>Some text here</element>\n</root>\n\n", "explain": "Java's XML DOM tools don't really allow total control of the output format \"out of the box\" but the following program generates XML that is equivalent to the required output.\nOutput:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "C#", "code": "\n\nusing System.Xml;\nusing System.Xml.Serialization;\n[XmlRoot(\"root\")]\npublic class ExampleXML\n{\n    [XmlElement(\"element\")]\n    public string element = \"Some text here\";\n    static void Main(string[] args)\n    {\n        var xmlnamespace = new XmlSerializerNamespaces();\n        xmlnamespace.Add(\"\", \"\"); //used to stop default namespaces from printing\n        var writer = XmlWriter.Create(\"output.xml\");\n        new XmlSerializer(typeof(ExampleXML)).Serialize(writer, new ExampleXML(), xmlnamespace);\n    }\n    //Output: <?xml version=\"1.0\" encoding=\"utf-8\"?><root><element>Some text here</element></root>\n}\n\n", "explain": "Serialization using the built-in System.Xml.Serialization library of .Net.\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "JavaScript", "code": "\nWorks with: Firefox version 2.0\n\nvar doc = document.implementation.createDocument( null, 'root', null );\nvar root = doc.documentElement;\nvar element = doc.createElement( 'element' );\nroot.appendChild( element );\nelement.appendChild( document.createTextNode('Some text here') );\nvar xmlString = new XMLSerializer().serializeToString( doc );\n\n\nvar xml = <root>\n  <element>Some text here</element>\n</root>;\nvar xmlString = xml.toXMLString();\n\n\nXML.ignoreProcessingInstructions = false;\nvar xml = <?xml version=\"1.0\"?>  \n<root>\n  <element>Some text here</element>\n</root>;\nvar xmlString = xml.toXMLString();\n\n", "explain": "DOM\nE4X\nE4X \u2014 with processing instruction\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "PHP", "code": "\nWorks with: PHP version 5\n<?php\n$dom = new DOMDocument();//the constructor also takes the version and char-encoding as it's two respective parameters\n$dom->formatOutput = true;//format the outputted xml\n$root = $dom->createElement('root');\n$element = $dom->createElement('element');\n$element->appendChild($dom->createTextNode('Some text here'));\n$root->appendChild($element);\n$dom->appendChild($root);\n$xmlstring = $dom->saveXML();\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "MATLAB", "code": "\ndocNode = com.mathworks.xml.XMLUtils.createDocument('root');\ndocRootNode = docNode.getDocumentElement;\nthisElement = docNode.createElement('element'); \nthisElement.appendChild(docNode.createTextNode('Some text here'));\ndocRootNode.appendChild(thisElement);\n\n\n xmlwrite(docNode)\n\nans =\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n   <element>Some text here</element>\n</root>\n\n", "explain": "Output:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Go", "code": "\nLibrary: gitlab.com/stone.code/xmldom-go.git\n\npackage main\n\nimport (\n    \"fmt\"\n    dom \"gitlab.com/stone.code/xmldom-go.git\"\n)\n\nfunc main() {\n    d, err := dom.ParseStringXml(`\n<?xml version=\"1.0\"\u00a0?>\n<root>\n    <element>\n        Some text here\n    </element>\n</root>`)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    fmt.Println(string(d.ToXml()))\n}\n\n\nOutput:\n<root>\n    <element>\n        Some text here\n    </element>\n</root>\n\n", "explain": "A very small, subset of the W3C DOM Core in Go. The work builds off the existing XML parser. A fork of the godom project (http://code.google.com/p/godom/), which appears to be unsupported at the moment.\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program createXml.s   */\n/* install package   libxml++2.6-dev    */\n/* link with gcc option -lxml2    */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessEndpgm:      .asciz \"Normal end of program.\\n\" \nszFileName:        .asciz \"file1.xml\" \nszFileMode:        .asciz \"w\"\nszMessError:       .asciz \"Error detected\u00a0!!!!. \\n\"\n\nszVersDoc:         .asciz \"1.0\"\nszLibRoot:         .asciz \"root\"\nszLibElement:      .asciz \"element\"\nszText:            .asciz \"some text here\"\nszCarriageReturn:  .asciz \"\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n.align 4\n\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                     @ entry of program \n    ldr r0,iAdrszVersDoc\n    bl xmlNewDoc                          @ create doc\n    mov r9,r0                             @ doc address\n    mov r0,#0\n    ldr r1,iAdrszLibRoot\n    bl xmlNewNode                         @ create root node\n    mov r8,r0                             @ node root address\n    mov r0,r9\n    mov r1,r8\n    bl xmlDocSetRootElement\n@TODO voir la gestion des erreurs\n\n    mov r0,#0\n    ldr r1,iAdrszLibElement\n    bl xmlNewNode                         @ create element node\n    mov r7,r0                             @ node element address\n    ldr r0,iAdrszText\n    bl xmlNewText                         @ create text\n    mov r6,r0                             @ text address\n    mov r0,r7                             @ node element address\n    mov r1,r6                             @ text address\n    bl xmlAddChild                        @ add text to element node\n    mov r0,r8                             @ node root address\n    mov r1,r7                             @ node element address\n    bl xmlAddChild                        @ add node elemeny to root node\n    ldr r0,iAdrszFileName\n    ldr r1,iAdrszFileMode\n    bl fopen                              @ file open\n    cmp r0,#0\n    blt 99f\n    mov r5,r0                             @ File descriptor\n    mov r1,r9                             @ doc\n    mov r2,r8                             @ root\n    bl xmlElemDump                        @ write xml file\n    cmp r0,#0\n    blt 99f\n    mov r0,r5\n    bl fclose                             @ file close\n    mov r0,r9\n    bl xmlFreeDoc\n    bl xmlCleanupParser\n    ldr r0,iAdrszMessEndpgm\n    bl affichageMess\n    b 100f\n99:\n    @ error\n    ldr r0,iAdrszMessError\n    bl affichageMess       \n100:                                       @ standard end of the program \n    mov r0, #0                             @ return code\n    mov r7, #EXIT                          @ request to exit program\n    svc #0                                 @ perform the system call\n\niAdrszMessError:          .int szMessError\niAdrszMessEndpgm:         .int szMessEndpgm\niAdrszVersDoc:            .int szVersDoc\niAdrszLibRoot:            .int szLibRoot\niAdrszLibElement:         .int szLibElement\niAdrszText:               .int szText\niAdrszFileName:           .int szFileName\niAdrszFileMode:           .int szFileMode\niAdrszCarriageReturn:     .int szCarriageReturn\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                   @ save  registres\n    mov r2,#0                               @ counter length \n1:                                          @ loop length calculation \n    ldrb r1,[r0,r2]                         @ read octet start position + index \n    cmp r1,#0                               @ if 0 its over \n    addne r2,r2,#1                          @ else add 1 in the length \n    bne 1b                                  @ and loop \n                                            @ so here r2 contains the length of the message \n    mov r1,r0                               @ address message in r1 \n    mov r0,#STDOUT                          @ code to write to the standard output Linux \n    mov r7, #WRITE                          @ code call system \"write\" \n    svc #0                                  @ call systeme \n    pop {r0,r1,r2,r7,lr}                    @ restaur registers */ \n    bx lr                                   @ return  \n/******************************************************************/\n/*     Converting a register to a decimal                                 */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                         @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n1:                                          @ start loop\n    bl divisionpar10                        @ r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                              @ digit\n    strb r1,[r3,r2]                         @ store digit on area\n    cmp r0,#0                               @ stop if quotient = 0 \n    subne r2,#1                               @ previous position    \n    bne 1b                                  @ else loop\n                                            @ end replaces digit in front of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2] \n    strb r1,[r3,r4]                         @ store in area begin\n    add r4,#1\n    add r2,#1                               @ previous position\n    cmp r2,#LGZONECAL                       @ end\n    ble 2b                                  @ loop\n    mov r1,#' '\n3:\n    strb r1,[r3,r4]\n    add r4,#1\n    cmp r4,#LGZONECAL                       @ end\n    ble 3b\n100:\n    pop {r1-r4,lr}                          @ restaur registres \n    bx lr                                   @return\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\n/* r1 remainder  */\ndivisionpar10:\n  /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}                           @ save registers  */\n    mov r4,r0  \n    mov r3,#0x6667                         @ r3 <- magic_number  lower\n    movt r3,#0x6666                        @ r3 <- magic_number  upper\n    smull r1, r2, r3, r0                   @ r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) \n    mov r2, r2, ASR #2                     @ r2 <- r2 >> 2\n    mov r1, r0, LSR #31                    @ r1 <- r0 >> 31\n    add r0, r2, r1                         @ r0 <- r2 + r1 \n    add r2,r0,r0, lsl #2                   @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                   @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2-r4}\n    bx lr                                  @ return\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Ruby", "code": "\nLibrary: REXML\nrequire(\"rexml/document\")\ninclude REXML\n(doc = Document.new) << XMLDecl.new\nroot = doc.add_element('root')\nelement = root.add_element('element')\nelement.add_text('Some text here')\n\n# save to a string \n# (the first argument to write() needs an object that understands \"<<\")\nserialized = String.new\ndoc.write(serialized, 4)\nputs serialized\n\n\n<?xml version='1.0'?>\n<root>\n    <element>\n        Some text here\n    </element>\n</root>\n", "explain": "produces\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Ada", "code": "\nWorks with: GNAT\n\nwith Ada.Text_IO.Text_Streams;\nwith DOM.Core.Documents;\nwith DOM.Core.Nodes;\n\nprocedure Serialization is\n   My_Implementation : DOM.Core.DOM_Implementation;\n   My_Document       : DOM.Core.Document;\n   My_Root_Node      : DOM.Core.Element;\n   My_Element_Node   : DOM.Core.Element;\n   My_Text_Node      : DOM.Core.Text;\nbegin\n   My_Document := DOM.Core.Create_Document (My_Implementation);\n   My_Root_Node := DOM.Core.Documents.Create_Element (My_Document, \"root\");\n   My_Root_Node := DOM.Core.Nodes.Append_Child (My_Document, My_Root_Node);\n   My_Element_Node := DOM.Core.Documents.Create_Element (My_Document, \"element\");\n   My_Element_Node := DOM.Core.Nodes.Append_Child (My_Root_Node, My_Element_Node);\n   My_Text_Node := DOM.Core.Documents.Create_Text_Node (My_Document, \"Some text here\");\n   My_Text_Node := DOM.Core.Nodes.Append_Child (My_Element_Node, My_Text_Node);\n   DOM.Core.Nodes.Write\n     (Stream => Ada.Text_IO.Text_Streams.Stream\n        (Ada.Text_IO.Standard_Output),\n      N => My_Document,\n      Pretty_Print => True);\nend Serialization;\n\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n <element>Some text here</element>\n</root>\n", "explain": "Uses XML/Ada from AdaCore.\nIt can be shortened a lot by adding \"use\" clauses and writing the creation functions into the declaration part.\nOutput:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Julia", "code": "\nusing LightXML\n\n# Modified from the documentation for LightXML.jl. The underlying library requires an encoding string be printed.\n\n# create an empty XML document\nxdoc = XMLDocument()\n\n# create & attach a root node\nxroot = create_root(xdoc, \"root\")\n\n# create the first child\nxs1 = new_child(xroot, \"element\")\n\n# add the inner content\nadd_text(xs1, \"some text here\")\n\nprintln(xdoc)\n\nOutput:\n\n<?xml version=\"1.0\" encoding=\"utf-8\"?>\n<root>\n  <element>some text here</element>\n</root>\n\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Kotlin", "code": "\n\n// version 1.1.3\n\nimport javax.xml.parsers.DocumentBuilderFactory\nimport javax.xml.transform.dom.DOMSource\nimport java.io.StringWriter\nimport javax.xml.transform.stream.StreamResult\nimport javax.xml.transform.TransformerFactory\n\nfun main(args: Array<String>) {\n    val dbFactory = DocumentBuilderFactory.newInstance()\n    val dBuilder  = dbFactory.newDocumentBuilder()\n    val doc = dBuilder.newDocument()\n    val root = doc.createElement(\"root\")  // create root node\n    doc.appendChild(root)\n    val element = doc.createElement(\"element\")  // create element node\n    val text = doc.createTextNode(\"Some text here\")  // create text node\n    element.appendChild(text)\n    root.appendChild(element)\n\n    // serialize\n    val source = DOMSource(doc)\n    val sw = StringWriter()\n    val result = StreamResult(sw)\n    val tFactory = TransformerFactory.newInstance()\n    tFactory.newTransformer().apply {\n        setOutputProperty(\"indent\", \"yes\")\n        setOutputProperty(\"{http://xml.apache.org/xslt}indent-amount\", \"4\") \n        transform(source, result)\n    }\n    println(sw)            \n}\n\n\nOutput:\n<?xml version=\"1.0\" encoding=\"UTF-8\" standalone=\"no\"?>\n<root>\n    <element>Some text here</element>\n</root>\n\n", "explain": "This is the closest I could get to the required output.\nThere appears to be no satisfactory way to prevent the default encoding and standalone attributes from appearing in the XML declaration using the standard JDK DOM implementation. If you set the standalone attribute to true - using doc.setXmlStandalone(true) - then this removes it from the declaration but unfortunately there is then no carriage return before the <root> tag! \nSo I've decided to leave it as it is.  \n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Perl", "code": "\nLibrary: XML::SimpleSimple\nuse XML::Simple;\nprint XMLout( { root => { element => \"Some text here\" } }, NoAttr => 1, RootName => \"\" );\n\n\n<root>\n  <element>Some text here</element>\n</root>\n\nLibrary: XML::DOM::BagOfTricksDOM::BagOfTricks\nuse XML::DOM::BagOfTricks qw(createDocument createTextElement);\n\nmy ($doc, $root) = createDocument('root');\n$root->appendChild(\n    createTextElement($doc, 'element', 'Some text here')\n);\nprint $doc->toString;\n\n\n<root><element>Some text here</element></root>\n\nLibrary: LibXML\nuse XML::LibXML;\n\n$xml = XML::LibXML::Document->new('1.0');\n$node = $xml->createElement('root');\n$xml->setDocumentElement($node);\n$node2 = $xml->createElement('element');\n$text = $xml->createTextNode('Some text here');\n$node2->addChild($text);\n$node->appendWellBalancedChunk('text');\n$node->addChild($node2);\n\nprint $xml->toString;\n\n\n<?xml version=\"1.0\"?>\n<root>text<element>Some text here</element></root>\n\n", "explain": "Output:\nOutput:\nOutput:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Lua", "code": "\n\nrequire(\"LuaXML\")\nlocal dom = xml.new(\"root\")\nlocal element = xml.new(\"element\")\ntable.insert(element, \"Some text here\")\ndom:append(element)\ndom:save(\"dom.xml\")\n\n\n<?xml version=\"1.0\"?>\n<!-- file \"dom.xml\", generated by LuaXML -->\n\n<root>\n  <element>Some text here</element>\n</root>\n", "explain": "Using the widely available 'LuaXML' module\nResulting contents of dom.xml:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Scala", "code": "\nval xml = <root><element>Some text here</element></root>\nscala.xml.XML.save(filename=\"output.xml\", node=xml, enc=\"UTF-8\", xmlDecl=true, doctype=null)\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "D", "code": "\nWorks with: D version 2.011+\nmodule xmltest ;\n\nimport std.stdio ;\nimport std.xml ;\n\nvoid main() {\n  auto doc = new Document(\"root\") ;\n//doc.prolog = q\"/<?xml version=\"1.0\"?>/\"\u00a0; // default\n  doc ~= new Element(\"element\", \"Some text here\") ;\n  writefln(doc) ;\n// output: <?xml version=\"1.0\"?><root><element>Some text here</element></root>\n}\n\n", "explain": ""}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Haskell", "code": "\n\nimport Data.List\nimport Text.XML.Light\n\nxmlDOM :: String -> String\nxmlDOM txt = showTopElement $ Element\n    (unqual \"root\")\n    []\n    [ Elem $ Element\n      (unqual \"element\")\n      []\n      [Text $ CData CDataText txt Nothing]\n      Nothing\n    ]\n    Nothing\n\n\n*Main> mapM_ (putStrLn.ppContent) $ parseXML (xmlDOM \"  Some text  \")\n<?xml version=\"1.0\"\u00a0?>\n<root>\n  <element>  Some text  </element>\n</root>\n", "explain": "Using the XML.Light module from HackageDB\nOutput:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "ABAP", "code": "\nDATA: xml_string TYPE string.\n\nDATA(xml)  = cl_ixml=>create( ).\nDATA(doc)  = xml->create_document( ).\nDATA(root) = doc->create_simple_element( name   = 'root'\n                                         parent = doc ).\n\ndoc->create_simple_element( name   = 'element'\n                            parent = root\n                            value  = 'Some text here' ).\n\nDATA(stream_factory) = xml->create_stream_factory( ).\nDATA(stream)         = stream_factory->create_ostream_cstring( string = xml_string ).\nDATA(renderer)       = xml->create_renderer( document = doc\n                                             ostream  = stream ).\nstream->set_pretty_print( abap_true ).\nrenderer->render( ).\n\ncl_demo_output=>display_text( xml_string ).\n\n\n<?xml version=\"1.0\" encoding=\"utf-16\"?>\n<root>\n<element>Some text here</element>\n</root>\n", "explain": "Output:\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "F#", "code": "\nopen System.Xml\n\n[<EntryPoint>]\nlet main argv =\n    let xd = new XmlDocument()\n    // Create the required nodes:\n    xd.AppendChild (xd.CreateXmlDeclaration(\"1.0\", null, null)) |> ignore\n    let root = xd.AppendChild (xd.CreateNode(\"element\", \"root\", \"\"))\n    let element = root.AppendChild (xd.CreateElement(\"element\", \"element\", \"\"))\n    element.AppendChild (xd.CreateTextNode(\"Some text here\")) |> ignore\n    // The same can be accomplished with:\n    // xd.LoadXml(\"\"\"<?xml version=\"1.0\"?><root><element>Some text here</element></root>\"\"\")\n\n    let xw = new XmlTextWriter(System.Console.Out)\n    xw.Formatting <- Formatting.Indented\n    xd.WriteContentTo(xw)\n    0\n\n\n<?xml version=\"1.0\"?>\n<root>\n  <element>Some text here</element>\n</root>\n", "explain": "Output\n"}, {"task_name": "XML/DOM serialization", "task_url": "https://rosettacode.org/wiki/XML/DOM_serialization", "task_cat": "XML", "lang": "Groovy", "code": "\nimport groovy.xml.MarkupBuilder\ndef writer = new StringWriter() << '<?xml version=\"1.0\"\u00a0?>\\n'\ndef xml = new MarkupBuilder(writer)\nxml.root() {\n    element('Some text here' ) \n}\nprintln writer\n\n", "explain": ""}]