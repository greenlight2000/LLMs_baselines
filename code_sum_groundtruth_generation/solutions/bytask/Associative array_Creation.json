[{"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Python", "code": "\n\nhash = dict()  # 'dict' is the dictionary type.\nhash = dict(red=\"FF0000\", green=\"00FF00\", blue=\"0000FF\")\nhash = { 'key1':1, 'key2':2, }\nvalue = hash[key]\n\n# empty dictionary\nd = {}\nd['spam'] = 1\nd['eggs'] = 2  \n\n# dictionaries with two keys\nd1 = {'spam': 1, 'eggs': 2}\nd2 = dict(spam=1, eggs=2)\n\n# dictionaries from tuple list\nd1 = dict([('spam', 1), ('eggs', 2)])\nd2 = dict(zip(['spam', 'eggs'], [1, 2]))\n\n# iterating over keys\nfor key in d:\n  print key, d[key]\n\n# iterating over (key, value) pairs\nfor key, value in d.iteritems():\n  print key, value\n\nmyDict = { '1': 'a string', 1: 'an integer', 1.0: 'a floating point number', (1,): 'a tuple' }\n\n", "explain": "Hashes are a built-in type called dictionaries (or mappings) in Python.  \nNumerous methods exist for the mapping type https://docs.python.org/3/library/stdtypes.html#mapping-types-dict\nNote: Python dictionary keys can be of any arbitrary \"hashable\" type.  The following contains several distinct key value pairs:\n(Some other languages such as awk and Perl evaluate all keys such that numerically or lexically equivalent expressions become identical entries in the hash or associative array).\nUser defined classes which implement the __hash__() special method can also be used as dictionary keys.  It's the responsibility of the programmer to ensure the properties of the resultant hash value.  The instance object's unique ID\n(accessible via the id() built-in function) is commonly used for this purpose.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "C", "code": "\n\n", "explain": "Solution is at Associative arrays/Creation/C.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "C++", "code": "\n\n#include <map>\n\nCreation[edit]\n\nstd::map<A, B> exampleMap\n\n\nstd::map<int, double> exampleMap\n\nInsertion[edit]\n\nOperator[][edit]\n\nexampleMap[7] = 3.14\n\n\nint myKey = 7;\ndouble myValue = 3.14;\nexampleMap[myKey] = myValue;\n\ninsert()[edit]\n\nexampleMap.insert(std::pair<int, double>(7,3.14));\n\n\nexampleMap.insert(std::make_pair(7,3.14));\n\nLookup[edit]\n\noperator[][edit]\n\nmyValue = exampleMap[myKey]\n\n\nfind()[edit]\n\ndouble myValue = 0.0;\nstd::map<int, double>::iterator myIterator = exampleMap.find(myKey);\nif(exampleMap.end() != myIterator)\n{\n  // Return the value for that key.\n  myValue = myIterator->second;\n}\n\n\nExample[edit]\n\n#include <map>\n#include <iostreams>\n\nint main()\n{\n  // Create the map.\n  std::map<int, double> exampleMap;\n\n  // Choose our key\n  int myKey = 7;\n\n  // Choose our value\n  double myValue = 3.14;\n\n  // Assign a value to the map with the specified key.\n  exampleMap[myKey] = myValue;\n\n  // Retrieve the value\n  double myRetrievedValue = exampleMap[myKey];\n\n  // Display our retrieved value.\n  std::cout << myRetrievedValue << std::endl;\n\n  // main() must return 0 on success.\n  return 0;\n}\n\n", "explain": "The C++ standard defines std::map as a means of creating an association between a key of one arbitrary type and a value of another arbitrary type.  This requires the inclusion of the standard header map.\nTo create a simple map whose key is of type A and whose value is of type B, one would define the variable like so:\nIf one wanted to us a key type of int and a value of double, you would define it like so:\nOnce we've created our map, we've got a couple different ways to insert the value.  Let's use an example key of 7, and an exable value of 3.14.\nThe first method is using the [] operator.\nOf course, you can use a variable (or any rvalue of the correct type) for the key or value parameters:\nThe second approach is a little more complicated.  We have to use the pair<> template:\nor by using make_pair to avoid repeating key/value types:\nAs with insertion, there are a couple ways we can retrieve the value.\nWe use it as an rvalue, supplying the correct key:\nIf the value doesn't already exist, a default-constructed object of the value's type will be inserted using the key you specified, and that default value will be returned.\nAlternatively, you can look up a value by using find(), storing its return value in an iterator, and comparing the iterator against the map's end() sentinal value:\nThe need for the ->second code is because our iterator points to a pair<>(), and our value is the second member of that pair.\nThis code assigns a 0 to myValue if the map contained a value.\nThis simple program creates a map, assigns a value to that map, retrieves a value from that map, and prints the value to STDOUT.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Java", "code": "\n\n\n\n\nMap<String, Integer> map = new HashMap<>();\n\n\nmap.put(\"rosetta\", 100);\nmap.put(\"code\", 200);\n\n\nint valueA = map.get(\"rosetta\");\nint valueB = map.get(\"code\");\n\n\nmap.replace(\"rosetta\", 300);\n\n\nboolean replaced = map.replace(\"rosetta\", 100, 300);\n\n\nboolean contains = map.containsKey(\"rosetta\");\n\n\nboolean contains = map.containsValue(100);\n\n\nMap<String, Integer> map = new LinkedHashMap<>();\nmap.put(\"rosetta\", 100);\nmap.put(\"code\", 200);\n\n\nMap<String, Integer> map = new TreeMap<>();\nmap.put(\"rosetta\", 100);\nmap.put(\"code\", 200);\n\n\nComparator<String> comparator = new Comparator<String>() {\n    public int compare(String stringA, String stringB) {\n        if (stringA.compareTo(stringB) > 0) {\n            return -1;\n        } else if (stringA.compareTo(stringB) < 0) {\n            return 1;\n        }\n        return 0;\n    }\n};\n\n\nMap<String, Integer> map = new TreeMap<>(comparator);\n\n\nComparator<String> comparator = (stringA, stringB) -> {\n    if (stringA.compareTo(stringB) > 0) {\n        return -1;\n    } else if (stringA.compareTo(stringB) < 0) {\n        return 1;\n    }\n    return 0;\n};\n\n", "explain": "\n    Java offers an associative array, referred to as a Map, as part of the Collections Framework.\n    There are numerous implementing classes, each which provide unique functionality for various tasks.\n\n    It's worth noting that Java also offers the Dictionary class, which appears to be less preferred, according to Java.\n\"[The Map] interface takes the place of the Dictionary class ...\".\n\n    The most generalized Map would be the HashMap, which is a basic, unordered, set of keys and values.\n    There is also the LinkedHashMap, which will preserve the order of input.\n    There is the TreeMap, which is used to store the keys in a specific order, using the key's compareTo method.\n    Optionally, you could provide your own comparator using the Comparator interface, which I'll demonstrate below.\n    There are numerous other implementing classes, which can be found under the Map Javadoc,\n    Map (Java SE 20 & JDK 20).\n\n    Here is a basic implementation of a HashMap.\n\n    To add a key and value pair, you use the Map.put method.\n    A useful feature of Map.put is that if the key already exists, thus is being overridden,\n    it will return the overridden value, otherwise null.\n\n    To get a value, you use the Map.get method, specifying the key as the parameter.\n    If the specified key does not exist, null is returned.\n\n    To mutate a key's value, you use the Map.replace method.\n\n    Alternately, you can replace the value, only if it is of a current value.\n    So, in this example it will return true, only if the key \"rosetta\" had the current value of 100.\n\n    To check for the existence of a key, you use the containsKey method.\n\n    And to check for the existence of a value, you use the containsValue method.\n\n    A LinkedHashMap is exactly the same as a HashMap, except it will preserve the order in which the keys were added.\n\n    A TreeMap is useful for when you want the keys in a specific order.\n    By default, it will use the key's compareTo method, to determine the order.\n    So, if you're key is a String, the order will be ascending, similar to an actual dictionary.\n\n    You could, optionally, specify a comparator by implementing a Comparator interface.\n    A TreeMap, conveniently, only requires you to implement the compare method of the Comparator,\n    so the implementation can be done as an anonymous class.\n\n    Which you then supply as an argument to the constructor.\n\n    To make things even simpler, you could use a lambda for the anonymous class.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "C#", "code": "\n\nSystem.Collections.HashTable map = new System.Collections.HashTable();\nmap[\"key1\"] = \"foo\";\n\n\nDictionary<string, string> map = new Dictionary<string,string>();\nmap[ \"key1\" ] = \"foo\";\n\nWorks with: C# version 3.0+\nvar map = new Dictionary<string, string> {{\"key1\", \"foo\"}};\n\n", "explain": "Platform: .NET 1.x\nPlatform: .NET 2.0\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "JavaScript", "code": "\n\nvar assoc = {};\n\nassoc['foo'] = 'bar';\nassoc['another-key'] = 3;\n\n// dot notation can be used if the property name is a valid identifier\nassoc.thirdKey = 'we can also do this!';\nassoc[2] = \"the index here is the string '2'\";\n\n//using JavaScript's object literal notation\nvar assoc = {\n  foo: 'bar',\n  'another-key': 3 //the key can either be enclosed by quotes or not\n};\n\n//iterating keys\nfor (var key in assoc) {\n  // hasOwnProperty() method ensures the property isn't inherited\n  if (assoc.hasOwnProperty(key)) {\n    alert('key:\"' + key + '\", value:\"' + assoc[key] + '\"');\n  }\n}\n\n\nvar map = new Map(),\n    fn = function () {},\n    obj = {};\n\nmap.set(fn, 123);\nmap.set(obj, 'abc');\nmap.set('key', 'val');\nmap.set(3, x => x + x);\n\nmap.get(fn); //=> 123\nmap.get(function () {}); //=> undefined because not the same function\nmap.get(obj); //=> 'abc'\nmap.get({}); //=> undefined because not the same object\nmap.get('key'); //=> 'val'\nmap.get(3); //=> (x => x + x)\n\nmap.size; //=> 4\n\n//iterating using ES6 for..of syntax\nfor (var key of map.keys()) {\n  console.log(key + ' => ' + map.get(key));\n}\n\n", "explain": "ECMAScript5.1 does not have associative arrays, however Objects (which are just an unordered bundle of name/value pairs) can be used like associative arrays. JavaScript Arrays may also be used, but Objects are the convention.\nJavascript object property names (keys) are strings. Other types and expressions can be used with square bracket notation, they are evaluated and converted to strings and the result used as the property name. Using quotes on property names avoids potential collisions with reserved JavaScript key words.\nECMAScript 6 (ES6) offers both a map and a weak map implementation. While Objects must use strings, Maps may use objects, functions, and numbers as keys in addition to strings.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "SQL", "code": "\nREM Create a table to associate keys with values\nCREATE TABLE  associative_array ( KEY_COLUMN VARCHAR2(10), VALUE_COLUMN VARCHAR2(100)); .\nREM Insert a Key Value Pair\nINSERT (KEY_COLUMN, VALUE_COLUMN) VALUES ( 'VALUE','KEY');.\nREM Retrieve a key value pair\nSELECT aa.value_column FROM associative_array aa where aa.key_column = 'KEY';\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "PHP", "code": "\n$array = array();\n$array = []; // Simpler form of array initialization\n$array['foo'] = 'bar';\n$array['bar'] = 'foo';\n\necho($array['foo']); // bar\necho($array['moo']); // Undefined index\n\n// Alternative (inline) way\n$array2 = array('fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green');\n\n// Another alternative (simpler) way\n$array2 = ['fruit' => 'apple',\n                'price' => 12.96,\n                'colour' => 'green'];\n\n// Check if key exists in the associative array\necho(isset($array['foo'])); // Faster, but returns false if the value of the element is set to null\necho(array_key_exists('foo', $array)); // Slower, but returns true if the value of the element is null\nIterate over key/value[edit]\nforeach($array as $key => $value)\n{\n   echo \"Key: $key Value: $value\";\n}\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Go", "code": "\n\n// declare a nil map variable, for maps from string to int\nvar x map[string]int\n\n// make an empty map\nx = make(map[string]int)\n\n// make an empty map with an initial capacity\nx = make(map[string]int, 42)\n\n// set a value\nx[\"foo\"] = 3\n\n// getting values\ny1 := x[\"bar\"]     // zero value returned if no map entry exists for the key\ny2, ok := x[\"bar\"] // ok is a boolean, true if key exists in the map\n\n// removing keys\ndelete(x, \"foo\")\n\n// make a map with a literal\nx = map[string]int{\n\t\"foo\": 2, \"bar\": 42, \"baz\": -1,\n}\n\n", "explain": "Allowable key types are those with == and\u00a0!= operators.  This includes is boolean, numeric, string, pointer, channel, and interface types.  It also includes structs and arrays containing only these types.  Disallowed as map keys are all slice, function, and map types.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  or android 32 bits */\n/*  program hashmap.s   */ \n\n/*      */\n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ MAXI, 10                   @ size hashmap\n.equ HEAPSIZE,20000\n.equ LIMIT, 10                  @ key characters number for compute index\n.equ COEFF, 80                  @ filling rate 80 = 80%\n\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* structure hashMap   */\n    .struct  0\nhash_count:                       //  stored values counter\n    .struct  hash_count + 4\nhash_key:                         //  key\n    .struct  hash_key + (4 * MAXI)\nhash_data:                        // data\n    .struct  hash_data + (4 * MAXI)\nhash_fin:\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessFin:          .asciz \"End program.\\n\"\nszCarriageReturn:   .asciz \"\\n\"\nszMessNoP:          .asciz \"Key not found\u00a0!!!\\n\"\nszKey1:             .asciz \"one\"\nszData1:            .asciz \"Ceret\"\nszKey2:             .asciz \"two\"\nszData2:            .asciz \"Maureillas\"\nszKey3:             .asciz \"three\"\nszData3:            .asciz \"Le Perthus\"\nszKey4:             .asciz \"four\"\nszData4:            .asciz \"Le Boulou\"\n\n.align 4\niptZoneHeap:    .int sZoneHeap            // start heap address\niptZoneHeapEnd: .int sZoneHeap + HEAPSIZE // end heap address\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\n//sZoneConv:        .skip 24\ntbHashMap1:       .skip hash_fin         @ hashmap\nsZoneHeap:        .skip HEAPSIZE         @ heap\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                          @ entry of program \n    \n    ldr r0,iAdrtbHashMap1\n    bl hashInit                @ init hashmap\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey1          @ store key one\n    ldr r2,iAdrszData1\n    bl hashInsert\n    cmp r0,#0                  @ error\u00a0?\n    bne 100f\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey2          @ store key two\n    ldr r2,iAdrszData2\n    bl hashInsert\n    cmp r0,#0\n    bne 100f\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey3          @ store key three\n    ldr r2,iAdrszData3\n    bl hashInsert\n    cmp r0,#0\n    bne 100f\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey4          @ store key four\n    ldr r2,iAdrszData4\n    bl hashInsert\n    cmp r0,#0\n    bne 100f\n    \n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey2          @ remove key two\n    bl hashRemoveKey\n    cmp r0,#0\n    bne 100f\n    \n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey1         @ search key\n    bl searchKey\n    cmp r0,#-1\n    beq 1f\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 2f\n1:\n    ldr r0,iAdrszMessNoP\n    bl affichageMess\n2:\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey2\n    bl searchKey\n    cmp r0,#-1\n    beq 3f\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 4f\n3:\n    ldr r0,iAdrszMessNoP\n    bl affichageMess\n4:\n    ldr r0,iAdrtbHashMap1\n    ldr r1,iAdrszKey4\n    bl searchKey\n    cmp r0,#-1\n    beq 5f\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    b 6f\n5:\n    ldr r0,iAdrszMessNoP\n    bl affichageMess\n6:\n    ldr r0,iAdrszMessFin\n    bl affichageMess\n \n100:                                  @ standard end of the program \n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessFin:            .int szMessFin\niAdrtbHashMap1:           .int tbHashMap1\niAdrszKey1:               .int szKey1\niAdrszData1:              .int szData1\niAdrszKey2:               .int szKey2\niAdrszData2:              .int szData2\niAdrszKey3:               .int szKey3\niAdrszData3:              .int szData3\niAdrszKey4:               .int szKey4\niAdrszData4:              .int szData4\niAdrszMessNoP:            .int szMessNoP\n/***************************************************/\n/*     init hashMap               */\n/***************************************************/\n// r0 contains address to hashMap\nhashInit:\n    push {r1-r3,lr}             @ save  registers \n    mov r1,#0\n    mov r2,#0\n    str r2,[r0,#hash_count]      @ init counter\n    add r0,r0,#hash_key         @ start zone key/value\n1:\n    lsl r3,r1,#3\n    add r3,r3,r0\n    str r2,[r3,#hash_key]\n    str r2,[r3,#hash_data]\n    add r1,r1,#1\n    cmp r1,#MAXI\n    blt 1b\n100:\n    pop {r1-r3,pc}             @ restaur registers\n/***************************************************/\n/*     insert key/datas               */\n/***************************************************/\n// r0 contains address to hashMap\n// r1 contains address to key\n// r2 contains address to datas\nhashInsert:\n    push {r1-r8,lr}             @ save  registers \n    mov r6,r0                   @ save address \n    bl hashIndex                @ search void key or identical key\n    cmp r0,#0                   @ error\u00a0?\n    blt 100f\n    \n    ldr r3,iAdriptZoneHeap\n    ldr r3,[r3]\n    ldr r8,iAdriptZoneHeapEnd\n    ldr r8,[r8]\n    sub r8,r8,#50\n    lsl r0,r0,#2               @ 4 bytes\n    add r7,r6,#hash_key        @ start zone key/value\n    ldr r4,[r7,r0]\n    cmp r4,#0                  @ key already stored\u00a0?\n    bne 1f\n    ldr r4,[r6,#hash_count]    @ no -> increment counter\n    add r4,r4,#1\n    cmp r4,#(MAXI * COEFF / 100)\n    bge 98f\n    str r4,[r6,#hash_count]\n1:\n    str r3,[r7,r0]\n    mov r4,#0\n2:                            @ copy key loop in heap\n    ldrb r5,[r1,r4]\n    strb r5,[r3,r4]\n    cmp r5,#0\n    add r4,r4,#1\n    bne 2b\n    add r3,r3,r4\n    cmp r3,r8\n    bge 99f\n    add r7,r6,#hash_data\n    str r3,[r7,r0]\n    mov r4,#0\n3:                            @ copy data loop in heap\n    ldrb r5,[r2,r4]\n    strb r5,[r3,r4]\n    cmp r5,#0\n    add r4,r4,#1\n    bne 3b\n    add r3,r3,r4\n    cmp r3,r8\n    bge 99f\n    ldr r0,iAdriptZoneHeap\n    str r3,[r0]               @ new heap address\n    \n    mov r0,#0                 @ insertion OK\n    b 100f\n98:                           @ error hashmap\n    adr r0,szMessErrInd\n    bl affichageMess\n    mov r0,#-1\n    b 100f\n99:                           @ error heap\n    adr r0,szMessErrHeap\n    bl affichageMess\n    mov r0,#-1\n100:\n    pop {r1-r8,lr}             @ restaur registers\n    bx lr                      @ return\nszMessErrInd:          .asciz \"Error\u00a0: HashMap size Filling rate Maxi\u00a0!!\\n\"\nszMessErrHeap:         .asciz \"Error\u00a0: Heap size  Maxi\u00a0!!\\n\"\n.align 4\niAdriptZoneHeap:       .int iptZoneHeap\niAdriptZoneHeapEnd:    .int iptZoneHeapEnd\n/***************************************************/\n/*     search void index in hashmap              */\n/***************************************************/\n// r0 contains hashMap address \n// r1 contains key address\nhashIndex:\n    push {r1-r4,lr}       @ save  registers \n    add r4,r0,#hash_key\n    mov r2,#0             @ index\n    mov r3,#0             @ characters sum \n1:                        @ loop to compute characters sum \n    ldrb r0,[r1,r2]\n    cmp r0,#0             @ string end\u00a0?\n    beq 2f\n    add r3,r3,r0          @ add to sum\n    add r2,r2,#1\n    cmp r2,#LIMIT\n    blt 1b\n2:\n    mov r5,r1             @ save key address\n    mov r0,r3\n    mov r1,#MAXI\n    bl division           @ compute remainder -> r3\n    mov r1,r5             @ key address\n    \n3:\n    ldr r0,[r4,r3,lsl #2] @ loak key for computed index \n    cmp r0,#0             @ void key\u00a0?\n    beq 4f \n    bl comparStrings      @ identical key\u00a0?\n    cmp r0,#0\n    beq 4f                @ yes\n    add r3,r3,#1          @ no search next void key\n    cmp r3,#MAXI          @ maxi\u00a0?\n    movge r3,#0           @ restart to index 0\n    b 3b\n4:\n    mov r0,r3             @ return index void array or key equal\n100:\n    pop {r1-r4,pc}        @ restaur registers\n\n/***************************************************/\n/*     search key in hashmap              */\n/***************************************************/\n// r0 contains hash map address\n// r1 contains key address\nsearchKey:\n    push {r1-r2,lr}           @ save  registers \n    mov r2,r0\n    bl hashIndex\n    lsl r0,r0,#2\n    add r1,r0,#hash_key\n    ldr r1,[r2,r1]\n    cmp r1,#0\n    moveq r0,#-1\n    beq 100f\n    add r1,r0,#hash_data\n    ldr r0,[r2,r1]\n100:\n    pop {r1-r2,pc}            @ restaur registers\n/***************************************************/\n/*     remove key in hashmap              */\n/***************************************************/\n// r0 contains hash map address\n// r1 contains key address\nhashRemoveKey:                  @ INFO: hashRemoveKey\n    push {r1-r3,lr}             @ save  registers \n    mov r2,r0\n    bl hashIndex\n    lsl r0,r0,#2\n    add r1,r0,#hash_key\n    ldr r3,[r2,r1]\n    cmp r3,#0\n    beq  2f\n    add r3,r2,r1\n    mov r1,#0                   @ raz key address\n    str r1,[r3]   \n    add r1,r0,#hash_data\n    add r3,r2,r1\n    mov r1,#0\n    str r1,[r3]                 @ raz datas address\n    mov r0,#0\n    b 100f\n2:\n    adr r0,szMessErrRemove\n    bl affichageMess\n    mov r0,#-1\n100:\n    pop {r1-r3,pc}            @ restaur registers\nszMessErrRemove:         .asciz \"\\033[31mError remove key\u00a0!!\\033[0m\\n\"\n.align 4\n/************************************/   \n/* Strings case sensitive comparisons  */\n/************************************/\t  \n/* r0 et r1 contains the address of strings */\n/* return 0 in r0 if equals */\n/* return -1 if string r0 < string r1 */\n/* return 1  if string r0 > string r1 */\ncomparStrings:\n    push {r1-r4}         @ save des registres\n    mov r2,#0            @ characters counter\n1:\n    ldrb r3,[r0,r2]      @ byte string 1\n    ldrb r4,[r1,r2]      @ byte string 2\n    cmp r3,r4\n    movlt r0,#-1         @ smaller\n    movgt r0,#1\t         @ greather\n    bne 100f             @ not equals\n    cmp r3,#0            @ 0 end string\u00a0?\n    moveq r0,#0          @ equals\n    beq 100f             @ end string\n    add r2,r2,#1         @ else add 1 in counter\n    b 1b                 @ and loop\n100:\n    pop {r1-r4}\n    bx lr   \n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Delphi", "code": "\nprogram AssociativeArrayCreation;\n\n{$APPTYPE CONSOLE}\n\nuses Generics.Collections;\n\nvar\n  lDictionary: TDictionary<string, Integer>;\nbegin\n  lDictionary := TDictionary<string, Integer>.Create;\n  try\n    lDictionary.Add('foo', 5);\n    lDictionary.Add('bar', 10);\n    lDictionary.Add('baz', 15);\n    lDictionary.AddOrSetValue('foo', 6); // replaces value if it exists\n  finally\n    lDictionary.Free;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Ruby", "code": "\nHash literals[edit]\n\n{:name => 'Zeus', :planet => 'Jupiter'}\n\n{name: 'Zeus', planet: 'Jupiter'}\n\n{1 => 'two', three: 4}\n\n{}\nCustomizing the default value[edit]\n\nhash = {}\nhash[666] = 'devil'\nhash[777]  # => nil\nhash[666]  # => 'devil'\n\nhash = Hash.new('unknown key')\nhash[666] = 'devil'\nhash[777]  # => 'unknown key'\nhash[666]  # => 'devil'\n\nhash = Hash.new { |h, k| \"unknown key #{k}\" }\nhash[666] = 'devil'\nhash[777]  # => 'unknown key 777'\nhash[666]  # => 'devil'\n\nhash = Hash.new { |h, k| h[k] = \"key #{k} was added at #{Time.now}\" }\nhash[777]  # => 'key 777 was added at Sun Apr 03 13:49:57 -0700 2011'\nhash[555]  # => 'key 555 was added at Sun Apr 03 13:50:01 -0700 2011'\nhash[777]  # => 'key 777 was added at Sun Apr 03 13:49:57 -0700 2011'\n", "explain": "Ruby has literal syntax for Hash objects.\nA Hash with symbols as keys:\nShorthand for symbol keys:\nA Hash with keys and values of arbitrary types:\nAn empty Hash:\nA Hash object that returns nil for unknown keys:\nA Hash object that returns 'unknown key' for unknown keys:\nA Hash object that returns \"unknown key #{key}\" for unknown keys:\nA Hash object that adds \"key #{key} was added at #{Time.now}\" to the hash the first time an unknown key is seen:\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Rust", "code": "\nuse std::collections::HashMap;\nfn main() {\n    let mut olympic_medals = HashMap::new();\n    olympic_medals.insert(\"United States\", (1072, 859, 749));\n    olympic_medals.insert(\"Soviet Union\", (473, 376, 355));\n    olympic_medals.insert(\"Great Britain\", (246, 276, 284));\n    olympic_medals.insert(\"Germany\", (252, 260, 270));\n    println!(\"{:?}\", olympic_medals);\n}\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Swift", "code": "\n// make an empty map\nvar a = [String: Int]()\n// or\nvar b: [String: Int] = [:]\n\n// make an empty map with an initial capacity\nvar c = [String: Int](minimumCapacity: 42)\n\n// set a value\nc[\"foo\"] = 3\n\n// make a map with a literal\nvar d = [\"foo\": 2, \"bar\": 42, \"baz\": -1]\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "R", "code": "\n\nenvironment example[edit]\n> env <- new.env()\n> env[[\"x\"]] <- 123\n> env[[\"x\"]]\n[1] 123\n> index <- \"1\"\n> env[[index]] <- \"rainfed hay\"\n> env[[index]]\n[1] \"rainfed hay\"\n> env[[\"1\"]]\n[1] \"rainfed hay\"\n> env\n<environment: 0xb7cd560>\n> print(env)\n<environment: 0xb7cd560>\nvector example[edit]\n> x <- c(hello=1, world=2, \"!\"=3)\n> print(x)\nhello world    \u00a0! \n    1     2     3\n> print(names(x))\n[1] \"hello\" \"world\" \"!\"\nprint(unname(x))\n[1] 1 2 3\nlist example[edit]\n> a <- list(a=1, b=2, c=3.14, d=\"xyz\")\n> print(a)\n$a\n[1] 1\n\n$b\n[1] 2\n\n$c\n[1] 3.14\n\n$d\n[1] \"xyz\"\n> print(names(a))\n[1] \"a\" \"b\" \"c\" \"d\"\n> print(unname(a))\n[[1]]\n[1] 1\n\n[[2]]\n[1] 2\n\n[[3]]\n[1] 3.14\n\n[[4]]\n[1] \"xyz\"\n", "explain": "R lacks a native representation of key-value pairs, but different structures allow named elements, which provide similar functionality.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Visual_FoxPro", "code": "\n\nLOCAL loCol As Collection, k, n, o\nCLEAR \n*!* Example using strings\nloCol = NEWOBJECT(\"Collection\")\nloCol.Add(\"Apples\", \"A\")\nloCol.Add(\"Oranges\", \"O\")\nloCol.Add(\"Pears\", \"P\")\nn = loCol.Count\n? \"Items:\", n\n*!* Loop through the collection\nk = 1\nFOR EACH o IN loCol FOXOBJECT\n   \u00a0? o, loCol.GetKey(k)\n    k = k + 1 \nENDFOR\t\n*!* Get an item by its key\n? loCol(\"O\")\n?\n*!* Example using objects\nLOCAL loFruits As Collection\nloFruits = NEWOBJECT(\"Collection\")\nloFruits.Add(CREATEOBJECT(\"fruit\", \"Apples\"), \"A\")\nloFruits.Add(CREATEOBJECT(\"fruit\", \"Oranges\"), \"O\")\nloFruits.Add(CREATEOBJECT(\"fruit\", \"Pears\"), \"P\")\n*!* Loop through the collection\nk = 1\nFOR EACH o IN loFruits FOXOBJECT\n   \u00a0? o.Name, loFruits.GetKey(k)\n    k = k + 1 \nENDFOR\n*!* Get an item name by its key\n? loFruits(\"P\").Name\n\n\nDEFINE CLASS fruit As Custom\nPROCEDURE Init(tcName As String)\nTHIS.Name = tcName\nENDPROC\nENDDEFINE\n", "explain": "Visual FoxPro has a collection class which can be used for this.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Ada", "code": "\nWorks with: GNAT version GPL 2007\nwith Ada.Containers.Ordered_Maps;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;\n\nprocedure Associative_Array is\n   \n   -- Instantiate the generic package Ada.Containers.Ordered_Maps\n\n   package Associative_Int is new Ada.Containers.Ordered_Maps(Unbounded_String, Integer);\n   use Associative_Int;\n  \n   Color_Map : Map;\n   Color_Cursor : Cursor;\n   Success : Boolean;\n   Value : Integer;\nbegin\n\n   -- Add values to the ordered map\n\n   Color_Map.Insert(To_Unbounded_String(\"Red\"), 10, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Blue\"), 20, Color_Cursor, Success);\n   Color_Map.Insert(To_Unbounded_String(\"Yellow\"), 5, Color_Cursor, Success);\n\n   -- retrieve values from the ordered map and print the value and key\n   -- to the screen\n\n   Value := Color_Map.Element(To_Unbounded_String(\"Red\"));\n   Ada.Text_Io.Put_Line(\"Red:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Blue\"));\n   Ada.Text_IO.Put_Line(\"Blue:\" & Integer'Image(Value));\n   Value := Color_Map.Element(To_Unbounded_String(\"Yellow\"));\n   Ada.Text_IO.Put_Line(\"Yellow:\" & Integer'Image(Value));\nend Associative_Array;\n\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\ndict = Dict('a' => 97, 'b' => 98) # list keys/values\n# Dict{Char,Int64} with 2 entries:\n#   'b' => 98\n#   'a' => 97\n\ndict = Dict(c => Int(c) for c = 'a':'d') # dict comprehension\n# Dict{Char,Int64} with 4 entries:\n#   'b' => 98\n#   'a' => 97\n#   'd' => 100\n#   'c' => 99\n\ndict['\u00e9'] = 233; dict # add an element\n# Dict{Char,Int64} with 3 entries:\n#   'b' => 98\n#   'a' => 97\n#   '\u00e9' => 233\n\nemptydict = Dict() # create an empty dict\n# Dict{Any,Any} with 0 entries\n\ndict[\"a\"] = 1 # type mismatch\n# ERROR: MethodError: Cannot `convert` an object of type String to an object of type Char\n\ntypeof(dict) # type is infered correctly\n# Dict{Char,Int64}\n\n", "explain": "We build dictionaries associating to some characters their code points, by listing the key/value pairs, through a dictionary comprehension, by creating an empty dictionary and filling it, by using the specific syntax associated to typed dictionaries.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Kotlin", "code": "\nTranslation of: Java\nfun main(args: Array<String>) {\n    // map definition:\n    val map = mapOf(\"foo\" to 5,\n                    \"bar\" to 10,\n                    \"baz\" to 15,\n                    \"foo\" to 6)\n\n    // retrieval:\n    println(map[\"foo\"]) // => 6\n    println(map[\"invalid\"]) // => null\n\n    // check keys:\n    println(\"foo\" in map) // => true\n    println(\"invalid\" in map) // => false\n\n    // iterate over keys:\n    for (k in map.keys) print(\"$k \")\n    println()\n\n    // iterate over values:\n    for (v in map.values) print(\"$v \")\n    println()\n\n    // iterate over key, value pairs:\n    for ((k, v) in map) println(\"$k => $v\")\n}\n\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Perl", "code": "\nHash[edit]\n\n# using => key does not need to be quoted unless it contains special chars\nmy %hash = (\n  key1 => 'val1',\n  'key-2' => 2,\n  three => -238.83,\n  4 => 'val3',\n);\n\n# using , both key and value need to be quoted if containing something non-numeric in nature\nmy %hash = (\n  'key1', 'val1',\n  'key-2', 2,\n  'three', -238.83,\n  4, 'val3',\n);\n\nprint $hash{key1};\n\n$hash{key1} = 'val1';\n\n@hash{'key1', 'three'} = ('val1', -238.83);\nHashRef[edit]\n\nmy $hashref = {\n key1 => 'val1',\n  'key-2' => 2,\n  three => -238.83,\n  4 => 'val3',\n}\n\nprint $hashref->{key1};\n\n$hashref->{key1} = 'val1';\n\n@{$hashref}{('key1', 'three')} = ('val1', -238.83);\nKey Types[edit]\n\n", "explain": "Definition:\nUse:\nDefinition:\nUse:\nKeys are strings.  Anything else is stringized in Perl's usual ways, which generally means integers work too, but for floating point care might be needed against round-off.\nVarious tie modules implement keys of other types, usually by constructing underlying string keys of suitable nature.  For example Tie::RefHash allows objects (blessed or unblessed) as keys.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Objective-C", "code": "\nWorks with: Cocoa and Works with: GNUstep\n\nNSDictionary *dict = [NSDictionary dictionaryWithObjectsAndKeys:\n    @\"Joe Doe\", @\"name\",\n    [NSNumber numberWithUnsignedInt:42], @\"age\",\n    [NSNull null], @\"extra\",\n    nil];\n\nNSDictionary *dict = @{\n    @\"name\": @\"Joe Doe\",\n    @\"age\": @42,\n    @\"extra\": [NSNull null],\n    };\n\nNSMutableDictionary *dict = [NSMutableDictionary dictionary];\n[dict setObject:@\"Joe Doe\" forKey:@\"name\"];\n[dict setObject:[NSNumber numberWithInt:42] forKey:@\"age\"];\n\nNSString *name = [dict objectForKey:@\"name\"];\nunsigned age = [dict objectForKey:@\"age\"] unsignedIntValue];\nid missing = [dict objectForKey:@\"missing\"];\n", "explain": "You can use a NSDictionary to create an immutable hash. A dictionary can contain only objects; if you want store non objects like integer, you have to box it in NSNumber.\nThe same as the above with the new literal syntax in clang 3.1+ / Apple LLVM Compiler 4.0+ (XCode 4.4+)\u00a0:\nTo create a mutable dictionary, use NSMutableDictionary:\nYou can access value with objectForKey:. If a key does not exists, nil is returned.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Prolog", "code": "\n\nmymap(key1,value1).\nmymap(key2,value2).\n\n?- mymap(key1,V).\n   V = value1\n", "explain": "We use the facts table for this purpose.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Lua", "code": "\n\nhash = {}\nhash[ \"key-1\" ] = \"val1\"\nhash[ \"key-2\" ] = 1\nhash[ \"key-3\" ] = {}\n\n\n", "explain": "Lua tables are Hashes\nReturns nil on unknown key.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Scala", "code": "\n// immutable maps\nvar map = Map(1 -> 2, 3 -> 4, 5 -> 6)\nmap(3) // 4\nmap = map + (44 -> 99) // maps are immutable, so we have to assign the result of adding elements\nmap.isDefinedAt(33) // false\nmap.isDefinedAt(44) // true\n// mutable maps (HashSets)\nimport scala.collection.mutable.HashMap\nval hash = new HashMap[Int, Int]\nhash(1) = 2\nhash += (1 -> 2)  // same as hash(1) = 2\nhash += (3 -> 4, 5 -> 6, 44 -> 99)\nhash(44) // 99\nhash.contains(33) // false\nhash.isDefinedAt(33) // same as contains\nhash.contains(44) // true\n// iterate over key/value\nhash.foreach {e => println(\"key \"+e._1+\" value \"+e._2)} // e is a 2 element Tuple\n// same with for syntax\nfor((k,v) <- hash) println(\"key \" + k + \" value \" + v)\n// items in map where the key is greater than 3\nmap.filter {k => k._1 > 3} //  Map(5 -> 6, 44 -> 99)\n// same with for syntax\nfor((k, v) <- map; if k > 3) yield (k,v)\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Dart", "code": "\nmain() {\n\tvar rosettaCode = { // Type is inferred to be Map<String, String>\n\t\t'task': 'Associative Array Creation'\n\t};\n\n\trosettaCode['language'] = 'Dart';\n\n\t// The update function can be used to update a key using a callback\n\trosettaCode.update( 'is fun',  // Key to update\n\t\t(value) => \"i don't know\", // New value to use if key is present\n\t\tifAbsent: () => 'yes!' // Value to use if key is absent\n\t);\n\t\n\tassert( rosettaCode.toString() == '{task: Associative Array Creation, language: Dart, is fun: yes!}');\n\t\n\t// If we type the Map with dynamic keys and values, it is like a JavaScript object\n\tMap<dynamic, dynamic> jsObject = {\n\t\t'key': 'value',\n\t\t1: 2,\n\t\t1.5: [ 'more', 'stuff' ],\n\t\t#doStuff: () => print('doing stuff!') // #doStuff is a symbol, only one instance of this exists in the program. Would be :doStuff in Ruby\n\t};\n\n\tprint( jsObject['key'] );\n\tprint( jsObject[1] );\n\t\n\tfor ( var value in jsObject[1.5] )\n\t\tprint('item: $value');\n\n\tjsObject[ #doStuff ](); // Calling the function\n\t\n\tprint('\\nKey types:');\n\tjsObject.keys.forEach( (key) => print( key.runtimeType ) );\n}\n\n\nOutput:\nvalue\n2\nitem: more\nitem: stuff\ndoing stuff!\n\nKey types:\nString\nint\ndouble\nSymbol\n\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "D", "code": "\nvoid main() {\n    auto hash = [\"foo\":42, \"bar\":100];\n    assert(\"foo\" in hash);\n}\n\n", "explain": ""}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Haskell", "code": "\n\nWorks with: GHC\nimport Data.Map\n\ndict = fromList [(\"key1\",\"val1\"), (\"key2\",\"val2\")]\n\nans = Data.Map.lookup \"key2\" dict  -- evaluates to Just \"val2\"\n\n\ndict = [(\"key1\",\"val1\"), (\"key2\",\"val2\")]\n\nans = lookup \"key2\" dict  -- evaluates to Just \"val2\"\n\n\n", "explain": "Binary trees:\nIt is also possible to use association lists (lists of pairs). It is inefficient (O(n) lookup), but simple.\nGHC also had an imperative hash table implementation in the Data.HashTable module, but was removed in GHC 7.8. \nOther standard associatives arrays libraries are\u00a0: Data.IntMap and Data.HasMap\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "PL/SQL", "code": "\n\nDECLARE\n    type ThisIsNotAnAssocArrayType is record (\n        myShape VARCHAR2(20),\n        mySize number,\n        isActive BOOLEAN\n    );\n    assocArray ThisIsNotAnAssocArrayType\u00a0;\nBEGIN\n    assocArray.myShape\u00a0:= 'circle';\n\n    dbms_output.put_line ('assocArray.myShape: ' || assocArray.myShape);\n    dbms_output.put_line ('assocArray.mySize: ' || assocArray.mySize);\nEND;\n/\n", "explain": "PL/SQL allows associative arrays defined on two different keys types: Varchar2 or PLS/Integer\nAssociative Arrays are a PL/SQL only construct. Unlike Oracle Nested Tables or Varrays (the other two types of Oracle collections), associative arrays do not have a corresponding type which can be stored natively in the database. The following code will also show a workaround for this feature.\nThe following example code is a \"record definition\", which has nothing to do with associative arrays:-\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Scheme", "code": "\n\n(define my-dict '((a b) (1 hello) (\"c\" (a b c)))\n(assoc 'a my-dict)                              \u00a0; evaluates to '(a b)\n\n(define my-alist '((a b) (1 hello) (\"c\" (a b c)))\n(define my-hash (alist->hash-table my-alist))\n\n#!r6rs\n\n(import (rnrs base)\n        (rnrs hashtables (6)))\n\n(define my-hash (make-hashtable equal-hash equal?))\n(hashtable-set! my-hash 'a 'b)\n(hashtable-set! my-hash 1 'hello)\n(hashtable-set! my-hash \"c\" '(a b c))\nA persistent associative array from scratch[edit]\nWorks with: CHICKEN version 5.3.0\nLibrary: r7rs\nLibrary: srfi-1\nLibrary: srfi-151\n\n(cond-expand\n  (r7rs)\n  (chicken (import r7rs)))\n\n(define-library (avl-trees)\n\n \u00a0;;\n \u00a0;; This library implements \u2018persistent\u2019 (that is, \u2018immutable\u2019) AVL\n \u00a0;; trees for R7RS Scheme.\n \u00a0;;\n \u00a0;; References:\n \u00a0;;\n \u00a0;;   * Niklaus Wirth, 1976. Algorithms + Data Structures =\n \u00a0;;     Programs. Prentice-Hall, Englewood Cliffs, New Jersey.\n \u00a0;;\n \u00a0;;   * Niklaus Wirth, 2004. Algorithms and Data Structures. Updated\n \u00a0;;     by Fyodor Tkachov, 2014.\n \u00a0;;\n \u00a0;; THIS IS A TRIMMED-DOWN VERSION OF MY SOLUTION TO THE AVL TREES\n \u00a0;; TASK: https://rosettacode.org/wiki/AVL_tree#Scheme\n \u00a0;;\n\n  (export avl)\n  (export avl?)\n  (export avl-empty?)\n  (export avl-insert)\n  (export avl-search-values)\n  (export avl-check-usage)\n\n  (import (scheme base))\n  (import (scheme case-lambda))\n  (import (scheme process-context))\n  (import (scheme write))\n\n  (begin\n\n    (define-syntax avl-check-usage\n      (syntax-rules ()\n        ((_ pred msg)\n         (or pred (usage-error msg)))))\n\n    (define-record-type <avl>\n      (%avl key data bal left right)\n      avl?\n      (key %key)\n      (data %data)\n      (bal %bal)\n      (left %left)\n      (right %right))\n\n    (define (avl)\n      (%avl #f #f #f #f #f))\n\n    (define (avl-empty? tree)\n      (avl-check-usage\n       (avl? tree)\n       \"avl-empty? expects an AVL tree as argument\")\n      (not (%bal tree)))\n\n    (define (avl-search-values pred<? tree key)\n     \u00a0;; Return two values: the data matching the key, or #f is the\n     \u00a0;; key is not found; and a second value that is either #f or #t,\n     \u00a0;; depending on whether the key is found.\n      (define (search p)\n        (if (not p)\n            (values #f #f)\n            (let ((k (%key p)))\n              (cond ((pred<? key k) (search (%left p)))\n                    ((pred<? k key) (search (%right p)))\n                    (else (values (%data p) #t))))))\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-search-values expects a procedure as first argument\")\n      (if (avl-empty? tree)\n          (values #f #f)\n          (search tree)))\n\n    (define (avl-insert pred<? tree key data)\n\n      (define (search p fix-balance?)\n        (cond\n         ((not p)\n         \u00a0;; The key was not found. Make a new node and set\n         \u00a0;; fix-balance?\n          (values (%avl key data 0 #f #f) #t))\n\n         ((pred<? key (%key p))\n         \u00a0;; Continue searching.\n          (let-values (((p1 fix-balance?)\n                        (search (%left p) fix-balance?)))\n            (cond\n             ((not fix-balance?)\n              (let ((p^ (%avl (%key p) (%data p) (%bal p)\n                              p1 (%right p))))\n                (values p^ #f)))\n             (else\n             \u00a0;; A new node has been inserted on the left side.\n              (case (%bal p)\n                ((1)\n                 (let ((p^ (%avl (%key p) (%data p) 0\n                                 p1 (%right p))))\n                   (values p^ #f)))\n                ((0)\n                 (let ((p^ (%avl (%key p) (%data p) -1\n                                 p1 (%right p))))\n                   (values p^ fix-balance?)))\n                ((-1)\n                \u00a0;; Rebalance.\n                 (case (%bal p1)\n                   ((-1)\n                   \u00a0;; A single LL rotation.\n                    (let* ((p^ (%avl (%key p) (%data p) 0\n                                     (%right p1) (%right p)))\n                           (p1^ (%avl (%key p1) (%data p1) 0\n                                      (%left p1) p^)))\n                      (values p1^ #f)))\n                   ((0 1)\n                   \u00a0;; A double LR rotation.\n                    (let* ((p2 (%right p1))\n                           (bal2 (%bal p2))\n                           (p^ (%avl (%key p) (%data p)\n                                     (- (min bal2 0))\n                                     (%right p2) (%right p)))\n                           (p1^ (%avl (%key p1) (%data p1)\n                                      (- (max bal2 0))\n                                      (%left p1) (%left p2)))\n                           (p2^ (%avl (%key p2) (%data p2) 0\n                                      p1^ p^)))\n                      (values p2^ #f)))\n                   (else (internal-error))))\n                (else (internal-error)))))))\n\n         ((pred<? (%key p) key)\n         \u00a0;; Continue searching.\n          (let-values (((p1 fix-balance?)\n                        (search (%right p) fix-balance?)))\n            (cond\n             ((not fix-balance?)\n              (let ((p^ (%avl (%key p) (%data p) (%bal p)\n                              (%left p) p1)))\n                (values p^ #f)))\n             (else\n             \u00a0;; A new node has been inserted on the right side.\n              (case (%bal p)\n                ((-1)\n                 (let ((p^ (%avl (%key p) (%data p) 0\n                                 (%left p) p1)))\n                   (values p^ #f)))\n                ((0)\n                 (let ((p^ (%avl (%key p) (%data p) 1\n                                 (%left p) p1)))\n                   (values p^ fix-balance?)))\n                ((1)\n                \u00a0;; Rebalance.\n                 (case (%bal p1)\n                   ((1)\n                   \u00a0;; A single RR rotation.\n                    (let* ((p^ (%avl (%key p) (%data p) 0\n                                     (%left p) (%left p1)))\n                           (p1^ (%avl (%key p1) (%data p1) 0\n                                      p^ (%right p1))))\n                      (values p1^ #f)))\n                   ((-1 0)\n                   \u00a0;; A double RL rotation.\n                    (let* ((p2 (%left p1))\n                           (bal2 (%bal p2))\n                           (p^ (%avl (%key p) (%data p)\n                                     (- (max bal2 0))\n                                     (%left p) (%left p2)))\n                           (p1^ (%avl (%key p1) (%data p1)\n                                      (- (min bal2 0))\n                                      (%right p2) (%right p1)))\n                           (p2^ (%avl (%key p2) (%data p2) 0\n                                      p^ p1^)))\n                      (values p2^ #f)))\n                   (else (internal-error))))\n                (else (internal-error)))))))\n\n         (else\n         \u00a0;; The key was found; p is an existing node.\n          (values (%avl key data (%bal p) (%left p) (%right p))\n                  #f))))\n\n      (avl-check-usage\n       (procedure? pred<?)\n       \"avl-insert expects a procedure as first argument\")\n      (if (avl-empty? tree)\n          (%avl key data 0 #f #f)\n          (let-values (((p fix-balance?) (search tree #f)))\n            p)))\n\n    (define (internal-error)\n      (display \"internal error\\n\" (current-error-port))\n      (emergency-exit 123))\n\n    (define (usage-error msg)\n      (display \"Procedure usage error:\\n\" (current-error-port))\n      (display \"  \" (current-error-port))\n      (display msg (current-error-port))\n      (newline (current-error-port))\n      (exit 1))\n\n    ))\u00a0;; end library (avl-trees)\n\n\n(define-library (associative-arrays)\n\n \u00a0;;\n \u00a0;; Persistent associative arrays for R7RS Scheme.\n \u00a0;;\n \u00a0;; The story:\n \u00a0;; \n \u00a0;; An implementation of associative arrays, where keys are compared\n \u00a0;; with an \u2018equal to\u2019 predicate, typically has three parts:\n \u00a0;;\n \u00a0;;    * a hash function, which converts a key to a hash value; and\n \u00a0;;      the hash value either has a \u2018less than\u2019 predicate or can be\n \u00a0;;      put in a radix tree;\n \u00a0;;\n \u00a0;;    * a table keyed by the hash values;\n \u00a0;;\n \u00a0;;    * a way to resolve hash value collisions.\n \u00a0;;\n \u00a0;; At one extreme is the association list, which can be viewed as\n \u00a0;; having a hash function that *always* collides. At a nearly\n \u00a0;; opposite extreme are ideal hash trees, which never have\n \u00a0;; collisions, but which, towards that end, require hash values to\n \u00a0;; \u2018grow\u2019 on the fly.\n \u00a0;;\n \u00a0;; Perhaps the simplest form of associative array having all three\n \u00a0;; parts is \u2018separate chaining\u2019: the hash function generates an\n \u00a0;; integer modulo some table size; the table itself is an array of\n \u00a0;; that size; and collisions are resolved by falling back to an\n \u00a0;; association list.\n \u00a0;;\n \u00a0;; Below I use my solution to the AVL Tree task\n \u00a0;; (https://rosettacode.org/wiki/AVL_tree#Scheme) to implement\n \u00a0;; *persistent* (that is, \u2018immutable\u2019) associative arrays. The hash\n \u00a0;; function is whatever you want, as long as it produces (what\n \u00a0;; Scheme regards as) a real number. Hash value collisions are\n \u00a0;; resolved by falling back to association lists.\n \u00a0;;\n\n  (export assoc-array)\n  (export assoc-array?)\n  (export assoc-array-set)\n  (export assoc-array-ref)\n\n  (import (scheme base))\n  (import (scheme case-lambda))\n  (import (scheme write))\n  (import (avl-trees))\n\n  (cond-expand\n    (chicken (import (only (srfi 1) alist-delete)))\n   \u00a0;; Insert whatever you need here for your Scheme.\n    (else))\n\n  (begin\n\n    (define-record-type <assoc-array>\n      (%assoc-array hashfunc pred=? default table)\n      assoc-array?\n      (hashfunc %hashfunc)\n      (pred=? %pred=?)\n      (default %default)\n      (table %table))\n\n    (define assoc-array\n     \u00a0;; Create an associative array.\n      (case-lambda\n        ((hashfunc)\n         (let ((pred=? equal?)\n               (default #f))\n           (assoc-array hashfunc pred=? default)))\n        ((hashfunc pred=?)\n         (let ((default #f))\n           (assoc-array hashfunc pred=? default)))\n        ((hashfunc pred=? default)\n         (%assoc-array hashfunc pred=? default (avl)))))\n\n    (define (assoc-array-set array key data)\n     \u00a0;; Produce a new associative array that is the same as the input\n     \u00a0;; array except for the given key-data association. The input\n     \u00a0;; array is left unchanged (which is why the procedure is called\n     \u00a0;; \u2018assoc-array-set\u2019 rather than \u2018assoc-array-set!\u2019).\n      (let ((hashfunc (%hashfunc array))\n            (pred=? (%pred=? array))\n            (default (%default array))\n            (table (%table array)))\n        (let ((hash-value (hashfunc key)))\n         \u00a0;; The following could be made more efficient by combining\n         \u00a0;; the \u2018search\u2019 and \u2018insert\u2019 operations for the AVL tree.\n          (let*-values\n              (((alst found?) (avl-search-values < table hash-value)))\n            (cond\n             (found?\n             \u00a0;; Add a new entry to the association list. Removal of\n             \u00a0;; any old associations with the key is not strictly\n             \u00a0;; necessary, but without it the associative array will\n             \u00a0;; grow every time you replace an\n             \u00a0;; association. (Alternatively, you could occasionally\n             \u00a0;; clean the associative array of shadowed key\n             \u00a0;; associations.)\n              (let* ((alst (alist-delete key alst pred=?))\n                     (alst `((,key . ,data) . ,alst))\n                     (table (avl-insert < table hash-value alst)))\n                (%assoc-array hashfunc pred=? default table)))\n             (else\n             \u00a0;; Start a new association list.\n              (let* ((alst `((,key . ,data)))\n                     (table (avl-insert < table hash-value alst)))\n                (%assoc-array hashfunc pred=? default table))))))))\n\n    (define (assoc-array-ref array key)\n     \u00a0;; Return the data associated with the key. If the key is not in\n     \u00a0;; the table, return the associative array\u2019s default data.\n      (let* ((hashfunc (%hashfunc array))\n             (hash-value (hashfunc key)))\n        (let*-values\n            (((alst found?)\n              (avl-search-values < (%table array) hash-value)))\n          (if found?\n              (let ((pair (assoc key alst (%pred=? array))))\n                (if pair\n                    (cdr pair)\n                    (%default array)))\n              (%default array)))))\n\n    ))\u00a0;; end library (associative-arrays)\n\n\n(cond-expand\n  (DEMONSTRATION\n   (begin\n     (import (scheme base))\n     (import (scheme write))\n     (import (srfi 151))\n     (import (associative-arrays))\n\n    \u00a0;; I like SpookyHash, but for this demonstration I shall use the\n    \u00a0;; simpler \u2018ElfHash\u2019 and define it only for strings. See\n    \u00a0;; https://en.wikipedia.org/w/index.php?title=PJW_hash_function&oldid=997863283\n     (define (hashfunc s)\n       (let ((n (string-length s))\n             (h 0))\n         (do ((i 0 (+ i 1)))\n             ((= i n))\n           (let* ((ch\n                  \u00a0;; If the character is outside the 8-bit range,\n                  \u00a0;; probably I should break it into four bytes, each\n                  \u00a0;; incorporated separately into the hash. For this\n                  \u00a0;; demonstration, I shall simply discard the higher\n                  \u00a0;; bits.\n                   (bitwise-and (char->integer (string-ref s i))\n                                #xFF))\n                  (h^ (+ (arithmetic-shift h 4) ch))\n                  (high^ (bitwise-and h^ #xF0000000)))\n             (unless (zero? high^)\n               (set! h^\n                 (bitwise-xor h^ (arithmetic-shift high^ -24))))\n             (set! h (bitwise-and h^ (bitwise-not high^)))))\n         h))\n\n     (let* ((a1 (assoc-array hashfunc))\n            (a2 (assoc-array-set a1 \"A\" #\\A))\n            (a3 (assoc-array-set a2 \"B\" #x42))\u00a0; ASCII \u2018B\u2019.\n            (a4 (assoc-array-set a3 \"C\" \"C\")))\n       (write (assoc-array-ref a1 \"A\")) (newline)\n       (write (assoc-array-ref a1 \"B\")) (newline)\n       (write (assoc-array-ref a1 \"C\")) (newline)\n       (write (assoc-array-ref a2 \"A\")) (newline)\n       (write (assoc-array-ref a2 \"B\")) (newline)\n       (write (assoc-array-ref a2 \"C\")) (newline)\n       (write (assoc-array-ref a3 \"A\")) (newline)\n       (write (assoc-array-ref a3 \"B\")) (newline)\n       (write (assoc-array-ref a3 \"C\")) (newline)\n       (write (assoc-array-ref a4 \"A\")) (newline)\n       (write (assoc-array-ref a4 \"B\")) (newline)\n       (write (assoc-array-ref a4 \"C\")) (newline))\n\n     ))\n  (else))\n\nOutput:\n$ csc -DDEMONSTRATION -R r7rs -X r7rs associative_array-scheme.scm && ./associative_array-scheme\n#f\n#f\n#f\n#\\A\n#f\n#f\n#\\A\n66\n#f\n#\\A\n66\n\"C\"\n\n", "explain": "Scheme has association lists (alists), which are inefficient, ordered maps with arbitrary keys and values.\n\nHash tables are provided by SRFI-69 [1]. Many Scheme implementation also provide native hash tables.\nThe R6RS standard specifies support for hashtables in the standard libraries document.\nMost implementations of associative arrays\u2014including those for Scheme\u2014are for \u2018mutable\u2019 arrays, whose previous values are effectively lost whenever an insertion is done. Here instead is a persistent (\u2018immutable\u2019) implementation, using code from the AVL Tree task. (So performance will be on average logarithmic. Just be aware of that.)\nThat there are so many implementations of associative arrays for Scheme is partly because making an implementation from scratch is fairly easy. But many approaches are difficult to use if the goal is persistent associative arrays. For instance, if you use a classical hash table, inserting an association would require copying an entire array.\nAssociate arrays are not part of the Scheme language itself, but are compiler/interpreter or library add-ons. So I feel justified in presenting this sketch of yet another library add-on.\nIt is easy to add generators to this implementation, by which I mean \u2018iterators\u2019 that are themselves executable procedures.\n(Afterword. To be honest, I would not use the term \u2018associative array\u2019, because \u2018array\u2019 implies uniformly constant time access, which even a traditional hash table generally cannot provide. I would call these things \u2018maps\u2019\u2014or, if the word \u2018map\u2019 is heavily used for something else [such as Scheme\u2019s map procedures], then I would call them \u2018dictionaries\u2019.)\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Apex", "code": "\n\n// Cannot / Do not need to instantiate the algorithm implementation (e.g, HashMap).\nMap<String, String> strMap = new Map<String, String>();\nstrMap.put('a', 'aval');\nstrMap.put('b', 'bval');\n\nSystem.assert( strMap.containsKey('a') );\nSystem.assertEquals( 'bval', strMap.get('b') );\n// String keys are case-sensitive\nSystem.assert( !strMap.containsKey('A') );\n\nMap<String, String> strMap = new Map<String, String>{\n  'a' => 'aval',\n  'b' => 'bval'\n};\n\nSystem.assert( strMap.containsKey('a') );\nSystem.assertEquals( 'bval', strMap.get('b') );\n", "explain": "Apex provides a Map datatype that maps unique keys to a single value. Both keys and values can be any data type, including user-defined types. Like Java, equals and hashCode are used to determine key uniqueness for user-defined types. Uniqueness of sObject keys is determined by comparing field values.\nCreating a new empty map of String to String:\nCreating a new map of String to String with values initialized:\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "PowerShell", "code": "\n\n$hashtable = @{}\n\n$hashtable = @{\n    \"key1\" = \"value 1\"\n    key2 = 5            # if the key name has no spaces, no quotes are needed.\n}\n\n$hashtable.foo    = \"bar\"\n$hashtable['bar'] = 42\n$hashtable.\"a b\"  = 3.14  # keys can contain spaces, property-style access needs quotation marks, then\n$hashtable[5]     = 8     # keys don't need to be strings\n\n# Case insensitive keys, both end up as the same key:\n$h=@{}\n$h['a'] = 1\n$h['A'] = 2\n$h\n\nName                           Value                                                                                              \n----                           -----                                                                                              \na                              2     \n\n# Case sensitive keys:\n$h = New-Object -TypeName System.Collections.Hashtable\n$h['a'] = 1\n$h['A'] = 2\n$h\n\nName                           Value                                                                                              \n----                           -----                                                                                              \nA                              2                                                                                                  \na                              1\n\n$hashtable.key1     # value 1\n$hashtable['key2']  # 5\n\n$obj = [PSCustomObject]@{\n    \"key1\" = \"value 1\"\n    key2 = 5            \n}\n\n", "explain": "An empty hash table can be created with:\nA hash table can be initialized with key/value pairs:\nIndividual values can be assigned or replaced by either using a property-style access method or indexing into the table with the given key:\nNB. PowerShell compares strings as case-insensitive, that means the hashtable keys 'a' and 'A' are considered the same key. This happens when @{} is turned into a hashtable, but can be overridden by an explicit long-form:\nSimilarly, values can be retrieved using either syntax:\nIt is common to see a hashtable literal used to create an object, by casting it to a new type:\nThis is a convenience syntax, has less code and runs faster than other ways to create objects.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Logo", "code": "\n\npprop \"animals \"cat 5\npprop \"animals \"dog 4\npprop \"animals \"mouse 11\nprint gprop \"animals \"cat   \u00a0; 5\nremprop \"animals \"dog\nshow plist \"animals   \u00a0;  [mouse 11 cat 5]\n", "explain": "UCB Logo has \"property lists\" which associate names with values. They have their own namespace.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "ColdFusion", "code": "\n<cfset myHash = structNew()>\n<cfset myHash.key1 = \"foo\">\n<cfset myHash[\"key2\"] = \"bar\">\n<cfset myHash.put(\"key3\",\"java-style\")>\n\n\n", "explain": "In ColdFusion, a map is literally a java.util.HashMap, thus the above 3rd method is possible.\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "F#", "code": "\n\nlet dic = System.Collections.Generic.Dictionary<string,string>() ;;\ndic.Add(\"key\",\"val\") ;\ndic.[\"key\"] <- \"new val\" ;\n\n\nlet d = [(\"key\",\"val\");(\"other key\",\"other val\")] |> Map.ofList\nlet newd = d.Add(\"new key\",\"new val\")\n\nlet takeVal (d:Map<string,string>) = \n    match d.TryFind(\"key\") with\n        | Some(v) -> printfn \"%s\" v\n        | None -> printfn \"not found\"\n\n", "explain": ".NET 3.5 Generic Dictionary (mutable)\nFunctional dictionary (immutable)\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "Groovy", "code": "\n\nmap = [:]\nmap[7] = 7\nmap['foo'] = 'foovalue'\nmap.put('bar', 'barvalue')\nmap.moo = 'moovalue'\n\nassert 7 == map[7]\nassert 'foovalue' == map.foo\nassert 'barvalue' == map['bar']\nassert 'moovalue' == map.get('moo')\n\n\nmap = [7:7, foo:'foovalue', bar:'barvalue', moo:'moovalue']\n\nassert 7 == map[7]\nassert 'foovalue' == map.foo\nassert 'barvalue' == map['bar']\nassert 'moovalue' == map.get('moo')\n\n", "explain": "Create an empty map and add values\nCreate a pre-populated map and verify values\n"}, {"task_name": "Associative array/Creation", "task_url": "https://rosettacode.org/wiki/Associative_array/Creation", "task_cat": "Data Structures", "lang": "AWK", "code": "\n\nBEGIN {\n  a[\"red\"] = 0xff0000\n  a[\"green\"] = 0x00ff00\n  a[\"blue\"] = 0x0000ff\n  for (i in a) {\n    printf \"%8s %06x\\n\", i, a[i] \n  }\n  # deleting a key/value\n  delete a[\"red\"]\n  for (i in a) {\n    print i\n  }\n  # check if a key exists\n  print ( \"red\" in a )   # print 0\n  print ( \"blue\" in a )  # print 1\n}\n\n", "explain": "Arrays in AWK are indeed associative arrays.\n"}]