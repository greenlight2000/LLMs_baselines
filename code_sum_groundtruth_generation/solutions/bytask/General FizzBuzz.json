[{"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nElegant naive version[edit]\ndef genfizzbuzz(factorwords, numbers):\n    # sort entries by factor\n    factorwords.sort(key=lambda factor_and_word: factor_and_word[0])\n    lines = []\n    for num in numbers:\n        words = ''.join(word for factor, word in factorwords if (num % factor) == 0)\n        lines.append(words if words else str(num))\n    return '\\n'.join(lines)\n\nif __name__ == '__main__':\n    print(genfizzbuzz([(5, 'Buzz'), (3, 'Fizz'), (7, 'Baxx')], range(1, 21)))\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\nOne-liner using generator expressions[edit]\nn = 20\nmappings = {3: \"Fizz\", 5: \"Buzz\", 7: \"Baxx\"}\nfor i in range(1, n+1): print(''.join(word * (i % key == 0) for key, word in mappings.items()) or i)\n\nGenerator using counters instead of modulo[edit]\nWorks with: Python version 3.x\nfrom collections import defaultdict\n\nN = 100\nFACTOR_TO_WORD = {\n    3: \"Fizz\",\n    5: \"Buzz\",\n}\n\ndef fizzbuzz(n=N, factor_to_word=FACTOR_TO_WORD):\n\n    factors = defaultdict(list)\n\n    for factor in factor_to_word:\n        factors[factor].append(factor)\n\n    for i in range(1, n+1):\n        res = ''\n        for factor in sorted(factors.pop(i, ())):\n            factors[i+factor].append(factor)\n            res += factor_to_word[factor]\n        yield res or i\n\nif __name__ == '__main__':\n\n    n = int(input('Enter number: '))\n\n    mods = {\n      int(k): v\n      for k, v in (\n        input('Enter \"<factor> <word>\" (without quotes): ').split(maxsplit=1)\n        for _ in range(3)\n      )\n    }\n\n    for line in fizzbuzz(n, mods):\n        print(line)\n\nSieve of Eratosthenes[edit]\n\nfrom collections import defaultdict\n\nn = 100\nmods = [\n    (3, 'Fizz'),\n    (5, 'Buzz'),\n]\n\ndef fizzbuzz(n=n, mods=mods):\n    res = defaultdict(str)\n\n    for num, name in mods:\n        for i in range(num, n+1, num):\n            res[i] += name\n\n    return '\\n'.join(res[i] or str(i) for i in range(1, n+1))\n\n\nif __name__ == '__main__':\n    n = int(input())\n\n    mods = []\n    while len(mods) != 3:   # for reading until EOF change 3 to -1\n        try:\n            line = input()\n        except EOFError:\n            break\n        idx = line.find(' ')                        # preserves whitespace\n        num, name = int(line[:idx]), line[idx+1:]   #   after the first space\n        mods.append((num, name))    # preserves order and duplicate moduli\n\n    print(fizzbuzz(n, mods))\n\n\nOutput:\n>>> mods = [\n...   (4, 'Four '),\n...   (6, 'six '),\n...   (2, 'Two '),\n...   (8, 'eight... '),\n...   (6, 'HA! SIX!'),\n... ]\n>>> print(fizzbuzz(16, mods))\n1\nTwo \n3\nFour Two \n5\nsix Two HA! SIX!\n7\nFour Two eight... \n9\nTwo \n11\nFour six Two HA! SIX!\n13\nTwo \n15\nFour Two eight... \n\n", "explain": "This variant uses ranges with step 3, 5, etc. Preserves order and duplicate moduli.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct replace_info {\n    int n;\n    char *text;\n};\n\nint compare(const void *a, const void *b)\n{\n    struct replace_info *x = (struct replace_info *) a;\n    struct replace_info *y = (struct replace_info *) b;\n    return x->n - y->n;\n}\n\nvoid generic_fizz_buzz(int max, struct replace_info *info, int info_length)\n{\n    int i, it;\n    int found_word;\n\n    for (i = 1; i < max; ++i) {\n        found_word = 0;\n\n        /* Assume sorted order of values in the info array */\n        for (it = 0; it < info_length; ++it) {\n            if (0 == i % info[it].n) {\n                printf(\"%s\", info[it].text);\n                found_word = 1;\n            }\n        }\n\n        if (0 == found_word)\n            printf(\"%d\", i);\n\n        printf(\"\\n\");\n    }\n}\n\nint main(void)\n{\n    struct replace_info info[3] = {\n        {5, \"Buzz\"},\n        {7, \"Baxx\"},\n        {3, \"Fizz\"}\n    };\n\n    /* Sort information array */\n    qsort(info, 3, sizeof(struct replace_info), compare);\n\n    /* Print output for generic FizzBuzz */\n    generic_fizz_buzz(20, info, 3);\n    return 0;\n}\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n#include <algorithm>\n#include <iostream>\n#include <vector>\n#include <string>\n\nclass pair  {\npublic:\n    pair( int s, std::string z )            { p = std::make_pair( s, z ); }\n    bool operator < ( const pair& o ) const { return i() < o.i(); }\n    int i() const                           { return p.first; }\n    std::string s() const                   { return p.second; }\nprivate:\n    std::pair<int, std::string> p;\n};\nvoid gFizzBuzz( int c, std::vector<pair>& v ) {\n    bool output;\n    for( int x = 1; x <= c; x++ ) {\n        output = false;\n        for( std::vector<pair>::iterator i = v.begin(); i != v.end(); i++ ) {\n            if( !( x % ( *i ).i() ) ) {\n                std::cout << ( *i ).s();\n                output = true;\n            }\n        }\n        if( !output ) std::cout << x;\n        std::cout << \"\\n\";\n    }\n}\nint main( int argc, char* argv[] ) {\n    std::vector<pair> v;\n    v.push_back( pair( 7, \"Baxx\" ) );\n    v.push_back( pair( 3, \"Fizz\" ) );\n    v.push_back( pair( 5, \"Buzz\" ) );\n    std::sort( v.begin(), v.end() );\n    gFizzBuzz( 20, v );\n    return 0;\n}\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\npublic class FizzBuzz {\n\n    public static void main(String[] args) {\n        Sound[] sounds = {new Sound(3, \"Fizz\"), new Sound(5, \"Buzz\"),  new Sound(7, \"Baxx\")};\n        for (int i = 1; i <= 20; i++) {\n            StringBuilder sb = new StringBuilder();\n            for (Sound sound : sounds) {\n                sb.append(sound.generate(i));\n            }\n            System.out.println(sb.length() == 0 ? i : sb.toString());\n        }\n    }\n\n    private static class Sound {\n        private final int trigger;\n        private final String onomatopoeia;\n\n        public Sound(int trigger, String onomatopoeia) {\n            this.trigger = trigger;\n            this.onomatopoeia = onomatopoeia;\n        }\n\n        public String generate(int i) {\n            return i % trigger == 0 ? onomatopoeia : \"\";\n        }\n\n    }\n\n}\n\n\nimport java.util.stream.*;\nimport java.util.function.*;\nimport java.util.*;\npublic class fizzbuzz_general {\n    /**\n     * To run: java fizzbuzz_general.java 3=Fizz 5=Buzz 7=Baxx 100\n     *\n     */\n    public static void main(String[] args) {\n        Function<String[],Function<Integer,String>> make_cycle_function = \n              parts -> j -> j%(Integer.parseInt(parts[0]))==0?parts[1]:\"\";\n        List<Function<Integer,String>> cycle_functions = Stream.of(args)\n                     .map(arg -> arg.split(\"=\"))\n                     .filter(parts->parts.length==2)\n                     .map(make_cycle_function::apply)\n                     .collect(Collectors.toList());\n        Function<Integer,String> moduloTesters = i -> cycle_functions.stream()\n                                   .map(fcn->fcn.apply(i))\n                                   .collect(Collectors.joining());\n        BiFunction<Integer,String,String> formatter = \n                    (i,printThis) -> \"\".equals(printThis)?Integer.toString(i):printThis;                               \n        Function<Integer,String> fizzBuzz = i -> formatter.apply(i,moduloTesters.apply(i));\n       \n        IntStream.rangeClosed(0,Integer.parseInt(args[args.length-1]))\n           .mapToObj(Integer::valueOf)\n           .map(fizzBuzz::apply)\n           .forEach(System.out::println);\n    }\n}\n\n", "explain": "\nFor a more complete example see jFizzBuzz\n Or using a lot of Lambdas ... \n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nusing System;\n\npublic class GeneralFizzBuzz\n{\n    public static void Main() \n    {\n        int i;\n        int j;\n        int k;\n        \n        int limit;\n        \n        string iString;\n        string jString;\n        string kString;\n\n        Console.WriteLine(\"First integer:\");\n        i = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"First string:\");\n        iString = Console.ReadLine();\n\n        Console.WriteLine(\"Second integer:\");\n        j = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Second string:\");\n        jString = Console.ReadLine();\n\n        Console.WriteLine(\"Third integer:\");\n        k = Convert.ToInt32(Console.ReadLine());\n        Console.WriteLine(\"Third string:\");\n        kString = Console.ReadLine();\n\n        Console.WriteLine(\"Limit (inclusive):\");\n        limit = Convert.ToInt32(Console.ReadLine());\n\n        for(int n = 1; n<= limit; n++)\n        {\n            bool flag = true;\n            if(n%i == 0)\n            {\n                Console.Write(iString);\n                flag = false;\n            }\n\n            if(n%j == 0)\n            {\n                Console.Write(jString);\n                flag = false;\n            }\n\n            if(n%k == 0)\n            {\n                Console.Write(kString);\n                flag = false;\n            }\n            if(flag)\n                Console.Write(n);\n            Console.WriteLine();\n        }\n    }\n}\n\n", "explain": "Not extremely clever and doesn't use anything too fancy.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\n\nfunction fizz(d, e) {\n  return function b(a) {\n    return a ? b(a - 1).concat(a) : [];\n  }(e).reduce(function (b, a) {\n    return b + (d.reduce(function (b, c) {\n      return b + (a % c[0] ? \"\" : c[1]);\n    }, \"\") || a.toString()) + \"\\n\";\n  }, \"\");\n}\n\n\nfunction fizz(lstRules, lngMax) {\n\n    return (\n        function rng(i) {\n            return i ? rng(i - 1).concat(i) : []\n        }\n    )(lngMax).reduce(\n        function (strSeries, n) {\n\n            // The next member of the series of lines:\n            // a word string or a number string\n            return strSeries + (\n                lstRules.reduce(\n                    function (str, tplNumWord) {\n                        return str + (\n                            n % tplNumWord[0] ? '' : tplNumWord[1]\n                        )\n                    }, ''\n                ) || n.toString()\n            ) + '\\n';\n            \n        }, ''\n    );\n}\n\nfizz([[3, 'Fizz'], [5, 'Buzz'], [7, 'Baxx']], 20);\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\nES6[edit]\n// range\u00a0:: Int -> Int -> [Int]\nconst range = (min, max) =>\n  Array.from({ length: max - min }, (_, i) => min + i)\n\nconst defaultRules = Object.freeze([\n  [3, 'Fizz'],\n  [5, 'Buzz'],\n  [7, 'Baxx'],\n])\n\n// fizzBuzz\u00a0:: Int -> [[Int, String]] -> String\nconst fizzBuzz = (max, rules = defaultRules) =>\n  range(1, max + 1).map(n =>\n    rules.reduce((words, [factor, word]) =>\n      words + (n % factor ? '' : word), ''\n    ) || n\n  ).join('\\n')\n\nconsole.log(fizzBuzz(20))\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": "In a functional style of JavaScript, with two nested reduce folds \u2013 one through the integer series,\nand one through the series of rules.\nFirst as compacted by Google's Closure compiler:\nand then in the original expanded form,  for better legibility:\n\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\nImports System.Globalization\n\nModule Program\n    Sub Main()\n        Console.Write(\"Max: \")\n        Dim max = Integer.Parse(Console.ReadLine(), CultureInfo.InvariantCulture)\n\n        Dim factors As New SortedDictionary(Of Integer, String)\n\n        Const NUM_FACTORS = 3\n        For i = 1 To NUM_FACTORS\n            Console.Write(\"Factor {0}: \", i)\n            Dim input = Console.ReadLine().Split()\n            factors.Add(Integer.Parse(input(0), CultureInfo.InvariantCulture), input(1))\n        Next\n\n        For i = 1 To max\n            Dim anyMatches = False\n            For Each factor In factors\n                If i Mod factor.Key = 0 Then\n                    Console.Write(factor.Value)\n                    anyMatches = True\n                End If\n            Next\n            If Not anyMatches Then Console.Write(i)\n            Console.WriteLine()\n        Next\n    End Sub\nEnd Module\n\n\nOutput:\nMax: 20\nFactor 1: 7 Baxx\nFactor 2: 3 Fizz\nFactor 3: 5 Buzz\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "SQL", "code": "\nWorks with: ORACLE 19c\n\n/*\nThis code is an implementation of \"General FizzBuzz\" in SQL ORACLE 19c \n*/\nselect lpad( nvl(   case when mod(level, 3) = 0 then 'Fizz' end \n                 || case when mod(level, 5) = 0 then 'Buzz' end \n                 || case when mod(level, 7) = 0 then 'Baxx' end\n                , level)\n            ,12) as output\n  from dual\nconnect by level <= 107\n;\n/\n\n\nOutput:\n           1\n           2\n        Fizz\n           4\n        Buzz\n        Fizz\n        Baxx\n           8\n        Fizz\n        Buzz\n          11\n        Fizz\n          13\n        Baxx\n    FizzBuzz\n          16\n          17\n        Fizz\n          19\n        Buzz\n    FizzBaxx\n         ...\n         101\n        Fizz\n         103\n         104\nFizzBuzzBaxx\n         106\n         107\n\n", "explain": "This is not a particularly efficient solution, but it gets the job done.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n<?php\n\n$max = 20;\n$factor = array(3 => 'Fizz', 5 => 'Buzz', 7 => 'Jazz');\n\nfor ($i = 1 ; $i <= $max ; $i++) {\n    $matched = false;\n    foreach ($factor AS $number => $word) {\n        if ($i % $number == 0) {\n            echo $word;\n            $matched = true;\n        }\n    }\n    echo ($matched ? '' : $i), PHP_EOL;\n}\n\n?>\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nJazz\n8\nFizz\nBuzz\n11\nFizz\n13\nJazz\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nconst numbers = 3\n\nfunc main() {\n\n\t//using the provided data\n\tmax := 20\n\twords := map[int]string{\n\t\t3: \"Fizz\",\n\t\t5: \"Buzz\",\n\t\t7: \"Baxx\",\n\t}\n\tkeys := []int{3, 5, 7}\n\tdivisible := false\n\tfor i := 1; i <= max; i++ {\n\t\tfor _, n := range keys {\n\t\t\tif i % n == 0 {\n\t\t\t\tfmt.Print(words[n])\n\t\t\t\tdivisible = true\n\t\t\t}\n\t\t}\n\t\tif !divisible {\n\t\t\tfmt.Print(i)\n\t\t}\n\t\tfmt.Println()\n\t\tdivisible = false\n\t}\n\n}\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\ndef general_fizzbuzz(text)\n  num, *nword = text.split\n  num = num.to_i\n  dict = nword.each_slice(2).map{|n,word| [n.to_i,word]}\n  (1..num).each do |i|\n    str = dict.map{|n,word| word if i%n==0}.join\n    puts str.empty? ? i : str\n  end\nend\n\ntext = <<EOS\n20\n3 Fizz\n5 Buzz\n7 Baxx\nEOS\n\ngeneral_fizzbuzz(text)\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nuse std::io;\nuse std::io::BufRead;\n\nfn parse_entry(l: &str) -> (i32, String) {\n    let params: Vec<&str> = l.split(' ').collect();\n\n    let divisor = params[0].parse::<i32>().unwrap();\n    let word = params[1].to_string();\n    (divisor, word)\n}\n\nfn main() {\n    let stdin = io::stdin();\n    let mut lines = stdin.lock().lines().map(|l| l.unwrap());\n\n    let l = lines.next().unwrap();\n    let high = l.parse::<i32>().unwrap();\n\n    let mut entries = Vec::new();\n    for l in lines {\n        if &l == \"\" { break }\n        let entry = parse_entry(&l);\n        entries.push(entry);\n    }\n\n    for i in 1..(high + 1) {\n        let mut line = String::new();\n        for &(divisor, ref word) in &entries {\n            if i % divisor == 0 {\n                line = line + &word;\n            }\n        }\n        if line == \"\" {\n            println!(\"{}\", i);\n        } else {\n            println!(\"{}\", line);\n        }\n    }\n}\n\n\nuse std::collections::BTreeMap;\nuse std::fmt::{self, Write};\nuse std::io::{self, Stdin};\n\n#[derive(Debug, PartialEq)]\npub struct FizzBuzz {\n    end: usize,\n    factors: Factors,\n}\n\nimpl FizzBuzz {\n    fn from_reader(rdr: &Stdin) -> Result<FizzBuzz, Box<dyn std::error::Error>> {\n        let mut line = String::new();\n        rdr.read_line(&mut line)?;\n\n        let end = line.trim().parse::<usize>()?;\n\n        let mut factors = Factors::new();\n\n        loop {\n            let mut line = String::new();\n            rdr.read_line(&mut line)?;\n\n            if line.trim().is_empty() { break; }\n\n            let mut split = line.trim().splitn(2, ' ');\n\n            let factor = match split.next() {\n                Some(f) => f.parse::<usize>()?,\n                None => break,\n            };\n\n            let phrase = match split.next() {\n                Some(p) => p,\n                None => break,\n            };\n\n            factors.insert(factor, phrase.to_string());\n        }\n\n        Ok(FizzBuzz { end, factors })\n    }\n}\n\nimpl fmt::Display for FizzBuzz {\n    fn fmt(&self, f: &mut fmt::Formatter) -> fmt::Result {\n        for n in 1..=self.end {\n            let mut had_factor = false;\n\n            // check for factors\n            for (factor, phrase) in self.factors.iter() {\n                if n % factor == 0 {\n                    f.write_str(&phrase)?;\n                    had_factor = true;\n                }\n            }\n\n            if !had_factor {\n                f.write_str(n.to_string().as_str())?;\n            }\n            f.write_char('\\n')?;\n        }\n        Ok(())\n    }\n}\n\ntype Factors = BTreeMap<usize, String>;\n\nfn main() -> Result<(), Box<dyn std::error::Error>> {\n    let input = io::stdin();\n\n    let fizz_buzz = FizzBuzz::from_reader(&input)?;\n\n    println!(\"{}\", fizz_buzz);\n\n    Ok(())\n}\n\n#[cfg(test)]\nmod tests {\n    use super::*;\n\n    #[test]\n    fn fizz_buzz_prints_expected_format() {\n        let expected_factors = {\n            let mut map = Factors::new();\n            map.insert(3, \"Fizz\".to_string());\n            map.insert(5, \"Buzz\".to_string());\n            map.insert(7, \"Baxx\".to_string());\n            map\n        };\n\n        let expected_end = 20;\n\n        let fizz_buzz = FizzBuzz {\n            end: expected_end,\n            factors: expected_factors,\n        };\n\n        let expected = r#\"1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\"#;\n        let printed = format!(\"{}\", fizz_buzz);\n\n        assert_eq!(expected, &printed);\n    }\n}\n\n", "explain": "This solution stores the Fizz Buzz state in a struct, leveraging types and the standard library for a more general solution:\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nimport Foundation\n\nprint(\"Input max number: \", terminator: \"\")\n\nguard let maxN = Int(readLine()\u00a0?? \"0\"), maxN > 0 else {\n  fatalError(\"Please input a number greater than 0\")\n}\n\nfunc getFactor() -> (Int, String) {\n  print(\"Enter a factor and phrase: \", terminator: \"\")\n\n  guard let factor1Input = readLine() else {\n    fatalError(\"Please enter a factor\")\n  }\n\n  let sep1 = factor1Input.components(separatedBy: \" \")\n  let phrase = sep1.dropFirst().joined(separator: \" \")\n\n  guard let factor = Int(sep1[0]), factor\u00a0!= 0, !phrase.isEmpty else {\n    fatalError(\"Please enter a factor and phrase\")\n  }\n\n  return (factor, phrase)\n}\n\nlet (factor1, phrase1) = getFactor()\nlet (factor2, phrase2) = getFactor()\nlet (factor3, phrase3) = getFactor()\n\nfor i in 1...maxN {\n  let factors = [\n    (i.isMultiple(of: factor1), phrase1),\n    (i.isMultiple(of: factor2), phrase2),\n    (i.isMultiple(of: factor3), phrase3)\n  ].filter({ $0.0 }).map({ $0.1 }).joined()\n\n  print(\"\\(factors.isEmpty\u00a0? String(i)\u00a0: factors)\")\n}\n\n\nOutput:\nInput max number: 20\nEnter a factor and phrase: 3 fizz\nEnter a factor and phrase: 5 buzz\nEnter a factor and phrase: 7 baxx\n1\n2\nfizz\n4\nbuzz\nfizz\nbaxx\n8\nfizz\nbuzz\n11\nfizz\n13\nbaxx\nfizzbuzz\n16\n17\nfizz\n19\nbuzz\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n... solution[edit]\n\ngenFizzBuzz <- function(n, ...)\n{\n  args <- list(...)\n  #R doesn't like vectors of mixed types, so c(3, \"Fizz\") is coerced to c(\"3\", \"Fizz\"). We must undo this.\n  #Treating \"[[\" as if it is a function is a bit of R's magic. You can treat it like a function because it actually is one.\n  factors <- as.integer(sapply(args, \"[[\", 1)) \n  words <- sapply(args, \"[[\", 2)\n  sortedPermutation <- sort.list(factors)#Required by the task: We must go from least factor to greatest.\n  factors <- factors[sortedPermutation]\n  words <- words[sortedPermutation]\n  for(i in 1:n)\n  {\n    isFactor <- i %% factors == 0\n    print(if(any(isFactor)) paste0(words[isFactor], collapse = \"\") else i)\n  }\n}\ngenFizzBuzz(105, c(3, \"Fizz\"), c(5, \"Buzz\"), c(7, \"Baxx\"))\ngenFizzBuzz(105, c(5, \"Buzz\"), c(9, \"Prax\"), c(3, \"Fizz\"), c(7, \"Baxx\"))\n\nNames solution[edit]\n\nnamedGenFizzBuzz <- function(n, namedNums)\n{\n  factors <- sort(namedNums)#Required by the task: We must go from least factor to greatest.\n  for(i in 1:n)\n  {\n    isFactor <- i %% factors == 0\n    print(if(any(isFactor)) paste0(names(factors)[isFactor], collapse = \"\") else i)\n  }\n}\nnamedNums <- c(Fizz=3, Buzz=5, Baxx=7)#Notice that we can name our inputs without a function call.\nnamedGenFizzBuzz(105, namedNums)\nshuffledNamedNums <- c(Buzz=5, Prax=9, Fizz=3, Baxx=7)\nnamedGenFizzBuzz(105, shuffledNamedNums)\n\n", "explain": "The task asks that we assume 3 factors for the sake of simplicity. However, R makes the k factors case not much more complicated, so we will do that. The only major downside is that checking for malformed user input becomes so difficult that we will not bother.\nIf we deviate from the task's example of how to input parameters and instead use R's names facilities to make our (number, name) pairs, we get a much cleaner solution.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO;              use Ada.Text_IO;\nwith Ada.Integer_Text_IO;      use Ada.Integer_Text_IO;\nwith Ada.Containers.Generic_Array_Sort;\nwith Ada.Strings.Unbounded;    use Ada.Strings.Unbounded;\nwith Ada.Text_IO.Unbounded_IO; use Ada.Text_IO.Unbounded_IO;\n\nprocedure Main is\n   type map_element is record\n      Num  : Positive;\n      Word : Unbounded_String;\n   end record;\n\n   type map_list is array (Positive range <>) of map_element;\n\n   function \"<\" (Left, Right : map_element) return Boolean is\n   begin\n      return Left.Num < Right.Num;\n   end \"<\";\n\n   procedure list_sort is new Ada.Containers.Generic_Array_Sort\n     (Index_Type => Positive, Element_Type => map_element,\n      Array_Type => map_list);\n   \n   procedure general_fizz_buzz (max : Positive; words : in out map_list) is\n      found : Boolean;\n   begin\n      list_sort (words);\n\n      for i in 1 .. max loop\n         found := False;\n         for element of words loop\n            if i mod element.Num = 0 then\n               found := True;\n               Put (element.Word);\n            end if;\n         end loop;\n         if not found then\n            Put (Item => i, Width => 1);\n         end if;\n         New_Line;\n      end loop;\n   end general_fizz_buzz;\n\n   fizzy : map_list :=\n     ((3, To_Unbounded_String (\"FIZZ\")), (7, To_Unbounded_String (\"BAXX\")),\n      (5, To_Unbounded_String (\"BUZZ\")));\n\nbegin\n   general_fizz_buzz (20, fizzy);\nend Main;\n\n\nOutput:\n1\n2\nFIZZ\n4\nBUZZ\nFIZZ\nBAXX\n8\nFIZZ\nBUZZ\n11\nFIZZ\n13\nBAXX\nFIZZBUZZ\n16\n17\nFIZZ\n19\nBUZZ\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\n\nfunction fizzbuzz(triggers :: Vector{Tuple{Int, ASCIIString}}, upper :: Int)\n    for i = 1 : upper\n        triggered = false\n\n        for trigger in triggers\n            if i % trigger[1] == 0\n                triggered = true\n                print(trigger[2])\n            end\n        end\n\n        !triggered && print(i)\n        println()\n    end\nend\n\nprint(\"Enter upper limit:\\n> \")\nupper = parse(Int, readline())\n\ntriggers = Tuple{Int, ASCIIString}[]\nprint(\"Enter factor/string pairs (space delimited; ^D when done):\\n> \")\nwhile (r = readline()) != \"\"\n    input = split(r)\n    push!(triggers, (parse(Int, input[1]), input[2]))\n    print(\"> \")\nend\n\nprintln(\"EOF\\n\")\nfizzbuzz(triggers, upper)\n\n\nOutput:\nEnter upper limit:\n> 20\nEnter factor/string pairs (space delimited; ^D when done):\n> 3 Fizz\n> 5 Buzz\n> 7 Baxx\n> EOF\n\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n", "explain": "For simplicity, assume that the user will enter valid input.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nfun main(args: Array<String>) {\n\n    //Read the maximum number, set to 0 if it couldn't be read\n    val max = readLine()?.toInt() ?: 0\n    val words = mutableMapOf<Int, String>()\n\n    //Read input three times for a factor and a word\n    (1..3).forEach {\n        readLine()?.let {\n            val tokens = it.split(' ')\n            words.put(tokens[0].toInt(), tokens[1])\n        }\n    }\n\n    //Sort the words so they will be output in arithmetic order\n    val sortedWords = words.toSortedMap()\n\n    //Find the words with matching factors and print them, print the number if no factors match\n    for (i in 1..max) {\n        val wordsToPrint = sortedWords.filter { i % it.key == 0 }.map { it.value }\n        if (wordsToPrint.isNotEmpty()) {\n            wordsToPrint.forEach { print(it) }\n            println()\n        }\n        else\n            println(i)\n    }\n}\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n#!bin/usr/perl\nuse 5.020;\nuse strict;\nuse warnings;\n\n#Get a max number from the user\nsay(\"Please enter the maximum possible multiple. \");\nmy $max = <STDIN>;\n\n#Get the factors from the user\nmy @factors = ();\nmy $buffer;\nsay(\"Now enter the first factor and its associated word. Ex: 3 Fizz \");\nchomp($buffer = <STDIN>);\npush @factors, $buffer;\nsay(\"Now enter the second factor and its associated word. Ex: 5 Buzz \");\nchomp($buffer = <STDIN>);\npush @factors, $buffer;\nsay(\"Now enter the third factor and its associated word. Ex: 7 Baxx \");\nchomp($buffer = <STDIN>);\npush @factors, $buffer;\n\n#Counting from 1 to max\nfor(my $i = 1; $i <= $max; $i++)\n{\n    #Create a secondary buffer as well as set the original buffer to the current index\n    my $oBuffer;\n    $buffer = $i;\n    #Run through each element in our array\n    foreach my $element (@factors)\n    {\n        #Look for white space\n        $element =~ /\\s/;\n        #If the int is a factor of max, append it to oBuffer as a string to be printed\n        if($i % substr($element, 0, @-) == 0)\n        {\n            $oBuffer = $oBuffer . substr($element, @+ + 1, length($element));\n            #This is essentially setting a flag saying that at least one element is a factor\n            $buffer = \"\";\n        }\n    }\n    #If there are any factors for that number, print their words. If not, print the number.\n    if(length($buffer) > 0)\n    {\n        print($buffer . \"\\n\");\n    }\n    else\n    {\n        print($oBuffer . \"\\n\");\n    }\n}\n\n\nOutput:\nPlease enter the maximum possible multiple. \n20\nNow enter the first factor and its associated word. Ex: 3 Fizz \n3 Fizz\nNow enter the second factor and its associated word. Ex: 5 Buzz \n5 Buzz\nNow enter the third factor and its associated word. Ex: 7 Baxx \n7 Baxx\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\nmaxNumber(105).  \nfactors([(3, \"Fizz\"), (5, \"Buzz\"), (7, \"Baxx\")]).\n\n\ngo :- maxNumber(M), factors(Fs), MLast is M+1, loop(1,MLast,Fs).\n\nloop(B,B,_).\nloop(A,B,Fs) :- \n    A < B, fizzbuzz(A,Fs,S), ( (S = \"\", Res is A) ; Res = S ), writeln(Res), \n    Next is A+1, loop(Next,B,Fs).\n\nfizzbuzz(_,[],\"\").\nfizzbuzz(N,[(F,S)|Fs],Res) :-\n    fizzbuzz(N,Fs,OldRes),\n    ( N mod F =:= 0, string_concat(S,OldRes,Res) ; Res = OldRes ).\n\n\n?- go.\n\n\nfactors([(3, \"Fizz\"), (5, \"Buzz\")]).\n\n\n", "explain": "Assuming the user specifies as input two facts of the form:\nA simple Prolog solution to the generalised FizzBuzz problem is as follows:\nThe program can be launched by querying the predicate\nIt is worth noting that \ncorresponds to basic FizzBuzz and that the proposed solution can handle an arbitrary number of factors.\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction genFizz (param)\n  local response\n  print(\"\\n\")\n  for n = 1, param.limit do\n    response = \"\"\n    for i = 1, 3 do\n      if n % param.factor[i] == 0 then\n        response = response .. param.word[i]\n      end\n    end\n    if response == \"\" then print(n) else print(response) end\n  end\nend\n\nlocal param = {factor = {}, word = {}}\nparam.limit = io.read()\nfor i = 1, 3 do\n  param.factor[i], param.word[i] = io.read(\"*number\", \"*line\")\nend\ngenFizz(param)\n\nWithout modulo[edit]\nTranslation of: Python\nlocal function fizzbuzz(n, mods)\n  local res = {}\n\n  for i = 1, #mods, 2 do\n    local mod, name = mods[i], mods[i+1]\n    for i = mod, n, mod do\n      res[i] = (res[i] or '') .. name\n    end\n  end\n\n  for i = 1, n do\n    res[i] = res[i] or i\n  end\n\n  return table.concat(res, '\\n')\nend\n\ndo\n  local n = tonumber(io.read())     -- number of lines, eg. 100\n  local mods = {}\n\n  local n_mods = 0\n  while n_mods ~= 3 do              -- for reading until EOF, change 3 to -1\n    local line = io.read()\n    if not line then break end\n    local s, e = line:find(' ')\n    local num  = tonumber(line:sub(1, s-1))\n    local name = line:sub(e+1)\n    mods[#mods+1] = num\n    mods[#mods+1] = name\n    n_mods = n_mods + 1\n  end\n\n  print(fizzbuzz(n, mods))\nend\n\n\nOutput:\n> mods = {\n>>   3, 'cheese ',\n>>   2, 'broccoli ',\n>>   3, 'sauce ',\n>> }\n> fizzbuzz(8, mods)\n1\nbroccoli \ncheese sauce \nbroccoli \n5\ncheese broccoli sauce \n7\nbroccoli \nFast Version without Modulo[edit]\n#!/usr/bin/env luajit\n\nlocal num = arg[1] or tonumber(arg[1]) or 110\nlocal t = {\n\t{3, \"Fizz\"},\n\t{5, \"Buzz\"},\n\t{7, \"Gazz\"},\n}\n\n-- `cnt` contains counters for each factor-word pair; when a counter of a pair reaches its factor,\n-- the counter is reset to zero and the word is written to output\nlocal cnt = setmetatable({}, {__index = function() return 0 end})\n\nfor i = 1,num do\n\tfor i = 1,#t do \n\t\tcnt[i] = cnt[i]+1 \n\tend\n\tlocal match = false\n\tfor i=1,#t do\n\t\tif cnt[i] == t[i][1] then\n\t\t\tio.write(t[i][2])\n\t\t\tcnt[i] = 0\n\t\t\tmatch = true\t\n\t\tend\n\tend\n\tif not match then\n\t\tio.write(i)\n\tend\n\tio.write(\", \")\nend\n\n\nOutput:\n> ./fizzbuzz_gen.lua    \n1, 2, Fizz, 4, Buzz, Fizz, Gazz, 8, Fizz, Buzz, 11, Fizz, 13, Gazz, FizzBuzz, 16, 17, Fizz, 19, Buzz, FizzGazz, 22, 23, Fizz, Buzz, 26, Fizz, Gazz, 29, FizzBuzz, 31, 32, Fizz, 34, BuzzGazz, Fizz, 37, 38, Fizz, Buzz, 41, FizzGazz, 43, 44, FizzBuzz, 46, 47, Fizz, Gazz, Buzz, Fizz, 52, 53, Fizz, Buzz, Gazz, Fizz, 58, 59, FizzBuzz, 61, 62, FizzGazz, 64, Buzz, Fizz, 67, 68, Fizz, BuzzGazz, 71, Fizz, 73, 74, FizzBuzz, 76, Gazz, Fizz, 79, Buzz, Fizz, 82, 83, FizzGazz, Buzz, 86, Fizz, 88, 89, FizzBuzz, Gazz, 92, Fizz, 94, Buzz, Fizz, 97, Gazz, Fizz, Buzz, 101, Fizz, 103, 104, FizzBuzzGazz, 106, 107, Fizz, 109, Buzz,\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\n\nOutput for all examples:\n$ scala GeneralFizzBuzz.scala\n20\n3 Fizz\n5 Buzz\n7 Baxx\n^D\n\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\nSimple[edit]\nimport scala.io.{Source, StdIn}\n\nobject GeneralFizzBuzz extends App {\n  val max = StdIn.readInt()\n  val factors = Source.stdin.getLines().toSeq\n    .map(_.split(\" \", 2))\n    .map(f => f(0).toInt -> f(1))\n    .sorted\n\n  (1 to max).foreach { i =>\n    val words = factors.collect { case (k, v) if i % k == 0 => v }\n    println(if (words.nonEmpty) words.mkString else i)\n  }\n}\n\nLazyList (f/k/a Stream)[edit]\nimport scala.io.{Source, StdIn}\n\nobject GeneralFizzBuzz extends App {\n  def fizzBuzzTerm(n: Int, factors: Seq[(Int, String)]): String = {\n    val words = factors.collect { case (k, v) if n % k == 0 => v }\n    if (words.nonEmpty) words.mkString else n.toString\n  }\n\n  def fizzBuzz(factors: Seq[(Int, String)]): LazyList[String] =\n    LazyList.from(1).map(fizzBuzzTerm(_, factors))\n\n  val max = StdIn.readInt()\n  val factors = Source.stdin.getLines().toSeq\n    .map(_.split(\" \", 2))\n    .map { case Array(k, v) => k.toInt -> v }\n    .sorted\n  fizzBuzz(factors).take(max).foreach(println)\n}\n\nScala 3 (Dotty)[edit]\nTranslation of: LazyList (f/k/a Stream)\nimport scala.io.{Source, StdIn}\n\ndef fizzBuzzTerm(n: Int, factors: Seq[(Int, String)]): String | Int =\n  val words = factors.collect { case (k, v) if n % k == 0 => v }\n  if words.nonEmpty then words.mkString else n\n\ndef fizzBuzz(factors: Seq[(Int, String)]): LazyList[String | Int] =\n  LazyList.from(1).map(i => fizzBuzzTerm(i, factors))\n\n@main def run(): Unit =\n  val max = StdIn.readInt()\n  val factors: Seq[(Int, String)] = Source.stdin.getLines().toSeq\n    .map(_.split(\" \", 2))\n    .map { case Array(k, v) => k.toInt -> v }\n    .sorted\n  fizzBuzz(factors).take(max).foreach(println)\n\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport core.stdc.stdlib;\nimport std.stdio;\n\nvoid main() {\n    int limit;\n    write(\"Max number (>0): \");\n    readf!\"%d\\n\"(limit);\n    if (limit <= 0) {\n        writeln(\"The max number to consider must be greater than zero.\");\n        exit(1);\n    }\n\n    int terms;\n    write(\"Terms (>0): \");\n    readf!\"%d\\n\"(terms);\n    if (terms <= 0) {\n        writeln(\"The number of terms to consider must be greater than zero.\");\n        exit(1);\n    }\n\n    int[] factors = new int[terms];\n    string[] words = new string[terms];\n\n    for (int i=0; i<terms; ++i) {\n        write(\"Factor \", i+1, \" and word: \");\n        readf!\"%d %s\\n\"(factors[i], words[i]);\n        if (factors[i] <= 0) {\n            writeln(\"The factor to consider must be greater than zero.\");\n            exit(1);\n        }\n    }\n\n    foreach(n; 1..limit+1) {\n        bool print = true;\n\n        for (int i=0; i<terms; ++i) {\n            if (n % factors[i] == 0) {\n                write(words[i]);\n                print = false;\n            }\n        }\n\n        if (print) {\n            writeln(n);\n        } else {\n            writeln();\n        }\n    }\n}\n\n\nOutput:\nMax number (>0): 20\nTerms (>0): 3\nFactor 1 and word: 3 Fizz\nFactor 2 and word: 5 Buzz\nFactor 3 and word: 7 Baxx\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nfizz :: (Integral a, Show a) => a -> [(a, String)] -> String\nfizz a xs\n    | null result = show a\n    | otherwise   = result\n    where result = concatMap (fizz' a) xs\n          fizz' a (factor, str)\n              | a `mod` factor == 0 = str\n              | otherwise           = \"\"\n\nmain = do\n    line <- getLine\n    let n = read line\n    contents <- getContents\n    let multiples = map (convert . words) $ lines contents\n    mapM_ (\\ x -> putStrLn $ fizz x multiples) [1..n]\n    where convert [x, y] = (read x, y)\n\n\ntype Rule = (Int, String)\n\n----------------- FIZZETC (USING RULE SET) ---------------\n\nfizzEtc :: [(Int, String)] -> [String]\nfizzEtc rules = foldr nextLine [] [1 ..]\n  where\n    nextLine x a\n      | null noise = show x : a\n      | otherwise = noise : a\n      where\n        noise = foldl reWrite [] rules\n        reWrite s (m, k)\n          | 0 == rem x m = s <> k\n          | otherwise = s\n\n\n------------------- TEST OF SAMPLE RULES -----------------\nfizzTest :: [String]\nfizzTest = fizzEtc [(3, \"Fizz\"), (5, \"Buzz\"), (7, \"Baxx\")]\n\nmain :: IO ()\nmain = mapM_ putStrLn $ take 20 fizzTest\n\n\nOutput:\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n", "explain": "Or, as a function which takes a list of rules as an argument:\n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\n'The Function\nFunction FizzBuzz(range, mapping)\n    data = Array()\n\n    'Parse the mapping and put to \"data\" array\n    temp = Split(mapping, \",\")\n    ReDim data(UBound(temp),1)\n    For i = 0 To UBound(temp)\n        map = Split(temp(i), \" \")\n        data(i, 0) = map(0)\n        data(i, 1) = map(1)\n    Next    \n\n    'Do the loop\n    For i = 1 to range\n        noMatch = True\n        For j = 0 to UBound(data, 1)\n            If (i Mod data(j, 0)) = 0 Then\n                WScript.StdOut.Write data(j, 1)\n                noMatch = False\n            End If\n        Next\n        If noMatch Then WScript.StdOut.Write i\n        WScript.StdOut.Write vbCrLf\n    Next\nEnd Function\n\n'The Main Thing\nWScript.StdOut.Write \"Range? \"\nx = WScript.StdIn.ReadLine\nWScript.StdOut.Write \"Mapping? \"\ny = WScript.StdIn.ReadLine\nWScript.StdOut.WriteLine \"\"\nFizzBuzz x, y\n\n\nSample Run:\n\\Desktop>cscript /nologo fizzbuzz.vbs\nRange? 20\nMapping? 3 Fizz,5 Buzz,7 Baxx\n\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\n\n\\Desktop>\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\n$limit = 20\n$data  = @(\"3 Fizz\",\"5 Buzz\",\"7 Baxx\")\n\t#An array with whitespace as the delimiter\n\t#Between the factor and the word\n \nfor ($i = 1;$i -le $limit;$i++){\n\t$outP = \"\"\n\tforeach ($x in $data){\n\t\t$data_split = $x -split \" \"\t#Split the \"<factor> <word>\"\n\t\tif (($i % $data_split[0]) -eq 0){\n\t\t\t$outP += $data_split[1]\t#Append the <word> to outP\n\t\t}\n\t}\n\tif(!$outP){\t#Is outP equal to NUL?\n\t\tWrite-HoSt $i\n\t} else {\n\t\tWrite-HoSt $outP\n\t}\n}\n\n\nOutput:\nPS> ./GENFB\n1\n2\nFizz\n4\nBuzz\nFizz\nBaxx\n8\nFizz\nBuzz\n11\nFizz\n13\nBaxx\nFizzBuzz\n16\n17\nFizz\n19\nBuzz\nPS>\n", "explain": ""}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\ndef log = ''\n(1..40).each {Integer value -> log +=(value %3 == 0) ? (value %5 == 0)? 'FIZZBUZZ\\n':(value %7 == 0)? 'FIZZBAXX\\n':'FIZZ\\n'\n                                    :(value %5 == 0) ? (value %7 == 0)? 'BUZBAXX\\n':'BUZZ\\n'\n                                    :(value %7 == 0) ?'BAXX\\n'\n                                    :(value+'\\n')}\nprintln log\n\n1\n2\nFIZZ\n4\nBUZZ\nFIZZ\nBAXX\n8\nFIZZ\nBUZZ\n11\nFIZZ\n13\nBAXX\nFIZZBUZZ\n16\n17\nFIZZ\n19\nBUZZ\nFIZZBAXX\n22\n23\nFIZZ\nBUZZ\n26\nFIZZ\nBAXX\n29\nFIZZBUZZ\n31\n32\nFIZZ\n34\nBUZBAXX\nFIZZ\n37\n38\nFIZZ\nBUZZ\n\n\ndef fizzBuzz = { i -> [[3,'Fizz'],[5,'Buzz'],[7,'Baxx']].collect{i%it[0]?'':it[1]}.join()?:i}\n1.upto(100){println fizzBuzz(it)}\n\n", "explain": " or (inspired by normal FizzBuzz in Groovy: https://rosettacode.org/wiki/FizzBuzz#Groovy \n"}, {"task_name": "General FizzBuzz", "task_url": "https://rosettacode.org/wiki/General_FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\nFirst, we get the parameters, and\ngenerate a file with the list of numbers (writing directly to that file)\ngenerate a custom awk-program for that special case (redirecting standard-output)\nthe custom program is run, and does the actual work to output the desired result\n\n105\n3 Fizz\n5 Buzz\n7 Baxx\nUsage\n\nawk  -f fizzbuzzGenerate.awk  input.txt > fizzbuzzCustom.awk\nawk  -f fizzbuzzCustom.awk  numbers.txt\n\nProgram\n\n# usage:  awk -f fizzbuzzGen.awk > fizzbuzzCustom.awk\n#\nfunction Print(s) {\n    print s > \"/dev/stderr\"\n}\n\nBEGIN { Print( \"# FizzBuzz-Generate:\" )\n        q2 = \"\\\"\"\n        fN = \"numbers.txt\"\n       #fP = \"fizzbuzzCustom.awk\"\n}\n\nNF==1 { Print( \"# \" $1 \" Numbers:\" )\n        for( i=1; i <= $1; i++ )\n            print( i ) > fN   # (!!) write to file not allowed in sandbox at ideone.com\n\n        Print( \"# Custom program:\" )\n        print \"BEGIN {print \" q2 \"# CustomFizzBuzz:\" q2 \"} \\n\"\n        next\n}\n\nNF==2 { Print( \"# \" $1 \"-->\" $2 )   ##\n        print \"$1\u00a0%  \"$1\" == 0 {x = x \"q2 $2 q2 \"}\"\n        next\n}\n\nEND {  print \"\"\n       print \"!x  {print $1; next}\"\n       print \"    {print \" q2 \" \" q2 \", x; x=\" q2 q2 \"} \\n\"\n\n       print \"END {print \" q2 \"# Done.\" q2 \"}\"\n       Print( \"# Done.\" )\n}\n\n\n", "explain": "This is a two-step solution:\nInput:\nExample output see FizzBuzz/AWK#Custom_FizzBuzz\n"}]