[{"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Python", "code": "\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = list(set(items))\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nhelperset = set()\nfor x in items:\n    if x not in helperset:\n        unique.append(x)\n        helperset.add(x)\n\nimport itertools\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = [k for k,g in itertools.groupby(sorted(items))]\n\nitems = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nunique = []\nfor x in items:\n    if x not in unique:\n        unique.append(x)\n\nfrom collections import OrderedDict as od\n\nprint(list(od.fromkeys([1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']).keys()))\n\nfrom itertools import (groupby)\n\n\n# nubByKey\u00a0:: (a -> b) -> [a] -> [a]\ndef nubByKey(k, xs):\n    return list(list(v)[0] for _, v in groupby(sorted(xs, key=k), key=k))\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor k in [\n    id,                      # default case sensitive uniqueness\n    lambda x: x.lower(),     # case-insensitive uniqueness\n    lambda x: x[0],          # unique first character (case-sensitive)\n    lambda x: x[0].lower(),  # unique first character (case-insensitive)\n]:\n    print (\n        nubByKey(k, xs)\n    )\n\nOutput:\n['apple', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange', 'ampersand']\n['ampersand', 'apple', 'orange']\n['Apple', 'ORANGE', 'apple', 'orange']\n['apple', 'orange']\n\n# nubByEq\u00a0:: (a -> a -> Bool) -> [a] -> [a]\ndef nubByEq(eq, xs):\n    def go(yys, xxs):\n        if yys:\n            y = yys[0]\n            ys = yys[1:]\n            return go(ys, xxs) if (\n                elemBy(eq, y, xxs)\n            ) else (\n                [y] + go(ys, [y] + xxs)\n            )\n        else:\n            return []\n    return go(xs, [])\n\n\n# elemBy\u00a0:: (a -> a -> Bool) -> a -> [a] -> Bool\ndef elemBy(eq, x, xs):\n    if xs:\n        return eq(x, xs[0]) or elemBy(eq, x, xs[1:])\n    else:\n        return False\n\n\nxs = [\n    'apple', 'apple',\n    'ampersand', 'aPPLE', 'Apple',\n    'orange', 'ORANGE', 'Orange', 'orange', 'apple'\n]\nfor eq in [\n    lambda a, b: a == b,                   # default case sensitive uniqueness\n    lambda a, b: a.lower() == b.lower(),   # case-insensitive uniqueness\n    lambda a, b: a[0] == b[0],             # unique first char (case-sensitive)\n    lambda a, b: a[0].lower() == b[0].lower(),   # unique first char (any case)\n]:\n    print (\n        nubByEq(eq, xs)\n    )\n\n# nubBy\u00a0:: (a -> a -> Bool) -> [a] -> [a]\ndef nubBy(p, xs):\n    def go(xs):\n        if xs:\n            x = xs[0]\n            return [x] + go(\n                list(filter(\n                    lambda y: not p(x, y),\n                    xs[1:]\n                ))\n            )\n        else:\n            return []\n    return go(xs)\n\nOutput:\n['apple', 'ampersand', 'aPPLE', 'Apple', 'orange', 'ORANGE', 'Orange']\n['apple', 'ampersand', 'orange']\n['apple', 'Apple', 'orange', 'ORANGE']\n['apple', 'orange']\n", "explain": "If all the elements are hashable (this excludes list, dict, set, and other mutable types), we can use a set:\nor if we want to keep the order of the elements\nIf all the elements are comparable (i.e. <, >=, etc. operators; this works for list, dict, etc. but not for complex and many other types, including most user-defined types), we can sort and group:\nIf both of the above fails, we have to use the brute-force method, which is inefficient:\n\nanother way of removing duplicate elements from a list, while preserving the order would be to use OrderedDict module like so\nSee also http://www.peterbe.com/plog/uniqifiers-benchmark and http://aspn.activestate.com/ASPN/Cookbook/Python/Recipe/52560\n\nWe may also need to specify the particular type (or degree) of uniqueness and duplication that is at issue. Case-insensitive, with strings\u00a0? Unique with respect to a particular key in the case of dictionaries\u00a0?\nOne way to do this is to require an equality predicate, or perhaps a key function, in addition to a list to be pruned. For example, using itertools.groupby, at the cost of needing a sort and discarding order:\nOr alternatively, using an equality predicate with a recursive function which scales less well, but does preserve order:\nA briefer definition of which might be in terms of filter:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "C", "code": "\nO(n^2) version, using linked lists[edit]\n\n#include <stdio.h>\n#include <stdlib.h>\n\nstruct list_node {int x; struct list_node *next;};\ntypedef struct list_node node;\n\nnode * uniq(int *a, unsigned alen)\n {if (alen == 0) return NULL;\n  node *start = malloc(sizeof(node));\n  if (start == NULL) exit(EXIT_FAILURE);\n  start->x = a[0];\n  start->next = NULL;\n\n  for (int i = 1 ; i < alen ; ++i)\n     {node *n = start;\n      for (;; n = n->next)\n         {if (a[i] == n->x) break;\n          if (n->next == NULL)\n             {n->next = malloc(sizeof(node));\n              n = n->next;\n              if (n == NULL) exit(EXIT_FAILURE);\n              n->x = a[i];\n              n->next = NULL;\n              break;}}}\n\n  return start;}\n\nint main(void)\n   {int a[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};\n    for (node *n = uniq(a, 10) ; n != NULL ; n = n->next)\n        printf(\"%d \", n->x);\n    puts(\"\");\n    return 0;}\n\n\nOutput:\n1 2 4 5 15 3\n\nO(n^2) version, pure arrays[edit]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdbool.h>\n#include <string.h>\n\n/* Returns `true' if element `e' is in array `a'. Otherwise, returns `false'.\n * Checks only the first `n' elements. Pure, O(n).\n */\nbool elem(int *a, size_t n, int e)\n{\n    for (size_t i = 0; i < n; ++i)\n        if (a[i] == e)\n            return true;\n\n    return false;\n}\n\n/* Removes the duplicates in array `a' of given length `n'. Returns the number\n * of unique elements. In-place, order preserving, O(n ^ 2).\n */\nsize_t nub(int *a, size_t n)\n{\n    size_t m = 0;\n\n    for (size_t i = 0; i < n; ++i)\n        if (!elem(a, m, a[i]))\n            a[m++] = a[i];\n\n    return m;\n}\n\n/* Out-place version of `nub'. Pure, order preserving, alloc < n * sizeof(int)\n * bytes, O(n ^ 2).\n */\nsize_t nub_new(int **b, int *a, size_t n)\n{\n    int *c = malloc(n * sizeof(int));\n    memcpy(c, a, n * sizeof(int));\n    int m = nub(c, n);\n    *b = malloc(m * sizeof(int));\n    memcpy(*b, c, m * sizeof(int));\n    free(c);\n    return m;\n}\n\nint main(void)\n{\n    int a[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};\n    int *b;\n\n    size_t n = nub_new(&b, a, sizeof(a) / sizeof(a[0]));\n\n    for (size_t i = 0; i < n; ++i)\n        printf(\"%d \", b[i]);\n    puts(\"\");\n\n    free(b);\n    return 0;\n}\n\n\nOutput:\n1 2 4 5 15 3\n\nSorting method[edit]\nUsing qsort and return uniques in-place:#include <stdio.h>\n#include <stdlib.h>\n\nint icmp(const void *a, const void *b)\n{\n#define _I(x) *(const int*)x\n\treturn _I(a) < _I(b) ? -1 : _I(a) > _I(b);\n#undef _I\n}\n\n/* filter items in place and return number of uniques.  if a separate\n   list is desired, duplicate it before calling this function */\nint uniq(int *a, int len)\n{\n\tint i, j;\n\tqsort(a, len, sizeof(int), icmp);\n\tfor (i = j = 0; i < len; i++)\n\t\tif (a[i] != a[j]) a[++j] = a[i];\n\treturn j + 1;\n}\n\nint main()\n{\n\tint x[] = {1, 2, 1, 4, 5, 2, 15, 1, 3, 4};\n\tint i, len = uniq(x, sizeof(x) / sizeof(x[0]));\n\tfor (i = 0; i < len; i++) printf(\"%d\\n\", x[i]);\n\n\treturn 0;\n}\n\n\nOutput:\n1\n2\n3\n4\n5\n15\n\n", "explain": "Since there's no way to know ahead of time how large the new data structure will need to be, we'll return a linked list instead of an array.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "C++", "code": "\n\n#include <set>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    typedef set<int> TySet;\n    int data[] = {1, 2, 3, 2, 3, 4};\n\n    TySet unique_set(data, data + 6);\n\n    cout << \"Set items:\" << endl;\n    for (TySet::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)\n          cout << *iter << \" \";\n    cout << endl;\n}\n\n\nWorks with: GCC\n#include <ext/hash_set>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    typedef __gnu_cxx::hash_set<int> TyHash;\n    int data[] = {1, 2, 3, 2, 3, 4};\n\n    TyHash unique_set(data, data + 6);\n\n    cout << \"Set items:\" << endl;\n    for (TyHash::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)\n          cout << *iter << \" \";\n    cout << endl;\n}\n\n\nWorks with: GCC\n#include <tr1/unordered_set>\n#include <iostream>\nusing namespace std;\n\nint main() {\n    typedef tr1::unordered_set<int> TyHash;\n    int data[] = {1, 2, 3, 2, 3, 4};\n\n    TyHash unique_set(data, data + 6);\n\n    cout << \"Set items:\" << endl;\n    for (TyHash::iterator iter = unique_set.begin(); iter != unique_set.end(); iter++)\n          cout << *iter << \" \";\n    cout << endl;\n}\n\n\n#include <iostream>\n#include <iterator>\n#include <algorithm>\n\n// helper template\ntemplate<typename T> T* end(T (&array)[size]) { return array+size; }\n\nint main()\n{\n  int data[] = { 1, 2, 3, 2, 3, 4 };\n  std::sort(data, end(data));\n  int* new_end = std::unique(data, end(data));\n  std::copy(data, new_end, std::ostream_iterator<int>(std::cout, \" \");\n  std::cout << std::endl;\n}\n\n\nWorks with: C++11\n#include <algorithm>\n#include <iostream>\n#include <vector>\n\nint main() {\n  std::vector<int> data = {1, 2, 3, 2, 3, 4};\n\n  std::sort(data.begin(), data.end());\n  data.erase(std::unique(data.begin(), data.end()), data.end());\n\n  for(int& i: data) std::cout << i << \" \";\n  std::cout << std::endl;\n  return 0;\n}\n\n", "explain": "This version uses std::set, which requires its element type be comparable using the < operator.\nThis version uses hash_set, which is part of the SGI extension to the Standard Template Library. It is not part of the C++ standard library. It requires that its element type have a hash function.\nThis version uses unordered_set, which is part of the TR1, which is likely to be included in the next version of C++. It is not part of the C++ standard library. It requires that its element type have a hash function.\nAlternative method working directly on the array:\nUsing sort, unique, and erase on a vector.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Java", "code": "\n\nimport java.util.ArrayList;\nimport java.util.Iterator;\nimport java.util.LinkedHashSet;\nimport java.util.List;\nimport java.util.Set;\n\n\nint[] removeDuplicates(int[] values) {\n    /* use a LinkedHashSet to preserve order */\n    Set<Integer> set = new LinkedHashSet<>();\n    for (int value : values)\n        set.add(value);\n    values = new int[set.size()];\n    Iterator<Integer> iterator = set.iterator();\n    int index = 0;\n    while (iterator.hasNext())\n        values[index++] = iterator.next();\n    return values;\n}\n\n\nint[] removeDuplicates(int[] values) {\n    List<Integer> list = new ArrayList<>();\n    for (int value : values)\n        if (!list.contains(value)) list.add(value);\n    values = new int[list.size()];\n    int index = 0;\n    for (int value : list)\n        values[index++] = value;\n    return values;\n}\n\n[2, 1, 4, 1, 1, 3, 1, 3, 1, 4, 3, 2, 3, 4, 3, 2, 2, 3, 3, 3]\n[2, 1, 4, 3]\n\n[2, 4, 1, 4, 1, 4, 3, 1, 1, 3, 4, 4, 4, 4, 2, 1, 1, 2, 3, 2]\n[2, 4, 1, 3]\n\n\nWorks with: Java version 1.5\nimport java.util.*;\n\nclass Test {\n\n    public static void main(String[] args) {\n\n        Object[] data = {1, 1, 2, 2, 3, 3, 3, \"a\", \"a\", \"b\", \"b\", \"c\", \"d\"};\n        Set<Object> uniqueSet = new HashSet<Object>(Arrays.asList(data));\n        for (Object o : uniqueSet)\n            System.out.printf(\"%s \", o);\n    }\n}\n\n1 a 2 b 3 c d\nWorks with: Java version 8\nimport java.util.*;\n\nclass Test {\n\n    public static void main(String[] args) {\n\n        Object[] data = {1, 1, 2, 2, 3, 3, 3, \"a\", \"a\", \"b\", \"b\", \"c\", \"d\"};\n        Arrays.stream(data).distinct().forEach((o) -> System.out.printf(\"%s \", o));\n    }\n}\n\n1 2 3 a b c d\n", "explain": "There is more than 1 way to achieve this.  The most logical approach will depend on your application.\nOne way would be to add the values to a Set object, which only allows for unique values.\nAlternately, you could simply add the values to a mutable List, checking if the list already contains the value before adding it.\n\nAlternate approaches\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "C#", "code": "\nWorks with: C# version 2+\nint[] nums = { 1, 1, 2, 3, 4, 4 };\nList<int> unique = new List<int>();\nforeach (int n in nums)\n    if (!unique.Contains(n))\n        unique.Add(n);\n\nWorks with: C# version 3+\nint[] nums = {1, 1, 2, 3, 4, 4};\nint[] unique = nums.Distinct().ToArray();\n\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "JavaScript", "code": "\n\nfunction unique(ary) {\n    // concat() with no args is a way to clone an array\n    var u = ary.concat().sort();\n    for (var i = 1; i < u.length; ) {\n        if (u[i-1] === u[i])\n            u.splice(i,1);\n        else\n            i++;\n    }\n    return u;\n}\n\nvar ary = [1, 2, 3, \"a\", \"b\", \"c\", 2, 3, 4, \"b\", \"c\", \"d\", \"4\"];\nvar uniq = unique(ary);\nfor (var i = 0; i < uniq.length; i++) \n    print(uniq[i] + \"\\t\" + typeof(uniq[i]));\n\n1 - number\n2 - number\n3 - number\n4 - number\n4 - string\na - string\nb - string\nc - string\nd - string\n\nArray.prototype.unique = function() {\n    var u = this.concat().sort();\n    for (var i = 1; i < u.length; ) {\n        if (u[i-1] === u[i])\n            u.splice(i,1);\n        else\n            i++;\n    }\n    return u;\n}\nvar uniq = [1, 2, 3, \"a\", \"b\", \"c\", 2, 3, 4, \"b\", \"c\", \"d\"].unique();\n\n\nArray.prototype.unique = function() {\n   return this.sort().reduce( (a,e) => e === a[a.length-1] ? a : (a.push(e), a), [] )\n}\n\n\nArray.prototype.unique = function() {\n    return [... new Set(this)]\n}\n\n\nfunction uniq(lst) {\n  var u = [],\n    dct = {},\n    i = lst.length,\n    v;\n\n  while (i--) {\n    v = lst[i], dct[v] || (\n      dct[v] = u.push(v)\n    );\n  }\n  u.sort(); // optional\n  \n  return u;\n}\n\n\nTranslation of: Haskell\n(function () {\n    'use strict';\n\n    // nub\u00a0:: [a] -> [a]\n    function nub(xs) {\n\n        // Eq\u00a0:: a -> a -> Bool\n        function Eq(a, b) {\n            return a === b;\n        }\n\n        // nubBy\u00a0:: (a -> a -> Bool) -> [a] -> [a]\n        function nubBy(fnEq, xs) {\n            var x = xs.length ? xs[0] : undefined;\n\n            return x !== undefined ? [x].concat(\n                nubBy(fnEq, xs.slice(1)\n                    .filter(function (y) {\n                        return !fnEq(x, y);\n                    }))\n            ) : [];\n        }\n\n        return nubBy(Eq, xs);\n    }\n\n\n    // TEST\n    \n    return [\n        nub('4 3 2 8 0 1 9 5 1 7 6 3 9 9 4 2 1 5 3 2'.split(' '))\n        .map(function (x) {\n            return Number(x);\n        }),\n        nub('chthonic eleemosynary paronomasiac'.split(''))\n        .join('')\n    ]\n\n})();\n\n\nOutput:\n[[4, 3, 2, 8, 0, 1, 9, 5, 7, 6], \"chtoni elmsyarp\"]\n", "explain": "This uses the === \"strict equality\" operator, which does no type conversions (4 == \"4\" is true but 4 === \"4\" is false)\nOr, extend the prototype for Array:\nWith reduce and arrow functions (ES6):\nWith sets and spread operator (ES6):\nIf, however, the array is homogenous, or we wish to interpret it as such by using JavaScript's Abstract Equality comparison (as in '==', see http://www.ecma-international.org/ecma-262/5.1/#sec-11.9.3) then it proves significantly faster to use a hash table.\nFor example, in ES 5:\nOr, to allow for customised definitions of equality and duplication, we can follow the Haskell prelude in defining a nub\u00a0:: [a] -> [a] function which is a special case of nubBy\u00a0:: (a -> a -> Bool) -> [a] -> [a]\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "SQL", "code": "\nWorks with: ORACLE 19c\n\n/*\nThis code is an implementation of \"Remove duplicate elements\" in SQL ORACLE 19c \np_in_str    -- input string  \np_delimiter -- delimeter \n*/\nwith\n  function remove_duplicate_elements(p_in_str in varchar2, p_delimiter in varchar2 default ',') return varchar2 is\n  v_in_str varchar2(32767)\u00a0:= replace(p_in_str,p_delimiter,',');\n  v_res    varchar2(32767);\nbegin\n  --\n  execute immediate 'select listagg(distinct cv,:p_delimiter) from (select (column_value).getstringval() cv from xmltable(:v_in_str))' \n     into v_res using p_delimiter, v_in_str;\n  --\n  return v_res;\n  --\nend;\n\n--Test\nselect remove_duplicate_elements('1, 2, 3, \"a\", \"b\", \"c\", 2, 3, 4, \"b\", \"c\", \"d\"') as res from dual\nunion all \nselect remove_duplicate_elements('3 9 1 10 3 7 6 5 2 7 4 7 4 2 2 2 2 8 2 10 4 9 2 4 9 3 4 3 4 7',' ') as res from dual\n;\n\nOutput:\n1,2,3,4,a,b,c,d\n1 10 2 3 4 5 6 7 8 9\n\n", "explain": "This is not a particularly efficient solution, but it gets the job done.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "PHP", "code": "\n$list = array(1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd');\n$unique_list = array_unique($list);\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "MATLAB", "code": "\n\n>> unique([1 2 6 3 6 4 5 6])\n\nans =\n\n     1     2     3     4     5     6\n\n\n", "explain": "MATLAB has a built-in function, \"unique(list)\", which performs this task.\nSample Usage:\nNOTE: The unique function only works for vectors and not for true arrays.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Fortran", "code": "\n\nprogram remove_dups\n  implicit none\n  integer :: example(12)         ! The input\n  integer :: res(size(example))  ! The output\n  integer :: k                   ! The number of unique elements\n  integer :: i, j\n\n  example = [1, 2, 3, 2, 2, 4, 5, 5, 4, 6, 6, 5]\n  k = 1\n  res(1) = example(1)\n  outer: do i=2,size(example)\n     do j=1,k\n        if (res(j) == example(i)) then\n           ! Found a match so start looking again\n           cycle outer\n        end if\n     end do\n     ! No match found so add it to the output\n     k = k + 1\n     res(k) = example(i)\n  end do outer\n  write(*,advance='no',fmt='(a,i0,a)') 'Unique list has ',k,' elements: '\n  write(*,*) res(1:k)\nend program remove_dups\n\n\nprogram remove_dups\n    implicit none\n    integer :: example(12)         ! The input\n    integer :: res(size(example))  ! The output\n    integer :: k                   ! The number of unique elements\n    integer :: i\n\n    example = [1, 2, 3, 2, 2, 4, 5, 5, 4, 6, 6, 5]\n    k = 1\n    res(1) = example(1)\n    do i=2,size(example)\n        ! if the number already exist in res check next\n        if (any( res == example(i) )) cycle\n        ! No match found so add it to the output\n        k = k + 1\n        res(k) = example(i)\n    end do\n\n    write(*,advance='no',fmt='(a,i0,a)') 'Unique list has ',k,' elements: '\n    write(*,*) res(1:k)\nend program remove_dups\n\n\nOutput:\nUnique list has 6 elements:            1           2           3           4           5           6\n\n", "explain": "Fortran has no built-in hash functions or sorting functions but the code below implements the compare all elements algorithm.\nSame as above but using 'ANY' to check if the input number already exists in the array of unique elements:\n\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Go", "code": "\nMap solution[edit]\npackage main\n\nimport \"fmt\"\n\nfunc uniq(list []int) []int {\n\tunique_set := make(map[int]bool, len(list))\n\tfor _, x := range list {\n\t\tunique_set[x] = true\n\t}\n\tresult := make([]int, 0, len(unique_set))\n\tfor x := range unique_set {\n\t\tresult = append(result, x)\n\t}\n\treturn result\n}\n\nfunc main() {\n\tfmt.Println(uniq([]int{1, 2, 3, 2, 3, 4})) // prints: [3 4 1 2] (but in a semi-random order)\n}\n\nMap preserving order[edit]\n\npackage main\n\nimport \"fmt\"\n\nfunc uniq(list []int) []int {\n\tunique_set := make(map[int]int, len(list))\n\ti := 0\n\tfor _, x := range list {\n\t\tif _, there := unique_set[x]; !there {\n\t\t\tunique_set[x] = i\n\t\t\ti++\n\t\t}\n\t}\n\tresult := make([]int, len(unique_set))\n\tfor x, i := range unique_set {\n\t\tresult[i] = x\n\t}\n\treturn result\n}\n\nfunc main() {\n\tfmt.Println(uniq([]int{1, 2, 3, 2, 3, 4})) // prints: [1 2 3 4]\n}\n\nFloat64, removing duplicate NaNs[edit]\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n)\n\nfunc uniq(list []float64) []float64 {\n\tunique_set := map[float64]int{}\n\ti := 0\n\tnan := false\n\tfor _, x := range list {\n\t\tif _, exists := unique_set[x]; exists {\n\t\t\tcontinue\n\t\t}\n\t\tif math.IsNaN(x) {\n\t\t\tif nan {\n\t\t\t\tcontinue\n\t\t\t} else {\n\t\t\t\tnan = true\n\t\t\t}\n\t\t}\n\t\tunique_set[x] = i\n\t\ti++\n\t}\n\tresult := make([]float64, len(unique_set))\n\tfor x, i := range unique_set {\n\t\tresult[i] = x\n\t}\n\treturn result\n}\n\nfunc main() {\n\tfmt.Println(uniq([]float64{1, 2, math.NaN(), 2, math.NaN(), 4})) // Prints [1 2 NaN 4]\n}\n\nAny type using reflection[edit]\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math\"\n\t\"reflect\"\n)\n\nfunc uniq(x interface{}) (interface{}, bool) {\n\tv := reflect.ValueOf(x)\n\tif !v.IsValid() {\n\t\tpanic(\"uniq: invalid argument\")\n\t}\n\tif k := v.Kind(); k != reflect.Array && k != reflect.Slice {\n\t\tpanic(\"uniq: argument must be an array or a slice\")\n\t}\n\telemType := v.Type().Elem()\n\tintType := reflect.TypeOf(int(0))\n\tmapType := reflect.MapOf(elemType, intType)\n\tm := reflect.MakeMap(mapType)\n\ti := 0\n\tfor j := 0; j < v.Len(); j++ {\n\t\tx := v.Index(j)\n\t\tif m.MapIndex(x).IsValid() {\n\t\t\tcontinue\n\t\t}\n\t\tm.SetMapIndex(x, reflect.ValueOf(i))\n\t\tif m.MapIndex(x).IsValid() {\n\t\t\ti++\n\t\t}\n\t}\n\tsliceType := reflect.SliceOf(elemType)\n\tresult := reflect.MakeSlice(sliceType, i, i)\n\thadNaN := false\n\tfor _, key := range m.MapKeys() {\n\t\tival := m.MapIndex(key)\n\t\tif !ival.IsValid() {\n\t\t\thadNaN = true\n\t\t} else {\n\t\t\tresult.Index(int(ival.Int())).Set(key)\n\t\t}\n\t}\n\n\treturn result.Interface(), hadNaN\n}\n\ntype MyType struct {\n\tname  string\n\tvalue float32\n}\n\nfunc main() {\n\tintArray := [...]int{5, 1, 2, 3, 2, 3, 4}\n\tintSlice := []int{5, 1, 2, 3, 2, 3, 4}\n\tstringSlice := []string{\"five\", \"one\", \"two\", \"three\", \"two\", \"three\", \"four\"}\n\tfloats := []float64{1, 2, 2, 4,\n\t\tmath.NaN(), 2, math.NaN(),\n\t\tmath.Inf(1), math.Inf(1), math.Inf(-1), math.Inf(-1)}\n\tcomplexes := []complex128{1, 1i, 1 + 1i, 1 + 1i,\n\t\tcomplex(math.NaN(), 1), complex(1, math.NaN()),\n\t\tcomplex(math.Inf(+1), 1), complex(1, math.Inf(1)),\n\t\tcomplex(math.Inf(-1), 1), complex(1, math.Inf(1)),\n\t}\n\tstructs := []MyType{\n\t\t{\"foo\", 42},\n\t\t{\"foo\", 2},\n\t\t{\"foo\", 42},\n\t\t{\"bar\", 42},\n\t\t{\"bar\", 2},\n\t\t{\"fail\", float32(math.NaN())},\n\t}\n\n\tfmt.Print(\"intArray: \", intArray, \" \u2192 \")\n\tfmt.Println(uniq(intArray))\n\tfmt.Print(\"intSlice: \", intSlice, \" \u2192 \")\n\tfmt.Println(uniq(intSlice))\n\tfmt.Print(\"stringSlice: \", stringSlice, \" \u2192 \")\n\tfmt.Println(uniq(stringSlice))\n\tfmt.Print(\"floats: \", floats, \" \u2192 \")\n\tfmt.Println(uniq(floats))\n\tfmt.Print(\"complexes: \", complexes, \"\\n \u2192 \")\n\tfmt.Println(uniq(complexes))\n\tfmt.Print(\"structs: \", structs, \" \u2192 \")\n\tfmt.Println(uniq(structs))\n\t// Passing a non slice or array will compile put\n\t// then produce a run time panic:\n\t//a\u00a0:= 42\n\t//uniq(a)\n\t//uniq(nil)\n}\n\n\nOutput:\nintArray: [5 1 2 3 2 3 4] \u2192 [5 1 2 3 4] false\nintSlice: [5 1 2 3 2 3 4] \u2192 [5 1 2 3 4] false\nstringSlice: [five one two three two three four] \u2192 [five one two three four] false\nfloats: [1 2 2 4 NaN 2 NaN +Inf +Inf -Inf -Inf] \u2192 [1 2 4 +Inf -Inf] true\ncomplexes: [(1+0i) (0+1i) (1+1i) (1+1i) (NaN+1i) (1+NaNi) (+Inf+1i) (1+Infi) (-Inf+1i) (1+Infi)]\n \u2192 [(1+0i) (0+1i) (1+1i) (+Inf+1i) (1+Infi) (-Inf+1i)] true\nstructs: [{foo 42} {foo 2} {foo 42} {bar 42} {bar 2} {fail NaN}] \u2192 [{foo 42} {foo 2} {bar 42} {bar 2}] true\n\n", "explain": "It takes only small changes to the above code to preserver order.  Just store the sequence in the map:\nIn solutions above, you just replace int with another type to use for a list of another type.  (See Associative_arrays/Creation#Go for acceptable types.)  Except a weird thing happens with NaNs.  They (correctly) don't compare equal, so you have to special case them if you want to remove duplicate NaNs:\nGo doesn't have templates or generics, but it does have reflection.\nUsing this it's possible to build a version that will work on almost any array or slice type.\nUsing the reflect package for this does make the code less readable.\nNormally in Go this type of solution is somewhat rare. Instead, for very short code (such as min, max, abs) it's common to cast or make a type specific function by hand as needed. For longer code, often an interface can be used instead (see the sort package for an example).\nNote: due to details with how Go handles map keys that contain a NaN somewhere (including within a complex or even within a sub struct field) this version simply omits any NaN containing values it comes across and returns a bool to indicate if that happened. This version is otherwise a translation of the above order preserving map implementation, it does not for example call reflect.DeepEqual so elements with pointers to distinct but equal values will be treated as non-equal.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Delphi", "code": "\n\nprogram RemoveDuplicateElements;\n\n{$APPTYPE CONSOLE}\n\nuses Generics.Collections;\n\nvar\n  i: Integer;\n  lIntegerList: TList<Integer>;\nconst\n  INT_ARRAY: array[1..7] of Integer = (1, 2, 2, 3, 4, 5, 5);\nbegin\n  lIntegerList := TList<Integer>.Create;\n  try\n  for i in INT_ARRAY do\n    if not lIntegerList.Contains(i) then\n      lIntegerList.Add(i);\n\n  for i in lIntegerList do\n    Writeln(i);\n  finally\n    lIntegerList.Free;\n  end;\nend.\n\n\nOutput:\n1\n2\n3\n4\n5\n", "explain": "Generics were added in Delphi2009.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Ruby", "code": "\n\nary = [1,1,2,1,'redundant',[1,2,3],[1,2,3],'redundant']\np ary.uniq              # => [1, 2, \"redundant\", [1, 2, 3]]\n\nclass Array\n  # used Hash\n  def uniq1\n    each_with_object({}) {|elem, h| h[elem] = true}.keys\n  end\n  # sort (requires comparable)\n  def uniq2\n    sorted = sort\n    pre = sorted.first\n    sorted.each_with_object([pre]){|elem, uniq| uniq << (pre = elem) if elem\u00a0!= pre}\n  end\n  # go through the list\n  def uniq3\n    each_with_object([]) {|elem, uniq| uniq << elem unless uniq.include?(elem)}\n  end\nend\n\nary = [1,1,2,1,'redundant',[1,2,3],[1,2,3],'redundant']\np ary.uniq1             #=> [1, 2, \"redundant\", [1, 2, 3]]\np ary.uniq2 rescue nil  #   Error (not comparable)\np ary.uniq3             #=> [1, 2, \"redundant\", [1, 2, 3]]\n\nary = [1,2,3,7,6,5,2,3,4,5,6,1,1,1]\np ary.uniq1             #=> [1, 2, 3, 7, 6, 5, 4]\np ary.uniq2             #=> [1, 2, 3, 4, 5, 6, 7]\np ary.uniq3             #=> [1, 2, 3, 7, 6, 5, 4]\n\ndef unique(array)\n    pure = Array.new\n    for i in array\n        flag = false\n        for j in pure\n            flag = true if j==i\n        end\n        pure << i unless flag\n    end\n    return pure\nend\n\nunique [\"hi\",\"hey\",\"hello\",\"hi\",\"hey\",\"heyo\"]   # => [\"hi\", \"hey\", \"hello\", \"heyo\"]\nunique [1,2,3,4,1,2,3,5,1,2,3,4,5]              # => [1,2,3,4,5]\n", "explain": "Ruby has an Array#uniq built-in method, which returns a new array by removing duplicate values in self.\nYou can also write your own uniq method. \nA version without implementing class declarations:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Rust", "code": "\nuse std::collections::HashSet;\nuse std::hash::Hash;\n\nfn remove_duplicate_elements_hashing<T: Hash + Eq>(elements: &mut Vec<T>) {\n    let set: HashSet<_> = elements.drain(..).collect();\n    elements.extend(set.into_iter());\n}\n\nfn remove_duplicate_elements_sorting<T: Ord>(elements: &mut Vec<T>) {\n    elements.sort_unstable(); // order does not matter\n    elements.dedup();\n}\n\nfn main() {\n    let mut sample_elements = vec![0, 0, 1, 1, 2, 3, 2];\n    println!(\"Before removal of duplicates\u00a0: {:?}\", sample_elements);\n    remove_duplicate_elements_sorting(&mut sample_elements);\n    println!(\"After removal of duplicates\u00a0: {:?}\", sample_elements);\n}\n\nOutput:\nBefore removal of duplicates\u00a0: [0, 0, 1, 1, 2, 3, 2]\nAfter removal of duplicates\u00a0: [1, 0, 3, 2]\n\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Swift", "code": "\n\nWorks with: Swift version 1.2+\nprintln(Array(Set([3,2,1,2,3,4])))\n\nOutput:\n[2, 3, 1, 4]\n\nWorks with: Swift version 1.2+\nfunc uniq<T: Hashable>(lst: [T]) -> [T] {\n  var seen = Set<T>(minimumCapacity: lst.count)\n  return lst.filter { x in\n    let unseen = !seen.contains(x)\n    seen.insert(x)\n    return unseen\n  }\n}\n\nprintln(uniq([3,2,1,2,3,4]))\n\nOutput:\n[3, 2, 1, 4]\n\nfunc uniq<T: Equatable>(lst: [T]) -> [T] {\n  var seen = [T]()\n  return lst.filter { x in\n    let unseen = find(seen, x) == nil\n    if (unseen) {\n      seen.append(x)\n    }\n    return unseen\n  }\n}\n\nprintln(uniq([3,2,1,2,3,4]))\n\nOutput:\n[3, 2, 1, 4]\n", "explain": "Requires elements to be hashable:\nAnother solution (preserves order of first occurrence). Also requires elements to be hashable:\nOnly requires elements to be equatable, but runs in O(n^2):\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "R", "code": "\nitems <- c(1,2,3,2,4,3,2)\nunique (items)\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Visual_FoxPro", "code": "\nLOCAL i As Integer, n As Integer, lcOut As String\nCLOSE DATABASES ALL\nCLEAR\nCREATE CURSOR nums (num I)\nINDEX ON num TAG num COLLATE \"Machine\"\nSET ORDER TO 0\nn = 50\nRAND(-1)\nFOR i = 1 TO n\n    INSERT INTO nums VALUES (RanInt(1, 10))\nENDFOR\nSELECT num, COUNT(num) As cnt FROM nums\u00a0;\nGROUP BY num INTO CURSOR grouped\nLIST OFF TO FILE grouped.txt NOCONSOLE\nlcOut = \"\"\nSCAN\n    lcOut = lcOut + TRANSFORM(num) + \",\"\nENDSCAN\nlcOut = LEFT(lcOut, LEN(lcOut)-1)\n? lcOut\t\n\nFUNCTION RanInt(tnLow As Integer, tnHigh As Integer) As Integer\nRETURN INT((tnHigh - tnLow + 1)*RAND() + tnLow)\nENDFUNC\n\nOutput:\nNUM          COUNT\n  1              6\n  2              5\n  3              6\n  4              8\n  5              4\n  6              3\n  7              8\n  8              7\n  9              3\n\nUnique Values: 1,2,3,4,5,6,7,8,9\n\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Ada", "code": "\nWorks with: GNAT version GPL 2018\nwith Ada.Containers.Ordered_Sets, Ada.Text_IO;\nuse Ada.Text_IO;\n \nprocedure Duplicate is\t\n\tpackage Int_Sets is new Ada.Containers.Ordered_Sets (Integer);\n\tNums : constant array (Natural range <>) of Integer := (1,2,3,4,5,5,6,7,1);\n\tUnique : Int_Sets.Set;\nbegin\n\tfor n of Nums loop\n\t\tUnique.Include (n);\n\tend loop;\n\tfor e of Unique loop\n\t\tPut (e'img);\n\tend loop;\nend Duplicate;\n\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\na = [1, 2, 3, 4, 1, 2, 3, 4]\n@show unique(a) Set(a)\n\n\nOutput:\nunique(a) = [1, 2, 3, 4]\nSet(a) = Set([4, 2, 3, 1])\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Kotlin", "code": "\nTranslation of: Java\nfun main(args: Array<String>) {\n    val data = listOf(1, 2, 3, \"a\", \"b\", \"c\", 2, 3, 4, \"b\", \"c\", \"d\")\n    val set = data.distinct()\n\n    println(data)\n    println(set)\n}\n\n\nOutput:\n[1, 2, 3, a, b, c, 2, 3, 4, b, c, d]\n[1, 2, 3, a, b, c, 4, d]\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Perl", "code": "\nLibrary: List::MoreUtilsMoreUtils\n\nuse List::MoreUtils qw(uniq);\n\nmy @uniq = uniq qw(1 2 3 a b c 2 3 4 b c d);\n\nmy %seen;\nmy @uniq = grep {!$seen{$_}++} qw(1 2 3 a b c 2 3 4 b c d);\n\nmy %hash = map { $_ => 1 } qw(1 2 3 a b c 2 3 4 b c d);\nmy @uniq = keys %hash;\n\nmy %seen;\n@seen{qw(1 2 3 a b c 2 3 4 b c d)} = ();\nmy @uniq = keys %seen;\n", "explain": "(this version even preserves the order of first appearance of each element)\nIt is implemented like this:\nNote: the following two solutions convert elements to strings in the result, so if you give it references they will lose the ability to be dereferenced.\nAlternately:\nAlternately:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Objective-C", "code": "\nNSArray *items = [NSArray arrayWithObjects:@\"A\", @\"B\", @\"C\", @\"B\", @\"A\", nil];\n\nNSSet *unique = [NSSet setWithArray:items];\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Prolog", "code": "\nuniq(Data,Uniques)\u00a0:- sort(Data,Uniques).\n\n?- uniq([1, 2, 3, 2, 3, 4],Xs).\nXs = [1, 2, 3, 4]\n\nmember1(X,[H|_])\u00a0:- X==H,!.\nmember1(X,[_|T])\u00a0:- member1(X,T).\n\ndistinct([],[]).\ndistinct([H|T],C)\u00a0:- member1(H,T),!, distinct(T,C).\ndistinct([H|T],[H|C])\u00a0:- distinct(T,C).\n\n?- distinct([A, A, 1, 2, 3, 2, 3, 4],Xs).\nXs = [A, 1, 2, 3, 4]\n", "explain": "Example usage:\n\nBecause sort/2 is GNU prolog and not ISO here is an ISO compliant version:\nExample usage:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Lua", "code": "\nitems = {1,2,3,4,1,2,3,4,\"bird\",\"cat\",\"dog\",\"dog\",\"bird\"}\nflags = {}\nio.write('Unique items are:')\nfor i=1,#items do\n   if not flags[items[i]] then\n      io.write(' ' .. items[i])\n      flags[items[i]] = true\n   end\nend\nio.write('\\n')\n\n\nOutput:\nUnique items are: 1 2 3 4 bird cat dog\n\nlocal items = {1,2,3,4,1,2,3,4,0/0,nil,\"bird\",\"cat\",\"dog\",\"dog\",\"bird\",0/0}\n\nfunction rmdup(t)\n  local r,dup,c,NaN = {},{},1,{}  \n  for i=1,#t do \n    local e = t[i]\n    local k = e~=e and NaN or e\n    if k~=nil and not dup[k] then  \n      c, r[c], dup[k]= c+1, e, true \n    end\n  end\n  return r\nend\n\nprint(table.concat(rmdup(items),' '))\n\n\nOutput:\n1 2 3 4 nan bird cat dog\n", "explain": "Lua doesn't accept Not-a-Number (NaN) and nil as table key, we can handle them like this (Lua 5.3):\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Scala", "code": "\nval list = List(1,2,3,4,2,3,4,99)\nval l2 = list.distinct\n// l2: scala.List[scala.Int] = List(1,2,3,4,99)\n\nval arr = Array(1,2,3,4,2,3,4,99)\nval arr2 = arr.distinct\n// arr2: Array[Int] = Array(1, 2, 3, 4, 99)\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.algorithm;\n\n    [1, 3, 2, 9, 1, 2, 3, 8, 8, 1, 0, 2]\n    .sort()\n    .uniq\n    .writeln;\n}\n\n\nOutput:\n[0, 1, 2, 3, 8, 9]\n\nvoid main() {\n    import std.stdio;\n\n    immutable data = [1, 3, 2, 9, 1, 2, 3, 8, 8, 1, 0, 2];\n\n    bool[int] hash;\n    foreach (el; data)\n        hash[el] = true;\n    hash.byKey.writeln;\n}\n\n\nOutput:\n[8, 0, 1, 9, 2, 3]\n\nvoid main()\n{\n    import std.stdio, std.algorithm, std.array;\n\n    auto a = [5,4,32,7,6,4,2,6,0,8,6,9].sort.uniq.array;\n    a.writeln;\n}\n\n\nOutput:\n[0, 2, 4, 5, 6, 7, 8, 9, 32]\n", "explain": "Using an associative array:\nLike code D#1, but with an array returned:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Haskell", "code": "\nUsage[edit]\n print $ unique [4, 5, 4, 2, 3, 3, 4]\n\n[4,5,2,3]\n\nSorted result using Set[edit]\n\nimport qualified Data.Set as Set\n\nunique :: Ord a => [a] -> [a]\nunique = Set.toList . Set.fromList\n\nUnsorted result using Set[edit]\n\nimport Data.Set\n\nunique :: Ord a => [a] -> [a]\nunique = loop empty\n  where\n    loop s []                    = []\n    loop s (x : xs) | member x s = loop s xs\n                    | otherwise  = x : loop (insert x s) xs\n\nUsing filter[edit]\n\nimport Data.List\n\nunique :: Eq a => [a] -> [a]\nunique []       = []\nunique (x : xs) = x : unique (filter (x /=) xs)\n\nStandard Library[edit]\nimport Data.List\nData.List.nub :: Eq a => [a] -> [a]\nData.List.Unique.unique :: Ord a => [a] -> [a]\n\n", "explain": "O(n ln(n)).  Requires there is a partial ordering of elements.\nO(n ln(n)).  Retains original order.  Requires there is a partial ordering of elements.\nO(n^2).  Retains original order.  Only requires that elements can be compared for equality.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Scheme", "code": "\n(define (remove-duplicates l)\n  (cond ((null? l)\n         '())\n        ((member (car l) (cdr l))\n         (remove-duplicates (cdr l)))\n        (else\n         (cons (car l) (remove-duplicates (cdr l))))))\n\n(remove-duplicates '(1 2 1 3 2 4 5))\n(1 3 2 4 5)\n\n(define (remove-duplicates l)\n  (do ((a '() (if (member (car l) a) a (cons (car l) a)))\n       (l l (cdr l)))\n    ((null? l) (reverse a))))\n\n(remove-duplicates '(1 2 1 3 2 4 5))\n(1 2 3 4 5)\n\n", "explain": "Alternative approach:\nThe function 'delete-duplicates' is also available in srfi-1.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "PowerShell", "code": "\n\n$data = 1,2,3,1,2,3,4,1\n\n$h = @{}\nforeach ($x in $data) {\n    $h[$x] = 1\n}\n$h.Keys\n\n$data | Sort-Object -Unique\n\n$data | Select-Object -Unique\n", "explain": "The common array for both approaches:\nUsing a hash table to remove duplicates:\nSorting and removing duplicates along the way can be done with the Sort-Object cmdlet.\nRemoving duplicates without sorting can be done with the Select-Object cmdlet.\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Logo", "code": "\nWorks with: UCB Logo\nshow remdup [1 2 3 a b c 2 3 4 b c d]  \u00a0; [1 a 2 3 4 b c d]\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "F#", "code": "\n\nset [|1;2;3;2;3;4|]\n\n\nval it : Set<int> = seq [1; 2; 3; 4]\n\n", "explain": "The simplest way is to build a set from the given array (this actually works for any enumerable input sequence type, not just arrays):\ngives:\n"}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "Groovy", "code": "\ndef list = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nassert list.size() == 12\nprintln \"             Original List: ${list}\"\n\n// Filtering the List (non-mutating)\ndef list2 = list.unique(false)\nassert list2.size() == 8\nassert list.size() == 12\nprintln \"             Filtered List: ${list2}\"\n\n// Filtering the List (in place)\nlist.unique()\nassert list.size() == 8\nprintln \"   Original List, filtered: ${list}\"\n\ndef list3 = [1, 2, 3, 'a', 'b', 'c', 2, 3, 4, 'b', 'c', 'd']\nassert list3.size() == 12\n\n// Converting to Set\ndef set = list as Set\nassert set.size() == 8\nprintln \"                       Set: ${set}\"\n\n\nOutput:\n             Original List: [1, 2, 3, a, b, c, 2, 3, 4, b, c, d]\n             Filtered List: [1, 2, 3, a, b, c, 4, d]\n   Original List, filtered: [1, 2, 3, a, b, c, 4, d]\n                       Set: [1, 2, 3, a, b, c, 4, d]\n", "explain": ""}, {"task_name": "Remove duplicate elements", "task_url": "https://rosettacode.org/wiki/Remove_duplicate_elements", "task_cat": "Sorting", "lang": "AWK", "code": "\n\n$ awk 'BEGIN{split(\"a b c d c b a\",a);for(i in a)b[a[i]]=1;r=\"\";for(i in b)r=r\" \"i;print r}'\na b c d\n\n", "explain": "We produce an array a with duplicates from a string; \nthen index a second array b with the contents of a, \nso that duplicates make only one entry; \nthen produce a string with the keys of b, \nwhich is finally output.\n"}]