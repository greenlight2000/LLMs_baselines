[{"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nLibrary[edit]\nWorks with: Python version 2.6+, 3.x\nimport math\nmath.factorial(n)\nIterative[edit]\ndef factorial(n):\n    result = 1\n    for i in range(1, n+1):\n        result *= i\n    return result\nFunctional[edit]\nfrom operator import mul\nfrom functools import reduce\n\ndef factorial(n):\n    return reduce(mul, range(1,n+1), 1)\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n# factorial\u00a0:: Integer\ndef factorial(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )[-1]\n\nfrom itertools import (accumulate, chain)\nfrom operator import mul\n\n\n# factorials\u00a0:: [Integer]\ndef factorials(n):\n    return list(\n        accumulate(chain([1], range(1, 1 + n)), mul)\n    )\n\nprint(factorials(5))\n\n# -> [1, 1, 2, 6, 24, 120]\n\nfrom numpy import prod\n\ndef factorial(n):\n    return prod(range(1, n + 1), dtype=int)\nRecursive[edit]\ndef factorial(n):\n    z=1\n    if n>1:\n        z=n*factorial(n-1)\n    return z\n\nOutput:\n>>> for i in range(6):\n    print(i, factorial(i))\n   \n0 1\n1 1\n2 2\n3 6\n4 24\n5 120\n>>>\n\ndef factorial(n):\n    return n * factorial(n - 1) if n else 1\nNumerical Approximation[edit]\n\nfrom cmath import *\n\n# Coefficients used by the GNU Scientific Library\ng = 7\np = [0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n     771.32342877765313, -176.61502916214059, 12.507343278686905,\n     -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7]\n\ndef gamma(z):\n  z = complex(z)\n  # Reflection formula\n  if z.real < 0.5:\n    return pi / (sin(pi*z)*gamma(1-z))\n  else:\n    z -= 1\n    x = p[0]\n    for i in range(1, g+2):\n      x += p[i]/(z+i)\n    t = z + g + 0.5\n    return sqrt(2*pi) * t**(z+0.5) * exp(-t) * x\n\ndef factorial(n):\n  return gamma(n+1)\n\nprint \"factorial(-0.5)**2=\",factorial(-0.5)**2\nfor i in range(10):\n  print \"factorial(%d)=%s\"%(i,factorial(i))\n\nOutput:\nfactorial(-0.5)**2= (3.14159265359+0j)\nfactorial(0)=(1+0j)\nfactorial(1)=(1+0j)\nfactorial(2)=(2+0j)\nfactorial(3)=(6+0j)\nfactorial(4)=(24+0j)\nfactorial(5)=(120+0j)\nfactorial(6)=(720+0j)\nfactorial(7)=(5040+0j)\nfactorial(8)=(40320+0j)\nfactorial(9)=(362880+0j)\n\n", "explain": "or\nor including the sequence that got us there:\nor\nor\nThe following sample uses Lanczos approximation from wp:Lanczos_approximation to approximate the gamma function.\nThe gamma function \u0393(x) extends the domain of the factorial function, while maintaining the relationship that factorial(x) = \u0393(x+1).\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\nIterative[edit]\nint factorial(int n) {\n    int result = 1;\n    for (int i = 1; i <= n; ++i)\n        result *= i;\n    return result;\n}\n\n\nint factorialSafe(int n) {\n    int result = 1;\n    if(n<0)\n        return -1;\n    for (int i = 1; i <= n; ++i)\n        result *= i;\n    return result;\n}\n\nRecursive[edit]\nint factorial(int n) {\n    return n == 0 ? 1 : n * factorial(n - 1);\n}\n\n\nint factorialSafe(int n) {\n    return n<0 ? -1 : n == 0 ? 1 : n * factorialSafe(n - 1);\n}\n\nTail Recursive[edit]\n\nint fac_aux(int n, int acc) {\n    return n < 1 ? acc : fac_aux(n - 1, acc * n);\n}\n\nint fac_auxSafe(int n, int acc) {\n    return n<0 ? -1 : n < 1 ? acc : fac_aux(n - 1, acc * n);\n}\n\nint factorial(int n) {\n    return fac_aux(n, 1);\n}\n\nObfuscated[edit]\n\n#include <stdio.h>\n\n#define l11l 0xFFFF\n#define ll1 for\n#define ll111 if\n#define l1l1 unsigned\n#define l111 struct\n#define lll11 short\n#define ll11l long\n#define ll1ll putchar\n#define l1l1l(l) l=malloc(sizeof(l111 llll1));l->lll1l=1-1;l->ll1l1=1-1;\n#define l1ll1 *lllll++=l1ll%10000;l1ll/=10000;\n#define l1lll ll111(!l1->lll1l){l1l1l(l1->lll1l);l1->lll1l->ll1l1=l1;}\\\nlllll=(l1=l1->lll1l)->lll;ll=1-1;\n#define llll 1000\n\n\n\n\n                                                     l111 llll1 {\n                                                     l111 llll1 *\n      lll1l,*ll1l1        ;l1l1                      lll11 lll [\n      llll];};main      (){l111 llll1                *ll11,*l1l,*\n      l1, *ll1l, *    malloc ( ) ; l1l1              ll11l l1ll ;\n      ll11l l11,ll  ,l;l1l1 lll11 *lll1,*            lllll; ll1(l\n      =1-1 ;l< 14; ll1ll(\"\\t\\\"8)>l\\\"9!.)>vl\"         [l]^'L'),++l\n      );scanf(\"%d\",&l);l1l1l(l1l) l1l1l(ll11         ) (l1=l1l)->\n      lll[l1l->lll[1-1]     =1]=l11l;ll1(l11         =1+1;l11<=l;\n      ++l11){l1=ll11;         lll1 = (ll1l=(         ll11=l1l))->\n      lll; lllll =(            l1l=l1)->lll;         ll=(l1ll=1-1\n      );ll1(;ll1l->             lll1l||l11l!=        *lll1;){l1ll\n      +=l11**lll1++             ;l1ll1 ll111         (++ll>llll){\n      l1lll lll1=(              ll1l =ll1l->         lll1l)->lll;\n      }}ll1(;l1ll;              ){l1ll1 ll111        (++ll>=llll)\n      { l1lll} } *              lllll=l11l;}\n      ll1(l=(ll=1-              1);(l<llll)&&\n      (l1->lll[ l]              !=l11l);++l);        ll1 (;l1;l1=\n      l1->ll1l1,l=              llll){ll1(--l        ;l>=1-1;--l,\n      ++ll)printf(              (ll)?((ll%19)        ?\"%04d\":(ll=\n      19,\"\\n%04d\")              ):\"%4d\",l1->         lll[l] ) ; }\n                                                     ll1ll(10); }\n\n", "explain": "Handle negative n (returning -1)\nHandle negative n (returning -1).\nSafe with some compilers (for example: GCC with -O2, LLVM's clang)\nThis is simply beautiful, 1995 IOCCC winning entry by Michael Savastio, largest factorial possible\u00a0: 429539!\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <boost/iterator/counting_iterator.hpp>\n#include <algorithm>\n\nint factorial(int n)\n{\n  // last is one-past-end\n  return std::accumulate(boost::counting_iterator<int>(1), boost::counting_iterator<int>(n+1), 1, std::multiplies<int>());\n}\n\nIterative[edit]\n\n//iteration with while\nlong long int factorial(long long int n)\n{ \n   long long int r = 1;\n   while(1<n) \n       r *= n--;\n   return r;\n}\n\nTemplate[edit]\ntemplate <int N>\nstruct Factorial \n{\n    enum { value = N * Factorial<N - 1>::value };\n};\n \ntemplate <>\nstruct Factorial<0> \n{\n    enum { value = 1 };\n};\n \n// Factorial<4>::value == 24\n// Factorial<0>::value == 1\nvoid foo()\n{\n    int x = Factorial<4>::value; // == 24\n    int y = Factorial<0>::value; // == 1\n}\n\nCompare all Solutions (except the meta)[edit]\n#include <algorithm>\n#include <chrono>\n#include <iostream>\n#include <numeric>\n#include <vector>\n#include <boost/iterator/counting_iterator.hpp>\n\nusing ulli = unsigned long long int;\n\n// bad style do-while and wrong for Factorial1(0LL) -> 0\u00a0!!!\nulli Factorial1(ulli m_nValue) {\n    ulli result = m_nValue;\n    ulli result_next;\n    ulli pc = m_nValue;\n    do {\n        result_next = result * (pc - 1);\n        result = result_next;\n        pc--;\n    } while (pc > 2);\n    return result;\n}\n\n// iteration with while\nulli Factorial2(ulli n) {\n    ulli r = 1;\n    while (1 < n)\n        r *= n--;\n    return r;\n}\n\n// recursive\nulli Factorial3(ulli n) {\n    return n < 2 ? 1 : n * Factorial3(n - 1);\n}\n\n// tail recursive\ninline ulli _fac_aux(ulli n, ulli acc) {\n    return n < 1 ? acc : _fac_aux(n - 1, acc * n);\n}\nulli Factorial4(ulli n) {\n    return _fac_aux(n, 1);\n}\n\n// accumulate with functor\nulli Factorial5(ulli n) {\n    // last is one-past-end\n    return std::accumulate(boost::counting_iterator<ulli>(1ULL),\n                           boost::counting_iterator<ulli>(n + 1ULL), 1ULL,\n                           std::multiplies<ulli>());\n}\n\n// accumulate with lambda\nulli Factorial6(ulli n) {\n    // last is one-past-end\n    return std::accumulate(boost::counting_iterator<ulli>(1ULL),\n                           boost::counting_iterator<ulli>(n + 1ULL), 1ULL,\n                           [](ulli a, ulli b) { return a * b; });\n}\n\nint main() {\n    ulli v = 20; // max value with unsigned long long int\n    ulli result;\n    std::cout << std::fixed;\n    using duration = std::chrono::duration<double, std::micro>;\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial1(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"do-while(1)               result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial2(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"while(2)                  result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial3(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"recursive(3)              result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial3(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"tail recursive(4)         result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial5(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"std::accumulate(5)        result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n\n    {\n        auto t1 = std::chrono::high_resolution_clock::now();\n        result = Factorial6(v);\n        auto t2 = std::chrono::high_resolution_clock::now();\n        std::cout << \"std::accumulate lambda(6) result \" << result << \" took \" << duration(t2 - t1).count() << \" \u00b5s\\n\";\n    }\n}\n\ndo-while(1)               result 2432902008176640000 took 0.110000 \u00b5s\nwhile(2)                  result 2432902008176640000 took 0.078000 \u00b5s\nrecursive(3)              result 2432902008176640000 took 0.057000 \u00b5s\ntail recursive(4)         result 2432902008176640000 took 0.056000 \u00b5s\nstd::accumulate(5)        result 2432902008176640000 took 0.056000 \u00b5s\nstd::accumulate lambda(6) result 2432902008176640000 took 0.079000 \u00b5s\n\n", "explain": "The C versions work unchanged with C++, however, here is another possibility using the STL and boost:\nThis version of the program is iterative, with a while loop.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nIterative[edit]\npackage programas;\n\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class IterativeFactorial {\n\n  public BigInteger factorial(BigInteger n) {\n    if ( n == null ) {\n      throw new IllegalArgumentException();\n    }\n    else if ( n.signum() == - 1 ) {\n      // negative\n      throw new IllegalArgumentException(\"Argument must be a non-negative integer\");\n    }\n    else {\n      BigInteger factorial = BigInteger.ONE;\n      for ( BigInteger i = BigInteger.ONE; i.compareTo(n) < 1; i = i.add(BigInteger.ONE) ) {\n        factorial = factorial.multiply(i);\n      }\n      return factorial;\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    BigInteger number, result;\n    boolean error = false;\n    System.out.println(\"FACTORIAL OF A NUMBER\");\n    do {\n      System.out.println(\"Enter a number:\");\n      try {\n        number = scanner.nextBigInteger();\n        result = new IterativeFactorial().factorial(number);\n        error = false;\n        System.out.println(\"Factorial of \" + number + \": \" + result);\n      }\n      catch ( InputMismatchException e ) {\n        error = true;\n        scanner.nextLine();\n      }\n\n      catch ( IllegalArgumentException e ) {\n        error = true;\n        scanner.nextLine();\n      }\n    }\n    while ( error );\n    scanner.close();\n  }\n\n}\nRecursive[edit]\npackage programas;\n\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class RecursiveFactorial {\n\n  public BigInteger factorial(BigInteger n) {\n    if ( n == null ) {\n      throw new IllegalArgumentException();\n    }\n\n    else if ( n.equals(BigInteger.ZERO) ) {\n      return BigInteger.ONE;\n    }\n    else if ( n.signum() == - 1 ) {\n      // negative\n      throw new IllegalArgumentException(\"Argument must be a non-negative integer\");\n    }\n    else {\n      return n.equals(BigInteger.ONE)\n         \u00a0? BigInteger.ONE\n         \u00a0: factorial(n.subtract(BigInteger.ONE)).multiply(n);\n    }\n  }\n\n  public static void main(String[] args) {\n    Scanner scanner = new Scanner(System.in);\n    BigInteger number, result;\n    boolean error = false;\n    System.out.println(\"FACTORIAL OF A NUMBER\");\n    do {\n      System.out.println(\"Enter a number:\");\n      try {\n        number = scanner.nextBigInteger();\n        result = new RecursiveFactorial().factorial(number);\n        error = false;\n        System.out.println(\"Factorial of \" + number + \": \" + result);\n      }\n      catch ( InputMismatchException e ) {\n        error = true;\n        scanner.nextLine();\n      }\n\n      catch ( IllegalArgumentException e ) {\n        error = true;\n        scanner.nextLine();\n      }\n    }\n    while ( error );\n    scanner.close();\n\n  }\n\n}\nSimplified and Combined Version[edit]\nimport java.math.BigInteger;\nimport java.util.InputMismatchException;\nimport java.util.Scanner;\n\npublic class LargeFactorial {\n    public static long userInput;\n    public static void main(String[]args){\n        Scanner input = new Scanner(System.in);\n        System.out.println(\"Input factorial integer base: \");\n        try {\n            userInput = input.nextLong();\n            System.out.println(userInput + \"! is\\n\" + factorial(userInput) + \" using standard factorial method.\");\n            System.out.println(userInput + \"! is\\n\" + factorialRec(userInput) + \" using recursion method.\");\n        }catch(InputMismatchException x){\n            System.out.println(\"Please give integral numbers.\");\n        }catch(StackOverflowError ex){\n            if(userInput > 0) {\n                System.out.println(\"Number too big.\");\n            }else{\n                System.out.println(\"Please give non-negative(positive) numbers.\");\n            }\n        }finally {\n            System.exit(0);\n        }\n    }\n    public static BigInteger factorialRec(long n){\n        BigInteger result = BigInteger.ONE;\n        return n == 0\u00a0? result\u00a0: result.multiply(BigInteger.valueOf(n)).multiply(factorial(n-1));\n    }\n    public static BigInteger factorial(long n){\n        BigInteger result = BigInteger.ONE;\n        for(int i = 1; i <= n; i++){\n            result = result.multiply(BigInteger.valueOf(i));\n        }\n        return result;\n    }\n}\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nIterative[edit]\nusing System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        var accumulator = 1;\n        for (var factor = 1; factor <= number; factor++)\n        {\n            accumulator *= factor;\n        }\n        return accumulator;\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n\nRecursive[edit]\nusing System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        return number == 0 ? 1 : number * Factorial(number - 1);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n\nTail Recursive[edit]\nusing System;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n\n        return Factorial(number, 1);\n    }\n\n    static int Factorial(int number, int accumulator)\n    {\n        if(number < 0) \n            throw new ArgumentOutOfRangeException(nameof(number), number, \"Must be zero or a positive number.\");\n        if(accumulator < 1) \n            throw new ArgumentOutOfRangeException(nameof(accumulator), accumulator, \"Must be a positive number.\");\n\n        return number == 0 ? accumulator : Factorial(number - 1, number * accumulator);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n\nFunctional[edit]\nusing System;\nusing System.Linq;\n\nclass Program\n{\n    static int Factorial(int number)\n    {\n        return Enumerable.Range(1, number).Aggregate((accumulator, factor) => accumulator * factor);\n    }\n\n    static void Main()\n    {\n        Console.WriteLine(Factorial(10));\n    }\n}\n\nArbitrary Precision[edit]\nLibrary: System.Numerics\n\nusing System;\nusing System.Numerics;\nusing System.Linq; \nclass Program\n{\n    static BigInteger factorial(int n) // iterative\n    {\n        BigInteger acc = 1; for (int i = 1; i <= n; i++) acc *= i; return acc;\n    }\n\n    static public BigInteger Factorial(int number) // functional\n    {\n        return Enumerable.Range(1, number).Aggregate(new BigInteger(1), (acc, num) => acc * num);\n    }\n\n    static public BI FactorialQ(int number) // functional quick, uses prodtree method\n    {\n        var s = Enumerable.Range(1, number).Select(num => new BI(num)).ToArray();\n        int top = s.Length, nt, i, j;\n        while (top > 1) {\n            for (i = 0, j = top, nt = top >> 1; i < nt; i++) s[i] *= s[--j];\n            top = nt + ((top & 1) == 1 ? 1 : 0);\n        }\n        return s[0];\n    }\n\n    static void Main(string[] args)\n    {\n        Console.WriteLine(Factorial(250));\n    }\n}\n\n\nOutput:\n3232856260909107732320814552024368470994843717673780666747942427112823747555111209488817915371028199450928507353189432926730931712808990822791030279071281921676527240189264733218041186261006832925365133678939089569935713530175040513178760077247933065402339006164825552248819436572586057399222641254832982204849137721776650641276858807153128978777672951913990844377478702589172973255150283241787320658188482062478582659808848825548800000000000000000000000000000000000000000000000000000000000000\n", "explain": "Factorial() can calculate 200000! in around 40 seconds over at Tio.run.\nFactorialQ() can calculate 1000000! in around 40 seconds over at Tio.run.\nThe \"product tree\" algorithm multiplies pairs of items on a list until there is only one item. Even though around the same number of multiply operations occurs (compared to the plain \"accumulator\" method), this is faster because the \"bigger\" numbers are generated near the end of the algorithm, instead of around halfway through.  There is a significant space overhead incurred due to the creation of the temporary array to hold the partial results.  The additional time overhead for array creation is negligible compared with the time savings of not dealing with the very large numbers until near the end of the algorithm.\nFor example, for 50!, here are the number of digits created for each product for either method:\nplain:\n1 1 1 2 3 3 4 5 6 7 8 9 10 11 13 14 15 16 18 19 20 22 23 24 26 27 29 30 31 33 34 36 37 39 41 42 44 45 47 48 50 52 53 55 57 58 60 62 63 65\nproduct tree:\n2 2 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 3 5 5 5 6 6 6 6 6 6 6 6 6 8 11 11 11 11 11 13 21 21 23 42 65\nOne can see the plain method increases linearly up to the final value of 65.  The product tree method stays low for quite awhile, then jumps up at the end.\nFor 200000!, when one sums up the number of digits of each product for all 199999 multiplications, the plain method is nearly 93 billion, while the product tree method is only about 17.3 million.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nIterative[edit]\nfunction factorial(n) {\n  //check our edge case\n  if (n < 0) { throw \"Number must be non-negative\"; }\n\n  var result = 1;\n  //we skip zero and one since both are 1 and are identity\n  while (n > 1) {\n    result *= n;\n    n--;\n  }\n  return result;\n}\nRecursive[edit]\nES5 (memoized )[edit]\n(function(x) {\n\n  var memo = {};\n\n  function factorial(n) {\n    return n < 2\u00a0? 1\u00a0: memo[n] || (memo[n] = n * factorial(n - 1));\n  }\n  \n  return factorial(x);\n  \n})(18);\n\nOutput:\n6402373705728000\n\n(function () {\n    'use strict';\n\n    // factorial\u00a0:: Int -> Int\n    function factorial(x) {\n\n        return range(1, x)\n            .reduce(function (a, b) {\n                return a * b;\n            }, 1);\n    }\n\n\n\n    // range\u00a0:: Int -> Int -> [Int]\n    function range(m, n) {\n        var a = Array(n - m + 1),\n            i = n + 1;\n\n        while (i-- > m) a[i - m] = i;\n        return a;\n    }\n\n\n    return factorial(18);\n\n})();\n\nOutput:\n6402373705728000\n\nES6[edit]\nvar factorial = n => (n < 2)\u00a0? 1\u00a0: n * factorial(n - 1);\n\n(() => {\n    'use strict';\n\n    // factorial\u00a0:: Int -> Int\n    const factorial = n =>\n        enumFromTo(1, n)\n        .reduce(product, 1);\n\n\n    const test = () =>\n        factorial(18);\n    // --> 6402373705728000\n\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // product\u00a0:: Num -> Num -> Num\n    const product = (a, b) => a * b;\n\n    // range\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = (m, n) =>\n        Array.from({\n            length: (n - m) + 1\n        }, (_, i) => m + i);\n\n    // MAIN ------\n    return test();\n})();\n\nOutput:\n6402373705728000\n\n<html>\n\n  <body>\n\n    <button onclick=\"incrementFact()\">Factorial</button>\n    <p id=\"FactArray\"></p>\n    <p id=\"Factorial\"></p>\n    <br>\n    \n  </body>\n\n</html>\n\n<input id=\"userInput\" value=\"\">\n<br>\n<button onclick=\"singleFact()\">Single Value Factorial</button>\n<p id=\"SingleFactArray\"></p>\n<p id=\"SingleFactorial\"></p>\n\n\n<script>\n  function mathFact(total, sum) {\n    return total * sum;\n  }\n\n  var incNumbers = [1];\n\n  function incrementFact() {\n    var n = incNumbers.pop();\n    incNumbers.push(n);\n    incNumbers.push(n + 1);\n    document.getElementById(\"FactArray\").innerHTML = incNumbers;\n    document.getElementById(\"Factorial\").innerHTML = incNumbers.reduceRight(mathFact);\n\n  }\n\n  var singleNum = [];\n\n  function singleFact() {\n    var x = document.getElementById(\"userInput\").value;\n    for (i = 0; i < x; i++) {\n      singleNum.push(i + 1);\n      document.getElementById(\"SingleFactArray\").innerHTML = singleNum;\n    }\n    document.getElementById(\"SingleFactorial\").innerHTML = singleNum.reduceRight(mathFact);\n    singleNum = [];\n  }\n\n</script>\n", "explain": "Or, assuming that we have some sort of integer range function, we can memoize using the accumulator of a fold/reduce:\n\n\nOr, as an alternative to recursion, we can fold/reduce a product function over the range of integers 1..n\n\nThe first part outputs the factorial for every addition to the array and the second part calculates factorial from a single number.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nIterative[edit]\n<?php\nfunction factorial($n) {\n  if ($n < 0) {\n    return 0;\n  }\n\n  $factorial = 1;\n  for ($i = $n; $i >= 1; $i--) {\n    $factorial = $factorial * $i;\n  }\n\n  return $factorial;\n}\n?>\nRecursive[edit]\n<?php\nfunction factorial($n) {\n  if ($n < 0) {\n    return 0;\n  }\n\n  if ($n == 0) {\n    return 1;\n  }\n\n  else {\n    return $n * factorial($n-1);\n  }\n}\n?>\nOne-Liner[edit]\n<?php\nfunction factorial($n) { return $n == 0\u00a0? 1\u00a0: array_product(range(1, $n)); }\n?>\nLibrary[edit]\n\ngmp_fact($n)\n", "explain": "Requires the GMP library to be compiled in:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\nBuilt-in[edit]\n\nanswer = factorial(N)\nRecursive[edit]\nfunction f=fac(n)\n    if n==0\n        f=1;\n        return\n    else\n        f=n*fac(n-1);\n    end\nIterative[edit]\n\n  function b=factorial(a)\n\tb=1;\t\n\tfor i=1:a\t\n\t    b=b*i;\n\tend\n", "explain": "The factorial function is built-in to MATLAB. The built-in function is only accurate for N <= 21 due to the precision limitations of floating point numbers. \nA possible iterative solution:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nFortran 90[edit]\n\nnfactorial = PRODUCT((/(i, i=1,n)/))\n\nINTEGER RECURSIVE FUNCTION RECURSIVE_FACTORIAL(X) RESULT(ANS)\n    INTEGER, INTENT(IN)\u00a0:: X\n\n    IF (X <= 1) THEN\n        ANS = 1\n    ELSE\n        ANS = X * RECURSIVE_FACTORIAL(X-1)\n    END IF\n\nEND FUNCTION RECURSIVE_FACTORIAL\nFORTRAN 77[edit]\n      INTEGER FUNCTION MFACT(N)\n      INTEGER N,I,FACT\n      FACT=1\n      IF (N.EQ.0) GOTO 20\n      DO 10 I=1,N\n        FACT=FACT*I\n10    CONTINUE\n20    CONTINUE\n      MFACT = FACT\n      RETURN\n      END\n", "explain": "A simple one-liner is sufficient.\nRecursive functions were added in Fortran 90, allowing the following:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\nIterative[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc main() {\n    fmt.Println(factorial(800))\n}\n\nfunc factorial(n int64) *big.Int {\n    if n < 0 {\n        return nil\n    }\n    r\u00a0:= big.NewInt(1)\n    var f big.Int\n    for i\u00a0:= int64(2); i <= n; i++ {\n        r.Mul(r, f.SetInt64(i))\n    }\n    return r\n}\nBuilt in, exact[edit]\n\npackage main\n\nimport (\n    \"math/big\"\n    \"fmt\"\n)\n\nfunc factorial(n int64) *big.Int {\n    var z big.Int\n    return z.MulRange(1, n)\n}\n\nfunc main() {\n    fmt.Println(factorial(800))\n}\nEfficient exact[edit]\n\nBuilt in, Gamma[edit]\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n)\n\nfunc factorial(n float64) float64 {\n    return math.Gamma(n + 1)\n}\n\nfunc main() {\n    for i\u00a0:= 0.; i <= 10; i++ {\n        fmt.Println(i, factorial(i))\n    }\n    fmt.Println(100, factorial(100))\n}\n\nOutput:\n0 1\n1 1\n2 2\n3 6\n4 24\n5 120\n6 720\n7 5040\n8 40320\n9 362880\n10 3.6288e+06\n100 9.332621544394405e+157\n\nBuilt in, Lgamma[edit]\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/big\"\n)\n\nfunc lfactorial(n float64) float64 {\n    l, _\u00a0:= math.Lgamma(n + 1)\n    return l\n}\n\nfunc factorial(n float64) *big.Float {\n    i, frac\u00a0:= math.Modf(lfactorial(n) * math.Log2E)\n    z\u00a0:= big.NewFloat(math.Exp2(frac))\n    return z.SetMantExp(z, int(i))\n}\n\nfunc main() {\n    for i\u00a0:= 0.; i <= 10; i++ {\n        fmt.Println(i, factorial(i))\n    }\n    fmt.Println(100, factorial(100))\n    fmt.Println(800, factorial(800))\n}\n\nOutput:\n0 1\n1 1\n2 2\n3 6\n4 24\n5 119.99999999999994\n6 720.0000000000005\n7 5039.99999999999\n8 40320.000000000015\n9 362880.0000000001\n10 3.6288000000000084e+06\n100 9.332621544394454e+157\n800 7.710530113351238e+1976\n\n", "explain": "Sequential, but at least handling big numbers:\nBuilt in function currently uses a simple divide and conquer technique.  It's a step up from sequential multiplication.\nFor a bigger step up, an algorithm fast enough to compute factorials of numbers up to a million or so, see Factorial/Go.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program factorial.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessLargeNumber:   .asciz \"Number N to large. \\n\"\nszMessNegNumber:      .asciz \"Number N is negative. \\n\"\n\nszMessResult:  .ascii \"Resultat = \"      @ message result\nsMessValeur:   .fill 12, 1, ' '\n                   .asciz \"\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                @ entry of program \n    push {fp,lr}      @ saves 2 registers \n\n    mov r0,#-5\n    bl factorial\n    mov r0,#10\n    bl factorial\n    mov r0,#20\n    bl factorial\n\n\n100:   @ standard end of the program \n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\n\n\n/********************************************/\n/*     calculation                         */\n/********************************************/\n/* r0 contains number N */\nfactorial:\n    push {r1,r2,lr}    \t@ save  registres \n    cmp r0,#0\n    blt 99f\n    beq 100f\n    cmp r0,#1\n    beq 100f\n    bl calFactorial\n    cmp r0,#-1          @ overflow\u00a0?\n    beq 98f\n    ldr r1,iAdrsMessValeur                \n    bl conversion10       @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    b 100f\n\n98:   @ display error message\n    ldr r0,iAdrszMessLargeNumber\n    bl affichageMess\n    b 100f\n99:  @ display error message\n    ldr r0,iAdrszMessNegNumber\n    bl affichageMess\n\n100:\n    pop {r1,r2,lr}    \t\t\t@ restaur registers \n    bx lr\t        \t\t\t@ return  \niAdrszMessNegNumber:       .int szMessNegNumber\niAdrszMessLargeNumber:\t    .int szMessLargeNumber\niAdrsMessValeur:            .int sMessValeur\t\niAdrszMessResult:          .int szMessResult\n/******************************************************************/\n/*     calculation                         */ \n/******************************************************************/\n/* r0 contains the number N */\ncalFactorial:\n    cmp r0,#1          @ N = 1\u00a0?\n    bxeq lr           @ yes -> return \n    push {fp,lr}    \t\t@ save  registers \n    sub sp,#4           @ 4 byte on the stack \n    mov fp,sp           @ fp <- start address stack\n    str r0,[fp]                    @ fp contains  N\n    sub r0,#1          @ call function with N - 1\n    bl calFactorial\n    cmp r0,#-1         @ error overflow\u00a0?\n    beq 100f         @ yes -> return\n    ldr r1,[fp]       @ load N\n    umull r0,r2,r1,r0   @ multiply result by N \n    cmp r2,#0           @ r2 is the hi rd  if <> 0 overflow\n    movne r0,#-1      @ if overflow  -1 -> r0\n\n100:\n    add sp,#4            @ free 4 bytes on stack\n    pop {fp,lr}    \t\t\t@ restau2 registers \n    bx lr\t        \t\t@ return  \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n/******************************************************************/\n/*     Converting a register to a decimal                                 */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\nconversion10:\n    push {r1-r4,lr}    /* save registers */ \n    mov r3,r1\n    mov r2,#10\n\n1:\t   @ start loop\n    bl divisionpar10 @ r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48        @ digit\t\n    strb r1,[r3,r2]  @ store digit on area\n    sub r2,#1         @ previous position\n    cmp r0,#0         @ stop if quotient = 0 */\n    bne 1b\t          @ else loop\n    @ and move spaves in first on area\n    mov r1,#' '   @ space\t\n2:\t\n    strb r1,[r3,r2]  @ store space in area\n    subs r2,#1       @ @ previous position\n    bge 2b           @ loop if r2 >= z\u00e9ro \n\n100:\t\n    pop {r1-r4,lr}    @ restaur registres \n    bx lr\t          @return\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n   push {r2-r4}   /* save registers  */\n   mov r4,r0 \n   ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n   smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n   mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n   mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n   add r0, r2, r1         /* r0 <- r2 + r1 */\n   add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n   sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n   pop {r2-r4}\n   bx lr                  /* leave function */\n   .align 4\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "MIPS_Assembly", "code": "\nIterative[edit]\n##################################\n# Factorial; iterative           #\n# By Keith Stellyes\u00a0:)           #\n# Targets Mars implementation    #\n# August 24, 2016                #\n##################################\n\n# This example reads an integer from user, stores in register a1\n# Then, it uses a0 as a multiplier and target, it is set to 1\n\n# Pseudocode:\n# a0 = 1\n# a1 = read_int_from_user()\n# while(a1 > 1)\n# {\n# a0 = a0*a1\n# DECREMENT a1\n# }\n# print(a0)\n\n.text ### PROGRAM BEGIN ###\n\t### GET INTEGER FROM USER ###\n\tli $v0, 5 #set syscall arg to READ_INTEGER\n\tsyscall #make the syscall\n\tmove $a1, $v0 #int from READ_INTEGER is returned in $v0, but we need $v0\n\t              #this will be used as a counter\n\n\t### SET $a1 TO INITAL VALUE OF 1 AS MULTIPLIER ###\n\tli $a0,1\n\n\t### Multiply our multiplier, $a1 by our counter, $a0 then store in $a1 ###\nloop:\tble $a1,1,exit # If the counter is greater than 1, go back to start\n\tmul $a0,$a0,$a1 #a1 = a1*a0\n\n\tsubi $a1,$a1,1 # Decrement counter\n\t\n\tj loop # Go back to start\n\t\nexit: \n\t### PRINT RESULT ###\n\tli $v0,1 #set syscall arg to PRINT_INTEGER\n\t#NOTE: syscall 1 (PRINT_INTEGER) takes a0 as its argument. Conveniently, that\n\t#      is our result. \n\tsyscall  #make the syscall\n\n\t#exit\n\tli $v0, 10 #set syscall arg to EXIT\n\tsyscall #make the syscall\nRecursive[edit]\n#reference code\n#int factorialRec(int n){\n#    if(n<2){return 1;}\n#    else{ return n*factorial(n-1);}\n#}\n.data\n\tn:\t.word 5\n\tresult:\t.word\n.text\nmain:\n\tla\t$t0, n\n\tlw\t$a0, 0($t0)\n\tjal\tfactorialRec\n\tla\t$t0, result\n\tsw\t$v0, 0($t0)\n\taddi\t$v0, $0, 10\n\tsyscall\t\n\t\nfactorialRec:\n\taddi\t$sp, $sp, -8\t#calling convention\n\tsw\t$a0, 0($sp)\n\tsw\t$ra, 4($sp)\n\t\n\taddi\t$t0, $0, 2\t#if (n < 2) do return 1 \n\tslt\t$t0, $a0, $t0\t#else return n*factorialRec(n-1)\n\tbeqz\t$t0, anotherCall\n\t\n\tlw\t$ra, 4($sp)\t#recursive anchor\n\tlw\t$a0, 0($sp)\n\taddi\t$sp, $sp, 8\n\taddi\t$v0, $0, 1\n\tjr\t$ra\n\t\nanotherCall:\n\taddi\t$a0, $a0, -1\n\tjal\tfactorialRec\n\n\tlw\t$ra, 4($sp)\n\tlw\t$a0, 0($sp)\n\taddi\t$sp, $sp, 8\n\tmul\t$v0, $a0, $v0\n\tjr\t$ra\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nIterative[edit]\nprogram Factorial1;\n\n{$APPTYPE CONSOLE}\n\nfunction FactorialIterative(aNumber: Integer): Int64;\nvar\n  i: Integer;\nbegin\n  Result\u00a0:= 1;\n  for i\u00a0:= 1 to aNumber do\n    Result\u00a0:= i * Result;\nend;\n\nbegin\n  Writeln('5! = ', FactorialIterative(5));\nend.\nRecursive[edit]\nprogram Factorial2;\n\n{$APPTYPE CONSOLE}\n\nfunction FactorialRecursive(aNumber: Integer): Int64;\nbegin\n  if aNumber < 1 then\n    Result\u00a0:= 1\n  else\n    Result\u00a0:= aNumber * FactorialRecursive(aNumber - 1);\nend;\n\nbegin\n  Writeln('5! = ', FactorialRecursive(5));\nend.\nTail Recursive[edit]\nprogram Factorial3;\n\n{$APPTYPE CONSOLE}\n\nfunction FactorialTailRecursive(aNumber: Integer): Int64;\n\n  function FactorialHelper(aNumber: Integer; aAccumulator: Int64): Int64;\n  begin\n    if aNumber = 0 then\n      Result\u00a0:= aAccumulator\n    else\n      Result\u00a0:= FactorialHelper(aNumber - 1, aNumber * aAccumulator);\n    end;\n\nbegin\n  if aNumber < 1 then\n    Result\u00a0:= 1\n  else\n    Result\u00a0:= FactorialHelper(aNumber, 1);\nend;\n\nbegin\n  Writeln('5! = ', FactorialTailRecursive(5));\nend.\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\nWith large n, the recursion can overflow the call stack and raise a SystemStackError. So factorial_recursive(10000) might fail.\nMRI does not optimize tail recursion. So factorial_tail_recursive(10000) might also fail.\n# Recursive\ndef factorial_recursive(n)\n  n.zero?\u00a0? 1\u00a0: n * factorial_recursive(n - 1)\nend\n\n# Tail-recursive\ndef factorial_tail_recursive(n, prod = 1)\n  n.zero?\u00a0? prod\u00a0: factorial_tail_recursive(n - 1, prod * n)\nend\n\n# Iterative with Range#each\ndef factorial_iterative(n)\n  (2...n).each { |i| n *= i }\n  n.zero?\u00a0? 1\u00a0: n\nend\n\n# Iterative with Range#inject\ndef factorial_inject(n)\n  (1..n).inject(1){ |prod, i| prod * i }\nend\n\n# Iterative with Range#reduce, requires Ruby 1.8.7\ndef factorial_reduce(n)\n  (2..n).reduce(1,\u00a0:*)\nend\n\n\nrequire 'benchmark'\n\nn = 400\nm = 10000\n\nBenchmark.bm(16) do |b|\n  b.report('recursive:')       {m.times {factorial_recursive(n)}}\n  b.report('tail recursive:')  {m.times {factorial_tail_recursive(n)}}\n  b.report('iterative:')       {m.times {factorial_iterative(n)}}\n  b.report('inject:')          {m.times {factorial_inject(n)}}\n  b.report('reduce:')          {m.times {factorial_reduce(n)}}\nend\n\n\nOutput:\n                       user     system      total        real\nrecursive:         2.350000   0.260000   2.610000 (  2.610410)\ntail recursive:    2.710000   0.270000   2.980000 (  2.996830)\niterative:         2.250000   0.250000   2.500000 (  2.510037)\ninject:            2.500000   0.130000   2.630000 (  2.641898)\nreduce:            2.110000   0.230000   2.340000 (  2.338166)\n", "explain": "Beware of recursion! Iterative solutions are better for large n.\nThe benchmark depends on the Ruby implementation. \nWith MRI, #factorial_reduce seems slightly faster than others. \nThis might happen because (1..n).reduce(:*) loops through fast C code, and avoids interpreted Ruby code.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nfn factorial_recursive (n: u64) -> u64 {\n    match n {\n        0 => 1,\n        _ => n * factorial_recursive(n-1)\n    }\n}\n\nfn factorial_iterative(n: u64) -> u64 {\n    (1..=n).product()\n}\n\nfn main () {\n    for i in 1..10 {\n        println!(\"{}\", factorial_recursive(i))\n    }\n    for i in 1..10 {\n        println!(\"{}\", factorial_iterative(i))\n    }\n}\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nIterative[edit]\nfunc factorial(_ n: Int) -> Int {\n\treturn n < 2\u00a0? 1\u00a0: (2...n).reduce(1, *)\n}\nRecursive[edit]\nfunc factorial(_ n: Int) -> Int {\n\treturn n < 2\u00a0? 1\u00a0: n * factorial(n - 1)\n}\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nRecursive[edit]\nfact <- function(n) {\n  if (n <= 1) 1\n  else n * Recall(n - 1)\n}\nIterative[edit]\nfactIter <- function(n) {\n  f = 1\n  if (n > 1) {\n    for (i in 2:n) f <- f * i\n  }\n  f\n}\nNumerical Approximation[edit]\n\nprint(factorial(50)) # 3.041409e+64\n", "explain": "R has a native gamma function and a wrapper for that function that can produce factorials.  E.g.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\n\nIntrinsic Function[edit]\n\nMOVE FUNCTION FACTORIAL(num) TO result\n\nIterative[edit]\nWorks with: GnuCOBOL\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. factorial_iterative.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i      PIC 9(38).\n\n       LINKAGE SECTION.\n       01  n      PIC 9(38).\n       01  ret    PIC 9(38).\n\n       PROCEDURE DIVISION USING BY VALUE n RETURNING ret.\n           MOVE 1 TO ret\n \n           PERFORM VARYING i FROM 2 BY 1 UNTIL n < i\n               MULTIPLY i BY ret\n           END-PERFORM\n \n           GOBACK.\n\n       END FUNCTION factorial_iterative.\n\nRecursive[edit]\nWorks with: Visual COBOL\nWorks with: GnuCOBOL\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. factorial_recursive.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  prev-n PIC 9(38).\n\n       LINKAGE SECTION.\n       01  n      PIC 9(38).\n       01  ret    PIC 9(38).\n\n       PROCEDURE DIVISION USING BY VALUE n RETURNING ret.\n           IF n = 0\n               MOVE 1 TO ret\n           ELSE\n               SUBTRACT 1 FROM n GIVING prev-n\n               MULTIPLY n BY factorial_recursive(prev-n) GIVING ret\n           END-IF\n \n           GOBACK.\n\n       END FUNCTION factorial_recursive.\nTest[edit]\nWorks with: GnuCOBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. factorial_test.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION factorial_iterative\n           FUNCTION factorial_recursive.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i      PIC 9(38).\n\n       PROCEDURE DIVISION.\n           DISPLAY\n               \"i = \"\n               WITH NO ADVANCING\n           END-DISPLAY.\n           ACCEPT i END-ACCEPT.\n           DISPLAY SPACE END-DISPLAY.\n\n           DISPLAY\n               \"factorial_iterative(i) = \"\n               factorial_iterative(i)\n           END-DISPLAY.\n\n           DISPLAY\n               \"factorial_recursive(i) = \"\n               factorial_recursive(i)\n           END-DISPLAY.\n\n           GOBACK.\n\n       END PROGRAM factorial_test.\n\nOutput:\ni = 14\n\nfactorial_iterative(i) = 00000000000000000000000000087178291200\nfactorial_recursive(i) = 00000000000000000000000000087178291200\n\n", "explain": "The following functions have no need to check if their parameters are negative because they are unsigned.\nCOBOL includes an intrinsic function which returns the factorial of its argument.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nIterative[edit]\nfunction Factorial (N : Positive) return Positive is\n   Result : Positive := N;\n   Counter : Natural := N - 1;\nbegin\n   for I in reverse 1..Counter loop\n      Result := Result * I;\n   end loop;\n   return Result;\nend Factorial;\n\nRecursive[edit]\nfunction Factorial(N : Positive) return Positive is\n   Result : Positive := 1;\nbegin\n   if N > 1 then\n      Result := N * Factorial(N - 1);\n   end if;\n   return Result;\nend Factorial;\n\nNumerical Approximation[edit]\nwith Ada.Numerics.Generic_Complex_Types;\nwith Ada.Numerics.Generic_Complex_Elementary_Functions;\nwith Ada.Numerics.Generic_Elementary_Functions;\nwith Ada.Text_IO.Complex_Io;\nwith Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Factorial_Numeric_Approximation is\n   type Real is digits 15;\n   package Complex_Pck is new Ada.Numerics.Generic_Complex_Types(Real);\n   use Complex_Pck;\n   package Complex_Io is new Ada.Text_Io.Complex_Io(Complex_Pck);\n   use Complex_IO;\n   package Cmplx_Elem_Funcs is new Ada.Numerics.Generic_Complex_Elementary_Functions(Complex_Pck);\n   use Cmplx_Elem_Funcs;\n   \n   function Gamma(X : Complex) return Complex is\n      package Elem_Funcs is new Ada.Numerics.Generic_Elementary_Functions(Real);\n      use Elem_Funcs;\n      use Ada.Numerics;\n      -- Coefficients used by the GNU Scientific Library\n      G : Natural := 7;\n      P : constant array (Natural range 0..G + 1) of Real := (\n         0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n         771.32342877765313, -176.61502916214059, 12.507343278686905,\n         -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7);\n      Z : Complex := X;\n      Cx : Complex;\n      Ct : Complex;\n   begin\n      if Re(Z) < 0.5 then\n         return Pi / (Sin(Pi * Z) * Gamma(1.0 - Z));\n      else\n         Z := Z - 1.0;\n         Set_Re(Cx, P(0));\n         Set_Im(Cx, 0.0);\n         for I in 1..P'Last loop\n            Cx := Cx + (P(I) / (Z + Real(I)));\n         end loop;\n         Ct := Z + Real(G) + 0.5;\n         return Sqrt(2.0 * Pi) * Ct**(Z + 0.5) * Exp(-Ct) * Cx;\n      end if;\n   end Gamma;\n   \n   function Factorial(N : Complex) return Complex is\n   begin\n      return Gamma(N + 1.0);\n   end Factorial;\n   Arg : Complex;\nbegin\n   Put(\"factorial(-0.5)**2.0 = \");\n   Set_Re(Arg, -0.5);\n   Set_Im(Arg, 0.0);\n   Put(Item => Factorial(Arg) **2.0, Fore => 1, Aft => 8, Exp => 0);\n   New_Line;\n   for I in 0..9 loop\n      Set_Re(Arg, Real(I));\n      Set_Im(Arg, 0.0);\n      Put(\"factorial(\" & Integer'Image(I) & \") = \");\n      Put(Item => Factorial(Arg), Fore => 6, Aft => 8, Exp => 0);\n      New_Line;\n   end loop;\nend Factorial_Numeric_Approximation;\n\n\nOutput:\nfactorial(-0.5)**2.0 = (3.14159265,0.00000000)\nfactorial( 0) = (     1.00000000,     0.00000000)\nfactorial( 1) = (     1.00000000,     0.00000000)\nfactorial( 2) = (     2.00000000,     0.00000000)\nfactorial( 3) = (     6.00000000,     0.00000000)\nfactorial( 4) = (    24.00000000,     0.00000000)\nfactorial( 5) = (   120.00000000,     0.00000000)\nfactorial( 6) = (   720.00000000,     0.00000000)\nfactorial( 7) = (  5040.00000000,     0.00000000)\nfactorial( 8) = ( 40320.00000000,     0.00000000)\nfactorial( 9) = (362880.00000000,     0.00000000)\n\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nhelp?> factorial\nsearch: factorial Factorization factorize\n\n  factorial(n)\n\n  Factorial of n. If n is an Integer, the factorial is computed as an integer (promoted to at\n  least 64 bits). Note that this may overflow if n is not small, but you can use factorial(big(n))\n  to compute the result exactly in arbitrary precision. If n is not an Integer, factorial(n) is\n  equivalent to gamma(n+1).\n\n  julia> factorial(6)\n  720\n\n  julia> factorial(21)\n  ERROR: OverflowError()\n  [...]\n\n  julia> factorial(21.0)\n  5.109094217170944e19\n\n  julia> factorial(big(21))\n  51090942171709440000\n\nfunction fact(n::Integer)\n    n < 0 && return zero(n)\n    f = one(n)\n    for i in 2:n\n        f *= i\n    end\n    return f\nend\n\nfor i in 10:20\n\tprintln(\"$i -> \", fact(i))\nend\n\nOutput:\n10 -> 3628800\n11 -> 39916800\n12 -> 479001600\n13 -> 6227020800\n14 -> 87178291200\n15 -> 1307674368000\n16 -> 20922789888000\n17 -> 355687428096000\n18 -> 6402373705728000\n19 -> 121645100408832000\n20 -> 2432902008176640000\n\nfact2(n::Integer) = prod(Base.OneTo(n))\n@show fact2(20)\n\nOutput:\nfact2(20) = 2432902008176640000\n", "explain": "Built-in version:\nDynamic version:\nAlternative version:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nfun facti(n: Int) = when {\n    n < 0 -> throw IllegalArgumentException(\"negative numbers not allowed\")\n    else  -> {\n        var ans = 1L\n        for (i in 2..n) ans *= i\n        ans\n    }\n}\n\nfun factr(n: Int): Long = when {\n    n < 0 -> throw IllegalArgumentException(\"negative numbers not allowed\")\n    n < 2 -> 1L\n    else  -> n * factr(n - 1)\n}\n\nfun main(args: Array<String>) {\n    val n = 20\n    println(\"$n! = \" + facti(n))\n    println(\"$n! = \" + factr(n))\n}\n\nOutput:\n20! = 2432902008176640000\n20! = 2432902008176640000\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nIterative[edit]\nsub factorial\n{\n  my $n = shift;\n  my $result = 1;\n  for (my $i = 1; $i <= $n; ++$i)\n  {\n    $result *= $i;\n  };\n  $result;\n}\n\n# using a .. range\nsub factorial {\n    my $r = 1;\n    $r *= $_ for 1..shift;\n    $r;\n}\nRecursive[edit]\nsub factorial\n{\n  my $n = shift;\n  ($n == 0)? 1\u00a0: $n*factorial($n-1);\n}\nFunctional[edit]\nuse List::Util qw(reduce);\nsub factorial\n{\n  my $n = shift;\n  reduce { $a * $b } 1, 1 .. $n\n}\nModules[edit]\n\nLibrary: ntheory\nuse ntheory qw/factorial/;\n# factorial returns a UV (native unsigned int) or Math::BigInt depending on size\nsay length(  factorial(10000)  );\nuse bigint;\nsay length(  10000->bfac  );\nuse Math::GMP;\nsay length(  Math::GMP->new(10000)->bfac  );\nuse Math::Pari qw/ifact/;\nsay length(  ifact(10000)  );\n", "explain": "Each of these will print 35660, the number of digits in 10,000!.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nRecursive[edit]\nfact(X, 1)\u00a0:- X<2.\nfact(X, F)\u00a0:- Y is X-1, fact(Y,Z), F is Z*X.\nTail recursive[edit]\nfact(N, NF)\u00a0:-\n\tfact(1, N, 1, NF).\n\nfact(X, X, F, F)\u00a0:-\u00a0!.\nfact(X, N, FX, F)\u00a0:-\n\tX1 is X + 1,\n\tFX1 is FX * X1,\n\tfact(X1, N, FX1, F).\nFold[edit]\n\n% foldl(Pred, Init, List, R).\n%\nfoldl(_Pred, Val, [], Val).\nfoldl(Pred, Val, [H | T], Res)\u00a0:-\n\tcall(Pred, Val, H, Val1),\n\tfoldl(Pred, Val1, T, Res).\n\n% factorial\np(X, Y, Z)\u00a0:- Z is X * Y).\n\nfact(X, F)\u00a0:-\n\tnumlist(2, X, L),\n\tfoldl(p, 1, L, F).\nFold with anonymous function[edit]\n\n:- use_module(lambda).\n\n% foldl(Pred, Init, List, R).\n%\nfoldl(_Pred, Val, [], Val).\nfoldl(Pred, Val, [H | T], Res)\u00a0:-\n\tcall(Pred, Val, H, Val1),\n\tfoldl(Pred, Val1, T, Res).\n\nfact(N, F)\u00a0:-\n\tnumlist(2, N, L),\n\tfoldl(\\X^Y^Z^(Z is X * Y), 1, L, F).\nContinuation passing style[edit]\n\n:- use_module(lambda).\n\nfact(N, FN)\u00a0:-\n\tcont_fact(N, FN, \\X^Y^(Y = X)).\n\ncont_fact(N, F, Pred)\u00a0:-\n\t(   N = 0 ->\n\t    call(Pred, 1, F)\n\t;   N1 is N - 1,\n\n\t    P =  \\Z^T^(T is Z * N),\n\t    cont_fact(N1, FT, P),\n\t    call(Pred, FT, F)\n\t).\n", "explain": "We can simulate foldl.\nUsing the module lambda written by Ulrich Neumerkel found there http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/lambda.pl, we can use anonymous functions and write\u00a0:\nWorks with SWI-Prolog and module lambda written by Ulrich Neumerkel found there http://www.complang.tuwien.ac.at/ulrich/Prolog-inedit/lambda.pl.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nRecursive[edit]\nfunction fact(n)\n  return n > 0 and n * fact(n-1) or 1\nend\nTail Recursive[edit]\nfunction fact(n, acc)\n  acc = acc or 1\n  if n == 0 then\n    return acc\n  end\n  return fact(n-1, n*acc)\nend\nMemoization[edit]\n\nfact = setmetatable({[0] = 1}, {\n  __call = function(t,n)\n    if n < 0 then return 0 end\n    if not t[n] then t[n] = n * t(n-1) end\n    return t[n]\n  end\n})\n", "explain": "The memoization table can be accessed directly (eg. fact[10]) and will return the memoized value,\nor nil if the value has not been memoized yet.\nIf called as a function (eg. fact(10)), the value will be calculated, memoized and returned.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nImperative[edit]\n\ndef factorial(n: Int) = {\n  var res = 1\n  for (i <- 1 to n)\n    res *= i \n  res\n}\nRecursive[edit]\n\ndef factorial(n: Int): Int = \n  if (n < 1) 1 \n  else       n * factorial(n - 1)\n\ndef factorial(n: Int) = {\n  @tailrec def fact(x: Int, acc: Int): Int = {\n    if (x < 2) acc else fact(x - 1, acc * x)\n  }\n  fact(n, 1)\n}\nStdlib .product[edit]\n\ndef factorial(n: Int) = (2 to n).product\nFolding[edit]\n\ndef factorial(n: Int) =\n  (2 to n).foldLeft(1)(_ * _)\nUsing implicit functions to extend the Int type[edit]\n\nimplicit def IntToFac(i\u00a0: Int) = new {\n  def\u00a0! = (2 to i).foldLeft(BigInt(1))(_ * _)\n}\n\nExample used in the REPL:\nscala> 20!\nres0: scala.math.BigInt = 2432902008176640000\n\nscala> 100!\nres1: scala.math.BigInt = 93326215443944152681699238856266700490715968264381621468592963895217599993229915608941463976156518286253697920827223758251185210916864000000000000000000000000\n\n", "explain": "An imperative style using a mutable variable:\nUsing naive recursion:\nUsing tail recursion with a helper function:\nUsing standard library builtin:\nUsing folding:\nEnriching the integer type to support unary exclamation mark operator and implicit conversion to big integer:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nRecursive[edit]\nint fact(int n) {\n  if(n<0) {\n    throw new IllegalArgumentException('Argument less than 0');\n  }\n  return n==0\u00a0? 1\u00a0: n*fact(n-1);\n}\n\nmain() {\n  print(fact(10));\n  print(fact(-1));\n}\nIterative[edit]\nint fact(int n) {\n  if(n<0) {\n    throw new IllegalArgumentException('Argument less than 0');\n  }\n  int res=1;\n  for(int i=1;i<=n;i++) {\n    res*=i;\n  }\n  return res;\n}\n \nmain() {\n  print(fact(10));\n  print(fact(-1));\n}\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nIterative Version[edit]\nuint factorial(in uint n) pure nothrow @nogc\nin {\n    assert(n <= 12);\n} body {\n    uint result = 1;\n    foreach (immutable i; 1 .. n + 1)\n        result *= i;\n    return result;\n}\n\n// Computed and printed at compile-time.\npragma(msg, 12.factorial);\n\nvoid main() {\n    import std.stdio;\n\n    // Computed and printed at run-time.\n    12.factorial.writeln;\n}\n\nOutput:\n479001600u\n479001600\nRecursive Version[edit]\nuint factorial(in uint n) pure nothrow @nogc\nin {\n    assert(n <= 12);\n} body {\n    if (n == 0)\n        return 1;\n    else\n        return n * factorial(n - 1);\n}\n\n// Computed and printed at compile-time.\npragma(msg, 12.factorial);\n\nvoid main() {\n    import std.stdio;\n\n    // Computed and printed at run-time.\n    12.factorial.writeln;\n}\n\nFunctional Version[edit]\nimport std.stdio, std.algorithm, std.range;\n\nuint factorial(in uint n) pure nothrow @nogc\nin {\n    assert(n <= 12);\n} body {\n    return reduce!q{a * b}(1u, iota(1, n + 1));\n}\n\n// Computed and printed at compile-time.\npragma(msg, 12.factorial);\n\nvoid main() {\n    // Computed and printed at run-time.\n    12.factorial.writeln;\n}\n\nTail Recursive (at run-time, with DMD) Version[edit]\nuint factorial(in uint n) pure nothrow\nin {\n    assert(n <= 12);\n} body {\n    static uint inner(uint n, uint acc) pure nothrow @nogc {\n        if (n < 1)\n            return acc;\n        else\n            return inner(n - 1, acc * n);\n    }\n    return inner(n, 1);\n}\n\n// Computed and printed at compile-time.\npragma(msg, 12.factorial);\n\nvoid main() {\n    import std.stdio;\n\n    // Computed and printed at run-time.\n    12.factorial.writeln;\n}\n\n", "explain": "(Same output.)\n(Same output.)\n(Same output.)\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nfactorial n = product [1..n]\n\nfactorial = product . enumFromTo 1\n\nfactorial n = foldl (*) 1 [1..n]\n\nfactorials = scanl (*) 1 [1..]\n\nfactorial\u00a0:: Integral -> Integral\nfactorial 0 = 1\nfactorial n = n * factorial (n-1)\n\nfac n\n    | n >= 0    = go 1 n\n    | otherwise = error \"Negative factorial!\"\n        where go acc 0 = acc\n              go acc n = go (acc * n) (n - 1)\n\n{-# LANGUAGE PostfixOperators #-}\n\n(!)\u00a0:: Integer -> Integer\n(!) 0 = 1\n(!) n = n * (pred n\u00a0!)\n\nmain\u00a0:: IO ()\nmain = do\n  print (5\u00a0!)\n  print ((4\u00a0!)\u00a0!)\n\nBinary splitting[edit]\n\n-- product of [a,a+1..b]\nproductFromTo a b = \n  if a>b then 1 \n  else if a == b then a \n  else productFromTo a c * productFromTo (c+1) b \n  where c = (a+b) `div` 2\n\nfactorial = productFromTo 1\n", "explain": "The simplest description: factorial is the product of the numbers from 1 to n:\nOr, using composition and omitting the argument (partial application):\nOr, written explicitly as a fold:\nSee also: The Evolution of a Haskell Programmer\nOr, if you wanted to generate a list of all the factorials:\nOr, written without library functions:\nTail-recursive, checking the negative case:\nUsing postfix notation:\n\nThe following method is more efficient for large numbers.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "PL/SQL", "code": "\nDeclare\n  /*====================================================================================================\n  -- For    \u00a0:  https://rosettacode.org/\n  -- --\n  -- Task   \u00a0: Factorial\n  -- Method \u00a0: iterative\n  -- Language: PL/SQL\n  --\n  -- 2020-12-30 by alvalongo\n  ====================================================================================================*/\n  --\n  function fnuFactorial(inuValue   integer)\n  return number\n  is\n    nuFactorial number;\n  Begin\n    if inuValue is not null then\n       nuFactorial:=1;\n       --\n       if inuValue>=1 then\n          --\n          For nuI in 1..inuValue loop\n              nuFactorial:=nuFactorial*nuI;\n          end loop;\n          --\n       End if;\n       --\n    End if;\n    --\n    return(nuFactorial);\n  End fnuFactorial;\nBEGIN\n  For nuJ in 0..100 loop\n      Dbms_Output.Put_Line('Factorial('||nuJ||')='||fnuFactorial(nuJ));\n  End loop;\nEND;\n\nOutput:\nText\nPL/SQL block, executed in 115 ms\nFactorial(0)=1\nFactorial(1)=1\nFactorial(2)=2\nFactorial(3)=6\nFactorial(4)=24\nFactorial(5)=120\nFactorial(6)=720\nFactorial(7)=5040\nFactorial(8)=40320\nFactorial(9)=362880\nFactorial(10)=3628800\nFactorial(11)=39916800\nFactorial(12)=479001600\nFactorial(13)=6227020800\nFactorial(14)=87178291200\nFactorial(15)=1307674368000\nFactorial(16)=20922789888000\nFactorial(17)=355687428096000\nFactorial(18)=6402373705728000\nFactorial(19)=121645100408832000\nFactorial(20)=2432902008176640000\nFactorial(21)=51090942171709440000\nFactorial(22)=1124000727777607680000\nFactorial(23)=25852016738884976640000\nFactorial(24)=620448401733239439360000\nFactorial(25)=15511210043330985984000000\nFactorial(26)=403291461126605635584000000\nFactorial(27)=10888869450418352160768000000\nFactorial(28)=304888344611713860501504000000\nFactorial(29)=8841761993739701954543616000000\nFactorial(30)=265252859812191058636308480000000\nFactorial(31)=8222838654177922817725562880000000\nFactorial(32)=263130836933693530167218012160000000\nFactorial(33)=8683317618811886495518194401280000000\nFactorial(34)=295232799039604140847618609643520000000\nFactorial(35)=10333147966386144929666651337523200000000\nFactorial(36)=371993326789901217467999448150835200000000\nFactorial(37)=13763753091226345046315979581580902400000000\nFactorial(38)=523022617466601111760007224100074291200000000\nFactorial(39)=20397882081197443358640281739902897356800000000\nFactorial(40)=815915283247897734345611269596115894272000000000\nFactorial(41)=33452526613163807108170062053440751665150000000000\nFactorial(42)=1405006117752879898543142606244511569936000000000000\nFactorial(43)=60415263063373835637355132068513997507200000000000000\nFactorial(44)=2658271574788448768043625811014615890320000000000000000\nFactorial(45)=119622220865480194561963161495657715064000000000000000000\nFactorial(46)=5502622159812088949850305428800254892944000000000000000000\nFactorial(47)=258623241511168180642964355153611979968400000000000000000000\nFactorial(48)=12413915592536072670862289047373375038480000000000000000000000\nFactorial(49)=608281864034267560872252163321295376886000000000000000000000000\nFactorial(50)=30414093201713378043612608166064768844300000000000000000000000000\nFactorial(51)=1551118753287382280224243016469303211060000000000000000000000000000\nFactorial(52)=80658175170943878571660636856403766975120000000000000000000000000000\nFactorial(53)=4274883284060025564298013753389399649681000000000000000000000000000000\nFactorial(54)=230843697339241380472092742683027581082800000000000000000000000000000000\nFactorial(55)=12696403353658275925965100847566516959550000000000000000000000000000000000\nFactorial(56)=710998587804863451854045647463724949735000000000000000000000000000000000000\nFactorial(57)=40526919504877216755680601905432322134900000000000000000000000000000000000000\nFactorial(58)=2350561331282878571829474910515074683820000000000000000000000000000000000000000\nFactorial(59)=138683118545689835737939019720389406345000000000000000000000000000000000000000000\nFactorial(60)=8320987112741390144276341183223364380700000000000000000000000000000000000000000000\nFactorial(61)=507580213877224798800856812176625227222700000000000000000000000000000000000000000000\nFactorial(62)=31469973260387937525653122354950764087810000000000000000000000000000000000000000000000\nFactorial(63)=1982608315404440064116146708361898137532000000000000000000000000000000000000000000000000\nFactorial(64)=126886932185884164103433389335161480802000000000000000000000000000000000000000000000000000\nFactorial(65)=8247650592082470666723170306785496252130000000000000000000000000000000000000000000000000000\nFactorial(66)=544344939077443064003729240247842752641000000000000000000000000000000000000000000000000000000\nFactorial(67)=36471110918188685288249859096605464426900000000000000000000000000000000000000000000000000000000\nFactorial(68)=2480035542436830599600990418569171581030000000000000000000000000000000000000000000000000000000000\nFactorial(69)=171122452428141311372468338881272839091000000000000000000000000000000000000000000000000000000000000\nFactorial(70)=1,197857166996989179607278372168909873640000000000000000000000000000000000000000000000000000000E+100\nFactorial(71)=8,504785885678623175211676442399260102844000000000000000000000000000000000000000000000000000000E+101\nFactorial(72)=6,123445837688608686152407038527467274048000000000000000000000000000000000000000000000000000000E+103\nFactorial(73)=4,470115461512684340891257138125051110055000000000000000000000000000000000000000000000000000000E+105\nFactorial(74)=3,307885441519386412259530282212537821441000000000000000000000000000000000000000000000000000000E+107\nFactorial(75)=2,480914081139539809194647711659403366081000000000000000000000000000000000000000000000000000000E+109\nFactorial(76)=1,885494701666050254987932260861146558222000000000000000000000000000000000000000000000000000000E+111\nFactorial(77)=1,451830920282858696340707840863082849831000000000000000000000000000000000000000000000000000000E+113\nFactorial(78)=1,132428117820629783145752115873204622868000000000000000000000000000000000000000000000000000000E+115\nFactorial(79)=8,946182130782975286851441715398316520660000000000000000000000000000000000000000000000000000000E+116\nFactorial(80)=7,156945704626380229481153372318653216530000000000000000000000000000000000000000000000000000000E+118\nFactorial(81)=5,797126020747367985879734231578109105390000000000000000000000000000000000000000000000000000000E+120\nFactorial(82)=4,753643337012841748421382069894049466420000000000000000000000000000000000000000000000000000000E+122\nFactorial(83)=3,945523969720658651189747118012061057130000000000000000000000000000000000000000000000000000000E+124\nFactorial(84)=~\nFactorial(85)=~\nFactorial(86)=~\nFactorial(87)=~\nFactorial(88)=~\nFactorial(89)=~\nFactorial(90)=~\nFactorial(91)=~\nFactorial(92)=~\nFactorial(93)=~\nFactorial(94)=~\nFactorial(95)=~\nFactorial(96)=~\nFactorial(97)=~\nFactorial(98)=~\nFactorial(99)=~\nFactorial(100)=~\nTotal execution time 176 ms\n\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\nRecursive[edit]\n(define (factorial n)\n  (if (<= n 0)\n      1\n      (* n (factorial (- n 1)))))\n\n(define (factorial n)\n  (let loop ((i 1)\n             (accum 1))\n    (if (> i n)\n        accum\n        (loop (+ i 1) (* accum i)))))\nIterative[edit]\n(define (factorial n)\n  (do ((i 1 (+ i 1))\n       (accum 1 (* accum i)))\n      ((> i n) accum)))\nFolding[edit]\n;Using a generator and a function that apply generated values to a function taking two arguments\n\n;A generator knows commands 'next? and 'next\n(define (range a b)\n(let ((k a))\n(lambda (msg)\n(cond\n\t((eq? msg 'next?) (<= k b))\n\t((eq? msg 'next)\n\t(cond\n\t\t((<= k b) (set! k (+ k 1)) (- k 1))\n\t\t(else 'nothing-left)))))))\n\n;Similar to List.fold_left in OCaml, but uses a generator\n(define (fold fun a gen)\n(let aux ((a a))\n\t(if (gen 'next?) (aux (fun a (gen 'next))) a)))\n\n;Now the factorial function\n(define (factorial n) (fold * 1 (range 1 n)))\n\n(factorial 8)\n;40320\n", "explain": "The following is tail-recursive, so it is effectively iterative:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Apex", "code": "\nIterative[edit]\npublic static long fact(final Integer n) {\n    if (n < 0) {\n        System.debug('No negative numbers');\n        return 0;\n    }\n    long ans = 1;\n    for (Integer i = 1; i <= n; i++) {\n        ans *= i;\n    }\n    return ans;\n}\nRecursive[edit]\npublic static long factRec(final Integer n) {\n    if (n < 0){\n        System.debug('No negative numbers');\n        return 0;\n    }\n    return (n < 2)\u00a0? 1\u00a0: n * fact(n - 1);\n}\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nRecursive[edit]\nfunction Get-Factorial ($x) {\n    if ($x -eq 0) {\n        return 1\n    }\n    return $x * (Get-Factorial ($x - 1))\n}\nIterative[edit]\nfunction Get-Factorial ($x) {\n    if ($x -eq 0) {\n        return 1\n    } else {\n        $product = 1\n        1..$x | ForEach-Object { $product *= $_ }\n        return $product\n    }\n}\nEvaluative[edit]\nWorks with: PowerShell version 2\n\nfunction Get-Factorial ($x) {\n    if ($x -eq 0) {\n        return 1\n    }\n    return (Invoke-Expression (1..$x -join '*'))\n}\n", "explain": "This one first builds a string, containing 1*2*3... and then lets PowerShell evaluate it. A bit of mis-use but works.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nRecursive[edit]\nto factorial :n\n  if :n < 2 [output 1]\n  output :n * factorial :n-1\nend\nIterative[edit]\n\nto factorial :n \n\tmake \"fact 1 \n\tmake \"i 1 \n\trepeat :n [make \"fact :fact * :i make \"i :i + 1] \n\tprint :fact \nend\n", "explain": "NOTE: Slight code modifications may needed in order to run this as each Logo implementation differs in various ways.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "ABAP", "code": "\nIterative[edit]\nform factorial using iv_val type i.\n  data: lv_res type i value 1.\n  do iv_val times.\n    multiply lv_res by sy-index.\n  enddo.\n\n  iv_val = lv_res.\nendform.\n\nRecursive[edit]\nform fac_rec using iv_val type i.\n  data: lv_temp type i.\n\n  if iv_val = 0.\n    iv_val = 1.\n  else.\n    lv_temp = iv_val - 1.\n    perform fac_rec using lv_temp.\n    multiply iv_val by lv_temp.\n  endif.\nendform.\n\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n//val inline factorial\u00a0:\n//   ^a ->  ^a\n//    when  ^a\u00a0: (static member get_One\u00a0: ->  ^a) and\n//          ^a\u00a0: (static member ( + )\u00a0:  ^a *  ^a ->  ^a) and\n//          ^a\u00a0: (static member ( * )\u00a0:  ^a *  ^a ->  ^a)\nlet inline factorial n = Seq.reduce (*) [ LanguagePrimitives.GenericOne .. n ]\n\n> factorial 8;;\nval it\u00a0: int = 40320\n> factorial 800I;;\nval it\u00a0: bigint = 771053011335386004144639397775028360595556401816010239163410994033970851827093069367090769795539033092647861224230677444659785152639745401480184653174909762504470638274259120173309701702610875092918816846985842150593623718603861642063078834117234098513725265045402523056575658860621238870412640219629971024686826624713383660963127048195572279707711688352620259869140994901287895747290410722496106151954257267396322405556727354786893725785838732404646243357335918597747405776328924775897564519583591354080898117023132762250714057271344110948164029940588827847780442314473200479525138318208302427727803133219305210952507605948994314345449325259594876385922128494560437296428386002940601874072732488897504223793518377180605441783116649708269946061380230531018291930510748665577803014523251797790388615033756544830374909440162270182952303329091720438210637097105616258387051884030288933650309756289188364568672104084185529365727646234588306683493594765274559497543759651733699820639731702116912963247441294200297800087061725868223880865243583365623482704395893652711840735418799773763054887588219943984673401051362280384187818611005035187862707840912942753454646054674870155072495767509778534059298038364204076299048072934501046255175378323008217670731649519955699084482330798811049166276249251326544312580289357812924825898217462848297648349400838815410152872456707653654424335818651136964880049831580548028614922852377435001511377656015730959254647171290930517340367287657007606177675483830521499707873449016844402390203746633086969747680671468541687265823637922007413849118593487710272883164905548707198762911703545119701275432473548172544699118836274377270607420652133092686282081777383674487881628800801928103015832821021286322120460874941697199487758769730544922012389694504960000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000I\n\n\n", "explain": ""}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\nRecursive[edit]\n\ndef rFact\nrFact = { (it > 1)\u00a0? it * rFact(it - 1)\u00a0: 1 as BigInteger }\nIterative[edit]\ndef iFact = { (it > 1)\u00a0? (2..it).inject(1 as BigInteger) { i, j -> i*j }\u00a0: 1 }\n\ndef time = { Closure c ->\n    def start = System.currentTimeMillis()\n    def result = c()\n    def elapsedMS = (System.currentTimeMillis() - start)/1000\n    printf '(%6.4fs elapsed)', elapsedMS\n    result\n}\n\ndef dashes = '---------------------'\nprint \"   n!       elapsed time   \"; (0..15).each { def length = Math.max(it - 3, 3); printf \"\u00a0%${length}d\", it }; println()\nprint \"--------- -----------------\"; (0..15).each { def length = Math.max(it - 3, 3); print \" ${dashes[0..<length]}\" }; println()\n[recursive:rFact, iterative:iFact].each { name, fact ->\n    printf \"%9s \", name\n    def factList = time { (0..15).collect {fact(it)} }\n    factList.each { printf ' %3d', it }\n    println()\n}\n\nOutput:\n   n!       elapsed time      0   1   2   3   4   5   6    7     8      9      10       11        12         13          14           15\n--------- ----------------- --- --- --- --- --- --- --- ---- ----- ------ ------- -------- --------- ---------- ----------- ------------\nrecursive (0.0040s elapsed)   1   1   2   6  24 120 720 5040 40320 362880 3628800 39916800 479001600 6227020800 87178291200 1307674368000\niterative (0.0060s elapsed)   1   1   2   6  24 120 720 5040 40320 362880 3628800 39916800 479001600 6227020800 87178291200 1307674368000\n", "explain": "A recursive closure must be pre-declared.\nTest Program:\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "Zig", "code": "\n\nconst stdout = @import(\"std\").io.getStdOut().outStream();\n\npub fn factorial(comptime Num: type, n: i8) ?Num {\n    return if (@typeInfo(Num)\u00a0!= .Int)\n        @compileError(\"factorial called with num-integral type: \" ++ @typeName(Num))\n    else if (n < 0)\n        null\n    else calc: {\n        var i: i8 = 1;\n        var fac: Num = 1;\n        while (i <= n)\u00a0: (i += 1) {\n            if (@mulWithOverflow(Num, fac, i, &fac))\n                break :calc null;\n        } else break :calc fac;\n    };\n}\n\npub fn main() !void {\n    try stdout.print(\"-1! = {}\\n\", .{factorial(i32, -1)});\n    try stdout.print(\"0! = {}\\n\", .{factorial(i32, 0)});\n    try stdout.print(\"5! = {}\\n\", .{factorial(i32, 5)});\n    try stdout.print(\"33!(64 bit) = {}\\n\", .{factorial(i64, 33)}); // not vailid i64 factorial\n    try stdout.print(\"33! = {}\\n\", .{factorial(i128, 33)}); // biggest facorial possible\n    try stdout.print(\"34! = {}\\n\", .{factorial(i128, 34)}); // will overflow\n}\n\nOutput:\n-1! = null\n0! = 1\n5! = 120\n33!(64 bit) = null\n33! = 8683317618811886495518194401280000000\n34! = null\n\n", "explain": "Supports all integer data types, and checks for both overflow and negative numbers; returns null when there is a domain error.\n"}, {"task_name": "Factorial", "task_url": "https://rosettacode.org/wiki/Factorial", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\nfunction fact_r(n)\n{\n  if ( n <= 1 ) return 1;\n  return n*fact_r(n-1);\n}\n\n\nfunction fact(n)\n{\n  if ( n < 1 ) return 1;\n  r = 1\n  for(m = 2; m <= n; m++) {\n    r *= m;\n  }\n  return r\n}\n\n", "explain": "Recursive\nIterative\n"}]