[{"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\nfrom random import randrange\n\ndef knuth_shuffle(x):\n    for i in range(len(x)-1, 0, -1):\n        j = randrange(i + 1)\n        x[i], x[j] = x[j], x[i]\n\nx = list(range(10))\nknuth_shuffle(x)\nprint(\"shuffled:\", x)\n\nOutput:\nshuffled: [5, 1, 6, 0, 8, 4, 2, 3, 9, 7]\n\n\nWorks with: Python version 3.7\n'''Knuth shuffle as a fold'''\n\nfrom functools import reduce\nfrom random import randint\n\n\n# knuthShuffle\u00a0:: [a] -> IO [a]\ndef knuthShuffle(xs):\n    '''A pseudo-random shuffle of the elements in xs.'''\n    return reduce(\n        swapped,\n        enumerate(randoms(len(xs))), xs\n    )\n\n\n# swapped\u00a0:: (Int, Int) -> [a] -> [a]\ndef swapped(xs, ij):\n    '''New list in which the elements at indices\n       i and j of xs are swapped.\n    '''\n    def go(a, b):\n        if a\u00a0!= b:\n            m, n = (a, b) if b > a else (b, a)\n            l, ht = splitAt(m)(xs)\n            ys, zs = splitAt((n - m) - 1)(ht[1:])\n            return l + [zs[0]] + ys + [ht[0]] + zs[1:]\n        else:\n            return xs\n    i, j = ij\n    z = len(xs) - 1\n    return xs if i > z or j > z else go(i, j)\n\n\n# randoms\u00a0:: Int -> IO [Int]\ndef randoms(n):\n    '''Pseudo-random list of n - 1 indices.\n    '''\n    return list(map(randomRInt(0)(n - 1), range(1, n)))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Repeated Knuth shuffles of ['a' .. 'k']'''\n\n    print(\n        fTable(main.__doc__ + ':\\n')(str)(lambda x: ''.join(x))(\n            lambda _: knuthShuffle(list('abcdefghijk'))\n        )(range(1, 11))\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# randomRInt\u00a0:: Int -> Int -> IO () -> Int\ndef randomRInt(m):\n    '''The return value of randomRInt is itself\n       a function. The returned function, whenever\n       called, yields a a new pseudo-random integer\n       in the range [m..n].\n    '''\n    return lambda n: lambda _: randint(m, n)\n\n\n# splitAt\u00a0:: Int -> [a] -> ([a], [a])\ndef splitAt(n):\n    '''A tuple pairing the prefix of length n\n       with the rest of xs.\n    '''\n    return lambda xs: (xs[0:n], xs[n:])\n\n\n# FORMATTING -----------------------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\nRepeated Knuth shuffles of ['a' .. 'k']:\n\n 1 -> kdafbhigejc\n 2 -> jhdkgeicabf\n 3 -> aciebghdfkj\n 4 -> fjahegibckd\n 5 -> cabejfidkgh\n 6 -> gbecahfkijd\n 7 -> jegchkdifba\n 8 -> fcjkghiadeb\n 9 -> ihfebdajgkc\n10 -> hjkigbadcfe\n", "explain": "Python's standard library function random.shuffle uses this algorithm and so should normally be used. \nThe function below is very similar:\n\nWe could also write our own Knuth shuffle function as a fold, with a non-mutating swap function:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdlib.h>\n#include <string.h>\n\nint rrand(int m)\n{\n  return (int)((double)m * ( rand() / (RAND_MAX+1.0) ));\n}\n\n#define BYTE(X) ((unsigned char *)(X)) \nvoid shuffle(void *obj, size_t nmemb, size_t size)\n{\n  void *temp = malloc(size);\n  size_t n = nmemb;\n  while ( n > 1 ) {\n    size_t k = rrand(n--);\n    memcpy(temp, BYTE(obj) + n*size, size);\n    memcpy(BYTE(obj) + n*size, BYTE(obj) + k*size, size);\n    memcpy(BYTE(obj) + k*size, temp, size);\n  }\n  free(temp);\n}\n\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/* define a shuffle function. e.g. decl_shuffle(double).\n * advantage: compiler is free to optimize the swap operation without\n *            indirection with pointers, which could be much faster.\n * disadvantage: each datatype needs a separate instance of the function.\n *            for a small funciton like this, it's not very big a deal.\n */\n#define decl_shuffle(type)\t\t\t\t\\\nvoid shuffle_##type(type *list, size_t len) {\t\t\\\n\tint j;\t\t\t\t\t\t\\\n\ttype tmp;\t\t\t\t\t\\\n\twhile(len) {\t\t\t\t\t\\\n\t\tj = irand(len);\t\t\t\t\\\n\t\tif (j\u00a0!= len - 1) {\t\t\t\\\n\t\t\ttmp = list[j];\t\t\t\\\n\t\t\tlist[j] = list[len - 1];\t\\\n\t\t\tlist[len - 1] = tmp;\t\t\\\n\t\t}\t\t\t\t\t\\\n\t\tlen--;\t\t\t\t\t\\\n\t}\t\t\t\t\t\t\\\n}\t\t\t\t\t\t\t\\\n\n/* random integer from 0 to n-1 */\nint irand(int n)\n{\n\tint r, rand_max = RAND_MAX - (RAND_MAX % n);\n\t/* reroll until r falls in a range that can be evenly\n\t * distributed in n bins.  Unless n is comparable to\n\t * to RAND_MAX, it's not *that* important really. */\n\twhile ((r = rand()) >= rand_max);\n\treturn r / (rand_max / n);\n}\n\n/* declare and define int type shuffle function from macro */\ndecl_shuffle(int);\n\nint main()\n{\n\tint i, x[20];\n\n\tfor (i = 0; i < 20; i++) x[i] = i;\n\tfor (printf(\"before:\"), i = 0; i < 20 || !printf(\"\\n\"); i++)\n\t\tprintf(\" %d\", x[i]);\n\n\tshuffle_int(x, 20);\n\n\tfor (printf(\"after: \"), i = 0; i < 20 || !printf(\"\\n\"); i++)\n\t\tprintf(\" %d\", x[i]);\n\treturn 0;\n}\n\n", "explain": "This shuffles any \"object\"; it imitates qsort in the syntax.\nAlternatively, using Durstenfeld's method (swapping selected item and last item in each iteration instead of literally shifting everything), and macro'd function declaration/definition:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <cstdlib>\n#include <algorithm>\n#include <iterator>\n\ntemplate<typename RandomAccessIterator>\nvoid knuthShuffle(RandomAccessIterator begin, RandomAccessIterator end) {\n  for(unsigned int n = end - begin - 1; n >= 1; --n) {\n    unsigned int k = rand() % (n + 1);\n    if(k != n) {\n      std::iter_swap(begin + k, begin + n);\n    }\n  }\n}\n\n\n#include <algorithm>\n#include <vector>\n\nint main()\n{\n    int array[] = { 1,2,3,4,5,6,7,8,9 }; // C-style array of integers\n    std::vector<int> vec(array, array + 9); // build STL container from int array\n\n    std::random_shuffle(array, array + 9); // shuffle C-style array\n    std::random_shuffle(vec.begin(), vec.end()); // shuffle STL container\n}\n\n", "explain": "Compiler: g++ (version 4.3.2 20081105 (Red Hat 4.3.2-7))\nThe standard library provides this in the form of std::random_shuffle.\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\nimport java.util.Random;\n\npublic static final Random gen = new Random();\n\n// version for array of ints\npublic static void shuffle (int[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); //decrements after using the value\n        int temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n// version for array of references\npublic static void shuffle (Object[] array) {\n    int n = array.length;\n    while (n > 1) {\n        int k = gen.nextInt(n--); //decrements after using the value\n        Object temp = array[n];\n        array[n] = array[k];\n        array[k] = temp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\npublic static void KnuthShuffle<T>(T[] array)\n{\n    System.Random random = new System.Random();\n    for (int i = 0; i < array.Length; i++)\n    {\n        int j = random.Next(i, array.Length); // Don't select from the entire array on subsequent loops\n        T temp = array[i]; array[i] = array[j]; array[j] = temp;\n    }\n}\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\nfunction knuthShuffle(arr) {\n    var rand, temp, i;\n\n    for (i = arr.length - 1; i > 0; i -= 1) {\n        rand = Math.floor((i + 1) * Math.random());//get random between zero and i (inclusive)\n        temp = arr[rand];\n        arr[rand] = arr[i]; //swap i (last element) with random element.\n        arr[i] = temp;\n    }\n    return arr;\n}\n\nvar res = {\n    '1,2,3': 0, '1,3,2': 0,\n    '2,1,3': 0, '2,3,1': 0,\n    '3,1,2': 0, '3,2,1': 0\n};\n\nfor (var i = 0; i < 100000; i++) {\n    res[knuthShuffle([1,2,3]).join(',')] += 1;\n}\n\nfor (var key in res) {\n    print(key + \"\\t\" + res[key]);\n}\n\n\n1,2,3   16619\n1,3,2   16614\n2,1,3   16752\n2,3,1   16959\n3,1,2   16460\n3,2,1   16596\nES6[edit]\nMutating in-place swap[edit]\n(() => {\n\n    // knuthShuffle\u00a0:: [a] -> [a]\n    const knuthShuffle = xs =>\n        enumFromTo(0, xs.length - 1)\n        .reduceRight((a, i) => {\n            const\n                iRand =  randomRInt(0, i),\n                tmp = a[iRand];\n            return iRand !== i ? (\n                a[iRand] = a[i],\n                a[i] = tmp,\n                a\n            ) : a;\n        }, xs);\n\n    const test = () => knuthShuffle(\n        (`alpha beta gamma delta epsilon zeta\n              eta theta iota kappa lambda mu`)\n        .split(/\\s+/)\n    );\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = (m, n) =>\n        n >= m ? (\n            iterateUntil(x => x >= n, x => 1 + x, m)\n        ) : [];\n\n    // iterateUntil\u00a0:: (a -> Bool) -> (a -> a) -> a -> [a]\n    const iterateUntil = (p, f, x) => {\n        let vs = [x],\n            h = x;\n        while (!p(h))(h = f(h), vs.push(h));\n        return vs;\n    };\n\n    // randomRInt\u00a0:: Int -> Int -> Int\n    const randomRInt = (low, high) =>\n        low + Math.floor(\n            (Math.random() * ((high - low) + 1))\n        );\n\n    return test();\n})();\n\n\nOutput:\n\n[\"iota\", \"epsilon\", \"kappa\", \"theta\", \"gamma\", \"delta\", \n\"lambda\", \"eta\", \"zeta\", \"beta\", \"mu\", \"alpha\"]\n\nNon-mutating swap[edit]\n(() => {\n\n    // knuthShuffle\u00a0:: [a] -> [a]\n    const knuthShuffle = xs =>\n        enumFromTo(0, xs.length - 1)\n        .reduceRight((a, i) => {\n            const iRand = randomRInt(0, i);\n            return i !== iRand ? (\n                swapped(i, iRand, a)\n            ) : a;\n        }, xs);\n\n    const test = () => knuthShuffle(\n        (`alpha beta gamma delta epsilon zeta\n          eta theta iota kappa lambda mu`)\n        .split(/\\s+/)\n    );\n\n    // Non mutating version of swapped\n\n    // swapped\u00a0:: Int -> Int -> [a] -> [a]\n    const swapped = (iFrom, iTo, xs) =>\n        xs.map(\n            (x, i) => iFrom !== i ? (\n                iTo !== i ? (\n                    x\n                ) : xs[iFrom]\n            ) : xs[iTo]\n        );\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = (m, n) =>\n        n >= m ? (\n            iterateUntil(x => x >= n, x => 1 + x, m)\n        ) : [];\n\n    // iterateUntil\u00a0:: (a -> Bool) -> (a -> a) -> a -> [a]\n    const iterateUntil = (p, f, x) => {\n        let vs = [x],\n            h = x;\n        while (!p(h))(h = f(h), vs.push(h));\n        return vs;\n    };\n\n    // randomRInt\u00a0:: Int -> Int -> Int\n    const randomRInt = (low, high) =>\n        low + Math.floor(\n            (Math.random() * ((high - low) + 1))\n        );\n\n    // zipWith\u00a0:: (a -> b -> c) -> [a] -> [b] -> [c]\n    const zipWith = (f, xs, ys) =>\n        Array.from({\n            length: Math.min(xs.length, ys.length)\n        }, (_, i) => f(xs[i], ys[i], i));\n\n    // MAIN ---\n    return test();\n})();\n\n\nOutput:\n\n[\"mu\", \"theta\", \"beta\", \"eta\", \"delta\", \"epsilon\", \n\"kappa\", \"alpha\", \"gamma\", \"lambda\", \"zeta\", \"iota\"]\n\n", "explain": "Results in:\ne.g.\ne.g.\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n//The Fisher-Yates original Method\nfunction yates_shuffle($arr){\n\t$shuffled = Array();\n\twhile($arr){\n\t\t$rnd = array_rand($arr);\n\t\t$shuffled[] = $arr[$rnd];\n\t\tarray_splice($arr, $rnd, 1);\n\t}\n\treturn $shuffled;\n}\n\n//The modern Durstenfeld-Knuth algorithm\nfunction knuth_shuffle(&$arr){\n\tfor($i=count($arr)-1;$i>0;$i--){\n\t\t$rnd = mt_rand(0,$i);\n\t\tlist($arr[$i], $arr[$rnd]) = array($arr[$rnd], $arr[$i]);\n\t}\n}\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\n\nfunction list = knuthShuffle(list)\n\n    for i = (numel(list):-1:2)  \n        \n        j = floor(i*rand(1) + 1); %Generate random int between 1 and i\n        \n        %Swap element i with element j.\n        list([j i]) = list([i j]);    \n    end\nend\n\n\nfunction list = randSort(list)\n    \n    list = list( randperm(numel(list)) );\n    \nend\n\n", "explain": "Because this shuffle is done using rounds of operations on subsets of decreasing size, this is not an algorithm that can be vectorized using built-in MATLAB functions. So, we have to go old-school, no fancy MATLAB trickery.\nThere is an alternate way to do this that is not a true Knuth Shuffle, but operates with the same spirit. \nThis alternate version produces the same output, saves some space, \nand can be implemented in-line without the need to encapsulate it \nin a function call like the Knuth Shuffle.  \n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram Knuth_Shuffle\n  implicit none\n\n  integer, parameter :: reps = 1000000\n  integer :: i, n\n  integer, dimension(10) :: a, bins = 0, initial = (/ (n, n=1,10) /) \n\n  do i = 1, reps\n    a = initial\n \tcall Shuffle(a)\n    where (a == initial) bins = bins + 1  ! skew tester\n  end do\n  write(*, \"(10(i8))\") bins\n! prints  100382  100007   99783  100231  100507   99921   99941  100270  100290  100442\n\ncontains\n\nsubroutine Shuffle(a)\n  integer, intent(inout) :: a(:)\n  integer :: i, randpos, temp\n  real :: r\n\n  do i = size(a), 2, -1\n    call random_number(r)\n    randpos = int(r * i) + 1\n    temp = a(randpos)\n    a(randpos) = a(i)\n    a(i) = temp\n  end do\n     \nend subroutine Shuffle\n   \nend program Knuth_Shuffle\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Scratch", "code": "\n\n", "explain": "See Knuth's shuffle in action.  Visit this Scratch implementation to see a demo and inspect its source.\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    var a [20]int\n    for i := range a {\n        a[i] = i\n    }\n    fmt.Println(a)\n\n    rand.Seed(time.Now().UnixNano())\n    for i := len(a) - 1; i >= 1; i-- {\n        j := rand.Intn(i + 1)\n        a[i], a[j] = a[j], a[i]\n    }\n    fmt.Println(a)\n}\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n    \"time\"\n)\n\n// Generic Knuth Shuffle algorithm.  In Go, this is done with interface\n// types.  The parameter s of function shuffle is an interface type.\n// Any type satisfying the interface \"shuffler\" can be shuffled with\n// this function.  Since the shuffle function uses the random number\n// generator, it's nice to seed the generator at program load time.\nfunc init() {\n    rand.Seed(time.Now().UnixNano())\n}\nfunc shuffle(s shuffler) {\n    for i := s.Len() - 1; i >= 1; i-- {\n        j := rand.Intn(i + 1)\n        s.Swap(i, j)\n    }\n}\n\n// Conceptually, a shuffler is an indexed collection of things.\n// It requires just two simple methods.\ntype shuffler interface {\n    Len() int      // number of things in the collection\n    Swap(i, j int) // swap the two things indexed by i and j\n}\n\n// ints is an example of a concrete type implementing the shuffler\n// interface.\ntype ints []int\n\nfunc (s ints) Len() int      { return len(s) }\nfunc (s ints) Swap(i, j int) { s[i], s[j] = s[j], s[i] }\n\n// Example program.  Make an ints collection, fill with sequential numbers,\n// print, shuffle, print.\nfunc main() {\n    a := make(ints, 20)\n    for i := range a {\n        a[i] = i\n    }\n    fmt.Println(a)\n    shuffle(a)\n    fmt.Println(a)\n}\n\n\nExample output: (of either program)\n[0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 16 17 18 19]\n[11 10 12 19 4 13 15 17 14 2 5 18 8 0 6 9 7 3 1 16]\n\n", "explain": "(Note, in addition to these examples,\nrand.Shuffle\nwas added in Go1.10\nimplementing a Fisher\u2013Yates shuffle.)\nTo shuffle any type:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program knuthShuffle.s   */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:      .ascii \"Value \u00a0: \"\nsMessValeur:       .fill 11, 1, ' '            @ size => 11\nszCarriageReturn: .asciz \"\\n\"\n\n.align 4\niGraine:  .int 123456\n.equ NBELEMENTS,      10\nTableNumber:\t     .int   1,2,3,4,5,6,7,8,9,10\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                           @ entry of program \n    ldr r0,iAdrTableNumber                      @ address number table\n    mov r1,#NBELEMENTS                          @ number of \u00e9lements \n    bl knuthShuffle\n    ldr r2,iAdrTableNumber\n    mov r3,#0\n1:                                              @ loop display table\n    ldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                      @ display value\n    bl conversion10                             @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                            @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 1b\n\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess   \n    /*    2e shuffle             */\n    ldr r0,iAdrTableNumber                     @ address number table\n    mov r1,#NBELEMENTS                         @ number of \u00e9lements \n    bl knuthShuffle\n    ldr r2,iAdrTableNumber\n    mov r3,#0\n2:                                             @ loop display table\n    ldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                     @ display value\n    bl conversion10                            @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                           @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 2b\n\n100:                                            @ standard end of the program \n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc #0                                      @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrTableNumber:          .int TableNumber\n\n/******************************************************************/\n/*     Knuth Shuffle                                             */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains the number of elements */\nknuthShuffle:\n    push {r2-r5,lr}                                    @ save registers\n    mov r5,r0                                          @ save table address\n    mov r2,#0                                          @ start index\n1:\n    mov r0,r2                                          @ generate aleas\n    bl genereraleas\n    ldr r3,[r5,r2,lsl #2]                              @ swap number on the table\n    ldr r4,[r5,r0,lsl #2]\n    str r4,[r5,r2,lsl #2]\n    str r3,[r5,r0,lsl #2]\n    add r2,#1                                           @ next number\n    cmp r2,r1                                           @ end\u00a0?\n    blt 1b                                              @ no -> loop\n\n100:\n    pop {r2-r5,lr}\n    bx lr                                               @ return \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n\n1:\t                                           @ start loop\n    bl divisionpar10U                              @unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                     @ digit\n    strb r1,[r3,r2]                                @ store digit on area\n    cmp r0,#0                                      @ stop if quotient = 0 \n    subne r2,#1                                    @ else previous position\n    bne 1b\t                                   @ and loop\n                                                   @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n\n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n\n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    //mov r3,#0xCCCD                                   @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                  @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* r0 contains limit  */\ngenereraleas:\n    push {r1-r4,lr}                                    @ save registers \n    ldr r4,iAdriGraine\n    ldr r2,[r4]\n    ldr r3,iNbDep1\n    mul r2,r3,r2\n    ldr r3,iNbDep1\n    add r2,r2,r3\n    str r2,[r4]                                        @ maj de la graine pour l appel suivant \n    cmp r0,#0\n    beq 100f\n    mov r1,r0                                          @ divisor\n    mov r0,r2                                          @ dividende\n    bl division\n    mov r0,r3                                          @ r\u00e9sult = remainder\n  \n100:                                                   @ end function\n    pop {r1-r4,lr}                                     @ restaur registers\n    bx lr                                              @ return\n/*****************************************************/\niAdriGraine: .int iGraine\t\niNbDep1: .int 0x343FD\niNbDep2: .int 0x269EC3 \n/***************************************************/\n/* integer division unsigned                       */\n/***************************************************/\ndivision:\n    /* r0 contains dividend */\n    /* r1 contains divisor */\n    /* r2 returns quotient */\n    /* r3 returns remainder */\n    push {r4, lr}\n    mov r2, #0                                         @ init quotient\n    mov r3, #0                                         @ init remainder\n    mov r4, #32                                        @ init counter bits\n    b 2f\n1:                                                     @ loop \n    movs r0, r0, LSL #1                                @ r0 <- r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1)\n    adc r3, r3, r3                                     @ r3 <- r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C \n    cmp r3, r1                                         @ compute r3 - r1 and update cpsr \n    subhs r3, r3, r1                                   @ if r3 >= r1 (C=1) then r3 <- r3 - r1 \n    adc r2, r2, r2                                     @ r2 <- r2 + r2 + C. This is equivalent to r2 <- (r2 << 1) + C \n2:\n    subs r4, r4, #1                                    @ r4 <- r4 - 1 \n    bpl 1b                                             @ if r4 >= 0 (N=0) then loop\n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal or DWScript\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nTranslation of: Tcl\nclass Array\n  def knuth_shuffle!\n    j = length\n    i = 0\n    while j > 1\n      r = i + rand(j)\n      self[i], self[r] = self[r], self[i]\n      i += 1\n      j -= 1\n    end\n    self\n  end\nend\n\nr = Hash.new(0)\n100_000.times do |i|\n  a = [1,2,3].knuth_shuffle!\n  r[a] += 1\nend\n\nr.keys.sort.each {|a| puts \"#{a.inspect} => #{r[a]}\"}\n\n[1, 2, 3] => 16572\n[1, 3, 2] => 16610\n[2, 1, 3] => 16633\n[2, 3, 1] => 16714\n[3, 1, 2] => 16838\n[3, 2, 1] => 16633\n\nclass Array\n  def knuth_shuffle!\n    (length - 1).downto(1) do |i|\n      j = rand(i + 1)\n      self[i], self[j] = self[j], self[i]\n    end\n    self\n  end\nend\n", "explain": "results in\nMore idiomatic:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nLibrary: rand\nuse rand::Rng;\n\nextern crate rand;\n\nfn knuth_shuffle<T>(v: &mut [T]) {\n    let mut rng = rand::thread_rng();\n    let l = v.len();\n\n    for n in 0..l {\n        let i = rng.gen_range(0, l - n);\n        v.swap(i, l - n - 1);\n    }\n}\n\nfn main() {\n    let mut v: Vec<_> = (0..10).collect();\n\n    println!(\"before: {:?}\", v);\n    knuth_shuffle(&mut v);\n    println!(\"after:  {:?}\", v);\n}\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\n\nextension BidirectionalCollection where Self: MutableCollection\n{\n\tmutating func shuffleInPlace()\n\t{\n\t\tvar index = self.index(before: self.endIndex)\n\t\twhile index\u00a0!= self.startIndex\n\t\t{\n\t\t\t// Note the use of ... below. This makes the current element eligible for being selected\n\t\t\tlet randomInt = Int.random(in: 0 ... self.distance(from: startIndex, to: index))\n\t\t\tlet randomIndex = self.index(startIndex, offsetBy: randomInt)\n\t\t\tself.swapAt(index, randomIndex)\n\t\t\tindex = self.index(before: index)\n\t\t}\n\t}\n}\n\nvar a = [0, 1, 2, 3, 4, 5, 6, 7, 8, 9]\na.shuffleInPlace()\nprint(a)\n\nOutput:\n[1, 5, 2, 7, 6, 0, 9, 8, 4, 3]\n\nimport func Darwin.arc4random_uniform\n\nextension Array {\n    \n    func shuffle() -> Array {\n        \n        var result = self; result.shuffleInPlace(); return result\n    }\n    \n    mutating func shuffleInPlace() {\n        \n        for i in 1 ..< count { swap(&self[i], &self[Int(arc4random_uniform(UInt32(i+1)))]) }\n    }\n    \n}\n\n// Swift 2.0:\nprint([1, 2, 3, 4, 5, 6, 7, 8, 9, 10].shuffle())\n// Swift 1.x:\n//println([1, 2, 3, 4, 5, 6, 7, 8, 9, 10].shuffle())\n\nOutput:\n[8, 7, 2, 1, 6, 10, 5, 3, 4, 9]\n\nimport func Darwin.arc4random_uniform\n\nfunc shuffleInPlace<T: MutableCollectionType where T.Index: RandomAccessIndexType>(inout collection: T) {\n    \n    let i0 = collection.startIndex\n    \n    for i in i0.successor() ..< collection.endIndex {\n        \n        let j = i0.advancedBy(numericCast(\n                    arc4random_uniform(numericCast(\n                        i0.distanceTo()\n                    )+1)\n                ))\n        \n        swap(&collection[i], &collection[j])\n    }\n}\n\nfunc shuffle<T: MutableCollectionType where T.Index: RandomAccessIndexType>(collection: T) -> T {\n    \n    var result = collection\n    \n    shuffleInPlace(&result)\n    \n    return result\n}\n\n// Swift 2.0:\nprint(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n// Swift 1.x:\n//println(shuffle([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n\nOutput:\n[2, 5, 7, 1, 6, 10, 4, 3, 8, 9]\nWorks with: Swift  version  2.0 While the above solutions work with Swift 2.0 as they are, we can use Swift 2.0's Protocol Oriented Programming features to add shuffling methods to any mutable collection that has a random-access index:\nimport func Darwin.arc4random_uniform\n\n// Define a protocol for shuffling:\n\nprotocol Shufflable {\n    \n    @warn_unused_result (mutable_variant=\"shuffleInPlace\")\n    func shuffle() -> Self\n    \n    mutating func shuffleInPlace()\n    \n}\n\n// Provide a generalized implementation of the shuffling protocol for any mutable collection with random-access index:\n\nextension Shufflable where Self: MutableCollectionType, Self.Index: RandomAccessIndexType {\n    \n    func shuffle() -> Self {\n        \n        var result = self\n        \n        result.shuffleInPlace()\n        \n        return result\n    }\n    \n    mutating func shuffleInPlace() {\n        \n        let i0 = startIndex\n        \n        for i in i0+1 ..< endIndex {\n            \n            let j = i0.advancedBy(numericCast(\n                        arc4random_uniform(numericCast(\n                            i0.distanceTo(i)\n                        )+1)\n                    ))\n\n            swap(&self[i], &self[j])\n        }\n    }\n    \n}\n\n// Declare Array's conformance to Shufflable:\n\nextension Array: Shufflable \n    { /* Implementation provided by Shufflable protocol extension */ }\n\nprint([1, 2, 3, 4, 5, 6, 7, 8, 9, 10].shuffle())\n\nOutput:\n[3, 1, 5, 6, 7, 8, 10, 2, 4, 9]\n", "explain": "Version that works in Swift 5.x and probably above. This version works for any mutable bidirectional collection although O(n) time complexity can only be guaranteed for a RandomAccessCollection where the index meets the Apple requirements for O(1) access to elements.\nAlso has the advantage that it implemented the algorithm as written at the top of this page i.e. it counts down from the end and picks the random element from the part of the array that has not yet been traversed.\nSimple version (any Swift version): Extend Array with shuffle methods; using arc4random_uniform from C stdlib:\nGeneric version (any Swift version): While the above code is generic in that it works with arrays of any element type, we can use generic global functions to define shuffling for any mutable collection with random-access index type which is far more generic than the above code:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nOriginal Fisher-Yates version[edit]\nfisheryatesshuffle <- function(n)\n{\n  pool <- seq_len(n)\n  a <- c()\n  while(length(pool) > 0)\n  {\n     k <- sample.int(length(pool), 1)\n     a <- c(a, pool[k])\n     pool <- pool[-k]\n  }\n  a\n}\nKnuth variation[edit]\nfisheryatesknuthshuffle <- function(n)\n{\n   a <- seq_len(n)\n   while(n >=2)\n   {     \n      k <- sample.int(n, 1)\n      if(k\u00a0!= n)\n      {\n         temp <- a[k]\n         a[k] <- a[n]\n         a[n] <- temp\n      }\n      n <- n - 1\n   }\n   a\n}\n\n#Example usage: \nfisheryatesshuffle(6)                # e.g. 1 3 6 2 4 5\nx <- c(\"foo\", \"bar\", \"baz\", \"quux\")\nx[fisheryatesknuthshuffle(4)]        # e.g. \"bar\"  \"baz\"  \"quux\" \"foo\"\nShort version[edit]\n\nknuth <- function(vec)\n{\n  last <- length(vec)\n  if(last >= 2)\n  {\n    for(i in last:2)\n    {\n      j <- sample(seq_len(i), size = 1)\n      vec[c(i, j)] <- vec[c(j, i)]\n    }\n  }\n  vec\n}\n#Demonstration:\nknuth(integer(0))\nknuth(c(10))\nreplicate(10, knuth(c(10, 20)))\nreplicate(10, knuth(c(10, 20, 30)))\nknuth(c(\"Also\", \"works\", \"for\", \"strings\"))\n\nOutput:\n> knuth(integer(0))\ninteger(0)\n> knuth(c(10))\n[1] 10\n> replicate(10, knuth(c(10, 20)))\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]   20   20   10   10   20   10   20   10   20    10\n[2,]   10   10   20   20   10   20   10   20   10    20\n> replicate(10, knuth(c(10, 20, 30)))\n     [,1] [,2] [,3] [,4] [,5] [,6] [,7] [,8] [,9] [,10]\n[1,]   30   10   20   20   30   30   10   30   10    10\n[2,]   10   20   30   10   10   10   20   20   20    20\n[3,]   20   30   10   30   20   20   30   10   30    30\n> knuth(c(\"Also\", \"works\", \"for\", \"strings\"))\n[1] \"strings\" \"Also\"    \"for\"     \"works\"\n", "explain": "See also, the built-in function 'sample'.  \nAfter accounting for R being 1-indexed rather than 0-indexed, it's not hard to implement the pseudo-code given in the task almost exactly:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. knuth-shuffle.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  i                       PIC 9(8).\n       01  j                       PIC 9(8).\n\n       01  temp                    PIC 9(8).\n\n       LINKAGE SECTION.\n       78  Table-Len               VALUE 10.\n       01  ttable-area.\n           03  ttable              PIC 9(8) OCCURS Table-Len TIMES.\n\n       PROCEDURE DIVISION USING ttable-area.\n           MOVE FUNCTION RANDOM(FUNCTION CURRENT-DATE (11:6)) TO i\n\n           PERFORM VARYING i FROM Table-Len BY -1 UNTIL i = 0\n               COMPUTE j =\n                   FUNCTION MOD(FUNCTION RANDOM * 10000, Table-Len) + 1\n\n               MOVE ttable (i) TO temp\n               MOVE ttable (j) TO ttable (i)\n               MOVE temp TO ttable (j)\n           END-PERFORM\n\n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\ngeneric\n   type Element_Type is private;\n   type Array_Type is array (Positive range <>) of Element_Type;\n   \nprocedure Generic_Shuffle (List : in out Array_Type);\n\nwith Ada.Numerics.Discrete_Random;\n\nprocedure Generic_Shuffle (List : in out Array_Type) is\n   package Discrete_Random is new Ada.Numerics.Discrete_Random(Result_Subtype => Integer);\n   use Discrete_Random;\n   K : Integer;\n   G : Generator;\n   T : Element_Type;\nbegin\n   Reset (G);\n   for I in reverse List'Range loop\n      K := (Random(G) mod I) + 1;\n      T := List(I);\n      List(I) := List(K);\n      List(K) := T;\n   end loop;\nend Generic_Shuffle;\n\n\nwith Ada.Text_IO;\nwith Generic_Shuffle;\n\nprocedure Test_Shuffle is\n   \n   type Integer_Array is array (Positive range <>) of Integer;\n\n   Integer_List : Integer_Array\n     := (1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18);\n   procedure Integer_Shuffle is new Generic_Shuffle(Element_Type => Integer,\n                                                    Array_Type => Integer_Array);\nbegin\n\n   for I in Integer_List'Range loop\n      Ada.Text_IO.Put(Integer'Image(Integer_List(I)));\n   end loop;\n   Integer_Shuffle(List => Integer_List);\n   Ada.Text_IO.New_Line;\n   for I in Integer_List'Range loop\n      Ada.Text_IO.Put(Integer'Image(Integer_List(I)));\n   end loop;\nend Test_Shuffle;\n\n", "explain": "This implementation is a generic shuffle routine, able to shuffle an array of any type.\nAn example using Generic_Shuffle. \n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction knuthshuffle!(r::AbstractRNG, v::AbstractVector)\n    for i in length(v):-1:2\n        j = rand(r, 1:i)\n        v[i], v[j] = v[j], v[i]\n    end\n    return v\nend\nknuthshuffle!(v::AbstractVector) = knuthshuffle!(Base.Random.GLOBAL_RNG, v)\n\nv = collect(1:20)\nprintln(\"# v = $v\\n   -> \", knuthshuffle!(v))\n\n\nOutput:\n# v = [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n   -> [16, 5, 17, 10, 2, 7, 20, 14, 4, 8, 19, 15, 18, 12, 11, 1, 9, 13, 3, 6]\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nobject Knuth {\n    internal val gen = java.util.Random()\n}\n\nfun <T> Array<T>.shuffle(): Array<T> {\n    val a = clone()\n    var n = a.size\n    while (n > 1) {\n        val k = Knuth.gen.nextInt(n--)\n        val t = a[n]\n        a[n] = a[k]\n        a[k] = t\n    }\n    return a\n}\n\nfun main(args: Array<String>) {\n    val str = \"abcdefghijklmnopqrstuvwxyz\".toCharArray()\n    (1..10).forEach {\n        val s = str.toTypedArray().shuffle().toCharArray()\n        println(s)\n        require(s.toSortedSet() == str.toSortedSet())\n    }\n\n    val ia = arrayOf(1, 2, 3, 4, 5, 6, 7, 8, 9, 10)\n    (1..10).forEach {\n        val s = ia.shuffle()\n        println(s.distinct())\n        require(s.toSortedSet() == ia.toSet())\n    }\n}\n\n\nOutput:\nxdhsvtnumjgbywiqoapcelkrfz\npjnegbiyzuhsrclodftwkmaqvx\nbkmqwhzregifyanvsltxjupodc\newhxrlybnjqpvdsozaimkucgft\npdqgoaymbzefnjrwuvilsckxht\nkcpagyuehjswdtvnzfrlbxqomi\niztsmaygkblephcjfnwvxurdoq\npltdyjwivsehckzfaxruqogmbn\nnytfbpmjicgkaueoxwrhlsqvdz\nepucijbvrhwyzdlsqftagxmkon\n[7, 4, 5, 9, 2, 1, 3, 8, 10, 6]\n[8, 10, 5, 4, 3, 6, 1, 2, 7, 9]\n[7, 9, 2, 1, 10, 4, 6, 5, 8, 3]\n[9, 6, 1, 8, 2, 5, 10, 3, 4, 7]\n[7, 3, 6, 9, 10, 2, 5, 4, 1, 8]\n[2, 9, 1, 7, 5, 10, 8, 4, 6, 3]\n[4, 2, 7, 3, 8, 5, 6, 10, 1, 9]\n[4, 8, 7, 6, 10, 5, 2, 1, 3, 9]\n[6, 3, 9, 4, 5, 2, 10, 8, 1, 7]\n[3, 6, 9, 2, 10, 8, 7, 5, 1, 4]\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nsub shuffle {\n  my @a = @_;\n  foreach my $n (1 .. $#a) {\n    my $k = int rand $n + 1;\n    $k == $n or @a[$k, $n] = @a[$n, $k];\n  }\n  return @a;\n}\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\n@interface NSMutableArray (KnuthShuffle)\n- (void)knuthShuffle;\n@end\n@implementation NSMutableArray (KnuthShuffle)\n- (void)knuthShuffle {\n  for (NSUInteger i = self.count-1; i > 0; i--) {\n    NSUInteger j = arc4random_uniform(i+1);\n    [self exchangeObjectAtIndex:i withObjectAtIndex:j];\n  }\n}\n@end\n\nint main() {\n  @autoreleasepool {\n    NSMutableArray *x = [NSMutableArray arrayWithObjects:@0, @1, @2, @3, @4, @5, @6, @7, @8, @9, nil];\n    [x knuthShuffle];\n    NSLog(@\"%@\", x);\n  }\n  return 0;\n}\n\nOutput:\n(\n    9,\n    4,\n    0,\n    8,\n    5,\n    3,\n    2,\n    1,\n    7,\n    6\n)\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nfunction table.shuffle(t)\n  for n = #t, 1, -1 do\n    local k = math.random(n)\n    t[n], t[k] = t[k], t[n]\n  end\n \n  return t\nend\n\nmath.randomseed( os.time() )\na = {1, 2, 3, 4, 5, 6, 7, 8, 9, 10}\ntable.shuffle(a)\nfor i,v in ipairs(a) do print(i,v) end\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\ndef shuffle[T](a: Array[T]) = {\n  for (i <- 1 until a.size reverse) {\n    val j = util.Random nextInt (i + 1)\n    val t = a(i)\n    a(i) = a(j)\n    a(j) = t\n  }\n  a\n}\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nStandard Version[edit]\n\nvoid main() {\n    import std.stdio, std.random;\n\n    auto a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    a.randomShuffle;\n    a.writeln;\n}\n\n\nOutput:\n[8, 9, 3, 1, 7, 5, 4, 6, 2]\nOne Implementation[edit]\n\nimport std.stdio, std.algorithm, std.random, std.range;\n\nvoid knuthShuffle(Range)(Range r)\nif (isRandomAccessRange!Range && hasLength!Range &&\n    hasSwappableElements!Range) {\n    foreach_reverse (immutable i, ref ri; r[1 .. $ - 1])\n        ri.swap(r[uniform(0, i + 1)]);\n}\n\nvoid main() {\n    auto a = [1, 2, 3, 4, 5, 6, 7, 8, 9];\n    a.knuthShuffle;\n    a.writeln;\n}\n\n", "explain": "A variant of the Knuth shuffle is in the D standard library Phobos:\nThis shuffles any collection that supports random access, length and swapping of items:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\nimport System.Random (randomRIO)\n\nmkRands :: Int -> IO [Int]\nmkRands = mapM (randomRIO . (,) 0) . enumFromTo 1 . pred\n\nreplaceAt :: Int -> a -> [a] -> [a]\nreplaceAt i c l =\n  let (a, b) = splitAt i l\n  in a ++ c : drop 1 b\n\nswapElems :: (Int, Int) -> [a] -> [a]\nswapElems (i, j) xs\n  | i == j = xs\n  | otherwise = replaceAt j (xs !! i) $ replaceAt i (xs !! j) xs\n\nknuthShuffle :: [a] -> IO [a]\nknuthShuffle xs = (foldr swapElems xs . zip [1 ..]) <$> mkRands (length xs)\n\n\nimport System.Random (randomRIO)\nimport Data.Bool (bool)\n\nknuthShuffle :: [a] -> IO [a]\nknuthShuffle xs = (foldr swapped xs . zip [1 ..]) <$> randoms (length xs)\n\nswapped :: (Int, Int) -> [a] -> [a]\nswapped (i, j) xs =\n  let go (a, b)\n        | a == b = xs\n        | otherwise =\n          let (m, n) = bool (b, a) (a, b) (b > a)\n              (l, hi:t) = splitAt m xs\n              (ys, lo:zs) = splitAt (pred (n - m)) t\n          in concat [l, lo : ys, hi : zs]\n  in bool xs (go (i, j)) $ ((&&) . (i <) <*> (j <)) $ length xs\n\nrandoms :: Int -> IO [Int]\nrandoms x = mapM (randomRIO . (,) 0) [1 .. pred x]\n\nmain :: IO ()\nmain = knuthShuffle ['a' .. 'k'] >>= print\n\n\n*Main> knuthShuffle  ['a'..'k']\n\"bhjdgfciake\"\n\n*Main> knuthShuffle $ map(ap (,)(+10)) [0..9]\n[(0,10),(8,18),(2,12),(3,13),(9,19),(4,14),(7,17),(1,11),(6,16),(5,15)]\n\nknuthShuffleProcess :: (Show a) => [a] -> IO ()\nknuthShuffleProcess = \n   (mapM_ print. reverse =<<). ap (fmap. (. zip [1..]). scanr swapElems) (mkRands. length)\n\n\nOutput: Detailed example\n\n*Main> knuthShuffleProcess  ['a'..'k']\n\"abcdefghijk\"\n\"abckefghijd\"\n\"jbckefghiad\"\n\"jbckeighfad\"\n\"jbckeihgfad\"\n\"jbhkeicgfad\"\n\"jbhiekcgfad\"\n\"jbeihkcgfad\"\n\"ibejhkcgfad\"\n\"iebjhkcgfad\"\n\"iebjhkcgfad\"\n\nimport Data.Array.ST\nimport Data.STRef\nimport Control.Monad\nimport Control.Monad.ST\nimport Control.Arrow\nimport System.Random\n\nshuffle :: RandomGen g => [a] -> g -> ([a], g)\nshuffle list g = runST $ do\n    r <- newSTRef g\n    let rand range = liftM (randomR range) (readSTRef r) >>=\n            runKleisli (second (Kleisli $ writeSTRef r) >>> arr fst)\n    a <- newAry (1, len) list\n    forM_ [len, len - 1 .. 2] $ \\n -> do\n        k <- rand (1, n)\n        liftM2 (,) (readArray a k) (readArray a n) >>=\n           runKleisli (Kleisli (writeArray a n) *** Kleisli (writeArray a k))\n    liftM2 (,) (getElems a) (readSTRef r)\n  where len = length list\n        newAry :: (Int, Int) -> [a] -> ST s (STArray s Int a)\n        newAry = newListArray\n\n", "explain": "or, as an alternative to making two indexed references into the list with (!!):\nExamples of use of either of the two versions above:\nFunction for showing intermediate results:\nAn imperative implementation using arrays and the ST monad:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\nImplementation\nfunction shuffle( a )\n\tdim i\n\tdim r\n\trandomize timer\n\tfor i = lbound( a ) to ubound( a )\n\t\tr = int( rnd * ( ubound( a ) + 1 )  )\n\t\tif r <> i then\n\t\t\tswap a(i), a(r)\n\t\tend if\n\tnext\n\tshuffle = a\nend function\n\nsub swap( byref a, byref b )\n\tdim tmp\n\ttmp = a\n\ta = b \n\tb = tmp\nend sub\nInvocation\ndim a\na = array( 1,2,3,4,5,6,7,8,9)\nwscript.echo \"before: \", join( a, \", \" )\nshuffle a\nwscript.echo \"after: \", join( a, \", \" )\nshuffle a\nwscript.echo \"after: \", join( a, \", \" )\nwscript.echo \"--\"\na = array( now(), \"cow\", 123, true, sin(1), 16.4 )\nwscript.echo \"before: \", join( a, \", \" )\nshuffle a\nwscript.echo \"after: \", join( a, \", \" )\nshuffle a\nwscript.echo \"after: \", join( a, \", \" )\n\nOutput:\nbefore:  1, 2, 3, 4, 5, 6, 7, 8, 9\nafter:  6, 4, 1, 2, 7, 3, 5, 8, 9\nafter:  8, 7, 3, 2, 6, 5, 9, 1, 4\n--\nbefore:  16/02/2010 5:46:58 PM, cow, 123, True, 0.841470984807897, 16.4\nafter:  True, 16.4, 16/02/2010 5:46:58 PM, 123, cow, 0.841470984807897\nafter:  16.4, 16/02/2010 5:46:58 PM, 123, 0.841470984807897, True, cow\n\n", "explain": ""}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n#!r6rs\n(import (rnrs base (6))\n        (srfi :27 random-bits))\n\n(define (semireverse li n)\n  (define (continue front back n)\n    (cond\n      ((null? back) front)\n      ((zero? n) (cons (car back) (append front (cdr back))))\n      (else (continue (cons (car back) front) (cdr back) (- n 1)))))\n  (continue '() li n))\n\n(define (shuffle li)\n  (if (null? li)\n      ()\n      (let\n          ((li-prime (semireverse li (random-integer (length li)))))\n        (cons (car li-prime) (shuffle (cdr li-prime))))))\n\n#!r6rs\n(import (rnrs base (6))\n        (srfi :27 random-bits))\n\n(define (vector-swap! vec i j)\n  (let\n      ((temp (vector-ref vec i)))\n    (vector-set! vec i (vector-ref vec j))\n    (vector-set! vec j temp)))\n\n(define (countdown n)\n  (if (zero? n)\n      ()\n      (cons n (countdown (- n 1)))))\n\n(define (vector-shuffle! vec)\n  (for-each\n   (lambda (i)\n     (let\n         ((j (random-integer i)))\n       (vector-swap! vec (- i 1) j)))\n   (countdown (vector-length vec))))\n", "explain": "A functional version, using lists (inefficient), somewhat unusual in reversing the entire initial sublist on each pass instead of just swapping:\nA mutable version, using vectors (efficient):\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 3\n$A = 1, 2, 3, 4, 5\nGet-Random $A -Count $A.Count\nWorks with: PowerShell version 2\nfunction shuffle ($a) {\n    $c = $a.Clone()  # make copy to avoid clobbering $a\n    1..($c.Length - 1) | ForEach-Object {\n        $i = Get-Random -Minimum $_ -Maximum $c.Length\n        $c[$_-1],$c[$i] = $c[$i],$c[$_-1]\n        $c[$_-1]  # return newly-shuffled value\n    }\n    $c[-1]  # last value\n}\n\n", "explain": "This yields the values one by one instead of returning the array as a whole, so the rest of the pipeline can work on the values while shuffling is still in progress.\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto swap :i :j :a\n  localmake \"t item :i :a\n  setitem :i :a item :j :a\n  setitem :j :a :t\nend\nto shuffle :a\n  for [i [count :a] 2] [swap 1 + random :i :i :a]\nend\n\nmake \"a {1 2 3 4 5 6 7 8 9 10}\nshuffle :a\nshow :a\n\nto slice :lst :start :finish\n\tlocal \"res\n\tmake \"res []\n\tfor \"i [:start :finish 1] [\n\t\tmake \"j item :i :lst\n\t\tmake \"res se :res :j\n\t]\n\top :res\nend\n\nto setitem :n :lst :val\n\tlocal \"lhs\n\tlocal \"rhs\n\tmake \"lhs slice :lst 1 :n-1\n\tmake \"rhs slice :lst :n+1 count :lst\n\top (se :lhs :val :rhs)\nend\n\nto swap :i :j :a\n\tlocal \"t\n\tmake \"t item :i :a\n\tmake \"a setitem :i :a item :j :a\n\tmake \"a setitem :j :a :t\n\top :a\nend\n\nto shuffle :a\n\tfor \"i [count :a 2] \n\t[\n\t\tmake \"a swap 1 + random :i :i :a\n\t]\n\top :a\nend\n \nmake \"a ( list 1 2 3 4 5 6 7 8 9 10 )\nmake \"a shuffle :a\nshow :a\n", "explain": "Lhogho does not have a setitem, and also does things more 'function'ally.\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\nopen System\n\nlet FisherYatesShuffle (initialList : array<'a>) =                  // '\n    let availableFlags = Array.init initialList.Length (fun i -> (i, true))\n                                                                    // Which items are available and their indices\n    let rnd = new Random()  \n    let nextItem nLeft =\n        let nItem = rnd.Next(0, nLeft)                              // Index out of available items\n        let index =                                                 // Index in original deck\n            availableFlags                                          // Go through available array\n            |> Seq.filter (fun (ndx,f) -> f)                        // and pick out only the available tuples\n            |> Seq.nth nItem                                        // Get the one at our chosen index\n            |> fst                                                  // and retrieve it's index into the original array\n        availableFlags.[index] <- (index, false)                    // Mark that index as unavailable\n        initialList.[index]                                         // and return the original item\n    seq {(initialList.Length) .. -1 .. 1}                           // Going from the length of the list down to 1\n    |> Seq.map (fun i -> nextItem i)                                // yield the next item\n\n\nlet KnuthShuffle (lst : array<'a>) =                   // '\n    let Swap i j =                                                  // Standard swap\n        let item = lst.[i]\n        lst.[i] <- lst.[j]\n        lst.[j] <- item\n    let rnd = new Random()\n    let ln = lst.Length\n    [0..(ln - 2)]                                                   // For all indices except the last\n    |> Seq.iter (fun i -> Swap i (rnd.Next(i, ln)))                 // swap th item at the index with a random one following it (or itself)\n    lst                                                             // Return the list shuffled in place\n\n\n> KnuthShuffle [| \"Darrell\"; \"Marvin\"; \"Doug\"; \"Greg\"; \"Sam\"; \"Ken\" |];;\nval it : string array = [|\"Marvin\"; \"Doug\"; \"Sam\"; \"Darrell\"; \"Ken\"; \"Greg\"|]\n\n", "explain": "Allows a shuffle of arrays of arbitrary items.  Requires 2010 beta of F#.  Lazily returns a sequence.\nThis is the original Fisher-Yates shuffle as described by the link:\nHere's the modified Knuth shuffle which shuffles the original array in place\nExample:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef shuffle = { list ->\n    if (list == null || list.empty) return list\n    def r = new Random()\n    def n = list.size()\n    (n..1).each { i ->\n        def j = r.nextInt(i)\n        list[[i-1, j]] = list[[j, i-1]]\n    }\n    list\n}\n\n\ndef list = [] + (0..20)\nprintln list\nprintln shuffle(list)\nprintln shuffle(list)\nprintln shuffle(list)\n\n\nOutput:\n[0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20]\n[12, 16, 7, 13, 1, 9, 17, 20, 15, 3, 5, 6, 8, 0, 18, 10, 14, 4, 2, 11, 19]\n[17, 6, 10, 1, 18, 5, 7, 13, 2, 11, 16, 3, 14, 0, 4, 20, 19, 12, 8, 9, 15]\n[6, 20, 11, 4, 7, 12, 5, 14, 19, 18, 13, 15, 1, 2, 8, 16, 17, 10, 0, 9, 3]\n", "explain": "Solution:\nTest:\n"}, {"task_name": "Knuth shuffle", "task_url": "https://rosettacode.org/wiki/Knuth_shuffle", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\n# Shuffle an _array_ with indexes from 1 to _len_.\nfunction shuffle(array, len,    i, j, t) {\n\tfor (i = len; i > 1; i--) {\n\t\t# j = random integer from 1 to i\n\t\tj = int(i * rand()) + 1\n\n\t\t# swap array[i], array[j]\n\t\tt = array[i]\n\t\tarray[i] = array[j]\n\t\tarray[j] = t\n\t}\n}\n\n# Test program.\nBEGIN {\n\tlen = split(\"11 22 33 44 55 66 77 88 99 110\", array)\n\tshuffle(array, len)\n\n\tfor (i = 1; i < len; i++) printf \"%s \", array[i]\n\tprintf \"%s\\n\", array[len]\n}\n\n", "explain": "Many arrays in AWK have the first index at 1. \nThis example shows how to shuffle such arrays. \nThe elements can be integers, floating-point numbers, or strings.\n"}]