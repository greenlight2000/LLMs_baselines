[{"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Python", "code": "\nPython 3.X Using defaultdict[edit]\n\n>>> import urllib.request\n>>> from collections import defaultdict\n>>> words = urllib.request.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.values())\n>>> for ana in anagram.values():\n\tif len(ana) >= count:\n\t\tprint ([x.decode() for x in ana])\n\nPython 2.7 version[edit]\n\n>>> import urllib\n>>> from collections import defaultdict\n>>> words = urllib.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagram = defaultdict(list) # map sorted chars to anagrams\n>>> for word in words:\n\tanagram[tuple(sorted(word))].append( word )\n\n\t\n>>> count = max(len(ana) for ana in anagram.itervalues())\n>>> for ana in anagram.itervalues():\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['evil', 'levi', 'live', 'veil', 'vile']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['abel', 'able', 'bale', 'bela', 'elba']\n>>> count\n5\n>>>\n\nPython: Using groupby[edit]\nTranslation of: Haskell\nWorks with: Python version 2.6 sort and then group using groupby()\n>>> import urllib, itertools\n>>> words = urllib.urlopen('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').read().split()\n>>> len(words)\n25104\n>>> anagrams = [list(g) for k,g in itertools.groupby(sorted(words, key=sorted), key=sorted)]\n\n\n>>> count = max(len(ana) for ana in anagrams)\n>>> for ana in anagrams:\n\tif len(ana) >= count:\n\t\tprint ana\n\n\t\t\n['abel', 'able', 'bale', 'bela', 'elba']\n['caret', 'carte', 'cater', 'crate', 'trace']\n['angel', 'angle', 'galen', 'glean', 'lange']\n['alger', 'glare', 'lager', 'large', 'regal']\n['elan', 'lane', 'lean', 'lena', 'neal']\n['evil', 'levi', 'live', 'veil', 'vile']\n>>> count\n5\n>>>\n\n\nWorks with: Python version 3.7\n'''Largest anagram groups found in list of words.'''\n\nfrom os.path import expanduser\nfrom itertools import groupby\nfrom operator import eq\n\n\n# main\u00a0:: IO ()\ndef main():\n    '''Largest anagram groups in local unixdict.txt'''\n\n    print(unlines(\n        largestAnagramGroups(\n            lines(readFile('unixdict.txt'))\n        )\n    ))\n\n\n# largestAnagramGroups\u00a0:: [String] -> [[String]]\ndef largestAnagramGroups(ws):\n    '''A list of the anagram groups of\n       of the largest size found in a\n       given list of words.\n    '''\n\n    # wordChars\u00a0:: String -> (String, String)\n    def wordChars(w):\n        '''A word paired with its\n           AZ sorted characters\n        '''\n        return (''.join(sorted(w)), w)\n\n    groups = list(map(\n        compose(list)(snd),\n        groupby(\n            sorted(\n                map(wordChars, ws),\n                key=fst\n            ),\n            key=fst\n        )\n    ))\n\n    intMax = max(map(len, groups))\n    return list(map(\n        compose(unwords)(curry(map)(snd)),\n        filter(compose(curry(eq)(intMax))(len), groups)\n    ))\n\n\n# GENERIC -------------------------------------------------\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# curry\u00a0:: ((a, b) -> c) -> a -> b -> c\ndef curry(f):\n    '''A curried function derived\n       from an uncurried function.'''\n    return lambda a: lambda b: f(a, b)\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# lines\u00a0:: String -> [String]\ndef lines(s):\n    '''A list of strings,\n       (containing no newline characters)\n       derived from a single new-line delimited string.'''\n    return s.splitlines()\n\n\n# from os.path import expanduser\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\n# unwords\u00a0:: [String] -> String\ndef unwords(xs):\n    '''A space-separated string derived from\n       a list of words.'''\n    return ' '.join(xs)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\ncaret carte cater crate creat creta react recta trace\nangor argon goran grano groan nagor orang organ rogan\nester estre reest reset steer stere stree terse tsere\n", "explain": "Python 3.2 shell input (IDLE)\nPython 2.7 shell input (IDLE)\n\nOr, disaggregating, speeding up a bit by avoiding the slightly expensive use of sorted as a key, updating for Python 3, and using a local unixdict.txt: \n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <time.h>\n\nchar *sortedWord(const char *word, char *wbuf)\n{\n    char *p1, *p2, *endwrd;\n    char t;\n    int swaps;\n\n    strcpy(wbuf, word);\n    endwrd = wbuf+strlen(wbuf);\n    do {\n       swaps = 0;\n       p1 = wbuf; p2 = endwrd-1;\n       while (p1<p2) {\n          if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n          }\n          p1++; p2--;\n       }\n       p1 = wbuf; p2 = p1+1;\n       while(p2 < endwrd) {\n           if (*p2 > *p1) {\n             t = *p2; *p2 = *p1; *p1 = t;\n             swaps = 1;\n           }\n           p1++; p2++;\n       }\n    } while (swaps);\n    return wbuf;\n}\n\nstatic\nshort cxmap[] = {\n    0x06, 0x1f, 0x4d, 0x0c, 0x5c, 0x28, 0x5d, 0x0e, 0x09, 0x33, 0x31, 0x56,\n    0x52, 0x19, 0x29, 0x53, 0x32, 0x48, 0x35, 0x55, 0x5e, 0x14, 0x27, 0x24,\n    0x02, 0x3e, 0x18, 0x4a, 0x3f, 0x4c, 0x45, 0x30, 0x08, 0x2c, 0x1a, 0x03,\n    0x0b, 0x0d, 0x4f, 0x07, 0x20, 0x1d, 0x51, 0x3b, 0x11, 0x58, 0x00, 0x49,\n    0x15, 0x2d, 0x41, 0x17, 0x5f, 0x39, 0x16, 0x42, 0x37, 0x22, 0x1c, 0x0f,\n    0x43, 0x5b, 0x46, 0x4b, 0x0a, 0x26, 0x2e, 0x40, 0x12, 0x21, 0x3c, 0x36,\n    0x38, 0x1e, 0x01, 0x1b, 0x05, 0x4e, 0x44, 0x3d, 0x04, 0x10, 0x5a, 0x2a,\n    0x23, 0x34, 0x25, 0x2f, 0x2b, 0x50, 0x3a, 0x54, 0x47, 0x59, 0x13, 0x57,\n   };\n#define CXMAP_SIZE (sizeof(cxmap)/sizeof(short))\n\n\nint Str_Hash( const char *key, int ix_max )\n{\n   const char *cp;\n   short mash;\n   int  hash = 33501551;\n   for (cp = key; *cp; cp++) {\n      mash = cxmap[*cp % CXMAP_SIZE];\n      hash = (hash >>4) ^ 0x5C5CF5C ^ ((hash<<1) + (mash<<5));\n      hash &= 0x3FFFFFFF;\n      }\n   return  hash % ix_max;\n}\n\ntypedef struct sDictWord  *DictWord;\nstruct sDictWord {\n    const char *word;\n    DictWord next;\n};\n\ntypedef struct sHashEntry *HashEntry;\nstruct sHashEntry {\n    const char *key;\n    HashEntry next;\n    DictWord  words;\n    HashEntry link;\n    short wordCount;\n};\n\n#define HT_SIZE 8192\n\nHashEntry hashTable[HT_SIZE];\n\nHashEntry mostPerms = NULL;\n\nint buildAnagrams( FILE *fin )\n{\n    char buffer[40];\n    char bufr2[40];\n    char *hkey;\n    int hix;\n    HashEntry he, *hep;\n    DictWord  we;\n    int  maxPC = 2;\n    int numWords = 0;\n    \n    while ( fgets(buffer, 40, fin)) {\n        for(hkey = buffer; *hkey && (*hkey!='\\n'); hkey++);\n        *hkey = 0;\n        hkey = sortedWord(buffer, bufr2);\n        hix = Str_Hash(hkey, HT_SIZE);\n        he = hashTable[hix]; hep = &hashTable[hix];\n        while( he && strcmp(he->key , hkey) ) {\n            hep = &he->next;\n            he = he->next;\n        }\n        if ( ! he ) {\n            he = malloc(sizeof(struct sHashEntry));\n            he->next = NULL;\n            he->key = strdup(hkey);\n            he->wordCount = 0;\n            he->words = NULL;\n            he->link = NULL;\n            *hep = he;\n        }\n        we = malloc(sizeof(struct sDictWord));\n        we->word = strdup(buffer);\n        we->next = he->words;\n        he->words = we;\n        he->wordCount++;\n        if ( maxPC < he->wordCount) {\n            maxPC = he->wordCount;\n            mostPerms = he;\n            he->link = NULL;\n        }\n        else if (maxPC == he->wordCount) {\n            he->link = mostPerms;\n            mostPerms = he;\n        }\n         \n        numWords++;\n    }\n    printf(\"%d words in dictionary max ana=%d\\n\", numWords, maxPC);\n    return maxPC;\n}\n\n\nint main( ) \n{\n    HashEntry he;\n    DictWord  we;\n    FILE *f1;\n    \n    f1 = fopen(\"unixdict.txt\",\"r\");\n    buildAnagrams(f1);\n    fclose(f1);\n    \n    f1 = fopen(\"anaout.txt\",\"w\");\n//    f1 = stdout;\n\n    for (he = mostPerms; he; he = he->link) {\n        fprintf(f1,\"%d:\", he->wordCount);\n        for(we = he->words; we; we = we->next) {\n            fprintf(f1,\"%s, \", we->word);\n        }\n        fprintf(f1, \"\\n\");\n    }\n\n    fclose(f1);\n    return 0;\n}\n\n\nOutput: (less than 1 second on old P500)\n5:vile, veil, live, levi, evil, \n5:trace, crate, cater, carte, caret, \n5:regal, large, lager, glare, alger, \n5:neal, lena, lean, lane, elan, \n5:lange, glean, galen, angle, angel, \n5:elba, bela, bale, able, abel, \n\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <fcntl.h>\n#include <unistd.h>\n#include <sys/stat.h>\n#include <string.h>\n\ntypedef struct { const char *key, *word; int cnt; } kw_t;\n\nint lst_cmp(const void *a, const void *b)\n{\n\treturn strcmp(((const kw_t*)a)->key, ((const kw_t*)b)->key);\n}\n\n/* Bubble sort.  Faster than stock qsort(), believe it or not */\nvoid sort_letters(char *s)\n{\n\tint i, j;\n\tchar t;\n\tfor (i = 0; s[i] != '\\0'; i++) {\n\t\tfor (j = i + 1; s[j] != '\\0'; j++)\n\t\t\tif (s[j] < s[i]) {\n\t\t\t\tt = s[j]; s[j] = s[i]; s[i] = t;\n\t\t\t}\n\t}\n}\n\nint main()\n{\n\tstruct stat s;\n\tchar *words, *keys;\n\tsize_t i, j, k, longest, offset;\n\tint n_word = 0;\n\tkw_t *list;\n\n\tint fd = open(\"unixdict.txt\", O_RDONLY);\n\tif (fd == -1) return 1;\n\tfstat(fd, &s);\n\twords = malloc(s.st_size * 2);\n\tkeys  = words + s.st_size;\n\n\tread(fd, words, s.st_size);\n\tmemcpy(keys, words, s.st_size);\n\n\t/* change newline to null for easy use; sort letters in keys */\n\tfor (i = j = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\n') {\n\t\t\twords[i] = keys[i] = '\\0';\n\t\t\tsort_letters(keys + j);\n\t\t\tj = i + 1;\n\t\t\tn_word ++;\n\t\t}\n\t}\n\n\tlist = calloc(n_word, sizeof(kw_t));\n\n\t/* make key/word pointer pairs for sorting */\n\tfor (i = j = k = 0; i < s.st_size; i++) {\n\t\tif (words[i] == '\\0') {\n\t\t\tlist[j].key = keys + k;\n\t\t\tlist[j].word = words + k;\n\t\t\tk = i + 1;\n\t\t\tj++;\n\t\t}\n\t}\n\n\tqsort(list, n_word, sizeof(kw_t), lst_cmp);\n\n\t/* count each key's repetition */\n\tfor (i = j = k = offset = longest = 0; i < n_word; i++) {\n\t\tif (!strcmp(list[i].key, list[j].key)) {\n\t\t\t++k;\n\t\t\tcontinue;\n\t\t}\n\n\t\t/* move current longest to begining of array */\n\t\tif (k < longest) {\n\t\t\tk = 0;\n\t\t\tj = i;\n\t\t\tcontinue;\n\t\t}\n\n\t\tif (k > longest) offset = 0;\n\n\t\twhile (j < i) list[offset++] = list[j++];\n\t\tlongest = k;\n\t\tk = 0;\n\t}\n\n\t/* show the longest */\n\tfor (i = 0; i < offset; i++) {\n\t\tprintf(\"%s \", list[i].word);\n\t\tif (i < n_word - 1 && strcmp(list[i].key, list[i+1].key))\n\t\t\tprintf(\"\\n\");\n\t}\n\n\t/* free(list); free(words); */\n\tclose(fd);\n\treturn 0;\n}\n\n\nOutput:\nabel able bale bela elba \ncaret carte cater crate trace \nangel angle galen glean lange \nalger glare lager large regal \nelan lane lean lena neal \nevil levi live veil vile\n\n", "explain": "A much shorter version with no fancy data structures:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "C++", "code": "\n#include <iostream>\n#include <fstream>\n#include <string>\n#include <map>\n#include <vector>\n#include <algorithm>\n#include <iterator>\n \nint main() {\n  std::ifstream in(\"unixdict.txt\");\n  typedef  std::map<std::string, std::vector<std::string> > AnagramMap;\n  AnagramMap anagrams;\n \n  std::string word;\n  size_t count = 0;\n  while (std::getline(in, word)) {\n    std::string key = word;\n    std::sort(key.begin(), key.end());\n    // note: the [] op. automatically inserts a new value if key does not exist\n    AnagramMap::mapped_type & v = anagrams[key];\n    v.push_back(word);\n    count = std::max(count, v.size());\n  }\n \n  in.close();\n \n  for (AnagramMap::const_iterator it = anagrams.begin(), e = anagrams.end();\n       it != e; it++)\n    if (it->second.size() >= count) {\n      std::copy(it->second.begin(), it->second.end(),\n                std::ostream_iterator<std::string>(std::cout, \", \"));\n      std::cout << std::endl;\n    }\n  return 0;\n}\n\n\nOutput:\nabel, able, bale, bela, elba, \ncaret, carte, cater, crate, trace, \nangel, angle, galen, glean, lange, \nalger, glare, lager, large, regal, \nelan, lane, lean, lena, neal, \nevil, levi, live, veil, vile,\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Java", "code": "\n\nWorks with: Java version 1.5+\nimport java.net.*;\nimport java.io.*;\nimport java.util.*;\n \npublic class WordsOfEqChars {\n    public static void main(String[] args) throws IOException {\n        URL url = new URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\");\n        InputStreamReader isr = new InputStreamReader(url.openStream());\n        BufferedReader reader = new BufferedReader(isr);\n\n        Map<String, Collection<String>> anagrams = new HashMap<String, Collection<String>>();\n        String word;\n        int count = 0;\n        while ((word = reader.readLine()) != null) {\n            char[] chars = word.toCharArray();\n            Arrays.sort(chars);\n            String key = new String(chars);\n            if (!anagrams.containsKey(key))\n                anagrams.put(key, new ArrayList<String>());\n            anagrams.get(key).add(word);\n            count = Math.max(count, anagrams.get(key).size());\n        }\n\n        reader.close();\n\n        for (Collection<String> ana : anagrams.values())\n            if (ana.size() >= count)\n                System.out.println(ana);\n    }   \n}\n\nWorks with: Java version 1.8+\nimport java.net.*;\nimport java.io.*;\nimport java.util.*;\nimport java.util.concurrent.*;\nimport java.util.function.*;\n\npublic interface Anagram {\n  public static <AUTOCLOSEABLE extends AutoCloseable, OUTPUT> Supplier<OUTPUT> tryWithResources(Callable<AUTOCLOSEABLE> callable, Function<AUTOCLOSEABLE, Supplier<OUTPUT>> function, Supplier<OUTPUT> defaultSupplier) {\n    return () -> {\n      try (AUTOCLOSEABLE autoCloseable = callable.call()) {\n        return function.apply(autoCloseable).get();\n      } catch (Throwable throwable) {\n        return defaultSupplier.get();\n      }\n    };\n  }\n\n  public static <INPUT, OUTPUT> Function<INPUT, OUTPUT> function(Supplier<OUTPUT> supplier) {\n    return i -> supplier.get();\n  }\n\n  public static void main(String... args) {\n    Map<String, Collection<String>> anagrams = new ConcurrentSkipListMap<>();\n    int count = tryWithResources(\n      () -> new BufferedReader(\n        new InputStreamReader(\n          new URL(\n            \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\n          ).openStream()\n        )\n      ),\n      reader -> () -> reader.lines()\n        .parallel()\n        .mapToInt(word -> {\n          char[] chars = word.toCharArray();\n          Arrays.parallelSort(chars);\n          String key = Arrays.toString(chars);\n          Collection<String> collection = anagrams.computeIfAbsent(\n            key, function(ArrayList::new)\n          );\n          collection.add(word);\n          return collection.size();\n        })\n        .max()\n        .orElse(0),\n      () -> 0\n    ).get();\n    anagrams.values().stream()\n      .filter(ana -> ana.size() >= count)\n      .forEach(System.out::println)\n    ;\n  }\n}\n\n\nOutput:\n[angel, angle, galen, glean, lange]\n[elan, lane, lean, lena, neal]\n[alger, glare, lager, large, regal]\n[abel, able, bale, bela, elba]\n[evil, levi, live, veil, vile]\n[caret, carte, cater, crate, trace]\n\n", "explain": "The key to this algorithm is the sorting of the characters in each word from the dictionary. The line Arrays.sort(chars); sorts all of the letters in the word in ascending order using a built-in quicksort, so all of the words in the first group in the result end up under the key \"aegln\" in the anagrams map.\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "C#", "code": "\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Net;\nusing System.Text.RegularExpressions;\n\nnamespace Anagram\n{\n    class Program\n    {\n        const string DICO_URL = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\";\n\n        static void Main( string[] args )\n        {\n            WebRequest request = WebRequest.Create(DICO_URL);\n            string[] words;\n            using (StreamReader sr = new StreamReader(request.GetResponse().GetResponseStream(), true)) {\n                words = Regex.Split(sr.ReadToEnd(), @\"\\r?\\n\");\n            }\n            var groups = from string w in words\n                         group w by string.Concat(w.OrderBy(x => x)) into c\n                         group c by c.Count() into d\n                         orderby d.Key descending\n                         select d;\n            foreach (var c in groups.First()) {\n                Console.WriteLine(string.Join(\" \", c));\n            }\n        }\n    }\n}\n\n\nOutput:\nabel able bale bela elba\nalger glare lager large regal\nangel angle galen glean lange\ncaret carte cater crate trace\nelan lane lean lena neal\nevil levi live veil vile\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "JavaScript", "code": "\nES5[edit]\nWorks with: Node.js\nvar fs = require('fs');\nvar words = fs.readFileSync('unixdict.txt', 'UTF-8').split('\\n');\n\nvar i, item, max = 0,\n    anagrams = {};\n \nfor (i = 0; i < words.length; i += 1) {\n  var key = words[i].split('').sort().join('');\n  if (!anagrams.hasOwnProperty(key)) {//check if property exists on current obj only\n      anagrams[key] = [];\n  }\n  var count = anagrams[key].push(words[i]); //push returns new array length\n  max = Math.max(count, max);\n}\n\n//note, this returns all arrays that match the maximum length\nfor (item in anagrams) {\n  if (anagrams.hasOwnProperty(item)) {//check if property exists on current obj only\n    if (anagrams[item].length === max) {\n        console.log(anagrams[item].join(' '));\n    }\n  }\n}\n\n\nOutput:\n[ 'abel', 'able', 'bale', 'bela', 'elba' ]\n[ 'alger', 'glare', 'lager', 'large', 'regal' ]\n[ 'angel', 'angle', 'galen', 'glean', 'lange' ]\n[ 'caret', 'carte', 'cater', 'crate', 'trace' ]\n[ 'elan', 'lane', 'lean', 'lena', 'neal' ]\n[ 'evil', 'levi', 'live', 'veil', 'vile' ]\n\nvar fs = require('fs');\nvar dictionary = fs.readFileSync('unixdict.txt', 'UTF-8').split('\\n');\n\n//group anagrams\nvar sortedDict = dictionary.reduce(function (acc, word) {\n  var sortedLetters = word.split('').sort().join('');\n  if (acc[sortedLetters] === undefined) { acc[sortedLetters] = []; }\n  acc[sortedLetters].push(word);\n  return acc;\n}, {});\n\n//sort list by frequency\nvar keysSortedByFrequency = Object.keys(sortedDict).sort(function (keyA, keyB) {\n  if (sortedDict[keyA].length < sortedDict[keyB].length) { return 1; }\n  if (sortedDict[keyA].length > sortedDict[keyB].length) { return -1; }\n  return 0;\n});\n\n//print first 10 anagrams by frequency\nkeysSortedByFrequency.slice(0, 10).forEach(function (key) {\n  console.log(sortedDict[key].join(' '));\n});\n\n\nES6[edit]\n\n(() => {\n    'use strict';\n\n    // largestAnagramGroups\u00a0:: FilePath -> Either String [[String]]\n    const largestAnagramGroups = fp =>\n        either(msg => msg)(strLexicon => {\n            const\n                groups = sortBy(flip(comparing(length)))(\n                    groupBy(on(eq)(fst))(\n                        sortBy(comparing(fst))(\n                            strLexicon\n                            .split(/[\\r\\n]/)\n                            .map(w => [w.split('').sort().join(''), w])\n                        )\n                    )\n                ),\n                maxSize = groups[0].length;\n            return map(map(snd))(\n                takeWhile(x => maxSize === x.length)(\n                    groups\n                )\n            )\n        })(readFileLR(fp));\n\n    // ------------------------TEST------------------------\n    const main = () =>\n        console.log(JSON.stringify(\n            largestAnagramGroups('unixdict.txt'),\n            null, 2\n        ))\n\n\n    // -----------------GENERIC FUNCTIONS------------------\n\n    // Left\u00a0:: a -> Either a b\n    const Left = x => ({\n        type: 'Either',\n        Left: x\n    });\n\n    // Right\u00a0:: b -> Either a b\n    const Right = x => ({\n        type: 'Either',\n        Right: x\n    });\n\n    // Tuple (,)\u00a0:: a -> b -> (a, b)\n    const Tuple = a =>\n        b => ({\n            type: 'Tuple',\n            '0': a,\n            '1': b,\n            length: 2\n        });\n\n    // comparing\u00a0:: (a -> b) -> (a -> a -> Ordering)\n    const comparing = f =>\n        x => y => {\n            const\n                a = f(x),\n                b = f(y);\n            return a < b ? -1 : (a > b ? 1 : 0);\n        };\n\n    // either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\n    const either = fl =>\n        fr => e => 'Either' === e.type ? (\n            undefined !== e.Left ? (\n                fl(e.Left)\n            ) : fr(e.Right)\n        ) : undefined;\n\n    // eq (==)\u00a0:: Eq a => a -> a -> Bool\n    const eq = a =>\n        // True when a and b are equivalent.\n        b => a === b\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        1 < f.length ? (\n            (a, b) => f(b, a)\n        ) : (x => y => f(y)(x));\n\n    // fst\u00a0:: (a, b) -> a\n    const fst = tpl =>\n        // First member of a pair.\n        tpl[0];\n\n    // groupBy\u00a0:: (a -> a -> Bool) -> [a] -> [[a]]\n    const groupBy = fEq => xs =>\n        // // Typical usage: groupBy(on(eq)(f), xs)\n        0 < xs.length ? (() => {\n            const\n                tpl = xs.slice(1).reduce(\n                    (gw, x) => {\n                        const\n                            gps = gw[0],\n                            wkg = gw[1];\n                        return fEq(wkg[0])(x) ? (\n                            Tuple(gps)(wkg.concat([x]))\n                        ) : Tuple(gps.concat([wkg]))([x]);\n                    },\n                    Tuple([])([xs[0]])\n                );\n            return tpl[0].concat([tpl[1]])\n        })() : [];\n\n    // length\u00a0:: [a] -> Int\n    const length = xs => xs.length\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => xs.map(f);\n\n    // on\u00a0:: (b -> b -> c) -> (a -> b) -> a -> a -> c\n    const on = f =>\n        // e.g. sortBy(on(compare,length), xs)\n        g => a => b => f(g(a))(g(b));\n\n    // readFileLR\u00a0:: FilePath -> Either String IO String\n    const readFileLR = fp => {\n        const\n            e = $(),\n            ns = $.NSString\n            .stringWithContentsOfFileEncodingError(\n                $(fp).stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                e\n            );\n        return ns.isNil() ? (\n            Left(ObjC.unwrap(e.localizedDescription))\n        ) : Right(ObjC.unwrap(ns));\n    };\n\n    // snd\u00a0:: (a, b) -> b\n    const snd = tpl => tpl[1];\n\n    // sortBy\u00a0:: (a -> a -> Ordering) -> [a] -> [a]\n    const sortBy = f =>\n        xs => xs.slice()\n        .sort((a, b) => f(a)(b));\n\n    // takeWhile\u00a0:: (a -> Bool) -> [a] -> [a]\n    // takeWhile\u00a0:: (Char -> Bool) -> String -> String\n    const takeWhile = p =>\n        xs => {\n            const lng = xs.length;\n            return 0 < lng ? xs.slice(\n                0,\n                until(i => lng === i || !p(xs[i]))(\n                    i => 1 + i\n                )(0)\n            ) : [];\n        };\n\n    // until\u00a0:: (a -> Bool) -> (a -> a) -> a -> a\n    const until = p => f => x => {\n        let v = x;\n        while (!p(v)) v = f(v);\n        return v;\n    };\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[\n  [\n    \"abel\",\n    \"able\",\n    \"bale\",\n    \"bela\",\n    \"elba\"\n  ],\n  [\n    \"caret\",\n    \"carte\",\n    \"cater\",\n    \"crate\",\n    \"trace\"\n  ],\n  [\n    \"angel\",\n    \"angle\",\n    \"galen\",\n    \"glean\",\n    \"lange\"\n  ],\n  [\n    \"alger\",\n    \"glare\",\n    \"lager\",\n    \"large\",\n    \"regal\"\n  ],\n  [\n    \"elan\",\n    \"lane\",\n    \"lean\",\n    \"lena\",\n    \"neal\"\n  ],\n  [\n    \"evil\",\n    \"levi\",\n    \"live\",\n    \"veil\",\n    \"vile\"\n  ]\n]\n", "explain": "Alternative using reduce:\n\nUsing JavaScript for Automation\n(A JavaScriptCore interpreter on macOS with an Automation library).\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Visual_Basic_.NET", "code": "\nImports System.IO\nImports System.Collections.ObjectModel\n\nModule Module1\n\n  Dim sWords As New Dictionary(Of String, Collection(Of String))\n\n  Sub Main()\n\n    Dim oStream As StreamReader = Nothing\n    Dim sLines() As String = Nothing\n    Dim sSorted As String = Nothing\n    Dim iHighCount As Integer = 0\n    Dim iMaxKeyLength As Integer = 0\n    Dim sOutput As String = \"\"\n\n    oStream = New StreamReader(\"unixdict.txt\")\n    sLines = oStream.ReadToEnd.Split(New String() {vbCrLf}, StringSplitOptions.RemoveEmptyEntries)\n    oStream.Close()\n\n    For i As Integer = 0 To sLines.GetUpperBound(0)\n      sSorted = SortCharacters(sLines(i))\n\n      If Not sWords.ContainsKey(sSorted) Then sWords.Add(sSorted, New Collection(Of String))\n\n      sWords(sSorted).Add(sLines(i))\n\n      If sWords(sSorted).Count > iHighCount Then\n        iHighCount = sWords(sSorted).Count\n\n        If sSorted.Length > iMaxKeyLength Then iMaxKeyLength = sSorted.Length\n      End If\n    Next\n\n    For Each sKey As String In sWords.Keys\n      If sWords(sKey).Count = iHighCount Then\n        sOutput &= \"[\" & sKey.ToUpper & \"]\" & Space(iMaxKeyLength - sKey.Length + 1) & String.Join(\", \", sWords(sKey).ToArray()) & vbCrLf\n      End If\n    Next\n\n    Console.WriteLine(sOutput)\n    Console.ReadKey()\n\n  End Sub\n\n  Private Function SortCharacters(ByVal s As String) As String\n\n    Dim sReturn() As Char = s.ToCharArray()\n    Dim sTemp As Char = Nothing\n\n    For i As Integer = 0 To sReturn.GetUpperBound(0) - 1\n      If (sReturn(i + 1)) < (sReturn(i)) Then\n        sTemp = sReturn(i)\n        sReturn(i) = sReturn(i + 1)\n        sReturn(i + 1) = sTemp\n        i = -1\n      End If\n    Next\n\n    Return CStr(sReturn)\n\n  End Function\n\nEnd Module\n\nOutput:\n[ABEL]  abel, able, bale, bela, elba\n[AEGLR] alger, glare, lager, large, regal\n[AEGLN] angel, angle, galen, glean, lange\n[ACERT] caret, carte, cater, crate, trace\n[AELN]  elan, lane, lean, lena, neal\n[EILV]  evil, levi, live, veil, vile\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "PHP", "code": "\n<?php\n$words = explode(\"\\n\", file_get_contents('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'));\nforeach ($words as $word) {\n    $chars = str_split($word);\n    sort($chars);\n    $anagram[implode($chars)][] = $word;\n}\n\n$best = max(array_map('count', $anagram));\nforeach ($anagram as $ana)\n    if (count($ana) == $best)\n        print_r($ana);\n?>\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Fortran", "code": "\n\n!***************************************************************************************\n\tmodule anagram_routines\n!***************************************************************************************\n\timplicit none\n\t\n\t!the dictionary file:\n\tinteger,parameter :: file_unit = 1000\n\tcharacter(len=*),parameter :: filename = 'unixdict.txt'\n\t\n\t!maximum number of characters in a word:\n\tinteger,parameter :: max_chars = 50\n\t\n\t!maximum number of characters in the string displaying the anagram lists:\n\tinteger,parameter :: str_len = 256\n\t\n\ttype word \n\t  character(len=max_chars) :: str = repeat(' ',max_chars)    !the word from the dictionary\n\t  integer                  :: n = 0                          !length of this word\n\t  integer                  :: n_anagrams = 0\t             !number of anagrams found\n\t  logical                  :: checked = .false.              !if this one has already been checked\n\t  character(len=str_len)   :: anagrams = repeat(' ',str_len) !the anagram list for this word\n\tend type word\n\t\n\t!the dictionary structure:\n\ttype(word),dimension(:),allocatable,target :: dict\n\t\n\tcontains\n!***************************************************************************************\n\n\t!******************************************************************************\n\t\tfunction count_lines_in_file(fid) result(n_lines)\n\t!******************************************************************************\n\t\timplicit none\n\t\n\t\tinteger             :: n_lines\n\t\tinteger,intent(in)  :: fid\t\t\n\t\tcharacter(len=1)    :: tmp\n\t\tinteger             :: i\n\t\tinteger             :: ios\n\t\t\n\t\t!the file is assumed to be open already.\n\t\t\n\t\trewind(fid)\t  !rewind to beginning of the file\n\t\t\n\t\tn_lines = 0\n\t\tdo !read each line until the end of the file.\n\t\t\tread(fid,'(A1)',iostat=ios) tmp\n\t\t\tif (ios < 0) exit      !End of file\n\t\t\tn_lines = n_lines + 1  !row counter\n\t\tend do\n\n\t\trewind(fid)   !rewind to beginning of the file\t\n\t\t\t\t\n\t!******************************************************************************\n\t\tend function count_lines_in_file\n\t!******************************************************************************\n\t\n\t!******************************************************************************\n\t\tpure elemental function is_anagram(x,y)\n\t!******************************************************************************\n\t\timplicit none\n\t\tcharacter(len=*),intent(in) :: x\n\t\tcharacter(len=*),intent(in) :: y\n\t\tlogical :: is_anagram\n\t\n\t\tcharacter(len=len(x)) :: x_tmp\t!a copy of x\n\t\tinteger :: i,j\n\t\t\n\t\t!a character not found in any word:\n\t\tcharacter(len=1),parameter :: null = achar(0)\n\t\t\t\n\t\t!x and y are assumed to be the same size.\n\t\t\n\t\tx_tmp = x\n\t\tdo i=1,len_trim(x)\n\t\t\tj = index(x_tmp, y(i:i)) !look for this character in x_tmp\n\t\t\tif (j/=0) then\n\t\t\t\tx_tmp(j:j) = null  !clear it so it won't be checked again\n\t\t\telse\n\t\t\t\tis_anagram = .false. !character not found: x,y are not anagrams\n\t\t\t\treturn\n\t\t\tend if\n\t\tend do\n\t\n\t\t!if we got to this point, all the characters \n\t\t! were the same, so x,y are anagrams:\n\t\tis_anagram = .true.\n\t\t\t\t\t\n\t!******************************************************************************\n\t\tend function is_anagram\n\t!******************************************************************************\n\n!***************************************************************************************\n\tend module anagram_routines\n!***************************************************************************************\n\n!***************************************************************************************\n\tprogram main\n!***************************************************************************************\n\tuse anagram_routines\n\timplicit none\n\t\n\tinteger :: n,i,j,n_max\n\ttype(word),pointer :: x,y\n\tlogical :: first_word\n\treal :: start, finish\n\t\n\tcall cpu_time(start)\t!..start timer\n\t\n\t!open the dictionary and read in all the words:\n\topen(unit=file_unit,file=filename)      !open the file\n\tn = count_lines_in_file(file_unit)      !count lines in the file\n\tallocate(dict(n))                       !allocate dictionary structure\n\tdo i=1,n                                !\n\t\tread(file_unit,'(A)') dict(i)%str   !each line is a word in the dictionary\n\t\tdict(i)%n = len_trim(dict(i)%str)   !saving length here to avoid trim's below\n\tend do\t\t\n\tclose(file_unit)                        !close the file\n\t\n\t!search dictionary for anagrams:\n\tdo i=1,n\n\t\t\n\t\tx => dict(i)\t!pointer to simplify code\n\t\tfirst_word = .true.\t!initialize\n\t\t\n\t\tdo j=i,n\n\t\t\n\t\t\ty => dict(j)\t!pointer to simplify code\n\t\t\t\n\t\t\t!checks to avoid checking words unnecessarily:\n\t\t\tif (x%checked .or. y%checked) cycle     !both must not have been checked already\n\t\t\tif (x%n/=y%n) cycle                     !must be the same size\n\t\t\tif (x%str(1:x%n)==y%str(1:y%n)) cycle   !can't be the same word\n\t\t\t\n\t\t\t! check to see if x,y are anagrams:\n\t\t\tif (is_anagram(x%str(1:x%n), y%str(1:y%n))) then\n\t\t\t\t!they are anagrams.\n\t\t\t\ty%checked = .true. \t!don't check this one again.\n\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\tif (first_word) then\n\t\t\t\t\t!this is the first anagram found for this word.\n\t\t\t\t\tfirst_word = .false.\n\t\t\t\t\tx%n_anagrams = x%n_anagrams + 1\n\t\t\t\t\tx%anagrams = trim(x%anagrams)//x%str(1:x%n)  !add first word to list\n\t\t\t\tend if\n\t\t\t\tx%anagrams = trim(x%anagrams)//','//y%str(1:y%n) !add next word to list\n\t\t\tend if\n\t\n\t\tend do\n\t\tx%checked = .true.  !don't check this one again\n\t\t \n\tend do\n\t\n\t!anagram groups with the most words:\n\twrite(*,*) ''\n\tn_max = maxval(dict%n_anagrams)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\t\n\t!anagram group containing longest words:\n\twrite(*,*) ''\n\tn_max = maxval(dict%n, mask=dict%n_anagrams>0)\n\tdo i=1,n\n\t\tif (dict(i)%n_anagrams>0 .and. dict(i)%n==n_max) write(*,'(A)') trim(dict(i)%anagrams)\n\tend do\n\twrite(*,*) ''\n\n\tcall cpu_time(finish)\t!...stop timer\n\twrite(*,'(A,F6.3,A)') '[Runtime = ',finish-start,' sec]'\n\twrite(*,*) ''\n\n!***************************************************************************************\n\tend program main\n!***************************************************************************************\n\n\nOutput:\n\tabel,able,bale,bela,elba\n\talger,glare,lager,large,regal\n\tangel,angle,galen,glean,lange\n\tcaret,carte,cater,crate,trace\n\telan,lane,lean,lena,neal\n\tevil,levi,live,veil,vile\n\t \n\tconservation,conversation\n\n\t[Runtime =  6.897 sec]\n\n", "explain": "This program:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"bytes\"\n    \"fmt\"\n    \"io/ioutil\"\n    \"net/http\"\n    \"sort\"\n)\n\nfunc main() {\n    r, err := http.Get(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    b, err := ioutil.ReadAll(r.Body)\n    r.Body.Close()\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    var ma int\n    var bs byteSlice\n    m := make(map[string][][]byte)\n    for _, word := range bytes.Fields(b) {\n        bs = append(bs[:0], byteSlice(word)...)\n        sort.Sort(bs)\n        k := string(bs)\n        a := append(m[k], word)\n        if len(a) > ma {\n            ma = len(a)\n        }\n        m[k] = a\n    }\n    for _, a := range m {\n        if len(a) == ma {\n            fmt.Printf(\"%s\\n\", a)\n        }\n    }\n}\n\ntype byteSlice []byte\n\nfunc (b byteSlice) Len() int           { return len(b) }\nfunc (b byteSlice) Swap(i, j int)      { b[i], b[j] = b[j], b[i] }\nfunc (b byteSlice) Less(i, j int) bool { return b[i] < b[j] }\n\n\nOutput:\n[angel angle galen glean lange]\n[elan lane lean lena neal]\n[evil levi live veil vile]\n[abel able bale bela elba]\n[caret carte cater crate trace]\n[alger glare lager large regal]\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program anagram.s   */\n\n /* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n \n.equ MAXI,         40000\n.equ BUFFERSIZE,   300000\n.equ READ, 3                            @ system call \n.equ OPEN, 5                            @ system call\n.equ CLOSE, 6                           @ system call\n.equ O_RDWR,  0x0002                    @ open for reading and writing\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszFileName:           .asciz \"./listword.txt\"\nszMessErreur:         .asciz \"FILE ERROR.\"\nszCarriageReturn:     .asciz \"\\n\"\nszMessSpace:          .asciz \" \"\n\nptBuffer1:            .int sBuffer1\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nptTabBuffer:                .skip 4 * MAXI\nptTabAna:                   .skip 4 * MAXI\ntbiCptAna:                  .skip 4 * MAXI\niNBword:                    .skip 4\nsBuffer:                    .skip BUFFERSIZE\nsBuffer1:                   .skip BUFFERSIZE\n\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                      @ entry of program \n    mov r4,#0              @ loop indice\n    ldr r0,iAdrszFileName  @ file name\n    mov r1,#O_RDWR         @ flags\n    mov r2,#0              @ mode\n    mov r7,#OPEN           @ \n    svc 0 \n    cmp r0,#0              @ error open\n    ble 99f\n    mov r8,r0              @ FD save Fd\n    ldr r1,iAdrsBuffer     @ buffer address\n    ldr r2,iSizeBuf        @ buffersize\n    mov r7, #READ\n    svc 0 \n    cmp r0,#0              @ error read\u00a0?\n    blt 99f\n    mov r5,r0              @ save size read bytes\n    ldr r4,iAdrsBuffer     @ buffer address\n    ldr r0,iAdrsBuffer     @ start word address\n    mov r2,#0\n    mov r1,#0              @ word length\n1:\n    cmp r2,r5\n    bge 2f\n    ldrb r3,[r4,r2]\n    cmp r3,#0xD            @ end word\u00a0?\n    addne r1,r1,#1         @ increment word length\n    addne r2,r2,#1         @ increment indice\n    bne 1b                 @ and loop\n    mov r3,#0\n    strb r3,[r4,r2]        @ store final zero\n    bl anaWord             @ sort word letters\n    add r2,r2,#2           @ jump OD and 0A \n    add r0,r4,r2           @ new address begin word\n    mov r1,#0              @ init length\n    b 1b                   @ and loop\n    \n2:\n    mov r3,#0              @ last word\n    strb r3,[r4,r2]\n    bl anaWord\n    \n    mov r0,r8              @ file Fd\n    mov r7, #CLOSE\n    svc 0 \n    cmp r0,#0              @ error close\u00a0?\n    blt 99f\n    \n    ldr r0,iAdrptTabAna    @ address sorted string area\n    mov r1,#0              @ first indice\n    ldr r2,iAdriNBword\n    ldr r2,[r2]            @ last indice\n    ldr r3,iAdrptTabBuffer @ address sorted string area\n    bl triRapide           @ quick sort\n    ldr r4,iAdrptTabAna    @ address sorted string area\n    ldr r7,iAdrptTabBuffer @ address sorted string area\n    ldr r10,iAdrtbiCptAna  @ address counter occurences\n    mov r9,r2              @ size word array\n    mov r8,#0              @ indice first occurence\n    ldr r3,[r4,r8,lsl #2]  @ load first value\n    mov r2,#1              @ loop indice\n    mov r6,#0              @ counter\n    mov r12,#0             @ counter value max\n3:\n    ldr r5,[r4,r2,lsl #2]  @ load next value\n    mov r0,r3\n    mov r1,r5\n    bl comparStrings\n    cmp r0,#0              @ sorted strings equal\u00a0?\n    bne 4f\n    add r6,r6,#1           @ yes increment counter\n    b 5f\n4:                         @ no\n    str r6,[r10,r8,lsl #2] @ store counter in first occurence\n    cmp r6,r12             @ counter > value max\n    movgt r12,r6           @ yes  counter -> value max\n    mov r6,#0              @ raz counter\n    mov r8,r2              @ init index first occurence\n    mov r3,r5              @ init value first occurence\n5:\n    add r2,r2,#1           @ increment indice\n    cmp r2,r9              @ end word array\u00a0?\n    blt 3b                 @ no -> loop\n    \n    mov r2,#0              @ raz indice\n6:                         @ display loop\n    ldr r6,[r10,r2,lsl #2] @ load counter\n    cmp r6,r12             @ equal to max value\u00a0?\n    bne 8f\n    ldr r0,[r7,r2,lsl #2]  @ load address first word\n    bl affichageMess\n    add r3,r2,#1           @ increment new indixe\n    mov r4,#0              @ counter\n7:\n    ldr r0,iAdrszMessSpace\n    bl affichageMess\n    ldr r0,[r7,r3,lsl #2]  @ load address other word\n    bl affichageMess\n    add r3,r3,#1           @ increment indice\n    add r4,r4,#1           @ increment counter\n    cmp r4,r6              @ max value\u00a0?\n    blt 7b                 @ no loop\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n8:\n    add r2,r2,#1           @ increment indice\n    cmp r2,r9              @ maxi\u00a0?\n    blt 6b                 @ no -> loop\n    \n    b 100f\n99:                        @ display error\n    ldr r1,iAdrszMessErreur\n    bl displayError\n    \n100:                       @ standard end of the program \n    mov r0, #0             @ return code\n    mov r7, #EXIT          @ request to exit program\n    svc #0                 @ perform the system call\niAdrszCarriageReturn:        .int szCarriageReturn\niAdrszFileName:              .int szFileName\niAdrszMessErreur:            .int szMessErreur\niAdrsBuffer:                 .int sBuffer\niSizeBuf:                    .int BUFFERSIZE\niAdrszMessSpace:             .int szMessSpace\niAdrtbiCptAna:               .int tbiCptAna\n/******************************************************************/\n/*     analizing word                                   */ \n/******************************************************************/\n/*  r0  word address */\n/*  r1 word length   */\nanaWord:\n    push {r1-r6,lr}\n    mov r5,r0\n    mov r6,r1\n    ldr r1,iAdrptTabBuffer\n    ldr r2,iAdriNBword\n    ldr r3,[r2]\n    str r0,[r1,r3,lsl #2]\n    \n    ldr r1,iAdrptTabAna\n    ldr r4,iAdrptBuffer1\n    ldr r0,[r4]\n    add r6,r6,r0\n    add r6,r6,#1\n    str r6,[r4]\n    str r0,[r1,r3,lsl #2]\n    \n    add r3,r3,#1\n    str r3,[r2]\n    mov r1,r0\n    mov r0,r5\n    bl triLetters         @ sort word letters\n    mov r2,#0\n100:\n    pop {r1-r6,pc}\niAdrptTabBuffer:        .int ptTabBuffer\niAdrptTabAna:           .int ptTabAna\niAdriNBword:            .int iNBword\niAdrptBuffer1:          .int ptBuffer1\n/******************************************************************/\n/*     sort word letters                                  */ \n/******************************************************************/\n/* r0  address begin word */\n/* r1  address recept array */\ntriLetters:\n    push {r1-r7,lr}\n    mov r2,#0\n1:\n    ldrb r3,[r0,r2]         @ load letter\n    cmp r3,#0               @ end word\u00a0?\n    beq 6f\n    cmp r2,#0               @ first letter\u00a0?\n    bne 2f\n    strb r3,[r1,r2]         @ yes store in first position\n    add r2,r2,#1            @ increment indice\n    b 1b                    @ and loop\n2:\n    mov r4,#0\n3:                          @ begin loop to search insertion position\n    ldrb r5,[r1,r4]         @ load letter \n    cmp r3,r5               @ compare\n    blt 4f                  @ to low -> insertion\n    add r4,r4,#1            @ increment indice\n    cmp r4,r2               @ compare to letters number in place\n    blt 3b                  @ search loop\n    strb r3,[r1,r2]         @ else store in last position\n    add r2,r2,#1\n    b 1b                    @ and loop\n4:                          @ move first letters in one position \n    sub r6,r2,#1            @ start indice\n5:\n    ldrb r5,[r1,r6]         @ load letter\n    add r7,r6,#1            @ store indice - 1\n    strb r5,[r1,r7]         @ store letter\n    sub r6,r6,#1            @ decrement indice\n    cmp r6,r4               @ end\u00a0?\n    bge 5b                  @ no loop\n    strb r3,[r1,r4]         @ else store letter in free position\n    add r2,r2,#1\n    b 1b                    @ and loop\n6: \n    mov r3,#0               @ final z\u00e9ro\n    strb r3,[r1,r2]\n100:\n    pop {r1-r7,pc}\n/***************************************************/\n/*   Appel r\u00e9cursif Tri Rapide quicksort           */\n/***************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains the number of elements  > 0  */\n/* r3 contains the address of table 2 */\ntriRapide:\n    push {r2-r6,lr}         @ save registers\n    mov r6,r3 \n    sub r2,#1               @ last item index\n    cmp r1,r2               @ first > last\u00a0? \n    bge 100f                @ yes -> end\n    mov r4,r0               @ save r0\n    mov r5,r2               @ save r2\n    mov r3,r6\n    bl partition1           @ cutting into 2 parts\n    mov r2,r0               @ index partition\n    mov r0,r4               @ table address\n    bl triRapide            @ sort lower part\n    mov r0,r4               @ table address\n    add r1,r2,#1            @ index begin = index partition + 1\n    add r2,r5,#1            @ number of elements\n    bl triRapide            @ sort higter part\n   \n 100:                       @ end function\n    pop {r2-r6,lr}          @ restaur  registers \n    bx lr                   @ return\n\n/******************************************************************/\n/*      Partition table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains index of last item   */\n/* r3 contains the address of table 2 */\npartition1:\n    push {r1-r12,lr}        @ save registers\n    mov r8,r0               @ save address table 2\n    mov r9,r1 \n    ldr r10,[r8,r2,lsl #2]  @ load string address last index\n    mov r4,r9               @ init with first index\n    mov r5,r9               @ init with first index\n1:                          @ begin loop\n    ldr r6,[r8,r5,lsl #2]   @ load string address\n    mov r0,r6\n    mov r1,r10\n    bl comparStrings\n    cmp r0,#0\n    ldrlt r7,[r8,r4,lsl #2]  @ if < swap value table\n    strlt r6,[r8,r4,lsl #2]\n    strlt r7,[r8,r5,lsl #2]\n    ldrlt r7,[r3,r4,lsl #2]  @ swap array 2\n    ldrlt r12,[r3,r5,lsl #2]\n    strlt r7,[r3,r5,lsl #2]\n    strlt r12,[r3,r4,lsl #2]\n    addlt r4,#1              @ and increment index 1\n    add    r5,#1             @ increment index 2\n    cmp r5,r2                @ end\u00a0?\n    blt 1b                   @ no -> loop\n    ldr r7,[r8,r4,lsl #2]    @ swap value\n    str r10,[r8,r4,lsl #2]\n    str r7,[r8,r2,lsl #2]\n    ldr r7,[r3,r4,lsl #2]    @ swap array 2\n    ldr r12,[r3,r2,lsl #2]\n    str r7,[r3,r2,lsl #2]\n    str r12,[r3,r4,lsl #2]\n    \n    mov r0,r4                @ return index partition\n100:\n    pop {r1-r12,lr}\n    bx lr\n/************************************/       \n/* Strings case sensitive comparisons  */\n/************************************/      \n/* r0 et r1 contains the address of strings */\n/* return 0 in r0 if equals */\n/* return -1 if string r0 < string r1 */\n/* return 1  if string r0 > string r1 */\ncomparStrings:\n    push {r1-r4}      @ save des registres\n    mov r2,#0         @ counter\n1:    \n    ldrb r3,[r0,r2]   @ byte string 1\n    ldrb r4,[r1,r2]   @ byte string 2\n    cmp r3,r4\n    movlt r0,#-1      @ small\n    movgt r0,#1       @ greather  \n    bne 100f          @ not equals\n    cmp r3,#0         @ 0 end string\n    moveq r0,#0       @ equals\n    beq 100f          @ end string\n    add r2,r2,#1      @ else add 1 in counter\n    b 1b              @ and loop\n100:\n    pop {r1-r4}\n    bx lr   \n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nbale able bela abel elba\ncater carte crate caret trace\ngalen glean angle lange angel\nregal glare alger lager large\nlena lane lean elan neal\nveil levi live vile evil\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  System.Classes\nLibrary:  System.Diagnostics\nprogram AnagramsTest;\n\n{$APPTYPE CONSOLE}\n\n{$R *.res}\n\nuses\n  System.SysUtils,\n  System.Classes,\n  System.Diagnostics;\n\nfunction Sort(s: string): string;\nvar\n  c: Char;\n  i, j, aLength: Integer;\nbegin\n  aLength := s.Length;\n\n  if aLength = 0 then\n    exit('');\n\n  Result := s;\n\n  for i := 1 to aLength - 1 do\n    for j := i + 1 to aLength do\n      if result[i] > result[j] then\n      begin\n        c := result[i];\n        result[i] := result[j];\n        result[j] := c;\n      end;\nend;\n\nfunction IsAnagram(s1, s2: string): Boolean;\nbegin\n  if s1.Length <> s2.Length then\n    exit(False);\n\n  Result := Sort(s1) = Sort(s2);\n\nend;\n\nfunction Split(s: string; var Count: Integer; var words: string): Boolean;\nvar\n  sCount: string;\nbegin\n  sCount := s.Substring(0, 4);\n  words := s.Substring(5);\n  Result := TryStrToInt(sCount, Count);\nend;\n\nfunction CompareLength(List: TStringList; Index1, Index2: Integer): Integer;\nbegin\n  result := List[Index1].Length - List[Index2].Length;\n  if Result = 0 then\n    Result := CompareText(Sort(List[Index2]), Sort(List[Index1]));\nend;\n\nvar\n  Dict: TStringList;\n  i, j, Count, MaxCount, WordLength, Index: Integer;\n  words: string;\n  StopWatch: TStopwatch;\n\nbegin\n  StopWatch := TStopwatch.Create;\n  StopWatch.Start;\n\n  Dict := TStringList.Create();\n  Dict.LoadFromFile('unixdict.txt');\n\n  Dict.CustomSort(CompareLength);\n\n  Index := 0;\n  words := Dict[Index];\n  Count := 1;\n\n  while Index + Count < Dict.Count do\n  begin\n    if IsAnagram(Dict[Index], Dict[Index + Count]) then\n    begin\n      words := words + ',' + Dict[Index + Count];\n      Dict[Index + Count] := '';\n      inc(Count);\n    end\n    else\n    begin\n      Dict[Index] := format('%.4d', [Count]) + ',' + words;\n      inc(Index, Count);\n      words := Dict[Index];\n      Count := 1;\n    end;\n  end;\n\n  // The last one not match any one\n  if not Dict[Dict.count - 1].IsEmpty then\n    Dict.Delete(Dict.count - 1);\n\n  Dict.Sort;\n\n  while Dict[0].IsEmpty do\n    Dict.Delete(0);\n\n  StopWatch.Stop;\n\n  Writeln(Format('Time pass: %d ms [i7-4500U Windows 7]', [StopWatch.ElapsedMilliseconds]));\n\n  Split(Dict[Dict.count - 1], MaxCount, words);\n  writeln(#10'The anagrams that contain the most words, has ', MaxCount, ' words:'#10);\n  writeln('Words found:'#10);\n\n  Writeln('  ', words);\n\n  for i := Dict.Count - 2 downto 0 do\n  begin\n    Split(Dict[i], Count, words);\n    if Count = MaxCount then\n      Writeln('  ', words)\n    else\n      Break;\n  end;\n\n  Dict.Free;\n  Readln;\nend.\n\n\nOutput:\nTime pass: 700 ms [i7-4500U Windows 7]\n\nThe anagrams that contain the most words, has 5 words:\n\nWords found:\n\n  veil,live,vile,evil,levi\n  trace,crate,cater,carte,caret\n  regal,glare,large,lager,alger\n  neal,lean,elan,lane,lena\n  glean,angel,galen,angle,lange\n  able,bale,abel,bela,elba\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Ruby", "code": "\nrequire 'open-uri'\n\nanagram = Hash.new {|hash, key| hash[key] = []} # map sorted chars to anagrams\n\nURI.open('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt') do |f|\n  words = f.read.split\n  for word in words\n    anagram[word.split('').sort] << word\n  end\nend\n\ncount = anagram.values.map {|ana| ana.length}.max\nanagram.each_value do |ana|\n  if ana.length >= count\n    p ana\n  end\nend\n\nOutput:\n [\"evil\", \"levi\", \"live\", \"veil\", \"vile\"]\n [\"abel\", \"able\", \"bale\", \"bela\", \"elba\"]\n [\"elan\", \"lane\", \"lean\", \"lena\", \"neal\"]\n [\"alger\", \"glare\", \"lager\", \"large\", \"regal\"]\n [\"angel\", \"angle\", \"galen\", \"glean\", \"lange\"]\n [\"caret\", \"carte\", \"cater\", \"crate\", \"trace\"]\n\n\nrequire 'open-uri'\n\nanagrams = open('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'){|f| f.read.split.group_by{|w| w.each_char.sort} }\nanagrams.values.group_by(&:size).max.last.each{|group| puts group.join(\", \") }\n\nOutput:\nabel, able, bale, bela, elba\nalger, glare, lager, large, regal\nangel, angle, galen, glean, lange\ncaret, carte, cater, crate, trace\nelan, lane, lean, lena, neal\nevil, levi, live, veil, vile\n\n", "explain": "Short version (with lexical ordered result).\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Rust", "code": "\nSorting[edit]\n\nuse std::collections::HashMap;\nuse std::fs::File;\nuse std::io::{BufRead,BufReader};\nuse std::borrow::ToOwned;\n\nextern crate unicode_segmentation;\nuse unicode_segmentation::{UnicodeSegmentation};\n\nfn main () {\n    let file = BufReader::new(File::open(\"unixdict.txt\").unwrap());\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let s = line.unwrap();\n        //Bytes:      let mut sorted = s.trim().bytes().collect::<Vec<_>>();\n        //Codepoints: let mut sorted = s.trim().chars().collect::<Vec<_>>();\n        let mut sorted = s.trim().graphemes(true).map(ToOwned::to_owned).collect::<Vec<_>>();\n        sorted.sort();\n\n        map.entry(sorted).or_insert_with(Vec::new).push(s);\n    }\n\n    if let Some(max_len) = map.values().map(|v| v.len()).max() {\n        for anagram in map.values().filter(|v| v.len() == max_len) {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}\n\nOutput:\nalger glare lager large regal\nangel angle galen glean lange\nelan lane lean lena neal\nevil levi live veil vile\ncaret carte cater crate trace\nabel able bale bela elba\n\nUsing prime factors[edit]\n\nuse std::collections::HashMap;\nuse std::path::Path;\nuse std::io::{self, BufRead, BufReader};\nuse std::fs::File;\n\nfn main() {\n    if let Ok(anagrams) = find_anagrams(\"unixdict.txt\") {\n        for anagram in anagrams {\n            for word in anagram {\n                print!(\"{} \", word);\n            }\n            println!();\n        }\n    }\n}\n\nconst PRIMES: [u64; 256] = [2,3,5,7,11,13,17,19,23,29,31,37,41,43,47,53,59,61,67,71,73,79,83,89,97,101,103,107,109,113,127\n                           ,131,137,139,149,151,157,163,167,173,179,181,191,193,197,199,211,223,227,229,233,239,241,251,257\n                           ,263,269,271,277,281,283,293,307,311,313,317,331,337,347,349,353,359,367,373,379,383,389,397,401\n                           ,409,419,421,431,433,439,443,449,457,461,463,467,479,487,491,499,503,509,521,523,541,547,557,563\n                           ,569,571,577,587,593,599,601,607,613,617,619,631,641,643,647,653,659,661,673,677,683,691,701,709\n                           ,719,727,733,739,743,751,757,761,769,773,787,797,809,811,821,823,827,829,839,853,857,859,863,877\n                           ,881,883,887,907,911,919,929,937,941,947,953,967,971,977,983,991,997,1009,1013,1019,1021,1031,1033\n                           ,1039,1049,1051,1061,1063,1069,1087,1091,1093,1097,1103,1109,1117,1123,1129,1151,1153,1163,1171\n                           ,1181,1187,1193,1201,1213,1217,1223,1229,1231,1237,1249,1259,1277,1279,1283,1289,1291,1297,1301\n                           ,1303,1307,1319,1321,1327,1361,1367,1373,1381,1399,1409,1423,1427,1429,1433,1439,1447,1451,1453\n                           ,1459,1471,1481,1483,1487,1489,1493,1499,1511,1523,1531,1543,1549,1553,1559,1567,1571,1579,1583\n                           ,1597,1601,1607,1609,1613,1619];\n\nfn find_anagrams<P: AsRef<Path>>(file: P) -> io::Result<Vec<Vec<String>>> {\n    let file = BufReader::new(File::open(file)?);\n    let mut map = HashMap::new();\n    for line in file.lines() {\n        let string = line?;\n        let mut num = 1;\n        for ch in string.trim().bytes() {\n            num *= PRIMES[ch as usize];\n        }\n        map.entry(num).or_insert_with(Vec::new).push(string);\n    }\n    Ok(map.into_iter().map(|(_, entry)| entry).collect())\n}\n", "explain": "Unicode is hard so the solution depends on what you consider to be an anagram: two strings that have the same bytes, the same codepoints, or the same graphemes. The first two are easily accomplished in Rust proper, but the latter requires an external library. Graphemes are probably the most correct way, but it is also the least efficient since graphemes are variable size and thus require a heap allocation per grapheme.\nIf we assume an ASCII string, we can map each character to a prime number and multiply these together to create a number which uniquely maps to each anagram.\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Swift", "code": "\nWorks with: Swift 2.0\nimport Foundation\n\nlet wordsURL = NSURL(string: \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")!\n\nlet wordsstring = try NSString(contentsOfURL:wordsURL , encoding: NSUTF8StringEncoding)\nlet allwords = wordsstring.componentsSeparatedByString(\"\\n\")\n\nlet words = allwords//[0..<100] // used to limit the size while testing\n\nextension String {\n    var charactersAscending\u00a0: String {\n        return String(Array(characters).sort())\n    }\n}\n\nvar charsToWords = [String:Set<String>]()\n\nvar biggest = 0\nvar biggestlists = [Set<String>]()\n\nfor thisword in words {\n    let chars = thisword.charactersAscending\n    \n    var knownwords = charsToWords[chars]\u00a0?? Set<String>()\n    knownwords.insert(thisword)\n    charsToWords[chars] = knownwords\n\n    if knownwords.count > biggest {\n        biggest = knownwords.count\n\n        biggestlists = [knownwords]\n    }\n    else if knownwords.count == biggest {\n        biggestlists.append(knownwords)\n    }\n}\n\nprint(\"Found \\(biggestlists.count) sets of anagrams with \\(biggest) members each\")\nfor (i, thislist) in biggestlists.enumerate() {\n    print(\"set \\(i): \\(thislist.sort())\")\n}\n\nOutput:\nFound 6 sets of anagrams with 5 members each\nset 0: [abel, able, bale, bela, elba]\nset 1: [angel, angle, galen, glean, lange]\nset 2: [elan, lane, lean, lena, neal]\nset 3: [alger, glare, lager, large, regal]\nset 4: [caret, carte, cater, crate, trace]\nset 5: [evil, levi, live, veil, vile]\nProgram ended with exit code: 0\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "R", "code": "\nwords <- readLines(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\nword_group <- sapply(\n    strsplit(words, split=\"\"), # this will split all words to single letters...\n    function(x) paste(sort(x), collapse=\"\") # ...which we sort and paste again\n)\n\ncounts <- tapply(words, word_group, length) # group words by class to get number of anagrams\nanagrams <- tapply(words, word_group, paste, collapse=\", \") # group to get string with all anagrams\n\n# Results\ntable(counts)\ncounts\n    1     2     3     4     5 \n22263  1111   155    31     6 \n\nanagrams[counts == max(counts)]\n                               abel                               acert \n     \"abel, able, bale, bela, elba\" \"caret, carte, cater, crate, trace\" \n                              aegln                               aeglr \n\"angel, angle, galen, glean, lange\" \"alger, glare, lager, large, regal\" \n                               aeln                                eilv \n     \"elan, lane, lean, lena, neal\"      \"evil, levi, live, veil, vile\"\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "COBOL", "code": "\n\n      *> TECTONICS\n      *>   wget http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\n      *>   or visit https://sourceforge.net/projects/souptonuts/files\n      *>   or snag ftp://ftp.openwall.com/pub/wordlists/all.gz\n      *>      for a 5 million all language word file (a few phrases)\n      *>   cobc -xj anagrams.cob [-DMOSTWORDS -DMOREWORDS -DALLWORDS]\n      *> ***************************************************************\n       identification division.\n       program-id. anagrams.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select words-in\n           assign to wordfile\n           organization is line sequential\n           status is words-status\n           .\n\n       REPLACE ==:LETTERS:== BY ==42==.\n\n       data division.\n       file section.\n       fd words-in record is varying from 1 to :LETTERS: characters\n                             depending on word-length.\n       01 word-record.\n          05 word-data         pic x occurs 0 to :LETTERS: times\n                                     depending on word-length.\n\n       working-storage section.\n       >>IF ALLWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/all.words\".\n       01 max-words    constant as 4802100.\n\n       >>ELSE-IF MOSTWORDS DEFINED\n       01 wordfile     constant as \"/usr/local/share/dict/linux.words\".\n       01 max-words    constant as 628000.\n\n       >>ELSE-IF MOREWORDS DEFINED\n       01 wordfile     constant as \"/usr/share/dict/words\".\n       01 max-words    constant as 100000.\n\n       >>ELSE\n       01 wordfile     constant as \"unixdict.txt\".\n       01 max-words    constant as 26000.\n       >>END-IF\n\n      *> The 5 million word file needs to restrict the word length\n       >>IF ALLWORDS DEFINED\n       01 max-letters          constant as 26.\n       >>ELSE\n       01 max-letters          constant as :LETTERS:.\n       >>END-IF\n\n       01 word-length          pic 99 comp-5.\n       01 words-status         pic xx.\n          88 ok-status         values '00' thru '09'.\n          88 eof-status        value '10'.\n\n      *> sortable word by letter table\n       01 letter-index         usage index.\n       01 letter-table.\n          05 letters           occurs 1 to max-letters times\n                               depending on word-length\n                               ascending key letter\n                               indexed by letter-index.\n             10 letter         pic x.\n\n      *> table of words\n       01 sorted-index         usage index.\n       01 word-table.\n          05 word-list         occurs 0 to max-words times\n                               depending on word-tally\n                               ascending key sorted-word\n                               indexed by sorted-index.\n             10 match-count    pic 999 comp-5.\n             10 this-word      pic x(max-letters).\n             10 sorted-word    pic x(max-letters).\n       01 sorted-display       pic x(10).\n\n       01 interest-table.\n          05 interest-list     pic 9(8) comp-5\n                               occurs 0 to max-words times\n                               depending on interest-tally.\n\n       01 outer                pic 9(8) comp-5.\n       01 inner                pic 9(8) comp-5.\n       01 starter              pic 9(8) comp-5.\n       01 ender                pic 9(8) comp-5.\n       01 word-tally           pic 9(8) comp-5.\n       01 interest-tally       pic 9(8) comp-5.\n       01 tally-display        pic zz,zzz,zz9.\n\n       01 most-matches         pic 99 comp-5.\n       01 matches              pic 99 comp-5.\n       01 match-display        pic z9.\n\n      *> timing display\n       01 time-stamp.\n          05 filler            pic x(11).\n          05 timer-hours       pic 99.\n          05 filler            pic x.\n          05 timer-minutes     pic 99.\n          05 filler            pic x.\n          05 timer-seconds     pic 99.\n          05 filler            pic x.\n          05 timer-subsec      pic v9(6).\n       01 timer-elapsed        pic 9(6)v9(6).\n       01 timer-value          pic 9(6)v9(6).\n       01 timer-display        pic zzz,zz9.9(6).\n\n      *> ***************************************************************\n       procedure division.\n       main-routine.\n\n       >>IF ALLWORDS DEFINED\n           display \"** Words limited to \" max-letters \" letters **\"\n       >>END-IF\n\n       perform show-time\n\n       perform load-words\n       perform find-most\n       perform display-result\n\n       perform show-time\n       goback\n       .\n\n      *> ***************************************************************\n       load-words.\n       open input words-in\n       if not ok-status then\n           display \"error opening \" wordfile upon syserr\n           move 1 to return-code\n           goback\n       end-if\n\n       perform until exit\n           read words-in\n           if eof-status then exit perform end-if\n           if not ok-status then\n               display wordfile \" read error: \" words-status upon syserr\n           end-if\n\n           if word-length equal zero then exit perform cycle end-if\n\n       >>IF ALLWORDS DEFINED\n           move min(word-length, max-letters) to word-length\n       >>END-IF\n\n           add 1 to word-tally\n           move word-record to this-word(word-tally) letter-table\n           sort letters ascending key letter\n           move letter-table to sorted-word(word-tally)\n       end-perform\n\n       move word-tally to tally-display\n       display trim(tally-display) \" words\" with no advancing\n\n       close words-in\n       if not ok-status then\n           display \"error closing \" wordfile upon syserr\n           move 1 to return-code\n       end-if\n\n      *> sort word list by anagram check field\n       sort word-list ascending key sorted-word\n       .\n\n      *> first entry in a list will end up with highest match count\n       find-most.\n       perform varying outer from 1 by 1 until outer > word-tally\n           move 1 to matches\n           add 1 to outer giving starter\n           perform varying inner from starter by 1\n                   until sorted-word(inner) not equal sorted-word(outer)\n               add 1 to matches\n           end-perform\n           if matches > most-matches then\n               move matches to most-matches\n               initialize interest-table all to value\n               move 0 to interest-tally\n           end-if\n           move matches to match-count(outer)\n           if matches = most-matches then\n               add 1 to interest-tally\n               move outer to interest-list(interest-tally)\n           end-if\n       end-perform\n       .\n\n      *> only display the words with the most anagrams\n       display-result.\n       move interest-tally to tally-display\n       move most-matches to match-display\n       display \", most anagrams: \" trim(match-display)\n               \", with \" trim(tally-display) \" set\" with no advancing\n       if interest-tally not equal 1 then\n           display \"s\" with no advancing\n       end-if\n       display \" of interest\"\n\n       perform varying outer from 1 by 1 until outer > interest-tally\n           move sorted-word(interest-list(outer)) to sorted-display\n           display sorted-display\n                   \" [\" trim(this-word(interest-list(outer)))\n              with no advancing\n           add 1 to interest-list(outer) giving starter\n           add most-matches to interest-list(outer) giving ender\n           perform varying inner from starter by 1\n               until inner = ender\n                   display \", \" trim(this-word(inner))\n                      with no advancing\n           end-perform\n           display \"]\"\n       end-perform\n       .\n\n      *> elapsed time\n       show-time.\n       move formatted-current-date(\"YYYY-MM-DDThh:mm:ss.ssssss\")\n         to time-stamp\n       compute timer-value = timer-hours * 3600 + timer-minutes * 60\n                             + timer-seconds + timer-subsec\n       if timer-elapsed = 0 then\n           display time-stamp\n           move timer-value to timer-elapsed\n       else\n           if timer-value < timer-elapsed then\n               add 86400 to timer-value\n           end-if\n           subtract timer-elapsed from timer-value\n           move timer-value to timer-display\n           display time-stamp \", \" trim(timer-display) \" seconds\"\n       end-if\n       .\n\n       end program anagrams.\n\n\nOutput:\nprompt$ time cobc -xjd anagrams.cob\n2016-05-04T07:13:23.225147\n25,104 words, most anagrams: 5, with 6 sets of interest\nabel       [abel, able, bale, bela, elba]\nacert      [caret, carte, cater, crate, trace]\naegln      [angel, angle, galen, glean, lange]\naeglr      [alger, glare, lager, large, regal]\naeln       [elan, lane, lean, lena, neal]\neilv       [evil, levi, live, veil, vile]\n2016-05-04T07:13:23.262851, 0.037704 seconds\n\nreal    0m0.191s\nuser    0m0.152s\nsys     0m0.024s\n\nprompt$ cobc -xjd anagrams.cob -DMOSTWORDS\n2016-05-04T07:13:42.570360\n627,999 words, most anagrams: 17, with 1 set of interest\naerst      [arest, arets, aster, astre, earst, rates, reast, resat, serta, stare, stear, tares, tarse, taser, tears, teras, treas]\n2016-05-04T07:13:43.832743, 1.262383 seconds\n\nprompt$ cobc -xjd anagrams.cob -DALLWORDS\n** Words limited to 26 letters **\n2016-05-04T07:13:50.944146\n4,802,017 words, most anagrams: 68, with 1 set of interest\naeinst     [aisnet, aniets, anites, antesi, anties, antise, ...\n2016-05-04T07:14:02.475959, 11.531813 seconds\n", "explain": "Tested with GnuCOBOL 2.0.  ALLWORDS output display trimmed for width.\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Indefinite_Ordered_Sets;\n\nprocedure Words_Of_Equal_Characters is\n   package Set_Of_Words is new Ada.Containers.Indefinite_Ordered_Sets (String);\n   use Ada.Containers, Set_Of_Words;\n   package Anagrams is new Ada.Containers.Indefinite_Ordered_Maps (String, Set);\n   use Anagrams;\n\n   File   : File_Type;\n   Result : Map;\n   Max    : Count_Type := 1;\n\n   procedure Put (Position : Anagrams.Cursor) is\n      First : Boolean := True;\n      List  : Set renames Element (Position);\n      procedure Put (Position : Set_Of_Words.Cursor) is\n      begin\n         if First then\n            First := False;\n         else\n            Put (',');\n         end if;\n         Put (Element (Position));\n      end Put;\n   begin\n      if List.Length = Max then\n         Iterate (List, Put'Access);\n         New_Line;\n      end if;\n   end Put;\n\nbegin\n   Open (File, In_File, \"unixdict.txt\");\n   loop\n      declare\n         Word : constant String     := Get_Line (File);\n         Key  : String (Word'Range) := (others => Character'Last);\n         List : Set;\n         Position : Anagrams.Cursor;\n      begin\n         for I in Word'Range loop\n            for J in Word'Range loop\n               if Key (J) > Word (I) then\n                  Key (J + 1..I) := Key (J..I - 1);\n                  Key (J) := Word (I);\n                  exit;\n               end if;\n            end loop;\n         end loop;\n         Position := Find (Result, Key);\n         if Has_Element (Position) then\n            List := Element (Position);\n            Insert (List, Word);\n            Replace_Element (Result, Position, List);\n         else\n            Insert (List, Word);\n            Include (Result, Key, List);\n         end if;\n         Max := Count_Type'Max (Max, Length (List));\n      end;\n   end loop;\nexception\n   when End_Error =>\n      Iterate (Result, Put'Access);\n      Close (File);\nend Words_Of_Equal_Characters;\n\n\nOutput:\nabel,able,bale,bela,elba\ncaret,carte,cater,crate,trace\nangel,angle,galen,glean,lange\nalger,glare,lager,large,regal\nelan,lane,lean,lena,neal\nevil,levi,live,veil,vile\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Julia", "code": "\nWorks with: Julia version 1.6\nurl = \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\nwordlist = open(readlines, download(url))\n\nwsort(word::AbstractString) = join(sort(collect(word)))\n\nfunction anagram(wordlist::Vector{<:AbstractString})\n    dict = Dict{String, Set{String}}()\n    for word in wordlist\n        sorted = wsort(word)\n        push!(get!(dict, sorted, Set{String}()), word)\n    end\n    wcnt = maximum(length, values(dict))\n    return collect(Iterators.filter((y) -> length(y) == wcnt, values(dict)))\nend\n\nprintln.(anagram(wordlist))\n\n\nOutput:\nSet(String[\"live\", \"vile\", \"veil\", \"evil\", \"levi\"])\nSet(String[\"abel\", \"able\", \"bale\", \"bela\", \"elba\"])\nSet(String[\"crate\", \"cater\", \"carte\", \"trace\", \"caret\"])\nSet(String[\"galen\", \"angel\", \"lange\", \"angle\", \"glean\"])\nSet(String[\"lager\", \"regal\", \"glare\", \"large\", \"alger\"])\nSet(String[\"neal\", \"elan\", \"lena\", \"lane\", \"lean\"])\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Kotlin", "code": "\nTranslation of: Java\nimport java.io.BufferedReader\nimport java.io.InputStreamReader\nimport java.net.URL\nimport kotlin.math.max\n\nfun main() {\n    val url = URL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\")\n    val isr = InputStreamReader(url.openStream())\n    val reader = BufferedReader(isr)\n    val anagrams = mutableMapOf<String, MutableList<String>>()\n    var count = 0\n    var word = reader.readLine()\n    while (word != null) {\n        val chars = word.toCharArray()\n        chars.sort()\n        val key = chars.joinToString(\"\")\n        if (!anagrams.containsKey(key)) anagrams[key] = mutableListOf()\n        anagrams[key]?.add(word)\n        count = max(count, anagrams[key]?.size ?: 0)\n        word = reader.readLine()\n    }\n    reader.close()\n    anagrams.values\n        .filter { it.size == count }\n        .forEach { println(it) }\n}\n\n\nOutput:\n[abel, able, bale, bela, elba]\n[alger, glare, lager, large, regal]\n[angel, angle, galen, glean, lange]\n[caret, carte, cater, crate, trace]\n[elan, lane, lean, lena, neal]\n[evil, levi, live, veil, vile]\n\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Perl", "code": "\nuse List::Util 'max';\n\nmy @words = split \"\\n\", do { local( @ARGV, $/ ) = ( 'unixdict.txt' ); <> };\nmy %anagram;\nfor my $word (@words) {\n    push @{ $anagram{join '', sort split '', $word} }, $word;\n}\n\nmy $count = max(map {scalar @$_} values %anagram);\nfor my $ana (values %anagram) {\n    print \"@$ana\\n\" if @$ana == $count;\n}\n\n\npush @{$anagram{ join '' => sort split '' }}, $_ for @words;\n$max > @$_  or  $max = @$_    for values %anagram;\n@$_ == $max and print \"@$_\\n\" for values %anagram;\n\n\nOutput:\nalger glare lager large regal\nabel able bale bela elba\nevil levi live veil vile\nangel angle galen glean lange\nelan lane lean lena neal\ncaret carte cater crate trace\n\n", "explain": "If we calculate $max, then we don't need the CPAN module:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog version 5.10.0\n:- use_module(library( http/http_open )).\n\nanagrams:-\n        % we read the URL of the words\n\thttp_open('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt',\tIn, []),\n\tread_file(In, [], Out),\n\tclose(In),\n\n        % we get a list of pairs key-value where key = a-word value = <list-of-its-codes>\n        % this list must be sorted\n\tmsort(Out, MOut),\n\n        % in order to gather values with the same keys\n\tgroup_pairs_by_key(MOut, GPL),\n\n        % we sorted this list in decreasing order of the length of values\n\tpredsort(my_compare, GPL, GPLSort),\n\n\t% we extract the first 6 items \n        GPLSort = [_H1-T1, _H2-T2, _H3-T3, _H4-T4, _H5-T5, _H6-T6 | _],\n\n        % Tnn are lists of codes (97 for 'a'), we create the strings \n\tmaplist(maplist(atom_codes), L, [T1, T2, T3, T4, T5, T6] ),\n\n\tmaplist(writeln, L).\n\n\nread_file(In, L, L1) :-\n\tread_line_to_codes(In, W),\n\t(   W == end_of_file -> \n               % the file is read\n\t       L1 = L\n\t       ; \n               % we sort the list of codes of the line\n\t       msort(W, W1),\n\n               % to create the key in alphabetic order\n\t       atom_codes(A, W1), \n\n               % and we have the pair Key-Value in the result list\n\t       read_file(In, [A-W | L], L1)).\n\n% predicate for sorting list of pairs Key-Values\n% if the lentgh of values is the same\n% we sort the keys in alhabetic order\nmy_compare(R, K1-V1, K2-V2) :-\n\tlength(V1, L1),\n\tlength(V2, L2),\n\t(   L1 < L2 -> R = >; L1 > L2 -> R = <; compare(R, K1, K2)).\n\n\n[abel,able,bale,bela,elba]\n[caret,carte,cater,crate,trace]\n[angel,angle,galen,glean,lange]\n[alger,glare,lager,large,regal]\n[elan,lane,lean,lena,neal]\n[evil,levi,live,veil,vile]\ntrue\n", "explain": "The result is\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Lua", "code": "\n\nfunction sort(word)\n  local bytes = {word:byte(1, -1)}\n  table.sort(bytes)\n  return string.char(table.unpack(bytes))\nend\n\n-- Read in and organize the words.\n-- word_sets[<alphabetized_letter_list>] = {<words_with_those_letters>}\nlocal word_sets = {}\nlocal max_size = 0\nfor word in io.lines('unixdict.txt') do\n  local key = sort(word)\n  if word_sets[key] == nil then word_sets[key] = {} end\n  table.insert(word_sets[key], word)\n  max_size = math.max(max_size, #word_sets[key])\nend\n\n-- Print out the answer sets.\nfor _, word_set in pairs(word_sets) do\n  if #word_set == max_size then\n    for _, word in pairs(word_set) do io.write(word .. ' ') end\n    print('')  -- Finish with a newline.\n  end\nend\n\n\nOutput:\nabel able bale bela elba \nevil levi live veil vile \nalger glare lager large regal \nangel angle galen glean lange \ncaret carte cater crate trace \nelan lane lean lena neal\n", "explain": "Lua's core library is very small and does not include built-in network functionality. If a networking library were imported, the local file in the following script could be replaced with the remote dictionary file. \n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Scala", "code": "\nval src = io.Source fromURL \"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\"\nval vls = src.getLines.toList.groupBy(_.sorted).values\nval max = vls.map(_.size).max\nvls filter (_.size == max) map (_ mkString \" \") mkString \"\\n\"\n\nOutput:\nabel able bale bela elba\nangel angle galen glean lange\nevil levi live veil vile\nalger glare lager large regal\nelan lane lean lena neal\ncaret carte cater crate trace\n\n\n\nSource\n  .fromURL(\"http://wiki.puzzlers.org/pub/wordlists/unixdict.txt\").getLines.toList\n  .groupBy(_.sorted).values\n  .groupBy(_.size).maxBy(_._1)._2\n  .map(_.mkString(\"\\t\"))\n  .foreach(println)\n\nOutput:\nabel\table\tbale\tbela\telba\nangel\tangle\tgalen\tglean\tlange\nevil\tlevi\tlive\tveil\tvile\nalger\tglare\tlager\tlarge\tregal\nelan\tlane\tlean\tlena\tneal\ncaret\tcarte\tcater\tcrate\ttrace\n\n", "explain": "Another take:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "D", "code": "\nShort Functional Version[edit]\nimport std.stdio, std.algorithm, std.string, std.exception, std.file;\n\nvoid main() {\n    string[][ubyte[]] an;\n    foreach (w; \"unixdict.txt\".readText.splitLines)\n        an[w.dup.representation.sort().release.assumeUnique] ~= w;\n    immutable m = an.byValue.map!q{ a.length }.reduce!max;\n    writefln(\"%(%s\\n%)\", an.byValue.filter!(ws => ws.length == m));\n}\n\n\nOutput:\n[\"caret\", \"carte\", \"cater\", \"crate\", \"trace\"]\n[\"evil\", \"levi\", \"live\", \"veil\", \"vile\"]\n[\"abel\", \"able\", \"bale\", \"bela\", \"elba\"]\n[\"elan\", \"lane\", \"lean\", \"lena\", \"neal\"]\n[\"alger\", \"glare\", \"lager\", \"large\", \"regal\"]\n[\"angel\", \"angle\", \"galen\", \"glean\", \"lange\"]\n\nFaster Version[edit]\n\nvoid main() {\n    import std.stdio, std.algorithm, std.file, std.string;\n\n    auto keys = \"unixdict.txt\".readText!(char[]);\n    immutable vals = keys.idup;\n    string[][string] anags;\n    foreach (w; keys.splitter) {\n        immutable k = w.representation.sort().release.assumeUTF;\n        anags[k] ~= vals[k.ptr - keys.ptr .. k.ptr - keys.ptr + k.length];\n    }\n    //immutable m = anags.byValue.maxs!q{ a.length };\n    immutable m = anags.byValue.map!q{ a.length }.reduce!max;\n    writefln(\"%(%-(%s\u00a0%)\\n%)\", anags.byValue.filter!(ws => ws.length == m));\n}\n\n\n", "explain": "Runtime: about 0.07 seconds.\nLess safe, same output.\nRuntime: about 0.06 seconds.\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Haskell", "code": "\nimport Data.List\n\ngroupon f x y = f x == f y\n\nmain = do\n  f <- readFile \"./../Puzzels/Rosetta/unixdict.txt\"\n  let  words = lines f\n       wix = groupBy (groupon fst) . sort $ zip (map sort words) words\n       mxl = maximum $ map length wix\n  mapM_ (print . map snd) . filter ((==mxl).length) $ wix\n\n\nOutput:\n*Main> main\n[\"abel\",\"able\",\"bale\",\"bela\",\"elba\"]\n[\"caret\",\"carte\",\"cater\",\"crate\",\"trace\"]\n[\"angel\",\"angle\",\"galen\",\"glean\",\"lange\"]\n[\"alger\",\"glare\",\"lager\",\"large\",\"regal\"]\n[\"elan\",\"lane\",\"lean\",\"lena\",\"neal\"]\n[\"evil\",\"levi\",\"live\",\"veil\",\"vile\"]\n\n\nimport Data.List (groupBy, maximumBy, sort)\nimport Data.Ord (comparing)\nimport Data.Function (on)\nimport Data.Text (pack)\n\nmain :: IO ()\nmain = do\n  f <- readFile \"./unixdict.txt\"\n  let ws = groupBy (on (==) fst) (sort (((,) =<< pack . sort) <$> lines f))\n  mapM_\n    (print . fmap snd)\n    (filter ((length (maximumBy (comparing length) ws) ==) . length) ws)\n\n\nOutput:\n[\"abel\",\"able\",\"bale\",\"bela\",\"elba\"]\n[\"caret\",\"carte\",\"cater\",\"crate\",\"trace\"]\n[\"angel\",\"angle\",\"galen\",\"glean\",\"lange\"]\n[\"alger\",\"glare\",\"lager\",\"large\",\"regal\"]\n[\"elan\",\"lane\",\"lean\",\"lena\",\"neal\"]\n[\"evil\",\"levi\",\"live\",\"veil\",\"vile\"]\n", "explain": "and we can noticeably speed up the second stage sorting and grouping by packing the String lists of Chars to the Text type:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "VBScript", "code": "\n\nConst adInteger = 3 \nConst adVarChar = 200 \n\nfunction charcnt(s,ch)\ncharcnt=0\nfor i=1 to len(s)\n  if mid(s,i,1)=ch then charcnt=charcnt+1\nnext\nend function  \n\nset fso=createobject(\"Scripting.Filesystemobject\")\ndim a(122)\n\nsfn=WScript.ScriptFullName\nsfn= Left(sfn, InStrRev(sfn, \"\\\"))\nset f=fso.opentextfile(sfn & \"unixdict.txt\",1)\n\n'words to dictionnary using acronym as key\nset d=createobject(\"Scripting.Dictionary\")\n\nwhile not f.AtEndOfStream\n  erase a :cnt=0\n  s=trim(f.readline)\n\t\n\t'tally chars\n  for i=1 to len(s)\n   n=asc(mid(s,i,1))\n   a(n)=a(n)+1\n  next\n\t\n  'build the anagram\n  k=\"\"\n  for i= 48 to 122\n    if a(i) then k=k & string(a(i),chr(i))\n  next\n\t\n\t'add to dict\n  if d.exists(k) then\n    b=d(k)\n    d(k)=b & \" \" & s\n  else\n    d(k)=s\n  end if\nwend\n\n'copy dictionnary to recorset to be able to sort it .Add nr of items as a new field\nSet rs = CreateObject(\"ADODB.Recordset\")\nrs.Fields.Append \"anag\", adVarChar, 30\nrs.Fields.Append \"items\", adInteger\nrs.Fields.Append \"words\", adVarChar, 200\nrs.open\nfor each k in d.keys\n rs.addnew\n rs(\"anag\")=k\n s=d(k)\n rs(\"words\")=s\n rs(\"items\")=charcnt(s,\" \")+1\n rs.update\nnext\nd.removeall\n\n'do the query\nrs.sort=\"items DESC, anag ASC\"\nrs.movefirst\nit=rs(\"items\")\nwhile rs(\"items\")=it\n  wscript.echo  rs(\"items\") & \" (\" &rs(\"anag\") & \") \" & rs(\"words\")\n  rs.movenext\nwend\nrs.close\n\n5 (abel) abel able bale bela elba\n5 (acert) caret carte cater crate trace\n5 (aegln) angel angle galen glean lange\n5 (aeglr) alger glare lager large regal\n5 (aeln) elan lane lean lena neal\n5 (eilv) evil levi live veil vile\n\n", "explain": "A little convoluted, uses a dictionary and a recordset...\nThe output:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Scheme", "code": "\n\n(import (scheme base)\n        (scheme char)\n        (scheme file)\n        (scheme write)\n        (srfi 125) \u00a0; hash tables\n        (srfi 132))\u00a0; sorting library\n\n;; read in the words\n(define (read-groups)\n  (with-input-from-file \n    \"unixdict.txt\"\n    (lambda () \n      (let ((groups (hash-table string=?)))\n        (do ((line (read-line) (read-line)))\n          ((eof-object? line) groups)\n          (let* ((key (list->string (list-sort char<? (string->list line))))\n                 (val (hash-table-ref/default groups key '())))\n            (hash-table-set! groups key (cons line val))))))))\n\n;; extract the longest values from given hash-table of groups\n(define (largest-groups groups)\n  (define (find-largest grps n sofar)\n    (cond ((null? grps)\n           sofar)\n          ((> (length (car grps)) n)\n           (find-largest (cdr grps) (length (car grps)) (list (car grps))))\n          ((= (length (car grps)) n)\n           (find-largest (cdr grps) n (cons (car grps) sofar)))\n          (else \n            (find-largest (cdr grps) n sofar))))\n  (find-largest (hash-table-values groups) 0 '()))\n\n;; print results\n(for-each \n  (lambda (group)\n    (display \"[ \")\n    (for-each (lambda (word) (display word) (display \" \")) group)\n    (display \"]\\n\"))\n  (list-sort (lambda (a b) (string<? (car a) (car b)))\n             (map (lambda (grp) (list-sort string<? grp))\n                  (largest-groups (read-groups)))))\n\nOutput:\n[ abel able bale bela elba ]\n[ alger glare lager large regal ]\n[ angel angle galen glean lange ]\n[ caret carte cater crate trace ]\n[ elan lane lean lena neal ]\n[ evil levi live veil vile ]\n\n", "explain": "Uses two SRFI libraries: SRFI 125 for hash tables and SRFI 132 for sorting.\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 2\n$c = New-Object Net.WebClient\n$words = -split ($c.DownloadString('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'))\n$top_anagrams = $words `\n    | ForEach-Object {\n          $_ | Add-Member -PassThru NoteProperty Characters `\n                   (-join (([char[]] $_) | Sort-Object))\n      } `\n    | Group-Object Characters `\n    | Group-Object Count `\n    | Sort-Object Count `\n    | Select-Object -First 1\n\n$top_anagrams.Group | ForEach-Object { $_.Group -join ', ' }\n\n\nOutput:\nabel, able, bale, bela, elba\nalger, glare, lager, large, regal\nangel, angle, galen, glean, lange\ncaret, carte, cater, crate, trace\nelan, lane, lean, lena, neal\nevil, levi, live, veil, vile\n\n$Timer = [System.Diagnostics.Stopwatch]::StartNew()\n\n$uri = 'http://wiki.puzzlers.org/pub/wordlists/unixdict.txt'\n$words = -split [Net.WebClient]::new().DownloadString($uri)\n\n$anagrams = @{}\n$maxAnagramCount = 0\n\nforeach ($w in $words)\n{\n    # Sort the characters in the word into alphabetical order\n    $chars=[char[]]$w\n    [array]::sort($chars)\n    $orderedChars = [string]::Join('', $chars)\n    \n\n    # If no anagrams list for these chars, make one\n    if (-not $anagrams.ContainsKey($orderedChars))\n    {\n        $anagrams[$orderedChars] = [Collections.Generic.List[String]]::new()\n    }\n\n\n    # Add current word as an anagram of these chars,\n    # in a way which keeps the list available\n    ($list = $anagrams[$orderedChars]).Add($w)\n    \n\n    # Keep running score of max number of anagrams seen\n    if ($list.Count -gt $maxAnagramCount)\n    {\n        $maxAnagramCount = $list.Count\n    }\n    \n}\n\nforeach ($entry in $anagrams.GetEnumerator())\n{\n    if ($entry.Value.Count -eq $maxAnagramCount)\n    {\n        [string]::join('', $entry.Value)\n    }\n}\n\n", "explain": "Another way with more .Net methods is quite a different style, but drops the runtime from 2 minutes to 1.5 seconds:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "ABAP", "code": "\nreport zz_anagrams no standard page heading.\ndefine update_progress.\n  call function 'SAPGUI_PROGRESS_INDICATOR'\n    exporting\n      text = &1.\nend-of-definition.\n\n\" Selection screen segment allowing the person to choose which file will act as input.\nselection-screen begin of block file_choice.\n  parameters p_file type string lower case.\nselection-screen end of block file_choice.\n\n\" When the user requests help with input, run the routine to allow them to navigate the presentation server.\nat selection-screen on value-request for p_file.\n  perform getfile using p_file.\n\nat selection-screen output.\n  %_p_file_%_app_%-text = 'Input File: '.\n\nstart-of-selection.\n  data: gt_data type table of string.\n\n  \" Read the specified file from the presentation server into memory.\n  perform readfile using p_file changing gt_data.\n  \" After the file has been read into memory, loop through it line-by-line and make anagrams.\n  perform anagrams using gt_data.\n\n\" Subroutine for generating a list of anagrams.\n\" The supplied input is a table, with each entry corresponding to a word.\nform anagrams using it_data like gt_data.\n  types begin of ty_map.\n    types key type string.\n    types value type string.\n  types end of ty_map.\n\n  data: lv_char     type c,\n        lv_len      type i,\n        lv_string   type string,\n        ls_entry    type ty_map,\n        lt_anagrams type standard table of ty_map,\n        lt_c_tab    type table of string.\n\n  field-symbols: <fs_raw> type string.\n  \" Loop through each word in the table, and make an associative array.\n  loop at gt_data assigning <fs_raw>.\n    \" First, we need to re-order the word alphabetically. This generated a key. All anagrams will use this same key.\n    \" Add each character to a table, which we will then sort alphabetically.\n    lv_len = strlen( <fs_raw> ).\n    refresh lt_c_tab.\n    do lv_len times.\n      lv_len = sy-index  - 1.\n      append <fs_raw>+lv_len(1) to lt_c_tab.\n    enddo.\n    sort lt_c_tab as text.\n    \" Now append the characters to a string and add it as a key into the map.\n    clear lv_string.\n    loop at lt_c_tab into lv_char.\n      concatenate lv_char lv_string into lv_string respecting blanks.\n    endloop.\n    ls_entry-key = lv_string.\n    ls_entry-value = <fs_raw>.\n    append ls_entry to lt_anagrams.\n  endloop.\n  \" After we're done processing, output a list of the anagrams.\n  clear lv_string.\n  loop at lt_anagrams into ls_entry.\n    \" Is it part of the same key --> Output in the same line, else a new entry.\n    if lv_string = ls_entry-key.\n        write: ', ', ls_entry-value.\n    else.\n      if sy-tabix <> 1.\n        write: ']'.\n      endif.\n      write:  / '[', ls_entry-value.\n    endif.\n    lv_string = ls_entry-key.\n  endloop.\n  \" Close last entry.\n  write ']'.\nendform.\n\n\" Read a specified file from the presentation server.\nform readfile using i_file type string changing it_raw like gt_data.\n  data: l_datat type string,\n        l_msg(2048),\n        l_lines(10).\n\n  \" Read the file into memory.\n  update_progress 'Reading file...'.\n  call method cl_gui_frontend_services=>gui_upload\n    exporting\n      filename = i_file\n    changing\n      data_tab = it_raw\n    exceptions\n      others   = 1.\n  \" Output error if the file could not be uploaded.\n  if sy-subrc <> 0.\n    write : / 'Error reading the supplied file!'.\n    return.\n  endif.\nendform.\n\n\nOutput:\n[ angel ,  angle ,  galen ,  glean ,  lange ]\n[ elan ,  lane ,  lean ,  lena ,  neal ]\n[ alger ,  glare ,  lager ,  large ,  regal ]\n[ abel ,  able ,  bale ,  bela ,  elba ]\n[ evil ,  levi ,  live ,  veil ,  vile ]\n[ caret ,  carte ,  cater ,  crate ,  trace ]\n", "explain": ""}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "F#", "code": "\n\nlet xss = Seq.groupBy (Array.ofSeq >> Array.sort) (System.IO.File.ReadAllLines \"unixdict.txt\")\nSeq.map snd xss |> Seq.filter (Seq.length >> ( = ) (Seq.map (snd >> Seq.length) xss |> Seq.max))\n\n\nval it : string seq seq =\n  seq\n    [seq [\"abel\"; \"able\"; \"bale\"; \"bela\"; \"elba\"];\n     seq [\"alger\"; \"glare\"; \"lager\"; \"large\"; \"regal\"];\n     seq [\"angel\"; \"angle\"; \"galen\"; \"glean\"; \"lange\"];\n     seq [\"caret\"; \"carte\"; \"cater\"; \"crate\"; \"trace\"];\n     seq [\"elan\"; \"lane\"; \"lean\"; \"lena\"; \"neal\"];\n     seq [\"evil\"; \"levi\"; \"live\"; \"veil\"; \"vile\"]]\n\n", "explain": "Read the lines in the dictionary, group by the sorted letters in each word, find the length of the longest sets of anagrams, extract the longest sequences of words sharing the same letters (i.e. anagrams):\nNote that it is necessary to convert the sorted letters in each word from sequences to arrays because the groupBy function uses the default comparison and sequences do not compare structurally (but arrays do in F#).\nTakes 0.8s to return:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "Groovy", "code": "\n\ndef words = new URL('http://wiki.puzzlers.org/pub/wordlists/unixdict.txt').text.readLines()\ndef groups = words.groupBy{ it.toList().sort() }\ndef bigGroupSize = groups.collect{ it.value.size() }.max()\ndef isBigAnagram = { it.value.size() == bigGroupSize }\nprintln groups.findAll(isBigAnagram).collect{ it.value }.collect{ it.join(' ') }.join('\\n')\n\n\nOutput:\nabel able bale bela elba\nalger glare lager large regal\nangel angle galen glean lange\ncaret carte cater crate trace\nelan lane lean lena neal\nevil levi live veil vile\n\n", "explain": "This program:\n"}, {"task_name": "Anagrams", "task_url": "https://rosettacode.org/wiki/Anagrams", "task_cat": "Text processing", "lang": "AWK", "code": "\n# JUMBLEA.AWK - words with the most duplicate spellings\n# syntax: GAWK -f JUMBLEA.AWK UNIXDICT.TXT\n{   for (i=1; i<=NF; i++) {\n      w = sortstr(toupper($i))\n      arr[w] = arr[w] $i \" \"\n      n = gsub(/ /,\"&\",arr[w])\n      if (max_n < n) { max_n = n }\n    }\n}\nEND {\n    for (w in arr) {\n      if (gsub(/ /,\"&\",arr[w]) == max_n) {\n        printf(\"%s\\t%s\\n\",w,arr[w])\n      }\n    }\n    exit(0)\n}\nfunction sortstr(str,  i,j,leng) {\n    leng = length(str)\n    for (i=2; i<=leng; i++) {\n      for (j=i; j>1 && substr(str,j-1,1) > substr(str,j,1); j--) {\n        str = substr(str,1,j-2) substr(str,j,1) substr(str,j-1,1) substr(str,j+1)\n      }\n    }\n    return(str)\n}\n\n\nOutput:\nABEL    abel able bale bela elba\nACERT   caret carte cater crate trace\nAEGLN   angel angle galen glean lange\nAEGLR   alger glare lager large regal\nAELN    elan lane lean lena neal\nEILV    evil levi live veil vile\n\n\nWorks with: gawk\n#!/bin/gawk -f\n\n{   patsplit($0, chars, \".\")\n    asort(chars)\n    sorted = \"\"\n    for (i = 1; i <= length(chars); i++)\n\tsorted = sorted chars[i]\n\n    if (++count[sorted] > countMax) countMax++\n    accum[sorted] = accum[sorted] \" \" $0\n}\n\nEND {\n    for (i in accum)\n\tif (count[i] == countMax)\n\t    print substr(accum[i], 2)\n}\n\n", "explain": "Alternatively, non-POSIX version:\n"}]