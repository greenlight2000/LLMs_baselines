[{"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Python", "code": "\n\ndef readconf(fn):\n    ret = {}\n    with file(fn) as fp:\n        for line in fp:\n            # Assume whitespace is ignorable\n            line = line.strip()\n            if not line or line.startswith('#'): continue\n            \n            boolval = True\n            # Assume leading \";\" means a false boolean\n            if line.startswith(';'):\n                # Remove one or more leading semicolons\n                line = line.lstrip(';')\n                # If more than just one word, not a valid boolean\n                if len(line.split()) != 1: continue\n                boolval = False\n            \n            bits = line.split(None, 1)\n            if len(bits) == 1:\n                # Assume booleans are just one standalone word\n                k = bits[0]\n                v = boolval\n            else:\n                # Assume more than one word is a string value\n                k, v = bits\n            ret[k.lower()] = v\n    return ret\n\n\nif __name__ == '__main__':\n    import sys\n    conf = readconf(sys.argv[1])\n    for k, v in sorted(conf.items()):\n        print k, '=', v\n\n", "explain": "This task is not well-defined, so we have to make some assumptions (see comments in code).\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "C", "code": "\nLibrary: libconfini\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <confini.h>\n\n#define rosetta_uint8_t unsigned char\n\n#define FALSE 0\n#define TRUE 1\n\n#define CONFIGS_TO_READ 5\n#define INI_ARRAY_DELIMITER ','\n\n/* Assume that the config file represent a struct containing all the parameters to load */\nstruct configs {\n\tchar *fullname;\n\tchar *favouritefruit;\n\trosetta_uint8_t needspeeling;\n\trosetta_uint8_t seedsremoved;\n\tchar **otherfamily;\n\tsize_t otherfamily_len;\n\tsize_t _configs_left_;\n};\n\nstatic char ** make_array (size_t * arrlen, const char * src, const size_t buffsize, IniFormat ini_format) {\n \n\t/* Allocate a new array of strings and populate it from the stringified source */\n\t*arrlen = ini_array_get_length(src, INI_ARRAY_DELIMITER, ini_format);\n\tchar ** const dest = *arrlen ? (char **) malloc(*arrlen * sizeof(char *) + buffsize) : NULL;\n\tif (!dest) { return NULL; }\n\tmemcpy(dest + *arrlen, src, buffsize);\n\tchar * iter = (char *) (dest + *arrlen);\n\tfor (size_t idx = 0; idx < *arrlen; idx++) {\n\t\tdest[idx] = ini_array_release(&iter, INI_ARRAY_DELIMITER, ini_format);\n\t\tini_string_parse(dest[idx], ini_format);\n\t}\n\treturn dest;\n\n}\n\nstatic int configs_member_handler (IniDispatch *this, void *v_confs) {\n\n\tstruct configs *confs = (struct configs *) v_confs;\n\n\tif (this->type != INI_KEY) {\n\n\t\treturn 0;\n\n\t}\n\n\tif (ini_string_match_si(\"FULLNAME\", this->data, this->format)) {\n\n\t\tif (confs->fullname) { return 0; }\n\t\tthis->v_len = ini_string_parse(this->value, this->format); /* Remove all quotes, if any */\n\t\tconfs->fullname = strndup(this->value, this->v_len);\n\t\tconfs->_configs_left_--;\n\n\t} else if (ini_string_match_si(\"FAVOURITEFRUIT\", this->data, this->format)) {\n\n\t\tif (confs->favouritefruit) { return 0; }\n\t\tthis->v_len = ini_string_parse(this->value, this->format); /* Remove all quotes, if any */\n\t\tconfs->favouritefruit = strndup(this->value, this->v_len);\n\t\tconfs->_configs_left_--;\n\n\t} else if (ini_string_match_si(\"NEEDSPEELING\", this->data, this->format)) {\n\n\t\tif (~confs->needspeeling & 0x80) { return 0; }\n\t\tconfs->needspeeling = ini_get_bool(this->value, TRUE);\n\t\tconfs->_configs_left_--;\n\n\t} else if (ini_string_match_si(\"SEEDSREMOVED\", this->data, this->format)) {\n\n\t\tif (~confs->seedsremoved & 0x80) { return 0; }\n\t\tconfs->seedsremoved = ini_get_bool(this->value, TRUE);\n\t\tconfs->_configs_left_--;\n\n\t} else if (!confs->otherfamily && ini_string_match_si(\"OTHERFAMILY\", this->data, this->format)) {\n\n\t\tif (confs->otherfamily) { return 0; }\n\t\tthis->v_len = ini_array_collapse(this->value, INI_ARRAY_DELIMITER, this->format); /* Save memory (not strictly needed) */\n\t\tconfs->otherfamily = make_array(&confs->otherfamily_len, this->value, this->v_len + 1, this->format);\n\t\tconfs->_configs_left_--;\n\n\t}\n\n\t/* Optimization: stop reading the INI file when we have all we need */\n\treturn !confs->_configs_left_;\n\n}\n\nstatic int populate_configs (struct configs * confs) {\n\n\t/* Define the format of the configuration file */\n\tIniFormat config_format = {\n\t\t.delimiter_symbol = INI_ANY_SPACE,\n\t\t.case_sensitive = FALSE,\n\t\t.semicolon_marker = INI_IGNORE,\n\t\t.hash_marker = INI_IGNORE,\n\t\t.multiline_nodes = INI_NO_MULTILINE,\n\t\t.section_paths = INI_NO_SECTIONS,\n\t\t.no_single_quotes = FALSE,\n\t\t.no_double_quotes = FALSE,\n\t\t.no_spaces_in_names = TRUE,\n\t\t.implicit_is_not_empty = TRUE,\n\t\t.do_not_collapse_values = FALSE,\n\t\t.preserve_empty_quotes = FALSE,\n\t\t.disabled_after_space = TRUE,\n\t\t.disabled_can_be_implicit = FALSE\n\t};\n\n\t*confs = (struct configs) { NULL, NULL, 0x80, 0x80, NULL, 0, CONFIGS_TO_READ };\n\n\tif (load_ini_path(\"rosetta.conf\", config_format, NULL, configs_member_handler, confs) & CONFINI_ERROR) {\n\n\t\tfprintf(stderr, \"Sorry, something went wrong\u00a0:-(\\n\");\n\t\treturn 1;\n\n\t}\n\n\tconfs->needspeeling &= 0x7F;\n\tconfs->seedsremoved &= 0x7F;\n\n\treturn 0;\n\n}\n\nint main () {\n\n\tstruct configs confs;\n\n\tini_global_set_implicit_value(\"YES\", 0);\n\n\tif (populate_configs(&confs)) {\n\n\t\treturn 1;\n\n\t}\n\n\t/* Print the configurations parsed */\n\n\tprintf(\n\n\t\t\"Full name: %s\\n\"\n\t\t\"Favorite fruit: %s\\n\"\n\t\t\"Need spelling: %s\\n\"\n\t\t\"Seeds removed: %s\\n\",\n\n\t\tconfs.fullname,\n\t\tconfs.favouritefruit,\n\t\tconfs.needspeeling ? \"True\" : \"False\",\n\t\tconfs.seedsremoved ? \"True\" : \"False\"\n\n\t);\n\n\tfor (size_t idx = 0; idx < confs.otherfamily_len; idx++) {\n\n\t\tprintf(\"Other family[%d]: %s\\n\", idx, confs.otherfamily[idx]);\n\n\t}\n\n\t/* Free the allocated memory */\n\n\t#define FREE_NON_NULL(PTR) if (PTR) { free(PTR); }\n\n\tFREE_NON_NULL(confs.fullname);\n\tFREE_NON_NULL(confs.favouritefruit);\n\tFREE_NON_NULL(confs.otherfamily);\n\n\treturn 0;\n\n}\n\n\nOutput:\nFull name: Foo Barber\nFavorite fruit: banana\nNeed spelling: True\nSeeds removed: False\nOther family[0]: Rhu Barber\nOther family[1]: Harry Barber\n", "explain": "optimized\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "C++", "code": "\nLibrary: Boost\nWorks with: Visual Studio version  2005\n\n#include \"stdafx.h\"\n#include <iostream>\n#include <fstream>\n#include <vector>\n#include <string>\n#include <boost/tokenizer.hpp>\n#include <boost/algorithm/string/case_conv.hpp>\nusing namespace std;\nusing namespace boost;\n\ntypedef boost::tokenizer<boost::char_separator<char> > Tokenizer;\nstatic const char_separator<char> sep(\" \",\"#;,\");\n\n//Assume that the config file represent a struct containing all the parameters to load\nstruct configs{\n\tstring fullname;\n\tstring favoritefruit;\n\tbool needspelling;\n\tbool seedsremoved;\n\tvector<string> otherfamily;\n} conf;\n\nvoid parseLine(const string &line, configs &conf)\n{\n\tif (line[0] == '#' || line.empty())\n\t\treturn;\n\tTokenizer tokenizer(line, sep);\n\tvector<string> tokens;\n\tfor (Tokenizer::iterator iter = tokenizer.begin(); iter != tokenizer.end(); iter++)\n\t\ttokens.push_back(*iter);\n\tif (tokens[0] == \";\"){\n\t\talgorithm::to_lower(tokens[1]);\n\t\tif (tokens[1] == \"needspeeling\")\n\t\t\tconf.needspelling = false;\n\t\tif (tokens[1] == \"seedsremoved\")\n\t\t\tconf.seedsremoved = false;\n\t}\n\talgorithm::to_lower(tokens[0]);\n\tif (tokens[0] == \"needspeeling\")\n\t\tconf.needspelling = true;\n\tif (tokens[0] == \"seedsremoved\")\n\t\tconf.seedsremoved = true;\n\tif (tokens[0] == \"fullname\"){\n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.fullname += tokens[i] + \" \";\n\t\tconf.fullname.erase(conf.fullname.size() -1, 1);\n\t}\n\tif (tokens[0] == \"favouritefruit\") \n\t\tfor (unsigned int i=1; i<tokens.size(); i++)\n\t\t\tconf.favoritefruit += tokens[i];\n\tif (tokens[0] == \"otherfamily\"){\n\t\tunsigned int i=1;\n\t\tstring tmp;\n\t\twhile (i<=tokens.size()){\t\t\n\t\t\tif ( i == tokens.size() || tokens[i] ==\",\"){\n\t\t\t\ttmp.erase(tmp.size()-1, 1);\n\t\t\t\tconf.otherfamily.push_back(tmp);\n\t\t\t\ttmp = \"\";\n\t\t\t\ti++;\n\t\t\t}\n\t\t\telse{\n\t\t\t\ttmp += tokens[i];\n\t\t\t\ttmp += \" \";\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t}\n}\n\nint _tmain(int argc, TCHAR* argv[])\n{\n\tif (argc != 2)\n\t{\n\t\twstring tmp = argv[0];\n\t\twcout << L\"Usage: \" << tmp << L\" <configfile.ini>\" << endl;\n\t\treturn -1;\n\t}\n\tifstream file (argv[1]);\n\t\n\tif (file.is_open())\n\t\twhile(file.good())\n\t\t{\n\t\t\tchar line[255];\n\t\t\tfile.getline(line, 255);\n\t\t\tstring linestring(line);\n\t\t\tparseLine(linestring, conf);\n\t\t}\n\telse\n\t{\n\t\tcout << \"Unable to open the file\" << endl;\n\t\treturn -2;\n\t}\n\n\tcout << \"Fullname= \" << conf.fullname << endl;\n\tcout << \"Favorite Fruit= \" << conf.favoritefruit << endl;\n\tcout << \"Need Spelling= \" << (conf.needspelling?\"True\":\"False\") << endl;\n\tcout << \"Seed Removed= \" << (conf.seedsremoved?\"True\":\"False\") << endl;\n\tstring otherFamily;\n\tfor (unsigned int i = 0; i < conf.otherfamily.size(); i++)\n\t\totherFamily += conf.otherfamily[i] + \", \";\n\totherFamily.erase(otherFamily.size()-2, 2);\n\tcout << \"Other Family= \" << otherFamily << endl;\n\n\treturn 0;\n}\n\n\nOutput:\nFullname= Foo Barber\nFavorite Fruit= banana\nNeed Spelling= True\nSeed Removed= False\nOther Family= Rhu Barber, Harry Barber\n\n#include <iostream>\n#include <iomanip>\n#include <string>\n#include <exception>\n#include <fstream>\n#include <vector>\n#include <algorithm>\n\nstruct confi {\n\tstd::string fullname;\n\tstd::string favouritefruit;\n\tbool needspeeling;\n\tbool seedsremoved;\n\tstd::vector<std::string> otherfamily;\n};\n\nvoid read_config(std::ifstream& in, confi& out) {\n\tin.open(\"Config.txt\");\n\tstd::string str;\n\tout.needspeeling = false;\n\tout.seedsremoved = false;\n\twhile(!in.eof()) {\n\t\twhile(getline(in,str)) {\n\t\t\tstd::string::size_type begin = str.find_first_not_of(\" \\f\\t\\v\");\n\t\t\t//Skips blank lines\n\t\t\tif(begin == std::string::npos)\n\t\t\t\tcontinue;\n\t\t\t//Skips #\n\t\t\tif(std::string(\"#\").find(str[begin]) != std::string::npos)\n\t\t\t\tcontinue;\n\t\t\tstd::string firstWord;\n\t\t\ttry {\n\t\t\t\tfirstWord = str.substr(0,str.find(\" \"));\n\t\t\t}\n\t\t\tcatch(std::exception& e) {\n\t\t\t\tfirstWord = str.erase(str.find_first_of(\" \"),str.find_first_not_of(\" \"));\n\t\t\t}\n\t\t\tstd::transform(firstWord.begin(),firstWord.end(),firstWord.begin(), ::toupper);\n\t\t\tif(firstWord == \"FULLNAME\")\n\t\t\t\tout.fullname = str.substr(str.find(\" \")+1,str.length());\n\t\t\tif(firstWord == \"FAVOURITEFRUIT\")\n\t\t\t\tout.favouritefruit = str.substr(str.find(\" \")+1,str.length());\n\t\t\tif(firstWord == \"NEEDSPEELING\")\n\t\t\t\tout.needspeeling = true;\n\t\t\tif(firstWord == \"SEEDSREMOVED\")\n\t\t\t\tout.seedsremoved = true;\n\t\t\tif(firstWord == \"OTHERFAMILY\") {\n\t\t\t\tsize_t found = str.find(\",\");\n\t\t\t\tif(found != std::string::npos) {\n\t\t\t\t\tout.otherfamily.push_back(str.substr(str.find_first_of(\" \")+1,found-str.find_first_of(\" \")-1));\n\t\t\t\t\tout.otherfamily.push_back(str.substr(found+2,str.length()));\n\t\t\t\t}\n\t\t\t}\n\t\t\t\t\t\n\t\t}\n\t}\n\tstd::cout << \"Full Name: \" << out.fullname << std::endl;\n\tstd::cout << \"Favourite Fruit: \" << out.favouritefruit << std::endl;\n\tstd::cout << \"Needs peeling?: \";\n\tif(out.needspeeling == true)\n\t\tstd::cout << \"True\" << std::endl;\n\telse\n\t\tstd::cout << \"False\" << std::endl;\n\tstd::cout << \"Seeds removed?: \";\n\tif(out.seedsremoved == true)\n\t\tstd::cout << \"True\" << std::endl;\n\telse\n\t\tstd::cout << \"False\" << std::endl;\n\tstd::cout << \"Other family members: \" << out.otherfamily[0] << \", \" << out.otherfamily[1] << std::endl;\n}\nint main() {\n\tstd::ifstream inp;\n\tconfi outp;\n\tread_config(inp,outp);\n}\n\n\nOutput:\nFull Name: Foo Barber\nFavourite Fruit: banana\nNeeds peeling?: True\nSeeds removed?: False\nOther family members: Rhu Barber, Harry Barber\n", "explain": "unoptimized\nSolution without Boost libraries. No optimisation.\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Java", "code": "\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class ConfigReader {\n    private static final Pattern             LINE_PATTERN = Pattern.compile( \"([^ =]+)[ =]?(.*)\" );\n    private static final Map<String, Object> DEFAULTS     = new HashMap<String, Object>() {{\n        put( \"needspeeling\", false );\n        put( \"seedsremoved\", false );\n    }};\n\n    public static void main( final String[] args ) {\n        System.out.println( parseFile( args[ 0 ] ) );\n    }\n\n    public static Map<String, Object> parseFile( final String fileName ) {\n        final Map<String, Object> result = new HashMap<String, Object>( DEFAULTS );\n        /*v*/ BufferedReader      reader = null;\n\n        try {\n            reader = new BufferedReader( new FileReader( fileName ) );\n            for ( String line; null != ( line = reader.readLine() );  ) {\n                parseLine( line, result );\n            }\n        } catch ( final IOException x ) {\n            throw new RuntimeException( \"Oops: \" + x, x );\n        } finally {\n            if ( null != reader ) try {\n                reader.close();\n            } catch ( final IOException x2 ) {\n                System.err.println( \"Could not close \" + fileName + \" - \" + x2 );\n            }\n        }\n\n        return result;\n    }\n\n    private static void parseLine( final String line, final Map<String, Object> map ) {\n        if ( \"\".equals( line.trim() ) || line.startsWith( \"#\" ) || line.startsWith( \";\" ) )\n            return;\n\n        final Matcher matcher = LINE_PATTERN.matcher( line );\n\n        if ( ! matcher.matches() ) {\n            System.err.println( \"Bad config line: \" + line );\n            return;\n        }\n\n        final String key   = matcher.group( 1 ).trim().toLowerCase();\n        final String value = matcher.group( 2 ).trim();\n\n        if ( \"\".equals( value ) ) {\n            map.put( key, true );\n        } else if ( -1 == value.indexOf( ',' ) ) {\n            map.put( key, value );\n        } else {\n            final String[] values = value.split( \",\" );\n\n            for ( int i = 0; i < values.length; i++ ) {\n                values[ i ] = values[ i ].trim();\n            }\n            map.put( key, Arrays.asList( values ) );\n        }\n    }\n}\n\n\nOutput:\n{otherfamily=[Rhu Barber, Harry Barber], favouritefruit=banana, seedsremoved=false, needspeeling=true, fullname=Foo Barber}\n\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\nimport java.util.HashMap;\nimport java.util.Map;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\nimport java.util.stream.Collectors;\n\npublic class ConfigReader {\n    private static final Pattern LINE_PATTERN = Pattern.compile(\"([^ =]+)[ =]?(.*)\");\n\n    public static void main(final String[] args) throws IOException {\n        System.out.println(parseFile(args[0]));\n    }\n\n    public static Map<String, Object> parseFile(final String fileName) throws IOException {\n        final Map<String, Object> result = new HashMap<>();\n        result.put(\"needspeeling\", false);\n        result.put(\"seedsremoved\", false);\n        try (BufferedReader reader = new BufferedReader(new FileReader(fileName))) {\n            result.putAll(reader.lines()\n                .filter(line -> !\"\".equals(line.trim()) && !line.startsWith(\"#\") && !line.startsWith(\";\"))\n                .map(LINE_PATTERN::matcher)\n                .filter(Matcher::matches)\n                .collect(Collectors.toMap(matcher -> matcher.group(1).trim().toLowerCase(), matcher -> {\n                    final String value = matcher.group(2).trim();\n                    if (\"\".equals(value)) {\n                        return true;\n                    } else if (-1 == value.indexOf(',')) {\n                        return value;\n                    }\n                    return Arrays.asList(value.split(\",\")).stream().map(String::trim).collect(Collectors.toList());\n                }))\n            );\n        }\n\n        return result;\n    }\n}\n\n\nOutput:\n{seedsremoved=false, otherfamily=[Rhu Barber, Harry Barber], needspeeling=true, fullname=Foo Barber, favouritefruit=banana}\n", "explain": "A more natural way to do this in Java would be Properties.load(InputStream) but the example data is not in the format expected by that method (equals signs are optional).\nA more functional and concise approach using Java 8:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "JavaScript", "code": "\n\nfunction parseConfig(config) {\n    // this expression matches a line starting with an all capital word, \n    // and anything after it\n    var regex = /^([A-Z]+)(.*)$/mg;\n    var configObject = {};\n    \n    // loop until regex.exec returns null\n    var match;\n    while (match = regex.exec(config)) {\n        // values will typically be an array with one element\n        // unless we want an array\n        // match[0] is the whole match, match[1] is the first group (all caps word), \n        // and match[2] is the second (everything through the end of line)\n        var key = match[1], values = match[2].split(\",\");\n        if (values.length === 1) {\n            configObject[key] = values[0];\n        }\n        else {\n            configObject[key] = values.map(function(value){\n                return value.trim();\n            });\n        }\n    }\n    \n    return configObject;\n}\n\n\n{\n  \"FULLNAME\": \" Foo Barber\",\n  \"FAVOURITEFRUIT\": \" banana\",\n  \"NEEDSPEELING\": \"\",\n  \"OTHERFAMILY\": [\n    \"Rhu Barber\",\n    \"Harry Barber\"\n  ]\n}\n\n", "explain": "In JavaScript using an object makes more sense than local variables.  This function takes our config file in plain text as the parameter.\nThe result is an object, which can be represented with this JSON.\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "PHP", "code": "\n\n<?php\n\n$conf = file_get_contents('parse-conf-file.txt');\n\n// Add an \"=\" after entry name\n$conf = preg_replace('/^([a-z]+)/mi', '$1 =', $conf);\n\n// Replace multiple parameters separated by commas\u00a0:\n//   name = value1, value2\n// by multiple lines\u00a0:\n//   name[] = value1\n//   name[] = value2\n$conf = preg_replace_callback(\n    '/^([a-z]+)\\s*=((?=.*\\,.*).*)$/mi',\n    function ($matches) {\n        $r = '';\n        foreach (explode(',', $matches[2]) AS $val) {\n            $r .= $matches[1] . '[] = ' . trim($val) . PHP_EOL;\n        }\n        return $r;\n    },\n    $conf\n);\n\n// Replace empty values by \"true\"\n$conf = preg_replace('/^([a-z]+)\\s*=$/mi', '$1 = true', $conf);\n\n// Parse configuration file\n$ini = parse_ini_string($conf);\n\necho 'Full name       = ', $ini['FULLNAME'], PHP_EOL;\necho 'Favourite fruit = ', $ini['FAVOURITEFRUIT'], PHP_EOL;\necho 'Need spelling   = ', (empty($ini['NEEDSPEELING']) ? 'false' : 'true'), PHP_EOL;\necho 'Seeds removed   = ', (empty($ini['SEEDSREMOVED']) ? 'false' : 'true'), PHP_EOL;\necho 'Other family    = ', print_r($ini['OTHERFAMILY'], true), PHP_EOL;\n\n\nOutput:\nFull name       = Foo Barber\nFavourite fruit = banana\nNeed spelling   = true\nSeeds removed   = false\nOther family    = Array\n(\n    [0] => Rhu Barber\n    [1] => Harry Barber\n)\n", "explain": "Slightly modify the format of the configuration file before passing it to the internal function parse_ini_string()\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Fortran", "code": "\nprogram readconfig\n  implicit none\n  integer, parameter    :: strlen = 100\n  logical               :: needspeeling = .false., seedsremoved =.false.\n  character(len=strlen) :: favouritefruit = \"\", fullname = \"\", fst, snd\n  character(len=strlen), allocatable :: otherfamily(:), tmp(:)\n  character(len=1000)   :: line\n  integer               :: lun, stat,  j, j0, j1, ii = 1, z\n  integer, parameter    :: state_begin=1, state_in_fst=2, state_in_sep=3\n\n  open(newunit=lun, file=\"config.ini\", status=\"old\")\n  \n  do \n    read(lun, \"(a)\", iostat=stat) line\n    if (stat<0) exit\n    if ((line(1:1) == \"#\") .or. &\n        (line(1:1) == \";\") .or. &\n        (len_trim(line)==0)) then\n      cycle\n    end if\n    z = state_begin\n    do j = 1, len_trim(line)\n      if (z == state_begin) then\n        if (line(j:j)/=\" \") then\n          j0 = j\n          z = state_in_fst\n        end if\n      elseif (z == state_in_fst) then\n        if (index(\"= \",line(j:j))>0) then\n          fst = lower(line(j0:j-1))\n          z = state_in_sep\n        end if\n      elseif (z == state_in_sep) then\n        if (index(\" =\",line(j:j)) == 0) then\n          snd = line(j:)\n          exit\n        end if\n      else\n         stop \"not possible to be here\"\n      end if\n    end do\n    if (z == state_in_fst) then\n      fst = lower(line(j0:))\n    elseif (z == state_begin) then\n      cycle\n    end if\n\n    if (fst==\"fullname\") then\n      read(snd,\"(a)\") fullname\n    elseif (fst==\"favouritefruit\") then\n      read(snd,\"(a)\") favouritefruit\n    elseif (fst==\"seedsremoved\") then\n      seedsremoved = .true.\n    elseif (fst==\"needspeeling\") then\n      needspeeling = .true.\n    elseif (fst==\"otherfamily\") then\n      j = 1; ii = 1\n      do while (len_trim(snd(j:)) >0)\n        j1  = index(snd(j:),\",\")\n        if (j1==0) then\n          j1 = len_trim(snd)\n        else\n          j1 = j + j1 - 2\n        end if\n        do \n          if (j>len_trim(snd)) exit\n          if (snd(j:j) /= \" \") exit\n          j = j +1\n        end do\n        allocate(tmp(ii)) \n        tmp(1:ii-1) = otherfamily\n        call move_alloc(tmp, otherfamily)\n        read(snd(j:j1),\"(a)\"), otherfamily(ii)\n        j = j1 + 2 \n        ii = ii + 1\n      end do\n    else \n      print *, \"unknown option '\"//trim(fst)//\"'\"; stop\n    end if\n  end do\n  close(lun)\n\n  print \"(a,a)\",\"fullname = \",       trim(fullname)\n  print \"(a,a)\",\"favouritefruit = \", trim(favouritefruit)\n  print \"(a,l)\",\"needspeeling = \",   needspeeling\n  print \"(a,l)\",\"seedsremoved = \",   seedsremoved\n  print \"(a,*(a,:,', '))\", \"otherfamily = \", &\n         (trim(otherfamily(j)), j=1,size(otherfamily))\n\ncontains\n\npure function lower (str) result (string)\n    implicit none\n    character(*), intent(In) :: str\n    character(len(str))      :: string\n    Integer :: ic, i\n\n    character(26), parameter :: cap = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ'\n    character(26), parameter :: low = 'abcdefghijklmnopqrstuvwxyz'\n\n    string = str\n    do i = 1, len_trim(str)\n        ic = index(cap, str(i:i))\n        if (ic > 0) string(i:i) = low(ic:ic)\n    end do\nend function \n\nend program\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Go", "code": "\n\npackage config\n\nimport (\n\t\"errors\"\n\t\"io\"\n\t\"fmt\"\n\t\"bytes\"\n\t\"strings\"\n\t\"io/ioutil\"\n)\n\nvar (\n\tENONE    = errors.New(\"Requested value does not exist\")\n\tEBADTYPE = errors.New(\"Requested type and actual type do not match\")\n\tEBADVAL  = errors.New(\"Value and type do not match\")\n)\n\ntype varError struct {\n\terr error\n\tn   string\n\tt   VarType\n}\n\nfunc (err *varError) Error() string {\n\treturn fmt.Sprintf(\"%v: (%q, %v)\", err.err, err.n, err.t)\n}\n\ntype VarType int\n\nconst (\n\tBool VarType = 1 + iota\n\tArray\n\tString\n)\n\nfunc (t VarType) String() string {\n\tswitch t {\n\tcase Bool:\n\t\treturn \"Bool\"\n\tcase Array:\n\t\treturn \"Array\"\n\tcase String:\n\t\treturn \"String\"\n\t}\n\n\tpanic(\"Unknown VarType\")\n}\n\ntype confvar struct {\n\tType VarType\n\tVal  interface{}\n}\n\ntype Config struct {\n\tm map[string]confvar\n}\n\nfunc Parse(r io.Reader) (c *Config, err error) {\n\tc = new(Config)\n\tc.m = make(map[string]confvar)\n\n\tbuf, err := ioutil.ReadAll(r)\n\tif err != nil {\n\t\treturn\n\t}\n\n\tlines := bytes.Split(buf, []byte{'\\n'})\n\n\tfor _, line := range lines {\n\t\tline = bytes.TrimSpace(line)\n\t\tif len(line) == 0 {\n\t\t\tcontinue\n\t\t}\n\t\tswitch line[0] {\n\t\tcase '#', ';':\n\t\t\tcontinue\n\t\t}\n\n\t\tparts := bytes.SplitN(line, []byte{' '}, 2)\n\t\tnam := string(bytes.ToLower(parts[0]))\n\n\t\tif len(parts) == 1 {\n\t\t\tc.m[nam] = confvar{Bool, true}\n\t\t\tcontinue\n\t\t}\n\n\t\tif strings.Contains(string(parts[1]), \",\") {\n\t\t\ttmpB := bytes.Split(parts[1], []byte{','})\n\t\t\tfor i := range tmpB {\n\t\t\t\ttmpB[i] = bytes.TrimSpace(tmpB[i])\n\t\t\t}\n\t\t\ttmpS := make([]string, 0, len(tmpB))\n\t\t\tfor i := range tmpB {\n\t\t\t\ttmpS = append(tmpS, string(tmpB[i]))\n\t\t\t}\n\n\t\t\tc.m[nam] = confvar{Array, tmpS}\n\t\t\tcontinue\n\t\t}\n\n\t\tc.m[nam] = confvar{String, string(bytes.TrimSpace(parts[1]))}\n\t}\n\n\treturn\n}\n\nfunc (c *Config) Bool(name string) (bool, error) {\n\tname = strings.ToLower(name)\n\n\tif _, ok := c.m[name]; !ok {\n\t\treturn false, nil\n\t}\n\n\tif c.m[name].Type != Bool {\n\t\treturn false, &varError{EBADTYPE, name, Bool}\n\t}\n\n\tv, ok := c.m[name].Val.(bool)\n\tif !ok {\n\t\treturn false, &varError{EBADVAL, name, Bool}\n\t}\n\treturn v, nil\n}\n\nfunc (c *Config) Array(name string) ([]string, error) {\n\tname = strings.ToLower(name)\n\n\tif _, ok := c.m[name]; !ok {\n\t\treturn nil, &varError{ENONE, name, Array}\n\t}\n\n\tif c.m[name].Type != Array {\n\t\treturn nil, &varError{EBADTYPE, name, Array}\n\t}\n\n\tv, ok := c.m[name].Val.([]string)\n\tif !ok {\n\t\treturn nil, &varError{EBADVAL, name, Array}\n\t}\n\treturn v, nil\n}\n\nfunc (c *Config) String(name string) (string, error) {\n\tname = strings.ToLower(name)\n\n\tif _, ok := c.m[name]; !ok {\n\t\treturn \"\", &varError{ENONE, name, String}\n\t}\n\n\tif c.m[name].Type != String {\n\t\treturn \"\", &varError{EBADTYPE, name, String}\n\t}\n\n\tv, ok := c.m[name].Val.(string)\n\tif !ok {\n\t\treturn \"\", &varError{EBADVAL, name, String}\n\t}\n\n\treturn v, nil\n}\n\n\npackage main\n\nimport (\n\t\"os\"\n\t\"fmt\"\n\t\"config\"\n)\n\nfunc main() {\n\tif len(os.Args) != 2 {\n\t\tfmt.Printf(\"Usage: %v <configfile>\\n\", os.Args[0])\n\t\tos.Exit(1)\n\t}\n\n\tfile, err := os.Open(os.Args[1])\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\tdefer file.Close()\n\n\tconf, err := config.Parse(file)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfullname, err := conf.String(\"fullname\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfavouritefruit, err := conf.String(\"favouritefruit\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tneedspeeling, err := conf.Bool(\"needspeeling\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tseedsremoved, err := conf.Bool(\"seedsremoved\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\totherfamily, err := conf.Array(\"otherfamily\")\n\tif err != nil {\n\t\tfmt.Println(err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"FULLNAME: %q\\n\", fullname)\n\tfmt.Printf(\"FAVOURITEFRUIT: %q\\n\", favouritefruit)\n\tfmt.Printf(\"NEEDSPEELING: %q\\n\", needspeeling)\n\tfmt.Printf(\"SEEDSREMOVED: %q\\n\", seedsremoved)\n\tfmt.Printf(\"OTHERFAMILY: %q\\n\", otherfamily)\n}\n\n", "explain": "This make assumptions about the way the config file is supposed to be structured similar to the ones made by the Python solution.\nUsage example:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nLibrary:  uSettings\n\nunit uSettings;\n\ninterface\n\nuses\n  System.SysUtils, System.IoUtils, System.Generics.Collections, System.Variants;\n\ntype\n  TVariable = record\n    value: variant;\n    function ToString: string;\n    class operator Implicit(a: variant): TVariable;\n    class operator Implicit(a: TVariable): TArray<string>;\n    class operator Implicit(a: TVariable): string;\n  end;\n\n  TSettings = class(TDictionary<string, TVariable>)\n  private\n    function GetVariable(key: string): TVariable;\n    procedure SetVariable(key: string; const Value: TVariable);\n    function GetKey(line: string; var key: string; var value: variant; var\n      disable: boolean): boolean;\n    function GetAllKeys: TList<string>;\n  public\n    procedure LoadFromFile(Filename: TfileName);\n    procedure SaveToFile(Filename: TfileName);\n    property Variable[key: string]: TVariable read GetVariable write SetVariable; default;\n  end;\n\nimplementation\n\n{ TVariable }\n\nclass operator TVariable.Implicit(a: variant): TVariable;\nbegin\n  Result.value := a;\nend;\n\nclass operator TVariable.Implicit(a: TVariable): TArray<string>;\nbegin\n  if VarIsType(a.value, varArray or varOleStr) then\n    Result := a.value\n  else\n    raise Exception.Create('Error: can''t convert this type data in array');\nend;\n\nclass operator TVariable.Implicit(a: TVariable): string;\nbegin\n  Result := a.ToString;\nend;\n\nfunction TVariable.ToString: string;\nvar\n  arr: TArray<string>;\nbegin\n  if VarIsType(value, varArray or varOleStr) then\n  begin\n    arr := value;\n    Result := string.Join(', ', arr).Trim;\n  end\n  else\n    Result := value;\n  Result := Result.Trim;\nend;\n\n{ TSettings }\n\nfunction TSettings.GetAllKeys: TList<string>;\nvar\n  key: string;\nbegin\n  Result := TList<string>.Create;\n  for key in Keys do\n    Result.Add(key);\nend;\n\nfunction TSettings.GetKey(line: string; var key: string; var value: variant; var\n  disable: boolean): boolean;\nvar\n  line_: string;\n  j: integer;\nbegin\n  line_ := line.Trim;\n  Result := not (line_.IsEmpty or (line_[1] = '#'));\n  if not Result then\n    exit;\n\n  disable := (line_[1] = ';');\n  if disable then\n    delete(line_, 1, 1);\n\n  var data := line_.Split([' '], TStringSplitOptions.ExcludeEmpty);\n  case length(data) of\n    1: //Boolean\n      begin\n        key := data[0].ToUpper;\n        value := True;\n      end;\n\n    2: //Single String\n      begin\n        key := data[0].ToUpper;\n        value := data[1].Trim;\n      end;\n\n  else // Mult String value or Array of value\n    begin\n      key := data[0];\n      delete(line_, 1, key.Length);\n      if line_.IndexOf(',') > -1 then\n      begin\n        data := line_.Trim.Split([','], TStringSplitOptions.ExcludeEmpty);\n        for j := 0 to High(data) do\n          data[j] := data[j].Trim;\n        value := data;\n      end\n      else\n        value := line_.Trim;\n    end;\n  end;\n  Result := true;\nend;\n\nfunction TSettings.GetVariable(key: string): TVariable;\nbegin\n  key := key.Trim.ToUpper;\n  if not ContainsKey(key) then\n    add(key, false);\n\n  result := Items[key];\nend;\n\nprocedure TSettings.LoadFromFile(Filename: TfileName);\nvar\n  key, line: string;\n  value: variant;\n  disabled: boolean;\n  Lines: TArray<string>;\nbegin\n  if not FileExists(Filename) then\n    exit;\n\n  Clear;\n  Lines := TFile.ReadAllLines(Filename);\n  for line in Lines do\n  begin\n    if GetKey(line, key, value, disabled) then\n    begin\n      if disabled then\n        AddOrSetValue(key, False)\n      else\n        AddOrSetValue(key, value)\n    end;\n  end;\nend;\n\nprocedure TSettings.SaveToFile(Filename: TfileName);\nvar\n  key, line: string;\n  value: variant;\n  disabled: boolean;\n  Lines: TArray<string>;\n  i: Integer;\n  All_kyes: TList<string>;\nbegin\n  All_kyes := GetAllKeys();\n  SetLength(Lines, 0);\n  i := 0;\n  if FileExists(Filename) then\n  begin\n    Lines := TFile.ReadAllLines(Filename);\n    for i := high(Lines) downto 0 do\n    begin\n      if GetKey(Lines[i], key, value, disabled) then\n      begin\n        if not ContainsKey(key) then\n        begin\n          Lines[i] := '; ' + Lines[i];\n          Continue;\n        end;\n\n        All_kyes.Remove(key);\n\n        disabled := VarIsType(Variable[key].value, varBoolean) and (Variable[key].value\n          = false);\n        if not disabled then\n        begin\n          if VarIsType(Variable[key].value, varBoolean) then\n            Lines[i] := key\n          else\n            Lines[i] := format('%s %s', [key, Variable[key].ToString])\n        end\n        else\n          Lines[i] := '; ' + key;\n      end;\n    end;\n\n  end;\n\n  // new keys\n  i := high(Lines) + 1;\n  SetLength(Lines, Length(Lines) + All_kyes.Count);\n  for key in All_kyes do\n  begin\n    Lines[i] := format('%s %s', [key, Variable[key].ToString]);\n    inc(i);\n  end;\n\n  Tfile.WriteAllLines(Filename, Lines);\n\n  All_kyes.Free;\nend;\n\nprocedure TSettings.SetVariable(key: string; const Value: TVariable);\nbegin\n  AddOrSetValue(key.Trim.ToUpper, Value);\nend;\nend.\n\n\nprogram ReadAConfigFile;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils,\n  uSettings;\n\nconst\n  FileName = 'Config.txt';\n\nvar\n  Settings: TSettings;\n\nprocedure show(key: string; value: string);\nbegin\n  writeln(format('%14s = %s', [key, value]));\nend;\n\nbegin\n  Settings := TSettings.Create;\n  Settings.LoadFromFile(FileName);\n\n  for var k in Settings.Keys do\n    show(k, Settings[k]);\n\n  Settings.Free;\n  Readln;\nend.\n\n\nOutput:\nFAVOURITEFRUIT = banana\n      FULLNAME = Foo Barber\n  NEEDSPEELING = True\n  SEEDSREMOVED = False\n   OTHERFAMILY = Rhu Barber, Harry Barber\n", "explain": "Unit for manager config files, used in Update a configuration file.\nUsage of unit:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Ruby", "code": "\nfullname = favouritefruit = \"\"\nneedspeeling = seedsremoved = false\notherfamily = []\n\nIO.foreach(\"config.file\") do |line|\n  line.chomp!\n  key, value = line.split(nil, 2)\n  case key\n  when /^([#;]|$)/; # ignore line\n  when \"FULLNAME\"; fullname = value\n  when \"FAVOURITEFRUIT\"; favouritefruit = value\n  when \"NEEDSPEELING\"; needspeeling = true\n  when \"SEEDSREMOVED\"; seedsremoved = true\n  when \"OTHERFAMILY\"; otherfamily = value.split(\",\").map(&:strip)\n  when /^./; puts \"#{key}: unknown key\"\n  end\nend\n\nputs \"fullname       = #{fullname}\"\nputs \"favouritefruit = #{favouritefruit}\"\nputs \"needspeeling   = #{needspeeling}\"\nputs \"seedsremoved   = #{seedsremoved}\"\notherfamily.each_with_index do |name, i|\n  puts \"otherfamily(#{i+1}) = #{name}\"\nend\n\n\nOutput:\nfullname       = Foo Barber\nfavouritefruit = banana\nneedspeeling   = true\nseedsremoved   = false\notherfamily(1) = Rhu Barber\notherfamily(2) = Harry Barber\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Rust", "code": "\nuse std::fs::File;\nuse std::io::BufRead;\nuse std::io::BufReader;\nuse std::iter::FromIterator;\nuse std::path::Path;\n\nfn main() {\n    let path = String::from(\"file.conf\");\n    let cfg = config_from_file(path);\n    println!(\"{:?}\", cfg);\n}\n\nfn config_from_file(path: String) -> Config {\n    let path = Path::new(&path);\n    let file = File::open(path).expect(\"File not found or cannot be opened\");\n    let content = BufReader::new(&file);\n    let mut cfg = Config::new();\n\n    for line in content.lines() {\n        let line = line.expect(\"Could not read the line\");\n        // Remove whitespaces at the beginning and end\n        let line = line.trim();\n\n        // Ignore comments and empty lines\n        if line.starts_with(\"#\") || line.starts_with(\";\") || line.is_empty() {\n            continue;\n        }\n\n        // Split line into parameter name and rest tokens\n        let tokens = Vec::from_iter(line.split_whitespace()); \n        let name = tokens.first().unwrap();\n        let tokens = tokens.get(1..).unwrap();\n\n        // Remove the equal signs\n        let tokens = tokens.iter().filter(|t| !t.starts_with(\"=\"));\n        // Remove comment after the parameters\n        let tokens = tokens.take_while(|t| !t.starts_with(\"#\") && !t.starts_with(\";\"));\n        \n        // Concat back the parameters into one string to split for separated parameters\n        let mut parameters = String::new();\n        tokens.for_each(|t| { parameters.push_str(t); parameters.push(' '); });\n        // Splits the parameters and trims\n        let parameters = parameters.split(',').map(|s| s.trim());\n        // Converts them from Vec<&str> into Vec<String>\n        let parameters: Vec<String> = parameters.map(|s| s.to_string()).collect();\n        \n        // Setting the config parameters\n        match name.to_lowercase().as_str() {\n            \"fullname\" => cfg.full_name = parameters.get(0).cloned(),\n            \"favouritefruit\" => cfg.favourite_fruit = parameters.get(0).cloned(),\n            \"needspeeling\" => cfg.needs_peeling = true,\n            \"seedsremoved\" => cfg.seeds_removed = true,\n            \"otherfamily\" => cfg.other_family = Some(parameters),\n            _ => (),\n        }\n    }\n\n    cfg\n}\n\n#[derive(Clone, Debug)]\nstruct Config {\n    full_name: Option<String>,\n    favourite_fruit: Option<String>,\n    needs_peeling: bool,\n    seeds_removed: bool,\n    other_family: Option<Vec<String>>,\n}\n\nimpl Config {\n    fn new() -> Config {\n        Config {\n            full_name: None,\n            favourite_fruit: None,\n            needs_peeling: false,\n            seeds_removed: false,\n            other_family: None,\n        }\n    }\n}\n\n\nOutput:\nConfig { full_name: Some(\"Foo Barber\"), favourite_fruit: Some(\"banana\"), needs_peeling: true, seeds_removed: false, other_family: Some([\"Rhu Barber\", \"Harry Barber\"]) }\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "COBOL", "code": "\n       identification division.\n       program-id. ReadConfiguration.\n\n       environment division.\n       configuration section.\n       repository.\n           function all intrinsic.\n\n       input-output section.\n       file-control.\n           select config-file     assign to \"Configuration.txt\"\n                                  organization line sequential.\n       data division.\n       file section.\n\n       fd  config-file.\n       01  config-record          pic is x(128).\n\n       working-storage section.\n       77  idx                    pic 9(3).\n       77  pos                    pic 9(3).\n       77  last-pos               pic 9(3).\n       77  config-key             pic x(32).\n       77  config-value           pic x(64).\n       77  multi-value            pic x(64).\n       77  full-name              pic x(64).\n       77  favourite-fruit        pic x(64).\n       77  other-family           pic x(64) occurs 10.\n       77  need-speeling          pic x(5) value \"false\".\n       77  seeds-removed          pic x(5) value \"false\".\n\n       procedure division.\n       main.\n           open input config-file\n           perform until exit\n              read config-file\n                 at end\n                    exit perform\n              end-read  \n              move trim(config-record) to config-record\n              if config-record(1:1) = \"#\" or \";\" or spaces\n                 exit perform cycle\n              end-if\n              unstring config-record delimited by spaces into config-key\n              move trim(config-record(length(trim(config-key)) + 1:)) to config-value\n              if config-value(1:1) = \"=\"\n                 move trim(config-value(2:)) to config-value\n              end-if\n              evaluate upper-case(config-key)\n                 when \"FULLNAME\"\n                    move config-value to full-name\n                 when \"FAVOURITEFRUIT\"\n                    move config-value to favourite-fruit\n                 when \"NEEDSPEELING\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if\n                    if config-value = \"true\" or \"false\"\n                       move config-value to need-speeling\n                    end-if\n                 when \"SEEDSREMOVED\"\n                    if config-value = spaces\n                       move \"true\" to config-value\n                    end-if,\n                    if config-value = \"true\" or \"false\"\n                       move config-value to seeds-removed\n                    end-if\n                 when \"OTHERFAMILY\"\n                    move 1 to idx, pos\n                    perform until exit\n                       unstring config-value delimited by \",\" into multi-value with pointer pos\n                          on overflow\n                             move trim(multi-value) to other-family(idx)\n                             move pos to last-pos\n                          not on overflow\n                             if config-value(last-pos:) <> spaces\n                                move trim(config-value(last-pos:)) to other-family(idx)\n                             end-if,\n                             exit perform\n                       end-unstring\n                       add 1 to idx\n                    end-perform\n              end-evaluate\n           end-perform\n           close config-file\n\n           display \"fullname = \" full-name\n           display \"favouritefruit = \" favourite-fruit\n           display \"needspeeling = \" need-speeling\n           display \"seedsremoved = \" seeds-removed\n           perform varying idx from 1 by 1 until idx > 10\n              if other-family(idx) <> low-values\n                 display \"otherfamily(\" idx \") = \" other-family(idx)\n              end-if\n           end-perform\n           .\n\n\nOutput:\nfullname = Foo Barber\nfavouritefruit = banana\nneedspeeling = true\nseedsremoved = false\notherfamily(001) = Rhu Barber\notherfamily(002) = Harry Barber\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Visual_Basic", "code": "\n' Configuration file parser routines.\n'\n' (c) Copyright 1993 - 2011 Mark Hobley\n'\n' This configuration parser contains code ported from an application program\n' written in Microsoft Quickbasic\n'\n' This code can be redistributed or modified under the terms of version 1.2 of\n' the GNU Free Documentation Licence as published by the Free Software Foundation.\n\nSub readini()\n  var.filename = btrim$(var.winpath) & ini.inifile\n  var.filebuffersize = ini.inimaxlinelength\n  Call openfileread\n  If flg.error = \"Y\" Then\n    flg.abort = \"Y\"\n    Exit Sub\n  End If\n  If flg.exists <> \"Y\" Then\n    flg.abort = \"Y\"\n    Exit Sub\n  End If\n  var.inistream = var.stream\nreadinilabela:\n  Call readlinefromfile\n  If flg.error = \"Y\" Then\n    flg.abort = \"Y\"\n    Call closestream\n    flg.error = \"Y\"\n    Exit Sub\n  End If\n  If flg.endoffile <> \"Y\" Then\n    iniline$ = message$\n    If iniline$ <> \"\" Then\n      If Left$(iniline$, 1) <> ini.commentchar AND Left$(iniline$, 1) <> ini.ignorechar Then\n        endofinicommand% = 0\n        For l% = 1 To Len(iniline$)\n          If Mid$(iniline$, l%, 1) < \" \" Then\n            endofinicommand% = l%\n          End If\n          If Not (endofinicommand%) Then\n            If Mid$(iniline$, l%, 1) = \" \" Then\n              endofinicommand% = l%\n            End If\n          End If\n          If endofinicommand% Then\n            l% = Len(iniline$)\n          End If\n        Next l%\n        iniarg$ = \"\"\n        If endofinicommand% Then\n          If endofinicommand% <> Len(iniline$) Then\n            iniarg$ = btrim$(Mid$(iniline$, endofinicommand% + 1))\n            If iniarg$ = \"\" Then\n              GoTo readinilabelb\n            End If\n            inicommand$ = Left$(iniline$, endofinicommand% - 1)\n          End If\n        Else\n          inicommand$ = btrim$(iniline$)\n        End If\nreadinilabelb:\n        'interpret command\n        inicommand$ = UCase$(inicommand$)\n        Select Case inicommand$\n          Case \"FULLNAME\"\n            If iniarg$ <> \"\" Then\n              ini.fullname = iniarg$\n            End If\n          Case \"FAVOURITEFRUIT\"\n            If iniarg$ <> \"\" Then\n              ini.favouritefruit = iniarg$\n            End If\n          Case \"NEEDSPEELING\"\n            ini.needspeeling = \"Y\"\n          Case \"SEEDSREMOVED\"\n            ini.seedsremoved = \"Y\"\n          Case \"OTHERFAMILY\"\n            If iniarg$ <> \"\" Then\n              ini.otherfamily = iniarg$\n              CALL familyparser\n            End If\n          Case Else\n            '!! error handling required\n        End Select\n      End If\n    End If\n    GoTo readinilabela\n  End If\n  Call closestream\n  Exit Sub\nreadinierror:\n\nEnd Sub\n\nSub openfileread()\n  flg.streamopen = \"N\"\n  Call checkfileexists\n  If flg.error = \"Y\" Then Exit Sub\n  If flg.exists <> \"Y\" Then Exit Sub\n  Call getfreestream\n  If flg.error = \"Y\" Then Exit Sub\n  var.errorsection = \"Opening File\"\n  var.errordevice = var.filename\n  If ini.errortrap = \"Y\" Then\n    On Local Error GoTo openfilereaderror\n  End If\n  flg.endoffile = \"N\"\n  Open var.filename For Input As #var.stream Len = var.filebuffersize\n  flg.streamopen = \"Y\"\n  Exit Sub\nopenfilereaderror:\n  var.errorcode = Err\n  Call errorhandler\n  resume '!!\nEnd Sub\n\nPublic Sub checkfileexists()\n  var.errorsection = \"Checking File Exists\"\n  var.errordevice = var.filename\n  If ini.errortrap = \"Y\" Then\n    On Local Error GoTo checkfileexistserror\n  End If\n  flg.exists = \"N\"\n  If Dir$(var.filename, 0) <> \"\" Then\n    flg.exists = \"Y\"\n  End If\n  Exit Sub\ncheckfileexistserror:\n  var.errorcode = Err\n  Call errorhandler\nEnd Sub\n\nPublic Sub getfreestream()\n  var.errorsection = \"Opening Free Data Stream\"\n  var.errordevice = \"\"\n  If ini.errortrap = \"Y\" Then\n    On Local Error GoTo getfreestreamerror\n  End If\n  var.stream = FreeFile\n  Exit Sub\ngetfreestreamerror:\n  var.errorcode = Err\n  Call errorhandler\n  resume '!!\nEnd Sub\n\nSub closestream()\n  If ini.errortrap = \"Y\" Then\n    On Local Error GoTo closestreamerror\n  End If\n  var.errorsection = \"Closing Stream\"\n  var.errordevice = \"\"\n  flg.resumenext = \"Y\"\n  Close #var.stream\n  If flg.error = \"Y\" Then\n    flg.error = \"N\"\n    '!! Call unexpectederror\n  End If\n  flg.streamopen = \"N\"\n  Exit Sub\nclosestreamerror:\n  var.errorcode = Err\n  Call errorhandler\n  resume next\nEnd Sub\n\nSub readlinefromfile()\n  If ini.errortrap = \"Y\" Then\n    On Local Error GoTo readlinefromfileerror\n  End If\n  If EOF(var.stream) Then\n    flg.endoffile = \"Y\"\n    Exit Sub\n  End If\n  Line Input #var.stream, tmp$\n  message$ = tmp$\n  Exit Sub\nreadlinefromfileerror:\n  var.errorcode = Err\n  Call errorhandler\n  resume '!!\nEnd Sub\n\nPublic Sub errorhandler()\n  tmp$ = btrim$(var.errorsection)\n  tmp2$ = btrim$(var.errordevice)\n  If tmp2$ <> \"\" Then\n    tmp$ = tmp$ + \" (\" + tmp2$ + \")\"\n  End If\n  tmp$ = tmp$ + \"\u00a0: \" + Str$(var.errorcode)\n  tmp1% = MsgBox(tmp$, 0, \"Error!\")\n  flg.error = \"Y\"\n  If flg.resumenext = \"Y\" Then\n    flg.resumenext = \"N\"\n'    Resume Next\n  Else\n    flg.error = \"N\"\n'    Resume\n  End If\nEnd Sub\n\nPublic Function btrim$(arg$)\n  btrim$ = LTrim$(RTrim$(arg$))\nEnd Function\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Ada", "code": "\nWorks with: Ada version 2005\n\nwith Config; use Config;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Rosetta_Read_Cfg is\n  cfg: Configuration:= Init(\"rosetta_read.cfg\", Case_Sensitive => False, Variable_Terminator => ' ');\n  fullname       : String  := cfg.Value_Of(\"*\", \"fullname\");\n  favouritefruit : String  := cfg.Value_Of(\"*\", \"favouritefruit\");\n  needspeeling   : Boolean := cfg.Is_Set(\"*\", \"needspeeling\");\n  seedsremoved   : Boolean := cfg.Is_Set(\"*\", \"seedsremoved\");\n  otherfamily    : String  := cfg.Value_Of(\"*\", \"otherfamily\");\nbegin\n  Put_Line(\"fullname = \"       & fullname);\n  Put_Line(\"favouritefruit = \" & favouritefruit);\n  Put_Line(\"needspeeling = \"   & Boolean'Image(needspeeling));\n  Put_Line(\"seedsremoved = \"   & Boolean'Image(seedsremoved));\n  Put_Line(\"otherfamily = \"    & otherfamily);\nend;\n\n\nOutput:\nfullname = Foo Barber\nfavouritefruit = banana\nneedspeeling = TRUE\nseedsremoved = FALSE\notherfamily = Rhu Barber, Harry Barber\n", "explain": "Uses package Config available at SourceForge: \nhttps://sourceforge.net/projects/ini-files/\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction readconf(file)\n    vars = Dict()\n    for line in eachline(file)\n        line = strip(line)\n        if !isempty(line) && !startswith(line, '#') && !startswith(line, ';')\n            fspace  = searchindex(line, \" \")\n            if fspace == 0\n                vars[Symbol(lowercase(line))] = true\n            else\n                vname, line = Symbol(lowercase(line[1:fspace-1])), line[fspace+1:end]\n                value = ',' \u2208 line ? strip.(split(line, ',')) : line\n                vars[vname] = value\n            end\n        end\n    end\n    for (vname, value) in vars\n        eval(:($vname = $value))\n    end\n    return vars\nend\n\nreadconf(\"test.conf\")\n\n@show fullname favouritefruit needspeeling otherfamily\n\n\nOutput:\nfullname = \"Foo Barber\"\nfavouritefruit = \"banana\"\nneedspeeling = true\notherfamily = SubString{String}[\"Rhu Barber\", \"Harry Barber\"]\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Kotlin", "code": "\nWorks with: Kotlin version 1.0.6\n\nimport java.nio.charset.StandardCharsets\nimport java.nio.file.Files\nimport java.nio.file.Paths\n\ndata class Configuration(val map: Map<String, Any?>) {\n    val fullName: String by map\n    val favoriteFruit: String by map\n    val needsPeeling: Boolean by map\n    val otherFamily: List<String> by map\n}\n\nfun main(args: Array<String>) {\n    val lines = Files.readAllLines(Paths.get(\"src/configuration.txt\"), StandardCharsets.UTF_8)\n    val keyValuePairs = lines.map{ it.trim() }\n            .filterNot { it.isEmpty() }\n            .filterNot(::commentedOut)\n            .map(::toKeyValuePair)\n\n    val configurationMap = hashMapOf<String, Any>(\"needsPeeling\" to false)\n    for (pair in keyValuePairs) {\n        val (key, value) = pair\n        when (key) {\n            \"FULLNAME\"       -> configurationMap.put(\"fullName\", value)\n            \"FAVOURITEFRUIT\" -> configurationMap.put(\"favoriteFruit\", value)\n            \"NEEDSPEELING\"   -> configurationMap.put(\"needsPeeling\", true)\n            \"OTHERFAMILY\"    -> configurationMap.put(\"otherFamily\", value.split(\" , \").map { it.trim() })\n            else             -> println(\"Encountered unexpected key $key=$value\")\n        }\n    }\n    println(Configuration(configurationMap))\n}\n\nprivate fun commentedOut(line: String) = line.startsWith(\"#\") || line.startsWith(\";\")\n\nprivate fun toKeyValuePair(line: String) = line.split(Regex(\" \"), 2).let {\n    Pair(it[0], if (it.size == 1) \"\" else it[1])\n}\n\n", "explain": "This example is more verbose than it has to be because of increased effort in providing immutability to the configuration class. \n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Perl", "code": "\n\nmy $fullname;\nmy $favouritefruit;\nmy $needspeeling;\nmy $seedsremoved;\nmy @otherfamily;\n\n# configuration file definition.  See read_conf_file below for explanation.\nmy $conf_definition = {\n    'fullname'          => [ 'string', \\$fullname ],\n    'favouritefruit'    => [ 'string', \\$favouritefruit ],\n    'needspeeling'      => [ 'boolean', \\$needspeeling ],\n    'seedsremoved'      => [ 'boolean', \\$seedsremoved ],\n    'otherfamily'       => [ 'array', \\@otherfamily ],\n};\n\nmy $arg = shift;               # take the configuration file name from the command line\n                               # (or first subroutine argument if this were in a sub)\nmy $file;                      # this is going to be a file handle reference\nopen $file, $arg or die \"Can't open configuration file '$arg': $!\";\n\nread_conf_file($file, $conf_definition); \n\nprint \"fullname = $fullname\\n\";\nprint \"favouritefruit = $favouritefruit\\n\";\nprint \"needspeeling = \", ($needspeeling ? 'true' : 'false'), \"\\n\";\nprint \"seedsremoved = \", ($seedsremoved ? 'true' : 'false'), \"\\n\";\nfor (my $i = 0; $i < @otherfamily; ++$i) {\n    print \"otherfamily(\", $i + 1, \") = \", $otherfamily[$i], \"\\n\";\n}\n\n# read_conf_file:  Given a file handle opened for reading and a configuration definition,\n# read the file.\n# If the configuration file doesn't match the definition, raise an exception with \"die\".\n# The configuration definition is (a reference to) an associative array\n# where the keys are the configuration variable names in all lower case\n# and the values are references to arrays.\n# The first element of each of these arrays is the expected type:  'boolean', 'string', or 'array';\n# the second element is a reference to the variable that should be assigned the data.\nsub read_conf_file {\n    my ($fh, $def) = @_;        # copy parameters\n\n    local $_;                   # avoid interfering with use of $_ in main program\n    while (<$fh>) {             # read a line from $fh into $_ until end of file\n        next if /^#/;           # skip \"#\" comments\n        next if /^;/;           # skip \";\" comments\n        next if /^$/;           # skip blank lines\n        chomp;                  # strip final newline\n\n        $_ =~ /^\\s*(\\w+)\\s*(.*)$/i or die \"Syntax error\";\n        my $key = $1;\n        my $rest = $2;\n        $key =~ tr/[A-Z]/[a-z]/; # convert keyword to lower case\n\n        if (!exists $def->{$key}) {\n            die \"Unknown keyword: '$key'\";\n        }\n\n        if ($def->{$key}[0] eq 'boolean') {\n            if ($rest) {\n                die \"Syntax error:  extra data following boolean '$key'\";\n            }\n            ${$def->{$key}[1]} = 1;\n            next;                # done with this line, go back to \"while\"\n        }\n\n        $rest =~ s/\\s*$//;       # drop trailing whitespace\n        $rest =~ s/^=\\s*//;      # drop equals sign if present\n\n        if ($def->{$key}[0] eq 'string') {\n            ${$def->{$key}[1]} = $rest;\n        } elsif ($def->{$key}[0] eq 'array') {\n            @{$def->{$key}[1]} = split /\\s*,\\s*/, $rest;\n        } else {\n            die \"Internal error (unknown type in configuration definition)\";\n        }\n    }\n}\n\n", "explain": "This is an all-singing, all-dancing version that checks the configuration file syntax and contents and raises exceptions if it fails.  (It is intentionally over-commented for pedagogical purposes.)\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Lua", "code": "\nconf = {}\n\nfp = io.open( \"conf.txt\", \"r\" )\n\nfor line in fp:lines() do\n    line = line:match( \"%s*(.+)\" )\n    if line and line:sub( 1, 1 ) ~= \"#\" and line:sub( 1, 1 ) ~= \";\" then\n \toption = line:match( \"%S+\" ):lower()\n\tvalue  = line:match( \"%S*%s*(.*)\" )\n\n\tif not value then\n \t    conf[option] = true\n\telse\n\t    if not value:find( \",\" ) then\n\t\tconf[option] = value\n\t    else\n\t\tvalue = value .. \",\"\n\t\tconf[option] = {}\n\t\tfor entry in value:gmatch( \"%s*(.-),\" ) do\n\t\t    conf[option][#conf[option]+1] = entry\n\t\tend\n\t    end\n\tend\n\n    end\nend\n\nfp:close()\n\n\nprint( \"fullname = \", conf[\"fullname\"] )\nprint( \"favouritefruit = \", conf[\"favouritefruit\"] )\nif conf[\"needspeeling\"] then print( \"needspeeling = true\" ) else print( \"needspeeling = false\" ) end\nif conf[\"seedsremoved\"] then print( \"seedsremoved = true\" ) else print( \"seedsremoved = false\" ) end\nif conf[\"otherfamily\"] then\n    print \"otherfamily:\"\n    for _, entry in pairs( conf[\"otherfamily\"] ) do\n\tprint( \"\", entry )\n    end\nend\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Scala", "code": "\n\nFilters out empty and comment lines\nSplits field name and value(s)\nAdds \"true\" to value-less fields\nConverts values to (k, List(values)\nConverts the entire collection to a Map\nval conf = scala.io.Source.fromFile(\"config.file\").\n  getLines.\n  toList.\n  filter(_.trim.size > 0).\n  filterNot(\"#;\" contains _(0)).\n  map(_ split(\" \", 2) toList).\n  map(_ :+ \"true\" take 2).\n  map {\n    s:List[String] => (s(0).toLowerCase, s(1).split(\",\").map(_.trim).toList)\n  }.toMap\n\n\nfor ((k,v) <- conf) {\n  if (v.size == 1)\n    println(\"%s: %s\" format (k, v(0)))\n  else\n    for (i <- 0 until v.size)\n      println(\"%s(%s): %s\" format (k, i+1, v(i)))\n\n}\n\n\nOutput:\nfullname: Foo Barber\nfavouritefruit: banana\nneedspeeling: true\notherfamily(1): Rhu Barber\notherfamily(2): Harry Barber\n\n", "explain": "A \"one liner\" version which:\nTest code:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "D", "code": "\nimport std.stdio, std.string, std.conv, std.regex, std.getopt;\n\nenum VarName(alias var) = var.stringof;\n\nvoid setOpt(alias Var)(in string line) {\n    auto m = match(line, regex(`^(?i)` ~ VarName!Var ~ `(?-i)(\\s*=?\\s+(.*))?`));\n\n    if (!m.empty) {\n        static if (is(typeof(Var) == string[]))\n            Var = m.captures.length > 2 ? m.captures[2].split(regex(`\\s*,\\s*`)) : [\"\"];\n        static if (is(typeof(Var) == string))\n            Var = m.captures.length > 2 ? m.captures[2] : \"\";\n        static if (is(typeof(Var) == bool))\n            Var = true;\n        static if (is(typeof(Var) == int))\n            Var = m.captures.length > 2 ? to!int(m.captures[2]) : 0;\n    }\n}\n\nvoid main(in string[] args) {\n    string fullName, favouriteFruit;\n    string[] otherFamily;\n    bool needsPeeling, seedsRemoved; // Default false.\n\n    auto f = \"readcfg.conf\".File;\n\n    foreach (line; f.byLine) {\n        auto opt = line.strip.idup;\n\n        setOpt!fullName(opt);\n        setOpt!favouriteFruit(opt);\n        setOpt!needsPeeling(opt);\n        setOpt!seedsRemoved(opt);\n        setOpt!otherFamily(opt);\n    }\n\n    writefln(\"%s = %s\", VarName!fullName, fullName);\n    writefln(\"%s = %s\", VarName!favouriteFruit, favouriteFruit);\n    writefln(\"%s = %s\", VarName!needsPeeling, needsPeeling);\n    writefln(\"%s = %s\", VarName!seedsRemoved, seedsRemoved);\n    writefln(\"%s = %s\", VarName!otherFamily, otherFamily);\n}\n\n\nOutput:\nfullName = Foo Barber\nfavouriteFruit = banana\nneedsPeeling = true\nseedsRemoved = false\notherFamily = [\"Rhu Barber\", \"Harry Barber\", \"John\"]\nVariant 2[edit]\n\nimport std.stdio, std.string, std.conv, std.regex, std.algorithm;\n\nauto reNameValue = ctRegex!(`^(\\w+)\\s*=?\\s*(\\S.*)?`);// ctRegex creates regexp parser at compile time\n\n// print Config members w/o hardcoding names\nvoid PrintMembers(Config c)\n{\n    foreach(M; __traits(derivedMembers, Config))\n        writeln(M ~ ` = `, __traits(getMember, c, M));\n}\n\nvoid main(in string[] args /* arg[0] is EXE name */) {\n\n    auto cfg = new Config;\n    auto f = args[1].File;// open config given in command line\n    foreach (line; f.byLineCopy.map!(s => s.strip).filter!(s => !s.empty && s[0] != '#' && s[0] != ';')) {// free loop from unnecessary lines\n        auto m = matchFirst(line, reNameValue);\n        if (m.empty) { writeln(`Wrong config line: ` ~ line); continue; }\n\n        switch(m[1].toUpper) {\n        case `FULLNAME`:       cfg.FullName       = m[2]; break;\n        case `FAVOURITEFRUIT`: cfg.FavouriteFruit = m[2]; break;\n        case `NEEDSPEELING`:   cfg.needsPeeling   = (m[2].toUpper != `FALSE`); break;\n        case `SEEDSREMOVED`:   cfg.seedsRemoved   = (m[2].toUpper != `FALSE`); break;\n        case `OTHERFAMILY`:    cfg.otherFamily    = split(m[2], regex(`\\s*,\\s*`)); break;// regex allows to avoid 'strip' step\n        default:\n            writeln(`Unknown config variable: ` ~ m[1]);\n        }\n    }\n    PrintMembers(cfg);\n}\n\nclass Config\n{\n    string FullName;\n    string FavouriteFruit;\n    bool needsPeeling;\n    bool seedsRemoved;\n    string[] otherFamily;\n}\n\n\nOutput:\n\n# This is a configuration file in standard configuration file format\n#\n# Lines beginning with a hash or a semicolon are ignored by the application\n# program. Blank lines are also ignored by the application program.\n\n# This is the fullname parameter\nFULLNAME Foo Barber   \n\n# This is a favourite fruit\nFAVOURITEFRUIT = banana  \n\n# This is a boolean that should be set\nNeeDSPeeLING\n\n# This boolean is commented out\n; SEEDSREMOVED\n\n# Configuration option names are not case sensitive, but configuration parameter\n# data is case sensitive and may be preserved by the application program.\n\n# An optional equals sign can be used to separate configuration parameter data\n# from the option name. This is dropped by the parser. \n\n# A configuration option may take multiple parameters separated by commas.\n# Leading and trailing whitespace around parameter names and parameter data fields\n# are ignored by the application program.\n\nOTHERFAMILY Rhu Barber , Harry Barber,   John\n\n\nFullName = Foo Barber\nFavouriteFruit = banana\nneedsPeeling = true\nseedsRemoved = false\notherFamily = [\"Rhu Barber\", \"Harry Barber\", \"John\"]\n\n", "explain": "Correct version with handling optional '=' sign. Config is assembled into one class.\nOn config:\nOutput is:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Haskell", "code": "\nimport Data.Char\nimport Data.List\nimport Data.List.Split\n\nmain :: IO ()\nmain = readFile \"config\" >>= (print . parseConfig)\n\nparseConfig :: String -> Config\nparseConfig = foldr addConfigValue defaultConfig . clean . lines\n    where clean = filter (not . flip any [\"#\", \";\", \"\", \" \"] . (==) . take 1)\n          \naddConfigValue :: String -> Config -> Config\naddConfigValue raw config = case key of\n    \"fullname\"       -> config {fullName      = values}\n    \"favouritefruit\" -> config {favoriteFruit = values}\n    \"needspeeling\"   -> config {needsPeeling  = True}\n    \"seedsremoved\"   -> config {seedsRemoved  = True}\n    \"otherfamily\"    -> config {otherFamily   = splitOn \",\" values}\n    _                -> config\n    where (k, vs) = span (/= ' ') raw\n          key = map toLower k\n          values = tail vs\n\ndata Config = Config\n    { fullName      :: String\n    , favoriteFruit :: String\n    , needsPeeling  :: Bool\n    , seedsRemoved  :: Bool\n    , otherFamily   :: [String]\n    } deriving (Show)\n\ndefaultConfig :: Config\ndefaultConfig = Config \"\" \"\" False False []\n\n\nimport Data.ConfigFile\nimport Data.Either.Utils\n\ngetSetting cp x = forceEither $ get cp \"Default\" x\n\ncp <- return . forceEither =<< readfile emptyCP \"name_of_configuration_file\"\nlet username = getSetting cp \"username\"\n    password = getSetting cp \"password\"\n\n\n# this is a comment\nusername  = myname\n\n", "explain": "Or, use Data.Configfile:\nThis works with configuration files in standard format, i.e.,\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "VBScript", "code": "\nSet ofso = CreateObject(\"Scripting.FileSystemObject\")\nSet config = ofso.OpenTextFile(ofso.GetParentFolderName(WScript.ScriptFullName)&\"\\config.txt\",1)\n\nconfig_out = \"\"\n\nDo Until config.AtEndOfStream\n\tline = config.ReadLine\n\tIf Left(line,1) <> \"#\" And Len(line) <> 0 Then\n\t\tconfig_out = config_out & parse_var(line) & vbCrLf\n\tEnd If\nLoop\n\nWScript.Echo config_out\n\nFunction parse_var(s)\n\t'boolean false\n\tIf InStr(s,\";\") Then\n\t\tparse_var = Mid(s,InStr(1,s,\";\")+2,Len(s)-InStr(1,s,\";\")+2) & \" = FALSE\"\n\t'boolean true\n\tElseIf UBound(Split(s,\" \")) = 0 Then\n\t\tparse_var = s & \" = TRUE\"\n\t'multiple parameters\n\tElseIf InStr(s,\",\") Then\n\t\tvar = Left(s,InStr(1,s,\" \")-1)\n\t\tparams = Split(Mid(s,InStr(1,s,\" \")+1,Len(s)-InStr(1,s,\" \")+1),\",\")\n\t\tn = 1 : tmp = \"\"\n\t\tFor i = 0 To UBound(params)\n\t\t\tparse_var = parse_var & var & \"(\" & n & \") = \" & LTrim(params(i)) & vbCrLf\n\t\t\tn = n + 1\n\t\tNext\n\t'single var and paramater\n\tElse\n\t\tparse_var = Left(s,InStr(1,s,\" \")-1) & \" = \" & Mid(s,InStr(1,s,\" \")+1,Len(s)-InStr(1,s,\" \")+1)\n\tEnd If\nEnd Function\n\nconfig.Close\nSet ofso = Nothing\n\n\nOutput:\nFULLNAME = Foo Barber\nFAVOURITEFRUIT = banana\nNEEDSPEELING = TRUE\nSEEDSREMOVED = FALSE\nOTHERFAMILY(1) = Rhu Barber\nOTHERFAMILY(2) = Harry Barber\n\n", "explain": ""}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "PowerShell", "code": "\nfunction Read-ConfigurationFile\n{\n    [CmdletBinding()]\n    Param\n    (\n        # Path to the configuration file.  Default is \"C:\\ConfigurationFile.cfg\"\n        [Parameter(Mandatory=$false, Position=0)]\n        [string]\n        $Path = \"C:\\ConfigurationFile.cfg\"\n    )\n\n    [string]$script:fullName = \"\"\n    [string]$script:favouriteFruit = \"\" \n    [bool]$script:needsPeeling = $false \n    [bool]$script:seedsRemoved = $false\n    [string[]]$script:otherFamily = @()\n\n    function Get-Value ([string]$Line)\n    {\n        if ($Line -match \"=\")\n        {\n            [string]$value = $Line.Split(\"=\",2).Trim()[1]\n        }\n        elseif ($Line -match \" \")\n        {\n            [string]$value = $Line.Split(\" \",2).Trim()[1]\n        }\n\n        $value\n    }\n\n    # Process each line in file that is not a comment.\n    Get-Content $Path | Select-String -Pattern \"^[^#;]\" | ForEach-Object {\n\n        [string]$line = $_.Line.Trim()\n\n        if ($line -eq [String]::Empty)\n        {\n            # do nothing for empty lines\n        }\n        elseif ($line.ToUpper().StartsWith(\"FULLNAME\"))\n        {\n            $script:fullName = Get-Value $line\n        }\n        elseif ($line.ToUpper().StartsWith(\"FAVOURITEFRUIT\"))\n        {\n            $script:favouriteFruit = Get-Value $line\n        }\n        elseif ($line.ToUpper().StartsWith(\"NEEDSPEELING\"))\n        {\n            $script:needsPeeling = $true\n        }\n        elseif ($line.ToUpper().StartsWith(\"SEEDSREMOVED\"))\n        {\n            $script:seedsRemoved = $true\n        }\n        elseif ($line.ToUpper().StartsWith(\"OTHERFAMILY\"))\n        {\n            $script:otherFamily = (Get-Value $line).Split(',').Trim()\n        }\n    }\n\n    Write-Verbose -Message (\"{0,-15}= {1}\" -f \"FULLNAME\", $script:fullName)\n    Write-Verbose -Message (\"{0,-15}= {1}\" -f \"FAVOURITEFRUIT\", $script:favouriteFruit)\n    Write-Verbose -Message (\"{0,-15}= {1}\" -f \"NEEDSPEELING\", $script:needsPeeling)\n    Write-Verbose -Message (\"{0,-15}= {1}\" -f \"SEEDSREMOVED\", $script:seedsRemoved)\n    Write-Verbose -Message (\"{0,-15}= {1}\" -f \"OTHERFAMILY\", ($script:otherFamily -join \", \"))\n}\n\n\nRead-ConfigurationFile -Path .\\temp.txt -Verbose\n\n\nOutput:\nVERBOSE: FULLNAME       = Foo Barber\nVERBOSE: FAVOURITEFRUIT = banana\nVERBOSE: NEEDSPEELING   = True\nVERBOSE: SEEDSREMOVED   = False\nVERBOSE: OTHERFAMILY    = Rhu Barber, Harry Barber\n\n\nGet-Variable -Name fullName, favouriteFruit, needsPeeling, seedsRemoved, otherFamily\n\n\nOutput:\nName                           Value\n----                           -----\nfullName                       Foo Barber\nfavouriteFruit                 banana\nneedsPeeling                   True\nseedsRemoved                   False\notherFamily                    {Rhu Barber, Harry Barber}\n\nUsing Switch -Regex[edit]\nFunction Read-ConfigurationFile {\n   [CmdletBinding()]\n   [OutputType([Collections.Specialized.OrderedDictionary])]\n   Param (\n   [Parameter(\n      Mandatory=$true,\n      Position=0\n      )\n   ]\n   [Alias('LiteralPath')]\n   [ValidateScript({\n      Test-Path -LiteralPath $PSItem -PathType 'Leaf'\n      })\n   ]\n   [String]\n   $_LiteralPath\n   )\n\n   Begin {\n      Function Houdini-Value ([String]$_Text) {\n         $__Aux = $_Text.Trim()\n         If ($__Aux.Length -eq 0) {\n            $__Aux = $true\n         } ElseIf ($__Aux.Contains(',')) {\n            $__Aux = $__Aux.Split(',') |\n               ForEach-Object {\n                  If ($PSItem.Trim().Length -ne 0) {\n                     $PSItem.Trim()\n                  }\n               }\n         }\n         Return $__Aux\n      }\n   }\n   \n   Process {\n      $__Configuration = [Ordered]@{}\n      # Config equivalent pattern\n      # Select-String -Pattern '^\\s*[^\\s;#=]+.*\\s*$' -LiteralPath '.\\filename.cfg'\n      Switch -Regex -File $_LiteralPath {\n\n         '^\\s*[;#=]|^\\s*$'  {\n            Write-Verbose -Message \"v$(' '*20)ignored\"\n            Write-Verbose -Message $Matches[0]\n            Continue\n         }\n\n         '^([^=]+)=(.*)$' {\n            Write-Verbose -Message '\u2193\u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 equal pattern'\n            Write-Verbose -Message $Matches[0]\n            $__Name,$__Value = $Matches[1..2]\n            $__Configuration[$__Name.Trim()] = Houdini-Value($__Value)\n            Continue\n         }\n\n         '^\\s*([^\\s;#=]+)(.*)(\\s*)$' {\n            Write-Verbose -Message '\u2193\u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 \u2190 space or tab pattern or only name'\n            Write-Verbose -Message $Matches[0]\n            $__Name,$__Value = $Matches[1..2]\n            $__Configuration[$__Name.Trim()] = Houdini-Value($__Value)\n            Continue\n         }\n\n      }\n      Return $__Configuration\n   }\n}\n\nFunction Show-Value ([Collections.Specialized.OrderedDictionary]$_Dictionary, $_Index, $_SubIndex) {\n   $__Aux = $_Index + ' = '\n   If ($_Dictionary[$_Index] -eq $null) {\n      $__Aux += $false\n   } ElseIf ($_Dictionary[$_Index].Count -gt 1) {\n      If ($_SubIndex -eq $null) {\n         $__Aux += $_Dictionary[$_Index] -join ','\n      } Else {\n         $__Aux = $_Index + '(' + $_SubIndex + ') = '\n         If ($_Dictionary[$_Index][$_SubIndex] -eq $null) {\n            $__Aux += $false\t\t \n         } Else {\n            $__Aux += $_Dictionary[$_Index][$_SubIndex]\n         }\n      }\n   } Else {\n      $__Aux += $_Dictionary[$_Index]\n   }\n   Return $__Aux\n}\n\n\n$Configuration = Read-ConfigurationFile -LiteralPath '.\\config.cfg'\n\n\n$Configuration\n\n\nOutput:\nName                           Value\n----                           -----\nFULLNAME                       Foo Barber\nFAVOURITEFRUIT                 banana\nNEEDSPEELING                   True\nOTHERFAMILY                    {Rhu Barber, Harry Barber}\n\n\nShow-Value $Configuration 'fullname'\nShow-Value $Configuration 'favouritefruit'\nShow-Value $Configuration 'needspeeling'\nShow-Value $Configuration 'seedsremoved'\nShow-Value $Configuration 'otherfamily'\nShow-Value $Configuration 'otherfamily' 0\nShow-Value $Configuration 'otherfamily' 1\nShow-Value $Configuration 'otherfamily' 2\n\n\nOutput:\nfullname = Foo Barber\nfavouritefruit = banana\nneedspeeling = True\nseedsremoved = False\notherfamily = Rhu Barber,Harry Barber\notherfamily(0) = Rhu Barber\notherfamily(1) = Harry Barber\notherfamily(2) = False\n\n\n'$Configuration[''fullname'']'\n$Configuration['fullname']\n'$Configuration.''fullname'''\n$Configuration.'fullname'\n'$Configuration.Item(''fullname'')'\n$Configuration.Item('fullname')\n'$Configuration[0]'\n$Configuration[0]\n'$Configuration.Item(0)'\n$Configuration.Item(0)\n' '\n'=== $Configuration[''otherfamily''] ==='\n$Configuration['otherfamily']\n'=== $Configuration[''otherfamily''][0] ==='\n$Configuration['otherfamily'][0]\n'=== $Configuration[''otherfamily''][1] ==='\n$Configuration['otherfamily'][1]\n' '\n'=== $Configuration.''otherfamily'' ==='\n$Configuration.'otherfamily'\n'=== $Configuration.''otherfamily''[0] ==='\n$Configuration.'otherfamily'[0]\n'=== $Configuration.''otherfamily''[1] ==='\n$Configuration.'otherfamily'[1]\n' '\n'=== $Configuration.Item(''otherfamily'') ==='\n$Configuration.Item('otherfamily')\n'=== $Configuration.Item(''otherfamily'')[0] ==='\n$Configuration.Item('otherfamily')[0]\n'=== $Configuration.Item(''otherfamily'')[1] ==='\n$Configuration.Item('otherfamily')[1]\n' '\n'=== $Configuration[3] ==='\n$Configuration[3]\n'=== $Configuration[3][0] ==='\n$Configuration[3][0]\n'=== $Configuration[3][1] ==='\n$Configuration[3][1]\n' '\n'=== $Configuration.Item(3) ==='\n$Configuration.Item(3)\n'=== $Configuration.Item(3).Item(0) ==='\n$Configuration.Item(3).Item(0)\n'=== $Configuration.Item(3).Item(1) ==='\n$Configuration.Item(3).Item(1)\n\n\nOutput:\n$Configuration['fullname']\nFoo Barber\n$Configuration.'fullname'\nFoo Barber\n$Configuration.Item('fullname')\nFoo Barber\n$Configuration[0]\nFoo Barber\n$Configuration.Item(0)\nFoo Barber\n\n=== $Configuration['otherfamily'] ===\nRhu Barber\nHarry Barber\n=== $Configuration['otherfamily'][0] ===\nRhu Barber\n=== $Configuration['otherfamily'][1] ===\nHarry Barber\n\n=== $Configuration.'otherfamily' ===\nRhu Barber\nHarry Barber\n=== $Configuration.'otherfamily'[0] ===\nRhu Barber\n=== $Configuration.'otherfamily'[1] ===\nHarry Barber\n\n=== $Configuration.Item('otherfamily') ===\nRhu Barber\nHarry Barber\n=== $Configuration.Item('otherfamily')[0] ===\nRhu Barber\n=== $Configuration.Item('otherfamily')[1] ===\nHarry Barber\n\n=== $Configuration[3] ===\nRhu Barber\nHarry Barber\n=== $Configuration[3][0] ===\nRhu Barber\n=== $Configuration[3][1] ===\nHarry Barber\n\n=== $Configuration.Item(3) ===\nRhu Barber\nHarry Barber\n=== $Configuration.Item(3).Item(0) ===\nRhu Barber\n=== $Configuration.Item(3).Item(1) ===\nHarry Barber\n\n", "explain": "I stored the file in \".\\temp.txt\" and there is no output unless the -Verbose switch is used:\nTest if the variables are set:\nSetting variable\nShow variable\nUsing customize function\nUsing index variable\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "Groovy", "code": "\ndef config = [:]\ndef loadConfig = { File file ->\n    String regex = /^(;{0,1})\\s*(\\S+)\\s*(.*)$/\n    file.eachLine { line ->\n        (line =~ regex).each { matcher, invert, key, value ->\n            if (key == '' || key.startsWith(\"#\")) return\n            parts = value ? value.split(/\\s*,\\s*/) : (invert ? [false] : [true])\n            if (parts.size() > 1) {\n                parts.eachWithIndex{ part, int i -> config[\"$key(${i + 1})\"] = part}\n            } else {\n                config[key] = parts[0]\n            }\n        }\n    }\n}\n\n\nloadConfig new File('config.ini')\nconfig.each { println it }\n\n\nOutput:\nFULLNAME=Foo Barber\nFAVOURITEFRUIT=banana\nNEEDSPEELING=true\nSEEDSREMOVED=false\nOTHERFAMILY(1)=Rhu Barber\nOTHERFAMILY(2)=Harry Barber\n", "explain": "Testing:\n"}, {"task_name": "Read a configuration file", "task_url": "https://rosettacode.org/wiki/Read_a_configuration_file", "task_cat": "Initialization", "lang": "AWK", "code": "\n# syntax: GAWK -f READ_A_CONFIGURATION_FILE.AWK\nBEGIN {\n    fullname = favouritefruit = \"\"\n    needspeeling = seedsremoved = \"false\"\n    fn = \"READ_A_CONFIGURATION_FILE.INI\"\n    while (getline rec <fn > 0) {\n      tmp = tolower(rec)\n      if (tmp ~ /^ *fullname/) { fullname = extract(rec) }\n      else if (tmp ~ /^ *favouritefruit/) { favouritefruit = extract(rec) }\n      else if (tmp ~ /^ *needspeeling/) { needspeeling = \"true\" }\n      else if (tmp ~ /^ *seedsremoved/) { seedsremoved = \"true\" }\n      else if (tmp ~ /^ *otherfamily/) { split(extract(rec),otherfamily,\",\") }\n    }\n    close(fn)\n    printf(\"fullname=%s\\n\",fullname)\n    printf(\"favouritefruit=%s\\n\",favouritefruit)\n    printf(\"needspeeling=%s\\n\",needspeeling)\n    printf(\"seedsremoved=%s\\n\",seedsremoved)\n    for (i=1; i<=length(otherfamily); i++) {\n      sub(/^ +/,\"\",otherfamily[i]) # remove leading spaces\n      sub(/ +$/,\"\",otherfamily[i]) # remove trailing spaces\n      printf(\"otherfamily(%d)=%s\\n\",i,otherfamily[i])\n    }\n    exit(0)\n}\nfunction extract(rec,  pos,str) {\n    sub(/^ +/,\"\",rec)       # remove leading spaces before parameter name\n    pos = match(rec,/[= ]/) # determine where data begins\n    str = substr(rec,pos)   # extract the data\n    gsub(/^[= ]+/,\"\",str)   # remove leading \"=\" and spaces\n    sub(/ +$/,\"\",str)       # remove trailing spaces\n    return(str)\n}\n\n\nOutput:\nfullname=Foo Barber\nfavouritefruit=banana\nneedspeeling=true\nseedsremoved=false\notherfamily(1)=Rhu Barber\notherfamily(2)=Harry Barber\n\n", "explain": ""}]