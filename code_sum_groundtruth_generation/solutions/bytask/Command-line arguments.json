[{"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Python", "code": "\n\nimport sys\nprogram_name = sys.argv[0]\narguments = sys.argv[1:]\ncount = len(arguments)\n\n\n", "explain": "sys.argv is a list containing all command line arguments, including the program name. Typically you slice the list to access the actual command line argument:\nWhen running a module by invoking Python, the Python interpreter processes and removes some of the arguments, and the module cannot access them. To process command line arguments, run the module directly. sys.argv is a copy of the command line arguments; modifying sys.argv will not change the arguments seen by other processes, e.g. ps.  (In other words sys.argv is an object which contains a copy of the process' command line arguments ... modifying that copy is only visible from within the Python program and not externally).\nFor powerful option parsing capabilities check out the optparse module.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "C", "code": "\n\n#include <stdlib.h>\n#include <stdio.h>\n\nint main(int argc, char* argv[])\n{\n  int i;\n  (void) printf(\"This program is named %s.\\n\", argv[0]);\n  for (i = 1; i < argc; ++i)\n    (void) printf(\"the argument #%d is %s\\n\", i, argv[i]);\n  return EXIT_SUCCESS;\n}\n\n", "explain": "Command line arguments are passed to main. Since the program name is also passed as \"argument\", the provided count is actually one more than the number of program arguments. Traditionally the argument count is named argc and the array of argument strings is called argv, but that's not mandatory; any (non-reserved) name will work just as well. It is, however, a good idea to stick to the conventional names.\nBe careful on systems that use Unicode or other multibyte character sets. You may need to use a type of _wchar* and multi-byte-character-set-aware versions of printf.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "C++", "code": "\n\n#include <iostream>\n\nint main(int argc, const char* argv[]) {\n    std::cout << \"This program is named \" << argv[0] << '\\n'\n              << \"There are \" << argc - 1 << \" arguments given.\\n\";\n    for (int i = 1; i < argc; ++i)\n        std::cout << \"The argument #\" << i << \" is \" << argv[i] << '\\n';\n}\n\n", "explain": "Command line arguments are passed the same way as in C.\nThis example uses <iostream>. C-style i/o also works.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Java", "code": "\n\npublic static void main(String[] args)\n\n\nmyprogram -c \"alpha beta\" -h \"gamma\"\n\n\n-c\nalpha beta\n-h\ngamma\n\n\npublic class Arguments {\n  public static void main(String[] args) {\n     System.out.println(\"There are \" + args.length + \" arguments given.\");\n     for(int i = 0; i < args.length; i++) \n        System.out.println(\"The argument #\" + (i+1) + \" is \" + args[i] + \" and is at index \" + i);\n  }\n}\n\n\n", "explain": "The arguments will be passed to main as the only parameter.\nThe array is non-null.\nRunning this command\nWill produce the following\n\nAnd alternate demonstration.\nFor more sophisticated command-line option and option-argument parsing use the Apache Commons CLI (command-line interface) library.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "C#", "code": "\n\nusing System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main(string[] args) {\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n\n\nusing System;\n\nnamespace RosettaCode {\n    class Program {\n        static void Main() {\n            string[] args = Environment.GetCommandLineArgs();\n            for (int i = 0; i < args.Length; i++)\n                Console.WriteLine(String.Format(\"Argument {0} is '{1}'\", i, args[i]));\n        }\n    }\n}\n\n", "explain": "There are at least two methods to access the command-line arguments. The first method is to access the string array passed to Main. This method only accesses the arguments and not the path to the executable.\nThe second method is to call the Environment.GetCommandLineArgs function. This method also returns the path to the executable as args[0] followed by the actual command line arguments.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "JavaScript", "code": "\nWorks with: Node.js\nprocess.argv.forEach((val, index) => {\n  console.log(`${index}: ${val}`);\n});\n\nWorks with: JScript\nvar objArgs = WScript.Arguments;\nfor (var i = 0; i < objArgs.length; i++)\n   WScript.Echo(objArgs.Item(i));\n\nWorks with: JScript.NET (compiled with jsc.exe)\nimport System;\nvar argv:String[] = Environment.GetCommandLineArgs();\nfor (var i in argv)\n  print(argv[i]);\n\nWorks with: Rhino\nWorks with: SpiderMonkey\nfor (var i = 0; i < arguments.length; i++)\n    print(arguments[i]);\n\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Visual_Basic_.NET", "code": "\n\nSub Main(ByVal args As String())\n    For Each token In args\n        Console.WriteLine(token)\n    Next\nEnd Sub\n", "explain": "This syntax will tokenize the command line arguments. Tokens are normally delimited by spaces, but spaces can be part of a token if surrounded by quotes.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "PHP", "code": "\n\n<?php\n$program_name = $argv[0];\n$second_arg = $argv[2];\n$all_args_without_program_name = array_shift($argv);\n\n", "explain": "When PHP is run from the command line, the special variables $argv and $argc contain the array of arguments, and the number of arguments, respectively. The program name is passed as the first argument.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Fortran", "code": "\nWorks with: Fortran version 2003 and later\nprogram command_line_arguments\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer :: i , nargs\n  character (len_max) :: arg\n  \n  nargs = command_argument_count()\n  !nargs = iargc()\n  do i = 0, nargs\n    call get_command_argument (i, arg)\n    !call getarg (i, arg)\n    write (*, '(a)') trim (arg)\n  end do\n\nend program command_line_arguments\n\n\n> ./a.out -c \"alpha beta\" -h \"gamma\"\n./a.out\n-c\nalpha beta\n-h\ngamma\n\n", "explain": "Note: This sample uses the Fortran 2003 intrinsic routines command_argument_count and get_command_argument instead of the nonstandard extensions iargc and getarg. Most Fortran compilers support both.\nSample usage:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Go", "code": "\npackage main\nimport (\n\t\"fmt\"\n\t\"os\"\n)\n\nfunc main() {\n\tfor i, x := range os.Args[1:] {\n\t\tfmt.Printf(\"the argument #%d is %s\\n\", i, x)\n\t}\n}\n\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program commandLine.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                         @ Linux output console\n.equ EXIT,   1                         @ Linux syscall\n.equ WRITE,  4                         @ Linux syscall\n/* Initialized data */\n.data\nszCarriageReturn:  .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \n.align 4\n\n/*  code section */\n.text\n.global main \nmain:                                   @ entry of program\n    push {fp,lr}                        @ saves registers\n    add fp,sp,#8                        @  fp <- start address\n    ldr r4,[fp]                         @ number of Command line arguments\n    add r5,fp,#4                        @ first parameter address \n    mov r2,#0                           @ init loop counter\nloop:\n    ldr r0,[r5,r2,lsl #2]               @ string address parameter\n    bl affichageMess                    @ display string\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                    @ display carriage return\n    add r2,#1                           @ increment counter\n    cmp r2,r4                           @ number parameters\u00a0?\n    blt loop                            @ loop\n\n100:                                    @ standard end of the program\n    mov r0, #0                          @ return code\n    pop {fp,lr}                         @restaur  registers\n    mov r7, #EXIT                       @ request to exit program\n    swi 0                               @ perform the system call\n\niAdrszCarriageReturn:    .int szCarriageReturn\n\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur 2 registres\n    bx lr                                          @ return\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Delphi", "code": "\n// The program name and the directory it was called from are in\n// param[0] , so given the axample of myprogram -c \"alpha beta\" -h \"gamma\"\n\n  for x := 0 to paramcount do\n      writeln('param[',x,'] = ',param[x]);\n\n// will yield ( assuming windows and the c drive as the only drive)\u00a0:\n\n//  param[0] = c:\\myprogram\n//  param[1] = -c\n//  param[2] = alpha beta\n//  param[3] = -h\n//  param[4] = gamma\n\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Ruby", "code": "\n\n#! /usr/bin/env ruby\np ARGV\n myprog a -h b c\n => [\"a\",\"-h\",\"b\",\"c\"]\n\n", "explain": "Command line arguments are available in the constant Object::ARGV.\nmyprog:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Rust", "code": "\nuse std::env;\n\nfn main(){\n    let args: Vec<_> = env::args().collect();\n    println!(\"{:?}\", args);\n}\n\n./program -c \"alpha beta\" -h \"gamma\"\n[\"./program\", \"-c\", \"alpha beta\", \"-h\", \"gamma\"]\n", "explain": "Run:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Swift", "code": "\nlet args = Process.arguments\nprintln(\"This program is named \\(args[0]).\")\nprintln(\"There are \\(args.count-1) arguments.\")\nfor i in 1..<args.count {\n  println(\"the argument #\\(i) is \\(args[i])\")\n}\n\nWorks with: Swift version 1.2+\nprintln(\"This program is named \\(String.fromCString(Process.unsafeArgv[0])!).\")\nprintln(\"There are \\(Process.argc-1) arguments.\")\nfor i in 1 ..< Int(Process.argc) {\n  println(\"the argument #\\(i) is \\(String.fromCString(Process.unsafeArgv[i])!)\")\n}\nWorks with: Swift version 1.0-1.1\nprintln(\"This program is named \\(String.fromCString(C_ARGV[0])!).\")\nprintln(\"There are \\(C_ARGC-1) arguments.\")\nfor i in 1 ..< Int(C_ARGC) {\n  println(\"the argument #\\(i) is \\(String.fromCString(C_ARGV[i])!)\")\n}\n", "explain": "Alternately:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "R", "code": "\n\nR CMD BATCH --vanilla --slave '--args a=1 b=c(2,5,6)' test.r test.out\n\n\n# Read the commandline arguments\nargs <- (commandArgs(TRUE))\n\n# args is now a list of character vectors\n# First check to see if any arguments were passed,\n# then evaluate each argument.\nif (length(args)==0) {\n    print(\"No arguments supplied.\")\n    # Supply default values\n    a <- 1\n    b <- c(1,1,1)\n} else {\n    for (i in 1:length(args)) {\n         eval(parse(text=args[[i]]))\n    }\n}\nprint(a*2)\nprint(b*3)\n\n\n[1] 2\n[1]  6 15 18\n> proc.time()\n   user  system elapsed \n  0.168   0.026   0.178 \n\n\nsent to stdout (i.e., as is normal with shell scripts)\ndone without the profiling\n\n", "explain": "Following adapted from this post by Forester:\nSuppose you want to call your script test.r with the arguments a=1 b=c(2,5,6), where b is a numeric vector. Suppose you also want to redirect your output to test.out (not that you have a choice--I still don't know how to make R send shell-script output to stdout). You would then run\nfrom the commandline, with the following text in test.r:\n(possibly preceding code that actually does something\u00a0:-) Your output test.out would then contain (e.g., if you cat it)\nIf you know how to get the output\nplease update this example!\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "COBOL", "code": "\n\nWorks with: OpenCOBOL\nWorks with: Visual COBOL\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-all-args.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  args                   PIC X(50).\n       \n       PROCEDURE DIVISION.\n       main-line.\n           ACCEPT args FROM COMMAND-LINE\n           DISPLAY args\n           \n           GOBACK\n           .\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. accept-args-one-at-a-time.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  arg                 PIC X(50) VALUE SPACES.\n       \n       PROCEDURE DIVISION.\n           ACCEPT arg FROM ARGUMENT-VALUE\n           PERFORM UNTIL arg = SPACES\n               DISPLAY arg\n               MOVE SPACES TO arg\n               ACCEPT arg FROM ARGUMENT-VALUE\n           END-PERFORM\n           \n           GOBACK\n           .\n\n\nWorks with: OpenCOBOL\nWorks with: gnuCOBOL\n       *>Created By Zwiegnet 8/19/2004\n\n        IDENTIFICATION DIVISION.\n        PROGRAM-ID. arguments.\n\n        ENVIRONMENT DIVISION.\n\n        DATA DIVISION.\n\n\n        WORKING-STORAGE SECTION.\n\n        01 command1 PIC X(50).\n        01 command2 PIC X(50).\n        01 command3 PIC X(50).\n\n\n        PROCEDURE DIVISION.\n       \n        PERFORM GET-ARGS.\n\n        *> Display Usage for Failed Checks\n        ARGUSAGE.\n        display \"Usage: <command1> <command2> <command3>\"\n        STOP RUN.\n\n        *> Evaluate Arguments\n        GET-ARGS.\n        ACCEPT command1 FROM ARGUMENT-VALUE\n        IF command1 = SPACE OR LOW-VALUES THEN\n        PERFORM ARGUSAGE\n        ELSE\n        INSPECT command1 REPLACING ALL SPACES BY LOW-VALUES\n\n\n        ACCEPT command2 from ARGUMENT-VALUE\n        IF command2 = SPACE OR LOW-VALUES THEN\n        PERFORM ARGUSAGE\n        ELSE\n        INSPECT command2 REPLACING ALL SPACES BY LOW-VALUES\n\n\n        ACCEPT command3 from ARGUMENT-VALUE\n        IF command3 = SPACE OR LOW-VALUES THEN\n        PERFORM ARGUSAGE\n        ELSE\n                INSPECT command3 REPLACING ALL SPACES BY LOW-VALUES\n        \n\n\n        *> Display Final Output\n        display command1 \" \" command2 \" \" command3\n\n\n        STOP RUN.\n\n.\n\n", "explain": "The COBOL standard appears to say nothing regarding the retrieval of command-line arguments, although methods of retrieving them are provided by most vendors.\nGetting the arguments in one go, exactly as they were passed in:\nGetting the arguments one at a time, with arguments being split by whitespace if not in quotes:\nPassing arguments from UNIX/Linux Systems to COBOL.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Visual_Basic", "code": "\n\nSub Main\n    MsgBox Command$\nEnd Sub\n", "explain": "Like Qbasic, Visual Basic returns all of the args in the built-in variable Command$:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Ada", "code": "\n\nwith Ada.Command_line; use Ada.Command_Line;\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Print_Commands is\nbegin\n   -- The number of command line arguments is retrieved from the function Argument_Count\n   -- The actual arguments are retrieved from the function Argument\n   -- The program name is retrieved from the function Command_Name\n   Put(Command_Name & \" \");\n   for Arg in 1..Argument_Count loop\n      Put(Argument(Arg) & \" \");\n   end loop;\n   New_Line;\nend Print_Commands;\n\nAlternative version using Matreshka[edit]\n\nwith Ada.Wide_Wide_Text_IO;\n\nwith League.Application;\nwith League.Strings;\n\nprocedure Main is\nbegin\n   for J in 1 .. League.Application.Arguments.Length loop\n      Ada.Wide_Wide_Text_IO.Put_Line\n       (League.Application.Arguments.Element (J).To_Wide_Wide_String);\n   end loop;\nend Main;\n\n", "explain": "In Ada95 and later versions, command line arguments are available through the predefined package Ada.Command_Line. In Ada83, this would be implementation dependent.\nUses Matreshka\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Julia", "code": "\n\nusing Printf\n\nprog = Base.basename(Base.source_path())\n\nprintln(prog, \"'s command-line arguments are:\")\nfor s in ARGS\n    println(\"    \", s)\nend\n\n\nOutput:\n$ julia command_line_arguments.jl -c \"alpha beta\" -h \"gamma\"\ncommand_line_arguments.jl's command-line arguments are:\n    -c\n    alpha beta\n    -h\n    gamma\n\n", "explain": "Works when the Julia program is run as a file argument to julia.exe.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Kotlin", "code": "\nTranslation of: Java\nfun main(args: Array<String>) {\n     println(\"There are \" + args.size + \" arguments given.\")\n     args.forEachIndexed { i, a -> println(\"The argument #${i+1} is $a and is at index $i\") }\n}\n\n\nOutput:\n\n", "explain": "See Java output.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Perl", "code": "\nWorks with: Perl version 5.x\n\nmy @params = @ARGV;\nmy $params_size = @ARGV; \nmy $second = $ARGV[1];\nmy $fifth = $ARGV[4];\n\n\nuse Getopt::Long;\nGetOptions ( \n    'help|h'     => \\my $help,\n    'verbose|v'  => \\my $verbose,\n);\n\n", "explain": "@ARGV is the array containing all command line parameters\nIf you don't mind importing a module:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Objective-C", "code": "\n\nNSArray *args = [[NSProcessInfo processInfo] arguments];\nNSLog(@\"This program is named\u00a0%@.\", [args objectAtIndex:0]);\nNSLog(@\"There are %d arguments.\", [args count] - 1);\nfor (i = 1; i < [args count]; ++i){\n    NSLog(@\"the argument #%d is\u00a0%@\", i, [args objectAtIndex:i]);\n}\n\n", "explain": "In addition to the regular C mechanism of arguments to main(), Objective-C also has another way to get the arguments as string objects inside an array object:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Prolog", "code": "\n\n:-\n    current_prolog_flag(os_argv, Args),\n    write(Args).\n\n\n:-\n    current_prolog_flag(argv, Args),\n    write(Args).\n\n\n", "explain": "The command line arguments supplied to a Prolog interpreter can be accessed by passing os_argv to current_prolog_flag/2.\nAlternatively, argv can be used to access only the arguments *not* consumed by the Prolog interpreter.\nThis omits the interpreter name, the input Prolog filename, and any other arguments directed at the Prolog interpreter.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Lua", "code": "\n\nprint( \"Program name:\", arg[0] )\n\nprint \"Arguments:\"\nfor i = 1, #arg do\n    print( i,\" \", arg[i] )\nend\n\n", "explain": "The lua scripting language does not use argc and argv conventions for the command line parameters. Instead, the command line parameters to the main script are provided through the global table arg. The script name is placed into element zero of arg, and the script parameters go into the subsequent elements:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Scala", "code": "\nLibrary: Scala\n\nobject CommandLineArguments extends App { \n    println(s\"Received the following arguments: + ${args.mkString(\"\", \", \", \".\")}\")\n}\n\nprintln(s\"Received the following arguments: + ${argv.mkString(\"\", \", \", \".\")}\")\n", "explain": "Calling Scala from command line means invoking a method called main, defined on an\nobject, whose type is (Array[String]):Unit, meaning it receives an\narray of strings, and returns unit. That array contains the command line arguments.\nWhen running a Scala script, where the whole body is executed, the arguments get stored in an array of strings called argv:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Dart", "code": "\nmain(List<String> args) {\n    for(var arg in args)\n        print(arg);\n}\n\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "D", "code": "\nvoid main(in string[] args) {\n    import std.stdio;\n\n    foreach (immutable i, arg; args[1 .. $])\n        writefln(\"#%2d\u00a0: %s\", i + 1, arg);\n}\n\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Haskell", "code": "\n\nimport System\nmain = getArgs >>= print\n\nmyprog a -h b c\n=> [\"a\",\"-h\",\"b\",\"c\"]\n\n", "explain": "Defined by the System module, getArgs\u00a0:: IO [String] provides the command-line arguments in a list.\nmyprog.hs:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Scheme", "code": "\n (define (main args)\n  (for-each (lambda (arg) (display arg) (newline)) args))\n", "explain": ""}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "PowerShell", "code": "\n\n$i = 0\nforeach ($s in $args) {\n    Write-Host Argument (++$i) is $s\n}\n\n", "explain": "In PowerShell the arguments to a script can be accessed with the $args array:\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Logo", "code": "\nWorks with: UCB Logo version 5.6\n\nlogo file.logo - arg1 arg2 arg3\n\n\nshow :COMMAND.LINE\n[arg1 arg2 arg3]\n\n#! /usr/bin/logo -\n\n\nfile.logo arg1 arg2 arg3\n\n", "explain": "If the command line to a logo script is written\nThen the arguments after the \"-\" are found in a list in variable :COMMAND.LINE\nAlternatively, make the first line of an executable logo script:\nto be able to invoke the script with arguments.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "F#", "code": "\n\n#light\n[<EntryPoint>]\nlet main args =\n    Array.iter (fun x -> printfn \"%s\" x) args\n    0\n\n", "explain": "The entry-point function accepts the comment line arguments as an array of strings. The following program will print each argument on a separate line.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "Groovy", "code": "\n\nprintln args\n\n\n$ groovy Echo this is an argument list\n[this, is, an, argument, list]\n$ groovy Echo -x alkfrew4oij -cdkjei +22\n[-x, alkfrew4oij, -cdkjei, +22]\n$\n\n", "explain": "Command-line arguments are accessible via the args list variable. The following is saved as the file \"Echo.groovy\":\nThe existence of command-line arguments presupposes the existence of a command line interpreter. The following test runs were entered in a cygwin bash shell in a Microsoft Windows XP system:\nFor more sophisticated command-line option and option-argument parsing use the CliBuilder (command-line interface builder) library, which extends the functionality of the Java-based Apache Commons CLI library to Groovy.\n"}, {"task_name": "Command-line arguments", "task_url": "https://rosettacode.org/wiki/Command-line_arguments", "task_cat": "Initialization", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\n\nBEGIN {\n  print \"There are \" ARGC \"command line parameters\"\n  for(l=1; l<ARGC; l++) {\n    print \"Argument \" l \" is \" ARGV[l]\n  }\n}\n\n", "explain": ""}]