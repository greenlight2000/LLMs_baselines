[{"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Python", "code": "\nWorks with: Python version 2.3 through 3.4\nnext = str(int('123') + 1)\n\n# Dropping or keeping any non-numerics in the string\n\n\n# succString\u00a0:: Bool -> String -> String\ndef succString(blnPruned):\n    def go(x):\n        try:\n            return [str(1 + (float(x) if '.' in x else int(x)))]\n        except ValueError:\n            return [] if blnPruned else [x]\n    return lambda s: ' '.join(concatMap(go)(s.split()))\n\n\n# TEST ----------------------------------------------------\ndef main():\n    print(\n        '\\n'.join(\n            [succString(bln)(\n                '41.0 pine martens in 1491 -1.5 mushrooms \u2260 136'\n            ) for bln in [False, True]]\n        )\n    )\n\n\n# GENERIC ---------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    return lambda xs: (\n        [ys[0] for ys in [f(x) for x in xs] if ys]\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\nOutput:\n42.0 pine martens in 1492 -0.5 mushrooms \u2260 137\n42.0 1492 -0.5 137\n", "explain": "Or, preserving the distinction between integer and floating point numeric values, while also allowing for noisy or multi-number numerical strings, and providing the option of retaining or pruning out any non-numeric parts of the string.\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "C", "code": "\nHandling strings of arbitrary sizes:#include <stdio.h>\n#include <string.h>\n#include <stdlib.h>\n\n/*  Constraints: input is in the form of (\\+|-)?[0-9]+\n *  and without leading zero (0 itself can be as \"0\" or \"+0\", but not \"-0\");\n *  input pointer is realloc'able and may change;\n *  if input has leading + sign, return may or may not keep it.\n *  The constranits conform to sprintf(\"%+d\") and this function's own output.\n */\nchar * incr(char *s)\n{\n\tint i, begin, tail, len;\n\tint neg = (*s == '-');\n\tchar tgt = neg ? '0' : '9';\n\n\t/* special case: \"-1\" */\n\tif (!strcmp(s, \"-1\")) {\n\t\ts[0] = '0', s[1] = '\\0';\n\t\treturn s;\n\t}\n\n\tlen = strlen(s);\n\tbegin = (*s == '-' || *s == '+') ? 1 : 0;\n\n\t/* find out how many digits need to be changed */\n\tfor (tail = len - 1; tail >= begin && s[tail] == tgt; tail--);\n\n\tif (tail < begin && !neg) {\n\t\t/* special case: all 9s, string will grow */\n\t\tif (!begin) s = realloc(s, len + 2);\n\t\ts[0] = '1';\n\t\tfor (i = 1; i <= len - begin; i++) s[i] = '0';\n\t\ts[len + 1] = '\\0';\n\t} else if (tail == begin && neg && s[1] == '1') {\n\t\t/* special case: -1000..., so string will shrink */\n\t\tfor (i = 1; i < len - begin; i++) s[i] = '9';\n\t\ts[len - 1] = '\\0';\n\t} else { /* normal case; change tail to all 0 or 9, change prev digit by 1*/\n\t\tfor (i = len - 1; i > tail; i--)\n\t\t\ts[i] = neg ? '9' : '0';\n\t\ts[tail] += neg ? -1 : 1;\n\t}\n\n\treturn s;\n}\n\nvoid string_test(const char *s)\n{\n\tchar *ret = malloc(strlen(s));\n\tstrcpy(ret, s);\n\n\tprintf(\"text: %s\\n\", ret);\n\tprintf(\"  ->: %s\\n\", ret = incr(ret));\n\tfree(ret);\n}\n\nint main()\n{\n\tstring_test(\"+0\");\n\tstring_test(\"-1\");\n\tstring_test(\"-41\");\n\tstring_test(\"+41\");\n\tstring_test(\"999\");\n\tstring_test(\"+999\");\n\tstring_test(\"109999999999999999999999999999999999999999\");\n\tstring_test(\"-100000000000000000000000000000000000000000000\");\n\n\treturn 0;\n}\n\n\nOutput:\n\ntext: +0\n\n ->: +1\n\ntext: -1\n\n ->: 0\n\ntext: -41\n\n ->: -40\n\ntext: +41\n\n ->: +42\n\ntext: 999\n\n ->: 1000\n\ntext: +999\n\n ->: 1000\n\ntext: 109999999999999999999999999999999999999999\n\n ->: 110000000000000000000000000000000000000000\n\ntext: -100000000000000000000000000000000000000000000\n\n  ->: -99999999999999999999999999999999999999999999\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "C++", "code": "\n// standard C++ string stream operators\n#include <cstdlib>\n#include <string>\n#include <sstream>\n\n// inside a function or method...\nstd::string s = \"12345\";\n\nint i;\nstd::istringstream(s) >> i;\ni++;\n//or:\n//int i = std::atoi(s.c_str()) + 1;\n\nstd::ostringstream oss;\nif (oss << i) s = oss.str();\n\nWorks with: C++11\n#include <string>\n\nstd::string s = \"12345\";\ns = std::to_string(1+std::stoi(s));\n\nLibrary: Boost\n// Boost\n#include <cstdlib>\n#include <string>\n#include <boost/lexical_cast.hpp>\n\n// inside a function or method...\nstd::string s = \"12345\";\nint i = boost::lexical_cast<int>(s) + 1;\ns = boost::lexical_cast<std::string>(i);\n\nLibrary: Qt\nUses: Qt (Components:{{#foreach: component$n$|{{{component$n$}}}Property \"Uses Library\" (as page type) with input value \"Library/Qt/{{{component$n$}}}\" contains invalid characters or is incomplete and therefore can cause unexpected results during a query or annotation process., }})\n// Qt\nQString num1 = \"12345\";\nQString num2 = QString(\"%1\").arg(v1.toInt()+1);\n\nLibrary: MFC\nUses: Microsoft Foundation Classes (Components:{{#foreach: component$n$|{{{component$n$}}}Property \"Uses Library\" (as page type) with input value \"Library/Microsoft Foundation Classes/{{{component$n$}}}\" contains invalid characters or is incomplete and therefore can cause unexpected results during a query or annotation process., }})\nUses: C Runtime (Components:{{#foreach: component$n$|{{{component$n$}}}Property \"Uses Library\" (as page type) with input value \"Library/C Runtime/{{{component$n$}}}\" contains invalid characters or is incomplete and therefore can cause unexpected results during a query or annotation process., }})\n// MFC\nCString s = \"12345\";\nint i = _ttoi(s) + 1;\nint i = _tcstoul(s, NULL, 10) + 1; \ns.Format(\"%d\", i);\n\n\nWorks with: g++ version 4.0.2\n#include <string>\n#include <iostream>\n#include <ostream>\n\nvoid increment_numerical_string(std::string& s)\n{\n    std::string::reverse_iterator iter = s.rbegin(), end = s.rend();\n    int carry = 1;\n    while (carry && iter != end)\n    {\n        int value = (*iter - '0') + carry;\n        carry = (value / 10);\n        *iter = '0' + (value % 10);\n        ++iter;\n    }\n    if (carry)\n        s.insert(0, \"1\");\n}\n\nint main()\n{\n    std::string big_number = \"123456789012345678901234567899\";\n    std::cout << \"before increment: \" << big_number << \"\\n\";\n    increment_numerical_string(big_number);\n    std::cout << \"after increment:  \" << big_number << \"\\n\";\n}\n\n", "explain": "All of the above solutions only work for numbers <= INT_MAX. The following works for an (almost) arbitrary large number:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Java", "code": "\n\nString s = \"12345\";\ns = String.valueOf(Integer.parseInt(s) + 1);\n\n\nString s = \"123456789012345678901234567890.12345\";\ns = new BigDecimal(s).add(BigDecimal.ONE).toString();\n\n", "explain": "When using Integer.parseInt in other places, it may be beneficial to call trim on the String, since parseInt will throw an Exception if there are spaces in the String.\nAnother solution that works with big decimal numbers:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "C#", "code": "\nstring s = \"12345\";\ns = (int.Parse(s) + 1).ToString();\n// The above functions properly for strings >= Int32.MinValue and\n//  < Int32.MaxValue. ( -2147483648 to 2147483646 )\n\n// The following will work for any arbitrary-length integer string.\n//  (Assuming that the string fits in memory, leaving enough space\n//  for the temporary BigInteger created, plus the resulting string):\nusing System.Numerics;\nstring bis = \"123456789012345678999999999\";\nbis = (BigInteger.Parse(bis) + 1).ToString();\n// Note that extremely long strings will take a long time to parse\n//  and convert from a BigInteger back into a string.\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "JavaScript", "code": "\nES6[edit]\n\nlet s = '9999';\nlet splusplus = (+s+1)+\"\"\n\nconsole.log([splusplus, typeof splusplus]) // 10000,string\n\n\nTranslation of: Python\nTranslation of: Haskell\n(() => {\n    'use strict';\n\n    // succString\u00a0:: Bool -> String -> String\n    const succString = blnPruned => s => {\n        const go = w => {\n            const\n                v = w.includes('.') ? (\n                    parseFloat(w)\n                ) : parseInt(w);\n            return isNaN(v) ? (\n                blnPruned ? [] : [w]\n            ) : [(1 + v).toString()];\n        };\n        return unwords(concatMap(go, words(s)));\n    };\n\n    // TEST -----------------------------------------------\n    const main = () =>\n        console.log(\n            unlines(\n                ap(\n                    map(succString, [true, false]),\n                    ['41 pine martens in 1491.3 -1.5 mushrooms \u2260 136']\n                )\n            )\n        );\n\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // Each member of a list of functions applied to each\n    // of a list of arguments, deriving a list of new values.\n\n    // ap (<*>)\u00a0:: [(a -> b)] -> [a] -> [b]\n    const ap = (fs, xs) => //\n        fs.reduce((a, f) => a.concat(\n            xs.reduce((a, x) => a.concat([f(x)]), [])\n        ), []);\n\n    // concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\n    const concatMap = (f, xs) =>\n        xs.reduce((a, x) => a.concat(f(x)), []);\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = (f, xs) => xs.map(f);\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n    // unwords\u00a0:: [String] -> String\n    const unwords = xs => xs.join(' ');\n\n    // words\u00a0:: String -> [String]\n    const words = s => s.split(/\\s+/);\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n42 1492.3 -0.5 137\n42 pine martens in 1492.3 -0.5 mushrooms \u2260 137\n", "explain": "Using implicit coercion:\nOr, expanding the range of a stringSucc function to allow for non-numeric noise, and also for multiple numeric expressions in a single string:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Visual_Basic_.NET", "code": "\n    Dim s As String = \"123\"\n\n    s = CStr(CInt(\"123\") + 1)\n    ' or\n    s = (CInt(\"123\") + 1).ToString\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "PHP", "code": "\n$s = \"12345\";\n$s++;\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "MATLAB", "code": "\nfunction numStr = incrementNumStr(numStr)\n    numStr = num2str(str2double(numStr) + 1);\nend\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nCHARACTER(10) :: intstr = \"12345\", realstr = \"1234.5\"\nINTEGER :: i\nREAL :: r\n \nREAD(intstr, \"(I10)\") i        ! Read numeric string into integer i\ni = i + 1                      ! increment i\nWRITE(intstr, \"(I10)\") i       ! Write i back to string\n\nREAD(realstr, \"(F10.1)\") r \t\nr = r + 1.0\t\t\t\t\nWRITE(realstr, \"(F10.1)\") r\n\n", "explain": "Using 'internal' files you can increment both integer and real strings\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Go", "code": "\n\npackage main\nimport \"fmt\"\nimport \"strconv\"\nfunc main() {\n  i, _ := strconv.Atoi(\"1234\")\n  fmt.Println(strconv.Itoa(i + 1))\n}\n\n\npackage main\n\nimport (\n    \"math/big\"\n    \"fmt\"\n    \"strconv\"\n)\n\nfunc main() {\n    // integer\n    is := \"1234\"\n    fmt.Println(\"original:   \", is)\n    i, err := strconv.Atoi(is)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // assignment back to original variable shows result is the same type.\n    is = strconv.Itoa(i + 1)\n    fmt.Println(\"incremented:\", is)\n\n    // error checking worthwhile\n    fmt.Println()\n    _, err = strconv.Atoi(\" 1234\") // whitespace not allowed\n    fmt.Println(err)\n    _, err = strconv.Atoi(\"12345678901\")\n    fmt.Println(err)\n    _, err = strconv.Atoi(\"_1234\")\n    fmt.Println(err)\n    _, err = strconv.ParseFloat(\"12.D34\", 64)\n    fmt.Println(err)\n\n    // float\n    fmt.Println()\n    fs := \"12.34\"\n    fmt.Println(\"original:   \", fs)\n    f, err := strconv.ParseFloat(fs, 64)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    // various options on FormatFloat produce different formats.  All are valid\n    // input to ParseFloat, so result format does not have to match original\n    // format.  (Matching original format would take more code.)\n    fs = strconv.FormatFloat(f+1, 'g', -1, 64)\n    fmt.Println(\"incremented:\", fs)\n    fs = strconv.FormatFloat(f+1, 'e', 4, 64)\n    fmt.Println(\"what format?\", fs)\n\n    // complex\n    // strconv package doesn't handle complex types, but fmt does.\n    // (fmt can be used on ints and floats too, but strconv is more efficient.)\n    fmt.Println()\n    cs := \"(12+34i)\"\n    fmt.Println(\"original:   \", cs)\n    var c complex128\n    _, err = fmt.Sscan(cs, &c)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    cs = fmt.Sprint(c + 1)\n    fmt.Println(\"incremented:\", cs)\n\n    // big integers have their own functions\n    fmt.Println()\n    bs := \"170141183460469231731687303715884105728\"\n    fmt.Println(\"original:   \", bs)\n    var b, one big.Int\n    _, ok := b.SetString(bs, 10)\n    if !ok {\n        fmt.Println(\"big.SetString fail\")\n        return\n    }\n    one.SetInt64(1)\n    bs = b.Add(&b, &one).String()\n    fmt.Println(\"incremented:\", bs)\n}\n\n\nOutput:\noriginal:    1234\nincremented: 1235\n\nstrconv.ParseInt: parsing \" 1234\": invalid syntax\nstrconv.ParseInt: parsing \"12345678901\": value out of range\nstrconv.ParseInt: parsing \"_1234\": invalid syntax\nstrconv.ParseFloat: parsing \"12.D34\": invalid syntax\n\noriginal:    12.34\nincremented: 13.34\nwhat format? 1.3340e+01\n\noriginal:    (12+34i)\nincremented: (13+34i)\n\noriginal:    170141183460469231731687303715884105728\nincremented: 170141183460469231731687303715884105729\n\n", "explain": "Concise:\nMore:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program incstring.s   */\n\n/* Constantes    */\n.equ BUFFERSIZE,   100\n.equ STDIN,  0     @ Linux input console\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ READ,   3     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/* Initialized data */\n.data\nszMessNum:           .asciz \"Enter number\u00a0: \\n\"\nszCarriageReturn:  .asciz \"\\n\"\nszMessResult:       .ascii \"Increment number is = \"      @ message result\nsMessValeur:        .fill 12, 1, ' '\n                       .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \nsBuffer:    .skip    BUFFERSIZE\n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* saves 2 registers */\n\n    ldr r0,iAdrszMessNum\n    bl affichageMess\n    mov r0,#STDIN         @ Linux input console\n    ldr r1,iAdrsBuffer   @ buffer address \n    mov r2,#BUFFERSIZE   @ buffer size \n    mov r7, #READ         @ request to read datas\n    swi 0                  @ call system\n    ldr r1,iAdrsBuffer    @ buffer address \n    mov r2,#0                @ end of string\n    strb r2,[r1,r0]         @ store byte at the end of input string (r0\n    @ \n    ldr r0,iAdrsBuffer    @ buffer address\n    bl conversionAtoD    @ conversion string in number in r0\n    @ increment r0\n    add r0,#1\n    @ conversion register to string\n    ldr r1,iAdrsMessValeur                \n    bl conversion10S       @ call conversion\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    \n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\n\niAdrsMessValeur:        .int sMessValeur\niAdrszMessNum:           .int szMessNum\niAdrsBuffer:             .int sBuffer\niAdrszMessResult:       .int szMessResult\niAdrszCarriageReturn:  .int szCarriageReturn\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      /* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n\n /******************************************************************/\n/*     Convert a string to a number stored in a registry          */ \n/******************************************************************/\n/* r0 contains the address of the area terminated by 0 or 0A */\n/* r0 returns a number                           */\nconversionAtoD:\n    push {fp,lr}         @ save 2 registers \n    push {r1-r7}         @ save others registers \n    mov r1,#0\n    mov r2,#10           @ factor \n    mov r3,#0            @ counter \n    mov r4,r0            @ save address string -> r4 \n    mov r6,#0            @ positive sign by default \n    mov r0,#0            @ initialization to 0 \n1:     /* early space elimination loop */\n    ldrb r5,[r4,r3]     @ loading in r5 of the byte located at the beginning + the position \n    cmp r5,#0            @ end of string -> end routine\n    beq 100f\n    cmp r5,#0x0A        @ end of string -> end routine\n    beq 100f\n    cmp r5,#' '          @ space\u00a0? \n    addeq r3,r3,#1      @ yes we loop by moving one byte \n    beq 1b\n    cmp r5,#'-'          @ first character is -    \n    moveq r6,#1         @  1 -> r6\n    beq 3f              @ then move on to the next position \n2:   /* beginning of digit processing loop */\n    cmp r5,#'0'          @ character is not a number \n    blt 3f\n    cmp r5,#'9'          @ character is not a number\n    bgt 3f\n    /* character is a number */\n    sub r5,#48\n    umull r0,r1,r2,r0         @ multiply par factor 10 \n\tcmp r1,#0           @ overflow\u00a0?\n    bgt 99f            @ overflow error\n    add r0,r5            @ add to  r0 \n3:\n    add r3,r3,#1         @ advance to the next position \n    ldrb r5,[r4,r3]     @ load byte \n    cmp r5,#0            @ end of string -> end routine\n    beq 4f\n    cmp r5,#0x0A            @ end of string -> end routine\n    beq 4f\n    b 2b                 @ loop \n4:\n    cmp r6,#1            @ test r6 for sign \n    moveq r1,#-1\n    muleq r0,r1,r0       @ if negatif, multiply par -1 \n    b 100f\n99:  /* overflow error */\n    ldr r0,=szMessErrDep\n    bl   affichageMess\n    mov r0,#0      @ return  zero  if error\n100:\n    pop {r1-r7}          @ restaur other registers \n    pop {fp,lr}          @ restaur   2 registers \n    bx lr                 @return procedure \n/* constante program */\t\nszMessErrDep:  .asciz  \"Too large: overflow 32 bits.\\n\"\n.align 4\n\n/***************************************************/\n/*  Converting a register to a signed decimal      */\n/***************************************************/\n/* r0 contains value and r1 area address    */\nconversion10S:\n    push {r0-r4,lr}    @ save registers\n    mov r2,r1       /* debut zone stockage */\n    mov r3,#'+'     /* par defaut le signe est + */\n    cmp r0,#0       @ negative number\u00a0? \n    movlt r3,#'-'   @ yes\n    mvnlt r0,r0     @ number inversion\n    addlt r0,#1   \n    mov r4,#10       @ length area\n1:  @ start loop\n    bl divisionpar10\n    add r1,#48   @ digit\n    strb r1,[r2,r4]  @ store digit on area\n    sub r4,r4,#1      @ previous position\n    cmp r0,#0          @ stop if quotient = 0\n    bne 1b\t\n\n    strb r3,[r2,r4]  @ store signe \n    subs r4,r4,#1    @ previous position\n    blt  100f        @ if r4 < 0 -> end\n\n    mov r1,#' '   @ space\t\n2:\n    strb r1,[r2,r4]  @store byte space\n    subs r4,r4,#1    @ previous position\n    bge 2b           @ loop if r4 > 0\n100: \n    pop {r0-r4,lr}   @ restaur registers\n    bx lr  \n\n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10:\t\n    /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}   /* save registers  */\n    mov r4,r0 \n    ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n    smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n    mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n    mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n    add r0, r2, r1         /* r0 <- r2 + r1 */\n    add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n    sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n    pop {r2-r4}\n    bx lr                  /* leave function */\n    .align 4\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "MIPS_Assembly", "code": "\nTranslation of: Z80 Assembly\n.include \"\\SrcAll\\Header.asm\"   ;defines the UserRam label (address 0xA0001000 on N64)\n.include \"\\SrcAll\\BasicMacros.asm\"\n.include \"\\SrcALL\\AdvancedMacros.asm\"\n.include \"\\SrcALL\\MemoryMap.asm\"\n\nCursorX equ 0x100 ;offset from label UserRam, used for tracking where to print to the tv screen\nCursorY equ 0x101 ;offset from label UserRam, used for tracking where to print to the tv screen\nmain:\n\t;copy the string to ram.\n\tla $t0,0x00393939\t;store 0,0x39,0x39,0x39 ;n64 is big-endian\n\tla $t1,0x31000000\t\n\t\n\tla $t2,UserRam\n\tsw $t0,0($t2)\n\tnop\n\tsw $t1,4($t2)\n\tnop\n\t\n\t;string ram now looks like this:\n\t;\tbyte 0\n\t;\tbyte \"9991\"\n\t;\tbyte 0\n\t; it was more convenient to store the numeric string little-endian,\n       \u00a0; the leading terminator lets us easily print it in reverse.\n\t\n\n\tla $t1,UserRam+1\t;read past the terminator placed at the front.\n\tli $t2,0x3A\nincStr:\n\tlbu $t0,($t1)\n\tbeqz $t0,display\n\tnop\n\taddiu $t0,1\n\tbltu $t0,$t2,noCarry\n\tnop\n\t;carry it forward\n\tli $t0,0x30\n\tsb $t0,($t1)\n\taddiu $t1,1\n\tj incStr\n\tnop\n\t\nnoCarry:\n\tsb $t0,($t1)\n\taddiu $t1,1\n\tj incStr\n\t\ndisplay:\n\tla $t1,UserRam+4\ndisplay_loop:\n\tlbu $t0,($t1)\n\tbeqz $t0,shutdown\n\tnop\n\tmove $a1,$t0\n\tjal PrintChar       ;takes $a1 as argument, prints the ascii character in $a1 to the television screen\n\tnop\n\tsubiu $t1,1\n\tj display_loop\n        nop\nshutdown:\n\tnop                 ;not required on real hardware, but project 64 throws a fit if I don't have this.\n\tb shutdown\n\tnop\n\nOutput:\n2000\n\n", "explain": "\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Delphi", "code": "\nprogram IncrementNumericalString;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nconst\n  STRING_VALUE = '12345';\nbegin\n  WriteLn(Format('\"%s\" + 1 = %d', [STRING_VALUE, StrToInt(STRING_VALUE) + 1]));\n\n  Readln;\nend.\n\n\nOutput:\n\"12345\" + 1 = 123456\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Ruby", "code": "\n\n'1234'.succ #=> '1235'\n'99'.succ #=> '100'\n", "explain": "If a string represents a number, the succ method will increment the number:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Rust", "code": "\nfn next_string(input: &str) -> String {\n    (input.parse::<i64>().unwrap() + 1).to_string()\n}\n\nfn main() {\n    let s = \"-1\";\n    let s2 = next_string(s);\n    println!(\"{:?}\", s2);\n}\n\nOutput:\n\"0\"\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Swift", "code": "\nWorks with: Swift version 2.x+\nlet s = \"1234\"\nif let x = Int(s) {\n  print(\"\\(x + 1)\")\n}\nWorks with: Swift version 1.x\nlet s = \"1234\"\nif let x = s.toInt() {\n  println(\"\\(x + 1)\")\n}\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "R", "code": "\ns = \"12345\"\ns <- as.character(as.numeric(s) + 1)\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "COBOL", "code": "\n       PROGRAM-ID. increment-num-str.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  str                    PIC X(5) VALUE \"12345\".\n       01  num                    REDEFINES str PIC 9(5).\n       \n       PROCEDURE DIVISION.\n           DISPLAY str\n           ADD 1 TO num\n           DISPLAY str\n\n           GOBACK\n           .\n\n\n       PROGRAM-ID. increment-num-str.\n       \n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  num-str                PIC 9(5) VALUE 12345.\n       \n       PROCEDURE DIVISION.\n           DISPLAY num-str\n           ADD 1 TO num-str\n           DISPLAY num-str\n       \n           GOBACK\n           .\n\n", "explain": "The following example also increments a numerical string, although it does not apear to. num-str is implicitly defined as USAGE DISPLAY which means its contents will be stored as characters. This means num-str is effectively a string of (numeric) characters.\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Ada", "code": "\n\nS : String := \"12345\";\nS := Ada.Strings.Fixed.Trim(Source => Integer'Image(Integer'Value(S) + 1), Side => Ada.Strings.Both);\n\n", "explain": "The standard Ada package Ada.Strings.Fixed provides a function for trimming blanks from a string.\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Julia", "code": "\nimport Base.+\nBase.:+(s::AbstractString, n::Real) = string((x = tryparse(Int, s)) isa Int ? x + 1 : parse(Float64, s) + 1)\n@show \"125\" + 1\n@show \"125.15\" + 1\n@show \"1234567890987654321\" + 1\n\nOutput:\n\"125\" + 1 = \"126\"\n\"125.15\" + 1 = \"126.15\"\n\"1234567890987654321\" + 1 = \"1234567890987654322\"\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Kotlin", "code": "\n// version 1.0.5-2\n\n/** overload ++ operator to increment a numeric string */\noperator fun String.inc(): String =\n    try {\n        val num = this.toInt()\n        (num + 1).toString()\n    }\n    catch(e: NumberFormatException) {\n        this  // return string unaltered\n    }\n\nfun main(args: Array<String>) {\n    var ns = \"12345\"\n    println(++ns)\n    ns = \"ghijk\"  // not numeric, so won't be changed by increment operator\n    println(++ns)\n}\n\n\nOutput:\n12346\nghijk\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Perl", "code": "\nmy $s = \"12345\";\n$s++;\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Objective-C", "code": "\nNSString *s = @\"12345\";\nint i = [s intValue] + 1;\ns = [NSString stringWithFormat:@\"%i\", i]\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Prolog", "code": "\n\nincr_numerical_string(S1, S2)\u00a0:-\n\tstring_to_atom(S1, A1),\n\tatom_number(A1, N1),\n\tN2 is N1+1,\n\tatom_number(A2, N2),\n\tstring_to_atom(S2, A2).\n\nOutput:\n\u00a0?- incr_numerical_string(\"123\", S2).\nS2 = \"124\".\n", "explain": "Works with SWI-Prolog.\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Lua", "code": "\n\n> -- A STRING THAT CAN BE IMPLICITLY CONVERTED TO A NUMBER\n> s = \"1234\"\n> s+1 -- implicitly convert to number, add 1, remain a number\n1235\n> type(s+1)\nnumber\n> (s+1)..'' -- implicitly convert to number, add 1, implicitly convert back to string\n1235\n> type((s+1)..'')\nstring\n> tostring(s+1) -- implicitly convert to number, add 1, explicitly convert back to string\n1235\n> type(tostring(s+1))\nstring\n> -- A STRING THAT CANNOT BE IMPLICITLY CONVERTED TO A NUMBER\n> s = \"hello\"\n> s+1\nstdin:1: attempt to add a 'string' with a 'number'\nstack traceback:\n        [C]: in metamethod 'add'\n        stdin:1: in main chunk\n        [C]: in\u00a0?\n> -- ONE-LINER EXPLICIT VERSION\n> tostring(tonumber(\"1234\")+1)\n1235\n", "explain": "Lua will attempt an implicit type conversion if an arithmetic operator is used with a string. This is illustrated by the following interactive session (revised for Lua 5.4):\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Scala", "code": "\n\nimplicit def toSucc(s: String) = new { def succ = BigDecimal(s) + 1 toString }\n\nscala> \"123\".succ\nres5: String = 124\n\n", "explain": "The string needs to be converted to a numeric type. BigDecimal should\nhandle most numeric strings. We define a method to do it.\nUsage:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "D", "code": "\nvoid main() {\n    import std.string;\n\n    immutable s = \"12349\".succ;\n    assert(s == \"12350\");\n}\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Haskell", "code": "\n(show . (+1) . read) \"1234\"\n\n\n(show . succ) (read \"1234\" :: Int)\n\n\nTranslation of: Python\nimport Text.Read (readMaybe)\nimport Data.Maybe (mapMaybe)\n\nsuccString :: Bool -> String -> String\nsuccString pruned s =\n  let succs\n        :: (Num a, Show a)\n        => a -> Maybe String\n      succs = Just . show . (1 +)\n      go w\n        | elem '.' w = (readMaybe w :: Maybe Double) >>= succs\n        | otherwise = (readMaybe w :: Maybe Integer) >>= succs\n      opt w\n        | pruned = Nothing\n        | otherwise = Just w\n  in unwords $\n     mapMaybe\n       (\\w ->\n           case go w of\n             Just s -> Just s\n             _ -> opt w)\n       (words s)\n\n\n-- TEST ---------------------------------------------------\nmain :: IO ()\nmain =\n  (putStrLn . unlines) $\n  succString <$> [True, False] <*>\n  pure \"41.0 pine martens in 1491 -1.5 mushrooms \u2260 136\"\n\n\nOutput:\n42.0 1492 -0.5 137\n42.0 pine martens in 1492 -0.5 mushrooms \u2260 137\n", "explain": "or, for Integral values, we can use the Prelude's succ function:\nand to extend the range of a succString function to allow for both floating point and integral numeric strings, for non-numeric noise, for multiple numeric expressions within a single string, and for an option to retain or prune any non-numeric noise, we could write things like:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Scheme", "code": "\n(number->string (+ 1 (string->number \"1234\")))\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Apex", "code": "\nstring count = '12345';\ncount = String.valueOf(integer.valueOf(count)+1);\nsystem.debug('Incremental Value\u00a0: '+count);\n\nOutput:\n12346\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "PowerShell", "code": "\n\n$s = \"12345\"\n$t = [string] ([int] $s + 1)\n\n$t = [string] (1 + $s)\n", "explain": "The easiest way is to cast the string to int, incrementing it and casting back to string:\nOne can also take advantage of the fact that PowerShell casts automatically according to the left-most operand to save one cast:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Logo", "code": "\n\nshow \"123 + 1 \u00a0; 124\nshow word? (\"123 + 1)\u00a0;  true\n", "explain": "Logo is weakly typed, so numeric strings can be treated as numbers and numbers can be treated as strings.\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "ABAP", "code": "\nreport zz_incstring\nperform test using: '0', '1', '-1', '10000000', '-10000000'.\n\nform test using iv_string type string.\n  data: lv_int  type i,\n        lv_string type string.\n  lv_int = iv_string + 1.\n  lv_string = lv_int.\n  concatenate '\"' iv_string '\" + 1 = \"' lv_string '\"' into lv_string.\n  write / lv_string.\nendform.\n\n\nOutput:\n\"0\" + 1 = \"1 \"\n\"1\" + 1 = \"2 \"\n\"-1\" + 1 = \"0 \"\n\"10000000\" + 1 = \"10000001 \"\n\"-10000000\" + 1 = \"9999999-\"\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "F#", "code": "\n// Increment a numerical string. Nigel Galloway: April 4th., 2023\nlet inc=int>>(+)1>>string\nprintfn \"%s\" (inc(\"1234\"))\n\n\nOutput:\n1235\n\n", "explain": ""}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "Groovy", "code": "\n\nprintln (((\"23455\" as BigDecimal) + 1) as String)\nprintln (((\"23455.78\" as BigDecimal) + 1) as String)\n\n\nOutput:\n23456\n23456.78\n", "explain": "Solution:\n"}, {"task_name": "Increment a numerical string", "task_url": "https://rosettacode.org/wiki/Increment_a_numerical_string", "task_cat": "Text processing", "lang": "AWK", "code": "\n\n$ awk 'BEGIN{s=\"42\"; s++; print s\"(\"length(s)\")\" }'\n43(2)\n\n", "explain": "The example shows that the string s can be incremented, \nbut after that still is a string of length 2.\n"}]