[{"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nWorks with: Python version 2.5\n\nfrom collections import deque\nstack = deque()\nstack.append(value) # pushing\nvalue = stack.pop()\nnot stack # is empty?\n\nfrom collections import deque\n\nclass Stack:\n    def __init__(self):\n        self._items = deque()\n    def append(self, item):\n        self._items.append(item)\n    def pop(self):\n        return self._items.pop()\n    def __nonzero__(self):\n        return bool(self._items)\n\nclass Stack:\n    def __init__(self):\n        self._first = None\n    def __nonzero__(self):\n        return self._first is not None \n    def append(self, value):\n        self._first = (value, self._first)\n    def pop(self):\n        if self._first is None:\n            raise IndexError, \"pop from empty stack\"\n        value, self._first = self._first\n        return value\n\nwhile not stack.empty():\n\nwhile stack:\n\n", "explain": "The faster and Pythonic way is using a deque (available from 2.4). \nA regular list is a little slower.\nIf you need to expose your stack to the world, you may want to create a simpler wrapper:\nHere is a stack implemented as linked list - with the same list interface.\nNotes:\nUsing list interface - append, __nonzero__ make it easier to use, cleanup the client code, and allow changing the implementation later without affecting the client code. \nFor example, instead of:\nYou can write:\nQuick testing show that deque is about 5 times faster then the wrapper linked list implementations. This may be important if your stack is used in tight loops.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/* to read expanded code, run through cpp | indent -st */\n#define DECL_STACK_TYPE(type, name)\t\t\t\t\t\\\ntypedef struct stk_##name##_t{type *buf; size_t alloc,len;}*stk_##name;\t\\\nstk_##name stk_##name##_create(size_t init_size) {\t\t\t\\\n\tstk_##name s; if (!init_size) init_size = 4;\t\t\t\\\n\ts = malloc(sizeof(struct stk_##name##_t));\t\t\t\\\n\tif (!s) return 0;\t\t\t\t\t\t\\\n\ts->buf = malloc(sizeof(type) * init_size);\t\t\t\\\n\tif (!s->buf) { free(s); return 0; }\t\t\t\t\\\n\ts->len = 0, s->alloc = init_size;\t\t\t\t\\\n\treturn s; }\t\t\t\t\t\t\t\\\nint stk_##name##_push(stk_##name s, type item) {\t\t\t\\\n\ttype *tmp;\t\t\t\t\t\t\t\\\n\tif (s->len >= s->alloc) {\t\t\t\t\t\\\n\t\ttmp = realloc(s->buf, s->alloc*2*sizeof(type));\t\t\\\n\t\tif (!tmp) return -1; s->buf = tmp;\t\t\t\\\n\t\ts->alloc *= 2; }\t\t\t\t\t\\\n\ts->buf[s->len++] = item;\t\t\t\t\t\\\n\treturn s->len; }\t\t\t\t\t\t\\\ntype stk_##name##_pop(stk_##name s) {\t\t\t\t\t\\\n\ttype tmp;\t\t\t\t\t\t\t\\\n\tif (!s->len) abort();\t\t\t\t\t\t\\\n\ttmp = s->buf[--s->len];\t\t\t\t\t\t\\\n\tif (s->len * 2 <= s->alloc && s->alloc >= 8) {\t\t\t\\\n\t\ts->alloc /= 2;\t\t\t\t\t\t\\\n\t\ts->buf = realloc(s->buf, s->alloc * sizeof(type));}\t\\\n\treturn tmp; }\t\t\t\t\t\t\t\\\nvoid stk_##name##_delete(stk_##name s) {\t\t\t\t\\\n\tfree(s->buf); free(s); }\n\n#define stk_empty(s) (!(s)->len)\n#define stk_size(s) ((s)->len)\n\nDECL_STACK_TYPE(int, int)\n\nint main(void)\n{\n\tint i;\n\tstk_int stk = stk_int_create(0);\n\n\tprintf(\"pushing: \");\n\tfor (i = 'a'; i <= 'z'; i++) {\n\t\tprintf(\" %c\", i);\n\t\tstk_int_push(stk, i);\n\t}\n\n\tprintf(\"\\nsize now: %d\", stk_size(stk));\n\tprintf(\"\\nstack is%s empty\\n\", stk_empty(stk) ? \"\" : \" not\");\n\n\tprintf(\"\\npoppoing:\");\n\twhile (stk_size(stk))\n\t\tprintf(\" %c\", stk_int_pop(stk));\n\tprintf(\"\\nsize now: %d\", stk_size(stk));\n\tprintf(\"\\nstack is%s empty\\n\", stk_empty(stk) ? \"\" : \" not\");\n\n\t/* stk_int_pop(stk); <-- will abort() */\n\tstk_int_delete(stk);\n\treturn 0;\n}\n\nOr[edit]\n#include <stdio.h>\n#include <stdlib.h>\n#include <stddef.h>\n#include <stdbool.h>\n\n#define check_pointer(p) if (!p) {puts(\"Out of memory.\"); exit(EXIT_FAILURE);}\n\n#define MINIMUM_SIZE 1\n /* Minimal stack size (expressed in number of elements) for which\n space is allocated. It should be at least 1. */\n#define GROWTH_FACTOR 2\n /* How much more memory is allocated each time a stack grows\n out of its allocated segment. */\ntypedef int T;\n // The type of the stack elements.\n\ntypedef struct\n {T *bottom;\n  T *top;\n  T *allocated_top;} stack;\n\nstack * new(void)\n/* Creates a new stack. */\n {stack *s = malloc(sizeof(stack));\n  check_pointer(s);\n  s->bottom = malloc(MINIMUM_SIZE * sizeof(T));\n  check_pointer(s->bottom);\n  s->top = s->bottom - 1;\n  s->allocated_top = s->bottom + MINIMUM_SIZE - 1;\n  return s;}\n\nvoid destroy(stack *s)\n/* Frees all the memory used for a stack. */\n {free(s->bottom);\n  free(s);}\n\nbool empty(stack *s)\n/* Returns true iff there are no elements on the stack. This\nis different from the stack not having enough memory reserved\nfor even one element, which case is never allowed to arise. */\n {return s->top < s->bottom ? true : false;}\n\nvoid push(stack *s, T x)\n/* Puts a new element on the stack, enlarging the latter's\nmemory allowance if necessary. */\n {if (s->top == s->allocated_top)\n     {ptrdiff_t qtty = s->top - s->bottom + 1;\n      ptrdiff_t new_qtty = GROWTH_FACTOR * qtty;\n      s->bottom = realloc(s->bottom, new_qtty * sizeof(T));\n      check_pointer(s->bottom);\n      s->top = s->bottom + qtty - 1;\n      s->allocated_top = s->bottom + new_qtty - 1;}\n  *(++s->top) = x;}\n\nT pop(stack *s)\n/* Removes and returns the topmost element. The result of popping\nan empty stack is undefined. */\n {return *(s->top--);}\n\nvoid compress(stack *s)\n/* Frees any memory the stack isn't actually using. The\nallocated portion still isn't allowed to shrink smaller than\nMINIMUM_SIZE. If all the stack's memory is in use, nothing\nhappens. */\n {if (s->top == s->allocated_top) return;\n  ptrdiff_t qtty = s->top - s->bottom + 1;\n  if (qtty < MINIMUM_SIZE) qtty = MINIMUM_SIZE;\n  size_t new_size = qtty * sizeof(T);\n  s->bottom = realloc(s->bottom, new_size);\n  check_pointer(s->bottom);\n  s->allocated_top = s->bottom + qtty - 1;}\n\n", "explain": "Macro expanding to type flexible stack routines.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\nLibrary: STL\n\n#include <stack>\n\n\n#include <deque>\ntemplate <class T, class Sequence = std::deque<T> >\nclass stack {\n  friend bool operator== (const stack&, const stack&);\n  friend bool operator<  (const stack&, const stack&);\npublic:\n  typedef typename Sequence::value_type      value_type;\n  typedef typename Sequence::size_type       size_type;\n  typedef          Sequence                  container_type;\n  typedef typename Sequence::reference       reference;\n  typedef typename Sequence::const_reference const_reference;\nprotected:\n  Sequence seq;\npublic:\n  stack() : seq() {}\n  explicit stack(const Sequence& s0) : seq(s0) {}\n  bool empty() const { return seq.empty(); }\n  size_type size() const { return seq.size(); }\n  reference top() { return seq.back(); }\n  const_reference top() const { return seq.back(); }\n  void push(const value_type& x) { seq.push_back(x); }\n  void pop() { seq.pop_back(); }\n};\n\ntemplate <class T, class Sequence>\nbool operator==(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return x.seq == y.seq;\n}\ntemplate <class T, class Sequence>\nbool operator<(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return x.seq < y.seq;\n}\n\ntemplate <class T, class Sequence>\nbool operator!=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return !(x == y);\n}\ntemplate <class T, class Sequence>\nbool operator>(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return y < x;\n}\ntemplate <class T, class Sequence>\nbool operator<=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return !(y < x);\n}\ntemplate <class T, class Sequence>\nbool operator>=(const stack<T,Sequence>& x, const stack<T,Sequence>& y)\n{\n  return !(x < y);\n}\n\n", "explain": "The C++ standard library already provides a ready-made stack class. You get it by writing\nand then using the std::stack class.\nAn example of an explicit implementation of a stack class (which actually implements the standard stack class, except that the standard one is in namespace std):\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\nimport java.util.Stack;\n\npublic class StackTest {\n    public static void main( final String[] args ) {\n        final Stack<String> stack = new Stack<String>();\n\n        System.out.println( \"New stack empty? \" + stack.empty() );\n\n        stack.push( \"There can be only one\" );\n        System.out.println( \"Pushed stack empty? \" + stack.empty() );\n        System.out.println( \"Popped single entry: \" + stack.pop() );\n\n        stack.push( \"First\" );\n        stack.push( \"Second\" );\n        System.out.println( \"Popped entry should be second: \" + stack.pop() );\n\n        // Popping an empty stack will throw...\n        stack.pop();\n        stack.pop();\n    }\n}\n\n\nOutput:\nNew stack empty? true\nPushed stack empty? false\nPopped single entry: There can be only one\nPopped entry should be second: Second\nException in thread \"main\" java.util.EmptyStackException\n\tat java.util.Stack.peek(Stack.java:85)\n\tat java.util.Stack.pop(Stack.java:67)\n\tat StackTest.main(StackTest.java:21)\n\npublic class Stack{\n    private Node first = null;\n    public boolean isEmpty(){\n        return first == null;\n    }\n    public Object Pop(){\n        if(isEmpty()) \n            throw new Exception(\"Can't Pop from an empty Stack.\");\n        else{\n            Object temp = first.value;\n            first = first.next;\n            return temp;\n        }\n    }\n    public void Push(Object o){\n        first = new Node(o, first);\n    }\n    class Node{\n        public Node next;\n        public Object value;\n        public Node(Object value){\n            this(value, null); \n        }\n        public Node(Object value, Node next){\n            this.next = next;\n            this.value = value;\n        }\n    }\n}\n\nWorks with: Java version 1.5\npublic class Stack<T>{\n    private Node first = null;\n    public boolean isEmpty(){\n        return first == null;\n    }\n    public T Pop(){\n        if(isEmpty()) \n            throw new Exception(\"Can't Pop from an empty Stack.\");\n        else{\n            T temp = first.value;\n            first = first.next;\n            return temp;\n        }\n    }\n    public void Push(T o){\n        first = new Node(o, first);\n    }\n    class Node{\n        public Node next;\n        public T value;\n        public Node(T value){\n            this(value, null); \n        }\n        public Node(T value, Node next){\n            this.next = next;\n            this.value = value;\n        }\n    }\n}\n\n", "explain": "The collections framework includes a Stack class. Let's test it:\nAlternatively, you might implement a stack yourself...\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n// Non-Generic Stack\nSystem.Collections.Stack stack = new System.Collections.Stack();\nstack.Push( obj );\nbool isEmpty = stack.Count == 0;\nobject top = stack.Peek(); // Peek without Popping.\ntop = stack.Pop();\n\n// Generic Stack\nSystem.Collections.Generic.Stack<Foo> stack = new System.Collections.Generic.Stack<Foo>();\nstack.Push(new Foo());\nbool isEmpty = stack.Count == 0;\nFoo top = stack.Peek(); // Peek without Popping.\ntop = stack.Pop();\n\n", "explain": ""}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\nvar stack = [];\nstack.push(1)\nstack.push(2,3);\nprint(stack.pop());   // 3\nprint(stack.length);   // 2, stack empty if 0\n\n\nfunction Stack() {\n    this.data = new Array();\n\n    this.push  = function(element) {this.data.push(element)}\n    this.pop   = function() {return this.data.pop()}\n    this.empty = function() {return this.data.length == 0}\n    this.peek  = function() {return this.data[this.data.length - 1]}\n}\n\n\nfunction makeStack() {\n  var stack = [];\n\n  var popStack = function () {\n    return stack.pop();\n  };\n  var pushStack = function () {\n    return stack.push.apply(stack, arguments);\n  };\n  var isEmpty = function () {\n    return stack.length === 0;\n  };\n  var peekStack = function () {\n    return stack[stack.length-1];\n  };\n    \n  return {\n    pop: popStack,\n    push: pushStack,\n    isEmpty: isEmpty,\n    peek: peekStack,\n    top: peekStack\n  };\n}\n\n", "explain": "The built-in Array class already has stack primitives.\nHere's a constructor that wraps the array:\nHere's an example using the revealing module pattern instead of prototypes.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n\n$stack = array();\n\nempty( $stack ); // true\n\narray_push( $stack, 1 ); // or $stack[] = 1;\narray_push( $stack, 2 ); // or $stack[] = 2;\n\nempty( $stack ); // false\n\necho array_pop( $stack ); // outputs \"2\"\necho array_pop( $stack ); // outputs \"1\"\n\n", "explain": "PHP arrays behave like a stack:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\n\nmodule mod_stack\n\n  implicit none\n  type node\n    ! data entry in each node\n    real*8, private :: data\n    ! pointer to the next node of the linked list\n    type(node), pointer, private :: next\n  end type node\n  private node\n\n  type stack\n    ! pointer to first element of stack.\n    type(node), pointer, private :: first\n    ! size of stack\n    integer, private :: len=0\n  contains\n    procedure :: pop\n    procedure :: push\n    procedure :: peek\n    procedure :: getSize\n    procedure :: clearStack\n    procedure :: isEmpty\n  end type stack\n\ncontains\n\n  function pop(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    type(node), pointer :: tmp\n    if ( this%len == 0 ) then\n      print*, \"popping from empty stack\"\n      !stop\n    end if\n    tmp => this%first\n    x = this%first%data\n    this%first => this%first%next\n    deallocate(tmp)\n    this%len = this%len -1\n  end function pop\n\n  subroutine push(this, x)\n    real*8 :: x\n    class(stack), target :: this\n    type(node), pointer :: new, tmp\n    allocate(new)\n    new%data = x\n    if (.not. associated(this%first)) then\n      this%first => new\n    else\n      tmp => this%first\n      this%first => new\n      this%first%next => tmp\n    end if\n    this%len = this%len + 1\n  end subroutine push\n\n  function peek(this) result(x)\n    class(stack) :: this\n    real*8 :: x\n    x = this%first%data\n  end function peek\n\n  function getSize(this) result(n)\n    class(stack) :: this\n    integer :: n\n    n = this%len\n  end function getSize\n\n  function isEmpty(this) result(empty)\n    class(stack) :: this\n    logical :: empty\n    if ( this%len > 0 ) then\n      empty = .FALSE.\n    else\n      empty = .TRUE.\n    end if\n  end function isEmpty\n\n  subroutine clearStack(this)\n    class(stack) :: this\n    type(node), pointer :: tmp\n    integer :: i\n    if ( this%len == 0 ) then\n      return\n    end if\n    do i = 1, this%len\n      tmp => this%first\n      if ( .not. associated(tmp)) exit\n      this%first => this%first%next\n      deallocate(tmp)\n    end do\n    this%len = 0\n  end subroutine clearStack\nend module mod_stack\n\nprogram main\n  use mod_stack\n  type(stack) :: my_stack\n  integer :: i\n  real*8 :: dat\n  do i = 1, 5, 1\n    dat = 1.0 * i\n    call my_stack%push(dat)\n  end do\n  do while ( .not. my_stack%isEmpty() )\n    print*, my_stack%pop()\n  end do\n  call my_stack%clearStack()\nend program main\n\n", "explain": "This solution can easily be adapted to data types other than floating point numbers.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\nvar intStack []int\n\n\nintStack = append(intStack, 7)\n\n\npopped, intStack = intStack[len(intStack)-1], intStack[:len(intStack)-1]\n\n\nlen(intStack) == 0\n\n\nintStack[len(intStack)-1]\n\n\npackage main\n\nimport \"fmt\"\n\ntype stack []interface{}\n\nfunc (k *stack) push(s interface{}) {\n    *k = append(*k, s)\n}\n\nfunc (k *stack) pop() (s interface{}, ok bool) {\n    if k.empty() {\n        return\n    }\n    last := len(*k) - 1\n    s = (*k)[last]\n    *k = (*k)[:last]\n    return s, true\n}\n\nfunc (k *stack) peek() (s interface{}, ok bool) {\n    if k.empty() {\n        return\n    }\n    last := len(*k) - 1\n    s = (*k)[last]\n    return s, true\n}\n\nfunc (k *stack) empty() bool {\n    return len(*k) == 0\n}\n\nfunc main() {\n    var s stack\n    fmt.Println(\"new stack:\", s)\n    fmt.Println(\"empty?\", s.empty())\n    s.push(3)\n    fmt.Println(\"push 3. stack:\", s)\n    fmt.Println(\"empty?\", s.empty())\n    s.push(\"four\")\n    fmt.Println(`push \"four\" stack:`, s)\n    if top, ok := s.peek(); ok {\n        fmt.Println(\"top value:\", top)\n    } else {\n        fmt.Println(\"nothing on stack\")\n    }\n    if popped, ok := s.pop(); ok {\n        fmt.Println(popped, \"popped.  stack:\", s)\n    } else {\n        fmt.Println(\"nothing to pop\")\n    }\n}\n\n\nOutput:\nnew stack: []\nempty? true\npush 3. stack: [3]\nempty? false\npush \"four\" stack: [3 four]\ntop value: four\nfour popped.  stack: [3]\n\n", "explain": "Go slices make excellent stacks without defining any extra types, functions, or methods.  For example, to keep a stack of integers, simply declare one as,\nUse the built in append function to push numbers on the stack:\nUse a slice expression with the built in len function to pop from the stack:\nThe test for an empty stack:\nAnd to peek at the top of the stack:\nIt is idiomatic Go to use primitive language features where they are sufficient, and define helper functions or types and methods only as they make sense for a particular situation.  Below is an example using a type with methods and idiomatic \"ok\" return values to avoid panics.  It is only an example of something that might make sense in some situation.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\n\nSTMFD sp!,{r0-r12,lr} ;push r0 thru r12 and the link register\nLDMFD sp!,{r0-r12,pc} ;pop r0 thru r12, and the value that was in the link register is put into the program counter. \n                      ;This acts as a pop and return command all-in-one. (Most programs use bx lr to return.)\n\nLDR r0,[sp] ;load the top of the stack into r0\n\n;this example uses VASM syntax which considers a \"word\" to be 16-bit regardless of the architecture\nInitStackPointer:    .long 0x3FFFFFFF   ;other assemblers would call this a \"word\"\n\nMOV R1,#InitStackPointer\nLDR SP,[R1]  ;set up the stack pointer\nLDR R2,[R1]  ;also load it into R2\n;There's no point in checking since we haven't pushed/popped anything but just for demonstration purposes we'll check now\nCMP SP,R2\nBEQ StackIsEmpty\n\n", "explain": "The stack is held in register 13, or r13 but more commonly referred to as SP for clarity.\nPushing and popping multiple values is very similar to 68000 Assembly.\nLike in 68000 Assembly, you are not limited to using SP as the source/destination for these commands; any register can fulfill that role. If you wish to have multiple stacks, then so be it. \nThe stack pointer will work with any operation the other registers can. As such, a peek can be done by using an LDR with the stack pointer as the address register:\nThe order in which registers are pushed/popped is always the same, no matter which order you list the registers in your source code. If you want to push some registers and purposefully pop them into different registers, you'll need to push/pop them separately.\nA check if the stack is empty is also very simple, provided the initial value of the stack pointer was saved at the start of the program, or (more likely) was loaded from a nearby memory location.\nIn THUMB mode, the PUSH and POP commands replace STMFD and LDMFD. They work in a similar fashion, but are limited to just the stack unlike the real STMFD and LDMFD commands which can use any register as the \"stack pointer.\"\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "MIPS_Assembly", "code": "\naddi sp,sp,-4\nsw t0,0(sp)      ;push\n\nlw t0,0(sp)\naddi sp,sp,4     ;pop\n\nlw t0,0(sp)      ;top\n\n", "explain": "\"Empty\" requires you to know the starting value of SP. Since it's hardware-dependent, there's no one answer for this part of the task.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "X86_Assembly", "code": "\n; x86_64 linux nasm\n\nstruc Stack\n  maxSize: resb 8\n  currentSize: resb 8\n  contents:\nendStruc\n\nsection .data\n\nsoError: db \"Stack Overflow Exception\", 10\nseError: db \"Stack Empty Error\", 10\n\n\nsection .text\n\ncreateStack:\n; IN: max number of elements (rdi)\n; OUT: pointer to new stack (rax)\n  push rdi\n  xor rdx, rdx\n  mov rbx, 8\n  mul rbx\n  mov rcx, rax\n  mov rax, 12\n  mov rdi, 0\n  syscall\n  push rax\n  mov rdi, rax\n  add rdi, rcx\n  mov rax, 12\n  syscall\n  pop rax\n  pop rbx\n  mov qword [rax + maxSize], rbx\n  mov qword [rax + currentSize], 0\n  ret\n\n\npush:\n; IN: stack to operate on (stack argument), element to push (rdi)\n; OUT: void\n  mov rax, qword [rsp + 8]\n  mov rbx, qword [rax + currentSize]\n  cmp rbx, qword [rax + maxSize]\n  je stackOverflow\n  lea rsi, [rax + contents + 8*rbx]\n  mov qword [rsi], rdi\n  add qword [rax + currentSize], 1\n  ret\n\n\npop:\n; pop\n; IN: stack to operate on (stack argument)\n; OUT: element from stack top\n  mov rax, qword [rsp + 8]\n  mov rbx, qword [rax + currentSize]\n  cmp rbx, 0\n  je stackEmpty\n  sub rbx, 1\n  lea rsi, [rax + contents + 8*rbx]\n  mov qword [rax + currentSize], rbx\n  mov rax, qword [rsi]\n  ret\n\n\n; stack operation exceptions\nstackOverflow:\n  mov rsi, soError\n  mov rdx, 25\n  jmp errExit\nstackEmpty:\n  mov rsi, seError\n  mov rdx, 18\nerrExit:\n  mov rax, 1\n  mov rdi, 1\n  syscall\n  mov rax, 60\n  mov rdi, 1\n  syscall\n", "explain": ""}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nprogram Stack;\n\n{$APPTYPE CONSOLE}\n\nuses Generics.Collections;\n\nvar\n  lStack: TStack<Integer>;\nbegin\n  lStack := TStack<Integer>.Create;\n  try\n    lStack.Push(1);\n    lStack.Push(2);\n    lStack.Push(3);\n    Assert(lStack.Peek = 3); // 3 should be at the top of the stack\n\n    Writeln(lStack.Pop); // 3\n    Writeln(lStack.Pop); // 2\n    Writeln(lStack.Pop); // 1\n    Assert(lStack.Count = 0); // should be empty\n  finally\n    lStack.Free;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n\nstack = []\nstack.push(value) # pushing\nvalue = stack.pop # popping\nstack.empty? # is empty?\n\nrequire 'forwardable'\n\n# A stack contains elements in last-in, first-out order.\n# Stack#push adds new elements to the top of the stack;\n# Stack#pop removes elements from the top.\nclass Stack\n  extend Forwardable\n  \n  # Creates a Stack containing _objects_.\n  def self.[](*objects)\n    new.push(*objects)\n  end\n  \n  # Creates an empty Stack.\n  def initialize\n    @ary = []\n  end\n  \n  # Duplicates a Stack.\n  def initialize_copy(obj)\n    super\n    @ary = @ary.dup\n  end\n  \n  # Adds each object to the top of this Stack. Returns self.\n  def push(*objects)\n    @ary.push(*objects)\n    self\n  end\n  alias << push\n  \n  ##\n  # :method: pop\n  # :call-seq:\n  #   pop -> obj or nil\n  #   pop(n) -> ary\n  #\n  # Removes an element from the top of this Stack, and returns it.\n  # Returns nil if the Stack is empty.\n  #\n  # If passing a number _n_, removes the top _n_ elements, and returns\n  # an Array of them. If this Stack contains fewer than _n_ elements,\n  # returns them all. If this Stack is empty, returns an empty Array.\n  def_delegator\u00a0:@ary, :pop\n  \n  ##\n  # :method: top\n  # :call-seq:\n  #   top -> obj or nil\n  #   top(n) -> ary\n  # Returns the topmost element without modifying the stack.\n  def_delegator\u00a0:@ary, :last, :top\n  \n  ##\n  # :method: empty?\n  # Returns true if this Stack contains no elements.\n  def_delegator\u00a0:@ary, :empty?\n  \n  ##\n  # :method: size\n  # Returns the number of elements in this Stack.\n  def_delegator\u00a0:@ary, :size\n  alias length size\n  \n  # Converts this Stack to a String.\n  def to_s\n    \"#{self.class}#{@ary.inspect}\"\n  end\n  alias inspect to_s\nend\np s = Stack.new                 # => Stack[]\np s.empty?                      # => true\np s.size                        # => 0\np s.top                         # => nil\np s.pop                         # => nil\np s.pop(1)                      # => []\np s.push(1)                     # => Stack[1]\np s.push(2, 3)                  # => Stack[1, 2, 3]\np s.top                         # => 3\np s.top(2)                      # => [2, 3]\np s                             # => Stack[1, 2, 3]\np s.size                        # => 3\np s.pop                         # => 3\np s.pop(1)                      # => [2]\np s.empty?                      # => false\n\np s = Stack[:a, :b, :c]         # => Stack[:a, :b, :c]\np s << :d                       # => Stack[:a, :b, :c, :d]\np s.pop                         # => :d\n\nrequire 'forwardable'\n\nclass Stack\n  extend Forwardable\n\n  def initialize\n    @stack = []\n  end\n\n  def_delegators\u00a0:@stack, :push, :pop, :empty?\nend\n\n", "explain": "Using an Array, there are already methods Array#push, Array#pop and Array#empty?.\nIf you need to expose your stack to the world, you may want to create a simpler wrapper. Here is a wrapper class Stack that wraps Array but only exposes stack methods.\nJust meeting the requirements of a push, pop and empty method:\n(push takes multiple arguments; pop takes an optional argument which specifies how many to pop)\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\nUsing the standard library[edit]\n\nfn main() {\n    let mut stack = Vec::new();\n    stack.push(\"Element1\");\n    stack.push(\"Element2\");\n    stack.push(\"Element3\");\n\n    assert_eq!(Some(&\"Element3\"), stack.last());\n    assert_eq!(Some(\"Element3\"), stack.pop());\n    assert_eq!(Some(\"Element2\"), stack.pop());\n    assert_eq!(Some(\"Element1\"), stack.pop());\n    assert_eq!(None, stack.pop());\n}\nSimple implementation[edit]\n\ntype Link<T> = Option<Box<Frame<T>>>;\n\npub struct Stack<T> {\n    head: Link<T>,\n}\nstruct Frame<T> { \n    elem: T,\n    next: Link<T>,\n}\n\n/// Iterate by value (consumes list)\npub struct IntoIter<T>(Stack<T>); \nimpl<T> Iterator for IntoIter<T> {\n    type Item = T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.0.pop()\n    }\n}\n\n/// Iterate by immutable reference\npub struct Iter<'a, T: 'a> { \n    next: Option<&'a Frame<T>>,\n}\nimpl<'a, T> Iterator for Iter<'a, T> { // Iterate by immutable reference\n    type Item = &'a T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|frame| {\n            self.next = frame.next.as_ref().map(|frame| &**frame);\n            &frame.elem\n        })\n    }\n}\n\n/// Iterate by mutable reference\npub struct IterMut<'a, T: 'a> {\n    next: Option<&'a mut Frame<T>>,\n}\nimpl<'a, T> Iterator for IterMut<'a, T> {\n    type Item = &'a mut T;\n    fn next(&mut self) -> Option<Self::Item> {\n        self.next.take().map(|frame| {\n            self.next = frame.next.as_mut().map(|frame| &mut **frame);\n            &mut frame.elem\n        })\n    }\n}\n\n\nimpl<T> Stack<T> {\n    /// Return new, empty stack\n    pub fn new() -> Self {\n        Stack { head: None }\n    }\n\n    /// Add element to top of the stack\n    pub fn push(&mut self, elem: T) {\n        let new_frame = Box::new(Frame {\n            elem: elem,\n            next: self.head.take(),\n        });\n        self.head = Some(new_frame);\n    }\n\n    /// Remove element from top of stack, returning the value\n    pub fn pop(&mut self) -> Option<T> {\n        self.head.take().map(|frame| { \n            let frame = *frame;\n            self.head = frame.next;\n            frame.elem\n        })\n    }\n\n    /// Get immutable reference to top element of the stack\n    pub fn peek(&self) -> Option<&T> {\n        self.head.as_ref().map(|frame| &frame.elem)\n    }\n\n    /// Get mutable reference to top element on the stack\n    pub fn peek_mut(&mut self) -> Option<&mut T> {\n        self.head.as_mut().map(|frame| &mut frame.elem)\n    }\n\n    /// Iterate over stack elements by value\n    pub fn into_iter(self) -> IntoIter<T> {\n        IntoIter(self)\n    }\n\n    /// Iterate over stack elements by immutable reference\n    pub fn iter<'a>(&'a self) -> Iter<'a,T> {\n        Iter { next: self.head.as_ref().map(|frame| &**frame) }\n    }\n\n    /// Iterate over stack elements by mutable reference\n    pub fn iter_mut(&mut self) -> IterMut<T> {\n        IterMut { next: self.head.as_mut().map(|frame| &mut **frame) }\n    }\n}\n\n// The Drop trait tells the compiler how to free an object after it goes out of scope. \n// By default, the compiler would do this recursively which *could* blow the stack for\n// extraordinarily long lists. This simply tells it to do it iteratively.\nimpl<T> Drop for Stack<T> {\n    fn drop(&mut self) {\n        let mut cur_link = self.head.take();\n        while let Some(mut boxed_frame) = cur_link {\n            cur_link = boxed_frame.next.take();\n        }\n    }\n}\n", "explain": "One could just use a vector (Vec<T>) which is part of the standard library\nSimply uses a singly-linked list.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\n\nstruct Stack<T> {\n    var items = [T]()\n    var empty:Bool {\n        return items.count == 0\n    }\n    \n    func peek() -> T {\n        return items[items.count - 1]\n    }\n    \n    mutating func pop() -> T {\n        return items.removeLast()\n    }\n    \n    mutating func push(obj:T) {\n        items.append(obj)\n    }\n}\n\nvar stack = Stack<Int>()\nstack.push(1)\nstack.push(2)\nprintln(stack.pop())\nprintln(stack.peek())\nstack.pop()\nprintln(stack.empty)\n\nOutput:\n2\n1\ntrue\n\n", "explain": "Generic stack.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nLibrary: proto\n\nlibrary(proto)\n\nstack <- proto(expr = {\n   l <- list()\n   empty <- function(.) length(.$l) == 0\n   push <- function(., x) \n   {\n      .$l <- c(list(x), .$l)\n      print(.$l)\n      invisible()\n   }\n   pop <- function(.) \n   {\n      if(.$empty()) stop(\"can't pop from an empty list\")\n      .$l[[1]] <- NULL\n      print(.$l)\n      invisible()\n   }\n})\n\nstack$empty()\n# [1] TRUE\nstack$push(3)\n# [[1]]\n# [1] 3\nstack$push(\"abc\")\n# [[1]]\n# [1] \"abc\"\n# [[2]]\n# [1] 3\nstack$push(matrix(1:6, nrow=2))\n# [[1]]\n#      [,1] [,2] [,3]\n# [1,]    1    3    5\n# [2,]    2    4    6\n# [[2]]\n# [1] \"abc\"\n# [[3]]\n# [1] 3\nstack$empty()\n# [1] FALSE\nstack$pop()\n# [[1]]\n[1] \"abc\"\n# [[2]]\n# [1] 3\nstack$pop()\n# [[1]]\n# [1] 3\nstack$pop()\n# list()\nstack$pop()\n# Error in get(\"pop\", env = stack, inherits = TRUE)(stack, ...)\u00a0: \n#   can't pop from an empty list\n", "explain": "See FIFO for functional and object oriented implementations of a First-In-First-Out object, with similar code.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\nWorks with: COBOL version 2002\nWorks with: OpenCOBOL version 1.1\n\n       01  stack.\n         05  head USAGE IS POINTER VALUE NULL.\n\n\n       01  node BASED.\n         COPY node-info REPLACING\n           01 BY 05\n           node-info BY info.\n         05  link USAGE IS POINTER VALUE NULL.\n\n\n       01  node-info PICTURE X(10) VALUE SPACES.\n\n\n       01  p PICTURE 9.\n         88 nil VALUE ZERO WHEN SET TO FALSE IS 1.\n         88 t   VALUE 1 WHEN SET TO FALSE IS ZERO.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. push.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node.\n       LINKAGE SECTION.\n       COPY stack.\n       01  node-info-any PICTURE X ANY LENGTH.\n       PROCEDURE DIVISION USING stack node-info-any.\n         ALLOCATE node\n         CALL \"pointerp\" USING\n           BY REFERENCE ADDRESS OF node\n           BY REFERENCE p\n         END-CALL\n         IF nil\n           CALL \"stack-overflow-error\" END-CALL\n         ELSE\n           MOVE node-info-any TO info OF node\n           SET link OF node TO head OF stack\n           SET head OF stack TO ADDRESS OF node\n         END-IF\n         GOBACK.\n       END PROGRAM push.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. pop.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY node-info.\n       PROCEDURE DIVISION USING stack node-info.\n         CALL \"empty\" USING\n           BY REFERENCE stack\n           BY REFERENCE p\n         END-CALL\n         IF t\n           CALL \"stack-underflow-error\" END-CALL\n         ELSE\n           SET ADDRESS OF node TO head OF stack\n           SET head OF stack TO link OF node\n           MOVE info OF node TO node-info\n         END-IF\n         FREE ADDRESS OF node\n         GOBACK.\n       END PROGRAM pop.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. empty.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY p.\n       PROCEDURE DIVISION USING stack p.\n         CALL \"pointerp\" USING\n           BY CONTENT head OF stack\n           BY REFERENCE p\n         END-CALL\n         IF t\n           SET t TO FALSE\n         ELSE\n           SET t TO TRUE\n         END-IF\n         GOBACK.\n       END PROGRAM empty.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. head.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY node-info.\n       PROCEDURE DIVISION USING stack node-info.\n         CALL \"empty\" USING\n           BY REFERENCE stack\n           BY REFERENCE p\n         END-CALL\n         IF t\n           CALL \"stack-underflow-error\" END-CALL\n         ELSE\n           SET ADDRESS OF node TO head OF stack\n           MOVE info OF node TO node-info\n         END-IF\n         GOBACK.\n       END PROGRAM head.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. peek.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY node-info.\n       PROCEDURE DIVISION USING stack node-info.\n         CALL \"head\" USING\n           BY CONTENT stack\n           BY REFERENCE node-info\n         END-CALL\n         GOBACK.\n       END PROGRAM peek.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. pointerp.\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  test-pointer USAGE IS POINTER.\n       COPY p.\n       PROCEDURE DIVISION USING test-pointer p.\n         IF test-pointer EQUAL NULL\n           SET nil TO TRUE\n         ELSE\n           SET t TO TRUE\n         END-IF\n         GOBACK.\n       END PROGRAM pointerp.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. stack-overflow-error.\n       PROCEDURE DIVISION.\n         DISPLAY \"stack-overflow-error\" END-DISPLAY\n         STOP RUN.\n       END PROGRAM stack-overflow-error.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. stack-underflow-error.\n       PROCEDURE DIVISION.\n         DISPLAY \"stack-underflow-error\" END-DISPLAY\n         STOP RUN.\n       END PROGRAM stack-underflow-error.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. copy-stack.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node-info.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY stack REPLACING stack BY new-stack.\n       PROCEDURE DIVISION USING stack new-stack.\n         CALL \"empty\" USING\n           BY REFERENCE stack\n           BY REFERENCE p\n         END-CALL\n         IF nil\n           CALL \"pop\" USING\n             BY REFERENCE stack\n             BY REFERENCE node-info\n           END-CALL\n           CALL \"copy-stack\" USING\n             BY REFERENCE stack\n             BY REFERENCE new-stack\n           END-CALL\n           CALL \"push\" USING\n             BY REFERENCE stack\n             BY REFERENCE node-info\n           END-CALL\n           CALL \"push\" USING\n             BY REFERENCE new-stack\n             BY REFERENCE node-info\n           END-CALL\n         END-IF\n         GOBACK.\n       END PROGRAM copy-stack.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. reverse-stack.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node-info.\n       LINKAGE SECTION.\n       COPY stack.\n       COPY stack REPLACING stack BY new-stack.\n       PROCEDURE DIVISION USING stack new-stack.\n         CALL \"empty\" USING\n           BY REFERENCE stack\n           BY REFERENCE p\n         END-CALL\n         IF nil\n           CALL \"pop\" USING\n             BY REFERENCE stack\n             BY REFERENCE node-info\n           END-CALL\n           CALL \"push\" USING\n             BY REFERENCE new-stack\n             BY REFERENCE node-info\n           END-CALL\n           CALL \"reverse-stack\" USING\n             BY REFERENCE stack\n             BY REFERENCE new-stack\n           END-CALL\n           CALL \"push\" USING\n             BY REFERENCE stack\n             BY REFERENCE node-info\n           END-CALL\n         END-IF\n         GOBACK.\n       END PROGRAM reverse-stack.\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. traverse-stack.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY p.\n       COPY node-info.\n       COPY stack REPLACING stack BY new-stack.\n       LINKAGE SECTION.\n       COPY stack.\n       PROCEDURE DIVISION USING stack.\n         CALL \"copy-stack\" USING\n           BY REFERENCE stack\n           BY REFERENCE new-stack\n         END-CALL\n         CALL \"empty\" USING\n           BY REFERENCE new-stack\n           BY REFERENCE p\n         END-CALL\n         IF nil\n           CALL \"head\" USING\n             BY CONTENT new-stack\n             BY REFERENCE node-info\n           END-CALL\n           DISPLAY node-info END-DISPLAY\n           CALL \"peek\" USING\n             BY CONTENT new-stack\n             BY REFERENCE node-info\n           END-CALL\n           DISPLAY node-info END-DISPLAY\n           CALL \"pop\" USING\n             BY REFERENCE new-stack\n             BY REFERENCE node-info\n           END-CALL\n           DISPLAY node-info END-DISPLAY\n           CALL \"traverse-stack\" USING\n             BY REFERENCE new-stack\n           END-CALL\n         END-IF\n         GOBACK.\n       END PROGRAM traverse-stack.\n\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. stack-test.\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       COPY stack.\n       COPY stack REPLACING stack BY new-stack.\n       PROCEDURE DIVISION.\n         CALL \"push\" USING\n           BY REFERENCE stack\n           BY CONTENT \"daleth\"\n         END-CALL\n         CALL \"push\" USING\n           BY REFERENCE stack\n           BY CONTENT \"gimel\"\n         END-CALL\n         CALL \"push\" USING\n           BY REFERENCE stack\n           BY CONTENT \"beth\"\n         END-CALL\n         CALL \"push\" USING\n           BY REFERENCE stack\n           BY CONTENT \"aleph\"\n         END-CALL\n         CALL \"traverse-stack\" USING\n           BY REFERENCE stack\n         END-CALL\n         CALL \"reverse-stack\" USING\n           BY REFERENCE stack\n           BY REFERENCE new-stack\n         END-CALL\n         CALL \"traverse-stack\" USING\n           BY REFERENCE new-stack\n         END-CALL\n         STOP RUN.\n       END PROGRAM stack-test.\n\n       COPY stack-utilities.\n\n\nOutput:\naleph\naleph\nbeth\nbeth\nbeth\ngimel\ngimel\ngimel\ndaleth\ndaleth\ndaleth\ndaleth\ndaleth\ndaleth\ngimel\ngimel\ngimel\nbeth\nbeth\nbeth\naleph\naleph\naleph\n\n", "explain": "Based loosely on the C stack implementation in Evangel Quiwa's Data Structures.\nThis example (ab)uses the COPY procedure to ensure that there is a consistently-defined stack type, node type, node information type, p(redicate) type, and set of stack-utilities.\nstack.cbl\nnode.cbl\nnode-info.cbl\np.cbl\nstack-utilities.cbl\nstack-test.cbl\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\n\ngeneric\n   type Element_Type is private; \npackage Generic_Stack is\n   type Stack is private; \n   procedure Push (Item : Element_Type; Onto : in out Stack); \n   procedure Pop (Item : out Element_Type; From : in out Stack); \n   function Create return Stack;\n   Stack_Empty_Error : exception;\nprivate\n   type Node; \n   type Stack is access Node; \n   type Node is record \n      Element : Element_Type;  \n      Next    : Stack        := null;  \n   end record; \nend Generic_Stack;\n\nwith Ada.Unchecked_Deallocation;\n\npackage body Generic_Stack is\n   \n   ------------\n   -- Create --\n   ------------\n   \n   function Create return Stack is\n   begin\n      return (null);\n   end Create;\n\n   ----------\n   -- Push --\n   ----------\n\n   procedure Push(Item : Element_Type; Onto : in out Stack) is\n      Temp : Stack := new Node;\n   begin\n      Temp.Element := Item;\n      Temp.Next := Onto;\n      Onto := Temp; \n   end Push;\n\n   ---------\n   -- Pop --\n   ---------\n\n   procedure Pop(Item : out Element_Type; From : in out Stack) is\n      procedure Free is new Ada.Unchecked_Deallocation(Node, Stack);\n      Temp : Stack := From;\n   begin\n      if Temp = null then\n         raise Stack_Empty_Error;\n      end if;\n      Item := Temp.Element;\n      From := Temp.Next;\n      Free(Temp);\n   end Pop;\n\nend Generic_Stack;\n\n", "explain": "This is a generic stack implementation.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nstack = Int[]           # []\n@show push!(stack, 1)   # [1]\n@show push!(stack, 2)   # [1, 2]\n@show push!(stack, 3)   # [1, 2, 3]\n@show pop!(stack)       # 3\n@show length(stack)     # 2\n@show empty!(stack)     # []\n@show isempty(stack)    # true\n\n", "explain": "The built-in Array class already has efficient (linear amortized time) stack primitives.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\n\n// version 1.1.2\n\nclass Stack<E> {\n    private val data = mutableListOf<E>()\n\n    val size get() = data.size\n\n    val empty get() = size == 0\n\n    fun push(element: E) = data.add(element)\n\n    fun pop(): E {\n        if (empty) throw RuntimeException(\"Can't pop elements from an empty stack\")\n        return data.removeAt(data.lastIndex)\n    }\n\n    val top: E\n        get() {\n            if (empty) throw RuntimeException(\"Empty stack can't have a top element\")\n            return data.last()\n        }\n\n    fun clear() = data.clear()\n\n    override fun toString() = data.toString()\n}\n\nfun main(args: Array<String>) {\n    val s = Stack<Int>()\n    (1..5).forEach { s.push(it) }\n    println(s)\n    println(\"Size of stack = ${s.size}\")\n    print(\"Popping: \")\n    (1..3).forEach { print(\"${s.pop()} \") }\n    println(\"\\nRemaining on stack: $s\")\n    println(\"Top element is now ${s.top}\")\n    s.clear()\n    println(\"After clearing, stack is ${if(s.empty) \"empty\" else \"not empty\"}\")\n    try {\n        s.pop()\n    }\n    catch (e: Exception) {\n        println(e.message)\n    }\n}\n\n\nOutput:\n[1, 2, 3, 4, 5]\nSize of stack = 5\nPopping: 5 4 3\nRemaining on stack: [1, 2]\nTop element is now 2\nAfter clearing, stack is empty\nCan't pop elements from an empty stack\n\n", "explain": "Rather than use the java.util.Stack<E> class, we will write our own simple Stack<E> class for this task:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\nsub empty{ not @_ }\n\n", "explain": "Perl comes prepared to treat its arrays as stacks, giving us the push and pop functions for free. To add empty, we basically give a new name to \"not\":\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n\nNSMutableArray *stack = [NSMutableArray array]; // creating\n\n[stack addObject:value]; // pushing\n\nid value = [stack lastObject];\n[stack removeLastObject]; // popping\n\n[stack count] == 0 // is empty?\n\n", "explain": "Using a NSMutableArray:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\n% push( ELEMENT, STACK, NEW )\n% True if NEW is [ELEMENT|STACK]\npush(ELEMENT,STACK,[ELEMENT|STACK]).\n\n% pop( STACK, TOP, NEW )\n% True if TOP and NEW are head and tail, respectively, of STACK\npop([TOP|STACK],TOP,STACK).\n\n% empty( STACK )\n% True if STACK is empty\nempty([]).\n", "explain": "Prolog is a particularly silly language to implement stack functions in, as the built-in lists can be treated as stacks in an ad hoc manner. Nonetheless, in the name of completeness:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\n\nstack = {}\ntable.insert(stack,3)\nprint(table.remove(stack)) --> 3\n\n", "explain": "Tables have stack primitives by default:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\n\nclass Stack[T] {\n  private var items = List[T]()\n\n  def isEmpty = items.isEmpty\n\n  def peek = items match {\n    case List()       => error(\"Stack empty\")\n    case head\u00a0:: rest => head\n  }\n\n  def pop = items match {\n    case List()       => error(\"Stack empty\")\n    case head\u00a0:: rest => items = rest; head\n  }\n\n  def push(value: T) = items = value +: items\n}\n\nimport collection.mutable.{ Stack => Stak }\n\nclass Stack[T] extends Stak[T] {\n  override def pop: T = {\n    if (this.length == 0) error(\"Can't Pop from an empty Stack.\")\n    else super.pop\n  }\n  def peek: T = this.head\n}A test could be:object StackTest extends App {\n\n  val stack = new Stack[String]\n\n  stack.push(\"Peter Pan\")\n  stack.push(\"Suske & Wiske\", \"Alice in Wonderland\")\n\n  assert(stack.peek == \"Alice in Wonderland\")\n  assert(stack.pop() == \"Alice in Wonderland\")\n  assert(stack.pop() == \"Suske & Wiske\")\n  assert(stack.pop() == \"Peter Pan\")\n  println(\"Completed without errors\")\n}\n", "explain": "The Do it yourself approach:\nOr use the standard Scala library. \nSlightly modified to meet to requirements of this task.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\n\nimport std.array;\n\nclass Stack(T) {\n    private T[] items;\n\n    @property bool empty() { return items.empty(); }\n\n    void push(T top) { items ~= top; }\n\n    T pop() {\n        if (this.empty)\n            throw new Exception(\"Empty Stack.\");\n        auto top = items.back;\n        items.popBack();\n        return top;\n    }\n}\n\nvoid main() {\n    auto s = new Stack!int();\n    s.push(10);\n    s.push(20);\n    assert(s.pop() == 20);\n    assert(s.pop() == 10);\n    assert(s.empty());\n}\n\n", "explain": "Generic stack class implemented with a dynamic array.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\ntype Stack a = [a]\n\ncreate :: Stack a\ncreate = []\n\npush :: a -> Stack a -> Stack a\npush = (:)\n\npop :: Stack a -> (a, Stack a)\npop []     = error \"Stack empty\"\npop (x:xs) = (x,xs)\n\nempty :: Stack a -> Bool\nempty = null\n\npeek :: Stack a -> a\npeek []    = error \"Stack empty\"\npeek (x:_) = x\n\n\nimport Control.Monad.State\n\ntype Stack a b = State [a] b\n\npush :: a -> Stack a ()\npush = modify . (:)\n\npop :: Stack a a\npop = do\n    nonEmpty\n    x <- peek\n    modify tail\n    return x\n\nempty :: Stack a Bool\nempty = gets null\n\npeek :: Stack a a\npeek = nonEmpty >> gets head\n\nnonEmpty :: Stack a ()\nnonEmpty = empty >>= flip when (fail \"Stack empty\")\n\n", "explain": "The Haskell solution is trivial, using a list. Note that pop returns both the element and the changed stack, to remain purely functional.\nWe can make a stack that can be destructively popped by hiding the list inside a State monad.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\nStack class[edit]\nclass stack\n\tdim tos\n\tdim stack()\n\tdim stacksize\n\t\n\tprivate sub class_initialize\n\t\tstacksize = 100\n\t\tredim stack( stacksize )\n\t\ttos = 0\n\tend sub\n\n\tpublic sub push( x )\n\t\tstack(tos) = x\n\t\ttos = tos + 1\n\tend sub\n\t\n\tpublic property get stackempty\n\t\tstackempty = ( tos = 0 )\n\tend property\n\t\n\tpublic property get stackfull\n\t\tstackfull = ( tos > stacksize )\n\tend property\n\t\n\tpublic property get stackroom\n\t\tstackroom = stacksize - tos\n\tend property\n\t\n\tpublic function pop()\n\t\tpop = stack( tos - 1 )\n\t\ttos = tos - 1\n\tend function\n\n\tpublic sub resizestack( n )\n\t\tredim preserve stack( n )\n\t\tstacksize = n\n\t\tif tos > stacksize then\n\t\t\ttos = stacksize\n\t\tend if\n\tend sub\nend class\n\ndim s\nset s = new stack\ns.resizestack 10\nwscript.echo s.stackempty\ndim i\nfor i = 1 to 10\n\ts.push rnd\n\twscript.echo s.stackroom\n\tif s.stackroom = 0 then exit for\nnext\nfor i = 1 to 10\n\twscript.echo s.pop\n\tif s.stackempty then exit for\nnext\n\nOutput: (changes every time)\n-1\n9\n8\n7\n6\n5\n4\n3\n2\n1\n0\n0.7090379\n0.81449\n0.7607236\n1.401764E-02\n0.7747401\n0.301948\n0.2895625\n0.5795186\n0.533424\n0.7055475\nUsing an ArrayList.[edit]\n' Stack Definition - VBScript\n \nOption Explicit\n\nDim stack, i, x\nSet stack = CreateObject(\"System.Collections.ArrayList\")\nIf Not empty_(stack) Then Wscript.Echo stack.Count\npush stack, \"Banana\"\npush stack, \"Apple\"\npush stack, \"Pear\"\npush stack, \"Strawberry\"\nWscript.Echo \"Count=\" & stack.Count \t\t    ' --> Count=4\nWscript.Echo pop(stack) & \" - Count=\" & stack.Count ' --> Strawberry - Count=3\nWscript.Echo \"Tail=\" & stack.Item(0) \t\t    ' --> Tail=Banana\nWscript.Echo \"Head=\" & stack.Item(stack.Count-1)    ' --> Head=Pear\nWscript.Echo stack.IndexOf(\"Apple\", 0)   \t    ' --> 1\nFor i=1 To stack.Count\n\tWscript.Echo join(stack.ToArray(), \", \")\n\tx = pop(stack)\nNext 'i\n\nSub push(s, what)\n    s.Add what\nEnd Sub 'push\n \nFunction pop(s)\n\tDim what\n    If s.Count > 0 Then\n        what = s(s.Count-1)\n        s.RemoveAt s.Count-1\n    Else\n        what = \"\"\n    End If\n    pop = what\nEnd Function 'pop\n \nFunction empty_(s)\n    empty_ = s.Count = 0\nEnd Function 'empty_\n\nOutput:\nCount=4\nStrawberry - Count=3\nTail=Banana\nHead=Pear\n1\nBanana, Apple, Pear\nBanana, Apple\nBanana\n\n", "explain": ""}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n\n(define (make-stack)\n  (let ((st '()))\n    (lambda (message . args)\n      (case message\n        ((empty?) (null? st))\n        ((top) (if (null? st)\n                   'empty\n                   (car st)))\n        ((push) (set! st (cons (car args) st)))\n        ((pop) (if (null? st)\n                   'empty\n                   (let ((result (car st)))\n                     (set! st (cdr st))\n                     result)))\n        (else 'badmsg)))))\n", "explain": "This version uses primitive message passing.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\n\n$stack = New-Object -TypeName System.Collections.Stack\n# or\n$stack = [System.Collections.Stack] @()\n\n\n1, 2, 3, 4 | ForEach-Object {$stack.Push($_)}\n\n$stack -join \", \"\n\nOutput:\n4, 3, 2, 1\n\n\n$stack.Pop()\n\nOutput:\n4\n\n\n$stack -join \", \"\n\nOutput:\n3, 2, 1\n\n\n$stack.Peek()\n\nOutput:\n3\n\n\n$stack\n\nOutput:\n3\n2\n1\n\n", "explain": "A new stack:\nPush some stuff on the stack:\nShow stack as a string:\nPop the top level of the stack:\nShow stack as a string:\nGet a copy of the top level of the stack:\nThe stack:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\n\nmake \"stack []\npush \"stack 1\npush \"stack 2\npush \"stack 3\nprint pop \"stack  \u00a0; 3\nprint empty? :stack\u00a0; false\n", "explain": "UCB Logo has built-in methods for treating lists as stacks. Since they are destructive, they take the name of the stack rather than the list itself.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "ABAP", "code": "\n\nreport z_stack.\n\ninterface stack.\n  methods:\n    push\n      importing\n        new_element      type any\n      returning\n        value(new_stack) type ref to stack,\n\n    pop\n      exporting\n        top_element      type any\n      returning\n        value(new_stack) type ref to stack,\n\n    empty\n      returning\n        value(is_empty) type abap_bool,\n\n    peek\n      exporting\n        top_element type any,\n\n    get_size\n      returning\n        value(size) type int4,\n\n    stringify\n      returning\n        value(stringified_stack) type string.\nendinterface.\n\n\nclass character_stack definition.\n  public section.\n    interfaces:\n      stack.\n\n\n    methods:\n      constructor\n        importing\n          characters type string optional.\n\n\n  private section.\n    data:\n      characters type string.\nendclass.\n\n\nclass character_stack implementation.\n  method stack~push.\n    characters = |{ new_element }{ characters }|.\n\n    new_stack = me.\n  endmethod.\n\n\n  method stack~pop.\n    if not me->stack~empty( ).\n      top_element = me->characters(1).\n\n      me->characters = me->characters+1.\n    endif.\n\n    new_stack = me.\n  endmethod.\n\n\n  method stack~empty.\n    is_empty = xsdbool( strlen( me->characters ) eq 0 ).\n  endmethod.\n\n\n  method stack~peek.\n    check not me->stack~empty( ).\n\n    top_element = me->characters(1).\n  endmethod.\n\n\n  method stack~get_size.\n    size = strlen( me->characters ).\n  endmethod.\n\n\n  method stack~stringify.\n    stringified_stack = cond string(\n      when me->stack~empty( )\n      then `empty`\n      else me->characters ).\n  endmethod.\n\n\n  method constructor.\n    check characters is not initial.\n\n    me->characters = characters.\n  endmethod.\nendclass.\n\n\nclass integer_stack definition.\n  public section.\n    interfaces:\n      stack.\n\n\n    methods:\n      constructor\n        importing\n          integers type int4_table optional.\n\n\n  private section.\n    data:\n      integers type int4_table.\nendclass.\n\n\nclass integer_stack implementation.\n  method stack~push.\n    append new_element to me->integers.\n\n    new_stack = me.\n  endmethod.\n\n\n  method stack~pop.\n    if not me->stack~empty( ).\n      top_element = me->integers[ me->stack~get_size( ) ].\n\n      delete me->integers index me->stack~get_size( ).\n    endif.\n\n    new_stack = me.\n  endmethod.\n\n\n  method stack~empty.\n    is_empty = xsdbool( lines( me->integers ) eq 0 ).\n  endmethod.\n\n\n  method stack~peek.\n    check not me->stack~empty( ).\n\n    top_element = me->integers[ lines( me->integers ) ].\n  endmethod.\n\n\n  method stack~get_size.\n    size = lines( me->integers ).\n  endmethod.\n\n\n  method stack~stringify.\n    stringified_stack = cond string(\n      when me->stack~empty( )\n      then `empty`\n      else reduce string(\n        init stack = ``\n        for integer in me->integers\n        next stack = |{ integer }{ stack }| ) ).\n  endmethod.\n\n\n  method constructor.\n    check integers is not initial.\n\n    me->integers = integers.\n  endmethod.\nendclass.\n\n\nstart-of-selection.\n  data:\n    stack1        type ref to stack,\n    stack2        type ref to stack,\n    stack3        type ref to stack,\n\n    top_character type char1,\n    top_integer   type int4.\n\n  stack1 = new character_stack( ).\n  stack2 = new integer_stack( ).\n  stack3 = new integer_stack( ).\n\n  write: |Stack1 = { stack1->stringify( ) }|, /.\n  stack1->push( 'a' )->push( 'b' )->push( 'c' )->push( 'd' ).\n  write: |push a, push b, push c, push d -> Stack1 = { stack1->stringify( ) }|, /.\n  stack1->pop( )->pop( importing top_element = top_character ).\n  write: |pop, pop and return element -> { top_character }, Stack1 = { stack1->stringify( ) }|, /, /.\n\n  write: |Stack2 = { stack2->stringify( ) }|, /.\n  stack2->push( 1 )->push( 2 )->push( 3 )->push( 4 ).\n  write: |push 1, push 2, push 3, push 4 -> Stack2 = { stack2->stringify( ) }|, /.\n  stack2->pop( )->pop( importing top_element = top_integer ).\n  write: |pop, pop and return element -> { top_integer }, Stack2 = { stack2->stringify( ) }|, /, /.\n\n  write: |Stack3 = { stack3->stringify( ) }|, /.\n  stack3->pop( ).\n  write: |pop -> Stack3 = { stack3->stringify( ) }|, /, /.\n\n\nOutput:\nStack1 = empty\n\npush a, push b, push c, push d -> Stack1 = dcba\n\npop, pop and return element -> c, Stack1 = ba\n\n\nStack2 = empty\n\npush 1, push 2, push 3, push 4 -> Stack2 = 4321\n\npop, pop and return element -> 3, Stack2 = 21\n\n\nStack3 = empty\n\npop -> Stack3 = empty\n\n", "explain": "This works for ABAP Version 7.40 and above\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\n\ntype Stack<'a> //'//(workaround for syntax highlighting problem)\n  (?items) =\n  let items = defaultArg items []\n\n  member x.Push(A) = Stack(A::items)\n\n  member x.Pop() =\n    match items with\n      | x::xr ->  (x, Stack(xr))\n      | [] -> failwith \"Stack is empty.\"\n\n  member x.IsEmpty() = items = []\n\n// example usage\nlet anEmptyStack = Stack<int>()\nlet stack2 = anEmptyStack.Push(42)\nprintfn \"%A\" (stack2.IsEmpty())\nlet (x, stack3) = stack2.Pop()\nprintfn \"%d\" x\nprintfn \"%A\" (stack3.IsEmpty())\n\n", "explain": ".NET provides a mutable stack type in System.Collections.Generic.Stack.\nA list-based immutable stack type could be implemented like this:\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef stack = []\nassert stack.empty\n\nstack.push(55)\nstack.push(21)\nstack.push('kittens')\nassert stack.last() == 'kittens'\nassert stack.size() == 3\nassert ! stack.empty\n \nprintln stack\n\nassert stack.pop() == \"kittens\"\nassert stack.size() == 2\n\nprintln stack\n\nstack.push(-20)\n\nprintln stack\n\nstack.push( stack.pop() * stack.pop() )\nassert stack.last() == -420\nassert stack.size() == 2\n\nprintln stack\n\nstack.push(stack.pop() / stack.pop())\nassert stack.size() == 1\n\nprintln stack\n\nprintln stack.pop()\nassert stack.size() == 0\nassert stack.empty\n\ntry { stack.pop() } catch (NoSuchElementException e) { println e.message }\n\n\nOutput:\n[55, 21, kittens]\n[55, 21]\n[55, 21, -20]\n[55, -420]\n[-7.6363636364]\n-7.6363636364\nCannot pop() an empty List\n", "explain": "In Groovy, all lists have stack semantics, including \"push()\" and \"pop()\" methods, an \"empty\" property, and a \"last()\" method as a stand-in for \"top/peek\" semantics. Calling \"pop()\" on an empty list throws an exception.\nOf course, these stack semantics are not exclusive. Elements of the list can still be accessed and manipulated in myriads of other ways.\n"}, {"task_name": "Stack", "task_url": "https://rosettacode.org/wiki/Stack", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\nfunction deque(arr) {\n    arr[\"start\"] = 0\n    arr[\"end\"] = 0\n}\n\nfunction dequelen(arr) {\n    return arr[\"end\"] - arr[\"start\"]\n}\n\nfunction empty(arr) {\n    return dequelen(arr) == 0\n}\n\nfunction push(arr, elem) {\n    arr[++arr[\"end\"]] = elem\n}\n\nfunction pop(arr) {\n    if (empty(arr)) {\n        return\n    }\n    return arr[arr[\"end\"]--]\n}\n\nfunction unshift(arr, elem) {\n    arr[arr[\"start\"]--] = elem\n}\n\nfunction shift(arr) {\n    if (empty(arr)) {\n        return\n    }\n    return arr[++arr[\"start\"]]\n}\n\nfunction peek(arr) {\n    if (empty(arr)) {\n        return\n    }\n    return arr[arr[\"end\"]]\n}\n\nfunction printdeque(arr,    i, sep) {\n    printf(\"[\")\n    for (i = arr[\"start\"] + 1; i <= arr[\"end\"]; i++) {\n        printf(\"%s%s\", sep, arr[i])\n        sep = \", \"\n    }\n    printf(\"]\\n\")\n}\n\nBEGIN {\n    deque(q)\n    for (i = 1; i <= 10; i++) {\n        push(q, i)\n    }\n    printdeque(q)\n    for (i = 1; i <= 10; i++) {\n        print pop(q)\n    }\n    printdeque(q)\n}\n\n", "explain": ""}]