[{"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Python", "code": "\nFunctional[edit]\n\n>>> def luhn(n):\n\tr = [int(ch) for ch in str(n)][::-1]\n\treturn (sum(r[0::2]) + sum(sum(divmod(d*2,10)) for d in r[1::2]))\u00a0% 10 == 0\n\n>>> for n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n\tprint(n, luhn(n))\n\nOutput:\n49927398716 True\n49927398717 False\n1234567812345678 False\n1234567812345670 True\n\nWorks with: Python version 3.7\n'''Luhn test of credit card numbers'''\n\nfrom operator import add, mul\nfrom functools import reduce\nfrom itertools import cycle\n\n\n# luhn\u00a0:: Integer -> Bool\ndef luhn(n):\n    '''True if n is a valid Luhn credit card number.'''\n    def divMod10Sum(a, x):\n        return a + add(*divmod(x, 10))\n    return 0 == reduce(\n        divMod10Sum,\n        map(\n            mul,\n            cycle([1, 2]),\n            map(int, reversed(str(n)))\n        ),\n        0\n    )\u00a0% 10\n\n\n# ---------------------------TEST---------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Tests'''\n    print(list(\n        map(luhn, [\n            49927398716, 49927398717,\n            1234567812345678, 1234567812345670\n        ])\n    ))\n\n\nif __name__ == '__main__':\n    main()\n\nOutput:\n[True, False, False, True]\n\n'''Luhn test of credit card numbers'''\n\nfrom itertools import cycle\n\n\n# luhn\u00a0:: String -> Bool\ndef luhn(k):\n    '''True if k is a valid Luhn credit card number string\n    '''\n    def asDigits(s):\n        return (int(c) for c in s)\n\n    return 0 == sum(map(\n        lambda f, x: f(x),\n        cycle([\n            lambda n: n,\n            lambda n: sum(asDigits(str(2 * n)))\n        ]),\n        asDigits(reversed(k))\n    ))\u00a0% 10\n\n\n# ------------------------- TEST -------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Tests'''\n    print('\\n'.join([\n        repr((x, luhn(x))) for x in [\n            \"49927398716\",\n            \"49927398717\",\n            \"1234567812345678\",\n            \"1234567812345670\"\n        ]\n    ]))\n\n\nif __name__ == '__main__':\n    main()\n\nOutput:\n('49927398716', True)\n('49927398717', False)\n('1234567812345678', False)\n('1234567812345670', True)\nProcedural[edit]\n\n>>> def v\u00e9rifLuhn(ch):\n  sum = 0\n  chParity = len(ch)\u00a0% 2\n  for i in range (len(ch)-1, -1, -1):\n    j = int(ch[i])\n    if ((i + 1)\u00a0% 2\u00a0!= chParity):\n      j = j * 2 \n    if (j > 9):\n      j = j - 9 \n    sum = sum + j\n  print(\"value calculated = \", str(sum))\n  return sum\u00a0% 10 == 0         \n   \nfor n in (49927398716, 49927398717, 1234567812345678, 1234567812345670):\n        print (str(n)+\" =>\", v\u00e9rifLuhn(str(n)))\n", "explain": "The divmod in the function below conveniently splits a number into its two digits ready for summing:\nOr, using itertools cycle with map and reduce:\nOr alternatively, we can prune out some of the imports, define the Luhn predicate over strings rather than integers,\nand cycle lambdas rather than integers.\nWithout usingsum() and divmod() functions:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "C", "code": "\n#include <string.h>\n#include <stdio.h>\n\nint luhn(const char* cc)\n{\n\tconst int m[] = {0,2,4,6,8,1,3,5,7,9}; // mapping for rule 3\n\tint i, odd = 1, sum = 0;\n\n\tfor (i = strlen(cc); i--; odd = !odd) {\n\t\tint digit = cc[i] - '0';\n\t\tsum += odd ? digit : m[digit];\n\t}\n\n\treturn sum % 10 == 0;\n}\n\nint main()\n{\n\tconst char* cc[] = {\n\t\t\"49927398716\",\n\t\t\"49927398717\",\n\t\t\"1234567812345678\",\n\t\t\"1234567812345670\",\n\t\t0\n\t};\n\tint i;\n\n\tfor (i = 0; cc[i]; i++)\n\t\tprintf(\"%16s\\t%s\\n\", cc[i], luhn(cc[i]) ? \"ok\" : \"not ok\");\n\n\treturn 0;\n}\n\nOutput:\n     49927398716        ok\n     49927398717        not ok\n1234567812345678        not ok\n1234567812345670        ok\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "C++", "code": "\n#include <iostream>\nusing namespace std;\n\nint toInt(const char c)\n{\n    return c-'0';\n}\n\nint confirm( const char *id)\n{\n    bool is_odd_dgt = true;\n    int s = 0;\n    const char *cp;\n\n    for(cp=id; *cp; cp++);\n    while(cp > id) {\n        --cp;\n        int k = toInt(*cp);\n        if (is_odd_dgt) {\n            s += k;\n        }\n        else {\n            s += (k!=9)? (2*k)%9 : 9;\n        }\n\tis_odd_dgt = !is_odd_dgt;\n    }\n    return 0 == s%10;\n}\n\nint main( )\n{\n    const char * t_cases[] = {\n        \"49927398716\",\n        \"49927398717\",\n        \"1234567812345678\",\n        \"1234567812345670\",\n        NULL,\n    };\n    for ( const char **cp = t_cases; *cp; cp++) {\n        cout << *cp << \": \" << confirm(*cp) << endl;\n    }\n    return 0;\n}\n\nC++11[edit]\n#include <iostream>\n#include <vector>\n#include <algorithm>\nusing namespace std;\n\nbool luhn( const string& id)\n{\n  static const int m[10]  = {0,2,4,6,8,1,3,5,7,9}; // mapping for rule 3\n  bool is_odd_dgt = false;\n  auto lambda = [&](int a, char c) {return a + ((is_odd_dgt = !is_odd_dgt) ? c-'0' : m[c-'0']);};\n  int s = std::accumulate(id.rbegin(), id.rend(), 0, lambda);\n  return 0 == s%10;\n}\n\nint main( )\n{\n  auto t_cases = {\"49927398716\", \"49927398717\", \"1234567812345678\", \"1234567812345670\"};\n  auto print = [](const string & s) {cout << s << \": \" << luhn(s) << endl;};\n  for_each(t_cases.begin(), t_cases.end(), print);\n  return 0;\n}\n\n\n#include <iostream>\n#include <type_traits>\n\ntemplate<size_t I, int... Args>\nstruct find_impl;\n\ntemplate<int A, int... Args>\nstruct find_impl<0, A, Args...> {\n    using type = std::integral_constant<int, A>;\n};\n\ntemplate<int A, int B, int... Args>\nstruct find_impl<0, A, B, Args...> {\n    using type = std::integral_constant<int, A>;\n};\n\ntemplate<size_t I, int A, int B, int... Args>\nstruct find_impl<I, A, B, Args...> {\n    using type = typename find_impl<I-1, B, Args...>::type;\n};\n\nnamespace detail {\ntemplate<typename, typename>\nstruct append_sequence\n{};\n\ntemplate<typename T, typename... Ts>\nstruct append_sequence<T, std::tuple<Ts...>> {\n    using type = std::tuple<Ts..., T>;\n};\n\ntemplate<typename... Ts>\nstruct reverse_sequence {\n    using type = std::tuple<>;\n};\n\ntemplate<typename T, typename... Ts>\nstruct reverse_sequence<T, Ts...> {\n    using type = typename append_sequence<\n                            T,\n                            typename reverse_sequence<Ts...>::type\n                        >::type;\n};\n}\n\ntemplate<size_t I>\nusing rule3 = typename find_impl<I, 0, 2, 4, 6, 8, 1, 3, 5, 7, 9>::type;\n\ntemplate<int A, char C, bool dgt>\nstruct calc\n    : std::integral_constant<int, A + C - '0'>\n{};\n\ntemplate<int A, char C>\nstruct calc<A, C, false>\n    : std::integral_constant<int, A + rule3<C - '0'>::type::value>\n{};\n\ntemplate<typename Acc, bool Dgt, char...>\nstruct luhn_impl;\n\ntemplate<typename Acc, bool Dgt, char A, char... Args>\nstruct luhn_impl<Acc, Dgt, A, Args...> {\n    using type = typename calc<Acc::value, A, Dgt>::type;\n};\n\ntemplate<typename Acc, bool Dgt, char A, char B, char... Args>\nstruct luhn_impl<Acc, Dgt, A, B, Args...> {\n    using type =\n        typename luhn_impl<typename calc<Acc::value, A, Dgt>::type, !Dgt, B, Args...>::type;\n};\n\ntemplate<typename>\nstruct luhn;\n\ntemplate<typename... Args>\nstruct luhn<std::tuple<Args...>> {\n    using type = typename luhn_impl<std::integral_constant<int, 0>, true, Args::value...>::type;\n    constexpr static bool result = (type::value % 10) == 0;\n};\n\ntemplate<char... Args>\nbool operator \"\" _luhn() {\n    return luhn<typename detail::reverse_sequence<std::integral_constant<char, Args>...>::type>::result;\n}\n\nint main() {\n    std::cout << std::boolalpha;\n    std::cout << 49927398716_luhn << std::endl;\n    std::cout << 49927398717_luhn << std::endl;\n    std::cout << 1234567812345678_luhn << std::endl;\n    std::cout << 1234567812345670_luhn << std::endl;\n    return 0;\n}\n\ntrue\nfalse\nfalse\ntrue\n\n", "explain": "It is also possible to achieve a compile-time version using metaprogramming.\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Java", "code": "\npublic class Luhn {\n    public static void main(String[] args) {\n        System.out.println(luhnTest(\"49927398716\"));\n        System.out.println(luhnTest(\"49927398717\"));\n        System.out.println(luhnTest(\"1234567812345678\"));\n        System.out.println(luhnTest(\"1234567812345670\"));\n    }\n    \n    public static boolean luhnTest(String number){\n        int s1 = 0, s2 = 0;\n        String reverse = new StringBuffer(number).reverse().toString();\n        for(int i = 0 ;i < reverse.length();i++){\n            int digit = Character.digit(reverse.charAt(i), 10);\n            if(i % 2 == 0){//this is for odd digits, they are 1-indexed in the algorithm\n                s1 += digit;\n            }else{//add 2 * digit for 0-4, add 2 * digit - 9 for 5-9\n                s2 += 2 * digit;\n                if(digit >= 5){\n                    s2 -= 9;\n                }\n            }\n        }\n        return (s1 + s2) % 10 == 0;\n    }\n}\n\n\nOutput:\ntrue\nfalse\nfalse\ntrue\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "C#", "code": "\n\n    public static class Luhn\n    {\n        public static bool LuhnCheck(this string cardNumber)\n        {\n            return LuhnCheck(cardNumber.Select(c => c - '0').ToArray());\n        }\n\n        private static bool LuhnCheck(this int[] digits)\n        {\n            return GetCheckValue(digits) == 0;\n        }\n\n        private static int GetCheckValue(int[] digits)\n        {\n            return digits.Select((d, i) => i % 2 == digits.Length % 2 ? ((2 * d) % 10) + d / 5 : d).Sum() % 10;\n        }\n    }\n\n    public static class TestProgram\n    {\n        public static void Main()\n        {\n            long[] testNumbers = {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (var testNumber in testNumbers)\n                Console.WriteLine(\"{0} is {1}valid\", testNumber, testNumber.ToString().LuhnCheck() ? \"\" : \"not \");\n        }\n    }\n\n49927398716 is valid\n49927398717 is not valid\n1234567812345678 is not valid\n1234567812345670 is valid\n\n\nusing System;\nusing System.Linq;\n\nnamespace Luhn\n{\n    class Program\n    {\n        public static bool luhn(long n)\n        {\n            long nextdigit, sum = 0;            \n            bool alt = false;            \n            while (n != 0)\n            {                \n                nextdigit = n % 10;\n                if (alt)\n                {\n                    nextdigit *= 2;\n                    nextdigit -= (nextdigit > 9) ? 9 : 0;\n                }\n                sum += nextdigit;\n                alt = !alt;\n                n /= 10;\n            }\n            return (sum % 10 == 0);\n        }\n\n        public static bool luhnLinq(long n)\n        {\n            string s = n.ToString();\n            return s.Select((c, i) => (c - '0') << ((s.Length - i - 1) & 1)).Sum(n => n > 9 ? n - 9 : n) % 10 == 0;\n        }\n\n        static void Main(string[] args)\n        {            \n            long[] given = new long[] {49927398716, 49927398717, 1234567812345678, 1234567812345670};\n            foreach (long num in given)\n            {\n                string valid = (luhn(num)) ? \" is valid\" : \" is not valid\";\n                Console.WriteLine(num + valid);\n            }\n            \n        }\n    }\n}\n\n49927398716 is valid\n49927398717 is not valid\n1234567812345678 is not valid\n1234567812345670 is valid\n\n\nusing System;\nnamespace Luhn_Test\n{\n\tpublic static class Extensions \n\t{\n\t\tpublic static string Reverse(this string s )\n\t\t{\n\t\t    char[] charArray = s.ToCharArray();\n\t\t    Array.Reverse( charArray );\n\t\t    return new string( charArray );\n\t\t}\n\t}\n\tclass Program\n\t{\n\t\tpublic static bool Luhn(long x)\n\t\t{\n\t\t\tlong s1=0;\n\t\t\tlong s2=0;\n\t\t\tbool STATE=x%10!=0; // If it ends with zero, we want the order to be the other way around\n\t\t\tx=long.Parse(x.ToString().Reverse());\n\t\t\twhile (x!=0)\n\t\t\t{\n\t\t\t\ts1+=STATE?x%10:0;\n\t\t\t\ts2+=STATE?0:((x%10)*2>9)?(((x%10)*2/10)+((x%10)*2)%10):((x%10)*2); \n\t\t\t\tSTATE=!STATE; //Switch state\n\t\t\t\tx/=10; //Cut the last digit and continue\n\t\t\t}\n\t\t\treturn ((s1+s2)%10==0); //Check if it ends with zero, if so, return true, otherwise,false.\n\t\t}\n\t\tpublic static void Main(string[] args)\n\t\t{\n\t\t\tlong[] ks = {1234567812345670, 49927398717, 1234567812345678 ,1234567812345670 };\n\t\t\tforeach (long k in ks)\n\t\t\t{\n\t\t\tConsole.WriteLine(\"{0} is {1} Valid.\",k,Luhn(k)?\"\":\"Not\");\t\n\t\t\t}\n\t\tStart:\n\t\t\ttry { \n\t\t\tConsole.WriteLine(\"Enter your credit:\");\n\t\t\tlong x=long.Parse(Console.ReadLine());\n\t\t\tConsole.WriteLine(\"{0} Valid.\",Luhn(x)?\"\":\"Not\");\n\t\t\tgoto Start;\n\t\t\t}\n\t\t\tcatch (FormatException)\n\t\t\t{\n\t\t\t\tgoto Start;\n\t\t\t}\t\t\t\n\t\t}\n\t}\n}\n\n1234567812345670 is Valid.\n49927398717 is Not Valid.\n1234567812345678 is Not Valid.\n49927398716 is Valid.\n\n\nusing System;\nusing System.Linq;\n\npublic class CreditCardLogic\n{\n    static Func<char, int> charToInt = c => c - '0';\n\n    static Func<int, int> doubleDigit = n => (n * 2).ToString().Select(charToInt).Sum();\n\n    static Func<int, bool> isOddIndex = index => index % 2 == 0;\n\n    public static bool LuhnCheck(string creditCardNumber)\n    {\n        var checkSum = creditCardNumber\n            .Select(charToInt)\n            .Reverse()\n            .Select((digit, index) => isOddIndex(index) ? digit : doubleDigit(digit))\n            .Sum();\n\n        return checkSum % 10 == 0;\n    }\n}\n\n\nusing System;\nusing EuropaRTL.Utilities;\n\npublic static partial class Algoritmhs\n{\n    public static bool CheckLuhn(long n)\n    {\n        int s1 = n.Shatter(true).Subset(2).Arithmetic('+');\n        int s2 = n.Shatter(true).Subset(1, -1, 2).ArithmeticRA('*', 2).ShatterAndSum().Arithmetic('+');\n        return (s1 + s2) % 10 == 0 ? true : false;\n    }\n}\nclass Program\n{\n    static void Main(string[] args)\n    {\n        long[] ll = {\n                49927398716,\n                49927398717,\n                1234567812345678,\n                1234567812345670\n            };\n        foreach (var item in ll)\n        {\n            item.ToString().WriteLine();\n            Algoritmhs.CheckLuhn(item).ToString().WriteLine();\n        }\n        Console.ReadKey();\n    }\n}\n\n49927398716\nTrue\n49927398717\nFalse\n1234567812345678\nFalse\n1234567812345670\nFalse\n\n", "explain": "The LuhnCheck method takes an array of integers because values in memory will be integer-aligned.\nNote that the original implementation, which follows, is flawed because it assumes that n is a number which, when represented as a string, has an even number of characters. Granted, the brief is for Credit Card Numbers which are all, at the time of writing, an even number of digits.\nA solution without using LINQ, works for all versions of .NET.\nA solution optimized for readability:\nExtremely compact version uses Europa rtl library https://github.com/CodeAlkemist/Europa-rtl\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "JavaScript", "code": "\n\nmod10check = function(cc) {\n  return $A(cc).reverse().map(Number).inject(0, function(s, d, i) {\n    return s + (i % 2 == 1 ? (d == 9 ? 9 : (d * 2) % 9) : d);\n  }) % 10 == 0;\n};\n['49927398716','49927398717','1234567812345678','1234567812345670'].each(function(i){alert(mod10check(i))});\n\n\nvar LuhnCheck = (function()\n{\n\tvar luhnArr = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9];\n\treturn function(str)\n\t{\n\t\tvar counter = 0;\n\t\tvar incNum;\n\t\tvar odd = false;\n\t\tvar temp = String(str).replace(/[^\\d]/g, \"\");\n\t\tif ( temp.length == 0)\n\t\t\treturn false;\n\t\tfor (var i = temp.length-1; i >= 0; --i)\n\t\t{\n\t\t\tincNum = parseInt(temp.charAt(i), 10);\n\t\t\tcounter += (odd = !odd)? incNum : luhnArr[incNum];\n\t\t}\n\t\treturn (counter%10 == 0);\n\t}\n})();\n\n\nvar luhn10 = function(a,b,c,d,e) {\n  for(d = +a[b = a.length-1], e=0; b--;)\n    c = +a[b], d += ++e % 2 ? 2 * c % 10 + (c > 4) : c;\n  return !(d%10)\n};\n\n// returns true\nluhn10('4111111111111111') \n\n// returns false\nluhn10('4111111111111112')\n\n\nconst lunhCheck = (str) => {\n    const sumDigit = (c) => (c < 10) ? c :\n              sumDigit( Math.trunc(c / 10) + (c % 10));\n    \n    return str.split('').reverse()\n              .map(Number)\n              .map((c, i) => i % 2 !== 0 ? sumDigit(c * 2) : c)\n              .reduce((acc,v) => acc + v) % 10 === 0;\n};\n\nlunhCheck('49927398716'); // returns true\nlunhCheck('49927398717'); // returns false\nlunhCheck('1234567812345678'); // returns false\nlunhCheck('1234567812345670'); // returns true\n\n", "explain": "Using prototype.\nWithout any library.\nHighly compressed version.\nNaive implementation\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Visual_Basic_.NET", "code": "\n    Imports System.Linq\n    Function ValidLuhn(value As String)\n        Return value.Select(Function(c, i) (AscW(c) - 48) << ((value.Length - i - 1) And 1)).Sum(Function(n) If(n > 9, n - 9, n)) Mod 10 = 0\n    End Function\n    Sub Main()\n        Console.WriteLine(ValidLuhn(\"49927398716\"))\n        Console.WriteLine(ValidLuhn(\"49927398717\"))\n        Console.WriteLine(ValidLuhn(\"1234567812345678\"))\n        Console.WriteLine(ValidLuhn(\"1234567812345670\"))\n    End Sub\n\nOutput:\nTrue\nFalse\nFalse\nTrue\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "PHP", "code": "\nTranslation of: C\n$numbers = \"49927398716 49927398717 1234567812345678 1234567812345670\";\nforeach (split(' ', $numbers) as $n)\n    echo \"$n is \", luhnTest($n) ? 'valid' : 'not valid', '</br>';\n\nfunction luhnTest($num) {\n    $len = strlen($num);\n    for ($i = $len-1; $i >= 0; $i--) {\n        $ord = ord($num[$i]);\n        if (($len - 1) & $i) {\n            $sum += $ord;\n        } else {\n            $sum += $ord / 5 + (2 * $ord) % 10;\n        }\n    }       \n    return $sum % 10 == 0;\n}\n\n\nOutput:\n49927398716 is valid\n49927398717 is not valid\n1234567812345678 is not valid\n1234567812345670 is valid\n\nfunction luhn_test($num) {\n    $str = '';\n    foreach( array_reverse( str_split( $num ) ) as $i => $c ) $str .= ($i % 2 ? $c * 2 : $c );\n    return array_sum( str_split($str) ) % 10 == 0;\n}\n\nforeach (array('49927398716','49927398717','1234567812345678','1234567812345670') as $n)\n    echo \"$n is \", luhn_test($n) ? 'valid' : 'not valid', \"</br>\\n\";\n\n\nOutput:\n49927398716 is valid\n49927398717 is not valid\n1234567812345678 is not valid\n1234567812345670 is valid\n\n", "explain": "And a more concise example using PHP core methods:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "MATLAB", "code": "\n\nfunction passed = luhn(num)\nif nargin == 0 % evaluate test cases\n  testnum = [49927398716 49927398717 1234567812345678 1234567812345670];\n  for num = testnum\n    disp([int2str(num) ': ' int2str(luhn(num))])\n  end\n  return  \nend\n% luhn function starts here\nd = int2str(num) - '0';\t% convert number into vector of digits\nm = [2:2:8,1:2:9];\t% rule 3: maps 1:9 to [2 4 6 8 1 3 5 7 9]\npassed = ~mod(sum(d(end:-2:1)) + sum(m(d(end-1:-2:1))), 10);  \nend\n\n\nOutput:\n49927398716: 1\n49927398717: 0\n1234567812345678: 0\n1234567812345670: 1\n", "explain": "The solution is basically the same as for Octave. \n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Fortran", "code": "\nprogram luhn\n  implicit none\n  integer              :: nargs\n  character(len=20)    :: arg\n  integer              :: alen, i, dr\n  integer, allocatable :: number(:)\n  integer, parameter   :: drmap(0:9) = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n\n  ! Get number\n  nargs = command_argument_count()\n  if (nargs /= 1) then\n     stop\n  end if\n  call get_command_argument(1, arg, alen)\n  allocate(number(alen))\n  do i=1, alen\n     number(alen-i+1) = iachar(arg(i:i)) - iachar('0')\n  end do\n\n  ! Calculate number\n  dr = 0\n  do i=1, alen\n     dr = dr + merge(drmap(number(i)), number(i), mod(i,2) == 0)\n  end do\n\n  if (mod(dr,10) == 0) then\n     write(*,'(a,i0)') arg(1:alen)//' is valid'\n  else\n     write(*,'(a,i0)') arg(1:alen)//' is not valid'\n  end if\nend program luhn\n\n! Results:\n! 49927398716 is valid\n! 49927398717 is not valid\n! 1234567812345678 is not valid\n! 1234567812345670 is valid\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nconst input = `49927398716\n49927398717\n1234567812345678\n1234567812345670`\n\nvar t = [...]int{0, 2, 4, 6, 8, 1, 3, 5, 7, 9}\n\nfunc luhn(s string) bool {\n    odd := len(s) & 1\n    var sum int\n    for i, c := range s {\n        if c < '0' || c > '9' {\n            return false\n        }\n        if i&1 == odd {\n            sum += t[c-'0']\n        } else {\n            sum += int(c - '0')\n        }\n    }\n    return sum%10 == 0\n}\n\nfunc main() {\n    for _, s := range strings.Split(input, \"\\n\") {\n        fmt.Println(s, luhn(s))\n    }\n}\n\n\nOutput:\n49927398716 true\n49927398717 false\n1234567812345678 false\n1234567812345670 true\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "ARM_Assembly", "code": "\n.text\n.global _start\n_start:\n    ldr r0, =example_numbers\n    bl test_number\n\n    add r1, r0, #1\n    bl length\n    add r0, r1, r0\n    bl test_number\n    \n    add r1, r0, #1\n    bl length\n    add r0, r1, r0\n    bl test_number\n    \n    add r1, r0, #1\n    bl length\n    add r0, r1, r0\n    bl test_number\n\n    mov r0, #0\n    mov r7, #1\n    swi 0\n\ntest_number:\n    push {r0, lr}\n    bl print_string\n\n    bl luhn_test\n    cmp r0, #1\n    ldreq r0, =valid_message\n    ldrne r0, =invalid_message\n    bl print_string\n    pop {r0, lr}\n    mov pc, lr\n\n\n\nprint_string:\n    push {r0-r7, lr}\n    mov r1, r0   @ string to print\n    bl length\n    mov r2, r0   @ length of string\n    mov r0, #1   @ write to stdout\n    mov r7, #4   @ SYS_WRITE\n    swi 0        @ call system interupt\n    pop {r0-r7, lr}\n    mov pc, lr\n\n@ r0 address of credit card number string\n@ returns result in r0\nluhn_test:\n    push {r1-r7, lr}\n    mov r1, r0\n    bl isNumerical            @ check if string is a number\n    cmp r0, #1\n    bne .luhn_test_end        @ exit if not number\n    mov r0, r1 \n    ldr r1, =reversed_string  @ address to store reversed string\n    bl reverse                @ reverse string\n    push {r0}\n    bl length   @ get length of string\n    mov r4, r0  @ store string length in r4 \n    pop {r0}\n    mov r2, #0  @ string index\n    mov r6, #0  @ sum of odd digits\n    mov r7, #0  @ sum of even digits\n    .loadNext:\n        ldrb r3, [r1, r2]         @ load byte into r3\n        sub r3, #'0'              @ convert letter to digit\n        and r5, r2, #1            @ test if index is even or odd\n        cmp r5, #0\n        beq .odd_digit\n        bne .even_digit\n        .odd_digit:\n            add r6, r3              @ add digit to sum if odd\n            b .continue             @ skip next step\n        .even_digit:\n            lsl r3, #1              @ multiply digit by 2\n            cmp r3, #10             @ sum digits\n            subge r3, #10           @ get digit in 1s place\n            addge r3, #1            @ add 1 for the 10s place\n            add r7, r3              @ add digit sum to the total\n            \n        .continue: \n        add r2, #1                @ increment digit index\n        cmp r2, r4                @ check if at end of string\n        blt .loadNext\n\n    add r0, r6, r7                @ add even and odd sum\n    mov r3, r0                    @ copy sum to r3\n    ldr r1, =429496730            @ (2^32-1)/10\n    sub r0, r0, r0, lsr #30       @ divide by 10\n    umull r2, r0, r1, r0\n    mov r1, #10\n    mul r0, r1                    @ multiply the r0 by 10 to see if divisible\n    cmp r0, r3                    @ compare with the original value in r3\n    .luhn_test_end:\n    movne r0, #0                  @ return false if invalid card number\n    moveq r0, #1                  @ return true if valid card number\n    pop {r1-r7, lr}\n    mov pc, lr\n    \nlength:\n    push {r1-r2, lr}\n    mov r2, r0              @ start of string address\n    .loop:\n        ldrb r1, [r2], #1   @ load byte from address r2 and increment\n        cmp r1, #0          @ check for end of string\n        bne .loop           @ load next byte if not 0\n    sub r0, r2, r0          @ subtract end of string address from start\n    sub r0, #1              @ end of line from count\n    pop {r1-r2, lr}\n    mov pc, lr\n\n@ reverses a string\n@ r0 address of string to reverse\n@ r1 address to store reversed string\nreverse:\n    push {r0-r5, lr}\n    push {r0, lr}\n    bl length                @ get length of string to reverse\n    mov r3, r0               @ backword index\n    pop {r0, lr}\n    mov r4, #0               @ fowrard index\n    .reverse_next:\n        sub r3, #1           @ decrement backword index\n        ldrb r5, [r0, r3]    @ load byte from original string at index\n        strb r5, [r1, r4]    @ copy byte to reversed string\n        add r4, #1           @ increment fowrard index\n        cmp r3, #0           @ check if any characters are left\n        bge .reverse_next\n\n    mov r5, #0\n    strb r5, [r1, r4]  @ write null byte to terminate reversed string\n    pop {r0-r5, lr}\n    mov pc, lr\n\nisNumerical:\n    push {r1, lr}\n    .isNumerical_checkNext:\n        ldrb r1, [r0], #1\n        cmp r1, #0\n        beq .isNumerical_true\n        cmp r1, #'0'\n        blt .isNumerical_false\n        cmp r1, #'9'\n        bgt .isNumerical_false\n        b .isNumerical_checkNext\n    .isNumerical_false:\n        mov r0, #0\n        b .isNumerical_end\n    .isNumerical_true:\n        mov r0, #1\n    .isNumerical_end:\n    pop {r1, lr}\n    mov pc, lr\n\n\n.data\nvalid_message:\n    .asciz \" valid card number\\n\"\ninvalid_message:\n    .asciz \" invalid card number\\n\"\n\nreversed_string:\n    .space 32\n\nexample_numbers:\n    .asciz \"49927398716\"\n    .asciz \"49927398717\"\n    .asciz \"1234567812345678\"\n    .asciz \"1234567812345670\"\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\n{Test data arrays}\n\nconst Num1: array [0..10] of byte = (4,9,9,2,7,3,9,8,7,1,6);\nconst Num2: array [0..10] of byte = (4,9,9,2,7,3,9,8,7,1,7);\nconst Num3: array [0..15] of byte = (1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,8);\nconst Num4: array [0..15] of byte = (1,2,3,4,5,6,7,8,1,2,3,4,5,6,7,0);\n\n{Simplifies cases where we have to sum a two digit number}\n\nconst DigitSum: array [0..18] of byte = (0,1,2,3,4,5,6,7,8,9,1,2,3,4,5,6,7,8,9);\n\nfunction ValidateCreditCard(CardNum: array of byte): boolean;\n{Validate a Credit Card number}\nvar I,J,Len,Sum,Sum1,Sum2: integer;\nvar Rev: array of byte;\nbegin\nSum1:=0; Sum2:=0;\nLen:=High(CardNum);\nfor I:=Len downto 0 do\n if ((I-Len) and 1)=0 then Sum1:=Sum1 + CardNum[I]\n else Sum2:=Sum2 + DigitSum[CardNum[I]*2];\nSum:=Sum1+Sum2;\nResult:=(Sum mod 10)=0;\nend;\n\n\nfunction CardNumberToStr(CardNum: array of byte): string;\n{Convert card number to a string}\nvar I: integer;\nbegin\nResult:='';\nfor I:=0 to High(CardNum) do\nResult:=Result+IntToStr(CardNum[I]);\nend;\n\n\nprocedure TestDisplayNumber(Memo: TMemo; Num: array of byte);\n{Test a credit card number and display results}\nvar S: string;\nbegin\nS:=CardNumberToStr(Num);\nif ValidateCreditCard(Num) then S:=S+': Valid'\nelse S:=S+': Not Valid';\nMemo.Lines.Add(S);\nend;\n\n\nprocedure TestCreditCardNums(Memo: TMemo);\n{Test all credit card numbers}\nbegin\nTestDisplayNumber(Memo,Num1);\nTestDisplayNumber(Memo,Num2);\nTestDisplayNumber(Memo,Num3);\nTestDisplayNumber(Memo,Num4);\nend;\n\n\nOutput:\n49927398716: Valid\n49927398717: Not Valid\n1234567812345678: Not Valid\n1234567812345670: Valid\n\n\n\n", "explain": "Uses an array to handle the situation where multiply a term by 2, creates a two digit number. The array automatically handles adding each digit of the resulting two digit number. Also, avoids reversing the number by traversing the array backwards\n\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Ruby", "code": "\n def luhn_valid?(str)\n   str.scan(/\\d/).reverse            #using str.to_i.digits fails for cases with leading zeros\n      .each_slice(2)\n      .sum { |i, k = 0| i.to_i + ((k.to_i)*2).digits.sum }\n      .modulo(10).zero?\n end\n\n[\"49927398716\", \"49927398717\", \"1234567812345678\", \"1234567812345670\"].map{ |i| luhn_valid?(i) }\n\nOutput:\n[true, false, false, true]\n\ndef luhn_valid?(n)  # Card values can be numbers or strings\n  d2sum = [0, 2, 4, 6, 8, 1, 3, 5, 7, 9]\n  sum, num = 0, n.to_i\n  num.digits.each_with_index { |digit, i| sum += i.even?\u00a0? digit\u00a0: d2sum[digit] }\n  sum\u00a0% 10 == 0\nend\n\ncards = [49927398716, \"49927398717\", 1234567812345678, \"1234567812345670\"]\ncards.each{ |i| puts \"#{i}: #{luhn_valid?(i)}\" }\n\nOutput:\n49927398716: true\n49927398717: false\n1234567812345678: false\n1234567812345670: true\n", "explain": "Simpler Alternative\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Rust", "code": "\nextern crate luhn_test_of_credit_card_numbers;\n\nuse luhn_test_of_credit_card_numbers::luhn_test;\n\nfn validate_isin(isin: &str) -> bool {\n    if !isin.chars().all(|x| x.is_alphanumeric()) || isin.len()\u00a0!= 12 {\n        return false;\n    }\n    if !isin[..2].chars().all(|x| x.is_alphabetic())\n        || !isin[2..12].chars().all(|x| x.is_alphanumeric())\n        || !isin.chars().last().unwrap().is_numeric()\n    {\n        return false;\n    }\n\n    let bytes = isin.as_bytes();\n\n    let s2 = bytes\n        .iter()\n        .flat_map(|&c| {\n            if c.is_ascii_digit() {\n                vec![c]\n            } else {\n                (c + 10 - ('A' as u8)).to_string().into_bytes()\n            }\n        })\n        .collect::<Vec<u8>>();\n\n    let string = std::str::from_utf8(&s2).unwrap();\n    let number = string.parse::<u64>().unwrap();\n\n    return luhn_test(number as u64);\n}\n\n#[cfg(test)]\nmod tests {\n    use super::validate_isin;\n\n    #[test]\n    fn test_validate_isin() {\n        assert_eq!(validate_isin(\"US0378331005\"), true);\n        assert_eq!(validate_isin(\"US0373831005\"), false);\n        assert_eq!(validate_isin(\"U50378331005\"), false);\n        assert_eq!(validate_isin(\"US03378331005\"), false);\n        assert_eq!(validate_isin(\"AU0000XVGZA3\"), true);\n        assert_eq!(validate_isin(\"AU0000VXGZA3\"), true);\n        assert_eq!(validate_isin(\"FR0000988040\"), true);\n    }\n}\n\nOutput:\n49927398716: true\n49927398717: false\n1234567812345678: false\n1234567812345670: true\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Swift", "code": "\nfunc luhn(_ number: String) -> Bool {\n    return number.reversed().enumerated().map({\n        let digit = Int(String($0.element))!\n        let even = $0.offset\u00a0% 2 == 0\n        return even\u00a0? digit\u00a0: digit == 9\u00a0? 9\u00a0: digit * 2\u00a0% 9\n    }).reduce(0, +)\u00a0% 10 == 0\n}\n\nluhn(\"49927398716\") // true\nluhn(\"49927398717\") // false\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "R", "code": "\n \nis.luhn <- function(cc){\n  numbers <- as.numeric(rev(unlist(strsplit(cc,\"\"))))\n  (sum(numbers[seq(1,length(numbers),by=2)]) + sum({numbers[seq(2,length(numbers),by=2)]*2 ->.;  .%%10 +.%/%10}))\u00a0%% 10 == 0\n}\n  \nsapply(c(\"49927398716\",\"49927398717\",\"1234567812345678\",\"1234567812345670\"),is.luhn)\n\nOutput:\nsapply(c(\"49927398716\",\"49927398717\",\"1234567812345678\",\"1234567812345670\"),is.luhn)\n     49927398716      49927398717 1234567812345678 1234567812345670 \n            TRUE            FALSE            FALSE             TRUE \n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "COBOL", "code": "\nWorks with: OpenCOBOL\nWorks with: IBM Enterprise COBOL for z/OS\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHNTEST.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       data division.\n       WORKING-STORAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION.\n           move \"49927398716\"       to inp-card\n           perform test-card\n           move \"49927398717\"       to inp-card\n           perform test-card\n           move \"1234567812345678\"  to inp-card\n           perform test-card\n           move \"1234567812345670\"  to inp-card\n           perform test-card\n           stop run\n           .\n       test-card.\n           call \"LUHN\" using inp-card, ws-result\n           if pass-luhn-test\n             display \"input=\" inp-card \"pass\"\n           else\n             display \"input=\" inp-card \"fail\"\n           .\n\n       END PROGRAM LUHNTEST.\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  LUHN.\n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  maxlen           pic 9(02) comp value 16.\n       01  inplen           pic 9(02) comp value 0.\n       01  i                pic 9(02) comp value 0.\n       01  j                pic 9(02) comp value 0.\n       01  l                pic 9(02) comp value 0.\n       01  dw               pic 9(02) comp value 0.\n       01  ws-total         pic 9(03) comp value 0.\n       01  ws-prod          pic 99.\n       01  filler redefines ws-prod.\n         03  ws-prod-tens   pic 9.\n         03  ws-prod-units  pic 9.\n       01  ws-card.\n         03  filler           occurs 16 times depending on maxlen.\n           05  ws-card-ch     pic x(01).\n           05  ws-card-digit redefines ws-card-ch  pic 9(01).\n       LINKAGE SECTION.\n       01  inp-card.\n         03  inp-card-ch      pic x(01) occurs 20 times.\n       01  ws-result          pic 9(01).\n         88  pass-luhn-test             value 0.\n\n       PROCEDURE DIVISION using inp-card, ws-result.\n           perform varying i from 1 by +1\n           until i > maxlen\n           or    inp-card-ch (i) = space\n           end-perform\n           compute l = i - 1\n           compute inplen = l\n           perform varying j from 1 by +1\n           until j > inplen\n             if l < 1\n               move \"0\"             to ws-card-ch (j)\n             else\n               move inp-card-ch (l) to ws-card-ch (j)\n               compute l = l - 1\n             end-if\n           end-perform\n           move 0 to ws-total\n           perform varying i from 1 by +1\n           until i > inplen\n             compute dw = 2 - (i - 2 * function integer (i / 2))\n             compute ws-prod = ws-card-digit (i) * dw\n             compute ws-total = ws-total\n                              + ws-prod-tens\n                              + ws-prod-units\n           end-perform\n           compute ws-result = ws-total - 10 * function integer (ws-total / 10)\n           goback\n           .\n       END PROGRAM LUHN.\n\n\nOutput:\ninput=49927398716         pass \ninput=49927398717         fail \ninput=1234567812345678    fail \ninput=1234567812345670    pass \n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\nPublic Function LuhnCheckPassed(ByVal dgts As String) As Boolean\nDim i As Long, s As Long, s1 As Long\n  dgts = VBA.StrReverse(dgts)\n    For i = 1 To Len(dgts) Step 2\n        s = s + CInt(Mid$(dgts, i, 1))\n    Next i\n    For i = 2 To Len(dgts) Step 2\n        s1 = 2 * (CInt(Mid$(dgts, i, 1)))\n        If s1 >= 10 Then\n            s = s - 9\n        End If\n        s = s + s1\n    Next i\n  LuhnCheckPassed = Not CBool(s Mod 10)\nEnd Function\n\nSub Main()\n  Debug.Assert LuhnCheckPassed(\"49927398716\")\n  Debug.Assert Not LuhnCheckPassed(\"49927398717\")\n  Debug.Assert Not LuhnCheckPassed(\"1234567812345678\")\n  Debug.Assert LuhnCheckPassed(\"1234567812345670\")\nEnd Sub\n", "explain": "Test:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Ada", "code": "\nTranslation of: C\nWorks with: GNAT\nwith Ada.Text_IO;\nuse  Ada.Text_IO;\n\nprocedure Luhn is\n\n  function Luhn_Test (Number: String) return Boolean is\n    Sum  : Natural := 0;\n    Odd  : Boolean := True;\n    Digit: Natural range 0 .. 9;\n  begin\n    for p in reverse Number'Range loop\n      Digit := Integer'Value (Number (p..p));\n      if Odd then\n        Sum := Sum + Digit;\n      else\n        Sum := Sum + (Digit*2 mod 10) + (Digit / 5);\n      end if;\n      Odd := not Odd;\n    end loop;\n    return (Sum mod 10) = 0;\n  end Luhn_Test;\n \nbegin\n\n  Put_Line (Boolean'Image (Luhn_Test (\"49927398716\")));\n  Put_Line (Boolean'Image (Luhn_Test (\"49927398717\")));\n  Put_Line (Boolean'Image (Luhn_Test (\"1234567812345678\")));\n  Put_Line (Boolean'Image (Luhn_Test (\"1234567812345670\")));\n\nend Luhn;\n\n\nOutput:\nTRUE\nFALSE\nFALSE\nTRUE\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Julia", "code": "\n\nluhntest(x::Integer) = (sum(digits(x)[1:2:end]) + sum(map(x -> sum(digits(x)), 2 * digits(x)[2:2:end]))) % 10 == 0\n\n\nfunction luhntest(x::Integer)\n    d = reverse(digits(x))\n    s = sum(d[1:2:end])\n    s += sum(sum.(digits.(2d[2:2:end])))\n    return s % 10 == 0\nend\n\nfor card in [49927398716, 49927398717, 1234567812345678, 1234567812345670]\n    println(luhntest(card) ? \"PASS \" : \"FAIL \", card)\nend\n\n\nOutput:\nPASS 49927398716\nFAIL 49927398717\nFAIL 1234567812345678\nPASS 1234567812345670\n", "explain": "The test function itself is only a single line of code:\nMore readable version:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Kotlin", "code": "\n// version 1.0\n\nfun checkLuhn(number: String): Boolean {\n    var isOdd = true\n    var sum = 0\n\n    for (index in number.indices.reversed()) {\n        val digit = number[index] - '0'\n        sum += if (isOdd) digit else (digit * 2).let { (it / 10) + (it % 10) }\n        isOdd = !isOdd\n    }\n\n    return (sum % 10) == 0\n}\n\nfun main(args: Array<String>) {\n    val numbers = arrayOf(\"49927398716\", \"49927398717\", \"1234567812345678\", \"1234567812345670\")\n    for (number in numbers)\n        println(\"${number.padEnd(16)} is ${if(checkLuhn(number)) \"valid\" else \"invalid\"}\")\n}\n\n\nOutput:\n49927398716      is valid\n49927398717      is invalid\n1234567812345678 is invalid\n1234567812345670 is valid\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Perl", "code": "\nsub luhn_test\n{\n        my @rev = reverse split //,$_[0];\n        my ($sum1,$sum2,$i) = (0,0,0);\n\n        for(my $i=0;$i<@rev;$i+=2)\n        {\n                $sum1 += $rev[$i];\n                last if $i == $#rev;\n                $sum2 += 2*$rev[$i+1]%10 + int(2*$rev[$i+1]/10);\n        }\n        return ($sum1+$sum2) % 10 == 0;\n}\nprint luhn_test('49927398716');\nprint luhn_test('49927398717');\nprint luhn_test('1234567812345678');\nprint luhn_test('1234567812345670');\n\n\nsub luhn {\n    my (@n,$i,$sum) = split //, reverse $_[0];\n    my @a = map {int(2*$_ / 10) + (2*$_ % 10)} (0..9);\n    map {$sum += $i++ % 2 ? $a[$_] : $_} @n;\n    return ($sum % 10) ? 0 : 1;\n}\n\n# Test and display\nmap {print luhn($_), \": $_\\n\"}\n    qw(49927398716 49927398717 1234567812345678 1234567812345670);\n\n\nOutput:\n1: 49927398716\n0: 49927398717\n0: 1234567812345678\n1: 1234567812345670\n", "explain": "Or using map( ) and a precomputed array:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Objective-C", "code": "\n- (NSArray *) toCharArray {\n\t\n\tNSMutableArray *characters = [[NSMutableArray alloc] initWithCapacity:[self length]];\n\tfor (int i=0; i < [self length]; i++) {\n\t\tNSString *ichar  = [NSString stringWithFormat:@\"%C\", [self characterAtIndex:i]];\n\t\t[characters addObject:ichar];\n\t}\n\t\n\treturn characters;\n}\n\n+ (BOOL) luhnCheck:(NSString *)stringToTest {\n\t\n\tNSArray *stringAsChars = [stringToTest toCharArray];\n\t\n\tBOOL isOdd = YES;\n\tint oddSum = 0;\n\tint evenSum = 0;\n\t\n\tfor (int i = [stringToTest length] - 1; i >= 0; i--) {\n\t\t\n\t\tint digit = [(NSString *)stringAsChars[i] intValue];\n\t\t\n\t\tif (isOdd) \n\t\t\toddSum += digit;\n\t\telse \n\t\t\tevenSum += digit/5 + (2*digit) % 10;\n\t\t\t\n\t\tisOdd = !isOdd;\t\t\t\t \n\t}\n\t\n\treturn ((oddSum + evenSum) % 10 == 0);\n}\n\nBOOL test0 = [self luhnCheck:@\"49927398716\"]; //Result = YES\nBOOL test1 = [self luhnCheck:@\"49927398717\"]; //Result = NO\nBOOL test2 = [self luhnCheck:@\"1234567812345678\"]; //Result = NO\t\t\t\t   \nBOOL test3 = [self luhnCheck:@\"1234567812345670\"]; //Result = YES\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Lua", "code": "\nfunction luhn(n)\n  n=string.reverse(n)\n  print(n)\n  local s1=0\n  --sum odd digits\n  for i=1,n:len(),2 do\n    s1=s1+n:sub(i,i)\n  end\n  --evens\n  local s2=0\n  for i=2,n:len(),2 do\n    local doubled=n:sub(i,i)*2\n    doubled=string.gsub(doubled,'(%d)(%d)',function(a,b)return a+b end)\n    s2=s2+doubled\n  end\n  print(s1)\n  print(s2)\n  local total=s1+s2\n  if total%10==0 then\n    return true\n  end\n  return false\nend \n\n-- Note that this function takes strings, not numbers.\n-- 16-digit numbers tend to be problematic\n-- when looking at individual digits.\nprint(luhn'49927398716')\nprint(luhn'49927398717')\nprint(luhn'1234567812345678')\nprint(luhn'1234567812345670')\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Scala", "code": "\nLibrary: Scala\nFunctional style[edit]\nobject Luhn {\n  private def parse(s: String): Seq[Int] = s.map{c =>\n    assert(c.isDigit)\n    c.asDigit\n  }\n  def checksum(digits: Seq[Int]): Int = {\n    digits.reverse.zipWithIndex.foldLeft(0){case (sum,(digit,i))=>\n      if (i%2 == 0) sum + digit\n      else sum + (digit*2)/10 + (digit*2)%10\n    }\u00a0% 10\n  }\n  def validate(digits: Seq[Int]): Boolean = checksum(digits) == 0\n  def checksum(number: String): Int = checksum(parse(number))\n  def validate(number: String): Boolean = validate(parse(number))\n}\n\nobject LuhnTest extends App {\n  Seq((\"49927398716\", true),\n    (\"49927398717\", false),\n    (\"1234567812345678\", false),\n    (\"1234567812345670\", true)\n  ).foreach { case (n, expected) =>\n    println(s\"$n ${Luhn.validate(n)}\")\n    assert(Luhn.validate(n) == expected)\n  }\n}\n\nOutput:\n49927398716 true\n49927398717 false\n1234567812345678 false\n1234567812345670 true\nImperative style[edit]\n  def luhnTest1(number: String): Boolean = {\n    var (odd, sum) = (true, 0)\n\n    for (int <- number.reverse.map { _.toString.toShort }) {\n      if (odd) sum += int\n      else sum += (int * 2\u00a0% 10) + (int / 5)\n      odd = !odd\n    }\n    sum\u00a0% 10 == 0\n  }\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Transact-SQL", "code": "\nCREATE FUNCTION dbo._CreditCardNumCheck( @strCCNum VarChar(40) )\nRETURNS VarChar(7)\nAS\nBEGIN\n\tDECLARE @string\t\t\tVarChar(40) = REVERSE(@strCCNum); -- usage: set once, never changed\n\tDECLARE @strS2Values\t\tVarChar(10) = '0246813579';  -- constant: maps digits to their S2 summed values\n\tDECLARE @table\t\t\tTABLE (ID INT, Value INT, S_Value INT); -- ID=digit position. S_Value is used for SUM().\n\tDECLARE @p\t\t\tINT = 0; -- loop counter: position in string\n\t-- Convert the reversed string's digits into rows in a table variable, S_Values to be updated afterwards\n\tWHILE @p < LEN(@string)\n\t\tBEGIN\n\t\t\tSET @p = @p+1;\n\t\t\tINSERT INTO @table (ID,Value,S_Value) VALUES (@p, CONVERT(INT,SUBSTRING(@string,@p,1)), 0);\n\t\tEND\n\t-- Update S_Value column\u00a0: the digit's value to be summed (for even-positioned digits this is mapped via @strS2Values)\n\tUPDATE @table SET S_Value = CASE WHEN ID\u00a0% 2 = 1 THEN Value ELSE CONVERT(INT,SUBSTRING(@strS2Values,Value+1,1)) END\n\t-- If the SUM of S_Values ends in 0 (modulo 10 = 0) then the CC Number is valid\n\tRETURN CASE WHEN (SELECT SUM(S_Value) FROM @table)\u00a0% 10 = 0 THEN 'Valid' ELSE 'Invalid' END\nEND\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "D", "code": "\nFunctional Version[edit]\nTranslation of: Haskell\nimport std.algorithm, std.range, std.string;\n\nenum luhnTest = (in string n) pure /*nothrow*/ @safe /*@nogc*/ =>\n    retro(n)\n    .zip(only(1, 2).cycle)\n    .map!(p => (p[0] - '0') * p[1])\n    .map!(d => d / 10 + d % 10)\n    .sum % 10 == 0;\n\nvoid main() {\n    assert(\"49927398716 49927398717 1234567812345678 1234567812345670\"\n           .split.map!luhnTest.equal([true, false, false, true]));\n}\n\nMore Imperative Version[edit]\nTranslation of: C\nimport std.algorithm;\n\nbool luhnTest(in string num) @safe pure nothrow @nogc {\n    uint sum;\n    foreach_reverse (immutable i, immutable n; num) {\n        immutable uint ord = n - '\\u0030';\n        sum += ((num.length - i) & 1) ? ord : ord / 5 + (2 * ord) % 10;\n    }\n    return sum % 10 == 0;\n}\n\nvoid main() {\n    immutable data = [\"49927398716\",\n                      \"49927398717\",\n                      \"1234567812345678\",\n                      \"1234567812345670\"];\n    assert(data.map!luhnTest.equal([true, false, false, true]));\n}\n\nStronger Statically Typed Version[edit]\n\nTranslation of: SPARK\nimport std.stdio;\n\nstruct Interval(T) {\n    immutable T a, b;\n\n    this(in T a_, in T b_) pure nothrow @nogc {\n        this.a = a_;\n        this.b = b_;\n    }\n\n    bool opBinaryRight(string op=\"in\")(in T x)\n    const pure nothrow @nogc {\n        return x >= a && x <= b;\n    }\n\n    pure nothrow @safe @nogc const invariant {\n        assert(a <= b);\n    }\n}\n\nInterval!T interval(T)(in T a, in T b) pure nothrow @nogc {\n    return Interval!T(a, b);\n}\n\n\nbool luhnTest(in string num) pure nothrow @nogc\nin {\n    assert(num.length <= 20);\n} body {\n    int sum = 0;\n    bool od = true;\n    bool ok = true;\n    immutable int numLen = num.length;\n\n    foreach_reverse (immutable p; 0 .. numLen) {\n        immutable int i = num[p] - '0';\n        if (i !in interval(0, 9)) {\n            ok = false;\n            break;\n        }\n\n        immutable int x = ((i * 2) % 10) + (i / 5);\n        assert((numLen - p) in interval(0, 19));\n        assert(sum in interval(0, (numLen - p) * 10));\n        assert(i in interval(0, 9));\n        assert(x in interval(0, 9));\n        sum += od ? i : x;\n        od = !od;\n    }\n\n    return ok && (sum % 10) == 0;\n}\n\n\nvoid main() {\n    foreach (immutable n; [\"49927398716\", \"49927398717\",\n                           \"1234567812345678\", \"1234567812345670\",\n                           \"123456781234567D\"])\n        writefln(\"%s is %svalid\", n, luhnTest(n) ? \"\" : \"not \");\n}\n\n", "explain": "This version uses more precise types.\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Haskell", "code": "\nimport Data.Char (digitToInt)\nluhn = (0 ==) . (`mod` 10) . sum . map (uncurry (+) . (`divMod` 10)) .\n       zipWith (*) (cycle [1,2]) . map digitToInt . reverse\n\n\nOutput:\nmap luhn [\"49927398716\", \"49927398717\", \"1234567812345678\", \"1234567812345670\"]\n[True,False,False,True]\n\n\nimport Data.Char (digitToInt)\nimport Data.List (transpose)\nimport Data.List.Split (chunksOf)\n\nluhn :: String -> Bool\nluhn x = 0 == rem (s1 + s2) 10\n  where\n    stringInts = fmap digitToInt\n    [odds, evens] =\n      (transpose . chunksOf 2)\n        (stringInts $ reverse x)\n    s1 = sum odds\n    s2 = sum $ sum . stringInts . show . (2 *) <$> evens\n\nmain :: IO ()\nmain =\n  mapM_\n    (print . ((,) <*> luhn))\n    [ \"49927398716\",\n      \"49927398717\",\n      \"1234567812345678\",\n      \"1234567812345670\"\n    ]\n\n\nOutput:\n(\"49927398716\",True)\n(\"49927398717\",False)\n(\"1234567812345678\",False)\n(\"1234567812345670\",True)\n", "explain": "Or, aiming for a legible relationship with the stages shown in the task description:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "PL/SQL", "code": "\nFUNCTION algoLuhn ( p_numeroVerif VARCHAR2 )\n    RETURN NUMBER\n  IS\n    i         NUMBER;\n    v_NBi     SMALLINT;\n    v_retour  SMALLINT;\n    v_somme   NUMBER := 0;\n    v_nbCar   NUMBER;\n    \n  BEGIN  \n    v_nbCar := LENGTH(p_numeroVerif);    \n    \n    FOR i IN 1..v_nbCar\n    LOOP\n        v_NBi := TO_NUMBER(SUBSTR(p_numeroVerif,v_nbCar+1-i,1));\n        \n        v_somme := v_somme\n                  + MOD(i,2)   * v_NBi\n                  + MOD(i+1,2) * SIGN(-SIGN(v_Nbi-4)+1) * (2*v_NBi)\n                  + MOD(i+1,2) * SIGN( SIGN(v_Nbi-5)+1) * (2*v_NBi-9);\n     \n    END LOOP;\n        \n    v_retour := SIGN(MOD(v_somme,10));\n    \n    RETURN v_retour;\n  \n  EXCEPTION\n    WHEN OTHERS\n      THEN\n        RETURN 1;\n        \n  END algoLuhn;\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "VBScript", "code": "\nFunction Luhn_Test(cc)\n\tcc = RevString(cc)\n\ts1 = 0\n\ts2 = 0\n\tFor i = 1 To Len(cc)\n\t\tIf i Mod 2 > 0 Then\n\t\t\ts1 = s1 + CInt(Mid(cc,i,1))\n\t\tElse\n\t\t\ttmp = CInt(Mid(cc,i,1))*2\n\t\t\tIf  tmp < 10 Then\n\t\t\t\ts2 = s2 + tmp\n\t\t\tElse\n\t\t\t\ts2 = s2 + CInt(Right(CStr(tmp),1)) + 1\n\t\t\tEnd If\n\t\tEnd If \n\tNext\n\tIf Right(CStr(s1 + s2),1) = \"0\" Then\n\t\tLuhn_Test = \"Valid\"\n\tElse\n\t\tLuhn_Test = \"Invalid\"\n\tEnd If\nEnd Function\n\nFunction RevString(s)\n\tFor i = Len(s) To 1 Step -1\n\t\tRevString = RevString & Mid(s,i,1)\n\tNext\nEnd Function\n\nWScript.Echo \"49927398716 is \" & Luhn_Test(\"49927398716\")\nWScript.Echo \"49927398717 is \" & Luhn_Test(\"49927398717\")\t\t\t \nWScript.Echo \"1234567812345678 is \" & Luhn_Test(\"1234567812345678\")\nWScript.Echo \"1234567812345670 is \" & Luhn_Test(\"1234567812345670\")\n\nOutput:\n49927398716 is Valid\n49927398717 is Invalid\n1234567812345678 is Invalid\n1234567812345670 is Valid\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Scheme", "code": "\n(define luhn\n  (lambda (n)\n    (let loop ((number n)\n               (index 0)\n               (result 0))\n      (if (= 0 number)\n          (= 0 (remainder result 10))\n          (loop (quotient number 10)\n                (+ index 1)\n                (+ result\n                   (if (even? index)\n                       (remainder number 10)\n                       (let ((part (* 2 (remainder number 10))))\n                         (+ (remainder part 10) (quotient part 10))))))))))\n\nOutput:\n(map luhn '(49927398716 49927398717 1234567812345678 1234567812345670))\n(#t #f #f #t)\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "PowerShell", "code": "\nfunction Test-LuhnNumber\n{\n  <#\n    .SYNOPSIS\n        Tests validity of credit card numbers.\n    .DESCRIPTION\n        Tests validity of credit card numbers using the Luhn test.\n    .PARAMETER Number\n        The number must be 11 or 16 digits.\n    .EXAMPLE\n        Test-LuhnNumber 49927398716\n    .EXAMPLE\n        [int64[]]$numbers = 49927398716, 49927398717, 1234567812345678, 1234567812345670\n        C:\\PS>$numbers | ForEach-Object {\n                  \"{0,-17}: {1}\" -f $_,\"$(if(Test-LuhnNumber $_) {'Is valid.'} else {'Is not valid.'})\"\n              }\n  #>\n    [CmdletBinding()]\n    [OutputType([bool])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   Position=0)]\n        [ValidateScript({$_.Length -eq 11 -or $_.Length -eq 16})]\n        [ValidatePattern(\"^\\d+$\")]\n        [string]\n        $Number\n    )\n\n    $digits = ([Regex]::Matches($Number,'.','RightToLeft')).Value\n    \n    $digits |\n        ForEach-Object `\n               -Begin   {$i = 1} `\n               -Process {if ($i++\u00a0% 2) {$_}} |\n        ForEach-Object `\n               -Begin   {$sumOdds = 0} `\n               -Process {$sumOdds += [Char]::GetNumericValue($_)}\n    $digits |\n        ForEach-Object `\n               -Begin   {$i = 0} `\n               -Process {if ($i++\u00a0% 2) {$_}} |\n        ForEach-Object `\n               -Process {[Char]::GetNumericValue($_) * 2} |\n        ForEach-Object `\n               -Begin   {$sumEvens = 0} `\n               -Process {\n                            $_number = $_.ToString()\n                            if ($_number.Length -eq 1)\n                            {\n                                $sumEvens += [Char]::GetNumericValue($_number)\n                            }\n                            elseif ($_number.Length -eq 2)\n                            {\n                                $sumEvens += [Char]::GetNumericValue($_number[0]) + [Char]::GetNumericValue($_number[1])\n                            }\n                        }\n\n    ($sumOdds + $sumEvens).ToString()[-1] -eq \"0\"\n}\nTest-LuhnNumber 49927398716\n\nOutput:\nTrue\n\n49927398716, 49927398717, 1234567812345678, 1234567812345670 | ForEach-Object {\n    \"{0,-17}: {1}\" -f $_,\"$(if(Test-LuhnNumber $_) {'Is valid.'} else {'Is not valid.'})\"\n}\n\nOutput:\n49927398716     \u00a0: Is valid.\n49927398717     \u00a0: Is not valid.\n1234567812345678\u00a0: Is not valid.\n1234567812345670\u00a0: Is valid.\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Logo", "code": "\nto small? :list\n  output or [empty? :list] [empty? bf :list]\nend\nto every.other :list\n  if small? :list [output :list]\n  output fput first :list every.other bf bf :list\nend\nto wordtolist :word\n  output map.se [?] :word\nend\n\nto double.digit :digit\n  output item :digit {0 2 4 6 8 1 3 5 7 9}@0\n \u00a0; output ifelse :digit < 5 [2*:digit] [1 + modulo 2*:digit 10]\nend\n\nto luhn :credit\n  localmake \"digits reverse filter [number?\u00a0?] wordtolist :credit\n  localmake \"s1 apply \"sum every.other :digits\n  localmake \"s2 apply \"sum map \"double.digit every.other bf :digits\n  output equal? 0 last sum :s1 :s2\nend\n\nshow luhn \"49927398716         \u00a0; true\nshow luhn \"49927398717         \u00a0; false\nshow luhn \"1234-5678-1234-5678 \u00a0; false\nshow luhn \"1234-5678-1234-5670 \u00a0; true\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "ABAP", "code": "\nMETHOD luhn_check.\n\n  DATA: sum(1) TYPE n VALUE 0. \" Sum of checksum.\n  DATA: current TYPE i. \" Current digit.\n  DATA: odd TYPE i VALUE 1. \" Multiplier.\n  DATA: len TYPE i. \" String crowler.\n\n\n  \" Luhn algorithm.\n  len = NUMOFCHAR( pi_string ) - 1.\n  WHILE ( len >= 0 ).\n    current = pi_string+len(1) * odd.\n    IF ( current > 9 ).\n      current = current - 9. \" Digits sum.\n    ENDIF.\n    sum = sum + current.\n    odd = 3 - odd. \" 1 <--> 2 Swich\n    len = len - 1. \" Move to next charcter.\n  ENDWHILE.\n\n  \" Validation check.\n  IF ( sum = 0 ).\n    pr_valid = abap_true.\n  ELSE.\n    pr_valid = abap_false.\n  ENDIF.\n\nENDMETHOD.\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "F#", "code": "\nlet luhn (s:string) =\n  let rec g r c = function\n  | 0 -> r\n  | i ->\n      let d = ((int s.[i - 1]) - 48) <<< c\n      g (r + if d < 10 then d else d - 9) (1 - c) (i - 1)\n  (g 0 0 s.Length) % 10 = 0\n\n", "explain": ""}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "Groovy", "code": "\ndef checkLuhn(number) {\n    int total\n    (number as String).reverse().eachWithIndex { ch, index ->\n        def digit = Integer.parseInt(ch)\n        total += (index % 2 ==0) ? digit : [0, 2, 4, 6, 8, 1, 3, 5, 7, 9][digit]\n    }\n    total % 10 == 0\n}\n\n\ndef verifyLuhn(number, expected) {\n    println \"Checking: $number (${checkLuhn(number)})\"\n    assert expected == checkLuhn(number)\n}\n\n[49927398716: true, 49927398717: false, 1234567812345678: false, 1234567812345670: true].each { number, expected ->\n    verifyLuhn number, expected\n}\n\n\nOutput:\nChecking: 49927398716 (true)\nChecking: 49927398717 (false)\nChecking: 1234567812345678 (false)\nChecking: 1234567812345670 (true)\n", "explain": "Testing the function:\n"}, {"task_name": "Luhn test of credit card numbers", "task_url": "https://rosettacode.org/wiki/Luhn_test_of_credit_card_numbers", "task_cat": "Checksums", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\nBEGIN {\n    A[1] = 49927398716;\n    A[2] = 49927398717;\n    A[3] = 1234567812345678;\n    A[4] = 1234567812345670;\n    A[5] = \"01234567897\";\n    A[6] = \"01234567890\";\n    A[7] = \"00000000000\";\n    for (k in A) print \"isLuhn(\"A[k]\"): \",isLuhn(A[k]);\t\n}\n\nfunction isLuhn(cardno) {\n    s = 0;\n    m = \"0246813579\";\n    n = length(cardno);\n    for (k = n; 0 < k; k -= 2) {\n\ts += substr(cardno, k, 1);\n    }\n    for (k = n-1; 0 < k; k -= 2) {\n\ts += substr(m, substr(cardno, k, 1)+1, 1);\n    }\n    return ((s%10)==0);\t\n}\n\n\nOutput:\nisLuhn(1234567812345670):  1\nisLuhn(01234567897):  1\nisLuhn(01234567890):  0\nisLuhn(00000000000):  1\nisLuhn(49927398716):  1\nisLuhn(49927398717):  0\nisLuhn(1234567812345678):  0\n", "explain": ""}]