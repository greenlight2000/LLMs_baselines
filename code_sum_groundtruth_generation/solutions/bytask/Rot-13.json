[{"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Python", "code": "\n\nWorks with: Python version 2.x\n>>> u'foo'.encode('rot13')\n'sbb'\n>>> 'sbb'.decode('rot13')\nu'foo'\n\nWorks with: Python version 2.x\nWorks with: Python version 3.x\n>>> import codecs\n>>> codecs.encode(\"The quick brown fox jumps over the lazy dog\", \"rot13\")\n'Gur dhvpx oebja sbk whzcf bire gur ynml qbt'\n>>> codecs.decode(_, \"rot13\")\n'The quick brown fox jumps over the lazy dog'\n\nWorks with: Python version 3.x\n#!/usr/bin/env python\nimport string\n\nTRANSLATION_TABLE = str.maketrans(\n    string.ascii_uppercase + string.ascii_lowercase,\n    string.ascii_uppercase[13:] + string.ascii_uppercase[:13] +\n    string.ascii_lowercase[13:] + string.ascii_lowercase[:13]\n)\n\n\ndef rot13(s):\n    \"\"\"Return the rot-13 encoding of s.\"\"\"\n    return s.translate(TRANSLATION_TABLE)\n\n\nif __name__ == \"__main__\":\n    \"\"\"rot-13 encode the input files, or stdin if no files are provided.\"\"\"\n    import fileinput\n    for line in fileinput.input():\n        print(rot13(line), end=\"\")\n\nWorks with: Python version 3.x and Works with: Python version 2.7\n\n#!/usr/bin/env python\nfrom __future__ import print_function\nimport string\nlets = string.ascii_lowercase\nkey = {x:y for (x,y) in zip(lets[13:]+lets[:14], lets)}\nkey.update({x.upper():key[x].upper() for x in key.keys()})\nencode = lambda x: ''.join((key.get(c,c) for c in x))\nif __name__ == '__main__':\n   \"\"\"Peform line-by-line rot-13 encoding on any files listed on our\n      command line or act as a standard UNIX filter (if no arguments\n      specified).\n   \"\"\"\n   import fileinput\n   for line in fileinput.input():\n      print(encode(line), end=\"\")\n", "explain": "Python 2.x (but not 3.x) has built-in rot13 encoding and decoding:\nIn both Python 2.x and 3.x one can use the standard library module codecs for rot13 encoding and decoding:\nAn alternative that doesn't rely on the built-in \"rot13\" codec:\nThe str.translate() and str.maketrans() functions make the function's definition almost trivial. The fileinput module makes the wrapper functionality trivial to implement. This can be adapted for Python2.x by replacing str.maketrans with string.maketrans and using Python2 style print statement in place of the Python3 print function.\nThis one uses a dictionary comprehension to define the key for\nlowercase then another to updates with with uppercase mappings.\nIt uses generator expression in a lambda as the encoding function\nand the dictionary .get() (with default value) to preserve any non-letter\ncharacters during encoding.  This lambda line can be used to generate\nan encoding function for any substitution cipher defined in the name\n\"key.\"\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "C", "code": "\n\n#include <ctype.h>\n#include <limits.h>\n#include <stdio.h>\n#include <stdlib.h>\n\nstatic char rot13_table[UCHAR_MAX + 1];\n\nstatic void init_rot13_table(void) {\n\tstatic const unsigned char upper[] = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\tstatic const unsigned char lower[] = \"abcdefghijklmnopqrstuvwxyz\";\n\n\tfor (int ch = '\\0'; ch <= UCHAR_MAX; ch++) {\n\t\trot13_table[ch] = ch;\n\t}\n\tfor (const unsigned char *p = upper; p[13] != '\\0'; p++) {\n\t\trot13_table[p[0]] = p[13];\n\t\trot13_table[p[13]] = p[0];\n\t}\n\tfor (const unsigned char *p = lower; p[13] != '\\0'; p++) {\n\t\trot13_table[p[0]] = p[13];\n\t\trot13_table[p[13]] = p[0];\n\t}\n}\n\nstatic void rot13_file(FILE *fp)\n{\n\tint ch;\n\twhile ((ch = fgetc(fp)) != EOF) {\n\t\tfputc(rot13_table[ch], stdout);                \n\t}\n}\n\nint main(int argc, char *argv[])\n{\n\tinit_rot13_table();\n\n\tif (argc > 1) {\n\t\tfor (int i = 1; i < argc; i++) {\n\t\t\tFILE *fp = fopen(argv[i], \"r\");\n\t\t\tif (fp == NULL) {\n\t\t\t\tperror(argv[i]);\n\t\t\t\treturn EXIT_FAILURE;\n\t\t\t}\n\t\t\trot13_file(fp);\n\t\t\tfclose(fp);\n\t\t}\n\t} else {\n\t\trot13_file(stdin);\n\t}\n\treturn EXIT_SUCCESS;\n}\n\n", "explain": "The following code can handle all character sets, even if the letters are not in a contiguous range (in ASCII they are, in EBCDIC they aren't).\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "C++", "code": "\n#include <iostream>\n#include <istream>\n#include <ostream>\n#include <fstream>\n#include <cstdlib>\n#include <string>\n\n// the rot13 function\nstd::string rot13(std::string s)\n{\n  static std::string const\n    lcalph = \"abcdefghijklmnopqrstuvwxyz\",\n    ucalph = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n\n  std::string result;\n  std::string::size_type pos;\n\n  result.reserve(s.length());\n\n  for (std::string::iterator it = s.begin(); it != s.end(); ++it)\n  {\n    if ( (pos = lcalph.find(*it)) != std::string::npos )\n      result.push_back(lcalph[(pos+13) % 26]);\n    else if ( (pos = ucalph.find(*it)) != std::string::npos )\n      result.push_back(ucalph[(pos+13) % 26]);\n    else\n      result.push_back(*it);\n  }\n\n  return result;\n}\n\n// function to output the rot13 of a file on std::cout\n// returns false if an error occurred processing the file, true otherwise\n// on entry, the argument is must be open for reading\nint rot13_stream(std::istream& is)\n{\n  std::string line;\n  while (std::getline(is, line))\n  {\n    if (!(std::cout << rot13(line) << \"\\n\"))\n      return false;\n  }\n  return is.eof();\n}\n\n// the main program\nint main(int argc, char* argv[])\n{\n  if (argc == 1) // no arguments given\n    return rot13_stream(std::cin)? EXIT_SUCCESS : EXIT_FAILURE;\n\n  std::ifstream file;\n  for (int i = 1; i < argc; ++i)\n  {\n    file.open(argv[i], std::ios::in);\n    if (!file)\n    {\n      std::cerr << argv[0] << \": could not open for reading: \" << argv[i] << \"\\n\";\n      return EXIT_FAILURE;\n    }\n    if (!rot13_stream(file))\n    {\n      if (file.eof())\n        // no error occurred for file, so the error must have been in output\n        std::cerr << argv[0] << \": error writing to stdout\\n\";\n      else\n        std::cerr << argv[0] << \": error reading from \" << argv[i] << \"\\n\";\n      return EXIT_FAILURE;\n    }\n    file.clear();\n    file.close();\n    if (!file)\n      std::cerr << argv[0] << \": warning: closing failed for \" << argv[i] << \"\\n\";\n  }\n  return EXIT_SUCCESS;\n}\n\n\nLibrary: Boost\n#include <iostream>\n#include <string>\n#include <boost/iostreams/concepts.hpp>    // output_filter\n#include <boost/iostreams/operations.hpp>  // put\n#include <boost/iostreams/filtering_stream.hpp>\n#include <fstream>\nnamespace io = boost::iostreams;\n\nclass rot_output_filter : public io::output_filter \n{\npublic:\n    explicit rot_output_filter(int r=13):rotby(r),negrot(alphlen-r){};\n\n    template<typename Sink>\n    bool put(Sink& dest, int c){\n        char uc = toupper(c);\n\n        if(('A' <= uc) && (uc <= ('Z'-rotby)))\n            c = c + rotby;\n        else if ((('Z'-rotby) <= uc) && (uc <= 'Z'))\n            c = c - negrot;\n        return boost::iostreams::put(dest, c);\n    };\nprivate:\n        static const int alphlen = 26;\n        const int rotby;\n        const int negrot;\n};\n\nint main(int argc, char *argv[])\n{\n    io::filtering_ostream out;\n    out.push(rot_output_filter(13));\n    out.push(std::cout);\n\n    if (argc == 1) out << std::cin.rdbuf();\n    else for(int i = 1; i < argc; ++i){\n        std::ifstream in(argv[i]);\n        out << in.rdbuf();\n    }\n}\n\nC++11[edit]\n#include <string>\n#include <iostream>\n#include <fstream>\n\nchar rot13(const char c){\n\tif (c >= 'a' && c <= 'z')\n\t\treturn (c - 'a' + 13) % 26 + 'a';\n\telse if (c >= 'A' && c <= 'Z')\n\t\treturn (c - 'A' + 13) % 26 + 'A';\n\treturn c;\n}\n\nstd::string &rot13(std::string &s){\n\tfor (auto &c : s) //range based for is the only used C++11 feature\n\t\tc = rot13(c);\n\treturn s;\n}\n\nvoid rot13(std::istream &in, std::ostream &out){\n\tstd::string s;\n\twhile (std::getline(in, s))\n\t\tout << rot13(s) << '\\n';\n}\n\nint main(int argc, char *argv[]){\n\tif (argc == 1)\n\t\trot13(std::cin, std::cout);\n\tfor (int arg = 1; arg < argc; ++arg){\n\t\tstd::ifstream f(argv[arg]);\n\t\tif (!f)\n\t\t\treturn EXIT_FAILURE;\n\t\trot13(f, std::cout);\n\t}\n}\n\n", "explain": "Here is an other approach which can rotate by any number:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Java", "code": "\nimport java.io.*;\n\npublic class Rot13 {\n\n    public static void main(String[] args) throws IOException {\n        if (args.length >= 1) {\n            for (String file : args) {\n                try (InputStream in = new BufferedInputStream(new FileInputStream(file))) {\n                    rot13(in, System.out);\n                }\n            }\n        } else {\n            rot13(System.in, System.out);\n        }\n    }\n\n    private static void rot13(InputStream in, OutputStream out) throws IOException {\n        int ch;\n        while ((ch = in.read()) != -1) {\n            out.write(rot13((char) ch));\n        }\n    }\n\n    private static char rot13(char ch) {\n        if (ch >= 'A' && ch <= 'Z') {\n            return (char) (((ch - 'A') + 13) % 26 + 'A');\n        }\n        if (ch >= 'a' && ch <= 'z') {\n            return (char) (((ch - 'a') + 13) % 26 + 'a');\n        }\n        return ch;\n    }\n}\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "C#", "code": "\nusing System;\nusing System;\nusing System.IO;\nusing System.Linq;\nusing System.Text;\n\n\nclass Program {\n    private static char shift(char c) {\n\t\treturn c.ToString().ToLower().First() switch {\n\t\t\t>= 'a' and <= 'm' => (char)(c + 13),\n\t\t\t>= 'n' and <= 'z' => (char)(c - 13),\n\t\t\tvar _ => c\n\t\t};\n    }\n\n    static string Rot13(string s)\n    \t=> new string(message.Select(c => shift(c)).ToArray());\n\n\n    static void Main(string[] args) {\n        foreach (var file in args.Where(file => File.Exists(file))) {\n            Console.WriteLine(Rot13(File.ReadAllText(file)));\n        }\n        if (!args.Any()) {\n            Console.WriteLine(Rot13(Console.In.ReadToEnd()));\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "JavaScript", "code": "\nfunction rot13(c) {\n    return c.replace(/([a-m])|([n-z])/ig, function($0,$1,$2) {\n        return String.fromCharCode($1 ? $1.charCodeAt(0) + 13 : $2 ? $2.charCodeAt(0) - 13 : 0) || $0;\n    });\n}\nrot13(\"ABJURER nowhere\") // NOWHERE abjurer\n\n\nfunction rot13(value){\n  if (!value)\n    return \"\";\n\n  function singleChar(c) {\n    if (c.toUpperCase() < \"A\" || c.toUpperCase() > \"Z\")\n      return c;\n\n    if (c.toUpperCase() <= \"M\")\n      return String.fromCharCode(c.charCodeAt(0) + 13);\n\n    return String.fromCharCode(c.charCodeAt(0) - 13);  \n  }\n\n  return _.map(value.split(\"\"), singleChar).join(\"\");\n}\n\ndescribe(\"Rot-13\", function() {\n  it(\"Given nothing will return nothing\", function() {\n    expect(rot13()).toBe(\"\");\n  });\n\n  it(\"Given empty string will return empty string\", function() {\n    expect(rot13(\"\")).toBe(\"\");\n  });\n\n  it(\"Given A will return N\", function() {\n    expect(rot13(\"A\")).toBe(\"N\");\n  });\n\n  it(\"Given B will return O\", function() {\n    expect(rot13(\"B\")).toBe(\"O\");\n  });\n\n  it(\"Given N will return A\", function() {\n    expect(rot13(\"N\")).toBe(\"A\");\n  });\n\n  it(\"Given Z will return M\", function() {\n    expect(rot13(\"Z\")).toBe(\"M\");\n  });\n\n  it(\"Given ZA will return MN\", function() {\n    expect(rot13(\"ZA\")).toBe(\"MN\");\n  });\n\n  it(\"Given HELLO will return URYYB\", function() {\n    expect(rot13(\"HELLO\")).toBe(\"URYYB\");\n  });\n\n  it(\"Given hello will return uryyb\", function() {\n    expect(rot13(\"hello\")).toBe(\"uryyb\");\n  });\n\n\n  it(\"Given hello1 will return uryyb1\", function() {\n    expect(rot13(\"hello1\")).toBe(\"uryyb1\");\n  });\n});\n\n", "explain": "TDD with Jasmine using Underscore.js\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Visual_Basic_.NET", "code": "\n\nWorks with: Visual Basic .NET version 9.0+\nModule Module1\n\n   Private Function rot13(ByVal str As String) As String\n       Dim newChars As Char(), i, j As Integer, original, replacement As String\n\n       original = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n       replacement = \"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\"\n\n       newChars = str.ToCharArray()\n\n       For i = 0 To newChars.Length - 1\n           For j = 0 To 51\n               If newChars(i) = original(j) Then\n                   newChars(i) = replacement(j)\n                   Exit For\n               End If\n           Next\n       Next\n\n       Return New String(newChars)\n   End Function\n\nEnd Module\n\n", "explain": "Platform: .NET\nThis solution just uses simple textual substitution, since the number of characters involved is small.  If the cipher involved more characters, it would be better to use character arithmetic; however, this is not encouraged in VB.Net.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "SQL", "code": "\nselect translate(\n        'The quick brown fox jumps over the lazy dog.',\n        'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n        'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm'\n        )\n        from dual;\nWorks with: T-SQL\nwith cte(num) as \n(\n select 1\n union all\n select num+1\n from cte\n)\nselect cast((\nselect char(ascii(chr) +\n\t\tcase \n\t\t\twhen    ascii(chr) between ascii('a') and ascii('m') or\n\t\t\t\tascii(chr) between ascii('A') and ascii('M') then 13\n\t\t\twhen    ascii(chr) between ascii('n') and ascii('z') or\n\t\t\t\tascii(chr) between ascii('N') and ascii('Z') then -13\n\t\t\telse    0\n\t\tend)\nfrom\n(\nselect top(1000) num, \n\t\t -- your string to be converted to ROT13\n                 substring('The Quick Brown Fox Jumps Over The Lazy Dog',num,1) chr\nfrom cte\n) tmp\nFor XML PATH ('')) as xml).value('.', 'VARCHAR(max)') rot13\noption (maxrecursion 0)\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "PHP", "code": "\n\necho str_rot13('foo'), \"\\n\";\n\nsbb\n\n\n<?php\nfunction rot13($s) {\n    return strtr($s, 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz',\n                     'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm');\n}\n\necho rot13('foo'), \"\\n\";\n?>\n\nsbb\n\n", "explain": "PHP has a built-in function for this:\nwill output\nHere is an implementation:\nOutput:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "MATLAB", "code": "\nfunction r=rot13(s)\n    if ischar(s)\n        r=s;  % preallocation and copy of non-letters\n        for i=1:size(s,1)\n            for j=1:size(s,2)\n                if isletter(s(i,j))\n                    if s(i,j)>=97   % lower case\n                        base = 97;\n                    else            % upper case\n                        base = 65;\n                    end\n                    r(i,j)=char(mod(s(i,j)-base+13,26)+base);\n                end\n            end\n        end\n    else\n        error('Argument must be a CHAR')\n    end\nend\n\n\n>> rot13('Hello World!')\n\nans =\n\nUryyb Jbeyq!\n\n\nfunction text = rot13(text)\n    if ischar(text)\n        \n        selectedLetters = ( (text >= 'A') & (text <= 'Z') ); %Select upper case letters\n        text(selectedLetters) = char( mod( text(selectedLetters)-'A'+13,26 )+'A' );\n        \n        selectedLetters = ( (text >= 'a') & (text <= 'z') ); %Select lower case letters\n        text(selectedLetters) = char( mod( text(selectedLetters)-'a'+13,26 )+'a' );\n\n    else\n        error('Argument must be a string.')\n    end\nend\n\n\n>> plainText = char((64:123))\n\nplainText =\n\n@ABCDEFGHIJKLMNOPQRSTUVWXYZ[\\]^_`abcdefghijklmnopqrstuvwxyz{\n\n>> rot13(plainText)\n\nans =\n\n@NOPQRSTUVWXYZABCDEFGHIJKLM[\\]^_`nopqrstuvwxyzabcdefghijklm{\n\n", "explain": "Call it like this:\nIt is possible to vectorize this code, the example below is not fully vectorized in order to make the order of operations clear. It is possible to reduce this solution to two lines by integrating the \"selectedLetters\" calculations directly into the line following them.\nSample Output:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram test_rot_13\n\n  implicit none\n  integer, parameter :: len_max = 256\n  integer, parameter :: unit = 10\n  character (len_max) :: file\n  character (len_max) :: fmt\n  character (len_max) :: line\n  integer :: arg\n  integer :: arg_max\n  integer :: iostat\n\n  write (fmt, '(a, i0, a)') '(a', len_max, ')'\n  arg_max = iargc ()\n  if (arg_max > 0) then\n! Encode all files listed on the command line.\n    do arg = 1, arg_max\n      call getarg (arg, file)\n      open (unit, file = file, iostat = iostat)\n      if (iostat /= 0) cycle\n      do\n        read (unit, fmt = fmt, iostat = iostat) line\n        if (iostat /= 0) exit\n        write (*, '(a)') trim (rot_13 (line))\n      end do\n      close (unit)\n    end do\n  else\n! Encode standard input.\n    do\n      read (*, fmt = fmt, iostat = iostat) line\n      if (iostat /= 0) exit\n      write (*, '(a)') trim (rot_13 (line))\n    end do\n  end if\n\ncontains\n\n  function rot_13 (input) result (output)\n\n    implicit none\n    character (len_max), intent (in) :: input\n    character (len_max) :: output\n    integer :: i\n\n    output = input\n    do i = 1, len_trim (output)\n      select case (output (i : i))\n      case ('A' : 'M', 'a' : 'm')\n        output (i : i) = char (ichar (output (i : i)) + 13)\n      case ('N' : 'Z', 'n' : 'z')\n        output (i : i) = char (ichar (output (i : i)) - 13)\n      end select\n    end do\n\n  end function rot_13\n\nend program test_rot_13\n\n\n> cat foo.txt\nfoo\n> cat bar.txt\nbar\n> ./rot_13 foo.txt bar.txt\nsbb\none\n> ./rot_13 < foo.txt\nsbb\n> cat foo.txt bar.txt | ./rot_13\nsbb\none\n\n", "explain": "Note: iargc and getarg are common extensions that are implemented by e.g. the Intel Fortran Compiler, G95 and gfortran.\nSample usage:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc rot13char(c rune) rune {\n    if c >= 'a' && c <= 'm' || c >= 'A' && c <= 'M' {\n        return c + 13\n    } else if c >= 'n' && c <= 'z' || c >= 'N' && c <= 'Z' {\n        return c - 13\n    }\n    return c\n}\n\nfunc rot13(s string) string {\n    return strings.Map(rot13char, s)\n}\n\nfunc main() {\n    fmt.Println(rot13(\"nowhere ABJURER\"))\n}\n\n\nabjurer NOWHERE\n\n", "explain": "Output:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program rot13.s   */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n.equ STRINGSIZE,          500\n/************************************/\n/* Initialized data                 */\n/************************************/\n.data\nszMessString:            .asciz \"String\u00a0:\\n\"\nszMessEncrip:            .asciz \"\\nEncrypted\u00a0:\\n\"\nszMessDecrip:            .asciz \"\\nDecrypted\u00a0:\\n\"\nszString1:               .asciz \"{NOWHERE! abcd xyz 1234}\"\n\nszCarriageReturn:       .asciz \"\\n\"\n/************************************/\n/* UnInitialized data               */\n/************************************/\n.bss \nszString2:                .skip  STRINGSIZE\nszString3:                .skip  STRINGSIZE\n/************************************/\n/*  code section                    */\n/************************************/\n.text\n.global main \nmain: \n\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszString1                        @ display string\n    bl affichageMess\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszString2\n    bl encryptRot13\n    ldr r0,iAdrszMessEncrip\n    bl affichageMess\n    ldr r0,iAdrszString2                        @ display string\n    bl affichageMess \n    ldr r0,iAdrszString2\n    ldr r1,iAdrszString3\n    bl decryptRot13\n    ldr r0,iAdrszMessDecrip\n    bl affichageMess\n    ldr r0,iAdrszString3                        @ display string\n    bl affichageMess \n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess \n100:                                            @ standard end of the program\n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc 0                                       @ perform system call\niAdrszMessString:         .int szMessString\niAdrszMessDecrip:         .int szMessDecrip\niAdrszMessEncrip:         .int szMessEncrip\niAdrszString1:            .int szString1\niAdrszString2:            .int szString2\niAdrszString3:            .int szString3\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     encrypt strings                         */ \n/******************************************************************/\n/* r0 contains the address of the string1 */\n/* r1 contains the address of the encrypted string */\nencryptRot13:\n    push {r3,r4,lr}           @ save  registers \n    mov r3,#0                 @ counter byte string 1\n    mov r2,#13                @ rot characters number\n1:\n    ldrb r4,[r0,r3]           @ load byte string 1\n    cmp r4,#0                 @ zero final\u00a0?\n    streqb r4,[r1,r3]\n    moveq r0,r3\n    beq 100f\n    cmp r4,#65                @ < A\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#90                @ > Z\n    bgt 2f\n    add r4,r2                 @ add key\n    cmp r4,#90                @ > Z\n    subgt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n2:\n    cmp r4,#97                @ < a\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#122               @> z\n    strgtb r4,[r1,r3]\n    addgt r3,#1\n    bgt 1b\n    add r4,r2\n    cmp r4,#122\n    subgt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n\n100:\n    pop {r3,r4,lr}            @ restaur registers\n    bx lr                     @ return\n/******************************************************************/\n/*     decrypt strings                                           */ \n/******************************************************************/\n/* r0 contains the address of the encrypted string1 */\n/* r1 contains the address of the decrypted string */\ndecryptRot13:\n    push {r3,r4,lr}          @ save  registers \n    mov r3,#0                @ counter byte string 1\n    mov r2,#13                @ rot characters number\n1:\n    ldrb r4,[r0,r3]          @ load byte string 1\n    cmp r4,#0                @ zero final\u00a0?\n    streqb r4,[r1,r3]\n    moveq r0,r3\n    beq 100f\n    cmp r4,#65               @ < A\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#90               @ > Z\n    bgt 2f\n    sub r4,r2                @ substract key\n    cmp r4,#65               @ < A\n    addlt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n2:\n    cmp r4,#97               @ < a\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#122              @ > z\n    strgtb r4,[r1,r3]\n    addgt r3,#1\n    bgt 1b\n    sub r4,r2                @ substract key\n    cmp r4,#97               @ < a\n    addlt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n\n100:\n    pop {r3,r4,lr}           @ restaur registers\n    bx lr                    @ return\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n/* for this file see task include a file in language ARM assembly*/\n.include \"../affichage.inc\"\n\nOutput:\nString\u00a0:\n{NOWHERE! abcd xyz 1234}\nEncrypted\u00a0:\n{ABJURER! nopq klm 1234}\nDecrypted\u00a0:\n{NOWHERE! abcd xyz 1234}\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "X86_Assembly", "code": "\n\nformat \tELF \texecutable 3\nentry \tstart\n\t\nsegment\treadable writeable\nbuf\trb\t1\n\t\nsegment\treadable executable\nstart:\tmov\teax, 3\t\t; syscall \"read\"\n\tmov\tebx, 0\t\t; stdin\n\tmov\tecx, buf\t; buffer for read byte\n\tmov\tedx, 1\t\t; len (read one byte)\n\tint\t80h\n\n\tcmp\teax, 0\t\t; EOF?\n\tjz\texit\n\n\txor \teax, eax\t; load read char to eax\n\tmov\tal, [buf]\n\tcmp\teax, \"A\"\t; see if it is in ascii a-z or A-Z\n\tjl\tprint\n\tcmp\teax, \"z\"\n\tjg\tprint\n\tcmp\teax, \"Z\"\n\tjle\trotup\n\tcmp\teax, \"a\"\n\tjge\trotlow\n\tjmp\tprint\n\nrotup:\tsub\teax, \"A\"-13\t; do rot 13 for A-Z\n\tcdq\n\tmov\tebx, 26\n\tdiv\tebx\n\tadd\tedx, \"A\"\n\tjmp\trotend\n\t\nrotlow:\tsub\teax, \"a\"-13\t; do rot 13 for a-z\n\tcdq\n\tmov\tebx, 26\n\tdiv\tebx\n\tadd\tedx, \"a\"\n\nrotend:\tmov\t[buf], dl\n\t\nprint: \tmov\teax, 4\t\t; syscall write\n\tmov\tebx, 1\t\t; stdout\n\tmov\tecx, buf\t; *char\n\tmov\tedx, 1\t\t; string length\n\tint\t80h\n\n\tjmp\tstart\n\nexit: \tmov     eax,1\t\t; syscall exit\n\txor     ebx,ebx\t\t; exit code\n\tint     80h\n", "explain": "Using Linux/FASM.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nTranslation of: Go\nprogram Rot13;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\nfunction Rot13char(c: AnsiChar): AnsiChar;\nbegin\n  Result := c;\n  if c in ['a'..'m', 'A'..'M'] then\n    Result := AnsiChar(ord(c) + 13)\n  else if c in ['n'..'z', 'N'..'Z'] then\n    Result := AnsiChar(ord(c) - 13);\nend;\n\nfunction Rot13Fn(s: ansistring): ansistring;\nvar i: Integer;\nbegin\n  SetLength(result, length(s));\n  for i := 1 to length(s) do\n    Result[i] := Rot13char(s[i]);\nend;\n\nbegin\n  writeln(Rot13Fn('nowhere ABJURER'));\n  readln;\nend.\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Ruby", "code": "\n# Returns a copy of _s_ with rot13 encoding.\ndef rot13(s)\n  s.tr('A-Za-z', 'N-ZA-Mn-za-m')\nend\n\n# Perform rot13 on files from command line, or standard input.\nwhile line = ARGF.gets\n  print rot13(line)\nend\n\nABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\n\n\nNOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\n\n", "explain": "One can run ruby rot13.rb file1 file2 to rot13 those files, or run ruby rot13.rb to rot13 the standard input.\nInput:\nOutput:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Rust", "code": "\nfn rot13(string: &str) -> String {\n    string.chars().map(|c| {\n        match c {\n            'a'..='m' | 'A'..='M' => ((c as u8) + 13) as char,\n            'n'..='z' | 'N'..='Z' => ((c as u8) - 13) as char,\n            _ => c\n        }\n    }).collect()\n}\n\nfn main () {\n    assert_eq!(rot13(\"abc\"), \"nop\");\n}\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Swift", "code": "\nfunc rot13char(c: UnicodeScalar) -> UnicodeScalar {\n  switch c {\n  case \"A\"...\"M\", \"a\"...\"m\":\n    return UnicodeScalar(UInt32(c) + 13)\n  case \"N\"...\"Z\", \"n\"...\"z\":\n    return UnicodeScalar(UInt32(c) - 13)\n  default:\n    return c\n  }\n}\n\nfunc rot13(str: String) -> String {\n  return String(map(str.unicodeScalars){ c in Character(rot13char(c)) })\n}\n\nprintln(rot13(\"The quick brown fox jumps over the lazy dog\"))\n\nOutput:\nGur dhvpx oebja sbk whzcf bire gur ynml qbt\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "R", "code": "\nrot13 <- function(x)\n{\n  old <- paste(letters, LETTERS, collapse=\"\", sep=\"\")\n  new <- paste(substr(old, 27, 52), substr(old, 1, 26), sep=\"\")\n  chartr(old, new, x)\n}\nx <- \"The Quick Brown Fox Jumps Over The Lazy Dog!.,:;'#~[]{}\"\nrot13(x)   # \"Gur Dhvpx Oebja Sbk Whzcf Bire Gur Ynml Qbt!.,:;'#~[]{}\"\nx2 <- paste(letters, LETTERS, collapse=\"\", sep=\"\")\nrot13(x2)  # \"nNoOpPqQrRsStTuUvVwWxXyYzZaAbBcCdDeEfFgGhHiIjJkKlLmM\"\n\n", "explain": "For a slightly more general function, see the example on the chartr help page.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "COBOL", "code": "\nWorks with: COBOL-85\n\nFORMAT IDENTIFICATION DIVISION.\n       PROGRAM-ID. rot-13.\n\n       DATA DIVISION.\n       LINKAGE SECTION.\n       77  in-str       PIC X(100).\n       77  out-str      PIC X(100).\n\n       PROCEDURE DIVISION USING BY REFERENCE in-str, out-str.\n           MOVE in-str TO out-str\n           INSPECT out-str\n               CONVERTING \"abcdefghijklmnopqrstuvwxyz\"\n               TO \"nopqrstuvwxyzabcdefghijklm\"\n           INSPECT out-str\n               CONVERTING \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n               TO \"NOPQRSTUVWXYZABCDEFGHIJKLM\"\n           EXIT PROGRAM.\n\n       END PROGRAM rot-13.\n\nWorks with: COBOL 2002\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. rot-13.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  STR-LENGTH   CONSTANT AS 100.\n01  normal-lower CONSTANT AS \"abcdefghijklmnopqrstuvwxyz\".\n01  rot13-lower  CONSTANT AS \"nopqrstuvwxyzabcdefghijklm\".\n01  normal-upper CONSTANT AS \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n01  rot13-upper  CONSTANT AS \"NOPQRSTUVWXYZABCDEFGHIJKLM\".\nLINKAGE SECTION.\n77  in-str       PICTURE IS X(STR-LENGTH).\n77  out-str      PICTURE IS X(STR-LENGTH).\n\nPROCEDURE DIVISION USING in-str, RETURNING out-str.\n    MOVE in-str TO out-str\n    INSPECT out-str CONVERTING normal-lower TO rot13-lower\n    INSPECT out-str CONVERTING normal-upper TO rot13-upper\n    GOBACK.\n\nEND FUNCTION rot-13.\n\n", "explain": "Strict COBOL-85 implementation.\nA more modern version, with a user-defined function and compile-time constants.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\nFunction ROT13(ByVal a As String) As String\n  Dim i As Long\n  Dim n As Integer, e As Integer\n\n  ROT13 = a\n  For i = 1 To Len(a)\n    n = Asc(Mid$(a, i, 1))\n    Select Case n\n      Case 65 To 90\n        e = 90\n        n = n + 13\n      Case 97 To 122\n        e = 122\n        n = n + 13\n      Case Else\n        e = 255\n    End Select\n  \n    If n > e Then\n      n = n - 26\n    End If\n    Mid$(ROT13, i, 1) = Chr$(n)\n  Next i\nEnd Function\n\nSub Main()\n  Debug.Assert ROT13(\"abc\") = \"nop\"\n  Debug.Assert ROT13(\"nop\") = \"abc\"\nEnd Sub\n", "explain": "Testing:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Ada", "code": "\nwith Ada.Text_IO.Text_Streams; use Ada.Text_IO.Text_Streams;\nwith Ada.Strings.Maps; use Ada.Strings.Maps;\nwith Ada.Command_Line; use Ada.Command_Line;\n\nprocedure Rot_13 is\n   \n   From_Sequence : Character_Sequence := \"abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n   Result_Sequence : Character_Sequence := \"nopqrstuvwxyzabcdefghijklmNOPQRSTUVWXYZABCDEFGHIJKLM\";\n   Rot_13_Mapping : Character_Mapping := To_Mapping(From_Sequence, Result_Sequence);\n\n   In_Char : Character;\n   Stdio : Stream_Access := Stream(Ada.Text_IO.Standard_Input);\n   Stdout : Stream_Access := Stream(Ada.Text_Io.Standard_Output);\n   Input : Ada.Text_Io.File_Type;\n \nbegin\n   if Argument_Count > 0 then\n      for I in 1..Argument_Count loop\n         begin\n            Ada.Text_Io.Open(File => Input, Mode => Ada.Text_Io.In_File, Name => Argument(I));\n            Stdio := Stream(Input);\n             while not Ada.Text_Io.End_Of_File(Input) loop\n               In_Char :=Character'Input(Stdio); \n               Character'Output(Stdout, Value(Rot_13_Mapping, In_Char));\n            end loop;\n            Ada.Text_IO.Close(Input);\n         exception\n            when Ada.Text_IO.Name_Error =>\n               Ada.Text_Io.Put_Line(File => Ada.Text_Io.Standard_Error, Item => \"File \" & Argument(I) & \" is not a file.\");\n            when Ada.Text_Io.Status_Error =>\n               Ada.Text_Io.Put_Line(File => Ada.Text_Io.Standard_Error, Item => \"File \" & Argument(I) & \" is already opened.\");\n         end;\n      end loop;\n   else\n      while not Ada.Text_Io.End_Of_File loop\n         In_Char :=Character'Input(Stdio); \n         Character'Output(Stdout, Value(Rot_13_Mapping, In_Char));\n      end loop;\n   end if;\nend Rot_13;\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Julia", "code": "\n# Julia 1.0\nfunction rot13(c::Char)\n    shft = islowercase(c) ? 'a' : 'A'\n    isletter(c) ? c = shft + (c - shft + 13) % 26 : c\nend\n\nrot13(str::AbstractString) = map(rot13, str)\n\n\nOutput:\njulia> rot13(\"abcdefghijklmnopqrtuvwxyz 123 ABCDEFGHIJKLMNOPQRTUVWXYZ\")\n\"nopqrstuvwxyzabcdeghijklm 123 NOPQRSTUVWXYZABCDEGHIJKLM\"\n\nAlternative version[edit]\nreplace(\"nowhere ABJURER\", r\"[A-Za-z]\" => s -> map(c -> c + (uppercase(c) < 'N' ? 13 : -13), s))\n\n\nOutput:\nabjurer NOWHERE\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Kotlin", "code": "\nimport java.io.*\n\nfun String.rot13() = map {\n    when {\n        it.isUpperCase() -> { val x = it + 13; if (x > 'Z') x - 26 else x }\n        it.isLowerCase() -> { val x = it + 13; if (x > 'z') x - 26 else x }\n        else -> it\n    } }.toCharArray()\n\nfun InputStreamReader.println() =\n        try { BufferedReader(this).forEachLine { println(it.rot13()) } }\n        catch (e: IOException) { e.printStackTrace() }\n\nfun main(args: Array<String>) {\n    if (args.any())\n        args.forEach { FileReader(it).println() }\n    else\n        InputStreamReader(System.`in`).println()\n}\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Perl", "code": "\nsub rot13 {\n  shift =~ tr/A-Za-z/N-ZA-Mn-za-m/r;\n}\n \nprint rot13($_) while (<>);\n\nNOWHERE Abjurer\n\n\nABJURER Nowhere\n\n\nperl -pe 'tr/A-Za-z/N-ZA-Mn-za-m/'\n", "explain": "Input:\nOutput:\nOne-liner version:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Prolog", "code": "\n\n:- use_module(library(ctypes)).\n\nruntime_entry(start)\u00a0:-\n\tprompt(_, ''),\n\trot13.\n\nrot13\u00a0:-\n\tget0(Ch),\n\t(   is_endfile(Ch) ->\n\t\ttrue\n\t;   rot13_char(Ch, Rot),\n\t    put(Rot),\n\t    rot13\n\t).\n\nrot13_char(Ch, Rot)\u00a0:-\n\t(   is_alpha(Ch) ->\n\t\tto_upper(Ch, Up),\n\t\tLetter is Up - 0'A,\n\t\tRot is Ch + ((Letter + 13) mod 26) - Letter\n\t;   Rot = Ch\n\t).\n\nrot13(Str, SR)\u00a0:-\n\tmaplist(rot, Str, Str1),\n\tstring_to_list(SR, Str1).\n\nrot(C, C1)\u00a0:-\n\t(   member(C, \"abcdefghijklmABCDEFGHIJKLM\") -> C1 is C+13;\n\t    (\tmember(C, \"nopqrstuvwxyzNOPQRSTUVWXYZ\") -> C1 is C-13; C1 = C)).\n\n\u00a0?- rot13(\"The Quick Brown Fox Jumped Over The Lazy Dog!\", SR).\nSR = \"Gur Dhvpx Oebja Sbk Whzcrq Bire Gur Ynml Qbt!\".\n", "explain": "Works with Quintus Prolog.\nWorks with SWI-Prolog.\nOutput\u00a0:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Lua", "code": "\nfunction rot13(s)\n\tlocal a = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz\"\n\tlocal b = \"NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm\"\n\treturn (s:gsub(\"%a\", function(c) return b:sub(a:find(c)) end))\nend\n\nAlternative version[edit]\nfunction rot13(s)\n  return (s:gsub(\"%a\", function(c) c=c:byte() return string.char(c+(c%32<14 and 13 or -13)) end))\nend\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Scala", "code": "\nscala> def rot13(s: String) = s map {\n     |   case c if 'a' <= c.toLower && c.toLower <= 'm' => c + 13 toChar\n     |   case c if 'n' <= c.toLower && c.toLower <= 'z' => c - 13 toChar\n     |   case c => c\n     | }\nrot13: (s: String)String\n\nscala> rot13(\"7 Cities of Gold.\")\nres61: String = 7 Pvgvrf bs Tbyq.\n\nscala> rot13(res61)\nres62: String = 7 Cities of Gold.\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "D", "code": "\nUsing Standard Functions[edit]\nimport std.stdio;\nimport std.ascii: letters, U = uppercase, L = lowercase;\nimport std.string: makeTrans, translate;\n\nimmutable r13 = makeTrans(letters,\n                          //U[13 .. $] ~ U[0 .. 13] ~\n                          U[13 .. U.length] ~ U[0 .. 13] ~\n                          L[13 .. L.length] ~ L[0 .. 13]);\n\nvoid main() {\n    writeln(\"This is the 1st test!\".translate(r13, null));\n}\n\n\nOutput:\nThe Quick Brown Fox Jumps Over The Lazy Dog!\nImperative Implementation[edit]\nimport std.stdio, std.string, std.traits;\n\npure S rot13(S)(in S s) if (isSomeString!S) {\n    return rot(s, 13);\n}\n\npure S rot(S)(in S s, in int key) if (isSomeString!S) {\n    auto r = s.dup;\n\n    foreach (i, ref c; r) {\n        if ('a' <= c && c <= 'z')\n            c = ((c - 'a' + key) % 26 + 'a');\n        else if ('A' <= c && c <= 'Z')\n            c = ((c - 'A' + key) % 26 + 'A');\n    }\n    return cast(S) r;\n}\n\nvoid main() {\n    \"Gur Dhvpx Oebja Sbk Whzcf Bire Gur Ynml Qbt!\".rot13().writeln();\n}\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Haskell", "code": "\n\nimport Data.Char (chr, isAlpha, ord, toLower)\nimport Data.Bool (bool)\n\nrot13 :: Char -> Char\nrot13 c\n  | isAlpha c = chr $ bool (-) (+) ('m' >= toLower c) (ord c) 13\n  | otherwise = c\n\n-- Simple test\nmain :: IO ()\nmain = print $ rot13 <$> \"Abjurer nowhere\"\n\n\nimport Data.Char (chr, isAlpha, ord, toLower)\nimport Data.Bool (bool)\n\nrot13 :: Char -> Char\nrot13 =\n  let rot = flip ((bool (-) (+) . ('m' >=) . toLower) <*> ord)\n  in (bool <*> chr . rot 13) <*> isAlpha\n\n-- Simple test\nmain :: IO ()\nmain = print $ rot13 <$> \"Abjurer nowhere\"\n\n\nOutput:\n\"Nowhere abjurer\"\n\nimport System.Environment\nimport System.IO\nimport System.Directory\nimport Control.Monad\n\nhInteract :: (String -> String) -> Handle -> Handle -> IO ()\nhInteract f hIn hOut =\n  hGetContents hIn >>= hPutStr hOut . f\n\nprocessByTemp :: (Handle -> Handle -> IO ()) -> String -> IO ()\nprocessByTemp f name = do\n  hIn <- openFile name ReadMode\n  let tmp = name ++ \"$\" \n  hOut <- openFile tmp WriteMode\n  f hIn hOut\n  hClose hIn\n  hClose hOut\n  removeFile name\n  renameFile tmp name\n\nprocess :: (Handle -> Handle -> IO ()) -> [String] -> IO ()\nprocess f [] = f stdin stdout\nprocess f ns = mapM_ (processByTemp f) ns\n\n\nmain = do\n names <- getArgs\n process (hInteract (map rot13)) names\n\n\n", "explain": "Straightforward implementation by checking multiple cases:\nOr in point-free applicative terms:\nTo wrap rot13 as a utility program, here's a quick implementation of a general framework:\nThen the wrapped program is simply \nNote that the framework will read the file lazily, which also provides buffering.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "PL/SQL", "code": "\n-- Works for VARCHAR2 (up to 32k chars)\nCREATE OR REPLACE FUNCTION fn_rot13_native(p_text VARCHAR2) RETURN VARCHAR2 IS\n  c_source CONSTANT VARCHAR2(52)\u00a0:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n  c_target CONSTANT VARCHAR2(52)\u00a0:= 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm';\nBEGIN\n  RETURN TRANSLATE(p_text, c_source, c_target);\nEND;\n/\n\n-- For CLOBs (translate only works with VARCHAR2, so do it in chunks)\nCREATE OR REPLACE FUNCTION fn_rot13_clob(p_text CLOB) RETURN CLOB IS\n  c_source CONSTANT VARCHAR2(52)\u00a0:= 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz';\n  c_target CONSTANT VARCHAR2(52)\u00a0:= 'NOPQRSTUVWXYZABCDEFGHIJKLMnopqrstuvwxyzabcdefghijklm';\n  c_chunk_size CONSTANT PLS_INTEGER\u00a0:= 4000;\n  v_result CLOB\u00a0:= NULL;\nBEGIN\n  FOR i IN 0..TRUNC(LENGTH(p_text) / c_chunk_size) LOOP\n    v_result\u00a0:= v_result || \n      TRANSLATE(dbms_lob.substr(p_text, c_chunk_size, i * c_chunk_size + 1), c_source, c_target);\n  END LOOP;\n  RETURN v_result;\nEND;\n/\n\n-- The full algorithm (Slower. And MUCH slower if using CLOB!)\nCREATE OR REPLACE FUNCTION fn_rot13_algorithm(p_text VARCHAR2) RETURN CLOB IS\n  c_upper_a CONSTANT PLS_INTEGER\u00a0:= ASCII('A');\n  c_lower_a CONSTANT PLS_INTEGER\u00a0:= ASCII('a');\n  v_rot VARCHAR2(32000);\n  v_char VARCHAR2(1);\nBEGIN\n  FOR i IN 1..LENGTH(p_text) LOOP\n    v_char\u00a0:= SUBSTR(p_text, i, 1);\n    IF v_char BETWEEN 'A' AND 'Z' THEN\n      v_rot\u00a0:= v_rot || CHR(MOD(ASCII(v_char) - c_upper_a + 13, 26) + c_upper_a);\n    ELSIF v_char BETWEEN 'a' AND 'z' THEN\n      v_rot\u00a0:= v_rot || CHR(MOD(ASCII(v_char) - c_lower_a + 13, 26) + c_lower_a);\n    ELSE\n      v_rot\u00a0:= v_rot || v_char;\n    END IF;\n  END LOOP;\n  RETURN v_rot;\nEND;\n/\n\nOutput:\nSELECT fn_rot13_native('Hello ROT-13') FROM DUAL;\nSELECT fn_rot13_clob('Hello ROT-13') FROM DUAL;\nSELECT fn_rot13_algorithm('Hello ROT-13') FROM DUAL;\n\n-- All return:\n-- Uryyb EBG-13\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "VBScript", "code": "\noption explicit \n\nfunction rot13(a)\n  dim b,n1,n,i\n  b=\"\"\n  for i=1 to len(a)\n    n=asc(mid(a,i,1))\n    if n>=65 and n<= 91 then\n       n1=(((n-65)+13)mod 26)+65\n    elseif n>=97 and n<= 123 then\n       n1=(((n-97)+13)mod 26)+97\n    else\n        n1=n\n    end if\n    b=b & chr(n1)\n  next  \n  rot13=b\nend function\n\nconst a=\"The quick brown fox jumps over the lazy dog.\"\ndim b,c\nwscript.echo a \nb=rot13(a)\nwscript.echo b    \nc=rot13(b)\nwscript.echo c\n\nOutput:\nThe quick brown fox jumps over the lazy dog.\nGur dhvpx oebja sbk whzcf bire gur ynml qbt.\nThe quick brown fox jumps over the lazy dog.\n\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Scheme", "code": "\n(define (rot13 str)\n  (define (rot13-char c)\n    (integer->char (+ (char->integer c)\n                      (cond ((and (char>=? c #\\a) (char<? c #\\n))\n                             13)\n                            ((and (char>=? c #\\A) (char<? c #\\N))\n                             13)\n                            ((and (char>=? c #\\n) (char<=? c #\\z))\n                             -13)\n                            ((and (char>=? c #\\N) (char<=? c #\\Z))\n                             -13)\n                            (else\n                             0)))))\n  (list->string (map rot13-char (string->list str))))\nR7RS[edit]\nWorks with: Chibi-Scheme\nWorks with: Chicken Scheme\nWorks with: Gambit Scheme\nWorks with: Gauche\nWorks with: Guile\n\nfewer redundant tests\nloops over input lines\nconforms to R7RS\n;; Works with: chibi, csi, gosh, gsi, guile\n(cond-expand\n (r7rs (import (scheme base)\n               (scheme write)))\n (gambit)\n (chicken (import (r7rs))))\n\n(define char-rot13\n  (let* ((A (char->integer #\\A))\n         (N (char->integer #\\N))\n         (Z (char->integer #\\Z))\n         (a (char->integer #\\a))\n         (n (char->integer #\\n))\n         (z (char->integer #\\z))\n         (inc 13)\n         (dec (- inc))\n         (rot (lambda (c direction)\n                (integer->char (+ c direction)))))\n    (lambda (ch)\n      (let ((c (char->integer ch)))\n        (if (>= c A)\n            (if (< c N)\n                (rot c inc)\n                (if (<= c Z)\n                    (rot c dec)\n                    (if (>= c a)\n                        (if (< c n)\n                            (rot c inc)\n                            (if (<= c z)\n                                (rot c dec)\n                                ch))))))))))\n\n(define (string-rot13 str)\n  (string-map char-rot13 str))\n\n(if (not (and (string=? (string-rot13 \"abcdefghijklmnopqrstuvwxyz\")\n                        \"nopqrstuvwxyzabcdefghijklm\")\n              (string=? (string-rot13 \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\")\n                        \"NOPQRSTUVWXYZABCDEFGHIJKLM\")))\n    (error \"Test failed.\"))\n\n(let loop ((line (read-line)))\n  (if (string? line)\n      (begin\n        (display (string-rot13 line))\n        (newline)\n        (loop (read-line)))))\n", "explain": "An alternative version with the following modification:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "PowerShell", "code": "\n$e = \"This is a test Guvf vf n grfg\"\n\n[char[]](0..64+78..90+65..77+91..96+110..122+97..109+123..255)[[char[]]$e] -join \"\"\n\nfunction Invoke-Rot13 {\n  param(\n    [char[]]$message\n  )\n  begin {\n    $outString = New-Object System.Collections.ArrayList\n    $alpha = 'a','b','c','d','e','f','g','h','i','j','k','l','m','n','o','p','q','r','s','t','u','v','w','x','y','z'\n    $alphaL = $alpha + $alpha\n    $alphaU = $alphaL.toUpper()\n    $int = 13\n  }\n  process{\n    $message | ForEach-Object {\n      # test if char is special\n      if ($_ -match '[^\\p{L}\\p{Nd}]') {\n        $outString += $_\n      }\n      # test if char is digit\n      elseif ($_ -match '\\d') {\n        $outString += $_\n      }\n      # test if char is upperCase\n      elseif ($_ -ceq $_.ToString().ToUpper()) {\n        $charIndex = $alphaU.IndexOf($_.tostring())\n        $outString += $alphaU[$charIndex+$int]\n      }\n      # test if char is lowerCase\n      elseif ($_ -ceq $_.ToString().ToLower()) {\n        $charIndex = $alphaL.IndexOf($_.tostring())\n        $outString += $alphaL[$charIndex+$int]\n      }\n      else {\n        $outString += $_\n      }\n    } # end foreach\n  } # end process\n  end {\n    # output string and join all chars\n    $outString -join \"\"\n  }\n} # end function\n\nPS> $message = '{!This is /A\\ Test123}'\nPS> $messageE = Invoke-Rot13 -message $message\nPS> $messageE\nPS> Invoke-Rot13 -message $messageE\n{!Guvf vf /N\\ Grfg123}\n{!This is /A\\ Test123}\n", "explain": "A more POSH way..\nOutPut\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Logo", "code": "\nto rot13 :c\n  make \"a difference ascii lowercase :c  ascii \"a\n  if or :a < 0 :a > 25 [output :c]\n  make \"delta ifelse :a < 13 [13] [-13]\n  output char sum :delta ascii :c\nend\n\nprint map \"rot13 \"|abjurer NOWHERE|\nnowhere ABJURER\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "F#", "code": "\n\nlet rot13 (s : string) =\n   let rot c =\n       match c with\n       | c when c > 64 && c < 91 -> ((c - 65 + 13) % 26) + 65\n       | c when c > 96 && c < 123 -> ((c - 97 + 13) % 26) + 97\n       | _ -> c\n   s |> Array.of_seq\n   |> Array.map(int >> rot >> char)\n   |> (fun seq -> new string(seq))\n\n", "explain": "Illustrates turning a string into an array of chars then composition of type casting with a conversion function. We create a composite that converts its input to an integer, calls the convertion function and\nthen casts to a char type. The result is an array of modified chars that we can use to create a new string.\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Groovy", "code": "\n\ndef rot13 = { String s ->\n    (s as List).collect { ch ->\n        switch (ch) {\n            case ('a'..'m') + ('A'..'M'):\n                return (((ch as char) + 13) as char)\n            case ('n'..'z') + ('N'..'Z'):\n                return (((ch as char) - 13) as char)\n            default:\n                return ch\n        }\n    }.inject (\"\") { string, ch -> string += ch}\n}\n\n\nprintln rot13(\"Noyr jnf V, 'rer V fnj Ryon.\")\n\n\nAble was I, 'ere I saw Elba.\n", "explain": "Solution:\nTest program:\nOutput:\n"}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "Zig", "code": "\n// Warning: modifies the buffer in-place (returns pointer to in)\nfn rot13(in: [] u8) []u8 {\n    for (in) |*c| {\n        var d\u00a0: u8 = c.*;\n        var x\u00a0: u8 = d;\n        x = if (@subWithOverflow(u8, d | 32, 97, &x) ) x else x;\n        if (x < 26) {\n            x = (x + 13)\u00a0% 26 + 65 + (d & 32);\n            c.* = x;\n        }        \n    }\n    return in;\n}\n\nconst msg: [:0] const u8 = \n    \\\\Lbh xabj vg vf tbvat gb or n onq qnl\n    \\\\ jura gur yrggref va lbhe nycunorg fbhc\n    \\\\ fcryy Q-V-F-N-F-G-R-E.\n;\n\n// need to copy the const string to a buffer\n// before we can modify it in-place\n//https://zig.news/kristoff/what-s-a-string-literal-in-zig-31e9\n\nvar buf: [500]u8 = undefined;\nfn assignStr(out: []u8, str: [:0]const u8) void {\n    for (str) |c, i| {\n        out[i] = c;\n    }\n    out[str.len] = 0;\n}\n\nconst print = @import(\"std\").debug.print;\n\npub fn main() void {\n    assignStr(&buf, msg);\n    print(\"rot13={s}\\n\",.{rot13(&buf)});\n}\n", "explain": ""}, {"task_name": "Rot-13", "task_url": "https://rosettacode.org/wiki/Rot-13", "task_cat": "Encryption", "lang": "AWK", "code": "\nWorks with: gawk\n# usage: awk -f rot13.awk \nBEGIN {\n  for(i=0; i < 256; i++) {\n    amap[sprintf(\"%c\", i)] = i\n  }\n  for(l=amap[\"a\"]; l <= amap[\"z\"]; l++) {\n    rot13[l] = sprintf(\"%c\", (((l-amap[\"a\"])+13) % 26 ) + amap[\"a\"])\n  }\n  FS = \"\"\n}\n{\n  o = \"\"\n  for(i=1; i <= NF; i++) {\n    if ( amap[tolower($i)] in rot13 ) {\n      c = rot13[amap[tolower($i)]]\n      if ( tolower($i) != $i ) c = toupper(c)\n      o = o c\n    } else {\n      o = o $i\n    }\n  }\n  print o\n}\n\n\nInput:\nHello, HAL\u00a0!\n\n\nOutput:\nUryyb, UNY\u00a0!\n\n", "explain": ""}]