[{"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Python", "code": "\n\nfrom heapq import heappush, heappop, heapify\nfrom collections import defaultdict\n\ndef encode(symb2freq):\n    \"\"\"Huffman encode the given dict mapping symbols to weights\"\"\"\n    heap = [[wt, [sym, \"\"]] for sym, wt in symb2freq.items()]\n    heapify(heap)\n    while len(heap) > 1:\n        lo = heappop(heap)\n        hi = heappop(heap)\n        for pair in lo[1:]:\n            pair[1] = '0' + pair[1]\n        for pair in hi[1:]:\n            pair[1] = '1' + pair[1]\n        heappush(heap, [lo[0] + hi[0]] + lo[1:] + hi[1:])\n    return sorted(heappop(heap)[1:], key=lambda p: (len(p[-1]), p))\n\ntxt = \"this is an example for huffman encoding\"\nsymb2freq = defaultdict(int)\nfor ch in txt:\n    symb2freq[ch] += 1\n# in Python 3.1+:\n# symb2freq = collections.Counter(txt)\nhuff = encode(symb2freq)\nprint \"Symbol\\tWeight\\tHuffman Code\"\nfor p in huff:\n    print \"%s\\t%s\\t%s\" % (p[0], symb2freq[p[0]], p[1])\n\n\nOutput:\nSymbol  Weight  Huffman Code\n    6   101\nn   4   010\na   3   1001\ne   3   1100\nf   3   1101\nh   2   0001\ni   3   1110\nm   2   0010\no   2   0011\ns   2   0111\ng   1   00000\nl   1   00001\np   1   01100\nr   1   01101\nt   1   10000\nu   1   10001\nx   1   11110\nc   1   111110\nd   1   111111\n\nAlternative[edit]\n\n\"\"\"Huffman encoding and decoding. Requires Python >= 3.7.\"\"\"\nfrom __future__ import annotations\n\nfrom collections import Counter\n\nfrom heapq import heapify\nfrom heapq import heappush\nfrom heapq import heappop\n\nfrom itertools import chain\nfrom itertools import islice\n\nfrom typing import BinaryIO\nfrom typing import Dict\nfrom typing import Iterable\nfrom typing import Optional\nfrom typing import Tuple\n\n\nLEFT_BIT = \"0\"\nRIGHT_BIT = \"1\"\nWORD_SIZE = 8  # Assumed to be a multiple of 8.\nREAD_SIZE = WORD_SIZE // 8\nP_EOF = 1 << WORD_SIZE\n\n\nclass Node:\n    \"\"\"Huffman tree node.\"\"\"\n\n    def __init__(\n        self,\n        weight: int,\n        symbol: Optional[int] = None,\n        left: Optional[Node] = None,\n        right: Optional[Node] = None,\n    ):\n        self.weight = weight\n        self.symbol = symbol\n        self.left = left\n        self.right = right\n\n    def is_leaf(self) -> bool:\n        \"\"\"Return `True` if this node is a leaf node, or `False` otherwise.\"\"\"\n        return self.left is None and self.right is None\n\n    def __lt__(self, other: Node) -> bool:\n        return self.weight < other.weight\n\n\ndef huffman_tree(weights: Dict[int, int]) -> Node:\n    \"\"\"Build a prefix tree from a map of symbol frequencies.\"\"\"\n    heap = [Node(v, k) for k, v in weights.items()]\n    heapify(heap)\n\n    # Pseudo end-of-file with a weight of 1.\n    heappush(heap, Node(1, P_EOF))\n\n    while len(heap) > 1:\n        left, right = heappop(heap), heappop(heap)\n        node = Node(weight=left.weight + right.weight, left=left, right=right)\n        heappush(heap, node)\n\n    return heappop(heap)\n\n\ndef huffman_table(tree: Node) -> Dict[int, str]:\n    \"\"\"Build a table of prefix codes by visiting every leaf node in `tree`.\"\"\"\n    codes: Dict[int, str] = {}\n\n    def walk(node: Optional[Node], code: str = \"\"):\n        if node is None:\n            return\n\n        if node.is_leaf():\n            assert node.symbol\n            codes[node.symbol] = code\n            return\n\n        walk(node.left, code + LEFT_BIT)\n        walk(node.right, code + RIGHT_BIT)\n\n    walk(tree)\n    return codes\n\n\ndef huffman_encode(data: bytes) -> Tuple[Iterable[bytes], Node]:\n    \"\"\"Encode the given byte string using Huffman coding.\n\n    Returns the encoded byte stream and the Huffman tree required to\n    decode those bytes.\n    \"\"\"\n    weights = Counter(data)\n    tree = huffman_tree(weights)\n    table = huffman_table(tree)\n    return _encode(data, table), tree\n\n\ndef huffman_decode(data: Iterable[bytes], tree: Node) -> bytes:\n    \"\"\"Decode the given byte stream using a Huffman tree.\"\"\"\n    return bytes(_decode(_bits_from_bytes(data), tree))\n\n\ndef _encode(stream: Iterable[int], codes: Dict[int, str]) -> Iterable[bytes]:\n    bits = chain(chain.from_iterable(codes[s] for s in stream), codes[P_EOF])\n\n    # Pack bits (stream of 1s and 0s) one word at a time.\n    while True:\n        word = \"\".join(islice(bits, WORD_SIZE))  # Most significant bit first.\n        if not word:\n            break\n\n        # Pad last bits if they don't align to a whole word.\n        if len(word) < WORD_SIZE:\n            word = word.ljust(WORD_SIZE, \"0\")\n\n        # Byte order becomes relevant when READ_SIZE > 1.\n        yield int(word, 2).to_bytes(READ_SIZE, byteorder=\"big\", signed=False)\n\n\ndef _decode(bits: Iterable[str], tree: Node) -> Iterable[int]:\n    node = tree\n\n    for bit in bits:\n        if bit == LEFT_BIT:\n            assert node.left\n            node = node.left\n        else:\n            assert node.right\n            node = node.right\n\n        if node.symbol == P_EOF:\n            break\n\n        if node.is_leaf():\n            assert node.symbol\n            yield node.symbol\n            node = tree  # Back to the top of the tree.\n\n\ndef _word_to_bits(word: bytes) -> str:\n    \"\"\"Return the binary representation of a word given as a byte string,\n    including leading zeros up to WORD_SIZE.\n\n    For example, when WORD_SIZE is 8:\n        _word_to_bits(b'65') == '01000001'\n    \"\"\"\n    i = int.from_bytes(word, \"big\")\n    return bin(i)[2:].zfill(WORD_SIZE)\n\n\ndef _bits_from_file(file: BinaryIO) -> Iterable[str]:\n    \"\"\"Generate a stream of bits (strings of either \"0\" or \"1\") from file-like\n    object `file`, opened in binary mode.\"\"\"\n    word = file.read(READ_SIZE)\n    while word:\n        yield from _word_to_bits(word)\n        word = file.read(READ_SIZE)\n\n\ndef _bits_from_bytes(stream: Iterable[bytes]) -> Iterable[str]:\n    \"\"\"Generate a stream of bits (strings of either \"0\" or \"1\") from an\n    iterable of single byte byte-strings.\"\"\"\n    return chain.from_iterable(_word_to_bits(byte) for byte in stream)\n\n\ndef main():\n    \"\"\"Example usage.\"\"\"\n    s = \"this is an example for huffman encoding\"\n    data = s.encode()  # Need a byte string\n    encoded, tree = huffman_encode(data)\n\n    # Pretty print the Huffman table\n    print(f\"Symbol Code\\n------ ----\")\n    for k, v in sorted(huffman_table(tree).items(), key=lambda x: len(x[1])):\n        print(f\"{chr(k):<6} {v}\")\n\n    # Print the bit pattern of the encoded data\n    print(\"\".join(_bits_from_bytes(encoded)))\n\n    # Encode then decode\n    decoded = huffman_decode(*huffman_encode(data))\n    print(decoded.decode())\n\n\nif __name__ == \"__main__\":\n    main()\n\n\nOutput:\nSymbol Code\n------ ----\nn      000\n       110\nm      0010\nh      0101\ni      1001\nf      1010\ne      1011\na      1110\nr      00110\nl      00111\nc      01000\nu      01001\nx      01100\nd      01101\nt      01110\np      01111\n\u0100      10000\ng      10001\no      11110\ns      11111\n011100101100111111110100111111110111000011010110110011100010011110011110111101010111100011011001010100110101010001011100001101011000010001111001101100100010001100000000\nthis is an example for huffman encoding\n\n", "explain": "A slight modification of the method outlined in the task description allows the code to be accumulated as the heap is manipulated.\nThe output is sorted first on length of the code, then on the symbols.\nAn extension to the method outlined above is given here.\nThis implementation creates an explicit tree structure, which is used during decoding. We also make use of a \"pseudo end of file\" symbol and padding bits to facilitate reading and writing encoded data to from/to a file.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n\n#define BYTES 256\n\nstruct huffcode {\n  int nbits;\n  int code;\n};\ntypedef struct huffcode huffcode_t;\n\nstruct huffheap {\n  int *h;\n  int n, s, cs;\n  long *f;\n};\ntypedef struct huffheap heap_t;\n\n/* heap handling funcs */\nstatic heap_t *_heap_create(int s, long *f)\n{\n  heap_t *h;\n  h = malloc(sizeof(heap_t));\n  h->h = malloc(sizeof(int)*s);\n  h->s = h->cs = s;\n  h->n = 0;\n  h->f = f;\n  return h;\n}\n\nstatic void _heap_destroy(heap_t *heap)\n{\n  free(heap->h);\n  free(heap);\n}\n\n#define swap_(I,J) do { int t_; t_ = a[(I)];\t\\\n      a[(I)] = a[(J)]; a[(J)] = t_; } while(0)\nstatic void _heap_sort(heap_t *heap)\n{\n  int i=1, j=2; /* gnome sort */\n  int *a = heap->h;\n\n  while(i < heap->n) { /* smaller values are kept at the end */\n    if ( heap->f[a[i-1]] >= heap->f[a[i]] ) {\n      i = j; j++;\n    } else {\n      swap_(i-1, i);\n      i--;\n      i = (i==0) ? j++ : i;\n    }\n  }\n}\n#undef swap_\n\nstatic void _heap_add(heap_t *heap, int c)\n{\n  if ( (heap->n + 1) > heap->s ) {\n    heap->h = realloc(heap->h, heap->s + heap->cs);\n    heap->s += heap->cs;\n  }\n  heap->h[heap->n] = c;\n  heap->n++;\n  _heap_sort(heap);\n}\n\nstatic int _heap_remove(heap_t *heap)\n{\n  if ( heap->n > 0 ) {\n    heap->n--;\n    return heap->h[heap->n];\n  }\n  return -1;\n}\n\n/* huffmann code generator */\nhuffcode_t **create_huffman_codes(long *freqs)\n{\n  huffcode_t **codes;\n  heap_t *heap;\n  long efreqs[BYTES*2];\n  int preds[BYTES*2];\n  int i, extf=BYTES;\n  int r1, r2;\n\n  memcpy(efreqs, freqs, sizeof(long)*BYTES);\n  memset(&efreqs[BYTES], 0, sizeof(long)*BYTES);\n\n  heap = _heap_create(BYTES*2, efreqs);\n  if ( heap == NULL ) return NULL;\n\n  for(i=0; i < BYTES; i++) if ( efreqs[i] > 0 ) _heap_add(heap, i);\n\n  while( heap->n > 1 )\n  {\n    r1 = _heap_remove(heap);\n    r2 = _heap_remove(heap);\n    efreqs[extf] = efreqs[r1] + efreqs[r2];\n    _heap_add(heap, extf);\n    preds[r1] = extf;\n    preds[r2] = -extf;\n    extf++;\n  }\n  r1 = _heap_remove(heap);\n  preds[r1] = r1;\n  _heap_destroy(heap);\n\n  codes = malloc(sizeof(huffcode_t *)*BYTES);\n\n  int bc, bn, ix;\n  for(i=0; i < BYTES; i++) {\n    bc=0; bn=0;\n    if ( efreqs[i] == 0 ) { codes[i] = NULL; continue; }\n    ix = i;\n    while( abs(preds[ix]) != ix ) {\n      bc |= ((preds[ix] >= 0) ? 1 : 0 ) << bn;\n      ix = abs(preds[ix]);\n      bn++;\n    }\n    codes[i] = malloc(sizeof(huffcode_t));\n    codes[i]->nbits = bn;\n    codes[i]->code = bc;\n  }\n  return codes;\n}\n\nvoid free_huffman_codes(huffcode_t **c)\n{\n  int i;\n\n  for(i=0; i < BYTES; i++) free(c[i]);\n  free(c);\n}\n\n#define MAXBITSPERCODE 100\n\nvoid inttobits(int c, int n, char *s)\n{\n  s[n] = 0;\n  while(n > 0) {\n    s[n-1] = (c%2) + '0';\n    c >>= 1; n--;\n  }\n}\n\nconst char *test = \"this is an example for huffman encoding\";\n\nint main()\n{\n  huffcode_t **r;\n  int i;\n  char strbit[MAXBITSPERCODE];\n  const char *p;\n  long freqs[BYTES];\n\n  memset(freqs, 0, sizeof freqs);\n\n  p = test;\n  while(*p != '\\0') freqs[*p++]++;\n\n  r = create_huffman_codes(freqs);\n\n  for(i=0; i < BYTES; i++) {\n    if ( r[i] != NULL ) {\n      inttobits(r[i]->code, r[i]->nbits, strbit);\n      printf(\"%c (%d) %s\\n\", i, r[i]->code, strbit);\n    }\n  }\n\n  free_huffman_codes(r);\n\n  return 0;\n}\n\nAlternative[edit]\n\n#include <stdio.h>\n#include <string.h>\n\ntypedef struct node_t {\n\tstruct node_t *left, *right;\n\tint freq;\n\tchar c;\n} *node;\n\nstruct node_t pool[256] = {{0}};\nnode qqq[255], *q = qqq - 1;\nint n_nodes = 0, qend = 1;\nchar *code[128] = {0}, buf[1024];\n\nnode new_node(int freq, char c, node a, node b)\n{\n\tnode n = pool + n_nodes++;\n\tif (freq) n->c = c, n->freq = freq;\n\telse {\n\t\tn->left = a, n->right = b;\n\t\tn->freq = a->freq + b->freq;\n\t}\n\treturn n;\n}\n\n/* priority queue */\nvoid qinsert(node n)\n{\n\tint j, i = qend++;\n\twhile ((j = i / 2)) {\n\t\tif (q[j]->freq <= n->freq) break;\n\t\tq[i] = q[j], i = j;\n\t}\n\tq[i] = n;\n}\n\nnode qremove()\n{\n\tint i, l;\n\tnode n = q[i = 1];\n\n\tif (qend < 2) return 0;\n\tqend--;\n\twhile ((l = i * 2) < qend) {\n\t\tif (l + 1 < qend && q[l + 1]->freq < q[l]->freq) l++;\n\t\tq[i] = q[l], i = l;\n\t}\n\tq[i] = q[qend];\n\treturn n;\n}\n\n/* walk the tree and put 0s and 1s */\nvoid build_code(node n, char *s, int len)\n{\n\tstatic char *out = buf;\n\tif (n->c) {\n\t\ts[len] = 0;\n\t\tstrcpy(out, s);\n\t\tcode[n->c] = out;\n\t\tout += len + 1;\n\t\treturn;\n\t}\n\n\ts[len] = '0'; build_code(n->left,  s, len + 1);\n\ts[len] = '1'; build_code(n->right, s, len + 1);\n}\n\nvoid init(const char *s)\n{\n\tint i, freq[128] = {0};\n\tchar c[16];\n\n\twhile (*s) freq[(int)*s++]++;\n\n\tfor (i = 0; i < 128; i++)\n\t\tif (freq[i]) qinsert(new_node(freq[i], i, 0, 0));\n\n\twhile (qend > 2) \n\t\tqinsert(new_node(0, 0, qremove(), qremove()));\n\n\tbuild_code(q[1], c, 0);\n}\n\nvoid encode(const char *s, char *out)\n{\n\twhile (*s) {\n\t\tstrcpy(out, code[*s]);\n\t\tout += strlen(code[*s++]);\n\t}\n}\n\nvoid decode(const char *s, node t)\n{\n\tnode n = t;\n\twhile (*s) {\n\t\tif (*s++ == '0') n = n->left;\n\t\telse n = n->right;\n\n\t\tif (n->c) putchar(n->c), n = t;\n\t}\n\n\tputchar('\\n');\n\tif (t != n) printf(\"garbage input\\n\");\n}\n\nint main(void)\n{\n\tint i;\n\tconst char *str = \"this is an example for huffman encoding\";\n        char buf[1024];\n\n\tinit(str);\n\tfor (i = 0; i < 128; i++)\n\t\tif (code[i]) printf(\"'%c': %s\\n\", i, code[i]);\n\n\tencode(str, buf);\n\tprintf(\"encoded: %s\\n\", buf);\n\n\tprintf(\"decoded: \");\n\tdecode(buf, q[1]);\n\n\treturn 0;\n}\n\n\nOutput:\n' ': 000\n'a': 1000\n'c': 01101\n'd': 01100\n'e': 0101\n'f': 0010\n'g': 010000\n'h': 1101\n'i': 0011\n'l': 010001\n'm': 1111\n'n': 101\n'o': 1110\n'p': 10011\n'r': 10010\n's': 1100\n't': 01111\n'u': 01110\n'x': 01001\nencoded: 0111111010011110000000111100000100010100001010100110001111100110100010101000001011101001000011010111000100010111110001010000101101011011110011000011101010000\ndecoded: this is an example for huffman encoding\n", "explain": "This code lacks a lot of needed checkings, especially for memory allocation.\nUsing a simple heap-based priority queue.  Heap is an array, while ndoe tree is done by binary links.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "C++", "code": "\n\n#include <iostream>\n#include <queue>\n#include <map>\n#include <climits> // for CHAR_BIT\n#include <iterator>\n#include <algorithm>\n\nconst int UniqueSymbols = 1 << CHAR_BIT;\nconst char* SampleString = \"this is an example for huffman encoding\";\n\ntypedef std::vector<bool> HuffCode;\ntypedef std::map<char, HuffCode> HuffCodeMap;\n\nclass INode\n{\npublic:\n    const int f;\n\n    virtual ~INode() {}\n\nprotected:\n    INode(int f) : f(f) {}\n};\n\nclass InternalNode : public INode\n{\npublic:\n    INode *const left;\n    INode *const right;\n\n    InternalNode(INode* c0, INode* c1) : INode(c0->f + c1->f), left(c0), right(c1) {}\n    ~InternalNode()\n    {\n        delete left;\n        delete right;\n    }\n};\n\nclass LeafNode : public INode\n{\npublic:\n    const char c;\n\n    LeafNode(int f, char c) : INode(f), c(c) {}\n};\n\nstruct NodeCmp\n{\n    bool operator()(const INode* lhs, const INode* rhs) const { return lhs->f > rhs->f; }\n};\n\nINode* BuildTree(const int (&frequencies)[UniqueSymbols])\n{\n    std::priority_queue<INode*, std::vector<INode*>, NodeCmp> trees;\n\n    for (int i = 0; i < UniqueSymbols; ++i)\n    {\n        if(frequencies[i] != 0)\n            trees.push(new LeafNode(frequencies[i], (char)i));\n    }\n    while (trees.size() > 1)\n    {\n        INode* childR = trees.top();\n        trees.pop();\n\n        INode* childL = trees.top();\n        trees.pop();\n\n        INode* parent = new InternalNode(childR, childL);\n        trees.push(parent);\n    }\n    return trees.top();\n}\n\nvoid GenerateCodes(const INode* node, const HuffCode& prefix, HuffCodeMap& outCodes)\n{\n    if (const LeafNode* lf = dynamic_cast<const LeafNode*>(node))\n    {\n        outCodes[lf->c] = prefix;\n    }\n    else if (const InternalNode* in = dynamic_cast<const InternalNode*>(node))\n    {\n        HuffCode leftPrefix = prefix;\n        leftPrefix.push_back(false);\n        GenerateCodes(in->left, leftPrefix, outCodes);\n\n        HuffCode rightPrefix = prefix;\n        rightPrefix.push_back(true);\n        GenerateCodes(in->right, rightPrefix, outCodes);\n    }\n}\n\nint main()\n{\n    // Build frequency table\n    int frequencies[UniqueSymbols] = {0};\n    const char* ptr = SampleString;\n    while (*ptr != '\\0')\n        ++frequencies[*ptr++];\n\n    INode* root = BuildTree(frequencies);\n    \n    HuffCodeMap codes;\n    GenerateCodes(root, HuffCode(), codes);\n    delete root;\n\n    for (HuffCodeMap::const_iterator it = codes.begin(); it != codes.end(); ++it)\n    {\n        std::cout << it->first << \" \";\n        std::copy(it->second.begin(), it->second.end(),\n                  std::ostream_iterator<bool>(std::cout));\n        std::cout << std::endl;\n    }\n    return 0;\n}\n\n\nOutput:\n  110\na 1001\nc 101010\nd 10001\ne 1111\nf 1011\ng 101011\nh 0101\ni 1110\nl 01110\nm 0011\nn 000\no 0010\np 01000\nr 01001\ns 0110\nt 01111\nu 10100\nx 10000\n", "explain": "This code builds a tree to generate huffman codes, then prints the codes.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Java", "code": "\n\nimport java.util.*;\n\nabstract class HuffmanTree implements Comparable<HuffmanTree> {\n    public final int frequency; // the frequency of this tree\n    public HuffmanTree(int freq) { frequency = freq; }\n\n    // compares on the frequency\n    public int compareTo(HuffmanTree tree) {\n        return frequency - tree.frequency;\n    }\n}\n\nclass HuffmanLeaf extends HuffmanTree {\n    public final char value; // the character this leaf represents\n   \n    public HuffmanLeaf(int freq, char val) {\n        super(freq);\n        value = val;\n    }\n}\n\nclass HuffmanNode extends HuffmanTree {\n    public final HuffmanTree left, right; // subtrees\n   \n    public HuffmanNode(HuffmanTree l, HuffmanTree r) {\n        super(l.frequency + r.frequency);\n        left = l;\n        right = r;\n    }\n}\n\npublic class HuffmanCode {\n    // input is an array of frequencies, indexed by character code\n    public static HuffmanTree buildTree(int[] charFreqs) {\n        PriorityQueue<HuffmanTree> trees = new PriorityQueue<HuffmanTree>();\n        // initially, we have a forest of leaves\n        // one for each non-empty character\n        for (int i = 0; i < charFreqs.length; i++)\n            if (charFreqs[i] > 0)\n                trees.offer(new HuffmanLeaf(charFreqs[i], (char)i));\n\n        assert trees.size() > 0;\n        // loop until there is only one tree left\n        while (trees.size() > 1) {\n            // two trees with least frequency\n            HuffmanTree a = trees.poll();\n            HuffmanTree b = trees.poll();\n\n            // put into new node and re-insert into queue\n            trees.offer(new HuffmanNode(a, b));\n        }\n        return trees.poll();\n    }\n\n    public static void printCodes(HuffmanTree tree, StringBuffer prefix) {\n        assert tree != null;\n        if (tree instanceof HuffmanLeaf) {\n            HuffmanLeaf leaf = (HuffmanLeaf)tree;\n\n            // print out character, frequency, and code for this leaf (which is just the prefix)\n            System.out.println(leaf.value + \"\\t\" + leaf.frequency + \"\\t\" + prefix);\n\n        } else if (tree instanceof HuffmanNode) {\n            HuffmanNode node = (HuffmanNode)tree;\n\n            // traverse left\n            prefix.append('0');\n            printCodes(node.left, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n\n            // traverse right\n            prefix.append('1');\n            printCodes(node.right, prefix);\n            prefix.deleteCharAt(prefix.length()-1);\n        }\n    }\n\n    public static void main(String[] args) {\n        String test = \"this is an example for huffman encoding\";\n\n        // we will assume that all our characters will have\n        // code less than 256, for simplicity\n        int[] charFreqs = new int[256];\n        // read each character and record the frequencies\n        for (char c : test.toCharArray())\n            charFreqs[c]++;\n\n        // build tree\n        HuffmanTree tree = buildTree(charFreqs);\n\n        // print out results\n        System.out.println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n        printCodes(tree, new StringBuffer());\n    }\n}\n\n\nOutput:\nSYMBOL\tWEIGHT\tHUFFMAN CODE\nd\t1\t00000\nt\t1\t00001\nh\t2\t0001\ns\t2\t0010\nc\t1\t00110\nx\t1\t00111\nm\t2\t0100\no\t2\t0101\nn\t4\t011\nu\t1\t10000\nl\t1\t10001\na\t3\t1001\nr\t1\t10100\ng\t1\t101010\np\t1\t101011\ne\t3\t1011\ni\t3\t1100\nf\t3\t1101\n \t6\t111\n", "explain": "This implementation creates an actual tree structure, and then traverses the tree to recover the code.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "C#", "code": "\nusing System;\nusing System.Collections.Generic;\n\nnamespace Huffman_Encoding\n{\n    public class PriorityQueue<T> where T : IComparable\n    {\n        protected List<T> LstHeap = new List<T>();\n\n        public virtual int Count\n        {\n            get { return LstHeap.Count; }\n        }\n\n        public virtual void Add(T val)\n        {\n            LstHeap.Add(val);\n            SetAt(LstHeap.Count - 1, val);\n            UpHeap(LstHeap.Count - 1);\n        }\n\n        public virtual T Peek()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Peeking at an empty priority queue\");\n            }\n\n            return LstHeap[0];\n        }\n\n        public virtual T Pop()\n        {\n            if (LstHeap.Count == 0)\n            {\n                throw new IndexOutOfRangeException(\"Popping an empty priority queue\");\n            }\n\n            T valRet = LstHeap[0];\n\n            SetAt(0, LstHeap[LstHeap.Count - 1]);\n            LstHeap.RemoveAt(LstHeap.Count - 1);\n            DownHeap(0);\n            return valRet;\n        }\n\n        protected virtual void SetAt(int i, T val)\n        {\n            LstHeap[i] = val;\n        }\n\n        protected bool RightSonExists(int i)\n        {\n            return RightChildIndex(i) < LstHeap.Count;\n        }\n\n        protected bool LeftSonExists(int i)\n        {\n            return LeftChildIndex(i) < LstHeap.Count;\n        }\n\n        protected int ParentIndex(int i)\n        {\n            return (i - 1) / 2;\n        }\n\n        protected int LeftChildIndex(int i)\n        {\n            return 2 * i + 1;\n        }\n\n        protected int RightChildIndex(int i)\n        {\n            return 2 * (i + 1);\n        }\n\n        protected T ArrayVal(int i)\n        {\n            return LstHeap[i];\n        }\n\n        protected T Parent(int i)\n        {\n            return LstHeap[ParentIndex(i)];\n        }\n\n        protected T Left(int i)\n        {\n            return LstHeap[LeftChildIndex(i)];\n        }\n\n        protected T Right(int i)\n        {\n            return LstHeap[RightChildIndex(i)];\n        }\n\n        protected void Swap(int i, int j)\n        {\n            T valHold = ArrayVal(i);\n            SetAt(i, LstHeap[j]);\n            SetAt(j, valHold);\n        }\n\n        protected void UpHeap(int i)\n        {\n            while (i > 0 && ArrayVal(i).CompareTo(Parent(i)) > 0)\n            {\n                Swap(i, ParentIndex(i));\n                i = ParentIndex(i);\n            }\n        }\n\n        protected void DownHeap(int i)\n        {\n            while (i >= 0)\n            {\n                int iContinue = -1;\n\n                if (RightSonExists(i) && Right(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = Left(i).CompareTo(Right(i)) < 0 ? RightChildIndex(i) : LeftChildIndex(i);\n                }\n                else if (LeftSonExists(i) && Left(i).CompareTo(ArrayVal(i)) > 0)\n                {\n                    iContinue = LeftChildIndex(i);\n                }\n\n                if (iContinue >= 0 && iContinue < LstHeap.Count)\n                {\n                    Swap(i, iContinue);\n                }\n\n                i = iContinue;\n            }\n        }\n    }\n\n    internal class HuffmanNode<T> : IComparable\n    {\n        internal HuffmanNode(double probability, T value)\n        {\n            Probability = probability;\n            LeftSon = RightSon = Parent = null;\n            Value = value;\n            IsLeaf = true;\n        }\n\n        internal HuffmanNode(HuffmanNode<T> leftSon, HuffmanNode<T> rightSon)\n        {\n            LeftSon = leftSon;\n            RightSon = rightSon;\n            Probability = leftSon.Probability + rightSon.Probability;\n            leftSon.IsZero = true;\n            rightSon.IsZero = false;\n            leftSon.Parent = rightSon.Parent = this;\n            IsLeaf = false;\n        }\n\n        internal HuffmanNode<T> LeftSon { get; set; }\n        internal HuffmanNode<T> RightSon { get; set; }\n        internal HuffmanNode<T> Parent { get; set; }\n        internal T Value { get; set; }\n        internal bool IsLeaf { get; set; }\n\n        internal bool IsZero { get; set; }\n\n        internal int Bit\n        {\n            get { return IsZero ? 0 : 1; }\n        }\n\n        internal bool IsRoot\n        {\n            get { return Parent == null; }\n        }\n\n        internal double Probability { get; set; }\n\n        public int CompareTo(object obj)\n        {\n            return -Probability.CompareTo(((HuffmanNode<T>) obj).Probability);\n        }\n    }\n\n    public class Huffman<T> where T : IComparable\n    {\n        private readonly Dictionary<T, HuffmanNode<T>> _leafDictionary = new Dictionary<T, HuffmanNode<T>>();\n        private readonly HuffmanNode<T> _root;\n\n        public Huffman(IEnumerable<T> values)\n        {\n            var counts = new Dictionary<T, int>();\n            var priorityQueue = new PriorityQueue<HuffmanNode<T>>();\n            int valueCount = 0;\n\n            foreach (T value in values)\n            {\n                if (!counts.ContainsKey(value))\n                {\n                    counts[value] = 0;\n                }\n                counts[value]++;\n                valueCount++;\n            }\n\n            foreach (T value in counts.Keys)\n            {\n                var node = new HuffmanNode<T>((double) counts[value] / valueCount, value);\n                priorityQueue.Add(node);\n                _leafDictionary[value] = node;\n            }\n\n            while (priorityQueue.Count > 1)\n            {\n                HuffmanNode<T> leftSon = priorityQueue.Pop();\n                HuffmanNode<T> rightSon = priorityQueue.Pop();\n                var parent = new HuffmanNode<T>(leftSon, rightSon);\n                priorityQueue.Add(parent);\n            }\n\n            _root = priorityQueue.Pop();\n            _root.IsZero = false;\n        }\n\n        public List<int> Encode(T value)\n        {\n            var returnValue = new List<int>();\n            Encode(value, returnValue);\n            return returnValue;\n        }\n\n        public void Encode(T value, List<int> encoding)\n        {\n            if (!_leafDictionary.ContainsKey(value))\n            {\n                throw new ArgumentException(\"Invalid value in Encode\");\n            }\n            HuffmanNode<T> nodeCur = _leafDictionary[value];\n            var reverseEncoding = new List<int>();\n            while (!nodeCur.IsRoot)\n            {\n                reverseEncoding.Add(nodeCur.Bit);\n                nodeCur = nodeCur.Parent;\n            }\n\n            reverseEncoding.Reverse();\n            encoding.AddRange(reverseEncoding);\n        }\n\n        public List<int> Encode(IEnumerable<T> values)\n        {\n            var returnValue = new List<int>();\n\n            foreach (T value in values)\n            {\n                Encode(value, returnValue);\n            }\n            return returnValue;\n        }\n\n        public T Decode(List<int> bitString, ref int position)\n        {\n            HuffmanNode<T> nodeCur = _root;\n            while (!nodeCur.IsLeaf)\n            {\n                if (position > bitString.Count)\n                {\n                    throw new ArgumentException(\"Invalid bitstring in Decode\");\n                }\n                nodeCur = bitString[position++] == 0 ? nodeCur.LeftSon : nodeCur.RightSon;\n            }\n            return nodeCur.Value;\n        }\n\n        public List<T> Decode(List<int> bitString)\n        {\n            int position = 0;\n            var returnValue = new List<T>();\n\n            while (position != bitString.Count)\n            {\n                returnValue.Add(Decode(bitString, ref position));\n            }\n            return returnValue;\n        }\n    }\n\n    internal class Program\n    {\n        private const string Example = \"this is an example for huffman encoding\";\n\n        private static void Main()\n        {\n            var huffman = new Huffman<char>(Example);\n            List<int> encoding = huffman.Encode(Example);\n            List<char> decoding = huffman.Decode(encoding);\n            var outString = new string(decoding.ToArray());\n            Console.WriteLine(outString == Example ? \"Encoding/decoding worked\" : \"Encoding/Decoding failed\");\n\n            var chars = new HashSet<char>(Example);\n            foreach (char c in chars)\n            {\n                encoding = huffman.Encode(c);\n                Console.Write(\"{0}:  \", c);\n                foreach (int bit in encoding)\n                {\n                    Console.Write(\"{0}\", bit);\n                }\n                Console.WriteLine();\n            }\n            Console.ReadKey();\n        }\n    }\n}\n\n\n", "explain": "File:CSharpHuffman.jpg\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "JavaScript", "code": "\nTranslation of: Ruby\nWorks with: SpiderMonkey for the print() function.\n\nfunction HuffmanEncoding(str) {\n    this.str = str;\n\n    var count_chars = {};\n    for (var i = 0; i < str.length; i++) \n        if (str[i] in count_chars) \n            count_chars[str[i]] ++;\n        else \n            count_chars[str[i]] = 1;\n\n    var pq = new BinaryHeap(function(x){return x[0];});\n    for (var ch in count_chars) \n        pq.push([count_chars[ch], ch]);\n\n    while (pq.size() > 1) {\n        var pair1 = pq.pop();\n        var pair2 = pq.pop();\n        pq.push([pair1[0]+pair2[0], [pair1[1], pair2[1]]]);\n    }\n\n    var tree = pq.pop();\n    this.encoding = {};\n    this._generate_encoding(tree[1], \"\");\n\n    this.encoded_string = \"\"\n    for (var i = 0; i < this.str.length; i++) {\n        this.encoded_string += this.encoding[str[i]];\n    }\n}\n\nHuffmanEncoding.prototype._generate_encoding = function(ary, prefix) {\n    if (ary instanceof Array) {\n        this._generate_encoding(ary[0], prefix + \"0\");\n        this._generate_encoding(ary[1], prefix + \"1\");\n    }\n    else {\n        this.encoding[ary] = prefix;\n    }\n}\n\nHuffmanEncoding.prototype.inspect_encoding = function() {\n    for (var ch in this.encoding) {\n        print(\"'\" + ch + \"': \" + this.encoding[ch])\n    }\n}\n\nHuffmanEncoding.prototype.decode = function(encoded) {\n    var rev_enc = {};\n    for (var ch in this.encoding) \n        rev_enc[this.encoding[ch]] = ch;\n\n    var decoded = \"\";\n    var pos = 0;\n    while (pos < encoded.length) {\n        var key = \"\"\n        while (!(key in rev_enc)) {\n            key += encoded[pos];\n            pos++;\n        }\n        decoded += rev_enc[key];\n    }\n    return decoded;\n}\n\n\nvar s = \"this is an example for huffman encoding\";\nprint(s);\n\nvar huff = new HuffmanEncoding(s);\nhuff.inspect_encoding();\n\nvar e = huff.encoded_string;\nprint(e);\n\nvar t = huff.decode(e);\nprint(t);\n\nprint(\"is decoded string same as original? \" + (s==t));\n\n\nOutput:\nthis is an example for huffman encoding\n'n': 000\n's': 0010\n'm': 0011\n'o': 0100\n't': 01010\n'x': 01011\n'p': 01100\n'l': 01101\n'r': 01110\n'u': 01111\n'c': 10000\n'd': 10001\n'i': 1001\n' ': 101\n'a': 1100\n'e': 1101\n'f': 1110\n'g': 11110\n'h': 11111\n0101011111100100101011001001010111000001011101010111100001101100011011101101111001000111010111111011111110111000111100000101110100010000010010001100100011110\nthis is an example for huffman encoding\nis decoded string same as original? true\nTranslation of: C\nclass node{\n\tconstructor(freq, char, left, right){\n\t\tthis.left = left;\n\t\tthis.right = right;\n\t\tthis.freq = freq;\n\t\tthis.c = char;\n\t}\n};\n\nnodes = [];\ncode = {};\n\nfunction new_node(left, right){\n\treturn new node(left.freq + right.freq, -1, left, right);;\n};\n\nfunction qinsert(node){\n\tnodes.push(node);\n\tnodes.sort(compareFunction);\n};\n\nfunction qremove(){\n\treturn nodes.pop();\n};\n\nfunction compareFunction(a, b){\n\treturn b.freq - a.freq;\n};\n\nfunction build_code(node, codeString, length){\n\tif (node.c != -1){\n\t\tcode[node.c] = codeString;\n\t\treturn;\n\t};\n\t/* Left Branch */\n\tleftCodeString = codeString + \"0\"; \n\tbuild_code(node.left, leftCodeString, length + 1);\n\t/* Right Branch */\n\trightCodeString = codeString + \"1\";\n\tbuild_code(node.right, rightCodeString, length + 1);\n};\n\nfunction init(string){\n\tvar i;\n\tvar freq = [];\n\tvar codeString = \"\";\n\t\n\tfor (var i = 0; i < string.length; i++){\n\t\tif (isNaN(freq[string.charCodeAt(i)])){\n\t\t\tfreq[string.charCodeAt(i)] = 1;\n\t\t} else {\n\t\t\tfreq[string.charCodeAt(i)] ++;\n\t\t};\n\t};\n\t\n\tfor (var i = 0; i < freq.length; i++){\n\t\tif (freq[i] > 0){\n\t\t\tqinsert(new node(freq[i], i, null, null));\n\t\t};\n\t};\n\t\n\twhile (nodes.length > 1){\n\t\tqinsert(new_node(qremove(), qremove()));\n\t}; \n\t\n\tbuild_code(nodes[0], codeString, 0);\n};\n\nfunction encode(string){\n\toutput = \"\";\n\t\n\tfor (var i = 0; i < string.length; i ++){\n\t\toutput += code[string.charCodeAt(i)];\n\t};\n\t\n\treturn output;\n};\n\nfunction decode(input){\n\toutput = \"\";\n\tnode = nodes[0];\n\t\n\tfor (var i = 0; i < input.length; i++){\n\t\tif (input[i] == \"0\"){\n\t\t\tnode = node.left;\n\t\t} else {\n\t\t\tnode = node.right;\n\t\t};\n\t\t\n\t\tif (node.c != -1){\n\t\t\toutput += String.fromCharCode(node.c);\n\t\t\tnode = nodes[0];\n\t\t};\n\t};\n\t\n\treturn output\n};\n\n\nstring = \"this is an example of huffman encoding\";\nconsole.log(\"initial string: \" + string);\ninit(string);\nfor (var i = 0; i < Object.keys(code).length; i++){\n\tif (isNaN(code[Object.keys(code)[i]])){\n\t} else {\n\t\tconsole.log(\"'\" + String.fromCharCode(Object.keys(code)[i]) + \"'\" + \": \" + code[Object.keys(code)[i]]);\n\t};\n};\n\nhuffman = encode(string);\nconsole.log(\"encoded: \" + huffman + \"\\n\");\noutput = decode(huffman);\nconsole.log(\"decoded: \" + output);\n\ninitial string: this is an example of huffman encoding\n' ': 111\n'a': 1011\n'c': 00101\n'd': 00100\n'e': 1010\n'f': 1101\n'g': 00111\n'h': 0101\n'i': 1100\n'l': 00110\n'm': 0100\n'n': 100\n'o': 0111\n'p': 00001\n's': 0110\n't': 00000\n'u': 00011\n'x': 00010\nencoded: 000000101110001101111100011011110111001111010000101011010000001001101010111011111011110101000111101110101001011100111101010000101011100100110010000111\ndecoded: this is an example of huffman encoding\n\n", "explain": "First, use the Binary Heap implementation from here: http://eloquentjavascript.net/appendix2.html\nThe Huffman encoder\nAnd, using the Huffman encoder\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "PHP", "code": "\nWorks with: PHP version 5.3+\nTranslation of: Python (not exactly)\n<?php\nfunction encode($symb2freq) {\n    $heap = new SplPriorityQueue;\n    $heap->setExtractFlags(SplPriorityQueue::EXTR_BOTH);\n    foreach ($symb2freq as $sym => $wt)\n        $heap->insert(array($sym => ''), -$wt);\n\n    while ($heap->count() > 1) {\n        $lo = $heap->extract();\n        $hi = $heap->extract();\n        foreach ($lo['data'] as &$x)\n            $x = '0'.$x;\n        foreach ($hi['data'] as &$x)\n            $x = '1'.$x;\n        $heap->insert($lo['data'] + $hi['data'],\n                      $lo['priority'] + $hi['priority']);\n    }\n    $result = $heap->extract();\n    return $result['data'];\n}\n\n$txt = 'this is an example for huffman encoding';\n$symb2freq = array_count_values(str_split($txt));\n$huff = encode($symb2freq);\necho \"Symbol\\tWeight\\tHuffman Code\\n\";\nforeach ($huff as $sym => $code)\n    echo \"$sym\\t$symb2freq[$sym]\\t$code\\n\";\n?>\n\n\nOutput:\nSymbol\tWeight\tHuffman Code\nn\t4\t000\nm\t2\t0010\no\t2\t0011\nt\t1\t01000\ng\t1\t01001\nx\t1\t01010\nu\t1\t01011\ns\t2\t0110\nc\t1\t01110\nd\t1\t01111\np\t1\t10000\nl\t1\t10001\na\t3\t1001\n \t6\t101\nf\t3\t1100\ni\t3\t1101\nr\t1\t11100\nh\t2\t11101\ne\t3\t1111\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Fortran", "code": "\n! output:\n! d-> 00000, t-> 00001, h-> 0001, s-> 0010, \n! c-> 00110, x-> 00111, m-> 0100, o-> 0101, \n! n-> 011, u-> 10000, l-> 10001, a-> 1001, \n! r-> 10100, g-> 101010, p-> 101011, \n! e-> 1011, i-> 1100, f-> 1101,  -> 111\n!\n! 00001|0001|1100|0010|111|1100|0010|111|1001|011|\n! 111|1011|00111|1001|0100|101011|10001|1011|111|\n! 1101|0101|10100|111|0001|10000|1101|1101|0100|\n! 1001|011|111|1011|011|00110|0101|00000|1100|011|101010|\n!\nmodule huffman\nimplicit none\ntype node\n  character (len=1 ), allocatable :: sym(:)\n  character (len=10), allocatable :: code(:) \n  integer                         :: freq\ncontains\n  procedure                       :: show => show_node\nend type\n\ntype queue\n  type(node), allocatable :: buf(:)\n  integer                 :: n = 0\ncontains\n  procedure :: extractmin\n  procedure :: append\n  procedure :: siftdown\nend type\n\ncontains\n\nsubroutine siftdown(this, a)\n  class (queue)           :: this\n  integer                 :: a, parent, child\n  associate (x => this%buf)\n  parent = a\n  do while(parent*2 <= this%n)\n    child = parent*2\n    if (child + 1 <= this%n) then \n      if (x(child+1)%freq < x(child)%freq ) then\n        child = child +1 \n      end if\n    end if\n    if (x(parent)%freq > x(child)%freq) then\n      x([child, parent]) = x([parent, child])\n      parent = child\n    else\n      exit\n    end if  \n  end do      \n  end associate\nend subroutine\n\nfunction extractmin(this) result (res)\n  class(queue) :: this\n  type(node)   :: res\n  res = this%buf(1)\n  this%buf(1) = this%buf(this%n)\n  this%n = this%n - 1\n  call this%siftdown(1)\nend function\n\nsubroutine append(this, x)\n  class(queue), intent(inout) :: this\n  type(node)                  :: x\n  type(node), allocatable     :: tmp(:)\n  integer                     :: i\n  this%n = this%n +1  \n  if (.not.allocated(this%buf)) allocate(this%buf(1))\n  if (size(this%buf)<this%n) then\n    allocate(tmp(2*size(this%buf)))\n    tmp(1:this%n-1) = this%buf\n    call move_alloc(tmp, this%buf)\n  end if\n  this%buf(this%n) = x\n  i = this%n\n  do \n    i = i / 2\n    if (i==0) exit\n    call this%siftdown(i)\n  end do\nend subroutine\n\nfunction join(a, b) result(c)\n  type(node)             :: a, b, c\n  integer                :: i, n, n1\n  n1 = size(a%sym)\n  n = n1 + size(b%sym)  \n  c%freq = a%freq + b%freq\n  allocate (c%sym(n), c%code(n))\n  do i = 1, n1\n    c%sym(i) = a%sym(i)\n    c%code(i) = \"0\" // trim(a%code(i))\n  end do\n  do i = 1, size(b%sym)\n    c%sym(i+n1) = b%sym(i)\n    c%code(i+n1) = \"1\" // trim(b%code(i))\n  end do\nend function\n\nsubroutine show_node(this)\n  class(node) :: this\n  integer     :: i\n  write(*, \"(*(g0,'-> ',g0,:,', '))\", advance=\"no\") &\n   (this%sym(i), trim(this%code(i)), i=1,size(this%sym))\n  print *\nend subroutine\n\nfunction create(letter, freq) result (this)\n  character :: letter\n  integer   :: freq\n  type(node) :: this\n  allocate(this%sym(1), this%code(1))\n  this%sym(1) = letter ; this%code(1) = \"\"\n  this%freq = freq\nend function\nend module \n\nprogram main\n  use huffman\n  character (len=*), parameter   :: txt = &\n   \"this is an example for huffman encoding\"\n  integer                        :: i, freq(0:255) = 0\n  type(queue)                    :: Q\n  type(node)                     :: x\n  do i = 1, len(txt)\n    freq(ichar(txt(i:i))) = freq(ichar(txt(i:i))) + 1 \n  end do\n  do i = 0, 255\n    if (freq(i)>0) then\n      call Q%append(create(char(i), freq(i)))\n    end if\n  end do\n  do i = 1, Q%n-1\n    call Q%append(join(Q%extractmin(),Q%extractmin()))\n  end do\n  x = Q%extractmin()\n  call x%show()\n  do i = 1, len(txt) \n    do k = 1, size(x%sym)\n      if (x%sym(k)==txt(i:i)) exit\n     end do\n     write (*, \"(a,'|')\", advance=\"no\")  trim(x%code(k))\n  end do\n  print *\nend program\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Go", "code": "\nTranslation of: Java\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\ntype HuffmanTree interface {\n    Freq() int\n}\n\ntype HuffmanLeaf struct {\n    freq  int\n    value rune\n}\n\ntype HuffmanNode struct {\n    freq        int\n    left, right HuffmanTree\n}\n\nfunc (self HuffmanLeaf) Freq() int {\n    return self.freq\n}\n\nfunc (self HuffmanNode) Freq() int {\n    return self.freq\n}\n\ntype treeHeap []HuffmanTree\n\nfunc (th treeHeap) Len() int { return len(th) }\nfunc (th treeHeap) Less(i, j int) bool {\n    return th[i].Freq() < th[j].Freq()\n}\nfunc (th *treeHeap) Push(ele interface{}) {\n    *th = append(*th, ele.(HuffmanTree))\n}\nfunc (th *treeHeap) Pop() (popped interface{}) {\n    popped = (*th)[len(*th)-1]\n    *th = (*th)[:len(*th)-1]\n    return\n}\nfunc (th treeHeap) Swap(i, j int) { th[i], th[j] = th[j], th[i] }\n\nfunc buildTree(symFreqs map[rune]int) HuffmanTree {\n    var trees treeHeap\n    for c, f := range symFreqs {\n        trees = append(trees, HuffmanLeaf{f, c})\n    }\n    heap.Init(&trees)\n    for trees.Len() > 1 {\n        // two trees with least frequency\n        a := heap.Pop(&trees).(HuffmanTree)\n        b := heap.Pop(&trees).(HuffmanTree)\n\n        // put into new node and re-insert into queue\n        heap.Push(&trees, HuffmanNode{a.Freq() + b.Freq(), a, b})\n    }\n    return heap.Pop(&trees).(HuffmanTree)\n}\n\nfunc printCodes(tree HuffmanTree, prefix []byte) {\n    switch i := tree.(type) {\n    case HuffmanLeaf:\n        // print out symbol, frequency, and code for this\n        // leaf (which is just the prefix)\n        fmt.Printf(\"%c\\t%d\\t%s\\n\", i.value, i.freq, string(prefix))\n    case HuffmanNode:\n        // traverse left\n        prefix = append(prefix, '0')\n        printCodes(i.left, prefix)\n        prefix = prefix[:len(prefix)-1]\n\n        // traverse right\n        prefix = append(prefix, '1')\n        printCodes(i.right, prefix)\n        prefix = prefix[:len(prefix)-1]\n    }\n}\n\nfunc main() {\n    test := \"this is an example for huffman encoding\"\n\n    symFreqs := make(map[rune]int)\n    // read each symbol and record the frequencies\n    for _, c := range test {\n        symFreqs[c]++\n    }\n\n    // build tree\n    tree := buildTree(symFreqs)\n\n    // print out results\n    fmt.Println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\")\n    printCodes(tree, []byte{})\n}\n\n\nOutput:\nSYMBOL\tWEIGHT\tHUFFMAN CODE\nn\t4\t000\nm\t2\t0010\no\t2\t0011\ns\t2\t0100\nu\t1\t01010\np\t1\t01011\nh\t2\t0110\nd\t1\t01110\nc\t1\t01111\nt\t1\t10000\nl\t1\t10001\nx\t1\t10010\nr\t1\t100110\ng\t1\t100111\ni\t3\t1010\ne\t3\t1011\n \t6\t110\nf\t3\t1110\na\t3\t1111\n\nTranslation of: Python\npackage main\n\nimport (\n    \"container/heap\"\n    \"fmt\"\n)\n\ntype coded struct {\n    sym  rune\n    code string\n}\n\ntype counted struct {\n    total int\n    syms []coded\n}\n\ntype cHeap []counted\n\n// satisfy heap.Interface\nfunc (c cHeap) Len() int           { return len(c) }\nfunc (c cHeap) Less(i, j int) bool { return c[i].total < c[j].total }\nfunc (c cHeap) Swap(i, j int)      { c[i], c[j] = c[j], c[i] }\nfunc (c *cHeap) Push(ele interface{}) {\n    *c = append(*c, ele.(counted))\n}\nfunc (c *cHeap) Pop() (popped interface{}) {\n    popped = (*c)[len(*c)-1]\n    *c = (*c)[:len(*c)-1]\n    return\n}\n\nfunc encode(sym2freq map[rune]int) []coded {\n    var ch cHeap\n    for sym, freq := range sym2freq {\n        ch = append(ch, counted{freq, []coded{{sym: sym}}})\n    }\n    heap.Init(&ch)\n    for len(ch) > 1 {\n        a := heap.Pop(&ch).(counted)\n        b := heap.Pop(&ch).(counted)\n        for i, c := range a.syms {\n            a.syms[i].code = \"0\" + c.code\n        }\n        for i, c := range b.syms {\n            b.syms[i].code = \"1\" + c.code\n        }\n        heap.Push(&ch, counted{a.total + b.total, append(a.syms, b.syms...)})\n    }\n    return heap.Pop(&ch).(counted).syms\n}\n\nconst txt = \"this is an example for huffman encoding\"\n\nfunc main() {\n    sym2freq := make(map[rune]int)\n    for _, c := range txt {\n        sym2freq[c]++\n    }\n    table := encode(sym2freq)\n    fmt.Println(\"Symbol  Weight Huffman Code\")\n    for _, c := range table {\n        fmt.Printf(\"     %c    %d    %s\\n\", c.sym, sym2freq[c.sym], c.code)\n    }\n}\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Ruby", "code": "\nUses a Library: RubyGems package PriorityQueue\nrequire 'priority_queue'\n\ndef huffman_encoding(str)\n  char_count = Hash.new(0)\n  str.each_char {|c| char_count[c] += 1}\n  \n  pq = CPriorityQueue.new\n  # chars with fewest count have highest priority\n  char_count.each {|char, count| pq.push(char, count)}\n  \n  while pq.length > 1\n    key1, prio1 = pq.delete_min\n    key2, prio2 = pq.delete_min\n    pq.push([key1, key2], prio1 + prio2)\n  end\n  \n  Hash[*generate_encoding(pq.min_key)]\nend\n\ndef generate_encoding(ary, prefix=\"\")\n  case ary\n  when Array\n    generate_encoding(ary[0], \"#{prefix}0\") + generate_encoding(ary[1], \"#{prefix}1\")\n  else\n    [ary, prefix]\n  end\nend\n\ndef encode(str, encoding)\n  str.each_char.collect {|char| encoding[char]}.join\nend\n\ndef decode(encoded, encoding)\n  rev_enc = encoding.invert\n  decoded = \"\"\n  pos = 0\n  while pos < encoded.length\n    key = \"\"\n    while rev_enc[key].nil?\n      key << encoded[pos]\n      pos += 1\n    end\n    decoded << rev_enc[key]\n  end\n  decoded\nend\n\nstr = \"this is an example for huffman encoding\"\nencoding = huffman_encoding(str)\nencoding.to_a.sort.each {|x| p x}\n\nenc = encode(str, encoding)\ndec = decode(enc, encoding)\nputs \"success!\" if str == dec\n\n[\" \", \"111\"]\n[\"a\", \"1011\"]\n[\"c\", \"00001\"]\n[\"d\", \"00000\"]\n[\"e\", \"1101\"]\n[\"f\", \"1100\"]\n[\"g\", \"00100\"]\n[\"h\", \"1000\"]\n[\"i\", \"1001\"]\n[\"l\", \"01110\"]\n[\"m\", \"10101\"]\n[\"n\", \"010\"]\n[\"o\", \"0001\"]\n[\"p\", \"00101\"]\n[\"r\", \"00111\"]\n[\"s\", \"0110\"]\n[\"t\", \"00110\"]\n[\"u\", \"01111\"]\n[\"x\", \"10100\"]\nsuccess!\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Rust", "code": "\n\nuse std::collections::BTreeMap;\nuse std::collections::binary_heap::BinaryHeap;\n\n#[derive(Debug, Eq, PartialEq)]\nenum NodeKind {\n    Internal(Box<Node>, Box<Node>),\n    Leaf(char),\n}\n\n#[derive(Debug, Eq, PartialEq)]\nstruct Node {\n    frequency: usize,\n    kind: NodeKind,\n}\n\nimpl Ord for Node {\n    fn cmp(&self, rhs: &Self) -> std::cmp::Ordering {\n        rhs.frequency.cmp(&self.frequency)\n    }\n}\n\nimpl PartialOrd for Node {\n    fn partial_cmp(&self, rhs: &Self) -> Option<std::cmp::Ordering> {\n        Some(self.cmp(&rhs))\n    }\n}\n\ntype HuffmanCodeMap = BTreeMap<char, Vec<u8>>;\n\nfn main() {\n    let text = \"this is an example for huffman encoding\";\n\n    let mut frequencies = BTreeMap::new();\n    for ch in text.chars() {\n        *frequencies.entry(ch).or_insert(0) += 1;\n    }\n\n    let mut prioritized_frequencies = BinaryHeap::new();\n    for counted_char in frequencies {\n        prioritized_frequencies.push(Node {\n            frequency: counted_char.1,\n            kind: NodeKind::Leaf(counted_char.0),\n        });\n    }\n\n    while prioritized_frequencies.len() > 1 {\n        let left_child = prioritized_frequencies.pop().unwrap();\n        let right_child = prioritized_frequencies.pop().unwrap();\n        prioritized_frequencies.push(Node {\n            frequency: right_child.frequency + left_child.frequency,\n            kind: NodeKind::Internal(Box::new(left_child), Box::new(right_child)),\n        });\n    }\n\n    let mut codes = HuffmanCodeMap::new();\n    generate_codes(\n        prioritized_frequencies.peek().unwrap(),\n        vec![0u8; 0],\n        &mut codes,\n    );\n\n    for item in codes {\n        print!(\"{}: \", item.0);\n        for bit in item.1 {\n            print!(\"{}\", bit);\n        }\n        println!();\n    }\n}\n\nfn generate_codes(node: &Node, prefix: Vec<u8>, out_codes: &mut HuffmanCodeMap) {\n    match node.kind {\n        NodeKind::Internal(ref left_child, ref right_child) => {\n            let mut left_prefix = prefix.clone();\n            left_prefix.push(0);\n            generate_codes(&left_child, left_prefix, out_codes);\n\n            let mut right_prefix = prefix;\n            right_prefix.push(1);\n            generate_codes(&right_child, right_prefix, out_codes);\n        }\n        NodeKind::Leaf(ch) => {\n            out_codes.insert(ch, prefix);\n        }\n    }\n}\n\n\n\u00a0: 110\na: 1001\nc: 101010\nd: 10001\ne: 1111\nf: 1011\ng: 101011\nh: 0101\ni: 1110\nl: 01110\nm: 0011\nn: 000\no: 0010\np: 01000\nr: 01001\ns: 0110\nt: 01111\nu: 10100\nx: 10000\n\n", "explain": "Adapted C++ solution.\nOutput:\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Swift", "code": "\n\nWorks with: Swift version 2+\nenum HuffmanTree<T> {\n  case Leaf(T)\n  indirect case Node(HuffmanTree<T>, HuffmanTree<T>)\n  \n  func printCodes(prefix: String) {\n    switch(self) {\n    case let .Leaf(c):\n      print(\"\\(c)\\t\\(prefix)\")\n    case let .Node(l, r):\n      l.printCodes(prefix + \"0\")\n      r.printCodes(prefix + \"1\")\n    }\n  }\n}\n\nfunc buildTree<T>(freqs: [(T, Int)]) -> HuffmanTree<T> {\n  assert(freqs.count > 0, \"must contain at least one character\")\n  // leaves sorted by increasing frequency\n  let leaves : [(Int, HuffmanTree<T>)] = freqs.sort { (p1, p2) in p1.1 < p2.1 }.map { (x, w) in (w, .Leaf(x)) }\n  // nodes sorted by increasing frequency\n  var nodes = [(Int, HuffmanTree<T>)]()\n  // iterate through leaves and nodes in order of increasing frequency\n  for var i = 0, j = 0; ; {\n    assert(i < leaves.count || j < nodes.count)\n    // get subtree of least frequency\n    var e1 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e1 = leaves[i]\n      i++\n    } else {\n      e1 = nodes[j]\n      j++\n    }\n    \n    // if there's no subtrees left, then that one was the answer\n    if i == leaves.count && j == nodes.count {\n      return e1.1\n    }\n    \n    // get next subtree of least frequency\n    var e2 : (Int, HuffmanTree<T>)\n    if j == nodes.count || i < leaves.count && leaves[i].0 < nodes[j].0 {\n      e2 = leaves[i]\n      i++\n    } else {\n      e2 = nodes[j]\n      j++\n    }\n    // create node from two subtrees\n    nodes.append((e1.0 + e2.0, .Node(e1.1, e2.1)))\n  }\n}\n\nfunc getFreqs<S : SequenceType where S.Generator.Element : Hashable>(seq: S) -> [(S.Generator.Element, Int)] {\n  var freqs : [S.Generator.Element : Int] = [:]\n  for c in seq {\n    freqs[c] = (freqs[c] ?? 0) + 1\n  }\n  return Array(freqs)\n}\n\nlet str = \"this is an example for huffman encoding\"\nlet charFreqs = getFreqs(str.characters)\nlet tree = buildTree(charFreqs)\nprint(\"Symbol\\tHuffman code\")\ntree.printCodes(\"\")\n\n\nOutput:\nSymbol\tHuffman code\nu\t00000\nt\t00001\nd\t00010\nr\t00011\nc\t00100\nl\t00101\no\t0011\nm\t0100\ns\t0101\nn\t011\nh\t1000\ng\t10010\np\t100110\nx\t100111\nf\t1010\na\t1011\ni\t1100\ne\t1101\n \t111\n\n", "explain": "Rather than a priority queue of subtrees, we use the strategy of two sorted lists, one for leaves and one for nodes, and \"merge\" them as we iterate through them, taking advantage of the fact that any new nodes we create are bigger than any previously created nodes, so go at the end of the nodes list.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Ada", "code": "\nWorks with: Ada 2005\n\nwith Ada.Containers.Indefinite_Ordered_Maps;\nwith Ada.Containers.Ordered_Maps;\nwith Ada.Finalization;\ngeneric\n   type Symbol_Type is private;\n   with function \"<\" (Left, Right : Symbol_Type) return Boolean is <>;\n   with procedure Put (Item : Symbol_Type);\n   type Symbol_Sequence is array (Positive range <>) of Symbol_Type;\n   type Frequency_Type is private;\n   with function \"+\" (Left, Right : Frequency_Type) return Frequency_Type\n     is <>;\n   with function \"<\" (Left, Right : Frequency_Type) return Boolean is <>;\npackage Huffman is\n   -- bits = booleans (true/false = 1/0)\n   type Bit_Sequence is array (Positive range <>) of Boolean;\n   Zero_Sequence : constant Bit_Sequence (1 .. 0) := (others => False);\n   -- output the sequence\n   procedure Put (Code : Bit_Sequence);\n\n   -- type for freqency map\n   package Frequency_Maps is new Ada.Containers.Ordered_Maps\n     (Element_Type => Frequency_Type,\n      Key_Type     => Symbol_Type);\n\n   type Huffman_Tree is private;\n   -- create a huffman tree from frequency map\n   procedure Create_Tree\n     (Tree        : out Huffman_Tree;\n      Frequencies : Frequency_Maps.Map);\n   -- encode a single symbol\n   function Encode\n     (Tree   : Huffman_Tree;\n      Symbol : Symbol_Type)\n      return   Bit_Sequence;\n   -- encode a symbol sequence\n   function Encode\n     (Tree    : Huffman_Tree;\n      Symbols : Symbol_Sequence)\n      return    Bit_Sequence;\n   -- decode a bit sequence\n   function Decode\n     (Tree : Huffman_Tree;\n      Code : Bit_Sequence)\n      return Symbol_Sequence;\n   -- dump the encoding table\n   procedure Dump_Encoding (Tree : Huffman_Tree);\nprivate\n   -- type for encoding map\n   package Encoding_Maps is new Ada.Containers.Indefinite_Ordered_Maps\n     (Element_Type => Bit_Sequence,\n      Key_Type     => Symbol_Type);\n\n   type Huffman_Node;\n   type Node_Access is access Huffman_Node;\n   -- a node is either internal (left_child/right_child used)\n   -- or a leaf (left_child/right_child are null)\n   type Huffman_Node is record\n      Frequency   : Frequency_Type;\n      Left_Child  : Node_Access := null;\n      Right_Child : Node_Access := null;\n      Symbol      : Symbol_Type;\n   end record;\n   -- create a leaf node\n   function Create_Node\n     (Symbol    : Symbol_Type;\n      Frequency : Frequency_Type)\n      return      Node_Access;\n   -- create an internal node\n   function Create_Node (Left, Right : Node_Access) return Node_Access;\n   -- fill the encoding map\n   procedure Fill\n     (The_Node : Node_Access;\n      Map      : in out Encoding_Maps.Map;\n      Prefix   : Bit_Sequence);\n\n   -- huffman tree has a tree and an encoding map\n   type Huffman_Tree is new Ada.Finalization.Controlled with record\n      Tree : Node_Access       := null;\n      Map  : Encoding_Maps.Map := Encoding_Maps.Empty_Map;\n   end record;\n   -- free memory after finalization\n   overriding procedure Finalize (Object : in out Huffman_Tree);\nend Huffman;\n\n\nwith Ada.Text_IO;\nwith Ada.Unchecked_Deallocation;\nwith Ada.Containers.Vectors;\npackage body Huffman is\n   package Node_Vectors is new Ada.Containers.Vectors\n     (Element_Type => Node_Access,\n      Index_Type   => Positive);\n\n   function \"<\" (Left, Right : Node_Access) return Boolean is\n   begin\n      -- compare frequency\n      if Left.Frequency < Right.Frequency then\n         return True;\n      elsif Right.Frequency < Left.Frequency then\n         return False;\n      end if;\n      -- same frequency, choose leaf node\n      if Left.Left_Child = null and then Right.Left_Child /= null then\n         return True;\n      elsif Left.Left_Child /= null and then Right.Left_Child = null then\n         return False;\n      end if;\n      -- same frequency, same node type (internal/leaf)\n      if Left.Left_Child /= null then\n         -- for internal nodes, compare left children, then right children\n         if Left.Left_Child < Right.Left_Child then\n            return True;\n         elsif Right.Left_Child < Left.Left_Child then\n            return False;\n         else\n            return Left.Right_Child < Right.Right_Child;\n         end if;\n      else\n         -- for leaf nodes, compare symbol\n         return Left.Symbol < Right.Symbol;\n      end if;\n   end \"<\";\n   package Node_Vector_Sort is new Node_Vectors.Generic_Sorting;\n\n   procedure Create_Tree\n     (Tree        : out Huffman_Tree;\n      Frequencies : Frequency_Maps.Map) is\n      Node_Queue : Node_Vectors.Vector := Node_Vectors.Empty_Vector;\n   begin\n      -- insert all leafs into the queue\n      declare\n         use Frequency_Maps;\n         Position : Cursor      := Frequencies.First;\n         The_Node : Node_Access := null;\n      begin\n         while Position /= No_Element loop\n            The_Node :=\n              Create_Node\n                (Symbol    => Key (Position),\n                 Frequency => Element (Position));\n            Node_Queue.Append (The_Node);\n            Next (Position);\n         end loop;\n      end;\n      -- sort by frequency (see \"<\")\n      Node_Vector_Sort.Sort (Node_Queue);\n      -- iterate over all elements\n      while not Node_Queue.Is_Empty loop\n         declare\n            First : constant Node_Access := Node_Queue.First_Element;\n         begin\n            Node_Queue.Delete_First;\n            -- if we only have one node left, it is the root node of the tree\n            if Node_Queue.Is_Empty then\n               Tree.Tree := First;\n            else\n               -- create new internal node with two smallest frequencies\n               declare\n                  Second : constant Node_Access := Node_Queue.First_Element;\n               begin\n                  Node_Queue.Delete_First;\n                  Node_Queue.Append (Create_Node (First, Second));\n               end;\n               Node_Vector_Sort.Sort (Node_Queue);\n            end if;\n         end;\n      end loop;\n      -- fill encoding map\n      Fill (The_Node => Tree.Tree, Map => Tree.Map, Prefix => Zero_Sequence);\n   end Create_Tree;\n\n   -- create leaf node\n   function Create_Node\n     (Symbol    : Symbol_Type;\n      Frequency : Frequency_Type)\n      return      Node_Access\n   is\n      Result : Node_Access := new Huffman_Node;\n   begin\n      Result.Frequency := Frequency;\n      Result.Symbol    := Symbol;\n      return Result;\n   end Create_Node;\n\n   -- create internal node\n   function Create_Node (Left, Right : Node_Access) return Node_Access is\n      Result : Node_Access := new Huffman_Node;\n   begin\n      Result.Frequency   := Left.Frequency + Right.Frequency;\n      Result.Left_Child  := Left;\n      Result.Right_Child := Right;\n      return Result;\n   end Create_Node;\n\n   -- fill encoding map\n   procedure Fill\n     (The_Node : Node_Access;\n      Map      : in out Encoding_Maps.Map;\n      Prefix   : Bit_Sequence) is\n   begin\n      if The_Node.Left_Child /= null then\n         -- append false (0) for left child\n         Fill (The_Node.Left_Child, Map, Prefix & False);\n         -- append true (1) for right child\n         Fill (The_Node.Right_Child, Map, Prefix & True);\n      else\n         -- leaf node reached, prefix = code for symbol\n         Map.Insert (The_Node.Symbol, Prefix);\n      end if;\n   end Fill;\n\n   -- free memory after finalization\n   overriding procedure Finalize (Object : in out Huffman_Tree) is\n      procedure Free is new Ada.Unchecked_Deallocation\n        (Name   => Node_Access,\n         Object => Huffman_Node);\n      -- recursively free all nodes\n      procedure Recursive_Free (The_Node : in out Node_Access) is\n      begin\n         -- free node if it is a leaf\n         if The_Node.Left_Child = null then\n            Free (The_Node);\n         else\n            -- free left and right child if node is internal\n            Recursive_Free (The_Node.Left_Child);\n            Recursive_Free (The_Node.Right_Child);\n            -- free node afterwards\n            Free (The_Node);\n         end if;\n      end Recursive_Free;\n   begin\n      -- recursively free root node\n      Recursive_Free (Object.Tree);\n   end Finalize;\n\n   -- encode single symbol\n   function Encode\n     (Tree   : Huffman_Tree;\n      Symbol : Symbol_Type)\n      return   Bit_Sequence\n   is\n   begin\n      -- simply lookup in map\n      return Tree.Map.Element (Symbol);\n   end Encode;\n\n   -- encode symbol sequence\n   function Encode\n     (Tree    : Huffman_Tree;\n      Symbols : Symbol_Sequence)\n      return    Bit_Sequence\n   is\n   begin\n      -- only one element\n      if Symbols'Length = 1 then\n         -- see above\n         return Encode (Tree, Symbols (Symbols'First));\n      else\n         -- encode first element, append result of recursive call\n         return Encode (Tree, Symbols (Symbols'First)) &\n         Encode (Tree, Symbols (Symbols'First + 1 .. Symbols'Last));\n      end if;\n   end Encode;\n\n   -- decode a bit sequence\n   function Decode\n     (Tree : Huffman_Tree;\n      Code : Bit_Sequence)\n      return Symbol_Sequence\n   is\n      -- maximum length = code length\n      Result   : Symbol_Sequence (1 .. Code'Length);\n      -- last used index of result\n      Last     : Natural     := 0;\n      The_Node : Node_Access := Tree.Tree;\n   begin\n      -- iterate over the code\n      for I in Code'Range loop\n         -- if current element is true, descent the right branch\n         if Code (I) then\n            The_Node := The_Node.Right_Child;\n         else\n            -- false: descend left branch\n            The_Node := The_Node.Left_Child;\n         end if;\n         if The_Node.Left_Child = null then\n            -- reached leaf node: append symbol to result\n            Last          := Last + 1;\n            Result (Last) := The_Node.Symbol;\n            -- reset current node to root\n            The_Node := Tree.Tree;\n         end if;\n      end loop;\n      -- return subset of result array\n      return Result (1 .. Last);\n   end Decode;\n\n   -- output a bit sequence\n   procedure Put (Code : Bit_Sequence) is\n      package Int_IO is new Ada.Text_IO.Integer_IO (Integer);\n   begin\n      for I in Code'Range loop\n         if Code (I) then\n            -- true = 1\n            Int_IO.Put (1, 0);\n         else\n            -- false = 0\n            Int_IO.Put (0, 0);\n         end if;\n      end loop;\n      Ada.Text_IO.New_Line;\n   end Put;\n\n   -- dump encoding map\n   procedure Dump_Encoding (Tree : Huffman_Tree) is\n      use type Encoding_Maps.Cursor;\n      Position : Encoding_Maps.Cursor := Tree.Map.First;\n   begin\n      -- iterate map\n      while Position /= Encoding_Maps.No_Element loop\n         -- key\n         Put (Encoding_Maps.Key (Position));\n         Ada.Text_IO.Put (\" = \");\n         -- code\n         Put (Encoding_Maps.Element (Position));\n         Encoding_Maps.Next (Position);\n      end loop;\n   end Dump_Encoding;\nend Huffman;\n\n\nwith Ada.Text_IO;\nwith Huffman;\nprocedure Main is\n   package Char_Natural_Huffman_Tree is new Huffman\n     (Symbol_Type => Character,\n      Put => Ada.Text_IO.Put,\n      Symbol_Sequence => String,\n      Frequency_Type => Natural);\n   Tree         : Char_Natural_Huffman_Tree.Huffman_Tree;\n   Frequencies  : Char_Natural_Huffman_Tree.Frequency_Maps.Map;\n   Input_String : constant String :=\n     \"this is an example for huffman encoding\";\nbegin\n   -- build frequency map\n   for I in Input_String'Range loop\n      declare\n         use Char_Natural_Huffman_Tree.Frequency_Maps;\n         Position : constant Cursor := Frequencies.Find (Input_String (I));\n      begin\n         if Position = No_Element then\n            Frequencies.Insert (Key => Input_String (I), New_Item => 1);\n         else\n            Frequencies.Replace_Element\n              (Position => Position,\n               New_Item => Element (Position) + 1);\n         end if;\n      end;\n   end loop;\n\n   -- create huffman tree\n   Char_Natural_Huffman_Tree.Create_Tree\n     (Tree        => Tree,\n      Frequencies => Frequencies);\n\n   -- dump encodings\n   Char_Natural_Huffman_Tree.Dump_Encoding (Tree => Tree);\n\n   -- encode example string\n   declare\n      Code : constant Char_Natural_Huffman_Tree.Bit_Sequence :=\n        Char_Natural_Huffman_Tree.Encode\n          (Tree    => Tree,\n           Symbols => Input_String);\n   begin\n      Char_Natural_Huffman_Tree.Put (Code);\n      Ada.Text_IO.Put_Line\n        (Char_Natural_Huffman_Tree.Decode (Tree => Tree, Code => Code));\n   end;\nend Main;\n\n\nOutput:\n  = 101\na = 1001\nc = 01010\nd = 01011\ne = 1100\nf = 1101\ng = 01100\nh = 11111\ni = 1110\nl = 01101\nm = 0010\nn = 000\no = 0011\np = 01110\nr = 01111\ns = 0100\nt = 10000\nu = 10001\nx = 11110\n1000011111111001001011110010010110010001011100111101001001001110011011100101110100110111110111111100011101110100101001000101110000001010001101011111000001100\nthis is an example for huffman encoding\n", "explain": "huffman.ads:\nhuffman.adb:\nexample main.adb:\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Julia", "code": "\nabstract type HuffmanTree end\n\nstruct HuffmanLeaf <: HuffmanTree\n    ch::Char\n    freq::Int\nend\n\nstruct HuffmanNode <: HuffmanTree\n    freq::Int\n    left::HuffmanTree\n    right::HuffmanTree\nend\n\nfunction makefreqdict(s::String)\n    d = Dict{Char, Int}()\n    for c in s\n        if !haskey(d, c)\n            d[c] = 1\n        else\n            d[c] += 1\n        end\n    end\n    d\nend\n\nfunction huffmantree(ftable::Dict)\n    trees::Vector{HuffmanTree} = [HuffmanLeaf(ch, fq) for (ch, fq) in ftable]\n    while length(trees) > 1\n        sort!(trees, lt = (x, y) -> x.freq < y.freq, rev = true)\n        least = pop!(trees)\n        nextleast = pop!(trees)\n        push!(trees, HuffmanNode(least.freq + nextleast.freq, least, nextleast))\n    end\n    trees[1]\nend\n\nprintencoding(lf::HuffmanLeaf, code) = println(lf.ch == ' ' ? \"space\" : lf.ch, \"\\t\", lf.freq, \"\\t\", code)\n\nfunction printencoding(nd::HuffmanNode, code)\n    code *= '0'\n    printencoding(nd.left, code)\n    code = code[1:end-1]\n\n    code *= '1'\n    printencoding(nd.right, code)\n    code = code[1:end-1]\nend\n\nconst msg = \"this is an example for huffman encoding\"\n\nprintln(\"Char\\tFreq\\tHuffman code\")\n\nprintencoding(huffmantree(makefreqdict(msg)), \"\")\n\nOutput:\n\nChar    Freq    Huffman code\np       1       00000\nc       1       00001\ng       1       00010\nx       1       00011\nn       4       001\ns       2       0100\nh       2       0101\nu       1       01100\nl       1       01101\nm       2       0111\no       2       1000\nd       1       10010\nr       1       100110\nt       1       100111\ne       3       1010\nf       3       1011\na       3       1100\ni       3       1101\nspace   6       111\n\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Kotlin", "code": "\nTranslation of: Java\n\nimport java.util.*\n\nabstract class HuffmanTree(var freq: Int) : Comparable<HuffmanTree> {\n    override fun compareTo(other: HuffmanTree) = freq - other.freq\n}\n\nclass HuffmanLeaf(freq: Int, var value: Char) : HuffmanTree(freq)\n\nclass HuffmanNode(var left: HuffmanTree, var right: HuffmanTree) : HuffmanTree(left.freq + right.freq)\n\nfun buildTree(charFreqs: IntArray) : HuffmanTree {\n    val trees = PriorityQueue<HuffmanTree>()\n\n    charFreqs.forEachIndexed { index, freq ->\n        if(freq > 0) trees.offer(HuffmanLeaf(freq, index.toChar()))\n    }\n\n    assert(trees.size > 0)\n    while (trees.size > 1) {\n        val a = trees.poll()\n        val b = trees.poll()\n        trees.offer(HuffmanNode(a, b))\n    }\n\n    return trees.poll()\n}\n\nfun printCodes(tree: HuffmanTree, prefix: StringBuffer) {\n    when(tree) {\n        is HuffmanLeaf -> println(\"${tree.value}\\t${tree.freq}\\t$prefix\")\n        is HuffmanNode -> {\n            //traverse left\n            prefix.append('0')\n            printCodes(tree.left, prefix)\n            prefix.deleteCharAt(prefix.lastIndex)\n            //traverse right\n            prefix.append('1')\n            printCodes(tree.right, prefix)\n            prefix.deleteCharAt(prefix.lastIndex)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val test = \"this is an example for huffman encoding\"\n\n    val maxIndex = test.max()!!.toInt() + 1\n    val freqs = IntArray(maxIndex) //256 enough for latin ASCII table, but dynamic size is more fun\n    test.forEach { freqs[it.toInt()] += 1 }\n\n    val tree = buildTree(freqs)\n    println(\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\")\n    printCodes(tree, StringBuffer())\n}\n\n\nOutput:\nSYMBOL\tWEIGHT\tHUFFMAN CODE\nd\t1\t00000\nt\t1\t00001\nh\t2\t0001\ns\t2\t0010\nc\t1\t00110\nx\t1\t00111\nm\t2\t0100\no\t2\t0101\nn\t4\t011\nu\t1\t10000\nl\t1\t10001\na\t3\t1001\nr\t1\t10100\ng\t1\t101010\np\t1\t101011\ne\t3\t1011\ni\t3\t1100\nf\t3\t1101\n6\t111\n", "explain": "This implementation creates an actual tree structure, and then traverses the tree to recover the code.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Perl", "code": "\nuse 5.10.0;\nuse strict;\n\n# produce encode and decode dictionary from a tree\nsub walk {\n\tmy ($node, $code, $h, $rev_h) = @_;\n\n\tmy $c = $node->[0];\n\tif (ref $c) { walk($c->[$_], $code.$_, $h, $rev_h) for 0,1 }\n\telse        { $h->{$c} = $code; $rev_h->{$code} = $c }\n\n\t$h, $rev_h\n}\n\n# make a tree, and return resulting dictionaries\nsub mktree {\n\tmy (%freq, @nodes);\n\t$freq{$_}++ for split '', shift;\n\t@nodes = map([$_, $freq{$_}], keys %freq);\n\n\tdo {\t# poor man's priority queue\n\t\t@nodes = sort {$a->[1] <=> $b->[1]} @nodes;\n\t\tmy ($x, $y) = splice @nodes, 0, 2;\n\t\tpush @nodes, [[$x, $y], $x->[1] + $y->[1]]\n\t} while (@nodes > 1);\n\n\twalk($nodes[0], '', {}, {})\n}\n\nsub encode {\n\tmy ($str, $dict) = @_;\n\tjoin '', map $dict->{$_}//die(\"bad char $_\"), split '', $str\n}\n\nsub decode {\n\tmy ($str, $dict) = @_;\n\tmy ($seg, @out) = (\"\");\n\n\t# append to current segment until it's in the dictionary\n\tfor (split '', $str) {\n\t\t$seg .= $_;\n\t\tmy $x = $dict->{$seg} // next;\n\t\tpush @out, $x;\n\t\t$seg = '';\n\t}\n\tdie \"bad code\" if length($seg);\n\tjoin '', @out\n}\n\nmy $txt = 'this is an example for huffman encoding';\nmy ($h, $rev_h) = mktree($txt);\nfor (keys %$h) { print \"'$_': $h->{$_}\\n\" }\n\nmy $enc = encode($txt, $h);\nprint \"$enc\\n\";\n\nprint decode($enc, $rev_h), \"\\n\";\n\n\nOutput:\n'u': 10000\n'd': 01111\n'a': 1101\n'l': 10001\n'i': 1110\n'g': 11110\n'h': 0100\n'r': 01110\n' ': 101\n'p': 01100\n't': 01101\n'n': 000\n'm': 0011\n'x': 01011\n'f': 1100\n'c': 01010\n'o': 0010\n's': 11111\n'e': 1001\n0110101001110111111011110111111011101000101100101011110100110110010001100110111000010011101010100100001100110000111101000101100100001010001001111111000011110\nthis is an example for huffman encoding\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Objective-C", "code": "\nTranslation of: Java\n\n#import <Foundation/Foundation.h>\n\n\n@interface HuffmanTree\u00a0: NSObject {\n\tint freq;\n}\n-(instancetype)initWithFreq:(int)f;\n@property (nonatomic, readonly) int freq;\n@end\n\n@implementation HuffmanTree\n@synthesize freq; // the frequency of this tree\n-(instancetype)initWithFreq:(int)f {\n\tif (self = [super init]) {\n\t\tfreq = f;\n\t}\n\treturn self;\n}\n@end\n\n\nconst void *HuffmanRetain(CFAllocatorRef allocator, const void *ptr) {\n\treturn (__bridge_retained const void *)(__bridge id)ptr;\n}\nvoid HuffmanRelease(CFAllocatorRef allocator, const void *ptr) {\n\t(void)(__bridge_transfer id)ptr;\n}\nCFComparisonResult HuffmanCompare(const void *ptr1, const void *ptr2, void *unused) {\n\tint f1 = ((__bridge HuffmanTree *)ptr1).freq;\n\tint f2 = ((__bridge HuffmanTree *)ptr2).freq;\n\tif (f1 == f2)\n\t\treturn kCFCompareEqualTo;\n\telse if (f1 > f2)\n\t\treturn kCFCompareGreaterThan;\n\telse\n\t\treturn kCFCompareLessThan;\n}\n\n\n@interface HuffmanLeaf\u00a0: HuffmanTree {\n\tchar value; // the character this leaf represents\n}\n@property (readonly) char value;\n-(instancetype)initWithFreq:(int)f character:(char)c;\n@end\n\n@implementation HuffmanLeaf\n@synthesize value;\n-(instancetype)initWithFreq:(int)f character:(char)c {\n\tif (self = [super initWithFreq:f]) {\n\t\tvalue = c;\n\t}\n\treturn self;\n}\n@end\n\n\n@interface HuffmanNode\u00a0: HuffmanTree {\n\tHuffmanTree *left, *right; // subtrees\n}\n@property (readonly) HuffmanTree *left, *right;\n-(instancetype)initWithLeft:(HuffmanTree *)l right:(HuffmanTree *)r;\n@end\n\n@implementation HuffmanNode\n@synthesize left, right;\n-(instancetype)initWithLeft:(HuffmanTree *)l right:(HuffmanTree *)r {\n\tif (self = [super initWithFreq:l.freq+r.freq]) {\n\t\tleft = l;\n\t\tright = r;\n\t}\n\treturn self;\n}\n@end\n\n\nHuffmanTree *buildTree(NSCountedSet *chars) {\n\t\n\tCFBinaryHeapCallBacks callBacks = {0, HuffmanRetain, HuffmanRelease, NULL, HuffmanCompare};\n\tCFBinaryHeapRef trees = CFBinaryHeapCreate(NULL, 0, &callBacks, NULL);\n\n\t// initially, we have a forest of leaves\n\t// one for each non-empty character\n\tfor (NSNumber *ch in chars) {\n\t\tint freq = [chars countForObject:ch];\n\t\tif (freq > 0)\n\t\t\tCFBinaryHeapAddValue(trees, (__bridge const void *)[[HuffmanLeaf alloc] initWithFreq:freq character:(char)[ch intValue]]);\n\t}\n\t\n\tNSCAssert(CFBinaryHeapGetCount(trees) > 0, @\"String must have at least one character\");\n\t// loop until there is only one tree left\n\twhile (CFBinaryHeapGetCount(trees) > 1) {\n\t\t// two trees with least frequency\n\t\tHuffmanTree *a = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);\n\t\tCFBinaryHeapRemoveMinimumValue(trees);\n\t\tHuffmanTree *b = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);\n\t\tCFBinaryHeapRemoveMinimumValue(trees);\n\t\t\n\t\t// put into new node and re-insert into queue\n\t\tCFBinaryHeapAddValue(trees, (__bridge const void *)[[HuffmanNode alloc] initWithLeft:a right:b]);\n\t}\n\tHuffmanTree *result = (__bridge HuffmanTree *)CFBinaryHeapGetMinimum(trees);\n\tCFRelease(trees);\n\treturn result;\n}\n\nvoid printCodes(HuffmanTree *tree, NSMutableString *prefix) {\n\tNSCAssert(tree != nil, @\"tree must not be nil\");\n\tif ([tree isKindOfClass:[HuffmanLeaf class]]) {\n\t\tHuffmanLeaf *leaf = (HuffmanLeaf *)tree;\n\t\t\n\t\t// print out character, frequency, and code for this leaf (which is just the prefix)\n\t\tNSLog(@\"%c\\t%d\\t%@\", leaf.value, leaf.freq, prefix);\n\t\t\n\t} else if ([tree isKindOfClass:[HuffmanNode class]]) {\n\t\tHuffmanNode *node = (HuffmanNode *)tree;\n\t\t\n\t\t// traverse left\n\t\t[prefix appendString:@\"0\"];\n\t\tprintCodes(node.left, prefix);\n\t\t[prefix deleteCharactersInRange:NSMakeRange([prefix length]-1, 1)];\n\t\t\n\t\t// traverse right\n\t\t[prefix appendString:@\"1\"];\n\t\tprintCodes(node.right, prefix);\n\t\t[prefix deleteCharactersInRange:NSMakeRange([prefix length]-1, 1)];\n\t}\n}\n\nint main(int argc, const char * argv[]) {\n    @autoreleasepool {\n\n\tNSString *test = @\"this is an example for huffman encoding\";\n\t\n\t// read each character and record the frequencies\n\tNSCountedSet *chars = [[NSCountedSet alloc] init];\n\tint n = [test length];\n\tfor (int i = 0; i < n; i++)\n\t\t[chars addObject:@([test characterAtIndex:i])];\n\t\n\t// build tree\n\tHuffmanTree *tree = buildTree(chars);\n\t\n\t// print out results\n\tNSLog(@\"SYMBOL\\tWEIGHT\\tHUFFMAN CODE\");\n\tprintCodes(tree, [NSMutableString string]);\n\t\n    }\n    return 0;\n}\n\n\nOutput:\nSYMBOL\tWEIGHT\tHUFFMAN CODE\ng\t1\t00000\nx\t1\t00001\nm\t2\t0001\nd\t1\t00100\nu\t1\t00101\nt\t1\t00110\nr\t1\t00111\nn\t4\t010\ns\t2\t0110\no\t2\t0111\np\t1\t10000\nl\t1\t10001\na\t3\t1001\n \t6\t101\nf\t3\t1100\ne\t3\t1101\nc\t1\t11100\nh\t2\t11101\ni\t3\t1111\n\n", "explain": "This is not purely Objective-C. It uses Apple's Core Foundation library for its binary heap, which admittedly is very ugly. Thus, this only builds on Mac OS X, not GNUstep.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Prolog", "code": "\n\nhuffman :-\n\tL = 'this is an example for huffman encoding',\n\tatom_chars(L, LA),\n\tmsort(LA, LS),\n\tpackList(LS, PL),\n\tsort(PL, PLS),\n\tbuild_tree(PLS, A),\n\tcoding(A, [], C),\n\tsort(C, SC),\n\tformat('Symbol~t   Weight~t~30|Code~n'),\n\tmaplist(print_code, SC).\n\nbuild_tree([[V1|R1], [V2|R2]|T], AF) :- \n\tV is V1 + V2, \n\tA = [V, [V1|R1], [V2|R2]],\n\t(   T=[] -> AF=A ;  sort([A|T], NT), build_tree(NT, AF) ).\n\ncoding([_A,FG,FD], Code, CF) :-\n\t(   is_node(FG) ->  coding(FG, [0 | Code], C1)\n\t\t\t ;  leaf_coding(FG, [0 | Code], C1) ),\n\t(   is_node(FD) ->  coding(FD, [1 | Code], C2)\n\t\t\t ;  leaf_coding(FD, [1 | Code], C2) ),\n\tappend(C1, C2, CF).\n\nleaf_coding([FG,FD], Code, CF) :-\n\treverse(Code, CodeR),\n\tCF = [[FG, FD, CodeR]] .\n\nis_node([_V, _FG, _FD]).\n\nprint_code([N, Car, Code]):-\n\tformat('~w\u00a0:~t~w~t~30|', [Car, N]),\n\tforall(member(V, Code), write(V)),\n\tnl.\n\npackList([], []).\npackList([X], [[1,X]]) :- !.\npackList([X|Rest], [XRun|Packed]):-\n    run(X, Rest, XRun, RRest),\n    packList(RRest, Packed).\n\nrun(V, [], [1,V], []).\nrun(V, [V|LRest], [N1,V], RRest):-\n    run(V, LRest, [N, V], RRest),\n    N1 is N + 1.\nrun(V, [Other|RRest], [1,V], [Other|RRest]):-\n    dif(V, Other).\n\n\nOutput:\n\u00a0?- huffman.\nSymbol          Weight        Code\nc\u00a0:             1             01010\nd\u00a0:             1             01011\ng\u00a0:             1             01100\nl\u00a0:             1             01101\np\u00a0:             1             01110\nr\u00a0:             1             01111\nt\u00a0:             1             10000\nu\u00a0:             1             10001\nx\u00a0:             1             11110\nh\u00a0:             2             11111\nm\u00a0:             2             0010\no\u00a0:             2             0011\ns\u00a0:             2             0100\na\u00a0:             3             1001\ne\u00a0:             3             1100\nf\u00a0:             3             1101\ni\u00a0:             3             1110\nn\u00a0:             4             000\n \u00a0:             6             101\n\n", "explain": "Works with SWI-Prolog\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Lua", "code": "\n\nlocal build_freqtable = function (data)\n  local freq = { }\n\n  for i = 1, #data do\n    local cur = string.sub (data, i, i)\n    local count = freq [cur] or 0\n    freq [cur] = count + 1\n  end\n\n  local nodes = { }\n  for w, f in next, freq do\n    nodes [#nodes + 1] = { word = w, freq = f }\n  end\n\n  table.sort (nodes, function (a, b) return a.freq > b.freq end) --- reverse order!\n\n  return nodes\nend\n\nlocal build_hufftree = function (nodes)\n  while true do\n    local n = #nodes\n    local left = nodes [n]\n    nodes [n] = nil\n\n    local right = nodes [n - 1]\n    nodes [n - 1] = nil\n\n    local new = { freq = left.freq + right.freq, left = left, right = right }\n\n    if n == 2 then return new end\n\n    --- insert new node at correct priority\n    local prio = 1\n    while prio < #nodes and nodes [prio].freq > new.freq do\n      prio = prio + 1\n    end\n    table.insert (nodes, prio, new)\n  end\nend\n\nlocal print_huffcodes do\n  local rec_build_huffcodes\n  rec_build_huffcodes = function (node, bits, acc)\n    if node.word == nil then\n      rec_build_huffcodes (node.left,  bits .. \"0\", acc)\n      rec_build_huffcodes (node.right, bits .. \"1\", acc)\n      return acc\n    else --- leaf\n      acc [#acc + 1] = { node.freq, node.word, bits }\n    end\n    return acc\n  end\n\n  print_huffcodes = function (root)\n    local codes = rec_build_huffcodes (root, \"\", { })\n    table.sort (codes, function (a, b) return a [1] < b [1] end)\n    print (\"frequency\\tword\\thuffman code\")\n    for i = 1, #codes do\n      print (string.format (\"%9d\\t\u2018%s\u2019\\t\u201c%s\u201d\", table.unpack (codes [i])))\n    end\n  end\nend\n\n\nlocal huffcode = function (data)\n  local nodes = build_freqtable (data)\n  local huff = build_hufftree (nodes)\n  print_huffcodes (huff)\n  return 0\nend\n\nreturn huffcode \"this is an example for huffman encoding\"\n\nfrequency\tword\thuffman code\n        1\t\u2018g\u2019\t\u201c01111\u201d\n        1\t\u2018p\u2019\t\u201c01011\u201d\n        1\t\u2018d\u2019\t\u201c01100\u201d\n        1\t\u2018c\u2019\t\u201c01101\u201d\n        1\t\u2018t\u2019\t\u201c01010\u201d\n        1\t\u2018r\u2019\t\u201c10000\u201d\n        1\t\u2018u\u2019\t\u201c11110\u201d\n        1\t\u2018x\u2019\t\u201c10001\u201d\n        1\t\u2018l\u2019\t\u201c01110\u201d\n        2\t\u2018o\u2019\t\u201c11111\u201d\n        2\t\u2018m\u2019\t\u201c0011\u201d\n        2\t\u2018h\u2019\t\u201c0010\u201d\n        2\t\u2018s\u2019\t\u201c0100\u201d\n        3\t\u2018i\u2019\t\u201c1101\u201d\n        3\t\u2018f\u2019\t\u201c1110\u201d\n        3\t\u2018a\u2019\t\u201c1100\u201d\n        3\t\u2018e\u2019\t\u201c1001\u201d\n        4\t\u2018n\u2019\t\u201c000\u201d\n        6\t\u2018 \u2019\t\u201c101\u201d\n\n", "explain": "This implementation proceeds in three steps: determine word frequencies,\nconstruct the Huffman tree, and finally fold the tree into the codes\nwhile outputting them.\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Scala", "code": "\nWorks with: scala version 2.8\nobject Huffman {\n  import scala.collection.mutable.{Map, PriorityQueue}\n  \n  sealed abstract class Tree\n  case class Node(left: Tree, right: Tree) extends Tree\n  case class Leaf(c: Char) extends Tree\n  \n  def treeOrdering(m: Map[Tree, Int]) = new Ordering[Tree] { \n     def compare(x: Tree, y: Tree) = m(y).compare(m(x))\n  }\n\n  def stringMap(text: String) = text groupBy (x => Leaf(x) : Tree) mapValues (_.length)\n  \n  def buildNode(queue: PriorityQueue[Tree], map: Map[Tree,Int]) {\n    val right = queue.dequeue\n    val left = queue.dequeue\n    val node = Node(left, right)\n    map(node) = map(left) + map(right)\n    queue.enqueue(node)\n  }\n\n  def codify(tree: Tree, map: Map[Tree, Int]) = {\n    def recurse(tree: Tree, prefix: String): List[(Char, (Int, String))] = tree match {\n      case Node(left, right) => recurse(left, prefix+\"0\") ::: recurse(right, prefix+\"1\")\n      case leaf @ Leaf(c) => c -> ((map(leaf), prefix)) :: Nil\n    }\n    recurse(tree, \"\")\n  }\n\n  def encode(text: String) = {\n    val map = Map.empty[Tree,Int] ++= stringMap(text)\n    val queue = new PriorityQueue[Tree]()(treeOrdering(map)) ++= map.keysIterator\n    \n    while(queue.size > 1) {\n      buildNode(queue, map)\n    }\n    codify(queue.dequeue, map)\n  }\n  \n  \n  def main(args: Array[String]) {\n    val text = \"this is an example for huffman encoding\"\n    val code = encode(text)\n    println(\"Char\\tWeight\\t\\tEncoding\")\n    code sortBy (_._2._1) foreach { \n      case (c, (weight, encoding)) => println(\"%c:\\t%3d/%-3d\\t\\t%s\" format (c, weight, text.length, encoding)) \n    }\n  }\n}\n\n\nOutput:\nChar    Weight          Encoding\nt:        1/39          011000\np:        1/39          011001\nr:        1/39          01101\nc:        1/39          01110\nx:        1/39          01111\ng:        1/39          10110\nl:        1/39          10111\nu:        1/39          11000\nd:        1/39          11001\no:        2/39          1010\ns:        2/39          1101\nm:        2/39          1110\nh:        2/39          1111\nf:        3/39          0000\na:        3/39          0001\ne:        3/39          0010\ni:        3/39          0011\nn:        4/39          100\n\u00a0:        6/39          010\n\nScala (Alternate version)[edit]\nWorks with: scala version 2.11.7\n// this version uses immutable data only, recursive functions and pattern matching\nobject Huffman {\n  sealed trait Tree[+A]\n  case class Leaf[A](value: A) extends Tree[A]\n  case class Branch[A](left: Tree[A], right: Tree[A]) extends Tree[A]\n\n  // recursively build the binary tree needed to Huffman encode the text\n  def merge(xs: List[(Tree[Char], Int)]): List[(Tree[Char], Int)] = {\n    if (xs.length == 1) xs else {\n      val l = xs.head\n      val r = xs.tail.head\n      val merged = (Branch(l._1, r._1), l._2 + r._2)\n      merge((merged :: xs.drop(2)).sortBy(_._2))\n    }\n  }\n\n  // recursively search the branches of the tree for the required character\n  def contains(tree: Tree[Char], char: Char): Boolean = tree match {\n    case Leaf(c) => if (c == char) true else false\n    case Branch(l, r) => contains(l, char) || contains(r, char)\n  }\n\n  // recursively build the path string required to traverse the tree to the required character\n  def encodeChar(tree: Tree[Char], char: Char): String = {\n    def go(tree: Tree[Char], char: Char, code: String): String = tree match {\n      case Leaf(_) => code\n      case Branch(l, r) => if (contains(l, char)) go(l, char, code + '0') else go(r, char, code + '1')\n    }\n    go(tree, char, \"\")\n  }\n\n  def main(args: Array[String]) {\n    val text = \"this is an example for huffman encoding\"\n    // transform the text into a list of tuples.\n    // each tuple contains a Leaf node containing a unique character and an Int representing that character's weight\n    val frequencies = text.groupBy(chars => chars).mapValues(group => group.length).toList.map(x => (Leaf(x._1), x._2)).sortBy(_._2)\n    // build the Huffman Tree for this text\n    val huffmanTree = merge(frequencies).head._1\n    // output the resulting character codes\n    println(\"Char\\tWeight\\tCode\")\n    frequencies.foreach(x => println(x._1.value + \"\\t\" + x._2 + s\"/${text.length}\" + s\"\\t${encodeChar(huffmanTree, x._1.value)}\"))\n  }\n}\n\nChar    Weight  Code\nx       1/39    01100\nt       1/39    01101\nu       1/39    00010\ng       1/39    00011\nl       1/39    00000\np       1/39    00001\nc       1/39    100110\nr       1/39    100111\nd       1/39    10010\ns       2/39    0111\nm       2/39    0100\nh       2/39    0101\no       2/39    1000\ne       3/39    1100\nf       3/39    1101\na       3/39    1010\ni       3/39    1011\nn       4/39    001\n        6/39    111\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "D", "code": "\nimport std.stdio, std.algorithm, std.typecons, std.container, std.array;\n\nauto encode(alias eq, R)(Group!(eq, R) sf) /*pure nothrow @safe*/ {\n    auto heap = sf.map!(s => tuple(s[1], [tuple(s[0], \"\")]))\n                .array.heapify!q{b < a};\n\n    while (heap.length > 1) {\n        auto lo = heap.front; heap.removeFront;\n        auto hi = heap.front; heap.removeFront;\n        lo[1].each!((ref pair) => pair[1] = '0' ~ pair[1]);\n        hi[1].each!((ref pair) => pair[1] = '1' ~ pair[1]);\n        heap.insert(tuple(lo[0] + hi[0], lo[1] ~ hi[1]));\n    }\n    return heap.front[1].schwartzSort!q{ tuple(a[1].length, a[0]) };\n}\n\nvoid main() /*@safe*/ {\n    immutable s = \"this is an example for huffman encoding\"d;\n    foreach (const p; s.dup.sort().group.encode)\n        writefln(\"'%s'  %s\", p[]);\n}\n\n\nOutput:\n' '  101\n'n'  010\n'a'  1001\n'e'  1100\n'f'  1101\n'h'  0001\n'i'  1110\n'm'  0010\n'o'  0011\n's'  0111\n'g'  00000\n'l'  00001\n'p'  01100\n'r'  01101\n't'  10000\n'u'  10001\n'x'  11110\n'c'  111110\n'd'  111111\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Haskell", "code": "\n\nimport Data.List (group, insertBy, sort, sortBy)\nimport Control.Arrow ((&&&), second)\nimport Data.Ord (comparing)\n\ndata HTree a\n  = Leaf a\n  | Branch (HTree a)\n           (HTree a)\n  deriving (Show, Eq, Ord)\n\ntest :: String -> IO ()\ntest =\n  mapM_ (\\(a, b) -> putStrLn ('\\'' : a : (\"'\u00a0: \" ++ b))) .\n  serialize . huffmanTree . freq\n\nserialize :: HTree a -> [(a, String)]\nserialize (Branch l r) =\n  (second ('0' :) <$> serialize l) ++ (second ('1' :) <$> serialize r)\nserialize (Leaf x) = [(x, \"\")]\n\nhuffmanTree\n  :: (Ord w, Num w)\n  => [(w, a)] -> HTree a\nhuffmanTree =\n  snd .\n  head . until (null . tail) hstep . sortBy (comparing fst) . fmap (second Leaf)\n\nhstep\n  :: (Ord a, Num a)\n  => [(a, HTree b)] -> [(a, HTree b)]\nhstep ((w1, t1):(w2, t2):wts) =\n  insertBy (comparing fst) (w1 + w2, Branch t1 t2) wts\n\nfreq\n  :: Ord a\n  => [a] -> [(Int, a)]\nfreq = fmap (length &&& head) . group . sort\n\nmain :: IO ()\nmain = test \"this is an example for huffman encoding\"\n\n\nOutput:\n'p' : 00000\n'r' : 00001\n'g' : 00010\n'l' : 00011\n'n' : 001\n'm' : 0100\n'o' : 0101\n'c' : 01100\n'd' : 01101\n'h' : 0111\n's' : 1000\n'x' : 10010\n't' : 100110\n'u' : 100111\n'f' : 1010\n'i' : 1011\n'a' : 1100\n'e' : 1101\n' ' : 111\n\nUsing Set as a priority queue[edit]\n\nimport qualified Data.Set as S\n\nhtree :: (Ord t, Num t, Ord a) => S.Set (t, HTree a) -> HTree a\nhtree ts | S.null ts_1 = t1\n         | otherwise = htree ts_3\n           where\n             ((w1,t1), ts_1) = S.deleteFindMin ts\n             ((w2,t2), ts_2) = S.deleteFindMin ts_1\n             ts_3 = S.insert (w1 + w2, Branch t1 t2) ts_2\n \nhuffmanTree :: (Ord w, Num w, Ord a) => [(w, a)] -> HTree a\nhuffmanTree =  htree . S.fromList . map (second Leaf)\n\nA non-tree version[edit]\n\nimport Data.List (sortBy, insertBy, sort, group)\nimport Control.Arrow (second, (&&&))\nimport Data.Ord (comparing)\n\nfreq :: Ord a => [a] -> [(Int, a)]\nfreq = map (length &&& head) . group . sort\n\nhuffman :: [(Int, Char)] -> [(Char, String)]\nhuffman = reduce . map (\\(p, c) -> (p, [(c ,\"\")])) . sortBy (comparing fst)\n  where add (p1, xs1) (p2, xs2) = (p1 + p2, map (second ('0':)) xs1 ++ map (second ('1':)) xs2)\n        reduce [(_, ys)]  = sortBy (comparing fst) ys\n        reduce (x1:x2:xs) = reduce $ insertBy (comparing fst) (add x1 x2) xs\n\ntest s = mapM_ (\\(a, b) -> putStrLn ('\\'' : a : \"\\'\u00a0: \" ++ b)) . huffman . freq $ s\n\nmain = do\n    test \"this is an example for huffman encoding\"\n\n", "explain": "Credits go to huffman where you'll also find a non-tree solution. Uses sorted list as a priority queue.\n(might be worth it for bigger alphabets): \nThis produces the output required without building the Huffman tree at all, \nby building all the trace strings directly while reducing the histogram:\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Scheme", "code": "\n(define (char-freq port table)\n  (if\n   (eof-object? (peek-char port))\n   table\n   (char-freq port (add-char (read-char port) table))))\n\n(define (add-char char table)\n  (cond\n   ((null? table) (list (list char 1)))\n   ((eq? (caar table) char) (cons (list char (+ (cadar table) 1)) (cdr table)))\n   (#t (cons (car table) (add-char char (cdr table))))))\n\n(define (nodeify table)\n  (map (lambda (x) (list x '() '())) table))\n\n(define node-freq cadar)\n\n(define (huffman-tree nodes)\n  (let ((queue (sort nodes (lambda (x y) (< (node-freq x) (node-freq y))))))\n    (if\n     (null? (cdr queue))\n     (car queue)\n     (huffman-tree\n      (cons\n       (list\n        (list 'notleaf (+ (node-freq (car queue)) (node-freq (cadr queue))))\n        (car queue)\n        (cadr queue))\n       (cddr queue))))))\n\n(define (list-encodings tree chars)\n  (for-each (lambda (c) (format #t \"~a:~a~%\" c (encode c tree))) chars))\n\n(define (encode char tree)\n  (cond\n   ((null? tree) #f)\n   ((eq? (caar tree) char) '())\n   (#t\n    (let ((left (encode char (cadr tree))) (right (encode char (caddr tree))))\n      (cond\n       ((not (or left right)) #f)\n       (left (cons #\\1 left))\n       (right (cons #\\0 right)))))))\n\n(define (decode digits tree)\n  (cond\n   ((not (eq? (caar tree) 'notleaf)) (caar tree))\n   ((eq? (car digits) #\\0) (decode (cdr digits) (cadr tree)))\n   (#t (decode (cdr digits) (caddr tree)))))\n\n(define input \"this is an example for huffman encoding\")\n(define freq-table (char-freq (open-input-string input) '()))\n(define tree (huffman-tree (nodeify freq-table)))\n(list-encodings tree (map car freq-table))\n\n\nOutput:\nt:(1 0 0 1 1)\nh:(1 0 0 0)\ni:(0 0 1 1)\ns:(1 0 1 1)\n\u00a0:(0 0 0)\na:(0 0 1 0)\nn:(1 1 0)\ne:(0 1 0 1)\nx:(1 0 0 1 0)\nm:(1 0 1 0)\np:(1 1 1 0 1)\nl:(1 1 1 0 0)\nf:(0 1 0 0)\no:(0 1 1 1)\nr:(1 1 1 1 1)\nu:(1 1 1 1 0)\nc:(0 1 1 0 0 1)\nd:(0 1 1 0 0 0)\ng:(0 1 1 0 1)\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 2\nfunction Get-HuffmanEncodingTable ( $String )\n    {\n    #  Create leaf nodes\n    $ID = 0\n    $Nodes = [char[]]$String |\n        Group-Object |\n        ForEach { $ID++; $_ } |\n        Select  @{ Label = 'Symbol'  ; Expression = { $_.Name  } },\n                @{ Label = 'Count'   ; Expression = { $_.Count } },\n                @{ Label = 'ID'      ; Expression = { $ID      } },\n                @{ Label = 'Parent'  ; Expression = { 0        } },\n                @{ Label = 'Code'    ; Expression = { ''       } }\n \n    #  Grow stems under leafs\n    ForEach ( $Branch in 2..($Nodes.Count) )\n        {\n        #  Get the two nodes with the lowest count\n        $LowNodes = $Nodes | Where Parent -eq 0 | Sort Count | Select -First 2\n \n        #  Create a new stem node\n        $ID++\n        $Nodes += '' |\n            Select  @{ Label = 'Symbol'  ; Expression = { ''       } },\n                    @{ Label = 'Count'   ; Expression = { $LowNodes[0].Count + $LowNodes[1].Count } },\n                    @{ Label = 'ID'      ; Expression = { $ID      } },\n                    @{ Label = 'Parent'  ; Expression = { 0        } },\n                    @{ Label = 'Code'    ; Expression = { ''       } }\n \n        #  Put the two nodes in the new stem node\n        $LowNodes[0].Parent = $ID\n        $LowNodes[1].Parent = $ID\n \n        #  Assign 0 and 1 to the left and right nodes\n        $LowNodes[0].Code = '0'\n        $LowNodes[1].Code = '1'\n        }\n   \n    #  Assign coding to nodes\n    ForEach ( $Node in $Nodes[($Nodes.Count-2)..0] )\n        {\n        $Node.Code = ( $Nodes | Where ID -eq $Node.Parent ).Code + $Node.Code\n        }\n \n    $EncodingTable = $Nodes | Where { $_.Symbol } | Select Symbol, Code | Sort Symbol\n    return $EncodingTable\n    }\n \n#  Get table for given string\n$String = \"this is an example for huffman encoding\"\n$HuffmanEncodingTable = Get-HuffmanEncodingTable $String\n \n#  Display table\n$HuffmanEncodingTable | Format-Table -AutoSize\n \n#  Encode string\n$EncodedString = $String\nForEach ( $Node in $HuffmanEncodingTable )\n    {\n    $EncodedString = $EncodedString.Replace( $Node.Symbol, $Node.Code )\n    }\n$EncodedString\n\n\nOutput:\nSymbol Code \n------ ---- \n       101  \na      1100 \nc      01011\nd      01100\ne      1101 \nf      1110 \ng      01110\nh      11111\ni      1001 \nl      11110\nm      0011 \nn      000  \no      0100 \np      10001\nr      01111\ns      0010 \nt      01010\nu      01101\nx      10000\n\n\n0101011111100100101011001001010111000001011101100001100001110001111101101101111001000111110111111011011110111000111100000101110100001011010001100100100001110\n\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "F#", "code": "\nTranslation of: OCaml\ntype 'a HuffmanTree =\n    | Leaf of int * 'a\n    | Node of int * 'a HuffmanTree * 'a HuffmanTree\n \nlet freq = function Leaf (f, _) | Node (f, _, _) -> f\nlet freqCompare a b = compare (freq a) (freq b)\n \nlet buildTree charFreqs =\n    let leaves = List.map (fun (c,f) -> Leaf (f,c)) charFreqs\n    let freqSort = List.sortWith freqCompare\n    let rec aux = function\n        | [] -> failwith \"empty list\"\n        | [a] -> a\n        | a::b::tl ->\n            let node = Node(freq a + freq b, a, b)\n            aux (freqSort(node::tl))\n    aux (freqSort leaves)\n \nlet rec printTree = function\n  | code, Leaf (f, c) ->\n      printfn \"%c\\t%d\\t%s\" c f (String.concat \"\" (List.rev code));\n  | code, Node (_, l, r) ->\n      printTree (\"0\"::code, l);\n      printTree (\"1\"::code, r)\n \nlet () =\n  let str = \"this is an example for huffman encoding\"\n  let charFreqs =\n    str |> Seq.groupBy id\n        |> Seq.map (fun (c, vals) -> (c, Seq.length vals))\n        |> Map.ofSeq\n         \n  let tree = charFreqs |> Map.toList |> buildTree\n  printfn \"Symbol\\tWeight\\tHuffman code\";\n  printTree ([], tree)\n\n\nOutput:\nSymbol\tWeight\tHuffman code\np\t1\t00000\nr\t1\t00001\ng\t1\t00010\nl\t1\t00011\nn\t4\t001\nm\t2\t0100\no\t2\t0101\nc\t1\t01100\nd\t1\t01101\nh\t2\t0111\ns\t2\t1000\nx\t1\t10010\nt\t1\t100110\nu\t1\t100111\nf\t3\t1010\ni\t3\t1011\na\t3\t1100\ne\t3\t1101\n \t6\t111\n", "explain": ""}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Groovy", "code": "\n\nimport groovy.transform.*\n\n@Canonical\n@Sortable(includes = ['freq', 'letter'])\nclass Node {\n    String letter\n    int freq\n    Node left\n    Node right\n    boolean isLeaf() { left == null && right == null }    \n}\n\nMap correspondance(Node n, Map corresp = [:], String prefix = '') {\n    if (n.isLeaf()) {\n        corresp[n.letter] = prefix ?: '0'\n    } else {\n        correspondance(n.left,  corresp, prefix + '0')\n        correspondance(n.right, corresp, prefix + '1')\n    }\n    return corresp\n}\n\nMap huffmanCode(String message) {\n    def queue = message.toList().countBy { it } // char frequencies\n        .collect { String letter, int freq ->   // transformed into tree nodes\n            new Node(letter, freq) \n        } as TreeSet // put in a queue that maintains ordering\n    \n    while(queue.size() > 1) {\n        def (nodeLeft, nodeRight)  = [queue.pollFirst(), queue.pollFirst()]\n        \n        queue << new Node(\n            freq:   nodeLeft.freq   + nodeRight.freq,\n            letter: nodeLeft.letter + nodeRight.letter,\n            left: nodeLeft, right: nodeRight\n        )\n    }\n    \n    return correspondance(queue.pollFirst())\n}\n\nString encode(CharSequence msg, Map codeTable) {\n    msg.collect { codeTable[it] }.join()\n}\n\nString decode(String codedMsg, Map codeTable, String decoded = '') {\n    def pair = codeTable.find { k, v -> codedMsg.startsWith(v) }\n    pair ? pair.key + decode(codedMsg.substring(pair.value.size()), codeTable)\n         : decoded   \n}\n\n\ndef message = \"this is an example for huffman encoding\"\n\ndef codeTable = huffmanCode(message)\ncodeTable.each { k, v -> println \"$k: $v\" }\n\ndef encoded = encode(message, codeTable)\nprintln encoded\n\ndef decoded = decode(encoded, codeTable)\nprintln decoded\n\n\nOutput:\ng: 00000\nl: 00001\nh: 0001\nm: 0010\no: 0011\nn: 010\np: 01100\nr: 01101\ns: 0111\nt: 10000\nu: 10001\na: 1001\n\u00a0: 101\ne: 1100\nf: 1101\ni: 1110\nx: 11110\nc: 111110\nd: 111111\n1000000011110011110111100111101100101010111001111010010010011000000111001011101001101101101000110001110111010010100101010111000101111100011111111111001000000\nthis is an example for huffman encoding\n\n\n", "explain": "Implemented and tested with Groovy 2.3.\nUsage:\n"}, {"task_name": "Huffman coding", "task_url": "https://rosettacode.org/wiki/Huffman_coding", "task_cat": "Compression", "lang": "Zig", "code": "\nTranslation of: Rust\nconst std = @import(\"std\");\n\nconst Node = struct {\n    frequency: usize,\n    kind: union(enum) {\n        internal: struct {\n            left: *Node,\n            right: *Node,\n        },\n        leaf: u8,\n    },\n\n    fn initLeaf(frequency: usize, ch: u8) Node {\n        return .{\n            .frequency = frequency,\n            .kind = .{ .leaf = ch },\n        };\n    }\n\n    fn initInternal(\n        allocator: std.mem.Allocator,\n        left_child: Node,\n        right_child: Node,\n    ) !Node {\n        const left = try allocator.create(Node);\n        const right = try allocator.create(Node);\n        left.* = left_child;\n        right.* = right_child;\n        return .{\n            .frequency = left_child.frequency + right_child.frequency,\n            .kind = .{ .internal = .{ .left = left, .right = right } },\n        };\n    }\n\n    fn deinit(self: Node, allocator: std.mem.Allocator) void {\n        switch (self.kind) {\n            .internal => |inner| {\n                inner.left.deinit(allocator);\n                inner.right.deinit(allocator);\n                allocator.destroy(inner.left);\n                allocator.destroy(inner.right);\n            },\n            .leaf => {},\n        }\n    }\n\n    fn compare(context: void, a: Node, b: Node) std.math.Order {\n        _ = context;\n        return std.math.order(a.frequency, b.frequency);\n    }\n};\n\npub fn main() !void {\n    const text = \"this is an example for huffman encoding\";\n\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer std.debug.assert(gpa.deinit() == .ok);\n\n    const allocator = gpa.allocator();\n    var frequencies = std.AutoHashMap(u8, usize).init(allocator);\n    defer frequencies.deinit();\n\n    for (text) |ch| {\n        const gop = try frequencies.getOrPut(ch);\n        if (gop.found_existing) {\n            gop.value_ptr.* += 1;\n        } else {\n            gop.value_ptr.* = 1;\n        }\n    }\n\n    var prioritized_frequencies =\n        std.PriorityQueue(Node, void, Node.compare).init(allocator, {});\n    defer prioritized_frequencies.deinit();\n\n    var freq_it = frequencies.iterator();\n    while (freq_it.next()) |counted_char| {\n        try prioritized_frequencies.add(Node.initLeaf(\n            counted_char.value_ptr.*,\n            counted_char.key_ptr.*,\n        ));\n    }\n\n    while (prioritized_frequencies.len > 1) {\n        try prioritized_frequencies.add(try Node.initInternal(\n            allocator,\n            prioritized_frequencies.remove(),\n            prioritized_frequencies.remove(),\n        ));\n    }\n\n    const root = prioritized_frequencies.items[0];\n    defer root.deinit(allocator);\n\n    var codes = std.AutoArrayHashMap(u8, []const u8).init(allocator);\n    defer codes.deinit();\n\n    var arena = std.heap.ArenaAllocator.init(allocator);\n    defer arena.deinit();\n\n    try generateCodes(arena.allocator(), &root, &.{}, &codes);\n\n    const stdout = std.io.getStdOut().writer();\n    var code_it = codes.iterator();\n    while (code_it.next()) |item| {\n        try stdout.print(\"{c}: {s}\\n\", .{\n            item.key_ptr.*,\n            item.value_ptr.*,\n        });\n    }\n}\n\nfn generateCodes(\n    arena: std.mem.Allocator,\n    node: *const Node,\n    prefix: []const u8,\n    out_codes: *std.AutoArrayHashMap(u8, []const u8),\n) !void {\n    switch (node.kind) {\n        .internal => |inner| {\n            const left_prefix = try arena.alloc(u8, prefix.len + 1);\n            std.mem.copy(u8, left_prefix, prefix);\n            left_prefix[prefix.len] = '0';\n            try generateCodes(arena, inner.left, left_prefix, out_codes);\n\n            const right_prefix = try arena.alloc(u8, prefix.len + 1);\n            std.mem.copy(u8, right_prefix, prefix);\n            right_prefix[prefix.len] = '1';\n            try generateCodes(arena, inner.right, right_prefix, out_codes);\n        },\n        .leaf => |ch| {\n            try out_codes.put(ch, prefix);\n        },\n    }\n}\n\n\nOutput:\nn: 000\nm: 0010\nd: 00110\nt: 00111\no: 0100\nh: 0101\nx: 01100\nr: 01101\nc: 01110\nu: 01111\ns: 1000\ng: 10010\np: 100110\nl: 100111\na: 1010\ni: 1011\n\u00a0: 110\ne: 1110\nf: 1111\n\n", "explain": ""}]