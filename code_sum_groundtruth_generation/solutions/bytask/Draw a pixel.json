[{"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Python", "code": "\nWorks with: Python  version 2.7.14\nLibrary: PIL\nfrom PIL import Image\n\nimg = Image.new('RGB', (320, 240))\npixels = img.load()\npixels[100,100] = (255,0,0)\nimg.show()\n\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "C", "code": "\n\n#include<graphics.h>\n\nint main()\n{\n\tinitwindow(320,240,\"Red Pixel\");\n\t\n\tputpixel(100,100,RED);\n\t\n\tgetch();\n\t\n\treturn 0;\n}\n\n", "explain": "Requires the WinBGIm library.\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Java", "code": "\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport javax.swing.JFrame;\n\npublic class DrawAPixel extends JFrame{\n\tpublic DrawAPixel() {\n\t\tsuper(\"Red Pixel\");\n\t\tsetSize(320, 240);\n\t\tsetDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\tsetVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics g) {\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}\n\n\nimport java.awt.Color;\nimport java.awt.Graphics;\nimport java.awt.image.BufferedImage;\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class DrawAPixel extends JPanel{\t\n\tprivate BufferedImage puffer;\n\tprivate JFrame window;\n\tprivate Graphics g;\n\tpublic DrawAPixel() {\n\t\twindow = new JFrame(\"Red Pixel\");\n\t\twindow.setSize(320, 240);\n\t\twindow.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n\t\twindow.setLayout(null);\n\t\tsetBounds(0, 0, 320, 240);\n\t\twindow.add(this);\n\t\twindow.setVisible(true);\n\t}\n\t@Override\n\tpublic void paint(Graphics gr) {\n\t\tif(g == null) {\n\t\t\tpuffer = (BufferedImage) createImage(getWidth(), getHeight());\n\t\t\tg = puffer.getGraphics();\n\t\t}\n\t\tg.setColor(new Color(255, 0, 0));\n\t\tg.drawRect(100, 100, 1, 1);\n\t\tgr.drawImage(puffer, 0, 0, this);\n\t}\n\tpublic static void main(String[] args) {\n\t\tnew DrawAPixel();\n\t}\n}\n\n", "explain": "Basic Implementation via subclass of JFrame:\nAdvanced Implementation via subclass of JPanel (more powerful especially while repainting):\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/draw\"\n)\n\nfunc main() {\n    rect := image.Rect(0, 0, 320, 240)\n    img := image.NewRGBA(rect)\n\n    // Use green background, say.\n    green := color.RGBA{0, 255, 0, 255}\n    draw.Draw(img, rect, &image.Uniform{green}, image.ZP, draw.Src)\n\n    // Set color of pixel at (100, 100) to red\n    red := color.RGBA{255, 0, 0, 255}\n    img.Set(100, 100, red)\n\n    // Check it worked.\n    cmap := map[color.Color]string{green: \"green\", red: \"red\"}\n    c1 := img.At(0, 0)\n    c2 := img.At(100, 100)\n    fmt.Println(\"The color of the pixel at (  0,   0) is\", cmap[c1], \"\\b.\")\n    fmt.Println(\"The color of the pixel at (100, 100) is\", cmap[c2], \"\\b.\")\n}\n\n\nOutput:\nThe color of the pixel at (  0,   0) is green.\nThe color of the pixel at (100, 100) is red.\n\n\npackage main\n\nimport (\n\t\"image\"\n\t\"image/color\"\n\t\"image/draw\"\n\t\"image/png\"\n\t\"os\"\n)\n\nfunc main() {\n\t// Create a 320 x 240 image\n\timg := image.NewRGBA(image.Rect(0, 0, 320, 240))\n\t// fill img in white\n\tdraw.Draw(img, img.Bounds(), &image.Uniform{color.RGBA{0, 0, 0, 0}}, image.ZP, draw.Src)\n\t// Draw a red dot at (100, 100)\n\timg.Set(100, 100, color.RGBA{255, 0, 0, 255})\n\t// Save to new.png\n\tw, _ := os.OpenFile(\"new.png\", os.O_WRONLY|os.O_CREATE, 0600)\n\tdefer w.Close()\n\tpng.Encode(w, img)\n}\n\n\npackage main\n// first run\" go get github.com/zserge/webview\" \n// simple GUI \"window\"\nimport \"github.com/zserge/webview\"\n\nfunc main() {\n\t// Open wikipedia in a 320*240 resizable window\n\twebview.Open(\"Minimal webview example\",\n\t\t\"https://en.m.wikipedia.org/wiki/Main_Page\", 320, 240, true)\n}\n\n", "explain": "Create a PNG image?\nGUI \"window\" rather than an image?\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program dpixel.s        */\n\n/* compile with as         */\n/* link with gcc and options -lX11 -L/usr/lpp/X11/lib   */\n\n/********************************************/\n/*Constantes                                */\n/********************************************/\n.equ STDOUT,              1     @ Linux output console\n.equ EXIT,                1     @ Linux syscall\n.equ WRITE,               4     @ Linux syscall\n/* constantes X11 */\n.equ KeyPressed,          2\n.equ ButtonPress,         4\n.equ MotionNotify,        6\n.equ EnterNotify,         7\n.equ LeaveNotify,         8\n.equ Expose,              12\n.equ ClientMessage,       33\n.equ KeyPressMask,        1\n.equ ButtonPressMask,     4\n.equ ButtonReleaseMask,   8\n.equ ExposureMask,        1<<15\n.equ StructureNotifyMask, 1<<17\n.equ EnterWindowMask,     1<<4\n.equ LeaveWindowMask,     1<<5 \n.equ ConfigureNotify,     22\n\n\n/*******************************************/\n/* DONNEES INITIALISEES                    */\n/*******************************************/ \n.data\nszWindowName:            .asciz \"Windows Raspberry\"\nszRetourligne:           .asciz  \"\\n\"\nszMessDebutPgm:          .asciz \"Program start. \\n\"\nszMessErreur:            .asciz \"Server X not found.\\n\"\nszMessErrfen:            .asciz \"Can not create window.\\n\"\nszMessErreurX11:         .asciz \"Error call function X11. \\n\"\nszMessErrGc:             .asciz \"Can not create graphics context.\\n\"\nszTitreFenRed:           .asciz \"Pi\"    \nszTexte1:                .asciz \"<- red pixel is here\u00a0!!\"\n.equ LGTEXTE1, . - szTexte1\nszTexte2:                .asciz \"Press q for close window or clic X in system menu.\"\n.equ LGTEXTE2, . - szTexte2\nszLibDW: .asciz \"WM_DELETE_WINDOW\"    @ special label for correct close error\n\n/*************************************************/\nszMessErr: .ascii\t\"Error code hexa\u00a0: \"\nsHexa: .space 9,' '\n         .ascii \"  decimal\u00a0:  \"\nsDeci: .space 15,' '\n         .asciz \"\\n\"\n\n/*******************************************/\n/* DONNEES NON INITIALISEES                    */\n/*******************************************/ \n.bss\n.align 4\nptDisplay:          .skip 4      @ pointer display\nptEcranDef:         .skip 4      @ pointer screen default\nptFenetre:          .skip 4      @ pointer window\nptGC:               .skip 4      @ pointer graphic context\nptGC1:              .skip 4      @ pointer graphic context1\nkey:                .skip 4      @ key code\nwmDeleteMessage:    .skip 8      @ ident close message\nevent:              .skip 400    @ TODO event size\u00a0??\nPrpNomFenetre:      .skip 100    @ window name proprety\nbuffer:             .skip 500 \niWhite:             .skip 4      @ rgb code for white pixel\niBlack:             .skip 4      @ rgb code for black pixel\n/**********************************************/\n/* -- Code section                            */\n/**********************************************/\n.text\n.global main\n\nmain:                               @ entry of program \n    ldr r0,iAdrszMessDebutPgm   @\n    bl affichageMess            @ display start message on console linux\n    /* attention r6  pointer display*/\n    /* attention r8  pointer graphic context   */\n    /* attention r9 ident window  */\n    /*****************************/\n    /*    OPEN SERVER X11        */\n    /*****************************/\n    mov r0,#0\n    bl XOpenDisplay             @ open X server\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurServeur\n    ldr r1,iAdrptDisplay\n    str r0,[r1]                 @ store display address \n    mov r6,r0                   @ and in register r6\n    ldr r2,[r0,#+132]           @ load default_screen\n    ldr r1,iAdrptEcranDef\n    str r2,[r1]                 @ store default_screen\n    mov r2,r0\n    ldr r0,[r2,#+140]           @ load pointer screen list\n    ldr r5,[r0,#+52]            @ load value white pixel\n    ldr r4,iAdrWhite            @ and store in memory\n    str r5,[r4]\n    ldr r3,[r0,#+56]            @ load value black pixel\n    ldr r4,iAdrBlack            @ and store in memory\n    str r3,[r4]\n    ldr r4,[r0,#+28]            @ load bits par pixel\n    ldr r1,[r0,#+8]             @ load root windows\n    /**************************/\n    /* CREATE WINDOW          */\n    /**************************/\n    mov r0,r6                   @ address display\n    mov r2,#0                   @ window position X\n    mov r3,#0                   @ window position Y\n    mov r8,#0                   @ for stack alignement\n    push {r8}\n    push {r3}                   @  background  = black pixel\n    push {r5}                   @  border = white pixel\n    mov r8,#2                   @  border size\n    push {r8}\n    mov r8,#240                 @ hauteur\n    push {r8}\n    mov r8,#320                 @ largeur \n    push {r8}   \n    bl XCreateSimpleWindow\n    add sp,#24                  @ stack alignement  6 push (4 bytes * 6)\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurF\n\n    ldr r1,iAdrptFenetre\n    str r0,[r1]                 @ store window address in memory\n    mov r9,r0                   @ and in register r9\n    /*****************************/\n    /* add window property       */\n    /*****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iAdrszWindowName     @ window name\n    ldr r3,iAdrszTitreFenRed    @ window name reduced\n    mov r4,#0\n    push {r4}                   @ parameters not use\n    push {r4}\n    push {r4}\n    push {r4}\n    bl XSetStandardProperties\n    add sp,sp,#16               @ stack alignement for 4 push\n    /**************************************/\n    /* for correction window close error  */\n    /**************************************/\n    mov r0,r6                   @ display address\n    ldr r1,iAdrszLibDW          @ atom address\n    mov r2,#1                   @ False  cr\u00e9ate atom if not exists\n    bl XInternAtom\n    cmp r0,#0                   @ error X11\u00a0?\n    ble erreurX11\n    ldr r1,iAdrwmDeleteMessage  @ recept address\n    str r0,[r1]\n    mov r2,r1                   @ return address\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r3,#1                   @ number of protocols\n    bl XSetWMProtocols\n    cmp r0,#0                   @ error X11\u00a0?\n    ble erreurX11\n    /**********************************/\n    /*  create graphic context        */\n    /**********************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r2,#0                   @ not use for simply context\n    mov r3,#0\n    bl XCreateGC\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurGC\n    ldr r1,iAdrptGC\n    str r0,[r1]                 @ store address graphic context\n    mov r8,r0                   @ and in r8\n    @ create other GC\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r2,#0                   @ not use for simply context\n    mov r3,#0\n    bl XCreateGC\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurGC\n    ldr r1,iAdrptGC1\n    str r0,[r1]                 @ store address graphic context 1\n    mov r1,r0\n    mov r0,r6\n    mov r2,#0xFF0000            @ color red\n    bl XSetForeground\n    cmp r0,#0\n    beq erreurGC\n    /****************************/\n    /* modif window background  */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iGris1               @ background color\n    bl XSetWindowBackground   \n    cmp r0,#0                   @ error\u00a0?\n    ble erreurX11\n    /***************************/\n    /* OUF!! window display    */\n    /***************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    bl XMapWindow\n    /****************************/\n    /* Write text1 in the window */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r2,r8                   @ address graphic context\n    mov r3,#105                 @ position x \n    sub sp,#4                   @ stack alignement\n    mov r4,#LGTEXTE1  - 1       @ size string \n    push {r4}                   @ on the stack\n    ldr r4,iAdrszTexte1         @ string address\n    push {r4}\n    mov r4,#105                 @ position y \n    push {r4}\n    bl XDrawString\n    add sp,sp,#16               @ stack alignement 3 push and 1 stack alignement\n    cmp r0,#0                   @ error\u00a0?\n    blt erreurX11\n    /****************************/\n    /* Write text2 in the window */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r2,r8                   @ address graphic context\n    mov r3,#10                  @ position x \n    sub sp,#4                   @ stack alignement\n    mov r4,#LGTEXTE2  - 1       @ size string \n    push {r4}                   @ on the stack\n    ldr r4,iAdrszTexte2         @ string address\n    push {r4}\n    mov r4,#200                 @ position y \n    push {r4}\n    bl XDrawString\n    add sp,sp,#16               @ stack alignement 3 push and 1 stack alignement\n    cmp r0,#0                   @ error\u00a0?\n    blt erreurX11\n    /****************************************/\n    /* draw pixel                           */\n    /****************************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iAdrptGC1\n    ldr r2,[r2]                 @  address graphic context 1\n    mov r3,#100                 @ position x\n    sub sp,sp,#4                @ stack alignement\n    mov r4,#100                 @ position y\n    push {r4}                   @ on the stack\n    bl XDrawPoint\n    add sp,sp,#8                @ stack alignement 1 push and 1 stack alignement\n\n    cmp r0,#0                   @ error\u00a0?\n    blt erreurX11\n    /****************************/\n    /* Autorisations            */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iFenetreMask         @ autorisation mask\n    bl XSelectInput\n    cmp r0,#0                   @ error\u00a0?\n    ble erreurX11\n    /****************************/\n    /* Events loop              */\n    /****************************/\n1:\n    mov r0,r6                   @ display address\n    ldr r1,iAdrevent            @ events address\n    bl XNextEvent               @ event\u00a0?\n    ldr r0,iAdrevent\n    ldr r0,[r0]                 @ code event\n    cmp r0,#KeyPressed          @ key\u00a0?\n    bne 2f\n    ldr r0,iAdrevent            @ yes read key in buffer\n    ldr r1,iAdrbuffer\n    mov r2,#255\n    ldr r3,iAdrkey\n    mov r4,#0\n    push {r4}                   @ stack alignement\n    push {r4}\n    bl XLookupString \n    add sp,#8                   @ stack alignement 2 push\n    cmp r0,#1                   @ is character key\u00a0?\n    bne 2f\n    ldr r0,iAdrbuffer           @ yes -> load first buffer character\n    ldrb r0,[r0]\n    cmp r0,#0x71                @ character q for quit\n    beq 5f                      @ yes -> end\n    b 4f\n2:\n    /*                                  */\n    /* for example  clic mouse button   */\n    /************************************/\n    cmp r0,#ButtonPress         @ clic mouse buton\n    bne 3f\n    ldr r0,iAdrevent\n    ldr r1,[r0,#+32]            @ position X mouse clic\n    ldr r2,[r0,#+36]            @ position Y\n    @ etc for eventuel use\n    b 4f\n3:\n    cmp r0,#ClientMessage       @ code for close window within error\n    bne 4f\n    ldr r0,iAdrevent\n    ldr r1,[r0,#+28]            @ code message address \n    ldr r2,iAdrwmDeleteMessage  @ equal code window cr\u00e9ate\u00a0???\n    ldr r2,[r2]\n    cmp r1,r2\n    beq 5f                      @ yes -> end window \n\n4:  @ loop for other event\n    b 1b\n    /***********************************/\n    /* Close window -> free ressources */\n    /***********************************/\n5:\n    mov r0,r6                  @ display address\n    ldr r1,iAdrptGC\n    ldr r1,[r1]                @ load context graphic address \n    bl XFreeGC\n    cmp r0,#0\n    blt erreurX11\n    mov r0,r6                  @ display address \n    mov r1,r9                  @ window address\n    bl XDestroyWindow\n    cmp r0,#0\n    blt erreurX11\n    mov r0,r6                  @ display address\n    bl XCloseDisplay\n    cmp r0,#0\n    blt erreurX11\n    mov r0,#0                  @ return code OK\n    b 100f\nerreurF:   @ create error window but possible not necessary. Display error by server\n    ldr r1,iAdrszMessErrfen\n    bl   displayError\n    mov r0,#1                  @ return error code\n    b 100f\nerreurGC:                      @ error create graphic context\n    ldr r1,iAdrszMessErrGc\n    bl   displayError\n    mov r0,#1\n    b 100f\nerreurX11:    @ erreur X11\n    ldr r1,iAdrszMessErreurX11\n    bl   displayError\n    mov r0,#1\n    b 100f\nerreurServeur:                 @ error no found X11 server see doc putty and Xming\n    ldr r1,iAdrszMessErreur\n    bl   displayError\n    mov r0,#1\n    b 100f\n\n100:                           @ standard end of the program \n    mov r7, #EXIT\n    svc 0 \niFenetreMask:        .int  KeyPressMask|ButtonPressMask|StructureNotifyMask\niGris1:              .int 0xFFA0A0A0\niAdrWhite:           .int iWhite\niAdrBlack:           .int iBlack\niAdrptDisplay:       .int ptDisplay\niAdrptEcranDef:      .int ptEcranDef\niAdrptFenetre:       .int ptFenetre\niAdrptGC:            .int ptGC\niAdrptGC1:           .int ptGC1\niAdrevent:           .int event\niAdrbuffer:          .int buffer\niAdrkey:             .int key\niAdrszLibDW:         .int szLibDW\niAdrszMessDebutPgm:  .int szMessDebutPgm\niAdrszMessErreurX11: .int szMessErreurX11\niAdrszMessErrGc:     .int szMessErrGc\niAdrszMessErreur:    .int szMessErreur\niAdrszMessErrfen:    .int szMessErrfen\niAdrszWindowName:    .int szWindowName\niAdrszTitreFenRed:   .int szTitreFenRed\niAdrszTexte1:            .int szTexte1\niAdrszTexte2:        .int szTexte2\niAdrPrpNomFenetre:   .int PrpNomFenetre\niAdrwmDeleteMessage: .int wmDeleteMessage\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                   @ save  registres\n    mov r2,#0                               @ counter length \n1:                                          @ loop length calculation \n    ldrb r1,[r0,r2]                         @ read octet start position + index \n    cmp r1,#0                               @ if 0 its over \n    addne r2,r2,#1                          @ else add 1 in the length \n    bne 1b                                  @ and loop \n                                            @ so here r2 contains the length of the message \n    mov r1,r0                               @ address message in r1 \n    mov r0,#STDOUT                          @ code to write to the standard output Linux \n    mov r7, #WRITE                          @ code call system \"write\" \n    svc #0                                  @ call systeme \n    pop {r0,r1,r2,r7,lr}                    @ restaur registers\n    bx lr                                   @ return\n/***************************************************/\n/*   display error message                         */\n/***************************************************/\n/* r0 contains error code  r1\u00a0: message address */\ndisplayError:\n    push {r0-r2,lr}                         @ save registers\n    mov r2,r0                               @ save error code\n    mov r0,r1\n    bl affichageMess\n    mov r0,r2                               @ error code\n    ldr r1,iAdrsHexa\n    bl conversion16                         @ conversion hexa\n    mov r0,r2                               @ error code\n    ldr r1,iAdrsDeci                        @ result address\n    bl conversion10                         @ conversion decimale\n    ldr r0,iAdrszMessErr                    @ display error message\n    bl affichageMess\n100:\n    pop {r0-r2,lr}                          @ restaur registers\n    bx lr                                   @ return \niAdrszMessErr:                 .int szMessErr\niAdrsHexa:                     .int sHexa\niAdrsDeci:                     .int sDeci\n/******************************************************************/\n/*     Converting a register to hexadecimal                      */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\nconversion16:\n    push {r1-r4,lr}                                    @ save registers\n    mov r2,#28                                         @ start bit position\n    mov r4,#0xF0000000                                 @ mask\n    mov r3,r0                                          @ save entry value\n1:                                                     @ start loop\n    and r0,r3,r4                                       @value register and mask\n    lsr r0,r2                                          @ move right \n    cmp r0,#10                                         @ compare value\n    addlt r0,#48                                       @ <10  ->digit\t\n    addge r0,#55                                       @ >10  ->letter A-F\n    strb r0,[r1],#1                                    @ store digit on area and + 1 in area address\n    lsr r4,#4                                          @ shift mask 4 positions\n    subs r2,#4                                         @  counter bits - 4 <= zero \u00a0?\n    bge 1b                                             @  no -> loop\n\n100:\n    pop {r1-r4,lr}                                     @ restaur registers \n    bx lr                                              @return\n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n1:                                                  @ start loop\n    bl divisionpar10U                               @ unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b                                          @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n \n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient    */\n/* r1 remainder   */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n/***************************************************/\n/* integer division unsigned                       */\n/***************************************************/\ndivision:\n    /* r0 contains dividend */\n    /* r1 contains divisor */\n    /* r2 returns quotient */\n    /* r3 returns remainder */\n    push {r4, lr}\n    mov r2, #0                                         @ init quotient\n    mov r3, #0                                         @ init remainder\n    mov r4, #32                                        @ init counter bits\n    b 2f\n1:                                                    @ loop \n    movs r0, r0, LSL #1                               @ r0 <- r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1)\n    adc r3, r3, r3                                     @ r3 <- r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C \n    cmp r3, r1                                         @ compute r3 - r1 and update cpsr \n    subhs r3, r3, r1                                  @ if r3 >= r1 (C=1) then r3 <- r3 - r1 \n    adc r2, r2, r2                                     @ r2 <- r2 + r2 + C. This is equivalent to r2 <- (r2 << 1) + C \n2:\n    subs r4, r4, #1                                   @ r4 <- r4 - 1 \n    bpl 1b                                            @ if r4 >= 0 (N=0) then loop\n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "X86_Assembly", "code": "\n\n        .model  tiny\n        .code\n        org     100h\n\nstart:  mov     ax, 0013h       ;set 320x200x8 graphic screen\n        int     10h\n        push    0A000h          ;point to graphic memory segment\n        pop     es\n        mov     byte ptr es:[320*100+100], 28h  ;draw bright red pixel\n\n        mov     ah, 0           ;wait for keystroke\n        int     16h\n        mov     ax, 0003h       ;restore normal text mode screen\n        int     10h\n        ret                     ;return to OS\n        end     start\n", "explain": "This doesn't quite meet the requirements, but it shows how little code is\nneeded to draw a pixel on an IBM-PC VGA screen. The executable program\nis a mere 32 bytes long. The \"window\" in this case is 320x200. Palette\nregister 28 hex is set to bright red by the BIOS at boot-up time. About\nhalf the code is used to wait for a keystroke before returning to the OS,\nso the pixel can be seen. Borland's tasm and tlink /t were used to\ncreate an executable .com file.\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Delphi", "code": "\nLibrary:  Windows\nLibrary:  Messages\nLibrary:  SysUtils\n\nprogram Draw_a_pixel;\n\n{$APPTYPE CONSOLE}\n\n{$R *.res}\n\nuses\n  Windows,\n  Messages,\n  SysUtils;\n\nvar\n  Msg: TMSG;\n  LWndClass: TWndClass;\n  hMainHandle: HWND;\n\nprocedure Paint(Handle: hWnd); forward;\n\nprocedure ReleaseResources;\nbegin\n  PostQuitMessage(0);\nend;\n\nfunction WindowProc(hWnd, Msg: Longint; wParam: wParam; lParam: lParam): Longint; stdcall;\nbegin\n  case Msg of\n    WM_PAINT:\n      Paint(hWnd);\n    WM_DESTROY:\n      ReleaseResources;\n  end;\n  Result := DefWindowProc(hWnd, Msg, wParam, lParam);\nend;\n\n\nprocedure CreateWin(W, H: Integer);\nbegin\n  LWndClass.hInstance := hInstance;\n  with LWndClass do\n  begin\n    lpszClassName := 'OneRedPixel';\n    Style := CS_PARENTDC or CS_BYTEALIGNCLIENT;\n    hIcon := LoadIcon(hInstance, 'MAINICON');\n    lpfnWndProc := @WindowProc;\n    hbrBackground := COLOR_BTNFACE + 1;\n    hCursor := LoadCursor(0, IDC_ARROW);\n  end;\n\n  RegisterClass(LWndClass);\n  hMainHandle := CreateWindow(LWndClass.lpszClassName,\n    'Draw a red pixel on (100,100)', WS_CAPTION or WS_MINIMIZEBOX or WS_SYSMENU\n    or WS_VISIBLE, ((GetSystemMetrics(SM_CXSCREEN) - W) div 2), ((GetSystemMetrics\n    (SM_CYSCREEN) - H) div 2), W, H, 0, 0, hInstance, nil);\nend;\n\nprocedure ShowModal;\nbegin\n  while GetMessage(Msg, 0, 0, 0) do\n  begin\n    TranslateMessage(Msg);\n    DispatchMessage(Msg);\n  end;\nend;\n\nprocedure Paint(Handle: hWnd);\nvar\n  ps: PAINTSTRUCT;\n  Dc: HDC;\nbegin\n  Dc := BeginPaint(Handle, ps);\n\n  // Fill bg with white\n  FillRect(Dc, ps.rcPaint, CreateSolidBrush($FFFFFF));\n\n  // Do the magic\n  SetPixel(Dc, 100, 100, $FF);\n\n  EndPaint(Handle, ps);\nend;\n\nbegin\n  CreateWin(320, 240);\n  ShowModal();\nend.\n\n\nOutput:\n\n", "explain": "Console version using windows api, thanks for RRUZ ([1])\n[2]\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Ruby", "code": "\nWorks with: Ruby version 2.6.6\nLibrary: gtk3\nrequire 'gtk3'\n\nWidth, Height = 320, 240\nPosX, PosY = 100, 100\n\nwindow = Gtk::Window.new\nwindow.set_default_size(Width, Height)\nwindow.title = 'Draw a pixel'\n\nwindow.signal_connect(:draw) do |widget, context|\n  context.set_antialias(Cairo::Antialias::NONE)\n  # paint out bg with white\n  # context.set_source_rgb(1.0, 1.0, 1.0)\n  # context.paint(1.0)\n  # draw a rectangle\n  context.set_source_rgb(1.0, 0.0, 0.0)\n  context.fill do\n    context.rectangle(PosX, PosY, 1, 1)\n  end\nend\n\nwindow.signal_connect(:destroy) { Gtk.main_quit }\n\nwindow.show\nGtk.main\n\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Rust", "code": "\nLibrary: piston_window\nLibrary: image\n\nOutput Image: RustOut\n\nextern crate piston_window;\nextern crate image;\n\nuse piston_window::*;\n\nfn main() {\n    let (width, height) = (320, 240);\n    \n    let mut window: PistonWindow =\n        WindowSettings::new(\"Red Pixel\", [width, height])\n        .exit_on_esc(true).build().unwrap();\n\n    // Since we cant manipulate pixels directly, we need to manipulate the pixels on a canvas.\n    // Only issue is that sub-pixels exist (which is probably why the red pixel looks like a smear on the output image)\n    let mut canvas = image::ImageBuffer::new(width, height);\n    canvas.put_pixel(100, 100, image::Rgba([0xff, 0, 0, 0xff]));\n\n    // Transform into a texture so piston can use it.\n    let texture: G2dTexture = Texture::from_image(\n        &mut window.factory,\n        &canvas,\n        &TextureSettings::new()\n    ).unwrap();\n\n    // The window event loop.\n    while let Some(event) = window.next() {\n        window.draw_2d(&event, |context, graphics| {\n            clear([1.0; 4], graphics);\n            image(&texture,\n            context.transform,\n            graphics);\n        });\n    }\n}\n\n", "explain": "\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Ada", "code": "\nLibrary: SDLAda\nwith SDL.Video.Windows.Makers;\nwith SDL.Video.Renderers.Makers;\nwith SDL.Events.Events;\n\nprocedure Draw_A_Pixel is\n\n   Width   : constant := 320;\n   Height  : constant := 200;\n\n   Window   : SDL.Video.Windows.Window;\n   Renderer : SDL.Video.Renderers.Renderer;\n\n   procedure Wait is\n      use type SDL.Events.Event_Types;\n      Event : SDL.Events.Events.Events;\n   begin\n      loop\n         while SDL.Events.Events.Poll (Event) loop\n            if Event.Common.Event_Type = SDL.Events.Quit then\n               return;\n            end if;\n         end loop;\n         delay 0.100;\n      end loop;\n   end Wait;\n\nbegin\n   if not SDL.Initialise (Flags => SDL.Enable_Screen) then\n      return;\n   end if;\n\n   SDL.Video.Windows.Makers.Create (Win      => Window,\n                                    Title    => \"Draw a pixel\",\n                                    Position => SDL.Natural_Coordinates'(X => 10, Y => 10),\n                                    Size     => SDL.Positive_Sizes'(Width, Height),\n                                    Flags    => 0);\n   SDL.Video.Renderers.Makers.Create (Renderer, Window.Get_Surface);\n   Renderer.Set_Draw_Colour ((0, 0, 0, 255));\n   Renderer.Fill (Rectangle => (0, 0, Width, Height));\n   Renderer.Set_Draw_Colour ((255, 0, 0, 255));\n   Renderer.Draw (Point => (100, 100));\n   Window.Update_Surface;\n\n   Wait;\n   Window.Finalize;\n   SDL.Finalise;\nend Draw_A_Pixel;\n\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Julia", "code": "\nusing Gtk, Graphics\n \nconst can = @GtkCanvas()\nconst win = GtkWindow(can, \"Draw a Pixel\", 320, 240)\n\ndraw(can) do widget\n    ctx = getgc(can)\n    set_source_rgb(ctx, 255, 0, 0)\n    move_to(ctx, 100, 100)\n    line_to(ctx, 101,100)\n    stroke(ctx)\nend\n \nshow(can)\nconst cond = Condition()\nendit(w) = notify(cond)\nsignal_connect(endit, win, :destroy)\nwait(cond)\n\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Kotlin", "code": "\n\n// Version 1.2.41\n\nimport java.awt.Color\nimport java.awt.Graphics\nimport java.awt.image.BufferedImage\n\nclass BasicBitmapStorage(width: Int, height: Int) {\n    val image = BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    fun fill(c: Color) {\n        val g = image.graphics\n        g.color = c\n        g.fillRect(0, 0, image.width, image.height)\n    }\n\n    fun setPixel(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB())\n\n    fun getPixel(x: Int, y: Int) = Color(image.getRGB(x, y))\n}\n\nfun main(args: Array<String>) {\n    val bbs = BasicBitmapStorage(320, 240)\n    with (bbs) {\n        fill(Color.white) // say\n        setPixel(100, 100, Color.red)\n        // check it worked\n        val c = getPixel(100, 100)\n        print(\"The color of the pixel at (100, 100) is \")\n        println(if (c == Color.red) \"red\" else \"white\")\n    }\n}\n\n\nOutput:\nThe color of the pixel at (100, 100) is red\n\n", "explain": "This task seems very similar to the Bitmap task and so therefore is the code to accomplish it.\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Perl", "code": "\nLibrary: Gtk3\nuse Gtk3 '-init';\n\nmy $window = Gtk3::Window->new();\n$window->set_default_size(320, 240);\n$window->set_border_width(10);\n$window->set_title(\"Draw a Pixel\");\n$window->set_app_paintable(TRUE);\n\nmy $da = Gtk3::DrawingArea->new();\n$da->signal_connect('draw' => \\&draw_in_drawingarea);\n$window->add($da);\n$window->show_all();\n\nGtk3->main;\n\nsub draw_in_drawingarea\n{\n  my ($widget, $cr, $data) = @_;\n  $cr->set_source_rgb(1, 0, 0);\n  $cr->set_line_width(1);\n  $cr->rectangle( 100, 100, 1, 1);\n  $cr->stroke;\n}\n\n", "explain": ""}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Lua", "code": "\n\nlocal SDL = require \"SDL\"\n\nlocal ret = SDL.init { SDL.flags.Video }\nlocal window = SDL.createWindow {\n\ttitle\t= \"Pixel\",\n\theight\t= 320,\n\twidth\t= 240\n}\n\nlocal renderer = SDL.createRenderer(window, 0, 0)\n\nrenderer:clear()\nrenderer:setDrawColor(0xFF0000)\nrenderer:drawPoint({x = 100,y = 100})\nrenderer:present()\n\nSDL.delay(5000)\n\n", "explain": "The luasdl2 library is required.\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "Scala", "code": "\nScala idiom[edit]\n\n\nOutput:\n\nimport java.awt.image.BufferedImage\nimport java.awt.Color\nimport scala.language.reflectiveCalls\n\nobject RgbBitmap extends App {\n\n  class RgbBitmap(val dim: (Int, Int)) {\n    def width = dim._1\n    def height = dim._2\n\n    private val image = new BufferedImage(width, height, BufferedImage.TYPE_3BYTE_BGR)\n\n    def apply(x: Int, y: Int) = new Color(image.getRGB(x, y))\n\n    def update(x: Int, y: Int, c: Color) = image.setRGB(x, y, c.getRGB)\n\n    def fill(c: Color) = {\n      val g = image.getGraphics\n      g.setColor(c)\n      g.fillRect(0, 0, width, height)\n    }\n  }\n\n  object RgbBitmap {\n    def apply(width: Int, height: Int) = new RgbBitmap(width, height)\n  }\n\n  /** Even Javanese style testing is still possible.\n    */\n  private val img0 = new RgbBitmap(50, 60) { // Wrappers to enable adhoc Javanese style\n    def getPixel(x: Int, y: Int) = this(x, y)\n    def setPixel(x: Int, y: Int, c: Color) = this(x, y) = c\n  }\n\n  img0.fill(Color.CYAN)\n  img0.setPixel(5, 6, Color.BLUE)\n  // Testing in Java style\n  assert(img0.getPixel(0, 1) == Color.CYAN)\n  assert(img0.getPixel(5, 6) == Color.BLUE)\n  assert(img0.width == 50)\n  assert(img0.height == 60)\n  println(\"Tests successfully completed with no errors found.\")\n\n}\n\n", "explain": "A more Scalesque version could be with the use of its idiom:\nBest experienced in your browser with Scastie (remote JVM).\n"}, {"task_name": "Draw a pixel", "task_url": "https://rosettacode.org/wiki/Draw_a_pixel", "task_cat": "GUI", "lang": "F#", "code": "\n\nopen System.Windows.Forms\nopen System.Drawing\n\nlet f = new Form()\nf.Size <- new Size(320,240)\nf.Paint.Add(fun e -> e.Graphics.FillRectangle(Brushes.Red, 100, 100 ,1,1))\nApplication.Run(f)\n\n", "explain": "Uses Windows Forms\n"}]