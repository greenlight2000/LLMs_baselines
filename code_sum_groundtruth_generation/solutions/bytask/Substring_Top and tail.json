[{"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Python", "code": "\nprint \"knight\"[1:]     # strip first character\nprint \"socks\"[:-1]     # strip last character\nprint \"brooms\"[1:-1]   # strip both first and last characters\n\n\nfrom functools import (reduce)\n\n\ndef main():\n    for xs in transpose(\n        (chunksOf(3)(\n            ap([tail, init, compose(init)(tail)])(\n                ['knights', 'socks', 'brooms']\n            )\n        ))\n    ):\n        print(xs)\n\n\n# GENERIC -------------------------------------------------\n\n# tail\u00a0:: [a] -> [a]\ndef tail(xs):\n    return xs[1:]\n\n\n# init::[a] - > [a]\ndef init(xs):\n    return xs[:-1]\n\n\n# ap (<*>)\u00a0:: [(a -> b)] -> [a] -> [b]\ndef ap(fs):\n    return lambda xs: reduce(\n        lambda a, f: a + reduce(\n            lambda a, x: a + [f(x)], xs, []\n        ), fs, []\n    )\n\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    return lambda f: lambda x: g(f(x))\n\n\n# transpose\u00a0:: [[a]] -> [[a]]\ndef transpose(xs):\n    return list(map(list, zip(*xs)))\n\n\nif __name__ == '__main__':\n    main()\n\n\nOutput:\n['nights', 'knight', 'night']\n['ocks', 'sock', 'ock']\n['rooms', 'broom', 'room']\n", "explain": "\nOr, composing atomic functional expressions for these slices:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "C", "code": "\n#include <string.h>\n#include <stdlib.h>\n#include <stdio.h>\n\nint main( int argc, char ** argv ){\n  const char * str_a = \"knight\";\n  const char * str_b = \"socks\";\n  const char * str_c = \"brooms\";\n\n  char * new_a = malloc( strlen( str_a ) - 1 );\n  char * new_b = malloc( strlen( str_b ) - 1 );\n  char * new_c = malloc( strlen( str_c ) - 2 );\n\n  strcpy( new_a, str_a + 1 );\n  strncpy( new_b, str_b, strlen( str_b ) - 1 );\n  strncpy( new_c, str_c + 1, strlen( str_c ) - 2 );\n\n  printf( \"%s\\n%s\\n%s\\n\", new_a, new_b, new_c );\n\n  free( new_a );\n  free( new_b );\n  free( new_c );\n\n  return 0;\n}\n\n\nnight\nsock\nroom\n\n", "explain": "Result:\nANSI C provides little functionality for text manipulation outside of string.h.  While a number of libraries for this purpose have been written, this example uses only ANSI C.\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <string>\n#include <iostream>\n\nint main( ) {\n   std::string word( \"Premier League\" ) ;\n   std::cout << \"Without first letter: \" << word.substr( 1 ) << \"\u00a0!\\n\" ;\n   std::cout << \"Without last letter: \" << word.substr( 0 , word.length( ) - 1 ) << \"\u00a0!\\n\" ;\n   std::cout << \"Without first and last letter: \" << word.substr( 1 , word.length( ) - 2 ) << \"\u00a0!\\n\" ;\n   return 0 ;\n}\n\n\nWithout first letter: remier League\u00a0!\nWithout last letter: Premier Leagu\u00a0!\nWithout first and last letter: remier Leagu\u00a0!\n\n", "explain": "Output:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Java", "code": "\n\npublic class RM_chars {\n  public static void main( String[] args ){\n    System.out.println( \"knight\".substring( 1 ) );\n    System.out.println( \"socks\".substring( 0, 4 ) );\n    System.out.println( \"brooms\".substring( 1, 5 ) );\n      // first, do this by selecting a specific substring\n      // to exclude the first and last characters\n    \n    System.out.println( \"knight\".replaceAll( \"^.\", \"\" ) );\n    System.out.println( \"socks\".replaceAll( \".$\", \"\" ) );\n    System.out.println( \"brooms\".replaceAll( \"^.|.$\", \"\" ) );\n      // then do this using a regular expressions\n  }\n}\n\n\nnight\nsock\nroom\nnight\nsock\nroom\n\npublic class SubstringTopAndTail {\n  public static void main( String[] args ){\n    var s = \"\\uD83D\\uDC0Eabc\\uD83D\\uDC0E\";  // Horse emoji, a, b, c, horse emoji: \"\ud83d\udc0eabc\ud83d\udc0e\"\n\n    var sizeOfFirstChar = Character.isSurrogate(s.charAt(0)) ? 2 : 1;\n    var sizeOfLastChar = Character.isSurrogate(s.charAt(s.length() - 1)) ? 2 : 1;\n\n    var removeFirst = s.substring(sizeOfFirstChar);\n    var removeLast = s.substring(0, s.length() - sizeOfLastChar);\n    var removeBoth = s.substring(sizeOfFirstChar, s.length() - sizeOfLastChar);\n\n    System.out.println(removeFirst);\n    System.out.println(removeLast);\n    System.out.println(removeBoth);\n  }\n}\n\n\nabc\ud83d\udc0e\n\ud83d\udc0eabc\nabc\n", "explain": "I solve this problem two ways.  First I use substring which is relatively fast for small strings, since it simply grabs the characters within a set of given bounds.  The second uses regular expressions, which have a higher overhead for such short strings, but work correctly with all Unicode code points, not just those in the Basic Multilingual Plane.\nResults:\nNearly all current solutions for this task fail to work correctly: the task says \"The program must reference logical characters (code points), not 8-bit code units for UTF-8 or 16-bit code units for UTF-16.\" The code below works correctly with all Unicode characters, without using regular expressions as the above program does.\nResults:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        string testString = \"test\";\n        Console.WriteLine(testString.Substring(1));\n        Console.WriteLine(testString.Substring(0, testString.Length - 1));\n        Console.WriteLine(testString.Substring(1, testString.Length - 2));\n    }\n}\n\nest\ntes\nes\n", "explain": "Result:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nalert(\"knight\".slice(1));       // strip first character\nalert(\"socks\".slice(0, -1));    // strip last character\nalert(\"brooms\".slice(1, -1));   // strip both first and last characters\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "PHP", "code": "\n<?php\necho substr(\"knight\", 1), \"\\n\";       // strip first character\necho substr(\"socks\", 0, -1), \"\\n\";    // strip last character\necho substr(\"brooms\", 1, -1), \"\\n\";   // strip both first and last characters\n?>\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nprogram substring\n\n  character(len=5) :: string\n  string = \"Hello\"\n  \n  write (*,*) string\n  write (*,*) string(2:)\n  write (*,*) string( :len(string)-1)\n  write (*,*) string(2:len(string)-1)\n\nend program substring\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"unicode/utf8\"\n)\n\nfunc main() {\n    // ASCII contents:  Interpreting \"characters\" as bytes.\n    s := \"ASCII\"\n    fmt.Println(\"String:                \", s)\n    fmt.Println(\"First byte removed:    \", s[1:])\n    fmt.Println(\"Last byte removed:     \", s[:len(s)-1])\n    fmt.Println(\"First and last removed:\", s[1:len(s)-1])\n    // UTF-8 contents:  \"Characters\" as runes (unicode code points)\n    u := \"\u0394\u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\u03ae\"\n    fmt.Println(\"String:                \", u)\n    _, sizeFirst := utf8.DecodeRuneInString(u)\n    fmt.Println(\"First rune removed:    \", u[sizeFirst:])\n    _, sizeLast := utf8.DecodeLastRuneInString(u)\n    fmt.Println(\"Last rune removed:     \", u[:len(u)-sizeLast])\n    fmt.Println(\"First and last removed:\", u[sizeFirst:len(u)-sizeLast])\n}\n\n\nString:                 ASCII\nFirst byte removed:     SCII\nLast byte removed:      ASCI\nFirst and last removed: SCI\nString:                 \u0394\u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\u03ae\nFirst rune removed:     \u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\u03ae\nLast rune removed:      \u0394\u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\nFirst and last removed: \u03b7\u03bc\u03bf\u03c4\u03b9\u03ba\n\n", "explain": "Go strings are byte arrays that can hold whatever you want them to hold.  Common contents are ASCII and UTF-8.  You use different techniques depending on how you are interpreting the string.  The utf8 package functions shown here allows efficient extraction of first and last runes without decoding the entire string.\nOutput:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n\n.include \"\\SrcAll\\Header.asm\"\n.include \"\\SrcAll\\BasicMacros.asm\"\n.include \"\\SrcALL\\AdvancedMacros.asm\"\n.include \"\\SrcALL\\MemoryMap.asm\"\n\n; .definelabel UserRam,0xA0010000\t\t(this is defined in the header)\n\nCursorX equ 0x100 ;offset from label UserRam\nCursorY equ 0x101 ;offset from label UserRam\n\nmain:\n\tjal Cls\n\tnop\n\t\n\tla a0,MyString\n\tla a1,UserRam+0x1000\n\tpush a0\n\tpush a1\n\t\tjal strcpy\n\t\taddiu a0,1\t\t;branch delay slot - increment base address prior to branching\n\tpop a0\t\t\t\t;deliberately pop in the \"wrong order\"\n\tpop a1\t\t\t\t;because printString uses $a0\n\t\n\tjal PrintString\n\tnop\n\tjal NewLine\n\tnop\n\t\n\t\n\t\n\tla a0,MyString\n\tla a1,UserRam+0x1000\n\t\n\tpush a0\n\tpush a1\n\t\tjal strcpy\n\t\tnop\t\t\t\t;branch delay slot\n\t\t;after a strcpy, a0/a1 both point to the null terminator\n\t\tsubiu a1,1\n\t\tmove t0,zero\n\t\tsb t0,(a1)\n\t\t.ifdef buildPSX\n\t\t\tnop\t\t;load delay slot\n\t\t.endif\n\tpop a0\n\tpop a1\n\t\n\tjal PrintString\n\tnop\n\tjal NewLine\n\tnop\n\t\n\tla a0,MyString\n\tla a1,UserRam+0x1000\n\t\n\tpush a0\n\tpush a1\n\t\tjal strcpy\n\t\taddiu a0,1\t;branch delay slot\n\t\t;after a strcpy, a0/a1 both point to the null terminator\n\t\tsubiu a1,1\n\t\tmove t0,zero\n\t\tsb t0,(a1)\n\t\t.ifdef buildPSX\n\t\t\tnop\t\t;load delay slot\n\t\t.endif\n\tpop a0\n\tpop a1\n\t\n\tjal PrintString\n\tnop\n\tjal NewLine\n\tnop\n\t\n\t\nhalt:\n\tnop\n\tj halt\n\tnop\n\t\n\t\nMyString:\n\t.ascii \"Hello World\"\n\t.byte 0\n\t.align 4\n\t\nMyFont:\n\n.ifdef buildn64\t\t\t\t\n\t.incbin \"\\ResN64\\ChibiAkumas.fnt\"\n.endif\n.ifdef buildPSX\t\t\t\t\n\t.incbin \"\\ResPSX\\ChibiAkumas.fnt\"\n.endif\n\n.include \"\\SrcALL\\graphics.asm\"\n.include \"\\SrcAll\\monitor.asm\"\n.include \"\\SrcALL\\Multiplatform_Math_Integer.asm\"\n.include \"\\SrcALL\\BasicFunctions_v2.asm\"\n.include \"\\SrcN64\\Footer.asm\"\n\nOutput:\nello World\nHello Worl\nello Worl\n\n", "explain": "Thanks to Chibialiens for the header/footer, font, and print routines.\nScreenshot of PlayStation 1 Emulator\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nprogram TopAndTail;\n\n{$APPTYPE CONSOLE}\n\nconst\n  TEST_STRING = '1234567890';\nbegin\n  Writeln(TEST_STRING);                                    // full string\n  Writeln(Copy(TEST_STRING, 2, Length(TEST_STRING)));      // first character removed\n  Writeln(Copy(TEST_STRING, 1, Length(TEST_STRING) - 1));  // last character removed\n  Writeln(Copy(TEST_STRING, 2, Length(TEST_STRING) - 2));  // first and last characters removed\n\n  Readln;\nend.\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Ruby", "code": "\nputs \"knight\"[1..-1]   # strip first character\nputs \"socks\"[0..-2]    # strip last character\nputs \"socks\".chop      # alternate way to strip last character\nputs \"brooms\"[1..-2]   # strip both first and last characters\nputs \"\u4e0e\u4eca\u4ee4\"[1..-2]    # => \u4eca\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Rust", "code": "\n\nfn main() {\n    let s = String::from(\"\u017elu\u0165ou\u010dk\u00fd k\u016f\u0148\");\n\n    let mut modified = s.clone();\n    modified.remove(0);\n    println!(\"{}\", modified);\n\n    let mut modified = s.clone();\n    modified.pop();\n    println!(\"{}\", modified);\n\n    let mut modified = s;\n    modified.remove(0);\n    modified.pop();\n    println!(\"{}\", modified);\n}\n\n\nfn main() {\n    let s = \"\u017elu\u0165ou\u010dk\u00fd k\u016f\u0148\";\n\n    println!(\n        \"{}\",\n        s.char_indices()\n            .nth(1)\n            .map(|(i, _)| &s[i..])\n            .unwrap_or_default()\n    );\n\n    println!(\n        \"{}\",\n        s.char_indices()\n            .nth_back(0)\n            .map(|(i, _)| &s[..i])\n            .unwrap_or_default()\n    );\n\n    println!(\n        \"{}\",\n        s.char_indices()\n            .nth(1)\n            .and_then(|(i, _)| s.char_indices().nth_back(0).map(|(j, _)| i..j))\n            .map(|range| &s[range])\n            .unwrap_or_default()\n    );\n}\n\n", "explain": "One possibility is to modify the owned string representation:\nAnother possibility is to cut a string slice (moreover, this version assumes\nnothing about the string length):\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Swift", "code": "\n\nlet txt = \"0123456789\"\nprintln(dropFirst(txt))\nprintln(dropLast(txt))\nprintln(dropFirst(dropLast(txt)))\n\n\nOutput:\n123456789\n012345678\n12345678\n\nlet txt = \"0123456789\"\nprintln(txt[txt.startIndex.successor() ..< txt.endIndex])\nprintln(txt[txt.startIndex             ..< txt.endIndex.predecessor()])\nprintln(txt[txt.startIndex.successor() ..< txt.endIndex.predecessor()])\n\n\nOutput:\n123456789\n012345678\n12345678\n\nvar txt = \"0123456789\"\ntxt.removeAtIndex(txt.startIndex)\ntxt.removeAtIndex(txt.endIndex.predecessor())\n\n\nextension String {\n    \n    /// Ensure positive indexes\n    \n    private func positive(index: Int) -> Int {\n        \n        if index >= 0 { return index }\n        \n        return count(self) + index\n    }\n    \n    /// Unicode character by zero-based integer (character) `index`\n    /// Supports negative character index to count from end. (-1 returns character before last)\n    \n    subscript(index: Int) -> Character {\n        \n        return self[advance(startIndex, positive(index))]\n    }\n    \n    /// String slice by character index\n    \n    subscript(range: Range<Int>) -> String {\n        \n        return self[advance(startIndex, range.startIndex) ..<\n                    advance(startIndex, range.endIndex, endIndex)]\n    }\n    \n    /// Left portion of text to `index`\n    \n    func left(index\u00a0: Int) -> String {\n        \n        return self[0 ..< positive(index)]\n    }\n    \n    /// Right portion of text from `index`\n    \n    func right(index\u00a0: Int) -> String{\n        \n        return self[positive(index) ..< count(self)]\n    }\n    \n    /// From `start` index until `end` index\n    \n    func mid(start: Int, _ end: Int) -> String {\n        \n        return self[positive(start) ..< positive(end)]\n    }\n    \n}\n\nlet txt = \"0123456789\"\n\ntxt.right(1) // Right part without first character\ntxt.left(-1) // Left part without last character\ntxt.mid(1,-1) // Middle part without first and last character\n", "explain": "Swift strings are native Unicode strings and do not index through the code points. Swift's String.Index refers to true Unicode characters (Unicode grapheme clusters). Swift standard library has generic functionality that not only works with strings, but also with any type that conforms to relevant protocols. The first method presented here uses generic functions from Swift standard library: \nThe other method is slicing by range subscripting:\nAnother way is mutating the string:\nThe above functions return what they remove.\nYou can also extend String type and define BASIC-style functions:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "COBOL", "code": "\n       identification division.\n       program-id. toptail.\n\n       data division.\n       working-storage section.\n       01 data-field.\n          05 value \"[this is a test]\".\n\n       procedure division.\n       sample-main.\n       display data-field\n      *> Using reference modification, which is (start-position:length)\n       display data-field(2:)\n       display data-field(1:length of data-field - 1)\n       display data-field(2:length of data-field - 2)\n       goback.\n       end program toptail.\n\n\nOutput:\nprompt$ cobc -xj toptail.cob\n[this is a test]\nthis is a test]\n[this is a test\nthis is a test\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Remove_Characters is\n   S: String := \"upraisers\";\n   use Ada.Text_IO;\nbegin\n   Put_Line(\"Full String:   \"\"\" & S & \"\"\"\");\n   Put_Line(\"Without_First: \"\"\" & S(S'First+1 .. S'Last) & \"\"\"\");\n   Put_Line(\"Without_Last:  \"\"\" & S(S'First   .. S'Last-1) & \"\"\"\");\n   Put_Line(\"Without_Both:  \"\"\" & S(S'First+1 .. S'Last-1) & \"\"\"\");\nend Remove_Characters;\n\n\nFull String:   \"upraisers\"\nWithout_First: \"praisers\"\nWithout_Last:  \"upraiser\"\nWithout_Both:  \"praiser\"\n\nwith Ada.Text_IO;\nwith Ada.Strings.UTF_Encoding.Wide_Strings;\n\nprocedure Remove_Characters\nis\n   use Ada.Text_IO;\n   use Ada.Strings.UTF_Encoding;\n   use Ada.Strings.UTF_Encoding.Wide_Strings;\n   \n   S : String := \"upraisers\";\n   U : Wide_String := Decode (UTF_8_String'(S));\n   \n   function To_String (X : Wide_String)return String\n   is\n   begin\n      return String (UTF_8_String'(Encode (X)));\n   end To_String;\n   \nbegin\n   Put_Line\n     (To_String\n        (\"Full String:   \"\"\" & U & \"\"\"\"));\n   Put_Line\n     (To_String\n        (\"Without_First: \"\"\" & U (U'First + 1 .. U'Last) & \"\"\"\"));\n   Put_Line\n     (To_String\n        (\"Without_Last:  \"\"\" & U (U'First   .. U'Last - 1) & \"\"\"\"));\n   Put_Line\n     (To_String\n        (\"Without_Both:  \"\"\" & U (U'First + 1 .. U'Last - 1) & \"\"\"\"));\n\nend Remove_Characters;\n\n\nFull String:   \"upraisers\"\nWithout_First: \"praisers\"\nWithout_Last:  \"upraiser\"\nWithout_Both:  \"praiser\"\n", "explain": "Output:\nWith UTF8 support in Ada 2012 (Wide_Character of literals is automatic):\nOutput:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Julia", "code": "\njulia> \"My String\"[2:end] # without first character\n\"y String\"\n\njulia> \"My String\"[1:end-1] # without last character\n\"My Strin\"\n\njulia> \"My String\"[2:end-1] # without first and last characters\n\"y Strin\"\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n// version 1.0.6\nfun main(args: Array<String>) {\n    val s = \"Rosetta\"\n    println(s.drop(1))\n    println(s.dropLast(1))\n    println(s.drop(1).dropLast(1))\n}\n\n\nOutput:\nosetta\nRosett\nosett\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Perl", "code": "\nprint substr(\"knight\",1), \"\\n\";        # strip first character\nprint substr(\"socks\", 0, -1), \"\\n\";    # strip last character\nprint substr(\"brooms\", 1, -1), \"\\n\";   # strip both first and last characters\n\n\n$string = 'ouch';\n$bits = chop($string);       # The last letter is returned by the chop function\nprint $bits;        # h\nprint $string;      # ouc    # See we really did chop the last letter off\n\n", "explain": "In perl, we can also remove the last character from a string variable with the chop function:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Prolog", "code": "\n\nremove_first_last_chars :-\n    L = \"Rosetta\",\n    L = [_|L1],\n    remove_last(L, L2),\n    remove_last(L1, L3),\n    writef('Original string     \u00a0: %s\\n', [L]),\n    writef('Without first char      \u00a0: %s\\n', [L1]),\n    writef('Without last char       \u00a0: %s\\n', [L2]),\n    writef('Without first/last chars\u00a0: %s\\n', [L3]).\n\nremove_last(L, LR) :-\n    append(LR, [_], L).\n\n\n\u00a0?- remove_first_last_chars.\nOriginal string         \u00a0: Rosetta\nWithout first char      \u00a0: osetta\nWithout last char       \u00a0: Rosett\nWithout first/last chars\u00a0: osett\ntrue.\n\n", "explain": "Works with SWI-Prolog.\nOutput\u00a0:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Lua", "code": "\nprint (string.sub(\"knights\",2))    -- remove the first character\nprint (string.sub(\"knights\",1,-2))    -- remove the last character\nprint (string.sub(\"knights\",2,-2))    -- remove the first and last characters\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Scala", "code": "\nLibrary: Scala\nprintln(\"knight\".tail)               // strip first character\nprintln(\"socks\".init)         // strip last character\nprintln(\"brooms\".tail.init)   // strip both first and last characters\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Dart", "code": "\nvoid main() {\n  String word = \"Premier League\";\n  print(\"Without first letter: ${word.substring(1)}\u00a0!\");\n  print(\"Without last letter: ${word.substring(0, word.length - 1)}\u00a0!\");\n  print(\"Without first and last letter: ${word.substring(1, word.length - 1)}\u00a0!\");\n}\n\n\nOutput:\nSame as C++ entry.\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "D", "code": "\n\nimport std.stdio;\n\nvoid main() {\n    // strip first character\n    writeln(\"knight\"[1 .. $]);\n\n    // strip last character\n    writeln(\"socks\"[0 .. $ - 1]);\n\n    // strip both first and last characters\n    writeln(\"brooms\"[1 .. $ - 1]);\n}\n\n\nOutput:\nnight\nsock\nroom\n", "explain": "Version for ASCII strings or Unicode dstrings:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Haskell", "code": "\n-- We define the functions to return an empty string if the argument is too\n-- short for the particular operation.\n\nremFirst, remLast, remBoth :: String -> String\n\nremFirst \"\" = \"\"\nremFirst cs = tail cs\n\nremLast \"\" = \"\"\nremLast cs = init cs\n\nremBoth (c:cs) = remLast cs\nremBoth  _     = \"\"\n\nmain :: IO ()\nmain = do\n  let s = \"Some string.\"  \n  mapM_ (\\f -> putStrLn . f $ s) [remFirst, remLast, remBoth]\n\n\nword = \"knights\"\n\nmain = do\n    -- You can drop the first item\n    -- using `tail`\n    putStrLn (tail word)\n\n    -- The `init` function will drop\n    -- the last item\n    putStrLn (init word)\n\n    -- We can combine these two to drop\n    -- the last and the first characters\n    putStrLn (middle word)\n\n-- You can combine functions using `.`,\n-- which is pronounced \"compose\" or \"of\"\nmiddle = init . tail\n\n\nmain :: IO ()\nmain = mapM_ print $ [tail, init, init . tail] <*> [\"knights\"]\n\n\nOutput:\n\"nights\"\n\"knight\"\n\"night\"\n", "explain": "Alternative solution with builtin functions:\nIn short:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nFunction TopNTail(s,mode)\n    Select Case mode\n        Case \"top\"\n            TopNTail = Mid(s,2,Len(s)-1)\n        Case \"tail\"\n            TopNTail = Mid(s,1,Len(s)-1)\n        Case \"both\"\n            TopNTail = Mid(s,2,Len(s)-2)\n    End Select\nEnd Function\n\nWScript.Echo \"Top: UPRAISERS = \" & TopNTail(\"UPRAISERS\",\"top\")\nWScript.Echo \"Tail: UPRAISERS = \" & TopNTail(\"UPRAISERS\",\"tail\")\nWScript.Echo \"Both: UPRAISERS = \" & TopNTail(\"UPRAISERS\",\"both\")\n\nOutput:\nTop: UPRAISERS = PRAISERS\nTail: UPRAISERS = UPRAISER\nBoth: UPRAISERS = PRAISER\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Scheme", "code": "\n(define (string-top s)\n  (if (string=? s \"\") s (substring s 0 (- (string-length s) 1))))\n\n(define (string-tail s)\n  (if (string=? s \"\") s (substring s 1 (string-length s))))\n\n(define (string-top-tail s)\n  (string-tail (string-top s)))\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Apex", "code": "\nString strOrig = 'brooms';\nString str1 = strOrig.substring(1, strOrig.length());\nsystem.debug(str1);\nString str2 = strOrig.substring(0, strOrig.length()-1);\nsystem.debug(str2);\nString str3 = strOrig.substring(1, strOrig.length()-1);\nsystem.debug(str3);\n\n// Regular Expressions approach\nString strOrig = 'brooms';\nString str1 = strOrig.replaceAll( '^.', '' );\nsystem.debug(str1);\nString str2 = strOrig.replaceAll( '.$', '' ) ;\nsystem.debug(str2);\nString str3 = strOrig.replaceAll( '^.|.$', '' );\nsystem.debug(str3);\n\n\nOutput:\nrooms\n\nbroom\n\nroom\n\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 4.0\nFirst method[edit]\n$string = \"top and tail\"\n$string\n$string.Substring(1)\n$string.Substring(0, $string.Length - 1)\n$string.Substring(1, $string.Length - 2)\n\nSecond method[edit]\n$string = \"top and tail\"\n$string\n$string[1..($string.Length - 1)] -join \"\"\n$string[0..($string.Length - 2)] -join \"\"\n$string[1..($string.Length - 2)] -join \"\"\n\n\ntop and tail\nop and tail\ntop and tai\nop and tai\n\n", "explain": "Output:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Logo", "code": "\nmake \"s \"|My string|\nprint butfirst :s\nprint butlast :s\nprint butfirst butlast :s\n", "explain": ""}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "F#", "code": "\n[<EntryPoint>]\nlet main args =\n    let s = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\n    printfn \"%A\" (s.Substring(1))\n    printfn \"%A\" (s.Substring(0, s.Length - 1))\n    printfn \"%A\" (s.Substring(1, s.Length - 2))\n    0\n\n\n\"\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\n\"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\"\n\"\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\"\n", "explain": "Output\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\ndef top  = { it.size() > 1 ? it[0..-2] : '' }\ndef tail = { it.size() > 1 ? it[1..-1] : '' }\n\n\ndef testVal = 'upraisers'\nprintln \"\"\"\noriginal: ${testVal}\ntop:      ${top(testVal)}\ntail:     ${tail(testVal)}\ntop&tail: ${tail(top(testVal))}\n\"\"\"\n\n\noriginal: upraisers\ntop:      upraiser\ntail:     praisers\ntop&tail: praiser\n", "explain": "Solution:\nTest:\nOutput:\n"}, {"task_name": "Substring/Top and tail", "task_url": "https://rosettacode.org/wiki/Substring/Top_and_tail", "task_cat": "String manipulation", "lang": "AWK", "code": "\nBEGIN {\n  mystring=\"knights\"\n  print substr(mystring,2)                       # remove the first letter\n  print substr(mystring,1,length(mystring)-1)    # remove the last character\n  print substr(mystring,2,length(mystring)-2)    # remove both the first and last character\n}\n\n", "explain": ""}]