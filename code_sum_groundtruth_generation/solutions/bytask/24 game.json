[{"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Python", "code": "\nPython: Original, with output[edit]\n\n'''\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n'''\n\nfrom __future__ import division, print_function\nimport random, ast, re\nimport sys\n\nif sys.version_info[0] < 3: input = raw_input\n\ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n\ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n\ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n\ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            print (\"New digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n\nif __name__ == '__main__': main()\n\n\nOutput:\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n\nYour four digits: 3 2 4 6\nExpression 1: (3 - 1)*(6*4)\nThe input '(3 - 1)*(6*4)' was wonky!\nExpression 2: (3 - 2) * 6 * 4\n =  24\nThat's right!\nThank you and goodbye.\nPython: Alternative[edit]\nimport random, re\nchars = [\"(\",\")\",\"/\",\"+\",\"-\",\"*\"]  \nwhile True:\n    charsandints, ints = [], []\n    for x in range(4):\n        ints.append(str(random.randrange(1,10)))\n    charsandints = chars + ints\n    print \"Numbers are:\", ints\n    guess = raw_input(\"Enter your guess:\")\n    if guess.lower() == \"q\":\n        break\n    elif guess.lower() == \"|\":\n        pass\n    else:\n        flag = True\n        for a in guess:\n            if a not in charsandints or guess.count(a) > charsandints.count(a):\n                flag = False\n        if re.search(\"\\d\\d\", guess):\n            print \"You cannot combine digits.\"\n            break\n        if flag:\n            print \"Your result is: \", eval(guess)\n            if eval(guess) == 24:\n                print \"You won\"\n                break\n            else:\n                print \"You lost\"\n                break\n        else:\n            print \"You cannot use anthing other than\", charsandints\n            break\nprint \"Thanks for playing\"\n\n", "explain": "Uses eval, the built-in expression evaluator of infix expressions.\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <ctype.h>\n#include <stdlib.h>\n#include <setjmp.h>\n#include <time.h>\n \njmp_buf ctx;\nconst char *msg;\n \nenum { OP_NONE = 0, OP_NUM, OP_ADD, OP_SUB, OP_MUL, OP_DIV };\n \ntypedef struct expr_t *expr, expr_t;\nstruct expr_t {\n\tint op, val, used;\n\texpr left, right;\n};\n \n#define N_DIGITS 4\nexpr_t digits[N_DIGITS];\n \nvoid gen_digits()\n{\n\tint i;\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].val = 1 + rand() % 9;\n}\n \n#define MAX_INPUT 64\nchar str[MAX_INPUT];\nint pos;\n \n#define POOL_SIZE 8\nexpr_t pool[POOL_SIZE];\nint pool_ptr;\n \nvoid reset()\n{\n\tint i;\n\tmsg = 0;\n\tpool_ptr = pos = 0;\n\tfor (i = 0; i < POOL_SIZE; i++) {\n\t\tpool[i].op = OP_NONE;\n\t\tpool[i].left = pool[i].right = 0;\n\t}\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tdigits[i].used = 0;\n}\n \n/* longish jumpish back to input cycle */\nvoid bail(const char *s)\n{\n\tmsg = s;\n\tlongjmp(ctx, 1);\n}\n \nexpr new_expr()\n{\n\tif (pool_ptr < POOL_SIZE)\n\t\treturn pool + pool_ptr++;\n\treturn 0;\n}\n \n/* check next input char */\nint next_tok()\n{\n\twhile (isspace(str[pos])) pos++;\n\treturn str[pos];\n}\n \n/* move input pointer forward */\nint take()\n{\n\tif (str[pos] != '\\0') return ++pos;\n\treturn 0;\n}\n \n/* BNF(ish)\nexpr = term { (\"+\")|(\"-\") term }\nterm = fact { (\"*\")|(\"/\") expr }\nfact =\tnumber\n\t| '(' expr ')'\n*/\n \nexpr get_fact();\nexpr get_term();\nexpr get_expr();\n \nexpr get_expr()\n{\n\tint c;\n\texpr l, r, ret;\n\tif (!(ret = get_term())) bail(\"Expected term\");\n\twhile ((c = next_tok()) == '+' || c == '-') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n\t\tif (!(r = get_term())) bail(\"Expected term\");\n \n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '+') ? OP_ADD : OP_SUB;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n \nexpr get_term()\n{\n\tint c;\n\texpr l, r, ret;\n\tret = get_fact();\n\twhile((c = next_tok()) == '*' || c == '/') {\n\t\tif (!take()) bail(\"Unexpected end of input\");\n \n\t\tr = get_fact();\n\t\tl = ret;\n\t\tret = new_expr();\n\t\tret->op = (c == '*') ? OP_MUL : OP_DIV;\n\t\tret->left = l;\n\t\tret->right = r;\n\t}\n\treturn ret;\n}\n \nexpr get_digit()\n{\n\tint i, c = next_tok();\n\texpr ret;\n\tif (c >= '0' && c <= '9') {\n\t\ttake();\n\t\tret = new_expr();\n\t\tret->op = OP_NUM;\n\t\tret->val = c - '0';\n\t\tfor (i = 0; i < N_DIGITS; i++)\n\t\t\tif (digits[i].val == ret->val && !digits[i].used) {\n\t\t\t\tdigits[i].used = 1;\n\t\t\t\treturn ret;\n\t\t\t}\n\t\tbail(\"Invalid digit\");\n\t}\n\treturn 0;\n}\n \nexpr get_fact()\n{\n\tint c;\n\texpr l = get_digit();\n\tif (l) return l;\n\tif ((c = next_tok()) == '(') {\n\t\ttake();\n\t\tl = get_expr();\n\t\tif (next_tok() != ')') bail(\"Unbalanced parens\");\n\t\ttake();\n\t\treturn l;\n\t}\n\treturn 0;\n}\n \nexpr parse()\n{\n\tint i;\n\texpr ret = get_expr();\n\tif (next_tok() != '\\0')\n\t\tbail(\"Trailing garbage\");\n\tfor (i = 0; i < N_DIGITS; i++)\n\t\tif (!digits[i].used)\n\t\t\tbail(\"Not all digits are used\");\n\treturn ret;\n}\n \ntypedef struct frac_t frac_t, *frac;\nstruct frac_t { int denom, num; };\n \nint gcd(int m, int n)\n{\n\tint t;\n\twhile (m) {\n\t\tt = m; m = n % m; n = t;\n\t}\n\treturn n;\n}\n \n/* evaluate expression tree.  result in fraction form */\nvoid eval_tree(expr e, frac res)\n{\n\tfrac_t l, r;\n\tint t;\n\tif (e->op == OP_NUM) {\n\t\tres->num = e->val;\n\t\tres->denom = 1;\n\t\treturn;\n\t}\n \n\teval_tree(e->left, &l);\n\teval_tree(e->right, &r);\n \n\tswitch(e->op) {\n\tcase OP_ADD:\n\t\tres->num = l.num * r.denom + l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_SUB:\n\t\tres->num = l.num * r.denom - l.denom * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_MUL:\n\t\tres->num = l.num * r.num;\n\t\tres->denom = l.denom * r.denom;\n\t\tbreak;\n\tcase OP_DIV:\n\t\tres->num = l.num * r.denom;\n\t\tres->denom = l.denom * r.num;\n\t\tbreak;\n\t}\n\tif ((t = gcd(res->denom, res->num))) {\n\t\tres->denom /= t;\n\t\tres->num /= t;\n\t}\n}\n \nvoid get_input()\n{\n\tint i;\nreinput:\n\treset();\n\tprintf(\"\\nAvailable digits are:\");\n\tfor (i = 0; i < N_DIGITS; i++) \n\t\tprintf(\" %d\", digits[i].val);\n\tprintf(\". Type an expression and I'll check it for you, or make new numbers.\\n\"\n\t\t\"Your choice? [Expr/n/q] \");\n \n\twhile (1) {\n\t\tfor (i = 0; i < MAX_INPUT; i++) str[i] = '\\n';\n\t\tfgets(str, MAX_INPUT, stdin);\n\t\tif (*str == '\\0') goto reinput;\n\t\tif (str[MAX_INPUT - 1] != '\\n')\n\t\t\tbail(\"string too long\");\n \n\t\tfor (i = 0; i < MAX_INPUT; i++)\n\t\t\tif (str[i] == '\\n') str[i] = '\\0';\n\t\tif (str[0] == 'q') {\n\t\t\tprintf(\"Bye\\n\");\n\t\t\texit(0);\n\t\t}\n\t\tif (str[0] == 'n') {\n\t\t\tgen_digits();\n\t\t\tgoto reinput;\n\t\t}\n\t\treturn;\n\t}\n}\n \nint main()\n{\n\tfrac_t f;\n\tsrand(time(0));\n \n\tgen_digits();\n\twhile(1) {\n\t\tget_input();\n\t\tsetjmp(ctx); /* if parse error, jump back here with err msg set */\n\t\tif (msg) {\n\t\t\t/* after error jump; announce, reset, redo */\n\t\t\tprintf(\"%s at '%.*s'\\n\", msg, pos, str);\n\t\t\tcontinue;\n\t\t}\n \n\t\teval_tree(parse(), &f);\n \n\t\tif (f.denom == 0) bail(\"Divide by zero\");\n\t\tif (f.denom == 1 && f.num == 24)\n\t\t\tprintf(\"You got 24.  Very good.\\n\");\n\t\telse {\n\t\t\tif (f.denom == 1)\n\t\t\t\tprintf(\"Eval to: %d, \", f.num);\n\t\t\telse\n\t\t\t\tprintf(\"Eval to: %d/%d, \", f.num, f.denom);\n\t\t\tprintf(\"no good.  Try again.\\n\");\n\t\t}\n\t}\n\treturn 0;\n}\n\n\nOutput:\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] 5*2*3/9\nEval to: 10/3, no good.  Try again.\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] (5*(2+3)-9\nUnbalanced parens at '(5*(2+3)-9'\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] 3*9-(5-2)\nYou got 24.  Very good.\n\nAvailable digits are: 5 2 3 9. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] n\n\nAvailable digits are: 4 4 4 7. Type an expression and I'll check it for you, or make new numbers.\nYour choice? [Expr/n/q] q\nBye\n\n", "explain": "Simple recursive descent parser.  It doesn't have a real lexer, because all tokens are single character (digits, operators and parens).  Code is a little too long.\nSee 24 game/C\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "C++", "code": "\nWorks with: C++11\n\n#include <random>\n#include <iostream>\n#include <stack>\n#include <set>\n#include <string>\n#include <functional>\nusing namespace std;\n\nclass RPNParse\n{\npublic:\n  stack<double> stk;\n  multiset<int> digits;\n\n  void op(function<double(double,double)> f)\n  {\n    if(stk.size() < 2)\n      throw \"Improperly written expression\";\n    int b = stk.top(); stk.pop();\n    int a = stk.top(); stk.pop();\n    stk.push(f(a, b));\n  }\n\n  void parse(char c)\n  {\n    if(c >= '0' && c <= '9')\n    {\n      stk.push(c - '0');\n      digits.insert(c - '0');\n    }\n    else if(c == '+')\n      op([](double a, double b) {return a+b;});\n    else if(c == '-')\n      op([](double a, double b) {return a-b;});\n    else if(c == '*')\n      op([](double a, double b) {return a*b;});\n    else if(c == '/')\n      op([](double a, double b) {return a/b;});\n  }\n\n  void parse(string s)\n  {\n    for(int i = 0; i < s.size(); ++i)\n      parse(s[i]);\n  }\n\n  double getResult()\n  {\n    if(stk.size() != 1)\n      throw \"Improperly written expression\";\n    return stk.top();\n  }\n};\n\nint main()\n{\n  random_device seed;\n  mt19937 engine(seed());\n  uniform_int_distribution<> distribution(1, 9);\n  auto rnd = bind(distribution, engine);\n\n  multiset<int> digits;\n  cout << \"Make 24 with the digits: \";\n  for(int i = 0; i < 4; ++i)\n  {\n    int n = rnd();\n    cout << \" \" << n;\n    digits.insert(n);\n  }\n  cout << endl;\n\n  RPNParse parser;\n\n  try\n  {\n    string input;\n    getline(cin, input);\n    parser.parse(input);\n\n    if(digits != parser.digits)\n      cout << \"Error: Not using the given digits\" << endl;\n    else\n    {\n      double r = parser.getResult();\n      cout << \"Result: \" << r << endl;\n\n      if(r > 23.999 && r < 24.001)\n        cout << \"Good job!\" << endl;\n      else\n        cout << \"Try again.\" << endl;\n    }\n  }\n  catch(char* e)\n  {\n    cout << \"Error: \" << e << endl;\n  }\n  return 0;\n}\n\n\nOutput:\nMake 24 with the digits:  1 4 9 9\n9 9 + 4 * 1 +\nResult: 73\nTry again.\n\nMake 24 with the digits:  3 9 9 2\n9 9 + 3 2 * +\nResult: 24\nGood job!\n\n", "explain": "This uses the C++11 standard to simplify several parts of the code. Input is given in RPN format.\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Java", "code": "\nWorks with: Java version 7\nimport java.util.*;\n\npublic class Game24 {\n    static Random r = new Random();\n\n    public static void main(String[] args) {\n\n        int[] digits = randomDigits();\n        Scanner in = new Scanner(System.in);\n\n        System.out.print(\"Make 24 using these digits: \");\n        System.out.println(Arrays.toString(digits));\n        System.out.print(\"> \");\n\n        Stack<Float> s = new Stack<>();\n        long total = 0;\n        for (char c : in.nextLine().toCharArray()) {\n            if ('0' <= c && c <= '9') {\n                int d = c - '0';\n                total += (1 << (d * 5));\n                s.push((float) d);\n            } else if (\"+/-*\".indexOf(c) != -1) {\n                s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        }\n        if (tallyDigits(digits) != total)\n            System.out.print(\"Not the same digits. \");\n        else if (Math.abs(24 - s.peek()) < 0.001F)\n            System.out.println(\"Correct!\");\n        else\n            System.out.print(\"Not correct.\");\n    }\n\n    static float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    static long tallyDigits(int[] a) {\n        long total = 0;\n        for (int i = 0; i < 4; i++)\n            total += (1 << (a[i] * 5));\n        return total;\n    }\n\n    static int[] randomDigits() {        \n        int[] result = new int[4];\n        for (int i = 0; i < 4; i++)\n            result[i] = r.nextInt(9) + 1;\n        return result;\n    }\n}\n\n\nOutput:\nMake 24 using these digits: [1, 2, 4, 8]\n> 12*48+*\nCorrect!\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "C#", "code": "\n\n", "explain": "See 24 game/CSharp\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\nfunction twentyfour(numbers, input) {\n    var invalidChars = /[^\\d\\+\\*\\/\\s-\\(\\)]/;\n\n    var validNums = function(str) {\n        // Create a duplicate of our input numbers, so that\n        // both lists will be sorted.\n        var mnums = numbers.slice();\n        mnums.sort();\n\n        // Sort after mapping to numbers, to make comparisons valid.\n        return str.replace(/[^\\d\\s]/g, \" \")\n            .trim()\n            .split(/\\s+/)\n            .map(function(n) { return parseInt(n, 10); })\n            .sort()\n            .every(function(v, i) { return v === mnums[i]; });\n    };\n\n    var validEval = function(input) {\n        try {\n            return eval(input);\n        } catch (e) {\n            return {error: e.toString()};\n        }\n    };\n\n    if (input.trim() === \"\") return \"You must enter a value.\";\n    if (input.match(invalidChars)) return \"Invalid chars used, try again. Use only:\\n + - * / ( )\";\n    if (!validNums(input)) return \"Wrong numbers used, try again.\";\n    var calc = validEval(input);\n    if (typeof calc !== 'number') return \"That is not a valid input; please try again.\";\n    if (calc !== 24) return \"Wrong answer: \" + String(calc) + \"; please try again.\";\n    return input + \" == 24.  Congratulations!\";\n};\n\n// I/O below.\n\nwhile (true) {\n    var numbers = [1, 2, 3, 4].map(function() {\n        return Math.floor(Math.random() * 8 + 1);\n    });\n\n    var input = prompt(\n        \"Your numbers are:\\n\" + numbers.join(\" \") +\n        \"\\nEnter expression. (use only + - * / and parens).\\n\", +\"'x' to exit.\", \"\");\n\n    if (input === 'x') {\n        break;\n    }\n    alert(twentyfour(numbers, input));\n}\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "PHP", "code": "\nTranslation of: Perl\n#!/usr/bin/env php\nThe 24 Game\n \nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n \nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n \nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n<?php\n\nwhile (true) {\n    $numbers = make_numbers();\n\n    for ($iteration_num = 1; ; $iteration_num++) {\n        echo \"Expresion $iteration_num: \";\n\n        $entry = rtrim(fgets(STDIN));\n\n        if ($entry === '!') break;\n        if ($entry === 'q') exit;\n\n        $result = play($numbers, $entry);\n\n        if ($result === null) {\n            echo \"That's not valid\\n\";\n            continue;\n        }\n        elseif ($result != 24) {\n            echo \"Sorry, that's $result\\n\";\n            continue;\n        }\n        else {\n            echo \"That's right! 24!!\\n\";\n            exit;\n        }\n    }\n}\n\nfunction make_numbers() {\n    $numbers = array();\n\n    echo \"Your four digits: \";\n\n    for ($i = 0; $i < 4; $i++) {\n        $number = rand(1, 9);\n        // The check is needed to avoid E_NOTICE from PHP\n        if (!isset($numbers[$number])) {\n            $numbers[$number] = 0;\n        }\n        $numbers[$number]++;\n        print \"$number \";\n    }\n\n    print \"\\n\";\n\n    return $numbers;\n}\n\nfunction play($numbers, $expression) {\n    $operator = true;\n    for ($i = 0, $length = strlen($expression); $i < $length; $i++) {\n        $character = $expression[$i];\n\n        if (in_array($character, array('(', ')', ' ', \"\\t\"))) continue;\n\n        $operator = !$operator;\n\n        if (!$operator) {\n            if (!empty($numbers[$character])) {\n                $numbers[$character]--;\n                continue;\n            }\n            return;\n        }\n        elseif (!in_array($character, array('+', '-', '*', '/'))) {\n            return;\n        }\n    }\n\n    foreach ($numbers as $remaining) {\n        if ($remaining > 0) {\n            return;\n        }\n    }\n    \n    return eval(\"return $expression;\");\n}\n?>\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Fortran", "code": "\nClever implementation[edit]\n\nprogram game_24\n  implicit none\n  real               :: vector(4), reals(11), result, a, b, c, d\n  integer            :: numbers(4), ascii(11), i\n  character(len=11)  :: expression\n  character          :: syntax(11)\n  ! patterns:\n  character, parameter :: one(11)   = (/ '(','(','1','x','1',')','x','1',')','x','1' /)\n  character, parameter :: two(11)   = (/ '(','1','x','(','1','x','1',')',')','x','1' /)\n  character, parameter :: three(11) = (/ '1','x','(','(','1','x','1',')','x','1',')' /)\n  character, parameter :: four(11)  = (/ '1','x','(','1','x','(','1','x','1',')',')' /)\n  character, parameter :: five(11)  = (/ '(','1','x','1',')','x','(','1','x','1',')' /)\n  \n  do\n    call random_number(vector)\n    numbers = 9 * vector + 1\n    write (*,*) 'Digits: ',numbers\n    write (*,'(a)',advance='no') 'Your expression: '\n    read (*,'(a11)') expression\n\n    forall (i=1:11) syntax(i) = expression(i:i)\n    ascii = iachar(syntax)\n    where (syntax >= '0' .and. syntax <= '9')\n      syntax = '1'  ! number\n    elsewhere (syntax == '+' .or. syntax == '-' .or. syntax == '*' .or. syntax == '/')\n      syntax = 'x'  ! op\n    elsewhere (syntax /= '(' .and. syntax /= ')')\n      syntax = '-'  ! error\n    end where\n\n    reals = real(ascii-48)\n    if ( all(syntax == one) ) then\n      a = reals(3); b = reals(5); c = reals(8); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(op(a,4,b),7,c),10,d)\n    else if ( all(syntax == two) ) then\n      a = reals(2); b = reals(5); c = reals(7); d = reals(11)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,op(b,6,c)),10,d)\n    else if ( all(syntax == three) ) then\n      a = reals(1); b = reals(5); c = reals(7); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(op(b,6,c),9,d))\n    else if ( all(syntax == four) ) then\n      a = reals(1); b = reals(4); c = reals(7); d = reals(9)\n      call check_numbers(a,b,c,d)\n      result = op(a,2,op(b,5,op(c,8,d)))\n    else if ( all(syntax == five) ) then\n      a = reals(2); b = reals(4); c = reals(8); d = reals(10)\n      call check_numbers(a,b,c,d)\n      result = op(op(a,3,b),6,op(c,9,d))\n    else\n      stop 'Input string: incorrect syntax.'\n    end if\n\n    if ( abs(result-24.0) < epsilon(1.0) ) then\n      write (*,*) 'You won!'\n    else\n      write (*,*) 'Your result (',result,') is incorrect!'\n    end if\n  \n    write (*,'(a)',advance='no') 'Another one? [y/n] '\n    read (*,'(a1)') expression\n    if ( expression(1:1) == 'n' .or. expression(1:1) == 'N' ) then\n      stop\n    end if  \n  end do\n  \ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in) :: x,y\n    select case ( char(ascii(c)) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n  \n  subroutine check_numbers(a,b,c,d)\n    real, intent(in) :: a,b,c,d\n    integer          :: test(4)\n    test = (/ nint(a),nint(b),nint(c),nint(d) /)\n    call Insertion_Sort(numbers)\n    call Insertion_Sort(test)\n    if ( any(test /= numbers) ) then\n      stop 'You cheat\u00a0;-) (Incorrect numbers)'\n    end if\n  end subroutine check_numbers\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\nend program game_24\n\nAs a more general recursive descent parser:[edit]\n\n! implement a recursive descent parser\nmodule evaluate_algebraic_expression\n\n  integer, parameter :: size = 124\n  character, parameter :: statement_end = achar(0)\n  character(len=size) :: text_to_parse\n  integer :: position\n  data position/0/,text_to_parse/' '/\n\ncontains\n\n  character function get_token()\n    ! return the current token\n    implicit none\n    if (position <= size) then\n       get_token = text_to_parse(position:position)\n       do while (get_token <= ' ')\n          call advance\n          if (size < position) exit\n          get_token = text_to_parse(position:position)\n       end do\n    end if\n    if (size < position) get_token = statement_end\n  end function get_token\n\n  subroutine advance ! consume a token.  Move to the next token.  consume_token would have been a better name.\n    position = position + 1    \n  end subroutine advance\n  \n  logical function unfinished()\n    unfinished = get_token() /= statement_end\n  end function unfinished\n\n  subroutine parse_error()\n    write(6,*)'\"'//get_token()//'\" unexpected in expression at',position\n    stop 1\n  end subroutine parse_error\n\n  function precedence3() result(a)\n    implicit none\n    real :: a\n    character :: token\n    character(len=10), parameter :: digits = '0123456789'\n    token = get_token()\n    if (verify(token,digits) /= 0) call parse_error()\n    a = index(digits, token) - 1\n    call advance()\n  end function precedence3\n\n  recursive function precedence2() result(a)\n    real :: a\n    character :: token\n    token = get_token()\n    if (token /= '(') then\n       a = precedence3()\n    else\n       call advance\n       a = precedence0()\n       token = get_token()\n       if (token /= ')') call parse_error()\n       call advance\n    end if\n  end function precedence2\n\n  recursive function precedence1() result(a)\n    implicit none\n    real :: a\n    real, dimension(2) :: argument\n    character(len=2), parameter :: tokens = '*/'\n    character :: token\n    a = 0\n    token = get_token()\n    argument(1) = precedence2()\n    token = get_token()\n    do while (verify(token,tokens) == 0)\n       call advance()\n       argument(2) = precedence2()\n       if (token == '/') argument(2) = 1 / argument(2)\n       argument(1) = product(argument)       \n       token = get_token()\n    end do\n    a = argument(1)\n  end function precedence1\n\n  recursive function precedence0() result(a)\n    implicit none\n    real :: a\n    real, dimension(2) :: argument\n    character(len=2), parameter :: tokens = '+-'\n    character :: token\n    a = 0\n    token = get_token()\n    argument(1) = precedence1()\n    token = get_token()\n    do while (verify(token,tokens) == 0)\n       call advance()\n       argument(2) = precedence1()\n       if (token == '-') argument = argument * (/1, -1/)\n       argument(1) = sum(argument)\n       token = get_token()\n    end do\n    a = argument(1)\n  end function precedence0\n\n  real function statement()\n    implicit none\n    if (unfinished()) then\n       statement = precedence0()\n    else                        !empty okay\n       statement = 0\n    end if\n    if (unfinished()) call parse_error()\n  end function statement\n\n  real function evaluate(expression)\n    implicit none\n    character(len=*), intent(in) :: expression\n    text_to_parse = expression\n    evaluate = statement()\n  end function evaluate\n  \nend module evaluate_algebraic_expression\n\n\nprogram g24\n  use evaluate_algebraic_expression\n  implicit none\n  integer, dimension(4) :: digits\n  character(len=78) :: expression\n  real :: result\n  ! integer\u00a0:: i\n  call random_seed!easily found internet examples exist to seed by /dev/urandom or time\n  call deal(digits)\n  ! do i=1, 9999\u00a0! produce the data to test digit distribution\n  !   call deal(digits)\n  !   write(6,*) digits\n  ! end do\n  write(6,'(a13,4i2,a26)')'Using digits',digits,', and the algebraic dyadic'\n  write(6,*)'operators +-*/() enter an expression computing 24.'\n  expression = ' '\n  read(5,'(a78)') expression\n  if (invalid_digits(expression, digits)) then\n     write(6,*)'invalid digits'\n  else\n     result = evaluate(expression)\n     if (nint(result) == 24) then\n        write(6,*) result, ' close enough'\n     else\n        write(6,*) result, ' no good'\n     end if\n  end if\n\ncontains\n\n  logical function invalid_digits(e,d) !verify the digits\n    implicit none\n    character(len=*), intent(in) :: e\n    integer, dimension(4), intent(inout) :: d\n    integer :: i, j, k, count\n    logical :: unfound\n    count = 0\n    invalid_digits = .false. !validity assumed\n    !write(6,*)'expression:',e(1:len_trim(e))\n    do i=1, len_trim(e)\n       if (verify(e(i:i),'0123456789') == 0) then\n          j = index('0123456789',e(i:i))-1\n          unfound = .true.\n          do k=1, 4\n             if (j == d(k)) then\n                unfound = .false.\n                exit\n             end if\n          end do\n          if (unfound) then\n             invalid_digits = .true.\n             !return or exit is okay here\n          else\n             d(k) = -99\n             count = count + 1\n          end if\n       end if\n    end do\n    invalid_digits = invalid_digits .or. (count /= 4)\n  end function invalid_digits\n\n  subroutine deal(digits)\n    implicit none\n    integer, dimension(4), intent(out) :: digits\n    integer :: i\n    real :: harvest\n    call random_number(harvest)\n    do i=1, 4\n       digits(i) = int(mod(harvest*9**i, 9.0))   + 1\n    end do\n    !    NB. computed with executable Iverson notation, www.jsoftware.oom\n    !    #B NB. B are the digits from 9999 deals\n    ! 39996\n    !    ({.,#)/.~/:~B  # show the distribution of digits\n    ! 0 4380\n    ! 1 4542\n    ! 2 4348\n    ! 3 4395\n    ! 4 4451\n    ! 5 4474\n    ! 6 4467\n    ! 7 4413\n    ! 8 4526\n    !    NB. this also shows that I forgot to add 1.  Inserting now...\n  end subroutine deal\nend program g24\n\n\n$ gfortran -g -O0 -std=f2008 -Wall f.f08 -o f.exe && echo '8*(9/9+2)' | ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n   24.000000      close enough\n$ \n$ \n$ \n$ ./f.exe \n$  Using digits 9 9 8 2, and the algebraic dyadic\n$  operators +-*/() enter an expression computing 24.\n$     8 *   ( 9 / 9  +    2   )\n$    24.000000      close enough\n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n(((2+8+9+9)))\n   28.000000      no good\n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n(((8+9-2+9)))\n   24.000000      close enough\n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n8929\n \"9\" unexpected in expression at           2\nSTOP 1\n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n12348\n invalid digits\n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n892\n invalid digits\n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n8921\n invalid digits\n$ \n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n89291\n invalid digits\n$ \n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n9+x-2+8+9\n \"x\" unexpected in expression at           3\nSTOP 1\n$ \n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n(9-2)+8+(9\n \"^@\" unexpected in expression at         125\nSTOP 1\n$ \n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n(9-2)+8+(9)\n   24.000000      close enough\n$ \n$ \n$ \n$ ./f.exe\n Using digits 9 9 8 2, and the algebraic dyadic\n operators +-*/() enter an expression computing 24.\n(9-2)+8/(9)\n   7.8888888      no good\n$ \n\n", "explain": "Indicate operator precedence by parentheses; e.g. (3+(5*6))-9. No whitespace is admissible.\nThe program uses Insertion_sort in Fortran.\nPermits spaces and arbitrary parentheses.\nCompilation and too many examples.  Which would you cut?\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math\"\n    \"math/rand\"\n    \"time\"\n)\n\nfunc main() {\n    rand.Seed(time.Now().Unix())\n    n := make([]rune, 4)\n    for i := range n {\n        n[i] = rune(rand.Intn(9) + '1')\n    }\n    fmt.Printf(\"Your numbers: %c\\n\", n)\n    fmt.Print(\"Enter RPN: \")\n    var expr string\n    fmt.Scan(&expr)\n    if len(expr) != 7 {\n        fmt.Println(\"invalid. expression length must be 7.\" +\n            \" (4 numbers, 3 operators, no spaces)\")\n        return\n    }\n    stack := make([]float64, 0, 4)\n    for _, r := range expr {\n        if r >= '0' && r <= '9' {\n            if len(n) == 0 {\n                fmt.Println(\"too many numbers.\")\n                return\n            }\n            i := 0\n            for n[i] != r {\n                i++\n                if i == len(n) {\n                    fmt.Println(\"wrong numbers.\")\n                    return\n                }\n            }\n            n = append(n[:i], n[i+1:]...)\n            stack = append(stack, float64(r-'0'))\n            continue\n        }\n        if len(stack) < 2 {\n            fmt.Println(\"invalid expression syntax.\")\n            return\n        }\n        switch r {\n        case '+':\n            stack[len(stack)-2] += stack[len(stack)-1]\n        case '-':\n            stack[len(stack)-2] -= stack[len(stack)-1]\n        case '*':\n            stack[len(stack)-2] *= stack[len(stack)-1]\n        case '/':\n            stack[len(stack)-2] /= stack[len(stack)-1]\n        default:\n            fmt.Printf(\"%c invalid.\\n\", r)\n            return\n        }\n        stack = stack[:len(stack)-1]\n    }\n    if math.Abs(stack[0]-24) > 1e-6 {\n        fmt.Println(\"incorrect.\", stack[0], \"!= 24\")\n    } else {\n        fmt.Println(\"correct.\")\n    }\n}\n\n\nYour numbers: [5 8 1 3]\nEnter RPN: 83-5*1-\ncorrect.\n\n", "explain": "RPN solution.\nExample game:\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program game24.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ STDIN,      0       @ Linux input console\n.equ READ,       3       @ Linux syscall\n.equ NBDIGITS,   4       @ digits number\n.equ TOTAL,      24\n.equ BUFFERSIZE, 100\n.equ STACKSIZE,  10      @ operator and digits number items in stacks\n\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessRules:         .ascii \"24 Game\\n\"\n                    .ascii \"The program will display four randomly-generated \\n\"\n                    .ascii \"single-digit numbers and will then prompt you to enter\\n\"\n                    .ascii \"an arithmetic expression followed by <enter> to sum \\n\"\n                    .ascii \"the given numbers to 24.\\n\"\n                    .asciz \"Exemple\u00a0: 9+8+3+4   or (7+5)+(3*4) \\n\\n\"\n\nszMessExpr:         .asciz \"Enter your expression (or type (q)uit to exit or (n) for other digits): \\n\"\n//szMessErrChoise:    .asciz \"invalid choice.\\n \"\nszMessDigits:       .asciz \"The four digits are @ @ @ @ and the score is 24. \\n\"\nszMessNoDigit:      .asciz \"Error\u00a0: One digit is not in digits list\u00a0!! \\n\"\nszMessSameDigit:    .asciz \"Error\u00a0: Two digits are same\u00a0!! \\n\"\nszMessOK:           .asciz \"It is OK. \\n\"\nszMessNotOK:        .asciz \"Error, it is not ok  total = @ \\n\"\nszMessErrOper:      .asciz \"Unknow Operator (+,-,$,/,(,)) \\n\"\nszMessNoparen:      .asciz \"no opening parenthesis\u00a0!! \\n\"\nszMessErrParen:     .asciz \"Error parenthesis number\u00a0!! \\n\"\nszMessNoalldigits:  .asciz \"One or more digits not used\u00a0!!\\n\"\nszMessNewGame:      .asciz \"New game (y/n)\u00a0? \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n.align 4\niGraine:  .int 123456\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\nsBuffer:          .skip BUFFERSIZE\niTabDigit:        .skip 4 * NBDIGITS\niTabTopDigit:     .skip 4 * NBDIGITS\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                 @ entry of program \n    \n    ldr r0,iAdrszMessRules            @ display rules\n    bl affichageMess\n1:\n    mov r3,#0\n    ldr r12,iAdriTabDigit\n    ldr r11,iAdriTabTopDigit\n    ldr r5,iAdrszMessDigits\n2:                                    @ loop generate random digits \n    mov r0,#8\n    bl genereraleas \n    add r0,r0,#1\n    str r0,[r12,r3,lsl #2]            @ store in table\n    mov r1,#0\n    str r1,[r11,r3,lsl #2]            @ raz top table\n    ldr r1,iAdrsZoneConv\n    bl conversion10                   @ call decimal conversion\n    mov r2,#0\n    strb r2,[r1,r0]                   @ reduce size display area with z\u00e9ro final\n    mov r0,r5\n    ldr r1,iAdrsZoneConv              @ insert conversion in message\n    bl strInsertAtCharInc\n    mov r5,r0\n    add r3,r3,#1\n    cmp r3,#NBDIGITS                  @ end\u00a0?\n    blt 2b                            @ no -> loop\n    mov r0,r5\n    bl affichageMess\n3:                                    @ loop human entry\n    ldr r0,iAdrszMessExpr\n    bl affichageMess\n    bl saisie                         @ entry\n    cmp r0,#'q'\n    beq 100f\n    cmp r0,#'Q'\n    beq 100f\n    cmp r0,#'n'\n    beq 1b\n    cmp r0,#'N'\n    beq 1b\n \n    bl evalExpr                      @ expression evaluation\n    cmp r0,#0                        @ ok ?\n    bne 3b                           @ no - > loop\n\n10:                                  @ display new game ?\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    ldr r0,iAdrszMessNewGame\n    bl affichageMess\n    bl saisie\n    cmp r0,#'y'\n    beq 1b\n    cmp r0,#'Y'\n    beq 1b\n    \n100:                                  @ standard end of the program \n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessRules:          .int szMessRules\niAdrszMessDigits:         .int szMessDigits\niAdrszMessExpr:           .int szMessExpr\niAdrszMessNewGame:        .int szMessNewGame\niAdrsZoneConv:            .int sZoneConv\niAdriTabDigit:            .int iTabDigit\niAdriTabTopDigit:         .int iTabTopDigit\n/******************************************************************/\n/*            evaluation expression                                       */ \n/******************************************************************/\n/* r0 return 0 if ok -1 else */\nevalExpr:\n    push {r1-r11,lr}           @ save registers\n    \n    mov r0,#0\n    ldr r1,iAdriTabTopDigit\n    mov r2,#0\n1:                             @ loop init table top digits\n    str r0,[r1,r2,lsl #2]\n    add r2,r2,#1\n    cmp r2,#NBDIGITS\n    blt 1b\n    \n    sub sp,sp,#STACKSIZE * 4   @ stack operator\n    mov fp,sp\n    sub sp,sp,#STACKSIZE * 4   @ stack digit\n    mov r1,sp\n    ldr r10,iAdrsBuffer\n    mov r8,#0                  @ indice character in buffer\n    mov r7,#0                  @ indice digits stack\n    mov r2,#0                  @ indice operator stack\n1:                             @ begin loop\n    ldrb r9,[r10,r8]\n    cmp r9,#0xA               @ end expression ?\n    beq 90f\n    cmp r9,#' '               @ space \u00a0?\n    addeq r8,r8,#1             @ loop\n    beq 1b\n    cmp r9,#'('               @ left parenthesis -> store in operator stack\n    streq r9,[fp,r2,lsl #2]\n    addeq r2,r2,#1\n    addeq r8,r8,#1             @ and loop\n    beq 1b\n    cmp r9,#')'               @ right parenthesis\u00a0?\n    bne 3f\n    mov r0,fp                  @ compute operator stack until left parenthesis\n    sub r2,r2,#1\n2:\n    ldr r6,[fp,r2,lsl #2]\n    cmp r6,#'('                @ left parenthesis\n    addeq r8,r8,#1             @ end ?\n    beq 1b                     @ and loop\n    sub r7,r7,#1               @ last digit\n    mov r3,r7\n    bl compute\n    sub r2,r2,#1\n    cmp r2,#0\n    bge 2b\n    ldr r0,iAdrszMessNoparen   @ no left parenthesis in stack\n    bl affichageMess\n    mov r0,#-1\n    b 100f\n3:\n    cmp r9,#'+'               @ addition\n    beq 4f\n    cmp r9,#'-'               @ soustraction\n    beq 4f\n    cmp r9,#'*'               @ multiplication\n    beq 4f\n    cmp r9,#'/'               @ division\n    beq 4f\n\n    b 5f                       @ not operator\n\n4:                             @ control priority and depile stacks\n    mov r0,fp\n    mov r3,r7\n    mov r4,r9\n    bl depileOper\n    mov r7,r3\n    add r8,r8,#1\n    b 1b                       @ and loop \n \n5:                             @  digit\n    sub r9,r9,#0x30\n    mov r0,r9\n    bl digitControl\n    cmp r0,#0                  @ error ?\n    bne 100f\n    str r9,[r1,r7,lsl #2]     @ store digit in digits stack\n    add r7,r7,#1\n\n    add r8,r8,#1\n    beq 1b    \n\n    b 100f\n90:                            @ compute all stack operators\n    mov r0,fp\n    sub r7,r7,#1\n91:\n    subs r2,r2,#1\n    blt 92f\n    mov r3,r7\n    bl compute\n    sub r7,r7,#1\n    b 91b\n92: \n    ldr r0,[r1]                 @ total = first value on digits stack\n    cmp r0,#TOTAL               @ control total \n    beq 93f                     @ ok \n    ldr r1,iAdrsZoneConv\n    bl conversion10             @ call decimal conversion\n    mov r2,#0\n    strb r2,[r1,r0]\n    ldr r0,iAdrszMessNotOK\n    ldr r1,iAdrsZoneConv        @ insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess\n    mov r0,#-1\n    b 100f\n93:                             @ control use all digits\n    ldr r1,iAdriTabTopDigit\n    mov r2,#0\n94:                             @ begin loop\n    ldr r0,[r1,r2,lsl #2]       @ load top\n    cmp r0,#0            \n    bne 95f\n    ldr r0,iAdrszMessNoalldigits\n    bl affichageMess\n    mov r0,#-1\n    b 100f\n95:\n    add r2,r2,#1\n    cmp r2,#NBDIGITS\n    blt 94b\n96:                             @ display message OK\n    ldr r0,iAdrszMessOK\n    bl affichageMess\n    mov r0,#0\n    b 100f\n    \n100:\n    add sp,sp,#80               @ stack algnement\n    pop {r1-r11,lr}\n    bx lr                       @ return \niAdrszMessNoparen:        .int szMessNoparen\niAdrszMessNotOK:          .int szMessNotOK\niAdrszMessOK:             .int szMessOK\niAdrszMessNoalldigits:    .int szMessNoalldigits\n/******************************************************************/\n/*            depile operator                                     */ \n/******************************************************************/\n/* r0 operator stack address  */\n/* r1 digits stack address */\n/* r2 operator indice */\n/* r3 digits indice */\n/* r4 operator */\n/* r2 return a new operator indice */\n/* r3 return a new digits indice */\ndepileOper:\n    push {r4-r8,lr}        @ save registers\n    cmp r2,#0              @ first operator ?\n    beq 60f\n    sub r5,r2,#1\n1:\n    ldr r6,[r0,r5,lsl #2]  @ load stack operator\n    cmp r6,r4              @ same operators\n    beq 50f\n    cmp r6,#'*'            @ multiplication\n    beq 50f\n    cmp r6,#'/'            @ division\n    beq 50f\n    cmp r6,#'-'            @ soustraction\n    beq 50f\n    \n    b 60f\n50:                        @ depile operators stack and compute\n    sub r2,r2,#1\n    sub r3,r3,#1\n    bl compute\n    sub r5,r5,#1\n    cmp r5,#0\n    bge 1b\n60:\n    str r4,[r0,r2,lsl #2]  @ add operator in stack\n    add r2,r2,#1\n    \n100:\n    pop {r4-r8,lr}\n    bx lr                  @ return \n/******************************************************************/\n/*            compute                                             */ \n/******************************************************************/\n/* r0 operator stack address  */\n/* r1 digits stack address */\n/* r2 operator indice */\n/* r3 digits indice */\ncompute:\n    push {r1-r8,lr}        @ save registers\n    ldr r6,[r1,r3,lsl #2]  @ load second digit\n    sub r5,r3,#1\n    ldr r7,[r1,r5,lsl #2]  @ load first digit\n    \n    ldr r8,[r0,r2,lsl #2]  @ load operator\n    cmp r8,#'+'\n    bne 1f\n    add r7,r7,r6           @ addition\n    str r7,[r1,r5,lsl #2] \n    b 100f\n1:     \n    cmp r8,#'-'\n    bne 2f\n    sub r7,r7,r6           @ soustaction\n    str r7,[r1,r5,lsl #2] \n    b 100f\n2:\n    cmp r8,#'*'\n    bne 3f                 @ multiplication\n    mul r7,r6,r7\n    str r7,[r1,r5,lsl #2] \n    b 100f\n3:\n    cmp r8,#'/'\n    bne 4f\n    udiv r7,r7,r6          @ division\n    str r7,[r1,r5,lsl #2]\n    b 100f\n4:\n    cmp r8,#'('            @ left parenthesis\u00a0?\n    bne 5f\n    ldr r0,iAdrszMessErrParen @  error \n    bl affichageMess\n    mov r0,#-1\n    b 100f\n5:\n    ldr r0,iAdrszMessErrOper\n    bl affichageMess\n    mov r0,#-1\n100:\n    pop {r1-r8,lr}\n    bx lr                   @ return \niAdrszMessErrOper:   .int szMessErrOper\niAdrszMessErrParen:  .int szMessErrParen\n/******************************************************************/\n/*            control digits                                       */ \n/******************************************************************/\n/* r0 return 0 if OK 1 if  not digit   */\ndigitControl:\n    push {r1-r4,lr}        @ save registers\n    ldr r1,iAdriTabTopDigit\n    ldr r2,iAdriTabDigit\n    mov r3,#0\n1:\n    ldr r4,[r2,r3,lsl #2]  @ load digit\n    cmp r0,r4              @ equal ?\n    beq 2f                 @ yes\n    add r3,r3,#1           @ no -> loop\n    cmp r3,#NBDIGITS       @ end\u00a0?\n    blt 1b\n    ldr r0,iAdrszMessNoDigit @ error\n    bl affichageMess\n    mov r0,#1\n    b 100f\n2:                         @ control prev use \n    ldr r4,[r1,r3,lsl #2]\n    cmp r4,#0\n    beq 3f\n    add r3,r3,#1\n    cmp r3,#NBDIGITS\n    blt 1b\n    ldr r0,iAdrszMessSameDigit\n    bl affichageMess\n    mov r0,#1\n    b 100f\n3:\n    mov r4,#1\n    str r4,[r1,r3,lsl #2]\n    mov r0,#0\n100:\n    pop {r1-r4,lr}\n    bx lr                   @ return \niAdrszMessNoDigit:     .int szMessNoDigit\niAdrszMessSameDigit:   .int szMessSameDigit\n/******************************************************************/\n/*            string entry                                       */ \n/******************************************************************/\n/* r0 return the first character of human entry */\nsaisie:\n    push {r1-r7,lr}        @ save registers\n    mov r0,#STDIN          @ Linux input console\n    ldr r1,iAdrsBuffer     @ buffer address \n    mov r2,#BUFFERSIZE     @ buffer size \n    mov r7,#READ           @ request to read datas\n    svc 0                  @ call system\n    ldr r1,iAdrsBuffer     @ buffer address \n    ldrb r0,[r1]           @ load first character\n100:\n    pop {r1-r7,lr}\n    bx lr                   @ return \niAdrsBuffer:         .int sBuffer\n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* r0 contains limit  */\ngenereraleas:\n    push {r1-r4,lr}         @ save registers \n    ldr r4,iAdriGraine\n    ldr r2,[r4]\n    ldr r3,iNbDep1\n    mul r2,r3,r2\n    ldr r3,iNbDep2\n    add r2,r2,r3\n    str r2,[r4]             @ maj de la graine pour l appel suivant \n    cmp r0,#0\n    beq 100f\n    add r1,r0,#1            @ divisor\n    mov r0,r2               @ dividende\n    bl division\n    mov r0,r3               @ r\u00e9sult = remainder\n  \n100:                        @ end function\n    pop {r1-r4,lr}          @ restaur registers\n    bx lr                   @ return\n/*****************************************************/\niAdriGraine: .int iGraine\niNbDep1:     .int 0x343FD\niNbDep2:     .int 0x269EC3 \n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\n24 Game\nThe program will display four randomly-generated\nsingle-digit numbers and will then prompt you to enter\nan arithmetic expression followed by <enter> to sum\nthe given numbers to 24.\nExemple\u00a0: 9+8+3+4   or (7+5)+(3*4)\n\nThe four digits are 5 1 1 5 and the score is 24.\nEnter your expression (or type (q)uit to exit or (n) for other digits):\nn\nThe four digits are 8 2 5 3 and the score is 24.\nEnter your expression (or type (q)uit to exit or (n) for other digits):\n(8*2)+5+3\nIt is OK.\n\nNew game (y/n)\u00a0?\n\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\nvar ErrorFlag: boolean;\nvar ErrorStr: string;\n\n\nfunction EvaluateExpression(Express: string): double;\n{ Recursive descent expression evaluator }\nvar Atom: char;\nvar ExpressStr: string;\nvar ExpressInx: integer;\nconst Tab_Char = #$09; SP_char = #$20;\n\n\tprocedure HandleError(S: string);\n\tbegin\n\tErrorStr:=S;\n\tErrorFlag:=True;\n\tAbort;\n\tend;\n\n\n\tprocedure GetChar;\n\tbegin\n\tif ExpressInx > Length(ExpressStr) then\n\t\tbegin\n\t\tAtom:= ')';\n\t\tend\n\t else\tbegin\n\t\tAtom:= ExpressStr[ExpressInx];\n\t\tInc(ExpressInx);\n\t\tend;\n\tend;\n\n\n\n\tprocedure SkipWhiteSpace;\n\t{ Skip Tabs And Spaces In Expression }\n\tbegin\n\twhile (Atom=TAB_Char) or (Atom=SP_char) do GetChar;\n\tend;\n\n\n\n\tprocedure SkipSpaces;\n\t{ Get Next Character, Ignoring Any Space Characters }\n\tbegin\n\trepeat GetChar until Atom <> SP_CHAR;\n\tend;\n\n\n\n\tfunction GetDecimal: integer;\n\t{ Read In A Decimal String And Return Its Value }\n\tvar S: string;\n\tbegin\n\tResult:=0;\n\tS:='';\n\twhile True do\n\t\tbegin\n\t\tif not (Atom in ['0'..'9']) then break;\n\t\tS:=S+Atom;\n\t\tGetChar;\n\t\tend;\n\tif S='' then HandleError('Number Expected')\n\telse Result:=StrToInt(S);\n\tif Result>9 then HandleError('Only Numbers 0..9 allowed')\n\tend;\n\n\n\tfunction Expression: double;\n\t{ Returns The Value Of An Expression }\n\n\n\n\t\tfunction Factor: double;\n\t\t{ Returns The Value Of A Factor }\n\t\tvar NEG: boolean;\n\t\tbegin\n\t\tResult:=0;\n\t\twhile Atom='+' do SkipSpaces;\t\t{ Ignore Unary \"+\" }\n\t\tNEG:= False;\n\t\twhile Atom ='-' do\t\t\t{ Unary \"-\" }\n\t\t\tbegin\n\t\t\tSkipSpaces;\n\t\t\tNEG:= not NEG;\n\t\t\tend;\n\n\t\tif (Atom>='0') and (Atom<='9') then Result:= GetDecimal\t{ Unsigned Integer }\n\t\telse case Atom of\n\t\t  '(':\tbegin\t\t\t\t{ Subexpression }\n\t\t\tSkipSpaces;\n\t\t\tResult:= Expression;\n\t\t\tif Atom<>')' then HandleError('Mismatched Parenthesis');\n\t\t\tSkipSpaces;\n\t\t\tend;\n\t\t  else\tHandleError('Syntax Error');\n\t\t  end;\n\t\t{ Numbers May Terminate With A Space Or Tab }\n\t\tSkipWhiteSpace;\n\t\tif NEG then Result:=-Result;\n\t\tend;\t{ Factor }\n\n\n\n\t\tfunction Term: double;\n\t\t{ Returns Factor * Factor, Etc. }\n\t\tvar R: double;\n\t\tbegin\n\t\tResult:= Factor;\n\t\twhile True do\n\t\t\tcase Atom of\n\t\t\t  '*':\tbegin\n\t\t\t  \tSkipSpaces;\n\t\t\t  \tResult:= Result * Factor;\n\t\t\t  \tend;\n\t\t\t  '/':\tbegin\n\t\t\t  \tSkipSpaces;\n\t\t\t  \tR:=Factor;\n\t\t\t  \tif R=0 then HandleError('Divide By Zero');\n\t\t\t  \tResult:= Result / R;\n\t\t\t  \tend;\n\t\t\t  else\tbreak;\n\t\t\tend;\n\t\tend;\n\t\t{ Term }\n\n\n\n\t\tfunction AlgebraicExpression: double;\n\t\t{ Returns Term + Term, Etc. }\n\t\tbegin\n\t\tResult:= Term;\n\t\twhile True do\n\t\t\tcase Atom of\n\t\t\t  '+':\tbegin SkipSpaces; Result:= Result + Term; end;\n\t\t\t  '-':\tbegin SkipSpaces; Result:= Result - Term; end\n\t\t\telse\tbreak;\n\t\t\tend;\n\t\tend; { Algexp }\n\n\n\n\tbegin\t{ Expression }\n\tSkipWhiteSpace;\n\tResult:= AlgebraicExpression;\n\tend;\t{ Expression }\n\n\n\nbegin\t{ EvaluateExpression }\nErrorFlag:=False;\nErrorStr:='';\nExpressStr:=Express;\nExpressInx:=1;\ntry\nGetChar;\nResult:= Expression;\nexcept end;\nend;\n\n\nfunction WaitForString(Memo: TMemo; Prompt: string): string;\n{Wait for key stroke on TMemo component}\nvar MW: TMemoWaiter;\nvar C: char;\nvar Y: integer;\nbegin\n{Use custom object to wait and capture key strokes}\nMW:=TMemoWaiter.Create(Memo);\ntry\nMemo.Lines.Add(Prompt);\nMemo.SelStart:=Memo.SelStart-1;\nMemo.SetFocus;\nResult:=MW.WaitForLine;\nfinally MW.Free; end;\nend;\n\n\n\n\n\nprocedure Play24Game(Memo: TMemo);\n{Play the 24 game}\nvar R: double;\nvar Nums: array [0..4-1] of char;\nvar I: integer;\nvar Express,RS: string;\nvar RB: boolean;\n\n\tprocedure GenerateNumbers;\n\t{Generate and display four random number 1..9}\n\tvar S: string;\n\tvar I: integer;\n\tbegin\n\t{Generate random numbers}\n\tfor I:=0 to High(Nums) do\n\t Nums[I]:=char(Random(9)+$31);\n\t{Display them}\n\tS:='';\n\tfor I:=0 to High(Nums) do\n\t S:=S+' '+Nums[I];\n\tMemo.Lines.Add('Your Digits: '+S);\n\tend;\n\n\tfunction TestMatchingNums: boolean;\n\t{Make sure numbers entered by user match the target numbers}\n\tvar SL1,SL2: TStringList;\n\tvar I: integer;\n\tbegin\n\tResult:=False;\n\tSL1:=TStringList.Create;\n\tSL2:=TStringList.Create;\n\ttry\n\t{Load target numbers into string list}\n\tfor I:=0 to High(Nums) do SL1.Add(Nums[I]);\n\t{Load users expression number int string list}\n\tfor I:=1 to Length(Express) do\n\t if Express[I] in ['0'..'9'] then SL2.Add(Express[I]);\n\t{There should be the same number }\n\tif SL1.Count<>SL2.Count then exit;\n\t{Sort them to facilitate testing}\n\tSL1.Sort; SL2.Sort;\n\t{Are number identical, if not exit}\n\tfor I:=0 to SL1.Count-1 do\n\t if SL1[I]<>SL2[I] then exit;\n\t{Users numbers passed all tests}\n\tResult:=True;\n\tfinally\n\t SL2.Free;\n\t SL1.Free;\n\t end;\n\tend;\n\n\tfunction TestUserExpression(var S: string): boolean;\n\t{Test expression user entered }\n\tbegin\n\tResult:=False;\n\tif not TestMatchingNums then\n\t\tbegin\n\t\tS:='Numbers Do not Match';\n\t\texit;\n\t\tend;\n\n\tR:=EvaluateExpression(Express);\n\tS:='Expression Value = '+FloatToStrF(R,ffFixed,18,0)+CRLF;\n\tif ErrorFlag then\n\t\tbegin\n\t\tS:=S+'Expression Problem: '+ErrorStr;\n\t\texit;\n\t\tend;\n\tif R<>24 then\n\t\tbegin\n\t\tS:=S+'Expression is incorrect value';\n\t\texit;\n\t\tend;\n\tS:=S+'!!!!!! Winner\u00a0!!!!!!!';\n\tResult:=True;\n\tend;\n\n\nbegin\nRandomize;\nMemo.Lines.Add('=========== 24 Game ===========');\nGenerateNumbers;\nwhile true do\n\tbegin\n\tif Application.Terminated then exit;\n\tExpress:=WaitForString(Memo,'Enter expression, Q = quit, N = New numbers: '+CRLF);\n\tif Pos('N',UpperCase(Express))>0 then\n\t\tbegin\n\t\tGenerateNumbers;\n\t\tContinue;\n\t\tend;\n\tif Pos('Q',UpperCase(Express))>0 then exit;\n\tRB:=TestUserExpression(RS);\n\tMemo.Lines.Add(RS);\n\tif not RB then continue;\n\tRS:=WaitForString(Memo,'Play again Y=Yes, N=No'+CRLF);\n\tif Pos('N',UpperCase(RS))>0 then exit;\n\tGenerateNumbers;\n\tend;\nend;\n\n\nOutput:\n=========== 24 Game ===========\nYour Digits:  8 2 5 5\nEnter expression, Q = quit, N = New numbers: \n\nn\n\nYour Digits:  3 1 9 3\nEnter expression, Q = quit, N = New numbers: \n\n3 * 9 -3\n\nNumbers Do not Match\nEnter expression, Q = quit, N = New numbers: \n\n3 * 9 - 3 * 1\n\nExpression Value = 24\n!!!!!! Winner\u00a0!!!!!!!\nPlay again Y=Yes, N=No\n\n\n\n\n", "explain": "Program includes full recursive descent, expression evaluator that can handle any expression the user might eneter. \n\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Ruby", "code": "\nclass Guess < String\n  def self.play\n    nums = Array.new(4){rand(1..9)}\n    loop do\n      result = get(nums).evaluate!\n      break if result == 24.0\n      puts \"Try again! That gives #{result}!\"\n    end\n    puts \"You win!\"\n  end\n  \n  def self.get(nums)\n    loop do\n      print \"\\nEnter a guess using #{nums}: \"\n      input = gets.chomp\n      return new(input) if validate(input, nums)\n    end\n  end\n  \n  def self.validate(guess, nums)\n    name, error =\n      {\n        invalid_character:  ->(str){ !str.scan(%r{[^\\d\\s()+*/-]}).empty? },\n        wrong_number:       ->(str){ str.scan(/\\d/).map(&:to_i).sort != nums.sort },\n        multi_digit_number: ->(str){ str.match(/\\d\\d/) }\n      }\n        .find {|name, validator| validator[guess] }\n    \n    error ? puts(\"Invalid input of a(n) #{name.to_s.tr('_',' ')}!\") : true\n  end\n  \n  def evaluate!\n    as_rat = gsub(/(\\d)/, '\\1r')        # r\u00a0: Rational suffix\n    eval \"(#{as_rat}).to_f\"\n  rescue SyntaxError\n    \"[syntax error]\"\n  end\nend\n\nGuess.play\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Rust", "code": "\n\nLibrary: rand\nuse std::io::{self,BufRead};\nextern crate rand;\nuse rand::Rng;\n\nfn op_type(x: char) -> i32{\n    match x {\n        '-' | '+' => return 1,\n        '/' | '*' => return 2,\n        '(' | ')' => return -1,\n        _   => return 0,\n    }\n}\n\nfn to_rpn(input: &mut String){\n\n    let mut rpn_string : String = String::new();\n    let mut rpn_stack : String = String::new();\n    let mut last_token = '#';\n    for token in input.chars(){\n        if token.is_digit(10) {\n            rpn_string.push(token);\n        }\n        else if op_type(token) == 0 {\n            continue;\n        }\n        else if op_type(token) > op_type(last_token) || token == '(' {\n                rpn_stack.push(token);\n                last_token=token;\n        }\n        else {\n            while let Some(top) = rpn_stack.pop() {\n                if top=='(' {\n                    break;\n                }\n                rpn_string.push(top);\n            }\n            if token != ')'{\n                rpn_stack.push(token);\n            }\n        }\n    }\n    while let Some(top) = rpn_stack.pop() {\n        rpn_string.push(top);\n    }\n\n    println!(\"you formula results in {}\", rpn_string);\n\n    *input=rpn_string;\n}\n\nfn calculate(input: &String, list : &mut [u32;4]) -> f32{\n    let mut stack : Vec<f32> = Vec::new();\n    let mut accumulator : f32 = 0.0;\n\n    for token in input.chars(){\n        if token.is_digit(10) {\n            let test = token.to_digit(10).unwrap() as u32;\n            match list.iter().position(|&x| x == test){\n                Some(idx) => list[idx]=10 ,\n                _         => println!(\" invalid digit: {} \",test),\n            }\n            stack.push(accumulator);\n            accumulator = test as f32;\n        }else{\n            let a = stack.pop().unwrap();\n            accumulator = match token {\n                '-' => a-accumulator,\n                '+' => a+accumulator,\n                '/' => a/accumulator,\n                '*' => a*accumulator,\n                _ => {accumulator},//NOP\n            };\n        }\n    }\n    println!(\"you formula results in {}\",accumulator);\n    accumulator\n}\n\nfn main() {\n\n    let mut rng = rand::thread_rng();\n    let mut list :[u32;4]=[rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10,rng.gen::<u32>()%10];\n\n    println!(\"form 24 with using + - / * {:?}\",list);\n    //get user input\n    let mut input = String::new();\n    io::stdin().read_line(&mut input).unwrap();\n    //convert to rpn\n    to_rpn(&mut input);\n    let result = calculate(&input, &mut list);\n\n    if list.iter().any(|&list| list !=10){\n        println!(\"and you used all numbers\");\n        match result {\n            24.0 => println!(\"you won\"),\n            _ => println!(\"but your formulla doesn't result in 24\"),\n        }\n    }else{\n        println!(\"you didn't use all the numbers\");\n    }\n\n}\n\n", "explain": "The solution below converts the infix notation to RPN and then calculates the result.\nI am still new to Rust so i am certain it could be written in a shorter way.\nSo if there is someone better than me please feel free to improve. \n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Swift", "code": "\nimport Darwin\nimport Foundation\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> Int[] {\n    var result = Int[]();\n    for var i = 0; i < 4; i++ {\n        result.append(Int(arc4random_uniform(9)+1))\n    }\n    return result;\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n    print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)\n\nvar enteredDigits = Int[]()\n\nvar enteredOperations = Character[]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n    switch character {\n        case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n            let digit = String(character)\n            enteredDigits.append(digit.toInt()!)\n        case \"+\", \"-\", \"*\", \"/\":\n            enteredOperations.append(character)\n        case \"\\n\":\n            println()\n        default:\n            println(\"Invalid expression\")\n    }\n}\n\n// check value of expression provided by the operator\nvar value = Int()\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n    value = enteredDigits[0]\n    for (i, operation) in enumerate(enteredOperations) {\n        switch operation {\n            case \"+\":\n                value = value + enteredDigits[i+1]\n            case \"-\":\n                value = value - enteredDigits[i+1]\n            case \"*\":\n                value = value * enteredDigits[i+1]\n            case \"/\":\n                value = value / enteredDigits[i+1]\n            default:\n                println(\"This message should never happen!\")\n        }\n    }\n}\n\nif value != 24 {\n    println(\"The value of the provided expression is \\(value) instead of 24!\")\n} else {\n    println(\"Congratulations, you found a solution!\")\n}\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "R", "code": "\n\ntwenty.four <- function(operators=c(\"+\", \"-\", \"*\", \"/\", \"(\"),\n                        selector=function() sample(1:9, 4, replace=TRUE),\n                        arguments=selector(),\n                        goal=24) {\n  newdigits <- function() {\n    arguments <<- selector()\n    cat(\"New digits:\", paste(arguments, collapse=\", \"), \"\\n\")\n  } \n  help <- function() cat(\"Make\", goal,\n      \"out of the numbers\",paste(arguments, collapse=\", \"),\n      \"and the operators\",paste(operators, collapse=\", \"), \".\",\n      \"\\nEnter 'q' to quit, '!' to select new digits,\",\n      \"or '?' to repeat this message.\\n\")\n  help()\n  repeat {\n    switch(input <- readline(prompt=\"> \"),\n           q={ cat(\"Goodbye!\\n\"); break },\n           `?`=help(),\n           `!`=newdigits(),\n           tryCatch({\n             expr <- parse(text=input, n=1)[[1]]\n             check.call(expr, operators, arguments)\n             result <- eval(expr)\n             if (isTRUE(all.equal(result, goal))) {\n               cat(\"Correct!\\n\")\n               newdigits()\n             } else {\n               cat(\"Evaluated to\", result, \"( goal\", goal, \")\\n\")\n             }\n           },error=function(e) cat(e$message, \"\\n\")))\n  }\n}\n\ncheck.call <- function(expr, operators, arguments) {\n  unexpr <- function(x) {\n    if (is.call(x))\n      unexpr(as.list(x))\n    else if (is.list(x))\n      lapply(x,unexpr)\n    else x\n  }\n  leaves <- unlist(unexpr(expr))\n  if (any(disallowed <-\n          !leaves %in% c(lapply(operators, as.name),\n                         as.list(arguments)))) {\n    stop(\"'\", paste(sapply(leaves[disallowed], as.character),\n                    collapse=\", \"),\n         \"' not allowed. \")\n  }\n  numbers.used <- unlist(leaves[sapply(leaves, mode) == 'numeric'])\n  \n  if (! isTRUE(all.equal(sort(numbers.used), sort(arguments))))\n   stop(\"Must use each number once.\")\n}\n\n\n> twenty.four()\n\nMake 24 out of the numbers 1, 6, 7, 5 and the operators +, -, *, /, ( . \nEnter 'q' to quit, '!' to select new digits, or '?' to repeat this message.\n> 6*(5-1)\nMust use each number once. \n> 1 + 6*5 - 7\nCorrect!\nNew digits: 7, 2, 9, 3 \n> (7+9)/2*3\nCorrect!\nNew digits: 1, 4, 1, 7 \n> 4*(7-1)\nMust use each number once. \n> (7-1)*4*1\nCorrect!\nNew digits: 1, 5, 2, 8 \n> (5-1)^2+8\n'^' not allowed.\n> !\nNew digits: 2, 8, 5, 2 \n> 52-28\n'52, 28' not allowed.\n> (8-2)*(5-2/2)\nMust use each number once. \n> (8+2)*2+5\nEvaluated to 25 ( goal 24 )\n> q\nGoodbye!\n\n", "explain": "This makes use of R's metaprogramming (parse, eval, etc.). It uses parse to obtain a parse tree, which is scanned for containing only permitted elements before evaluating.\nExample Session\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "COBOL", "code": "\n        >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\n*> This is GNUCobol 2.0\nidentification division.\nprogram-id. twentyfour.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ndata division.\nworking-storage section.\n01  p pic 999.\n01  p1 pic 999.\n01  p-max pic 999 value 38.\n01  program-syntax pic x(494) value\n*>statement = expression;\n        '001 001 000 n'\n    &   '002 000 004 ='\n    &   '003 005 000 n'\n    &   '004 000 002\u00a0;'\n*>expression = term, {('+'|'-') term,};\n    &   '005 005 000 n'\n    &   '006 000 016 ='\n    &   '007 017 000 n'\n    &   '008 000 015 {'\n    &   '009 011 013 ('\n    &   '010 001 000 t'\n    &   '011 013 000 |'\n    &   '012 002 000 t'\n    &   '013 000 009 )'\n    &   '014 017 000 n'\n    &   '015 000 008 }'\n    &   '016 000 006\u00a0;'\n*>term = factor, {('*'|'/') factor,};\n    &   '017 017 000 n'\n    &   '018 000 028 ='\n    &   '019 029 000 n'\n    &   '020 000 027 {'\n    &   '021 023 025 ('\n    &   '022 003 000 t'\n    &   '023 025 000 |'\n    &   '024 004 000 t'\n    &   '025 000 021 )'\n    &   '026 029 000 n'\n    &   '027 000 020 }'\n    &   '028 000 018\u00a0;'\n*>factor = ('(' expression, ')' | digit,);\n    &   '029 029 000 n'\n    &   '030 000 038 ='\n    &   '031 035 037 ('\n    &   '032 005 000 t'\n    &   '033 005 000 n'\n    &   '034 006 000 t'\n    &   '035 037 000 |'\n    &   '036 000 000 n'\n    &   '037 000 031 )'\n    &   '038 000 030\u00a0;'.\n01  filler redefines program-syntax.\n    03  p-entry occurs 038.\n        05  p-address pic 999.\n        05  filler pic x.\n        05  p-definition pic 999.\n        05  p-alternate redefines p-definition pic 999.\n        05  filler pic x.\n        05  p-matching pic 999.\n        05  filler pic x.\n        05  p-symbol pic x.\n\n01  t pic 999.\n01  t-len pic 99 value 6.\n01  terminal-symbols\n    pic x(210) value\n        '01 +                               '                                                               \n    &   '01 -                               '                                                               \n    &   '01 *                               '\n    &   '01 /                               '\n    &   '01 (                               '\n    &   '01 )                               '.\n01  filler redefines terminal-symbols.\n    03  terminal-symbol-entry occurs 6.\n        05  terminal-symbol-len pic 99.\n        05  filler pic x.\n        05  terminal-symbol pic x(32).\n\n01  nt pic 999.\n01  nt-lim pic 99 value 5.\n01  nonterminal-statements pic x(294) value\n        \"000 ....,....,....,....,....,....,....,....,....,\"\n    &   \"001 statement = expression;                      \"                                                       \n    &   \"005 expression = term, {('+'|'-') term,};        \"                                                      \n    &   \"017 term = factor, {('*'|'/') factor,};          \"                                                             \n    &   \"029 factor = ('(' expression, ')' | digit,);     \"                                                           \n    &   \"036 digit;                                       \".                                                            \n01  filler redefines nonterminal-statements.\n    03  nonterminal-statement-entry occurs 5.\n        05  nonterminal-statement-number pic 999.\n        05  filler pic x.\n        05  nonterminal-statement pic x(45).\n\n01  indent pic x(64) value all '|  '. \n01  interpreter-stack.\n    03  r pic 99. *> previous top of stack\n    03  s pic 99. *> current top of stack\n    03  s-max pic 99 value 32.\n    03  s-entry occurs 32.\n        05  filler pic x(2) value 'p='.\n        05  s-p pic 999. *> callers return address\n        05  filler pic x(4) value ' sc='.\n        05  s-start-control pic 999. *> sequence start address\n        05  filler pic x(4) value ' ec='.\n        05  s-end-control pic 999. *> sequence end address\n        05  filler pic x(4) value ' al='.\n        05  s-alternate pic 999. *> the next alternate \n        05  filler pic x(3) value ' r='.\n        05  s-result pic x. *> S success, F failure, N no result\n        05  filler pic x(3) value ' c='.\n        05  s-count pic 99. *> successes in a sequence\n        05  filler pic x(3) value ' x='.\n        05  s-repeat pic 99. *> repeats in a {} sequence\n        05  filler pic x(4) value ' nt='.\n        05  s-nt pic 99. *> current nonterminal\n\n01  language-area.\n    03  l pic 99.\n    03  l-lim pic 99.\n    03  l-len pic 99 value 1.\n    03  nd pic 9.\n    03  number-definitions.\n        05  n occurs 4 pic 9.\n    03  nu pic 9.\n    03  number-use.\n        05  u occurs 4 pic x.\n    03  statement.\n        05  c occurs 32.\n            07  c9 pic 9.\n\n01  number-validation.\n    03  p4 pic 99.\n    03  p4-lim pic 99 value 24.\n    03  permutations-4 pic x(96) value\n          '1234'\n        & '1243'\n        & '1324'\n        & '1342'\n        & '1423'\n        & '1432'\n        & '2134'\n        & '2143'\n        & '2314'\n        & '2341'\n        & '2413'\n        & '2431'\n        & '3124'\n        & '3142'\n        & '3214'\n        & '3241'\n        & '3423'\n        & '3432'\n        & '4123'\n        & '4132'\n        & '4213'\n        & '4231'\n        & '4312'\n        & '4321'.\n     03  filler redefines permutations-4.\n         05  permutation-4 occurs 24 pic x(4).\n     03  current-permutation-4 pic x(4).\n     03  cpx pic 9.\n     03  od1 pic 9.\n     03  od2 pic 9.\n     03  odx pic 9.\n     03  od-lim pic 9 value 4.\n     03  operator-definitions pic x(4) value '+-*/'.\n     03  current-operators pic x(3).\n     03  co3 pic 9.\n     03  rpx pic 9.\n     03  rpx-lim pic 9 value 4.\n     03  valid-rpn-forms pic x(28) value\n          'nnonono'\n        & 'nnnonoo'\n        & 'nnnoono'\n        & 'nnnnooo'.\n    03  filler redefines valid-rpn-forms.\n        05  rpn-form occurs 4 pic x(7).\n    03  current-rpn-form pic x(7).\n\n01  calculation-area.\n    03  osx pic 99.\n    03  operator-stack pic x(32).\n    03  oqx pic 99.\n    03  oqx1 pic 99.\n    03  output-queue pic x(32).\n    03  work-number pic s9999.\n    03  top-numerator pic s9999 sign leading separate.\n    03  top-denominator pic s9999 sign leading separate.\n    03  rsx pic 9.\n    03  result-stack occurs 8.\n        05  numerator pic s9999.\n        05  denominator pic s9999.\n\n01  error-found pic x.\n01  divide-by-zero-error pic x.\n\n*>  diagnostics\n01  NL pic x value x'0A'.\n01  NL-flag pic x value space.\n01  display-level pic x value '0'.\n01  loop-lim pic 9999 value 1500.\n01  loop-count pic 9999 value 0.\n01  message-area value spaces.\n    03  message-level pic x.\n    03  message-value pic x(128).\n\n*>  input and examples\n01  instruction pic x(32) value spaces.\n01  tsx pic 99.\n01  tsx-lim pic 99 value 14.\n01  test-statements.\n    03  filler pic x(32) value '1234;1 + 2 + 3 + 4'.\n    03  filler pic x(32) value '1234;1 * 2 * 3 * 4'. \n    03  filler pic x(32) value '1234;((1)) * (((2 * 3))) * 4'. \n    03  filler pic x(32) value '1234;((1)) * ((2 * 3))) * 4'. \n    03  filler pic x(32) value '1234;(1 + 2 + 3 + 4'. \n    03  filler pic x(32) value '1234;)1 + 2 + 3 + 4'. \n    03  filler pic x(32) value '1234;1 * * 2 * 3 * 4'. \n    03  filler pic x(32) value '5679;6 - (5 - 7) * 9'. \n    03  filler pic x(32) value '1268;((1 * (8 * 6) / 2))'. \n    03  filler pic x(32) value '4583;-5-3+(8*4)'. \n    03  filler pic x(32) value '4583;8 * 4 - 5 - 3'. \n    03  filler pic x(32) value '4583;8 * 4 - (5 + 3)'. \n    03  filler pic x(32) value '1223;1 * 3 / (2 - 2)'. \n    03  filler pic x(32) value '2468;(6 * 8) / 4 / 2'. \n01  filler redefines test-statements.\n    03  filler occurs 14.\n        05  test-numbers pic x(4).\n        05  filler pic x.\n        05  test-statement pic x(27).\n\nprocedure division.\nstart-twentyfour.\n    display 'start twentyfour'\n    perform generate-numbers\n    display 'type h <enter> to see instructions'\n    accept instruction\n    perform until instruction = spaces or 'q'\n        evaluate true\n        when instruction = 'h'\n            perform display-instructions\n        when instruction = 'n'\n            perform generate-numbers\n        when instruction(1:1) = 'm'\n            move instruction(2:4) to number-definitions\n            perform validate-number\n            if divide-by-zero-error = space\n            and 24 * top-denominator = top-numerator\n                display number-definitions ' is solved by ' output-queue(1:oqx)\n            else\n                display number-definitions ' is not solvable'\n            end-if\n        when instruction = 'd0' or 'd1' or 'd2' or 'd3'\n            move instruction(2:1) to display-level\n        when instruction = 'e'\n            display 'examples:'\n            perform varying tsx from 1 by 1\n            until tsx > tsx-lim\n                move spaces to statement\n                move test-numbers(tsx) to number-definitions\n                move test-statement(tsx) to statement\n                perform evaluate-statement\n                perform show-result\n            end-perform\n        when other\n            move instruction to statement\n            perform evaluate-statement\n            perform show-result\n        end-evaluate\n        move spaces to instruction\n        display 'instruction? ' with no advancing\n        accept instruction\n    end-perform\n\n    display 'exit twentyfour'\n    stop run\n    .\ngenerate-numbers.\n    perform with test after until divide-by-zero-error = space\n    and 24 * top-denominator = top-numerator\n        compute n(1) = random(seconds-past-midnight) * 10 *> seed\n        perform varying nd from 1 by 1 until nd > 4\n            compute n(nd) = random() * 10\n            perform until n(nd) <> 0\n                compute n(nd) = random() * 10\n            end-perform\n        end-perform\n        perform validate-number\n    end-perform\n    display NL 'numbers:' with no advancing\n    perform varying nd from 1 by 1 until nd > 4\n        display space n(nd) with no advancing\n    end-perform\n    display space\n    .\nvalidate-number.\n    perform varying p4 from 1 by 1 until p4 > p4-lim\n        move permutation-4(p4) to current-permutation-4 \n        perform varying od1 from 1 by 1 until od1 > od-lim\n            move operator-definitions(od1:1) to current-operators(1:1)\n            perform varying od2 from 1 by 1 until od2 > od-lim\n                move operator-definitions(od2:1) to current-operators(2:1)\n                perform varying odx from 1 by 1 until odx > od-lim\n                    move operator-definitions(odx:1) to current-operators(3:1)\n                    perform varying rpx from 1 by 1 until rpx > rpx-lim\n                        move rpn-form(rpx) to current-rpn-form\n                        move 0 to cpx co3\n                        move spaces to output-queue\n                        move 7 to oqx\n                        perform varying oqx1 from 1 by 1 until oqx1 > oqx\n                            if current-rpn-form(oqx1:1) = 'n'\n                                add 1 to cpx\n                                move current-permutation-4(cpx:1) to nd\n                                move n(nd) to output-queue(oqx1:1)\n                            else\n                                add 1 to co3\n                                move current-operators(co3:1) to output-queue(oqx1:1)\n                            end-if\n                        end-perform\n                    end-perform\n                    perform evaluate-rpn\n                    if divide-by-zero-error = space\n                    and 24 * top-denominator = top-numerator\n                        exit paragraph\n                    end-if\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    .  \ndisplay-instructions.\n    display '1)  Type h <enter> to repeat these instructions.'\n    display '2)  The program will display four randomly-generated'\n    display '    single-digit numbers and will then prompt you to enter'\n    display '    an arithmetic expression followed by <enter> to sum'\n    display '    the given numbers to 24.'\n    display '    The four numbers may contain duplicates and the entered'\n    display '    expression must reference all the generated numbers and duplicates.'\n    display '    Warning:  the program converts the entered infix expression'\n    display '    to a reverse polish notation (rpn) expression'\n    display '    which is then interpreted from RIGHT to LEFT.'\n    display '    So, for instance, 8*4 - 5 - 3 will not sum to 24.' \n    display '3)  Type n <enter> to generate a new set of four numbers.'\n    display '    The program will ensure the generated numbers are solvable.'\n    display '4)  Type m#### <enter> (e.g. m1234) to create a fixed set of numbers'\n    display '    for testing purposes.'\n    display '    The program will test the solvability of the entered numbers.'\n    display '    For example, m1234 is solvable and m9999 is not solvable.'\n    display '5)  Type d0, d1, d2 or d3 followed by <enter> to display none or'\n    display '    increasingly detailed diagnostic information as the program evaluates' \n    display '    the entered expression.'\n    display '6)  Type e <enter> to see a list of example expressions and results'\n    display '7)  Type <enter> or q <enter> to exit the program' \n    .\nshow-result.\n    if error-found = 'y'\n    or divide-by-zero-error = 'y'\n        exit paragraph\n    end-if\n    display 'statement in RPN is' space output-queue\n    evaluate true\n    when top-numerator = 0\n    when top-denominator = 0\n    when 24 * top-denominator <> top-numerator\n        display 'result (' top-numerator '/' top-denominator ') is not 24'\n    when other\n        display 'result is 24'\n    end-evaluate\n    .\nevaluate-statement.\n    compute l-lim = length(trim(statement))\n\n    display NL 'numbers:' space n(1) space n(2) space n(3) space n(4)\n    move number-definitions to number-use\n    display 'statement is' space statement  \n\n    move 1 to l\n    move 0 to loop-count\n    move space to error-found\n\n    move 0 to osx oqx\n    move spaces to output-queue\n\n    move 1 to p\n    move 1 to nt\n    move 0 to s\n    perform increment-s\n    perform display-start-nonterminal\n    perform increment-p\n\n    *>===================================\n    *> interpret ebnf\n    *>=================================== \n    perform until s = 0 \n    or error-found = 'y'\n\n        evaluate true\n\n        when p-symbol(p) = 'n'\n        and p-definition(p) = 000 *> a variable\n           perform test-variable\n       if s-result(s) = 'S'\n               perform increment-l\n           end-if\n           perform increment-p\n\n       when p-symbol(p) = 'n'\n       and p-address(p) <> p-definition(p) *> nonterminal reference\n           move p to s-p(s)\n           move p-definition(p) to p\n\n       when p-symbol(p) = 'n'\n       and p-address(p) = p-definition(p) *> nonterminal definition\n           perform increment-s\n           perform display-start-nonterminal\n           perform increment-p\n\n        when p-symbol(p) = '=' *> nonterminal control\n            move p to s-start-control(s)\n            move p-matching(p) to s-end-control(s)\n            perform increment-p\n\n        when p-symbol(p) = ';' *> end nonterminal\n            perform display-end-control\n            perform display-end-nonterminal\n            perform decrement-s\n            if s > 0\n                evaluate true\n                when s-result(r) = 'S'\n                    perform set-success\n                when s-result(r) = 'F'\n                    perform set-failure\n                end-evaluate\n                move s-p(s) to p\n                perform increment-p\n                perform display-continue-nonterminal\n            end-if\n\n    when p-symbol(p) = '{' *> start repeat sequence\n            perform increment-s\n            perform display-start-control\n            move p to s-start-control(s)\n            move p-alternate(p) to s-alternate(s)\n            move p-matching(p) to s-end-control(s)\n            move 0 to s-count(s)\n            perform increment-p\n\n        when p-symbol(p) = '}' *> end repeat sequence\n            perform display-end-control\n            evaluate true\n            when s-result(s) = 'S' *> repeat the sequence\n                perform display-repeat-control\n                perform set-nothing\n                add 1 to s-repeat(s)\n                move s-start-control(s) to p\n                perform increment-p\n           when other\n               perform decrement-s\n               evaluate true\n               when s-result(r) = 'N'\n               and s-repeat(r) = 0 *> no result\n                   perform increment-p\n               when s-result(r) = 'N'\n               and s-repeat(r) > 0 *> no result after success\n                   perform set-success\n                   perform increment-p\n               when other *> fail the sequence\n                   perform increment-p\n               end-evaluate\n           end-evaluate\n\n        when p-symbol(p) = '(' *> start sequence\n            perform increment-s\n            perform display-start-control\n            move p to s-start-control(s)\n            move p-alternate(p) to s-alternate(s)\n            move p-matching(p) to s-end-control(s)\n            move 0 to s-count(s)\n            perform increment-p\n\n       when p-symbol(p) = ')' *> end sequence\n           perform display-end-control\n           perform decrement-s\n           evaluate true\n           when s-result(r) = 'S' *> success\n               perform set-success\n               perform increment-p\n           when s-result(r) = 'N' *> no result\n               perform set-failure\n               perform increment-p\n            when other *> fail the sequence\n               perform set-failure\n               perform increment-p\n           end-evaluate\n\n        when p-symbol(p) = '|' *> alternate\n            evaluate true\n            when s-result(s) = 'S' *> exit the sequence\n                perform display-skip-alternate\n                move s-end-control(s) to p\n            when other\n                perform display-take-alternate\n                move p-alternate(p) to s-alternate(s) *> the next alternate\n                perform increment-p\n                perform set-nothing\n            end-evaluate\n\n        when p-symbol(p) = 't' *> terminal\n            move p-definition(p) to t\n            move terminal-symbol-len(t) to t-len\n            perform display-terminal\n            evaluate true\n            when statement(l:t-len) = terminal-symbol(t)(1:t-len) *> successful match\n               perform set-success\n               perform display-recognize-terminal\n               perform process-token\n               move t-len to l-len\n               perform increment-l\n               perform increment-p\n            when s-alternate(s) <> 000 *> we are in an alternate sequence\n               move s-alternate(s) to p\n            when other *> fail the sequence\n               perform set-failure\n               move s-end-control(s) to p\n            end-evaluate\n\n        when other *> end control\n            perform display-control-failure *> shouldnt happen\n\n        end-evaluate\n\n     end-perform\n\n     evaluate true *> at end of evaluation\n     when error-found = 'y'\n         continue\n     when l <= l-lim *> not all tokens parsed\n         display 'error: invalid statement'\n         perform statement-error\n     when number-use <> spaces\n         display 'error:  not all numbers were used: ' number-use\n         move 'y' to error-found\n     end-evaluate\n    .\nincrement-l.\n    evaluate true\n    when l > l-lim *> end of statement\n        continue\n    when other\n        add l-len to l\n        perform varying l from l by 1 \n        until c(l) <> space\n        or l > l-lim\n            continue\n        end-perform\n        move 1 to l-len\n        if l > l-lim\n            perform end-tokens\n        end-if\n    end-evaluate\n    .\nincrement-p.\n    evaluate true\n    when p >= p-max\n        display 'at' space p ' parse overflow'\n            space 's=<' s space s-entry(s) '>'\n        move 'y' to error-found\n    when other\n        add 1 to p\n        perform display-statement\n    end-evaluate\n    .\nincrement-s.\n    evaluate true\n    when s >= s-max\n        display 'at' space p ' stack overflow '\n            space 's=<' s space s-entry(s) '>'\n        move 'y' to error-found\n    when other\n        move s to r\n        add 1 to s\n        initialize s-entry(s)\n        move 'N' to s-result(s)\n        move p to s-p(s)\n        move nt to s-nt(s)\n    end-evaluate\n    .\ndecrement-s.\n    if s > 0\n        move s to r\n        subtract 1 from s\n        if s > 0\n            move s-nt(s) to nt\n        end-if\n    end-if\n    .\nset-failure.\n    move 'F' to s-result(s)\n    if s-count(s) > 0\n        display 'sequential parse failure'\n        perform statement-error\n    end-if\n    .\nset-success.\n    move 'S' to s-result(s)\n    add 1 to s-count(s)\n    .\nset-nothing.\n    move 'N' to s-result(s)\n    move 0 to s-count(s)\n    .\nstatement-error.\n    display statement\n    move spaces to statement\n    move '^ syntax error' to statement(l:)\n    display statement\n    move 'y' to error-found\n    .\n*>=====================\n*> twentyfour semantics\n*>=====================\ntest-variable.\n    *> check validity\n    perform varying nd from 1 by 1 until nd > 4\n    or c(l) = n(nd)\n        continue\n    end-perform\n    *> check usage\n    perform varying nu from 1 by 1 until nu > 4\n    or c(l) = u(nu)\n        continue\n    end-perform\n    evaluate true\n    when l > l-lim\n        perform set-failure\n    when c9(l) not numeric\n        perform set-failure\n    when nd > 4\n        display 'invalid number'\n        perform statement-error\n    when nu > 4\n        display 'number already used'\n        perform statement-error\n    when other\n        move space to u(nu)\n        perform set-success\n        add 1 to oqx\n        move c(l) to output-queue(oqx:1)\n    end-evaluate\n    .\n*> ==================================\n*> Dijkstra Shunting-Yard Algorithm\n*> to convert infix to rpn\n*> ==================================\nprocess-token.\n    evaluate true\n    when c(l) = '('\n        add 1 to osx\n        move c(l) to operator-stack(osx:1)\n    when c(l) = ')'\n        perform varying osx from osx by -1 until osx < 1\n        or operator-stack(osx:1) = '('\n            add 1 to oqx\n            move operator-stack(osx:1) to output-queue(oqx:1)\n        end-perform\n        if osx < 1\n            display 'parenthesis error'\n            perform statement-error\n            exit paragraph\n        end-if\n        subtract 1 from osx\n    when (c(l) = '+' or '-') and (operator-stack(osx:1) = '*' or '/')\n        *> lesser operator precedence\n        add 1 to oqx\n        move operator-stack(osx:1) to output-queue(oqx:1) \n        move c(l) to operator-stack(osx:1)\n    when other\n        *> greater operator precedence\n        add 1 to osx\n        move c(l) to operator-stack(osx:1)\n    end-evaluate\n    . \nend-tokens.\n    *> 1) copy stacked operators to the output-queue\n    perform varying osx from osx by -1 until osx < 1\n    or operator-stack(osx:1) = '('\n        add 1 to oqx\n        move operator-stack(osx:1) to output-queue(oqx:1)\n    end-perform\n    if osx > 0\n        display 'parenthesis error'\n        perform statement-error\n        exit paragraph\n    end-if\n    *> 2) evaluate the rpn statement\n    perform evaluate-rpn\n    if divide-by-zero-error = 'y'\n        display 'divide by zero error'\n    end-if\n    .\nevaluate-rpn.\n    move space to divide-by-zero-error\n    move 0 to rsx *> stack depth\n    perform varying oqx1 from 1 by 1 until oqx1 > oqx\n        if output-queue(oqx1:1) >= '1' and <= '9'\n            *> push current data onto the stack\n            add 1 to rsx\n            move top-numerator to numerator(rsx)\n            move top-denominator to denominator(rsx)\n            move output-queue(oqx1:1) to top-numerator\n            move 1 to top-denominator\n        else\n            *> apply the operation\n            evaluate true\n            when output-queue(oqx1:1) = '+'\n                compute top-numerator = top-numerator * denominator(rsx)\n                    + top-denominator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)  \n            when output-queue(oqx1:1) = '-' \n                compute top-numerator = top-denominator * numerator(rsx)\n                    - top-numerator * denominator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)  \n            when output-queue(oqx1:1) = '*' \n                compute top-numerator = top-numerator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)  \n            when output-queue(oqx1:1) = '/'\n                compute work-number = numerator(rsx) * top-denominator\n                compute top-denominator = denominator(rsx) * top-numerator\n                if top-denominator = 0\n                    move 'y' to divide-by-zero-error\n                    exit paragraph\n                end-if\n                move work-number to top-numerator\n            end-evaluate\n            *> pop the stack\n            subtract 1 from rsx\n        end-if\n    end-perform \n    .\n*>====================\n*> diagnostic displays\n*>====================\ndisplay-start-nonterminal.\n    perform varying nt from nt-lim by -1 until nt < 1\n    or p-definition(p) = nonterminal-statement-number(nt)\n        continue\n    end-perform\n    if nt > 0\n        move '1' to NL-flag\n        string '1' indent(1:s + s) 'at ' s space p ' start ' trim(nonterminal-statement(nt))\n            into message-area perform display-message\n        move nt to s-nt(s)\n    end-if\n    .\ndisplay-continue-nonterminal.\n    move s-nt(s) to nt\n    string '1' indent(1:s + s) 'at ' s space p space p-symbol(p) ' continue ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n            into message-area perform display-message\n    .\ndisplay-end-nonterminal.\n    move s-nt(s) to nt\n    move '2' to NL-flag\n    string '1' indent(1:s + s) 'at ' s space p ' end ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n            into message-area perform display-message\n    .\ndisplay-start-control.\n    string '2' indent(1:s + s) 'at ' s space p ' start ' p-symbol(p) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-repeat-control.\n    string '2' indent(1:s + s) 'at ' s space p ' repeat ' p-symbol(p) ' in ' trim(nonterminal-statement(nt))  ' with result ' s-result(s)\n        into message-area perform display-message\n    .\ndisplay-end-control.\n    string '2' indent(1:s + s) 'at ' s space p ' end ' p-symbol(p)  ' in ' trim(nonterminal-statement(nt)) ' with result ' s-result(s)\n        into message-area perform display-message\n    .\ndisplay-take-alternate.\n    string '2' indent(1:s + s) 'at ' s space p ' take alternate' ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-skip-alternate.\n    string '2' indent(1:s + s) 'at ' s space p ' skip alternate' ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-terminal.\n    string '1' indent(1:s + s) 'at ' s space p\n        ' compare ' statement(l:t-len) ' to ' terminal-symbol(t)(1:t-len)\n        ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-recognize-terminal.\n    string '1' indent(1:s + s) 'at ' s space p ' recognize terminal: ' c(l) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-recognize-variable.\n    string '1' indent(1:s + s) 'at ' s space p ' recognize digit: ' c(l) ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-statement.\n    compute p1 = p - s-start-control(s)\n    string '3' indent(1:s + s) 'at ' s space p\n        ' statement: ' s-start-control(s) '/' p1\n        space p-symbol(p) space s-result(s)\n        ' in ' trim(nonterminal-statement(nt))\n        into message-area perform display-message\n    .\ndisplay-control-failure.\n    display loop-count space indent(1:s + s) 'at' space p ' control failure' ' in ' trim(nonterminal-statement(nt))\n    display loop-count space indent(1:s + s) '   ' 'p=<' p p-entry(p) '>'\n    display loop-count space indent(1:s + s) '   ' 's=<' s space s-entry(s) '>'\n    display loop-count space indent(1:s + s) '   ' 'l=<' l space c(l)'>'\n    perform statement-error\n    .\ndisplay-message.\n    if display-level = 1\n        move space to NL-flag\n    end-if\n    evaluate true\n    when loop-count > loop-lim *> loop control\n        display 'display count exceeds ' loop-lim\n        stop run\n    when message-level <= display-level\n        evaluate true\n        when NL-flag = '1'\n             display NL loop-count space trim(message-value)\n        when NL-flag = '2'\n             display loop-count space trim(message-value) NL\n        when other\n             display loop-count space trim(message-value)\n        end-evaluate\n    end-evaluate\n    add 1 to loop-count\n    move spaces to message-area\n    move space to NL-flag\n    .\nend program twentyfour.\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Ada", "code": "\n\nwith Ada.Float_Text_IO;\nwith Ada.Text_IO;\nwith Ada.Numerics.Discrete_Random;\nprocedure Game_24 is\n   subtype Digit is Character range '1' .. '9';\n   package Random_Digit is new Ada.Numerics.Discrete_Random (Digit);\n   Exp_Error : exception;\n   Digit_Generator : Random_Digit.Generator;\n   Given_Digits : array (1 .. 4) of Digit;\n   Float_Value : constant array (Digit) of Float :=\n      (1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0);\n   function Apply_Op (L, R : Float; Op : Character) return Float is\n   begin\n      case Op is\n         when '+' =>\n            return L + R;\n         when '-' =>\n            return L - R;\n         when '*' =>\n            return L * R;\n         when '/' =>\n            return L / R;\n         when others =>\n            Ada.Text_IO.Put_Line (\"Unexpected operator: \" & Op);\n            raise Exp_Error;\n      end case;\n   end Apply_Op;\n   function Eval_Exp (E : String) return Float is\n      Flt : Float;\n      First : Positive := E'First;\n      Last : Positive;\n      function Match_Paren (Start : Positive) return Positive is\n         Pos : Positive := Start + 1;\n         Level : Natural := 1;\n      begin\n         loop\n            if Pos > E'Last then\n               Ada.Text_IO.Put_Line (\"Unclosed parentheses.\");\n               raise Exp_Error;\n            elsif E (Pos) = '(' then\n               Level := Level + 1;\n            elsif E (Pos) = ')' then\n               Level := Level - 1;\n               exit when Level = 0;\n            end if;\n            Pos := Pos + 1;\n         end loop;\n         return Pos;\n      end Match_Paren;\n   begin\n      if E (First) = '(' then\n         Last := Match_Paren (First);\n         Flt := Eval_Exp (E (First + 1 .. Last - 1));\n      elsif E (First) in Digit then\n         Last := First;\n         Flt := Float_Value (E (First));\n      else\n         Ada.Text_IO.Put_Line (\"Unexpected character: \" & E (First));\n         raise Exp_Error;\n      end if;\n      loop\n         if Last = E'Last then\n            return Flt;\n         elsif Last = E'Last - 1 then\n            Ada.Text_IO.Put_Line (\"Unexpected end of expression.\");\n            raise Exp_Error;\n         end if;\n         First := Last + 2;\n         if E (First) = '(' then\n            Last := Match_Paren (First);\n            Flt := Apply_Op (Flt, Eval_Exp (E (First + 1 .. Last - 1)),\n                             Op => E (First - 1));\n         elsif E (First) in Digit then\n            Last := First;\n            Flt := Apply_Op (Flt, Float_Value (E (First)),\n                             Op => E (First - 1));\n         else\n            Ada.Text_IO.Put_Line (\"Unexpected character: \" & E (First));\n            raise Exp_Error;\n         end if;\n      end loop;\n   end Eval_Exp;\nbegin\n   Ada.Text_IO.Put_Line (\"24 Game\");\n   Ada.Text_IO.Put_Line (\"- Enter Q to Quit\");\n   Ada.Text_IO.Put_Line (\"- Enter N for New digits\");\n   Ada.Text_IO.Put_Line (\"Note: Operators are evaluated left-to-right\");\n   Ada.Text_IO.Put_Line (\"      (use parentheses to override)\");\n   Random_Digit.Reset (Digit_Generator);\n   <<GEN_DIGITS>>\n   Ada.Text_IO.Put_Line (\"Generating 4 digits...\");\n   for I in Given_Digits'Range loop\n      Given_Digits (I) := Random_Digit.Random (Digit_Generator);\n   end loop;\n   <<GET_EXP>>\n   Ada.Text_IO.Put (\"Your Digits:\");\n   for I in Given_Digits'Range loop\n      Ada.Text_IO.Put (\" \" & Given_Digits (I));\n   end loop;\n   Ada.Text_IO.New_Line;\n   Ada.Text_IO.Put (\"Enter your Expression: \");\n   declare\n      Value : Float;\n      Response : constant String := Ada.Text_IO.Get_Line;\n      Prev_Ch : Character := ' ';\n      Unused_Digits : array (Given_Digits'Range) of Boolean :=\n        (others => True);\n   begin\n      if Response = \"n\" or Response = \"N\" then\n         goto GEN_DIGITS;\n      end if;\n      if Response = \"q\" or Response = \"Q\" then\n         return;\n      end if;\n      -- check input\n      for I in Response'Range loop\n         declare\n            Ch : constant Character := Response (I);\n            Found : Boolean;\n         begin\n            if Ch in Digit then\n               if Prev_Ch in Digit then\n                  Ada.Text_IO.Put_Line (\"Illegal multi-digit number used.\");\n                  goto GET_EXP;\n               end if;\n               Found := False;\n               for J in Given_Digits'Range loop\n                  if Unused_Digits (J) and then\n                        Given_Digits (J) = Ch then\n                     Unused_Digits (J) := False;\n                     Found := True;\n                     exit;\n                  end if;\n               end loop;\n               if not Found then\n                  Ada.Text_IO.Put_Line (\"Illegal number used: \" & Ch);\n                  goto GET_EXP;\n               end if;\n            elsif Ch /= '(' and Ch /= ')' and Ch /= '+' and\n                  Ch /= '-' and Ch /= '*' and Ch /= '/' then\n               Ada.Text_IO.Put_Line (\"Illegal character used: \" & Ch);\n               goto GET_EXP;\n            end if;\n            Prev_Ch := Ch;\n         end;\n      end loop;\n      -- check all digits used\n      for I in Given_Digits'Range loop\n         if Unused_Digits (I) then\n            Ada.Text_IO.Put_Line (\"Digit not used: \" & Given_Digits (I));\n            goto GET_EXP;\n         end if;\n      end loop;\n      -- check value\n      begin\n         Value := Eval_Exp (Response);\n      exception\n         when Exp_Error =>\n            goto GET_EXP; -- Message displayed by Eval_Exp;\n      end;\n      if abs (Value - 24.0) > 0.001 then\n         Ada.Text_IO.Put (\"Value \");\n         Ada.Float_Text_IO.Put (Value, Fore => 0, Aft => 3, Exp => 0);\n         Ada.Text_IO.Put_Line (\" is not 24!\");\n         goto GET_EXP;\n      else\n         Ada.Text_IO.Put_Line (\"You won!\");\n         Ada.Text_IO.Put_Line (\"Enter N for a new game, or try another solution.\");\n         goto GET_EXP;\n      end if;\n   end;\nend Game_24;\n\n\nOutput:\n24 Game\n- Enter Q to Quit\n- Enter N for New digits\nNote: Operators are evaluated left-to-right\n      (use parentheses to override)\nGenerating 4 digits...\nYour Digits: 2 9 5 9\nEnter your Expression: 9+9+5-2\nValue 21.000 is not 24!\nYour Digits: 2 9 5 9\nEnter your Expression: N\nGenerating 4 digits...\nYour Digits: 7 7 1 3\nEnter your Expression: (7-1)*(7-3)\nYou won!\nEnter N for a new game, or try another solution.\n", "explain": "game24.adb:\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Julia", "code": "\n\nvalidexpr(ex::Expr) = ex.head == :call && ex.args[1] in [:*,:/,:+,:-] && all(validexpr, ex.args[2:end])\nvalidexpr(ex::Int) = true\nvalidexpr(ex::Any) = false\nfindnumbers(ex::Number) = Int[ex]\nfindnumbers(ex::Expr) = vcat(map(findnumbers, ex.args)...)\nfindnumbers(ex::Any) = Int[]\nfunction twentyfour()\n    digits = sort!(rand(1:9, 4))\n    while true\n        print(\"enter expression using $digits => \")\n        ex = parse(readline())\n        try\n            validexpr(ex) || error(\"only *, /, +, - of integers is allowed\")\n            nums = sort!(findnumbers(ex))\n            nums == digits || error(\"expression $ex used numbers $nums\u00a0!= $digits\")\n            val = eval(ex)\n            val == 24 || error(\"expression $ex evaluated to $val, not 24\")\n            println(\"you won!\")\n            return\n        catch e\n            if isa(e, ErrorException)\n                println(\"incorrect: \", e.msg)\n            else\n                rethrow()\n            end\n        end\n    end\nend\n\n\nOutput:\njulia> twentyfour()\nenter expression using [2,5,8,9] => 5 * 2 - 8 + 9\nincorrect: expression (5 * 2 - 8) + 9 evaluated to 11, not 24\nenter expression using [2,5,8,9] => 5 * 5 + 2 + 8 - 9\nincorrect: expression (5 * 5 + 2 + 8) - 9 used numbers [2,5,5,8,9]\u00a0!= [2,5,8,9]\nenter expression using [2,5,8,9] => 8*2*2\nincorrect: expression 8 * 2 * 2 used numbers [2,2,8]\u00a0!= [2,5,8,9]\nenter expression using [2,5,8,9] => (8 + 9) + (5 + 2)\nyou won!\n", "explain": "This implementation, because it is based on the Julia parser and evaluator, allows the user to enter arbitrary infix expressions, including parentheses.  (These expressions are checked to ensure that they only include the allowed operations on integer literals.)\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\nimport java.util.Random\nimport java.util.Scanner\nimport java.util.Stack\n\ninternal object Game24 {\n    fun run() {\n        val r = Random()\n        val digits = IntArray(4).map { r.nextInt(9) + 1 }\n        println(\"Make 24 using these digits: $digits\")\n        print(\"> \")\n\n        val s = Stack<Float>()\n        var total = 0L\n        val cin = Scanner(System.`in`)\n        for (c in cin.nextLine()) {\n            when (c) {\n                in '0'..'9' -> {\n                    val d = c - '0'\n                    total += (1 shl (d * 5)).toLong()\n                    s += d.toFloat()\n                }\n                else ->\n                    if (\"+/-*\".indexOf(c) != -1) {\n                        s += c.applyOperator(s.pop(), s.pop())\n                    }\n            }\n        }\n\n        when {\n            tally(digits) != total ->\n                print(\"Not the same digits. \")\n            s.peek().compareTo(target) == 0 ->\n                println(\"Correct!\")\n            else ->\n                print(\"Not correct.\")\n        }\n    }\n\n    private fun Char.applyOperator(a: Float, b: Float) = when (this) {\n        '+' -> a + b\n        '-' -> b - a\n        '*' -> a * b\n        '/' -> b / a\n        else -> Float.NaN\n    }\n\n    private fun tally(a: List<Int>): Long = a.reduce({ t, i -> t + (1 shl (i * 5)) }).toLong()\n\n    private val target = 24\n}\n\nfun main(args: Array<String>) = Game24.run()\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Perl", "code": "\n#!/usr/bin/env perl\nuse warnings;\nuse strict;\nuse feature 'say';\n\nprint <<'EOF';\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nparentheses, (), show how to make an answer of 24.\n\nAn answer of \"q\" or EOF will quit the game.\nA blank answer will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24.\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\nEOF\n\nmy $try = 1;\nwhile (1) {\n  my @digits = map { 1+int(rand(9)) } 1..4;\n  say \"\\nYour four digits: \", join(\" \", @digits);\n  print \"Expression (try \", $try++, \"): \";\n\n  my $entry = <>;\n  if (!defined $entry || $entry eq 'q') \n    { say \"Goodbye.  Sorry you couldn't win.\"; last; }\n  $entry =~ s/\\s+//g;  # remove all white space\n  next if $entry eq '';\n\n  my $given_digits = join \"\", sort @digits;\n  my $entry_digits = join \"\", sort grep { /\\d/ } split(//, $entry);\n  if ($given_digits ne $entry_digits ||  # not correct digits\n      $entry =~ /\\d\\d/ ||                # combined digits\n      $entry =~ m|[-+*/]{2}| ||          # combined operators\n      $entry =~ tr|-0-9()+*/||c)         # Invalid characters\n    { say \"That's not valid\";  next; }\n\n  my $n = eval $entry;\n\n  if    (!defined $n) { say \"Invalid expression\"; }\n  elsif ($n == 24)    { say \"You win!\"; last; }\n  else                { say \"Sorry, your expression is $n, not 24\"; }\n}\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Prolog", "code": "\nWorks with: GNU Prolog\n:- initialization(main).\n\n\nanswer(24).\nplay :- round, play ; true.\n\nround :-\n    prompt(Ns), get_line(Input), Input \\= \"stop\"\n  , ( phrase(parse(Ns,[]), Input) -> Result = 'correct'\n                                   ; Result = 'wrong'\n    ), write(Result), nl, nl\n  . % where\n    prompt(Ns)  :- length(Ns,4), maplist(random(1,10), Ns)\n                 , write('Digits: '), write(Ns), nl\n                 .\n\nparse([],[X])     --> { answer(X) }.\nparse(Ns,[Y,X|S]) --> \"+\", { Z is X  +  Y }, parse(Ns,[Z|S]).\nparse(Ns,[Y,X|S]) --> \"-\", { Z is X  -  Y }, parse(Ns,[Z|S]).\nparse(Ns,[Y,X|S]) --> \"*\", { Z is X  *  Y }, parse(Ns,[Z|S]).\nparse(Ns,[Y,X|S]) --> \"/\", { Z is X div Y }, parse(Ns,[Z|S]).\nparse(Ns,Stack)   --> \" \", parse(Ns,Stack).\nparse(Ns,Stack)   --> { select(N,Ns,Ns1), number_codes(N,[Code]) }\n                    , [Code], parse(Ns1,[N|Stack])\n                    .\n\nget_line(Xs) :- get_code(X)\n              , ( X == 10 -> Xs = [] ; Xs = [X|Ys], get_line(Ys) )\n              .\nmain :- randomize, play, halt.\n\n\nDigits: [9,4,6,9]\n46*9-9+\ncorrect\n\nDigits: [7,4,7,8]\n8 4 7 7 / - *\ncorrect\n\nDigits: [7,2,8,2]\n7282---\nwrong\n\nDigits: [2,6,7,1]\n4611***\nwrong\n\nDigits: [3,6,5,8]\n+\nwrong\n\nDigits: [2,1,7,7]\nstop\n", "explain": "Example \"session\":\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Lua", "code": "\nlocal function help()\n\tprint [[\n The 24 Game\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n ]]\nend\n\nlocal function generate(n)\n\tresult = {}\n\tfor i=1,n do\n\t\tresult[i] = math.random(1,9)\n\tend\n\treturn result\nend\n\nlocal function check(answer, digits)\n\tlocal adig = {}\n\tlocal ddig = {}\n\tlocal index\n\tlocal lastWasDigit = false\n\tfor i=1,9 do adig[i] = 0 ddig[i] = 0 end\n\tallowed = {['(']=true,[')']=true,[' ']=true,['+']=true,['-']=true,['*']=true,['/']=true,['\\t']=true,['1']=true,['2']=true,['3']=true,['4']=true,['5']=true,['6']=true,['7']=true,['8']=true,['9']=true}\n\tfor i=1,string.len(answer) do\n\t\tif not allowed[string.sub(answer,i,i)] then\n\t\t\treturn false\n\t\tend\n\t\tindex = string.byte(answer,i)-48\n\t\tif index > 0 and index < 10 then\n\t\t\tif lastWasDigit then\n\t\t\t\treturn false\n\t\t\tend\n\t\t\tlastWasDigit = true\n\t\t\tadig[index] = adig[index] + 1\n\t\telse\n\t\t\tlastWasDigit = false\n\t\tend\n\tend\n\tfor i,digit in next,digits do\n\t\tddig[digit] = ddig[digit]+1\n\tend\n\tfor i=1,9 do\n\t\tif adig[i] ~= ddig[i] then\n\t\t\treturn false\n\t\tend\n\tend\n\treturn loadstring('return '..answer)()\nend\n\nlocal function game24()\n\thelp()\n\tmath.randomseed(os.time())\n\tmath.random()\n\tlocal digits = generate(4)\n\tlocal trial = 0\n\tlocal answer = 0\n\tlocal ans = false\n\tio.write 'Your four digits:'\n\tfor i,digit in next,digits do\n\t\tio.write (' ' .. digit)\n\tend\n\tprint()\n\twhile ans ~= 24 do\n\t\ttrial = trial + 1\n\t\tio.write(\"Expression \"..trial..\": \")\n\t\tanswer = io.read()\n\t\tif string.lower(answer) == 'q' then\n\t\t\tbreak\n\t\tend\n\t\tif answer == '!' then\n\t\t\tdigits = generate(4)\n\t\t\tio.write (\"New digits:\")\n\t\t\tfor i,digit in next,digits do\n\t\t\t\tio.write (' ' .. digit)\n\t\t\tend\n\t\t\tprint()\n\t\telse\n\t\t\tans = check(answer,digits)\n\t\t\tif ans == false then\n\t\t\t\tprint ('The input '.. answer ..' was wonky!')\n\t\t\telse\n\t\t\t\tprint (' = '.. ans)\n\t\t\t\tif ans == 24 then\n\t\t\t\t\tprint (\"Thats right!\")\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\tend\nend\ngame24()\n\n\nfunction twentyfour()\n   print [[\n The 24 Game\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n ]]\n   expr = re.compile[[   --matches properly formatted infix expressions and returns all numerals as captures\n         expr <- (!.) / (<paren> / <number>) (<ws> <oper> <ws> <expr>)?\n         number <- {[0-9]}\n         ws <- \" \"*\n         oper <- [-+/*]\n         paren <- \"(\" <ws> <expr> <ws> \")\"   ]]\n   local val_t = {math.random(9), math.random(9), math.random(9), math.random(9)}\n   table.sort(val_t)\n   print(\"the digits are \" .. table.concat(val_t, \", \"))\n   local ex = io.read()\n   a, b, c, d, e = expr:match(ex)\n   if a and b and c and d and not e then --if there is a fifth numeral the player is cheating\n      local digs = {a + 0, b + 0, c + 0, d + 0}\n      local flag = false -- (terrorism!)\n      table.sort(digs)\n      for i = 1, 4 do\n\t   flag = digs[i] ~= val_t[i] and not print\"Wrong digits!\" or flag\n      end\n      if not flag and loadstring(\"return \" .. ex)() == 24 then\n         print\"You win!\"\n      else\n         print\"You lose.\"\n      end\n   else print\"wat\" --expression could not be interpreted as arithmetic\n   end\nend\ntwentyfour()\n\n", "explain": "Alternately, using the lpeg.re module:\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Scala", "code": "\n\nobject TwentyFourGame {\n  def main(args: Array[String]) {\n    import Parser.TwentyFourParser\n    \n    println(welcome)\n    \n    var parser = new TwentyFourParser(problemsIterator.next)\n    println(\"Your four digits: \"+parser+\".\")\n    \n    var finished = false\n    var expressionCount = 1\n    do {\n      val line = Console.readLine(\"Expression \"+expressionCount+\": \")\n      line match {\n        case \"!\" =>\n          parser = new TwentyFourParser(problemsIterator.next)\n          println(\"New digits: \"+parser+\".\")\n          \n        case \"q\" =>\n          finished = true\n        \n        case _ =>\n          parser readExpression line match {\n            case Some(24) => println(\"That's right!\"); finished = true\n            case Some(n) => println(\"Sorry, that's \"+n+\".\")\n            case None =>\n          }\n      }\n      expressionCount += 1\n    } while (!finished)\n    \n    println(\"Thank you and goodbye!\")\n  }\n  \n  val welcome = \"\"\"|The 24 Game\n                   |\n                   |Given any four digits in the range 1 to 9, which may have repetitions,\n                   |Using just the +, -, *, and / operators; and the possible use of\n                   |brackets, (), show how to make an answer of 24.\n                   |\n                   |An answer of \"q\" will quit the game.\n                   |An answer of \"!\" will generate a new set of four digits.\n                   |Otherwise you are repeatedly asked for an expression until it evaluates to 24\n                   |\n                   |Note: you cannot form multiple digit numbers from the supplied digits,\n                   |so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n                   |\"\"\".stripMargin\n  \n  val problemsIterator = (\n    Iterator \n    continually List.fill(4)(scala.util.Random.nextInt(9) + 1 toDouble) \n    filter hasSolution\n  )\n  \n  def hasSolution(l: List[Double]) = permute(l) flatMap computeAllOperations exists (_ == 24)\n  \n  def computeAllOperations(l: List[Double]): List[Double] = l match {\n    case Nil => Nil\n    case x :: Nil => l\n    case x :: xs =>\n      for {\n        y <- computeAllOperations(xs)\n        z <- if (y == 0) List(x*y, x+y, x-y) else List(x*y, x/y, x+y, x-y)\n      } yield z\n  }\n  \n  def permute(l: List[Double]): List[List[Double]] = l match {\n    case Nil => List(Nil)\n    case x :: xs =>\n      for {\n        ys <- permute(xs)\n        position <- 0 to ys.length\n        (left, right) = ys splitAt position\n      } yield left ::: (x :: right)\n  }\n  \n  object Parser {\n    /*  Arithmetic expression grammar production rules in EBNF form:\n     *\n     * <expr> --> <term> ( '+' <term> | '-' <term> )*\n     * <term> --> <factor> ( '*'  <factor> | '/'  <factor> )*\n     * <factor> --> '(' <expr> ')' | <digit>\n     * <digit> --> 0 | 1  | 2 | 3 | 4 | 5 | 6 | 7 | 8 | 9\n     * \n     * Semantically, <digit> can only be a digit from the list of remaining digits.\n     */\n    \n    class TwentyFourParser(digits: List[Double]) extends scala.util.parsing.combinator.RegexParsers {\n      require(digits.length == 4 && digits.forall(d => 0 <= d && d <= 9))\n      override val toString = digits.map(_.toInt).mkString(\", \")\n      \n      // Grammar\n      def exprConsumingAllDigits = expr ^? (remainingDigits.allDigitsConsumed, digitsRemainingError) // Guarantees all digits consumed\n      def expr : Parser[Double] = term ~ rep( \"+\" ~ term | \"-\" ~ term) ^^ solveOperationChain\n      def term = factor ~ rep( \"*\" ~ factor | \"/\" ~ factor) ^^ solveOperationChain\n      def factor = \"(\" ~> expr <~ \")\" | digit\n      def digit = digitRegex ^? (remainingDigits.consumeDigit, digitNotAllowedError) \n      def digitRegex = \"\\\\d\".r | digitExpected\n      def digitExpected: Parser[String] = \".\".r <~ failure(expectedDigitError) // Produces clear error messages\n    \n      // Evaluate expressions\n      def readExpression(input: String): Option[Double] = {\n        remainingDigits = new DigitList(digits) // Initialize list of digits to be consumed\n        parseAll(exprConsumingAllDigits, input) match {\n          case Success(result, _) => Some(result)\n          case NoSuccess(msg, next) =>\n            println(ParsingErrorFormatter(msg, next))\n            None\n        }\n      }\n      \n      // List of digits to be consumed\n      private var remainingDigits: DigitList = _\n      \n      // Solve partial results from parsing\n      private def solveOperationChain(partialResult: ~[Double,List[~[String,Double]]]): Double = partialResult match {\n        case first ~ chain => chain.foldLeft(first)(doOperation)\n      }\n      private def doOperation(acc: Double, op: ~[String, Double]): Double = op match {\n        case \"+\" ~ operand => acc + operand\n        case \"-\" ~ operand => acc - operand\n        case \"*\" ~ operand => acc * operand\n        case \"/\" ~ operand => acc / operand\n        case x => error(\"Unknown operation \"+x+\".\") \n      }\n      \n      // Error messages\n      private def digitNotAllowedError(d: String) = \"Digit \"+d+\" is not allowed here. Available digits: \"+remainingDigits+\".\"\n      private def digitsRemainingError(x: Any) = \"Not all digits were consumed. Digits remaining: \"+remainingDigits+\".\"\n      private def expectedDigitError = \"Unexpected input. Expected a digit from the list: \"+remainingDigits+\".\"\n    }\n    \n    private object ParsingErrorFormatter {\n      def apply[T](msg: String, next: scala.util.parsing.input.Reader[T]) =\n        \"%s\\n%s\\n%s\\n\" format (msg, next.source.toString.trim, \" \"*(next.offset - 1)+\"^\")\n    }\n    \n    private class DigitList(digits: List[Double]) {\n      private var remainingDigits = digits\n      override def toString = remainingDigits.map(_.toInt).mkString(\", \")\n      \n      def consumeDigit: PartialFunction[String, Double] = {\n        case d if remainingDigits contains d.toDouble =>\n          val n = d.toDouble\n          remainingDigits = remainingDigits diff List(n)\n          n\n      }\n      \n      def allDigitsConsumed: PartialFunction[Double, Double] = {\n        case n if remainingDigits.isEmpty => n\n      }\n    }\n  }\n}\n\n\nOutput:\nC:\\Workset>scala TwentyFourGame\nThe 24 Game\n\nGiven any four digits in the range 1 to 9, which may have repetitions,\nUsing just the +, -, *, and / operators; and the possible use of\nbrackets, (), show how to make an answer of 24.\n\nAn answer of \"q\" will quit the game.\nAn answer of \"!\" will generate a new set of four digits.\nOtherwise you are repeatedly asked for an expression until it evaluates to 24\n\nNote: you cannot form multiple digit numbers from the supplied digits,\nso an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\nYour four digits: 2, 7, 7, 2.\nExpression 1: 2*7+2+7\nSorry, that's 23.0.\nExpression 2: 7*7/2-2\nSorry, that's 22.5.\nExpression 3: 2*7+(7-2)\nSorry, that's 19.0.\nExpression 4: 2*(7+7-2)\nThat's right!\nThank you and goodbye!\n\n", "explain": "The solution below is much more complex than strictly needed, because it shows off\nScala's Parser library, which enables easy construction of parsers from\nEBNF grammars.\nOnly problems with solution are shown to the user.\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "D", "code": "\nimport std.stdio, std.random, std.math, std.algorithm, std.range,\n       std.typetuple;\n\nvoid main() {\n    void op(char c)() {\n        if (stack.length < 2)\n            throw new Exception(\"Wrong expression.\");\n        stack[$ - 2] = mixin(\"stack[$ - 2]\" ~ c ~ \"stack[$ - 1]\");\n        stack.popBack();\n    }\n\n    const problem = iota(4).map!(_ => uniform(1, 10))().array();\n    writeln(\"Make 24 with the digits: \", problem);\n\n    double[] stack;\n    int[] digits;\n    foreach (const char c; readln())\n        switch (c) {\n            case ' ', '\\t', '\\n': break;\n            case '1': .. case '9':\n                stack ~= c - '0';\n                digits ~= c - '0';\n                break;\n            foreach (o; TypeTuple!('+', '-', '*', '/')) {\n                case o: op!o(); break;\n            }\n            break;\n            default: throw new Exception(\"Wrong char: \" ~ c);\n        }\n\n    if (!digits.sort().equal(problem.dup.sort()))\n        throw new Exception(\"Not using the given digits.\");\n    if (stack.length != 1)\n        throw new Exception(\"Wrong expression.\");\n    writeln(\"Result: \", stack[0]);\n    writeln(abs(stack[0] - 24) < 0.001 ? \"Good job!\" : \"Try again.\");\n}\n\n\nMake 24 with the digits: [1, 8, 9, 8]\n8 1 - 9 + 8 +\nResult: 24\nGood job!\n", "explain": "Example:\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Haskell", "code": "\nimport Data.List (sort)\nimport Data.Char (isDigit)\nimport Data.Maybe (fromJust)\nimport Control.Monad (foldM)\nimport System.Random (randomRs, getStdGen)\nimport System.IO (hSetBuffering, stdout, BufferMode(NoBuffering))\n\nmain = do\n  hSetBuffering stdout NoBuffering\n  mapM_\n    putStrLn\n    [ \"THE 24 GAME\\n\"\n    , \"Given four digits in the range 1 to 9\"\n    , \"Use the +, -, *, and / operators in reverse polish notation\"\n    , \"To show how to make an answer of 24.\\n\"\n    ]\n  digits <- fmap (sort . take 4 . randomRs (1, 9)) getStdGen :: IO [Int]\n  putStrLn (\"Your digits: \" ++ unwords (fmap show digits))\n  guessLoop digits\n  where\n    guessLoop digits =\n      putStr \"Your expression: \" >> fmap (processGuess digits . words) getLine >>=\n      either (\\m -> putStrLn m >> guessLoop digits) putStrLn\n\nprocessGuess _ [] = Right \"\"\nprocessGuess digits xs\n  | not matches = Left \"Wrong digits used\"\n  where\n    matches = digits == (sort . fmap read $ filter (all isDigit) xs)\nprocessGuess digits xs = calc xs >>= check\n  where\n    check 24 = Right \"Correct\"\n    check x = Left (show (fromRational (x :: Rational)) ++ \" is wrong\")\n\n-- A Reverse Polish Notation calculator with full error handling\ncalc xs =\n  foldM simplify [] xs >>=\n  \\ns ->\n     (case ns of\n        [n] -> Right n\n        _ -> Left \"Too few operators\")\n\nsimplify (a:b:ns) s\n  | isOp s = Right ((fromJust $ lookup s ops) b a : ns)\nsimplify _ s\n  | isOp s = Left (\"Too few values before \" ++ s)\nsimplify ns s\n  | all isDigit s = Right (fromIntegral (read s) : ns)\nsimplify _ s = Left (\"Unrecognized symbol: \" ++ s)\n\nisOp v = elem v $ fmap fst ops\n\nops = [(\"+\", (+)), (\"-\", (-)), (\"*\", (*)), (\"/\", (/))]\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Scheme", "code": "\nWorks with: PLT Scheme version 4\n\n#lang scheme\n(require srfi/27 srfi/1) ;; random-integer, every\n\n(define (play)\n  (let* ([numbers (build-list 4 (lambda (n)\n                                  (add1 (random-integer 9))))]\n         [valid?  (curryr valid? numbers)])\n    (printf startup-message numbers)\n    (let loop ([exp (read)])\n      (with-handlers ([exn:fail? (lambda (err)\n                                   (printf error-message exp (exn-message err))\n                                   (loop (read)))])\n       (cond [(eq? exp '!) (play)]\n             \n             [(or (eq? exp 'q)\n                  (eof-object? exp)) (printf quit-message)]\n             \n             [(not (valid? exp))\n              (printf bad-exp-message exp)\n              (loop (read))]\n            \n             [(not (= (eval exp) 24))\n              (printf bad-result-message exp (eval exp))\n              (loop (read))]\n            \n             [else (printf winning-message)])))))\n\n(define (valid? exp numbers)\n  ;; must contain each number exactly once and only valid symbols\n  (define (valid-symbol? sym)\n    ;; only +, -, *, and / are valid\n    (case sym\n      [(+ - * /) #t]\n      [else #f]))\n  \n  (let* ([ls (flatten exp)]\n         [numbers* (filter number? ls)]\n         [symbols  (remove number? ls)])\n    (and (equal? (sort numbers <)\n                 (sort numbers* <))\n         (every valid-symbol? symbols))))\n\n(define startup-message \"\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, /\nand these four numbers: ~a\n\nor '!' to get a new set of numbers\nor 'q' to quit\")\n\n(define error-message \"\nYour expression ~a raised an exception:\n\n  \\\"~a\\\"\n\nPlease try again\")\n\n(define bad-exp-message \"Sorry, ~a is a bad expression.\")\n(define bad-result-message \"Sorry, ~a evaluates to ~a, not 24.\")\n(define quit-message \"Thanks for playing...\")\n(define winning-message \"You win!\")\n\n(provide play)\n\n\nOutput:\n> (require \"24game.ss\")\n> (play)\n\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, /\nand these four numbers: (2 7 2 5)\n\nor '!' to get a new set of numbers\nor 'q' to quit\n!\n\nWrite a lisp expression that evaluates to 24\nusing only (, ), +, -, *, /\nand these four numbers: (9 2 7 6)\n\nor '!' to get a new set of numbers\nor 'q' to quit\n(9 7 6 2)\n\nYour expression (9 7 6 2) raised an exception:\n\n  \"procedure application: expected procedure, given: 9; arguments were: 7 6 2\"\n\nPlease try again\n(+ 9 7 6 2)\nYou win!\n\n", "explain": "This uses read to read in a scheme expression, and eval to evaluate it, so in that sense it's not ideal (eval is evil etc.) but any expression that is valid should be safe and terminate in a timely manner.\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "PowerShell", "code": "\n\nCLS\n\nFunction isNumeric ($x)\n{\n    $x2 = 0    \n    $isNum = [System.Int32]::TryParse($x,[ref]$x2)\nReturn $isNum\n}\n\n$NumberArray = @()\nWhile( $NumberArray.Count -lt 4 ){\n    $NumberArray += Random -Minimum 1 -Maximum 10\n}\n\nWrite-Host @\"\nWelcome to the 24 game!\n\nHere are your numbers: $($NumberArray -join \",\").\nUse division, multiplication, subtraction and addition to get 24 as a result with these 4 numbers.\n\"@\n\nDo\n{\n$Wrong = 0\n$EndResult = $null\n$TempChar = $null\n$TempChar2 = $null\n$Count = $null\n\n$AllowableCharacters = $NumberArray + \"+-*/()\".ToCharArray()\n    $Result = Read-Host\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If( $AllowableCharacters -notcontains $Char ){ $Wrong = 1 }\n        }\n\n        If($Wrong -eq 1)\n        {\n            Write-Warning \"Wrong input! Please use only the given numbers.\"\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If((IsNumeric $TempChar) -AND (IsNumeric $Char))\n            {\n                Write-Warning \"Wrong input! Combining two or more numbers together is not allowed!\"\n            }\n            $TempChar = $Char\n        }\n        Foreach($Char in $Result.ToCharArray())\n        {\n            If(IsNumeric $Char)\n            {\n                $Count++\n            }\n        }\n        If($Count -eq 4)\n        {\n            $EndResult = Invoke-Expression $Result\n                If($EndResult -eq 24)\n                {\n                    Write-Host \"`nYou've won the game!\"\n                }\n                Else\n                {\n                    Write-Host \"`n$EndResult is not 24! Too bad.\"\n                }\n        }\n        Else\n        {\n            Write-Warning \"Wrong input! You did not supply four numbers.\"\n        }\n}\nWhile($EndResult -ne 24)\n\n", "explain": "The \"isNumeric\" function was taken from the \"Determine_if_a_string_is_numeric\" task.\ntodo: add a validation that all given digits were used. Right now the validation is that 4 digits should be used in the expression, but not exactly the ones given. (example: if you are given the digits 2, 2, 6, 9 this program accepts the following solution: 6 * 4 * 2 / 2)\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Logo", "code": "\nWorks with: UCB_Logo version 5.5\n; useful constants\nmake \"false 1=0\nmake \"true  1=1\nmake \"lf char 10\nmake \"sp char 32\n\n; non-digits legal in expression\nmake \"operators (lput sp [+ - * / \\( \\)])\n\n; display help message\nto show_help :digits\n  type lf\n  print sentence quoted [Using only these digits:] :digits \n  print sentence quoted [and these operators:] [* / + -]\n  print quoted [\\(and parentheses as needed\\),]\n  print quoted [enter an arithmetic expression \n     which evaluates to exactly 24.]\n  type lf\n  print quoted [Enter \\\"!\\\" to get fresh numbers.]\n  print quoted [Enter \\\"q\\\" to quit.]\n  type lf\nend\n\nmake \"digits []\nmake \"done false\nuntil [done] [\n\n  if empty? digits [\n    make \"digits (map [(random 9) + 1] [1 2 3 4])\n  ]\n\n  (type \"Solution sp \"for sp digits \"? sp )\n  make \"expression readrawline\n\n  ifelse [expression = \"?] [\n\n    show_help digits\n\n  ] [ifelse [expression = \"q] [\n\n    print \"Bye!\n    make \"done true\n\n  ] [ifelse [expression = \"!] [\n\n    make \"digits []\n\n  ] [\n    make \"exprchars ` expression\n    make \"allowed (sentence digits operators)\n\n    ifelse (member? false (map [[c] member? c allowed] exprchars)) [\n      (print quoted [Illegal character in input.])\n    ] [\n      catch \"error [\n        make \"syntax_error true\n        make \"testval (run expression)\n        make \"syntax_error false\n      ]\n      ifelse syntax_error [\n        (print quoted [Invalid expression.])\n      ] [\n        ifelse (testval = 24) [\n          print quoted [You win!]\n          make \"done true\n        ] [\n          (print (sentence \n            quoted [Incorrect \\(got ] testval quoted [instead of 24\\).]))\n        ]\n      ]\n    ]\n  ]]]\n] \nbye\n\nOutput:\nSolution for 3 8 9 5?\u00a0?\n\nUsing only these digits: 3 8 9 5\nand these operators: * / + -\n(and parentheses as needed),\nenter an arithmetic expression which evaluates to exactly 24.\n\nEnter \"!\" to get fresh numbers.\nEnter \"q\" to quit.\n\nSolution for 3 8 9 5?\u00a0!\nSolution for 9 2 8 5? 9+2+8+5\nYou win!\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "ABAP", "code": "\n\n", "explain": "See 24 game/ABAP\n"}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "F#", "code": "\nopen System\nopen System.Text.RegularExpressions\n\n// Some utilities\nlet (|Parse|_|) regex str =\n   let m = Regex(regex).Match(str)\n   if m.Success then Some ([for g in m.Groups -> g.Value]) else None\nlet rec gcd x y = if x = y || x = 0 then y else if x < y then gcd y x else gcd y (x-y)\nlet abs (x : int) = Math.Abs x\nlet sign (x: int) = Math.Sign x\nlet cint s = Int32.Parse(s)\nlet replace m (s : string) t = Regex.Replace(t, m, s)\n\n// computing in Rationals\ntype Rat(x : int, y : int) =\n    let g = if y <> 0 then gcd (abs x) (abs y) else raise <| DivideByZeroException()\n    member this.n = sign y * x / g   // store a minus sign in the numerator\n    member this.d =\n        if y <> 0 then sign y * y / g else raise <| DivideByZeroException()\n    static member (~-) (x : Rat) = Rat(-x.n, x.d)\n    static member (+) (x : Rat, y : Rat) = Rat(x.n * y.d + y.n * x.d, x.d * y.d)\n    static member (-) (x : Rat, y : Rat) = x + Rat(-y.n, y.d)\n    static member (*) (x : Rat, y : Rat) = Rat(x.n * y.n, x.d * y.d)\n    static member (/) (x : Rat, y : Rat) = x * Rat(y.d, y.n)\n    override this.ToString() = sprintf @\"<%d,%d>\" this.n this.d\n    new(x : string, y : string) = if y = \"\" then Rat(cint x, 1) else Rat(cint x, cint y)\n\n// Due to the constraints imposed by the game (reduced set\n// of operators, all left associativ) we can get away with a repeated reduction\n// to evaluate the algebraic expression.\nlet rec reduce (str :string) =\n    let eval (x : Rat) (y : Rat) = function\n    | \"*\" -> x * y | \"/\" -> x / y | \"+\" -> x + y | \"-\" -> x - y | _ -> failwith \"unknown op\"\n    let subst s r = str.Replace(s, r.ToString())\n    let rstr =\n        match str with\n        | Parse @\"\\(<(-?\\d+),(\\d+)>([*/+-])<(-?\\d+),(\\d+)>\\)\" [matched; xn; xd; op; yn; yd] -> \n            subst matched <| eval (Rat(xn,xd)) (Rat(yn,yd)) op\n        | Parse @\"<(-?\\d+),(\\d+)>([*/])<(-?\\d+),(\\d+)>\" [matched; xn; xd; op; yn; yd] -> \n            subst matched <| eval (Rat(xn,xd)) (Rat(yn,yd)) op\n        | Parse @\"<(-?\\d+),(\\d+)>([+-])<(-?\\d+),(\\d+)>\" [matched; xn; xd; op; yn; yd] -> \n            subst matched <| eval (Rat(xn,xd)) (Rat(yn,yd)) op\n        | Parse @\"\\(<(-?\\d+),(\\d+)>\\)\" [matched; xn; xd] -> \n            subst matched <| Rat(xn,xd)\n        | Parse @\"(?<!>)-<(-?\\d+),(\\d+)>\" [matched; xn; xd] -> \n            subst matched <| -Rat(xn,xd)\n        | _ -> str\n    if str = rstr then str else reduce rstr\n\nlet gameLoop() =\n    let checkInput dddd input =\n        match input with\n        | \"n\" | \"q\" -> Some(input)\n        | Parse @\"[^1-9()*/+-]\" [c] ->\n            printfn \"You used an illegal character in your expression: %s\" c\n            None\n        | Parse @\"^\\D*(\\d)\\D+(\\d)\\D+(\\d)\\D+(\\d)(?:\\D*(\\d))*\\D*$\" [m; d1; d2; d3; d4; d5] ->\n            if d5 = \"\" && (String.Join(\" \", Array.sort [|d1;d2;d3;d4|])) = dddd then Some(input)\n            elif d5 = \"\" then\n                printfn \"Use this 4 digits with operators in between: %s.\" dddd\n                None\n            else \n                printfn \"Use only this 4 digits with operators in between: %s.\" dddd\n                None\n        | _ ->\n            printfn \"Use all 4 digits with operators in between: %s.\" dddd\n            None\n        \n    let rec userLoop dddd  =\n        let tryAgain msg =\n            printfn \"%s\" msg\n            userLoop dddd\n        printf \"[Expr|n|q]: \"\n        match Console.ReadLine() |> replace @\"\\s\" \"\" |> checkInput dddd with\n        | Some(input) -> \n            let data = input |> replace @\"((?<!\\d)-)?\\d+\" @\"<$&,1>\"\n            match data with\n            | \"n\" -> true | \"q\" -> false\n            | _ ->\n                try\n                    match reduce data with\n                    | Parse @\"^<(-?\\d+),(\\d+)>$\" [_; x; y] ->\n                        let n, d = (cint x), (cint y)\n                        if n = 24 then\n                            printfn \"Correct!\"\n                            true\n                        elif d=1 then tryAgain <| sprintf \"Wrong! Value = %d.\" n\n                        else tryAgain <| sprintf \"Wrong! Value = %d/%d.\" n d\n                    | _ -> tryAgain \"Wrong! not a well-formed expression!\"\n                with\n                    | :? System.DivideByZeroException ->\n                        tryAgain \"Wrong! Your expression results in a division by zero!\"\n                    | ex ->\n                        tryAgain <| sprintf \"There is an unforeseen problem with yout input: %s\" ex.Message\n        | None -> userLoop dddd\n\n    let random = new Random(DateTime.Now.Millisecond)\n    let rec loop() =\n        let dddd = String.Join(\" \", Array.init 4 (fun _ -> 1 + random.Next 9) |> Array.sort)\n        printfn \"\\nCompute 24 from the following 4 numbers: %s\" dddd\n        printfn \"Use them in any order with * / + - and parentheses; n = new numbers; q = quit\"\n        if userLoop dddd then loop()\n\n    loop()\n\ngameLoop()\n\n\nOutput:\nCompute 24 from the following 4 numbers: 3 3 3 5\nUse them in any order with * / + - and parentheses; n = new numbers; q = quit\n[Expr|n|q]: n\n\nCompute 24 from the following 4 numbers: 3 5 6 7\nUse them in any order with * / + - and parentheses; n = new numbers; q = quit\n[Expr|n|q]: (7 + 5) + 6/3\nWrong! Value = 14.\n[Expr|n|q]: (7 + 5) * 6/3\nCorrect!\n\nCompute 24 from the following 4 numbers: 3 3 4 5\nUse them in any order with * / + - and parentheses; n = new numbers; q = quit\n[Expr|n|q]: q\n\n", "explain": ""}, {"task_name": "24 game", "task_url": "https://rosettacode.org/wiki/24_game", "task_cat": "Puzzles", "lang": "Groovy", "code": "\nTranslation of: Ruby\n\nfinal random = new Random()\nfinal input = new Scanner(System.in)\n\n\ndef evaluate = { expr ->\n    if (expr == 'QUIT') {\n        return 'QUIT'\n    } else {\n        try { Eval.me(expr.replaceAll(/(\\d)/, '$1.0')) }\n        catch (e) { 'syntax error' }\n    }\n}\n\n\ndef readGuess = { digits ->\n    while (true) {\n        print \"Enter your guess using ${digits} (q to quit): \"\n        def expr = input.nextLine()\n        \n        switch (expr) {\n            case ~/^[qQ].*/:\n                return 'QUIT'\n\n            case ~/.*[^\\d\\s\\+\\*\\/\\(\\)-].*/:\n                def badChars = expr.replaceAll(~/[\\d\\s\\+\\*\\/\\(\\)-]/, '')\n                println \"invalid characters in input: ${(badChars as List) as Set}\"\n                break\n\n            case { (it.replaceAll(~/\\D/, '') as List).sort() != ([]+digits).sort() }:\n                println '''you didn't use the right digits'''\n                break\n\n            case ~/.*\\d\\d.*/:\n                println 'no multi-digit numbers allowed'\n                break\n\n            default:\n                return expr\n        }\n    }\n}\n\n\ndef digits = (1..4).collect { (random.nextInt(9) + 1) as String }\n\nwhile (true) {\n    def guess = readGuess(digits)\n    def result = evaluate(guess)\n    \n    switch (result) {\n        case 'QUIT':\n            println 'Awwww. Maybe next time?'\n            return\n            \n        case 24:\n            println 'Yes! You got it.'\n            return\n            \n        case 'syntax error':\n            println \"A ${result} was found in ${guess}\" \n            break\n            \n        default:\n            println \"Nope: ${guess} == ${result}, not 24\"\n            println 'One more try, then?'\n    }\n}\n\n\n$ groovy TwentyFour.gsh\nEnter your guess using [4, 8, 3, 6] (q to quit): 4836\nno multi-digit numbers allowed\nEnter your guess using [4, 8, 3, 6] (q to quit): 4  ++ ++ 8/ 3-6\nA syntax error was found in 4  ++ ++ 8/ 3-6\nEnter your guess using [4, 8, 3, 6] (q to quit): btsjsb\ninvalid characters in input: [t, s, b, j]\nEnter your guess using [4, 8, 3, 6] (q to quit): 1+3+2+2\nyou didn't use the right digits\nEnter your guess using [4, 8, 3, 6] (q to quit): q\nAwwww. Maybe next time?\n\n$ groovy TwentyFour.gsh\nEnter your guess using [6, 3, 2, 6] (q to quit): 6+6+3+2\nNope: 6+6+3+2 == 17.0, not 24\nOne more try, then?\nEnter your guess using [6, 3, 2, 6] (q to quit): (6*3 - 6) * 2\nYes! You got it.\n", "explain": "This solution breaks strict adherence to the rules in only one way: any line that starts with the letter \"q\" causes the game to quit.\nSample Run:\n"}]