[{"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nPython2: Simple[edit]\nfor i in xrange(1, 101):\n    if i\u00a0% 15 == 0:\n        print \"FizzBuzz\"\n    elif i\u00a0% 3 == 0:\n        print \"Fizz\"\n    elif i\u00a0% 5 == 0:\n        print \"Buzz\"\n    else:\n        print i\nPython3: Simple[edit]\nfor i in range(1, 101):\n    if i\u00a0% 15 == 0:\n        print(\"FizzBuzz\")\n    elif i\u00a0% 3 == 0:\n        print(\"Fizz\")\n    elif i\u00a0% 5 == 0:\n        print(\"Buzz\")\n    else:\n        print(i)\nPython: Simple - no duplication[edit]\nfor n in range(1,101):\n    response = ''\n\n    if not n%3:\n        response += 'Fizz'\n    if not n%5:\n        response += 'Buzz'\n\n    print(response or n)\n\nfor i in range(1,101): print(\"Fizz\"*(i%3==0) + \"Buzz\"*(i%5==0) or i)\n\nfor i in range(100):print(i%3//2*'Fizz'+i%5//4*'Buzz'or i+1)\n\nfor n in range(1, 100):\n    fb = ''.join([ denom[1] if n\u00a0% denom[0] == 0 else '' for denom in [(3,'fizz'),(5,'buzz')] ])\n    print fb if fb else n\n\nprint (', '.join([(x%3<1)*'Fizz'+(x%5<1)*'Buzz' or str(x) for x in range(1,101)]))\nPython: List Comprehension (Python 3)[edit]\n[print(\"FizzBuzz\") if i\u00a0% 15 == 0 else print(\"Fizz\") if i\u00a0% 3 == 0 else print(\"Buzz\") if i\u00a0% 5 == 0 else print(i) for i in range(1,101)]\nPython: Lazily[edit]\n\nfrom itertools import cycle, izip, count, islice\n\nfizzes = cycle([\"\"] * 2 + [\"Fizz\"])\nbuzzes = cycle([\"\"] * 4 + [\"Buzz\"])\nboth = (f + b for f, b in izip(fizzes, buzzes))\n\n# if the string is \"\", yield the number\n# otherwise yield the string\nfizzbuzz = (word or n for word, n in izip(both, count(1)))\n\n# print the first 100\nfor i in islice(fizzbuzz, 100):\n    print i\n\nWorks with: Python version 3.7\n'''Fizz buzz'''\n\nfrom itertools import count, cycle, islice\n\n\n# fizzBuzz\u00a0:: () -> Generator [String]\ndef fizzBuzz():\n    '''A non-finite stream of fizzbuzz terms.\n    '''\n    return map(\n        lambda f, b, n: (f + b) or str(n),\n        cycle([''] * 2 + ['Fizz']),\n        cycle([''] * 4 + ['Buzz']),\n        count(1)\n    )\n\n\n# ------------------------- TEST -------------------------\ndef main():\n    '''Display of first 100 terms of the fizzbuzz series.\n    '''\n    print(\n        '\\n'.join(\n            list(islice(\n                fizzBuzz(),\n                100\n            ))\n        )\n    )\n\n\nif __name__ == '__main__':\n    main()\nPython3.8: With walrus operator[edit]\nprint(*map(lambda n: 'Fizzbuzz '[(i):i+13] if (i\u00a0:= n**4%-15) > -14 else n, range(1,100)))\nPython: Math tricks[edit]\n\ndef numsum(n):\n\t''' The recursive sum of all digits in a number \n        unit a single character is obtained'''\n\tres = sum([int(i) for i in str(n)])\n\tif res < 10: return res\n\telse\u00a0: return numsum(res)\n\t\nfor n in range(1,101):\n\tresponse = 'Fizz'*(numsum(n) in [3,6,9]) + \\\n                   'Buzz'*(str(n)[-1] in ['5','0'])\\\n\t            or n\n\tprint(response)\nPython3: Super concise: 1 line[edit]\nprint(*((lambda x=x: ''.join(chr(c) for c in (102, 105)) + (2 * chr(122)) + ''.join(chr(c) for c in (98, 117)) + (2 * chr(122)) + '\\n' if x\u00a0% (30 >> 1) == 0 else ''.join(chr(c) for c in (102, 105)) + (2 * chr(122)) + '\\n' if x\u00a0% (6 >> 1) == 0 else ''.join(chr(c) for c in (98, 117)) + (2 * chr(122)) + '\\n' if x\u00a0% (10 >> 1) == 0 else str(x) + '\\n')() for x in range(1, 101)))\n", "explain": "One liner using string concatenation:\nOne liner another code:\nList Comprehensions:\nAnother list comprehension:\nYou can also create a lazy, unbounded sequence by using generator expressions:\n\nOr equivalently, in terms of map, and Python 3 libraries:\nNumbers ending in 5 or 0 are divisible by 5. Numbers whose digits recursively summed to a single-digit number == 3,6 or 9  are divisible by 3.  \n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n  int i = 0 ;  char B[88] ;\n  while ( i++ < 100 )\n    !sprintf( B, \"%s%s\", i%3 ? \"\":\"Fizz\", i%5 ? \"\":\"Buzz\" )\n    ? sprintf( B, \"%d\", i ):0, printf( \", %s\", B );\n\n\n  int i = 0 ;  char B[88] ;\n  while ( i++ < 100 )\n    !sprintf( B, \"%s%s%s%s\", \n       i%3 ? \"\":\"Fiz\", i%5 ? \"\":\"Buz\", i%7 ? \"\":\"Goz\", i%11 ? \"\":\"Kaz\" )\n    ? sprintf( B, \"%d\", i ):0, printf( \", %s\", B );\n\nOutput: ..., 89, FizBuz, Goz, 92, Fiz, 94, Buz, Fiz, 97, Goz, FizKaz, Buz\n\n\n#include <stdio.h>\n\nint main() {\n  for (int i=1; i<=105; i++) if (i%3 && i%5) printf(\"%3d \", i); else printf(\"%s%s%s\", i%3?\"\":\"Fizz\", i%5?\"\":\"Buzz\", i%15?\" \":\"\\n\");\n}\n\nThis actually works (the array init part, saves 6 bytes of static data, whee):#include<stdio.h>\n \nint main ()\n{\n  int i;\n  const char *s[] = { \"%d\\n\", \"Fizz\\n\", s[3] + 4, \"FizzBuzz\\n\" };\n  for (i = 1; i <= 100; i++)\n    printf(s[!(i % 3) + 2 * !(i % 5)], i);\n  return 0;\n}\n\n#include<stdio.h>\n\nint main (void)\n{\n    int i;\n    for (i = 1; i <= 100; i++)\n    {\n        if (!(i % 15))\n            printf (\"FizzBuzz\");\n        else if (!(i % 3))\n            printf (\"Fizz\");\n        else if (!(i % 5))\n            printf (\"Buzz\");\n        else\n            printf (\"%d\", i);\n\n        printf(\"\\n\");\n    }\n    return 0;\n}\n\n\n#include <stdio.h>\n \nmain() {\n  int i = 1;\n  while(i <= 100) {\n    if(i % 15 == 0)\n      puts(\"FizzBuzz\");\n    else if(i % 3 == 0)\n      puts(\"Fizz\");\n    else if(i % 5 == 0)\n      puts(\"Buzz\");\n    else\n      printf(\"%d\\n\", i);\n    i++;\n  }\n}\n\n\n#include <stdio.h>\n#define F(x,y) printf(\"%s\",i%x?\"\":#y\"zz\")\nint main(int i){for(--i;i++^100;puts(\"\"))F(3,Fi)|F(5,Bu)||printf(\"%i\",i);return 0;}\n\nWith numbers theory: #include <stdio.h>\n\nint main(void)\n{\n    for (int i = 1; i <= 100; ++i) {\n        if (i % 3 == 0) printf(\"fizz\");\n        if (i % 5 == 0) printf(\"buzz\");\n        if (i * i * i * i % 15 == 1) printf(\"%d\", i);\n        puts(\"\");\n    }\n}\n\n\n#include <stdio.h>\nint main()\n{\n    for (int i=0;++i<101;puts(\"\"))\n    {\n        char f[] = \"FizzBuzz%d\";\n        f[8-i%5&12]=0;\n        printf (f+(-i%3&4+f[8]/8), i);\n    }\n}\n\n", "explain": "For 2 prime numbers and based on a similar minimal JavaScript solution with low signal-to-noise, the C code is:\nWith 4 prime numbers:\nOne line version, with pretty printing\nImplicit int main and return 0 (C99+):\nobfuscated:\nWithout conditionals, anything in the loop body gcc compiles with branching, duplicate tests or duplicate strings. Depends on ASCII and two's complement arithmetic:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\nminimal conditions[edit]\n#include <iostream>\n#include <chrono>\n\nint main()\n{\n\n\tint fizz = 0, buzz = 0, fizzbuzz = 0;\n\n\tbool isFizz = false;\n\n\tauto startTime = std::chrono::high_resolution_clock::now();\n\n\tfor (unsigned int i = 1; i <= 4000000000; i++) {\n\t\tisFizz = false;\n\n\t\tif (i % 3 == 0) {\n\t\t\tisFizz = true;\n\t\t\tfizz++;\n\t\t}\n\n\t\tif (i % 5 == 0) {\n\t\t\tif (isFizz) {\n\t\t\t\tfizz--;\n\t\t\t\tfizzbuzz++;\n\t\t\t}\n\t\t\telse {\n\t\t\t\tbuzz++;\n\t\t\t}\n\t\t}\n\n\t}\n\n\tauto endTime = std::chrono::high_resolution_clock::now();\n\tauto totalTime = endTime - startTime;\n\n\tprintf(\"\\t fizz\u00a0: %d, buzz: %d, fizzbuzz: %d, duration %lld milliseconds\\n\", fizz, buzz, fizzbuzz, (totalTime / std::chrono::milliseconds(1)));\n\n\treturn 0;\n}\n\nwith modulo[edit]\n#include <iostream>\n\nusing namespace std;\nint main ()\n{\n       for (int i = 1; i <= 100; i++) \n       {\n               if ((i % 15) == 0)\n                       cout << \"FizzBuzz\\n\";\n               else if ((i % 3) == 0)\n                       cout << \"Fizz\\n\";\n               else if ((i % 5) == 0)\n                       cout << \"Buzz\\n\";\n               else\n                       cout << i << \"\\n\";\n       }\n       return 0;\n}\n\nwithout modulo 15[edit]\n#include <iostream>\nusing namespace std;\n\nint main()\n{\n  for (int i = 0; i <= 100; ++i)\n  {\n    bool fizz = (i % 3) == 0;\n    bool buzz = (i % 5) == 0;\n    if (fizz)\n      cout << \"Fizz\";\n    if (buzz)\n      cout << \"Buzz\";\n    if (!fizz && !buzz)\n      cout << i;\n    cout << \"\\n\";\n  }\n  return 0;\n}\n\nwithout modulo[edit]\n\n#include <iostream>\n\nint main()\n{\n    int i, f = 2, b = 4; \n\n    for ( i = 1 ; i <= 100 ; ++i, --f, --b )\n    {\n        if ( f && b ) { std::cout << i;             }\n        if ( !f )     { std::cout << \"Fizz\"; f = 3; }\n        if ( !b )     { std::cout << \"Buzz\"; b = 5; }\n        std::cout << std::endl;\n    }\n\n    return 0;\n}\n\nusing std::transform[edit]\nWorks with: C++11\n#include <iostream>                                                                                                     \n#include <algorithm>\n#include <vector>\n\nint main()\n{\n  std::vector<int> range(100);\n  std::iota(range.begin(), range.end(), 1);\n\n  std::vector<std::string> values;\n  values.resize(range.size());\n\n  auto fizzbuzz = [](int i) -> std::string {\n    if ((i%15) == 0) return \"FizzBuzz\";\n    if ((i%5) == 0)  return \"Buzz\";\n    if ((i%3) == 0)  return \"Fizz\";\n    return std::to_string(i);\n  };\n\n  std::transform(range.begin(), range.end(), values.begin(), fizzbuzz);\n\n  for (auto& str: values) std::cout << str << std::endl;\n\n  return 0;\n}\n\nmetaprogramming[edit]\n\n#include <iostream>\n\ntemplate <int n, int m3, int m5> \nstruct fizzbuzz : fizzbuzz<n-1, (n-1)%3, (n-1)%5>\n{\n  fizzbuzz() \n  { std::cout << n << std::endl; }\n};\n\ntemplate <int n>\nstruct fizzbuzz<n, 0, 0> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>\n{\n  fizzbuzz() \n  { std::cout << \"FizzBuzz\" << std::endl; }\n};\n\ntemplate <int n, int p>\nstruct fizzbuzz<n, 0, p> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>\n{\n  fizzbuzz() \n  { std::cout << \"Fizz\" << std::endl; }\n};\n\ntemplate <int n, int p>\nstruct fizzbuzz<n, p, 0> : fizzbuzz<n-1, (n-1)%3, (n-1)%5>\n{\n  fizzbuzz() \n  { std::cout << \"Buzz\" << std::endl; }\n};\n\ntemplate <>\nstruct fizzbuzz<0,0,0>\n{\n  fizzbuzz() \n  { std::cout << 0 << std::endl; }\n};\n\ntemplate <int n>\nstruct fb_run\n{\n  fizzbuzz<n, n%3, n%5> fb;\n};\n\nint main()\n{\n  fb_run<100> fb;\n  return 0;\n}\n\nhardcore templates[edit]\n\n#include <iostream>\n#include <string>\n#include <cstdlib>\n#include <boost/mpl/string.hpp>\n#include <boost/mpl/fold.hpp>\n#include <boost/mpl/size_t.hpp>\n\nusing namespace std;\nusing namespace boost;\n\n///////////////////////////////////////////////////////////////////////////////\n// exponentiation calculations\ntemplate <int accum, int base, int exp> struct POWER_CORE : POWER_CORE<accum * base, base, exp - 1>{};\n\ntemplate <int accum, int base>\nstruct POWER_CORE<accum, base, 0>\n{\n    enum : int { val = accum };\n};\n\ntemplate <int base, int exp> struct POWER : POWER_CORE<1, base, exp>{};\n\n///////////////////////////////////////////////////////////////////////////////\n// # of digit calculations\ntemplate <int depth, unsigned int i> struct NUM_DIGITS_CORE : NUM_DIGITS_CORE<depth + 1, i / 10>{};\n\ntemplate <int depth>\nstruct NUM_DIGITS_CORE<depth, 0>\n{\n    enum : int { val = depth};\n};\n\ntemplate <int i> struct NUM_DIGITS : NUM_DIGITS_CORE<0, i>{};\n\ntemplate <>\nstruct NUM_DIGITS<0>\n{\n    enum : int { val = 1 };\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Convert digit to character (1 -> '1')\ntemplate <int i>\nstruct DIGIT_TO_CHAR\n{\n    enum : char{ val = i + 48 };\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Find the digit at a given offset into a number of the form 0000000017\ntemplate <unsigned int i, int place> // place -> [0 .. 10]\nstruct DIGIT_AT\n{\n    enum : char{ val = (i / POWER<10, place>::val) % 10 };\n};\n\nstruct NULL_CHAR\n{\n    enum : char{ val = '\\0' };\n};\n\n///////////////////////////////////////////////////////////////////////////////\n// Convert the digit at a given offset into a number of the form '0000000017' to a character\ntemplate <unsigned int i, int place> // place -> [0 .. 9]\n    struct ALT_CHAR : DIGIT_TO_CHAR< DIGIT_AT<i, place>::val >{};\n\n///////////////////////////////////////////////////////////////////////////////\n// Convert the digit at a given offset into a number of the form '17' to a character\n\n// Template description, with specialization to generate null characters for out of range offsets\ntemplate <unsigned int i, int offset, int numDigits, bool inRange>  \n    struct OFFSET_CHAR_CORE_CHECKED{};\ntemplate <unsigned int i, int offset, int numDigits>                \n    struct OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, false> : NULL_CHAR{};\ntemplate <unsigned int i, int offset, int numDigits>                \n    struct OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, true>  : ALT_CHAR<i, (numDigits - offset) - 1 >{};\n\n// Perform the range check and pass it on\ntemplate <unsigned int i, int offset, int numDigits>\n    struct OFFSET_CHAR_CORE : OFFSET_CHAR_CORE_CHECKED<i, offset, numDigits, offset < numDigits>{};\n\n// Calc the number of digits and pass it on\ntemplate <unsigned int i, int offset>\n    struct OFFSET_CHAR : OFFSET_CHAR_CORE<i, offset, NUM_DIGITS<i>::val>{};\n\n///////////////////////////////////////////////////////////////////////////////\n// Integer to char* template. Works on unsigned ints.\ntemplate <unsigned int i>\nstruct IntToStr\n{\n    const static char str[];\n    typedef typename mpl::string<\n    OFFSET_CHAR<i, 0>::val,\n    OFFSET_CHAR<i, 1>::val,\n    OFFSET_CHAR<i, 2>::val,\n    OFFSET_CHAR<i, 3>::val,\n    OFFSET_CHAR<i, 4>::val,\n    OFFSET_CHAR<i, 5>::val,\n    /*OFFSET_CHAR<i, 6>::val,\n    OFFSET_CHAR<i, 7>::val,\n    OFFSET_CHAR<i, 8>::val,\n    OFFSET_CHAR<i, 9>::val,*/\n    NULL_CHAR::val>::type type;\n};\n\ntemplate <unsigned int i>\nconst char IntToStr<i>::str[] = \n{\n    OFFSET_CHAR<i, 0>::val,\n    OFFSET_CHAR<i, 1>::val,\n    OFFSET_CHAR<i, 2>::val,\n    OFFSET_CHAR<i, 3>::val,\n    OFFSET_CHAR<i, 4>::val,\n    OFFSET_CHAR<i, 5>::val,\n    OFFSET_CHAR<i, 6>::val,\n    OFFSET_CHAR<i, 7>::val,\n    OFFSET_CHAR<i, 8>::val,\n    OFFSET_CHAR<i, 9>::val,\n    NULL_CHAR::val\n};\n\ntemplate <bool condition, class Then, class Else>\nstruct IF\n{\n    typedef Then RET;\n};\n\ntemplate <class Then, class Else>\nstruct IF<false, Then, Else>\n{\n    typedef Else RET;\n};\n\n\ntemplate < typename Str1, typename Str2 >\nstruct concat : mpl::insert_range<Str1, typename mpl::end<Str1>::type, Str2> {};\ntemplate <typename Str1, typename Str2, typename Str3 >\nstruct concat3 : mpl::insert_range<Str1, typename mpl::end<Str1>::type, typename concat<Str2, Str3 >::type > {};\n\ntypedef typename mpl::string<'f','i','z','z'>::type fizz;\ntypedef typename mpl::string<'b','u','z','z'>::type buzz;\ntypedef typename mpl::string<'\\r', '\\n'>::type mpendl;\ntypedef typename concat<fizz, buzz>::type fizzbuzz;\n\n// discovered boost mpl limitation on some length\n\ntemplate <int N>\nstruct FizzBuzz\n{\n    typedef typename concat3<typename FizzBuzz<N - 1>::type, typename IF<N % 15 == 0, typename fizzbuzz::type, typename IF<N % 3 == 0, typename fizz::type, typename IF<N % 5 == 0, typename buzz::type, typename IntToStr<N>::type >::RET >::RET >::RET, typename mpendl::type>::type type;\n};\n\ntemplate <>\nstruct FizzBuzz<1>\n{\n    typedef mpl::string<'1','\\r','\\n'>::type type;\n};\n\nint main(int argc, char** argv)\n{\n    const int n = 7;\n    std::cout << mpl::c_str<FizzBuzz<n>::type>::value << std::endl;\n\treturn 0;\n}\n\n\n", "explain": "Modulo can be expensive on some architectures.\nVersion computing FizzBuzz at compile time with metaprogramming:\nCompile with -ftemplate-depth-9000 -std=c++0x:\nNote: it takes up lots of memory and takes several seconds to compile. To enable compilation for 7 < n <= 25, please, modify include/boost/mpl/limits/string.hpp BOOST_MPL_LIMIT_STRING_SIZE to 128 instead of 32).\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\npublic class FizzBuzz {\n    public static void main(String[] args) {\n        for (int number = 1; number <= 100; number++) {\n            if (number\u00a0% 15 == 0) {\n                System.out.println(\"FizzBuzz\");\n            } else if (number\u00a0% 3 == 0) {\n                System.out.println(\"Fizz\");\n            } else if (number\u00a0% 5 == 0) {\n                System.out.println(\"Buzz\");\n            } else {\n                System.out.println(number);\n            }\n        }\n    }\n}\n\npublic class FizzBuzz {\n    public static void main(String[] args) {\n        int number = 1;\n        while (number <= 100) {\n            if (number\u00a0% 15 == 0) {\n                System.out.println(\"FizzBuzz\");\n            } else if (number\u00a0% 3 == 0) {\n                System.out.println(\"Fizz\");\n            } else if (number\u00a0% 5 == 0) {\n                System.out.println(\"Buzz\");\n            } else {\n                System.out.println(number);\n            }\n            number++;\n        }\n    }\n}\n\npublic class FizzBuzz {\n    public static void main(String[] args) {\n        int number = 1;\n        while (number <= 100) {\n            System.out.println(number\u00a0% 15 == 0\u00a0? \"FizzBuzz\"\u00a0: number\u00a0% 3 == 0\u00a0? \"Fizz\"\u00a0: number\u00a0% 5 == 0\u00a0? \"Buzz\"\u00a0: number);\n            number++;\n        }\n    }\n}\n\nimport java.util.stream.IntStream;\nclass FizzBuzzJdk12 {\n    public static void main(String[] args) {\n        IntStream.range(1,101)\n        .mapToObj(i->switch (i%15) {\n            case 0 -> \"FizzBuzz\";\n            case 3, 6, 9, 12 -> \"Fizz\";\n            case 5, 10 -> \"Buzz\";\n            default -> Integer.toString(i);\n        })\n        .forEach(System.out::println)\n       \u00a0;\n    }\n}\n\nimport java.util.stream.IntStream;\n\nclass FizzBuzzJdk12 {\n    static final int FIZZ_FLAG = 0x8000_0000;\n    static final int BUZZ_FLAG = 0x4000_0000;\n    static final int FIZZ_BUZZ_FLAG = FIZZ_FLAG|BUZZ_FLAG;\n    static final int[] FLAGS = new int[] {\n        FIZZ_BUZZ_FLAG|0, 1, 2, FIZZ_FLAG|3, 4, \n        BUZZ_FLAG|5, FIZZ_FLAG|6, 7, 8, FIZZ_FLAG|9,\n        BUZZ_FLAG|10, 11, FIZZ_FLAG|12, 13, 14\n    };\n    public static void main(String[] args) {\n    IntStream.iterate(0,i->++i)\n       .flatMap(i -> IntStream.range(0,15).map(j->FLAGS[j]+15*i))\n       .mapToObj(\n        // JDK12 switch expression ...\n        n-> switch(n & FIZZ_BUZZ_FLAG) {\n            case FIZZ_BUZZ_FLAG -> \"fizzbuzz\";\n            case FIZZ_FLAG -> \"fizz\";\n            case BUZZ_FLAG -> \"buzz\";\n            default -> Integer.toString(~FIZZ_BUZZ_FLAG & n);\n            }\n       )\n       .skip(1)\n       .limit(100)\n       .forEach(System.out::println)\n      \u00a0;\n    }\n}\n", "explain": "Or: \nOr: \nOr: \nOr: \n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nclass Program\n{\n    public void FizzBuzzGo()\n    {\n        Boolean Fizz = false;\n        Boolean Buzz = false;\n        for (int count = 1; count <= 100; count ++)\n        {\n            Fizz = count % 3 == 0;\n            Buzz = count % 5 == 0;\n            if (Fizz && Buzz)\n            {\n                Console.WriteLine(\"Fizz Buzz\");\n                listBox1.Items.Add(\"Fizz Buzz\");\n            }\n            else if (Fizz)\n            {\n                Console.WriteLine(\"Fizz\");\n                listBox1.Items.Add(\"Fizz\");\n            }\n            else if (Buzz)\n            {\n                Console.WriteLine(\"Buzz\");\n                listBox1.Items.Add(\"Buzz\");\n            }\n            else\n            {\n                Console.WriteLine(count);\n                listBox1.Items.Add(count);\n            }\n        }\n    }\n}\n\nclass Program\n{\n    static void Main()\n    {\n        for (uint i = 1; i <= 100; i++)\n        {\n            string s = null;\n \n            if (i % 3 == 0)\n                s = \"Fizz\";\n \n            if (i % 5 == 0)\n                s += \"Buzz\";\n \n            System.Console.WriteLine(s ?? i.ToString());\n        }\n    }\n}\n\nusing System;\nusing System.Linq;\n\nnamespace FizzBuzz\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Enumerable.Range(1, 100)\n                .Select(a => String.Format(\"{0}{1}\", a % 3 == 0 ? \"Fizz\" : string.Empty, a % 5 == 0 ? \"Buzz\" : string.Empty))\n                .Select((b, i) => String.IsNullOrEmpty(b) ? (i + 1).ToString() : b)\n                .ToList()\n                .ForEach(Console.WriteLine);\n        }\n    }\n}\n\nusing System;\nusing System.Globalization;\nusing System.Linq;\n\nnamespace FizzBuzz\n{\n    class Program\n    {\n        static void Main()\n        {\n            Enumerable.Range(1, 100)\n                .GroupBy(e => e % 15 == 0 ? \"FizzBuzz\" : e % 5 == 0 ? \"Buzz\" : e % 3 == 0 ? \"Fizz\" : string.Empty)\n                .SelectMany(item => item.Select(x => new { \n                    Value = x, \n                    Display = String.IsNullOrEmpty(item.Key) ? x.ToString(CultureInfo.InvariantCulture) : item.Key \n                }))\n                .OrderBy(x => x.Value)\n                .Select(x => x.Display)\n                .ToList()\n                .ForEach(Console.WriteLine);\n        }\n    }\n}\n\nusing System;\nnamespace FizzBuzz\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            for (int i = 1; i <= 100; i++)\n            {\n                if (i % 15 == 0)\n                {\n                    Console.WriteLine(\"FizzBuzz\");\n                }\n                else if (i % 3 == 0)\n                {\n                    Console.WriteLine(\"Fizz\");\n                }\n                else if (i % 5 == 0)\n                {\n                    Console.WriteLine(\"Buzz\");\n                }\n                else\n                {\n                    Console.WriteLine(i);\n                }\n            }\n        }\n    }\n}\n\nusing System;\nusing System.Globalization;\n\nnamespace Rosettacode\n{\n    class Program\n    {\n        static void Main()\n        {\n            for (var number = 0; number < 100; number++)\n            {\n                if ((number % 3) == 0 & (number % 5) == 0)\n                {\n                    //For numbers which are multiples of both three and five print \"FizzBuzz\".\n                    Console.WriteLine(\"FizzBuzz\");\n                    continue;\n                }\n\n                if ((number % 3) == 0) Console.WriteLine(\"Fizz\");\n                if ((number % 5) == 0) Console.WriteLine(\"Buzz\");\n                if ((number % 3) != 0 && (number % 5) != 0) Console.WriteLine(number.ToString(CultureInfo.InvariantCulture));\n\n                if (number % 5 == 0)\n                {\n                    Console.WriteLine(Environment.NewLine);\n                }\n            }\n        }\n    }\n}\n\nusing System;\nusing System.Linq;\n \nnamespace FizzBuzz\n{\n    class Program\n    {\n        static void Main(string[] args)\n        {\n            Enumerable.Range(1, 100).ToList().ForEach(i => Console.WriteLine(i % 5 == 0 ? string.Format(i % 3 == 0 ? \"Fizz{0}\" : \"{0}\", \"Buzz\") : string.Format(i%3 == 0 ? \"Fizz\" : i.ToString())));\n        }\n    }\n}\n\nWith C#8 switch expressions[edit]\nclass Program\n{\n    public static string FizzBuzzIt(int n) =>\n        (n % 3, n % 5) switch\n        {\n            (0, 0) => \"FizzBuzz\",\n            (0, _) => \"Fizz\",\n            (_, 0) => \"Buzz\",\n            (_, _) => $\"{n}\"\n        };\n\n    static void Main(string[] args)\n    { \n        foreach (var n in Enumerable.Range(1, 100))\n        {\n            Console.WriteLine(FizzBuzzIt(n));\n        }\n    }\n}\n\nTDD using delegates[edit]\nusing System;\nusing System.Collections;\nusing System.Collections.Generic;\nusing System.Globalization;\nusing System.Linq;\nusing Microsoft.VisualStudio.TestTools.UnitTesting;\n\nnamespace FizzBuzz\n{\n    [TestClass]\n    public class FizzBuzzTest\n    {\n        private FizzBuzz fizzBuzzer;\n\n        [TestInitialize]\n        public void Initialize()\n        {\n            fizzBuzzer = new FizzBuzz();\n        }\n\n        [TestMethod]\n        public void Give4WillReturn4()\n        {\n            Assert.AreEqual(\"4\", fizzBuzzer.FizzBuzzer(4));\n        }\n\n        [TestMethod]\n        public void Give9WillReturnFizz()\n        {\n            Assert.AreEqual(\"Fizz\", fizzBuzzer.FizzBuzzer(9));\n        }\n\n        [TestMethod]\n        public void Give25WillReturnBuzz()\n        {\n            Assert.AreEqual(\"Buzz\", fizzBuzzer.FizzBuzzer(25));\n        }\n\n        [TestMethod]\n        public void Give30WillReturnFizzBuzz()\n        {\n            Assert.AreEqual(\"FizzBuzz\", fizzBuzzer.FizzBuzzer(30));\n        }\n\n        [TestMethod]\n        public void First15()\n        {\n            ICollection expected = new ArrayList\n                {\"1\", \"2\", \"Fizz\", \"4\", \"Buzz\", \"Fizz\", \"7\", \"8\", \"Fizz\", \"Buzz\", \"11\", \"Fizz\", \"13\", \"14\", \"FizzBuzz\"};\n\n            var actual = Enumerable.Range(1, 15).Select(x => fizzBuzzer.FizzBuzzer(x)).ToList();\n\n            CollectionAssert.AreEqual(expected, actual);\n        }\n\n        [TestMethod]\n        public void From1To100_ToShowHowToGet100()\n        {\n            const int expected = 100;\n            var actual = Enumerable.Range(1, 100).Select(x => fizzBuzzer.FizzBuzzer(x)).ToList();\n\n            Assert.AreEqual(expected, actual.Count);\n        }\n    }\n\n    public class FizzBuzz\n    {\n        private delegate string Xzzer(int value);\n        private readonly IList<Xzzer> _functions = new List<Xzzer>();\n\n        public FizzBuzz()\n        {\n            _functions.Add(x => x % 3 == 0 ? \"Fizz\" : \"\");\n            _functions.Add(x => x % 5 == 0 ? \"Buzz\" : \"\");\n        }\n\n        public string FizzBuzzer(int value)\n        {\n            var result = _functions.Aggregate(String.Empty, (current, function) => current + function.Invoke(value));\n            return String.IsNullOrEmpty(result) ? value.ToString(CultureInfo.InvariantCulture) : result;\n        }\n    }\n}\n\nGood old C ways[edit]\nusing System;\nint max = 100;\nfor(int i=0;\n    ++i<=max; \n    Console.WriteLine(\"{0}{1}{2}\", i%3==0 ? \"Fizz\" : \"\", i%5==0 ? \"Buzz\" : \"\", i%3!=0 && i%5!=0  ? i.ToString() : \"\")\n){}\n\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\nES5[edit]\nvar fizzBuzz = function () {\n  var i, output;\n  for (i = 1; i < 101; i += 1) {\n    output = '';\n    if (!(i\u00a0% 3)) { output += 'Fizz'; }\n    if (!(i\u00a0% 5)) { output += 'Buzz'; }\n    console.log(output || i);//empty string is false, so we short-circuit\n  }\n};\n\nfor (var i = 1; i <= 100; i++) {\n  console.log({\n    truefalse: 'Fizz', \n    falsetrue: 'Buzz', \n    truetrue: 'FizzBuzz'\n  }[(i%3==0) + '' + (i%5==0)] || i)\n}\n\nfor(i=1;i<101;i++)console.log((x=(i%3?'':'Fizz')+(i%5?'':'Buzz'))?x:i);\n\nfor(i=1;i<101;i++)console.log((i%3?'':'Fizz')+(i%5?'':'Buzz')||i)\n\n(function rng(i) {\n    return i\u00a0? rng(i - 1).concat(i)\u00a0: []\n})(100).map(\n    function (n) {\n        return n\u00a0% 3\u00a0? (\n            n\u00a0% 5\u00a0? n\u00a0: \"Buzz\"\n        )\u00a0: (\n            n\u00a0% 5\u00a0? \"Fizz\"\u00a0: \"FizzBuzz\"\n        )\n    }\n).join(' ')\nES6[edit]\n(() => {\n\n    // FIZZBUZZ --------------------------------------------------------------\n\n    // fizzBuzz\u00a0:: Int -> String\n    const fizzBuzz = n =>\n        caseOf(n, [\n            [x => x\u00a0% 15 === 0, \"FizzBuzz\"],\n            [x => x\u00a0% 3 === 0, \"Fizz\"],\n            [x => x\u00a0% 5 === 0, \"Buzz\"]\n        ], n.toString());\n\n    // GENERIC FUNCTIONS -----------------------------------------------------\n\n    // caseOf\u00a0:: a -> [(a -> Bool, b)] -> b -> b\n    const caseOf = (e, pvs, otherwise) =>\n        pvs.reduce((a, [p, v]) =>\n            a\u00a0!== otherwise\u00a0? a\u00a0: (p(e)\u00a0? v\u00a0: a), otherwise);\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = (m, n) =>\n        Array.from({\n            length: Math.floor(n - m) + 1\n        }, (_, i) => m + i);\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = (f, xs) => xs.map(f);\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n    // TEST ------------------------------------------------------------------\n    return unlines(\n        map(fizzBuzz, enumFromTo(1, 100))\n    );\n})();\n\nconst factors = [[3, 'Fizz'], [5, 'Buzz']]\nconst fizzBuzz = num => factors.map(([factor,text]) => (num\u00a0% factor)?'':text).join('') || num\nconst range1 = x => [...Array(x+1).keys()].slice(1)\nconst outputs = range1(100).map(fizzBuzz)\n\nconsole.log(outputs.join('\\n'))\n\nTranslation of: Python\nTranslation of: Haskell\n(() => {\n    'use strict';\n\n    // main\u00a0:: IO ()\n    const main = () => {\n\n        // FIZZBUZZ ---------------------------------------\n\n        // fizzBuzz\u00a0:: Generator [String]\n        const fizzBuzz = () => {\n            const fb = n => k => cycle(\n                replicate(n - 1)('').concat(k)\n            );\n            return zipWith(\n                liftA2(flip)(bool)(isNull)\n            )(\n                zipWith(append)(fb(3)('fizz'))(fb(5)('buzz'))\n            )(fmap(str)(enumFrom(1)));\n        };\n\n        // TEST -------------------------------------------\n        console.log(\n            unlines(\n                take(100)(\n                    fizzBuzz()\n                )\n            )\n        );\n    };\n\n    // GENERIC FUNCTIONS ----------------------------------\n\n    // Just\u00a0:: a -> Maybe a\n    const Just = x => ({\n        type: 'Maybe',\n        Nothing: false,\n        Just: x\n    });\n\n    // Nothing\u00a0:: Maybe a\n    const Nothing = () => ({\n        type: 'Maybe',\n        Nothing: true,\n    });\n\n    // Tuple (,)\u00a0:: a -> b -> (a, b)\n    const Tuple = a => b => ({\n        type: 'Tuple',\n        '0': a,\n        '1': b,\n        length: 2\n    });\n\n    // append (++)\u00a0:: [a] -> [a] -> [a]\n    // append (++)\u00a0:: String -> String -> String\n    const append = xs => ys => xs.concat(ys);\n\n    // bool\u00a0:: a -> a -> Bool -> a\n    const bool = f => t => p =>\n        p\u00a0? t\u00a0: f;\n\n    // cycle\u00a0:: [a] -> Generator [a]\n    function* cycle(xs) {\n        const lng = xs.length;\n        let i = 0;\n        while (true) {\n            yield(xs[i])\n            i = (1 + i)\u00a0% lng;\n        }\n    }\n\n    // enumFrom\u00a0:: Int => Int -> [Int]\n    function* enumFrom(x) {\n        let v = x;\n        while (true) {\n            yield v;\n            v = 1 + v;\n        }\n    }\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        x => y => f(y)(x);\n\n    // fmap <$>\u00a0:: (a -> b) -> Gen [a] -> Gen [b]\n    const fmap = f =>\n        function*(gen) {\n            let v = take(1)(gen);\n            while (0 < v.length) {\n                yield(f(v[0]))\n                v = take(1)(gen)\n            }\n        };\n\n    // fst\u00a0:: (a, b) -> a\n    const fst = tpl => tpl[0];\n\n    // isNull\u00a0:: [a] -> Bool\n    // isNull\u00a0:: String -> Bool\n    const isNull = xs =>\n        1 > xs.length;\n\n    // Returns Infinity over objects without finite length.\n    // This enables zip and zipWith to choose the shorter\n    // argument when one is non-finite, like cycle, repeat etc\n\n    // length\u00a0:: [a] -> Int\n    const length = xs =>\n        (Array.isArray(xs) || 'string' === typeof xs)\u00a0? (\n            xs.length\n        )\u00a0: Infinity;\n\n    // liftA2\u00a0:: (a0 -> b -> c) -> (a -> a0) -> (a -> b) -> a -> c\n    const liftA2 = op => f => g =>\n        // Lift a binary function to a composition\n        // over two other functions.\n        // liftA2 (*) (+ 2) (+ 3) 7 == 90\n        x => op(f(x))(g(x));\n\n    // replicate\u00a0:: Int -> a -> [a]\n    const replicate = n => x =>\n        Array.from({\n            length: n\n        }, () => x);\n\n    // snd\u00a0:: (a, b) -> b\n    const snd = tpl => tpl[1];\n\n    // str\u00a0:: a -> String\n    const str = x => x.toString();\n\n    // take\u00a0:: Int -> [a] -> [a]\n    // take\u00a0:: Int -> String -> String\n    const take = n => xs =>\n        'GeneratorFunction'\u00a0!== xs.constructor.constructor.name\u00a0? (\n            xs.slice(0, n)\n        )\u00a0: [].concat.apply([], Array.from({\n            length: n\n        }, () => {\n            const x = xs.next();\n            return x.done\u00a0? []\u00a0: [x.value];\n        }));\n\n    // The first argument is a sample of the type\n    // allowing the function to make the right mapping\n\n    // uncons\u00a0:: [a] -> Maybe (a, [a])\n    const uncons = xs => {\n        const lng = length(xs);\n        return (0 < lng)\u00a0? (\n            lng < Infinity\u00a0? (\n                Just(Tuple(xs[0])(xs.slice(1))) // Finite list\n            )\u00a0: (() => {\n                const nxt = take(1)(xs);\n                return 0 < nxt.length\u00a0? (\n                    Just(Tuple(nxt[0])(xs))\n                )\u00a0: Nothing();\n            })() // Lazy generator\n        )\u00a0: Nothing();\n    };\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs => xs.join('\\n');\n\n    // zipWith\u00a0:: (a -> b -> c) Gen [a] -> Gen [b] -> Gen [c]\n    const zipWith = f => ga => gb => {\n        function* go(ma, mb) {\n            let\n                a = ma,\n                b = mb;\n            while (!a.Nothing && !b.Nothing) {\n                let\n                    ta = a.Just,\n                    tb = b.Just\n                yield(f(fst(ta))(fst(tb)));\n                a = uncons(snd(ta));\n                b = uncons(snd(tb));\n            }\n        }\n        return go(uncons(ga), uncons(gb));\n    };\n\n    // MAIN ---\n    return main();\n})();\n", "explain": "Alternate version with ghetto pattern matching\nOr very tersely:\nOr with even less characters:\nOr, in a more functional style, without mutations\nA functional implementation:\n\nOr composing generic functions, and without use of modulo (or other) numeric tests:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\n\n", "explain": "See FizzBuzz/Basic\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "SQL", "code": "\nLibrary: SQL\nOracle SQL[edit]\nSELECT CASE\n    WHEN MOD(level,15)=0 THEN 'FizzBuzz'\n    WHEN MOD(level,3)=0 THEN 'Fizz'\n    WHEN MOD(level,5)=0 THEN 'Buzz'\n    ELSE TO_CHAR(level)\n    END FizzBuzz\n    FROM dual\n    CONNECT BY LEVEL <= 100;\n\nSELECT nvl(decode(MOD(level,3),0,'Fizz')||decode(MOD(level,5),0,'Buzz'),level)\nFROM dual\nCONNECT BY level<=100;\nPostgreSQL specific[edit]\nSELECT i, fizzbuzz \n  FROM \n    (SELECT i, \n            CASE \n              WHEN i\u00a0% 15 = 0 THEN 'FizzBuzz' \n              WHEN i\u00a0%  5 = 0 THEN 'Buzz' \n              WHEN i\u00a0%  3 = 0 THEN 'Fizz' \n              ELSE NULL \n            END AS fizzbuzz \n       FROM generate_series(1,100) AS i) AS fb \n WHERE fizzbuzz IS NOT NULL;\n\nSELECT COALESCE(FIZZ || BUZZ, FIZZ, BUZZ, OUTPUT) AS FIZZBUZZ FROM\n(SELECT GENERATE_SERIES AS FULL_SERIES, TO_CHAR(GENERATE_SERIES,'99') AS OUTPUT \nFROM GENERATE_SERIES(1,100)) F LEFT JOIN \n(SELECT TEXT 'Fizz' AS FIZZ, GENERATE_SERIES AS FIZZ_SERIES FROM GENERATE_SERIES(0,100,3)) FIZZ ON\nFIZZ.FIZZ_SERIES = F.FULL_SERIES LEFT JOIN\n(SELECT TEXT 'Buzz' AS BUZZ, GENERATE_SERIES AS BUZZ_SERIES FROM GENERATE_SERIES(0,100,5)) BUZZ ON\nBUZZ.BUZZ_SERIES = F.FULL_SERIES;\nRecursive Common Table Expressions (MSSQL 2005+)[edit]\nWITH nums (n, fizzbuzz ) AS (\n\tSELECT 1, CONVERT(nvarchar, 1) UNION ALL\n\tSELECT\n\t\t(n + 1) as n1, \n\t\tCASE\n\t\t\tWHEN (n + 1)\u00a0% 15 = 0 THEN 'FizzBuzz'\n\t\t\tWHEN (n + 1)\u00a0% 3  = 0 THEN 'Fizz'\n\t\t\tWHEN (n + 1)\u00a0% 5  = 0 THEN 'Buzz'\n\t\t\tELSE CONVERT(nvarchar, (n + 1))\n\t\tEND\n\tFROM nums WHERE n < 100\n)\nSELECT n, fizzbuzz FROM nums\nORDER BY n ASC\nOPTION ( MAXRECURSION 100 )\nSQL Anywhere specific - minimalist[edit]\nSELECT \n        isnull(if row_num\u00a0% 3 = 0 then 'Fizz' endif + if row_num\u00a0% 5 = 0 then 'Buzz' endif, str(row_num)) \nFROM \n        sa_rowgenerator(1,100)\nGeneric SQL using a join[edit]\n\n-- Load some numbers\nCREATE TABLE numbers(i INTEGER);\nINSERT INTO numbers VALUES(1);\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\nINSERT INTO numbers SELECT i + (SELECT MAX(i) FROM numbers) FROM numbers;\n-- Define the fizzes and buzzes\nCREATE TABLE fizzbuzz (message VARCHAR(8), divisor INTEGER);\nINSERT INTO fizzbuzz VALUES('fizz',      3);\nINSERT INTO fizzbuzz VALUES('buzz',      5);\nINSERT INTO fizzbuzz VALUES('fizzbuzz', 15);\n-- Play fizzbuzz\nSELECT COALESCE(max(message),CAST(i AS VARCHAR(99))) as result\nFROM numbers LEFT OUTER JOIN fizzbuzz ON MOD(i,divisor) = 0\nGROUP BY i\nHAVING i <= 100\nORDER BY i;\n-- Tidy up\nDROP TABLE fizzbuzz;\nDROP TABLE numbers;\n", "explain": "Or using Oracle's DECODE and NVL:\nUsing Generate_Series and tables only:\nThis should work in most RDBMSs, but you may need to change MOD(i,divisor) to i\u00a0% divisor.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\nif/else ladder approach[edit]\n<?php\nfor ($i = 1; $i <= 100; $i++)\n{\n    if (!($i\u00a0% 15))\n        echo \"FizzBuzz\\n\";\n    else if (!($i\u00a0% 3))\n        echo \"Fizz\\n\";\n    else if (!($i\u00a0% 5))\n        echo \"Buzz\\n\";\n    else\n        echo \"$i\\n\";\n}\n?>\nConcatenation approach[edit]\n\n<?php\nfor ( $i = 1; $i <= 100; ++$i )\n{\n     $str = \"\";\n\n     if (!($i\u00a0% 3 ) )\n          $str .= \"Fizz\";\n\n     if (!($i\u00a0% 5 ) )\n          $str .= \"Buzz\";\n\n     if ( empty( $str ) )\n          $str = $i;\n\n     echo $str . \"\\n\";\n}\n?>\nConcatenation approach without if-s[edit]\n<?php\nfor (\n    $i = 0;\n    $i++ < 100;\n    $o = ($i\u00a0% 3\u00a0? ''\u00a0: 'Fizz') . ($i\u00a0% 5\u00a0? ''\u00a0: 'Buzz')\n)\n    echo $o\u00a0?\u00a0: $i, PHP_EOL;\n?>\nOne Liner Approach[edit]\n<?php\nfor($i = 1; $i <= 100 and print(($i\u00a0% 15\u00a0? $i\u00a0% 5\u00a0? $i\u00a0% 3\u00a0? $i\u00a0: 'Fizz'\u00a0: 'Buzz'\u00a0: 'FizzBuzz') . \"\\n\"); ++$i);\n?>\nCompact One Liner Approach[edit]\nfor($i=0;$i++<100;)echo($i%3?'':'Fizz').($i%5?'':'Buzz')?:$i,\"\\n\";\nArray One Liner Approach[edit]\nfor($i = 0; $i++ < 100;) echo [$i, 'Fizz', 'Buzz', 'FizzBuzz'][!($i\u00a0% 3) + 2 *\u00a0!($i\u00a0% 5)], \"\\n\";\n", "explain": "Uses PHP's concatenation operator (.=) to build the output string. The concatenation operator allows us to add data to the end of a string without overwriting the whole string. Since Buzz will always appear if our number is divisible by five, and Buzz is the second part of \"FizzBuzz\", we can simply append \"Buzz\" to our string.\nIn contrast to the if-else ladder, this method lets us skip the check to see if $i is divisible by both 3 and 5 (i.e. 15). However, we get the added complexity of needing to reset $str to an empty string (not necessary in some other languages), and we also need a separate if statement to check to see if our string is empty, so we know if $i was not divisible by 3 or 5.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "MATLAB", "code": "\n\nfunction fizzBuzz() \n    for i = (1:100)\n        if mod(i,15) == 0\n           fprintf('FizzBuzz ')\n        elseif mod(i,3) == 0\n           fprintf('Fizz ')\n        elseif mod(i,5) == 0\n           fprintf('Buzz ')\n        else\n           fprintf('%i ',i)) \n        end\n    end\n    fprintf('\\n');    \nend\n\nfunction out = fizzbuzzS()\n\tnums = [3, 5];\n\twords = {'fizz', 'buzz'};\n\tfor (n=1:100)\n\t\ttempstr = '';\n\t\tfor (i = 1:2)\n\t\t\tif mod(n,nums(i))==0\n\t\t\t\ttempstr = [tempstr,  words{i}];\n\t\t\tend\n\t\tend\n\t\tif length(tempstr) == 0 \n\t\t\tdisp(n);\n\t\telse \n\t\t\tdisp(tempstr);\n\t\tend\n\tend\nend\n\nx            = string(1:100);\nx(3:3:$)     = 'Fizz';\nx(5:5:$)     = 'Buzz';\nx(3*5:3*5:$) = 'FizzBuzz'\n", "explain": "There are more sophisticated solutions to this task, but in the spirit of \"lowest level of comprehension required to illustrate adequacy\" this is what one might expect from a novice programmer (with a little variation in how the strings are stored and displayed).\nHere's a more extendible version that uses disp() to print the output:\nstraightforward\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\n\nprogram fizzbuzz_if\n   integer\u00a0:: i\n   \n   do i = 1, 100\n      if     (mod(i,15) == 0) then; print *, 'FizzBuzz'\n      else if (mod(i,3) == 0) then; print *, 'Fizz'\n      else if (mod(i,5) == 0) then; print *, 'Buzz'\n      else;                         print *, i\n      end if\n   end do\nend program fizzbuzz_if\n\nprogram FizzBuzz\nimplicit none\ninteger\u00a0:: i = 1\n\ndo i = 1, 100\n    if (Mod(i,3) == 0)write(*,\"(A)\",advance='no')  \"Fizz\"\n    if (Mod(i,5) == 0)write(*,\"(A)\",advance='no') \"Buzz\"\n    if (Mod(i,3) /= 0 .and. Mod(i,5) /=0 )write(*,\"(I3)\",advance='no') i\n    print *, \"\"\nend do\nend program FizzBuzz\n\nprogram fizzbuzz_select\n    integer\u00a0:: i\n    \n    do i = 1, 100\n       select case (mod(i,15))\n          case 0;        print *, 'FizzBuzz'\n          case 3,6,9,12; print *, 'Fizz'\n          case 5,10;     print *, 'Buzz'\n          case default;  print *, i\n       end select\n    end do\n end program fizzbuzz_select\n", "explain": "In ANSI FORTRAN 77 or later use structured IF-THEN-ELSE (example uses some ISO Fortran 90 features):\nThis example uses If statements to print \"Fizz\" and \"Buzz\" next to each other if the number is divisible by 3 and 5 by waiting to use a line break until after the If statements.\nIn ISO Fortran 90 or later use SELECT-CASE statement:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\nswitch/case approach[edit]\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i\u00a0:= 1; i <= 100; i++ {\n        switch {\n        case i%15==0:\n            fmt.Println(\"FizzBuzz\")\n        case i%3==0:\n            fmt.Println(\"Fizz\")\n        case i%5==0:\n            fmt.Println(\"Buzz\")\n        default: \n            fmt.Println(i)\n        }\n    }\n}\nmap approach[edit]\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i\u00a0:= 1; i <= 100; i++ {\n        fmt.Println(map[bool]map[bool]interface{}{\n            false: {false: i, true: \"Fizz\"}, true: {false: \"Buzz\", true: \"FizzBuzz\"},\n        }[i%5 == 0][i%3 == 0])\n    }\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "ARM_Assembly", "code": "\n/ * linux GAS */\n\n.global _start\n\n.data\n\nFizz: .ascii \"Fizz\\n\"\nBuzz: .ascii \"Buzz\\n\"\nFizzAndBuzz: .ascii \"FizzBuzz\\n\"\n\nnumstr_buffer: .skip 3\nnewLine: .ascii \"\\n\"\n\n.text\n\n_start:\n\n  bl FizzBuzz\n\n  mov r7, #1\n  mov r0, #0\n  svc #0\n\nFizzBuzz:\n\n  push {lr}\n  mov r9, #100\n\n  fizzbuzz_loop:\n\n    mov r0, r9\n    mov r1, #15\n    bl divide\n    cmp r1, #0\n    ldreq r1, =FizzAndBuzz\n    moveq r2, #9\n    beq fizzbuzz_print\n\n    mov r0, r9\n    mov r1, #3\n    bl divide\n    cmp r1, #0\n    ldreq r1, =Fizz\n    moveq r2, #5\n    beq fizzbuzz_print\n\n    mov r0, r9\n    mov r1, #5\n    bl divide\n    cmp r1, #0\n    ldreq r1, =Buzz\n    moveq r2, #5\n    beq fizzbuzz_print\n\n    mov r0, r9\n    bl make_num\n    mov r2, r1\n    mov r1, r0\n\n    fizzbuzz_print:\n\n      mov r0, #1\n      mov r7, #4\n      svc #0\n\n      sub r9, #1\n      cmp r9, #0\n\n    bgt fizzbuzz_loop\n\n  pop {lr}\n  mov pc, lr\n\nmake_num:\n\n  push {lr}\n  ldr r4, =numstr_buffer\n  mov r5, #4\n  mov r6, #1\n\n  mov r1, #100\n  bl divide\n\n  cmp r0, #0\n  subeq r5, #1\n  movne r6, #0\n\n  add r0, #48\n  strb r0, [r4, #0]\n\n  mov r0, r1\n  mov r1, #10\n  bl divide\n\n  cmp r0, #0\n  movne r6, #0\n  cmp r6, #1\n  subeq r5, #1\n\n  add r0, #48\n  strb r0, [r4, #1]\n\n  add r1, #48\n  strb r1, [r4, #2]\n\n  mov r2, #4\n  sub r0, r2, r5\n  add r0, r4, r0\n  mov r1, r5\n\n  pop {lr}\n  mov pc, lr\n\ndivide:\n  udiv r2, r0, r1\n  mul r3, r1, r2\n  sub r1, r0, r3\n  mov r0, r2\n  mov pc, lr\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "MIPS_Assembly", "code": "\n#################################\n# Fizz Buzz                     #\n# MIPS Assembly targetings MARS #\n# By Keith Stellyes             #\n# August 24, 2016               #\n#################################\n\n# $a0 left alone for printing\n# $a1 stores our counter\n# $a2 is 1 if not evenly divisible\n\n.data\n\tfizz: .asciiz \"Fizz\\n\"\n\tbuzz: .asciiz \"Buzz\\n\"\n\tfizzbuzz: .asciiz \"FizzBuzz\\n\"\n\tnewline: .asciiz \"\\n\"\n\n.text\nloop:\n\tbeq $a1,100,exit\n\tadd $a1,$a1,1\n\t\n\t#test for counter mod 15 (\"FIZZBUZZ\")\n\tdiv $a2,$a1,15\n\tmfhi $a2\n\tbnez $a2,loop_not_fb #jump past the fizzbuzz print logic if NOT MOD 15\n\t\n#### PRINT FIZZBUZZ: ####\n\tli $v0,4 #set syscall arg to PRINT_STRING\n\tla $a0,fizzbuzz #set the PRINT_STRING arg to fizzbuzz\n\tsyscall #call PRINT_STRING\n\tj loop #return to start\n#### END PRINT FIZZBUZZ ####\n\t\nloop_not_fb:\t\n\tdiv $a2,$a1,3 #divide $a1 (our counter) by 3 and store remainder in HI\n\tmfhi $a2 #retrieve remainder (result of MOD)\n\tbnez $a2, loop_not_f #jump past the fizz print logic if NOT MOD 3\n\t\n#### PRINT FIZZ ####\n\tli $v0,4 \n\tla $a0,fizz\n\tsyscall\n\tj loop\n#### END PRINT FIZZ ####\n\nloop_not_f:\n\tdiv $a2,$a1,5\n\tmfhi $a2\n\tbnez $a2,loop_not_b\n\n#### PRINT BUZZ ####\n\tli $v0,4 \n\tla $a0,buzz\n\tsyscall\n\tj loop\n#### END PRINT BUZZ ####\n\nloop_not_b:\n\t#### PRINT THE INTEGER ####\n\tli $v0,1 #set syscall arg to PRINT_INTEGER\n\tmove $a0,$a1 #set PRINT_INTEGER arg to contents of $a1\n\tsyscall #call PRINT_INTEGER\n\t\n\t### PRINT THE NEWLINE CHAR ###\n\tli $v0,4 #set syscall arg to PRINT_STRING\n\tla $a0,newline\n\tsyscall\n\t\n\tj loop #return to beginning\n\nexit:\n\tli $v0,10\n\tsyscall\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "X86_Assembly", "code": "\n; x86_64 linux nasm\n\nsection .bss\nnumber resb 4\n\nsection .data\nfizz: db \"Fizz\"\nbuzz: db \"Buzz\"\nnewLine: db 10\n\nsection .text\nglobal _start\n\n_start:\n\n  mov rax, 1     \u00a0; initialize counter\n\n  loop:\n    push rax\n    call fizzBuzz\n    pop rax\n    inc rax\n    cmp rax, 100\n    jle loop\n\n  mov rax, 60\n  mov rdi, 0\n  syscall\n\nfizzBuzz:\n  mov r10, rax\n  mov r15, 0      \u00a0; boolean fizz or buzz\n  checkFizz:\n    xor rdx, rdx  \u00a0; clear rdx for division\n    mov rbx, 3\n    div rbx\n    cmp rdx, 0    \u00a0; modulo result here\n    jne checkBuzz\n    mov r15, 1\n    mov rsi, fizz\n    mov rdx, 4\n    mov rax, 1\n    mov rdi, 1\n    syscall\n  checkBuzz:\n    mov rax, r10\n    xor rdx, rdx\n    mov rbx, 5\n    div rbx\n    cmp rdx, 0\n    jne finishLine\n    mov r15, 1\n    mov rsi, buzz\n    mov rdx, 4\n    mov rax, 1\n    mov rdi, 1\n    syscall\n  finishLine:     \u00a0; print number if no fizz or buzz\n    cmp r15, 1\n    je nextLine\n    mov rax, r10\n    call printNum\n    ret\n    nextLine:\n      mov rsi, newLine\n      mov rdx, 1\n      mov rax, 1\n      mov rdi, 1\n      syscall\n      ret\n\nprintNum:         \u00a0; write proper digits into number buffer\n  cmp rax, 100\n  jl lessThanHundred\n  mov byte [number], 49\n  mov byte [number + 1], 48\n  mov byte [number + 2], 48\n  mov rdx, 3\n  jmp print\n\n  lessThanHundred:\u00a0; get digits to write through division \n    xor rdx, rdx\n    mov rbx, 10\n    div rbx\n    add rdx, 48\n    cmp rax, 0\n    je lessThanTen\n    add rax, 48\n    mov byte [number], al\n    mov byte [number + 1], dl\n    mov rdx, 2\n    jmp print\n\n  lessThanTen:\n    mov byte [number], dl\n    mov rdx, 1\n  print:\n    mov byte [number + rdx], 10  \u00a0; add newline\n    inc rdx\n    mov rax, 1\n    mov rdi, 1\n    mov rsi, number\n    syscall\n  ret\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nprogram FizzBuzz;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils;\n\nvar\n  i: Integer;\nbegin\n  for i\u00a0:= 1 to 100 do\n  begin\n    if i mod 15 = 0 then\n      Writeln('FizzBuzz')\n    else if i mod 3 = 0 then\n      Writeln('Fizz')\n    else if i mod 5 = 0 then\n      Writeln('Buzz')\n    else\n      Writeln(i);\n  end;\nend.\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\n1.upto(100) do |n|\n  print \"Fizz\" if a = (n\u00a0% 3).zero?\n  print \"Buzz\" if b = (n\u00a0% 5).zero?\n  print n unless (a || b)\n  puts\nend\n\n(1..100).each do |n|\n  puts if (n\u00a0% 15).zero?\n    \"FizzBuzz\"\n  elsif (n\u00a0% 5).zero?\n    \"Buzz\"\n  elsif (n\u00a0% 3).zero?\n    \"Fizz\"\n  else\n    n\n  end\nend\n\nclass Enumerator::Lazy\n  def filter_map\n    Lazy.new(self) do |holder, *values|\n      result = yield *values\n      holder << result if result\n    end\n  end\nend\n \nclass Fizz\n  def initialize(head, tail)\n    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i\u00a0% 3 == 0}.first(tail)\n  end\n \n  def fizz?(num)\n    search = @list\n    search.include?(num)\n  end\n \n  def drop(num)\n    list = @list\n    list.delete(num)\n  end\n \n  def to_a\n    @list.to_a\n  end\nend\n \nclass Buzz\n  def initialize(head, tail)\n    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i\u00a0% 5 == 0}.first(tail)\n  end\n \n  def buzz?(num)\n    search = @list\n    search.include?(num)\n  end\n \n  def drop(num)\n    list = @list\n    list.delete(num)\n  end\n \n  def to_a\n    @list.to_a\n  end\nend\n \nclass FizzBuzz\n  def initialize(head, tail)\n    @list = (head..Float::INFINITY).lazy.filter_map{|i| i if i\u00a0% 15 == 0}.first(tail)\n  end\n \n  def fizzbuzz?(num)\n    search = @list\n    search.include?(num)\n  end\n \n  def to_a\n    @list.to_a\n  end\n \n  def drop(num)\n    list = @list\n    list.delete(num)\n  end\nend\nstopper = 100\n@fizz = Fizz.new(1,100)\n@buzz = Buzz.new(1,100)\n@fizzbuzz = FizzBuzz.new(1,100)\ndef min(v, n)\n  if v == 1\n    puts \"Fizz: #{n}\"\n    @fizz::drop(n)\n  elsif v == 2\n    puts \"Buzz: #{n}\"\n    @buzz::drop(n)\n  else\n    puts \"FizzBuzz: #{n}\"\n    @fizzbuzz::drop(n)\n  end\nend\n(@fizz.to_a & @fizzbuzz.to_a).map{|d| @fizz::drop(d)}\n(@buzz.to_a & @fizzbuzz.to_a).map{|d| @buzz::drop(d)}\nwhile @fizz.to_a.min < stopper or @buzz.to_a.min < stopper or @fizzbuzz.to_a.min < stopper\n  f, b, fb = @fizz.to_a.min, @buzz.to_a.min, @fizzbuzz.to_a.min\n  min(1,f)  if f < fb and f < b\n  min(2,b)  if b < f and b < fb\n  min(0,fb) if fb < b and fb < f\nend\n\n(1..100).each do |n|\n  v = \"#{\"Fizz\" if n\u00a0% 3 == 0}#{\"Buzz\" if n\u00a0% 5 == 0}\"\n  puts v.empty?\u00a0? n\u00a0: v\nend\n\n1.upto(100) { |n| puts \"#{'Fizz' if n\u00a0% 3 == 0}#{'Buzz' if n\u00a0% 5 == 0}#{n if n\u00a0% 3\u00a0!= 0 && n\u00a0% 5\u00a0!= 0}\" }\n\n1.upto 100 do |n|\n  r = ''\n  r << 'Fizz' if n\u00a0% 3 == 0\n  r << 'Buzz' if n\u00a0% 5 == 0\n  r << n.to_s if r.empty?\n  puts r\nend\n\n1.upto(100) { |i| puts \"#{[:Fizz][i%3]}#{[:Buzz][i%5]}\"[/.+/] || i }\n\n1.upto(100){|i|puts'FizzBuzz '[n=i**4%-15,n+13]||i}\n\nf = [nil, nil, :Fizz].cycle\nb = [nil, nil, nil, nil, :Buzz].cycle\n(1..100).each do |i|\n  puts \"#{f.next}#{b.next}\"[/.+/] || i\nend\n\nseq = *0..100\n{Fizz:3, Buzz:5, FizzBuzz:15}.each{|k,n| n.step(100,n){|i|seq[i]=k}}\nputs seq.drop(1)\n\nclass Integer\n  def fizzbuzz\n    v = \"#{\"Fizz\" if self\u00a0% 3 == 0}#{\"Buzz\" if self\u00a0% 5 == 0}\"\n    v.empty?\u00a0? self\u00a0: v\n  end\nend\n\nputs *(1..100).map(&:fizzbuzz)\n\nfizzbuzz = ->(i) do\n  (i%15).zero? and next \"FizzBuzz\"\n  (i%3).zero?  and next \"Fizz\"\n  (i%5).zero?  and next \"Buzz\"\n  i\nend\n\nputs (1..100).map(&fizzbuzz).join(\"\\n\")\n\n1.upto(100) do |n|\n  puts case [(n\u00a0% 3).zero?, (n\u00a0% 5).zero?]\n       in true, false\n         \"Fizz\"\n       in false, true\n         \"Buzz\"\n       in true, true\n         \"FizzBuzz\"\n       else\n         n\n       end\nend\n", "explain": "A bit more straightforward:\nEnumerable#Lazy and classes:\nWe can grab the first n fizz/buzz/fizzbuzz numbers in a list with a user defined function (filter_map), starting at the number we desire\ni.e, grabbing the first 10 fizz numbers starting from 30, fizz = Fizz.new(30,10) #=> [30, 33, 36, 39, 42, 45, 48, 51, 54, 57]\nAn example using string interpolation:\nInterpolation inspired one-liner:\nAn example using append:\nYet another solution:\nYet another solution:\nUsed Enumerable#cycle:\nAfter beforehand preparing the Array which put the number from 1 to 100, it processes.\nMonkeypatch example:\nWithout mutable variables or inline printing.\nJump anywhere#Ruby has a worse example of FizzBuzz, using a continuation!\nUsing Ruby 3's Pattern Matching:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\n\nfn main() {\n    for i in 1..=100 {\n        match (i\u00a0% 3, i\u00a0% 5) {\n            (0, 0) => println!(\"fizzbuzz\"),\n            (0, _) => println!(\"fizz\"),\n            (_, 0) => println!(\"buzz\"),\n            (_, _) => println!(\"{}\", i),\n        }\n    }\n}\n\nuse std::borrow::Cow;\n\nfn main() {\n    (1..=100)\n        .map(|n| match (n\u00a0% 3, n\u00a0% 5) {\n            (0, 0) => \"FizzBuzz\".into(),\n            (0, _) => \"Fizz\".into(),\n            (_, 0) => \"Buzz\".into(),\n            _ => Cow::from(n.to_string()),\n        })\n        .for_each(|n| println!(\"{:?}\", n));\n}\n\nuse std::fmt::Write;\n\nfn fizzbuzz() -> String {\n    (1..=100).fold(String::new(), |mut output, x| {\n        let fizz = if x\u00a0% 3 == 0 { \"fizz\" } else { \"\" };\n        let buzz = if x\u00a0% 5 == 0 { \"buzz\" } else { \"\" };\n        if fizz.len() + buzz.len()\u00a0!= 0 {\n            output + fizz + buzz + \"\\n\"\n        } else {\n            write!(&mut output, \"{}\", x).unwrap();\n            output + \"\\n\"\n        }\n    })\n}\n\nfn main() {\n    println!(\"{}\", fizzbuzz());\n}\n\n#![no_std]\n#![feature(asm, lang_items, libc, no_std, start)]\n \nextern crate libc;\n \nconst LEN: usize = 413;\nstatic OUT: [u8; LEN] = *b\"\\\n    1\\n2\\nFizz\\n4\\nBuzz\\nFizz\\n7\\n8\\nFizz\\nBuzz\\n11\\nFizz\\n13\\n14\\nFizzBuzz\\n\\\n    16\\n17\\nFizz\\n19\\nBuzz\\nFizz\\n22\\n23\\nFizz\\nBuzz\\n26\\nFizz\\n28\\n29\\nFizzBuzz\\n\\\n    31\\n32\\nFizz\\n34\\nBuzz\\nFizz\\n37\\n38\\nFizz\\nBuzz\\n41\\nFizz\\n43\\n44\\nFizzBuzz\\n\\\n    46\\n47\\nFizz\\n49\\nBuzz\\nFizz\\n52\\n53\\nFizz\\nBuzz\\n56\\nFizz\\n58\\n59\\nFizzBuzz\\n\\\n    61\\n62\\nFizz\\n64\\nBuzz\\nFizz\\n67\\n68\\nFizz\\nBuzz\\n71\\nFizz\\n73\\n74\\nFizzBuzz\\n\\\n    76\\n77\\nFizz\\n79\\nBuzz\\nFizz\\n82\\n83\\nFizz\\nBuzz\\n86\\nFizz\\n88\\n89\\nFizzBuzz\\n\\\n    91\\n92\\nFizz\\n94\\nBuzz\\nFizz\\n97\\n98\\nFizz\\nBuzz\\n\";\n \n#[start]\nfn start(_argc: isize, _argv: *const *const u8) -> isize {\n    unsafe {\n        asm!(\n            \"\n            mov $$1, %rax\n            mov $$1, %rdi\n            mov $0, %rsi\n            mov $1, %rdx\n            syscall\n            \"\n           \u00a0:\n           \u00a0: \"r\" (&OUT[0]) \"r\" (LEN)\n           \u00a0: \"rax\", \"rdi\", \"rsi\", \"rdx\"\n           \u00a0:\n        );\n    }\n    0\n}\n \n#[lang = \"eh_personality\"] extern fn eh_personality() {}\n#[lang = \"panic_fmt\"] extern fn panic_fmt() {}\n", "explain": "Basic example with a for loop and match:\nUsing an iterator and immutable data:\nA folding iterator version, buffered with a single string allocation, by making use of expressions the write! macro.\nOr the ultimate optimized version with hardcoded output, no standard library or main function, and direct assembly syscalls to write to stdout. \n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nusing a switch statement[edit]\nfor i in 1...100 {\n    switch (i\u00a0% 3, i\u00a0% 5) {\n    case (0, 0):\n        print(\"FizzBuzz\")\n    case (0, _):\n        print(\"Fizz\")\n    case (_, 0):\n        print(\"Buzz\")\n    default:\n        print(i)\n    }\n}\nusing two if statements and an Optional[edit]\nfor i in 1...100{\n    var s:String?\n    if i%3==0{s=\"Fizz\"}\n    if i%5==0{s=(s\u00a0?? \"\")+\"Buzz\"}\n    print(s\u00a0?? i)\n}\nusing a precomputed cycle[edit]\nimport Foundation\n\nlet formats: [String] = [\n  \"%d\",\n  \"%d\",\n  \"fizz\",\n  \"%d\",\n  \"buzz\",\n  \"fizz\",\n  \"%d\",\n  \"%d\",\n  \"fizz\",\n  \"buzz\",\n  \"%d\",\n  \"fizz\",\n  \"%d\",\n  \"%d\",\n  \"fizzbuzz\",\n]\n\nvar count = 0\nvar index = 0\nwhile count < 100 {\n  count += 1\n  print(String(format: formats[index], count))\n  index += 1\n  index\u00a0%= 15\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nxx <- x <- 1:100\nxx[x\u00a0%% 3 == 0] <- \"Fizz\"\nxx[x\u00a0%% 5 == 0] <- \"Buzz\"\nxx[x\u00a0%% 15 == 0] <- \"FizzBuzz\"\nxx\n\nxx <- rep(\"\", 100)\nx <- 1:100\nxx[x\u00a0%% 3 == 0] <- paste0(xx[x\u00a0%% 3 == 0], \"Fizz\")\nxx[x\u00a0%% 5 == 0] <- paste0(xx[x\u00a0%% 5 == 0], \"Buzz\")\nxx[xx == \"\"] <- x[xx == \"\"]\nxx\n\nx <- paste0(rep(\"\", 100), c(\"\", \"\", \"Fizz\"), c(\"\", \"\", \"\", \"\", \"Buzz\"))\ncat(ifelse(x == \"\", 1:100, x), sep = \"\\n\")\n\nx <- paste0(rep(\"\", 100), rep(c(\"\", \"Fizz\"), times = c(2, 1)), rep(c(\"\", \"Buzz\"), times = c(4, 1)))\ncat(ifelse(x == \"\", 1:100, x), sep = \"\\n\")\n\nx <- 1:100\nifelse(x\u00a0%% 15 == 0, 'FizzBuzz',\n       ifelse(x\u00a0%% 5 == 0, 'Buzz',\n              ifelse(x\u00a0%% 3 == 0, 'Fizz', x)))\n\nnamedNums <- c(Fizz = 3, Buzz = 5)\nfor(i in 1:100)\n{\n  isFactor <- i\u00a0%% namedNums == 0\n  print(if(any(isFactor)) paste0(names(namedNums)[isFactor], collapse = \"\") else i)\n}\n", "explain": "Or, without directly checking for divisibility by 15:\nOr, (ab)using the vector recycling rule:\nOr, for an abuse of the recycling rules that could be generalised:\nOr, with a more straightforward use of ifelse:\nOr, adapting from General FizzBuzz#Names solution:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "COBOL", "code": "\nCanonical version[edit]\nWorks with: OpenCOBOL\n      * FIZZBUZZ.COB\n      * cobc -x -g FIZZBUZZ.COB\n      *\n       IDENTIFICATION        DIVISION.\n       PROGRAM-ID.           fizzbuzz.\n       DATA                  DIVISION.\n       WORKING-STORAGE       SECTION.\n       01 CNT      PIC 9(03) VALUE 1.\n       01 REM      PIC 9(03) VALUE 0.\n       01 QUOTIENT PIC 9(03) VALUE 0.\n       PROCEDURE             DIVISION.\n      *\n       PERFORM UNTIL CNT > 100\n         DIVIDE 15 INTO CNT GIVING QUOTIENT REMAINDER REM\n         IF REM = 0\n           THEN\n             DISPLAY \"FizzBuzz \" WITH NO ADVANCING\n           ELSE\n             DIVIDE 3 INTO CNT GIVING QUOTIENT REMAINDER REM\n             IF REM = 0\n               THEN\n                 DISPLAY \"Fizz \" WITH NO ADVANCING\n               ELSE\n                 DIVIDE 5 INTO CNT GIVING QUOTIENT REMAINDER REM\n                 IF REM = 0\n                   THEN\n                     DISPLAY \"Buzz \" WITH NO ADVANCING\n                   ELSE\n                     DISPLAY CNT \" \" WITH NO ADVANCING\n                 END-IF\n             END-IF\n         END-IF\n         ADD 1 TO CNT\n       END-PERFORM\n       DISPLAY \"\"\n       STOP RUN.\n\nSimpler version[edit]\n\nWorks with: OpenCOBOL\nIdentification division.\nProgram-id. fizz-buzz.\n\nData division.\nWorking-storage section.\n\n01 num pic 999.\n\nProcedure division.\n    Perform varying num from 1 by 1 until num > 100\n        if function mod (num, 15) = 0 then display \"fizzbuzz\"\n        else if function mod (num, 3) = 0 then display \"fizz\"\n        else if function mod (num, 5) = 0 then display \"buzz\"\n        else display num\n    end-perform.\n    Stop run.\n\nEvaluate Version[edit]\n\nWorks with: OpenCOBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID.  FIZZBUZZ.\n       ENVIRONMENT DIVISION.\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  X PIC 999.\n       01  Y PIC 999.\n       01  REM3 PIC 999.\n       01  REM5 PIC 999.\n       PROCEDURE DIVISION.\n           PERFORM VARYING X FROM 1 BY 1 UNTIL X > 100\n               DIVIDE X BY 3 GIVING Y REMAINDER REM3\n               DIVIDE X BY 5 GIVING Y REMAINDER REM5\n            EVALUATE REM3 ALSO REM5\n              WHEN ZERO ALSO ZERO\n                DISPLAY \"FizzBuzz\"\n              WHEN ZERO ALSO ANY\n                DISPLAY \"Fizz\"\n              WHEN ANY ALSO ZERO\n                DISPLAY \"Buzz\"\n              WHEN OTHER\n                DISPLAY X\n            END-EVALUATE\n           END-PERFORM\n           STOP RUN\n           .\n\nChase the Fizz[edit]\nWorks with: OpenCOBOL\n\n         >>SOURCE FORMAT FREE\nidentification division.\nprogram-id. fizzbuzz.\ndata division.\nworking-storage section.\n01  i pic 999.\n01  fizz pic 999 value 3.\n01  buzz pic 999 value 5.\nprocedure division.\nstart-fizzbuzz.\n    perform varying i from 1 by 1 until i > 100 \n        evaluate i also i\n        when fizz also buzz\n            display 'fizzbuzz'\n            add 3 to fizz\n            add 5 to buzz\n        when fizz also any\n            display 'fizz'\n            add 3 to fizz\n        when buzz also any\n            display 'buzz'\n            add 5 to buzz\n        when other\n            display i\n        end-evaluate\n    end-perform\n    stop run\n    .\nend program fizzbuzz.\n\n", "explain": "I know this doesn't have the full-bodied, piquant flavor\nexpected from COBOL, but it is a little shorter.\nI think this shows clearly that it's resolving the problem and illuminating the rules specified\nA solution that simply evaluates and adds.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO; use Ada.Text_IO;\n \nprocedure Fizzbuzz is\nbegin\n   for I in 1..100 loop\n      if I mod 15 = 0 then\n         Put_Line(\"FizzBuzz\");\n      elsif I mod 5 = 0 then\n         Put_Line(\"Buzz\");\n      elsif I mod 3 = 0 then\n         Put_Line(\"Fizz\");\n      else\n         Put_Line(Integer'Image(I));\n      end if;\n   end loop;\nend Fizzbuzz;\n\n\n", "explain": "\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 1.8.5\n\nfor i in 1:100\n    if i\u00a0% 15 == 0\n        println(\"FizzBuzz\")\n    elseif i\u00a0% 3 == 0\n        println(\"Fizz\")\n    elseif i\u00a0% 5 == 0\n        println(\"Buzz\")\n    else\n        println(i)\n    end\nend\n\ncollect(i\u00a0% 15 == 0\u00a0? \"FizzBuzz\"\u00a0: i\u00a0% 5 == 0\u00a0? \"Buzz\"\u00a0: i\u00a0% 3 == 0\u00a0? \"Fizz\"\u00a0: i for i in 1:100) |> println\n\nfb(i::Integer) = \"Fizz\" ^ (i\u00a0% 3 == 0) * \"Buzz\" ^ (i\u00a0% 5 == 0) * string(i) ^ (i\u00a0% 3\u00a0!= 0 && i\u00a0% 5\u00a0!= 0)\nfor i in 1:100 println(fb(i)) end\n\nprintln.(map(fb, 1:100))\n\nfor i in 1:100\n    msg = \"Fizz\" ^ (i\u00a0% 3 == 0) * \"Buzz\" ^ (i\u00a0% 5 == 0)\n    println(isempty(msg)\u00a0? i\u00a0: msg)\nend\n", "explain": "One basic solution:\nAnother possible solution:\nA 3rd possible solution:\nA 4th one:\nA fifth (DRY, Don't Repeat Yourself) possible solution:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\ndata _null_;\n  do i=1 to 100;\n    if mod(i,15)=0 then put \"FizzBuzz\";\n    else if mod(i,5)=0 then put \"Buzz\";\n    else if mod(i,3)=0 then put \"Fizz\";\n    else put i;\n  end;\nrun;\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nImperative solution[edit]\nfun fizzBuzz() {\n    for (number in 1..100) {\n        println(\n            when {\n                number\u00a0% 15 == 0 -> \"FizzBuzz\"\n                number\u00a0% 3 == 0 -> \"Fizz\"\n                number\u00a0% 5 == 0 -> \"Buzz\"\n                else -> number\n            }\n        )\n    }\n}\nFunctional solution 1[edit]\nfun fizzBuzz1() {\n    fun fizzBuzz(x: Int) = if (x\u00a0% 15 == 0) \"FizzBuzz\" else x.toString()\n    fun fizz(x: Any) = if (x is Int && x\u00a0% 3 == 0) \"Buzz\" else x\n    fun buzz(x: Any) = if (x is Int && x.toInt()\u00a0% 5 == 0) \"Fizz\" else x\n\n    (1..100).map { fizzBuzz(it) }.map { fizz(it) }.map { buzz(it) }.forEach { println(it) }\n}\nFunctional solution 2[edit]\nfun fizzBuzz2() {\n    fun fizz(x: Pair<Int, StringBuilder>) = if(x.first\u00a0% 3 == 0) x.apply { second.append(\"Fizz\") } else x\n    fun buzz(x: Pair<Int, StringBuilder>) = if(x.first\u00a0% 5 == 0) x.apply { second.append(\"Buzz\") } else x\n    fun none(x: Pair<Int, StringBuilder>) = if(x.second.isBlank()) x.second.apply { append(x.first) } else x.second\n\n    (1..100).map { Pair(it, StringBuilder()) }\n            .map { fizz(it) }\n            .map { buzz(it) }\n            .map { none(it) }\n            .forEach { println(it) }\n}\nShort version with mapOf[edit]\nfun fizzBuzz() {\n    (1..100).forEach { println(mapOf(0 to it, it\u00a0% 3 to \"Fizz\", it\u00a0% 5 to \"Buzz\", it\u00a0% 15 to \"FizzBuzz\")[0]) }\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\nuse strict;\nuse warnings;\nuse feature qw(say);\n\nfor my $i (1..100) {\n    say $i\u00a0% 15 == 0\u00a0? \"FizzBuzz\"\n     \u00a0: $i\u00a0%  3 == 0\u00a0? \"Fizz\"\n     \u00a0: $i\u00a0%  5 == 0\u00a0? \"Buzz\"\n     \u00a0: $i;\n}\n\nprint 'Fizz'x!($_\u00a0% 3) . 'Buzz'x!($_\u00a0% 5) || $_, \"\\n\" for 1 .. 100;\n\nprint+(Fizz)[$_%3].(Buzz)[$_%5]||$_,$/for 1..1e2\n\nmap((Fizz)[$_%3].(Buzz)[$_%5]||$_,1..100);\n\nuse feature \"say\";\n\n@a = (\"FizzBuzz\", 0, 0, \"Fizz\", 0, \"Buzz\", \"Fizz\", 0, 0, \"Fizz\", \"Buzz\", 0, \"Fizz\");\n\nsay $a[$_\u00a0% 15] || $_ for 1..100;\n\nsub fizz_buzz {\n    join(\"\\n\", map {\n        sub mult {$_\u00a0% shift == 0};\n        my @out;\n        if (mult 3) { push @out, \"Fizz\"; }\n        if (mult 5) { push @out, \"Buzz\"; }\n        if (!@out) {push @out, $_; }\n        join('', @out);\n    } (1..100)).\"\\n\";\n}\nprint fizz_buzz;\n\n \n@FB1 = (1..100);\n@FB2 = map{!($_%3 or $_%5)?'FizzBuzz': $_}@FB1;\n@FB3 = map{(/\\d/ and\u00a0!($_%3))?'Fizz': $_}@FB2;\n@FB4 = map{(/\\d/ and\u00a0!($_%5))?'Buzz': $_}@FB3;\n@FB5 = map{$_.\"\\n\"}@FB4;\nprint @FB5;\n", "explain": "More concisely:\nFor code-golfing:\nFor array of values:\nCheating:\nas a subroutine:\nBy transforming a list:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Objective-C", "code": "\n// FizzBuzz in Objective-C\n#import <Foundation/Foundation.h>\n\nint main(int argc, char* argv[]) {\n\tfor (NSInteger i=1; I <= 101; i++) {\n\t\tif (i\u00a0% 15 == 0) {\n\t\t    NSLog(@\"FizzBuzz\\n\");\n\t\t} else if (i\u00a0% 3 == 0) {\n\t\t    NSLog(@\"Fizz\\n\");\n\t\t} else if (i\u00a0% 5 == 0) {\n\t\t    NSLog(@\"Buzz\\n\");\n\t\t} else {\n\t\t    NSLog(@\"%li\\n\", i);\n\t\t}\n\t}\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI Prolog version 4.8.0\nWorks with: Ciao Prolog version 1.21.0\n\nfizzbuzz\u00a0:-\n   forall(between(1, 100, X), print_item(X)).\n\nprint_item(X)\u00a0:-\n   (  X mod 15 =:= 0\n   -> write('FizzBuzz')\n  \u00a0;  X mod 3 =:= 0\n   -> write('Fizz')\n  \u00a0;  X mod 5 =:= 0\n   -> write('Buzz')\n  \u00a0;  write(X)\n   ),\n   nl.\n\nfizzbuzz(X)\u00a0:- X mod 15 =:= 0,\u00a0!, write('FizzBuzz').\nfizzbuzz(X)\u00a0:- X mod 3 =:= 0,\u00a0!, write('Fizz').\nfizzbuzz(X)\u00a0:- X mod 5 =:= 0,\u00a0!, write('Buzz').\nfizzbuzz(X)\u00a0:- write(X).\n\ndofizzbuzz\u00a0:-between(1, 100, X), fizzbuzz(X), nl, fail.\ndofizzbuzz.\n\n%        N  /3?  /5?  V\nfizzbuzz(_, yes, yes, 'FizzBuzz').\nfizzbuzz(_, yes, no,  'Fizz').\nfizzbuzz(_, no,  yes, 'Buzz').\nfizzbuzz(N, no,  no,  N).\n\n% Unifies V with 'yes' if D divides evenly into N, 'no' otherwise.\ndivisible_by(N, D, yes)\u00a0:- N mod D =:= 0.\ndivisible_by(N, D, no)\u00a0:- N mod D =\\= 0.\n\n% Print 'Fizz', 'Buzz', 'FizzBuzz' or N as appropriate.\nfizz_buzz_or_n(N)\u00a0:- N > 100.\nfizz_buzz_or_n(N)\u00a0:- N =< 100,\n   divisible_by(N, 3, Fizz),\n   divisible_by(N, 5, Buzz),\n   fizzbuzz(N, Fizz, Buzz, FB),\n   write(FB), nl,\n   M is N+1, fizz_buzz_or_n(M).\n\nmain\u00a0:-\n   fizz_buzz_or_n(1).\n\nWorks with: SWI Prolog version 8.2.1 Works with: Scryer Prolog version 0.7.8\n% This implementation uses modern Prolog techniques\n% in order to be an idiomatic solution that uses logical purity, generality and determinism wherever possible:\n% - CLP(Z): constraint logic programming on integers.\n% - library(reif): efficient logical predicates based on 'Indexing dif/2'.\n:- module(fizz_buzz, [main/0, integer_fizzbuzz_below_100/2, integer_fizzbuzz/2]).\n\n:- use_module(library(reif)).\n\n% for Scryer-Prolog:\n:- use_module(library(clpz)).\n:- use_module(library(between)).\n:- use_module(library(iso_ext)).\n:- use_module(library(si)).\n\n% for SWI-Prolog:\n%\u00a0:- use_module(library(clpfd)).\n\n% Prints all solutions to `integer_fizzbuzz_below_100` each on a separate line, in order.\n% Logically-impure shell, as currently there is no logically-pure way to write to a filestream.\nmain\u00a0:-\n    forall(integer_fizzbuzz_below_100(_, FizzBuzz), write_line(FizzBuzz)).\n\nwrite_line(Value)\u00a0:-\n    write(Value),\n    nl.\n\n% Constrains FizzBuzz results to the range 1 <= X <= 100,\n% and (for the 'most general query' where neither X or FizzBuzz is concrete)\n% ensures results are traversed in order low -> high X.\n%\n%\u00a0?- integer_fizzbuzz_below_100(X, FizzBuzz)\u00a0% generate all the results in order\n%\u00a0?- integer_fizzbuzz_below_100(27, Result)\u00a0% Find out what output `27` will produce (it's 'Fizz'.)\n%\u00a0?- integer_fizzbuzz_below_100(X, 'Fizz')  \u00a0% generate all the numbers which would print 'Fizz' in order (3, 6, 9, etc).\n%\u00a0?- integer_fizzbuzz_below_100(X, Res), integer_si(Res)\u00a0% generate all the numbers which would print themselves in order (1, 2, 4, 6, 7, 8, 11, etc).\n%\u00a0?- integer_fizzbuzz_below_100(X, Res), is_of_type(integer, Res)\u00a0% SWI-Prolog version doing the same.\ninteger_fizzbuzz_below_100(X, FizzBuzz)\u00a0:-\n    between(1, 100, X),\n    integer_fizzbuzz(X, FizzBuzz).\n\n% States the relationship between a number\n% and its FizzBuzz representation.\n%\n% Because constraints are propagated lazily,\n% prompting this predicate without having constrained `Num`\n% to a particular integer value will give you its definition back.\n% Put differently: This predicate returns the whole solution space at once,\n% and external labeling techniques are required to traverse and concretize this solution space\n% in an order that we like.\ninteger_fizzbuzz(Num, FizzBuzz)\u00a0:-\n    if_(Num mod 15 #= 0, FizzBuzz = 'FizzBuzz',\n        if_(Num mod 5 #= 0, FizzBuzz = 'Buzz',\n            if_(Num mod 3 #= 0, FizzBuzz = 'Fizz',\n                Num = FizzBuzz)\n           )\n       ).\n\n% Reifiable `#=`.\n#=(X, Y, T)\u00a0:-\n    X #= X1,\n    Y #= Y1,\n    zcompare(C, X1, Y1),\n    eq_t(C, T).\n\neq_t(=, true).\neq_t(<, false).\neq_t(>, false).\n", "explain": "Maybe not the most conventional way to write this in Prolog. The fizzbuzz predicate uses a higher-order predicate and print_item uses the if-then-else construction.\nMore conventional, doing the loop this time failure driven:\nClearer, doing the loop this time tail recursive, quite declarative:\nUsing modern Prolog techniques, resulting in idiomatic, highly declarative code:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nIf/else Ladder[edit]\nfor i = 1, 100 do\n\tif i\u00a0% 15 == 0 then\n\t\tprint(\"FizzBuzz\")\n\telseif i\u00a0% 3 == 0 then\n\t\tprint(\"Fizz\")\n\telseif i\u00a0% 5 == 0 then\n\t\tprint(\"Buzz\")\n\telse\n\t\tprint(i)\n\tend\nend\nConcatenation[edit]\nfor i = 1, 100 do\n\toutput = \"\"\n\tif i\u00a0% 3 == 0 then\n\t\toutput = output..\"Fizz\"\n\tend\n\tif i\u00a0% 5 == 0 then\n\t\toutput = output..\"Buzz\"\n\tend\n\tif(output == \"\") then\n\t\toutput = i\n\tend\n\tprint(output)\nend\nQuasi bit field[edit]\nword = {\"Fizz\", \"Buzz\", \"FizzBuzz\"}\n\nfor i = 1, 100 do\n        print(word[(i\u00a0% 3 == 0 and 1 or 0) + (i\u00a0% 5 == 0 and 2 or 0)] or i)\nend\nLookup table[edit]\nlocal t = {\n        [0]  = \"FizzBuzz\",\n        [3]  = \"Fizz\",\n        [5]  = \"Buzz\",\n        [6]  = \"Fizz\",\n        [9]  = \"Fizz\",\n        [10] = \"Buzz\",\n        [12] = \"Fizz\"\n}\n\nfor i = 1, 100 do\n        print(t[i%15] or i)\nend\nMetatable insertion[edit]\n\nlocal mt = {\n\t__newindex = (function (t, k, v)\n\t\tif type(k) ~= \"number\" then\trawset(t, k, v)\n\t\telseif 0 == (k\u00a0% 15) then\trawset(t, k, \"fizzbuzz\") \n\t\telseif 0 == (k\u00a0% 5) then\trawset(t, k, \"fizz\") \n\t\telseif 0 == (k\u00a0% 3) then\trawset(t, k, \"buzz\") \n\t\telse \t\t\t\t\t\trawset(t, k, k) end\n\t\treturn t[k]\nend)\n}\n\nlocal fizzbuzz = {}\nsetmetatable(fizzbuzz, mt)\n\nfor i=1,100 do fizzbuzz[i] = i end\nfor i=1,100 do print(fizzbuzz[i]) end\nFast Version without Modulo[edit]\n#!/usr/bin/env luajit\nlocal to=arg[1] or tonumber(arg[1]) or 100\nlocal CF,CB=3,5\nlocal cf,cb=CF,CB\nfor i=1,to do\n\tcf,cb=cf-1,cb-1\n\tif cf~=0 and cb~=0 then\n\t\tio.write(i)\n\telse\n\t\tif cf==0 then\n\t\t\tcf=CF\n\t\t\tio.write(\"Fizz\")\n\t\tend\n\t\tif cb==0 then\n\t\t\tcb=CB\n\t\t\tio.write(\"Buzz\")\n\t\tend\n\tend\n\tio.write(\", \")\nend\n\nOutput:\n> ./fizzbuzz.lua  \n1, 2, Fizz, 4, Buzz, Fizz, 7, 8, Fizz, Buzz, 11, Fizz, 13, 14, FizzBuzz, 16, 17, Fizz, 19, Buzz, Fizz, 22, 23, Fizz, Buzz, 26, Fizz, 28, 29, FizzBuzz, 31, 32, Fizz, 34, Buzz, Fizz, 37, 38, Fizz, Buzz, 41, Fizz, 43, 44, FizzBuzz, 46, 47, Fizz, 49, Buzz, Fizz, 52, 53, Fizz, Buzz, 56, Fizz, 58, 59, FizzBuzz, 61, 62, Fizz, 64, Buzz, Fizz, 67, 68, Fizz, Buzz, 71, Fizz, 73, 74, FizzBuzz, 76, 77, Fizz, 79, Buzz, Fizz, 82, 83, Fizz, Buzz, 86, Fizz, 88, 89, FizzBuzz, 91, 92, Fizz, 94, Buzz, Fizz, 97, 98, Fizz, Buzz,\u00a0%\n\n", "explain": "Sets any numeric key to its fizzbuzz value so that fizzbuzz[30] is \"fizzbuzz\"\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nLibrary: Scala\nIdiomatic scala code[edit]\nobject FizzBuzz extends App {\n  1 to 100 foreach { n =>\n    println((n\u00a0% 3, n\u00a0% 5) match {\n      case (0, 0) => \"FizzBuzz\"\n      case (0, _) => \"Fizz\"\n      case (_, 0) => \"Buzz\"\n      case _ => n\n    })\n  }\n}\nGeeky over-generalized solution \u263a[edit]\ndef replaceMultiples(x: Int, rs: (Int, String)*): Either[Int, String] =\n  rs map { case (n, s) => Either cond(x\u00a0% n == 0, s, x)} reduceLeft ((a, b) => \n    a fold(_ => b, s => b fold(_ => a, t => Right(s + t))))\n\ndef fizzbuzz = replaceMultiples(_: Int, 3 -> \"Fizz\", 5 -> \"Buzz\") fold(_.toString, identity)\n\n1 to 100 map fizzbuzz foreach println\nBy a two-liners geek[edit]\ndef f(n: Int, div: Int, met: String, notMet: String): String = if (n\u00a0% div == 0) met else notMet\nfor (i <- 1 to 100) println(f(i, 15, \"FizzBuzz\", f(i, 3, \"Fizz\", f(i, 5, \"Buzz\", i.toString))))\nOne-liner geek[edit]\nfor (i <- 1 to 100) println(Seq(15 -> \"FizzBuzz\", 3 -> \"Fizz\", 5 -> \"Buzz\").find(i\u00a0% _._1 == 0).map(_._2).getOrElse(i))\nFunctional Scala[edit]\ndef fizzBuzzTerm(n: Int): String =\n  if (n\u00a0% 15 == 0) \"FizzBuzz\"\n  else if (n\u00a0% 3 == 0) \"Fizz\"\n  else if (n\u00a0% 5 == 0) \"Buzz\"\n  else n.toString\n\ndef fizzBuzz(): Unit = LazyList.from(1).take(100).map(fizzBuzzTerm).foreach(println)\nScala 3 (Dotty)[edit]\n\ndef fizzBuzzTerm(n: Int): String | Int = // union types\n  (n\u00a0% 3, n\u00a0% 5) match // optional semantic indentation; no braces\n    case (0, 0) => \"FizzBuzz\"\n    case (0, _) => \"Fizz\"\n    case (_, 0) => \"Buzz\"\n    case _      => n // no need for `.toString`, thanks to union type\n  end match // optional `end` keyword, with what it's ending\nend fizzBuzzTerm // `end` also usable for identifiers\n\nval fizzBuzz = // no namespace object is required; all top level\n  LazyList.from(1).map(fizzBuzzTerm)\n\n@main def run(): Unit = // @main for main method; can take custom args\n  fizzBuzz.take(100).foreach(println)\n", "explain": "Written so as to introduce changes, with comments.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nmain() {\n  for (int i = 1; i <= 100; i++) {\n    List<String> out = [];\n    if (i\u00a0% 3 == 0)\n      out.add(\"Fizz\");\n    if (i\u00a0% 5 == 0)\n      out.add(\"Buzz\");\n    print(out.length > 0\u00a0? out.join(\"\")\u00a0: i);\n  }\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nimport std.stdio, std.algorithm, std.conv;\n\n/// With if-else.\nvoid fizzBuzz(in uint n) {\n    foreach (immutable i; 1 .. n + 1)\n        if (!(i\u00a0% 15))\n            \"FizzBuzz\".writeln;\n        else if (!(i\u00a0% 3))\n            \"Fizz\".writeln;\n        else if (!(i\u00a0% 5))\n            \"Buzz\".writeln;\n        else\n            i.writeln;\n}\n\n/// With switch case.\nvoid fizzBuzzSwitch(in uint n) {\n    foreach (immutable i; 1 .. n + 1)\n        switch (i\u00a0% 15) {\n            case 0:\n                \"FizzBuzz\".writeln;\n                break;\n            case 3, 6, 9, 12:\n                \"Fizz\".writeln;\n                break;\n            case 5, 10:\n                \"Buzz\".writeln;\n                break;\n            default:\n                i.writeln;\n        }\n}\n\nvoid fizzBuzzSwitch2(in uint n) {\n    foreach (immutable i; 1 .. n + 1)\n        (i\u00a0% 15).predSwitch(\n        0,       \"FizzBuzz\",\n        3,       \"Fizz\",\n        5,       \"Buzz\",\n        6,       \"Fizz\",\n        9,       \"Fizz\",\n        10,      \"Buzz\",\n        12,      \"Fizz\",\n        /*else*/ i.text).writeln;\n}\n\nvoid main() {\n    100.fizzBuzz;\n    writeln;\n    100.fizzBuzzSwitch;\n    writeln;\n    100.fizzBuzzSwitch2;\n}\n\nimport std;\n\nvoid main()\n{\n    auto fizzbuzz(in uint i)\n    {\n        string r;\n        if (i\u00a0% 3 == 0) r ~= \"fizz\";\n        if (i\u00a0% 5 == 0) r ~= \"buzz\";\n        if (r.length == 0) r ~= i.to!string;\n        return r;\n    }\n    \n    enum r = 1.iota(101).map!fizzbuzz;\n\n    r.each!writeln;\n}\n", "explain": "Alternate version calculating values at compile time:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nfizzbuzz\u00a0:: Int -> String\nfizzbuzz x\n  | f 15 = \"FizzBuzz\"\n  | f 3 = \"Fizz\"\n  | f 5 = \"Buzz\"\n  | otherwise = show x\n  where\n    f = (0 ==) . rem x\n\nmain\u00a0:: IO ()\nmain = mapM_ (putStrLn . fizzbuzz) [1 .. 100]\nfizzbuzz\u00a0:: Int -> String\nfizzbuzz n =\n  '\\n'\u00a0:\n  if null (fizz ++ buzz)\n    then show n\n    else fizz ++ buzz\n  where\n    fizz =\n      if mod n 3 == 0\n        then \"Fizz\"\n        else \"\"\n    buzz =\n      if mod n 5 == 0\n        then \"Buzz\"\n        else \"\"\n\nmain\u00a0:: IO ()\nmain = putStr $ concatMap fizzbuzz [1 .. 100]\n\nmain = mapM_ (putStrLn . fizzbuzz) [1..100]\n\nfizzbuzz n = \n    show n <|> [fizz| n `mod` 3 == 0] ++ \n               [buzz| n `mod` 5 == 0]\n\n-- A simple default choice operator. \n-- Defaults if both fizz and buzz fail, concats if any succeed.\ninfixr 0 <|>\nd <|> [] = d\n_ <|> x = concat x\n\nfizz = \"Fizz\"\nbuzz = \"Buzz\"\n\nmain = mapM_ putStrLn $ take 100 $ zipWith show_number_or_fizzbuzz [1..] fizz_buzz_list           \n\nshow_number_or_fizzbuzz x y = if null y then show x else y\n\nfizz_buzz_list = zipWith (++) (cycle [\"\",\"\",\"Fizz\"]) (cycle [\"\",\"\",\"\",\"\",\"Buzz\"])\n\nimport Control.Applicative ( ZipList(ZipList, getZipList) )\n\nfizzBuzz\u00a0:: [String]\nfizzBuzz =\n  getZipList $ go <$> \n    ZipList (cycle $ replicate 2 [] <> [\"fizz\"]) <*>\n    ZipList (cycle $ replicate 4 [] <> [\"buzz\"]) <*>\n    ZipList (show <$> [1 ..])\n\ngo\u00a0:: String -> String -> String -> String\ngo f b n\n  | null f && null b = n\n  | otherwise = f <> b\n\n\nmain\u00a0:: IO ()\nmain = mapM_ putStrLn $ take 100 fizzBuzz\n\nimport Data.Bool (bool)\n\nfizzBuzz\u00a0:: [String]\nfizzBuzz =\n  let fb n k = cycle $ replicate (pred n) [] <> [k]\n   in zipWith\n        (flip . bool <*> null)\n        (zipWith (<>) (fb 3 \"fizz\") (fb 5 \"buzz\"))\n        (show <$> [1 ..])\n\nmain\u00a0:: IO ()\nmain = mapM_ putStrLn $ take 100 fizzBuzz\n\nimport Control.Monad.State\nimport Control.Monad.Trans\nimport Control.Monad.Writer\n\nmain = putStr $ execWriter $ mapM_ (flip execStateT True . fizzbuzz) [1..100]\n\nfizzbuzz\u00a0:: Int -> StateT Bool (Writer String) ()\nfizzbuzz x = do\n when (x `mod` 3 == 0) $ tell \"Fizz\" >> put False\n when (x `mod` 5 == 0) $ tell \"Buzz\" >> put False\n get >>= (flip when $ tell $ show x)\n tell \"\\n\"\n\nfizzBuzz\u00a0:: (Integral a) => a -> String\nfizzBuzz i\n  | fizz && buzz = \"FizzBuzz\"\n  | fizz         = \"Fizz\"\n  | buzz         = \"Buzz\"\n  | otherwise    = show i\n  where fizz = i `mod` 3 == 0\n        buzz = i `mod` 5 == 0\n\nmain = mapM_ (putStrLn . fizzBuzz) [1..100]\n\nimport Data.Monoid\n\nfizzbuzz = max\n       <$> show\n       <*> \"fizz\" `when` divisibleBy 3\n       <>  \"buzz\" `when` divisibleBy 5\n       <>  \"quxx\" `when` divisibleBy 7\n  where\n    when m p x = if p x then m else mempty\n    divisibleBy n x = x `mod` n == 0\n\nmain = mapM_ (putStrLn . fizzbuzz) [1..100]\n\nfizzbuzz n = case (rem n 3, rem n 5) of\n               (0, 0) -> \"FizzBuzz\"\n               (0, _) -> \"Fizz\"\n               (_, 0) -> \"Buzz\"\n               (_, _) -> show n\n\nmain = mapM_ (putStrLn . fizzbuzz) [1..100]\n\nwordthing\u00a0:: [(Int, String)] -> Int -> String\nwordthing lst n =\n  if matches == [] then\n    show n\n  else\n    concat $ map snd matches\n  where matches = filter (\\x -> n `mod` (fst x) == 0) lst\n\nfizzbuzz\u00a0:: Int -> String\nfizzbuzz = wordthing [(3, \"Fizz\"), (5, \"Buzz\")]\n\nmain = do\n  mapM_ (putStrLn . fizzbuzz) [1..100]\n", "explain": "Variant directly implementing the specification:\nDoes not perform the mod 15 step, extesible to arbitrary addtional tests, ex: [bar| n `mod` 7 == 0].\nAlternate implementation using lazy infinite lists and avoiding use of \"mod\":\nOr in terms (still without mod or rem) of an applicative ZipList:\nor using an applicative test:\nUsing heavy artillery (needs the mtl package):\nUsing guards plus where.\nAn elegant solution exploiting monoidal and applicative properties of functions:\nAnd pattern matching approach:\nGeneralised solution:\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "PL/SQL", "code": "\nbegin\n  for i in 1 .. 100\n  loop\n    case\n    when mod(i, 15) = 0 then\n      dbms_output.put_line('FizzBuzz');\n    when mod(i, 5) = 0 then\n      dbms_output.put_line('Buzz');\n    when mod(i, 3) = 0 then\n      dbms_output.put_line('Fizz');\n    else\n      dbms_output.put_line(i);\n    end case;\n  end loop;\nend;\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\nWorks with: Windows Script Host version *\nFor i = 1 To 100\n\tIf i Mod 15 = 0 Then\n\t\tWScript.Echo \"FizzBuzz\"\n\tElseIf i Mod 5 = 0 Then\n\t\tWScript.Echo \"Buzz\"\n\tElseIf i Mod 3 = 0 Then\n\t\tWScript.Echo \"Fizz\"\n\tElse\n\t\tWScript.Echo i\n\tEnd If\nNext\nAn Alternative[edit]\nWorks with: Windows Script Host version *\nWith WScript.StdOut\n\tFor i = 1 To 100\n\t\tIf i Mod 3 = 0 Then .Write \"Fizz\"\n\t\tIf i Mod 5 = 0 Then .Write \"Buzz\"\n\t\tIf .Column = 1 Then .WriteLine i Else .WriteLine \"\"\n\tNext\nEnd With\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Scheme", "code": "\n(do ((i 1 (+ i 1)))\n    ((> i 100))\n    (display\n      (cond ((= 0 (modulo i 15)) \"FizzBuzz\")\n            ((= 0 (modulo i 3))  \"Fizz\")\n            ((= 0 (modulo i 5))  \"Buzz\")\n            (else                i)))\n    (newline))\n\n(define (fizzbuzz x y)\n  (println\n    (cond (( = (modulo x 15) 0 ) \"FizzBuzz\")\n          (( = (modulo x 3) 0 ) \"Fizz\")\n          (( = (modulo x 5) 0 ) \"Buzz\")\n          (else x)))\n\n    (if (< x y) (fizzbuzz (+ x 1) y)))\n\n(fizzbuzz 1 100)\n\n(define (fizzbuzz x)\n  (let ([words '((3 . \"Fizz\")\n                 (5 . \"Buzz\"))])\n    (define (fbm x)\n      (let ([w (map cdr (filter (lambda (wo) (= 0 (modulo x (car wo)))) words))])\n        (if (null? w) x (apply string-append w))))\n    (for-each (cut format #t \"~a~%\" <>) (map fbm (iota x 1 1)))))\n\n(fizzbuzz 15)\n", "explain": "\nUsing a recursive procedure.\nApproach with maps and filters, easier to change, less readable\nthan the previous.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nStraightforward, looping[edit]\nfor ($i = 1; $i -le 100; $i++) {\n    if ($i\u00a0% 15 -eq 0) {\n        \"FizzBuzz\"\n    } elseif ($i\u00a0% 5 -eq 0) {\n        \"Buzz\"\n    } elseif ($i\u00a0% 3 -eq 0) {\n        \"Fizz\"\n    } else {\n        $i\n    }\n}\nPipeline, Switch[edit]\n$txt=$null\n1..100 | ForEach-Object {\n    switch ($_) {\n        { $_\u00a0% 3 -eq 0 }  { $txt+=\"Fizz\" }\n        { $_\u00a0% 5 -eq 0 }  { $txt+=\"Buzz\" }\n        $_                { if($txt) { $txt } else { $_ }; $txt=$null }\n    }\n}\nConcatenation[edit]\nTranslation of: C#\n1..100 | ForEach-Object {\n    $s = ''\n    if ($_\u00a0% 3 -eq 0) { $s += \"Fizz\" }\n    if ($_\u00a0% 5 -eq 0) { $s += \"Buzz\" }\n    if (-not $s) { $s = $_ }\n    $s\n}\nPiping, Evaluation, Concatenation[edit]\n1..100 |\u00a0% {write-host(\"$(if(($_\u00a0% 3 -ne 0) -and ($_\u00a0% 5 -ne 0)){$_})$(if($_\u00a0% 3 -eq 0){\"Fizz\"})$(if($_\u00a0% 5 -eq 0){\"Buzz\"})\")}\nFilter, Piping, Regex Matching, Array Auto-Selection[edit]\nfilter fizz-buzz{\n    @(\n        $_, \n        \"Fizz\", \n        \"Buzz\", \n        \"FizzBuzz\"\n    )[\n        2 * \n        ($_ -match '[05]$') + \n        ($_ -match '(^([369][0369]?|[258][147]|[147][258]))$')\n    ]\n}\n\n1..100 | fizz-buzz\nString Manipulation with Regex[edit]\n(1..100 -join \"`n\") + \"`nFizzBuzz\" -replace '(?ms)(^([369]([369]|(?=0|$))|[258][147]|[147]([28]|(?=5))))(?=[05]?$.*(Fizz))|(((?<=[369])|[^369])0+|((?<=[147\\s])|[^147\\s])5)(?=$.*(Buzz))|FizzBuzz', '$5$9'\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Logo", "code": "\nto fizzbuzz :n\n  output cond [ [[equal? 0 modulo :n 15] \"FizzBuzz]\n                [[equal? 0 modulo :n  5] \"Buzz]\n                [[equal? 0 modulo :n  3] \"Fizz]\n                [else :n] ]\nend\n\nrepeat 100 [print fizzbuzz #]\n\nto fizzbuzz :n\n make \"c \"\n  if equal? 0 modulo :n 5 [make \"c \"Buzz]\n  if equal? 0 modulo :n 3 [make \"c word \"Fizz :c]\n output ifelse equal? :c \" [:n] [:c]\nend\n\nrepeat 100 [print fizzbuzz repcount]\n\n", "explain": "\"cond\" was undefined in Joshua Bell's online interpreter. So here is a version that works there. It also works in UCB logo by using # instead of \"repcount\". This version also factors away modulo 15:\nLhogho can use the above code, except that 'modulo' must be replaced with 'remainder'.\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "ColdFusion", "code": "\n<Cfloop from=\"1\" to=\"100\" index=\"i\">\n  <Cfif i mod 15 eq 0>FizzBuzz\n  <Cfelseif i mod 5 eq 0>Fizz\n  <Cfelseif i mod 3 eq 0>Buzz\n  <Cfelse><Cfoutput>#i# </Cfoutput>\n  </Cfif>      \n</Cfloop>\n\n\n<cfscript>\nresult = \"\";\n  for(i=1;i<=100;i++){\n    result=ListAppend(result, (i%15==0) ? \"FizzBuzz\": (i%5==0) ? \"Buzz\" : (i%3 eq 0)? \"Fizz\" : i );\n  }\n  WriteOutput(result);\n</cfscript>\n\n", "explain": "cfscript version\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "ABAP", "code": "\nImpure Functional 1[edit]\nWorks with: ABAP version 7.4 SP05 or Above only\nDATA: tab TYPE TABLE OF string.\n\ntab = VALUE #(\n  FOR i = 1 WHILE i <= 100 (\n    COND string( LET r3 = i MOD 3\n                     r5 = i MOD 5 IN\n                 WHEN r3 = 0 AND r5 = 0 THEN |FIZZBUZZ|\n                 WHEN r3 = 0            THEN |FIZZ|\n                 WHEN r5 = 0            THEN |BUZZ|\n                 ELSE i ) ) ).\n\ncl_demo_output=>write( tab ).\ncl_demo_output=>display( ).\n\nImpure Functional 2[edit]\nWorks with: ABAP version 7.4 SP05 or Above only\ncl_demo_output=>display( value stringtab( for i = 1 until i > 100\n                                          let fizz = cond #( when i mod 3 = 0 then |fizz| else space )\n                                              buzz = cond #( when i mod 5 = 0 then |buzz| else space )\n                                              fb   = |{ fizz }{ buzz }| in\n                                         ( switch #( fb when space then i else fb ) ) ) ).\n\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nlet fizzbuzz n =\n    match n%3 = 0, n%5 = 0 with\n    | true, false -> \"fizz\"\n    | false, true -> \"buzz\"\n    | true, true  -> \"fizzbuzz\"\n    | _ -> string n\n\nlet printFizzbuzz() =\n    [1..100] |> List.iter (fizzbuzz >> printfn \"%s\")\n[1..100] \n|> List.map (fun x ->\n            match x with \n            | _ when x\u00a0% 15 = 0 ->\"fizzbuzz\"\n            | _ when x\u00a0% 5 = 0 -> \"buzz\"\n            | _ when x\u00a0% 3 = 0 -> \"fizz\"\n            | _ ->  x.ToString())\n|> List.iter (fun x -> printfn \"%s\" x)\n\nlet (|MultipleOf|_|) divisors number =\n    if Seq.exists ((%) number >> (<>) 0) divisors\n    then None\n    else Some ()\n\nlet fizzbuzz = function\n| MultipleOf [3; 5] -> \"fizzbuzz\"\n| MultipleOf [3]    -> \"fizz\"\n| MultipleOf [5]    -> \"buzz\"\n| n                 -> string n\n\n{ 1 .. 100 }\n|> Seq.iter (fizzbuzz >> printfn \"%s\")\n", "explain": "Another example using (unnecessary) partial active pattern :D\n"}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n1.upto(100) { i -> println \"${i\u00a0% 3\u00a0? ''\u00a0: 'Fizz'}${i\u00a0% 5\u00a0? ''\u00a0: 'Buzz'}\"\u00a0?: i }\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "Zig", "code": "\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n    var i: usize = 1;\n    while (i <= 100)\u00a0: (i += 1) {\n        if (i\u00a0% 3 == 0 and i\u00a0% 5 == 0) {\n            print(\"FizzBuzz\\n\", .{});\n        } else if (i\u00a0% 3 == 0) {\n            print(\"Fizz\\n\", .{});\n        } else if (i\u00a0% 5 == 0) {\n            print(\"Buzz\\n\", .{});\n        } else {\n            print(\"{}\\n\", .{i});\n        }\n    }\n}\n", "explain": ""}, {"task_name": "FizzBuzz", "task_url": "https://rosettacode.org/wiki/FizzBuzz", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n\n", "explain": "See FizzBuzz/AWK\n"}]