[{"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Python", "code": "\nWorks with: Python version 2.3, 2.4, and 2.5\n\n>>> src = \"hello\"\n>>> a = src\n>>> b = src[:]\n>>> import copy\n>>> c = copy.copy(src)\n>>> d = copy.deepcopy(src)\n>>> src is a is b is c is d\nTrue\n\n>>> a = 'hello'\n>>> b = ''.join(a)\n>>> a == b\nTrue\n>>> b is a  ### Might be True ... depends on \"interning\" implementation details!\nFalse\n\n", "explain": "Since strings are immutable, all copy operations return the same string, with the reference count increased as appropriate\nTo actually copy a string:\nAs a result of object \"interning\" some strings such as the empty string and single character strings like 'a' may be references to the same object regardless of copying. This can potentially happen with any Python immutable object and should be of no consequence to any proper code.\nBe careful with is - use it only when you want to compare the identity of the object. To compare string values, use the == operator.  For numbers and strings any given Python interpreter's implementation of \"interning\" may cause the object identities to coincide.  Thus any number of names to identical numbers or strings might become references to the same objects regardless of how those objects were derived (even if the contents were properly \"copied\" around).  The fact that these are immutable objects makes this a reasonable behavior.\n\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "C", "code": "\n#include <stdlib.h>\t/* exit(), free() */\n#include <stdio.h>\t/* fputs(), perror(), printf() */\n#include <string.h>\n\nint\nmain()\n{\n\tsize_t len;\n\tchar src[] = \"Hello\";\n\tchar dst1[80], dst2[80];\n\tchar *dst3, *ref;\n\n\t/*\n\t * Option 1. Use strcpy() from <string.h>.\n\t *\n\t * DANGER! strcpy() can overflow the destination buffer.\n\t * strcpy() is only safe if the source string is shorter than\n\t * the destination buffer. We know that \"Hello\" (6 characters\n\t * with the final '\\0') easily fits in dst1 (80 characters).\n\t */\n\tstrcpy(dst1, src);\n\n\t/*\n\t * Option 2. Use strlen() and memcpy() from <string.h>, to copy\n\t * strlen(src) + 1 bytes including the final '\\0'.\n\t */\n\tlen = strlen(src);\n\tif (len >= sizeof dst2) {\n\t\tfputs(\"The buffer is too small!\\n\", stderr);\n\t\texit(1);\n\t}\n\tmemcpy(dst2, src, len + 1);\n\n\t/*\n\t * Option 3. Use strdup() from <string.h>, to allocate a copy.\n\t */\n\tdst3 = strdup(src);\n\tif (dst3 == NULL) {\n\t\t/* Failed to allocate memory! */\n\t\tperror(\"strdup\");\n\t\texit(1);\n\t}\n\n\t/* Create another reference to the source string. */\n\tref = src;\n\n\t/* Modify the source string, not its copies. */\n\tmemset(src, '-', 5);\n\n\tprintf(\" src: %s\\n\", src);   /*  src: ----- */\n\tprintf(\"dst1: %s\\n\", dst1);  /* dst1: Hello */\n\tprintf(\"dst2: %s\\n\", dst2);  /* dst2: Hello */\n\tprintf(\"dst3: %s\\n\", dst3);  /* dst3: Hello */\n\tprintf(\" ref: %s\\n\", ref);   /*  ref: ----- */\n\n\t/* Free memory from strdup(). */\n\tfree(dst3);\n\n\treturn 0;\n}\n\nLibrary: BSD libc[edit]\n#include <stdlib.h>\t/* exit() */\n#include <stdio.h>\t/* fputs(), printf() */\n#include <string.h>\n\nint\nmain()\n{\n\tchar src[] = \"Hello\";\n\tchar dst[80];\n\n\t/* Use strlcpy() from <string.h>. */\n\tif (strlcpy(dst, src, sizeof dst) >= sizeof dst) {\n\t\tfputs(\"The buffer is too small!\\n\", stderr);\n\t\texit(1);\n\t}\n\n\tmemset(src, '-', 5);\n\tprintf(\"src: %s\\n\", src);  /* src: ----- */\n\tprintf(\"dst: %s\\n\", dst);  /* dst: Hello */\n\n\treturn 0;\n}\n\nLibrary: Gadget[edit]\n\n#include <gadget/gadget.h>\n\nLIB_GADGET_START\n\nMain\n   String v, w = \"this message is a message\";\n   \n   Let( v, \"Hello world!\");\n   Print \"v = %s\\nw = %s\\n\\n\", v,w;\n   \n   Get_fn_let( v, Upper(w) );\n   \n   Print \"v = %s\\nw = %s\\n\\n\", v,w;\n\n   Stack{\n       Store ( v, Str_tran_last( Upper(w), \"MESSAGE\", \"PROOF\" ) );\n   }Stack_off;\n   \n   Print \"v = %s\\nw = %s\\n\\n\", v,w;\n   \n   Free secure v, w;\n\nEnd\n\n\nOutput:\nv = Hello world!\nw = this message is a message\n\nv = THIS MESSAGE IS A MESSAGE\nw = this message is a message\n\nv = THIS MESSAGE IS A PROOF\nw = this message is a message\n\n", "explain": "Versi\u00f3n 2, using Gadget library.\nLink:\nhttps://github.com/DanielStuardo/Gadget\n\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <iostream>\n#include <string>\n\nint main( ) {\n   std::string original (\"This is the original\");\n   std::string my_copy = original;\n   std::cout << \"This is the copy: \" << my_copy << std::endl;\n   original = \"Now we change the original! \";\n   std::cout << \"my_copy still is \" << my_copy << std::endl;\n}\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Java", "code": "\n\nString src = \"Hello\";\nString newAlias = src;\nString strCopy = new String(src);\n\n//\"newAlias == src\" is true\n//\"strCopy == src\" is false\n//\"strCopy.equals(src)\" is true\n\n\nStringBuffer srcCopy = new StringBuffer(\"Hello\");\n\n", "explain": "In Java, Strings are immutable, so it doesn't make that much difference to copy it.\nInstead, maybe you want to create a StringBuffer (mutable string) from an existing String or StringBuffer:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "C#", "code": "\nstring src = \"Hello\";\nstring dst = src;\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\n\nvar container = {myString: \"Hello\"};\nvar containerCopy = container; // Now both identifiers refer to the same object\n\ncontainerCopy.myString = \"Goodbye\"; // container.myString will also return \"Goodbye\"\n\n\nvar a = \"Hello\";\nvar b = a; // Same as saying window.b = window.a\n\nb = \"Goodbye\" // b contains a copy of a's value and a will still return \"Hello\"\n\n", "explain": "Objects can be copied in JavaScript via simple reassignment. \nChanges to the properties of one will be reflected in the other:\nIf you copy property values with reassignment, such as properties of the global object (window in browsers), only the value will be copied and not the reference\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Visual_Basic_.NET", "code": "\n\nWorks with: Visual Basic .NET version 9.0+\n'Immutable Strings\nDim a = \"Test string\"\nDim b = a 'reference to same string\nDim c = New String(a.ToCharArray) 'new string, normally not used\n\n'Mutable Strings\nDim x As New Text.StringBuilder(\"Test string\")\nDim y = x 'reference\nDim z = New Text.StringBuilder(x.ToString) 'new string\n\nDim a As String = \"Test String\"\nDim b As String = String.Copy(a) ' New string\n", "explain": "Platform: .NET\nAlternatively, you can use, with all versions of the .NET framework:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "PHP", "code": "\n$src = \"Hello\";\n$dst = $src;\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "MATLAB", "code": "\nstring1 = 'Hello';\nstring2 = string1;\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Fortran", "code": "\nstr2 = str1\n\n\n", "explain": "Because Fortran uses fixed length character strings if str1 is shorter than str2 then str2 is padded out with trailing spaces.\nIf str1 is longer than str2 it is truncated to fit.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Go", "code": "\n\nsrc := \"Hello\"\ndst := src\n\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n\t// creature string\n\tvar creature string = \"shark\"\n\t// point to creature\n\tvar pointer *string = &creature\n\t// creature string\n\tfmt.Println(\"creature =\", creature) // creature = shark\n\t// creature location in memory\n\tfmt.Println(\"pointer =\", pointer) // pointer = 0xc000010210\n\t// creature through the pointer\n\tfmt.Println(\"*pointer =\", *pointer) // *pointer = shark\n\t// set creature through the pointer\n\t*pointer = \"jellyfish\"\n\t// creature through the pointer\n\tfmt.Println(\"*pointer =\", *pointer) // *pointer = jellyfish\n\t// creature string\n\tfmt.Println(\"creature =\", creature) // creature = jellyfish\n}\n\n", "explain": "Just use assignment:\nStrings in Go are immutable.  Because of this, there is no need to distinguish between copying the contents and making an additional reference.  \nTechnically, Go strings are immutable byte slices.  \nA slice is an object that contains a reference to an underlying array.  \nIn the assignment shown above, a new slice object is created for dst.  \nIts internal reference is likely to point to the same underlying array as src, \nbut the language does not specify this behavior or make any guarantees about it.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program copystr.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/* Initialized data */\n.data\nszString: .asciz \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\\n\"\n\n/* UnInitialized data */\n.bss \n.align 4\niPtString:   .skip 4\nszString1:    .skip 80\n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* saves 2 registers */\n\n    @ display start string \n    ldr r0,iAdrszString\n    bl affichageMess\n    @ copy pointer string\n    ldr r0,iAdrszString\n    ldr r1,iAdriPtString\n    str r0,[r1]\n    @ control\n    ldr r1,iAdriPtString\n    ldr r0,[r1]\n    bl affichageMess\n    @ copy string\n    ldr r0,iAdrszString    \n    ldr r1,iAdrszString1\n1:\n    ldrb r2,[r0],#1   @ read one byte and increment pointer one byte\n    strb r2,[r1],#1   @ store one byte and increment pointer one byte\n    cmp r2,#0          @ end of string\u00a0?\n    bne 1b            @ no -> loop \n    @ control\n    ldr r0,iAdrszString1\n    bl affichageMess\n\n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\niAdrszString:\t\t.int szString\niAdriPtString:\t\t.int iPtString\niAdrszString1:\t\t.int szString1\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n\n.data \n\t\n.text\n\nstrcpy:\n  addi $sp, $sp, -4\n  sw $s0, 0($sp)\n  add $s0, $zero, $zero\n\nL1: \n  add $t1, $s0, $a1\n  lb $t2, 0($t1)\n  add $t3, $s0, $a0\n  sb $t2, 0($t3)\n  beq $t2, $zero, L2\n  addi $s0, $s0, 1\n  j L1\n\nL2:\n  lw $s0, 0($sp)\n  addi $sp, $sp, 4\n  jr $ra\n", "explain": "This does a full copy of the string, not just copying the pointer to the string's contents.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "X86_Assembly", "code": "\nWorks with: nasm\n\nsection .data\n    string db \"Hello World\", 0\n\nsection .bss\n    string2 resb 12\n    \nsection .text\nglobal _main\n_main:\n    mov ecx, 0\n    looping:\n        mov al, [string + ecx]\n        mov [string2 + ecx], al\n        inc ecx\n        cmp al, 0 ;copy until we find the terminating 0\n        je end\n        jmp looping\n    end:\n        xor eax, eax\n        ret\n\nsection .data\n    string db 11,\"Hello World\"\n\nsection .bss\n    string2 resb 12\n    \nsection .text\nglobal _main\n_main:\n    xor ecx, ecx ;clear ecx\n    mov cl, [string]\n    mov [string2], cl ;copy byte signaling length\n    mov edx, 1\n    looping: ;copy each single byte\n        mov al, [string + edx]\n        mov [string2 + edx], al\n        inc edx\n        dec ecx\n        cmp ecx, 0\n        jg looping\n    xor eax, eax\n    ret\n", "explain": "creating a second 0 terminated string with the same content:\ncreating a second string; first byte signals length of string\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Delphi", "code": "\n\nprogram CopyString;\n\n{$APPTYPE CONSOLE}\n\nvar\n  s1: string;\n  s2: string;\nbegin\n  s1 := 'Goodbye';\n  s2 := s1; // S2 points at the same string as S1\n  s2 := s2 + ', World!'; // A new string is created for S2\n\n  Writeln(s1);\n  Writeln(s2);\nend.\n\n\nOutput:\nGoodbye\nGoodbye, World!\n", "explain": "Delphi strings are reference counted with copy on write semantics.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\noriginal = \"hello\"\nreference = original          # copies reference\ncopy1 = original.dup          # instance of original.class\ncopy2 = String.new(original)  # instance of String\n\noriginal << \" world!\"         # append\np reference                   #=> \"hello world!\"\np copy1                       #=> \"hello\"\np copy2                       #=> \"hello\"\n\noriginal = \"hello\".freeze     # prevents further modifications\ncopy1 = original.dup          # copies contents (without status)\ncopy2 = original.clone        # copies contents (with status)\np copy1.frozen?               #=> false\np copy1 << \" world!\"          #=> \"hello world!\"\np copy2.frozen?               #=> true\np copy2 << \" world!\"          #=> can't modify frozen String (RuntimeError)\n", "explain": "In Ruby, String are mutable.\nThere is a method of Object#clone, too, in the copy of the object.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Rust", "code": "\nfn main() {\n    let s1 = \"A String\";\n    let mut s2 = s1;\n\n    s2 = \"Another String\";\n\n    println!(\"s1 = {}, s2 = {}\", s1, s2);\n}\nOutput: s1 = A String, s2 = Another String\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Swift", "code": "\n\nvar src = \"Hello\"\nvar dst = src\n\n", "explain": "Just use assignment:\nStrings in Swift are value types, so assigning copies the string.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "R", "code": "\n\nstr1 <- \"abc\"\nstr2 <- str1\n", "explain": "Copy a string by value:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "COBOL", "code": "\nTranslation of: C#\nMOVE \"Hello\" TO src\nMOVE src TO dst\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Ada", "code": "\n\nFixed Length String Copying.[edit]\nSrc : String := \"Hello\";\nDest : String := Src;\n\n\nSrc : String := \"Rosetta Stone\";\nDest : String := Src(1..7); -- Assigns \"Rosetta\" to Dest\nDest2 : String := Src(9..13); -- Assigns \"Stone\" to Dest2\n\nBounded Length String Copying[edit]\n-- Instantiate the generic package Ada.Strings.Bounded.Generic_Bounded_Length with a maximum length of 80 characters\npackage Flexible_String is new Ada.Strings.Bounded.Generic_Bounded_Length(80);\nuse Flexible_String;\n\nSrc : Bounded_String := To_Bounded_String(\"Hello\");\nDest : Bounded_String := Src;\n\n\nUnbounded Length String Copying[edit]\n-- The package Ada.Strings.Unbounded contains the definition of the Unbounded_String type and all its methods\nSrc : Unbounded_String := To_Unbounded_String(\"Hello\");\nDest : Unbounded_String := Src;\n\n", "explain": "Ada provides three different kinds of strings. \nThe String type is a fixed length string. \nThe Bounded_String type is a string with variable length up to a specified maximum size. \nThe Unbounded_String type is a variable length string with no specified maximum size. \nThe Bounded_String type behaves a lot like C strings, while the Unbounded_String type behaves a lot like the C++ String class.\nAda provides the ability to manipulate slices of strings.\nAda Bounded_String type provides a number of functions for dealing with slices.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Julia", "code": "\n\ns = \"Rosetta Code\"\nt = s\n\nprintln(\"s = \\\"\", s, \"\\\" and, after \\\"t = s\\\", t = \\\"\", t, \"\\\"\")\n\ns = \"Julia at \"*s\n\nprintln(\"s = \\\"\", s, \"\\\" and, after this change, t = \\\"\", t, \"\\\"\")\n\n\nOutput:\ns = \"Rosetta Code\" and, after \"t = s\", t = \"Rosetta Code\"\ns = \"Julia at Rosetta Code\" and, after this change, t = \"Rosetta Code\"\n\n", "explain": "Strings are immutable in Julia.  Assignment of one string valued variable to another is effectively a copy, as subsequent changes to either variable have no effect on the other.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\nval s = \"Hello\"\nval alias = s      // alias === s\nval copy = \"\" + s  // copy\u00a0!== s\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Perl", "code": "\n\nmy $original = 'Hello.';\nmy $new = $original;\n$new = 'Goodbye.';\nprint \"$original\\n\";   # prints \"Hello.\"\n\n\nmy $original = 'Hello.';\nmy $ref = \\$original;\n$$ref = 'Goodbye.';\nprint \"$original\\n\";   # prints \"Goodbye.\"\n\n\nmy $original = 'Hello.';\nour $alias;\nlocal *alias = \\$original;\n$alias = 'Good evening.';\nprint \"$original\\n\";   # prints \"Good evening.\"\n\nuse Lexical::Alias;\nmy $original = 'Hello.';\nmy $alias;\nalias $alias, $original;\n$alias = 'Good evening.';\nprint \"$original\\n\";   # prints \"Good evening.\"\n", "explain": "To copy a string, just use ordinary assignment:\nTo create a reference to an existing string, so that modifying the referent changes the original string, use a backslash:\nIf you want a new name for the same string, so that you can modify it without dereferencing a reference, assign a reference to a typeglob:\nNote that our $alias, though in most cases a no-op, is necessary under stricture. Beware that local binds dynamically, so any subroutines called in this scope will see (and possibly modify!) the value of $alias assigned here.\nTo make a lexical variable that is an alias of some other variable, the Lexical::Alias module can be used:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Objective-C", "code": "\n\nNSString *original = @\"Literal String\";\nNSString *new = [original copy];\nNSString *anotherNew = [NSString stringWithString:original];\nNSString *newMutable = [original mutableCopy];\n\n\nNSMutableString *original = [NSMutableString stringWithString:@\"Literal String\"];\nNSString *immutable = [original copy];\nNSString *anotherImmutable = [NSString stringWithString:original];\nNSMutableString *mutable = [original mutableCopy];\n\n\nconst char *cstring = \"I'm a plain C string\";\nNSString *string = [NSString stringWithUTF8String:cstring];\n\n\nchar bytes[] = \"some data\";\nNSString *string = [[NSString alloc] initWithBytes:bytes length:9 encoding:NSASCIIStringEncoding];\n\n\n", "explain": "Immutable strings - since they are immutable, you may get the same instance with its references count increased. Or, you can get a copy which is mutable if you use mutableCopy. Remember that both copy and mutableCopy return a retained instance. You can also get a copy by doing [NSString stringWithString:] or [[NSString alloc] initWithString:].\nNote that both copy and initWithString:/stringWithString: are optimized to return the original string object (possibly retained) if it is immutable.\nMutable strings - you can get either new mutable (if you use mutableCopy) or immutable (if you use copy) string:\nCopying a CString into an NSString:\nCopying from data, possibly not null terminated:\nAnd of course, if a C string is needed, you can use standard functions like strcpy.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Prolog", "code": "\n\n?- A = \"A test string\", A = B.\nA = B, B = \"A test string\".\n", "explain": "Values in Prolog are immutable so unifying with a variable that already has the value of a string will effectively copy that string. \nYou cannot reassign a value once it has been unified, it is not logical to have a value equal more than one thing. \n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Lua", "code": "\n\na = \"string\"\nb = a\nprint(a == b) -->true\nprint(b) -->string\n\n", "explain": "Lua strings are immutable, so only one reference to each string exists.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Scala", "code": "\n  val src = \"Hello\"\n  // Its actually not a copy but a reference\n  // That is not a problem because String is immutable\n  // In fact its a feature\n  val des = src\n  assert(src eq des) // Proves the same reference is used. \n  // To make a real copy makes no sense.\n  // Actually its hard to make a copy, the compiler is too smart.\n  // mkString, toString makes also not a real copy\n  val cop = src.mkString.toString\n  assert((src eq cop))                 // Still no copyed image\n  val copy = src.reverse.reverse       // Finally double reverse makes a copy\n  assert(src == copy &&\u00a0!(src eq copy))// Prove, but it really makes no sense.\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "D", "code": "\nvoid main() {\n    string src = \"This is a string\";\n\n    // copy contents:\n    auto dest1 = src.idup;\n\n    // copy contents to mutable char array\n    auto dest2 = src.dup;\n\n    // copy just the fat reference of the string\n    auto dest3 = src;\n}\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Haskell", "code": "\n\n", "explain": "In Haskell, every value is immutable, including Strings. \nSo one never needs to copy them; references are shared.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Scheme", "code": "\n(define dst (string-copy src))\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Apex", "code": "\n\nString original = 'Test';\nString cloned = original;\n//\"original == cloned\" is true\n\ncloned += ' more';\n//\"original == cloned\" is false\n", "explain": "In Apex, Strings are a primitive data type\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n\n$str = \"foo\"\n$dup = $str\n\n$dup = $str.Clone()\n", "explain": "Since PowerShell uses .NET behind the scenes and .NET strings are immutable you can simply assign the same string to another variable without breaking anything:\nTo actually create a copy the Clone() method can be used:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Logo", "code": "\n\nmake \"a \"foo\nmake \"b \"foo\nprint .eq :a :b  \u00a0; true, identical symbols are reused\n\nmake \"c :a\nprint .eq :a :c  \u00a0; true, copy a reference\n\nmake \"c word :b \"|| \u00a0; force a copy of the contents of a word by appending the empty word\nprint equal? :b :c  \u00a0; true\nprint .eq :b :c    \u00a0; false\n", "explain": "As a functional language, words are normally treated as symbols and cannot be modified. The EQUAL? predicate compares contents instead of identity. In UCB Logo the .EQ predicate tests for \"thing\" identity.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "ColdFusion", "code": "\n\n<cfset stringOrig = \"I am a string.\" />\n<cfset stringCopy = stringOrig />\n", "explain": "In ColdFusion, only complex data types (structs, objects, etc.) \nare passed by reference.  \nHence, any string copy operations are by value.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "ABAP", "code": "\ndata: lv_string1 type string value 'Test',\n      lv_string2 type string.\nlv_string2 = lv_string1.\n\nInline Declaration[edit]\nWorks with: ABAP version 7.4 Or above only\nDATA(string1) = |Test|.\nDATA(string2) = string1.\n\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "F#", "code": "\n\nlet str = \"hello\"\nlet additionalReference = str\nlet deepCopy = System.String.Copy( str )\n\nprintfn \"%b\" <| System.Object.ReferenceEquals( str, additionalReference ) // prints true\nprintfn \"%b\" <| System.Object.ReferenceEquals( str, deepCopy )            // prints false\n\n", "explain": ".NET strings are immutable, so it is usually not useful to make a deep copy. \nHowever if needed, it is possible using a static method of the System.String type:\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\ndef string = 'Scooby-doo-bee-doo'    // assigns string object to a variable reference\ndef stringRef = string               // assigns another variable reference to the same object\ndef stringCopy = new String(string)  // copies string value into a new object, and assigns to a third variable reference\n\n\nassert string == stringRef           // they have equal values (like Java equals(), not like Java ==)\nassert string.is(stringRef)          // they are references to the same objext (like Java ==)\nassert string == stringCopy          // they have equal values\nassert ! string.is(stringCopy)       // they are references to different objects (like Java\u00a0!=)\n\n\n", "explain": "The dynamics of references and object creation are very much the same as in Java. \nHowever, the meaning of the equality (==) operator is different in Groovy, so we show those differences here, even though they are not relevant to the actual copying.\nExample and counter-example:\nTest Program:\nCaveat Lector: Strings are immutable objects in Groovy, so it is wasteful and utterly unnecessary to ever make copies of them within a Groovy program.\n"}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\nconst debug = std.debug;\nconst mem = std.mem;\n\ntest \"copy a string\" {\n    const source = \"A string.\";\n\n    // Variable `dest1` will have the same type as `source`, which is\n    // `*const [9:0]u8`.\n    const dest1 = source;\n\n    // Variable `dest2`'s type is [9]u8.\n    //\n    // The difference between the two is that `dest1` string is null-terminated,\n    // while `dest2` is not.\n    var dest2: [source.len]u8 = undefined;\n    mem.copy(u8, dest2[0..], source[0..]);\n\n    debug.assert(mem.eql(u8, dest1[0..], \"A string.\"));\n    debug.assert(mem.eql(u8, dest2[0..], \"A string.\"));\n}\n", "explain": ""}, {"task_name": "Copy a string", "task_url": "https://rosettacode.org/wiki/Copy_a_string", "task_cat": "String manipulation", "lang": "AWK", "code": "\nBEGIN {\n  a = \"a string\"\n  b = a\n  sub(/a/, \"X\", a) # modify a\n  print b  # b is a copy, not a reference to...\n}\n\n", "explain": ""}]