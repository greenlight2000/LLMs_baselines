[{"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Python", "code": "\n\n>>> import os\n>>> os.path.commonpath(['/home/user1/tmp/coverage/test', \n                        '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n\n\n>>> import os\n>>> os.path.commonprefix(['/home/user1/tmp/coverage/test', \n                          '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp/cove'\n\n\n>>> def commonprefix(args, sep='/'):\n\treturn os.path.commonprefix(args).rpartition(sep)[0]\n\n>>> commonprefix(['/home/user1/tmp/coverage/test', \n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n\n\n>>> paths = ['/home/user1/tmp/coverage/test', '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members']\n>>> os.path.dirname(os.path.commonprefix(paths))\n'/home/user1/tmp'\n\n\n>>> from itertools import takewhile\n>>> def allnamesequal(name):\n\treturn all(n==name[0] for n in name[1:])\n\n>>> def commonprefix(paths, sep='/'):\n\tbydirectorylevels = zip(*[p.split(sep) for p in paths])\n\treturn sep.join(x[0] for x in takewhile(allnamesequal, bydirectorylevels))\n\n>>> commonprefix(['/home/user1/tmp/coverage/test', \n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n>>> # And also\n>>> commonprefix(['/home/user1/tmp', '/home/user1/tmp/coverage/test',\n                  '/home/user1/tmp/covert/operator', '/home/user1/tmp/coven/members'])\n'/home/user1/tmp'\n>>>\n\n", "explain": "Since Python 3.5 os.path.commonpath function can be used:\nThe Python os.path.commonprefix function is broken as it returns common characters that may not form a valid directory path:\nThis result can be fixed:\nEven shorter:\nBut it may be better to not rely on the faulty implementation at all:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "C", "code": "\n#include <stdio.h>\n\nint common_len(const char *const *names, int n, char sep)\n{\n\tint i, pos;\n\tfor (pos = 0; ; pos++) {\n\t\tfor (i = 0; i < n; i++) {\n\t\t\tif (names[i][pos] != '\\0' &&\n\t\t\t\t\tnames[i][pos] == names[0][pos])\n\t\t\t\tcontinue;\n\n\t\t\t/* backtrack */\n\t\t\twhile (pos > 0 && names[0][--pos] != sep);\n\t\t\treturn pos;\n\t\t}\n\t}\n\n\treturn 0;\n}\n\nint main()\n{\n\tconst char *names[] = {\n\t\t\"/home/user1/tmp/coverage/test\",\n\t\t\"/home/user1/tmp/covert/operator\",\n\t\t\"/home/user1/tmp/coven/members\",\n\t};\n\tint len = common_len(names, sizeof(names) / sizeof(const char*), '/');\n\n\tif (!len) printf(\"No common path\\n\");\n\telse      printf(\"Common path:\u00a0%.*s\\n\", len, names[0]);\n\n\treturn 0;\n}\noutput:Common path: /home/user1/tmp\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <algorithm>\n#include <iostream>\n#include <string>\n#include <vector>\n\nstd::string longestPath( const std::vector<std::string> & , char ) ;\n\nint main( ) {\n   std::string dirs[ ] = {\n      \"/home/user1/tmp/coverage/test\" ,\n      \"/home/user1/tmp/covert/operator\" ,\n      \"/home/user1/tmp/coven/members\" } ;\n   std::vector<std::string> myDirs ( dirs , dirs + 3 ) ;\n   std::cout << \"The longest common path of the given directories is \"\n             << longestPath( myDirs , '/' ) << \"!\\n\" ;\n   return 0 ;\n}\n\nstd::string longestPath( const std::vector<std::string> & dirs , char separator ) {\n   std::vector<std::string>::const_iterator vsi = dirs.begin( ) ;\n   int maxCharactersCommon = vsi->length( ) ;\n   std::string compareString = *vsi ;\n   for ( vsi = dirs.begin( ) + 1 ; vsi != dirs.end( ) ; vsi++ ) {\n      std::pair<std::string::const_iterator , std::string::const_iterator> p = \n\t std::mismatch( compareString.begin( ) , compareString.end( ) , vsi->begin( ) ) ;\n      if (( p.first - compareString.begin( ) ) < maxCharactersCommon ) \n\t maxCharactersCommon = p.first - compareString.begin( ) ;\n   }\n   std::string::size_type found = compareString.rfind( separator , maxCharactersCommon ) ;\n   return compareString.substr( 0 , found ) ;\n}\n\n\nThe longest common path of the given directories is /home/user1/tmp!\n\n", "explain": "Output:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Java", "code": "\nWorks with: Java version 1.5+\n\npublic class CommonPath {\n\tpublic static String commonPath(String... paths){\n\t\tString commonPath = \"\";\n\t\tString[][] folders = new String[paths.length][];\n\t\tfor(int i = 0; i < paths.length; i++){\n\t\t\tfolders[i] = paths[i].split(\"/\"); //split on file separator\n\t\t}\n\t\tfor(int j = 0; j < folders[0].length; j++){\n\t\t\tString thisFolder = folders[0][j]; //grab the next folder name in the first path\n\t\t\tboolean allMatched = true; //assume all have matched in case there are no more paths\n\t\t\tfor(int i = 1; i < folders.length && allMatched; i++){ //look at the other paths\n\t\t\t\tif(folders[i].length < j){ //if there is no folder here\n\t\t\t\t\tallMatched = false; //no match\n\t\t\t\t\tbreak; //stop looking because we've gone as far as we can\n\t\t\t\t}\n\t\t\t\t//otherwise\n\t\t\t\tallMatched &= folders[i][j].equals(thisFolder); //check if it matched\n\t\t\t}\n\t\t\tif(allMatched){ //if they all matched this folder name\n\t\t\t\tcommonPath += thisFolder + \"/\"; //add it to the answer\n\t\t\t}else{//otherwise\n\t\t\t\tbreak;//stop looking\n\t\t\t}\n\t\t}\n\t\treturn commonPath;\n\t}\n\t\n\tpublic static void main(String[] args){\n\t\tString[] paths = { \"/home/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths));\n\t\t\n\t\tString[] paths2 = { \"/hame/user1/tmp/coverage/test\",\n\t\t\t\t \"/home/user1/tmp/covert/operator\",\n\t\t\t\t \"/home/user1/tmp/coven/members\"};\n\t\tSystem.out.println(commonPath(paths2));\n\t}\n}\n\n\n/home/user1/tmp/\n/\n\n\tstatic String commonPath(String...  paths){\n\t\tString commonPath = \"\";\n\t\tString[][] folders = new String[paths.length][];\n\t\t\n\t\tfor(int i=0; i<paths.length; i++){\n\t\t\tfolders[i] = paths[i].split(\"/\");\n\t\t}\n\t\t\t\n\t\tfor(int j = 0; j< folders[0].length; j++){\n\t\t\tString s = folders[0][j];\n\t\t\tfor(int i=1; i<paths.length; i++){\n\t\t\t\tif(!s.equals(folders[i][j]))\n\t\t\t\t\treturn commonPath;\n\t\t\t}\n\t\t\tcommonPath += s + \"/\";\n\t\t}\n\t\treturn commonPath;\t\t\n\t}\n\n", "explain": "This example is case-sensitive.\nOutput:\nChange folders[i] = paths[i].split(\"/\"); to add more separators. Ex: to add \"\\\" and \".\" as separators, change the line to folders[i] = paths[i].split(\"[/\\\\\\\\.]\"); (adding square brackets makes the regex choose one character out of the group inside, adding all of the extra backslashes escapes the backslash character). After making this change, all separators will be changed to \"/\" in the result, but they can be mixed in the path (e.g. \"/home.user1/tmp\\\\coverage/test\" (escaped backslash) will act the same as \"/home/user1/tmp/coverage/test\").\nA slightly modified version of the previous program, only the method commonPath() is changed.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "C#", "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\nusing System.Text;\n\nnamespace RosettaCodeTasks\n{\n\n\tclass Program\n\t{\n\t\tstatic void Main ( string[ ] args )\n\t\t{\n\t\t\tFindCommonDirectoryPath.Test ( );\n\t\t}\n\n\t}\n\n\tclass FindCommonDirectoryPath\n\t{\n\t\tpublic static void Test ( )\n\t\t{\n\t\t\tConsole.WriteLine ( \"Find Common Directory Path\" );\n\t\t\tConsole.WriteLine ( );\n\t\t\tList<string> PathSet1 = new List<string> ( );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coverage/test\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/covert/operator\" );\n\t\t\tPathSet1.Add ( \"/home/user1/tmp/coven/members\" );\n\t\t\tConsole.WriteLine(\"Path Set 1 (All Absolute Paths):\");\n\t\t\tforeach ( string path in PathSet1 )\n\t\t\t{\n\t\t\t\tConsole.WriteLine ( path );\n\t\t\t}\n\t\t\tConsole.WriteLine ( \"Path Set 1 Common Path: {0}\", FindCommonPath ( \"/\", PathSet1 ) );\n\t\t}\n\t\tpublic static string FindCommonPath ( string Separator, List<string> Paths )\n\t\t{\n\t\t\tstring CommonPath = String.Empty;\n\t\t\tList<string> SeparatedPath = Paths\n\t\t\t\t.First ( str => str.Length == Paths.Max ( st2 => st2.Length ) )\n\t\t\t\t.Split ( new string[ ] { Separator }, StringSplitOptions.RemoveEmptyEntries )\n\t\t\t\t.ToList ( );\n\n\t\t\tforeach ( string PathSegment in SeparatedPath.AsEnumerable ( ) )\n\t\t\t{\n\t\t\t\tif ( CommonPath.Length == 0 && Paths.All ( str => str.StartsWith ( PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath = PathSegment;\n\t\t\t\t}\n\t\t\t\telse if ( Paths.All ( str => str.StartsWith ( CommonPath + Separator + PathSegment ) ) )\n\t\t\t\t{\n\t\t\t\t\tCommonPath += Separator + PathSegment;\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tbreak;\n\t\t\t\t}\n\t\t\t}\n\t\t\t\n\t\t\treturn CommonPath;\n\t\t}\n\t}\n}\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\n/**\n * Given an array of strings, return an array of arrays, containing the\n * strings split at the given separator\n * @param {!Array<!string>} a\n * @param {string} sep\n * @returns {!Array<!Array<string>>}\n */\nconst splitStrings = (a, sep = '/') => a.map(i => i.split(sep));\n\n/**\n * Given an index number, return a function that takes an array and returns the\n * element at the given index\n * @param {number} i\n * @return {function(!Array<*>): *}\n */\nconst elAt = i => a => a[i];\n\n/**\n * Transpose an array of arrays:\n * Example:\n * [['a', 'b', 'c'], ['A', 'B', 'C'], [1, 2, 3]] ->\n * [['a', 'A', 1], ['b', 'B', 2], ['c', 'C', 3]]\n * @param {!Array<!Array<*>>} a\n * @return {!Array<!Array<*>>}\n */\nconst rotate = a => a[0].map((e, i) => a.map(elAt(i)));\n\n/**\n * Checks of all the elements in the array are the same.\n * @param {!Array<*>} arr\n * @return {boolean}\n */\nconst allElementsEqual = arr => arr.every(e => e === arr[0]);\n\n\nconst commonPath = (input, sep = '/') => rotate(splitStrings(input, sep))\n    .filter(allElementsEqual).map(elAt(0)).join(sep);\n\nconst cdpInput = [\n  '/home/user1/tmp/coverage/test',\n  '/home/user1/tmp/covert/operator',\n  '/home/user1/tmp/coven/members',\n];\n\nconsole.log(`Common path is: ${commonPath(cdpInput)}`);\n\n\nOutput:\nCommon path is: /home/user1/tmp\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "PHP", "code": "\n<?php\n\n/*\n This works with dirs and files in any number of combinations.\n*/\n\nfunction _commonPath($dirList)\n{\n\t$arr = array();\n\tforeach($dirList as $i => $path)\n\t{\n\t\t$dirList[$i]\t= explode('/', $path);\n\t\tunset($dirList[$i][0]);\n\t\t\n\t\t$arr[$i] = count($dirList[$i]);\n\t}\n\t\n\t$min = min($arr);\n\t\n\tfor($i = 0; $i < count($dirList); $i++)\n\t{\n\t\twhile(count($dirList[$i]) > $min)\n\t\t{\n\t\t\tarray_pop($dirList[$i]);\n\t\t}\n\t\t\n\t\t$dirList[$i] = '/' . implode('/' , $dirList[$i]);\n\t}\n\t\n\t$dirList = array_unique($dirList);\n\twhile(count($dirList) !== 1)\n\t{\n\t\t$dirList = array_map('dirname', $dirList);\n\t\t$dirList = array_unique($dirList);\n\t}\n\treset($dirList);\n\t\n\treturn current($dirList);\n}\n\n /* TEST */\n\n$dirs = array(\n '/home/user1/tmp/coverage/test',\n '/home/user1/tmp/covert/operator',\n '/home/user1/tmp/coven/members',\n);\n\n\nif('/home/user1/tmp' !== common_path($dirs))\n{\n  echo 'test fail';\n} else {\n  echo 'test success';\n}\n\n?>\n\n\n<?php\n\n/* A more compact string-only version, which I assume would be much faster */\n/* If you want the trailing /, return $common; */\n\nfunction getCommonPath($paths) {\n\t$lastOffset = 1;\n\t$common = '/';\n\twhile (($index = strpos($paths[0], '/', $lastOffset)) !== FALSE) {\n\t\t$dirLen = $index - $lastOffset + 1;\t// include /\n\t\t$dir = substr($paths[0], $lastOffset, $dirLen);\n\t\tforeach ($paths as $path) {\n\t\t\tif (substr($path, $lastOffset, $dirLen) != $dir)\n\t\t\t\treturn $common;\n\t\t}\n\t\t$common .= $dir;\n\t\t$lastOffset = $index + 1;\n\t}\n\treturn substr($common, 0, -1);\n}\n\n?>\n\n", "explain": "\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Go", "code": "\n\npackage main\n\nimport (\n\t\"fmt\"\n\t\"os\"\n\t\"path\"\n)\n\nfunc CommonPrefix(sep byte, paths ...string) string {\n\t// Handle special cases.\n\tswitch len(paths) {\n\tcase 0:\n\t\treturn \"\"\n\tcase 1:\n\t\treturn path.Clean(paths[0])\n\t}\n\n\t// Note, we treat string as []byte, not []rune as is often\n\t// done in Go. (And sep as byte, not rune). This is because\n\t// most/all supported OS' treat paths as string of non-zero\n\t// bytes. A filename may be displayed as a sequence of Unicode\n\t// runes (typically encoded as UTF-8) but paths are\n\t// not required to be valid UTF-8 or in any normalized form\n\t// (e.g.\u00a0\"\u00e9\" (U+00C9) and \"\u00e9\" (U+0065,U+0301) are different\n\t// file names.\n\tc := []byte(path.Clean(paths[0]))\n\n\t// We add a trailing sep to handle the case where the\n\t// common prefix directory is included in the path list\n\t// (e.g.\u00a0/home/user1, /home/user1/foo, /home/user1/bar).\n\t// path.Clean will have cleaned off trailing / separators with\n\t// the exception of the root directory, \"/\" (in which case we\n\t// make it \"//\", but this will get fixed up to \"/\" bellow).\n\tc = append(c, sep)\n\n\t// Ignore the first path since it's already in c\n\tfor _, v := range paths[1:] {\n\t\t// Clean up each path before testing it\n\t\tv = path.Clean(v) + string(sep)\n\n\t\t// Find the first non-common byte and truncate c\n\t\tif len(v) < len(c) {\n\t\t\tc = c[:len(v)]\n\t\t}\n\t\tfor i := 0; i < len(c); i++ {\n\t\t\tif v[i] != c[i] {\n\t\t\t\tc = c[:i]\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t}\n\n\t// Remove trailing non-separator characters and the final separator\n\tfor i := len(c) - 1; i >= 0; i-- {\n\t\tif c[i] == sep {\n\t\t\tc = c[:i]\n\t\t\tbreak\n\t\t}\n\t}\n\n\treturn string(c)\n}\n\nfunc main() {\n\tc := CommonPrefix(os.PathSeparator,\n\t\t//\"/home/user1/tmp\",\n\t\t\"/home/user1/tmp/coverage/test\",\n\t\t\"/home/user1/tmp/covert/operator\",\n\t\t\"/home/user1/tmp/coven/members\",\n\t\t\"/home//user1/tmp/coventry\",\n\t\t\"/home/user1/././tmp/covertly/foo\",\n\t\t\"/home/bob/../user1/tmp/coved/bar\",\n\t)\n\tif c == \"\" {\n\t\tfmt.Println(\"No common path\")\n\t} else {\n\t\tfmt.Println(\"Common path:\", c)\n\t}\n}\n\n", "explain": "If the directory that is the common path is also in the list, then care must be taken to not truncate it (as some other solutions on this page do).\nE.g.\u00a0(/home/user1, /home/user1/foo, /home/user1/bar) should result in /home/user1, not /home.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nprogram Find_common_directory_path;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\nfunction FindCommonPath(Separator: Char; Paths: TArray<string>): string;\nvar\n  SeparatedPath: array of TArray<string>;\n  minLength, index: Integer;\n  isSame: Boolean;\n  j, i: Integer;\n  cmp: string;\nbegin\n  SetLength(SeparatedPath, length(Paths));\n  minLength := MaxInt;\n  for i := 0 to High(SeparatedPath) do\n  begin\n    SeparatedPath[i] := Paths[i].Split([Separator]);\n    if minLength > length(SeparatedPath[i]) then\n      minLength := length(SeparatedPath[i]);\n  end;\n\n  index := -1;\n\n  for i := 0 to minLength - 1 do\n  begin\n    isSame := True;\n    cmp := SeparatedPath[0][i];\n    for j := 1 to High(SeparatedPath) do\n      if SeparatedPath[j][i] <> cmp then\n      begin\n        isSame := False;\n        Break;\n      end;\n    if not isSame then\n    begin\n      index := i - 1;\n      Break;\n    end;\n  end;\n\n  Result := '';\n  if index >= 0 then\n    for i := 0 to index do\n    begin\n      Result := Result + SeparatedPath[0][i];\n      if i < index then\n        Result := Result + Separator;\n    end;\nend;\n\nbegin\n  Writeln(FindCommonPath('/', [\n    '/home/user1/tmp/coverage/test',\n    '/home/user1/tmp/covert/operator',\n    '/home/user1/tmp/coven/members']));\n  Readln;\nend.\n\n\nOutput:\n/home/user1/tmp\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Ruby", "code": "\n\nrequire 'abbrev'\n\ndirs = %w( /home/user1/tmp/coverage/test /home/user1/tmp/covert/operator /home/user1/tmp/coven/members )\n\ncommon_prefix = dirs.abbrev.keys.min_by {|key| key.length}.chop  # => \"/home/user1/tmp/cove\"\ncommon_directory = common_prefix.sub(%r{/[^/]*$}, '')            # => \"/home/user1/tmp\"\n\n\nseparator = '/'\npath0, *paths = dirs.collect {|dir| dir.split(separator)}\nuncommon_idx = path0.zip(*paths).index {|dirnames| dirnames.uniq.length > 1}\nuncommon_idx = path0.length  unless uncommon_idx                # if uncommon_idx==nil\ncommon_directory = path0[0...uncommon_idx].join(separator)      # => \"/home/user1/tmp\"\n\n\ndef common_directory_path(dirs, separator='/')\n  dir1, dir2 = dirs.minmax.map{|dir| dir.split(separator)}\n  dir1.zip(dir2).take_while{|dn1,dn2| dn1==dn2}.map(&:first).join(separator)\nend\n\np common_directory_path(dirs)           #=> \"/home/user1/tmp\"\n\n", "explain": "Uses the standard library abbrev module: Given a set of strings, calculate the set of unambiguous abbreviations for those strings, and return a hash where the keys are all the possible abbreviations and the values are the full strings.\nImplementing without that module:\nor method version\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Rust", "code": "\n\nuse std::path::{Path, PathBuf};\n\nfn main() {\n    let paths = [\n        Path::new(\"/home/user1/tmp/coverage/test\"),\n        Path::new(\"/home/user1/tmp/covert/operator\"),\n        Path::new(\"/home/user1/tmp/coven/members\"),\n    ];\n    match common_path(&paths) {\n        Some(p) => println!(\"The common path is: {:#?}\", p),\n        None => println!(\"No common paths found\"),\n    }\n}\n\nfn common_path<I, P>(paths: I) -> Option<PathBuf>\nwhere\n    I: IntoIterator<Item = P>,\n    P: AsRef<Path>,\n{\n    let mut iter = paths.into_iter();\n    let mut ret = iter.next()?.as_ref().to_path_buf();\n    for path in iter {\n        if let Some(r) = common(ret, path.as_ref()) {\n            ret = r;\n        } else {\n            return None;\n        }\n    }\n    Some(ret)\n}\n\nfn common<A: AsRef<Path>, B: AsRef<Path>>(a: A, b: B) -> Option<PathBuf> {\n    let a = a.as_ref().components();\n    let b = b.as_ref().components();\n    let mut ret = PathBuf::new();\n    let mut found = false;\n    for (one, two) in a.zip(b) {\n        if one == two {\n            ret.push(one);\n            found = true;\n        } else {\n            break;\n        }\n    }\n    if found {\n        Some(ret)\n    } else {\n        None\n    }\n}\n\n", "explain": "Rust has specific types for owned and borrowed paths. PathBuf is an 'owned' pointer to a path, Path is a borrow; this is similar to String and str, respectively.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Swift", "code": "\n\nimport Foundation\n\n\nfunc getPrefix(_ text:[String]) -> String? {\n    var common:String = text[0]\n    for i in text {\n        common = i.commonPrefix(with: common)\n    }\n    return common\n}\n\nvar test = [\"/home/user1/tmp/coverage/test\", \n \"/home/user1/tmp/covert/operator\",\n \"/home/user1/tmp/coven/members\"]\n\nvar output:String = getPrefix(test)!\nprint(output)\n\n", "explain": "The below solution works only in swift in Linux.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "R", "code": "\nget_common_dir <- function(paths, delim = \"/\")\n{\n  path_chunks <- strsplit(paths, delim)\n  \n  i <- 1\n  repeat({\n    current_chunk <- sapply(path_chunks, function(x) x[i])\n    if(any(current_chunk != current_chunk[1])) break\n    i <- i + 1\n  })\n  paste(path_chunks[[1]][seq_len(i - 1)], collapse = delim)\n\n}\n\n# Example Usage:\npaths <- c(\n  '/home/user1/tmp/coverage/test',\n  '/home/user1/tmp/covert/operator',\n  '/home/user1/tmp/coven/members')\n\nget_common_dir(paths)           # \"/home/user1/tmp\"\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\nWorks with: VBA version 6.5\nWorks with: VBA version 7.1\nPublic Function CommonDirectoryPath(ParamArray Paths()) As String\nDim v As Variant\nDim Path() As String, s As String\nDim i As Long, j As Long, k As Long\nConst PATH_SEPARATOR As String = \"/\"\n  \n  For Each v In Paths\n    ReDim Preserve Path(0 To i)\n    Path(i) = v\n    i = i + 1\n  Next v\n  \n  k = 1\n  \n  Do\n    For i = 0 To UBound(Path)\n      If i Then\n        If InStr(k, Path(i), PATH_SEPARATOR) <> j Then\n          Exit Do\n        ElseIf Left$(Path(i), j) <> Left$(Path(0), j) Then\n          Exit Do\n        End If\n      Else\n        j = InStr(k, Path(i), PATH_SEPARATOR)\n        If j = 0 Then\n          Exit Do\n        End If\n      End If\n    Next i\n    s = Left$(Path(0), j + CLng(k <> 1))\n    k = j + 1\n  Loop\n  CommonDirectoryPath = s\n  \nEnd Function\n\nSub Main()\n\n' testing the above function\n\nDebug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/home/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\") = _\n \"/home/user1/tmp\"\n \n Debug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/home/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\", _\n \"/home/user1/abc/coven/members\") = _\n \"/home/user1\"\n\nDebug.Assert CommonDirectoryPath( _\n \"/home/user1/tmp/coverage/test\", _\n \"/hope/user1/tmp/covert/operator\", _\n \"/home/user1/tmp/coven/members\") = _\n \"/\"\n\nEnd Sub\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Text_IO;  use Ada.Text_IO;\n\nprocedure Test_Common_Path is\n   function \"rem\" (A, B : String) return String is\n      Slash : Integer := A'First; -- At the last slash seen in A\n      At_A  : Integer := A'first;\n      At_B  : Integer := B'first;\n   begin\n      loop\n         if At_A > A'Last then\n            if At_B > B'Last or else B (At_B) = '/' then\n               return A;\n            else\n               return A (A'First..Slash - 1);\n            end if;\n         elsif At_B > B'Last then\n            if A (At_A) = '/' then -- A cannot be shorter than B here\n               return B;\n            else\n               return A (A'First..Slash - 1);\n            end if;\n         elsif A (At_A) /= B (At_B) then\n            return A (A'First..Slash - 1);\n         elsif A (At_A) = '/' then\n            Slash := At_A;\n         end if;\n         At_A := At_A + 1;\n         At_B := At_B + 1;\n      end loop;      \n   end \"rem\";\nbegin\n   Put_Line\n   (  \"/home/user1/tmp/coverage/test\" rem\n      \"/home/user1/tmp/covert/operator\" rem\n      \"/home/user1/tmp/coven/members\"\n   );\nend Test_Common_Path;\n\n\n/home/user1/tmp\n\n", "explain": "Output:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nfunction commonpath(ds::Vector{<:AbstractString}, dlm::Char='/')\n    0 < length(ds) || return \"\"\n    1 < length(ds) || return String(ds[1])\n    p = split(ds[1], dlm)\n    mincnt = length(p)\n    for d in ds[2:end]\n        q = split(d, dlm)\n        mincnt = min(mincnt, length(q))\n        hits = findfirst(p[1:mincnt] .!= q[1:mincnt])\n        if hits != 0 mincnt = hits - 1 end\n        if mincnt == 0 return \"\" end\n    end\n    1 < mincnt || p[1] != \"\" || return convert(T, string(dlm))\n    return join(p[1:mincnt], dlm)\nend\n\ntest = [\"/home/user1/tmp/coverage/test\", \"/home/user1/tmp/covert/operator\", \"/home/user1/tmp/coven/members\"]\n\nprintln(\"Comparing:\\n - \", join(test, \"\\n - \"))\nprintln(\"for their common directory path yields:\\n\", commonpath(test))\n\n\nOutput:\nComparing:\n - /home/user1/tmp/coverage/test\n - /home/user1/tmp/covert/operator\n - /home/user1/tmp/coven/members\nfor their common directory path yields:\n/home/user1/tmp\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\n// version 1.1.51\n\nfun findCommonDirPath(paths: List<String>, separator: Char): String {\n    if (paths.isEmpty()) return \"\"\n    if (paths.size == 1) return paths[0]\n    val splits = paths[0].split(separator)\n    val n = splits.size\n    val paths2 = paths.drop(1)\n    var k = 0\n    var common = \"\"\n    while (true) {\n        val prevCommon = common\n        common += if (k == 0) splits[0] else separator + splits[k]\n        if (!paths2.all { it.startsWith(common + separator) || it == common } ) return prevCommon\n        if (++k == n) return common\n    }\n}\n\nfun main(args: Array<String>) {\n    val paths = listOf(\n        \"/home/user1/tmp/coverage/test\",\n        \"/home/user1/tmp/covert/operator\",\n        \"/home/user1/tmp/coven/members\"\n    )\n    val pathsToPrint = paths.map { \"   '$it'\" }.joinToString(\"\\n\")\n    println(\"The common directory path of:\\n\\n$pathsToPrint\\n\")\n    println(\"is '${findCommonDirPath(paths, '/')}'\")\n}\n\n\nOutput:\nThe common directory path of:\n\n   '/home/user1/tmp/coverage/test'\n   '/home/user1/tmp/covert/operator'\n   '/home/user1/tmp/coven/members'\n\nis '/home/user1/tmp'\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Perl", "code": "\n\nsub common_prefix {\n    my $sep = shift;\n    my $paths = join \"\\0\", map { $_.$sep } @_;\n    $paths =~ /^ ( [^\\0]* ) $sep [^\\0]* (?: \\0 \\1 $sep [^\\0]* )* $/x;\n    return $1;\n}\n\n\nuse List::Util qw(first);\n\nsub common_prefix {\n    my ($sep, @paths) = @_;\n    my %prefixes;\n    \n    for (@paths) {\n        do { ++$prefixes{$_} } while s/$sep [^$sep]* $//x\n    }\n    \n    return first { $prefixes{$_} == @paths } reverse sort keys %prefixes;\n}\n\n\nmy @paths = qw(/home/user1/tmp/coverage/test \n               /home/user1/tmp/covert/operator\n               /home/user1/tmp/coven/members);\nprint common_prefix('/', @paths), \"\\n\";\n\n\nOutput:\n/home/user1/tmp\n", "explain": "A solution which lets the regex engine do all the work (it operates on the concatenation of the given paths delimited by null-bytes, which should be safe since null-bytes are not allowed inside paths):\nA more conventional solution, which tallies up all potential prefixes from the given paths and then looks for the longest one that occurred the same number of times as there are paths:\nTesting:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Prolog", "code": "\n%! directory_prefix(PATHs,STOP0,PREFIX)\n\ndirectory_prefix([],_STOP0_,'')\n:-\n!\n.\n\ndirectory_prefix(PATHs0,STOP0,PREFIX)\n:-\nprolog:once(longest_prefix(PATHs0,STOP0,LONGEST_PREFIX)) ->\nprolog:atom_concat(PREFIX,STOP0,LONGEST_PREFIX) ;\nPREFIX=''\n. \n\n%! longest_prefix(PATHs,STOP0,PREFIX)\n\nlongest_prefix(PATHs0,STOP0,PREFIX)\n:-\nQUERY=(shortest_prefix(PATHs0,STOP0,SHORTEST_PREFIX)) ,\nprolog:findall(SHORTEST_PREFIX,QUERY,SHORTEST_PREFIXs) ,\nlists:reverse(SHORTEST_PREFIXs,LONGEST_PREFIXs) ,\nlists:member(PREFIX,LONGEST_PREFIXs)\n.\n\n%! shortest_prefix(PATHs,STOP0,PREFIX)\n\nshortest_prefix([],_STOP0_,_PREFIX_) .\n\nshortest_prefix([PATH0|PATHs0],STOP0,PREFIX)\n:-\nstarts_with(PATH0,PREFIX) ,\nends_with(PREFIX,STOP0) ,\nshortest_prefix(PATHs0,STOP0,PREFIX)\n.\n\n%! starts_with(TARGET,START)\n\nstarts_with(TARGET,START)\n:-\nprolog:atom_concat(START,_,TARGET)\n.\n\n%! ends_with(TARGET,END)\n\nends_with(TARGET,END)\n:-\nprolog:atom_concat(_,END,TARGET)\n.\n\n\nOutput:\n?- directory_prefix(['/home/user1/tmp/coverage/test','/home/user1/tmp/convert/operator','/home/user1/tmp/coven/members'],'/',PREFIX) .\nPREFIX = '/home/user1/tmp' .\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Scala", "code": "\nNaive[edit]\n\nobject FindCommonDirectoryPath extends App {\n  def commonPath(paths: List[String]): String = {\n    def common(a: List[String], b: List[String]): List[String] = (a, b) match {\n      case (a :: as, b :: bs) if a equals b => a :: common(as, bs)\n      case _ => Nil\n    }\n    if (paths.length < 2) paths.headOption.getOrElse(\"\")\n    else paths.map(_.split(\"/\").toList).reduceLeft(common).mkString(\"/\")\n  }\n\n  val test = List(\n    \"/home/user1/tmp/coverage/test\",\n    \"/home/user1/tmp/covert/operator\",\n    \"/home/user1/tmp/coven/members\"\n  )\n  println(commonPath(test))\n}\n\n\n/home/user1/tmp\nAdvanced[edit]\n\nobject FindCommonDirectoryPathRelative extends App {\n  def commonPath(paths: List[String]): String = {\n    val SEP = \"/\"\n    val BOUNDARY_REGEX = s\"(?=[$SEP])(?<=[^$SEP])|(?=[^$SEP])(?<=[$SEP])\"\n    def common(a: List[String], b: List[String]): List[String] = (a, b) match {\n      case (a :: as, b :: bs) if a equals b => a :: common(as, bs)\n      case _ => Nil\n    }\n    if (paths.length < 2) paths.headOption.getOrElse(\"\")\n    else paths.map(_.split(BOUNDARY_REGEX).toList).reduceLeft(common).mkString\n  }\n\n  val test = List(\n    \"/home/user1/tmp/coverage/test\",\n    \"/home/user1/tmp/covert/operator\",\n    \"/home/user1/tmp/coven/members\"\n  )\n  println(commonPath(test).replaceAll(\"/$\", \"\"))\n\n  // test cases\n  assert(commonPath(test.take(1)) == test.head)\n  assert(commonPath(Nil) == \"\")\n  assert(commonPath(List(\"\")) == \"\")\n  assert(commonPath(List(\"/\")) == \"/\")\n  assert(commonPath(List(\"/\", \"\")) == \"\")\n  assert(commonPath(List(\"/\", \"/a\")) == \"/\")\n  assert(commonPath(List(\"/a\", \"/b\")) == \"/\")\n  assert(commonPath(List(\"/a\", \"/a\")) == \"/a\")\n  assert(commonPath(List(\"/a/a\", \"/b\")) == \"/\")\n  assert(commonPath(List(\"/a/a\", \"/b\")) == \"/\")\n  assert(commonPath(List(\"/a/a\", \"/a\")) == \"/a\")\n  assert(commonPath(List(\"/a/a\", \"/a/b\")) == \"/a/\")\n  assert(commonPath(List(\"/a/b\", \"/a/b\")) == \"/a/b\")\n  assert(commonPath(List(\"a\", \"/a\")) == \"\")\n  assert(commonPath(List(\"a/a\", \"/a\")) == \"\")\n  assert(commonPath(List(\"a/a\", \"/b\")) == \"\")\n  assert(commonPath(List(\"a\", \"a\")) == \"a\")\n  assert(commonPath(List(\"a/a\", \"b\")) == \"\")\n  assert(commonPath(List(\"a/a\", \"b\")) == \"\")\n  assert(commonPath(List(\"a/a\", \"a\")) == \"a\")\n  assert(commonPath(List(\"a/a\", \"a/b\")) == \"a/\")\n  assert(commonPath(List(\"a/b\", \"a/b\")) == \"a/b\")\n  assert(commonPath(List(\"/a/\", \"/b/\")) == \"/\")\n  assert(commonPath(List(\"/a/\", \"/a/\")) == \"/a/\")\n  assert(commonPath(List(\"/a/a/\", \"/b/\")) == \"/\")\n  assert(commonPath(List(\"/a/a/\", \"/b/\")) == \"/\")\n  assert(commonPath(List(\"/a/a/\", \"/a/\")) == \"/a/\")\n  assert(commonPath(List(\"/a/a/\", \"/a/b/\")) == \"/a/\")\n  assert(commonPath(List(\"/a/b/\", \"/a/b/\")) == \"/a/b/\")\n}\n\n", "explain": "This simple solution solves the task as given, but has oddities for edge cases due to the implementation of java.lang.String#split.\nOutput:\nThis implementation will handle various edge cases and relative paths. It also includes any common trailing '/' but callers can remove this if desired.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "D", "code": "\n\nimport std.stdio, std.string, std.algorithm, std.path, std.array;\n\nstring commonDirPath(in string[] paths, in string sep = \"/\") pure {\n    if (paths.empty)\n        return null;\n    return paths.map!(p => p.split(sep)).reduce!commonPrefix.join(sep);\n}\n\nvoid main() {\n    immutable paths = [\"/home/user1/tmp/coverage/test\",\n                       \"/home/user1/tmp/covert/operator\",\n                       \"/home/user1/tmp/coven/members\"];\n    writeln(`The common path is: \"`, paths.commonDirPath, '\"');\n}\n\n\nOutput:\nThe common path is: \"/home/user1/tmp\"\n", "explain": "This code uses the std.algorithm.commonPrefix function that finds the common prefix of two ranges.\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Haskell", "code": "\nimport Data.List\n\n-- Return the common prefix of two lists.\ncommonPrefix2 (x:xs) (y:ys) | x == y = x : commonPrefix2 xs ys\ncommonPrefix2 _ _ = []\n\n-- Return the common prefix of zero or more lists.\ncommonPrefix (xs:xss) = foldr commonPrefix2 xs xss\ncommonPrefix _ = []\n\n-- Split a string into path components.\nsplitPath = groupBy (\\_ c -> c /= '/')\n\n-- Return the common prefix of zero or more paths.\n-- Note that '/' by itself is not considered a path component,\n-- so \"/\" and \"/foo\" are treated as having nothing in common.\ncommonDirPath = concat . commonPrefix . map splitPath\n\nmain = putStrLn $ commonDirPath [\n        \"/home/user1/tmp/coverage/test\",\n        \"/home/user1/tmp/covert/operator\",\n        \"/home/user1/tmp/coven/members\"\n       ]\n\n\nimport Data.List (transpose, intercalate)\nimport Data.List.Split (splitOn)\n\n\n------------------ COMMON DIRECTORY PATH -----------------\n\ncommonDirectoryPath :: [String] -> String\ncommonDirectoryPath [] = []\ncommonDirectoryPath xs =\n  intercalate \"/\" $\n  head <$> takeWhile ((all . (==) . head) <*> tail) $\n  transpose (splitOn \"/\" <$> xs)\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  (putStrLn . commonDirectoryPath)\n    [ \"/home/user1/tmp/coverage/test\"\n    , \"/home/user1/tmp/covert/operator\"\n    , \"/home/user1/tmp/coven/members\"\n    ]\n\n\nOutput:\n/home/user1/tmp\n", "explain": "Or, expressed directly in applicative terms:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nWorks with: Windows Script Host version *\n' Read the list of paths (newline-separated) into an array...\nstrPaths = Split(WScript.StdIn.ReadAll, vbCrLf)\n \n' Split each path by the delimiter (/)...\nFor i = 0 To UBound(strPaths)\n\tstrPaths(i) = Split(strPaths(i), \"/\")\nNext\n\nWith CreateObject(\"Scripting.FileSystemObject\")\n\n\t' Test each path segment...\n\tFor j = 0 To UBound(strPaths(0))\n\t\t\n\t\t' Test each successive path against the first...\n\t\tFor i = 1 To UBound(strPaths)\n\t\t\tIf strPaths(0)(j) <> strPaths(i)(j) Then Exit For\n\t\tNext\n\n\t\t' If we didn't make it all the way through, exit the block...\n\t\tIf i <= UBound(strPaths) Then Exit For\n\t\t\n\t\t' Make sure this path exists...\n\t\tIf Not .FolderExists(strPath & strPaths(0)(j) & \"/\") Then Exit For\n\t\tstrPath = strPath & strPaths(0)(j) & \"/\"\n\t\t\n\tNext\n\nEnd With\n\n' Remove the final \"/\"...\nWScript.Echo Left(strPath, Len(strPath) - 1)\n\n", "explain": ""}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n<#\n.Synopsis\n    Finds the deepest common directory path of files passed through the pipeline.\n.Parameter File\n    PowerShell file object.\n#>\nfunction Get-CommonPath {\n[CmdletBinding()]\n    param (\n        [Parameter(Mandatory=$true, ValueFromPipeline=$true)]\n        [System.IO.FileInfo] $File\n    )\n    process {\n        # Get the current file's path list\n        $PathList =  $File.FullName -split \"\\$([IO.Path]::DirectorySeparatorChar)\"\n        # Get the most common path list\n        if ($CommonPathList) {\n            $CommonPathList = (Compare-Object -ReferenceObject $CommonPathList -DifferenceObject $PathList -IncludeEqual `\n                -ExcludeDifferent -SyncWindow 0).InputObject\n        } else {\n            $CommonPathList = $PathList\n        }\n    }\n    end {\n        $CommonPathList -join [IO.Path]::DirectorySeparatorChar\n    }\n}\n\n\n\"C:\\a\\b\\c\\d\\e\",\"C:\\a\\b\\e\\f\",\"C:\\a\\b\\c\\d\\x\" | Get-CommonPath\nC:\\a\\b\n\n", "explain": "Sample execution:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "F#", "code": "\nopen System\n\nlet (|SeqNode|SeqEmpty|) s =\n    if Seq.isEmpty s then SeqEmpty\n    else SeqNode ((Seq.head s), Seq.skip 1 s)\n\n[<EntryPoint>]\nlet main args =\n    let splitBySeparator (str : string) = Seq.ofArray (str.Split('/'))\n\n    let rec common2 acc = function\n        | SeqEmpty -> Seq.ofList (List.rev acc)\n        | SeqNode((p1, p2), rest) ->\n            if p1 = p2 then common2 (p1::acc) rest\n            else Seq.ofList (List.rev acc)\n\n    let commonPrefix paths =\n        match Array.length(paths) with\n        | 0 -> [||]\n        | 1 -> Seq.toArray (splitBySeparator paths.[0])\n        | _ ->\n            let argseq = Seq.ofArray paths\n            Seq.fold (\n                fun (acc : seq<string>) items ->\n                    common2 [] (List.ofSeq (Seq.zip acc (splitBySeparator items)))\n            ) (splitBySeparator (Seq.head argseq)) (Seq.skip 1 argseq)\n            |> Seq.toArray\n\n    printfn \"The common preffix is: %A\" (String.Join(\"/\", (commonPrefix args)))\n    0\n\n\nThe common preffix is: \"/home/user1/tmp\"\n", "explain": "Output for the given task input\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\ndef commonPath = { delim, Object[] paths ->\n    def pathParts = paths.collect { it.split(delim) }\n    pathParts.transpose().inject([match:true, commonParts:[]]) { aggregator, part ->\n        aggregator.match = aggregator.match && part.every { it == part [0] }\n        if (aggregator.match) { aggregator.commonParts << part[0] }\n        aggregator\n    }.commonParts.join(delim)\n}\n\n\nprintln commonPath('/',\n    '/home/user1/tmp/coverage/test',\n    '/home/user1/tmp/covert/operator',\n    '/home/user1/tmp/coven/members')\n\nprintln commonPath('/',\n    '/home/user1/tmp/coverage/test',\n    '/home/user1/tmp/covert/test',\n    '/home/user1/tmp/coven/test',\n    '/home/user1/tmp/covers/test')\n\n\n/home/user1/tmp\n/home/user1/tmp\n", "explain": "Solution:\nTest:\nOutput:\n"}, {"task_name": "Find common directory path", "task_url": "https://rosettacode.org/wiki/Find_common_directory_path", "task_cat": "String manipulation", "lang": "AWK", "code": "\n# Finds the longest common directory of paths[1], paths[2], ...,\n# paths[count], where sep is a single-character directory separator.\nfunction common_dir(paths, count, sep,    b, c, f, i, j, p) {\n\tif (count < 1)\n\t\treturn \"\"\n\n\tp = \"\"\t# Longest common prefix\n\tf = 0\t# Final index before last sep\n\n\t# Loop for c = each character of paths[1].\n\tfor (i = 1; i <= length(paths[1]); i++) {\n\t\tc = substr(paths[1], i, 1)\n\n\t\t# If c is not the same in paths[2], ..., paths[count]\n\t\t# then break both loops.\n\t\tb = 0\n\t\tfor (j = 2; j <= count; j++) {\n\t\t\tif (c != substr(paths[j], i, 1)) {\n\t\t\t\tb = 1\n\t\t\t\tbreak\n\t\t\t}\n\t\t}\n\t\tif (b)\n\t\t\tbreak\n\n\t\t# Append c to prefix. Update f.\n\t\tp = p c\n\t\tif (c == sep)\n\t\t\tf = i - 1\n\t}\n\n\t# Return only f characters of prefix.\n\treturn substr(p, 1, f)\n}\n\nBEGIN {\n\ta[1] = \"/home/user1/tmp/coverage/test\"\n\ta[2] = \"/home/user1/tmp/covert/operator\"\n\ta[3] = \"/home/user1/tmp/coven/members\"\n\tprint common_dir(a, 3, \"/\")\n}\n\n\n", "explain": "Prints /home/user1/tmp.\n"}]