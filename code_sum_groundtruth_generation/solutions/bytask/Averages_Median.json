[{"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Python", "code": "\ndef median(aray):\n    srtd = sorted(aray)\n    alen = len(srtd)\n    return 0.5*( srtd[(alen-1)//2] + srtd[alen//2])\n\na = (4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\na = (4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\nprint a, median(a)\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct floatList {\n    float *list;\n    int   size;\n} *FloatList;\n\nint floatcmp( const void *a, const void *b) {\n    if (*(const float *)a < *(const float *)b) return -1;\n    else return *(const float *)a > *(const float *)b;\n}\n\nfloat median( FloatList fl )\n{\n    qsort( fl->list, fl->size, sizeof(float), floatcmp);\n    return 0.5 * ( fl->list[fl->size/2] + fl->list[(fl->size-1)/2]);\n}\n\nint main()\n{\n    static float floats1[] = { 5.1, 2.6, 6.2, 8.8, 4.6, 4.1 };\n    static struct floatList flist1 = { floats1, sizeof(floats1)/sizeof(float) };\n\n    static float floats2[] = { 5.1, 2.6, 8.8, 4.6, 4.1 };\n    static struct floatList flist2 = { floats2, sizeof(floats2)/sizeof(float) };\n\n    printf(\"flist1 median is %7.2f\\n\", median(&flist1)); /* 4.85 */\n    printf(\"flist2 median is %7.2f\\n\", median(&flist2)); /* 4.60 */\n    return 0;\n}\n\nQuickselect algorithm[edit]\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <time.h>\n \n#define MAX_ELEMENTS 1000000\n \n/* Return the k-th smallest item in array x of length len */\ndouble quick_select(int k, double *x, int len)\n{\n   inline void swap(int a, int b)\n   {\n      double t = x[a];\n      x[a] = x[b], x[b] = t;\n   }\n \n   int left = 0, right = len - 1;\n   int pos, i;\n   double pivot;\n \n   while (left < right)\n   {\n      pivot = x[k];\n      swap(k, right);\n      for (i = pos = left; i < right; i++)\n      {\n         if (x[i] < pivot)\n         {\n            swap(i, pos);\n            pos++;\n         }\n      }\n      swap(right, pos);\n      if (pos == k) break;\n      if (pos < k) left = pos + 1;\n      else right = pos - 1;\n   }\n   return x[k];\n}\n \nint main(void)\n{\n   int i, length;\n   double *x, median;\n \n   /* Initialize random length double array with random doubles */\n   srandom(time(0));\n   length = random() % MAX_ELEMENTS;\n   x = malloc(sizeof(double) * length);\n   for (i = 0; i < length; i++)\n   {\n      // shifted by RAND_MAX for negative values\n      // divide by a random number for floating point\n      x[i] = (double)(random() - RAND_MAX / 2) / (random() + 1); // + 1 to not divide by 0\n   }\n \n\n   if (length % 2 == 0) // Even number of elements, median is average of middle two\n   {\n      median = (quick_select(length / 2, x, length) + quick_select(length / 2 - 1, x, length / 2)) / 2;\n   } \n   else // select middle element\n   {\n      median = quick_select(length / 2, x, length);\n   }\n \n\n   /* Sanity testing of median */\n   int less = 0, more = 0, eq = 0;\n   for (i = 0; i < length; i++)\n   {\n      if (x[i] < median) less ++;\n      else if (x[i] > median) more ++;\n      else eq ++;\n   }\n   printf(\"length: %d\\nmedian: %lf\\n<: %d\\n>: %d\\n=: %d\\n\", length, median, less, more, eq);\n\n   free(x);\n   return 0;\n}\n\n\nlength: 992021\nmedian: 0.000473\n<: 496010\n>: 496010\n=: 1\n\n", "explain": "Average O(n) time:\nOutput:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "C++", "code": "\n\n#include <algorithm>\n\n// inputs must be random-access iterators of doubles\n// Note: this function modifies the input range\ntemplate <typename Iterator>\ndouble median(Iterator begin, Iterator end) {\n  // this is middle for odd-length, and \"upper-middle\" for even length\n  Iterator middle = begin + (end - begin) / 2;\n\n  // This function runs in O(n) on average, according to the standard\n  std::nth_element(begin, middle, end);\n\n  if ((end - begin) % 2 != 0) { // odd length\n    return *middle;\n  } else { // even length\n    // the \"lower middle\" is the max of the lower half\n    Iterator lower_middle = std::max_element(begin, middle);\n    return (*middle + *lower_middle) / 2.0;\n  }\n}\n\n#include <iostream>\n\nint main() {\n  double a[] = {4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2};\n  double b[] = {4.1, 7.2, 1.7, 9.3, 4.4, 3.2};\n\n  std::cout << median(a+0, a + sizeof(a)/sizeof(a[0])) << std::endl; // 4.4\n  std::cout << median(b+0, b + sizeof(b)/sizeof(b[0])) << std::endl; // 4.25\n\n  return 0;\n}\n\nOrder Statistic Tree[edit]\n\nLibrary: gnu_pbds\n#include <bits/stdc++.h>\n#include <ext/pb_ds/assoc_container.hpp>\n#include <ext/pb_ds/tree_policy.hpp>\n\n// the std::less_equal<> comparator allows the tree to support duplicates\ntypedef __gnu_pbds::tree<double, __gnu_pbds::null_type, std::less_equal<double>, __gnu_pbds::rb_tree_tag, __gnu_pbds::tree_order_statistics_node_update> ost_t;\n\n// The lookup method, find_by_order (aka Select), is O(log n) for this data structure, much faster than std::nth_element()\ndouble median(ost_t &OST)\n{\n    int n = OST.size();\n    int m = n/2;\n    if (n == 1)\n        return *OST.find_by_order(0);\n    if (n == 2)\n        return (*OST.find_by_order(0) + *OST.find_by_order(1)) / 2;\n    \n    if (n & 1) // odd number of elements\n        return *OST.find_by_order(m);\n    else // even number of elements\n        return (*OST.find_by_order(m) + *OST.find_by_order(m-1)) / 2;\n}\n\nint main(int argc, char* argv[])\n{\n    ost_t ostree;\n    \n    // insertion is also O(log n) for OSTs\n    ostree.insert(4.1);\n    ostree.insert(7.2);\n    ostree.insert(1.7);\n    ostree.insert(9.3);\n    ostree.insert(4.4);\n    ostree.insert(3.2);\n\n    printf(\"%.3f\\n\", median(ostree)); // 4.250\n\n    return 0;\n}\n\n", "explain": "This function runs in linear time on average.\nUses a GNU C++ policy-based data structure to compute median in O(log n) time.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Java", "code": "\nWorks with: Java version 1.5+\n\ndouble median(List<Double> values) {\n    /* copy, as to prevent modifying 'values' */\n    List<Double> list = new ArrayList<>(values);\n    Collections.sort(list);\n    /* 'mid' will be truncated */\n    int mid = list.size() / 2;\n    return switch (list.size() % 2) {\n        case 0 -> {\n            double valueA = list.get(mid);\n            double valueB = list.get(mid + 1);\n            yield (valueA + valueB) / 2;\n        }\n        case 1 -> list.get(mid);\n        default -> 0;\n    };\n}\n\nWorks with: Java version 1.5+\n\npublic static double median2(List<Double> list) {\n    PriorityQueue<Double> pq = new PriorityQueue<Double>(list);\n    int n = list.size();\n    for (int i = 0; i < (n - 1) / 2; i++)\n        pq.poll(); // discard first half\n    if (n % 2 != 0) // odd length\n        return pq.poll();\n    else\n        return (pq.poll() + pq.poll()) / 2.0;\n}\n\nWorks with: Java version 1.8+\n\n@FunctionalInterface\ninterface MedianFinder<T, R> extends Function<Collection<T>, R> {\n    @Override\n    R apply(Collection<T> data);\n}\n\nclass MedianFinderImpl<T, R> implements MedianFinder<T, R> {\n    private final Supplier<R> ifEmpty;\n    private final Function<T, R> ifOdd;\n    private final Function<List<T>, R> ifEven;\n\n    MedianFinderImpl(Supplier<R> ifEmpty, Function<T, R> ifOdd, Function<List<T>, R> ifEven) {\n        this.ifEmpty = ifEmpty;\n        this.ifOdd = ifOdd;\n        this.ifEven = ifEven;\n    }\n\n    @Override\n    public R apply(Collection<T> data) {\n        return Objects.requireNonNull(data, \"data must not be null\").isEmpty()\n               \u00a0? ifEmpty.get()\n               \u00a0: (data.size() & 1) == 0\n                   \u00a0? ifEven.apply(data.stream().sorted()\n                          .skip(data.size() / 2 - 1)\n                          .limit(2).toList())\n                   \u00a0: ifOdd.apply(data.stream().sorted()\n                          .skip(data.size() / 2)\n                          .limit(1).findFirst().get());\n    }\n}\n\npublic class MedianOf {\n    private static final MedianFinder<Integer, Integer> INTEGERS = new MedianFinderImpl<>(() -> 0, n -> n, pair -> (pair.get(0) + pair.get(1)) / 2);\n    private static final MedianFinder<Integer, Float> INTEGERS_AS_FLOAT = new MedianFinderImpl<>(() -> 0f, n -> n * 1f, pair -> (pair.get(0) + pair.get(1)) / 2f);\n    private static final MedianFinder<Integer, Double> INTEGERS_AS_DOUBLE = new MedianFinderImpl<>(() -> 0d, n -> n * 1d, pair -> (pair.get(0) + pair.get(1)) / 2d);\n    private static final MedianFinder<Float, Float> FLOATS = new MedianFinderImpl<>(() -> 0f, n -> n, pair -> (pair.get(0) + pair.get(1)) / 2);\n    private static final MedianFinder<Double, Double> DOUBLES = new MedianFinderImpl<>(() -> 0d, n -> n, pair -> (pair.get(0) + pair.get(1)) / 2);\n    private static final MedianFinder<BigInteger, BigInteger> BIG_INTEGERS = new MedianFinderImpl<>(() -> BigInteger.ZERO, n -> n, pair -> pair.get(0).add(pair.get(1)).divide(BigInteger.TWO));\n    private static final MedianFinder<BigInteger, BigDecimal> BIG_INTEGERS_AS_BIG_DECIMAL = new MedianFinderImpl<>(() -> BigDecimal.ZERO, BigDecimal::new, pair -> new BigDecimal(pair.get(0).add(pair.get(1))).divide(BigDecimal.valueOf(2), RoundingMode.FLOOR));\n    private static final MedianFinder<BigDecimal, BigDecimal> BIG_DECIMALS = new MedianFinderImpl<>(() -> BigDecimal.ZERO, n -> n, pair -> pair.get(0).add(pair.get(1)).divide(BigDecimal.valueOf(2), RoundingMode.FLOOR));\n\n    public static Integer    integers(Collection<Integer> integerCollection) { return INTEGERS.apply(integerCollection); }\n    public static Float      integersAsFloat(Collection<Integer> integerCollection) { return INTEGERS_AS_FLOAT.apply(integerCollection); }\n    public static Double     integersAsDouble(Collection<Integer> integerCollection) { return INTEGERS_AS_DOUBLE.apply(integerCollection); }\n    public static Float      floats(Collection<Float> floatCollection) { return FLOATS.apply(floatCollection); }\n    public static Double     doubles(Collection<Double> doubleCollection) { return DOUBLES.apply(doubleCollection); }\n    public static BigInteger bigIntegers(Collection<BigInteger> bigIntegerCollection) { return BIG_INTEGERS.apply(bigIntegerCollection); }\n    public static BigDecimal bigIntegersAsBigDecimal(Collection<BigInteger> bigIntegerCollection) { return BIG_INTEGERS_AS_BIG_DECIMAL.apply(bigIntegerCollection); }\n    public static BigDecimal bigDecimals(Collection<BigDecimal> bigDecimalCollection) { return BIG_DECIMALS.apply(bigDecimalCollection); }\n}\n", "explain": "Sorting:\nUsing priority queue (which sorts under the hood):\nThis version operates on objects rather than primitives and uses abstractions to operate on all of the standard numerics.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "C#", "code": "\nusing System;\nusing System.Linq;\n\nnamespace Test\n{\n    class Program\n    {\n        static void Main()\n        {\n            double[] myArr = new double[] { 1, 5, 3, 6, 4, 2 };\n\n            myArr = myArr.OrderBy(i => i).ToArray();\n            // or Array.Sort(myArr) for in-place sort\n\n            int mid = myArr.Length / 2;\n            double median;\n\n            if (myArr.Length % 2 == 0)\n            {\n                //we know its even\n                median = (myArr[mid] + myArr[mid - 1]) / 2.0;\n            }\n            else\n            {\n                //we know its odd\n                median = myArr[mid];\n            }\n\n            Console.WriteLine(median);\n            Console.ReadLine();\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nES5[edit]\nfunction median(ary) {\n    if (ary.length == 0)\n        return null;\n    ary.sort(function (a,b){return a - b})\n    var mid = Math.floor(ary.length / 2);\n    if ((ary.length % 2) == 1)  // length is odd\n        return ary[mid];\n    else \n        return (ary[mid - 1] + ary[mid]) / 2;\n}\n\nmedian([]);   // null\nmedian([5,3,4]);  // 4\nmedian([5,4,2,3]);  // 3.5\nmedian([3,4,1,-8.4,7.2,4,1,1.2]);  // 2.1\n\nES6[edit]\n\nTranslation of: Haskell\n(() => {\n    'use strict';\n\n    // median\u00a0:: [Num] -> Num\n    function median(xs) {\n        // nth\u00a0:: [Num] -> Int -> Maybe Num\n        let nth = (xxs, n) => {\n                if (xxs.length > 0) {\n                    let [x, xs] = uncons(xxs), \n                        [ys, zs] = partition(y => y < x, xs),\n                        k = ys.length;\n\n                    return k === n ? x : (\n                        k > n ? nth(ys, n) : nth(zs, n - k - 1)\n                    );\n                } else return undefined;\n            },\n            n = xs.length;\n\n        return even(n) ? (\n            (nth(xs, div(n, 2)) + nth(xs, div(n, 2) - 1)) / 2\n        ) : nth(xs, div(n, 2));\n    }\n\n\n\n    // GENERIC\n\n    // partition\u00a0:: (a -> Bool) -> [a] -> ([a], [a])\n    let partition = (p, xs) =>\n        xs.reduce((a, x) =>\n            p(x) ? [a[0].concat(x), a[1]] : [a[0], a[1].concat(x)], [\n                [],\n                []\n            ]),\n\n        // uncons\u00a0:: [a] -> Maybe (a, [a])\n        uncons = xs => xs.length ? [xs[0], xs.slice(1)] : undefined,\n\n        // even\u00a0:: Integral a => a -> Bool\n        even = n => n % 2 === 0,\n\n        // div\u00a0:: Num -> Num -> Int\n        div = (x, y) => Math.floor(x / y);\n\n    return [\n        [],\n        [5, 3, 4],\n        [5, 4, 2, 3],\n        [3, 4, 1, -8.4, 7.2, 4, 1, 1.2]\n    ].map(median);\n})();\n\n\nOutput:\n[\n  null,\n  4,\n  3.5,\n  2.1\n]\n\n", "explain": "Using a quick select algorithm\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "PHP", "code": "\n\nfunction median($arr)\n{\n    sort($arr);\n    $count = count($arr); //count the number of values in array\n    $middleval = floor(($count-1)/2); // find the middle value, or the lowest middle value\n    if ($count % 2) { // odd number, middle is the median\n        $median = $arr[$middleval];\n    } else { // even number, calculate avg of 2 medians\n        $low = $arr[$middleval];\n        $high = $arr[$middleval+1];\n        $median = (($low+$high)/2);\n    }\n    return $median;\n}\n\necho median(array(4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";  // 4.4\necho median(array(4.1, 7.2, 1.7, 9.3, 4.4, 3.2)) . \"\\n\";       // 4.25\n\n", "explain": "This solution uses the sorting method of finding the median.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "MATLAB", "code": "\n\nfunction medianValue = findmedian(setOfValues)    \n   medianValue = median(setOfValues);\nend\n\n", "explain": "If the input has an even number of elements, function returns the mean of the middle two values:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nprogram Median_Test\n\n  real            :: a(7) = (/ 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2 /), &\n                     b(6) = (/ 4.1, 7.2, 1.7, 9.3, 4.4, 3.2 /)\n\n  print *, median(a)\n  print *, median(b)\n\ncontains\n\n  function median(a, found)\n    real, dimension(:), intent(in) :: a\n      ! the optional found argument can be used to check\n      ! if the function returned a valid value; we need this\n      ! just if we suspect our \"vector\" can be \"empty\"\n    logical, optional, intent(out) :: found\n    real :: median\n\n    integer :: l\n    real, dimension(size(a,1)) :: ac\n\n    if ( size(a,1) < 1 ) then\n       if ( present(found) ) found = .false.\n    else\n       ac = a\n       ! this is not an intrinsic: peek a sort algo from\n       ! Category:Sorting, fixing it to work with real if\n       ! it uses integer instead.\n       call sort(ac)\n\n       l = size(a,1)\n       if ( mod(l, 2) == 0 ) then\n          median = (ac(l/2+1) + ac(l/2))/2.0\n       else\n          median = ac(l/2+1)\n       end if\n\n       if ( present(found) ) found = .true.\n    end if\n\n  end function median\n\nend program Median_Test\n\nIf one refers to Quickselect_algorithm#Fortran which offers function FINDELEMENT(K,A,N) that returns the value of A(K) when the array of N elements has been rearranged if necessary so that A(K) is the K'th in order, then, supposing that a version is devised using the appropriate type for array A,       K = N/2\n      MEDIAN = FINDELEMENT(K + 1,A,N)\n      IF (MOD(N,2).EQ.0) MEDIAN = (FINDELEMENT(K,A,N) + MEDIAN)/2\n\n\n", "explain": "As well as returning a result, the function possibly re-arranges the elements of the array, which is not \"pure\" behaviour. Not to the degree of fully sorting them, merely that all elements before K are not larger than A(K) as it now is, and all elements after K are not smaller than A(K).\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Go", "code": "\nSort[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\nfunc main() {\n    fmt.Println(median([]float64{3, 1, 4, 1}))    // prints 2\n    fmt.Println(median([]float64{3, 1, 4, 1, 5})) // prints 3\n}\n\nfunc median(a []float64) float64 {\n    sort.Float64s(a)\n    half := len(a) / 2\n    m := a[half]\n    if len(a)%2 == 0 {\n        m = (m + a[half-1]) / 2\n    }\n    return m\n}\n\nPartial selection sort[edit]\n\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    fmt.Println(median([]float64{3, 1, 4, 1}))    // prints 2\n    fmt.Println(median([]float64{3, 1, 4, 1, 5})) // prints 3\n}\n\nfunc median(a []float64) float64 {\n    half := len(a) / 2\n    med := sel(a, half)\n    if len(a)%2 == 0 {\n        return (med + a[half-1]) / 2\n    }\n    return med\n}\n\nfunc sel(list []float64, k int) float64 {\n    for i, minValue := range list[:k+1] {\n        minIndex := i\n        for j := i + 1; j < len(list); j++ {\n            if list[j] < minValue {\n                minIndex = j\n                minValue = list[j]\n                list[i], list[minIndex] = minValue, list[i]\n            }\n        }\n    }\n    return list[k]\n}\n\nQuickselect[edit]\n\npackage main\n\nimport (\n    \"fmt\"\n    \"math/rand\"\n)\n\nfunc main() {\n    fmt.Println(median([]float64{3, 1, 4, 1}))    // prints 2\n    fmt.Println(median([]float64{3, 1, 4, 1, 5})) // prints 3\n}\n\nfunc median(list []float64) float64 {\n    half := len(list) / 2\n    med := qsel(list, half)\n    if len(list)%2 == 0 {\n        return (med + qsel(list, half-1)) / 2\n    }\n    return med\n}\n\nfunc qsel(a []float64, k int) float64 {\n    for len(a) > 1 {\n        px := rand.Intn(len(a))\n        pv := a[px]\n        last := len(a) - 1\n        a[px], a[last] = a[last], pv\n        px = 0\n        for i, v := range a[:last] {\n            if v < pv {\n                a[px], a[i] = v, a[px]\n                px++\n            }\n        }\n        if px == k {\n            return pv\n        }\n        if k < px {\n            a = a[:px]\n        } else {\n            // swap elements.  simply assigning a[last] would be enough to\n            // allow qsel to return the correct result but it would leave slice\n            // \"a\" unusable for subsequent use.  we want this full swap so that\n            // we can make two successive qsel calls in the case of median\n            // of an even number of elements.\n            a[px], a[last] = pv, a[px]\n            a = a[px+1:]\n            k -= px + 1\n        }\n    }\n    return a[0]\n}\n\n", "explain": "Go built-in sort.  O(n log n).\nThe task description references the WP entry for \"selection algorithm\" which (as of this writing) gives just one pseudocode example, which is implemented here.  As the WP article notes, it is O(kn).  \nUnfortunately in the case of median, k is n/2 so the algorithm is O(n^2).  Still, it gives the idea of median by selection.  Note that the partial selection sort does leave the k smallest values sorted, so in the case of an even number of elements, the two elements to average are available after a single call to sel().\nIt doesn't take too much more code to implement a quickselect with random pivoting, which should run in expected time O(n).  The qsel function here permutes elements of its parameter \"a\" in place.  It leaves the slice somewhat more ordered, but unlike the sort and partial sort examples above, does not guarantee that element k-1 is in place.  For the case of an even number of elements then, median must make two separate qsel() calls.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program averageMed.s   */\n/* use quickselect look pseudo code in wikipedia  quickselect */\n\n/************************************/\n/* Constantes                       */\n/************************************/\n/* for constantes see task include a file in arm assembly */\n.include \"../constantes.inc\"\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResultValue:        .asciz \"Result \u00a0: \"\nszCarriageReturn:         .asciz \"\\n\"\n     \n.align 4\nTableNumber:              .float 4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2\n.equ NBELEMENTS,      (. - TableNumber) / 4\nTableNumber2:\t          .float 4.1, 7.2, 1.7, 9.3, 4.4, 3.2\n.equ NBELEMENTS2,      (. - TableNumber2) / 4\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:             .skip 24\nsZoneConv1:            .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                    @ entry of program \n\n    ldr r0,iAdrTableNumber               @ address number table\n    mov r1,#0                            @ index first item\n    mov r2,#NBELEMENTS -1                @ index last item \n    bl searchMedian\n    ldr r0,iAdrTableNumber2               @ address number table 2\n    mov r1,#0                             @ index first item\n    mov r2,#NBELEMENTS2 -1                @ index last item \n    bl searchMedian\n\n100:                                     @ standard end of the program \n    mov r0, #0                           @ return code\n    mov r7, #EXIT                        @ request to exit program\n    svc #0                               @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrTableNumber:          .int TableNumber\niAdrTableNumber2:         .int TableNumber2\niAdrsZoneConv:            .int sZoneConv\niAdrszMessResultValue:    .int szMessResultValue\n/***************************************************/\n/*   search median term in float array                       */\n/***************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains index of last item   */\nsearchMedian:\n    push {r1-r5,lr}                @ save registers\n    mov r5,r0                      @ save array address\n    add r4,r1,r2\n    add r4,r4,#1                   @ sum numbers terms\n    tst r4,#1                      @ odd\u00a0?\n    bne 1f\n    lsr r3,r4,#1                   @ compute median index\n    bl select                      @ call selection\n    vmov s0,r0                     @ save first result\n    sub r3,r3,#1                   @ second term\n    mov r0,r5\n    bl select                      @ call selection\n    vmov s1,r0                     @ save 2ieme r\u00e9sult\n    vadd.f32 s0,s1                 @ compute average two r\u00e9sults\n    mov r0,#2\n    vmov s1,r0\n    vcvt.f32.u32 s1,s1             @ conversion integer -> float\n    vdiv.f32 s0,s0,s1\n    b 2f\n1:                                 @ even\n    lsr r3,r4,#1\n    bl select                      @ call selection\n    vmov s0,r0\n2:\n    ldr r0,iAdrsZoneConv           @ conversion float in decimal string \n    bl convertirFloat\n    mov r0,#3                      @ and display result\n    ldr r1,iAdrszMessResultValue\n    ldr r2,iAdrsZoneConv\n    ldr r3,iAdrszCarriageReturn\n    bl displayStrings  \n100:                               @ end function\n    pop {r1-r5,pc}                 @ restaur  register\n/***************************************************/\n/*   Appel r\u00e9cursif selection                      */\n/***************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains index of last item   */\n/* r3 contains search index */\n/* r0 return final value in float */\n/* remark\u00a0: the final result is a float returned in r0 register */\nselect:\n    push {r1-r6,lr}                @ save registers\n    mov r6,r3                      @ save search index\n    cmp r1,r2                      @ first = last\u00a0? \n    ldreq r0,[r0,r1,lsl #2]        @ return value of first index\n    beq 100f                       @ yes -> end\n    add r3,r1,r2\n    lsr r3,r3,#1                   @ compute median pivot \n    mov r4,r0                      @ save r0\n    mov r5,r2                      @ save r2\n    bl partition                   @ cutting into 2 parts\n    cmp r6,r0                      @ pivot is ok\u00a0?\n    ldreq r0,[r4,r0,lsl #2]        @ return value\n    beq 100f\n    bgt 1f\n    sub r2,r0,#1                   @ index partition  - 1 \n    mov r0,r4                      @ array address\n    mov r3,r6                      @ search index\n    bl select                      @ select lower part\n    b 100f\n1:\n    add r1,r0,#1                   @ index begin = index partition + 1\n    mov r0,r4                      @ array address\n    mov r2,r5                      @ last item\n    mov r3,r6                      @ search index\n    bl select                      @ select higter part\n 100:                              @ end function\n    pop {r1-r6,pc}                 @ restaur  register\n/******************************************************************/\n/*      Partition table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains index of first item  */\n/* r2 contains index of last item   */\n/* r3 contains index of pivot */\npartition:\n    push {r1-r6,lr}                                    @ save registers\n    ldr r4,[r0,r3,lsl #2]                              @ load value of pivot\n    ldr r5,[r0,r2,lsl #2]                              @ load value last index\n    str r5,[r0,r3,lsl #2]                              @ swap value of pivot\n    str r4,[r0,r2,lsl #2]                              @ and value last index\n    mov r3,r1                                          @ init with first index\n1:                                                     @ begin loop\n    ldr r6,[r0,r3,lsl #2]                              @ load value\n    cmp r6,r4                                          @ compare loop value and pivot value\n    ldrlt r5,[r0,r1,lsl #2]                            @ if < swap value table\n    strlt r6,[r0,r1,lsl #2]\n    strlt r5,[r0,r3,lsl #2]\n    addlt r1,#1                                        @ and increment index 1\n    add r3,#1                                          @ increment index 2\n    cmp r3,r2                                          @ end\u00a0?\n    blt 1b                                             @ no loop\n    ldr r5,[r0,r1,lsl #2]                              @ swap value\n    str r4,[r0,r1,lsl #2]\n    str r5,[r0,r2,lsl #2]\n    mov r0,r1                                          @ return index partition\n100:\n    pop {r1-r6,pc}\n    \n/***************************************************/\n/*   display multi strings                    */\n/***************************************************/\n/* r0  contains number strings address */\n/* r1 address string1 */\n/* r2 address string2 */\n/* r3 address string3 */\n/* other address on the stack */\n/* thinck to add  number other address * 4 to add to the stack */\ndisplayStrings:            @ INFO:  displayStrings\n    push {r1-r4,fp,lr}     @ save des registres\n    add fp,sp,#24          @ save param\u00e9ters address (6 registers saved * 4 bytes)\n    mov r4,r0              @ save strings number\n    cmp r4,#0              @ 0 string -> end\n    ble 100f\n    mov r0,r1              @ string 1\n    bl affichageMess\n    cmp r4,#1              @ number > 1\n    ble 100f\n    mov r0,r2\n    bl affichageMess\n    cmp r4,#2\n    ble 100f\n    mov r0,r3\n    bl affichageMess\n    cmp r4,#3\n    ble 100f\n    mov r3,#3\n    sub r2,r4,#4\n1:                         @ loop extract address string on stack\n    ldr r0,[fp,r2,lsl #2]\n    bl affichageMess\n    subs r2,#1\n    bge 1b\n100:\n    pop {r1-r4,fp,pc}\n/******************************************************************/\n/*     Conversion Float                                            */ \n/******************************************************************/\n/* s0  contains Float */\n/* r0 contains address conversion area  mini 20 charact\u00e8rs*/\n/* r0 return result length */\n/* see https://blog.benoitblanchon.fr/lightweight-float-to-string/ */\nconvertirFloat:\n    push {r1-r7,lr}\n    vpush {s0-s2}\n    mov r6,r0                 @ save area address\n    vmov r0,s0\n    mov r1,#0\n    vmov s1,r1\n    movs r7,#0                @ result length\n    movs r3,#'+'\n    strb r3,[r6]              @ sign + forcing\n    mov r2,r0\n    lsls r2,#1                @ extraction bit 31\n    bcc 1f                    @ positive\u00a0?\n    lsrs r0,r2,#1             @ raz sign if negative\n    movs r3,#'-'              @ sign -\n    strb r3,[r6]\n1:\n    adds r7,#1                @ next position\n    cmp r0,#0                 @ case of positive or negative 0\n    bne 2f\n    movs r3,#'0'\n    strb r3,[r6,r7]           @ store character 0\n    adds r7,#1                @ next position\n    movs r3,#0\n    strb r3,[r6,r7]           @ store  0 final\n    mov r0,r7                 @ return length\n    b 100f                    @ and end\n2: \n    ldr r2,iMaskExposant\n    mov r1,r0\n    ands r1,r2                @ exposant = 255\u00a0?\n    cmp r1,r2\n    bne 4f\n    lsls r0,#10               @ bit 22 \u00e0 0\u00a0?\n    bcc 3f                    @ yes\n    movs r2,#'N'              @ case of Nan. store byte, if not possible store int \n    strb r2,[r6]              @ area no aligned\n    movs r2,#'a'\n    strb r2,[r6,#1] \n    movs r2,#'n'\n    strb r2,[r6,#2] \n    movs r2,#0                @ 0 final\n    strb r2,[r6,#3] \n    movs r0,#3                @ return length 3\n    b 100f\n3:                            @ case infini positive or n\u00e9gative\n    movs r2,#'I'\n    strb r2,[r6,r7] \n    adds r7,#1\n    movs r2,#'n'\n    strb r2,[r6,r7] \n    adds r7,#1\n    movs r2,#'f'\n    strb r2,[r6,r7] \n    adds r7,#1\n    movs r2,#0\n    strb r2,[r6,r7]\n    mov r0,r7\n    b 100f\n4:\n    bl normaliserFloat\n    mov r5,r0                @ save exposant\n    VCVT.U32.f32  s2,s0      @ integer value of  integer part\n    vmov r0,s2               @ integer part\n    VCVT.F32.U32  s1,s2      @ conversion float\n    vsub.f32 s1,s0,s1        @ extraction fract part\n    vldr s2,iConst1\n    vmul.f32 s1,s2,s1        @ to crop it in full\n\n    VCVT.U32.f32  s1,s1      @ integer conversion\n    vmov r4,s1               @ fract value\n                             @ integer conversion in  r0\n    mov r2,r6                @ save address area begin \n    adds r6,r7\n    mov r1,r6\n    bl conversion10\n    add r6,r0\n    movs r3,#','\n    strb r3,[r6]\n    adds r6,#1\n \n    mov r0,r4                @ conversion fractional part\n    mov r1,r6\n    bl conversion10SP        @ sp\u00e9cial routine with conservation begin 0 \n    add r6,r0\n    subs r6,#1\n                             @ remove trailing zeros\n5:\n    ldrb r0,[r6]\n    cmp r0,#'0'\n    bne 6f\n    subs r6,#1\n    b 5b\n6:\n    cmp r0,#','\n    bne 7f\n    subs r6,#1\n7:\n    adds r6,#1\n    movs r3,#'E'\n    strb r3,[r6]\n    adds r6,#1\n    mov r0,r5                  @ conversion exposant\n    mov r3,r0\n    lsls r3,#1\n    bcc 4f\n    rsbs r0,r0,#0\n    movs r3,#'-'\n    strb r3,[r6]\n    adds r6,#1\n4:\n    mov r1,r6\n    bl conversion10\n    add r6,r0\n    \n    movs r3,#0\n    strb r3,[r6]\n    adds r6,#1\n    mov r0,r6\n    subs r0,r2                 @ return length result\n    subs r0,#1                 @ - 0 final\n\n100:\n    vpop {s0-s2}\n    pop {r1-r7,pc}\niMaskExposant:            .int 0xFF<<23\niConst1:                  .float 0f1E9\n\n/***************************************************/\n/*   normaliser float                              */\n/***************************************************/\n/* r0 contain float value (always positive value and <> Nan) */\n/* s0 return new value  */\n/* r0 return exposant */\nnormaliserFloat:\n    push {lr}               @ save  registre\n    vmov s0,r0              @ value float\n    movs r0,#0              @ exposant\n    vldr s1,iConstE7        @ no normalisation for value < 1E7\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 10f                 @ if s0  < iConstE7\n    \n    vldr s1,iConstE32\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 1f\n    vldr s1,iConstE32\n    vdiv.f32 s0,s0,s1\n    adds r0,#32\n1:\n    vldr s1,iConstE16\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 2f\n    vldr s1,iConstE16\n    vdiv.f32 s0,s0,s1\n    adds r0,#16\n2:\n    vldr s1,iConstE8\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 3f\n    vldr s1,iConstE8\n    vdiv.f32 s0,s0,s1\n    adds r0,#8\n3:\n    vldr s1,iConstE4\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 4f\n    vldr s1,iConstE4\n    vdiv.f32 s0,s0,s1\n    adds r0,#4\n4:\n    vldr s1,iConstE2\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 5f\n    vldr s1,iConstE2\n    vdiv.f32 s0,s0,s1\n    adds r0,#2\n5:\n    vldr s1,iConstE1\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    blo 10f\n    vldr s1,iConstE1\n    vdiv.f32 s0,s0,s1\n    adds r0,#1\n\n10:\n    vldr s1,iConstME5        @ pas de normalisation pour les valeurs > 1E-5\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 100f\n    vldr s1,iConstME31\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 11f\n    vldr s1,iConstE32\n\n    vmul.f32 s0,s0,s1\n    subs r0,#32\n11:\n    vldr s1,iConstME15\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 12f\n    vldr s1,iConstE16\n    vmul.f32 s0,s0,s1\n    subs r0,#16\n12:\n    vldr s1,iConstME7\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 13f\n    vldr s1,iConstE8\n    vmul.f32 s0,s0,s1\n    subs r0,#8\n13:\n    vldr s1,iConstME3\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 14f\n    vldr s1,iConstE4\n    vmul.f32 s0,s0,s1\n    subs r0,#4\n14:\n    vldr s1,iConstME1\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 15f\n    vldr s1,iConstE2\n    vmul.f32 s0,s0,s1\n    subs r0,#2\n15:\n    vldr s1,iConstE0\n    vcmp.f32 s0,s1\n    vmrs APSR_nzcv,FPSCR\n    bhi 100f\n    vldr s1,iConstE1\n    vmul.f32 s0,s0,s1\n    subs r0,#1\n\n100:                       @ fin standard de la fonction\n    pop {pc}               @ restaur des registres\n.align 2\niConstE7:             .float 0f1E7\niConstE32:            .float 0f1E32\niConstE16:            .float 0f1E16\niConstE8:             .float 0f1E8\niConstE4:             .float 0f1E4\niConstE2:             .float 0f1E2\niConstE1:             .float 0f1E1\niConstME5:            .float 0f1E-5\niConstME31:           .float 0f1E-31\niConstME15:           .float 0f1E-15\niConstME7:            .float 0f1E-7\niConstME3:            .float 0f1E-3\niConstME1:            .float 0f1E-1\niConstE0:             .float 0f1E0    \n/******************************************************************/\n/*     D\u00e9cimal Conversion                                         */ \n/******************************************************************/\n/* r0 contain value et r1 address conversion area   */\nconversion10SP:\n    push {r1-r6,lr}            @ save  registers\n    mov r5,r1\n    mov r4,#8\n    mov r2,r0\n    mov r1,#10                 @ conversion decimale\n1:                             @ begin loop\n    mov r0,r2                  @ copy number or quotients\n    bl division                @ r0 dividende r1 divisor r2 quotient r3 remainder\n    add r3,#48                 @ compute digit  \n    strb r3,[r5,r4]            @ store byte area address (r5) + offset (r4)\n    subs r4,r4,#1              @ position pr\u00e9cedente\n    bge 1b                     @ and loop if not < zero\n    mov r0,#8\n    mov r3,#0\n    strb r3,[r5,r0]            @ store 0 final\n100:    \n    pop {r1-r6,pc}             @ restaur registers   \n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n/* for this file see task include a file in language ARM assembly */\n.include \"../affichage.inc\"\n\nOutput:\nResult \u00a0: +4,40000009E0\nResult \u00a0: +4,25E0\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Delphi", "code": "\nprogram AveragesMedian;\n\n{$APPTYPE CONSOLE}\n\nuses Generics.Collections, Types;\n\nfunction Median(aArray: TDoubleDynArray): Double;\nvar\n  lMiddleIndex: Integer;\nbegin\n  TArray.Sort<Double>(aArray);\n\n  lMiddleIndex := Length(aArray) div 2;\n  if Odd(Length(aArray)) then\n    Result := aArray[lMiddleIndex]\n  else\n    Result := (aArray[lMiddleIndex - 1] + aArray[lMiddleIndex]) / 2;\nend;\n\nbegin\n  Writeln(Median(TDoubleDynArray.Create(4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)));\n  Writeln(Median(TDoubleDynArray.Create(4.1, 7.2, 1.7, 9.3, 4.4, 3.2)));\nend.\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Ruby", "code": "\ndef median(ary)\n  return nil if ary.empty?\n  mid, rem = ary.length.divmod(2)\n  if rem == 0\n    ary.sort[mid-1,2].inject(:+) / 2.0\n  else\n    ary.sort[mid]\n  end\nend\n\np median([])                        # => nil\np median([5,3,4])                   # => 4\np median([5,4,2,3])                 # => 3.5\np median([3,4,1,-8.4,7.2,4,1,1.2])  # => 2.1\n\n\ndef median(aray)\n    srtd = aray.sort\n    alen = srtd.length\n    (srtd[(alen-1)/2] + srtd[alen/2]) / 2.0\nend\n\n", "explain": "Alternately:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Rust", "code": "\n\nfn median(mut xs: Vec<f64>) -> f64 {\n    // sort in ascending order, panic on f64::NaN\n    xs.sort_by(|x,y| x.partial_cmp(y).unwrap() );\n    let n = xs.len();\n    if n\u00a0% 2 == 0 {\n        (xs[n/2] + xs[n/2 - 1]) / 2.0\n    } else {\n        xs[n/2]\n    }\n}\n\nfn main() {\n    let nums = vec![2.,3.,5.,0.,9.,82.,353.,32.,12.];\n    println!(\"{:?}\", median(nums))\n}\n\nOutput:\n9\n", "explain": "Sorting, then obtaining the median element:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "R", "code": "\n\nTranslation of: Octave\nomedian <- function(v) {\n  if ( length(v) < 1 )\n    NA\n  else {\n    sv <- sort(v)\n    l <- length(sv)\n    if ( l %% 2 == 0 )\n      (sv[floor(l/2)+1] + sv[floor(l/2)])/2\n    else\n      sv[floor(l/2)+1]\n  }\n}\n\na <- c(4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2)\nb <- c(4.1, 7.2, 1.7, 9.3, 4.4, 3.2)\n\nprint(median(a))   # 4.4\nprint(omedian(a))\nprint(median(b))   # 4.25\nprint(omedian(b))\n\n", "explain": "R has its built-in median function.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "COBOL", "code": "\n\nFUNCTION MEDIAN(some-table (ALL))\n\n", "explain": "Intrinsic function:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Ada", "code": "\nwith Ada.Text_IO, Ada.Float_Text_IO;\n\nprocedure FindMedian is\n\n    f: array(1..10) of float := ( 4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5 );\n    min_idx: integer;\n    min_val, median_val, swap: float;\n\nbegin\n    for i in f'range loop\n        min_idx := i;\n        min_val := f(i);\n        for j in i+1 .. f'last loop\n            if f(j) < min_val then\n                min_idx := j;\n                min_val := f(j);\n            end if;                \n        end loop;\n        swap := f(i); f(i) := f(min_idx); f(min_idx) := swap;\n    end loop;      \n\n    if f'length mod 2 /= 0 then\n        median_val := f( f'length/2+1 );\n    else\n        median_val := ( f(f'length/2) + f(f'length/2+1) ) / 2.0;\n    end if;\n    \n    Ada.Text_IO.Put( \"Median value: \" );\n    Ada.Float_Text_IO.Put( median_val );\n    Ada.Text_IO.New_line;    \nend FindMedian;\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Julia", "code": "\n\nusing Statistics\nfunction median2(n)\n\ts = sort(n)\n\tlen = length(n)\n\tif len % 2 == 0\n\t\treturn (s[floor(Int, len / 2) + 1] + s[floor(Int, len / 2)]) / 2\n\telse\n\t\treturn  s[floor(Int, len / 2) + 1]\n\tend\nend\n\na = [4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2]\nb = [4.1, 7.2, 1.7, 9.3, 4.4, 3.2]\n\n@show a b median2(a) median(a) median2(b) median(b)\n\n\nOutput:\na = [4.1,5.6,7.2,1.7,9.3,4.4,3.2]\nb = [4.1,7.2,1.7,9.3,4.4,3.2]\nmedian2(a) = 4.4\nmedian(a) = 4.4\nmedian2(b) = 4.25\nmedian(b) = 4.25\n\n", "explain": "Julia has a built-in median() function\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Kotlin", "code": "\nWorks with: Kotlin version 1.0+\nfun median(l: List<Double>) = l.sorted().let { (it[it.size / 2] + it[(it.size - 1) / 2]) / 2 }\n\nfun main(args: Array<String>) {\n    median(listOf(5.0, 3.0, 4.0)).let { println(it) }  // 4\n    median(listOf(5.0, 4.0, 2.0, 3.0)).let { println(it) }  // 3.5\n    median(listOf(3.0, 4.0, 1.0, -8.4, 7.2, 4.0, 1.0, 1.2)).let { println(it) }  // 2.1\n}\n\n\n", "explain": "\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Perl", "code": "\nTranslation of: Python\nsub median {\n  my @a = sort {$a <=> $b} @_;\n  return ($a[$#a/2] + $a[@a/2]) / 2;\n}\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Prolog", "code": "\nmedian(L, Z) :-\n    length(L, Length),\n    I is Length div 2,\n    Rem is Length rem 2,\n    msort(L, S),\n    maplist(sumlist, [[I, Rem], [I, 1]], Mid),\n    maplist(nth1, Mid, [S, S], X),\n    sumlist(X, Y),\n    Z is Y/2.\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Lua", "code": "\nfunction median (numlist)\n    if type(numlist) ~= 'table' then return numlist end\n    table.sort(numlist)\n    if #numlist %2 == 0 then return (numlist[#numlist/2] + numlist[#numlist/2+1]) / 2 end\n    return numlist[math.ceil(#numlist/2)]\nend\n\nprint(median({4.1, 5.6, 7.2, 1.7, 9.3, 4.4, 3.2}))\nprint(median({4.1, 7.2, 1.7, 9.3, 4.4, 3.2}))\n\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Scala", "code": "\nWorks with: Scala version 2.8 (See the Scala discussion on Mean for more information.)\ndef median[T](s: Seq[T])(implicit n: Fractional[T]) = {\n  import n._\n  val (lower, upper) = s.sortWith(_<_).splitAt(s.size / 2)\n  if (s.size\u00a0% 2 == 0) (lower.last + upper.head) / fromInt(2) else upper.head\n}\n\n", "explain": "This isn't really optimal. The methods splitAt and last are O(n/2) \non many sequences, and then there's the lower bound imposed by the sort. Finally,\nwe call size two times, and it can be O(n).\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "D", "code": "\nimport std.stdio, std.algorithm;\n\nT median(T)(T[] nums) pure nothrow {\n    nums.sort();\n    if (nums.length & 1)\n        return nums[$ / 2];\n    else\n        return (nums[$ / 2 - 1] + nums[$ / 2]) / 2.0;\n}\n\nvoid main() {\n    auto a1 = [5.1, 2.6, 6.2, 8.8, 4.6, 4.1];\n    writeln(\"Even median: \", a1.median);\n\n    auto a2 = [5.1, 2.6, 8.8, 4.6, 4.1];\n    writeln(\"Odd median:  \", a2.median);\n}\n\n\nOutput:\nEven median: 4.85\nOdd median:  4.6\n", "explain": ""}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Haskell", "code": "\n\nimport Data.List (partition)\n\nnth :: Ord t => [t] -> Int -> t\nnth (x:xs) n\n  | k == n = x\n  | k > n = nth ys n\n  | otherwise = nth zs $ n - k - 1\n  where\n    (ys, zs) = partition (< x) xs\n    k = length ys\n\nmedianMay :: (Fractional a, Ord a) => [a] -> Maybe a\nmedianMay xs\n  | n < 1 = Nothing\n  | even n = Just ((nth xs (div n 2) + nth xs (div n 2 - 1)) / 2.0)\n  | otherwise = Just (nth xs (div n 2))\n  where\n    n = length xs\n\nmain :: IO ()\nmain =\n  mapM_\n    (printMay . medianMay)\n    [[], [7], [5, 3, 4], [5, 4, 2, 3], [3, 4, 1, -8.4, 7.2, 4, 1, 1.2]]\n  where\n    printMay = maybe (putStrLn \"(not defined)\") print\n\n\nOutput:\n(not defined)\n7.0\n4.0\n3.5\n2.1\nOr Library: hstats\n> Math.Statistics.median [1,9,2,4]\n3.0\n\n", "explain": "This uses a quick select algorithm and runs in expected O(n) time.\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Scheme", "code": "\nTranslation of: Python\n\n(define (median l)\n  (* (+ (list-ref (bubble-sort l >) (round (/ (- (length l) 1) 2)))\n        (list-ref (bubble-sort l >) (round (/ (length l) 2)))) 0.5))\n\n(define (median l)\n  (* (+ (list-ref (sort l less?) (round (/ (- (length l) 1) 2)))\n        (list-ref (sort l less?) (round (/ (length l) 2)))) 0.5))\n", "explain": "Using Rosetta Code's bubble-sort function\nUsing SRFI-95:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "PowerShell", "code": "\n\nfunction Measure-Data\n{\n    [CmdletBinding()]\n    [OutputType([PSCustomObject])]\n    Param\n    (\n        [Parameter(Mandatory=$true,\n                   Position=0)]\n        [double[]]\n        $Data\n    )\n\n    Begin\n    {\n        function Get-Mode ([double[]]$Data)\n        {\n            if ($Data.Count -gt ($Data | Select-Object -Unique).Count)\n            {\n                $groups = $Data | Group-Object | Sort-Object -Property Count -Descending\n\n                return ($groups | Where-Object {[double]$_.Count -eq [double]$groups[0].Count}).Name | ForEach-Object {[double]$_}\n            }\n            else\n            {\n                return $null\n            }\n        }\n\n        function Get-StandardDeviation ([double[]]$Data)\n        {\n            $variance = 0            \n            $average  = $Data | Measure-Object -Average | Select-Object -Property Count, Average\n\n            foreach ($number in $Data)\n            {            \n                $variance +=  [Math]::Pow(($number - $average.Average),2)\n            }\n\n            return [Math]::Sqrt($variance / ($average.Count-1))\n        }\n\n        function Get-Median ([double[]]$Data)\n        {\n            if ($Data.Count % 2)\n            {\n                return $Data[[Math]::Floor($Data.Count/2)]\n            }\n            else\n            {\n                return ($Data[$Data.Count/2], $Data[$Data.Count/2-1] | Measure-Object -Average).Average\n            }\n        }\n    }\n    Process\n    {\n        $Data = $Data | Sort-Object\n\n        $Data | Measure-Object -Maximum -Minimum -Sum -Average |\n                Select-Object -Property Count,\n                                        Sum,\n                                        Minimum,\n                                        Maximum,\n                                        @{Name='Range'; Expression={$_.Maximum - $_.Minimum}},\n                                        @{Name='Mean' ; Expression={$_.Average}} |\n                Add-Member -MemberType NoteProperty -Name Median            -Value (Get-Median $Data)            -PassThru |\n                Add-Member -MemberType NoteProperty -Name StandardDeviation -Value (Get-StandardDeviation $Data) -PassThru |\n                Add-Member -MemberType NoteProperty -Name Mode              -Value (Get-Mode $Data)              -PassThru\n    }\n}\n\n$statistics = Measure-Data 4, 5, 6, 7, 7, 7, 8, 1, 1, 1, 2, 3\n$statistics\n\n\nOutput:\nCount            \u00a0: 12\nSum              \u00a0: 52\nMinimum          \u00a0: 1\nMaximum          \u00a0: 8\nRange            \u00a0: 7\nMean             \u00a0: 4.33333333333333\nMedian           \u00a0: 4.5\nStandardDeviation\u00a0: 2.67423169368609\nMode             \u00a0: {1, 7}\n\n\n$statistics.Median\n\n\nOutput:\n4.5\n\n", "explain": "This function returns an object containing the minimal amount of statistical data, including Median, and could be modified to take input directly from the pipeline.\nAll statistical properties could easily be added to the output object.\nMedian only:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "F#", "code": "\n\nlet rec splitToFives list = \n    match list with\n        | a::b::c::d::e::tail ->\n            ([a;b;c;d;e])::(splitToFives tail)\n        | [] -> []\n        | _ -> \n                let left = 5 - List.length (list)\n                let last = List.append list (List.init left (fun _ -> System.Double.PositiveInfinity) )\n                in [last]\n\nlet medianFromFives =\n    List.map ( fun (i:float list) ->\n        List.nth (List.sort i) 2 ) \n\nlet start l = \n    let rec magicFives list k =\n        if List.length(list) <= 10 then\n            List.nth (List.sort list) (k-1)\n        else\n            let s = splitToFives list\n            let M = medianFromFives s\n            let m = magicFives M (int(System.Math.Ceiling((float(List.length M))/2.)))\n            let (ll,lg) = List.partition ( fun i -> i < m ) list\n            let (le,lg) = List.partition ( fun i -> i = m ) lg\n            in\n               if (List.length ll >= k) then \n                    magicFives ll k\n               else if (List.length ll + List.length le >= k ) then m\n               else\n                    magicFives lg (k-(List.length ll)-(List.length le))\n    in\n        let len = List.length l in\n        if (len % 2 = 1) then\n            magicFives l ((len+1)/2)\n        else\n            let a = magicFives l (len/2)\n            let b = magicFives l ((len/2)+1)\n            in (a+b)/2.\n\n\nlet z = [1.;5.;2.;8.;7.;2.]\nstart z\nlet z' = [1.;5.;2.;8.;7.]\nstart z'\n\n", "explain": "Median of Medians algorithm implementation\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "Groovy", "code": "\n\ndef median(Iterable col) {\n    def s = col as SortedSet\n    if (s == null) return null\n    if (s.empty) return 0\n    def n = s.size()\n    def m = n.intdiv(2)\n    def l = s.collect { it }\n    n%2 == 1 ? l[m] : (l[m] + l[m-1])/2 \n}\n\n\ndef a = [4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5]\ndef sz = a.size()\n\n(0..sz).each {\n    println \"\"\"${median(a[0..<(sz-it)])} == median(${a[0..<(sz-it)]})\n${median(a[it..<sz])} == median(${a[it..<sz]})\"\"\"\n}\n\n\n4.45 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n4.45 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n4.4 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3])\n4.5 == median([2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n3.35 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9, 8.2])\n5.55 == median([-1.7, 7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n2.3 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0, 1.9])\n6.6 == median([7.5, 6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n3.35 == median([4.4, 2.3, -1.7, 7.5, 6.6, 0.0])\n5.55 == median([6.6, 0.0, 1.9, 8.2, 9.3, 4.5])\n4.4 == median([4.4, 2.3, -1.7, 7.5, 6.6])\n4.5 == median([0.0, 1.9, 8.2, 9.3, 4.5])\n3.35 == median([4.4, 2.3, -1.7, 7.5])\n6.35 == median([1.9, 8.2, 9.3, 4.5])\n2.3 == median([4.4, 2.3, -1.7])\n8.2 == median([8.2, 9.3, 4.5])\n3.35 == median([4.4, 2.3])\n6.9 == median([9.3, 4.5])\n4.4 == median([4.4])\n4.5 == median([4.5])\n0 == median([])\n0 == median([])\n", "explain": "Solution (brute force sorting, with arithmetic averaging of dual midpoints (even sizes)):\nTest:\nOutput:\n"}, {"task_name": "Averages/Median", "task_url": "https://rosettacode.org/wiki/Averages/Median", "task_cat": "Sorting", "lang": "AWK", "code": "\n\n#!/usr/bin/awk -f\n\nBEGIN {\n    d[1] = 3.0\n    d[2] = 4.0\n    d[3] = 1.0\n    d[4] = -8.4\n    d[5] = 7.2\n    d[6] = 4.0\n    d[7] = 1.0\n    d[8] = 1.2\n    showD(\"Before: \")\n    gnomeSortD()\n    showD(\"Sorted: \")\n    printf \"Median: %f\\n\", medianD()\n    exit\n}\n\nfunction medianD(     len, mid) {\n    len = length(d)\n    mid = int(len/2) + 1\n    if (len % 2) return d[mid]\n    else return (d[mid] + d[mid-1]) / 2.0\n}\n\nfunction gnomeSortD(    i) {\n    for (i = 2; i <= length(d); i++) {\n        if (d[i] < d[i-1]) gnomeSortBackD(i)\n    }\n}\n\nfunction gnomeSortBackD(i,     t) {\n    for (; i > 1 && d[i] < d[i-1]; i--) {\n        t = d[i]\n        d[i] = d[i-1]\n        d[i-1] = t\n    }\n}\n\nfunction showD(p,   i) {\n    printf p\n    for (i = 1; i <= length(d); i++) {\n        printf d[i] \" \"\n    }\n    print \"\"\n}\n\n\nBefore: 3 4 1 -8.4 7.2 4 1 1.2 \nSorted: -8.4 1 1 1.2 3 4 4 7.2 \nMedian: 2.100000\n\n", "explain": "AWK arrays can be passed as parameters, but not returned, so they are usually global.\nExample output:\n"}]