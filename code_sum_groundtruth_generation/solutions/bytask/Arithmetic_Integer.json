[{"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Python", "code": "\nx = int(raw_input(\"Number 1: \"))\ny = int(raw_input(\"Number 2: \"))\n\nprint \"Sum: %d\"\u00a0% (x + y)\nprint \"Difference: %d\"\u00a0% (x - y)\nprint \"Product: %d\"\u00a0% (x * y)\nprint \"Quotient: %d\"\u00a0% (x / y)     #  or x // y  for newer python versions.\n                                   # truncates towards negative infinity\nprint \"Remainder: %d\"\u00a0% (x\u00a0% y)    # same sign as second operand\nprint \"Quotient: %d with Remainder: %d\"\u00a0% divmod(x, y)\nprint \"Power: %d\"\u00a0% x**y\n\n## Only used to keep the display up when the program ends\nraw_input( )\n\ndef getnum(prompt):\n    while True: # retrying ...\n        try:\n            n = int(raw_input(prompt))\n        except ValueError:\n            print \"Input could not be parsed as an integer. Please try again.\"\\\n            continue\n        break\n    return n\n\nx = getnum(\"Number1: \")\ny = getnum(\"Number2: \")\n...\n\nquotient, remainder = divmod(355,113)\n\n\nPython 3.0 compatible code[edit]\ndef arithmetic(x, y):\n    for op in \"+ - * //\u00a0% **\".split():\n        expr = \"%(x)s\u00a0%(op)s\u00a0%(y)s\"\u00a0% vars()\n        print(\"%s\\t=> %s\"\u00a0% (expr, eval(expr)))\n\n\narithmetic(12, 8)\narithmetic(input(\"Number 1: \"), input(\"Number 2: \"))\n\nOutput:\n12 + 8  => 20\n12 - 8  => 4\n12 * 8  => 96\n12 // 8 => 1\n12\u00a0% 8  => 4\n12 ** 8\t=> 429981696\nNumber 1: 20\nNumber 2: 4\n20 + 4  => 24\n20 - 4  => 16\n20 * 4  => 80\n20 // 4 => 5\n20\u00a0% 4  => 0\n20 ** 4 => 160000\n", "explain": "Notes: In Python3 raw_input() will be renamed to input() (the old input() built-in will go away, though one could use eval(input()) to emulate the old ... and ill-advised ... behavior).  Also a better program would wrap the attempted int() conversions in a try: ... except ValueError:... construct such as:\n(In general it's good practice to perform parsing of all input in exception handling blocks.  This is especially true of interactive user input, but also applies to data read from configuration and other files, and marshaled from other processes via any IPC mechanism).\nPython also has the procedure divmod that returns both quotient and remainder. eg\nGiving a quotient of 3, and a remainder of 16. \n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\nint main(int argc, char *argv[])\n{\n  int a, b;\n  if (argc < 3) exit(1);\n  b = atoi(argv[--argc]);\n  if (b == 0) exit(2);\n  a = atoi(argv[--argc]);\n  printf(\"a+b = %d\\n\", a+b);\n  printf(\"a-b = %d\\n\", a-b);\n  printf(\"a*b = %d\\n\", a*b);\n  printf(\"a/b = %d\\n\", a/b); /* truncates towards 0 (in C99) */\n  printf(\"a%%b = %d\\n\", a%b); /* same sign as first operand (in C99) */\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "C++", "code": "\n#include <iostream>\n\nint main()\n{\n  int a, b;\n  std::cin >> a >> b;\n  std::cout << \"a+b = \" << a+b << \"\\n\";\n  std::cout << \"a-b = \" << a-b << \"\\n\";\n  std::cout << \"a*b = \" << a*b << \"\\n\";\n  std::cout << \"a/b = \" << a/b << \", remainder \" << a%b << \"\\n\";\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Java", "code": "\nimport java.util.Scanner;\n\npublic class IntegerArithmetic {\n    public static void main(String[] args) {\n        // Get the 2 numbers from command line arguments\n        Scanner sc = new Scanner(System.in);\n        int a = sc.nextInt();\n        int b = sc.nextInt();\n\n        int sum = a + b;        // The result of adding 'a' and 'b' (Note: integer addition is discouraged in print statements due to confusion with string concatenation)\n        int difference = a - b; // The result of subtracting 'b' from 'a'\n        int product = a * b;    // The result of multiplying 'a' and 'b'\n        int division = a / b;   // The result of dividing 'a' by 'b' (Note: 'division' does not contain the fractional result)\n        int remainder = a % b;  // The remainder of dividing 'a' by 'b'\n\n        System.out.println(\"a + b = \" + sum);\n        System.out.println(\"a - b = \" + difference);\n        System.out.println(\"a * b = \" + product);\n        System.out.println(\"quotient of a / b = \" + division);   // truncates towards 0\n        System.out.println(\"remainder of a / b = \" + remainder);   // same sign as first operand\n    }\n}\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        int a = Convert.ToInt32(args[0]);\n        int b = Convert.ToInt32(args[1]);\n\n        Console.WriteLine(\"{0} + {1} = {2}\", a, b, a + b);\n        Console.WriteLine(\"{0} - {1} = {2}\", a, b, a - b);\n        Console.WriteLine(\"{0} * {1} = {2}\", a, b, a * b);\n        Console.WriteLine(\"{0} / {1} = {2}\", a, b, a / b); // truncates towards 0\n        Console.WriteLine(\"{0}\u00a0% {1} = {2}\", a, b, a % b); // matches sign of first operand\n        Console.WriteLine(\"{0} to the power of {1} = {2}\", a, b, Math.Pow(a, b));\n    }\n}\n\n\nOutput:\n5 + 3 = 8\n5 - 3 = 2\n5 * 3 = 15\n5 / 3 = 1\n5\u00a0% 3 = 2\n5 to the power of 3 = 125\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "JavaScript", "code": "\nWScript[edit]\nWorks with: JScript\nWorks with: SpiderMonkey\n\nvar a = parseInt(get_input(\"Enter an integer\"), 10);\nvar b = parseInt(get_input(\"Enter an integer\"), 10);\n\nWScript.Echo(\"a = \" + a);\nWScript.Echo(\"b = \" + b);\nWScript.Echo(\"sum: a + b = \"        + (a + b));\nWScript.Echo(\"difference: a - b = \" + (a - b));\nWScript.Echo(\"product: a * b = \"    + (a * b));\nWScript.Echo(\"quotient: a / b = \"   + (a / b | 0)); // \"| 0\" casts it to an integer\nWScript.Echo(\"remainder: a\u00a0% b = \"  + (a % b));\n\nfunction get_input(prompt) {\n    output(prompt);\n    try {\n        return WScript.StdIn.readLine();\n    } catch(e) {\n        return readline();\n    }\n}\nfunction output(prompt) {\n    try {\n        WScript.Echo(prompt);\n    } catch(e) {\n        print(prompt);\n    }\n}\n\n\nOutput:\nEnter an integer\n-147\nEnter an integer\n63\na = -147\nb = 63\nsum: a + b = -84\ndifference: a - b = -210\nproduct: a * b = -9261\nquotient: a / b = -2\nremainder: a\u00a0% b = -21\nNode.JS[edit]\n// Invoked as node script_name.js <a> <b>. Positions 0 and 1 in the argv array contain 'node' and 'script_name.js' respectively\nvar a = parseInt(process.argv[2], 10);\nvar b = parseInt(process.argv[3], 10);\n\nvar sum = a + b;\nvar difference = a - b;\nvar product = a * b;\nvar division = a / b;\nvar remainder = a % b;  // This produces the remainder after dividing 'b' into 'a'. The '%' operator is called the 'modulo' operator\n\nconsole.log('a + b = %d', sum);  // The %d syntax is a placeholder that is replaced by the sum\nconsole.log('a - b = %d', difference);\nconsole.log('a * b = %d', product);\nconsole.log('a / b = %d', division);\nconsole.log('a\u00a0% b = %d', remainder);\n\n\nOutput:\n$ node arith.js 10 7\na + b = 17\na - b = 3\na * b = 70\na / b = 1.4285714285714286\na\u00a0% b = 3\n", "explain": "Note that the operators work the same in all versions of JavaScript; the requirement for specific implementations is in order to get user input.\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Visual_Basic_.NET", "code": "\nImports System.Console\nModule Module1\n  Sub Main\n    Dim a = CInt(ReadLine)\n    Dim b = CInt(ReadLine)\n    WriteLine(\"Sum \" & a + b)\n    WriteLine(\"Difference \" & a - b)\n    WriteLine(\"Product \" & a - b)\n    WriteLine(\"Quotient \" & a / b)\n    WriteLine(\"Integer Quotient \" & a \\ b)\n    WriteLine(\"Remainder \" & a Mod b)\n    WriteLine(\"Exponent \" & a ^ b)\n  End Sub\nEnd Module\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "SQL", "code": "\nWorks with: Oracle\n-- test.sql\n-- Tested in SQL*plus\n\ndrop table test;\n\ncreate table test (a integer, b integer);\n\ninsert into test values ('&&A','&&B');\n\ncommit;\n\nselect a-b difference from test;\n\nselect a*b product from test;\n\nselect trunc(a/b) integer_quotient from test;  \n\nselect mod(a,b) remainder from test;\n\nselect power(a,b) exponentiation from test;\nSQL> @test.sql\n\nTable dropped.\n\n\nTable created.\n\nEnter value for a: 3\nEnter value for b: 4\nold   1: insert into test values ('&&A','&&B')\nnew   1: insert into test values ('3','4')\n\n1 row created.\n\n\nCommit complete.\n\n\nDIFFERENCE\n----------\n        -1\n\n\n   PRODUCT\n----------\n        12\n\n\nINTEGER_QUOTIENT\n----------------\n               0\n\n\n REMAINDER\n----------\n         3\n\n\nEXPONENTIATION\n--------------\n            81\n   \n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "PHP", "code": "\n<?php\n$a = fgets(STDIN);\n$b = fgets(STDIN);\n\necho\n    \"sum:                 \", $a + $b, \"\\n\",\n    \"difference:          \", $a - $b, \"\\n\",\n    \"product:             \", $a * $b, \"\\n\",\n    \"truncating quotient: \", (int)($a / $b), \"\\n\",\n    \"flooring quotient:   \", floor($a / $b), \"\\n\",\n    \"remainder:           \", $a % $b, \"\\n\",\n    \"power:               \", $a ** $b, \"\\n\"; // PHP 5.6+ only\n?>\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Fortran", "code": "\n\n INTEGER A, B\n PRINT *, 'Type in two integer numbers separated by white space',\n+         ' and press ENTER'\n READ *, A, B\n PRINT *, '   A + B = ', (A + B)\n PRINT *, '   A - B = ', (A - B)\n PRINT *, '   A * B = ', (A * B)\n PRINT *, '   A / B = ', (A / B)\n PRINT *, 'MOD(A,B) = ', MOD(A,B)\n PRINT *\n PRINT *, 'Even though you did not ask, ',\n+         'exponentiation is an intrinsic op in Fortran, so...'\n PRINT *, '  A ** B = ', (A ** B)\n END\n\n", "explain": "In ANSI FORTRAN 77 or later:\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Go", "code": "\nint[edit]\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    var a, b int\n    fmt.Print(\"enter two integers: \")\n    fmt.Scanln(&a, &b)\n    fmt.Printf(\"%d + %d = %d\\n\", a, b, a+b)\n    fmt.Printf(\"%d - %d = %d\\n\", a, b, a-b)\n    fmt.Printf(\"%d * %d = %d\\n\", a, b, a*b)\n    fmt.Printf(\"%d / %d = %d\\n\", a, b, a/b)  // truncates towards 0\n    fmt.Printf(\"%d\u00a0%% %d = %d\\n\", a, b, a%b) // same sign as first operand\n    // no exponentiation operator\n}\n\n\nExample run:\nenter two integers: -5 3\n-5 + 3 = -2\n-5 - 3 = -8\n-5 * 3 = -15\n-5 / 3 = -1\n-5\u00a0% 3 = -2\n\nbig.Int[edit]\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nfunc main() {\n    var a, b, c big.Int\n    fmt.Print(\"enter two integers: \")\n    fmt.Scan(&a, &b)\n    fmt.Printf(\"%d + %d = %d\\n\", &a, &b, c.Add(&a, &b))\n    fmt.Printf(\"%d - %d = %d\\n\", &a, &b, c.Sub(&a, &b))\n    fmt.Printf(\"%d * %d = %d\\n\", &a, &b, c.Mul(&a, &b))\n\n    // Quo, Rem functions work like Go operators on int:\n    // quo truncates toward 0,\n    // and a non-zero rem has the same sign as the first operand.\n    fmt.Printf(\"%d quo %d = %d\\n\", &a, &b, c.Quo(&a, &b))\n    fmt.Printf(\"%d rem %d = %d\\n\", &a, &b, c.Rem(&a, &b))\n\n    // Div, Mod functions do Euclidean division:\n    // the result m = a mod b is always non-negative,\n    // and for d = a div b, the results d and m give d*y + m = x.\n    fmt.Printf(\"%d div %d = %d\\n\", &a, &b, c.Div(&a, &b))\n    fmt.Printf(\"%d mod %d = %d\\n\", &a, &b, c.Mod(&a, &b))\n\n    // as with int, no exponentiation operator\n}\n\n\nExample run:\nenter two integers: -5 3\n-5 + 3 = -2\n-5 - 3 = -8\n-5 * 3 = -15\n-5 quo 3 = -1\n-5 rem 3 = -2\n-5 div 3 = -2\n-5 mod 3 = 1\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program arith.s   */\n/* Constantes    */\n.equ STDOUT, 1\n.equ WRITE,  4\n.equ EXIT,   1\n\n/***********************/\n/* Initialized data */\n/***********************/\n.data\nszMessError:      .asciz \" Two numbers in command line please\u00a0! \\n\"       @ message\nszRetourLigne: .asciz \"\\n\"\nszMessResult:  .asciz \"Resultat \"      @ message result\nsMessValeur:   .fill 12, 1, ' '\n                   .asciz \"\\n\"\nszMessAddition: .asciz \"addition\u00a0:\"\nszMessSoustraction: .asciz \"soustraction\u00a0:\"\nszMessMultiplication: .asciz \"multiplication\u00a0:\"\nszMessDivision: .asciz \"division\u00a0:\"\nszMessReste: .asciz \"reste\u00a0:\"\n   \n/***********************/\t\t\t\t   \n/* No Initialized data */\n/***********************/\n.bss\niValeur:  .skip  4     @ reserve 4 bytes in memory\n\n.text\n.global main \nmain:\n    push {fp,lr}                @ save des  2 registres\n    add fp,sp,#8                @ fp <- adresse d\u00e9but\n    ldr r0,[fp]                 @ recup number of parameter in command line\n    cmp r0,#3\n    blt error\n    ldr r0,[fp,#8]              @ adresse of 1er number\n    bl conversionAtoD\n    mov r3,r0\n    ldr r0,[fp,#12]             @ adresse of 2eme number\n    bl conversionAtoD\n    mov r4,r0\n    @ addition\n    add r0,r3,r4\n    ldr r1,iAdrsMessValeur      @ result in r0\n    bl conversion10S            @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    ldr r0,iAdrszMessAddition\n    bl affichageMess            @ display message\n    ldr r0,iAdrsMessValeur\n    bl affichageMess            @ display message\n    @ soustraction\n    sub r0,r3,r4\n    ldr r1,=sMessValeur                 \n    bl conversion10S            @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    ldr r0,iAdrszMessSoustraction\n    bl affichageMess            @ display message\n    ldr r0,iAdrsMessValeur\n    bl affichageMess            @ display message\n\n    @ multiplication\n    mul r0,r3,r4\n    ldr r1,=sMessValeur                 \n    bl conversion10S            @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    ldr r0,iAdrszMessMultiplication\n    bl affichageMess            @ display message\n    ldr r0,iAdrsMessValeur\n    bl affichageMess            @ display message\n   \n    @ division \n    mov r0,r3\n    mov r1,r4\n    bl division\n    mov r0,r2                   @ quotient\n    ldr r1,=sMessValeur                 \n    bl conversion10S            @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    ldr r0,iAdrszMessDivision\n    bl affichageMess            @ display message\n    ldr r0,iAdrsMessValeur\n    bl affichageMess            @ display message\n\n    mov r0,r3                   @ remainder\n    ldr r1,=sMessValeur                 \n    bl conversion10S            @ call function with 2 parameter (r0,r1)\n    ldr r0,iAdrszMessResult\n    bl affichageMess            @ display message\n    ldr r0,iAdrszMessReste\n    bl affichageMess            @ display message\n    ldr r0,iAdrsMessValeur\n    bl affichageMess            @ display message\n \n    mov r0, #0                  @ return code\n    b 100f\nerror:\n    ldr r0,iAdrszMessError\n    bl affichageMess            @ call function with 1 parameter (r0)\n    mov r0, #1                  @ return code\n100: /* end of  program */\n    mov r7, #EXIT               @ request to exit program\n    swi 0                       @ perform the system call\niAdrsMessValeur: .int sMessValeur\t\niAdrszMessResult: .int szMessResult\niAdrszMessError: .int szMessError\niAdrszMessAddition: .int szMessAddition\niAdrszMessSoustraction: .int szMessSoustraction\niAdrszMessMultiplication: .int szMessMultiplication\niAdrszMessDivision: .int szMessDivision\niAdrszMessReste: .int szMessReste\n/******************************************************************/\n/*     affichage des messages   avec calcul longueur              */ \n/******************************************************************/\n/* r0 contient l adresse du message */\naffichageMess:\n    push {fp,lr}        /* save des  2 registres */ \n    push {r0,r1,r2,r7}  /* save des autres registres */\n    mov r2,#0           /* compteur longueur */\n1:                      /*calcul de la longueur */\n    ldrb r1,[r0,r2]     /* recup octet position debut + indice */\n    cmp r1,#0           /* si 0 c est fini */\n    beq 1f\n    add r2,r2,#1        /* sinon on ajoute 1 */\n    b 1b\n1:                      /* donc ici r2 contient la longueur du message */\n    mov r1,r0           /* adresse du message en r1 */\n    mov r0,#STDOUT      /* code pour \u00e9crire sur la sortie standard Linux */\n    mov r7, #WRITE      /* code de l appel systeme 'write' */\n    swi #0              /* appel systeme */\n    pop {r0,r1,r2,r7}   /* restaur des autres registres */\n    pop {fp,lr}         /* restaur des  2 registres */ \n    bx lr\t        /* retour procedure */\t\n/***************************************************/\n/*   conversion registre en d\u00e9cimal   sign\u00e9  */\n/***************************************************/\n/* r0 contient le registre   */\n/* r1 contient l adresse de la zone de conversion */\nconversion10S:\n    push {fp,lr}      /* save des  2 registres frame et retour */\n    push {r0-r5}      /* save autres registres  */\n    mov r2,r1         /* debut zone stockage */\n    mov r5,#'+'       /* par defaut le signe est + */\n    cmp r0,#0         /* nombre n\u00e9gatif\u00a0? */\n    movlt r5,#'-'     /* oui le signe est - */\n    mvnlt r0,r0       /* et inversion en valeur positive */\n    addlt r0,#1\n    mov r4,#10       /* longueur de la zone */\n1:                   /* debut de boucle de conversion */\n    bl divisionpar10 /* division  */\n    add r1,#48       /* ajout de 48 au reste pour conversion ascii */\t\n    strb r1,[r2,r4]  /* stockage du byte en d\u00e9but de zone r5 + la position r4 */\n    sub r4,r4,#1     /* position pr\u00e9cedente */\n    cmp r0,#0     \n    bne 1b\t     /* boucle si quotient different de z\u00e9ro */\n    strb r5,[r2,r4]  /* stockage du signe \u00e0 la position courante */\n    subs r4,r4,#1    /* position pr\u00e9cedente */\n    blt  100f        /* si r4 < 0  fin  */\n                     /* sinon il faut completer le debut de la zone avec des blancs */\n    mov r3,#' '      /* caractere espace */\t\n2:\n    strb r3,[r2,r4]  /* stockage du byte  */\n    subs r4,r4,#1    /* position pr\u00e9cedente */\n    bge 2b           /* boucle si r4 plus grand ou egal a zero */\n100:                 /* fin standard de la fonction  */\n    pop {r0-r5}      /*restaur des autres registres */\n    pop {fp,lr}      /* restaur des  2 registres frame et retour  */\n    bx lr   \n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 contient le dividende   */\n/* r0 retourne le quotient */\t\n/* r1 retourne le reste  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n   push {r2-r4}   /* save autres registres  */\n   mov r4,r0 \n   ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n   smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n   mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n   mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n   add r0, r2, r1         /* r0 <- r2 + r1 */\n   add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n   sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n   pop {r2-r4}\n   bx lr                  /* leave function */\n   .align 4\n.Ls_magic_number_10: .word 0x66666667\n/******************************************************************/\n/*     Conversion d une chaine en nombre stock\u00e9 dans un registre  */ \n/******************************************************************/\n/* r0 contient l adresse de la zone termin\u00e9e par 0 ou 0A */\nconversionAtoD:\n    push {fp,lr}      /* save des  2 registres */ \n    push {r1-r7}      /* save des autres registres */\n    mov r1,#0\n    mov r2,#10        /* facteur */\n    mov r3,#0         /* compteur */\n    mov r4,r0         /* save de l adresse dans r4 */\n    mov r6,#0         /* signe positif par defaut */\n    mov r0,#0         /* initialisation \u00e0 0 */ \n1:                    /* boucle d \u00e9limination des blancs du debut */\n    ldrb r5,[r4,r3]   /* chargement dans r5 de l octet situ\u00e9 au debut + la position */\n    cmp r5,#0         /* fin de chaine -> fin routine */\n    beq 100f\n    cmp r5,#0x0A      /* fin de chaine -> fin routine */\n    beq 100f\n    cmp r5,#' '       /* blanc au d\u00e9but */\n    bne 1f            /* non on continue */\n    add r3,r3,#1      /* oui on boucle en avan\u00e7ant d un octet */\n    b 1b\n1:\n    cmp r5,#'-'       /* premier caracteres est -    */\n    moveq r6,#1       /* maj du registre r6 avec 1 */\n    beq 3f            /* puis on avance \u00e0 la position suivante */\n2:                    /* debut de boucle de traitement des chiffres */\n    cmp r5,#'0'       /* caractere n est pas un chiffre */\n    blt 3f\n    cmp r5,#'9'       /* caractere n est pas un chiffre */\n    bgt 3f\n                      /* caract\u00e8re est un chiffre */\n    sub r5,#48\n    ldr r1,iMaxi      /*verifier le d\u00e9passement du registre  */  \n    cmp r0,r1\n    bgt 99f\n    mul r0,r2,r0     /* multiplier par facteur */\n    add r0,r5        /* ajout \u00e0 r0 */\n3:\n    add r3,r3,#1     /* avance \u00e0 la position suivante */\n    ldrb r5,[r4,r3]  /* chargement de l octet */\n    cmp r5,#0        /* fin de chaine -> fin routine */\n    beq 4f\n    cmp r5,#10       /* fin de chaine -> fin routine */\n    beq 4f\n    b 2b             /* boucler */ \n4:\n    cmp r6,#1        /* test du registre r6 pour le signe */\n    bne 100f\n    mov r1,#-1\n    mul r0,r1,r0    /* si negatif, on multiplie par -1 */\n    b 100f\n99:                 /* erreur de d\u00e9passement */\n    ldr r1,=szMessErrDep\n    bl   afficheerreur \n    mov r0,#0       /* en cas d erreur on retourne toujours zero */\n100:\n    pop {r1-r7}     /* restaur des autres registres */\n    pop {fp,lr}     /* restaur des  2 registres */ \n    bx lr           /* retour procedure */\t\n/* constante programme */\t\niMaxi: .int 1073741824\t\nszMessErrDep:  .asciz  \"Nombre trop grand\u00a0: d\u00e9passement de capacite de 32 bits.\u00a0:\\n\"\n.align 4\n/*=============================================*/\n/* division entiere non sign\u00e9e                */\n/*============================================*/\ndivision:\n    /* r0 contains N */\n    /* r1 contains D */\n    /* r2 contains Q */\n    /* r3 contains R */\n    push {r4, lr}\n    mov r2, #0              /* r2\u00a0? 0 */\n    mov r3, #0              /* r3\u00a0? 0 */\n    mov r4, #32             /* r4\u00a0? 32 */\n    b 2f\n1:\n    movs r0, r0, LSL #1    /* r0\u00a0? r0 << 1 updating cpsr (sets C if 31st bit of r0 was 1) */\n    adc r3, r3, r3         /* r3\u00a0? r3 + r3 + C. This is equivalent to r3\u00a0? (r3 << 1) + C */\n \n    cmp r3, r1             /* compute r3 - r1 and update cpsr */\n    subhs r3, r3, r1       /* if r3 >= r1 (C=1) then r3\u00a0? r3 - r1 */\n    adc r2, r2, r2         /* r2\u00a0? r2 + r2 + C. This is equivalent to r2\u00a0? (r2 << 1) + C */\n2:\n    subs r4, r4, #1        /* r4\u00a0? r4 - 1 */\n    bpl 1b                 /* if r4 >= 0 (N=0) then branch to .Lloop1 */\n \n    pop {r4, lr}\n    bx lr\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Delphi", "code": "\nprogram IntegerArithmetic;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, Math;\n\nvar\n  a, b: Integer;\nbegin\n  a := StrToInt(ParamStr(1));\n  b := StrToInt(ParamStr(2));\n\n  WriteLn(Format('%d + %d = %d', [a, b, a + b]));\n  WriteLn(Format('%d - %d = %d', [a, b, a - b]));\n  WriteLn(Format('%d * %d = %d', [a, b, a * b]));\n  WriteLn(Format('%d / %d = %d', [a, b, a div b])); // rounds towards 0\n  WriteLn(Format('%d\u00a0%% %d = %d', [a, b, a mod b])); // matches sign of the first operand\n  WriteLn(Format('%d ^ %d = %d', [a, b, Trunc(Power(a, b))]));\nend.\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Ruby", "code": "\nputs 'Enter x and y'\nx = gets.to_i  # to check errors, use x=Integer(gets)\ny = gets.to_i\n\nputs \"Sum: #{x+y}\",\n     \"Difference: #{x-y}\",\n     \"Product: #{x*y}\",\n     \"Quotient: #{x/y}\",       # truncates towards negative infinity\n     \"Quotient: #{x.fdiv(y)}\", # float\n     \"Remainder: #{x%y}\",      # same sign as second operand\n     \"Exponentiation: #{x**y}\",\n     \"Quotient: %d with Remainder: %d\"\u00a0% x.divmod(y)\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Rust", "code": "\n\nuse std::env;\n\nfn main() {\n    let args: Vec<_> = env::args().collect();\n    let a = args[1].parse::<i32>().unwrap();\n    let b = args[2].parse::<i32>().unwrap();\n\n    println!(\"sum:              {}\", a + b);\n    println!(\"difference:       {}\", a - b);\n    println!(\"product:          {}\", a * b);\n    println!(\"integer quotient: {}\", a / b); // truncates towards zero\n    println!(\"remainder:        {}\", a\u00a0% b); // same sign as first operand\n}\n", "explain": "Note that this code cannot be run within the Rust playpen as it does not support console input.\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Swift", "code": "\nlet a = 6 \nlet b = 4\n\nprint(\"sum =\\(a+b)\")\nprint(\"difference = \\(a-b)\")\nprint(\"product = \\(a*b)\")\nprint(\"Integer quotient = \\(a/b)\")\nprint(\"Remainder = (a%b)\")\nprint(\"No operator for Exponential\")\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "R", "code": "\ncat(\"insert number \")\na <- scan(nmax=1, quiet=TRUE)\ncat(\"insert number \")\nb <- scan(nmax=1, quiet=TRUE)\nprint(paste('a+b=', a+b))\nprint(paste('a-b=', a-b))\nprint(paste('a*b=', a*b))\nprint(paste('a%/%b=', a%/%b))\nprint(paste('a%%b=', a%%b))\nprint(paste('a^b=', a^b))\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Int-Arithmetic.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n       01 A      PIC S9(10).\n       01 B      PIC S9(10).\n       01 Result PIC S9(10).\n\n       PROCEDURE DIVISION.\n           DISPLAY \"First number: \" WITH NO ADVANCING\n           ACCEPT A\n           DISPLAY \"Second number: \" WITH NO ADVANCING\n           ACCEPT B\n           \n*          *> Note: The various ADD/SUBTRACT/etc. statements can be\n*          *> replaced with COMPUTE statements, which allow those\n*          *> operations to be defined similarly to other languages,\n*          *> e.g. COMPUTE Result = A + B\n\n           ADD A TO B GIVING Result\n           DISPLAY \"A + B = \" Result\n\n           SUBTRACT B FROM A GIVING Result\n           DISPLAY \"A - B = \" Result\n\n           MULTIPLY A BY B GIVING Result\n           DISPLAY \"A * B = \" Result\n\n*          *> Division here truncates towards zero. DIVIDE can take a\n*          *> ROUNDED clause, which will round the result to the nearest\n*          *> integer.\n           DIVIDE A BY B GIVING Result\n           DISPLAY \"A / B = \" Result\n\n           COMPUTE Result = A ^ B\n           DISPLAY \"A ^ B = \" Result\n       \n*          *> Matches sign of first argument.\n           DISPLAY \"A\u00a0% B = \" FUNCTION REM(A, B)\n\n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Ada", "code": "\nwith Ada.Text_Io;\nwith Ada.Integer_Text_IO;\n\nprocedure Integer_Arithmetic is\n   use Ada.Text_IO;\n   use Ada.Integer_Text_Io;\n\n   A, B : Integer;\nbegin\n   Get(A);\n   Get(B);\n   Put_Line(\"a+b = \" & Integer'Image(A + B));\n   Put_Line(\"a-b = \" & Integer'Image(A - B));\n   Put_Line(\"a*b = \" & Integer'Image(A * B));\n   Put_Line(\"a/b = \" & Integer'Image(A / B));\n   Put_Line(\"a mod b = \" & Integer'Image(A mod B)); -- Sign matches B\n   Put_Line(\"remainder of a/b = \" & Integer'Image(A rem B)); -- Sign matches A\n   Put_Line(\"a**b = \" & Integer'Image(A ** B));  \n\nend Integer_Arithmetic;\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Julia", "code": "\nfunction arithmetic (a = parse(Int, readline()), b = parse(Int, readline()))\n  for op in  [+,-,*,div,rem]\n    println(\"a $op b = $(op(a,b))\")\n  end\nend\n\n\nOutput:\njulia> arithmetic()\n4\n5\na + b = 9\na - b = -1\na * b = 20\na div b = 0\na rem b = 4\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Kotlin", "code": "\nimport kotlin.math.pow // not an operator but in the standard library\n\nfun main() {\n    val r = Regex(\"\"\"-?[0-9]+\\s+-?[0-9]+\"\"\")\n    print(\"Enter two integers separated by space(s): \")\n    val input: String = readLine()!!.trim()\n    val index = input.lastIndexOf(' ')\n    val a = input.substring(0, index).trimEnd().toLong()\n    val b = input.substring(index + 1).toLong()\n    println(\"$a + $b = ${a + b}\")\n    println(\"$a - $b = ${a - b}\")\n    println(\"$a * $b = ${a * b}\")\n    println(\"$a / $b = ${a / b}\")  // rounds towards zero\n    println(\"$a\u00a0% $b = ${a % b}\")  // if non-zero, matches sign of first operand\n    println(\"$a ^ $b = ${a.toDouble().pow(b.toDouble())}\")\n}\n}\n\n\nOutput:\nEnter two integers separated by space(s): 2 63\n2 + 63 = 65\n2 - 63 = -61\n2 * 63 = 126\n2 / 63 = 0\n2\u00a0% 63 = 2\n2 ^ 63 = 9.223372036854776E18\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Perl", "code": "\nWorks with: Perl version 5.x\nmy $a = <>;\nmy $b = <>;\n\nprint\n    \"sum:              \", $a + $b, \"\\n\",\n    \"difference:       \", $a - $b, \"\\n\",\n    \"product:          \", $a * $b, \"\\n\",\n    \"integer quotient: \", int($a / $b), \"\\n\",\n    \"remainder:        \", $a % $b, \"\\n\",\n    \"exponent:         \", $a ** $b, \"\\n\"\n    ;\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Prolog", "code": "\n\nprint_expression_and_result(M, N, Operator)\u00a0:-\n    Expression =.. [Operator, M, N],\n    Result is Expression,\n    format('~w ~8|is ~d~n', [Expression, Result]).\n\narithmetic_integer\u00a0:-\n    read(M),\n    read(N),\n    maplist( print_expression_and_result(M, N), [+,-,*,//,rem,^] ).\n\n?- arithmetic_integer.\n|: 5.\n|: 7.\n5+7     is 12\n5-7     is -2\n5*7     is 35\n5//7    is 0\n5 rem 7 is 5\n5^7     is 78125\ntrue.\n", "explain": "Integer quotient (`//`) rounds towards 0.\nRemainder (`rem`) matches the sign of its first operand.\nUse thus:\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Lua", "code": "\nlocal x = io.read()\nlocal y = io.read()\n\nprint (\"Sum: \"       , (x + y))\nprint (\"Difference: \", (x - y))\nprint (\"Product: \"   , (x * y))\nprint (\"Quotient: \"  , (x / y)) -- Does not truncate\nprint (\"Remainder: \" , (x % y)) -- Result has sign of right operand\nprint (\"Exponent: \"  , (x ^ y))\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Scala", "code": "\nval a = Console.readInt\nval b = Console.readInt\n \nval sum = a + b //integer addition is discouraged in print statements due to confusion with String concatenation\nprintln(\"a + b = \" + sum)\nprintln(\"a - b = \" + (a - b))\nprintln(\"a * b = \" + (a * b))\nprintln(\"quotient of a / b = \" + (a / b)) // truncates towards 0\nprintln(\"remainder of a / b = \" + (a\u00a0% b)) // same sign as first operand\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "D", "code": "\nimport std.stdio, std.string, std.conv;\n\nvoid main() {\n    int a = 10, b = 20;\n    try {\n        a = readln().strip().to!int();\n        b = readln().strip().to!int();\n    } catch (StdioException e) {}\n    writeln(\"a = \", a, \", b = \", b);\n\n    writeln(\"a + b = \", a + b);\n    writeln(\"a - b = \", a - b);\n    writeln(\"a * b = \", a * b);\n    writeln(\"a / b = \", a / b);\n    writeln(\"a\u00a0% b = \", a % b);\n    writeln(\"a ^^ b = \", a ^^ b);\n}\n\n\nOutput:\na = -16, b = 5\na + b = -11\na - b = -21\na * b = -80\na / b = -3\na\u00a0% b = -1\na ^^ b = -1048576\nShorter Version[edit]\n\nimport std.stdio, std.string, std.conv, std.meta;\n\nvoid main() {\n    int a = -16, b = 5;\n    try {\n        a = readln().strip().to!int();\n        b = readln().strip().to!int();\n    } catch (StdioException e) {}\n    writeln(\"a = \", a, \", b = \", b);\n\n    foreach (op; AliasSeq!(\"+\", \"-\", \"*\", \"/\", \"%\", \"^^\"))\n        mixin(`writeln(\"a ` ~ op ~ ` b = \", a` ~ op ~ `b);`);\n}\n\n\n", "explain": "Same output.\nDivision and modulus are defined as in C99.\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Haskell", "code": "\nmain = do\n  a <- readLn :: IO Integer\n  b <- readLn :: IO Integer\n  putStrLn $ \"a + b = \" ++ show (a + b)\n  putStrLn $ \"a - b = \" ++ show (a - b)\n  putStrLn $ \"a * b = \" ++ show (a * b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ** b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ^ b)\n  putStrLn $ \"a to the power of b = \" ++ show (a ^^ b)\n  putStrLn $ \"a `div` b = \"  ++ show (a `div` b)  -- truncates towards negative infinity\n  putStrLn $ \"a `mod` b = \"  ++ show (a `mod` b)  -- same sign as second operand\n  putStrLn $ \"a `divMod` b = \"  ++ show (a `divMod` b)\n  putStrLn $ \"a `quot` b = \" ++ show (a `quot` b) -- truncates towards 0\n  putStrLn $ \"a `rem` b = \"  ++ show (a `rem` b)  -- same sign as first operand\n  putStrLn $ \"a `quotRem` b = \"  ++ show (a `quotRem` b)\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "VBScript", "code": "\n\nImplementation[edit]\noption explicit\ndim a, b\nwscript.stdout.write \"A? \"\na = wscript.stdin.readline\nwscript.stdout.write \"B? \"\nb = wscript.stdin.readline\n\na = int( a )\nb = int( b )\n\nwscript.echo \"a + b=\", a + b\nwscript.echo \"a - b=\", a - b\nwscript.echo \"a * b=\", a * b\nwscript.echo \"a / b=\", a / b\nwscript.echo \"a \\ b=\", a \\ b\nwscript.echo \"a mod b=\", a mod b\nwscript.echo \"a ^ b=\", a ^ b\nAnother Implementation[edit]\n\noption explicit\ndim a, b\nwscript.stdout.write \"A? \"\na = wscript.stdin.readline\nwscript.stdout.write \"B? \"\nb = wscript.stdin.readline\n\na = int( a )\nb = int( b )\n\ndim op\nfor each op in split(\"+ - * / \\ mod ^\", \" \")\n\twscript.echo \"a\",op,\"b=\",eval( \"a \" & op & \" b\")\nnext\nInvocation[edit]\nC:\\foo>arithmetic.vbs\nA? 45\nB? 11\na + b= 4511\na - b= 34\na * b= 495\na / b= 4.09090909090909\na \\ b= 4\na mod b= 1\na ^ b= 1.5322783012207E+18\n\n", "explain": "VBScript's variables are all Variants. What starts out as an integer may be converted to something else if the need arises.\nGives the same output for the same input. Inspired by Python version.\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Scheme", "code": "\n(define (arithmetic x y)\n  (for-each (lambda (op)\n              (write  (list op x y))\n              (display \" => \")\n              (write ((eval op) x y))\n              (newline))\n            '(+ - * / quotient remainder modulo max min gcd lcm)))\n           \n(arithmetic 8 12)\n\n prints this:\n\n(+ 8 12) => 20\n(- 8 12) => -4\n(* 8 12) => 96\n(/ 8 12) => 2/3\n(quotient 8 12) => 0\n(remainder 8 12) => 8\n(modulo 8 12) => 8\n(max 8 12) => 12\n(min 8 12) => 8\n(gcd 8 12) => 4\n(lcm 8 12) => 24\n\n", "explain": "quotient - truncates towards 0\nremainder - same sign as first operand\nmodulo - same sign as second operand\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "PowerShell", "code": "\n$a = [int] (Read-Host First Number)\n$b = [int] (Read-Host Second Number)\n\nWrite-Host \"Sum:                              $($a + $b)\"\nWrite-Host \"Difference:                       $($a - $b)\"\nWrite-Host \"Product:                          $($a * $b)\"\nWrite-Host \"Quotient:                         $($a / $b)\"\nWrite-Host \"Quotient, round to even:          $([Math]::Round($a / $b))\"\nWrite-Host \"Remainder, sign follows first:    $($a % $b)\"\n\n\n[Math]::Pow($a, $b)\n\n", "explain": "Numbers are automatically converted to accomodate for the result. This means not only that Int32 will be expanded to Int64 but also that a non-integer quotient will cause the result to be of a floating-point type.\nThe remainder has the sign of the first operand.\nNo exponentiation operator exists, but can be worked around with the .NET BCL:\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Logo", "code": "\nto operate :a :b\n  (print [a =] :a)\n  (print [b =] :b)\n  (print [a + b =] :a + :b)\n  (print [a - b =] :a - :b)\n  (print [a * b =] :a * :b)\n  (print [a / b =] int :a / :b)\n  (print [a mod b =] modulo :a :b)\nend\n\n", "explain": "Each infix operator also has a prefix synonym (sum, difference, product, quotient). Sum and product can also have arity greater than two when used in parentheses (sum 1 2 3). Infix operators in general have high precedence; you may need to enclose their arguments in parentheses to obtain the correct expression.\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "ABAP", "code": "\nreport zz_arithmetic no standard page heading.\n\n\" Read in the two numbers from the user.\nselection-screen begin of block input.\n  parameters: p_first type i,\n              p_second type i.\nselection-screen end of block input.\n\n\" Set the text value that is displayed on input request.\nat selection-screen output.\n  %_p_first_%_app_%-text  = 'First Number: '.\n  %_p_second_%_app_%-text = 'Second Number: '.\n\nend-of-selection.\n  data: lv_result type i.\n  lv_result = p_first + p_second.\n  write: / 'Addition:', lv_result.\n  lv_result = p_first - p_second.\n  write: / 'Substraction:', lv_result.\n  lv_result = p_first * p_second.\n  write: / 'Multiplication:', lv_result.\n  lv_result = p_first div p_second.\n  write: / 'Integer quotient:', lv_result. \" Truncated towards zero.\n  lv_result = p_first mod p_second.\n  write: / 'Remainder:',  lv_result.\n\n", "explain": ""}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "F#", "code": "\n\ndo\n  let a, b = int Sys.argv.[1], int Sys.argv.[2]\n  for str, f in [\"+\", ( + ); \"-\", ( - ); \"*\", ( * ); \"/\", ( / ); \"%\", ( % )] do\n    printf \"%d %s %d = %d\\n\" a str b (f a b)\n\n\n4 + 3 = 7\n4 - 3 = 1\n4 * 3 = 12\n4 / 3 = 1\n4 % 3 = 1\n\n", "explain": "As F# is a functional language, we can easily create a list of pairs of the string name of a function and the function itself to iterate over printing the operation and applying the function to obtain the result:\nFor example, the output with the arguments 4 and 3 is:\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "Groovy", "code": "\n\ndef arithmetic = { a, b ->\n    println \"\"\"\n       a + b =        ${a} + ${b} = ${a + b}\n       a - b =        ${a} - ${b} = ${a - b}\n       a * b =        ${a} * ${b} = ${a * b}\n       a / b =        ${a} / ${b} = ${a / b}  \u00a0!!! Converts to floating point!\n(int)(a / b) = (int)(${a} / ${b}) = ${(int)(a / b)}             \u00a0!!! Truncates downward after the fact\n a.intdiv(b) =  ${a}.intdiv(${b}) = ${a.intdiv(b)}             \u00a0!!! Behaves as if truncating downward, actual implementation varies\n       a\u00a0% b =        ${a}\u00a0% ${b} = ${a\u00a0% b}\n\nExponentiation is also a base arithmetic operation in Groovy, so:\n      a ** b =       ${a} ** ${b} = ${a ** b}\n\"\"\"\n}\n\n\narithmetic(5,3)\n\n\nOutput:\n       a + b =        5 + 3 = 8\n       a - b =        5 - 3 = 2\n       a * b =        5 * 3 = 15\n       a / b =        5 / 3 = 1.6666666667  \u00a0!!! Converts to floating point!\n(int)(a / b) = (int)(5 / 3) = 1             \u00a0!!! Truncates downward after the fact\n a.intdiv(b) =  5.intdiv(3) = 1             \u00a0!!! Behaves as if truncating downward, actual implementation varies\n       a\u00a0% b =        5\u00a0% 3 = 2\n\nExponentiation is also a base arithmetic operation in Groovy, so:\n      a ** b =       5 ** 3 = 125\n", "explain": "Solution:\nTest:\n"}, {"task_name": "Arithmetic/Integer", "task_url": "https://rosettacode.org/wiki/Arithmetic/Integer", "task_cat": "Arithmetic", "lang": "AWK", "code": "\n/^[ \\t]*-?[0-9]+[ \\t]+-?[0-9]+[ \\t]*$/ {\n\tprint \"add:\", $1 + $2\n\tprint \"sub:\", $1 - $2\n\tprint \"mul:\", $1 * $2\n\tprint \"div:\", int($1 / $2) # truncates toward zero\n\tprint \"mod:\", $1 % $2      # same sign as first operand\n\tprint \"exp:\", $1 ^ $2\n\texit }\n\n\n", "explain": "For division and modulus, Awk should act like C.\nExponentiation's note: With nawk or gawk, $1 ** $2 acts like $1 ^ $2. With mawk, $1 ** $2 is a syntax error. Nawk allows **, but its manual page only has ^. Gawk's manual warns, \"The POSIX standard only specifies the use of `^' for exponentiation. For maximum portability, do not use the `**' operator.\"\n"}]