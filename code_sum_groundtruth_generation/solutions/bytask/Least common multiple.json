[{"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Python", "code": "\nFunctional[edit]\ngcd[edit]\n\n>>> import fractions\n>>> def lcm(a,b): return abs(a * b) / fractions.gcd(a,b) if a and b else 0\n\n>>> lcm(12, 18)\n36\n>>> lcm(-6, 14)\n42\n>>> assert lcm(0, 2) == lcm(2, 0) == 0\n>>>\n\n\n'''Least common multiple'''\n\nfrom inspect import signature\n\n\n# lcm\u00a0:: Int -> Int -> Int\ndef lcm(x):\n    '''The smallest positive integer divisible\n       without remainder by both x and y.\n    '''\n    return lambda y: 0 if 0 in (x, y) else abs(\n        y * (x // gcd_(x)(y))\n    )\n\n\n# gcd_\u00a0:: Int -> Int -> Int\ndef gcd_(x):\n    '''The greatest common divisor in terms of\n       the divisibility preordering.\n    '''\n    def go(a, b):\n        return go(b, a % b) if 0 != b else a\n    return lambda y: go(abs(x), abs(y))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Tests'''\n\n    print(\n        fTable(\n            __doc__ + 's of 60 and [12..20]:'\n        )(repr)(repr)(\n            lcm(60)\n        )(enumFromTo(12)(20))\n    )\n\n    pairs = [(0, 2), (2, 0), (-6, 14), (12, 18)]\n    print(\n        fTable(\n            '\\n\\n' + __doc__ + 's of ' + repr(pairs) + ':'\n        )(repr)(repr)(\n            uncurry(lcm)\n        )(pairs)\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# uncurry\u00a0:: (a -> b -> c) -> ((a, b) -> c)\ndef uncurry(f):\n    '''A function over a tuple, derived from\n       a vanilla or curried function.\n    '''\n    if 1 < len(signature(f).parameters):\n        return lambda xy: f(*xy)\n    else:\n        return lambda xy: f(xy[0])(xy[1])\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.\n    '''\n    return '\\n'.join(xs)\n\n\n# FORMATTING ----------------------------------------------\n\n# fTable\u00a0:: String -> (a -> String) ->\n#                     (b -> String) -> (a -> b) -> [a] -> String\ndef fTable(s):\n    '''Heading -> x display function -> fx display function ->\n                     f -> xs -> tabular string.\n    '''\n    def go(xShow, fxShow, f, xs):\n        ys = [xShow(x) for x in xs]\n        w = max(map(len, ys))\n        return s + '\\n' + '\\n'.join(map(\n            lambda x, y: y.rjust(w, ' ') + ' -> ' + fxShow(f(x)),\n            xs, ys\n        ))\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nLeast common multiples of 60 and [12..20]:\n12 -> 60\n13 -> 780\n14 -> 420\n15 -> 60\n16 -> 240\n17 -> 1020\n18 -> 180\n19 -> 1140\n20 -> 60\n\nLeast common multiples of [(0, 2), (2, 0), (-6, 14), (12, 18)]:\n  (0, 2) -> 0\n  (2, 0) -> 0\n(-6, 14) -> 42\n(12, 18) -> 36\nProcedural[edit]\nPrime decomposition[edit]\n\nfrom prime_decomposition import decompose\ntry:\n    reduce\nexcept NameError:\n    from functools import reduce\n    \ndef lcm(a, b):\n    mul = int.__mul__\n    if a and b:\n        da = list(decompose(abs(a)))\n        db = list(decompose(abs(b)))\n        merge= da\n        for d in da:\n            if d in db: db.remove(d)\n        merge += db\n        return reduce(mul, merge, 1)\n    return 0\n \nif __name__ == '__main__':\n    print( lcm(12, 18) )    # 36\n    print( lcm(-6, 14) )    # 42\n    assert lcm(0, 2) == lcm(2, 0) == 0\n\nIteration over multiples[edit]\n>>> def lcm(*values):\n\tvalues = set([abs(int(v)) for v in values])\n\tif values and 0 not in values:\n\t\tn = n0 = max(values)\n\t\tvalues.remove(n)\n\t\twhile any( n % m for m in values ):\n\t\t\tn += n0\n\t\treturn n\n\treturn 0\n\n>>> lcm(-6, 14)\n42\n>>> lcm(2, 0)\n0\n>>> lcm(12, 18)\n36\n>>> lcm(12, 18, 22)\n396\n>>>\n\nRepeated modulo[edit]\nTranslation of: Tcl\n>>> def lcm(p,q):\n\tp, q = abs(p), abs(q)\n\tm = p * q\n\tif not m: return 0\n\twhile True:\n\t\tp %= q\n\t\tif not p: return m // q\n\t\tq %= p\n\t\tif not q: return m // p\n\n\t\t\n>>> lcm(-6, 14)\n42\n>>> lcm(12, 18)\n36\n>>> lcm(2, 0)\n0\n>>>\n\n", "explain": "Using the fractions libraries gcd function:\nOr, for compositional flexibility, a curried lcm, expressed in terms of our own gcd function:\nThis imports Prime decomposition#Python\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "C", "code": "\n#include <stdio.h>\n\nint gcd(int m, int n)\n{\n        int tmp;\n        while(m) { tmp = m; m = n % m; n = tmp; }       \n        return n;\n}\n\nint lcm(int m, int n)\n{\n        return m / gcd(m, n) * n;\n}\n\nint main()\n{\n        printf(\"lcm(35, 21) = %d\\n\", lcm(21,35));\n        return 0;\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "C++", "code": "\nLibrary: Boost\n#include <boost/math/common_factor.hpp>\n#include <iostream>\n\nint main( ) {\n   std::cout << \"The least common multiple of 12 and 18 is \" << \n      boost::math::lcm( 12 , 18 ) << \" ,\\n\"\n      << \"and the greatest common divisor \" << boost::math::gcd( 12 , 18 ) << \"\u00a0!\" << std::endl ;\n   return 0 ;\n}\n\n\nOutput:\nThe least common multiple of 12 and 18 is 36 ,\nand the greatest common divisor 6\u00a0!\n\nAlternate solution[edit]\nWorks with: C++11\n#include <cstdlib>\n#include <iostream>\n#include <tuple>\n \nint gcd(int a, int b) {\n    a = abs(a);\n    b = abs(b);\n    while (b != 0) {\n        std::tie(a, b) = std::make_tuple(b, a % b);\n    }\n    return a;\n}\n \nint lcm(int a, int b) {\n    int c = gcd(a, b);\n    return c == 0 ? 0 : a / c * b;\n}\n \nint main() {\n    std::cout << \"The least common multiple of 12 and 18 is \" << lcm(12, 18) << \",\\n\"\n        << \"and their greatest common divisor is \" << gcd(12, 18) << \"!\" \n        << std::endl;\n    return 0;\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Java", "code": "\nimport java.util.Scanner;\n\npublic class LCM{\n   public static void main(String[] args){\n      Scanner aScanner = new Scanner(System.in);\n   \n      //prompts user for values to find the LCM for, then saves them to m and n\n      System.out.print(\"Enter the value of m:\");\n      int m = aScanner.nextInt();\n      System.out.print(\"Enter the value of n:\");\n      int n = aScanner.nextInt();\n      int lcm = (n == m || n == 1) ? m :(m == 1 ? n : 0);\n      /* this section increases the value of mm until it is greater  \n      / than or equal to nn, then does it again when the lesser \n      / becomes the greater--if they aren't equal. If either value is 1,\n      / no need to calculate*/\n      if (lcm == 0) {\n         int mm = m, nn = n;\n         while (mm != nn) {\n             while (mm < nn) { mm += m; }\n             while (nn < mm) { nn += n; }\n         }  \n         lcm = mm;\n      }\n      System.out.println(\"lcm(\" + m + \", \" + n + \") = \" + lcm);\n   }\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "C#", "code": "\nUsing System;\nclass Program\n{\n    static int gcd(int m, int n)\n    {\n        return n == 0 ? Math.Abs(m) : gcd(n, n % m);\n    }\n    static int lcm(int m, int n)\n    {\n        return Math.Abs(m * n) / gcd(m, n);\n    }\n    static void Main()\n    {\n        Console.WriteLine(\"lcm(12,18)=\" + lcm(12,18));\n    }\n}\n\n\nOutput:\nlcm(12,18)=36\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "JavaScript", "code": "\nES5[edit]\n\nfunction LCM(A)  // A is an integer array (e.g. [-50,25,-45,-18,90,447])\n{   \n    var n = A.length, a = Math.abs(A[0]);\n    for (var i = 1; i < n; i++)\n     { var b = Math.abs(A[i]), c = a;\n       while (a && b){ a > b ? a %= b : b %= a; } \n       a = Math.abs(c*A[i])/(a+b);\n     }\n    return a;\n}\n\n/* For example:\n   LCM([-50,25,-45,-18,90,447]) -> 67050\n*/\n\n\nES6[edit]\nTranslation of: Haskell\n(() => {\n    'use strict';\n\n    // gcd\u00a0:: Integral a => a -> a -> a\n    let gcd = (x, y) => {\n        let _gcd = (a, b) => (b === 0 ? a : _gcd(b, a % b)),\n            abs = Math.abs;\n        return _gcd(abs(x), abs(y));\n    }\n\n    // lcm\u00a0:: Integral a => a -> a -> a\n    let lcm = (x, y) =>\n        x === 0 || y === 0 ? 0 : Math.abs(Math.floor(x / gcd(x, y)) * y);\n\n    // TEST\n    return lcm(12, 18);\n\n})();\n\n\nOutput:\n36\n", "explain": "Computing the least common multiple of an integer array, using the associative law:\n\n\n\n\nlcm\n\u2061\n(\na\n,\nb\n,\nc\n)\n=\nlcm\n\u2061\n(\nlcm\n\u2061\n(\na\n,\nb\n)\n,\nc\n)\n,\n\n\n{\\displaystyle \\operatorname{lcm}(a,b,c)=\\operatorname{lcm}(\\operatorname{lcm}(a,b),c),}\n\n\n\n\n\n\nlcm\n\u2061\n(\n\na\n1\n\n,\n\na\n2\n\n,\n\u2026\n,\n\na\nn\n\n)\n=\nlcm\n\u2061\n(\nlcm\n\u2061\n(\n\na\n1\n\n,\n\na\n2\n\n,\n\u2026\n,\n\na\n\nn\n\u2212\n1\n\n\n)\n,\n\na\nn\n\n)\n.\n\n\n{\\displaystyle \\operatorname{lcm}(a_1,a_2,\\ldots,a_n) = \\operatorname{lcm}(\\operatorname{lcm}(a_1,a_2,\\ldots,a_{n-1}),a_n).}\n\n\n\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "PHP", "code": "\nTranslation of: D\necho lcm(12, 18) == 36;\n\nfunction lcm($m, $n) {\n    if ($m == 0 || $n == 0) return 0;\n    $r = ($m * $n) / gcd($m, $n);\n    return abs($r);\n}\n\nfunction gcd($a, $b) {\n    while ($b != 0) {\n        $t = $b;\n        $b = $a % $b;\n        $a = $t;\n    }\n    return $a;\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Fortran", "code": "\n\n    integer function lcm(a,b)\n    integer:: a,b\n        lcm = a*b / gcd(a,b)\n    end function lcm\n\n    integer function gcd(a,b)\n    integer :: a,b,t\n        do while (b/=0)\n            t = b\n            b = mod(a,b)\n            a = t\n        end do\n        gcd = abs(a)\n    end function gcd\n\n", "explain": "This solution is written as a combination of 2 functions, but a subroutine implementation would work great as well. \n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"math/big\"\n)\n\nvar m, n, z big.Int\n\nfunc init() {\n    m.SetString(\"2562047788015215500854906332309589561\", 10)\n    n.SetString(\"6795454494268282920431565661684282819\", 10)\n}\n\nfunc main() {\n    fmt.Println(z.Mul(z.Div(&m, z.GCD(nil, nil, &m, &n)), &n))\n}\n\n\nOutput:\n15669251240038298262232125175172002594731206081193527869\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Ruby", "code": "\n\nirb(main):001:0> 12.lcm 18\n=> 36\n\n\ndef gcd(m, n)\n  m, n = n, m % n until n.zero?\n  m.abs\nend\n\ndef lcm(*args)\n  args.inject(1) do |m, n|\n    return 0 if n.zero?\n    (m * n).abs / gcd(m, n)\n  end\nend\n\np lcm 12, 18, 22\np lcm 15, 14, -6, 10, 21\n\n\nOutput:\n396\n210\n\n", "explain": "Ruby has an Integer#lcm method, which finds the least common multiple of two integers.\nI can also write my own lcm method. This one takes any number of arguments.\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Rust", "code": "\n\nuse std::cmp::{max, min};\n\nfn gcd(a: usize, b: usize) -> usize {\n    match ((a, b), (a & 1, b & 1)) {\n        ((x, y), _) if x == y => y,\n        ((0, x), _) | ((x, 0), _) => x,\n        ((x, y), (0, 1)) | ((y, x), (1, 0)) => gcd(x >> 1, y),\n        ((x, y), (0, 0)) => gcd(x >> 1, y >> 1) << 1,\n        ((x, y), (1, 1)) => {\n            let (x, y) = (min(x, y), max(x, y));\n            gcd((y - x) >> 1, x)\n        }\n        _ => unreachable!(),\n    }\n}\n\nfn lcm(a: usize, b: usize) -> usize {\n    a * b / gcd(a, b)\n}\n\nfn main() {\n    println!(\"{}\", lcm(6324, 234))\n}\n\n", "explain": "This implementation uses a recursive implementation of Stein's algorithm to calculate the gcd.\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Swift", "code": "\n\nfunc lcm(a:Int, b:Int) -> Int {\n    return abs(a * b) / gcd_rec(a, b)\n}\n\n", "explain": "Using the Swift GCD function.\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "R", "code": "\n\"%gcd%\" <- function(u, v) {ifelse(u %% v != 0, v %gcd% (u%%v), v)}\n\n\"%lcm%\" <- function(u, v) { abs(u*v)/(u %gcd% v)}\n\nprint (50 %lcm% 75)\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. show-lcm.\n\n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION lcm\n           .\n       PROCEDURE DIVISION.\n           DISPLAY \"lcm(35, 21) = \" FUNCTION lcm(35, 21)\n           GOBACK\n           .\n       END PROGRAM show-lcm.\n\n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. lcm.\n       \n       ENVIRONMENT DIVISION.\n       CONFIGURATION SECTION.\n       REPOSITORY.\n           FUNCTION gcd\n           .\n       DATA DIVISION.\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           COMPUTE ret = FUNCTION ABS(m * n) / FUNCTION gcd(m, n)\n           GOBACK\n           .\n       END FUNCTION lcm.\n           \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. gcd.\n\n       DATA DIVISION.\n       LOCAL-STORAGE SECTION.\n       01  temp                    PIC S9(8).\n\n       01  x                       PIC S9(8).\n       01  y                       PIC S9(8).\n\n       LINKAGE SECTION.\n       01  m                       PIC S9(8).\n       01  n                       PIC S9(8).\n       01  ret                     PIC S9(8).\n\n       PROCEDURE DIVISION USING VALUE m, n RETURNING ret.\n           MOVE m to x\n           MOVE n to y\n\n           PERFORM UNTIL y = 0\n               MOVE x TO temp\n               MOVE y TO x\n               MOVE FUNCTION MOD(temp, y) TO Y\n           END-PERFORM\n\n           MOVE FUNCTION ABS(x) TO ret\n           GOBACK\n           .\n       END FUNCTION gcd.\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Ada", "code": "\n\nwith Ada.Text_IO; use Ada.Text_IO;\n\nprocedure Lcm_Test is\n   function Gcd (A, B : Integer) return Integer is\n      M : Integer := A;\n      N : Integer := B;\n      T : Integer;\n   begin\n      while N /= 0 loop\n         T := M;\n         M := N;\n         N := T mod N;\n      end loop;\n      return M;\n   end Gcd;\n\n   function Lcm (A, B : Integer) return Integer is\n   begin\n      if A = 0 or B = 0 then\n         return 0;\n      end if;\n      return abs (A) * (abs (B) / Gcd (A, B));\n   end Lcm;\nbegin\n   Put_Line (\"LCM of 12, 18 is\" & Integer'Image (Lcm (12, 18)));\n   Put_Line (\"LCM of -6, 14 is\" & Integer'Image (Lcm (-6, 14)));\n   Put_Line (\"LCM of 35, 0 is\" & Integer'Image (Lcm (35, 0)));\nend Lcm_Test;\n\n\nLCM of 12, 18 is 36\nLCM of -6, 14 is 42\nLCM of 35, 0 is 0\n", "explain": "lcm_test.adb:\nOutput:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Julia", "code": "\n\nlcm(m,n)\n\n", "explain": "Built-in function:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Kotlin", "code": "\nfun main(args: Array<String>) {\n    fun gcd(a: Long, b: Long): Long = if (b == 0L) a else gcd(b, a % b)\n    fun lcm(a: Long, b: Long): Long = a / gcd(a, b) * b\n    println(lcm(15, 9))\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Perl", "code": "\n\nsub gcd {\n\tmy ($x, $y) = @_;\n\twhile ($x) { ($x, $y) = ($y % $x, $x) }\n\t$y\n}\n\nsub lcm {\n\tmy ($x, $y) = @_;\n\t($x && $y) and $x / gcd($x, $y) * $y or 0\n}\n\nprint lcm(1001, 221);\n\nOr by repeatedly increasing the smaller of the two until LCM is reached:sub lcm {\n\tuse integer;\n\tmy ($x, $y) = @_;\n\tmy ($f, $s) = @_;\n\twhile ($f != $s) {\n\t\t($f, $s, $x, $y) = ($s, $f, $y, $x) if $f > $s;\n\t\t$f = $s / $x * $x;\n\t\t$f += $x if $f < $s;\n\t}\n\t$f\n}\n\nprint lcm(1001, 221);\n\n", "explain": "Using GCD:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Prolog", "code": "\n\nlcm(X, Y, Z) :-\n\tZ is abs(X * Y) / gcd(X,Y).\n\n\n\u00a0?- lcm(18,12, Z).\nZ = 36.\n\n", "explain": "SWI-Prolog knows gcd.\nExample:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Lua", "code": "\nfunction gcd( m, n )\n    while n ~= 0 do\n        local q = m\n        m = n\n        n = q % n\n    end\n    return m\nend\n\nfunction lcm( m, n )\n    return ( m ~= 0 and n ~= 0 ) and m * n / gcd( m, n ) or 0\nend\n\nprint( lcm(12,18) )\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Scala", "code": "\ndef gcd(a: Int, b: Int):Int=if (b==0) a.abs else gcd(b, a%b)\ndef lcm(a: Int, b: Int)=(a*b).abs/gcd(a,b)\n\nlcm(12, 18)   // 36\nlcm( 2,  0)   // 0\nlcm(-6, 14)   // 42\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Dart", "code": "\nmain() {\n\tint x=8;\n  int y=12;\nint z= gcd(x,y);\n  var lcm=(x*y)/z;\n  print('$lcm');\n  }\n\nint gcd(int a,int b)\n{\n  if(b==0)\n    return a;\n  if(b!=0)\n    return gcd(b,a%b);\n}\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "D", "code": "\nimport std.stdio, std.bigint, std.math;\n\nT gcd(T)(T a, T b) pure nothrow {\n    while (b) {\n        immutable t = b;\n        b = a % b;\n        a = t;\n    }\n    return a;\n}\n\nT lcm(T)(T m, T n) pure nothrow {\n    if (m == 0) return m;\n    if (n == 0) return n;\n    return abs((m * n) / gcd(m, n));\n}\n\nvoid main() {\n    lcm(12, 18).writeln;\n    lcm(\"2562047788015215500854906332309589561\".BigInt,\n        \"6795454494268282920431565661684282819\".BigInt).writeln;\n}\n\n\nOutput:\n36\n15669251240038298262232125175172002594731206081193527869\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Haskell", "code": "\n\nlcm :: (Integral a) => a -> a -> a\nlcm _ 0 =  0\nlcm 0 _ =  0\nlcm x y =  abs ((x `quot` (gcd x y)) * y)\n\n", "explain": "That is already available as the function lcm in the Prelude. Here's the implementation:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "VBScript", "code": "\nFunction LCM(a,b)\n\tLCM = POS((a * b)/GCD(a,b))\nEnd Function\n\nFunction GCD(a,b)\n\tDo\n\t\tIf a Mod b > 0 Then\n\t\t\tc = a Mod b\n\t\t\ta = b\n\t\t\tb = c\n\t\tElse\n\t\t\tGCD = b\n\t\t\tExit Do\n\t\tEnd If\n\tLoop\nEnd Function\n\nFunction POS(n)\n\tIf n < 0 Then\n\t\tPOS = n * -1\n\tElse\n\t\tPOS = n\n\tEnd If\nEnd Function\n\ni = WScript.Arguments(0)\nj = WScript.Arguments(1)\n\nWScript.StdOut.Write \"The LCM of \" & i & \" and \" & j & \" is \" & LCM(i,j) & \".\"\nWScript.StdOut.WriteLine\n\nOutput:\nC:\\>cscript /nologo lcm.vbs 12 18\nThe LCM of 12 and 18 is 36.\n\nC:\\>cscript /nologo lcm.vbs 14 -6\nThe LCM of 14 and -6 is 42.\n\nC:\\>cscript /nologo lcm.vbs 0 35\nThe LCM of 0 and 35 is 0.\n\nC:\\>\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Scheme", "code": "\n>(define gcd (lambda (a b)\n         (if (zero? b)\n             a\n             (gcd b (remainder a b)))))\n>(define lcm (lambda (a b)\n         (if (or (zero? a) (zero? b))\n             0\n             (abs (* b (floor (/ a (gcd a b))))))))\n>(lcm 12 18)\n36\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "TypeScript", "code": "\nTranslation of: C\n// Least common multiple\n\nfunction gcd(m: number, n: number): number {\n  var tmp: number;\n  while (m != 0) {\n    tmp = m;\n    m = n % m;\n    n = tmp;\n  }\n  return n;\n}\n\nfunction lcm(m: number, n: number): number {\n    return Math.floor(m / gcd(m, n)) * n;\n} \n\nconsole.log(`LCM(35, 21) = ${lcm(35, 21)}`);\n\n\nOutput:\nLCM(35, 21) = 105\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "PowerShell", "code": "\nversion 1[edit]\nfunction gcd ($a, $b)  {\n    function pgcd ($n, $m)  {\n        if($n -le $m) { \n            if($n -eq 0) {$m}\n            else{pgcd $n ($m-$n)}\n        }\n        else {pgcd $m $n}\n    }\n    $n = [Math]::Abs($a)\n    $m = [Math]::Abs($b)\n    (pgcd $n $m)\n}\nfunction lcm ($a, $b)  {\n    [Math]::Abs($a*$b)/(gcd $a $b)\n}\nlcm 12 18\n\nversion 2[edit]\n\nfunction gcd ($a, $b)  {\n    function pgcd ($n, $m)  {\n        if($n -le $m) { \n            if($n -eq 0) {$m}\n            else{pgcd $n ($m%$n)}\n        }\n        else {pgcd $m $n}\n    }\n    $n = [Math]::Abs($a)\n    $m = [Math]::Abs($b)\n    (pgcd $n $m)\n}\nfunction lcm ($a, $b)  {\n    [Math]::Abs($a*$b)/(gcd $a $b)\n}\nlcm 12 18\n\n\n36\n\n", "explain": "version2 is faster than version1\nOutput:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Logo", "code": "\nto abs :n\n  output sqrt product :n :n\nend\n\nto gcd :m :n\n  output ifelse :n = 0 [ :m ] [ gcd :n modulo :m :n ]\nend\n\nto lcm :m :n\n  output quotient (abs product :m :n) gcd :m :n\nend\n\nprint lcm 38 46\n\n874\n", "explain": "Demo code:\nOutput:\n"}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "F#", "code": "\nlet rec gcd x y = if y = 0 then abs x else gcd y (x % y)\n\nlet lcm x y = x * y / (gcd x y)\n\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "Groovy", "code": "\ndef gcd\ngcd = { m, n -> m = m.abs(); n = n.abs(); n == 0 ? m : m%n == 0 ? n : gcd(n, m % n) }\n\ndef lcd = { m, n -> Math.abs(m * n) / gcd(m, n) }\n\n[[m: 12, n: 18, l: 36],\n [m: -6, n: 14, l: 42],\n [m: 35, n: 0, l: 0]].each { t ->\n    println \"LCD of $t.m, $t.n is $t.l\"\n    assert lcd(t.m, t.n) == t.l\n}\n\n\nOutput:\nLCD of 12, 18 is 36\nLCD of -6, 14 is 42\nLCD of 35, 0 is 0\n", "explain": ""}, {"task_name": "Least common multiple", "task_url": "https://rosettacode.org/wiki/Least_common_multiple", "task_cat": "Recursion", "lang": "AWK", "code": "\n# greatest common divisor\nfunction gcd(m, n,    t) {\n\t# Euclid's method\n\twhile (n != 0) {\n\t\tt = m\n\t\tm = n\n\t\tn = t % n\n\t}\n\treturn m\n}\n\n# least common multiple\nfunction lcm(m, n,    r) {\n\tif (m == 0 || n == 0)\n\t\treturn 0\n\tr = m * n / gcd(m, n)\n\treturn r < 0 ? -r : r\n}\n\n# Read two integers from each line of input.\n# Print their least common multiple.\n{ print lcm($1, $2) }\n\nExample input and output: $ awk -f lcd.awk\n12 18\n36\n-6 14\n42\n35 0\n0\n\n", "explain": ""}]