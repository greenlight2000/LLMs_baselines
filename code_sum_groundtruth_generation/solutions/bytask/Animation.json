[{"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Python", "code": "\nUsing PyQt[edit]\nLibrary: PyQt5\n#!/usr/bin/env python3\nimport sys\n\nfrom PyQt5.QtCore import QBasicTimer, Qt\nfrom PyQt5.QtGui import QFont\nfrom PyQt5.QtWidgets import QApplication, QLabel\n\n\nclass Marquee(QLabel):\n    def __init__(self, **kwargs):\n        super().__init__(**kwargs)\n        self.right_to_left_direction = True\n        self.initUI()\n        self.timer = QBasicTimer()\n        self.timer.start(80, self)\n\n    def initUI(self):\n        self.setWindowFlags(Qt.FramelessWindowHint)\n        self.setAttribute(Qt.WA_TranslucentBackground)\n        self.setText(\"Hello World! \")\n        self.setFont(QFont(None, 50, QFont.Bold))\n        # make more irritating for the authenticity with <marquee> element\n        self.setStyleSheet(\"QLabel {color: cyan; }\")\n\n    def timerEvent(self, event):\n        i = 1 if self.right_to_left_direction else -1\n        self.setText(self.text()[i:] + self.text()[:i])  # rotate\n\n    def mouseReleaseEvent(self, event):  # change direction on mouse release\n        self.right_to_left_direction = not self.right_to_left_direction\n\n    def keyPressEvent(self, event):  # exit on Esc\n        if event.key() == Qt.Key_Escape:\n            self.close()\n\n\napp = QApplication(sys.argv)\nw = Marquee()\n# center widget on the screen\nw.adjustSize()  # update w.rect() now\nw.move(QApplication.instance().desktop().screen().rect().center()\n       - w.rect().center())\nw.show()\nsys.exit(app.exec())\n\nUsing pygame[edit]\nLibrary: pygame\nimport pygame, sys\nfrom pygame.locals import *\npygame.init()\n\nYSIZE = 40\nXSIZE = 150\n\nTEXT = \"Hello World! \"\nFONTSIZE = 32\n\nLEFT = False\nRIGHT = True\n\nDIR = RIGHT\n\nTIMETICK = 180\nTICK = USEREVENT + 2\n\nTEXTBOX = pygame.Rect(10,10,XSIZE,YSIZE)\n\npygame.time.set_timer(TICK, TIMETICK)\n\nwindow = pygame.display.set_mode((XSIZE, YSIZE))\npygame.display.set_caption(\"Animation\")\n\nfont = pygame.font.SysFont(None, FONTSIZE)\nscreen = pygame.display.get_surface()\n\ndef rotate():\n    index = DIR and -1 or 1\n    global TEXT\n    TEXT = TEXT[index:]+TEXT[:index]\n\ndef click(position):\n    if TEXTBOX.collidepoint(position):\n        global DIR\n        DIR = not DIR\n\ndef draw():\n    surface = font.render(TEXT, True, (255,255,255), (0,0,0))\n    global TEXTBOX\n    TEXTBOX = screen.blit(surface, TEXTBOX)\n    \ndef input(event):\n    if event.type == QUIT:\n        sys.exit(0)\n    elif event.type == MOUSEBUTTONDOWN:\n        click(event.pos)\n    elif event.type == TICK:\n        draw()\n        rotate()\n\nwhile True:\n    input(pygame.event.wait())\n    pygame.display.flip()\n\nUsing Tkinter[edit]\nimport Tkinter as tki\n\ndef scroll_text(s, how_many):\n    return s[how_many:] + s[:how_many]\n\ndirection = 1\ntk = tki.Tk()\nvar = tki.Variable(tk)\n\ndef mouse_handler(point):\n    global direction\n    direction *= -1\n\ndef timer_handler():\n    var.set(scroll_text(var.get(),direction))\n    tk.after(125, timer_handler)\n\nvar.set('Hello, World! ')\ntki.Label(tk, textvariable=var).pack()\ntk.bind(\"<Button-1>\", mouse_handler)\ntk.after(125, timer_handler)\ntk.title('Python Animation')\ntki.mainloop()\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "C", "code": "\nLibrary: GTK\n\n#include <stdlib.h>\n#include <string.h>\n#include <gtk/gtk.h>\n\nconst gchar *hello = \"Hello World! \";\ngint direction = -1;\ngint cx=0;\ngint slen=0;\n\nGtkLabel *label;\n\nvoid change_dir(GtkLayout *o, gpointer d)\n{\n  direction = -direction;\n}\n\ngchar *rotateby(const gchar *t, gint q, gint l)\n{\n  gint i, cl = l, j;\n  gchar *r = malloc(l+1);\n  for(i=q, j=0; cl > 0; cl--, i = (i + 1)%l, j++)\n    r[j] = t[i];\n  r[l] = 0;\n  return r;\n}\n\ngboolean scroll_it(gpointer data)\n{\n  if ( direction > 0 )\n    cx = (cx + 1) % slen;\n  else\n    cx = (cx + slen - 1 ) % slen;\n  gchar *scrolled = rotateby(hello, cx, slen);\n  gtk_label_set_text(label, scrolled);\n  free(scrolled);\n  return TRUE;\n}\n\n\nint main(int argc, char **argv)\n{\n  GtkWidget *win;\n  GtkButton *button;\n  PangoFontDescription *pd;\n\n  gtk_init(&argc, &argv);\n  win = gtk_window_new(GTK_WINDOW_TOPLEVEL);\n  gtk_window_set_title(GTK_WINDOW(win), \"Basic Animation\");\n  g_signal_connect(G_OBJECT(win), \"delete-event\", gtk_main_quit, NULL);\n\n  label = (GtkLabel *)gtk_label_new(hello);\n\n  // since we shift a whole character per time, it's better to use\n  // a monospace font, so that the shifting seems done at the same pace\n  pd = pango_font_description_new();\n  pango_font_description_set_family(pd, \"monospace\");\n  gtk_widget_modify_font(GTK_WIDGET(label), pd);\n\n  button = (GtkButton *)gtk_button_new();\n  gtk_container_add(GTK_CONTAINER(button), GTK_WIDGET(label));\n\n  gtk_container_add(GTK_CONTAINER(win), GTK_WIDGET(button));\n  g_signal_connect(G_OBJECT(button), \"clicked\", G_CALLBACK(change_dir), NULL);\n\n  slen = strlen(hello);\n\n  g_timeout_add(125, scroll_it, NULL);\n  \n  gtk_widget_show_all(GTK_WIDGET(win));\n  gtk_main();\n  return 0;\n}\n\n", "explain": "(NB: implicitly, through GTK, it uses also Pango library)\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "C++", "code": "\nLibrary: Qt\n\n#include \"animationwidget.h\"\n\n#include <QLabel>\n#include <QTimer>\n#include <QVBoxLayout>\n\n#include <algorithm>\n\nAnimationWidget::AnimationWidget(QWidget *parent) : QWidget(parent) {\n    setWindowTitle(tr(\"Animation\"));\n    QFont font(\"Courier\", 24);\n    QLabel* label = new QLabel(\"Hello World! \");\n    label->setFont(font);\n    QVBoxLayout* layout = new QVBoxLayout(this);\n    layout->addWidget(label);\n    QTimer* timer = new QTimer(this);\n    connect(timer, &QTimer::timeout, this, [label,this]() {\n        QString text = label->text();\n        std::rotate(text.begin(), text.begin() + (right_ ? text.length() - 1 : 1), text.end());\n        label->setText(text);\n    });\n    timer->start(200);\n}\n\nvoid AnimationWidget::mousePressEvent(QMouseEvent*) {\n    right_ = !right_;\n}\n\n\n#ifndef ANIMATIONWIDGET_H\n#define ANIMATIONWIDGET_H\n\n#include <QWidget>\n\nclass AnimationWidget : public QWidget {\n    Q_OBJECT\npublic:\n    AnimationWidget(QWidget *parent = nullptr);\nprotected:\n    void mousePressEvent(QMouseEvent *event) override;\nprivate:\n    bool right_ = true;\n};\n\n#endif // ANIMATIONWIDGET_H\n\n\n#include \"animationwidget.h\"\n\n#include <QApplication>\n\nint main(int argc, char *argv[]) {\n    QApplication a(argc, argv);\n    AnimationWidget w;\n    w.show();\n    return a.exec();\n}\n\n", "explain": "Contents of animationwidget.cpp:\nContents of animationwidget.h:\nContents of main.cpp:\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Java", "code": "\nLibrary: Swing\nimport java.awt.event.MouseAdapter;\nimport java.awt.event.MouseEvent;\nimport java.awt.event.WindowAdapter;\nimport java.awt.event.WindowEvent;\nimport java.util.Timer;\nimport java.util.TimerTask;\nimport javax.swing.JFrame;\nimport javax.swing.JLabel;\nimport javax.swing.WindowConstants;\n\npublic class Rotate {\n\n    private static class State {\n        private final String text = \"Hello World! \";\n        private int startIndex = 0;\n        private boolean rotateRight = true;\n    }\n\n    public static void main(String[] args) {\n        State state = new State();\n\n        JLabel label = new JLabel(state.text);\n        label.addMouseListener(new MouseAdapter() {\n            @Override\n            public void mouseClicked(MouseEvent event) {\n                state.rotateRight = !state.rotateRight;\n            }\n        });\n\n        TimerTask task = new TimerTask() {\n            public void run() {\n                int delta = state.rotateRight ? 1 : -1;\n                state.startIndex = (state.startIndex + state.text.length() + delta) % state.text.length();\n                label.setText(rotate(state.text, state.startIndex));\n            }\n        };\n        Timer timer = new Timer(false);\n        timer.schedule(task, 0, 500);\n\n        JFrame rot = new JFrame();\n        rot.setDefaultCloseOperation(WindowConstants.DISPOSE_ON_CLOSE);\n        rot.add(label);\n        rot.pack();\n        rot.setLocationRelativeTo(null);\n        rot.addWindowListener(new WindowAdapter() {\n            @Override\n            public void windowClosed(WindowEvent e) {\n                timer.cancel();\n            }\n        });\n        rot.setVisible(true);\n    }\n\n    private static String rotate(String text, int startIdx) {\n        char[] rotated = new char[text.length()];\n        for (int i = 0; i < text.length(); i++) {\n            rotated[i] = text.charAt((i + startIdx) % text.length());\n        }\n        return String.valueOf(rotated);\n    }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "C#", "code": "\nusing System;\nusing System.Drawing;\nusing System.Windows.Forms;\n\nnamespace BasicAnimation\n{\n  class BasicAnimationForm : Form\n  {\n    bool isReverseDirection;\n    Label textLabel;\n    Timer timer;\n\n    internal BasicAnimationForm()\n    {\n      this.Size = new Size(150, 75);\n      this.Text = \"Basic Animation\";\n\n      textLabel = new Label();\n      textLabel.Text = \"Hello World! \";\n      textLabel.Location = new Point(3,3);\n      textLabel.AutoSize = true;\n      textLabel.Click += new EventHandler(textLabel_OnClick);\n      this.Controls.Add(textLabel);\n\n      timer = new Timer();\n      timer.Interval = 500;\n      timer.Tick += new EventHandler(timer_OnTick);\n      timer.Enabled = true;\n\n      isReverseDirection = false;\n    }\n\n    private void timer_OnTick(object sender, EventArgs e)\n    {\n      string oldText = textLabel.Text, newText;\n      if(isReverseDirection)\n        newText = oldText.Substring(1, oldText.Length - 1) + oldText.Substring(0, 1);\n      else\n        newText = oldText.Substring(oldText.Length - 1, 1) + oldText.Substring(0, oldText.Length - 1);\n      textLabel.Text = newText;\n    }\n\n    private void textLabel_OnClick(object sender, EventArgs e)\n    {\n      isReverseDirection = !isReverseDirection;\n    }\n  }\n\n   class Program\n   {\n      static void Main()\n      {\n\tApplication.Run(new BasicAnimationForm());\n      }\n   }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Scratch", "code": "\n\n", "explain": "Scratch is event and animation oriented, so this is a natural task for this language.  This solution is hosted at the scratch website, where one can see it in action and read its code.\nSolution Summary and Comments\nThe solution consists of two blocks of code.  The main block initializes variables upon invocation and sets up a loop to display the crawling \"Hello World! \" message.  The crawl is accomplished by manipulation of the list containing the message as individual characters.  The other block of code is attached to the scratch sprite, and all it does is change the direction of the text crawl when the sprite is clicked.\nI tried a couple of techniques for introducing a delay into the text crawl loop.  The command \"Say message for 2 seconds\" resulted in poor performance; the application's response to clicks was spotty.  Using the timer and waiting for it to exceed 2 seconds before resetting it and advancing the crawl worked much better.  (I also tried waiting for the timer to equal 2 seconds, and unsurprisingly this resulted in an application freeze-up.)\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"log\"\n    \"time\"\n\n    \"github.com/gdamore/tcell\"\n)\n\nconst (\n    msg             = \"Hello World! \"\n    x0, y0          = 8, 3\n    shiftsPerSecond = 4\n    clicksToExit    = 5\n)\n\nfunc main() {\n    s, err := tcell.NewScreen()\n    if err != nil {\n        log.Fatal(err)\n    }\n    if err = s.Init(); err != nil {\n        log.Fatal(err)\n    }\n    s.Clear()\n    s.EnableMouse()\n    tick := time.Tick(time.Second / shiftsPerSecond)\n    click := make(chan bool)\n    go func() {\n        for {\n            em, ok := s.PollEvent().(*tcell.EventMouse)\n            if !ok || em.Buttons()&0xFF == tcell.ButtonNone {\n                continue\n            }\n            mx, my := em.Position()\n            if my == y0 && mx >= x0 && mx < x0+len(msg) {\n                click <- true\n            }\n        }\n    }()\n    for inc, shift, clicks := 1, 0, 0; ; {\n        select {\n        case <-tick:\n            shift = (shift + inc) % len(msg)\n            for i, r := range msg {\n                s.SetContent(x0+((shift+i)%len(msg)), y0, r, nil, 0)\n            }\n            s.Show()\n        case <-click:\n            clicks++\n            if clicks == clicksToExit {\n                s.Fini()\n                return\n            }\n            inc = len(msg) - inc\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI or android 32 bits with termux application */\n/*  program animLetter.s        */\n\n/* compile with as         */\n/* link with gcc and options -lX11 -L/usr/lpp/X11/lib   */\n\n/* REMARK: This program was written for android with the termux app.\n It works very well on raspberry pi but in this case the memory access relocation instructions \n can be simplified.\n*/\n\n /* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n/********************************************/\n/*Constantes                                */\n/********************************************/\n.equ STDOUT,              1     @ Linux output console\n.equ EXIT,                1     @ Linux syscall\n.equ WRITE,               4     @ Linux syscall\n/* constantes X11 */\n.equ KeyPressed,          2\n.equ ButtonPress,         4\n.equ MotionNotify,        6\n.equ EnterNotify,         7\n.equ LeaveNotify,         8\n.equ Expose,              12\n.equ ClientMessage,       33\n.equ KeyPressMask,        1\n.equ ButtonPressMask,     4\n.equ ButtonReleaseMask,   8\n.equ ExposureMask,        1<<15\n.equ StructureNotifyMask, 1<<17\n.equ EnterWindowMask,     1<<4\n.equ LeaveWindowMask,     1<<5 \n.equ ConfigureNotify,     22\n\n.equ GCForeground,        1<<2\n.equ GCFont,              1<<14\n\n/* constantes program */\n.equ WINDOWWIDTH,       400\n.equ WINDOWHEIGHT,      300\n\n/*******************************************/\n/* DONNEES INITIALISEES                    */\n/*******************************************/ \n.data\nszWindowName:            .asciz \"Windows Raspberry\"\nszRetourligne:           .asciz  \"\\n\"\nszMessDebutPgm:          .asciz \"Program start. \\n\"\nszMessErreur:            .asciz \"Server X not found.\\n\"\nszMessErrfen:            .asciz \"Can not create window.\\n\"\nszMessErreurX11:         .asciz \"Error call function X11. \\n\"\nszMessErrGc:             .asciz \"Can not create graphics context.\\n\"\nszMessErrFont:           .asciz \"Font not found.\\n\"\nszTitreFenRed:           .asciz \"Pi\"    \nszTexte1:                .asciz \"Hello world!  \"\n.equ LGTEXTE1, . - szTexte1\nszTexte2:                .asciz \"Press q for close window or clic X in system menu.\"\n.equ LGTEXTE2, . - szTexte2\nszLibDW:           .asciz \"WM_DELETE_WINDOW\"    @ special label for correct close error\n\nszfontname: .asciz  \"-*-helvetica-bold-*-normal-*-12-*\"         @ for font test\nszfontname2: .asciz \"-*-fixed-*-*-*-*-13-*-*-*-*-*\"\n.align 4\nstXGCValues:       .int 0,0,0xFFA0A0A0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   @ for foreground color gris1\n//stXGCValues:       .int 0,0,0x00000000,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   @ for foreground color black\nstXGCValues1:      .int 0,0,0x00FFFFFF,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   @ for foreground color white\nstXGCValues2:      .int 0,0,0x0000FF00,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0   @ for foreground color green \n/*******************************************/\n/* DONNEES NON INITIALISEES                    */\n/*******************************************/ \n.bss\n.align 4\nptDisplay:          .skip 4      @ pointer display\nptEcranDef:         .skip 4      @ pointer screen default\nptFenetre:          .skip 4      @ pointer window\nptGC:               .skip 4      @ pointer graphic context\nptGC1:              .skip 4      @ pointer graphic context\nptFont:             .skip 4      @ pointer font\nkey:                .skip 4      @ key code\nwmDeleteMessage:    .skip 8      @ ident close message\nevent:              .skip 400    @ TODO: event size\u00a0??\nPrpNomFenetre:      .skip 100    @ window name proprety\nbuffer:             .skip 500 \nsbuffer1:             .skip 500\niWhite:             .skip 4      @ rgb code for white pixel\niBlack:             .skip 4      @ rgb code for black pixel\niSens:              .skip 4      @ direction of travel\n/**********************************************/\n/* -- Code section                            */\n/**********************************************/\n.text\n.global main\niOfWhite:           .int iWhite - .\niOfBlack:           .int iBlack - .\niOfszMessDebutPgm:  .int szMessDebutPgm - .\niOfptDisplay:       .int ptDisplay - .\niOfptEcranDef:      .int ptEcranDef - .\niOfszLibDW:         .int szLibDW - .\nmain:                           @ entry of program \n    adr r0,iOfszMessDebutPgm   @\n    ldr r1,[r0]\n    add r0,r1\n    bl affichageMess            @ display start message on console linux\n    /* attention r6  pointer display*/\n    /* attention r8  pointer graphic context 1  */\n    /* attention r9 ident window  */\n    /* attention r10  pointer graphic context 2  */\n    /*****************************/\n    /*    OPEN SERVER X11        */\n    /*****************************/\n    mov r0,#0\n    bl XOpenDisplay             @ open X server\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurServeur\n    adr r2,iOfptDisplay\n    ldr r1,[r2]\n    add r1,r2\n    str r0,[r1]                 @ store display address \n\n    mov r6,r0                   @ and in register r6\n    ldr r2,[r0,#+132]           @ load default_screen\n    adr r1,iOfptEcranDef\n    ldr r3,[r1]\n    add r1,r3\n    str r2,[r1]                 @ store default_screen\n    mov r2,r0\n    ldr r0,[r2,#+140]           @ load pointer screen list\n    ldr r5,[r0,#+52]            @ load value white pixel\n    adr r4,iOfWhite             @ and store in memory\n    ldr r3,[r4]\n    add r4,r3\n    str r5,[r4]\n    ldr r7,[r0,#+56]            @ load value black pixel\n    adr r4,iOfBlack             @ and store in memory\n    ldr r5,[r4]\n    add r4,r5\n    str r7,[r4]\n    ldr r4,[r0,#+28]            @ load bits par pixel\n    ldr r1,[r0,#+8]             @ load root windows\n    /**************************/\n    /* CREATE WINDOW          */\n    /**************************/\n    mov r0,r6                   @ address display\n    mov r2,#0                   @ window position X\n    mov r3,#0                   @ window position Y\n    mov r8,#0                   @ for stack alignement\n    push {r8}\n    push {r7}                   @  background  = black pixel\n    push {r5}                   @  border = white pixel\n    mov r8,#2                   @  border size\n    push {r8}\n    mov r8,#WINDOWHEIGHT        @ height\n    push {r8}\n    mov r8,#WINDOWWIDTH         @ width\n    push {r8}   \n    bl XCreateSimpleWindow\n    add sp,#24                  @ stack alignement  6 push (4 bytes * 6)\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurF\n\n    adr r1,iOfptFenetre\n    ldr r3,[r1]\n    add r1,r3\n    str r0,[r1]                 @ store window address in memory\n    mov r9,r0                   @ and in register r9\n    \n    /*****************************/\n    /* add window property       */\n    /*****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    adr r2,iOfszWindowName      @ window name\n    ldr r5,[r2]\n    add r2,r5\n    adr r3,iOfszTitreFenRed     @ window name reduced\n    ldr r5,[r3]\n    add r3,r5\n    mov r4,#0\n    push {r4}                   @ parameters not use\n    push {r4}\n    push {r4}\n    push {r4}\n    bl XSetStandardProperties\n    add sp,sp,#16               @ stack alignement for 4 push\n    /**************************************/\n    /* for correction window close error  */\n    /**************************************/\n    mov r0,r6                   @ display address\n    adr r1,iOfszLibDW           @ atom address\n    ldr r5,[r1]\n    add r1,r5\n    mov r2,#1                   @ False  cr\u00e9ate atom if not exists\n    bl XInternAtom\n    cmp r0,#0                   @ error X11\u00a0?\n    blt erreurX11               @ Modif avril 22 pour android (ble pour raspberry)\n    adr r1,iOfwmDeleteMessage  @ recept address\n    ldr r5,[r1]\n    add r1,r5\n    str r0,[r1]\n    mov r2,r1                   @ return address\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    mov r3,#1                   @ number of protocols\n    bl XSetWMProtocols\n    cmp r0,#0                   @ error X11\u00a0?\n    ble erreurX11\n    /***********************************/\n    /* load font                       */\n    /* remark\u00a0: see font list X11 on your system */\n    /***********************************/\n    mov r0,r6                   @ display address\n    bl loadFont\n\n    /**********************************/\n    /*  create graphic context        */\n    /**********************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    bl createContextGraphic\n    \n\n    /****************************/\n    /* modif window background  */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iGris1               @ background color\n    bl XSetWindowBackground   \n    cmp r0,#0                   @ error\u00a0?\n    ble erreurX11\n    \n    /***************************/\n    /* OUF!! window display    */\n    /***************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    bl XMapWindow\n    \n                                @ copy text in buffer\n    adr r0,iOfszTexte1          @ string address\n    ldr r5,[r0]\n    add r0,r5\n    adr r1,iOfsbuffer1          @ buffer address\n    ldr r5,[r1]\n    add r1,r5\n    mov r2,#0\n1:                              @ loop copy character\n    ldrb r3,[r0,r2]\n    strb r3,[r1,r2]\n    cmp r3,#0\n    addne r2,r2,#1\n    bne 1b\n    \n    /****************************/\n    /* Autorisations            */\n    /****************************/\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window address\n    ldr r2,iFenetreMask         @ autorisation mask\n    bl XSelectInput\n    cmp r0,#0                   @ error\u00a0?\n    ble erreurX11\n    \n    /****************************/\n    /* Events loop              */\n    /****************************/\n1:\n    mov r0,r6                   @ display address\n    bl XPending                 @ loading the number of events\n    cmp r0,#0\n    bne 2f                      @ a event is occurring\n    adr r3,iOfsbuffer1\n    ldr r5,[r3]\n    add r3,r5\n    mov r0,r6                   @ display address\n    mov r1,r9                   @ window ident\n    mov r2,r8                   @ graphic context \n    bl animate                  @ string display and move\n    b 1b\n2:\n    mov r0,r6                   @ display address\n    adr r1,iOfevent             @ events address\n    ldr r5,[r1]\n    add r1,r5\n    bl XNextEvent               @ event\u00a0?\n    adr r0,iOfevent\n    ldr r5,[r0]\n    add r0,r5\n    ldr r0,[r0]                 @ code event\n    cmp r0,#KeyPressed          @ key\u00a0?\n    bne 2f\n    adr r0,iOfevent            @ yes read key in buffer\n    ldr r5,[r0]\n    add r0,r5\n    adr r1,iOfbuffer\n    ldr r5,[r1]\n    add r1,r5\n    mov r2,#255\n    adr r3,iOfkey\n    ldr r5,[r3]\n    add r3,r5\n    mov r4,#0\n    push {r4}                   @ stack alignement\n    push {r4}\n    bl XLookupString \n    add sp,#8                   @ stack alignement 2 push\n    cmp r0,#1                   @ is character key\u00a0?\n    bne 2f\n    adr r0,iOfbuffer           @ yes -> load first buffer character\n    ldr r5,[r0]\n    add r0,r5\n    ldrb r0,[r0]\n    cmp r0,#0x71                @ character q for quit\n    beq 5f                      @ yes -> end\n    b 4f\n2:\n    /************************************/\n    /*  clic mouse button   */\n    /************************************/\n    cmp r0,#ButtonPress         @ clic mouse buton\n    bne 3f\n    adr r0,iOfevent\n    ldr r5,[r0]\n    add r0,r5\n    ldr r1,[r0,#+32]            @ position X mouse clic\n    ldr r2,[r0,#+36]            @ position Y\n    cmp r1,#50                  @ test if position clic is on the screen string approx.\n    blt 4f\n    cmp r1,#150\n    bgt 4f\n    cmp r2,#80\n    blt 4f\n    cmp r2,#105\n    bgt 4f\n    adr r1,iOfiSens             @ load direction\n    ldr r2,[r1]\n    add r1,r2\n    ldr r2,[r1]\n    cmp r2,#0                   @ direction inversion\n    moveq r2,#1\n    movne r2,#0\n    str r2,[r1]\n    b 4f\n3:\n    cmp r0,#ClientMessage       @ code for close window within error\n    bne 4f\n    adr r0,iOfevent\n    ldr r5,[r0]\n    add r0,r5\n    ldr r1,[r0,#+28]            @ code message address \n    adr r2,iOfwmDeleteMessage   @ equal code window cr\u00e9ate\u00a0???\n    ldr r5,[r2]\n    add r2,r5\n    ldr r2,[r2]\n    cmp r1,r2\n    beq 5f                      @ yes -> end window \n\n4:  @ loop for other event\n    b 1b\niOfptFenetre:       .int ptFenetre - .\niOfszWindowName:    .int szWindowName - .\niOfszTitreFenRed:   .int szTitreFenRed - .\n    /***********************************/\n    /* Close window -> free ressources */\n    /***********************************/\n5:\n    mov r0,r6                  @ display address\n    adr r1,iOfptGC\n    ldr r5,[r1]\n    add r1,r5\n    ldr r1,[r1]                @ load context graphic address \n    bl XFreeGC\n    mov r0,r6                  @ display address\n    adr r1,iOfptGC1\n    ldr r5,[r1]\n    add r1,r5\n    ldr r1,[r1]                @ load context graphic address \n    bl XFreeGC\n    cmp r0,#0\n    blt erreurX11\n    mov r0,r6                  @ display address \n    mov r1,r9                  @ window address\n    bl XDestroyWindow\n    cmp r0,#0\n    blt erreurX11\n    mov r0,r6                  @ display address\n    bl XCloseDisplay\n    cmp r0,#0\n    blt erreurX11\n    mov r0,#0                  @ return code OK\n    b 100f\n\nerreurF:   @ create error window but possible not necessary. Display error by server\n    adr r1,iOfszMessErrfen\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1                  @ return error code\n    b 100f\nerreurGC:                      @ error create graphic context\n    adr r1,iOfszMessErrGc\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1\n    b 100f\nerreurX11:    @ erreur X11\n    adr r1,iOfszMessErreurX11\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1\n    b 100f\nerreurServeur:                 @ error no found X11 server see doc putty and Xming\n    adr r1,iOfszMessErreur\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1\n    b 100f\n\n100:                           @ standard end of the program \n    mov r7, #EXIT\n    svc 0 \n\niOfevent:           .int event - .\niOfbuffer:          .int buffer - .\niOfsbuffer1:        .int sbuffer1 - .\niOfkey:             .int key - .\niOfszMessErreurX11: .int szMessErreurX11 - .\niOfszMessErreur:    .int szMessErreur - .\niOfszMessErrfen:    .int szMessErrfen - .\niOfszTexte1:        .int szTexte1 - .\niOfszTexte2:        .int szTexte2 - .\niOfPrpNomFenetre:   .int PrpNomFenetre - .\niOfwmDeleteMessage: .int wmDeleteMessage - .\n\niFenetreMask:        .int  KeyPressMask|ButtonPressMask|StructureNotifyMask\niGris1:              .int 0xFFA0A0A0\niOfiSens:            .int iSens - .\n/******************************************************************/\n/*    load font                                                  */ \n/******************************************************************/\n/* r0 contains display  */\nloadFont:\n    push {r1-r2,lr}           @ save  registers \n    adr r1,iOfszfontname       @ font name\n    ldr r2,[r1]\n    add r1,r2\n    bl XLoadQueryFont\n    cmp r0,#0\n    beq 99f                    @ font not find\n    adr r1,iOfptFont\n    ldr r2,[r1]\n    add r1,r2\n    str r0,[r1]\n    mov r0,#0\n    b 100f\n99:\n    adr r1,iOfszMessErrFont\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1\n100:\n    pop {r1-r2,pc}             @ restaur registers\niOfszfontname:          .int szfontname2 - .\niOfptFont:              .int ptFont - .\niOfszMessErrFont:       .int szMessErrFont - .\n/******************************************************************/\n/*    Context Graphic cr\u00e9ation                                                  */ \n/******************************************************************/\n/* r0 contains display  */\n/* r1 window address */\n/* REMARKS\u00a0: no standard use registers  return GC1 in r8 and GC2 in r10 */ \ncreateContextGraphic:\n    push {r1-r7,lr}             @ save  registers \n    /**********************************/\n    /*  create graphic context        */\n    /**********************************/\n    mov r6,r0                   @ save display address\n    mov r7,r1                   @ save window address\n    adr r3,iOfptFont            @ font pointer\n    ldr r1,[r3]\n    add r3,r1\n    ldr r3,[r3]\n    ldr r4,[r3,#4]              @ load font ident\n    adr r3,iOfstXGCValues2      @ green color in foreground\n    ldr r5,[r3]\n    add r3,r5                   @ this parameter is used by XcreateGC\n    str r4,[r3,#60]             @ store ident font in  offset 60 \n    mov r0,r4\n    mov r0,r6                   @ display address\n    mov r1,r7                   @ window address\n    mov r2,#GCForeground|GCFont @  @ green color in foreground and font\n    bl XCreateGC\n    cmp r0,#0                   @ error\u00a0?\n    beq 99f\n    adr r1,iOfptGC\n    ldr r5,[r1]\n    add r1,r5\n    str r0,[r1]                 @ store address graphic context\n    mov r8,r0                   @ and in r8\n    /**********************************/\n    /*  create 2 graphic context        */\n    /**********************************/\n    mov r0,r6                   @ display address\n    mov r1,r7                   @ window address\n    mov r2,#GCForeground        @ red color in Foreground\n    adr r3,iOfstXGCValues\n    ldr r5,[r3]\n    add r3,r5\n    bl XCreateGC\n    cmp r0,#0                   @ error\u00a0?\n    beq erreurGC\n    adr r1,iOfptGC1\n    ldr r5,[r1]\n    add r1,r5\n    str r0,[r1]                 @ store address graphic context\n    mov r10,r0                  @ and in r10\n    b 100f\n99:                            @ create error\n    adr r1,iOfszMessErrGc\n    ldr r5,[r1]\n    add r1,r5\n    bl   displayError\n    mov r0,#1\n100:\n    pop {r1-r7,pc}             @ restaur registers\niOfszMessErrGc:     .int szMessErrGc - .\niOfptGC:            .int ptGC - .\niOfptGC1:           .int ptGC1 - .\niOfstXGCValues:     .int stXGCValues - .\niOfstXGCValues1:     .int stXGCValues1 - .\niOfstXGCValues2:     .int stXGCValues2 - .\n/******************************************************************/\n/*    animation                                                   */ \n/******************************************************************/\n/* r0 contains display  */\n/* r1 contains window ident */\n/* r2 contains context graphic */\n/* r3 string address   */\nanimate:\n    push {r2-r9,lr}            @ save  registers \n    mov r5,r3                   @ save string address\n    mov r6,r0                   @ save display\n    mov r7,r1                   @ save window\n    mov r8,r2                   @ save GC\n                                @ erase text in the windows\n    mov r0,r6                   @ display address\n    mov r1,r7                   @ window ident\n    mov r2,r10                  @ graphic context \n    mov r3,#50                  @ position x\n    mov r4,#LGTEXTE1  - 1       @ string lenght\n    push {r4}                   @ stack alignement\n    push {r4}                   @ to stack parameter\n\n    push {r5}                   @ string address\n    mov r4,#100                 @ position y\n    push {r4}\n    bl XDrawString\n    add sp,sp,#16               @ stack alignement (4 push)\n\n    mov r0,#LGTEXTE1 -2         @ string length\n    adr r1,iOfiSens             @ load direction\n    ldr r2,[r1]\n    add r1,r2\n    ldr r2,[r1]\n    cmp r2,#0                   @ test direction\n    bne 2f\n    \n    ldrb r9,[r5,r0]             @ last character\n    sub r1,r0,#1\n1:                              @ loop to move character one position\n    ldrb r2,[r5,r1]\n    strb r2,[r5,r0]\n    sub r0,r0,#1\n    subs r1,r1,#1\n    bge 1b\n    add r1,r1,#1\n    strb r9,[r5,r1]             @ last character -> first character\n    b 4f\n2:\n    ldrb r9,[r5]                @ first character\n    mov r1,#1\n    sub r2,r1,#1\n3:                              @ loop to move character\n    ldrb r3,[r5,r1]\n    strb r3,[r5,r2]\n    add r2,r2,#1\n    add r1,r1,#1\n    cmp r1,r0\n    ble 3b\n    strb r9,[r5,r2]             @ first character -> last character\n    \n4:\n                                @ write text in the windows\n    mov r0,r6                   @ display address\n    mov r1,r7                   @ window ident\n    mov r2,r8                   @ graphic context \n    mov r3,#50                  @ position x\n    mov r4,#LGTEXTE1  - 1       @ string lenght\n    push {r4}                   @ stack alignement\n    push {r4}                   @ to stack parameter\n    push {r5}                   @ string address\n    mov r4,#100                 @ position y\n    push {r4}\n    bl XDrawString\n    add sp,sp,#16               @ stack alignement (4 push)\n    mov r0,#20                  @ timeout 5s approx.\n    bl delay\n\n100:\n    pop {r2-r9,pc}             @ restaur registers\n/******************************************************************/\n/*    timeout                                                   */ \n/******************************************************************/\n/* r0 contains delay  */\n\ndelay:\n    push {r1,lr}           @ save  registers \n    ldr r1,iCst30000000\n    mul r0,r1,r0\n1:\n    subs r0,r0,#1\n    bge 1b\n100:\n    pop {r1,pc}             @ restaur registers\niCst30000000:       .int 30000000\n/***************************************************/\n/*      ROUTINES INCLUDE                 */\n/***************************************************/\n.include \"../affichage.inc\"\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Delphi", "code": "\nLibrary:  Winapi.Windows\nLibrary:  System.SysUtils\nLibrary:  System.Classes\nLibrary:  Vcl.Controls\nLibrary:  Vcl.Forms\nLibrary:  Vcl.StdCtrls\nLibrary:  Vcl.ExtCtrls\nunit Main;\n\ninterface\n\nuses\n  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Controls, Vcl.Forms,\n  Vcl.StdCtrls, Vcl.ExtCtrls;\n\ntype\n  TForm1 = class(TForm)\n    lblAniText: TLabel;\n    tmrAniFrame: TTimer;\n    procedure lblAniTextClick(Sender: TObject);\n    procedure tmrAniFrameTimer(Sender: TObject);\n  end;\n\nvar\n  Form1: TForm1;\n  Reverse: boolean = false;\n\nimplementation\n\n{$R *.dfm}\n\nprocedure TForm1.lblAniTextClick(Sender: TObject);\nbegin\n  Reverse := not Reverse;\nend;\n\nfunction Shift(text: string; direction: boolean): string;\nbegin\n  if direction then\n    result := text[text.Length] + text.Substring(0, text.Length - 1)\n  else\n    result := text.Substring(1, text.Length) + text[1];\nend;\n\nprocedure TForm1.tmrAniFrameTimer(Sender: TObject);\nbegin\n  with lblAniText do\n    Caption := Shift(Caption, Reverse);\nend;\nend.\n\n\nobject Form1: TForm1\n  ClientHeight = 132\n  ClientWidth = 621\n  object lblAniText: TLabel\n    Align = alClient\n    Alignment = taCenter\n    Caption = 'Hello World! '\n    Font.Height = -96\n    OnClick = lblAniTextClick\n  end\n  object tmrAniFrame: TTimer\n    Interval = 200\n    OnTimer = tmrAniFrameTimer\n  end\nend\n\n", "explain": "Form resource:\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Ruby", "code": "\nTranslation of: Tcl\nLibrary: Ruby/Tk\nrequire 'tk'\n$str = TkVariable.new(\"Hello World! \")\n$dir = :right\n \ndef animate\n  $str.value = shift_char($str.value, $dir)\n  $root.after(125) {animate}\nend\n\ndef shift_char(str, dir)\n  case dir\n  when :right then str[-1,1] + str[0..-2]\n  when :left  then str[1..-1] + str[0,1]\n  end\nend\n \n$root = TkRoot.new(\"title\" => \"Basic Animation\")\n \nTkLabel.new($root) do\n  textvariable $str\n  font \"Courier 14\"\n  pack {side 'top'}\n  bind(\"ButtonPress-1\") {$dir = {:right=>:left,:left=>:right}[$dir]}\nend\n \nanimate\nTk.mainloop\n\nLibrary: Shoes\nShoes.app do\n  @direction = 1\n  @label = para \"Hello World! \", :family => 'monospace'\n\n  click {|button, left, top| @direction *= -1 if button == 1}\n\n  animate(8) do |f| \n    t = @label.text\n    @label.text = @direction > 0 ? t[-1] + t[0..-2] : t[1..-1] + t[0]\n  end\nend\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Rust", "code": "\nLibrary: GTK[edit]\n#[cfg(feature = \"gtk\")]\nmod graphical {\n    extern crate gtk;\n\n    use self::gtk::traits::*;\n    use self::gtk::{Inhibit, Window, WindowType};\n    use std::ops::Not;\n    use std::sync::{Arc, RwLock};\n\n    pub fn create_window() {\n        gtk::init().expect(\"Failed to initialize GTK\");\n\n        let window = Window::new(WindowType::Toplevel);\n        window.connect_delete_event(|_, _| {\n            gtk::main_quit();\n            Inhibit(false)\n        });\n        let button = gtk::Button::new_with_label(\"Hello World! \");\n        window.add(&button);\n\n        let lock = Arc::new(RwLock::new(false));\n\n        let lock_button = lock.clone();\n        button.connect_clicked(move |_| {\n            let mut reverse = lock_button.write().unwrap();\n            *reverse = reverse.not();\n        });\n\n        let lock_thread = lock.clone();\n        gtk::timeout_add(100, move || {\n            let reverse = lock_thread.read().unwrap();\n            let mut text = button.get_label().unwrap();\n            let len = &text.len();\n\n            if *reverse {\n                let begin = &text.split_off(1);\n                text.insert_str(0, begin);\n            } else {\n                let end = &text.split_off(len - 1);\n                text.insert_str(0, end);\n            }\n\n            button.set_label(&text);\n\n            gtk::Continue(true)\n        });\n\n        window.show_all();\n        gtk::main();\n    }\n}\n\n\n#[cfg(feature = \"gtk\")]\nfn main() {\n    graphical::create_window();\n}\n\n#[cfg(not(feature = \"gtk\"))]\nfn main() {}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "R", "code": "\nLibrary: gWidgets\n\nrotate_string <- function(x, forwards) \n{ \n\u00a0 \u00a0nchx <- nchar(x) \n\u00a0 \u00a0if(forwards) \n\u00a0 \u00a0{ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 paste(substr(x, nchx, nchx), substr(x, 1, nchx - 1), sep = \"\") \n\u00a0 \u00a0} else \n\u00a0 \u00a0{ \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \n\u00a0 \u00a0 \u00a0 paste(substr(x, 2, nchx), substr(x, 1, 1), sep = \"\") \n\u00a0 \u00a0} \n}\n\nhandle_rotate_label <- function(obj, interval = 100)\n{\n\u00a0 addHandlerIdle(obj,\n\u00a0\u00a0\u00a0 handler = function(h, ...)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0 svalue(obj) <- rotate_string(svalue(obj), tag(obj, \"forwards\"))\n\u00a0\u00a0\u00a0 },\n\u00a0\u00a0\u00a0 interval = interval\n\u00a0 )\n}\n\nhandle_change_direction_on_click <- function(obj)\n{\n\u00a0 addHandlerClicked(obj,\n\u00a0\u00a0\u00a0 handler = function(h, ...)\n\u00a0\u00a0\u00a0 {\n\u00a0\u00a0\u00a0\u00a0\u00a0 tag(h$obj, \"forwards\") <- !tag(h$obj, \"forwards\")\n\u00a0\u00a0\u00a0 }\n\u00a0 )\n}\n\nlibrary(gWidgets)\nlibrary(gWidgetstcltk) #or library(gWidgetsRGtk2)\u00a0or library(gWidgetsrJava)\u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \u00a0 \nlab <- glabel(\"Hello World! \", container = gwindow()) \u00a0\ntag(lab, \"forwards\") <- TRUE \nhandle_rotate_label(lab) \nhandle_change_direction_on_click(lab)\n\n", "explain": "The basic principle is:create a window with a label in it, then add a handler to the label for rotating the string, and another for changing direction on a click.  Use of the tag function allows you to store the text flow direction as an attribute of the label.\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Visual_Basic", "code": "\n\nVERSION 5.00\nBegin VB.Form Form1\n   Begin VB.Timer Timer1\n      Interval = 250\n   End\n   Begin VB.Label Label1\n      AutoSize = -1  'True\n      Caption  = \"Hello World! \"\n   End\nEnd\nAttribute VB_Name = \"Form1\"\nAttribute VB_GlobalNameSpace = False\nAttribute VB_Creatable = False\nAttribute VB_PredeclaredId = True\nAttribute VB_Exposed = False\n'Everything above this line is hidden when in the IDE.\n\nPrivate goRight As Boolean\n\nPrivate Sub Label1_Click()\n    goRight = Not goRight\nEnd Sub\n\nPrivate Sub Timer1_Timer()\n    If goRight Then\n        x = Mid(Label1.Caption, 2) & Left(Label1.Caption, 1)\n    Else\n        x = Right(Label1.Caption, 1) & Left(Label1.Caption, Len(Label1.Caption) - 1)\n    End If\n    Label1.Caption = x\nEnd Sub\n\n", "explain": "This example shows code that is hidden by the IDE. (Form creation is done graphically within the IDE, not at runtime.)\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Ada", "code": "\nWorks with: GNAT\nLibrary: GtkAda\n\nwith Gtk.Main;\nwith Gtk.Handlers;\nwith Gtk.Label;\nwith Gtk.Button;\nwith Gtk.Window;\nwith Glib.Main;\n\nprocedure Animation is\n   Scroll_Forwards : Boolean := True;\n\n   package Button_Callbacks is new Gtk.Handlers.Callback\n     (Gtk.Button.Gtk_Button_Record);\n\n   package Label_Timeout is new Glib.Main.Generic_Sources\n     (Gtk.Label.Gtk_Label);\n\n   package Window_Callbacks is new Gtk.Handlers.Return_Callback\n     (Gtk.Window.Gtk_Window_Record, Boolean);\n\n   --  Callback for click event\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class);\n\n   --  Callback for delete event\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean;\n\n   procedure On_Button_Click\n     (Object : access Gtk.Button.Gtk_Button_Record'Class)\n   is\n      pragma Unreferenced (Object);\n   begin\n      Scroll_Forwards := not Scroll_Forwards;\n   end On_Button_Click;\n\n   function On_Main_Window_Delete\n     (Object : access Gtk.Window.Gtk_Window_Record'Class)\n      return   Boolean\n   is\n      pragma Unreferenced (Object);\n   begin\n      Gtk.Main.Main_Quit;\n      return True;\n   end On_Main_Window_Delete;\n\n   function Scroll_Text (Data : Gtk.Label.Gtk_Label) return Boolean is\n      Text : constant String := Gtk.Label.Get_Text (Data);\n   begin\n      if Scroll_Forwards then\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'First + 1 .. Text'Last) & Text (Text'First));\n      else\n         Gtk.Label.Set_Text\n           (Label => Data,\n            Str   => Text (Text'Last) & Text (Text'First .. Text'Last - 1));\n      end if;\n      return True;\n   end Scroll_Text;\n\n   Main_Window     : Gtk.Window.Gtk_Window;\n   Text_Button     : Gtk.Button.Gtk_Button;\n   Scrolling_Text  : Gtk.Label.Gtk_Label;\n   Timeout_ID      : Glib.Main.G_Source_Id;\n   pragma Unreferenced (Timeout_ID);\n\nbegin\n   Gtk.Main.Init;\n   Gtk.Window.Gtk_New (Window => Main_Window);\n   Gtk.Label.Gtk_New (Label => Scrolling_Text, Str => \"Hello World! \");\n   Gtk.Button.Gtk_New (Button => Text_Button);\n   Gtk.Button.Add (Container => Text_Button, Widget => Scrolling_Text);\n   Button_Callbacks.Connect\n     (Widget => Text_Button,\n      Name   => \"clicked\",\n      Marsh  => Button_Callbacks.To_Marshaller (On_Button_Click'Access));\n   Timeout_ID :=\n     Label_Timeout.Timeout_Add\n       (Interval => 125,\n        Func     => Scroll_Text'Access,\n        Data     => Scrolling_Text);\n   Gtk.Window.Add (Container => Main_Window, Widget => Text_Button);\n   Window_Callbacks.Connect\n     (Widget => Main_Window,\n      Name   => \"delete_event\",\n      Marsh  => Window_Callbacks.To_Marshaller (On_Main_Window_Delete'Access));\n   Gtk.Window.Show_All (Widget => Main_Window);\n   Gtk.Main.Main;\nend Animation;\n\n", "explain": "animation.adb:\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Julia", "code": "\nLibrary: Julia/Tk\nusing Tk\n\nconst frameinterval = 0.12 # partial seconds between change on screen display\n\nfunction windowanim(stepinterval::Float64)\n    wind = Window(\"Animation\", 300, 100)\n    frm = Frame(wind)\n    hello = \"Hello World!                                           \"\n    but = Button(frm, width=30, text=hello)\n    rightward = true\n    callback(s) = (rightward = !rightward)\n    bind(but, \"command\", callback)\n    pack(frm, expand=true, fill = \"both\")\n    pack(but, expand=true, fill = \"both\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    while true\n        but[:text] = permut[ppos]\n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if ppos > pmod\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if ppos < 1\n                ppos = pmod\n            end\n        end\n    end\nend\n\nwindowanim(frameinterval)\n\nLibrary: Julia/Gtk\nusing Gtk.ShortNames\n \nconst frameinterval = 0.12 # partial seconds between change on screen display\n \nfunction textanimation(stepinterval::Float64)\n    hello = \"Hello World!                        \"\n    win = Window(\"Animation\", 210, 40) |> (Frame() |> (but = Button(\"Switch Directions\")))\n    rightward = true\n    switchdirections(s) = (rightward = !rightward)\n    signal_connect(switchdirections, but, \"clicked\")\n    permut = [hello[i:end] * hello[1:i-1] for i in length(hello)+1:-1:2]\n    ppos = 1\n    pmod = length(permut)\n    nobreak = true\n    endit(w) = (nobreak = false)    \n    signal_connect(endit, win, :destroy)\n    showall(win)\n    while nobreak\n        setproperty!(but, :label, permut[ppos])        \n        sleep(stepinterval)\n        if rightward\n            ppos += 1\n            if(ppos > pmod)\n                ppos = 1\n            end\n        else\n            ppos -= 1\n            if(ppos < 1)\n                ppos = pmod\n            end\n        end\n    end\nend\n\ntextanimation(frameinterval)\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1.0\n\nimport java.awt.Dimension\nimport java.awt.event.MouseAdapter\nimport java.awt.event.MouseEvent\nimport java.util.*\nimport javax.swing.JFrame\nimport javax.swing.JLabel\n\nclass Rotate : JFrame() {\n    val text = \"Hello World! \"\n    val label = JLabel(text)\n    var rotRight = true\n    var startIdx = 0\n\n    init {\n        preferredSize = Dimension(96, 64)\n        label.addMouseListener(object: MouseAdapter() {\n            override fun mouseClicked(evt: MouseEvent) {\n                rotRight = !rotRight\n            }\n        })\n        add(label)\n        pack()\n        defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        isVisible = true\n    }\n}\n\nfun getRotatedText(text: String, startIdx: Int): String {\n    val ret = StringBuilder()\n    var i = startIdx\n    do {\n        ret.append(text[i++])\n        i %= text.length\n    }\n    while (i != startIdx)\n    return ret.toString()\n}\n\nfun main(args: Array<String>) {\n    val rot = Rotate()\n    val task = object : TimerTask() {\n        override fun run() {\n            if (rot.rotRight) {\n                if (--rot.startIdx < 0) rot.startIdx += rot.text.length\n            }\n            else {\n                if (++rot.startIdx >= rot.text.length) rot.startIdx -= rot.text.length\n            }\n            rot.label.text = getRotatedText(rot.text, rot.startIdx)\n        }\n    }\n    Timer(false).schedule(task, 0, 500)\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Perl", "code": "\nuse Tk;\nuse Time::HiRes qw(sleep);\n\nmy $msg    = 'Hello World! ';\nmy $first  = '.+';\nmy $second = '.';\n\nmy $mw = Tk::MainWindow->new(-title => 'Animated side-scroller',-bg=>\"white\");\n$mw->geometry (\"400x150+0+0\");\n\n$mw->optionAdd('*Label.font', 'Courier 24 bold' );\n\nmy $scroller = $mw->Label(-text => \"$msg\")->grid(-row=>0,-column=>0);\n$mw->bind('all'=> '<Key-Escape>' => sub {exit;});\n$mw->bind(\"<Button>\" => sub { ($second,$first) = ($first,$second) });\n\n$scroller->after(1, \\&display );\nMainLoop;\n\nsub display {\n    while () {\n        sleep 0.25;\n        $msg =~ s/($first)($second)/$2$1/;\n        $scroller->configure(-text=>\"$msg\");\n        $mw->update();\n    }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Prolog", "code": "\n\n:- use_module(library(pce)).\n\nanimation :-\n    new(D, window('Animation')),\n    new(Label, label(hello, 'Hello world\u00a0! ')),\n    send(D, display, Label, point(1,10)),\n    new(@animation, animation(Label)),\n    send(D, recogniser,\n         new(_G, my_click_gesture(left, ''))),\n\n    send(D, done_message, and(message(@animation, free),\n                  message(@receiver, destroy))),\n    send(D, open),\n    send(@animation?mytimer, start).\n\n\n:- pce_begin_class(animation(label), object).\nvariable(label, object,  both, \"Display window\").\nvariable(delta,    object, both,  \"increment of the angle\").\nvariable(mytimer, timer, both, \"timer of the animation\").\n\ninitialise(P, W:object) :->\n        \"Creation of the object\"::\n        send(P, label, W),\n        send(P, delta, to_left),\n    send(P, mytimer, new(_, timer(0.5,message(P, anim_message)))).\n\n% method called when the object is destroyed\n% first the timer is stopped\n% then all the resources are freed\nunlink(P) :->\n    send(P?mytimer, stop),\n    send(P, send_super, unlink).\n\n\n% message processed by the timer\nanim_message(P) :->\n    get(P, label, L),\n    get(L, selection, S),\n    get(P, delta, Delta),\n    compute(Delta, S, S1),\n    new(A, name(S1)),\n    send(L, selection, A).\n\n\n:- pce_end_class.\n\n:- pce_begin_class(my_click_gesture, click_gesture,\n           \"Click in a window\").\n\nclass_variable(button, button_name, left,\n           \"By default click with left button\").\n\nterminate(G, Ev:event) :->\n    send(G, send_super, terminate, Ev),\n    get(@animation, delta, D),\n    (   D = to_left -> D1 = to_right; D1 = to_left),\n    send(@animation, delta, D1).\n\n:- pce_end_class.\n\n\n% compute next text to be dispalyed\ncompute(to_right, S, S1) :-\n    get(S, size, Len),\n    Len1 is Len - 1,\n    get(S, sub, Len1, Str),\n    get(S, delete_suffix, Str, V),\n    get(Str, append, V, S1).\n\ncompute(to_left, S, S1) :-\n    get(S, sub, 0, 1, Str),\n    get(S, delete_prefix, Str, V),\n    get(V, append, Str, S1).\n\n", "explain": "SWI-Prolog has a grapghic interface XPCE.\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Lua", "code": "\nWorks with: L\u00d6VE\nfunction love.load()\n\ttext = \"Hello World! \"\n\tlength = string.len(text)\n\t\n\t\n\tupdate_time = 0.3\n\ttimer = 0\n\tright_direction = true\n\t\n\t\n\tlocal width, height = love.graphics.getDimensions( )\n\n\tlocal size = 100\n\tlocal font = love.graphics.setNewFont( size )\n\tlocal twidth = font:getWidth( text )\n\tlocal theight = font:getHeight( )\n\tx = width/2 - twidth/2\n\ty = height/2-theight/2\n\t\nend\n\n \nfunction love.update(dt)\n\ttimer = timer + dt\n\tif timer > update_time then\n\t\ttimer = timer - update_time\n\t\tif right_direction then\n\t\t\ttext = string.sub(text, 2, length) .. string.sub(text, 1, 1)\n\t\telse\n\t\t\ttext = string.sub(text, length, length) .. string.sub(text, 1, length-1)\n\t\tend\n\tend\nend\n\n\nfunction love.draw()\n\tlove.graphics.print (text, x, y)\nend\n\nfunction love.keypressed(key, scancode, isrepeat)\n\tif false then\n\telseif key == \"escape\" then\n\t\tlove.event.quit()\n\tend\nend\n\nfunction love.mousepressed( x, y, button, istouch, presses )\n\tright_direction = not right_direction\nend\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Scala", "code": "\nWorks with: Scala version 2.8\nimport scala.actors.Actor.{actor, loop, reactWithin, exit}\nimport scala.actors.TIMEOUT\nimport scala.swing.{SimpleSwingApplication, MainFrame, Label}\nimport scala.swing.event.MouseClicked\n\ncase object Revert\n\nobject BasicAnimation extends SimpleSwingApplication {\n  val label = new Label(\"Hello World! \")\n  val rotator = actor {\n    var goingRight = true\n    loop {\n      reactWithin(250 /*ms*/) {\n        case Revert => goingRight = !goingRight\n        case TIMEOUT =>\n          if (goingRight)\n            label.text = label.text.last + label.text.init\n          else\n            label.text = label.text.tail + label.text.head\n        case unknown => println(\"Unknown message \"+unknown); exit()\n      }\n    }\n  }\n  def top = new MainFrame {\n    title = \"Basic Animation\"\n    contents = label\n  }\n  listenTo(label.mouse.clicks) // use \"Mouse\" instead of \"mouse\" on Scala 2.7\n  reactions += {\n    case _ : MouseClicked => rotator ! Revert\n  }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Dart", "code": "\nFlutter[edit]\nLibrary: Flutter\n\nimport 'package:flutter/material.dart';\nimport 'dart:async' show Timer;\n\nvoid main() {\n  \n  var timer = const Duration( milliseconds: 75 ); // How often to update i.e. how fast the animation is\n  \n  runApp(MaterialApp (\n    home: Scaffold (\n      body: Center (\n        child: AnimatedText( timer )\n      )\n    )\n  ));\n}\n\nclass AnimatedText extends StatefulWidget {\n  \n  final Duration period; // Time period for update\n  \n  AnimatedText( this.period );\n  @override\n  _AnimatedText createState() => _AnimatedText( period );\n}\n\n\nclass _AnimatedText extends State<AnimatedText> {\n  \n  bool forward = true; // Text should go forward?\n  \n  Timer timer; // Timer Objects allow us to do things based on a period of time\n  // We want to get an array of characters, but Dart does not have a char type\n  // Below is the equivalent code\n  var _text =  'Hello World!      '.runes // .runes gives us the unicode number of each character\n    .map( (code) => String.fromCharCode(code) ) // Map all these codes to Strings containing the single character\n    .toList(); // Conver to a List\n  \n  _AnimatedText( Duration period ){\n    timer = Timer.periodic( period , (_){\n      setState((){ // Set state forces the gui elements to be redrawn\n        shiftText();\n        \n      });  \n    });\n  }\n  \n  String get text => _text.join(''); // Getter, joins the list of chars into a string\n  \n  void shiftText() {\n    if (forward) { // If we should go forward\n      var last = _text.removeLast(); // Remove the last char\n\n      _text.insert( 0, last); // Insert it at the front\n      \n    } else { // If we should go backward\n      var first = _text.removeAt(0); // Remove the first char\n      \n      _text.insert( _text.length, first ); // Insert it at the end\n    }\n    \n }\n  \n  @override\n  Widget build(BuildContext context) {\n    return GestureDetector( // GestureDetector lets us capture events\n      onTap: () => forward = !forward, // on Tap (Click in browser) invert the forward bool\n      child: Text(\n        text, // Call the text getter to get the shifted string\n        style: TextStyle( // Styling\n          fontSize: 50,\n          color: Colors.grey[600]\n        )\n      )\n    \n    );   \n  }\n    \n}\n\n\nHTML DOM[edit]\nLibrary: Html Dom\nimport 'dart:html';\nimport 'dart:async';\n\nconst frameTime = const Duration(milliseconds: 100);\n\nvoid main() {\n  String text = \"Hello World! \";\n  bool rotateRight = true;\n\n  Element writeHere =\n      querySelector('#output'); // assumes you have a pre with that ID\n  writeHere.onClick.listen((event) => rotateRight = !rotateRight);\n\n  new Timer.periodic(frameTime, (_) {\n    text = changeText(text, rotateRight);\n    writeHere.text = text;\n  });\n}\n\nString changeText(extt, rotateRight) {\n  if (rotateRight) {\n    return extt.substring(extt.length - 1) + extt.substring(0, extt.length - 1);\n  } else {\n    return extt.substring(1) + extt.substring(0, 1);\n  }\n}\n\n", "explain": "view it on dartpad!\n\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "D", "code": "\nLibrary: QD\nuses Library: SDL\nLibrary: SDL_ttf\nLibrary: tools\nmodule test26;\n\nimport qd, SDL_ttf, tools.time;\n\nvoid main() {\n  screen(320, 200);\n  auto last = sec();\n  string text = \"Hello World! \";\n  auto speed = 0.2;\n  int dir = true;\n  while (true) {\n    cls;\n    print(10, 10, Bottom|Right, text);\n    if (sec() - last > speed) {\n      last = sec();\n      if (dir == 0) text = text[$-1] ~ text[0 .. $-1];\n      else text = text[1 .. $] ~ text[0];\n    }\n    flip; events;\n    if (mouse.clicked\n      && mouse.pos in display.select(10, 10, 100, 20)\n    ) dir = !dir;\n  }\n}\n\n", "explain": ""}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Haskell", "code": "\nUsing simple graphics Library: HGL from HackageDB\nimport Graphics.HGL.Units (Time, Point, Size, )\nimport Graphics.HGL.Draw.Monad (Graphic, )\nimport Graphics.HGL.Draw.Text\nimport Graphics.HGL.Draw.Font\nimport Graphics.HGL.Window\nimport Graphics.HGL.Run\nimport Graphics.HGL.Utils\n\nimport Control.Exception (bracket, )\n\nrunAnim = runGraphics $\n bracket\n  (openWindowEx \"Basic animation task\" Nothing (250,50) DoubleBuffered (Just 110))\n  closeWindow\n  (\\w -> do\n    f <- createFont (64,28) 0 False False \"courier\" \n    let loop t dir = do\n\t  e <- maybeGetWindowEvent w\n\t  let d = case e of\n\t\t  Just (Button _ True False)  -> -dir\n\t\t  _ -> dir\n\t      t' = if d == 1 then last t : init t else tail t ++ [head t]\n\t  setGraphic w (withFont f $ text (5,10) t') >> getWindowTick w \n\t  loop  t' d\n\t      \n    loop \"Hello world\u00a0! \" 1  )\n\n\n*Main> runAnim\n\n", "explain": "Run within interpreter GHCi:\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "Logo", "code": "\nWorks with: UCB Logo\nto rotate.left :thing\n  output lput first :thing butfirst :thing\nend\nto rotate.right :thing\n  output fput last :thing butlast :thing\nend\n\nmake \"text \"|Hello World! |\nmake \"right? \"true\n\nto step.animation\n  label :text\t\t\t; graphical\n \u00a0; type char 13  type :text\t; textual\n  wait 6\t\t\t; 1/10 second\n  if button <> 0 [make \"right? not :right?]\n  make \"text ifelse :right? [rotate.right :text] [rotate.left :text]\nend\n\nhideturtle\nuntil [key?] [step.animation]\n\n", "explain": "\n"}, {"task_name": "Animation", "task_url": "https://rosettacode.org/wiki/Animation", "task_cat": "Temporal media", "lang": "F#", "code": "\nLibrary: Windows Presentation Foundation\nopen System.Windows\n\nlet str = \"Hello world! \"\nlet mutable i = 0\nlet mutable d = 1\n\n[<System.STAThread>]\ndo\n  let button = Controls.Button()\n  button.Click.Add(fun _ -> d <- str.Length - d)\n  let update _ =\n    i <- (i + d) % str.Length\n    button.Content <- str.[i..] + str.[..i-1]\n  Media.CompositionTarget.Rendering.Add update\n  (Application()).Run(Window(Content=button)) |> ignore\n\n", "explain": ""}]