[{"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Python", "code": "\nAscii-Art[edit]\nTranslation of: C\nimport math\n\nshades = ('.',':','!','*','o','e','&','#','%','@')\n\ndef normalize(v):\n\tlen = math.sqrt(v[0]**2 + v[1]**2 + v[2]**2)\n\treturn (v[0]/len, v[1]/len, v[2]/len)\n\ndef dot(x,y):\n\td = x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n\treturn -d if d < 0 else 0\n\ndef draw_sphere(r, k, ambient, light):\n\tfor i in range(int(math.floor(-r)),int(math.ceil(r)+1)):\n\t\tx = i + 0.5\n\t\tline = ''\n\n\t\tfor j in range(int(math.floor(-2*r)),int(math.ceil(2*r)+1)):\n\t\t\ty = j/2 + 0.5\n\t\t\tif x*x + y*y <= r*r:\n\t\t\t\tvec = normalize((x,y,math.sqrt(r*r - x*x - y*y)))\n\t\t\t\tb = dot(light,vec)**k + ambient\n\t\t\t\tintensity = int((1-b)*(len(shades)-1))\n\t\t\t\tline += shades[intensity] if 0 <= intensity < len(shades) else shades[0]\n\t\t\telse:\n\t\t\t\tline += ' '\n\n\t\tprint(line)\n\nlight = normalize((30,30,-50))\ndraw_sphere(20,4,0.1, light)\ndraw_sphere(10,2,0.4, light)\n\n\nOutput:\n                                &&&&&&&&&&######                                 \n                        &&eeeeeeeeeeeeeeee&&&&&&######%%                         \n                    &&oooo********ooooooeeeeee&&&&########%%                     \n                  oo****!!!!!!!!******ooooooeeee&&&&########%%                   \n              eeoo**!!!!::::::::!!!!******ooooeeee&&&&########%%%%               \n            ee**!!::::::....::::::!!!!!!**ooooeeee&&&&&&########%%%%             \n          ee**!!::..............::::!!!!****ooooeeee&&&&########%%%%%%           \n        ee**!!::..................::::!!!!**ooooeeee&&&&##########%%%%%%         \n        oo!!::....................::::!!!!****ooeeee&&&&&&########%%%%%%         \n      oo**::......................::::!!!!****ooeeee&&&&&&##########%%%%%%       \n    &&**!!::......................::::!!!!****ooeeee&&&&&&##########%%%%%%%%     \n    oo**!!::......................::::!!!!**ooooeeee&&&&&&##########%%%%%%%%     \n  &&oo!!::........................::::!!****ooooeeee&&&&&&##########%%%%%%%%%%   \n  ee**!!::......................::::!!!!****ooooeeee&&&&&&##########%%%%%%%%%%   \n  ee**!!::::..................::::::!!!!****ooooeeee&&&&############%%%%%%%%%%   \n  ee**!!::::................::::::!!!!****ooooeeee&&&&&&############%%%%%%%%%%   \n&&ee****!!::::............::::::!!!!****ooooooeeee&&&&&&##########%%%%%%%%%%%%%% \n&&eeoo**!!!!::::::::::::::::::!!!!******ooooeeee&&&&&&############%%%%%%%%%%%%%% \n&&eeoo****!!!!::::::::::::!!!!!!******ooooeeeeee&&&&&&############%%%%%%%%%%%%%% \n&&eeoooo**!!!!!!!!!!!!!!!!!!!!******ooooeeeeee&&&&&&############%%%%%%%%%%%%%%%% \n&&eeeeoo******!!!!!!!!!!********ooooooeeeeee&&&&&&&&############%%%%%%%%%%%%%%%% \n##&&eeoooooo******************ooooooeeeeee&&&&&&&&############%%%%%%%%%%%%%%%%%% \n##&&eeeeoooooooo******ooooooooooooeeeeee&&&&&&&&##############%%%%%%%%%%%%%%%%%% \n##&&&&eeeeeeooooooooooooooooooeeeeeeee&&&&&&&&##############%%%%%%%%%%%%%%%%%%%% \n  ##&&&&eeeeeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&&################%%%%%%%%%%%%%%%%%%   \n  ####&&&&&&eeeeeeeeeeeeeeeeee&&&&&&&&&&&&################%%%%%%%%%%%%%%%%%%%%   \n  ######&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&##################%%%%%%%%%%%%%%%%%%%%%%   \n \u00a0%%######&&&&&&&&&&&&&&&&&&&&&&&&####################%%%%%%%%%%%%%%%%%%%%%%%%   \n    ############&&&&&&&&&&&&########################%%%%%%%%%%%%%%%%%%%%%%%%     \n   \u00a0%%############################################%%%%%%%%%%%%%%%%%%%%%%%%%%     \n     \u00a0%%######################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%       \n       \u00a0%%################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         \n       \u00a0%%%%%%########################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         \n         \u00a0%%%%%%%%##############%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%           \n           \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%             \n             \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               \n                 \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                   \n                   \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                     \n                       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                         \n                               \u00a0%%%%%%%%%%%%%%%%                                 \n                                                                                 \n             \u00a0::..::::!!**               \n          ..............::!!oo           \n      ..................::!!**ooee       \n    ......................::!!**ooee     \n    ......................::!!**ooee     \n  ........................::!!**ooooee   \n  ........................::!!**ooooee   \n::........................::!!**ooooeeee \n........................::!!!!**ooooeeee \n::......................::!!****ooeeeeee \n::....................::!!!!**ooooeeeeee \n!!..................::!!!!****ooeeeeeeee \n**::::..........::::!!!!****ooooeeeeeeee \n \u00a0!!!!::::::::::!!!!!!****ooooeeeeeeee   \n  oo**!!!!!!!!!!!!******ooooeeeeeeeeee   \n    oo**************ooooooeeeeeeeeee     \n    eeooooooooooooooooeeeeeeeeeeeeee     \n      eeeeooooooooeeeeeeeeeeeeeeee       \n          eeeeeeeeeeeeeeeeeeee           \n              eeeeeeeeeeee\n\nLibrary: Pygame[edit]\nPython Sphere\n\nimport pygame\nfrom pygame.locals import *\nimport time\nimport sys\nimport random\nimport math\n\nclass Tricubic:\n    def __init__(self,pts):\n        self.coefficients = []\n        for plane in pts:\n            planecoeffs = []\n            for line in plane:\n                p = (line[3]-line[2])-(line[0]-line[1])\n                q = (line[0]-line[1])-p\n                r = line[2]-line[0]\n                s = line[1]\n                planecoeffs.append([p,q,r,s])\n            self.coefficients.append(planecoeff)\n    def Eval(at):\n        return Misc.Cubic([CoeffBicubic(coeffs[0],d),CoeffBicubic(coeffs[1],d),CoeffBicubic(coeffs[2],d),CoeffBicubic(coeffs[3],d)],d.z)\n    def CoeffCubic(coeffs,d):\n        return (coeffs[0]*(d.x**3))+(coeffs[1]*(d.x**2))+(coeffs[2]*d.x)+coeffs[3]\n    def CoeffBicubic(coeffs,d):\n        return Misc.Cubic([CoeffCubic(coeffs[0],d),CoeffCubic(coeffs[1],d),CoeffCubic(coeffs[2],d),CoeffCubic(coeffs[3],d)],d.y)\nclass Misc:\n    def LinePara(line,t):\n        return Vector3.Add(line[0],Vector3.Scale(Vector3.Subtract(line[1],line[0]),t))\n    def LUR(at,above):\n        look = at.Unit()\n        right = Vector3.Cross(look,above).Unit()\n        up = Vector3.Scale(Vector3.Cross(look,right),-1)\n        return [look,up,right]\n    def LinePlane(line,triangle,cp=True):\n        try:\n            u = Vector3.Subtract(triangle.points[1].point,triangle.points[0])\n            v = Vector3.Subtract(triangle.points[2],triangle.points[0])\n            n = Vector3.Cross(u,v)\n            r = (Vector3.Dot(n,Vector3.Subtract(triangle.points[0],line.start))/Vector3.Dot(n,line.direction))\n            if stp:\n                point = Vector3.Add(Vector3.Scale(line.direction,r),line.start)\n                w = Vector3.Subtract(point,triangle.points[0])\n                udv = Vector3.Dot(u,v)\n                wdv = Vector3.Dot(w,v)\n                vdv = Vector3.Dot(v,v)\n                wdu = Vector3.Dot(w,u)\n                udu = Vector3.Dot(u,u)\n                denominator = (udv**2)-(udu*vdv)\n                s = ((udv*wdv)-(vdv*wdu))/denominator\n                t = ((udv*wdu)-(udu*wdv))/denominator\n                return [r,Vector2(s,t),point]\n                print('hooray')\n            else:\n                return [r]\n        except:\n            return None\n    def Cubic(pts,d):\n        p = (pts[3]-pts[2])-(pts[0]-pts[1])\n        q = (pts[0]-pts[1])-p\n        r = pts[2]-pts[0]\n        s = pts[1]\n        return (p*(d**3))+(q*(d**2))+(r*d)+s\n    def Bicubic(pts,d):\n        return Misc.Cubic([Misc.Cubic(pts[0],d.x),Misc.Cubic(pts[1],d.x),Misc.Cubic(pts[2],d.x),Misc.Cubic(pts[3],d.x)],d.y)\n    def Tricubic(pts,d):\n        return Misc.Cubic([Misc.Bicubic(pts[0],d),Misc.Bicubic(pts[1],d),Misc.Bicubic(pts[2],d),Misc.Bicubic(pts[3],d)],d.z)\n    def Quadcubic(pts,d):\n        return Misc.Cubic([Misc.Tricubic(pts[0],d),Misc.Tricubic(pts[1],d),Misc.Tricubic(pts[2],d),Misc.Tricubic(pts[3],d)],d.w)\n    def Linear(pts,d):\n        return (pts[2]*d)+(pts[1]*(1-d))\n    def Bilinear(pts,d):\n        return Misc.Linear([0,Misc.Linear(pts[1],d.x),Misc.Linear(pts[2],d.x)],d.y)\n    def Trilinear(pts,d):\n        return Misc.Linear([0,Misc.Bilinear(pts[1],d),Misc.Bilinear(pts[2],d)],d.z)\n    def LP2(line,triangle,cp=True):\n        try:\n            bla = triangle.points[1]\n            bla = triangle.points[0]\n            u = Vector3.Subtract(triangle.points[1].point,triangle.points[0].point)\n            v = Vector3.Subtract(triangle.points[2].point,triangle.points[0].point)\n            n = Vector3.Cross(u,v)\n            d = Vector3.Subtract(line[1],line[0])\n            r = (Vector3.Dot(n,Vector3.Subtract(triangle.points[0].point,line[0]))/Vector3.Dot(n,d))\n            if cp:\n                point = Vector3.Add(Vector3.Scale(d,r),line[0])\n                w = Vector3.Subtract(point,triangle.points[0].point)\n                udv = Vector3.Dot(u,v)\n                wdv = Vector3.Dot(w,v)\n                vdv = Vector3.Dot(v,v)\n                wdu = Vector3.Dot(w,u)\n                udu = Vector3.Dot(u,u)\n                denominator = (udv**2)-(udu*vdv)\n                s = ((udv*wdv)-(vdv*wdu))/denominator\n                t = ((udv*wdu)-(udu*wdv))/denominator\n                return (r,Vector2(s,t),point)\n            else:\n                return (r)\n        except:\n            return None\n    def Phong(normal,viewer,light,material,term):\n        # light (vector_to,diffuse,specular)\n        # material (ambient,diffuse,specular,shininess)\n        n = normal.Unit()\n        v = viewer.Unit()\n        l = light[0].Unit()\n        ldn = Vector3.Dot(l,n)\n        #print(ldn)\n        val = 0\n        if ldn > 0:\n            val += material[1][term]*ldn*light[1][term]\n            rdv = Vector3.Dot(Vector3.Subtract(Vector3.Scale(n,2*ldn),l),v)\n            if rdv > 0:\n                val += (material[2][term]*(rdv**material[3])*light[2][term])\n        #print(val)\n        return val\n    def Lighting(ambient,normal,viewer,lights,material,term):\n        # lights [(vector_to,diffuse,specular)]\n        # material (ambient,diffuse,specular,shininess)\n        val = material[0][term]*ambient[term]\n        for light in lights:\n            val += Misc.Phong(normal,viewer,light,material,term)\n        return val\n    def Lighting2(start,direction,ambient,intersect,triangle,lights):\n        coord = intersect[1]\n        val = Color.Add(Color.Multiply(ambient,Color.Multiply(triangle.material.color['ambient'],triangle.Map('ambient',coord))),\n                        Color.Multiply(triangle.material.color['glow'],triangle.Map('glow',coord)))\n        for light in lights:\n            for n in range(3):\n                val[n] += Misc.Phong(triangle.InterpolatedNormal(coord),\n                                     Vector3.Scale(direction,-1),\n                                     (light.To(intersect[2]),light.Diffuse(intersect[2]),light.Specular(intersect[2])),\n                                     (Color(),\n                                      Color.Multiply(triangle.material.color['diffuse'],triangle.Map('diffuse',coord)),\n                                      Color.Multiply(triangle.material.color['specular'],triangle.Map('specular',coord)),\n                                      triangle.material.shiny),n)\n        return val\n    def Ray(start,direction,scene,color=True,sector=None):\n        intersect = None\n        intersected = None\n        col = None\n        for triangle in scene.triangles:\n            possible = True\n            if sector != None:\n                possible = False\n                for point in triangle.points:\n                    if not(point.sector.x < sector.x):\n                        possible = True\n                if possible:\n                    possible = False\n                    for point in triangle.points:\n                        if not(point.sector.x > sector.x):\n                            possible = True\n                if possible:\n                    possible = False\n                    for point in triangle.points:\n                        if not(point.sector.y < sector.y):\n                            possible = True\n                if possible:\n                    possible = False\n                    for point in triangle.points:\n                        if not(point.sector.y > sector.y):\n                            possible = True\n            possible = True\n            if possible:\n                tmp = Misc.LP2([start,Vector3.Add(start,direction)],triangle,color)\n                write = False\n                if type(tmp) == type(5.1):\n                    tmp = None\n                if (tmp != None):\n                    if (intersect == None):\n                        if (tmp[0] > 0) and (tmp[1].x >= 0) and (tmp[1].y >= 0) and (tmp[1].x+tmp[1].y <= 1):\n                            write = True\n                    elif (tmp[0] > 0) and (tmp[0] < intersect[0]) and (tmp[1].x >= 0) and (tmp[1].y >= 0) and (tmp[1].x+tmp[1].y <= 1):\n                        write = True\n                if write:\n                    intersect = tmp\n                    intersected = triangle\n        if color and (intersect != None):\n            applicable = []\n            for light in scene.lights:\n                block = Misc.Ray(intersect[2],light.To(intersect[2]),scene,False)\n                if block == None:\n                    applicable.append(light)\n                elif light.location != None:\n                    if Vector3.Subtract(light.location,intersect[2]).Magnitude() < block[0]:\n                        applicable.append(light)\n            col = Misc.Lighting2(start,direction,scene.ambient,intersect,intersected,applicable)\n            return (intersect,col)\n        else:\n            return intersect\nclass DirLight:\n    def __init__(self,direction,diffuse,specular):\n        self.location = None\n        self.direction = direction.Unit()\n        self.diffuse = diffuse\n        self.specular = specular\n    def To(self,frm):\n        return Vector3.Scale(self.direction,-1)\n    def Diffuse(self,to):\n        return self.diffuse\n    def Specular(self,to):\n        return self.specular\nclass Material:\n    def __init__(self):\n        self.color = {'ambient':Color(1,1,1),\n                      'diffuse':Color(1,1,1),\n                      'specular':Color(1,1,1),\n                      'glow':Color(1,1,1)}\n        self.maps = {'ambient':Map(),\n                     'diffuse':Map(),\n                     'specular':Map(),\n                     'glow':Map(),\n                     'bump':Map()}\n        self.shiny = 10\nclass Map:\n    def __init__(self,surface=None):\n        self.surface = surface\n        if self.surface != None:\n            self.width = self.surface.get_width()\n            self.height = self.surface.get_height()\n    def __getitem__(self,index):\n        if self.surface == None:\n            return Color(1,1,1)\n        else:\n            try:\n                return Color.From255(self.surface.get_at((int(index.x*(self.width-1)),int(index.y*(self.height-1)))))\n            except:\n                return Color(0,0,1)\nclass Color:\n    def __init__(self,r=0,g=0,b=0):\n        self.r = r\n        self.g = g\n        self.b = b\n    def __getitem__(self,index):\n        if index == 0:\n            return self.r\n        elif index == 1:\n            return self.g\n        elif index == 2:\n            return self.b\n    def __setitem__(self,index,value):\n        if index == 0:\n            self.r = value\n        elif index == 1:\n            self.g = value\n        elif index == 2:\n            self.b = value\n    def Multiply(A,B):\n        return Color(A.r*B.r,A.g*B.g,A.b*B.b)\n    def Add(A,B):\n        return Color(A.r+B.r,A.g+B.g,A.b+B.b)\n    def From255(A):\n        return Color(A.r/255,A.g/255,A.b/255)\nclass Vertex:\n    def __init__(self,point,normal,maps):\n        self.bpoint = point\n        self.bnormal = normal\n        self.maps = maps\n        for name in ['ambient','diffuse','specular','glow','bump']:\n            try:\n                bla = self.maps[name]\n            except:\n                self.maps[name] = Vector2()\n        self.sector = None\n    def Transform(self,points,norms):\n        self.point = Matrix2.Multiply(self.bpoint.Horizontal(),points).Vectorize()\n        self.normal = Matrix2.Multiply(self.bnormal.Horizontal(),norms).Vectorize()\nclass Triangle:\n    def __init__(self,vertices,material=Material()):\n        self.points = vertices\n        self.material = material\n    def Map(self,name,coord):\n        pts = []\n        for n in range(3):\n            pts.append(self.points[n].maps[name])\n        loc = Vector2.Add(pts[0],\n                          Vector2.Add(Vector2.Scale(Vector2.Subtract(pts[1],pts[0]),coord.x),\n                                      Vector2.Scale(Vector2.Subtract(pts[2],pts[0]),coord.y)))\n        #print(loc.x,loc.y)\n        return self.material.maps[name][loc]\n    def InterpolatedNormal(self,coord):\n        return Vector3.Add(Vector3.Scale(self.points[0].normal,1-coord.x-coord.y),\n                           Vector3.Add(Vector3.Scale(self.points[1].normal,coord.x),Vector3.Scale(self.points[2].normal,coord.y))).Unit()\nclass Line:\n    def __init__(self,A,B=None,direction=None):\n        self.start = A\n        if B != None:\n            self.direction = Vector3.Subtract(B,A).Unit()\n        elif direction != None:\n            self.direction = direction\n        else:\n            raise RuntimeError('Neither B nor direction are specified')\nclass Scene:\n    def __init__(self):\n        self.triangles = []\n        self.vertices = []\n        self.lights = []\n        self.exterior = []\n        self.ambient = 0\nclass Matrix2:\n    def __init__(self,data=[[]]):\n        self.FromData(data)\n    def __getitem__(self,index):\n        return self.data[index[1]][index[0]]\n    def __setitem__(self,index,value):\n        self.data[index[1]][index[0]]=value\n    def Dimension(self):\n        self.rows = len(self.data)\n        self.cols = len(self.data[0])\n    def FromData(self,data):\n        self.data = data\n        length=len(data[0])\n        for row in data:\n            if len(row)!=length:\n                self.data=None\n                raise RuntimeError('Data rows are not of uniform length.')\n        self.Dimension()\n    def Multiply(A,B):\n        if A.cols!=B.rows:\n            raise RuntimeError('Column count of Matrix2 \\\"A\\\" does not match row count of Matrix2 \\\"B\\\".')\n        matrix = Matrix2.Empty(B.cols,A.rows)\n        x=0\n        while x<matrix.cols:\n            y=0\n            while y<matrix.rows:\n                val=0\n                n=0\n                while n<A.cols:\n                    val+=A[(n,y)]*B[(x,n)]\n                    n+=1\n                matrix[(x,y)]=val\n                y+=1\n            x+=1\n        return matrix\n    def Scalar(A,n):\n        pass\n    def Empty(rows,cols):\n        data = []\n        row = [0]*rows\n        n = 0\n        while n < cols:\n            data.append(row[:])\n            n+=1\n        matrix=Matrix2(data)\n        matrix.Dimension()\n        return matrix\n    def Identity(cols):\n        matrix = Matrix2.Empty(cols,cols)\n        n = 0\n        while n < cols:\n            matrix[(n,n)]=1\n            n += 1\n        return matrix\n    def Vectorize(self):\n        if self.cols==1:\n            if self.rows!=4:\n                raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')\n            vertical=True\n        elif self.rows==1:\n            if self.cols!=4:\n                raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')\n            vertical = False\n        else:\n            raise RuntimeError('Only 1 by 4 or 4 by 1 Matrix2s can be cast to Vector3s.')\n        vector=[0]*4\n        n=0\n        while n<4:\n            if vertical:\n                vector[n]=self[(0,n)]\n            else:\n                vector[n]=self[(n,0)]\n            n+=1\n        return Vector3(vector[0],vector[1],vector[2],vector[3])\n    def Print(self,decimals,spaces):\n        length=0\n        for row in self.data:\n            for val in row:\n                string=str(round(val,decimals))\n                if length<len(string):\n                    length=len(string)\n        text=''\n        for row in self.data:\n            temp=''\n            for value in row:\n                val=str(round(float(value),decimals))\n                pads=length-len(val)\n                pad=int(pads/2)\n                temp+=(' '*pad)+val+(' '*(pads-pad))+(' '*spaces)\n            text+=(' '*spaces)+temp[0:len(temp)-1]+(' '*spaces)+'\\n'\n        return(text[0:len(text)-1])\n    def RotX(angle):\n        return Matrix2([\n            [1,0,0,0],\n            [0,math.cos(angle),0-math.sin(angle),0],\n            [0,math.sin(angle),math.cos(angle),0],\n            [0,0,0,1]])\n    def RotY(angle):\n        return Matrix2([\n            [math.cos(angle),0,0-math.sin(angle),0],\n            [0,1,0,0],\n            [math.sin(angle),0,math.cos(angle),0],\n            [0,0,0,1]])\n    def RotZ(angle):\n        return Matrix2([\n            [math.cos(angle),0-math.sin(angle),0,0],\n            [math.sin(angle),math.cos(angle),0,0],\n            [0,0,1,0],\n            [0,0,0,1]])\n    def Translate(vector):\n        return Matrix2([\n            [1,0,0,0],\n            [0,1,0,0],\n            [0,0,1,0],\n            [vector.x,vector.y,vector.z,1]])\n    def Scale(vector):\n        return Matrix2([\n            [vector.x,0,0,0],\n            [0,vector.y,0,0],\n            [0,0,vector.z,0],\n            [0,0,0,1]])\n    def Clone(self):\n        data = []\n        for row in self.data:\n            data.append(row[:])\n        return Matrix2(data)\n    def Inverse(self):\n        adjoint = self.Adjoint()\n        det = self.Determinant()\n        if det == 0:\n            raise RuntimeError('Cannot find the inverse of a matrix with a determinant of 0')\n        inverse = Matrix2.Empty(self.rows,self.cols)\n        x = 0\n        while x < self.cols:\n            y = 0\n            while y < self.rows:\n                inverse[(x,y)] = adjoint[(x,y)]/det\n                y += 1\n            x += 1\n        return inverse\n    def Transpose(self):\n        transpose = Matrix2.Empty(self.cols,self.rows)\n        x = 0\n        while x < self.cols:\n            y = 0\n            while y < self.rows:\n                transpose[(y,x)] = self[(x,y)]\n                y += 1\n            x += 1\n        return transpose\n    def Adjoint(self):\n        return self.Cofactors().Transpose()\n    def Determinant(self):\n        if self.rows != self.cols:\n            raise RuntimeError('Cannot find the determinant of a non-square matrix')\n        if self.rows == 1:\n            return self[(0,0)]\n        cofactors = self.Cofactors()\n        determinant = 0\n        n = 0\n        while n < self.cols:\n            determinant += self[(n,0)]*cofactors[(n,0)]\n            n += 1\n        return determinant\n    def Minors(self):\n        if self.rows != self.cols:\n            raise RuntimeError('Cannot find the minors of a non-square matrix')\n        if self.rows == 1:\n            raise RuntimeError('Cannot find the minors of a 1 by 1 matrix')\n        minors = Matrix2.Empty(self.rows,self.cols)\n        lines = range(self.rows)\n        x = 0\n        while x < self.cols:\n            y = 0\n            while y < self.cols:\n                tiny = Matrix2.Empty(self.rows-1,self.cols-1)\n                ox = 0\n                nx = 0\n                while ox < self.cols:\n                    oy = 0\n                    ny = 0\n                    while oy < self.cols:\n                        if not((ox == x) or (oy == y)):\n                            tiny[(nx,ny)] = self[(ox,oy)]\n                        if oy != y:\n                            ny += 1\n                        oy += 1\n                    if ox != x:\n                        nx += 1\n                    ox += 1\n                minors[(x,y)] = tiny.Determinant()\n                y += 1\n            x += 1\n        return minors\n    def Cofactors(self):\n        minors = self.Minors()\n        cofactors = Matrix2.Empty(self.rows,self.cols)\n        x = 0\n        while x < self.cols:\n            y = 0\n            while y < self.rows:\n                if int((x+y)/2) == ((x+y)/2):\n                    cofactors[(x,y)] = minors[(x,y)]\n                else:\n                    cofactors[(x,y)] = -1*minors[(x,y)]\n                y += 1\n            x += 1\n        return cofactors\n    def Perspective(e):\n        return Matrix2([\n            [1,0,0,0],\n            [0,1,0,0],\n            [0,0,1,1/e[2]],\n            [-e[0],-e[1],0,0]])\n    def Add(A,B):\n        if A.rows != B.rows:\n            RuntimeError('The row counts of Matrix \\\"A\\\" and Matrix \\\"B\\\" are not identical.')\n        if A.cols != B.cols:\n            RuntimeError('The column counts of Matrix \\\"A\\\" and Matrix \\\"B\\\" are not identical.')\n        matrix = Matrix.Empty(A.rows,A.cols)\n        for x in range(A.cols):\n            for y in range(A.rows):\n                matrix[(x,y)] = A[(x,y)]+B[(x,y)]\n        return matrix\n    def Subtract(A,B):\n        if A.rows != B.rows:\n            RuntimeError('The row counts of Matrix \\\"A\\\" and Matrix \\\"B\\\" are not identical.')\n        if A.cols != B.cols:\n            RuntimeError('The column counts of Matrix \\\"A\\\" and Matrix \\\"B\\\" are not identical.')\n        matrix = Matrix.Empty(A.rows,A.cols)\n        for x in range(A.cols):\n            for y in range(A.rows):\n                matrix[(x,y)] = A[(x,y)]+B[(x,y)]\n        return matrix\n    def DivHomogeneous(self):\n        if (self.cols,self.rows) == (1,4):\n            for y in range(3):\n                self[(0,y)] = self[(0,y)]/self[(0,3)]\n            self[(0,3)] = 1\n        if (self.cols,self.rows) == (4,1):\n            for x in range(3):\n                self[(x,0)] = self[(x,0)]/self[(3,0)]\n            self[(3,0)] = 1\n        else:\n            raise RuntimeError('1 by 4 or 4 by 1 Matrix2 expected')\n    def Object(pos,look,up,right):\n        return Matrix2([\n            [right.x,right.y,right.z,0],\n            [up.x,up.y,up.z,0],\n            [look.x,look.y,look.z,0],\n            [pos.x,pos.y,pos.z,1]])\n    def Camera(eye,look,up,right):\n        return Matrix2([\n            [right.x,up.x,look.x,0],\n            [right.y,up.y,look.y,0],\n            [right.z,up.z,look.z,0],\n            [-Vector3.Dot(eye,right),\n             -Vector3.Dot(eye,up),\n             -Vector3.Dot(eye,look),1]])\n    def YPR(rot):\n        return Matrix2.Multiply(\n            Matrix2.Multiply(Matrix2.RotZ(rot.z),\n                             Matrix2.RotX(rot.x)),\n            Matrix2.RotY(rot.y))\nclass Vector2:\n    def __init__(self,data=0,y=0):\n        if (type(data) == type(5)) or (type(data) == type(5.1)):\n            self.x = data\n            self.y = y\n        else:\n            self.x = data[0]\n            self.y = data[1]\n    def __getitem__(self,index):\n        if index == 0:\n            return self.x\n        elif index == 1:\n            return self.y\n    def __setitem__(self,index,value):\n        if index == 0:\n            self.x = value\n        elif index == 1:\n            self.y = 1\n    def Add(A,B):\n        return Vector2(A.x+B.x,A.y+B.y)\n    def Subtract(A,B):\n        return Vector2(A.x-B.x,A.y-B.y)\n    def Scale(A,n):\n        return Vector2(A.x*n,A.y*n)\n    def Magnitude(self):\n        return ((self.x**2)+(self.y**2))**.5\n    def Unit(self):\n        return Vector2.Scale(self,1/self.Magnitude())\n    def Clone(self):\n        return Vector2(self.x,self.y)\nclass Vector3:\n    def __init__(self,data=0,y=0,z=0,w=1):\n        if (type(data) == type(5)) or (type(data) == type(5.1)):\n            self.x = data/w\n            self.y = y/w\n            self.z = z/w\n        else:\n            try:\n                temp = data[3]\n            except:\n                temp = 1\n            self.x = data[0]/temp\n            self.y = data[1]/temp\n            self.z = data[2]/temp\n    def __getitem__(self,index):\n        if index == 0:\n            return self.x\n        elif index == 1:\n            return self.y\n        elif index == 2:\n            return self.z\n    def __setitem__(self,index,value):\n        if index == 0:\n            self.x = value\n        elif index == 1:\n            self.y = value\n        elif index == 2:\n            self.z = value\n    def Vertical(self):\n        return Matrix2([[self.x],[self.y],[self.z],[1]])\n    def Horizontal(self):\n        return Matrix2([[self.x,self.y,self.z,1]])\n    def Dot(A,B):\n        return (A.x*B.x)+(A.y*B.y)+(A.z*B.z)\n    def Cross(A,B):\n        return Vector3([\n            (A.y*B.z)-(A.z*B.y),\n            (A.z*B.x)-(A.x*B.z),\n            (A.x*B.y)-(A.y*B.x)])\n    def Add(A,B):\n        return Vector3(A.x+B.x,A.y+B.y,A.z+B.z)\n    def Subtract(A,B):\n        return Vector3(A.x-B.x,A.y-B.y,A.z-B.z)\n    def Scale(A,n):\n        return Vector3(A.x*n,A.y*n,A.z*n)\n    def Magnitude(self):\n        return ((self.x**2)+(self.y**2)+(self.z**2))**.5\n    def Print(self,decimals,spaces):\n        return self.Horizontal().Print(decimals,spaces)\n    def Same(A,B):\n        same = False\n        if A.x == B.x:\n            if A.y == B.y:\n                if A.z == B.z:\n                    same = True\n        return same\n    def Unit(self):\n        return Vector3.Scale(self,1/self.Magnitude())\n    def Clone(self):\n        return Vector3(self.x,self.y,self.z)\nclass Vector4:\n    def __init__(self,data=0,y=0,z=0,w=0):\n        if (type(data) == type(5)) or (type(data) == type(5.1)):\n            self.x = data\n            self.y = y\n            self.z = z\n            self.w = w\n        else:\n            self.x = data[0]\n            self.y = data[0]\n            self.z = data[0]\n            self.w = data[0]\n\npoints = [Vector3([-1,-1,0]),Vector3([1,-1,0]),Vector3([0,1,0])]\nwidth = 255\nheight = width\nscreen = pygame.display.set_mode((width,height),0,32)\nscl = 2\npos =  Vector3([0,0,5])\nview = Vector3([0,0,1])\nframes = 0\n\ndef Transform(point,mat):\n   return Matrix2.Multiply(point.Horizontal(),mat).Vectorize()\n\ndef RV():\n   return Vector3([random.random(),random.random(),random.random()])\n\ngreen = pygame.Color(0,255,0)\ndef XY(bla):\n   return (((width*bla[0])+width)/2,((height*bla[1])+width)/2)\n\nscreen.fill(pygame.Color(0,0,0))\nsize = 255\n\nworld = Matrix2.Identity(4)\ninv = world.Inverse()\ninvt = world.Inverse().Transpose()\ncenter = Vector3(0,0,2)\n\n\ndef Texture(size):\n   texture = []\n   for pa in range(size):\n      plane = []\n      for pb in range(size):\n         line = []\n         for pc in range(size):\n            line.append(random.random())\n         plane.append(line)\n      texture.append(plane)\n   return texture\n\nlights = [(Vector3(-10,6,-9),[.7,.7*.9,.7*.8],[.7,.7*.9,.9*.8])]\nlights = [(Vector3(-10,6,-9),[.8,.8,.8],[.7,.7,.7])]\n\ndepth = 3\ngroups = []\nfor n in range(1):  \n   textures = []\n   for n in range(depth):\n      textures.append(Texture(4**(n+1)))\n   groups.append(textures)\n\ndef Select(texture,at):\n   sel = []\n   for pa in range(4):\n      aplane = texture[pa+math.floor(at.z)]\n      bplane = []\n      for pb in range(4):\n         aline = aplane[pb+math.floor(at.y)]\n         bline = []\n         for pc in range(4):\n            bline.append(aline[pc+math.floor(at.x)])\n         bplane.append(bline)\n      sel.append(bplane)\n   return (sel,Vector3(at.x%1,at.y%1,at.z%1))\ndef Round(val):\n   return val-(val-math.floor(val))\n      \ntheta = math.tan(70*math.pi/360)\nfor x in range(width):\n   for event in pygame.event.get():\n      if event.type == QUIT:\n         pygame.quit()\n         sys.exit()\n      if event.type == KEYDOWN:\n         pass\n   for y in range(height):\n      l = Vector3(theta*2*((x/width)-.5),theta*2*((y/width)-.5),1).Unit()\n      ldc = Vector3.Dot(l,center) \n      d = ldc-(((ldc**2)-Vector3.Dot(center,center)+1)**.5)\n      if type(d) != type((-1)**.5):\n         intersection = Vector3.Scale(l,d)\n         normal = Vector3.Subtract(intersection,center).Unit()\n         point = Transform(normal,world)\n\n         s = Vector3.Scale(Vector3.Add(point,Vector3(1,1,1)),.5)\n         val = 0\n         for i in range(depth):\n            sel = Select(groups[0][i],Vector3.Scale(s,4**i))\n            val += Misc.Tricubic(sel[0],sel[1])*((1/2)**i)/4\n            \n         val = (25*val)%1\n         vals = [0,Misc.Linear([0,.3,1],val),1]\n\n         coloring = []\n         for i in range(3):\n            #light = Misc.Lighting([1,1,1],normal,Vector3.Scale(intersection,-1),lights,([0,.03*val,.03],[0,.7*val,.7],[.3,.3,.3],7),i)\n            light = Misc.Lighting([.1,.1,.1],normal,Vector3.Scale(intersection,-1),lights,(vals,vals,[1,1,1],10),i)\n            if light > 1:\n               light = 1\n            elif light < 0:\n               light = 0\n            coloring.append(round(255*light))\n         screen.set_at((x,height-y),pygame.Color(coloring[0],coloring[1],coloring[2]))\n   pygame.display.update()\npygame.image.save(screen,\"PythonSphere.png\")\nwhile True:\n   for event in pygame.event.get():\n      if event.type == QUIT:\n         pygame.quit()\n         sys.exit()\n      if event.type == KEYDOWN:\n         pass\n\nLibrary: VPython[edit]\nWorks with: Python version 2.7.5\n\nfrom visual import *\nscene.title = \"VPython: Draw a sphere\"\nsphere()    # using defaults, see http://www.vpython.org/contents/docs/defaults.html\n\n\nfrom __future__ import print_function, division\nfrom visual import *\n\ntitle = \"VPython: Draw a sphere\"\nscene.title = title\nprint( \"%s\\n\" % title )\n\nprint( 'Drag with right mousebutton to rotate view'  )\nprint( 'Drag up+down with middle mousebutton to zoom')\n\nscene.autocenter = True\n\n# uncomment any (or all) of those variants:\nS1 = sphere(pos=(0.0, 0.0, 0.0), radius=1.0, color=color.blue)\n#S2 = sphere(pos=(2.0, 0.0, 0.0), radius=1.0, material=materials.earth)\n#S3 = sphere(pos=(0.0, 2.0, 0.0), radius=1.0, material=materials.BlueMarble)\n#S4 = sphere(pos=(0.0, 0.0, 2.0), radius=1.0,\n#            color=color.orange, material=materials.marble)\n\nwhile True:                 # Animation-loop\n    rate(100)\n    pass                    # no animation in this demo\n\n", "explain": "Renders a sphere with random Perlin noise. \nThis code contains unnecessary functions which are part of a 3D graphics library I wrote. \nUses Pygame and Python 3.2.2\nShort version:\nRegular version, with some window-dressing:\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n#include <math.h>\n\nconst char *shades = \".:!*oe&#%@\";\n\ndouble light[3] = { 30, 30, -50 };\nvoid normalize(double * v)\n{\n        double len = sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n}\n\ndouble dot(double *x, double *y)\n{\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n}\n\nvoid draw_sphere(double R, double k, double ambient)\n{\n        int i, j, intensity;\n        double b;\n        double vec[3], x, y;\n        for (i = floor(-R); i <= ceil(R); i++) {\n                x = i + .5;\n                for (j = floor(-2 * R); j <= ceil(2 * R); j++) {\n                        y = j / 2. + .5;\n                        if (x * x + y * y <= R * R) {\n                                vec[0] = x;\n                                vec[1] = y;\n                                vec[2] = sqrt(R * R - x * x - y * y);\n                                normalize(vec);\n                                b = pow(dot(light, vec), k) + ambient;\n                                intensity = (1 - b) * (sizeof(shades) - 1);\n                                if (intensity < 0) intensity = 0;\n                                if (intensity >= sizeof(shades) - 1)\n                                        intensity = sizeof(shades) - 2;\n                                putchar(shades[intensity]);\n                        } else\n                                putchar(' ');\n                }\n                putchar('\\n');\n        }\n}\n\n\nint main()\n{\n        normalize(light);\n        draw_sphere(20, 4, .1);\n        draw_sphere(10, 2, .4);\n\n        return 0;\n}\n\n\nOutput:\n                               #############%%%%                                 \n                       ##&&eeeeeeeeee&&&&&&&####%%%%%%%%                         \n                   &&eeooooooooooooooeeeee&&&&######%%%%%%%%                     \n                 eeoo**************oooooooeeee&&&&####%%%%%%%%                   \n             &&oo**!!!!!!::!!!!!!!!****oooooee&&&&######%%%%%%%%%%               \n           eeoo!!!!::::::::::::::!!!!*****ooeeee&&&&####%%%%%%%%%%%%             \n         ee**!!::::............::::!!!!***ooooeeee&&######%%%%%%%%%%%%           \n       &&oo!!::..................::!!!!*****ooeeee&&&&####%%%%%%%%%%%%%%         \n       oo!!::....................::::!!*****ooeeee&&&&####%%%%%%%%%%%%%%         \n     ee**!!::....................::::!!*****ooeeee&&&&####%%%%%%%%%%%%%%%%       \n   &&oo!!::......................::::!!*****ooeeee&&&&######%%%%%%%%%%%%%%%%     \n   ee**!!::......................::::!!*****ooeeee&&&&######%%%%%%%%%%%%%%%%     \n ##oo**!!::......................::!!!!*****ooeeee&&&&####%%%%%%%%%%%%%%%%%%%%   \n &&oo**::::....................::::!!!!***ooooeeee&&&&####%%%%%%%%%%%%%%%%%%%%   \n eeoo**!!::..................::::!!!!*****ooooee&&&&######%%%%%%%%%%%%%%%%%%%%   \n eeoo**!!::................::::!!!!****oooooeeee&&&&######%%%%%%%%%%%%%%%%%%%%   \n#eeoo**!!::::............::::!!!!!!****oooeeee&&&&&&######%%%%%%%%%%%%%%%%%%%%%% \n#eeoo**!!!!::::::::::::::::!!!!!!****oooooeeee&&&&######%%%%%%%%%%%%%%%%%%%%%%%% \n#eeoooo**!!!!!!::::::::!!!!!!******ooooeeeee&&&&&&######%%%%%%%%%%%%%%%%%%%%%%%% \n#&&eeoo****!!!!!!!!!!!!!!!!******ooooeeeee&&&&&&######%%%%%%%%%%%%%%%%%%%%%%%%%% \n#&&eeoooo********************ooooooeeee&&&&&&&######%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n#&&&&eeoooooo************ooooooeeeeee&&&&&&&########%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n%##&&eeeeeeooooooooooooooooooeeeeee&&&&&&&########%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n%####&&&&eeeeeeeeeeeeeeeeeeeeee&&&&&&&&#########%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%% \n\u00a0%%##&&&&&&eeeeeeeeeeeeeeee&&&&&&&&&&#########%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   \n\u00a0%%######&&&&&&&&&&&&&&&&&&&&&&&&###########%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   \n\u00a0%%%%########&&&&&&&&&&&&&&############%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   \n\u00a0%%%%%%##############################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%   \n  \u00a0%%%%%%%%######################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     \n  \u00a0%%%%%%%%%%%%%%%%####%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%     \n    \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%       \n      \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         \n      \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         \n        \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%           \n          \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%             \n            \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%               \n                \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                   \n                  \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                     \n                      \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                         \n                              \u00a0%%%%%%%%%%%%%%%%%                                 \n                                                                                 \n            \u00a0::..:::::!!**               \n         .............::!!**oo           \n     ...................::!!**ooee       \n   .......................::!!ooeeee     \n   .......................::!!**ooee     \n .........................::!!**ooeeee   \n .........................::!!**ooeeee   \n:.........................::!!**ooeeeeee \n........................::!!**ooooeeeeee \n:.......................::!!**ooeeeeeeee \n:.....................::!!****ooeeeeeeee \n!::................:::!!****ooeeeeeeeeee \n*!!::..........::::!!!****ooooeeeeeeeeee \n **!!::::::::::!!!!*****ooooeeeeeeeeee   \n oo**!!!!!!!!!!*******ooooeeeeeeeeeeee   \n   oooo********oooooooeeeeeeeeeeeeee     \n   eeeeooooooooooeeeeeeeeeeeeeeeeeee     \n     eeeeeeeeeeeeeeeeeeeeeeeeeeeee       \n         eeeeeeeeeeeeeeeeeeeee           \n             eeeeeeeeeeeee               \nFun with 3D noise texture[edit]\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n\n#define MAXD 8\nint g[] = { -1, 1, -1, 1 };\n/* Perlin-like noise */\nstatic inline void\nhashed(int *data, int *out, int len) {\n#\tdefine ror(a, d) ((a << (d)) | (a >> (32 - d)))\n\tregister unsigned int h = 0x12345678, tmp;\n\tunsigned int *d = (void*)data;\n\tint i = len;\n\n\twhile (i--) {\n\t\ttmp = *d++;\n\t\th += ror(h, 15) ^ ror(tmp, 5);\n\t}\n\n\th ^= ror(h, 7);\n\th += ror(h, 23);\n\th ^= ror(h, 19);\n\th += ror(h, 11);\n\th ^= ror(h, 13);\n\th += ror(h, 17);\n#\tundef ror\n\tfor (i = len; i--; ) {\n\t\tout[i] = g[h & 3];\n\t\th >>= 2;\n\t}\n}\n\ndouble scale[MAXD], scale_u[MAXD];\nvoid noise_init()\n{\n\tint i;\n\tfor (i = 1; i < MAXD; i++) {\n\t\tscale[i] = 1 / (1 + sqrt(i + 1));\n\t\tscale_u[i] = scale[i] / sqrt(i + 1);\n\t}\n}\n\ndouble noise(double *x, int d)\n{\n#\tdefine sum(s, x) for (s = 0, j = 0; j < d; j++) s += x\n\tregister int i, j;\n\tint n[MAXD], o[MAXD], g[MAXD], tmp;\n\tdouble s, r, t, w, ret, u[MAXD];\n\n\tsum(s, x[j]);\n\ts *= scale[d];\n\n\tfor (i = 0; i < d; i++) {\n\t\to[i] = i;\n\t\tt = x[i] + s;\n\t\tu[i] = t - (n[i] = floor(t));\n\t}\n\to[d] = 0;\n\n\tfor (i = 0; i < d - 1; i++)\n\t\tfor (j = i; j < d; j++)\n\t\t\tif (u[o[i]] < u[o[j]])\n\t\t\t\ttmp = o[i], o[i] = o[j], o[j] = tmp;\n\n\tret = w = 0, r = 1;\n\tfor (s = 0, j = 0; j < d; j++) s += n[j];\n\ts *= scale_u[d];\n\n\tfor (i = 0; i <= d; i++) {\n\t\tfor (j = 0; j < d; j++)\n\t\t\tu[j] = x[j] + s - n[j];\n\n\t\tfor (t = (d + 1.) / (2 * d), j = 0; j < d; j++) {\n\t\t\tt -= u[j] * u[j];\n\t\t\tif (t <= 0) break;\n\t\t}\n\n\t\tif (t >= 0) {\n\t\t\tr = 0;\n\t\t\thashed(n, g, d);\n\t\t\tfor (j = 0; j < d; j++)\n\t\t\t\tif (g[j]) r += (g[j] == 1 ? u[j] : -u[j]);\n\t\t\tt *= t;\n\t\t\tret += r * t * t;\n\t\t}\n\n\t\tif (i < d) {\n\t\t\tn[o[i]]++;\n\t\t\ts += scale_u[d];\n\t\t}\n\t}\n\treturn ret * (d * d);\n}\n\ndouble get_noise2(double x, double y)\n{\n\tint i, ws;\n\tdouble r = 0, v[2];\n\n\tfor (i = 1, ws = 0; i <= 128; i <<= 1) {\n\t\tv[0] = x * i, v[1] = y * i;\n\t\tr += noise(v, 2);\n\t\tws ++;\n\t}\n\tr /= ws;\n\treturn r;\n}\n\ndouble get_noise3(double x, double y, double z)\n{\n\tint i, ws;\n\tdouble r = 0, v[3], w;\n\n\tfor (i = 1, ws = 0; i <= 32; i <<= 1) {\n\t\tv[0] = x * i, v[1] = y * i, v[2] = z * i;\n\t\tw = 1./sqrt(i);\n\t\tr += noise(v, 3) * w;\n\t\tws += w;\n\t}\n\treturn r / ws;\n}\n\n\nint main(int c, char** v)\n{\n\tunsigned char pix[256 * 256], *p;\n\tint i, j;\n\tdouble x, y, z, w;\n\tFILE *fp;\n\n\tnoise_init();\n\n\tfor (p = pix, i = 0; i < 256 * 256; i++) *p++ = 0;\n\n\tfor (p = pix, i = 0; i < 256; i++) {\n\t\ty = (i - 128) / 125.;\n\t\tfor (j = 0; j < 256; j++, p++) {\n\t\t\tx = (j - 128) / 125.;\n\t\t\t*p = (get_noise2(i/256., j/256.) + 1) / 6 * i;\n\n\t\t\tz = 1- x*x - y*y;\n\t\t\tif (z < 0) continue;\n\n\t\t\tz = sqrt(z);\n\n\t\t\tw = get_noise3(x, y, z);\n\n\t\t\tw = (w + 1) / 2;\n\t\t\tw *= (1 + x - y + z) / 3.5;\n\t\t\tif (w < 0) w = 0;\n\n\t\t\t*p = w * 255;\n\t\t}\n\t}\n\n\tfp = fopen(\"out.pgm\", \"w+\");\n\tfprintf(fp, \"P5\\n256 256\\n255\\n\");\n\tfwrite(pix, 1, 256 * 256, fp);\n\tfclose(fp);\n\n\treturn 0;\n}\n\n", "explain": "The lighting calculation is somewhere between crude and bogus, but hey, I'm shading it with ASCII characters, don't expect too much.\n\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "C++", "code": "\nLibrary: Qt\n// Based on https://www.cairographics.org/samples/gradient/\n\n#include <QImage>\n#include <QPainter>\n\nint main() {\n    const QColor black(0, 0, 0);\n    const QColor white(255, 255, 255);\n\n    const int size = 300;\n    const double diameter = 0.6 * size;\n\n    QImage image(size, size, QImage::Format_RGB32);\n    QPainter painter(&image);\n    painter.setRenderHint(QPainter::Antialiasing);\n\n    QLinearGradient linearGradient(0, 0, 0, size);\n    linearGradient.setColorAt(0, white);\n    linearGradient.setColorAt(1, black);\n\n    QBrush brush(linearGradient);\n    painter.fillRect(QRect(0, 0, size, size), brush);\n\n    QPointF point1(0.4 * size, 0.4 * size);\n    QPointF point2(0.45 * size, 0.4 * size);\n    QRadialGradient radialGradient(point1, size * 0.5, point2, size * 0.1);\n    radialGradient.setColorAt(0, white);\n    radialGradient.setColorAt(1, black);\n\n    QBrush brush2(radialGradient);\n    painter.setPen(Qt::NoPen);\n    painter.setBrush(brush2);\n    painter.drawEllipse(QRectF((size - diameter)/2, (size - diameter)/2, diameter, diameter));\n\n    image.save(\"sphere.png\");\n    return 0;\n}\n\n\nOutput:\n\n", "explain": "Media:Draw a sphere cpp.png\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Java", "code": "\nTranslation of: C\npublic class Sphere{\n    static char[] shades = {'.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@'};\n\n    static double[] light = { 30, 30, -50 };\n    private static void normalize(double[] v){\n        double len = Math.sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n        v[0] /= len; v[1] /= len; v[2] /= len;\n    }\n\n    private static double dot(double[] x, double[] y){\n        double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n        return d < 0 ? -d : 0;\n    }\n\n    public static void drawSphere(double R, double k, double ambient){\n        double[] vec = new double[3];\n        for(int i = (int)Math.floor(-R); i <= (int)Math.ceil(R); i++){\n            double x = i + .5;\n            for(int j = (int)Math.floor(-2 * R); j <= (int)Math.ceil(2 * R); j++){\n                double y = j / 2. + .5;\n                if(x * x + y * y <= R * R) {\n                    vec[0] = x;\n                    vec[1] = y;\n                    vec[2] = Math.sqrt(R * R - x * x - y * y);\n                    normalize(vec);\n                    double b = Math.pow(dot(light, vec), k) + ambient;\n                    int intensity = (b <= 0) ?\n                                shades.length - 2 :\n                                (int)Math.max((1 - b) * (shades.length - 1), 0);\n                    System.out.print(shades[intensity]);\n                } else\n                    System.out.print(' ');\n            }\n            System.out.println();\n        }\n    }\n\n    public static void main(String[] args){\n        normalize(light);\n        drawSphere(20, 4, .1);\n        drawSphere(10, 2, .4);\n    }\n}\n\n\nOutput:\n                               &&&&&&&&&&#######                                 \n                        &eeeeeeeeeeeeeeee&&&&&&#######%                          \n                    &eoooo*******oooooooeeeee&&&&&########%                      \n                 eoo****!!!!!!!!******oooooeeee&&&&&########%%                   \n              eoo**!!!!::::::::!!!!!*****ooooeeee&&&&&########%%%                \n            eo**!!::::::...:::::::!!!!!***ooooeeee&&&&&########%%%%              \n          eo*!!:::.............:::::!!!!***ooooeeee&&&&&########%%%%%            \n        eo*!!:::.................::::!!!!***ooooeeee&&&&#########%%%%%%          \n       eo*!!::....................::::!!!****oooeeee&&&&&#########%%%%%%         \n     &o**!::......................::::!!!****oooeeee&&&&&##########%%%%%%%       \n    &o**!::.......................::::!!!****oooeeee&&&&&##########%%%%%%%%      \n   &oo*!!::.......................:::!!!!***ooooeeee&&&&&##########%%%%%%%%%     \n  &eo*!!::.......................::::!!!****ooooeeee&&&&&##########%%%%%%%%%%    \n  eo**!!::......................::::!!!!***ooooeeeee&&&&&##########%%%%%%%%%%    \n &eo**!!:::...................:::::!!!!****ooooeeee&&&&&###########%%%%%%%%%%%   \n eeo**!!::::................:::::!!!!!****ooooeeee&&&&&&###########%%%%%%%%%%%   \n&eeo***!!:::::...........::::::!!!!!****oooooeeee&&&&&&###########%%%%%%%%%%%%%  \n&eeoo**!!!!::::::::::::::::::!!!!!*****ooooeeeee&&&&&&############%%%%%%%%%%%%%  \n&eeooo***!!!!::::::::::::!!!!!!!*****oooooeeeee&&&&&&############%%%%%%%%%%%%%%  \n&&eeooo***!!!!!!!!!!!!!!!!!!!******oooooeeeeee&&&&&&############%%%%%%%%%%%%%%%  \n&&eeeooo******!!!!!!!!!!********ooooooeeeeee&&&&&&&############%%%%%%%%%%%%%%%%  \n#&&eeeooooo******************oooooooeeeeee&&&&&&&#############%%%%%%%%%%%%%%%%%  \n#&&&eeeeoooooooo******oooooooooooeeeeeee&&&&&&&&#############%%%%%%%%%%%%%%%%%%  \n##&&&&eeeeeooooooooooooooooooeeeeeeee&&&&&&&&&##############%%%%%%%%%%%%%%%%%%%  \n ##&&&&&eeeeeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&################%%%%%%%%%%%%%%%%%%%   \n ####&&&&&&eeeeeeeeeeeeeeeeeee&&&&&&&&&&&################%%%%%%%%%%%%%%%%%%%%%   \n  #####&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&#################%%%%%%%%%%%%%%%%%%%%%%    \n \u00a0%#######&&&&&&&&&&&&&&&&&&&&&&&&###################%%%%%%%%%%%%%%%%%%%%%%%%    \n  \u00a0%###########&&&&&&&&&&&&&#######################%%%%%%%%%%%%%%%%%%%%%%%%%     \n   \u00a0%############################################%%%%%%%%%%%%%%%%%%%%%%%%%%      \n    \u00a0%%#######################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%       \n      \u00a0%%#################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%         \n       \u00a0%%%%%#########################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%          \n         \u00a0%%%%%%%%#############%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%            \n           \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%              \n             \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                \n                \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                   \n                   \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                      \n                       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                          \n                              \u00a0%%%%%%%%%%%%%%%%%                                 \n                                                                                 \n            \u00a0::...:::!!!*o               \n         ..............::!!*oo           \n      ..................::!!**ooe        \n    .....................::!!**ooee      \n   .......................::!!**ooee     \n  ........................::!!**oooee    \n .........................::!!**oooeee   \n:........................::!!!**oooeeee  \n........................::!!!**ooooeeee  \n:......................::!!!***oooeeeee  \n:....................:::!!!***oooeeeeee  \n!:.................:::!!!****oooeeeeeee  \n*!:::...........::::!!!!***ooooeeeeeeee  \n *!!!:::::::::::!!!!!****oooooeeeeeeee   \n  o**!!!!!!!!!!!!!*****oooooeeeeeeeee    \n   oo**************ooooooeeeeeeeeeee     \n    eoooooooooooooooooeeeeeeeeeeeee      \n      eeeooooooooeeeeeeeeeeeeeeee        \n         eeeeeeeeeeeeeeeeeeeee           \n             eeeeeeeeeeeee               \n                                         \n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "C#", "code": "\nTranslation of: C\nusing System;\n\nnamespace Sphere {\n    internal class Program {\n        private const string Shades = \".:!*oe%&#@\";\n        private static readonly double[] Light = {30, 30, -50};\n\n        private static void Normalize(double[] v) {\n            double len = Math.Sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n            v[0] /= len;\n            v[1] /= len;\n            v[2] /= len;\n        }\n\n        private static double Dot(double[] x, double[] y) {\n            double d = x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n            return d < 0 ? -d : 0;\n        }\n\n        public static void DrawSphere(double r, double k, double ambient) {\n            var vec = new double[3];\n            for(var i = (int)Math.Floor(-r); i <= (int)Math.Ceiling(r); i++) {\n                double x = i + .5;\n                for(var j = (int)Math.Floor(-2*r); j <= (int)Math.Ceiling(2*r); j++) {\n                    double y = j/2.0 + .5;\n                    if(x*x + y*y <= r*r) {\n                        vec[0] = x;\n                        vec[1] = y;\n                        vec[2] = Math.Sqrt(r*r - x*x - y*y);\n                        Normalize(vec);\n                        double b = Math.Pow(Dot(Light, vec), k) + ambient;\n                        int intensity = (b <= 0)\n                                            ? Shades.Length - 2\n                                            : (int)Math.Max((1 - b)*(Shades.Length - 1), 0);\n                        Console.Write(Shades[intensity]);\n                    }\n                    else\n                        Console.Write(' ');\n                }\n                Console.WriteLine();\n            }\n        }\n\n        private static void Main() {\n            Normalize(Light);\n            DrawSphere(6, 4, .1);\n            DrawSphere(10, 2, .4);\n            Console.ReadKey();\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "JavaScript", "code": "\nTranslation of: C\n\n<!DOCTYPE html>\n<html>\n<head>\n<meta charset=\"utf-8\">\n<title>Draw a sphere</title>\n<script>\nvar light=[30,30,-50],gR,gk,gambient;\n\nfunction normalize(v){\n\tvar len=Math.sqrt(v[0]*v[0]+v[1]*v[1]+v[2]*v[2]);\n\tv[0]/=len;\n\tv[1]/=len;\n\tv[2]/=len;\n\treturn v;\n}\n \nfunction dot(x,y){\n\tvar d=x[0]*y[0]+x[1]*y[1]+x[2]*y[2];\n\treturn d<0?-d:0;\n}\n \nfunction draw_sphere(R,k,ambient){\n\tvar i,j,intensity,b,vec,x,y,cvs,ctx,imgdata,idx;\n\tcvs=document.getElementById(\"c\");\n\tctx=cvs.getContext(\"2d\");\n\tcvs.width=cvs.height=2*Math.ceil(R)+1;\n\timgdata=ctx.createImageData(2*Math.ceil(R)+1,2*Math.ceil(R)+1);\n\tidx=0;\n\tfor(i=Math.floor(-R);i<=Math.ceil(R);i++){\n\t\tx=i+.5;\n\t\tfor(j=Math.floor(-R);j<=Math.ceil(R);j++){\n\t\t\ty=j+.5;\n\t\t\tif(x*x+y*y<=R*R){\n\t\t\t\tvec=[x,y,Math.sqrt(R*R-x*x-y*y)];\n\t\t\t\tvec=normalize(vec);\n\t\t\t\tb=Math.pow(dot(light,vec),k)+ambient;\n\t\t\t\tintensity=(1-b)*256;\n\t\t\t\tif(intensity<0)intensity=0;\n\t\t\t\tif(intensity>=256)intensity=255;\n\t\t\t\timgdata.data[idx++]=imgdata.data[idx++]=255-~~(intensity); //RG\n\t\t\t\timgdata.data[idx++]=imgdata.data[idx++]=255; //BA\n\t\t\t} else {\n\t\t\t\timgdata.data[idx++]=imgdata.data[idx++]=imgdata.data[idx++]=imgdata.data[idx++]=255; //RGBA\n\t\t\t}\n\t\t}\n\t}\n\tctx.putImageData(imgdata,0,0);\n}\n\nlight=normalize(light);\n</script>\n</head>\n<body onload=\"gR=200;gk=4;gambient=.2;draw_sphere(gR,gk,gambient)\">\nR=<input type=\"range\" id=\"R\" name=\"R\" min=\"5\" max=\"500\" value=\"200\" step=\"5\" onchange=\"document.getElementById('lR').innerHTML=gR=parseFloat(this.value);draw_sphere(gR,gk,gambient)\">\n<label for=\"R\" id=\"lR\">200</label><br>\nk=<input type=\"range\" id=\"k\" name=\"k\" min=\"0\" max=\"10\" value=\"4\" step=\".25\" onchange=\"document.getElementById('lk').innerHTML=gk=parseFloat(this.value);draw_sphere(gR,gk,gambient)\">\n<label for=\"k\" id=\"lk\">4</label><br>\nambient=<input type=\"range\" id=\"ambient\" name=\"ambient\" min=\"0\" max=\"1\" value=\".2\" step=\".05\" onchange=\"document.getElementById('lambient').innerHTML=gambient=parseFloat(this.value);draw_sphere(gR,gk,gambient)\">\n<label for=\"ambient\" id=\"lambient\">0.2</label><br>\n<canvas id=\"c\">Unsupportive browser...</canvas><br>\n</body>\n</html>\n\n", "explain": "This Javascript entry uses an HTML wrapper to offer easy running and some interactivity. It is made as such, though, that the entire HTML wrapper can be removed (except for a canvas with id c) and still work. If you remove the HTML, call the draw_sphere function to draw the thing.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "MATLAB", "code": "\n\nfigure; sphere\n\n", "explain": "To create the unit sphere:\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Go", "code": "\nOutput png\nTranslation of: C\n\npackage main\n\nimport (\n    \"fmt\"\n    \"image\"\n    \"image/color\"\n    \"image/png\"\n    \"math\"\n    \"os\"\n)\n\ntype vector [3]float64\n\nfunc normalize(v *vector) {\n    invLen := 1 / math.Sqrt(dot(v, v))\n    v[0] *= invLen\n    v[1] *= invLen\n    v[2] *= invLen\n}\n\nfunc dot(x, y *vector) float64 {\n    return x[0]*y[0] + x[1]*y[1] + x[2]*y[2]\n}\n\nfunc drawSphere(r int, k, amb float64, dir *vector) *image.Gray {\n    w, h := r*4, r*3\n    img := image.NewGray(image.Rect(-w/2, -h/2, w/2, h/2))\n    vec := new(vector)\n    for x := -r; x < r; x++ {\n        for y := -r; y < r; y++ {\n            if z := r*r - x*x - y*y; z >= 0 {\n                vec[0] = float64(x)\n                vec[1] = float64(y)\n                vec[2] = math.Sqrt(float64(z))\n                normalize(vec)\n                s := dot(dir, vec)\n                if s < 0 {\n                    s = 0\n                }\n                lum := 255 * (math.Pow(s, k) + amb) / (1 + amb)\n                if lum < 0 {\n                    lum = 0\n                } else if lum > 255 {\n                    lum = 255\n                }\n                img.SetGray(x, y, color.Gray{uint8(lum)})\n            }\n        }\n    }\n    return img\n}\n\nfunc main() {\n    dir := &vector{-30, -30, 50}\n    normalize(dir)\n    img := drawSphere(200, 1.5, .2, dir)\n    f, err := os.Create(\"sphere.png\")\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    if err = png.Encode(f, img); err != nil {\n        fmt.Println(err)\n    }\n    if err = f.Close(); err != nil {\n        fmt.Println(err)\n    }\n}\n\n", "explain": "Using image library rather than ASCII art.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Delphi", "code": "\nTranslation of: C\n\nprogram DrawASphere;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils,\n  Math;\n\ntype\n  TDouble3  = array[0..2] of Double;\n  TChar10 = array[0..9] of Char;\n\nvar\n  shades: TChar10 = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@');\n  light: TDouble3 = (30, 30, -50 );\n\n  procedure normalize(var v: TDouble3);\n  var\n    len: Double;\n  begin\n    len:= sqrt(v[0]*v[0] + v[1]*v[1] + v[2]*v[2]);\n    v[0] := v[0] / len;\n    v[1] := v[1] / len;\n    v[2] := v[2] / len;\n  end;\n\n  function dot(x, y: TDouble3): Double;\n  begin\n    Result:= x[0]*y[0] + x[1]*y[1] + x[2]*y[2];\n    Result:= IfThen(Result < 0, -Result, 0 );\n  end;\n\n  procedure drawSphere(R, k, ambient: Double);\n  var\n    vec: TDouble3;\n    x, y, b: Double;\n    i, j,\n    intensity: Integer;\n  begin\n    for i:= Floor(-R) to Ceil(R) do\n    begin\n      x := i + 0.5;\n      for j:= Floor(-2*R) to Ceil(2 * R) do\n      begin\n        y:= j / 2 + 0.5;\n        if(x * x + y * y <= R * R) then\n        begin\n          vec[0]:= x;\n          vec[1]:= y;\n          vec[2]:= sqrt(R * R - x * x - y * y);\n          normalize(vec);\n          b:= Power(dot(light, vec), k) + ambient;\n          intensity:= IfThen(b <= 0,\n                             Length(shades) - 2,\n                             Trunc(max( (1 - b) * (Length(shades) - 1), 0 )));\n          Write(shades[intensity]);\n        end\n        else\n          Write(' ');\n      end;\n      Writeln;\n    end;\n  end;\n\nbegin\n  normalize(light);\n  drawSphere(19, 4, 0.1);\n  drawSphere(10, 2, 0.4);\n  Readln;\nend.\n\n\nOutput:\n                             &&&&&&&&&&#######\n                       &eeeeeooeeeeeeee&&&&&&#######\n                   eeooo*********oooooeeeee&&&&&#######%\n                eo***!!!!!!!!!!!*****ooooeeee&&&&&#######%%\n             eo**!!!::::::::::!!!!!****ooooeeee&&&&########%%%\n           eo*!!::::........:::::!!!!****oooeeee&&&&########%%%%\n         eo*!!::..............:::::!!!***ooooeeee&&&&#########%%%%\n       eo*!!::..................:::!!!!***oooeeee&&&&&########%%%%%%\n      eo*!::....................::::!!!***ooooeeee&&&&#########%%%%%%\n     o**!::.....................::::!!!***ooooeeee&&&&#########%%%%%%%\n    eo*!::......................::::!!!***ooooeeee&&&&##########%%%%%%%\n   eo*!!::......................:::!!!!***ooooeee&&&&&##########%%%%%%%%\n  eo**!!::.....................:::!!!!***ooooeeee&&&&&##########%%%%%%%%%\n &eo**!!::...................::::!!!!****oooeeeee&&&&&##########%%%%%%%%%%\n eeo**!!:::................:::::!!!!****ooooeeee&&&&&##########%%%%%%%%%%%\n&eoo**!!!::::............:::::!!!!****oooooeeee&&&&&###########%%%%%%%%%%%%\n&eeo***!!!::::::::::::::::::!!!!!****ooooeeeee&&&&&&##########%%%%%%%%%%%%%\n&eeoo***!!!!::::::::::::!!!!!!*****oooooeeeee&&&&&&###########%%%%%%%%%%%%%\n&&eeoo****!!!!!!!!!!!!!!!!!!*****oooooeeeee&&&&&&############%%%%%%%%%%%%%%\n&&eeeooo*****!!!!!!!!!!*******ooooooeeeeee&&&&&&############%%%%%%%%%%%%%%%\n#&&eeeoooo*****************oooooooeeeeee&&&&&&&############%%%%%%%%%%%%%%%%\n#&&&eeeeoooooooooooooooooooooooeeeeeee&&&&&&&#############%%%%%%%%%%%%%%%%%\n##&&&&eeeeeoooooooooooooooeeeeeeeee&&&&&&&&##############%%%%%%%%%%%%%%%%%%\n ###&&&&eeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&&##############%%%%%%%%%%%%%%%%%%%\n ####&&&&&&&eeeeeeeeeeeeeee&&&&&&&&&&&################%%%%%%%%%%%%%%%%%%%%\n  #####&&&&&&&&&&&&&&&&&&&&&&&&&&&&#################%%%%%%%%%%%%%%%%%%%%%\n   ########&&&&&&&&&&&&&&&&&&&####################%%%%%%%%%%%%%%%%%%%%%%\n    ############################################%%%%%%%%%%%%%%%%%%%%%%%\n    \u00a0%#######################################%%%%%%%%%%%%%%%%%%%%%%%%%\n     \u00a0%%##################################%%%%%%%%%%%%%%%%%%%%%%%%%%%\n      \u00a0%%%%###########################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n        \u00a0%%%%%%#################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n          \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n            \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n               \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                  \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                      \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                            \u00a0%%%%%%%%%%%%%%%%%\n\n            \u00a0::...:::!!!*o\n         ..............::!!*oo\n      ..................::!!**ooe\n    .....................::!!**ooee\n   .......................::!!**ooee\n  ........................::!!**oooee\n .........................::!!**oooeee\n:........................::!!!**oooeeee\n........................::!!!**ooooeeee\n:......................::!!!***oooeeeee\n:....................:::!!!***oooeeeeee\n!:.................:::!!!****oooeeeeeee\n*!:::...........::::!!!!***ooooeeeeeeee\n *!!!:::::::::::!!!!!****oooooeeeeeeee\n  o**!!!!!!!!!!!!!*****oooooeeeeeeeee\n   oo**************ooooooeeeeeeeeeee\n    eoooooooooooooooooeeeeeeeeeeeee\n      eeeooooooooeeeeeeeeeeeeeeee\n         eeeeeeeeeeeeeeeeeeeee\n             eeeeeeeeeeeee\n\n", "explain": "Under Microsoft Windows:\nIf you notice the big sphere loses its roundness, then try increasing the width of the Windows console. By default it\u2019s 80; so put it to something bigger, let\u2019s say 90.\nSteps: Run the CMD Windows shell. Then follow this path to setup the new width: Main Menu-> Properties -> Layout -> Window Size -> Width.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Ruby", "code": "\nLibrary: Shoes\n\n\nShoes.app :width => 500, :height => 500, :resizable => false do\n  image 400, 470, :top => 30, :left => 50 do\n    nostroke\n    fill \"#127\"\n    image :top => 230, :left => 0 do\n      oval 70, 130, 260, 40\n      blur 30\n    end\n    oval 10, 10, 380, 380\n    image :top => 0, :left => 0 do\n      fill \"#46D\"\n      oval 30, 30, 338, 338\n      blur 10\n    end\n    fill gradient(rgb(1.0, 1.0, 1.0, 0.7), rgb(1.0, 1.0, 1.0, 0.0))\n    oval 80, 14, 240, 176\n    image :top => 0, :left => 0 do\n      fill \"#79F\"\n      oval 134, 134, 130, 130\n      blur 40\n    end\n    image :top => 150, :left => 40, :width => 320, :height => 260 do\n      fill gradient(rgb(0.7, 0.9, 1.0, 0.0), rgb(0.7, 0.9, 1.0, 0.6))\n      oval 60, 60, 200, 136\n      blur 20\n    end\n  end\nend\n\n", "explain": "Shoes comes with this sample program.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Rust", "code": "\nTranslation of: Go\n// [dependencies]\n// image = \"0.23\"\n\nuse image::{GrayImage, Luma};\n\ntype Vector = [f64; 3];\n\nfn normalize(v: &mut Vector) {\n    let inv_len = 1.0/dot_product(v, v).sqrt();\n    v[0] *= inv_len;\n    v[1] *= inv_len;\n    v[2] *= inv_len;\n}\n\nfn dot_product(v1: &Vector, v2: &Vector) -> f64 {\n    v1.iter().zip(v2.iter()).map(|(x, y)| *x * *y).sum()\n}\n\nfn draw_sphere(radius: u32, k: f64, ambient: f64, dir: &Vector) -> GrayImage {\n    let width = radius * 4;\n    let height = radius * 3;\n    let mut image = GrayImage::new(width, height);\n    let mut vec = [0.0; 3];\n    let diameter = radius * 2;\n    let r = radius as f64;\n    let xoffset = (width - diameter)/2;\n    let yoffset = (height - diameter)/2;\n    for i in 0..diameter {\n        let x = i as f64 - r;\n        for j in 0..diameter {\n            let y = j as f64 - r;\n            let z = r * r - x * x - y * y;\n            if z >= 0.0 {\n                vec[0] = x;\n                vec[1] = y;\n                vec[2] = z.sqrt();\n                normalize(&mut vec);\n                let mut s = dot_product(&dir, &vec);\n                if s < 0.0 {\n                    s = 0.0;\n                }\n                let mut lum = 255.0 * (s.powf(k) + ambient)/(1.0 + ambient);\n                if lum < 0.0 {\n                    lum = 0.0;\n                } else if lum > 255.0 {\n                    lum = 255.0;\n                }\n                image.put_pixel(i + xoffset, j + yoffset, Luma([lum as u8]));\n            }\n        }\n    }\n    image\n}\n\nfn main() {\n    let mut dir = [-30.0, -30.0, 50.0];\n    normalize(&mut dir);\n    match draw_sphere(200, 1.5, 0.2, &dir).save(\"sphere.png\") {\n        Ok(()) => {}\n        Err(error) => eprintln!(\"{}\", error),\n    }\n}\n\n\nOutput:\n\n", "explain": "Media:Draw a sphere rust.png\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Swift", "code": "\n\nclass Sphere: UIView{\n  \n  override func drawRect(rect: CGRect)\n  {\n    let context = UIGraphicsGetCurrentContext()\n    let locations: [CGFloat] = [0.0, 1.0]\n    \n    let colors = [UIColor.whiteColor().CGColor,\n      UIColor.blueColor().CGColor]\n    \n    let colorspace = CGColorSpaceCreateDeviceRGB()\n    \n    let gradient = CGGradientCreateWithColors(colorspace,\n      colors, locations)\n    \n    var startPoint = CGPoint()\n    var endPoint = CGPoint()\n    startPoint.x = self.center.x - (self.frame.width * 0.1)\n    startPoint.y = self.center.y - (self.frame.width * 0.15)\n    endPoint.x = self.center.x\n    endPoint.y = self.center.y\n    let startRadius: CGFloat = 0\n    let endRadius: CGFloat = self.frame.width * 0.38\n    \n    CGContextDrawRadialGradient (context, gradient, startPoint,\n      startRadius, endPoint, endRadius,\n      0)\n  }\n}\n\nvar s = Sphere(frame: CGRectMake(0, 0, 200, 200))\n\n\nstruct ContentView: View {\n\n    var body: some View {\n\n      let gradient = RadialGradient(gradient: Gradient(colors:[.white, .black]),\n      center: .init(x: 0.4, y: 0.4), startRadius: 10, endRadius: 100)\n      \n      return Circle()\n          .fill(gradient)\n          .frame(width: 200, height: 200)\n\n    }\n}\n\n", "explain": "In Playground for example:\nIn SwiftUI:\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Ada", "code": "\nLibrary: GtkAda\n\n\nwith Glib;                use Glib;\nwith Cairo;               use Cairo;\nwith Cairo.Png;           use Cairo.Png;\nwith Cairo.Pattern;       use Cairo.Pattern;\nwith Cairo.Image_Surface; use Cairo.Image_Surface;\nwith Ada.Numerics;\n\nprocedure Sphere is\n   subtype Dub is Glib.Gdouble;\n\n   Surface    : Cairo_Surface;\n   Cr         : Cairo_Context;\n   Pat        : Cairo_Pattern;\n   Status_Out : Cairo_Status;\n   M_Pi       : constant Dub := Dub (Ada.Numerics.Pi);\n\nbegin\n   Surface := Create (Cairo_Format_ARGB32, 512, 512);\n   Cr      := Create (Surface);\n   Pat     :=\n      Cairo.Pattern.Create_Radial (230.4, 204.8, 51.1, 204.8, 204.8, 256.0);\n   Cairo.Pattern.Add_Color_Stop_Rgba (Pat, 0.0, 1.0, 1.0, 1.0, 1.0);\n   Cairo.Pattern.Add_Color_Stop_Rgba (Pat, 1.0, 0.0, 0.0, 0.0, 1.0);\n   Cairo.Set_Source (Cr, Pat);\n   Cairo.Arc (Cr, 256.0, 256.0, 153.6, 0.0, 2.0 * M_Pi);\n   Cairo.Fill (Cr);\n   Cairo.Pattern.Destroy (Pat);\n   Status_Out := Write_To_Png (Surface, \"SphereAda.png\");\n   pragma Assert (Status_Out = Cairo_Status_Success);\nend Sphere;\n\nLibrary: Display\n\nwith Display; use Display;\nwith Display.Basic; use Display.Basic;\n\nprocedure Main is\n   Ball : Shape_Id := New_Circle\n     (X      => 0.0,\n      Y      => 0.0,\n      Radius => 20.0,\n      Color  => Blue);\nbegin\n   null;\nend Main;\n\n", "explain": "Translation from the C code at http://cairographics.org/samples/gradient\nUses the Cairo component of GtkAda to create and save as png\nThis uses a very loose binding to SDL as found in any GPS installation. For it to work, you must choose New Project From Templte|Empty Game\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Julia", "code": "\nASCII Text[edit]\nTranslation of: C\nfunction draw_sphere(r, k, ambient, light)\n    shades = ('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@')\n    for i in floor(Int, -r):ceil(Int, r)\n        x = i + 0.5\n        line = IOBuffer()\n        for j in floor(Int, -2r):ceil(2r)\n            y = j / 2 + 0.5\n            if x ^ 2 + y ^ 2 \u2264 r ^ 2\n                v = normalize([x, y, sqrt(r ^ 2 - x ^ 2 - y ^ 2)])\n                b = dot(light, v) ^ k + ambient\n                intensity = ceil(Int, (1 - b) * (length(shades) - 1))\n                if intensity < 1\n                    intensity = 1 end\n                if intensity > length(shades)\n                    intensity = length(shades) end\n                print(shades[intensity])\n            else\n                print(' ')\n            end\n        end\n        println()\n    end\nend\n\nlight = normalize([30, 30, -50])\ndraw_sphere(20, 4, 0.1, light)\ndraw_sphere(10, 2, 0.4, light)\n\nGraphical[edit]\n# run from REPL\n\nusing Makie\n\n\u03c6 = 0:\u03c0/100:2\u03c0\n\n\u03b8 = 0:\u03c0/200:\u03c0\n\nx = [cos(\u03b8) * sin(\u03c6) for \u03b8 in \u03b8, \u03c6 in \u03c6]\ny = [sin(\u03b8)*sin(\u03c6) for \u03b8 in \u03b8, \u03c6 in \u03c6]\nz = [cos(\u03c6) for \u03b8 in \u03b8, \u03c6 in \u03c6]\n\nsurface(x, y, z, backgroundcolor = :black, show_axis = false)\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Kotlin", "code": "\nTranslation of: C\n// version 1.0.6\n\nconst val shades = \".:!*oe&#%@\"\nval light  = doubleArrayOf(30.0, 30.0, -50.0)\n\nfun normalize(v: DoubleArray) {\n    val len = Math.sqrt(v[0] * v[0] + v[1] * v[1] + v[2] * v[2])\n    v[0] /= len; v[1] /= len; v[2] /= len\n}\n\nfun dot(x: DoubleArray, y: DoubleArray): Double {\n    val d = x[0] * y[0] + x[1] * y[1] + x[2] * y[2]   \n    return if (d < 0.0) -d else 0.0\n}\n\nfun drawSphere(r: Double, k: Double, ambient: Double) {\n    val vec = DoubleArray(3)\n    var intensity: Int\n    var b : Double\n    var x: Double\n    var y: Double\n    for (i in Math.floor(-r).toInt() .. Math.ceil(r).toInt()) {\n        x = i + 0.5\n        for (j in Math.floor(-2.0 * r).toInt() .. Math.ceil(2.0 * r).toInt()) {\n            y = j / 2.0 + 0.5\n            if (x * x + y * y <= r * r) {\n                vec[0] = x\n                vec[1] = y\n                vec[2] = Math.sqrt(r * r - x * x - y * y) \n                normalize(vec)\n                b = Math.pow(dot(light, vec), k) + ambient \n                intensity = ((1.0 - b) * (shades.length - 1)).toInt() \n                if (intensity < 0) intensity = 0  \n                if (intensity >= shades.length - 1) intensity = shades.length - 2                 \n                print(shades[intensity])\n            }\n            else print(' ')\n        }\n        println()\n    }\n}\n\nfun main(args: Array<String>) {\n    normalize(light)\n    drawSphere(20.0, 4.0, 0.1)\n    drawSphere(10.0, 2.0, 0.4)\n}\n\n\nOutput:\n                               &&&&&&&&&&#######\n                        &eeeeeeeeeeeeeeee&&&&&&#######%\n                    &eoooo*******oooooooeeeee&&&&&########%\n                 eoo****!!!!!!!!******oooooeeee&&&&&########%%\n              eoo**!!!!::::::::!!!!!*****ooooeeee&&&&&########%%%\n            eo**!!::::::...:::::::!!!!!***ooooeeee&&&&&########%%%%\n          eo*!!:::.............:::::!!!!***ooooeeee&&&&&########%%%%%\n        eo*!!:::.................::::!!!!***ooooeeee&&&&#########%%%%%%\n       eo*!!::....................::::!!!****oooeeee&&&&&#########%%%%%%\n     &o**!::......................::::!!!****oooeeee&&&&&##########%%%%%%%\n    &o**!::.......................::::!!!****oooeeee&&&&&##########%%%%%%%%\n   &oo*!!::.......................:::!!!!***ooooeeee&&&&&##########%%%%%%%%%\n  &eo*!!::.......................::::!!!****ooooeeee&&&&&##########%%%%%%%%%%\n  eo**!!::......................::::!!!!***ooooeeeee&&&&&##########%%%%%%%%%%\n &eo**!!:::...................:::::!!!!****ooooeeee&&&&&###########%%%%%%%%%%%\n eeo**!!::::................:::::!!!!!****ooooeeee&&&&&&###########%%%%%%%%%%%\n&eeo***!!:::::...........::::::!!!!!****oooooeeee&&&&&&###########%%%%%%%%%%%%%\n&eeoo**!!!!::::::::::::::::::!!!!!*****ooooeeeee&&&&&&############%%%%%%%%%%%%%\n&eeooo***!!!!::::::::::::!!!!!!!*****oooooeeeee&&&&&&############%%%%%%%%%%%%%%\n&&eeooo***!!!!!!!!!!!!!!!!!!!******oooooeeeeee&&&&&&############%%%%%%%%%%%%%%%\n&&eeeooo******!!!!!!!!!!********ooooooeeeeee&&&&&&&############%%%%%%%%%%%%%%%%\n#&&eeeooooo******************oooooooeeeeee&&&&&&&#############%%%%%%%%%%%%%%%%%\n#&&&eeeeoooooooo******oooooooooooeeeeeee&&&&&&&&#############%%%%%%%%%%%%%%%%%%\n##&&&&eeeeeooooooooooooooooooeeeeeeee&&&&&&&&&##############%%%%%%%%%%%%%%%%%%%\n ##&&&&&eeeeeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&################%%%%%%%%%%%%%%%%%%%\n ####&&&&&&eeeeeeeeeeeeeeeeeee&&&&&&&&&&&################%%%%%%%%%%%%%%%%%%%%%\n  #####&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&#################%%%%%%%%%%%%%%%%%%%%%%\n \u00a0%#######&&&&&&&&&&&&&&&&&&&&&&&&###################%%%%%%%%%%%%%%%%%%%%%%%%\n  \u00a0%###########&&&&&&&&&&&&&#######################%%%%%%%%%%%%%%%%%%%%%%%%%\n   \u00a0%############################################%%%%%%%%%%%%%%%%%%%%%%%%%%\n    \u00a0%%#######################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n      \u00a0%%#################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n       \u00a0%%%%%#########################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n         \u00a0%%%%%%%%#############%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n             \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                   \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                              \u00a0%%%%%%%%%%%%%%%%%\n\n            \u00a0::...:::!!!*o\n         ..............::!!*oo\n      ..................::!!**ooe\n    .....................::!!**ooee\n   .......................::!!**ooee\n  ........................::!!**oooee\n .........................::!!**oooeee\n:........................::!!!**oooeeee\n........................::!!!**ooooeeee\n:......................::!!!***oooeeeee\n:....................:::!!!***oooeeeeee\n!:.................:::!!!****oooeeeeeee\n*!:::...........::::!!!!***ooooeeeeeeee\n *!!!:::::::::::!!!!!****oooooeeeeeeee\n  o**!!!!!!!!!!!!!*****oooooeeeeeeeee\n   oo**************ooooooeeeeeeeeeee\n    eoooooooooooooooooeeeeeeeeeeeee\n      eeeooooooooeeeeeeeeeeeeeeee\n         eeeeeeeeeeeeeeeeeeeee\n             eeeeeeeeeeeee\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Perl", "code": "\nTranslation of: Raku\n\nuse strict;\nuse warnings;\n\nmy $x = my $y = 255;\n$x |= 1; # must be odd\nmy $depth = 255;\n\nmy $light = Vector->new(rand, rand, rand)->normalized;\n\nprint \"P2\\n$x $y\\n$depth\\n\";\n\nmy ($r, $ambient) = (($x - 1)/2, 0);\nmy ($r2) = $r ** 2;\n{\n    for my $x (-$r .. $r) {\n\tmy $x2 = $x**2;\n\tfor my $y (-$r .. $r) {\n\t    my $y2 = $y**2;\n\t    my $pixel = 0;\n\t    if ($x2 + $y2 < $r2) {\n\t\tmy $v = Vector->new($x, $y, sqrt($r2 - $x2 - $y2))->normalized;\n\t\tmy $I = $light . $v + $ambient;\n\t\t$I = $I < 0 ? 0 : $I > 1 ? 1 : $I;\n\t\t$pixel = int($I * $depth);\n\t    }\n\t    print $pixel;\n\t    print $y == $r ? \"\\n\" : \" \";\n\t}\n    }\n}\n\npackage Vector {\n    sub new {\n\tmy $class = shift;\n\tbless ref($_[0]) eq 'Array' ? $_[0] : [ @_ ], $class;\n    }\n    sub normalized {\n\tmy $this = shift;\n\tmy $norm = sqrt($this . $this);\n\tref($this)->new( map $_/$norm, @$this );\n    }\n    use overload q{.} => sub {\n\tmy ($a, $b) = @_;\n\tmy $sum = 0;\n\tfor (0 .. @$a - 1) {\n\t    $sum += $a->[$_] * $b->[$_]\n\t}\n\treturn $sum;\n    },\n    q{\"\"} => sub { sprintf \"Vector:[%s]\", join ' ', @{shift()} };\n}\n\n", "explain": "This produces a PGM image which can't be uploaded on rosettacode at the moment.  It looks similar as the Raku solution, though.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Lua", "code": "\nTranslation of: C\nWorks with: Lua version 5.1.4\nrequire (\"math\")\n\nshades = {'.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@'}\n\nfunction normalize (vec)\n    len = math.sqrt(vec[1]^2 + vec[2]^2 + vec[3]^2)\n    return {vec[1]/len, vec[2]/len, vec[3]/len}\nend\n\nlight = normalize{30, 30, -50}\n\nfunction dot (vec1, vec2)\n    d = vec1[1]*vec2[1] + vec1[2]*vec2[2] + vec1[3]*vec2[3]\n    return d < 0 and -d or 0\nend\n\nfunction draw_sphere (radius, k, ambient)\n    for i = math.floor(-radius),-math.floor(-radius) do\n        x = i + .5\n        local line = ''\n        for j = math.floor(-2*radius),-math.floor(-2*radius) do\n            y = j / 2 + .5\n            if x^2 + y^2 <= radius^2 then\n                vec = normalize{x, y, math.sqrt(radius^2 - x^2 - y^2)}\n                b = dot(light,vec) ^ k + ambient\n                intensity = math.floor ((1 - b) * #shades)\n                line = line .. (shades[intensity] or shades[1])\n            else\n                line = line .. ' '\n            end\n        end\n        print (line)\n    end\nend\n\ndraw_sphere (20, 4, 0.1)\ndraw_sphere (10, 2, 0.4)\n\n\nOutput:\n                               &&&&&&&&&&&&#####                                 \n                        &eeeoooooooooeeeeee&&&&&#######                          \n                    eooo*************oooooeeee&&&&&########                      \n                 eo**!!!!!!!!!!!!!!!*****ooooeeee&&&&#########                   \n              eo*!!!:::::...:::::::!!!!****oooeeee&&&&&##########                \n            o**!:::..............::::!!!!***ooooeee&&&&&###########              \n          o*!!::...................::::!!!***ooooeee&&&&&############            \n        eo*!::......................::::!!!***oooeeee&&&&&#############          \n       o*!::.........................:::!!!***ooooeee&&&&&##############         \n     &o*!::..........................:::!!!***ooooeeee&&&&###############%       \n    eo*!::...........................:::!!!***ooooeeee&&&&&###############%      \n   eo*!::............................:::!!!***ooooeeee&&&&&###############%%     \n  &o*!!::...........................:::!!!!***oooeeee&&&&&#################%%    \n  eo*!!:...........................::::!!!***ooooeeee&&&&&#################%%    \n eo**!!::.........................::::!!!****oooeeee&&&&&&#################%%%   \n eo**!!::.......................::::!!!!****oooeeeee&&&&&##################%%%   \n&eo**!!:::....................:::::!!!!***ooooeeeee&&&&&&##################%%%%  \n&eoo**!!::::................:::::!!!!****ooooeeeee&&&&&&###################%%%%  \n&eoo***!!!:::::........:::::::!!!!!****oooooeeeee&&&&&&###################%%%%%  \n&eeoo***!!!!:::::::::::::::!!!!!!*****ooooeeeee&&&&&&&####################%%%%%  \n&&eeoo****!!!!!!!!!!!!!!!!!!!!*****oooooeeeeee&&&&&&######################%%%%%  \n&&eeeooo******!!!!!!!!!!!*******ooooooeeeeee&&&&&&&######################%%%%%%  \n#&&eeeooooo******************oooooooeeeeee&&&&&&&#######################%%%%%%%  \n##&&&eeeeoooooooooo*ooooooooooooeeeeeeee&&&&&&&&#######################%%%%%%%%  \n ##&&&eeeeeeooooooooooooooooeeeeeeeee&&&&&&&&&########################%%%%%%%%   \n ###&&&&&eeeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&&##########################%%%%%%%%%   \n  ####&&&&&&&eeeeeeeeeeeeeee&&&&&&&&&&&&############################%%%%%%%%%    \n  ######&&&&&&&&&&&&&&&&&&&&&&&&&&&&&##############################%%%%%%%%%%    \n   ########&&&&&&&&&&&&&&&&&&&&&&################################%%%%%%%%%%%     \n    ###############&&&&&#######################################%%%%%%%%%%%%      \n     #########################################################%%%%%%%%%%%%       \n       #####################################################%%%%%%%%%%%%         \n        #################################################%%%%%%%%%%%%%%          \n          #############################################%%%%%%%%%%%%%%            \n            ########################################%%%%%%%%%%%%%%%              \n              ##################################%%%%%%%%%%%%%%%%%                \n                \u00a0%##########################%%%%%%%%%%%%%%%%%%                   \n                   \u00a0%%%%############%%%%%%%%%%%%%%%%%%%%%%%                      \n                       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%                          \n                              \u00a0%%%%%%%%%%%%%%%%%                                 \n                                                                                 \n             ........::!!*               \n         ...............::!!*o           \n      ....................::!**oo        \n    .......................::!**ooo      \n   ........................::!!**ooo     \n  .........................::!!**oooo    \n ..........................::!!**ooooe   \n...........................::!!**ooooee  \n..........................::!!***ooooee  \n.........................::!!!**oooooee  \n.......................:::!!!**oooooeee  \n:.....................::!!!***ooooooeee  \n!::................:::!!!!***ooooooeeee  \n\u00a0!!::..........:::::!!!****ooooooeeeee   \n  *!!!::::::::::!!!!!****oooooooeeeee    \n   o***!!!!!!!!!******ooooooooeeeeee     \n    ooo***********ooooooooooeeeeeee      \n      oooooooooooooooooooeeeeeeee        \n         eooooooooooeeeeeeeeee           \n             eeeeeeeeeeeee               \n                                         \n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Scala", "code": "\nobject Sphere extends App {\n  private val (shades, light) = (Seq('.', ':', '!', '*', 'o', 'e', '&', '#', '%', '@'), Array(30d, 30d, -50d))\n\n  private def drawSphere(r: Double, k: Double, ambient: Double): Unit = {\n    def dot(x: Array[Double], y: Array[Double]) = {\n      val d = x.head * y.head + x(1) * y(1) + x.last * y.last\n      if (d < 0) -d else 0D\n    }\n\n    for (i <- math.floor(-r).toInt to math.ceil(r).toInt; x = i + .5)\n      println(\n        (for (j <- math.floor(-2 * r).toInt to math.ceil(2 * r).toInt; y = j / 2.0 + .5)\n          yield if (x * x + y * y <= r * r) {\n\n            def intensity(vec: Array[Double]) = {\n              val b = math.pow(dot(light, vec), k) + ambient\n              if (b <= 0) shades.length - 2\n              else math.max((1 - b) * (shades.length - 1), 0).toInt\n            }\n\n            shades(intensity(normalize(Array(x, y, scala.math.sqrt(r * r - x * x - y * y)))))\n          } else ' ').mkString)\n  }\n\n  private def normalize(v: Array[Double]): Array[Double] = {\n    val len = math.sqrt(v.head * v.head + v(1) * v(1) + v.last * v.last)\n    v.map(_ / len)\n  }\n\n  normalize(light).copyToArray(light)\n  drawSphere(20, 4, .1)\n  drawSphere(10, 2, .4)\n\n}\n\n\nOutput:See it in running in your browser by ScalaFiddle (JavaScript) or by Scastie (JVM).\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "D", "code": "\nTranslation of: C\nimport std.stdio, std.math, std.algorithm, std.numeric;\n\nalias V3 = double[3];\nimmutable light = normalize([30.0, 30.0, -50.0]);\n\nV3 normalize(V3 v) pure @nogc {\n    v[] /= dotProduct(v, v) ^^ 0.5;\n    return v;\n}\n\ndouble dot(in ref V3 x, in ref V3 y) pure nothrow @nogc {\n    immutable double d = dotProduct(x, y);\n    return d < 0 ? -d : 0;\n}\n\nvoid drawSphere(in double R, in double k, in double ambient) @nogc {\n    enum shades = \".:!*oe&#%@\";\n    foreach (immutable i; cast(int)floor(-R) .. cast(int)ceil(R) + 1) {\n        immutable double x = i + 0.5;\n        foreach (immutable j; cast(int)floor(-2 * R) ..\n                              cast(int)ceil(2 * R) + 1) {\n            immutable double y = j / 2. + 0.5;\n            if (x ^^ 2 + y ^^ 2 <= R ^^ 2) {\n                immutable vec = [x, y, (R^^2 - x^^2 - y^^2) ^^ 0.5]\n                                .normalize;\n                immutable double b = dot(light, vec) ^^ k + ambient;\n                int intensity = cast(int)((1 - b) * (shades.length-1));\n                intensity = min(shades.length - 1, max(intensity, 0));\n                shades[intensity].putchar;\n            } else\n                ' '.putchar;\n        }\n        '\\n'.putchar;\n    }\n}\n\nvoid main() {\n    drawSphere(20, 4, 0.1);\n    drawSphere(10, 2, 0.4);\n}\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Haskell", "code": "\n\nimport Graphics.Rendering.OpenGL.GL\nimport Graphics.UI.GLUT.Objects\nimport Graphics.UI.GLUT\n\nsetProjection :: IO ()\nsetProjection = do\n  matrixMode $= Projection\n  ortho (-1) 1 (-1) 1 0 (-1)\n         \ngrey1,grey9,red,white :: Color4 GLfloat\ngrey1 = Color4 0.1 0.1 0.1 1\ngrey9 = Color4 0.9 0.9 0.9 1\nred   = Color4 1   0   0   1\nwhite = Color4 1   1   1   1\n\nsetLights :: IO ()\nsetLights = do\n  let l = Light 0\n  ambient  l $= grey1\n  diffuse  l $= white\n  specular l $= white\n  position l $= Vertex4 (-4) 4 3 (0 :: GLfloat)\n  light    l $= Enabled\n  lighting   $= Enabled\n\nsetMaterial :: IO ()\nsetMaterial = do\n  materialAmbient   Front $= grey1\n  materialDiffuse   Front $= red\n  materialSpecular  Front $= grey9\n  materialShininess Front $= (32 :: GLfloat)\n\ndisplay :: IO()\ndisplay = do\n  clear [ColorBuffer]\n  renderObject Solid $ Sphere' 0.8 64 64\n  swapBuffers\n\nmain :: IO()\nmain = do\n  _ <- getArgsAndInitialize\n  _ <- createWindow \"Sphere\"\n  clearColor $= Color4 0.0 0.0 0.0 0.0\n  setProjection\n  setLights\n  setMaterial\n  displayCallback $= display\n  mainLoop\n\nASCII art[edit]\nTranslation of: Python\nimport Data.List (genericLength)\n\nshades = \".:!*oe%#&@\"\nn = genericLength shades\ndot a b = sum $ zipWith (*) a b\nnormalize x = (/ sqrt (x `dot` x)) <$> x\n\nsphere r k amb light = unlines $\n  [ [ if x*x + y*y <= r*r\n      then let vec = normalize [x, y, sqrt (r*r-x*x-y*y)]\n               b = (light `dot` vec) ** k + amb\n               intensity = (1 - b)*(n - 1)\n           in shades !! round ((0 `max` intensity) `min` n)\n      else ' '\n    | y <- map (/2.12) [- 2*r - 0.5 .. 2*r + 0.5]  ]\n  | x <- [ - r - 0.5 .. r + 0.5] ]\n\n\u03bb> putStrLn $ sphere 10 4 0.1 (normalize [30,30,-50])\n                                          \n              #%%%%%%%####&&              \n          eoo*****oooee%%%###&&&          \n       eo*!!::::!!!**ooee%%%###&&&&       \n     e*!::......::!!**ooee%%####&&&&&     \n   %o!::.........::!!**ooee%%###&&&&&&&   \n  eo!::..........::!!**ooee%%###&&&&&&&&  \n %o*!:..........::!!**ooee%%%###&&&&&&&&& \n#eo*!::.......:::!!**ooeee%%####&&&&&&&&&&\n%eo*!!:::::::::!!***ooeee%%####&&&&&&&&&&&\n%eeo**!!!!!!!!****ooeee%%%####&&&&&&&&&&&&\n#%eeooo*******ooooeee%%%%####&&&&&&&&&&&&&\n##%%eeeoooooooeeeee%%%%####&&&&&&&&&&&&&&&\n&###%%%%eeeeee%%%%%%######&&&&&&&&&&&&&&&#\n &&####%%%%%%%%########&&&&&&&&&&&&&&&&&& \n  &&&##############&&&&&&&&&&&&&&&&&&&&&  \n   &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&#   \n     &&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&     \n       &&&&&&&&&&&&&&&&&&&&&&&&&&&&       \n          &&&&&&&&&&&&&&&&&&&&&&          \n              &&&&&&&&&&&&&#              \n                                          \n\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "VBScript", "code": "\nTranslation of: C\nshades = Array(\".\", \":\", \"!\", \"*\", \"o\", \"e\", \"&\", \"#\", \"%\", \"@\")\nlight = Array(30, 30, -50)\n\nSub Normalize(v)\n   length = Sqr(v(0)*v(0) + v(1)*v(1) + v(2)*v(2))\n   v(0) = v(0)/length : v(1) = v(1)/length : v(2) = v(2)/length\nEnd Sub\n\nFunction Dot(x, y)\n   d = x(0)*y(0) + x(1)*y(1) + x(2)*y(2)\n   If d < 0 Then Dot = -d Else Dot = 0 End If\nEnd Function\n\n'floor function is the Int function\n'ceil function implementation\nFunction Ceil(x)\n    Ceil = Int(x)\n    If Ceil <> x Then Ceil = Ceil + 1 End if\nEnd Function\n\nSub DrawSphere(R, k, ambient)\n   Dim i, j, intensity, inten, b, x, y\n   Dim vec(3)\n   For i = Int(-R) to Ceil(R)\n      x = i + 0.5\n      line = \"\"\n      For j = Int(-2*R) to Ceil(2*R)\n         y = j / 2 + 0.5\n         If x * x + y * y <= R*R Then\n            vec(0) = x\n            vec(1) = y\n            vec(2) = Sqr(R * R - x * x - y * y)\n            Normalize vec\n            b = dot(light, vec)^k + ambient\n            intensity = Int((1 - b) * UBound(shades))\n            If intensity < 0 Then intensity = 0 End If\n            If intensity >= UBound(shades) Then\n               intensity = UBound(shades)\n            End If\n            line = line & shades(intensity)\n         Else\n            line = line & \" \"\n         End If\n      Next\n      WScript.StdOut.WriteLine line\n   Next\nEnd Sub\n\nNormalize light\nDrawSphere 20, 4, 0.1\nDrawSphere 10,2,0.4\n\n\nOutput:\n                               &&&&&&&&&&#######\n                        &eeeeeeeeeeeeeeee&&&&&&#######%\n                    &eoooo*******oooooooeeeee&&&&&########%\n                 eoo****!!!!!!!!******oooooeeee&&&&&########%%\n              eoo**!!!!::::::::!!!!!*****ooooeeee&&&&&########%%%\n            eo**!!::::::...:::::::!!!!!***ooooeeee&&&&&########%%%%\n          eo*!!:::.............:::::!!!!***ooooeeee&&&&&########%%%%%\n        eo*!!:::.................::::!!!!***ooooeeee&&&&#########%%%%%%\n       eo*!!::....................::::!!!****oooeeee&&&&&#########%%%%%%\n     &o**!::......................::::!!!****oooeeee&&&&&##########%%%%%%%\n    &o**!::.......................::::!!!****oooeeee&&&&&##########%%%%%%%%\n   &oo*!!::.......................:::!!!!***ooooeeee&&&&&##########%%%%%%%%%\n  &eo*!!::.......................::::!!!****ooooeeee&&&&&##########%%%%%%%%%%\n  eo**!!::......................::::!!!!***ooooeeeee&&&&&##########%%%%%%%%%%\n &eo**!!:::...................:::::!!!!****ooooeeee&&&&&###########%%%%%%%%%%%\n eeo**!!::::................:::::!!!!!****ooooeeee&&&&&&###########%%%%%%%%%%%\n&eeo***!!:::::...........::::::!!!!!****oooooeeee&&&&&&###########%%%%%%%%%%%%%\n&eeoo**!!!!::::::::::::::::::!!!!!*****ooooeeeee&&&&&&############%%%%%%%%%%%%%\n&eeooo***!!!!::::::::::::!!!!!!!*****oooooeeeee&&&&&&############%%%%%%%%%%%%%%\n&&eeooo***!!!!!!!!!!!!!!!!!!!******oooooeeeeee&&&&&&############%%%%%%%%%%%%%%%\n&&eeeooo******!!!!!!!!!!********ooooooeeeeee&&&&&&&############%%%%%%%%%%%%%%%%\n#&&eeeooooo******************oooooooeeeeee&&&&&&&#############%%%%%%%%%%%%%%%%%\n#&&&eeeeoooooooo******oooooooooooeeeeeee&&&&&&&&#############%%%%%%%%%%%%%%%%%%\n##&&&&eeeeeooooooooooooooooooeeeeeeee&&&&&&&&&##############%%%%%%%%%%%%%%%%%%%\n ##&&&&&eeeeeeeeeeeeeeeeeeeeeeeeee&&&&&&&&&################%%%%%%%%%%%%%%%%%%%\n ####&&&&&&eeeeeeeeeeeeeeeeeee&&&&&&&&&&&################%%%%%%%%%%%%%%%%%%%%%\n  #####&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&&#################%%%%%%%%%%%%%%%%%%%%%%\n \u00a0%#######&&&&&&&&&&&&&&&&&&&&&&&&###################%%%%%%%%%%%%%%%%%%%%%%%%\n  \u00a0%###########&&&&&&&&&&&&&#######################%%%%%%%%%%%%%%%%%%%%%%%%%\n   \u00a0%############################################%%%%%%%%%%%%%%%%%%%%%%%%%%\n    \u00a0%%#######################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n      \u00a0%%#################################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n       \u00a0%%%%%#########################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n         \u00a0%%%%%%%%#############%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n           \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n             \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                   \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n                              \u00a0%%%%%%%%%%%%%%%%%\n\n            \u00a0::...:::!!!*o\n         ..............::!!*oo\n      ..................::!!**ooe\n    .....................::!!**ooee\n   .......................::!!**ooee\n  ........................::!!**oooee\n .........................::!!**oooeee\n:........................::!!!**oooeeee\n........................::!!!**ooooeeee\n:......................::!!!***oooeeeee\n:....................:::!!!***oooeeeeee\n!:.................:::!!!****oooeeeeeee\n*!:::...........::::!!!!***ooooeeeeeeee\n *!!!:::::::::::!!!!!****oooooeeeeeeee\n  o**!!!!!!!!!!!!!*****oooooeeeeeeeee\n   oo**************ooooooeeeeeeeeeee\n    eoooooooooooooooooeeeeeeeeeeeee\n      eeeooooooooeeeeeeeeeeeeeeee\n         eeeeeeeeeeeeeeeeeeeee\n             eeeeeeeeeeeee\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Logo", "code": "\n\nWorks with: MSWlogo\nto sphere :r\ncs perspective ht ;making the room ready to use\nrepeat 180 [polystart circle :r polyend down 1]\npolyview\nend\n", "explain": "Drawing a sphere is actually very simple in logo, using the perspective function to make life easier.\n"}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "Zig", "code": "\nTranslation of: Factor\nLibrary: raylib\nconst std = @import(\"std\");\nconst c = @cImport({\n    @cInclude(\"raylib.h\");\n});\n\npub fn main() !void {\n    c.SetConfigFlags(c.FLAG_WINDOW_RESIZABLE | c.FLAG_VSYNC_HINT);\n    c.InitWindow(600, 480, \"Draw a Sphere\");\n    defer c.CloseWindow();\n\n    const camera = c.Camera3D{\n        .position = .{ .x = 4.5, .y = 4.5, .z = 4.5 },\n        .target = .{ .x = 0, .y = 0, .z = 0 },\n        .up = .{ .x = 0, .y = 1, .z = 0 },\n        .fovy = 45.0,\n        .projection = c.CAMERA_PERSPECTIVE,\n    };\n\n    c.SetTargetFPS(60);\n\n    while (!c.WindowShouldClose()) {\n        c.BeginDrawing();\n        defer c.EndDrawing();\n\n        c.ClearBackground(c.BLACK);\n\n        {\n            c.BeginMode3D(camera);\n            defer c.EndMode3D();\n\n            c.DrawSphereWires(.{ .x = 0, .y = 0, .z = 0 }, 2, 20, 20, c.LIME);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Draw a sphere", "task_url": "https://rosettacode.org/wiki/Draw_a_sphere", "task_cat": "3D", "lang": "AWK", "code": "\n# syntax: GAWK -f DRAW_A_SPHERE.AWK\n# converted from VBSCRIPT\nBEGIN {\n    draw_sphere(20,4,0.1)\n    draw_sphere(10,2,0.4)\n    exit(0)\n}\nfunction draw_sphere(radius,k,ambient, b,i,intensity,j,leng_shades,light,line,shades,vec,x,y) {\n    leng_shades = split0(\".:!*oe&#%@\",shades,\"\")\n    split(\"30,30,-50\",light,\",\")\n    normalize(light)\n    for (i=int(-radius); i<=ceil(radius); i++) {\n      x = i + 0.5\n      line = \"\"\n      for (j=int(-2*radius); j<=ceil(2*radius); j++) {\n        y = j / 2 + 0.5\n        if (x*x + y*y <= radius*radius) {\n          vec[1] = x\n          vec[2] = y\n          vec[3] = sqrt(radius*radius - x*x - y*y)\n          normalize(vec)\n          b = dot(light,vec) ^ k + ambient\n          intensity = int((1-b) * leng_shades)\n          if (intensity < 0) {\n            intensity = 0\n          }\n          if (intensity >= leng_shades) {\n            intensity = leng_shades\n          }\n          line = line shades[intensity]\n        }\n        else {\n          line = line \" \"\n        }\n      }\n      printf(\"%s\\n\",line)\n    }\n}\nfunction ceil(x,  tmp) {\n    tmp = int(x)\n    return (tmp != x) ? tmp+1 : tmp\n}\nfunction dot(x,y,  tmp) {\n    tmp = x[1]*y[1] + x[2]*y[2] + x[3]*y[3]\n    return (tmp < 0) ? -tmp : 0\n}\nfunction normalize(v,  tmp) {\n    tmp = sqrt(v[1]*v[1] + v[2]*v[2] + v[3]*v[3])\n    v[1] /= tmp\n    v[2] /= tmp\n    v[3] /= tmp\n}\nfunction split0(str,array,fs,  arr,i,n) { # same as split except indices start at zero\n    n = split(str,arr,fs)\n    for (i=1; i<=n; i++) {\n      array[i-1] = arr[i]\n    }\n    return(n)\n}\n\n\nOutput:\n                               ############%%%%%\n                        #&&&eeeeeeeee&&&&&&#####%%%%%%%\n                    &eeeoooooooooooooeeeee&&&&#####%%%%%%%%\n                 &eoo***************oooooeeee&&&&####%%%%%%%%%\n              &eo***!!!!!:::!!!!!!!****ooooeee&&&&#####%%%%%%%%%%\n            eoo*!!!::::::::::::::!!!!****oooeeee&&&#####%%%%%%%%%%%\n          eo**!!:::............::::!!!!***oooeeee&&&#####%%%%%%%%%%%%\n        &eo*!!::.................:::!!!!***oooeee&&&&#####%%%%%%%%%%%%%\n       eo*!!::...................::::!!!***oooeeee&&&#####%%%%%%%%%%%%%%\n     #eo*!!::.....................:::!!!***oooeeee&&&&####%%%%%%%%%%%%%%%@\n    &eo*!!::......................:::!!!***oooeeee&&&&#####%%%%%%%%%%%%%%%@\n   &eo*!!::......................::::!!!***oooeeee&&&&#####%%%%%%%%%%%%%%%@@\n  #eo**!!::......................:::!!!****oooeee&&&&#####%%%%%%%%%%%%%%%%%@@\n  &eo**!:::....................::::!!!!***oooeeee&&&&#####%%%%%%%%%%%%%%%%%@@\n &eoo**!!::...................::::!!!!***ooooeee&&&&######%%%%%%%%%%%%%%%%%@@@\n &eoo**!!:::................::::!!!!****ooooeee&&&&&#####%%%%%%%%%%%%%%%%%%@@@\n#&eoo**!!!::::...........:::::!!!!!****oooeeee&&&&&######%%%%%%%%%%%%%%%%%%@@@@\n#&eeoo**!!!!::::::::::::::::!!!!!****ooooeeee&&&&&######%%%%%%%%%%%%%%%%%%%@@@@\n#&eeooo***!!!!!::::::::!!!!!!!*****ooooeeeee&&&&&######%%%%%%%%%%%%%%%%%%%@@@@@\n#&&eeooo****!!!!!!!!!!!!!!!******oooooeeee&&&&&#######%%%%%%%%%%%%%%%%%%%%@@@@@\n##&&eeoooo********************oooooeeeee&&&&&&######%%%%%%%%%%%%%%%%%%%%%%@@@@@\n##&&&eeeoooooo***********oooooooeeeeee&&&&&&#######%%%%%%%%%%%%%%%%%%%%%%@@@@@@\n%##&&&eeeeeooooooooooooooooooeeeeeee&&&&&&#######%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@\n%%###&&&&eeeeeeeeeeoeeeeeeeeeeee&&&&&&&&########%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@\n\u00a0%%###&&&&&&eeeeeeeeeeeeeeee&&&&&&&&&#########%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@\n\u00a0%%%#####&&&&&&&&&&&&&&&&&&&&&&&&##########%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@\n \u00a0%%%%#######&&&&&&&&&&&&&&&############%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@\n \u00a0%%%%%%#############################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@\n  \u00a0%%%%%%%%######################%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@\n   \u00a0%%%%%%%%%%%%%%%#####%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@\n    \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@\n      \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@\n       \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@\n         \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@\n           \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@@\n             \u00a0%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@@@@\n                 @%%%%%%%%%%%%%%%%%%%%%%%%%%@@@@@@@@@@@@@@@@@@\n                    @@@@%%%%%%%%%%%%@@@@@@@@@@@@@@@@@@@@@@@\n                        @@@@@@@@@@@@@@@@@@@@@@@@@@@@@@@\n                               @@@@@@@@@@@@@@@@@\n\n            \u00a0::..::::!!**o\n         .............::!!**oe\n      ..................::!!*ooee\n    .....................::!!*ooeee\n   .......................:!!**ooeee\n  ........................:!!**ooeeee\n ........................::!!**ooeeee&\n:........................::!!**ooeeee&&\n........................::!!**oooeeee&&\n:......................::!!***ooeeeee&&\n:....................::!!!***ooeeeee&&&\n!::................:::!!***oooeeeeee&&&\n*!!::..........::::!!!****oooeeeeee&&&&\n **!!::::::::::!!!!!***ooooeeeeee&&&&&\n  o***!!!!!!!!!!*****ooooeeeeeee&&&&&\n   eooo*********ooooooeeeeeeee&&&&&&\n    eeeoooooooooooeeeeeeeeee&&&&&&&\n      eeeeeeeeeeeeeeeeeee&&&&&&&&\n         &eeeeeeeeee&&&&&&&&&&\n             &&&&&&&&&&&&&\n\n\n", "explain": ""}]