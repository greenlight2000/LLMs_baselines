[{"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Python", "code": "\n\npeople = [('joe', 120), ('foo', 31), ('bar', 51)]\nsorted(people)\n\n\n[('bar', 51), ('foo', 31), ('joe', 120)]\n\n\nfrom operator import itemgetter\npeople = [(120, 'joe'), (31, 'foo'), (51, 'bar')]\npeople.sort(key=itemgetter(1))\n\n\n[(51, 'bar'), (31, 'foo'), (120, 'joe')]\n\n", "explain": "Recent versions of Python provide the sorted() built-in that works on any iterable.\nWhich leaves people with the value:\nThe most Pythonic (and fastest) version is to use itemgetter together with the key parameter to sort resp. sorted to perform the Decorate-sort-undecorate pattern:\nWhich leaves people with the value:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <ctype.h>\n\ntypedef struct twoStringsStruct {\n    char * key, *value;\n} sTwoStrings;\n \nint ord( char v )\n{\n    static char *dgts = \"012345679\";\n    char *cp;\n    for (cp=dgts; v != *cp; cp++);\n    return (cp-dgts);\n}\n\nint cmprStrgs(const sTwoStrings *s1,const sTwoStrings *s2)\n{\n    char *p1 = s1->key; \n    char *p2 = s2->key;\n    char *mrk1, *mrk2;\n    while ((tolower(*p1) == tolower(*p2)) && *p1) { p1++; p2++;}\n    if (isdigit(*p1) && isdigit(*p2)) {\n        long v1, v2;\n        if ((*p1 == '0') ||(*p2 == '0')) {\n            while (p1 > s1->key) {\n                p1--; p2--;\n                if (*p1 != '0') break;\n            }\n            if (!isdigit(*p1)) {\n                p1++; p2++;\n            }\n        }\n        mrk1 = p1; mrk2 = p2;\n        v1 = 0;\n        while(isdigit(*p1)) {\n            v1 = 10*v1+ord(*p1);\n            p1++;\n        }\n        v2 = 0;\n        while(isdigit(*p2)) {\n            v2 = 10*v2+ord(*p2);\n            p2++;\n        }\n        if (v1 == v2) \n           return(p2-mrk2)-(p1-mrk1);\n        return v1 - v2;\n    }\n    if (tolower(*p1) != tolower(*p2))\n       return (tolower(*p1) - tolower(*p2));\n    for(p1=s1->key, p2=s2->key; (*p1 == *p2) && *p1; p1++, p2++);\n    return (*p1 -*p2);\n}\n\nint maxstrlen( char *a, char *b)\n{\n\tint la = strlen(a);\n\tint lb = strlen(b);\n\treturn (la>lb)? la : lb;\n}\n\nint main()\n{\n    sTwoStrings toBsorted[] = {\n        { \"Beta11a\", \"many\" },\n        { \"alpha1\", \"This\" },\n        { \"Betamax\", \"sorted.\" },\n        { \"beta3\", \"order\" },\n        { \"beta11a\", \"strings\" },\n        { \"beta001\", \"is\" },\n        { \"beta11\", \"which\" },\n        { \"beta041\", \"be\" },\n        { \"beta05\", \"in\" },\n        { \"beta1\", \"the\" },\n        { \"beta40\", \"should\" },\n    };\n#define ASIZE (sizeof(toBsorted)/sizeof(sTwoStrings))\n    int k, maxlens[ASIZE];\n    char format[12];\n    sTwoStrings *cp;\n\n    qsort( (void*)toBsorted, ASIZE, sizeof(sTwoStrings),cmprStrgs); \n\n    for (k=0,cp=toBsorted; k < ASIZE; k++,cp++) {\n        maxlens[k] = maxstrlen(cp->key, cp->value);   \n        sprintf(format,\"\u00a0%%-%ds\", maxlens[k]);\n        printf(format, toBsorted[k].value);\n\t}\n    printf(\"\\n\");\n    for (k=0; k < ASIZE; k++) {\n        sprintf(format,\"\u00a0%%-%ds\", maxlens[k]);\n        printf(format, toBsorted[k].key);\n\t}\n    printf(\"\\n\");\n\n  return 0;\n}\n\n\n   This      is   the order     in  which    many strings should      be sorted.\n alpha1 beta001 beta1 beta3 beta05 beta11 Beta11a beta11a beta40 beta041 Betamax\n", "explain": "Using qsort, from the standard library.\nOutput:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "C++", "code": "\n\ng++ -std=c++11 sort.cpp\n\n#include <algorithm>\n#include <iostream>\n#include <string>\n\nstruct entry {\n  std::string name;\n  std::string value;\n};\n\nint main() {\n  entry array[] = { { \"grass\", \"green\" }, { \"snow\", \"white\" },\n                    { \"sky\", \"blue\" }, { \"cherry\", \"red\" } };\n\n  std::cout << \"Before sorting:\\n\";\n  for (const auto &e : array) {\n    std::cout << \"{\" << e.name << \", \" << e.value << \"}\\n\";\n  }\n\n  std::sort(std::begin(array), std::end(array), \n            [](const entry & a, const entry & b) {\n    return a.name < b.name;\n  });\n\n  std::cout << \"After sorting:\\n\";\n  for (const auto &e : array) {\n    std::cout << \"{\" << e.name << \", \" << e.value << \"}\\n\";\n  }\n}\n\n\nBefore sorting:\n{grass, green}\n{snow, white}\n{sky, blue}\n{cherry, red}\nAfter sorting:\n{cherry, red}\n{grass, green}\n{sky, blue}\n{snow, white}\n\n", "explain": "Uses C++11. Compile with\nOutput:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Java", "code": "\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SortComp {\n    public static class Pair {\n        public String name;\n        public String value;\n        public Pair(String n, String v) {\n            name = n;\n            value = v;\n        }\n    }\n\n    public static void main(String[] args) {\n        Pair[] pairs = {new Pair(\"06-07\", \"Ducks\"), new Pair(\"00-01\", \"Avalanche\"),\n            new Pair(\"02-03\", \"Devils\"), new Pair(\"01-02\", \"Red Wings\"),\n            new Pair(\"03-04\", \"Lightning\"), new Pair(\"04-05\", \"lockout\"),\n            new Pair(\"05-06\", \"Hurricanes\"), new Pair(\"99-00\", \"Devils\"),\n            new Pair(\"07-08\", \"Red Wings\"), new Pair(\"08-09\", \"Penguins\")};\n\n        sortByName(pairs);\n        for (Pair p : pairs) {\n            System.out.println(p.name + \" \" + p.value);\n        }\n    }\n\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, new Comparator<Pair>() {\n            public int compare(Pair p1, Pair p2) {\n                return p1.name.compareTo(p2.name);\n            }\n        });\n    }\n}\n\n\n00-01 Avalanche\n01-02 Red Wings\n02-03 Devils\n03-04 Lightning\n04-05 lockout\n05-06 Hurricanes\n06-07 Ducks\n07-08 Red Wings\n08-09 Penguins\n99-00 Devils\n\nWorks with: Java version 8+\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, (p1, p2) -> p1.name.compareTo(p2.name));\n    }\n\n\nWorks with: Java version 8+\n    public static void sortByName(Pair[] pairs) {\n        Arrays.sort(pairs, Comparator.comparing(p -> p.name));\n    }\n\n", "explain": "Output:\nIn Java 8, we can write the above using a lambda:\nWe can further use Comparator.comparing() to construct the comparator from a \"key\" function:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "C#", "code": "\nWorks with: C# version 3+\nusing System;\nusing System.Collections.Generic;\nusing System.Linq;\n\nclass Program\n{        \n    struct Entry\n    {\n        public Entry(string name, double value) { Name = name; Value = value; }\n        public string Name;\n        public double Value;\n    }\n\n    static void Main(string[] args)\n    {\n        var Elements = new List<Entry>\n        {\n            new Entry(\"Krypton\", 83.798), new Entry(\"Beryllium\", 9.012182), new Entry(\"Silicon\", 28.0855),\n            new Entry(\"Cobalt\", 58.933195), new Entry(\"Selenium\", 78.96), new Entry(\"Germanium\", 72.64)\n        };\n\n        var sortedElements = Elements.OrderBy(e => e.Name);\n\n        foreach (Entry e in sortedElements)\n            Console.WriteLine(\"{0,-11}{1}\", e.Name, e.Value);\n    }\n}\n\n\nBeryllium  9.012182\nCobalt     58.933195\nGermanium  72.64\nKrypton    83.798\nSelenium   78.96\nSilicon    28.0855\n", "explain": "Output:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nES5[edit]\nvar arr = [\n  {id: 3, value: \"foo\"},\n  {id: 2, value: \"bar\"},\n  {id: 4, value: \"baz\"},\n  {id: 1, value: 42},\n  {id: 5, something: \"another string\"} // Works with any object declaring 'id' as a number.\n];\narr = arr.sort(function(a, b) {return a.id - b.id}); // Sort with comparator checking the id.\n\nES6[edit]\n(() => {\n    'use strict';\n\n    // GENERIC FUNCTIONS FOR COMPARISONS\n\n    // compare\u00a0:: a -> a -> Ordering\n    const compare = (a, b) => a < b ? -1 : (a > b ? 1 : 0);\n\n    // on\u00a0:: (b -> b -> c) -> (a -> b) -> a -> a -> c\n    const on = (f, g) => (a, b) => f(g(a), g(b));\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f => (a, b) => f.apply(null, [b, a]);\n\n    // arrayCopy\u00a0:: [a] -> [a]\n    const arrayCopy = (xs) => xs.slice(0);\n\n    // show\u00a0:: a -> String\n    const show = x => JSON.stringify(x, null, 2);\n\n\n    // TEST\n    const xs = [{\n        name: 'Shanghai',\n        pop: 24.2\n    }, {\n        name: 'Karachi',\n        pop: 23.5\n    }, {\n        name: 'Beijing',\n        pop: 21.5\n    }, {\n        name: 'Sao Paulo',\n        pop: 24.2\n    }, {\n        name: 'Dhaka',\n        pop: 17.0\n    }, {\n        name: 'Delhi',\n        pop: 16.8\n    }, {\n        name: 'Lagos',\n        pop: 16.1\n    }]\n\n    // population\u00a0:: Dictionary -> Num\n    const population = x => x.pop;\n\n    // name\u00a0:: Dictionary -> String\n    const name = x => x.name;\n\n    return show({\n        byPopulation: arrayCopy(xs)\n            .sort(on(compare, population)),\n        byDescendingPopulation: arrayCopy(xs)\n            .sort(on(flip(compare), population)),\n        byName: arrayCopy(xs)\n            .sort(on(compare, name)),\n        byDescendingName: arrayCopy(xs)\n            .sort(on(flip(compare), name))\n    });\n})();\n\n\nOutput:\n{\n  \"byPopulation\": [\n    {\n      \"name\": \"Lagos\",\n      \"pop\": 16.1\n    },\n    {\n      \"name\": \"Delhi\",\n      \"pop\": 16.8\n    },\n    {\n      \"name\": \"Dhaka\",\n      \"pop\": 17\n    },\n    {\n      \"name\": \"Beijing\",\n      \"pop\": 21.5\n    },\n    {\n      \"name\": \"Karachi\",\n      \"pop\": 23.5\n    },\n    {\n      \"name\": \"Shanghai\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Sao Paulo\",\n      \"pop\": 24.2\n    }\n  ],\n  \"byDescendingPopulation\": [\n    {\n      \"name\": \"Shanghai\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Sao Paulo\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Karachi\",\n      \"pop\": 23.5\n    },\n    {\n      \"name\": \"Beijing\",\n      \"pop\": 21.5\n    },\n    {\n      \"name\": \"Dhaka\",\n      \"pop\": 17\n    },\n    {\n      \"name\": \"Delhi\",\n      \"pop\": 16.8\n    },\n    {\n      \"name\": \"Lagos\",\n      \"pop\": 16.1\n    }\n  ],\n  \"byName\": [\n    {\n      \"name\": \"Beijing\",\n      \"pop\": 21.5\n    },\n    {\n      \"name\": \"Delhi\",\n      \"pop\": 16.8\n    },\n    {\n      \"name\": \"Dhaka\",\n      \"pop\": 17\n    },\n    {\n      \"name\": \"Karachi\",\n      \"pop\": 23.5\n    },\n    {\n      \"name\": \"Lagos\",\n      \"pop\": 16.1\n    },\n    {\n      \"name\": \"Sao Paulo\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Shanghai\",\n      \"pop\": 24.2\n    }\n  ],\n  \"byDescendingName\": [\n    {\n      \"name\": \"Shanghai\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Sao Paulo\",\n      \"pop\": 24.2\n    },\n    {\n      \"name\": \"Lagos\",\n      \"pop\": 16.1\n    },\n    {\n      \"name\": \"Karachi\",\n      \"pop\": 23.5\n    },\n    {\n      \"name\": \"Dhaka\",\n      \"pop\": 17\n    },\n    {\n      \"name\": \"Delhi\",\n      \"pop\": 16.8\n    },\n    {\n      \"name\": \"Beijing\",\n      \"pop\": 21.5\n    }\n  ]\n}\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "SQL", "code": "\nWe can treat the array of data structures as a table. An order by clause in a query will sort the data.-- setup\ncreate table pairs (name varchar(16), value varchar(16));\ninsert into pairs values ('Fluffy', 'cat');\ninsert into pairs values ('Fido', 'dog');\ninsert into pairs values ('Francis', 'fish');\n-- order them by name\nselect * from pairs order by name;\n\n\nOutput:\nNAME             VALUE\n---------------- ----------------\nFido             dog\nFluffy           cat\nFrancis          fish\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nPROGRAM EXAMPLE\n  IMPLICIT NONE  \n\n  TYPE Pair\n    CHARACTER(6) :: name\n    CHARACTER(1) :: value\n  END TYPE Pair\n\n  TYPE(Pair) :: rcc(10), temp\n  INTEGER :: i, j\n\n  rcc(1) = Pair(\"Black\", \"0\")\n  rcc(2) = Pair(\"Brown\", \"1\")\n  rcc(3) = Pair(\"Red\", \"2\")\n  rcc(4) = Pair(\"Orange\", \"3\")\n  rcc(5) = Pair(\"Yellow\", \"4\") \n  rcc(6) = Pair(\"Green\", \"5\")\n  rcc(7) = Pair(\"Blue\", \"6\")\n  rcc(8) = Pair(\"Violet\", \"7\")\n  rcc(9) = Pair(\"Grey\", \"8\")\n  rcc(10) = Pair(\"White\", \"9\")\n\n  DO i = 2, SIZE(rcc)\n     j = i - 1\n     temp = rcc(i)\n        DO WHILE (j>=1 .AND. LGT(rcc(j)%name, temp%name))\n           rcc(j+1) = rcc(j)\n           j = j - 1\n        END DO\n     rcc(j+1) = temp\n  END DO\n\n  WRITE (*,\"(2A6)\") rcc\n\nEND PROGRAM EXAMPLE\n\n\nBlack      0\nBlue       6\nBrown      1\nGreen      5\nGrey       8\nOrange     3\nRed        2\nViolet     7\nWhite      9\nYellow     4\n\n", "explain": "Standard Fortran has no built-in sort function although some compilers add them. The following example uses an insertion sort.\nOutput\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"sort\"\n)\n\ntype pair struct {\n    name, value string\n}\ntype csArray []pair\n\n// three methods satisfy sort.Interface\nfunc (a csArray) Less(i, j int) bool { return a[i].name < a[j].name }\nfunc (a csArray) Len() int           { return len(a) }\nfunc (a csArray) Swap(i, j int)      { a[i], a[j] = a[j], a[i] }\n\nvar x = csArray{\n    pair{\"joe\", \"120\"},\n    pair{\"foo\", \"31\"},\n    pair{\"bar\", \"251\"},\n}\n\nfunc main() {\n    sort.Sort(x)\n    for _, p := range x {\n        fmt.Printf(\"%5s: %s\\n\", p.name, p.value)\n    }\n}\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program compositeSort.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* city structure      */\n    .struct  0\ncity_name:                             @ \n    .struct  city_name + 4 \ncity_habitants:                             @ \n    .struct  city_habitants + 4 \ncity_end:\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessResult:        .asciz \"Name\u00a0: @  number habitants\u00a0: @ \\n\"\nszMessSortHab:      .asciz \"Sort table for number of habitants\u00a0:\\n\"\nszMessSortName:     .asciz \"Sort table for name of city\u00a0:\\n\"\nszCarriageReturn:   .asciz \"\\n\"\n \n// cities name\nszCeret:           .asciz \"Ceret\"\nszMaureillas:      .asciz \"Maureillas\"\nszTaillet:         .asciz \"Taillet\"\nszReynes:          .asciz \"Reynes\"\nszVives:           .asciz \"Viv\u00e9s\"\nszBoulou:          .asciz \"Le Boulou\"\nszSaintJean:       .asciz \"Saint Jean Pla de Corts\"\nszCluses:          .asciz \"Les Cluses\"\nszAlbere:          .asciz \"L'Alb\u00e8re\"\nszPerthus:         .asciz \"Le Perthus\"\n.align 4\n\nTableCities:               \n                 .int szCluses         @ address name string\n                 .int 251              @ number of habitants\n                 .int szCeret\n                 .int 7705\n                 .int szMaureillas\n                 .int 2596\n                 .int szBoulou \n                 .int 5554\n                 .int szSaintJean\n                 .int 2153\n                 .int szAlbere\n                 .int 83\n                 .int szVives\n                 .int 174\n                 .int szTaillet\n                 .int 115\n                 .int szPerthus\n                 .int 586\n                 .int szReynes\n                 .int 1354\n.equ NBELEMENTS,  (. - TableCities) / city_end\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:        .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                             @ entry of program \n \n    ldr r0,iAdrszMessSortHab                      \n    bl affichageMess\n\n    ldr r0,iAdrTableCities                        @ address city table\n    mov r1,#0                                     @ not use in routine\n    mov r2,#NBELEMENTS                            @ number of \u00e9lements \n    mov r3,#city_habitants                        @ sort by number habitants\n    mov r4,#'N'                                   @ Alphanumeric\n    bl shellSort\n    ldr r0,iAdrTableCities                        @ address number table\n    bl displayTable\n    \n    ldr r0,iAdrszMessSortName                      \n    bl affichageMess\n \n    ldr r0,iAdrTableCities                        @ address city table\n    mov r1,#0                                     @ not use in routine\n    mov r2,#NBELEMENTS                            @ number of \u00e9lements \n    mov r3,#city_name                             @ sort by name\n    mov r4,#'A'                                   @ Alphanumeric\n    bl shellSort\n    ldr r0,iAdrTableCities                        @ address number table\n    bl displayTable\n\n100:                                              @ standard end of the program \n    mov r0, #0                                    @ return code\n    mov r7, #EXIT                                 @ request to exit program\n    svc #0                                        @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrTableCities:          .int TableCities\niAdrszMessSortHab:        .int szMessSortHab\niAdrszMessSortName:       .int szMessSortName\n/***************************************************/\n/*   shell Sort                                    */\n/***************************************************/\n\n/* r0 contains the address of table */\n/* r1 contains the first element but not use\u00a0!!   */\n/*   this routine use first element at index zero\u00a0!!!  */\n/* r2 contains the number of element */\n/* r3 contains the offset of sort zone */\n/* r4 contains type of sort zone N = numeric A = alphanumeric */\nshellSort:\n    push {r0-r12,lr}             @ save registers\n    sub sp,#city_end             @ reserve area on stack\n    mov fp,sp                    @ frame pointer = stack\n    mov r8,r3                    @ save offser area sort\n    mov r9,r4                    @ save type sort\n    mov r7,#city_end             @ element size\n    //vidregtit debut\n    sub r12,r2,#1                @ index last item\n    mov r6,r12                   @ init gap = last item\n1:                               @ start loop 1\n    lsrs r6,#1                   @ gap = gap / 2\n    beq 100f                     @ if gap = 0 -> end\n    mov r3,r6                    @ init loop indice 1 \n2:                               @ start loop 2\n    mul r1,r3,r7                 @ offset \u00e9lement\n    mov r2,fp                    @ save on stack\n    bl saveElement \n    add r1,r8                    @ + offset sort zone\n    ldr r4,[r0,r1]               @ load first value\n    mov r5,r3                    @ init loop indice 2\n3:                               @ start loop 3\n    cmp r5,r6                    @ indice < gap\n    blt 8f                       @ yes -> end loop 2\n    sub r10,r5,r6                @ index = indice - gap\n    mul r1,r10,r7                @ offset \u00e9lement\n    add r10,r1,r8                @ + offset sort zone\n    ldr r2,[r0,r10]              @ load second value\n    push {r3,r5}                 @ save registrars because not enought register\n    cmp r9,#'A'                  @ sort area alapha\u00a0?\n    beq 4f                       @ yes\n    cmp r4,r2                    @  else compare numeric values\n    bge 7f                       @ highter\n    b 6f                         @ lower\n4:                               @ compare area alphanumeric\n    mov r10,#0                   @ counter\n5:\n    ldrb r3,[r4,r10]             @ byte string 1\n    ldrb r5,[r2,r10]             @ byte string 2\n    cmp r3,r5\n    bgt 7f                     \n    blt 6f\n\n    cmp r3,#0                    @  end string 1\n    beq 7f                       @ ens comparaison\n    add r10,r10,#1               @ else add 1 in counter\n    b 5b                         @ and loop\n     \n6:\n    pop {r3,r5}                  @ restaur registers\n    mul r2,r5,r7                 @ offset \u00e9lement\n    bl copyElement               @ copy element r1 to element r2\n    sub r5,r6                    @ indice = indice - gap\n    b 3b                         @ and loop\n7:\n    pop {r3,r5}\n8:                               @ end loop 3\n    mul r1,r5,r7                 @ offset destination \u00e9lement \n    mov r2,fp                    @ restaur element in table\n    bl restaurElement \n    add r3,#1                    @ increment indice 1\n    cmp r3,r12                   @ end\u00a0?\n    ble 2b                       @ no -> loop 2\n    b 1b                         @ yes loop for new gap\n \n100:                             @ end function\n    add sp,#city_end \n    pop {r0-r12,lr}              @ restaur registers\n    bx lr                        @ return \n/******************************************************************/\n/*      copy table element                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 offset origin element */\n/* r2 offset destination element */\ncopyElement:\n    push {r0-r4,lr}                                    @ save registers\n    //vidregtit copy\n    mov r3,#0\n    add r1,r0\n    add r2,r0\n1:\n    ldrb r4,[r1,r3]\n    strb r4,[r2,r3]\n    add r3,#1\n    cmp r3,#city_end\n    blt 1b\n100:\n    pop {r0-r4,lr}\n    bx lr\n/******************************************************************/\n/*      save element                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 offset origin element */\n/* r2 address destination  */\nsaveElement:\n    push {r0-r4,lr}                                    @ save registers\n    mov r3,#0\n    add r1,r0\n1:\n    ldrb r4,[r1,r3]\n    strb r4,[r2,r3]\n    add r3,#1\n    cmp r3,#city_end\n    blt 1b\n100:\n    pop {r0-r4,lr}\n    bx lr\n/******************************************************************/\n/*      restaur element                                */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 offset destination element */\n/* r2 address origine  */\nrestaurElement:\n    push {r0-r4,lr}                                    @ save registers\n    mov r3,#0\n    add r1,r0\n1:\n    ldrb r4,[r2,r3]\n    strb r4,[r1,r3]\n    add r3,#1\n    cmp r3,#city_end\n    blt 1b\n100:\n    pop {r0-r4,lr}\n    bx lr\n/******************************************************************/\n/*      Display table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\ndisplayTable:\n    push {r0-r6,lr}              @ save registers\n    mov r2,r0                    @ table address\n    mov r3,#0\n    mov r6,#city_end\n1:                               @ loop display table\n    mul r4,r3,r6\n    add r4,#city_name\n    ldr r1,[r2,r4]\n    ldr r0,iAdrsMessResult\n    bl strInsertAtCharInc        @ put name in message\n    mov r5,r0                    @ save address of new message\n    mul r4,r3,r6\n    add r4,#city_habitants       @ and load value\n    ldr r0,[r2,r4]\n    ldr r1,iAdrsZoneConv\n    bl conversion10              @ call decimal conversion\n    mov r0,r5\n    ldr r1,iAdrsZoneConv         @ insert conversion in message\n    bl strInsertAtCharInc\n    bl affichageMess             @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 1b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n100:\n    pop {r0-r6,lr}\n    bx lr\niAdrsZoneConv:      .int sZoneConv\n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nSort table for number of habitants\u00a0:\nName\u00a0: L'Alb\u00e8re  number habitants\u00a0: 83\nName\u00a0: Taillet  number habitants\u00a0: 115\nName\u00a0: Viv\u00e9s  number habitants\u00a0: 174\nName\u00a0: Les Cluses  number habitants\u00a0: 251\nName\u00a0: Le Perthus  number habitants\u00a0: 586\nName\u00a0: Reynes  number habitants\u00a0: 1354\nName\u00a0: Saint Jean Pla de Corts  number habitants\u00a0: 2153\nName\u00a0: Maureillas  number habitants\u00a0: 2596\nName\u00a0: Le Boulou  number habitants\u00a0: 5554\nName\u00a0: Ceret  number habitants\u00a0: 7705\n\nSort table for name of city\u00a0:\nName\u00a0: Ceret  number habitants\u00a0: 7705\nName\u00a0: L'Alb\u00e8re  number habitants\u00a0: 83\nName\u00a0: Le Boulou  number habitants\u00a0: 5554\nName\u00a0: Le Perthus  number habitants\u00a0: 586\nName\u00a0: Les Cluses  number habitants\u00a0: 251\nName\u00a0: Maureillas  number habitants\u00a0: 2596\nName\u00a0: Reynes  number habitants\u00a0: 1354\nName\u00a0: Saint Jean Pla de Corts  number habitants\u00a0: 2153\nName\u00a0: Taillet  number habitants\u00a0: 115\nName\u00a0: Viv\u00e9s  number habitants\u00a0: 174\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Delphi", "code": "\nprogram SortCompositeStructures;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, Generics.Collections, Generics.Defaults;\n\ntype\n  TStructurePair = record\n    name: string;\n    value: string;\n    constructor Create(const aName, aValue: string);\n  end;\n\nconstructor TStructurePair.Create(const aName, aValue: string);\nbegin\n  name := aName;\n  value := aValue;\nend;\n\nvar\n  lArray: array of TStructurePair;\nbegin\n  SetLength(lArray, 3);\n  lArray[0] := TStructurePair.Create('dog', 'rex');\n  lArray[1] := TStructurePair.Create('cat', 'simba');\n  lArray[2] := TStructurePair.Create('horse', 'trigger');\n\n  TArray.Sort<TStructurePair>(lArray , TDelegatedComparer<TStructurePair>.Construct(\n  function(const Left, Right: TStructurePair): Integer\n  begin\n    Result := CompareText(Left.Name, Right.Name);\n  end));\nend.\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Ruby", "code": "\nPerson = Struct.new(:name,:value) do\n  def to_s; \"name:#{name}, value:#{value}\" end\nend\n\nlist = [Person.new(\"Joe\",3),\n        Person.new(\"Bill\",4),\n        Person.new(\"Alice\",20),\n        Person.new(\"Harry\",3)]\nputs list.sort_by{|x|x.name}\nputs\nputs list.sort_by(&:value)\n\n\nOutput:\nname:Alice, value:20\nname:Bill, value:4\nname:Harry, value:3\nname:Joe, value:3\n\nname:Joe, value:3\nname:Harry, value:3\nname:Bill, value:4\nname:Alice, value:20\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Rust", "code": "\nTranslation of: Kotlin\nuse std::cmp::Ordering;\n\n#[derive(Debug)]\nstruct Employee {\n    name: String,\n    category: String,\n}\n\nimpl Employee {\n    fn new(name: &str, category: &str) -> Self {\n        Employee {\n            name: name.into(),\n            category: category.into(),\n        }\n    }\n}\n\nimpl PartialEq for Employee {\n    fn eq(&self, other: &Self) -> bool {\n        self.name == other.name\n    }\n}\n\nimpl Eq for Employee {}\n\nimpl PartialOrd for Employee {\n    fn partial_cmp(&self, other: &Self) -> Option<Ordering> {\n        Some(self.cmp(other))\n    }\n}\n\nimpl Ord for Employee {\n    fn cmp(&self, other: &Self) -> Ordering {\n        self.name.cmp(&other.name)\n    }\n}\n\nfn main() {\n    let mut employees = vec![\n        Employee::new(\"David\", \"Manager\"),\n        Employee::new(\"Alice\", \"Sales\"),\n        Employee::new(\"Joanna\", \"Director\"),\n        Employee::new(\"Henry\", \"Admin\"),\n        Employee::new(\"Tim\", \"Sales\"),\n        Employee::new(\"Juan\", \"Admin\"),\n    ];\n    employees.sort();\n    for e in employees {\n        println!(\"{:<6}\u00a0: {}\", e.name, e.category);\n    }\n}\n\n\nOutput:\nAlice \u00a0: Sales\nDavid \u00a0: Manager\nHenry \u00a0: Admin\nJoanna\u00a0: Director\nJuan  \u00a0: Admin\nTim   \u00a0: Sales\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Swift", "code": "\nextension Sequence {\n  func sorted<Value>(\n    on: KeyPath<Element, Value>,\n    using: (Value, Value) -> Bool\n  ) -> [Element] where Value: Comparable {\n    return withoutActuallyEscaping(using, do: {using -> [Element] in\n      return self.sorted(by: { using($0[keyPath: on], $1[keyPath: on]) })\n    })\n  }\n}\n\nstruct Person {\n  var name: String\n  var role: String\n}\n\nlet a = Person(name: \"alice\", role: \"manager\")\nlet b = Person(name: \"bob\", role: \"worker\")\nlet c = Person(name: \"charlie\", role: \"driver\")\n\nprint([c, b, a].sorted(on: \\.name, using: <))\n\n\nOutput:\n[Runner.Person(name: \"alice\", role: \"manager\"), Runner.Person(name: \"bob\", role: \"worker\"), Runner.Person(name: \"charlie\", role: \"driver\")]\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "R", "code": "\n\nsortbyname <- function(x, ...) x[order(names(x), ...)]\nx <- c(texas=68.9, ohio=87.8, california=76.2, \"new york\"=88.2)\nsortbyname(x)\n\ncalifornia   new york       ohio      texas \n      76.2       88.2       87.8       68.9 \n\nsortbyname(x, decreasing=TRUE)\n\n     texas       ohio   new york california \n      68.9       87.8       88.2       76.2\n\n", "explain": "In R, vectors can have names associated with any of its elements.  The data is taken from the Common Lisp example.\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Ada", "code": "\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;           use Ada.Text_IO;\n\nwith Ada.Containers.Generic_Array_Sort;\n\nprocedure Demo_Array_Sort is\n\n   function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n\n   type A_Composite is\n      record\n         Name  : Unbounded_String;\n         Value : Unbounded_String;\n      end record;\n\n   function \"<\" (L, R : A_Composite) return Boolean is\n   begin\n      return L.Name < R.Name;\n   end \"<\";\n\n   procedure Put_Line (C : A_Composite) is\n   begin\n      Put_Line (To_String (C.Name) & \" \" & To_String (C.Value));\n   end Put_Line;\n\n   type An_Array is array (Natural range <>) of A_Composite;\n\n   procedure Sort is new Ada.Containers.Generic_Array_Sort (Natural, A_Composite, An_Array);\n\n   Data : An_Array := (1 => (Name => +\"Joe\",    Value => +\"5531\"),\n                       2 => (Name => +\"Adam\",   Value => +\"2341\"),\n                       3 => (Name => +\"Bernie\", Value => +\"122\"),\n                       4 => (Name => +\"Walter\", Value => +\"1234\"),\n                       5 => (Name => +\"David\",  Value => +\"19\"));\n\nbegin\n   Sort (Data);\n   for I in Data'Range loop\n      Put_Line (Data (I));\n   end loop;\nend Demo_Array_Sort;\n\n\n  C:\\Ada\\sort_composites\\lib\\demo_array_sort\n  Adam 2341\n  Bernie 122\n  David 19\n  Joe 5531\n  Walter 1234\n\n\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\nwith Ada.Text_IO;           use Ada.Text_IO;\n\nwith Ada.Containers.Ordered_Sets;\n\nprocedure Sort_Composites is\n\n   function \"+\" (S : String) return Unbounded_String renames To_Unbounded_String;\n\n   type A_Composite is\n      record\n         Name  : Unbounded_String;\n         Value : Unbounded_String;\n      end record;\n\n   function \"<\" (L, R : A_Composite) return Boolean is\n   begin\n      return L.Name < R.Name;\n   end \"<\";\n\n   procedure Put_Line (C : A_Composite) is\n   begin\n      Put_Line (To_String (C.Name) & \" \" & To_String (C.Value));\n   end Put_Line;\n\n   package Composite_Sets is new Ada.Containers.Ordered_Sets (A_Composite);\n\n   procedure Put_Line (C : Composite_Sets.Cursor) is\n   begin\n      Put_Line (Composite_Sets.Element (C));\n   end Put_Line;\n\n   Data : Composite_Sets.Set;\n\nbegin\n   Data.Insert (New_Item => (Name => +\"Joe\",    Value => +\"5531\"));\n   Data.Insert (New_Item => (Name => +\"Adam\",   Value => +\"2341\"));\n   Data.Insert (New_Item => (Name => +\"Bernie\", Value => +\"122\"));\n   Data.Insert (New_Item => (Name => +\"Walter\", Value => +\"1234\"));\n   Data.Insert (New_Item => (Name => +\"David\",  Value => +\"19\"));\n   Data.Iterate (Put_Line'Access);\nend Sort_Composites;\n\n\n  C:\\Ada\\sort_composites\\lib\\sort_composites\n  Adam 2341\n  Bernie 122\n  David 19\n  Joe 5531\n  Walter 1234\n\n\nwith Ada.Text_Io;\nwith Ada.Strings.Unbounded; use Ada.Strings.Unbounded;\n\nprocedure Sort_Composite is\n   type Composite_Record is record\n      Name : Unbounded_String;\n      Value : Unbounded_String;\n   end record;\n   \n   type Pairs_Array is array(Positive range <>) of Composite_Record;\n   \n   procedure Swap(Left, Right : in out Composite_Record) is\n      Temp : Composite_Record := Left;\n   begin\n      Left := Right;\n      Right := Temp;\n   end Swap; \n   \n   -- Sort_Names uses a bubble sort\n   \n   procedure Sort_Name(Pairs : in out Pairs_Array) is\n      Swap_Performed : Boolean := True;\n   begin\n      while Swap_Performed loop\n         Swap_Performed := False;\n         for I in Pairs'First..(Pairs'Last - 1) loop\n            if Pairs(I).Name > Pairs(I + 1).Name then\n               Swap (Pairs(I), Pairs(I + 1));\n               Swap_Performed := True;\n            end if;\n         end loop;\n      end loop;\n   end Sort_Name;\n   \n   procedure Print(Item : Pairs_Array) is\n   begin\n      for I in Item'range loop\n         Ada.Text_Io.Put_Line(To_String(Item(I).Name) & \", \" & \n            to_String(Item(I).Value));\n      end loop;\n   end Print;\n   type Names is (Fred, Barney, Wilma, Betty, Pebbles);\n   type Values is (Home, Work, Cook, Eat, Bowl);\n   My_Pairs : Pairs_Array(1..5);\nbegin\n   for I in My_Pairs'range loop\n      My_Pairs(I).Name := To_Unbounded_String(Names'Image(Names'Val(Integer(I - 1))));\n      My_Pairs(I).Value := To_Unbounded_String(Values'Image(Values'Val(Integer(I - 1))));\n   end loop;\n   Print(My_Pairs);\n   Ada.Text_Io.Put_Line(\"=========================\");\n   Sort_Name(My_Pairs);\n   Print(My_Pairs);\nend Sort_Composite;\n\n", "explain": "Ada 2005 defines 2 standard subprograms for sorting arrays - 1 for constrained arrays and 1 for unconstrained arrays. Below is a example of using the unconstrained version.\nResult:\nAda 2005 also provides ordered containers, so no explicit call is required. Here is an example of an ordered set:\nResult:\nThere is no standard sort function for Ada 95. The example below implements a simple bubble sort.\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nlst = Pair[Pair(\"gold\", \"shiny\"),\n           Pair(\"neon\", \"inert\"),\n           Pair(\"sulphur\", \"yellow\"),\n           Pair(\"iron\", \"magnetic\"),\n           Pair(\"zebra\", \"striped\"),\n           Pair(\"star\", \"brilliant\"),\n           Pair(\"apple\", \"tasty\"),\n           Pair(\"ruby\", \"red\"),\n           Pair(\"dice\", \"random\"),\n           Pair(\"coffee\", \"stimulating\"),\n           Pair(\"book\", \"interesting\")]\n\nprintln(\"The original list: \\n - \", join(lst, \"\\n - \"))\nsort!(lst; by=first)\nprintln(\"\\nThe list, sorted by name: \\n - \", join(lst, \"\\n - \"))\nsort!(lst; by=last)\nprintln(\"\\nThe list, sorted by value: \\n - \", join(lst, \"\\n - \"))\n\n\nOutput:\nThe original list: \n - \"gold\"=>\"shiny\"\n - \"neon\"=>\"inert\"\n - \"sulphur\"=>\"yellow\"\n - \"iron\"=>\"magnetic\"\n - \"zebra\"=>\"striped\"\n - \"star\"=>\"brilliant\"\n - \"apple\"=>\"tasty\"\n - \"ruby\"=>\"red\"\n - \"dice\"=>\"random\"\n - \"coffee\"=>\"stimulating\"\n - \"book\"=>\"interesting\"\n\nThe list, sorted by name: \n - \"apple\"=>\"tasty\"\n - \"book\"=>\"interesting\"\n - \"coffee\"=>\"stimulating\"\n - \"dice\"=>\"random\"\n - \"gold\"=>\"shiny\"\n - \"iron\"=>\"magnetic\"\n - \"neon\"=>\"inert\"\n - \"ruby\"=>\"red\"\n - \"star\"=>\"brilliant\"\n - \"sulphur\"=>\"yellow\"\n - \"zebra\"=>\"striped\"\n\nThe list, sorted by value: \n - \"star\"=>\"brilliant\"\n - \"neon\"=>\"inert\"\n - \"book\"=>\"interesting\"\n - \"iron\"=>\"magnetic\"\n - \"dice\"=>\"random\"\n - \"ruby\"=>\"red\"\n - \"gold\"=>\"shiny\"\n - \"coffee\"=>\"stimulating\"\n - \"zebra\"=>\"striped\"\n - \"apple\"=>\"tasty\"\n - \"sulphur\"=>\"yellow\"\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Kotlin", "code": "\n// version 1.1\n\ndata class Employee(val name: String, var category: String) : Comparable<Employee> {\n    override fun compareTo(other: Employee) = this.name.compareTo(other.name)\n}\n\nfun main(args: Array<String>) {\n    val employees = arrayOf(\n        Employee(\"David\", \"Manager\"),\n        Employee(\"Alice\", \"Sales\"),\n        Employee(\"Joanna\", \"Director\"),\n        Employee(\"Henry\", \"Admin\"),\n        Employee(\"Tim\", \"Sales\"),\n        Employee(\"Juan\", \"Admin\")\n    )\n    employees.sort()\n    for ((name, category) in employees) println(\"${name.padEnd(6)}\u00a0: $category\")\n}\n\n\nOutput:\nAlice \u00a0: Sales\nDavid \u00a0: Manager\nHenry \u00a0: Admin\nJoanna\u00a0: Director\nJuan  \u00a0: Admin\nTim   \u00a0: Sales\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Perl", "code": "\n\n@people = (['joe', 120], ['foo', 31], ['bar', 51]);\n@people = sort { $a->[0] cmp $b->[0] } @people;\n\n\n@people = (['joe', 120], ['foo', 31], ['bar', 51]);\n@people = sort { $a->[1] <=> $b->[1] } @people;\n\n", "explain": "Sort by name using cmp to compare strings:\nSort by number using <=> to compare numbers:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Objective-C", "code": "\n@interface Pair\u00a0: NSObject {\n    NSString *name;\n    NSString *value;\n}\n+(instancetype)pairWithName:(NSString *)n value:(NSString *)v;\n-(instancetype)initWithName:(NSString *)n value:(NSString *)v;\n-(NSString *)name;\n-(NSString *)value;\n@end\n\n@implementation Pair\n+(instancetype)pairWithName:(NSString *)n value:(NSString *)v {\n    return [[self alloc] initWithName:n value:v];\n}\n-(instancetype)initWithName:(NSString *)n value:(NSString *)v {\n    if ((self = [super init])) {\n        name = n;\n        value = v;\n    }\n    return self;\n}\n-(NSString *)name { return name; }\n-(NSString *)value { return value; }\n-(NSString *)description {\n    return [NSString stringWithFormat:@\"<\u00a0%@ ->\u00a0%@ >\", name, value];\n}\n@end\n\nint main() {\n    @autoreleasepool {\n\n        NSArray *pairs = @[\n                       [Pair pairWithName:@\"06-07\" value:@\"Ducks\"],\n                       [Pair pairWithName:@\"00-01\" value:@\"Avalanche\"],\n                       [Pair pairWithName:@\"02-03\" value:@\"Devils\"],\n                       [Pair pairWithName:@\"01-02\" value:@\"Red Wings\"],\n                       [Pair pairWithName:@\"03-04\" value:@\"Lightning\"],\n                       [Pair pairWithName:@\"04-05\" value:@\"lockout\"],\n                       [Pair pairWithName:@\"05-06\" value:@\"Hurricanes\"],\n                       [Pair pairWithName:@\"99-00\" value:@\"Devils\"],\n                       [Pair pairWithName:@\"07-08\" value:@\"Red Wings\"],\n                       [Pair pairWithName:@\"08-09\" value:@\"Penguins\"]];\n\n        // optional 3rd arg: you can also specify a selector to compare the keys\n        NSSortDescriptor *sd = [[NSSortDescriptor alloc] initWithKey:@\"name\" ascending:YES];\n\n        // it takes an array of sort descriptors, and it will be ordered by the\n        // first one, then if it's a tie by the second one, etc.\n        NSArray *sorted = [pairs sortedArrayUsingDescriptors:@[sd]];\n        NSLog(@\"%@\", sorted);\n\n    }\n\n    return 0;\n}\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Lua", "code": "\nfunction sorting( a, b ) \n    return a[1] < b[1] \nend\n \ntab = { {\"C++\", 1979}, {\"Ada\", 1983}, {\"Ruby\", 1995}, {\"Eiffel\", 1985} }\n\ntable.sort( tab, sorting )\nfor _, v in ipairs( tab ) do \n    print( unpack(v) ) \nend\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Scala", "code": "\ncase class Pair(name:String, value:Double)\nval input = Array(Pair(\"Krypton\", 83.798), Pair(\"Beryllium\", 9.012182), Pair(\"Silicon\", 28.0855))\ninput.sortBy(_.name) // Array(Pair(Beryllium,9.012182), Pair(Krypton,83.798), Pair(Silicon,28.0855))\n\n// alternative versions:\ninput.sortBy(struct => (struct.name, struct.value)) // additional sort field (name first, then value)\ninput.sortWith((a,b) => a.name.compareTo(b.name) < 0) // arbitrary comparison function\n\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "D", "code": "\nimport std.stdio, std.algorithm;\n\nstruct Pair { string name, value; }\n\nvoid main() {\n    Pair[] pairs = [{\"Joe\",    \"5531\"},\n                    {\"Adam\",   \"2341\"},\n                    {\"Bernie\",  \"122\"},\n                    {\"Walter\", \"1234\"},\n                    {\"David\",    \"19\"}];\n\n    pairs.schwartzSort!q{ a.name }.writeln;\n}\n\n\nOutput:\n[Pair(\"Adam\", \"2341\"), Pair(\"Bernie\", \"122\"), Pair(\"David\", \"19\"), Pair(\"Joe\", \"5531\"), Pair(\"Walter\", \"1234\")]\n", "explain": ""}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Haskell", "code": "\nimport Data.List\nimport Data.Function (on)\n\ndata Person =\n  P String\n    Int\n  deriving (Eq)\n\ninstance Show Person where\n  show (P name val) = \"Person \" ++ name ++ \" with value \" ++ show val\n\ninstance Ord Person where\n  compare (P a _) (P b _) = compare a b\n\npVal :: Person -> Int\npVal (P _ x) = x\n\npeople :: [Person]\npeople = [P \"Joe\" 12, P \"Bob\" 8, P \"Alice\" 9, P \"Harry\" 2]\n\n\nmain :: IO ()\nmain = do\n  mapM_ print $ sort people\n  putStrLn []\n  mapM_ print $ sortBy (on compare pVal) people\n\n\nOutput:\nPerson Alice with value 9\nPerson Bob with value 8\nPerson Harry with value 2\nPerson Joe with value 12\n\nPerson Harry with value 2\nPerson Bob with value 8\nPerson Alice with value 9\nPerson Joe with value 12\n\nimport Data.Ord (comparing)\nimport Data.List (sortBy)\n\nxs :: [(String, String, Int)]\nxs =\n  zip3\n    (words \"Richard John Marvin Alan Maurice James\")\n    (words \"Hamming McCarthy Minskey Perlis Wilkes Wilkinson\")\n    [1915, 1927, 1926, 1922, 1913, 1919]\n\nmain :: IO ()\nmain = mapM_ print $ sortBy (comparing (\\(_, _, y) -> y)) xs\n\n\nOutput:\n(\"Maurice\",\"Wilkes\",1913)\n(\"Richard\",\"Hamming\",1915)\n(\"James\",\"Wilkinson\",1919)\n(\"Alan\",\"Perlis\",1922)\n(\"Marvin\",\"Minskey\",1926)\n(\"John\",\"McCarthy\",1927)\n", "explain": "More generally, sortBy takes any (a -> a -> Ordering) function as its first argument. A function of this kind can be derived from a simpler (b -> a) function using the higher order comparing function.\nTo sort a list of triples by the third element, for example:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 4.0\n$list = @{\n\"def\" = \"one\"\n\"abc\" = \"two\"\n\"jkl\" = \"three\"\n\"abcdef\" = \"four\"\n\"ghi\" = \"five\"\n\"ghijkl\" = \"six\"\n }\n $list.GetEnumerator() | sort {-($PSItem.Name).length}, Name\n\n\nName                           Value                                                                               \n----                           -----                                                                               \nabcdef                         four                                                                                \nghijkl                         six                                                                                 \nabc                            two                                                                                 \ndef                            one                                                                                 \nghi                            five                                                                                \njkl                            three                                                                                  \n\n", "explain": "Output:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "F#", "code": "\n\nlet persons = [| (\"Joe\", 120); (\"foo\", 31); (\"bar\", 51) |]\nArray.sortInPlaceBy fst persons\nprintfn \"%A\" persons\n\n\n[|(\"Joe\", 120); (\"bar\", 51); (\"foo\", 31)|]\n\ntype Person = { name:string; id:int }\nlet persons2 = [{name=\"Joe\"; id=120}; {name=\"foo\"; id=31}; {name=\"bar\"; id=51}]\nlet sorted = List.sortBy (fun p -> p.id) persons2\nfor p in sorted do printfn \"%A\" p\n\n\n{name = \"foo\";\n id = 31;}\n{name = \"bar\";\n id = 51;}\n{name = \"Joe\";\n id = 120;}\n", "explain": "F# has sortBy functions that work on collection types for this purpose. An example using an array of pairs:\nOutput:\nAn example using a list of records:\nOutput:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "Groovy", "code": "\nclass Holiday {\n    def date\n    def name\n    Holiday(dateStr, name) { this.name = name; this.date = format.parse(dateStr) }\n    String toString() { \"${format.format date}: ${name}\" }\n    static format = new java.text.SimpleDateFormat(\"yyyy-MM-dd\")\n}\n\ndef holidays = [ new Holiday(\"2009-12-25\", \"Christmas Day\"),\n                 new Holiday(\"2009-04-22\", \"Earth Day\"),\n                 new Holiday(\"2009-09-07\", \"Labor Day\"),\n                 new Holiday(\"2009-07-04\", \"Independence Day\"),\n                 new Holiday(\"2009-10-31\", \"Halloween\"),\n                 new Holiday(\"2009-05-25\", \"Memorial Day\"),\n                 new Holiday(\"2009-03-14\", \"PI Day\"),\n                 new Holiday(\"2009-01-01\", \"New Year's Day\"),\n                 new Holiday(\"2009-12-31\", \"New Year's Eve\"),\n                 new Holiday(\"2009-11-26\", \"Thanksgiving\"),\n                 new Holiday(\"2009-02-14\", \"St. Valentine's Day\"),\n                 new Holiday(\"2009-03-17\", \"St. Patrick's Day\"),\n                 new Holiday(\"2009-01-19\", \"Martin Luther King Day\"),\n                 new Holiday(\"2009-02-16\", \"President's Day\") ]\n\nholidays.sort { x, y -> x.date <=> y.date }\nholidays.each { println it }\n\n\n2009-01-01: New Year's Day\n2009-01-19: Martin Luther King Day\n2009-02-14: St. Valentine's Day\n2009-02-16: President's Day\n2009-03-14: PI Day\n2009-03-17: St. Patrick's Day\n2009-04-22: Earth Day\n2009-05-25: Memorial Day\n2009-07-04: Independence Day\n2009-09-07: Labor Day\n2009-10-31: Halloween\n2009-11-26: Thanksgiving\n2009-12-25: Christmas Day\n2009-12-31: New Year's Eve\n", "explain": "Output:\n"}, {"task_name": "Sort an array of composite structures", "task_url": "https://rosettacode.org/wiki/Sort_an_array_of_composite_structures", "task_cat": "Sorting", "lang": "AWK", "code": "\n# syntax: GAWK -f SORT_AN_ARRAY_OF_COMPOSITE_STRUCTURES.AWK\nBEGIN {\n# AWK lacks structures but one can be simulated using an associative array.\n    arr[\"eight  8 \"]\n    arr[\"two    2 \"]\n    arr[\"five   5 \"]\n    arr[\"nine   9 \"]\n    arr[\"one    1 \"]\n    arr[\"three  3 \"]\n    arr[\"six    6 \"]\n    arr[\"seven  7 \"]\n    arr[\"four   4 \"]\n    arr[\"ten    10\"]\n    arr[\"zero   0 \"]\n    arr[\"twelve 12\"]\n    arr[\"minus2 -2\"]\n    show(1,7,\"@val_str_asc\",\"name\") # use name part of name-value pair\n    show(8,9,\"@val_num_asc\",\"value\") # use value part of name-value pair\n    exit(0)\n}\nfunction show(a,b,sequence,description,  i,x) {\n    PROCINFO[\"sorted_in\"] = \"@unsorted\"\n    for (i in arr) {\n      x = substr(i,a,b)\n      sub(/ +/,\"\",x)\n      arr[i] = x\n    }\n    PROCINFO[\"sorted_in\"] = sequence\n    printf(\"sorted by %s:\",description)\n    for (i in arr) {\n      printf(\" %s\",arr[i])\n    }\n    printf(\"\\n\")\n}\n\n\nOutput:\nsorted by name: eight five four minus2 nine one seven six ten three twelve two zero\nsorted by value: -2 0 1 2 3 4 5 6 7 8 9 10 12\n\n", "explain": ""}]