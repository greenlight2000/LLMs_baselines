[{"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Python", "code": "\nPython: POSIX[edit]\n\nimport smtplib\n\ndef sendemail(from_addr, to_addr_list, cc_addr_list,\n              subject, message,\n              login, password,\n              smtpserver='smtp.gmail.com:587'):\n    header  = 'From: %s\\n' % from_addr\n    header += 'To: %s\\n' % ','.join(to_addr_list)\n    header += 'Cc: %s\\n' % ','.join(cc_addr_list)\n    header += 'Subject: %s\\n\\n' % subject\n    message = header + message\n    \n    server = smtplib.SMTP(smtpserver)\n    server.starttls()\n    server.login(login,password)\n    problems = server.sendmail(from_addr, to_addr_list, message)\n    server.quit()\n    return problems\n\n\nsendemail(from_addr    = 'python@RC.net', \n          to_addr_list = ['RC@gmail.com'],\n          cc_addr_list = ['RC@xx.co.uk'], \n          subject      = 'Howdy', \n          message      = 'Howdy from a python function', \n          login        = 'pythonuser', \n          password     = 'XXXXX')\n\n\nSample Email received:\nMessage-ID: <4a4a1e78.0717d00a.1ba8.ffcfdbdd@xx.google.com>\nDate: Tue, 30 Jun 2009 22:04:56 -0700 (PDT)\nFrom: python@RC.net\nTo: RC@gmail.com\nCc: RC@xx.co.uk\nSubject: Howdy\n\nHowdy from a python function\n\nPython: Windows[edit]\n\nimport win32com.client\n\ndef sendmail(to, title, body):\n    olMailItem = 0\n    ol = win32com.client.Dispatch(\"Outlook.Application\")\n    msg = ol.CreateItem(olMailItem)\n    msg.To = to\n    msg.Subject = title\n    msg.Body = body\n    msg.Send()\n    ol.Quit()\n\nsendmail(\"somebody@somewhere\", \"Title\", \"Hello\")\n\n", "explain": "The function returns a dict of any addresses it could not forward to; \nother connection problems raise errors.\nTested on Windows, it should work on all POSIX platforms.\nExample use:\nUsing Outlook COM server with the Pywin32 library.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "C", "code": "\n\nLibrary: libcurl\n#include <curl/curl.h>\n#include <string.h>\n#include <stdio.h>\n\n#define from    \"<sender@duniya.com>\"\n#define to      \"<addressee@gmail.com>\"\n#define cc      \"<info@example.org>\"\n \nstatic const char *payload_text[] = {\n  \"Date: Mon, 13 Jun 2018 11:30:00 +0100\\r\\n\",\n  \"To: \" to \"\\r\\n\",\n  \"From: \" from \" (Example User)\\r\\n\",\n  \"Cc: \" cc \" (Another example User)\\r\\n\",\n  \"Message-ID: <ecd7db36-10ab-437a-9g3a-e652b9458efd@\"\n  \"rfcpedant.example.org>\\r\\n\",\n  \"Subject: Sanding mail via C\\r\\n\",\n  \"\\r\\n\",\n  \"This mail is being sent by a C program.\\r\\n\",\n  \"\\r\\n\",\n  \"It connects to the GMail SMTP server, by far, the most popular mail program of all.\\r\\n\",\n  \"Which is also probably written in C.\\r\\n\",\n  \"To C or not to C..............\\r\\n\",\n  \"That is the question.\\r\\n\",\n  NULL\n};\n \nstruct upload_status {\n  int lines_read;\n};\n \nstatic size_t payload_source(void *ptr, size_t size, size_t nmemb, void *userp)\n{\n  struct upload_status *upload_ctx = (struct upload_status *)userp;\n  const char *data;\n \n  if((size == 0) || (nmemb == 0) || ((size*nmemb) < 1)) {\n    return 0;\n  }\n \n  data = payload_text[upload_ctx->lines_read];\n \n  if(data) {\n    size_t len = strlen(data);\n    memcpy(ptr, data, len);\n    upload_ctx->lines_read++;\n \n    return len;\n  }\n \n  return 0;\n}\n \nint main(void)\n{\n  CURL *curl;\n  CURLcode res = CURLE_OK;\n  struct curl_slist *recipients = NULL;\n  struct upload_status upload_ctx;\n \n  upload_ctx.lines_read = 0;\n \n  curl = curl_easy_init();\n  if(curl) {\n\n    curl_easy_setopt(curl, CURLOPT_USERNAME, \"user\");\n    curl_easy_setopt(curl, CURLOPT_PASSWORD, \"secret\");\n\n    curl_easy_setopt(curl, CURLOPT_URL, \"smtp://smtp.gmail.com:465\");\n\n    curl_easy_setopt(curl, CURLOPT_USE_SSL, (long)CURLUSESSL_ALL);\n \n    curl_easy_setopt(curl, CURLOPT_CAINFO, \"/path/to/certificate.pem\");\n\n    curl_easy_setopt(curl, CURLOPT_MAIL_FROM, from);\n\n    recipients = curl_slist_append(recipients, to);\n    recipients = curl_slist_append(recipients, cc);\n    curl_easy_setopt(curl, CURLOPT_MAIL_RCPT, recipients);\n\n    curl_easy_setopt(curl, CURLOPT_READFUNCTION, payload_source);\n    curl_easy_setopt(curl, CURLOPT_READDATA, &upload_ctx);\n    curl_easy_setopt(curl, CURLOPT_UPLOAD, 1L);\n\n    curl_easy_setopt(curl, CURLOPT_VERBOSE, 1L);\n\n    res = curl_easy_perform(curl);\n\n    if(res != CURLE_OK)\n      fprintf(stderr, \"curl_easy_perform() failed: %s\\n\",curl_easy_strerror(res));\n\n    curl_slist_free_all(recipients);\n\n    curl_easy_cleanup(curl);\n  }\n \n  return (int)res;\n}\n\n", "explain": "Sends mail via the GMail SMTP server, requires libcurl\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "C++", "code": "\nLibrary: POCO\nWorks with: POCO version 1.3.6\n// on Ubuntu: sudo apt-get install libpoco-dev\n// or see http://pocoproject.org/\n// compile with: g++ -Wall -O3 send-mail-cxx.C -lPocoNet -lPocoFoundation\n\n#include <cstdlib>\n#include <iostream>\n#include <Poco/Net/SMTPClientSession.h>\n#include <Poco/Net/MailMessage.h>\n\nusing namespace Poco::Net;\n\nint main (int argc, char **argv)\n{\n  try\n    {\n      MailMessage msg;\n\n      msg.addRecipient (MailRecipient (MailRecipient::PRIMARY_RECIPIENT,\n                                       \"alice@example.com\",\n                                       \"Alice Moralis\"));\n      msg.addRecipient (MailRecipient (MailRecipient::CC_RECIPIENT,\n                                       \"pat@example.com\",\n                                       \"Patrick Kilpatrick\"));\n      msg.addRecipient (MailRecipient (MailRecipient::BCC_RECIPIENT,\n                                       \"mike@example.com\",\n                                       \"Michael Carmichael\"));\n\n      msg.setSender (\"Roy Kilroy <roy@example.com>\");\n\n      msg.setSubject (\"Rosetta Code\");\n      msg.setContent (\"Sending mail from C++ using POCO C++ Libraries\");\n\n      SMTPClientSession smtp (\"mail.example.com\"); // SMTP server name\n      smtp.login ();\n      smtp.sendMessage (msg);\n      smtp.close ();\n      std::cerr << \"Sent mail successfully!\" << std::endl;\n    }\n  catch (std::exception &e)\n    {\n      std::cerr << \"failed to send mail: \" << e.what() << std::endl;\n      return EXIT_FAILURE;\n    }\n\n  return EXIT_SUCCESS;\n}\n\n\nfailed to send mail: Host not found\n\n", "explain": "When run literally as above, should print:\nsince mail.example.com does not exist.  To get it to work, you'll need to fill in the name of an SMTP server (such as the one provided by your ISP), and you should adjust the addresses of the sender and the recipient(s).\nThis version does not do authentication.  However, the login() method can accept a username and password for authentication.  Also, newer versions of POCO provide SecureSMTPClientSession, for doing STARTTLS.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Java", "code": "\nimport java.util.Properties;\n\nimport javax.mail.MessagingException;\nimport javax.mail.Session;\nimport javax.mail.Transport;\nimport javax.mail.Message.RecipientType;\nimport javax.mail.internet.InternetAddress;\nimport javax.mail.internet.MimeMessage;\n\n/**\n * Mail\n */\npublic class Mail\n{\n /**\n  * Session\n  */\n protected Session session;\n\n /**\n  * Mail constructor.\n  * \n  * @param host Host\n  */\n public Mail(String host)\n {\n  Properties properties = new Properties();\n  properties.put(\"mail.smtp.host\", host);\n  session = Session.getDefaultInstance(properties);\n }\n\n /**\n  * Send email message.\n  *\n  * @param from From\n  * @param tos Recipients\n  * @param ccs CC Recipients\n  * @param subject Subject\n  * @param text Text\n  * @throws MessagingException\n  */\n public void send(String from, String tos[], String ccs[], String subject,\n        String text)\n        throws MessagingException\n {\n  MimeMessage message = new MimeMessage(session);\n  message.setFrom(new InternetAddress(from));\n  for (String to : tos)\n   message.addRecipient(RecipientType.TO, new InternetAddress(to));\n  for (String cc : ccs)\n   message.addRecipient(RecipientType.TO, new InternetAddress(cc));\n  message.setSubject(subject);\n  message.setText(text);\n  Transport.send(message);\n }\n}\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "C#", "code": "\nWorks with: Mono version 1.2\nWorks with: Visual C# version 2003\nstatic void Main(string[] args)\n{\n    //First of all construct the SMTP client\n\n    SmtpClient SMTP = new SmtpClient(\"smtp.gmail.com\", 587); //I have provided the URI and port for GMail, replace with your providers SMTP details\n    SMTP.EnableSsl = true; //Required for gmail, may not for your provider, if your provider does not require it then use false.\n    SMTP.DeliveryMethod = SmtpDeliveryMethod.Network;\n    SMTP.Credentials = new NetworkCredential(\"YourUserName\", \"YourPassword\");\n    MailMessage Mail = new MailMessage(\"yourEmail@address.com\", \"theirEmail@address.com\");\n\n\n    //Then we construct the message\n\n    Mail.Subject = \"Important Message\";\n    Mail.Body = \"Hello over there\"; //The body contains the string for your email\n    //using \"Mail.IsBodyHtml = true;\" you can put an HTML page in your message body\n\n    //Then we use the SMTP client to send the message\n\n    SMTP.Send(Mail);\n\n    Console.WriteLine(\"Message Sent\");\n}\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "PHP", "code": "\nmail('hello@world.net', 'My Subject', \"A Message!\", \"From: my@address.com\");\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Fortran", "code": "\nIntel Fortran on Windows[edit]\n\nprogram sendmail\n    use ifcom\n    use msoutl\n    implicit none\n    integer(4) :: app, status, msg\n    \n    call cominitialize(status)\n    call comcreateobject(\"Outlook.Application\", app, status)\n    msg = $Application_CreateItem(app, olMailItem, status)\n    call $MailItem_SetTo(msg, \"somebody@somewhere\", status)\n    call $MailItem_SetSubject(msg, \"Title\", status)\n    call $MailItem_SetBody(msg, \"Hello\", status)\n    call $MailItem_Send(msg, status)\n    call $Application_Quit(app, status)\n    call comuninitialize()\nend program\n\n", "explain": "Using Outlook COM server. Before compiling the program, it's necessary to use the Intel Fortran Module Wizard from the Visual Studio editor, to generate a Fortran module for the Microsoft Outlook Object Library. The following program has to be linked with this module (msoutl).\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Go", "code": "\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"bytes\"\n\t\"errors\"\n\t\"flag\"\n\t\"fmt\"\n\t\"io/ioutil\"\n\t\"net/smtp\"\n\t\"os\"\n\t\"strings\"\n)\n\ntype Message struct {\n\tFrom    string\n\tTo      []string\n\tCc      []string\n\tSubject string\n\tContent string\n}\n\nfunc (m Message) Bytes() (r []byte) {\n\tto := strings.Join(m.To, \",\")\n\tcc := strings.Join(m.Cc, \",\")\n\n\tr = append(r, []byte(\"From: \"+m.From+\"\\n\")...)\n\tr = append(r, []byte(\"To: \"+to+\"\\n\")...)\n\tr = append(r, []byte(\"Cc: \"+cc+\"\\n\")...)\n\tr = append(r, []byte(\"Subject: \"+m.Subject+\"\\n\\n\")...)\n\tr = append(r, []byte(m.Content)...)\n\n\treturn\n}\n\nfunc (m Message) Send(host string, port int, user, pass string) (err error) {\n\terr = check(host, user, pass)\n\tif err != nil {\n\t\treturn\n\t}\n\n\terr = smtp.SendMail(fmt.Sprintf(\"%v:%v\", host, port),\n\t\tsmtp.PlainAuth(\"\", user, pass, host),\n\t\tm.From,\n\t\tm.To,\n\t\tm.Bytes(),\n\t)\n\n\treturn\n}\n\nfunc check(host, user, pass string) error {\n\tif host == \"\" {\n\t\treturn errors.New(\"Bad host\")\n\t}\n\tif user == \"\" {\n\t\treturn errors.New(\"Bad username\")\n\t}\n\tif pass == \"\" {\n\t\treturn errors.New(\"Bad password\")\n\t}\n\n\treturn nil\n}\n\nfunc main() {\n\tvar flags struct {\n\t\thost string\n\t\tport int\n\t\tuser string\n\t\tpass string\n\t}\n\tflag.StringVar(&flags.host, \"host\", \"\", \"SMTP server to connect to\")\n\tflag.IntVar(&flags.port, \"port\", 587, \"Port to connect to SMTP server on\")\n\tflag.StringVar(&flags.user, \"user\", \"\", \"Username to authenticate with\")\n\tflag.StringVar(&flags.pass, \"pass\", \"\", \"Password to authenticate with\")\n\tflag.Parse()\n\n\terr := check(flags.host, flags.user, flags.pass)\n\tif err != nil {\n\t\tflag.Usage()\n\t\tos.Exit(1)\n\t}\n\n\tbufin := bufio.NewReader(os.Stdin)\n\n\tfmt.Printf(\"From: \")\n\tfrom, err := bufin.ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tfrom = strings.Trim(from, \" \\t\\n\\r\")\n\n\tvar to []string\n\tfor {\n\t\tfmt.Printf(\"To (Blank to finish): \")\n\t\ttmp, err := bufin.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ttmp = strings.Trim(tmp, \" \\t\\n\\r\")\n\n\t\tif tmp == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\tto = append(to, tmp)\n\t}\n\n\tvar cc []string\n\tfor {\n\t\tfmt.Printf(\"Cc (Blank to finish): \")\n\t\ttmp, err := bufin.ReadString('\\n')\n\t\tif err != nil {\n\t\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\t\tos.Exit(1)\n\t\t}\n\t\ttmp = strings.Trim(tmp, \" \\t\\n\\r\")\n\n\t\tif tmp == \"\" {\n\t\t\tbreak\n\t\t}\n\n\t\tcc = append(cc, tmp)\n\t}\n\n\tfmt.Printf(\"Subject: \")\n\tsubject, err := bufin.ReadString('\\n')\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tsubject = strings.Trim(subject, \" \\t\\n\\r\")\n\n\tfmt.Printf(\"Content (Until EOF):\\n\")\n\tcontent, err := ioutil.ReadAll(os.Stdin)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\tcontent = bytes.Trim(content, \" \\t\\n\\r\")\n\n\tm := Message{\n\t\tFrom:    from,\n\t\tTo:      to,\n\t\tCc:      cc,\n\t\tSubject: subject,\n\t\tContent: string(content),\n\t}\n\n\tfmt.Printf(\"\\nSending message...\\n\")\n\terr = m.Send(flags.host, flags.port, flags.user, flags.pass)\n\tif err != nil {\n\t\tfmt.Printf(\"Error: %v\\n\", err)\n\t\tos.Exit(1)\n\t}\n\n\tfmt.Printf(\"Message sent.\\n\")\n}\n\n", "explain": "A full little command-line program that can be used to send simple e-mails. Uses the built-in smtp package.\nSupports TLS connections.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Delphi", "code": "\nprocedure SendEmail;\nvar\n  msg: TIdMessage;\n  smtp: TIdSMTP;\nbegin\n  smtp := TIdSMTP.Create;\n  try\n    smtp.Host := 'smtp.server.com';\n    smtp.Port := 587;\n    smtp.Username := 'login';\n    smtp.Password := 'password';\n    smtp.AuthType := satNone;\n    smtp.Connect;\n    msg := TIdMessage.Create(nil);\n    try\n      with msg.Recipients.Add do begin\n        Address := 'doug@gmail.com';\n        Name := 'Doug';\n      end;\n      with msg.Sender do begin\n        Address := 'fred@server.com';\n        Name := 'Fred';\n      end;\n      msg.Subject := 'subj';\n      msg.Body.Text := 'here goes email message';\n      smtp.Send(msg);\n    finally\n      msg.Free;\n    end;\n  finally\n    smtp.Free;\n  end;\nend;\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Ruby", "code": "\nUses the Library: RubyGems gems TMail which allows us to manipulate email objects conveniently, and mime-types which guesses a file's mime type based on its filename.\nrequire 'base64'\nrequire 'net/smtp'\nrequire 'tmail'\nrequire 'mime/types'\n\nclass Email\n  def initialize(from, to, subject, body, options={})\n    @opts = {:attachments => [], :server => 'localhost'}.update(options)\n    @msg = TMail::Mail.new\n    @msg.from    = from\n    @msg.to      = to\n    @msg.subject = subject\n    @msg.cc      = @opts[:cc]  if @opts[:cc]\n    @msg.bcc     = @opts[:bcc] if @opts[:bcc]\n\n    if @opts[:attachments].empty?\n      # just specify the body\n      @msg.body = body\n    else\n      # attach attachments, including the body\n      @msg.body = \"This is a multi-part message in MIME format.\\n\"\n\n      msg_body = TMail::Mail.new\n      msg_body.body = body\n      msg_body.set_content_type(\"text\",\"plain\", {:charset => \"ISO-8859-1\"})\n      @msg.parts << msg_body\n\n      octet_stream = MIME::Types['application/octet-stream'].first\n\n      @opts[:attachments].select {|file| File.readable?(file)}.each do |file|\n        mime_type = MIME::Types.type_for(file).first || octet_stream\n        @msg.parts << create_attachment(file, mime_type)\n      end\n    end\n  end\n  attr_reader :msg\n\n  def create_attachment(file, mime_type)\n    attach = TMail::Mail.new\n    if mime_type.binary?\n      attach.body = Base64.encode64(File.read(file))\n      attach.transfer_encoding = 'base64'\n    else\n      attach.body = File.read(file)\n    end\n    attach.set_disposition(\"attachment\", {:filename => file})\n    attach.set_content_type(mime_type.media_type, mime_type.sub_type, {:name=>file})\n    attach\n  end\n\n  # instance method to send an Email object\n  def send\n    args = @opts.values_at(:server, :port, :helo, :username, :password, :authtype)\n    Net::SMTP.start(*args) do |smtp|\n      smtp.send_message(@msg.to_s, @msg.from[0], @msg.to)\n    end\n  end\n\n  # class method to construct an Email object and send it\n  def self.send(*args)\n    self.new(*args).send\n  end\nend\n\nEmail.send(\n  'sender@sender.invalid',\n  %w{ recip1@recipient.invalid recip2@example.com },\n  'the subject',\n  \"the body\\nhas lines\",\n  {\n    :attachments => %w{ file1 file2 file3 },\n    :server => 'mail.example.com',\n    :helo => 'sender.invalid',\n    :username => 'user',\n    :password => 'secret'\n  }\n)\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "R", "code": "\n\nWindows[edit]\n\nlibrary(RDCOMClient)\n\nsend.mail <- function(to, title, body) {\n  olMailItem <- 0\n  ol <- COMCreate(\"Outlook.Application\")\n  msg <- ol$CreateItem(olMailItem)\n  msg[[\"To\"]] <- to\n  msg[[\"Subject\"]] <- title\n  msg[[\"Body\"]] <- body\n  msg$Send()\n  ol$Quit()\n}\n\nsend.mail(\"somebody@somewhere\", \"Title\", \"Hello\")\n\n", "explain": "R does not have a built-in facility for sending emails though there is a package for this on CRAN: mail.\nUsing Outlook COM server with the RDCOMClient package.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Ada", "code": "\nLibrary: AWS\nwith AWS.SMTP, AWS.SMTP.Client, AWS.SMTP.Authentication.Plain;\nwith Ada.Text_IO;\nuse  Ada, AWS;\n\nprocedure Sendmail is\n   Status : SMTP.Status;\n   Auth : aliased constant SMTP.Authentication.Plain.Credential :=\n      SMTP.Authentication.Plain.Initialize (\"id\", \"password\");\n   Isp : SMTP.Receiver;\nbegin\n   Isp :=\n      SMTP.Client.Initialize\n        (\"smtp.mail.com\",\n         Port       => 5025,\n         Credential => Auth'Unchecked_Access);\n   SMTP.Client.Send\n     (Isp,\n      From    => SMTP.E_Mail (\"Me\", \"me@some.org\"),\n      To      => SMTP.E_Mail (\"You\", \"you@any.org\"),\n      Subject => \"subject\",\n      Message => \"Here is the text\",\n      Status  => Status);\n   if not SMTP.Is_Ok (Status) then\n      Text_IO.Put_Line\n        (\"Can't send message\u00a0:\" & SMTP.Status_Message (Status));\n   end if;\nend Sendmail;\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Julia", "code": "\nusing SMTPClient\n\naddbrackets(s) = replace(s, r\"^\\s*([^\\<\\>]+)\\s*$\", s\"<\\1>\")\n\nfunction wrapRFC5322(from, to, subject, msg)\n    timestr = Libc.strftime(\"%a, %d %b %Y %H:%M:%S %z\", time())\n    IOBuffer(\"Date: $timestr\\nTo: $to\\nFrom: $from\\nSubject: $subject\\n\\n$msg\")\nend\n\nfunction sendemail(from, to, subject, messagebody, serverandport;\n                   cc=[], user=\"\", password=\"\", isSSL=true, blocking=true)\n    opt = SendOptions(blocking=blocking, isSSL=isSSL, username=user, passwd=password)\n    send(serverandport, map(s -> addbrackets(s), vcat(to, cc)), addbrackets(from),\n         wrapRFC5322(addbrackets(from), addbrackets(to), subject, messagebody), opt)\nend\n\nsendemail(\"to@example.com\", \"from@example.com\", \"TEST\", \"hello there test message text here\", \"smtps://smtp.gmail.com\",\n          user=\"from@example.com\", password=\"example.com\")\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "SAS", "code": "\nfilename msg email\n   to=\"afriend@someserver.com\"\n   cc=\"anotherfriend@somecompany.com\"\n   subject=\"Important message\"\n;\n\ndata _null_;\n   file msg;\n   put \"Hello, Connected World!\";\nrun;\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Kotlin", "code": "\n\n// version 1.1.4-3\n\nimport java.util.Properties\nimport javax.mail.Authenticator\nimport javax.mail.PasswordAuthentication\nimport javax.mail.Session\nimport javax.mail.internet.MimeMessage\nimport javax.mail.internet.InternetAddress\nimport javax.mail.Message.RecipientType\nimport javax.mail.Transport\n\nfun sendEmail(user: String, tos: Array<String>, ccs: Array<String>, title: String,\n              body: String, password: String) {\n    val props = Properties()\n    val host = \"smtp.gmail.com\"\n    with (props) {\n        put(\"mail.smtp.host\", host)\n        put(\"mail.smtp.port\", \"587\") // for TLS\n        put(\"mail.smtp.auth\", \"true\")\n        put(\"mail.smtp.starttls.enable\", \"true\")\n    }\n    val auth = object: Authenticator() {\n        protected override fun getPasswordAuthentication() =\n            PasswordAuthentication(user, password)\n    }\n    val session = Session.getInstance(props, auth)\n    val message = MimeMessage(session)\n    with (message) {\n        setFrom(InternetAddress(user))\n        for (to in tos) addRecipient(RecipientType.TO, InternetAddress(to))\n        for (cc in ccs) addRecipient(RecipientType.TO, InternetAddress(cc))\n        setSubject(title)\n        setText(body)\n    }\n    val transport = session.getTransport(\"smtp\")\n    with (transport) {\n        connect(host, user, password)\n        sendMessage(message, message.allRecipients)\n        close()\n    }\n}\n\nfun main(args: Array<String>) {\n    val user = \"some.user@gmail.com\"\n    val tos = arrayOf(\"other.user@otherserver.com\")\n    val ccs = arrayOf<String>()\n    val title = \"Rosetta Code Example\"\n    val body = \"This is just a test email\"\n    val password = \"secret\"\n    sendEmail(user, tos, ccs, title, body, password)\n}\n\n", "explain": "To compile and run this program 'javax.mail.jar' will need to be present on your system and added to your classpath. Also if you're using the Google SMTP Server then, as well as requiring a gmail account, you'll probably need to temporarily turn on 'access for less secure apps' to prevent it from being blocked.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Perl", "code": "\nUsing Net::SMTP[edit]\n\nuse Net::SMTP;\nuse Authen::SASL;\n  # Net::SMTP's 'auth' method needs Authen::SASL to work, but\n  # this is undocumented, and if you don't have the latter, the\n  # method will just silently fail. Hence we explicitly use\n  # Authen::SASL here.\n\nsub send_email {\n  my %o =\n     (from => '', to => [], cc => [],\n      subject => '', body => '',\n      host => '', user => '', password => '',\n      @_);\n  ref $o{$_} or $o{$_} = [$o{$_}] foreach 'to', 'cc';\n\n  my $smtp = Net::SMTP->new($o{host} ? $o{host} : ())\n      or die \"Couldn't connect to SMTP server\";\n\n  $o{password} and\n     $smtp->auth($o{user}, $o{password}) ||\n     die 'SMTP authentication failed';\n\n  $smtp->mail($o{user});\n  $smtp->recipient($_) foreach @{$o{to}}, @{$o{cc}};\n  $smtp->data;\n  $o{from} and $smtp->datasend(\"From: $o{from}\\n\");\n  $smtp->datasend('To: ' . join(', ', @{$o{to}}) . \"\\n\");\n  @{$o{cc}} and $smtp->datasend('Cc: ' . join(', ', @{$o{cc}}) . \"\\n\");\n  $o{subject} and $smtp->datasend(\"Subject: $o{subject}\\n\");\n  $smtp->datasend(\"\\n$o{body}\");\n  $smtp->dataend;\n\n  return 1;\n}\n\n\nsend_email\n   from => 'A. T. Tappman',\n   to => ['suchandsuch@example.com', 'soandso@example.org'],\n   cc => 'somebodyelse@example.net',\n   subject => 'Important message',\n   body => 'I yearn for you tragically.',\n   host => 'smtp.example.com:587',\n   user => 'tappman@example.com',\n   password => 'yossarian';\n\n\nsend_email\n   to => 'suchandsuch@example.com',\n   user => 'tappman@example.com';\n\nUsing LWP[edit]\n\nuse strict;\nuse LWP::UserAgent;\nuse HTTP::Request;\n\nsub send_email {\n  my ($from, $to, $cc, $subject, $text) = @_;\n\n  my $ua = LWP::UserAgent->new;\n  my $req = HTTP::Request->new (POST => \"mailto:$to\",\n                                [ From => $from,\n                                  Cc => $cc,\n                                  Subject => $subject ],\n                                $text);\n  my $resp = $ua->request($req);\n  if (! $resp->is_success) {\n    print $resp->status_line,\"\\n\";\n  }\n}\n\nsend_email('from-me@example.com', 'to-foo@example.com', '',\n           \"very important subject\",\n           \"Body text\\n\");\n\n", "explain": "This subroutine throws an appropriate error if it fails to connect to the server or authenticate. It should work on any platform Perl does.\nAn example call:\nIf the host parameter is omitted, send_email falls back on the SMTP_Hosts defined in Net::Config. Hence, only two arguments are strictly necessary:\nLWP can send email by a POST to a mailto: URL.  The message is given as a HTTP request.  This is mainly of interest for treating different types of URLs in a common way.  LWP sends merely by running the sendmail program, or on MacOS classic by SMTP (to SMTPHOSTS environment variable).  For reference, the $ua->post() method does not suit since it constructs a message as MIME \"form data\".\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Lua", "code": "\n\n-- load the smtp support\nlocal smtp = require(\"socket.smtp\")\n\n-- Connects to server \"localhost\" and sends a message to users\n-- \"fulano@example.com\",  \"beltrano@example.com\", \n-- and \"sicrano@example.com\".\n-- Note that \"fulano\" is the primary recipient, \"beltrano\" receives a\n-- carbon copy and neither of them knows that \"sicrano\" received a blind\n-- carbon copy of the message.\nfrom = \"<luasocket@example.com>\"\n\nrcpt = {\n  \"<fulano@example.com>\",\n  \"<beltrano@example.com>\",\n  \"<sicrano@example.com>\"\n}\n\nmesgt = {\n  headers = {\n    to = \"Fulano da Silva <fulano@example.com>\",\n    cc = '\"Beltrano F. Nunes\" <beltrano@example.com>',\n    subject = \"My first message\"\n  },\n  body = \"I hope this works. If it does, I can send you another 1000 copies.\"\n}\n\nr, e = smtp.send{\n  from = from,\n  rcpt = rcpt, \n  source = smtp.message(mesgt)\n}\n\n", "explain": "Using LuaSocket's SMTP module (from the documentation on that page):\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Scala", "code": "\nLibrary: Scala\nimport java.util.Properties\n\nimport javax.mail.internet.{ InternetAddress, MimeMessage }\nimport javax.mail.Message.RecipientType\nimport javax.mail.{ Session, Transport }\n\n/** Mail constructor.\n *  @constructor Mail\n *  @param host Host\n */\nclass Mail(host: String) {\n  val session = Session.getDefaultInstance(new Properties() { put(\"mail.smtp.host\", host) })\n\n  /** Send email message.\n   *\n   *  @param from From\n   *  @param tos Recipients\n   *  @param ccs CC Recipients\n   *  @param subject Subject\n   *  @param text Text\n   *  @throws MessagingException\n   */\n  def send(from: String, tos: List[String], ccs: List[String], subject: String, text: String) {\n    val message = new MimeMessage(session)\n    message.setFrom(new InternetAddress(from))\n    for (to <- tos)\n      message.addRecipient(RecipientType.TO, new InternetAddress(to))\n    for (cc <- ccs)\n      message.addRecipient(RecipientType.TO, new InternetAddress(cc))\n    message.setSubject(subject)\n    message.setText(text)\n    Transport.send(message)\n  }\n}\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "D", "code": "\n\nvoid main() {\n    import std.net.curl;\n\n    auto s = SMTP(\"smtps://smtp.gmail.com\");\n    s.setAuthentication(\"someuser@gmail.com\", \"somepassword\");\n    s.mailTo = [\"<friend@example.com>\"];\n    s.mailFrom = \"<someuser@gmail.com>\";\n    s.message = \"Subject:test\\n\\nExample Message\";\n    s.perform;\n}\n\n", "explain": "Requires the libcurl library to be installed on the system.\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Haskell", "code": "\n\n{-# LANGUAGE OverloadedStrings #-}\n\nmodule Main (main) where\n\nimport           Network.Mail.SMTP\n                    ( Address(..)\n                    , htmlPart\n                    , plainTextPart\n                    , sendMailWithLogin'\n                    , simpleMail\n                    )\n\nmain :: IO ()\nmain =\n    sendMailWithLogin' \"smtp.example.com\" 25 \"user\" \"password\" $\n        simpleMail\n            (Address (Just \"From Example\") \"from@example.com\")\n            [Address (Just \"To Example\") \"to@example.com\"]\n            [] -- CC\n            [] -- BCC\n            \"Subject\"\n            [ plainTextPart \"This is plain text.\"\n            , htmlPart \"<h1>Title</h1><p>This is HTML.</p>\"\n            ]\n\n", "explain": "Example using smtp-mail package:\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "VBScript", "code": "\nFunction send_mail(from,recipient,cc,subject,message)\n\tWith CreateObject(\"CDO.Message\")\n\t\t.From = from\n\t\t.To = recipient\n\t\t.CC = cc\n\t\t.Subject = subject\n\t\t.Textbody = message\n\t\t.Configuration.Fields.Item _\n\t\t\t(\"http://schemas.microsoft.com/cdo/configuration/sendusing\") = 2\n\t\t.Configuration.Fields.Item _\n\t\t\t(\"http://schemas.microsoft.com/cdo/configuration/smtpserver\") = _\n\t\t        \"mystmpserver\"\n\t\t.Configuration.Fields.Item _\n\t\t    (\"http://schemas.microsoft.com/cdo/configuration/smtpserverport\") = 25\n\t\t.Configuration.Fields.Update\n\t\t.Send\n\tEnd With\nEnd Function\n\nCall send_mail(\"Alerts@alerts.org\",\"jkspeed@jkspeed.org\",\"\",\"Test Email\",\"this is a test message\")\n\n", "explain": ""}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "PowerShell", "code": "\n\n[hashtable]$mailMessage = @{\n    From = \"weirdBoy@gmail.com\"\n    To = \"anudderBoy@YourDomain.com\"\n    Cc = \"daWaghBoss@YourDomain.com\"\n    Attachment = \"C:\\temp\\Waggghhhh!_plan.txt\"\n    Subject = \"Waggghhhh!\"\n    Body = \"Wagggghhhhhh!\"\n    SMTPServer = \"smtp.gmail.com\"\n    SMTPPort = \"587\"\n    UseSsl = $true\n    ErrorAction = \"SilentlyContinue\" \n}\n\nSend-MailMessage @mailMessage\n\n", "explain": "PowerShell has a cmdlet named 'Send-MailMessage', and this is the easiest way to use it.\nThe parameters are splatted with a hashtable:\n"}, {"task_name": "Send email", "task_url": "https://rosettacode.org/wiki/Send_email", "task_cat": "Networking and Web Interaction", "lang": "Groovy", "code": "\n\nimport javax.mail.*\nimport javax.mail.internet.*\n \npublic static void simpleMail(String from, String password, String to,\n    String subject, String body) throws Exception {\n \n    String host = \"smtp.gmail.com\";\n    Properties props = System.getProperties();\n    props.put(\"mail.smtp.starttls.enable\",true);\n    /* mail.smtp.ssl.trust is needed in script to avoid error \"Could not convert socket to TLS\"  */\n    props.setProperty(\"mail.smtp.ssl.trust\", host);\n    props.put(\"mail.smtp.auth\", true);      \n    props.put(\"mail.smtp.host\", host);\n    props.put(\"mail.smtp.user\", from);\n    props.put(\"mail.smtp.password\", password);\n    props.put(\"mail.smtp.port\", \"587\");\n \n    Session session = Session.getDefaultInstance(props, null);\n    MimeMessage message = new MimeMessage(session);\n    message.setFrom(new InternetAddress(from));\n \n    InternetAddress toAddress = new InternetAddress(to);\n \n    message.addRecipient(Message.RecipientType.TO, toAddress);\n \n    message.setSubject(subject);\n    message.setText(body);\n \n    Transport transport = session.getTransport(\"smtp\");\n \n    transport.connect(host, from, password);\n \n    transport.sendMessage(message, message.getAllRecipients());\n    transport.close();\n}\n \n/* Set email address sender */\nString s1 = \"example@gmail.com\";\n \n/* Set password sender */\nString s2 = \"\";\n \n/* Set email address sender */\nString s3 = \"example@gmail.com\"\n \n/*Call function */\nsimpleMail(s1, s2 , s3, \"TITLE\", \"TEXT\");\n\n", "explain": "From [1]  we can get email solution for Groovy\n"}]