[{"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Python", "code": "\nString.format() method[edit]\nWorks with: Python version 3.X and 2.6+\n>>> for i in range(16): print('{0:b}'.format(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\nBuilt-in bin() function[edit]\nWorks with: Python version 3.X and 2.6+\n>>> for i in range(16): print(bin(i)[2:])\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\n>>> oct2bin = {'0': '000', '1': '001', '2': '010', '3': '011', '4': '100', '5': '101', '6': '110', '7': '111'}\n>>> bin = lambda n: ''.join(oct2bin[octdigit] for octdigit in '%o'\u00a0% n).lstrip('0') or '0'\n>>> for i in range(16): print(bin(i))\n\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\nCustom functions[edit]\n\n'''Binary strings for integers'''\n\n\n# showBinary\u00a0:: Int -> String\ndef showBinary(n):\n    '''Binary string representation of an integer.'''\n    def binaryChar(n):\n        return '1' if n\u00a0!= 0 else '0'\n    return showIntAtBase(2)(binaryChar)(n)('')\n\n\n# TEST ----------------------------------------------------\n\n# main\u00a0:: IO()\ndef main():\n    '''Test'''\n\n    print('Mapping showBinary over integer list:')\n    print(unlines(map(\n        showBinary,\n        [5, 50, 9000]\n    )))\n\n    print(tabulated(\n        '\\nUsing showBinary as a display function:'\n    )(str)(showBinary)(\n        lambda x: x\n    )([5, 50, 9000]))\n\n\n# GENERIC -------------------------------------------------\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# showIntAtBase\u00a0:: Int -> (Int -> String) -> Int -> String -> String\ndef showIntAtBase(base):\n    '''String representing a non-negative integer\n       using the base specified by the first argument,\n       and the character representation specified by the second.\n       The final argument is a (possibly empty) string to which\n       the numeric string will be prepended.'''\n    def wrap(toChr, n, rs):\n        def go(nd, r):\n            n, d = nd\n            r_ = toChr(d) + r\n            return go(divmod(n, base), r_) if 0\u00a0!= n else r_\n        return 'unsupported base' if 1 >= base else (\n            'negative number' if 0 > n else (\n                go(divmod(n, base), rs))\n        )\n    return lambda toChr: lambda n: lambda rs: (\n        wrap(toChr, n, rs)\n    )\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n                f -> value list -> tabular string.'''\n    def go(xShow, fxShow, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + '\\n'.join(\n            xShow(x).rjust(w, ' ') + ' -> ' + fxShow(f(x)) for x in xs\n        )\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\nif __name__ == '__main__':\n    main()\n\nOutput:\nMapping showBinary over integer list:\n101\n110010\n10001100101000\n\nUsing showBinary as a display function:\n   5 -> 101\n  50 -> 110010\n9000 -> 10001100101000\n\n'''Decomposition of an integer to a string of booleans.'''\n\n\n# boolsFromInt\u00a0:: Int -> [Bool]\ndef boolsFromInt(n):\n    '''List of booleans derived by binary\n       decomposition of an integer.'''\n    def go(x):\n        (q, r) = divmod(x, 2)\n        return Just((q, bool(r))) if x else Nothing()\n    return unfoldl(go)(n)\n\n\n# stringFromBools\u00a0:: [Bool] -> String\ndef stringFromBools(xs):\n    '''Binary string representation of a\n       list of boolean values.'''\n    def oneOrZero(x):\n        return '1' if x else '0'\n    return ''.join(map(oneOrZero, xs))\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO()\ndef main():\n    '''Test'''\n\n    binary = compose(stringFromBools)(boolsFromInt)\n\n    print('Mapping a composed function:')\n    print(unlines(map(\n        binary,\n        [5, 50, 9000]\n    )))\n\n    print(\n        tabulated(\n            '\\n\\nTabulating a string display from binary data:'\n        )(str)(stringFromBools)(\n            boolsFromInt\n        )([5, 50, 9000])\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# Just\u00a0:: a -> Maybe a\ndef Just(x):\n    '''Constructor for an inhabited Maybe (option type) value.'''\n    return {'type': 'Maybe', 'Nothing': False, 'Just': x}\n\n\n# Nothing\u00a0:: Maybe a\ndef Nothing():\n    '''Constructor for an empty Maybe (option type) value.'''\n    return {'type': 'Maybe', 'Nothing': True}\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n                f -> value list -> tabular string.'''\n    def go(xShow, fxShow, f, xs):\n        w = max(map(compose(len)(xShow), xs))\n        return s + '\\n' + '\\n'.join(\n            xShow(x).rjust(w, ' ') + ' -> ' + fxShow(f(x)) for x in xs\n        )\n    return lambda xShow: lambda fxShow: lambda f: lambda xs: go(\n        xShow, fxShow, f, xs\n    )\n\n\n# unfoldl(lambda x: Just(((x - 1), x)) if 0\u00a0!= x else Nothing())(10)\n# -> [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n# unfoldl\u00a0:: (b -> Maybe (b, a)) -> b -> [a]\ndef unfoldl(f):\n    '''Dual to reduce or foldl.\n       Where these reduce a list to a summary value, unfoldl\n       builds a list from a seed value.\n       Where f returns Just(a, b), a is appended to the list,\n       and the residual b is used as the argument for the next\n       application of f.\n       When f returns Nothing, the completed list is returned.'''\n    def go(v):\n        xr = v, v\n        xs = []\n        while True:\n            mb = f(xr[0])\n            if mb.get('Nothing'):\n                return xs\n            else:\n                xr = mb.get('Just')\n                xs.insert(0, xr[1])\n        return xs\n    return lambda x: go(x)\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string derived by the intercalation\n       of a list of strings with the newline character.'''\n    return '\\n'.join(xs)\n\n\n# MAIN -------------------------------------------------\nif __name__ == '__main__':\n    main()\n\nOutput:\nMapping a composed function:\n101\n110010\n10001100101000\n\nTabulating a string display from binary data:\n   5 -> 101\n  50 -> 110010\n9000 -> 10001100101000\n", "explain": "Pre-Python 2.6:\nDefined in terms of a more general showIntAtBase function:\n\nOr, using a more specialised function to decompose an integer to a list of boolean values:\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "C", "code": "\nWith bit level operations[edit]\n#define _CRT_SECURE_NO_WARNINGS    // turn off panic warnings\n#define _CRT_NONSTDC_NO_DEPRECATE   // enable old-gold POSIX names in MSVS\n\n#include <stdio.h>\n#include <stdlib.h>\n\n\nchar* bin2str(unsigned value, char* buffer)\n{\n    // This algorithm is not the fastest one, but is relativelly simple.\n    //\n    // A faster algorithm would be conversion octets to strings by a lookup table.\n    // There is only 2**8 == 256 octets, therefore we would need only 2048 bytes\n    // for the lookup table. Conversion of a 64-bit integers would need 8 lookups\n    // instead 64 and/or/shifts of bits etc. Even more... lookups may be implemented\n    // with XLAT or similar CPU instruction... and AVX/SSE gives chance for SIMD.\n\n    const unsigned N_DIGITS = sizeof(unsigned) * 8;\n    unsigned mask = 1 << (N_DIGITS - 1);\n    char* ptr = buffer;\n\n    for (int i = 0; i < N_DIGITS; i++)\n    {\n        *ptr++ = '0' + !!(value & mask);\n        mask >>= 1;\n    }\n    *ptr = '\\0';\n\n    // Remove leading zeros.\n    //\n    for (ptr = buffer; *ptr == '0'; ptr++)\n        ;\n\n    return ptr;\n}\n\n\nchar* bin2strNaive(unsigned value, char* buffer)\n{\n    // This variation of the solution doesn't use bits shifting etc.\n\n    unsigned n, m, p;\n\n    n = 0;\n    p = 1;  // p = 2 ** n\n    while (p <= value / 2)\n    {\n        n = n + 1;\n        p = p * 2;\n    }\n\n    m = 0;\n    while (n > 0)\n    {\n        buffer[m] = '0' + value / p;\n        value = value % p;\n        m = m + 1;\n        n = n - 1;\n        p = p / 2;\n    }\n\n    buffer[m + 1] = '\\0';\n    return buffer;\n}\n\n\nint main(int argc, char* argv[])\n{\n    const unsigned NUMBERS[] = { 5, 50, 9000 };\n\n    const int RADIX = 2;\n    char buffer[(sizeof(unsigned)*8 + 1)];\n\n    // Function itoa is an POSIX function, but it is not in C standard library.\n    // There is no big surprise that Microsoft deprecate itoa because POSIX is\n    // \"Portable Operating System Interface for UNIX\". Thus it is not a good\n    // idea to use _itoa instead itoa: we lost compatibility with POSIX;\n    // we gain nothing in MS Windows (itoa-without-underscore is not better\n    // than _itoa-with-underscore). The same holds for kbhit() and _kbhit() etc.\n    //\n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        itoa(value, buffer, RADIX);\n        printf(\"itoa:          %u decimal = %s binary\\n\", value, buffer);\n    }\n\n    // Yeep, we can use a homemade bin2str function. Notice that C is very very\n    // efficient (as \"hi level assembler\") when bit manipulation is needed.\n    //\n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        printf(\"bin2str:       %u decimal = %s binary\\n\", value, bin2str(value, buffer));\n    }\n\n    // Another implementation - see above.\n    //\n    for (int i = 0; i < sizeof(NUMBERS) / sizeof(unsigned); i++)\n    {\n        unsigned value = NUMBERS[i];\n        printf(\"bin2strNaive:  %u decimal = %s binary\\n\", value, bin2strNaive(value, buffer));\n    }\n\n    return EXIT_SUCCESS;\n}\n\n\nOutput:\nitoa:          5 decimal = 101 binary\nitoa:          50 decimal = 110010 binary\nitoa:          9000 decimal = 10001100101000 binary\nbin2str:       5 decimal = 101 binary\nbin2str:       50 decimal = 110010 binary\nbin2str:       9000 decimal = 10001100101000 binary\nbin2strNaive:  5 decimal = 101 binary\nbin2strNaive:  50 decimal = 110010 binary\nbin2strNaive:  9000 decimal = 10001100101000 binary\nWith malloc and log10[edit]\n\n#include <math.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <stdint.h>\n\nchar *bin(uint32_t x);\n\nint main(void)\n{\n    for (size_t i = 0; i < 20; i++) {\n        char *binstr = bin(i);\n        printf(\"%s\\n\", binstr);\n        free(binstr);\n    }\n}\n\nchar *bin(uint32_t x)\n{\n    size_t bits = (x == 0) ? 1 : log10((double) x)/log10(2) + 1;\n    char *ret = malloc((bits + 1) * sizeof (char));\n    for (size_t i = 0; i < bits ; i++) {\n       ret[bits - i - 1] = (x & 1) ? '1' : '0';\n       x >>= 1;\n    }\n    ret[bits] = '\\0';\n    return ret;\n}\n\n\nOutput:\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n10000\n10001\n10010\n10011\n", "explain": "Converts int to a string.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "C++", "code": "\n#include <bitset>\n#include <iostream>\n#include <limits>\n#include <string>\n \nvoid print_bin(unsigned int n) {\n  std::string str = \"0\";\n\n  if (n > 0) {\n    str = std::bitset<std::numeric_limits<unsigned int>::digits>(n).to_string();\n    str = str.substr(str.find('1')); // remove leading zeros\n  } \n  \n  std::cout << str << '\\n';\n}\n\nint main() {\n  print_bin(0);\n  print_bin(5);\n  print_bin(50);\n  print_bin(9000);\n}\n\n\nOutput:\n0\n101\n110010\n10001100101000\n\n\n#include <iostream>\n#include <bitset>\nvoid printBits(int n) {                     // Use int like most programming languages. \n  int iExp = 0;                             // Bit-length\n  while (n >> iExp) ++iExp;                 // Could use template <log(x)*1.44269504088896340736>  \n  for (int at = iExp - 1; at >= 0; at--)    // Reverse iter from the bit-length to 0 - msb is at end\n    std::cout << std::bitset<32>(n)[at];    // Show 1's, show lsb, hide leading zeros\n  std::cout << '\\n';\n}\nint main(int argc, char* argv[]) {\n  printBits(5);\n  printBits(50);\n  printBits(9000);\n} // for testing with n=0 printBits<32>(0);\n\n\n#include <iostream>\nint main(int argc, char* argv[]) {\n  unsigned int in[] = {5, 50, 9000};        // Use int like most programming languages\n  for (int i = 0; i < 3; i++)               // Use all inputs\n    for (int at = 31; at >= 0; at--)        // reverse iteration from the max bit-length to 0, because msb is at the end\n      if (int b = (in[i] >> at))            // skip leading zeros. Start output when significant bits are set\n         std::cout << ('0' + b & 1) << (!at ? \"\\n\": \"\");\t// '0' or '1'. Add EOL if last bit of num\n}\n\n\n#include <iostream>\nint main(int argc, char* argv[]) {                        // Usage: program.exe 5 50 9000\n  for (int i = 1; i < argc; i++)                          // argv[0] is program name\n    for (int at = 31; at >= 0; at--)                      // reverse iteration from the max bit-length to 0, because msb is at the end\n      if (int b = (atoi(argv[i]) >> at))                  // skip leading zeros\n         std::cout << ('0' + b & 1) << (!at ? \"\\n\": \"\");  // '0' or '1'. Add EOL if last bit of num\n}\n\n\n#include <iostream>\n\nstd::string binary(int n) {\n  return n == 0 ? \"\" : binary(n >> 1) + std::to_string(n & 1);\n}\n\nint main(int argc, char* argv[]) {\n  for (int i = 1; i < argc; ++i) {\n    std::cout << binary(std::stoi(argv[i])) << std::endl;\n  }\n}\n\n\nOutput:\n101\n110010\n10001100101000\n\n", "explain": "Shorter version using bitset\nUsing >> operator. (1st example is 2.75x longer. Matter of taste.)\nTo be fair comparison with languages that doesn't declare a function like C++ main(). 3.14x shorter than 1st example.\nUsing bitwise operations with recursion.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Java", "code": "\n\nInteger.toBinaryString(5);\n\nInteger.toBinaryString(50);\n\nInteger.toBinaryString(9000);\n\n\n101\n110010\n10001100101000\n\n", "explain": "\n    The Integer class offers the toBinaryString method.\n\n    If you printed these values you would get the following.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main()\n    {\n        foreach (var number in new[] { 5, 50, 9000 })\n        {\n            Console.WriteLine(Convert.ToString(number, 2));\n        }\n    }\n}\n\nAnother version using dotnet 5using System;\nusing System.Text;\n\nstatic string ToBinary(uint x) {\n    if(x == 0) return \"0\";\n    var bin = new StringBuilder();\n    for(uint mask = (uint)1 << (sizeof(uint)*8 - 1);mask > 0;mask = mask >> 1)\n        bin.Append((mask & x) > 0\u00a0? \"1\"\u00a0: \"0\");\n    return bin.ToString().TrimStart('0');\n}\n\nConsole.WriteLine(ToBinary(5));\nConsole.WriteLine(ToBinary(50));\nConsole.WriteLine(ToBinary(9000));\n\nOutput:\n101\n110010\n10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "JavaScript", "code": "\nES5[edit]\nfunction toBinary(number) {\n    return new Number(number)\n        .toString(2);\n}\nvar demoValues = [5, 50, 9000];\nfor (var i = 0; i < demoValues.length; ++i) {\n    // alert() in a browser, wscript.echo in WSH, etc.\n    print(toBinary(demoValues[i])); \n}\n\nES6[edit]\n\n(() => {\n    \"use strict\";\n\n    // ------------------ BINARY DIGITS ------------------\n\n    // showBinary\u00a0:: Int -> String\n    const showBinary = n =>\n        showIntAtBase_(2)(n);\n\n\n    // showIntAtBase_\u00a0:: // Int -> Int -> String\n    const showIntAtBase_ = base =>\n        n => n.toString(base);\n\n\n    // ---------------------- TEST -----------------------\n    const main = () => [5, 50, 9000]\n        .map(n => `${n} -> ${showBinary(n)}`)\n        .join(\"\\n\");\n\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n5 -> 101\n50 -> 110010\n9000 -> 10001100101000\n\n(() => {\n    \"use strict\";\n\n    // -------------- DIGITS FOR GIVEN BASE --------------\n\n    // showIntAtBase\u00a0:: Int -> (Int -> Char) ->\n    // Int -> String -> String\n    const showIntAtBase = base =>\n        // A string representation of n, in the given base,\n        // using a supplied (Int -> Char) function for digits,\n        // and a supplied suffix string.\n        toChr => n => rs => {\n            const go = ([x, d], r) => {\n                const r_ = toChr(d) + r;\n\n                return 0 !== x ? (\n                    go(quotRem(x)(base), r_)\n                ) : r_;\n            };\n\n            const e = \"error: showIntAtBase applied to\";\n\n            return 1 >= base ? (\n                `${e} unsupported base`\n            ) : 0 > n ? (\n                `${e} negative number`\n            ) : go(quotRem(n)(base), rs);\n        };\n\n    // ---------------------- TEST -----------------------\n    const main = () => {\n        // showHanBinary\u00a0:: Int -> String\n        const showHanBinary = n =>\n            showIntAtBase(2)(\n                x => \"\u3007\u4e00\" [x]\n            )(n)(\"\");\n\n        return [5, 50, 9000]\n            .map(\n                n => `${n} -> ${showHanBinary(n)}`\n            )\n            .join(\"\\n\");\n    };\n\n\n    // --------------------- GENERIC ---------------------\n\n    // quotRem\u00a0:: Integral a => a -> a -> (a, a)\n    const quotRem = m =>\n        // The quotient, tupled with the remainder.\n        n => [Math.trunc(m / n), m % n];\n\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n5 -> \u4e00\u3007\u4e00\n50 -> \u4e00\u4e00\u3007\u3007\u4e00\u3007\n9000 -> \u4e00\u3007\u3007\u3007\u4e00\u4e00\u3007\u3007\u4e00\u3007\u4e00\u3007\u3007\u3007\n", "explain": "The simplest showBinary (or showIntAtBase), using default digit characters, would use JavaScript's standard String.toString(base):\nOr, if we need more flexibility with the set of digits used, we can write a version of showIntAtBase which takes a more specific Int -> Char function as as an argument. This one is a rough translation of Haskell's Numeric.showIntAtBase:\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Visual_Basic_.NET", "code": "\nModule Program\n    Sub Main\n        For Each number In {5, 50, 9000}\n            Console.WriteLine(Convert.ToString(number, 2))\n        Next\n    End Sub\nEnd Module\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "PHP", "code": "\n<?php\necho decbin(5);\necho decbin(50);\necho decbin(9000);\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Fortran", "code": "\n\n!-*- mode: compilation; default-directory: \"/tmp/\" -*-\n!Compilation started at Sun May 19 23:14:14\n!\n!a=./F && make $a && $a < unixdict.txt\n!f95 -Wall -ffree-form F.F -o F\n!101\n!110010\n!10001100101000\n!\n!Compilation finished at Sun May 19 23:14:14\n!\n!\n!   tobin=: -.&' '@\":@#:\n!   tobin 5\n!101\n!   tobin 50\n!110010\n!   tobin 9000\n!10001100101000\n\nprogram bits\n  implicit none\n  integer, dimension(3) :: a\n  integer :: i\n  data a/5,50,9000/\n  do i = 1, 3\n    call s(a(i))\n  enddo\n\ncontains\n\n  subroutine s(a)\n    integer, intent(in) :: a\n    integer :: i\n    if (a .eq. 0) then\n      write(6,'(a)')'0'\n      return\n    endif\n    do i = 31, 0, -1\n      if (btest(a, i)) exit\n    enddo\n    do while (0 .lt. i)\n      if (btest(a, i)) then\n        write(6,'(a)',advance='no')'1'\n      else\n        write(6,'(a)',advance='no')'0'\n      endif\n      i = i-1\n    enddo\n    if (btest(a, i)) then\n      write(6,'(a)')'1'\n    else\n      write(6,'(a)')'0'\n    endif\n  end subroutine s\n\nend program bits\n\n", "explain": "Please find compilation instructions and the example run at the start of the FORTRAN90 source that follows.  Thank you.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n)\n\nfunc main() {\n\tfor i := 0; i < 16; i++ {\n\t\tfmt.Printf(\"%b\\n\", i)\n\t}\n}\n\n\nOutput:\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program binarydigit.s   */\n\n/* Constantes    */\n.equ STDOUT, 1\n.equ WRITE,  4\n.equ EXIT,   1\n/* Initialized data */\n.data\n\nsMessAffBin: .ascii \"The decimal value  \"\nsZoneDec: .space 12,' '\n             .ascii \" should produce an output of \"\nsZoneBin: .space 36,' '\n              .asciz \"\\n\"\n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* save des  2 registres */\n    mov r0,#5\n    ldr r1,iAdrsZoneDec\n    bl conversion10S    @ decimal conversion\n    bl conversion2      @ binary conversion and display r\u00e9sult\n    mov r0,#50\n    ldr r1,iAdrsZoneDec\n    bl conversion10S\n    bl conversion2\n    mov r0,#-1\n    ldr r1,iAdrsZoneDec\n    bl conversion10S\n    bl conversion2\n    mov r0,#1\n    ldr r1,iAdrsZoneDec\n    bl conversion10S\n    bl conversion2\n\n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\niAdrsZoneDec: .int sZoneDec\n/******************************************************************/\n/*     register conversion in binary                              */ \n/******************************************************************/\n/* r0 contains the register */\nconversion2:\n    push {r0,lr}     /* save  registers */  \n    push {r1-r5} /* save others registers */\n    ldr r1,iAdrsZoneBin   @ address reception area\n    clz r2,r0    @ number of left zeros bits \n    rsb r2,#32   @ number of significant bits\n    mov r4,#' '  @ space\n    add r3,r2,#1 @ position counter in reception area\n1:\n    strb r4,[r1,r3]   @ space in other location of reception area\n    add r3,#1\n    cmp r3,#32         @ end of area\u00a0?\n    ble 1b            @ no! loop\n    mov r3,r2    @ position counter of the written character\n2:               @ loop \n    lsrs r0,#1    @ shift right one bit with flags\n    movcc r4,#48  @ carry clear  => character 0\n    movcs r4,#49  @ carry set   => character 1 \n    strb r4,[r1,r3]  @ character in reception area at position counter\n    sub r3,r3,#1     @ \n    subs r2,r2,#1   @  0 bits\u00a0?\n    bgt 2b          @ no!  loop\n    \n    ldr r0,iAdrsZoneMessBin\n    bl affichageMess\n    \n100:\n    pop {r1-r5}  /* restaur others registers */\n    pop {r0,lr}\n    bx lr\t\niAdrsZoneBin: .int sZoneBin\t   \niAdrsZoneMessBin: .int sMessAffBin\n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registres */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registres */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\t\n/***************************************************/\n/*   conversion registre en d\u00e9cimal   sign\u00e9  */\n/***************************************************/\n/* r0 contient le registre   */\n/* r1 contient l adresse de la zone de conversion */\nconversion10S:\n    push {fp,lr}    /* save des  2 registres frame et retour */\n    push {r0-r5}   /* save autres registres  */\n    mov r2,r1       /* debut zone stockage */\n    mov r5,#'+'     /* par defaut le signe est + */\n    cmp r0,#0       /* nombre n\u00e9gatif\u00a0? */\n    movlt r5,#'-'     /* oui le signe est - */\n    mvnlt r0,r0       /* et inversion en valeur positive */\n    addlt r0,#1\n    mov r4,#10   /* longueur de la zone */\n1: /* debut de boucle de conversion */\n    bl divisionpar10 /* division  */\n    add r1,#48        /* ajout de 48 au reste pour conversion ascii */\t\n    strb r1,[r2,r4]  /* stockage du byte en d\u00e9but de zone r5 + la position r4 */\n    sub r4,r4,#1      /* position pr\u00e9cedente */\n    cmp r0,#0     \n    bne 1b\t       /* boucle si quotient different de z\u00e9ro */\n    strb r5,[r2,r4]  /* stockage du signe \u00e0 la position courante */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    blt  100f         /* si r4 < 0  fin  */\n    /* sinon il faut completer le debut de la zone avec des blancs */\n    mov r3,#' '   /* caractere espace */\t\n2:\n    strb r3,[r2,r4]  /* stockage du byte  */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    bge 2b        /* boucle si r4 plus grand ou egal a zero */\n100:  /* fin standard de la fonction  */\n    pop {r0-r5}   /*restaur des autres registres */\n    pop {fp,lr}   /* restaur des  2 registres frame et retour  */\n    bx lr   \n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 contient le dividende   */\n/* r0 retourne le quotient */\t\n/* r1 retourne le reste  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}   /* save others registers  */\n    mov r4,r0 \n    ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n    smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n    mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n    mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n    add r0, r2, r1         /* r0 <- r2 + r1 */\n    add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n    sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n    pop {r2-r4}\n    bx lr                  /* leave function */\n    .align 4\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "X86_Assembly", "code": "\n\n        .model  tiny\n        .code\n        .486\n        org     100h\nstart:  mov     ax, 5\n        call    binout\n        call    crlf\n        mov     ax, 50\n        call    binout\n        call    crlf\n        mov     ax, 9000\n        call    binout\n\ncrlf:   mov     al, 0Dh         ;new line\n        int     29h\n        mov     al, 0Ah\n        int     29h\n        ret\n\nbinout: push    ax\n        shr     ax, 1\n        je      bo10\n         call   binout\nbo10:   pop     ax\n        and     al, 01h\n        or      al, '0'\n        int     29h             ;display character\n        ret\n        end     start\n\nOutput:\n101\n110010\n10001100101000\n\n", "explain": "Translation of XPL0. Assemble with tasm, tlink /t\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Delphi", "code": "\nprogram BinaryDigit;\n{$APPTYPE CONSOLE}\nuses\n  sysutils;\n\nfunction IntToBinStr(AInt : LongWord) : string;\nbegin\n  Result := '';\n  repeat\n    Result := Chr(Ord('0')+(AInt and 1))+Result;\n    AInt := AInt div 2;\n  until (AInt = 0);\nend;\n\nBegin\n  writeln('   5: ',IntToBinStr(5));\n  writeln('  50: ',IntToBinStr(50));\n  writeln('9000: '+IntToBinStr(9000));\nend.\n\n\nOutput:\n   5: 101\n  50: 110010\n9000: 10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Ruby", "code": "\n[5,50,9000].each do |n|\n  puts \"%b\"\u00a0% n\nend\n\nfor n in [5,50,9000]\n  puts n.to_s(2)\nend\n\nOutput:\n101\n110010\n10001100101000\n", "explain": "or\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Rust", "code": "\nfn main() {\n    for i in 0..8 {\n        println!(\"{:b}\", i)\n    }\n}\n\n0\n1\n10\n11\n100\n101\n110\n111\n", "explain": "Outputs:\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Swift", "code": "\nfor num in [5, 50, 9000] {\n    println(String(num, radix: 2))\n}\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "R", "code": "\ndec2bin <- function(num) {\n  ifelse(num == 0,\n         0,\n         sub(\"^0+\",\"\",paste(rev(as.integer(intToBits(num))), collapse = \"\"))\n  )\n}\n\nfor (anumber in c(0, 5, 50, 9000)) {\n         cat(dec2bin(anumber),\"\\n\")\n}\n\n0\n101\n110010\n10001100101000\n\n", "explain": "output\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. SAMPLE.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n\n         01 binary_number   pic X(21).\n         01 str             pic X(21).\n         01 binary_digit    pic X.\n         01 digit           pic 9.\n         01 n               pic 9(7).\n         01 nstr            pic X(7).\n\n       PROCEDURE DIVISION.\n         accept nstr\n         move nstr to n\n         perform until n equal 0\n           divide n by 2 giving n remainder digit\n           move digit to binary_digit\n           string binary_digit  DELIMITED BY SIZE\n                  binary_number DELIMITED BY SPACE\n                  into str\n           move str to binary_number\n         end-perform.\n         display binary_number\n         stop run.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. binary-conversion.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01 binary-number   pic X(21).\n01 digit           pic 9.\n01 n               pic 9(7).\n01 nstr            pic X(7).\n01 ptr\t\t\t   pic 99.\n\nPROCEDURE DIVISION.\n\tdisplay \"Number: \" with no advancing.\n\taccept nstr.\n\tmove nstr to n.\n\tmove zeroes to binary-number.\n\tmove length binary-number to ptr.\n\tperform until n equal 0\n\t\tdivide n by 2 giving n remainder digit\n\t\tmove digit to binary-number(ptr:1) \n\t\tsubtract 1 from ptr\n\t\tif ptr < 1\n\t\t\texit perform\n\t\tend-if\n\tend-perform.\n\tdisplay binary-number.\n\tstop run.\n\n", "explain": "Free-form, using a reference modifier to index into binary-number.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Visual_FoxPro", "code": "\n*!* Binary Digits\nCLEAR\nk = CAST(5 As I)\n? NToBin(k)\nk = CAST(50 As I)\n? NToBin(k)\nk = CAST(9000 As I)\n? NToBin(k)\n\nFUNCTION NTOBin(n As Integer) As String\nLOCAL i As Integer, b As String, v As Integer\nb = \"\"\nv = HiBit(n)\nFOR i = 0 TO v\n    b = IIF(BITTEST(n, i), \"1\", \"0\") + b\nENDFOR\nRETURN b\nENDFUNC\n\nFUNCTION HiBit(n As Double) As Integer\n*!* Find the highest power of 2 in n\nLOCAL v As Double\nv = LOG(n)/LOG(2)\nRETURN FLOOR(v)\nENDFUNC\n\nOutput:\n101\n110010\n10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\nPublic Function Bin(ByVal l As Long) As String\nDim i As Long\n  If l Then\n    If l And &H80000000 Then 'negative number\n      Bin = \"1\" & String$(31, \"0\")\n      l = l And (Not &H80000000)\n      \n      For i = 0 To 30\n      If l And (2& ^ i) Then\n        Mid$(Bin, Len(Bin) - i) = \"1\"\n      End If\n      Next i\n      \n    Else                     'positive number\n      Do While l\n      If l Mod 2 Then\n        Bin = \"1\" & Bin\n      Else\n        Bin = \"0\" & Bin\n      End If\n      l = l \\ 2\n      Loop\n    End If\n  Else\n    Bin = \"0\"                'zero\n  End If\nEnd Function\n\n'testing:\nPublic Sub Main()\n  Debug.Print Bin(5)\n  Debug.Print Bin(50)\n  Debug.Print Bin(9000)\nEnd Sub\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Ada", "code": "\nwith ada.text_io; use ada.text_io;\nprocedure binary is \n  bit : array (0..1) of character := ('0','1');\n\n  function bin_image (n : Natural) return string is \n  (if n < 2 then (1 => bit (n)) else bin_image (n / 2) & bit (n mod 2));\n\n  test_values : array (1..3) of Natural := (5,50,9000); \nbegin\n  for test of test_values loop \n\tput_line (\"Output for\" & test'img & \" is \" & bin_image (test)); \n  end loop; \nend binary;\n\n\nOutput:\nOutput for 5 is 101\nOutput for 50 is 110010\nOutput for 9000 is 10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Julia", "code": "\nWorks with: Julia version 1.0\nusing Printf\n\nfor n in (0, 5, 50, 9000)\n    @printf(\"%6i \u2192 %s\\n\", n, string(n, base=2))\nend\n \n# with pad\nprintln(\"\\nwith pad\")\nfor n in (0, 5, 50, 9000)\n    @printf(\"%6i \u2192 %s\\n\", n, string(n, base=2, pad=20))\nend\n\n\nOutput:\n     0 \u2192 0\n     5 \u2192 101\n    50 \u2192 110010\n  9000 \u2192 10001100101000\n\nwith pad\n     0 \u2192 00000000000000000000\n     5 \u2192 00000000000000000101\n    50 \u2192 00000000000000110010\n  9000 \u2192 00000010001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Kotlin", "code": "\nfun main() {\n    val numbers = intArrayOf(5, 50, 9000)\n    numbers.forEach { println(\"$it -> ${it.toString(2)}\") }\n}\n\n\nOutput:\n5 -> 101\n50 -> 110010\n9000 -> 10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Perl", "code": "\nfor (5, 50, 9000) {\n  printf \"%b\\n\", $_;\n}\n101\n110010\n10001100101000\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nWorks with: GNU Prolog\nbinary(X)\u00a0:- format('~2r~n', [X]).\nmain\u00a0:- maplist(binary, [5,50,9000]), halt.\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Lua", "code": "\nLua - Iterative[edit]\nfunction dec2bin(n)\n    local bin = \"\"\n    while n > 1 do\n        bin = n % 2 .. bin\n        n = math.floor(n / 2)\n    end\n    return n .. bin\nend\n\nprint(dec2bin(5))\nprint(dec2bin(50))\nprint(dec2bin(9000))\n\n\nOutput:\n101\n110010\n10001100101000\nLua - Recursive[edit]\nWorks with: Lua version 5.3+\n-- for Lua 5.1/5.2 use math.floor(n/2) instead of n>>1, and n%2 instead of n&1\n\nfunction dec2bin(n)\n    return n>1 and dec2bin(n>>1)..(n&1) or n\nend\n\nprint(dec2bin(5))\nprint(dec2bin(50))\nprint(dec2bin(9000))\n\n\nOutput:\n101\n110010\n10001100101000\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Scala", "code": "\n\nscala> (5 toBinaryString)\nres0: String = 101\n\nscala> (50 toBinaryString)\nres1: String = 110010\n\nscala> (9000 toBinaryString)\nres2: String = 10001100101000\n", "explain": "Scala has an implicit conversion from Int to RichInt which has a method toBinaryString.\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Dart", "code": "\nString binary(int n) {\n  if(n<0)\n    throw new IllegalArgumentException(\"negative numbers require 2s complement\");\n  if(n==0) return \"0\";\n  String res=\"\";\n  while(n>0) {\n    res=(n%2).toString()+res;\n    n=(n/2).toInt();\n  }\n  return res;\n}\n\nmain() {\n  print(binary(0));\n  print(binary(1));\n  print(binary(5));\n  print(binary(10));\n  print(binary(50));\n  print(binary(9000));\n  print(binary(65535));\n  print(binary(0xaa5511ff));\n  print(binary(0x123456789abcde));\n  // fails due to precision limit\n  print(binary(0x123456789abcdef));\n}\n\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "D", "code": "\nvoid main() {\n    import std.stdio;\n\n    foreach (immutable i; 0 .. 16)\n        writefln(\"%b\", i);\n}\n\n\nOutput:\n0\n1\n10\n11\n100\n101\n110\n111\n1000\n1001\n1010\n1011\n1100\n1101\n1110\n1111\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Haskell", "code": "\nimport Data.List\nimport Numeric\nimport Text.Printf\n\n-- Use the built-in function showBin.\ntoBin n = showBin n \"\"\n\n-- Use the built-in function showIntAtBase.\ntoBin n = showIntAtBase 2 (\"01\" !!) n \"\"\n\n-- Implement our own version.\ntoBin1 0 = []\ntoBin1 x =  (toBin1 $ x `div` 2) ++ (show $ x `mod` 2)\n\n-- Or even more efficient (due to fusion) and universal implementation\ntoBin2 = foldMap show . reverse . toBase 2\n\ntoBase base = unfoldr modDiv\n  where modDiv 0 = Nothing\n        modDiv n = let (q, r) = (n `divMod` base) in Just (r, q) \n\n\nprintToBin n = putStrLn $ printf \"%4d  %14s  %14s\" n (toBin n) (toBin1 n)\n\nmain = do\n  putStrLn $ printf \"%4s  %14s  %14s\" \"N\" \"toBin\" \"toBin1\"\n  mapM_ printToBin [5, 50, 9000]\n\n\nOutput:\n   N           toBin          toBin1\n   5             101             101\n  50          110010          110010\n9000  10001100101000  10001100101000\n\n\nimport Data.Bifunctor (first)\nimport Data.List (unfoldr)\nimport Data.Tuple (swap)\n\n---------------------- BINARY DIGITS ---------------------\n\nbinaryDigits :: Int -> String\nbinaryDigits = reverse . unfoldr go\n  where\n    go 0 = Nothing\n    go n = Just . first (\"01\" !!) . swap . quotRem n $ 2\n\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain =\n  mapM_\n    ( putStrLn\n        . ( ((<>) . (<> \" -> \") . show)\n              <*> binaryDigits\n          )\n    )\n    [5, 50, 9000]\n\n\nOutput:\n5 -> 101\n50 -> 110010\n9000 -> 10001100101000\n", "explain": "\nand in terms of first and swap, we could also write this as:\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "VBScript", "code": "\n\nOption Explicit\nDim bin\nbin=Array(\"    \",\"   I\",\"  I \",\"  II\",\" I  \",\" I I\",\" II \",\" III\",\"I   \",\"I  I\",\"I I \",\"I II\",\" I  \",\"II I\",\"III \",\"IIII\") \n\nFunction num2bin(n)\n Dim s,i,n1,n2\n s=Hex(n)\n For i=1 To Len(s)\n   n1=Asc(Mid(s,i,1))\n   If n1>64 Then n2=n1-55 Else n2=n1-48\n   num2bin=num2bin & bin(n2)\n Next\n num2bin=Replace(Replace(LTrim(num2bin),\" \",\"0\"),\"I\",1)\n End Function\n \n Sub print(s): \n     On Error Resume Next\n     WScript.stdout.WriteLine (s)  \n     If  err= &h80070006& Then WScript.Echo \" Please run this script with CScript\": WScript.quit\n End Sub\n print num2bin(5)     \n print num2bin(50)   \n print num2bin(9000)\n\nOutput:\n\n101\n110010\n10001100101000\n\n\n", "explain": "Using no Math....\n\n\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Scheme", "code": "\n(display (number->string 5 2)) (newline)\n(display (number->string 50 2)) (newline)\n(display (number->string 9000 2)) (newline)\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "PowerShell", "code": "\nLibrary: Microsoft .NET Framework\n@(5,50,900) | foreach-object { [Convert]::ToString($_,2) }\n\nOutput:\n101\n110010\n1110000100\n", "explain": ""}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "F#", "code": "\n\nopen System\nfor i in [5; 50; 9000] do printfn \"%s\" <| Convert.ToString (i, 2)\n\n\nopen System\n\n// define the function\nlet printBin (i: int) = \n    Convert.ToString (i, 2)\n    |> printfn \"%s\" \n\n// use the function\n[5; 50; 9000] \n|> List.iter printBin\n\n\nopen System\nopen System.IO\n\n// define a callback function for %a\nlet bin (tw: TextWriter) value = \n    tw.Write(\"{0}\", Convert.ToString(int64 value, 2))\n\n// use it with printfn with %a\n[5; 50; 9000] \n|> List.iter (printfn \"binary: %a\" bin)\n\n\n101\n110010\n10001100101000\n\n", "explain": "By translating C#'s approach, using imperative coding style (inflexible):\nAlternatively, by creating a function printBin which prints in binary (more flexible):\nOr more idiomatic so that you can use it with any printf-style function and the %a format specifier (most flexible):\nOutput (either version):\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "Groovy", "code": "\n\nprint '''\n  n        binary\n----- ---------------\n'''\n[5, 50, 9000].each {\n    printf('%5d %15s\\n', it, Integer.toBinaryString(it))\n}\n\n\nOutput:\n  n        binary\n----- ---------------\n    5             101\n   50          110010\n 9000  10001100101000\n", "explain": "Solutions:\n"}, {"task_name": "Binary digits", "task_url": "https://rosettacode.org/wiki/Binary_digits", "task_cat": "Basic language learning", "lang": "AWK", "code": "\nBEGIN {\n  print tobinary(0)\n  print tobinary(1)\n  print tobinary(5)\n  print tobinary(50)\n  print tobinary(9000)\n}\n\nfunction tobinary(num) {\n  outstr = num % 2\n  while (num = int(num / 2))\n    outstr = (num % 2) outstr\n  return outstr\n}\n\n", "explain": ""}]