[{"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Python", "code": "\ndef caesar(s, k, decode = False):\n\tif decode: k = 26 - k\n\treturn \"\".join([chr((ord(i) - 65 + k)\u00a0% 26 + 65)\n\t\t\t\tfor i in s.upper()\n\t\t\t\tif ord(i) >= 65 and ord(i) <= 90 ])\n\nmsg = \"The quick brown fox jumped over the lazy dogs\"\nprint msg\nenc = caesar(msg, 11)\nprint enc\nprint caesar(enc, 11, decode = True)\n\nOutput:\nThe quick brown fox jumped over the lazy dogs\nESPBFTNVMCZHYQZIUFXAPOZGPCESPWLKJOZRD\nTHEQUICKBROWNFOXJUMPEDOVERTHELAZYDOGS\n\nWorks with: Python version 2.x (for 3.x change string.maketrans to str.maketrans)\nimport string\ndef caesar(s, k, decode = False):\n   if decode: k = 26 - k\n   return s.translate(\n       string.maketrans(\n           string.ascii_uppercase + string.ascii_lowercase,\n           string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +\n           string.ascii_lowercase[k:] + string.ascii_lowercase[:k]\n           )\n       )\nmsg = \"The quick brown fox jumped over the lazy dogs\"\nprint msg\nenc = caesar(msg, 11)\nprint enc\nprint caesar(enc, 11, decode = True)\n\nOutput:\nThe quick brown fox jumped over the lazy dogs\nEsp bftnv mczhy qzi ufxapo zgpc esp wlkj ozrd\nThe quick brown fox jumped over the lazy dogs\n\n\nWorks with: Python version 3.x\nimport string\ndef caesar(s, k = 13, decode = False, *, memo={}):\n  if decode: k = 26 - k\n  k = k\u00a0% 26\n  table = memo.get(k)\n  if table is None:\n    table = memo[k] = str.maketrans(\n                        string.ascii_uppercase + string.ascii_lowercase,\n                        string.ascii_uppercase[k:] + string.ascii_uppercase[:k] +\n                        string.ascii_lowercase[k:] + string.ascii_lowercase[:k])\n  return s.translate(table)\n\nfrom string import ascii_uppercase as abc\n\ndef caesar(s, k, decode = False):\n    trans = dict(zip(abc, abc[(k,26-k)[decode]:] + abc[:(k,26-k)[decode]]))\n    return ''.join(trans[L] for L in s.upper() if L in abc)\n\nmsg = \"The quick brown fox jumped over the lazy dogs\"\nprint(caesar(msg, 11))\nprint(caesar(caesar(msg, 11), 11, True))\n\nOutput:\nESPBFTNVMCZHYQZIUFXAPOZGPCESPWLKJOZRD\nTHEQUICKBROWNFOXJUMPEDOVERTHELAZYDOGS\n\n", "explain": "Alternate solution\nVariant with memoization of translation tables\nA compact alternative solution\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <ctype.h>\n\n#define caesar(x) rot(13, x)\n#define decaesar(x) rot(13, x)\n#define decrypt_rot(x, y) rot((26-x), y)\n\nvoid rot(int c, char *str)\n{\n\tint l = strlen(str);\n        \n        const char*  alpha_low  = \"abcdefghijklmnopqrstuvwxyz\"; \n\n        const char*  alpha_high = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\";\n   \n       \n       char subst;  /* substitution character */\n       int idx;    /* index */\n\n         int i; /* loop var */\n\n\tfor (i = 0; i < l; i++)  /* for each letter in string */\n\t{\n\t\tif( 0 == isalpha(str[i]) )  continue; /* not alphabet character */\n\n                idx = (int) (tolower(str[i]) - 'a') + c) % 26; /* compute index */\n\n\t\tif( isupper(str[i]) )\n                    subst = alpha_high[idx]; \n                else\n                    subst = alpha_low[idx]; \n\n               str[i] = subst;\n\n\t}\n}\n\n\nint main(int argc, char** argv)\n{\n\tchar str[] = \"This is a top secret text message!\";\n\t\n\tprintf(\"Original: %s\\n\", str);\n\tcaesar(str);\n\tprintf(\"Encrypted: %s\\n\", str);\n\tdecaesar(str);\n\tprintf(\"Decrypted: %s\\n\", str);\n\t\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "C++", "code": "\n#include <string>\n#include <iostream>\n#include <algorithm>\n#include <cctype>\n\nclass MyTransform {\nprivate : \n   int shift ;\npublic :\n   MyTransform( int s ) : shift( s ) { } \n\n  char operator( )( char c ) {\n      if ( isspace( c ) ) \n\t return ' ' ;\n      else {\n\t static std::string letters( \"abcdefghijklmnopqrstuvwxyz\" ) ;\n\t std::string::size_type found = letters.find(tolower( c )) ;\n\t int shiftedpos = ( static_cast<int>( found ) + shift ) % 26 ;\n\t if ( shiftedpos < 0 ) //in case of decryption possibly\n\t    shiftedpos = 26 + shiftedpos ;\n\t char shifted = letters[shiftedpos] ;\n\t return shifted ;\n      }\n  }\n} ;\n\nint main( ) {\n   std::string input ;\n   std::cout << \"Which text is to be encrypted\u00a0?\\n\" ;\n   getline( std::cin , input ) ;\n   std::cout << \"shift\u00a0?\\n\" ;\n   int myshift = 0 ;\n   std::cin >> myshift ;\n   std::cout << \"Before encryption:\\n\" << input << std::endl ;\n   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,\n\t MyTransform( myshift ) ) ;\n   std::cout << \"encrypted:\\n\" ;\n   std::cout << input << std::endl ;\n   myshift *= -1 ; //decrypting again\n   std::transform ( input.begin( ) , input.end( ) , input.begin( ) ,\n\t MyTransform( myshift ) ) ;\n   std::cout << \"Decrypted again:\\n\" ;\n   std::cout << input << std::endl ;\n   return 0 ;\n}\n\n\nOutput:\nWhich text is to be encrypted\u00a0?\nthis is an interesting text\nshift\u00a0?\n3\nBefore encryption:\nthis is an interesting text\nencrypted:\nwklv lv dq lqwhuhvwlqj whaw\nDecrypted again:\nthis is an interesting text\n\n\nWorks with: C++-11[edit]\n/* caesar cipher */\n\n#include <string>\n#include <iostream>\n#include <cctype>\n \nint main( ) {\n\n  using namespace std;\n\n  string input ;\n  int key = 0;\n\n  // lambda functions \n\n  auto encrypt = [&](char c, int key ) {\n    char A  = ( islower(c) )? 'a': 'A';\n    c = (isalpha(c))? (c - A + key) % 26 + A : c;\n    return (char) c;\n  };\n\n  auto decrypt = [&](char c, int key ) {\n    char A  = ( islower(c) )? 'a': 'A';\n    c = (isalpha(c))? (c - A + (26 - key) ) % 26 + A : c;\n    return (char) c;\n  };\n\n\n  cout << \"Enter a line of text.\\n\";\n  getline( cin , input );\n\n  cout << \"Enter an integer to shift text.\\n\";\n  cin  >> key;\n  \n  while ( (key < 1) || (key > 25) )\n    {\n      cout << \"must be an integer between 1 and 25 -->\" << endl;\n      cin  >> key;\n    }\n\n  cout << \"Plain:    \\t\" << input << endl ;\n\n  for ( auto & cp : input)    // use & for mutability\n      cp = encrypt(cp, key);\n\n  cout << \"Encrypted:\\t\" << input << endl;\n\n  for ( auto & cp : input)\n      cp = decrypt(cp, key);\n\n  cout << \"Decrypted:\\t\" << input << endl;\n\n  return 0 ;\n}\n\n\nOutput:\nEnter a line of text.\nThis is a line of plain text, 50 characters long.\nEnter an integer to shift text.\n5\nPlain:    \tThis is a line of plain text, 50 characters long.\nEncrypted:\tYmnx nx f qnsj tk uqfns yj}y1 :5 hmfwfhyjwx qtsl3\nDecrypted:\tThis is a line of plain text, 50 characters long.\n\n", "explain": "\nAlternative version - lambda functions, auto, iterators \n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Java", "code": "\nWorks with: Java version 1.5+\npublic class Cipher {\n    public static void main(String[] args) {\n\n        String str = \"The quick brown fox Jumped over the lazy Dog\";\n\n        System.out.println( Cipher.encode( str, 12 ));\n        System.out.println( Cipher.decode( Cipher.encode( str, 12), 12 ));\n    }\n\n    public static String decode(String enc, int offset) {\n        return encode(enc, 26-offset);\n    }\n\n    public static String encode(String enc, int offset) {\n        offset = offset % 26 + 26;\n        StringBuilder encoded = new StringBuilder();\n        for (char i : enc.toCharArray()) {\n            if (Character.isLetter(i)) {\n                if (Character.isUpperCase(i)) {\n                    encoded.append((char) ('A' + (i - 'A' + offset) % 26 ));\n                } else {\n                    encoded.append((char) ('a' + (i - 'a' + offset) % 26 ));\n                }\n            } else {\n                encoded.append(i);\n            }\n        }\n        return encoded.toString();\n    }\n}\n\n\nOutput:\nFtq cguow ndaiz raj Vgybqp ahqd ftq xmlk Pas\nThe quick brown fox Jumped over the lazy Dog\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "C#", "code": "\nusing System;\nusing System.Linq;\n\nnamespace CaesarCypher\n{\n    class Program\n    {\n        static char Encrypt(char ch, int code)\n        {\n            if (!char.IsLetter(ch)) return ch;\n\n            char offset = char.IsUpper(ch) ? 'A' : 'a';\n            return (char)((ch + code - offset) % 26 + offset);\n        }\n\n        static string Encrypt(string input, int code)\n        {\n            return new string(input.Select(ch => Encrypt(ch, code)).ToArray());\n        }\n\n        static string Decrypt(string input, int code)\n        {\n            return Encrypt(input, 26 - code);\n        }\n\n        const string TestCase = \"Pack my box with five dozen liquor jugs.\";\n\n        static void Main()\n        {\n            string str = TestCase;\n\n            Console.WriteLine(str);\n            str = Encrypt(str, 5);\n            Console.WriteLine(\"Encrypted: \" + str);\n            str = Decrypt(str, 5);\n            Console.WriteLine(\"Decrypted: \" + str);\n            Console.ReadKey();\n        }\n    }\n}\n\n\nOutput:\nPack my box with five dozen liquor jugs.\nEncrypted: Ufhp rd gtc bnym knaj itejs qnvztw ozlx.\nDecrypted: Pack my box with five dozen liquor jugs.\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "JavaScript", "code": "\nES5[edit]\nfunction caesar (text, shift) {\n  return text.toUpperCase().replace(/[^A-Z]/g,'').replace(/./g, function(a) {\n    return String.fromCharCode(65+(a.charCodeAt(0)-65+shift)%26);\n  });\n}\n\n// Tests\nvar text = 'veni, vidi, vici';\nfor (var i = 0; i<26; i++) {\n  console.log(i+': '+caesar(text,i));\n}\n\n\nOutput:\n0: VENIVIDIVICI\n1: WFOJWJEJWJDJ\n2: XGPKXKFKXKEK\n3: YHQLYLGLYLFL\n...\n\nES6[edit]\nvar caesar = (text, shift) => text\n  .toUpperCase()\n  .replace(/[^A-Z]/g, '')\n  .replace(/./g, a =>\n    String.fromCharCode(65 + (a.charCodeAt(0) - 65 + shift) % 26));\n\n\n((key, strPlain) => {\n\n    // Int -> String -> String\n    let caesar = (k, s) => s.split('')\n        .map(c => tr(\n            inRange(['a', 'z'], c) ? 'a' :\n            inRange(['A', 'Z'], c) ? 'A' : 0,\n            k, c\n        ))\n        .join('');\n\n    // Int -> String -> String\n    let unCaesar = (k, s) => caesar(26 - (k % 26), s);\n\n    // Char -> Int -> Char -> Char\n    let tr = (base, offset, char) =>\n        base ? (\n            String.fromCharCode(\n                ord(base) + (\n                    ord(char) - ord(base) + offset\n                ) % 26\n            )\n        ) : char;\n\n    // [a, a] -> a -> b\n    let inRange = ([min, max], v) => !(v < min || v > max);\n\n    // Char -> Int\n    let ord = c => c.charCodeAt(0);\n\n    // range\u00a0:: Int -> Int -> [Int]\n    let range = (m, n) =>\n        Array.from({\n            length: Math.floor(n - m) + 1\n        }, (_, i) => m + i);\n\n    // TEST\n    let strCipher = caesar(key, strPlain),\n        strDecode = unCaesar(key, strCipher);\n\n    return [strCipher, ' -> ', strDecode];\n\n})(114, 'Curio, Cesare venne, e vide e vinse\u00a0? ');\n\n\nOutput:\nMebsy, Mockbo foxxo, o fsno o fsxco\u00a0? ,  -> , Curio, Cesare venne, e vide e vinse\u00a0?\n", "explain": "\nOr, allowing encoding and decoding of both lower and upper case:\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Module1\n\n    Function Encrypt(ch As Char, code As Integer) As Char\n        If Not Char.IsLetter(ch) Then\n            Return ch\n        End If\n\n        Dim offset = AscW(If(Char.IsUpper(ch), \"A\"c, \"a\"c))\n        Dim test = (AscW(ch) + code - offset) Mod 26 + offset\n        Return ChrW(test)\n    End Function\n\n    Function Encrypt(input As String, code As Integer) As String\n        Return New String(input.Select(Function(ch) Encrypt(ch, code)).ToArray())\n    End Function\n\n    Function Decrypt(input As String, code As Integer) As String\n        Return Encrypt(input, 26 - code)\n    End Function\n\n    Sub Main()\n        Dim str = \"Pack my box with five dozen liquor jugs.\"\n\n        Console.WriteLine(str)\n        str = Encrypt(str, 5)\n        Console.WriteLine(\"Encrypted: {0}\", str)\n        str = Decrypt(str, 5)\n        Console.WriteLine(\"Decrypted: {0}\", str)\n    End Sub\n\nEnd Module\n\nOutput:\nPack my box with five dozen liquor jugs.\nEncrypted: Ufhp rd gtc bnym knaj itejs qnvztw ozlx.\nDecrypted: Pack my box with five dozen liquor jugs.\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "PHP", "code": "\n<?php\nfunction caesarEncode( $message, $key ){\n    $plaintext = strtolower( $message );\n    $ciphertext = \"\";\n    $ascii_a = ord( 'a' );\n    $ascii_z = ord( 'z' );\n    while( strlen( $plaintext ) ){\n        $char = ord( $plaintext );\n        if( $char >= $ascii_a && $char <= $ascii_z ){\n            $char = ( ( $key + $char - $ascii_a ) % 26 ) + $ascii_a;\n        }\n        $plaintext = substr( $plaintext, 1 );\n        $ciphertext .= chr( $char );\n    }\n    return $ciphertext;\n}\n\necho caesarEncode( \"The quick brown fox Jumped over the lazy Dog\", 12 ), \"\\n\";\n?>\n\n\nOutput:\nftq cguow ndaiz raj vgybqp ahqd ftq xmlk pas\n\n<?php\n\nfunction caesarEncode($message, $key) {\n    $from = 'ABCDEFGHIJKLMNOPQRSTUVWXYZ';\n    $to   = substr($from, $key) . substr($from, 0, $key);\n    return strtr($message, $from, $to);\n}\n\necho caesarEncode('THE QUICK BROWN FOX JUMPED OVER THE LAZY DOG', 12), PHP_EOL;\n\n\nOutput:\nFTQ CGUOW NDAIZ RAJ VGYBQP AHQD FTQ XMLK PAS\n", "explain": "Or, using PHP's strtr() built-in function\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Fortran", "code": "\nWorks with: Fortan 90 and later\nprogram Caesar_Cipher\n  implicit none\n\n  integer, parameter :: key = 3     \n  character(43) :: message = \"The five boxing wizards jump quickly\"\n\n  write(*, \"(2a)\") \"Original message  = \", message\n  call encrypt(message)\n  write(*, \"(2a)\") \"Encrypted message = \", message\n  call decrypt(message)\n  write(*, \"(2a)\") \"Decrypted message = \", message\n  \ncontains\n\nsubroutine encrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 + key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 + key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nsubroutine decrypt(text)\n  character(*), intent(inout) :: text\n  integer :: i\n  \n  do i = 1, len(text)\n    select case(text(i:i))\n      case ('A':'Z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 65 - key, 26) + 65)\n      case ('a':'z')\n        text(i:i) = achar(modulo(iachar(text(i:i)) - 97 - key, 26) + 97)\n    end select\n  end do\nend subroutine\n\nend program Caesar_Cipher\n\n\nOutput:\nOriginal message  = The five boxing wizards jump quickly\nEncrypted message = Wkh ilyh eralgj zlcdugv mxps txlfnob\nDecrypted message = The five boxing wizards jump quickly\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\ntype ckey struct {\n    enc, dec func(rune) rune\n}\n\nfunc newCaesar(k int) (*ckey, bool) {\n    if k < 1 || k > 25 {\n        return nil, false\n    }\n    rk := rune(k)\n    return &ckey{\n        enc: func(c rune) rune {\n            if c >= 'a' && c <= 'z'-rk || c >= 'A' && c <= 'Z'-rk {\n                return c + rk\n            } else if c > 'z'-rk && c <= 'z' || c > 'Z'-rk && c <= 'Z' {\n                return c + rk - 26\n            }\n            return c\n        },\n        dec: func(c rune) rune {\n            if c >= 'a'+rk && c <= 'z' || c >= 'A'+rk && c <= 'Z' {\n                return c - rk\n            } else if c >= 'a' && c < 'a'+rk || c >= 'A' && c < 'A'+rk {\n                return c - rk + 26\n            }\n            return c\n        },\n    }, true\n}\n\nfunc (ck ckey) encipher(pt string) string {\n    return strings.Map(ck.enc, pt)\n}\n\nfunc (ck ckey) decipher(ct string) string {\n    return strings.Map(ck.dec, ct)\n}\n\nfunc main() {\n    pt := \"The five boxing wizards jump quickly\"\n    fmt.Println(\"Plaintext:\", pt)\n    for _, key := range []int{0, 1, 7, 25, 26} {\n        ck, ok := newCaesar(key)\n        if !ok {\n            fmt.Println(\"Key\", key, \"invalid\")\n            continue\n        }\n        ct := ck.encipher(pt)\n        fmt.Println(\"Key\", key)\n        fmt.Println(\"  Enciphered:\", ct)\n        fmt.Println(\"  Deciphered:\", ck.decipher(ct))\n    }\n}\n\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n    \"unicode\"\n)\n\ntype ckey struct {\n    enc, dec unicode.SpecialCase\n}\n\nfunc newCaesar(k int) (*ckey, bool) {\n    if k < 1 || k > 25 {\n        return nil, false\n    }\n    i := uint32(k)\n    r := rune(k)\n    return &ckey{\n        unicode.SpecialCase{\n            {'A', 'Z' - i, [3]rune{r}},\n            {'Z' - i + 1, 'Z', [3]rune{r - 26}},\n            {'a', 'z' - i, [3]rune{r}},\n            {'z' - i + 1, 'z', [3]rune{r - 26}},\n        },\n        unicode.SpecialCase{\n            {'A', 'A' + i - 1, [3]rune{26 - r}},\n            {'A' + i, 'Z', [3]rune{-r}},\n            {'a', 'a' + i - 1, [3]rune{26 - r}},\n            {'a' + i, 'z', [3]rune{-r}},\n        },\n    }, true\n}\n\nfunc (ck ckey) encipher(pt string) string {\n    return strings.ToUpperSpecial(ck.enc, pt)\n}\n\nfunc (ck ckey) decipher(ct string) string {\n    return strings.ToUpperSpecial(ck.dec, ct)\n}\n\nfunc main() {\n    pt := \"The five boxing wizards jump quickly\"\n    fmt.Println(\"Plaintext:\", pt)\n    for _, key := range []int{0, 1, 7, 25, 26} {\n        ck, ok := newCaesar(key)\n        if !ok {\n            fmt.Println(\"Key\", key, \"invalid\")\n            continue\n        }\n        ct := ck.encipher(pt)\n        fmt.Println(\"Key\", key)\n        fmt.Println(\"  Enciphered:\", ct)\n        fmt.Println(\"  Deciphered:\", ck.decipher(ct))\n    }\n}\n\n\nOutput: (either version)\nPlaintext: The five boxing wizards jump quickly\nKey 0 invalid\nKey 1\n  Enciphered: Uif gjwf cpyjoh xjabset kvnq rvjdlmz\n  Deciphered: The five boxing wizards jump quickly\nKey 7\n  Enciphered: Aol mpcl ivepun dpghykz qbtw xbpjrsf\n  Deciphered: The five boxing wizards jump quickly\nKey 25\n  Enciphered: Sgd ehud anwhmf vhyzqcr itlo pthbjkx\n  Deciphered: The five boxing wizards jump quickly\nKey 26 invalid\n\n", "explain": "Obvious solution with explicit testing for character ranges:\nData driven version using functions designed for case conversion.  (And for method using\u00a0% operator, see Vigen\u00e8re_cipher#Go.)\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program caresarcode.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ WRITE,  4                           @ Linux syscall\n\n.equ STRINGSIZE,          500\n\n/* Initialized data */\n.data\nszMessString:            .asciz \"String\u00a0:\\n\"\nszMessEncrip:            .asciz \"\\nEncrypted\u00a0:\\n\"\nszMessDecrip:            .asciz \"\\nDecrypted\u00a0:\\n\"\nszString1:               .asciz \"Why study medicine because there is internet\u00a0?\"\n\nszCarriageReturn:       .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \nszString2:                .skip  STRINGSIZE\nszString3:                .skip  STRINGSIZE\n/*  code section */\n.text\n.global main \nmain: \n\n    ldr r0,iAdrszMessString                     @ display message\n    bl affichageMess\n    ldr r0,iAdrszString1                        @ display string\n    bl affichageMess\n    ldr r0,iAdrszString1\n    ldr r1,iAdrszString2\n    mov r2,#20                                  @ key\n    bl encrypt\n    ldr r0,iAdrszMessEncrip\n    bl affichageMess\n    ldr r0,iAdrszString2                        @ display string\n    bl affichageMess \n    ldr r0,iAdrszString2\n    ldr r1,iAdrszString3\n    mov r2,#20                                  @ key\n    bl decrypt\n    ldr r0,iAdrszMessDecrip\n    bl affichageMess\n    ldr r0,iAdrszString3                        @ display string\n    bl affichageMess \n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess \n100:                                            @ standard end of the program\n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc 0                                       @ perform system call\niAdrszMessString:         .int szMessString\niAdrszMessDecrip:         .int szMessDecrip\niAdrszMessEncrip:         .int szMessEncrip\niAdrszString1:            .int szString1\niAdrszString2:            .int szString2\niAdrszString3:            .int szString3\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     encrypt strings                         */ \n/******************************************************************/\n/* r0 contains the address of the string1 */\n/* r1 contains the address of the encrypted string */\n/* r2 contains the key (1-25)                     */\nencrypt:\n    push {r3,r4,lr}           @ save  registers \n    mov r3,#0                 @ counter byte string 1\n1:\n    ldrb r4,[r0,r3]           @ load byte string 1\n    cmp r4,#0                 @ zero final\u00a0?\n    streqb r4,[r1,r3]\n    moveq r0,r3\n    beq 100f\n    cmp r4,#65                @ < A\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#90                @ > Z\n    bgt 2f\n    add r4,r2                 @ add key\n    cmp r4,#90                @ > Z\n    subgt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n2:\n    cmp r4,#97                @ < a\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#122               @> z\n    strgtb r4,[r1,r3]\n    addgt r3,#1\n    bgt 1b\n    add r4,r2\n    cmp r4,#122\n    subgt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n\n100:\n    pop {r3,r4,lr}            @ restaur registers\n    bx lr                     @ return\n/******************************************************************/\n/*     decrypt strings                                           */ \n/******************************************************************/\n/* r0 contains the address of the encrypted string1 */\n/* r1 contains the address of the decrypted string */\n/* r2 contains the key (1-25)                     */\ndecrypt:\n    push {r3,r4,lr}          @ save  registers \n    mov r3,#0                @ counter byte string 1\n1:\n    ldrb r4,[r0,r3]          @ load byte string 1\n    cmp r4,#0                @ zero final\u00a0?\n    streqb r4,[r1,r3]\n    moveq r0,r3\n    beq 100f\n    cmp r4,#65               @ < A\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#90               @ > Z\n    bgt 2f\n    sub r4,r2                @ substract key\n    cmp r4,#65               @ < A\n    addlt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n2:\n    cmp r4,#97               @ < a\u00a0?\n    strltb r4,[r1,r3]\n    addlt r3,#1\n    blt 1b\n    cmp r4,#122              @ > z\n    strgtb r4,[r1,r3]\n    addgt r3,#1\n    bgt 1b\n    sub r4,r2                @ substract key\n    cmp r4,#97               @ < a\n    addlt r4,#26\n    strb r4,[r1,r3]\n    add r3,#1\n    b 1b\n\n100:\n    pop {r3,r4,lr}           @ restaur registers\n    bx lr                    @ return\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "X86_Assembly", "code": "\nTranslation of: C custom implementation\nWorks with: GCC version 7.3.0 - Ubuntu 18.04 64-bit\n                                        # Author: Ettore Forigo - Hexwell\n\n.intel_syntax noprefix\n\n.text\n.globl main\nmain:\n.PROLOGUE:\n    push    rbp\n    mov rbp, rsp\n    sub rsp, 32\n    mov QWORD PTR [rbp-32], rsi         # argv\n    \n.BODY:\n    mov BYTE PTR [rbp-1], 0             # shift = 0\n\n    .I_LOOP_INIT:\n        mov BYTE PTR [rbp-2], 0         # i = 0\n        jmp .I_LOOP_CONDITION           # I_LOOP_CONDITION\n    .I_LOOP_BODY:\n        movzx edx, BYTE PTR[rbp-1]      # shift\n        mov eax, edx                    # shift\n        sal eax, 2                      # shift << 2 == i * 4\n        add eax, edx                    # shift * 4 + shift = shift * 5\n        add eax, eax                    # shift * 5 + shift * 5 = shift * 10\n        mov ecx, eax                    # shift * 10\n        mov rax, QWORD PTR [rbp-32]     # argv\n        add rax, 8                      # argv + 1\n        mov rdx, QWORD PTR [rax]        # argv[1]\n        movzx eax, BYTE PTR [rbp-2]     # i\n        add rax, rdx                    # argv[1] + i\n        movzx eax, BYTE PTR [rax]       # argv[1][i]\n        add eax, ecx                    # shift * 10 + argv[1][i]\n        sub eax, 48                     # shift * 10 + argv[1][i] - '0'\n        mov BYTE PTR [rbp-1], al        # shift = shift * 10 + argv[1][i] - '0'\n    .I_LOOP_INCREMENT:\n        movzx eax, BYTE PTR [rbp-2]     # i\n        add eax, 1                      # i + 1\n        mov BYTE PTR [rbp-2], al        # i++\n    .I_LOOP_CONDITION:\n        mov rax, QWORD PTR [rbp-32]     # argv\n        add rax, 8                      # argv + 1\n        mov rax, QWORD PTR [rax]        # argv[1]\n        movzx edx, BYTE PTR [rbp-2]     # i\n        add rax, rdx                    # argv[1] + i\n        movzx rax, BYTE PTR [rax]       # argv[1][i]\n        test al, al                     # argv[1][i]?\n        jne .I_LOOP_BODY                # I_LOOP_BODY\n\n    .CAESAR_LOOP_INIT:\n        mov BYTE PTR [rbp-2], 0         # i = 0\n        jmp .CAESAR_LOOP_CONDITION      # CAESAR_LOOP_CONDITION\n    .CAESAR_LOOP_BODY:\n        mov rax, QWORD PTR [rbp-32]     # argv\n        add rax, 16                     # argv + 2\n        mov rdx, QWORD PTR [rax]        # argv[2]\n        movzx eax, BYTE PTR [rbp-2]     # i\n        add rax, rdx                    # argv[2] + i\n        mov rbx, rax                    # argv[2] + i\n        movzx eax, BYTE PTR [rax]       # argv[2][i]\n        cmp al, 32                      # argv[2][i] == ' '\n        je .CAESAR_LOOP_INCREMENT       # CAESAR_LOOP_INCREMENT\n        movzx edx, BYTE PTR [rbx]       # argv[2][i]\n        mov ecx, edx                    # argv[2][i]\n        movzx edx, BYTE PTR [rbp-1]     # shift\n        add edx, ecx                    # argv[2][i] + shift\n        sub edx, 97                     # argv[2][i] + shift - 'a'\n        mov BYTE PTR [rbx], dl          # argv[2][i] = argv[2][i] + shift - 'a'\n        movzx eax, BYTE PTR [rbx]       # argv[2][i]\n        cmp al, 25                      # argv[2][i] <=> 25\n        jle .CAESAR_RESTORE_ASCII       # <= CAESAR_RESTORE_ASCII\n        movzx edx, BYTE PTR [rbx]       # argv[2][i]\n        sub edx, 26                     # argv[2][i] - 26\n        mov BYTE PTR [rbx], dl          # argv[2][i] = argv[2][i] - 26\n    .CAESAR_RESTORE_ASCII:\n        movzx edx, BYTE PTR [rbx]       # argv[2][i]\n        add edx, 97                     # argv[2][i] + 'a'\n        mov BYTE PTR [rbx], dl          # argv[2][i] = argv[2][i] + 'a'\n    .CAESAR_LOOP_INCREMENT:\n        movzx eax, BYTE PTR [rbp-2]     # i\n        add eax, 1                      # i + 1\n        mov BYTE PTR [rbp-2], al        # i++\n    .CAESAR_LOOP_CONDITION:\n        mov rax, QWORD PTR [rbp-32]     # argv\n        add rax, 16                     # argv + 2\n        mov rdx, QWORD PTR [rax]        # argv[2]\n        movzx eax, BYTE PTR [rbp-2]     # i\n        add rax, rdx                    # argv[2] + i\n        movzx eax, BYTE PTR [rax]       # argv[2][i]\n        test al, al                     # argv[2][i]?\n        jne .CAESAR_LOOP_BODY           # CAESAR_LOOP_BODY\n\n    mov rax, QWORD PTR [rbp-32]         # argv\n    add rax, 16                         # argv + 2\n    mov rax, QWORD PTR [rax]            # argv[2]\n    mov rdi, rax                        # argv[2]\n    call    puts                        # puts(argv[2])\n\n.RETURN:\n    mov eax, 0                          # 0\n    leave\n    ret                                 # return 0\n\n$ gcc caesar.S -o caesar\n$ ./caesar 10 abc\nklm\n$ ./caesar 16 klm\nabc\n", "explain": "Usage:\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Delphi", "code": "\n\n", "explain": "See #Pascal.\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Ruby", "code": "\nclass String\n  ALFABET = (\"A\"..\"Z\").to_a\n\n  def caesar_cipher(num)\n    self.tr(ALFABET.join, ALFABET.rotate(num).join)\n  end\n\nend\n\n#demo:\nencypted  = \"THEYBROKEOURCIPHEREVERYONECANREADTHIS\".caesar_cipher(3)\ndecrypted = encypted.caesar_cipher(-3)\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Rust", "code": "\n\nuse std::io::{self, Write};\nuse std::fmt::Display;\nuse std::{env, process};\n\nfn main() {\n    let shift: u8 = env::args().nth(1)\n        .unwrap_or_else(|| exit_err(\"No shift provided\", 2))\n        .parse()\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n    let plain = get_input()\n        .unwrap_or_else(|e| exit_err(&e, e.raw_os_error().unwrap_or(-1)));\n\n    let cipher = plain.chars()\n        .map(|c| {\n            let case = if c.is_uppercase() {'A'} else {'a'} as u8;\n            if c.is_alphabetic() { (((c as u8 - case + shift)\u00a0% 26) + case) as char } else { c }\n        }).collect::<String>();\n\n    println!(\"Cipher text: {}\", cipher.trim());\n}\n\n\nfn get_input() -> io::Result<String> {\n    print!(\"Plain text:  \");\n    try!(io::stdout().flush());\n\n    let mut buf = String::new();\n    try!(io::stdin().read_line(&mut buf));\n    Ok(buf)\n}\n\nfn exit_err<T: Display>(msg: T, code: i32) ->\u00a0! {\n    let _ = writeln!(&mut io::stderr(), \"ERROR: {}\", msg);\n    process::exit(code);\n}\n", "explain": "This example shows proper error handling. It skips non-ASCII characters.\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Swift", "code": "\nfunc usage(_ e:String) {\n  print(\"error: \\(e)\")\n  print(\"./caeser -e 19 a-secret-string\")\n  print(\"./caeser -d 19 tskxvjxlskljafz\")\n}\n\nfunc charIsValid(_ c:Character) -> Bool {\n  return c.isASCII && ( c.isLowercase || 45 == c.asciiValue ) // '-' = 45\n}\n\nfunc charRotate(_ c:Character, _ by:Int) -> Character {\n  var cv:UInt8! = c.asciiValue\n  if 45 == cv { cv = 96 }  // if '-', set it to 'a'-1\n  cv += UInt8(by)\n  if 122 < cv { cv -= 27 } // if larget than 'z', reduce by 27\n  if 96 == cv { cv = 45 }  // restore '-'\n  return Character(UnicodeScalar(cv))\n}\n\nfunc caesar(_ enc:Bool, _ key:Int, _ word:String) -> String {\n  let r = enc\u00a0? key\u00a0: 27 - key\n  func charRotateWithKey(_ c:Character) -> Character {\n    return charRotate(c,r)\n  }\n  return String(word.map(charRotateWithKey))\n}\n\nfunc main() {\n  var encrypt = true\n\n  if 4\u00a0!= CommandLine.arguments.count {\n    return usage(\"caesar expects exactly three arguments\")\n  }\n\n  switch ( CommandLine.arguments[1] ) {\n  case \"-e\":\n    encrypt = true\n  case \"-d\":\n    encrypt = false\n  default:\n    return usage(\"first argument must be -e (encrypt) or -d (decrypt)\")\n  }\n\n  guard let key = Int(CommandLine.arguments[2]) else {\n    return usage(\"second argument not a number (must be in range 0-26)\")\n  }\n\n  if key < 0 || 26 < key {\n    return usage(\"second argument not in range 0-26\")\n  }\n\n  if !CommandLine.arguments[3].allSatisfy(charIsValid) {\n    return usage(\"third argument must only be lowercase ascii characters, or -\")\n  }\n\n  let ans = caesar(encrypt,key,CommandLine.arguments[3])\n  print(\"\\(ans)\")\n}\n\nfunc test() {\n  if ( Character(\"a\")\u00a0!= charRotate(Character(\"a\"),0) ) {\n    print(\"Test Fail 1\")\n  }\n  if ( Character(\"-\")\u00a0!= charRotate(Character(\"-\"),0) ) {\n    print(\"Test Fail 2\")\n  }\n  if ( Character(\"-\")\u00a0!= charRotate(Character(\"z\"),1) ) {\n    print(\"Test Fail 3\")\n  }\n  if ( Character(\"z\")\u00a0!= charRotate(Character(\"-\"),26)) {\n    print(\"Test Fail 4\")\n  }\n  if ( \"ihgmkzma\"\u00a0!= caesar(true,8,\"a-zecret\") ) {\n    print(\"Test Fail 5\")\n  }\n  if ( \"a-zecret\"\u00a0!= caesar(false,8,\"ihgmkzma\") ) {\n    print(\"Test Fail 6\")\n  }\n}\n\ntest()\nmain()\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "R", "code": "\n\n# based on Rot-13 solution: http://rosettacode.org/wiki/Rot-13#R\nceasar <- function(x, key)\n{\n  # if key is negative, wrap to be positive\n  if (key < 0) {\n    key <- 26 + key \n  }\n  \n  old <- paste(letters, LETTERS, collapse=\"\", sep=\"\")\n  new <- paste(substr(old, key * 2 + 1, 52), substr(old, 1, key * 2), sep=\"\")\n  chartr(old, new, x)\n}\n\n# simple examples from description\nprint(ceasar(\"hi\",2))\nprint(ceasar(\"hi\",20))\n\n# more advanced example\nkey <- 3\nplaintext <- \"The five boxing wizards jump quickly.\"\ncyphertext <- ceasar(plaintext, key)\ndecrypted <- ceasar(cyphertext, -key)\n\nprint(paste(\"    Plain Text: \", plaintext, sep=\"\"))\nprint(paste(\"   Cypher Text: \", cyphertext, sep=\"\"))\nprint(paste(\"Decrypted Text: \", decrypted, sep=\"\"))\n\nOutput:\n> print(ceasar(\"hi\",2))\n[1] \"jk\"\n> print(ceasar(\"hi\",20))\n[1] \"bc\"\n> print(paste(\"Plain Text: \", plaintext, sep=\"\"))\n[1] \"Plain Text: The five boxing wizards jump quickly.\"\n> print(paste(\"Cypher Text: \", cyphertext, sep=\"\"))\n[1] \"Cypher Text: Wkh ilyh eralqj zlcdugv mxps txlfnob.\"\n> print(paste(\"Decrypted Text: \", decrypted, sep=\"\"))\n[1] \"Decrypted Text: The five boxing wizards jump quickly.\"\n\n", "explain": "This is a generalization of the Rot-13 solution for R at: http://rosettacode.org/wiki/Rot-13#R .\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "COBOL", "code": "\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. CAESAR.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  MSG        PIC X(50)\n           VALUE \"The quick brown fox jumped over the lazy dog.\".\n       01  OFFSET     PIC 9(4) VALUE 7 USAGE BINARY.\n       01  FROM-CHARS PIC X(52).\n       01  TO-CHARS   PIC X(52).\n       01  TABL.\n           02         PIC X(26) VALUE \"abcdefghijklmnopqrstuvwxyz\".\n           02         PIC X(26) VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n           02         PIC X(26) VALUE \"abcdefghijklmnopqrstuvwxyz\".\n           02         PIC X(26) VALUE \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\".\n\n       PROCEDURE DIVISION.\n       BEGIN.\n           DISPLAY MSG\n           PERFORM ENCRYPT\n           DISPLAY MSG\n           PERFORM DECRYPT\n           DISPLAY MSG\n           STOP RUN.\n\n       ENCRYPT.\n           MOVE TABL (1:52) TO FROM-CHARS\n           MOVE TABL (1 + OFFSET:52) TO TO-CHARS\n           INSPECT MSG CONVERTING FROM-CHARS TO TO-CHARS.\n\n       DECRYPT.\n           MOVE TABL (1 + OFFSET:52) TO FROM-CHARS\n           MOVE TABL (1:52) TO TO-CHARS\n           INSPECT MSG CONVERTING FROM-CHARS TO TO-CHARS.\n\n       END PROGRAM CAESAR.\n\n\nOutput:\nThe quick brown fox jumped over the lazy dog.\naol xBpjr iyvDu mvE qBtwlk vCly Aol shGF kvn.\nThe quick brown fox jumped over the lazy dog.\n\nWorks with: COBOL 2002\n       >>SOURCE FORMAT IS FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. caesar-cipher.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encrypt\n    FUNCTION decrypt.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  plaintext                 PIC X(50).\n01  offset                    USAGE BINARY-CHAR.\n01  encrypted-str             PIC X(50).\n\nPROCEDURE DIVISION.\n    DISPLAY \"Enter a message to encrypt: \" WITH NO ADVANCING\n    ACCEPT plaintext\n    DISPLAY \"Enter the amount to shift by: \" WITH NO ADVANCING\n    ACCEPT offset\n    MOVE encrypt(offset, plaintext) TO encrypted-str\n    DISPLAY \"Encrypted: \" encrypted-str\n    DISPLAY \"Decrypted: \" decrypt(offset, encrypted-str).\n\nEND PROGRAM caesar-cipher.\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. encrypt.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION ALL INTRINSIC.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  i                         USAGE INDEX.\n01  a                         USAGE BINARY-CHAR.\nLINKAGE SECTION.\n01  offset                    USAGE BINARY-CHAR.\n01  str                       PIC X(50).\n01  encrypted-str             PIC X(50).\n\nPROCEDURE DIVISION USING offset, str RETURNING encrypted-str.\n    PERFORM VARYING i FROM 1 BY 1 UNTIL i > LENGTH(str)\n        IF str(i:1) IS NOT ALPHABETIC OR str(i:1) = SPACE\n            MOVE str(i:1) TO encrypted-str(i:1)\n            EXIT PERFORM CYCLE\n        END-IF\n        IF str(i:1) IS ALPHABETIC-UPPER\n            MOVE ORD(\"A\") TO a\n        ELSE\n            MOVE ORD(\"a\") TO a\n        END-IF\n        MOVE CHAR(MOD(ORD(str(i:1)) - a + offset, 26) + a)\n            TO encrypted-str(i:1)\n    END-PERFORM\n    EXIT FUNCTION.\n\nEND FUNCTION encrypt.\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. decrypt.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encrypt.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  decrypt-offset            USAGE BINARY-CHAR.\nLINKAGE SECTION.\n01  offset                    USAGE BINARY-CHAR.\n01  str                       PIC X(50).\n01  decrypted-str             PIC X(50).\n\nPROCEDURE DIVISION USING offset, str RETURNING decrypted-str.\n    SUBTRACT offset FROM 26 GIVING decrypt-offset\n    MOVE encrypt(decrypt-offset, str) TO decrypted-str\n    EXIT FUNCTION.\n\nEND FUNCTION decrypt.\n\n\nOutput:\nEnter a message to encrypt: The quick brown fox jumps over the lazy dog.\nEnter the amount to shift by: 7\nEncrypted: Aol xbpjr iyvdu mve qbtwz vcly aol shgf kvn.      \nDecrypted: The quick brown fox jumps over the lazy dog.     \n\n", "explain": "COBOL-85 ASCII or EBCIDIC\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Caesar is\n\n   type modulo26 is modulo 26;\n\n   function modulo26 (Character: Character; Output: Character) return modulo26 is\n   begin\n      return modulo26 (Character'Pos(Character)+Character'Pos(Output));\n   end modulo26;\n\n   function Character(Val: in  modulo26; Output: Character)\n                        return Character is\n   begin\n      return Character'Val(Integer(Val)+Character'Pos(Output));\n   end Character;\n\n   function crypt (Playn: String; Key: modulo26) return String is\n      Ciph: String(Playn'Range);\n\n   begin\n      for I in Playn'Range loop\n         case Playn(I) is\n            when 'A' .. 'Z' =>\n               Ciph(I) := Character(modulo26(Playn(I)+Key), 'A');\n            when 'a' .. 'z' =>\n               Ciph(I) := Character(modulo26(Playn(I)+Key), 'a');\n            when others =>\n               Ciph(I) := Playn(I);\n         end case;\n      end loop;\n      return Ciph;\n   end crypt;\n\n   Text:  String := Ada.Text_IO.Get_Line;\n   Key: modulo26 := 3; -- Default key from \"Commentarii de Bello Gallico\" shift cipher\n\nbegin -- encryption main program\n\n   Ada.Text_IO.Put_Line(\"Playn ------------>\" & Text);\n   Text := crypt(Text, Key);\n   Ada.Text_IO.Put_Line(\"Ciphertext ----------->\" & Text);\n   Ada.Text_IO.Put_Line(\"Decrypted Ciphertext ->\" & crypt(Text, -Key));\n\nend Caesar;\n\n\nOutput:\n> ./caesar \nThe five boxing wizards jump quickly\nPlaintext ------------>The five boxing wizards jump quickly\nCiphertext ----------->Wkh ilyh eralqj zlcdugv mxps txlfnob\nDecrypted Ciphertext ->The five boxing wizards jump quickly\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Julia", "code": "\nupdated version for Julia 1.x | Rename isalpha to isletter #27077 | https://github.com/JuliaLang/julia/pull/27077[edit]\n# Caeser cipher\n# Julia 1.5.4\n# author: manuelcaeiro | https://github.com/manuelcaeiro\n\nfunction csrcipher(text, key)\n    ciphtext = \"\"\n    for l in text\n        numl = Int(l)\n        ciphnuml = numl + key\n        if numl in 65:90\n            if ciphnuml > 90\n                rotciphnuml = ciphnuml - 26\n                ciphtext = ciphtext * Char(rotciphnuml)\n            else\n                ciphtext = ciphtext * Char(ciphnuml)\n            end\n        elseif numl in 97:122\n            if ciphnuml > 122\n                rotciphnuml = ciphnuml - 26\n                ciphtext = ciphtext * Char(rotciphnuml)\n            else\n                ciphtext = ciphtext * Char(ciphnuml)\n            end\n        else\n            ciphtext = ciphtext * Char(numl)\n        end\n    end\n    return ciphtext\nend\n\ntext = \"Magic Encryption\"; key = 13\ncsrcipher(text, key)\n\n\nOutput:\n\"Zntvp Rapelcgvba\"\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Kotlin", "code": "\n// version 1.0.5-2\n\nobject Caesar {\n    fun encrypt(s: String, key: Int): String {\n        val offset = key % 26\n        if (offset == 0) return s\n        var d: Char\n        val chars = CharArray(s.length) \n        for ((index, c) in s.withIndex()) {\n            if (c in 'A'..'Z') {\n                d = c + offset\n                if (d > 'Z') d -= 26\n            }\n            else if (c in 'a'..'z') {\n                d = c + offset\n                if (d > 'z') d -= 26\n            }\n            else\n                d = c\n            chars[index] = d\n        } \n        return chars.joinToString(\"\")\n    }\n    \n    fun decrypt(s: String, key: Int): String {\n        return encrypt(s, 26 - key)\n    }\n}\n\nfun main(args: Array<String>) {\n    val encoded = Caesar.encrypt(\"Bright vixens jump; dozy fowl quack.\", 8)\n    println(encoded)\n    val decoded = Caesar.decrypt(encoded, 8)\n    println(decoded)\n}\n\n\nOutput:\nJzqopb dqfmva rcux; lwhg nwet yciks.\nBright vixens jump; dozy fowl quack.\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Perl", "code": "\nsub caesar {\n        my ($message, $key, $decode) = @_;\n        $key = 26 - $key if $decode;\n        $message =~ s/([A-Z])/chr(((ord(uc $1) - 65 + $key)\u00a0% 26) + 65)/geir;\n}\n \nmy $msg = 'THE FIVE BOXING WIZARDS JUMP QUICKLY';\nmy $enc = caesar($msg, 10);\nmy $dec = caesar($enc, 10, 'decode');\n \nprint \"msg: $msg\\nenc: $enc\\ndec: $dec\\n\";\n\n\nOutput:\nmsg: THE FIVE BOXING WIZARDS JUMP QUICKLY\nenc: DRO PSFO LYHSXQ GSJKBNC TEWZ AESMUVI\ndec: THE FIVE BOXING WIZARDS JUMP QUICKLY\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog\nLibrary: clpfd\n:- use_module(library(clpfd)).\n\ncaesar :-\n\tL1 = \"The five boxing wizards jump quickly\",\n\twritef(\"Original\u00a0: %s\\n\", [L1]),\n\n\t% encryption of the sentence\n\tencoding(3, L1, L2) ,\n\twritef(\"Encoding\u00a0: %s\\n\", [L2]),\n\n\t% deciphering on the encoded sentence\n\tencoding(3, L3, L2),\n\twritef(\"Decoding\u00a0: %s\\n\", [L3]).\n\n% encoding/decoding of a sentence\nencoding(Key, L1, L2) :-\n\tmaplist(caesar_cipher(Key), L1, L2).\n\ncaesar_cipher(_, 32, 32) :- !.\n\ncaesar_cipher(Key, V1, V2) :-\n\tV #= Key + V1,\n\n\t% we verify that we are in the limits of A-Z and a-z.\n\t((V1 #=< 0'Z #/\\ V #> 0'Z) #\\/ (V1 #=< 0'z #/\\ V #> 0'z)\n\t#\\/\n\t(V1 #< 0'A #/\\ V2 #>= 0'A)#\\/ (V1 #< 0'a #/\\ V2 #>= 0'a)) #==> A,\n\n\t% if we are not in these limits A is 1, otherwise 0.\n\tV2 #= V - A * 26,\n\n\t% compute values of V1 and V2\n\tlabel([A, V1, V2]).\n\n\nOutput:\n\u00a0?- caesar.\nOriginal\u00a0: The five boxing wizards jump quickly\nEncoding\u00a0: Wkh ilyh eralqj zlcdugv mxps txlfnob\nDecoding\u00a0: The five boxing wizards jump quickly\ntrue .\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Lua", "code": "\nlocal function encrypt(text, key)\n\treturn text:gsub(\"%a\", function(t)\n\t\t\tlocal base = (t:lower() == t and string.byte('a') or string.byte('A'))\n\n\t\t\tlocal r = t:byte() - base\n\t\t\tr = r + key\n\t\t\tr = r%26 -- works correctly even if r is negative\n\t\t\tr = r + base\n\t\t\treturn string.char(r)\n\t\tend)\nend\n\nlocal function decrypt(text, key)\n\treturn encrypt(text, -key)\nend\n\ncaesar = {\n\tencrypt = encrypt,\n\tdecrypt = decrypt,\n}\n\n-- test\ndo\n\tlocal text = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ abcdefghijklmnopqrstuvwxyz\"\n\tlocal encrypted = caesar.encrypt(text, 7)\n\tlocal decrypted = caesar.decrypt(encrypted, 7)\n\tprint(\"Original text:  \", text)\n\tprint(\"Encrypted text: \", encrypted)\n\tprint(\"Decrypted text: \", decrypted)\nend\n\n\nlocal memo = {}\n\nlocal function make_table(k)\n    local t = {}\n    local a, A = ('a'):byte(), ('A'):byte()\n\n    for i = 0,25 do\n        local  c = a + i\n        local  C = A + i\n        local rc = a + (i+k) % 26\n        local RC = A + (i+k) % 26\n        t[c], t[C] = rc, RC\n    end\n\n    return t\nend\n\nlocal function caesar(str, k, decode)\n    k = (decode and -k or k) % 26\n\n    local t = memo[k]\n    if not t then\n        t = make_table(k)\n        memo[k] = t\n    end\n\n    local res_t = { str:byte(1,-1) }\n    for i,c in ipairs(res_t) do\n        res_t[i] = t[c] or c\n    end\n    return string.char(unpack(res_t))\nend\n\n", "explain": "\nFast version\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Scala", "code": "\nobject Caesar {\n  private val alphaU='A' to 'Z'\n  private val alphaL='a' to 'z'\n\n  def encode(text:String, key:Int)=text.map{\n    case c if alphaU.contains(c) => rot(alphaU, c, key)\n    case c if alphaL.contains(c) => rot(alphaL, c, key)\n    case c => c\n  }\n  def decode(text:String, key:Int)=encode(text,-key)\n  private def rot(a:IndexedSeq[Char], c:Char, key:Int)=a((c-a.head+key+a.size)%a.size)\n}\nval text=\"The five boxing wizards jump quickly\"\nprintln(\"Plaintext  => \" + text)\nval encoded=Caesar.encode(text, 3)\nprintln(\"Ciphertext => \" + encoded)\nprintln(\"Decrypted  => \" + Caesar.decode(encoded, 3))\n\nOutput:\nPlaintext  => The five boxing wizards jump quickly\nCiphertext => Wkh ilyh eralqj zlcdugv mxps txlfnob\nDecrypted  => The five boxing wizards jump quickly\nAlternate version[edit]\n\nclass Caeser(val key: Int) {\n  @annotation.tailrec\n  private def rotate(p: Int, s: IndexedSeq[Char]): IndexedSeq[Char] = if (p < 0) rotate(s.length + p, s) else s.drop(p) ++ s.take(p)\n\n  val uc = 'A' to 'Z'\n  val lc = 'a' to 'z'\n  val as = uc ++ lc\n  val bs = rotate(key, uc) ++ rotate(key, lc)\n  \n  def encode(c: Char) = if (as.contains(c)) bs(as.indexOf(c)) else c\n  def decode(c: Char) = if (bs.contains(c)) as(bs.indexOf(c)) else c\n}\nval text = \"The five boxing wizards jump quickly\"\nval myCaeser = new Caeser(3)\nval encoded = text.map(c => myCaeser.encode(c))\nprintln(\"Plaintext => \" + text)\nprintln(\"Ciphertext => \" + encoded)\nprintln(\"Decrypted => \" + encoded.map(c => myCaeser.decode(c)))\n\nOutput:\nPlaintext => The five boxing wizards jump quickly\nCiphertext => Wkh ilyh eralqj zlcdugv mxps txlfnob\nDecrypted => The five boxing wizards jump quickly\n", "explain": "This version first creates non shifted and shifted character sequences \nand then encodes and decodes by indexing between those sequences.\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Dart", "code": "\nclass Caesar {\n  int _key;\n\n  Caesar(this._key);\n\n  int _toCharCode(String s) {\n    return s.charCodeAt(0);\n  }\n\n  String _fromCharCode(int ch) {\n    return new String.fromCharCodes([ch]);\n  }\n\n  String _process(String msg, int offset) {\n    StringBuffer sb=new StringBuffer();\n    for(int i=0;i<msg.length;i++) {\n      int ch=msg.charCodeAt(i);\n      if(ch>=_toCharCode('A')&&ch<=_toCharCode('Z')) {\n        sb.add(_fromCharCode(_toCharCode(\"A\")+(ch-_toCharCode(\"A\")+offset)%26));\n      }\n      else if(ch>=_toCharCode('a')&&ch<=_toCharCode('z')) {\n        sb.add(_fromCharCode(_toCharCode(\"a\")+(ch-_toCharCode(\"a\")+offset)%26));\n      } else {\n        sb.add(msg[i]);\n      }\n    }\n    return sb.toString();\n  }\n\n  String encrypt(String msg) {\n    return _process(msg, _key);\n  }\n\n  String decrypt(String msg) {\n    return _process(msg, 26-_key);\n   }\n}\n\nvoid trip(String msg) {\n  Caesar cipher=new Caesar(10);\n\n  String enc=cipher.encrypt(msg);\n  String dec=cipher.decrypt(enc);\n  print(\"\\\"$msg\\\" encrypts to:\");\n  print(\"\\\"$enc\\\" decrypts to:\");\n  print(\"\\\"$dec\\\"\");\n  Expect.equals(msg,dec);\n}\n\nmain() {\n  Caesar c2=new Caesar(2);\n  print(c2.encrypt(\"HI\"));\n  Caesar c20=new Caesar(20);\n  print(c20.encrypt(\"HI\"));\n\n  // try a few roundtrips\n\n  trip(\"\");\n  trip(\"A\");\n  trip(\"z\");\n  trip(\"Caesar cipher\");\n  trip(\".-:/\\\"\\\\!\");\n  trip(\"The Quick Brown Fox Jumps Over The Lazy Dog.\");\n}\n\n\nOutput:\nJK\nBC\n\"\" encrypts to:\n\"\" decrypts to:\n\"\"\n\"A\" encrypts to:\n\"K\" decrypts to:\n\"A\"\n\"z\" encrypts to:\n\"j\" decrypts to:\n\"z\"\n\"Caesar cipher\" encrypts to:\n\"Mkockb mszrob\" decrypts to:\n\"Caesar cipher\"\n\".-:/\"\\!\" encrypts to:\n\".-:/\"\\!\" decrypts to:\n\".-:/\"\\!\"\n\"The Quick Brown Fox Jumps Over The Lazy Dog.\" encrypts to:\n\"Dro Aesmu Lbygx Pyh Tewzc Yfob Dro Vkji Nyq.\" decrypts to:\n\"The Quick Brown Fox Jumps Over The Lazy Dog.\"\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "D", "code": "\nimport std.stdio, std.traits;\n\nS rot(S)(in S s, in int key) pure nothrow @safe\nif (isSomeString!S) {\n    auto res = s.dup;\n\n    foreach (immutable i, ref c; res) {\n        if ('a' <= c && c <= 'z')\n            c = ((c - 'a' + key) % 26 + 'a');\n        else if ('A' <= c && c <= 'Z')\n            c = ((c - 'A' + key) % 26 + 'A');\n    }\n    return res;\n}\n\nvoid main() @safe {\n    enum key = 3;\n    immutable txt = \"The five boxing wizards jump quickly\";\n    writeln(\"Original:  \", txt);\n    writeln(\"Encrypted: \", txt.rot(key));\n    writeln(\"Decrypted: \", txt.rot(key).rot(26 - key));\n}\n\n\nOutput:\nOriginal:  The five boxing wizards jump quickly\nEncrypted: Wkh ilyh eralqj zlcdugv mxps txlfnob\nDecrypted: The five boxing wizards jump quickly\n\nimport std.stdio, std.ascii;\n\nvoid inplaceRot(char[] txt, in int key) pure nothrow {\n    foreach (ref c; txt) {\n        if (isLower(c))\n            c = (c - 'a' + key) % 26 + 'a';\n        else if (isUpper(c))\n            c = (c - 'A' + key) % 26 + 'A';\n    }\n}\n\nvoid main() {\n    enum key = 3;\n    auto txt = \"The five boxing wizards jump quickly\".dup;\n    writeln(\"Original:  \", txt);\n    txt.inplaceRot(key);\n    writeln(\"Encrypted: \", txt);\n    txt.inplaceRot(26 - key);\n    writeln(\"Decrypted: \", txt);\n}\n\n\nimport std.stdio, std.ascii, std.string, std.algorithm;\n\nstring rot(in string s, in int key) pure nothrow @safe {\n    auto uppr = uppercase.dup.representation;\n    bringToFront(uppr[0 .. key], uppr[key .. $]);\n    auto lowr = lowercase.dup.representation;\n    bringToFront(lowr[0 .. key], lowr[key .. $]);\n    return s.translate(makeTrans(letters, assumeUTF(uppr ~ lowr)));\n}\n\nvoid main() {\n    enum key = 3;\n    immutable txt = \"The five boxing wizards jump quickly\";\n    writeln(\"Original:  \", txt);\n    writeln(\"Encrypted: \", txt.rot(key));\n    writeln(\"Decrypted: \", txt.rot(key).rot(26 - key));\n}\n\n", "explain": "Simpler in-place version (same output):\nA version that uses the standard library (same output):\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Haskell", "code": "\nmodule Caesar (caesar, uncaesar) where \n\nimport Data.Char\n\ncaesar, uncaesar :: (Integral a) => a -> String -> String\ncaesar k = map f\n    where f c = case generalCategory c of\n              LowercaseLetter -> addChar 'a' k c\n              UppercaseLetter -> addChar 'A' k c\n              _               -> c\nuncaesar k = caesar (-k)\n\naddChar :: (Integral a) => Char -> a -> Char -> Char\naddChar b o c = chr $ fromIntegral (b' + (c' - b' + o) `mod` 26)\n    where b' = fromIntegral $ ord b\n          c' = fromIntegral $ ord c\n\n\n*Main> caesar 1 \"hal\"\n\"ibm\"\n*Main> unCaesar 1 \"ibm\"\n\"hal\"\n\n\nimport Data.Bool (bool)\nimport Data.Char (chr, isAlpha, isUpper, ord)\n\n---------------------- CAESAR CIPHER ---------------------\n\ncaesar, uncaesar :: Int -> String -> String\ncaesar = fmap . tr\nuncaesar = caesar . negate\n\ntr :: Int -> Char -> Char\ntr offset c\n  | isAlpha c =\n      chr\n        . ((+) <*> (flip mod 26 . (-) (offset + ord c)))\n        $ bool 97 65 (isUpper c)\n  | otherwise = c\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = do\n  let k = -114\n      cipher = caesar k\n      plain = \"Curio, Cesare venne, e vide e vinse\u00a0? \"\n  mapM_ putStrLn $ [cipher, uncaesar k . cipher] <*> [plain]\n\n\nOutput:\nSkhye, Suiqhu luddu, u lytu u lydiu\u00a0? \nCurio, Cesare venne, e vide e vinse\u00a0? \n\n{-# LANGUAGE LambdaCase #-}\nmodule Main where\n\nimport Control.Error (tryRead, tryAt)\nimport Control.Monad.Trans (liftIO)\nimport Control.Monad.Trans.Except (ExceptT, runExceptT)\n\nimport Data.Char \nimport System.Exit (die)\nimport System.Environment (getArgs)\n\nmain :: IO ()\nmain = runExceptT parseKey >>= \\case\n           Left err -> die err\n           Right k  -> interact $ caesar k\n\nparseKey :: (Read a, Integral a) => ExceptT String IO a\nparseKey = liftIO getArgs >>= \n           flip (tryAt \"Not enough arguments\") 0 >>= \n           tryRead \"Key is not a valid integer\"\n    \ncaesar :: (Integral a) => a -> String -> String\ncaesar k = map f\n    where f c = case generalCategory c of\n              LowercaseLetter -> addChar 'a' k c\n              UppercaseLetter -> addChar 'A' k c\n              _               -> c\n\naddChar :: (Integral a) => Char -> a -> Char -> Char\naddChar b o c = chr $ fromIntegral (b' + (c' - b' + o) `mod` 26)\n    where b' = fromIntegral $ ord b\n          c' = fromIntegral $ ord c\n\n", "explain": "And trying it out in GHCi:\nSimilarly, but allowing for negative cipher keys, and using isAlpha, isUpper, negate:\nOr with proper error handling:\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "VBScript", "code": "\n\n \n\tstr = \"IT WAS THE BEST OF TIMES, IT WAS THE WORST OF TIMES.\"\n\n\tWscript.Echo str\n\tWscript.Echo Rotate(str,5)\n\tWscript.Echo Rotate(Rotate(str,5),-5)\n\n\t'Rotate (Caesar encrypt/decrypt) test <numpos> positions.\n\t'  numpos < 0 - rotate left\n\t'  numpos > 0 - rotate right\n\t'Left rotation is converted to equivalent right rotation\n\n\tFunction Rotate (text, numpos)\n\n\t\tdim dic: set dic = CreateObject(\"Scripting.Dictionary\")\n\t\tdim ltr: ltr = Split(\"A B C D E F G H I J K L M N O P Q R S T U V W X Y Z\")\n\t\tdim rot: rot = (26 + numpos Mod 26) Mod 26 'convert all to right rotation\n\t\tdim ch\n\t\tdim i\n\n\t\tfor i = 0 to ubound(ltr)\n\t\t\tdic(ltr(i)) = ltr((rot+i) Mod 26)\n\t\tnext\n\n\t\tRotate = \"\"\n\n\t\tfor i = 1 to Len(text)\n\t\t\tch = Mid(text,i,1)\n\t\t\tif dic.Exists(ch) Then\n\t\t\t\tRotate = Rotate & dic(ch)\n\t\t\telse\n\t\t\t\tRotate = Rotate & ch\n\t\t\tend if\n\t\tnext\n\n\tEnd Function\n\nOutput:\nD:\\script>Caesar.vbs\nIT WAS THE BEST OF TIMES, IT WAS THE WORST OF TIMES.\nNY BFX YMJ GJXY TK YNRJX, NY BFX YMJ BTWXY TK YNRJX.\nIT WAS THE BEST OF TIMES, IT WAS THE WORST OF TIMES.\n\n", "explain": "Note that a left rotation has an equivalent right rotation so all rotations are converted to the equivalent right rotation prior to translation.\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Scheme", "code": "\n;\n; Works with R7RS-compatible Schemes (e.g. Chibi).\n; Also current versions of Chicken, Gauche and Kawa.\n;\n(cond-expand\n  (chicken (use srfi-13))\n  (gauche  (use srfi-13))\n  (kawa    (import (srfi :13)))\n  (else    (import (scheme base) (scheme write))))\u00a0; R7RS\n\n\n(define msg \"The quick brown fox jumps over the lazy dog.\")\n(define key 13)\n\n(define (caesar char)\n  (define A (char->integer #\\A))\n  (define Z (char->integer #\\Z))\n  (define a (char->integer #\\a))\n  (define z (char->integer #\\z))\n  (define c (char->integer char))\n  (integer->char\n    (cond ((<= A c Z) (+ A (modulo (+ key (- c A)) 26)))\n          ((<= a c z) (+ a (modulo (+ key (- c a)) 26)))\n          (else c))))\u00a0; Return other characters verbatim.\n\n(display (string-map caesar msg))\n(newline)\n\nOutput:\nGur dhvpx oebja sbk whzcf bire gur ynml qbt.\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "TypeScript", "code": "\nfunction replace(input: string, key: number)\u00a0: string {\n\treturn input.replace(/([a-z])/g, \n\t\t($1) => String.fromCharCode(($1.charCodeAt(0) + key + 26 - 97)\u00a0% 26 + 97)\n\t\t).replace(/([A-Z])/g, \n\t\t($1) => String.fromCharCode(($1.charCodeAt(0) + key + 26 - 65)\u00a0% 26 + 65));\n}\n\n// test\nvar str = 'The five boxing wizards jump quickly';\nvar encoded = replace(str, 3);\nvar decoded = replace(encoded, -3);\n\nconsole.log('Enciphered: ' + encoded);\nconsole.log('Deciphered: ' + decoded);\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "PowerShell", "code": "\n# Author: M. McNabb\nfunction Get-CaesarCipher\n{\nParam\n(\n[Parameter(\nMandatory=$true,ValueFromPipeline=$true)]\n[string]\n$Text,\n\n[ValidateRange(1,25)]\n[int]\n$Key = 1,\n\n[switch]\n$Decode\n)\n\nbegin\n{    \n    $LowerAlpha = [char]'a'..[char]'z'\n    $UpperAlpha = [char]'A'..[char]'Z'\n}\n\nprocess\n{\n    $Chars = $Text.ToCharArray()\n    \n    function encode\n    {\n        param\n        (\n        $Char,\n        $Alpha = [char]'a'..[char]'z'\n        )\n        $Index = $Alpha.IndexOf([int]$Char)\n        $NewIndex = ($Index + $Key) - $Alpha.Length\n        $Alpha[$NewIndex]\n    }\n    \n    function decode\n    {\n        param\n        (\n        $Char,\n        $Alpha = [char]'a'..[char]'z'\n        )\n        $Index = $Alpha.IndexOf([int]$Char)\n        $int = $Index - $Key\n        if ($int -lt 0) {$NewIndex = $int + $Alpha.Length}\n        else {$NewIndex = $int}\n        $Alpha[$NewIndex]\n    }\n\n    foreach ($Char in $Chars)\n    {\n        if ([int]$Char -in $LowerAlpha)\n        {\n            if ($Decode) {$Char = decode $Char}\n            else {$Char = encode $Char}\n        }\n        elseif ([int]$Char -in $UpperAlpha)\n        {\n            if ($Decode) {$Char = decode $Char $UpperAlpha}\n            else {$Char = encode $Char $UpperAlpha}\n        }\n        \n        $Char = [char]$Char\n        [string]$OutText += $Char\n    }\n\n    $OutText\n    $OutText = $null\n}\n}\n\n\nEncode:\nPS C:\\> 'Pack my box with five dozen liquor jugs.' | Get-CaesarCipher -key 3\nSdfn pb era zlwk ilyh grchq oltxru mxjv.\n\nDecode:\nPS C:\\> 'Sdfn pb era zlwk ilyh grchq oltxru mxjv.' | Get-CaesarCipher -key 3 -Decode\nPack my box with five dozen liquor jugs.\n\nEncode lines of text from a file:\nPS C:\\> Get-Content C:\\Text.txt | Get-CaesarCipher -key 10\nVsxo yxo.\nVsxo dgy!\nVsxo drboo;\n\n", "explain": "Usage examples:\n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Logo", "code": "\nTranslation of: Common Lisp\nWorks with: UCB Logo\n; some useful constants\nmake \"lower_a ascii \"a\nmake \"lower_z ascii \"z\nmake \"upper_a ascii \"A\nmake \"upper_z ascii \"Z\n\n; encipher a single character\nto encipher_char :char :key\n local \"code make \"code ascii :char\n local \"base make \"base 0\n ifelse [and (:code >= :lower_a) (:code <= :lower_z)] [make \"base :lower_a] [\n     if [and (:code >= :upper_a) (:code <= :upper_z)] [make \"base :upper_a] ]\n ifelse [:base > 0] [\n   output char (:base + (modulo ( :code - :base + :key ) 26 ))\n ] [\n   output :char\n ]\nend\n\n; encipher a whole string\nto caesar_cipher :string :key\n  output map [encipher_char\u00a0? :key] :string\nend\n\n; Demo\nmake \"plaintext \"|The five boxing wizards jump quickly|\nmake \"key 3\nmake \"ciphertext caesar_cipher :plaintext :key\nmake \"recovered  caesar_cipher :ciphertext -:key\n\nprint sentence \"| Original:| :plaintext\nprint sentence \"|Encrypted:| :ciphertext\nprint sentence \"|Recovered:| :recovered\nbye\n\nOutput:\n Original: The five boxing wizards jump quickly\nEncrypted: Wkh ilyh eralqj zlcdugv mxps txlfnob\nRecovered: The five boxing wizards jump quickly\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "F#", "code": "\nmodule caesar =\n    open System\n\n    let private cipher n s =\n        let shift c =\n            if Char.IsLetter c then\n                let a = (if Char.IsLower c then 'a' else 'A') |> int\n                (int c - a + n) % 26 + a |> char\n            else c\n        String.map shift s\n\n    let encrypt n = cipher n\n    let decrypt n = cipher (26 - n)\n\n> caesar.encrypt 2 \"HI\";;\nval it\u00a0: string = \"JK\"\n> caesar.encrypt 20 \"HI\";;\nval it\u00a0: string = \"BC\"\n> let c = caesar.encrypt 13 \"The quick brown fox jumps over the lazy dog.\";;\nval c\u00a0: string = \"Gur dhvpx oebja sbk whzcf bire gur ynml qbt.\"\n> caesar.decrypt 13 c;;\nval it\u00a0: string = \"The quick brown fox jumps over the lazy dog.\"\n\n", "explain": ""}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "Groovy", "code": "\n\ndef caesarEncode(\u200bcipherKey, text) {\n    def builder = new StringBuilder()\n    text.each { character ->\n        int ch = character[0] as char\n        switch(ch) {\n            case 'a'..'z': ch = ((ch - 97 + cipherKey) % 26 + 97); break\n            case 'A'..'Z': ch = ((ch - 65 + cipherKey) % 26 + 65); break\n        }\n        builder << (ch as char)\n    } \n    builder as String\n}\ndef caesarDecode(cipherKey, text) { caesarEncode(26 - cipherKey, text) }\n\n\ndef caesarEncode(cipherKey, text) {            \n    text.chars.collect { c -> \n        int off = c.isUpperCase() ? 'A' : 'a'\n        c.isLetter() ? (((c as int) - off + cipherKey) % 26 + off) as char : c \n    }.join()    \n}   \ndef caesarDecode(cipherKey, text) { caesarEncode(26 - cipherKey, text) }\n\n\ndef caesarEncode(k, text) { \n    (text as int[]).collect { it==' ' ? ' ' : (((it & 0x1f) + k - 1) % 26 + 1 | it & 0xe0) as char }.join()\n}   \ndef caesarDecode(k, text) { caesarEncode(26 - k, text) }\n\n\ndef caesarEncode(k, text) {\n    text.tr('a-zA-Z', ((('a'..'z')*2)[k..(k+25)] + (('A'..'Z')*2)[k..(k+25)]).join())\n}\ndef caesarDecode(cipherKey, text) { caesarEncode(26 - cipherKey, text) }\n\n\ndef caesarEncode(k, text) {\n    def c = { (it*2)[k..(k+25)].join() }\n    text.tr('a-zA-Z', c('a'..'z') + c('A'..'Z'))\n}\ndef caesarDecode(cipherKey, text) { caesarEncode(26 - cipherKey, text) }\n\n\ndef plainText = \"The Quick Brown Fox jumped over the lazy dog\"\ndef cipherKey = 12\ndef cipherText = caesarEncode(cipherKey, plainText)\ndef decodedText = caesarDecode(cipherKey, cipherText)\n \nprintln \"plainText: $plainText\"\nprintln \"cypherText($cipherKey): $cipherText\"\nprintln \"decodedText($cipherKey): $decodedText\"\n \nassert  plainText == decodedText\n\n\nOutput:\nplainText: The Quick Brown Fox jumped over the lazy dog\ncypherText(12): Ftq Cguow Ndaiz Raj vgybqp ahqd ftq xmlk pas\ndecodedText(12): The Quick Brown Fox jumped over the lazy dog\n", "explain": "Java style:\nFunctional style: \nNinja style: \nUsing built in 'tr' function and a replacement alphabet: \nand the same with closures for somewhat better readability:\nTest code: \n"}, {"task_name": "Caesar cipher", "task_url": "https://rosettacode.org/wiki/Caesar_cipher", "task_cat": "Encryption", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\n\nBEGIN {\n    message = \"My hovercraft is full of eels.\"\n    key = 1\n\n    cypher = caesarEncode(key, message)\n    clear  = caesarDecode(key, cypher)\n\n    print \"message: \" message\n    print \" cypher: \" cypher\n    print \"  clear: \" clear\n    exit\n}\n\nfunction caesarEncode(key, message) {\n    return caesarXlat(key, message, \"encode\")\n}\n\nfunction caesarDecode(key, message) {\n    return caesarXlat(key, message, \"decode\")\n}\n\nfunction caesarXlat(key, message, dir,    plain, cypher, i, num, s) {\n    plain = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    cypher = substr(plain, key+1) substr(plain, 1, key)\n\n    if (toupper(substr(dir, 1, 1)) == \"D\") {\n        s = plain\n        plain = cypher\n        cypher = s\n    }\n\n    s = \"\"\n    message = toupper(message)\n    for (i = 1; i <= length(message); i++) {\n        num = index(plain, substr(message, i, 1))\n        if (num) s = s substr(cypher, num, 1)\n        else s = s substr(message, i, 1)\n    }\n    return s\n}\n\n\nOutput:\nmessage: My hovercraft is full of eels.\n cypher: NZ IPWFSDSBGU JT GVMM PG FFMT.\n  clear: MY HOVERCRAFT IS FULL OF EELS.\n\n", "explain": ""}]