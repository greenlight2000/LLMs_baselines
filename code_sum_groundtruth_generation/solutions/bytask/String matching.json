[{"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Python", "code": "\n\"abcd\".startswith(\"ab\") #returns True\n\"abcd\".endswith(\"zn\") #returns False\n\"bb\" in \"abab\" #returns False\n\"ab\" in \"abab\" #returns True\nloc = \"abab\".find(\"bb\") #returns -1\nloc = \"abab\".find(\"ab\") #returns 0\nloc = \"abab\".find(\"ab\",loc+1) #returns 2\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "C", "code": "\n\n#include <string.h>\n#include <stdio.h>\n\nint startsWith(const char* container, const char* target)\n{\n  size_t clen = strlen(container), tlen = strlen(target);\n  if (clen < tlen)\n    return 0;\n  return strncmp(container, target, tlen) == 0;\n}\n\nint endsWith(const char* container, const char* target)\n{\n  size_t clen = strlen(container), tlen = strlen(target);\n  if (clen < tlen)\n    return 0;\n  return strncmp(container + clen - tlen, target, tlen) == 0;\n}\n\nint doesContain(const char* container, const char* target)\n{\n  return strstr(container, target) != 0;\n}\n\nint main(void)\n{\n  printf(\"Starts with Test ( Hello,Hell )\u00a0: %d\\n\", startsWith(\"Hello\",\"Hell\"));\n  printf(\"Ends with Test ( Code,ode )\u00a0: %d\\n\", endsWith(\"Code\",\"ode\"));\n  printf(\"Contains Test ( Google,msn )\u00a0: %d\\n\", doesContain(\"Google\",\"msn\"));\n\n  return 0;\n}\n\n\nOutput:\nStarts with Test ( Hello,Hell )\u00a0: 1\nEnds with Test ( Code,ode )\u00a0: 1\nContains Test ( Google,msn )\u00a0: 0\n\n#include <stdio.h>\n\n/* returns 0 if no match, 1 if matched, -1 if matched and at end */\nint s_cmp(const char *a, const char *b)\n{\n        char c1 = 0, c2 = 0;\n        while (c1 == c2) {\n                c1 = *(a++);\n                if ('\\0' == (c2 = *(b++)))\n                        return c1 == '\\0' ? -1 : 1;\n        }\n        return 0;\n}\n\n/* returns times matched */\nint s_match(const char *a, const char *b)\n{\n        int i = 0, count = 0;\n        printf(\"matching `%s' with `%s':\\n\", a, b);\n\n        while (a[i] != '\\0') {\n                switch (s_cmp(a + i, b)) {\n                case -1:\n                        printf(\"matched: pos %d (at end)\\n\\n\", i);\n                        return ++count;\n                case 1:\n                        printf(\"matched: pos %d\\n\", i);\n                        ++count;\n                        break;\n                }\n                i++;\n        }\n        printf(\"end match\\n\\n\");\n        return count;\n}\n\nint main()\n{\n        s_match(\"A Short String\", \"ort S\");\n        s_match(\"aBaBaBaBa\", \"aBa\");\n        s_match(\"something random\", \"Rand\");\n\n        return 0;\n}\n\n\nOutput:\nmatching `A Short String' with `ort S':\nmatched: pos 4\nend match\n\nmatching `aBaBaBaBa' with `aBa':\nmatched: pos 0\nmatched: pos 2\nmatched: pos 4\nmatched: pos 6 (at end)\n\nmatching `something random' with `Rand':\nend match\n", "explain": "Case sensitive matching:\nCode without using string library to demonstrate how char strings are just pointers:\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "C++", "code": "\n#include <string>\nusing namespace std;\n\nstring s1=\"abcd\";\nstring s2=\"abab\";\nstring s3=\"ab\";\n//Beginning\ns1.compare(0,s3.size(),s3)==0;\n//End\ns1.compare(s1.size()-s3.size(),s3.size(),s3)==0;\n//Anywhere\ns1.find(s2)//returns string::npos\nint loc=s2.find(s3)//returns 0\nloc=s2.find(s3,loc+1)//returns 2\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Java", "code": "\n\nString string = \"string matching\";\nString suffix = \"ing\";\n\n\nstring.startsWith(suffix)\n\n\nstring.substring(0, suffix.length()).equals(suffix)\n\n\nstring.contains(suffix)\n\n\nstring.indexOf(suffix) != -1\n\n\nstring.endsWith(suffix);\n\n\nstring.substring(string.length() - suffix.length()).equals(suffix)\n\n\nint indexOf;\nint offset = 0;\nwhile ((indexOf = string.indexOf(suffix, offset)) != -1) {\n    System.out.printf(\"'%s' @ %d to %d%n\", suffix, indexOf, indexOf + suffix.length() - 1);\n    offset = indexOf + 1;\n}\n\n'ing' @ 3 to 5\n'ing' @ 12 to 14\n\n\n\"abcd\".startsWith(\"ab\") //returns true\n\"abcd\".endsWith(\"zn\") //returns false\n\"abab\".contains(\"bb\") //returns false\n\"abab\".contains(\"ab\") //returns true\nint loc = \"abab\".indexOf(\"bb\") //returns -1\nloc = \"abab\".indexOf(\"ab\") //returns 0\nloc = \"abab\".indexOf(\"ab\",loc+1) //returns 2\n\npublic class JavaApplication6 {\n    public static void main(String[] args) {\n        String strOne = \"complexity\";\n        String strTwo = \"udacity\";\n        stringMatch(strOne, strTwo);\n    }\n\n    public static void stringMatch(String one, String two) {\n        boolean match = false;\n        if (one.charAt(0) == two.charAt(0)) {\n            System.out.println(match = true);   // returns true\n        } else {\n            System.out.println(match);       // returns false\n        }\n        for (int i = 0; i < two.length(); i++) {  \n            int temp = i;\n            for (int x = 0; x < one.length(); x++) {\n                if (two.charAt(temp) == one.charAt(x)) {\n                    System.out.println(match = true);    //returns true\n                    i = two.length();\n                }\n            }\n        }\n        int num1 = one.length() - 1;\n        int num2 = two.length() - 1;\n        if (one.charAt(num1) == two.charAt(num2)) {\n            System.out.println(match = true);\n        } else {\n            System.out.println(match = false);\n        }\n    }\n}\n\n", "explain": "For this task consider the following strings\nThe most idiomatic way of determining if a string starts with another string is to use the String.startsWith method.\nAnother way is to use a combination of String.substring and String.equals\nTo determine if a string contains at least one occurrence of another string, use the String.contains method.\nA slightly more idiomatic approach would be to use the String.indexOf method, which will also return the index of the first character.\nThe most idiomatic way of determining whether a string ends with another string is to use the String.endsWith method.\nSimilarly, a combination of String.substring and String.equals can be used.\nIf you're looking to find the index of each occurrence, you can use the following.\n\nAlternately\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "C#", "code": "\nWorks with: Mono version 2.6\nclass Program\n{\n\tpublic static void Main (string[] args)\n\t{\n\t\tvar value = \"abcd\".StartsWith(\"ab\");\n\t\tvalue = \"abcd\".EndsWith(\"zn\"); //returns false\n\t\tvalue = \"abab\".Contains(\"bb\"); //returns false\n\t\tvalue = \"abab\".Contains(\"ab\"); //returns true\n\t\tint loc = \"abab\".IndexOf(\"bb\"); //returns -1\n\t\tloc = \"abab\".IndexOf(\"ab\"); //returns 0\n\t\tloc = \"abab\".IndexOf(\"ab\",loc+1); //returns 2\n\t}\n}\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "JavaScript", "code": "\nvar stringA = \"tacoloco\"\n  , stringB = \"co\"\n  , q1, q2, q2multi, m\n  , q2matches = []\n\n// stringA starts with stringB\nq1 = stringA.substring(0, stringB.length) == stringB\n\n// stringA contains stringB\nq2  = stringA.indexOf(stringB)\n\n// multiple matches\nq2multi = new RegExp(stringB,'g')\n\nwhile(m = q2multi.exec(stringA)){\n\tq2matches.push(m.index)\n}\n\n// stringA ends with stringB\nq3 = stringA.substr(-stringB.length) == stringB\n\nconsole.log(\"1: Does '\"+stringA+\"' start with '\"+stringB+\"'? \" + ( q1 ? \"Yes.\" : \"No.\"))\nconsole.log(\"2: Is '\"+stringB+\"' contained in '\"+stringA+\"'? \" + (~q2 ? \"Yes, at index \"+q2+\".\" : \"No.\"))\nif (~q2 && q2matches.length > 1){\n\tconsole.log(\"   In fact, it happens \"+q2matches.length+\" times within '\"+stringA+\"', at index\"+(q2matches.length > 1 ? \"es\" : \"\")+\" \"+q2matches.join(', ')+\".\")\n}\nconsole.log(\"3: Does '\"+stringA+\"' end with '\"+stringB+\"'? \"   + ( q3 ? \"Yes.\" : \"No.\"))\n\n\nOutput:\n1: Does 'tacoloco' start with 'co'? No.\n2: Is 'co' contained in 'tacoloco'? Yes, at index 2.\n   In fact, it happens 2 times within 'tacoloco', at indexes 2, 6.\n3: Does 'tacoloco' end with 'co'? Yes.\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "PHP", "code": "\n<?php\n/**********************************************************************************\n* This program gets needle and haystack from the caller (chm.html) (see below)\n* and checks for occurrences of the needle in the haystack\n* 02.05.2013 Walter Pachl\n* Comments or Suggestions welcome\n**********************************************************************************/\n$haystack = $_POST['haystack']; if ($haystack=='') {$haystack='no haystack given';}\n$needle   = $_POST['needle'];   if ($needle=='')   {$needle='no needle given';}\n\nfunction rexxpos($h,$n) {\n  $pos = strpos($h,$n);\n  if ($pos === false) { $pos=-1; }\n  else                { $pos=$pos+1; }\n  return ($pos);\n }\n\n$pos=rexxpos($haystack,$needle);\n$tx1 = \"\";\nif ($pos==-1){ $n=0; }  // not found\nelse         { $n=1; }  // found once (so far)\n// Special cases\nif ($pos==1){ $tx1=\"needle found to be the start of the haystack\"; }\nif ($pos==strlen($haystack)-strlen($needle)+1)\n            { $tx1=\"needle found at end of haystack\"; }\n\nif ($n>0) { // look for other occurrences\n  $pl=$pos; // list of positions\n  $p=$pos;  //\n  $x=\"*************************************\";\n  $h=$haystack;\n  while ($p>0) {\n    $h=substr($x,0,$p).substr($h,$p);\n    $p=rexxpos($h,$needle);\n    if ( $p>0 ) { $n=$n+1; $pl=$pl.\",&nbsp;\".$p; }\n  }\n       if ($n==1) { $txt=\"needle found once in haystack, position: $pl.\"; }\n  else if ($n==2) { $txt=\"needle found twice in haystack, position(s): $pl.\"; }\n  else            { $txt=\"needle found $n times in haystack, position(s): $pl.\"; }\n}\nelse              { $txt=\"needle not found in haystack.\"; }\n?>\n<html>\n  <head>\n    <title>Character Matching</title>\n    <meta name=\"author\" content=\"Walter Pachl\">\n    <meta name=\"date\" content=\"02.05.2013\">\n    <style>\n      p { font: 120% courier; }\n    </style>\n  </head>\n  <body>\n    <p><strong>Haystack:&nbsp;'<?php echo \"$haystack\" ?>'</strong></p>\n    <p><strong>Needle:&nbsp;&nbsp;&nbsp;'<?php echo \"$needle\" ?>'</strong></p>\n    <p><strong><?php echo \"$txt\" ?></strong></p>\n    <!-- special message: -->\n    <p  style=\"color: red\";><strong><?php echo \"$tx1\" ?></strong></p>\n  </body>\n</html>\n\n<?php\n<!DOCTYPE html>\n<!--\n/************************************************************************\n* Here we prompt the user for a haystack and a needle\n* We then invoke program chmx.php\n* to check for occurrences of the needle in the haystack\n* 02.05.2013 Walter Pachl\n* Comments or Suggestions welcome\n************************************************************************/\n-->\n<html>\n  <head>\n    <meta http-equiv=\"Content-Type\" content=\"text/html; charset=UTF-8\" />\n    <title>Character matching</title>\n  </head>\n  <body>\n    <form id=\"test\" name=\"test\" method=\"post\" action=\"chmx.php\">\n    <h1>Character matching</h1>\n    <p>Given two strings, demonstrate the following 3 types of matchings:\n    <ol style=\"margin-top:2; margin-bottom:2;\">\n    <li>Determining if the first string starts with second string\n    <li>Determining if the first string contains the second string at any location\n    <li>Determining if the first string ends with the second string\n    </ol>\n    <p>Optional requirements:\n    <ol style=\"margin-top:2; margin-bottom:2;\">\n    <li>Print the location of the match(es) for part 2\n    <li>Handle multiple occurrences of a string for part 2.\n    </ol>\n    <p style=\"margin-top:5; margin-bottom:3;\">\n       <font face=\"Courier\"><strong>Haystack:</strong>\n       <strong><input type=\"text\" name=\"haystack\" size=\"80\"></strong></font></p>\n    <p style=\"margin-top:5; margin-bottom:3;\">\n       <font face=\"Courier\"><strong>Needle:&nbsp;&nbsp;</strong>\n       <strong><input type=\"text\" name=\"needle\" size=\"80\"></strong></font></p>\n    <p>Press <input name=\"Submit\" type=\"submit\" class=\"erfolg\" value=\"CHECK\"/>\n       to invoke chmx.php.</p>\n  </form>\n  </body>\n</html>\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Fortran", "code": "\n\n      SUBROUTINE STARTS(A,B)\t!Text A starts with text B?\n       CHARACTER*(*) A,B\n        IF (INDEX(A,B).EQ.1) THEN\t!Searches A to find B.\n          WRITE (6,*) \">\",A,\"< starts with >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< does not start with >\",B,\"<\"\n        END IF\n      END SUBROUTINE STARTS\n\n      SUBROUTINE HAS(A,B)\t!Text B appears somewhere in text A?\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = INDEX(A,B)\t\t!The first position in A where B matches.\n        IF (L.LE.0) THEN\n          WRITE (6,*) \">\",A,\"< does not contain >\",B,\"<\"\n         ELSE\n          WRITE (6,*) \">\",A,\"< contains a >\",B,\"<, offset\",L\n        END IF\n      END SUBROUTINE HAS\n\n      SUBROUTINE ENDS(A,B)\t!Text A ends with text B.\n       CHARACTER*(*) A,B\n       INTEGER L\n        L = LEN(A) - LEN(B)\t!Find the tail end of A that B might match.\n        IF (L.LT.0) THEN\t!Dare not use an OR, because of full evaluation risks.\n          WRITE (6,*) \">\",A,\"< is too short to end with >\",B,\"<\"\t!Might as well have a special message.\n        ELSE IF (A(L + 1:L + LEN(B)).NE.B) THEN\t!Otherwise, it is safe to look.\n          WRITE (6,*) \">\",A,\"< does not end with >\",B,\"<\"\n        ELSE\n          WRITE (6,*) \">\",A,\"< ends with >\",B,\"<\"\n        END IF\n      END SUBROUTINE ENDS\n\n      CALL STARTS(\"This\",\"is\")\n      CALL STARTS(\"Theory\",\"The\")\n      CALL HAS(\"Bananas\",\"an\")\n      CALL ENDS(\"Banana\",\"an\")\n      CALL ENDS(\"Banana\",\"na\")\n      CALL ENDS(\"Brief\",\"Much longer\")\n      END\n\n\n >This< does not start with >is<\n >Theory< starts with >The<\n >Bananas< contains a >an<, offset           2\n >Banana< does not end with >an<\n >Banana< ends with >na<\n >Brief< is too short to end with >Much longer<\n\n\n!-----------------------------------------------------------------------\n!Main program string_matching\n!-----------------------------------------------------------------------\nprogram    string_matching\n   implicit none\n   character(len=*), parameter :: fmt= '(I0)'\n   write(*,fmt) starts(\"this\",\"is\")\n   write(*,fmt) starts(\"theory\",\"the\")\n   write(*,fmt) has(\"bananas\",\"an\")\n   write(*,fmt) ends(\"banana\",\"an\")\n   write(*,fmt) ends(\"banana\",\"na\")\n   write(*,fmt) ends(\"brief\",\"much longer\")\n\n contains\n   !     Determining if the first string starts with second string\n   function  starts(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(1:len(string2))==string2) answer = 1\n   end function starts\n   !     Determining if the first string contains the second string at any location\n   function  has(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      character(len=:),allocatable :: temp\n      integer :: answer, add\n      character(len=*), parameter :: fmt= '(A6,X,I0)'\n      answer = 0\n      add = 0\n      if(len(string2)>len(string1)) return\n      answer = index(string1, string2)\n      if(answer==0) return\n      !     Print the location of the match for part 2\n      write(*,fmt) \" at \", answer\n      !     Handle multiple occurrences of a string for part 2.\n      add = answer\n      temp = string1(answer+1:)\n      do while(answer>0)\n         answer = index(temp, string2)\n         add = add + answer\n         if(answer>0) write(*,fmt) \" at \", add\n         !          deallocate(temp)\n         temp = string1(add+1:) ! auto reallocation\n      enddo\n      answer = 1\n   end function has\n   !     Determining if the first string ends with the second string\n   function  ends(string1, string2) result(answer)\n      implicit none\n      character(len=*), intent(in) :: string1\n      character(len=*), intent(in) :: string2\n      integer :: answer\n      answer = 0\n      if(len(string2)>len(string1)) return\n      if(string1(len(string1)-len(string2)+1:)==string2) answer = 1\n   end function ends\nend program string_matching\n\n\n0\n1\n   at  2\n   at  4\n1\n0\n1\n0\n\n\n", "explain": "Fortran does not offer a string type, but since F77 it has been possible to use a CHARACTER variable, of some specified size, whose size may be accessed via the LEN function. When passed as a parameter, a secret additional parameter specifies its size and so string-like usage is possible. Character matching is case sensitive, and, trailing spaces are ignored so that \"xx\" and \"xx \" are deemed equal. The function INDEX(text,target) determines the first index in text where target matches, and returns zero if there is no such match. Unfortunately, the function does not allow the specification of a starting position for a search, as to find any second and further matches. One must specify something like INDEX(text(5:),target) to start with position five, and then deal with the resulting offsets needed to relate the result to positions within the parameter. On the other hand, since there is no \"length\" conjoined to the text such substring selections can be made without copying the text to a work area, unlike the copy(text,start,stop) equivalent of Pascal for example. Some Fortran compilers do offer a starting point, and also an option to search backwards from the end, but these facilities are not guaranteed. Similarly, INDEX is only made available for CHARACTER searching, even though it could easily be generalised to other types.\nA second problem is presented by the possibility that a logical expression such as L.LT.0 .OR. etc. will always or might possibly or in certain constructions but not others be fully evaluated, which is to say that the etc will be evaluated even though L < 0 is true so that the result is determined. And in this case, evaluating the etc will cause trouble because the indexing won't work! To be safe, therefore, a rather lame two-stage test is required - though optimising compilers might well shift code around anyway.\nIn the case of STARTS, these annoyances can be left to the INDEX function rather than comparing the start of A against B. At the cost of it searching the whole of A if B is not at the start. Otherwise, it would be the mirror of ENDS.\nOutput: text strings are bounded by >etc.< in case of leading or trailing spaces.\nSimilar program using modern Fortran style \nOutput: false = 0, true = 1 ( + multiple occurrences if applicable)\nIn recent standards of Fortran strings as intrinsic first-class type and many intrinsic procedures for strings manipulation have been added.\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"strings\"\n)\n\nfunc match(first, second string) {\n    fmt.Printf(\"1. %s starts with %s: %t\\n\",\n        first, second, strings.HasPrefix(first, second))\n    i := strings.Index(first, second)\n    fmt.Printf(\"2. %s contains %s: %t,\\n\", first, second, i >= 0)\n    if i >= 0 {\n        fmt.Printf(\"2.1. at location %d,\\n\", i)\n        for start := i+1;; {\n            if i = strings.Index(first[start:], second); i < 0 {\n                break\n            }\n            fmt.Printf(\"2.2. at location %d,\\n\", start+i)\n            start += i+1\n        }\n        fmt.Println(\"2.2. and that's all\")\n    }\n    fmt.Printf(\"3. %s ends with %s: %t\\n\",\n        first, second, strings.HasSuffix(first, second))\n}\n\nfunc main() {\n    match(\"abracadabra\", \"abr\")\n}\n\n\nOutput:\n1. abracadabra starts with abr: true\n2. abracadabra contains abr: true,\n2.1. at location 0,\n2.2. at location 7,\n2.2. and that's all\n3. abracadabra ends with abr: false\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program strMatching.s   */\n\n/* Constantes    */\n.equ STDOUT, 1                           @ Linux output console\n.equ EXIT,   1                           @ Linux syscall\n.equ WRITE,  4                           @ Linux syscall\n\n/* Initialized data */\n.data\nszMessFound:             .asciz \"String found. \\n\" \nszMessNotFound:          .asciz \"String not found. \\n\" \nszString:                .asciz \"abcdefghijklmnopqrstuvwxyz\"\nszString2:               .asciz \"abc\"\nszStringStart:           .asciz \"abcd\"\nszStringEnd:             .asciz \"xyz\"\nszStringStart2:          .asciz \"abcd\"\nszStringEnd2:            .asciz \"xabc\"\nszCarriageReturn:        .asciz \"\\n\"\n\n/* UnInitialized data */\n.bss \n\n/*  code section */\n.text\n.global main \nmain: \n\n    ldr r0,iAdrszString                         @ address input string\n    ldr r1,iAdrszStringStart                    @ address search string\n\n    bl searchStringDeb                          @ Determining if the first string starts with second string\n    cmp r0,#0\n    ble 1f\n    ldr r0,iAdrszMessFound                      @ display message\n    bl affichageMess\n    b 2f\n1:\n    ldr r0,iAdrszMessNotFound\n    bl affichageMess\n2:\n    ldr r0,iAdrszString                         @ address input string\n    ldr r1,iAdrszStringEnd                      @ address search string\n    bl searchStringFin                          @ Determining if the first string ends with the second string\n    cmp r0,#0\n    ble 3f\n    ldr r0,iAdrszMessFound                      @ display message\n    bl affichageMess\n    b 4f\n3:\n    ldr r0,iAdrszMessNotFound\n    bl affichageMess\n4:\n    ldr r0,iAdrszString2                        @ address input string\n    ldr r1,iAdrszStringStart2                   @ address search string\n\n    bl searchStringDeb                          @ \n    cmp r0,#0\n    ble 5f\n    ldr r0,iAdrszMessFound                      @ display message\n    bl affichageMess\n    b 6f\n5:\n    ldr r0,iAdrszMessNotFound\n    bl affichageMess\n6:\n    ldr r0,iAdrszString2                        @ address input string\n    ldr r1,iAdrszStringEnd2                     @ address search string\n    bl searchStringFin\n    cmp r0,#0\n    ble 7f\n    ldr r0,iAdrszMessFound                      @ display message\n    bl affichageMess\n    b 8f\n7:\n    ldr r0,iAdrszMessNotFound\n    bl affichageMess\n8:\n    ldr r0,iAdrszString                         @ address input string\n    ldr r1,iAdrszStringEnd                      @ address search string\n    bl searchSubString                          @ Determining if the first string contains the second string at any location\n    cmp r0,#0\n    ble 9f\n    ldr r0,iAdrszMessFound                      @ display message\n    bl affichageMess\n    b 10f\n9:\n    ldr r0,iAdrszMessNotFound                   @ display substring result\n    bl affichageMess\n10:\n\n100:                                            @ standard end of the program\n    mov r0, #0                                  @ return code\n    mov r7, #EXIT                               @ request to exit program\n    svc 0                                       @ perform system call\niAdrszMessFound:          .int szMessFound\niAdrszMessNotFound:       .int szMessNotFound\niAdrszString:             .int szString\niAdrszString2:            .int szString2\niAdrszStringStart:        .int szStringStart\niAdrszStringEnd:          .int szStringEnd\niAdrszStringStart2:       .int szStringStart2\niAdrszStringEnd2:         .int szStringEnd2\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     search substring at begin of input string                  */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of substring */\n/* r0 returns 1 if find or 0 if not or -1 if error */\nsearchStringDeb:\n    push {r1-r4,lr}                             @ save  registers \n    mov r3,#0                                   @ counter byte  string \n    ldrb r4,[r1,r3]                             @ load first byte of substring\n    cmp r4,#0                                   @ empty string\u00a0?\n    moveq r0,#-1                                @ error\n    beq 100f\n1:\n    ldrb r2,[r0,r3]                             @ load byte string input\n    cmp r2,#0                                   @ zero final\u00a0?\n    moveq r0,#0                                 @ not find\n    beq 100f\n    cmp r4,r2                                   @ bytes equals\u00a0?\n    movne r0,#0                                 @ no not find\n    bne 100f\n    add r3,#1                                   @ increment counter\n    ldrb r4,[r1,r3]                             @ and load next byte of substring\n    cmp r4,#0                                   @ zero final\u00a0?\n    bne 1b                                      @ no -> loop\n    mov r0,#1                                   @ yes is ok \n100:\n    pop {r1-r4,lr}                              @ restaur registers\n    bx lr                                       @ return\n\n/******************************************************************/\n/*     search substring at end of input string                    */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of substring */\n/* r0 returns 1 if find or 0 if not or -1 if error */\nsearchStringFin:\n    push {r1-r5,lr}                             @ save  registers \n    mov r3,#0                                   @ counter byte  string \n                                                @ search the last character of substring\n1: \n    ldrb r4,[r1,r3]                             @ load byte of substring\n    cmp r4,#0                                   @ zero final\u00a0?\n    addne r3,#1                                 @ no increment counter\n    bne 1b                                      @ and loop\n    cmp r3,#0                                   @ empty string\u00a0?\n    moveq r0,#-1                                @ error\n    beq 100f\n    sub r3,#1                                   @ index of last byte\n    ldrb r4,[r1,r3]                             @ load last byte of substring\n                                                @ search the last character of string\n    mov r2,#0                                   @ index last character\n2: \n    ldrb r5,[r0,r2]                             @ load first byte of substring\n    cmp r5,#0                                   @ zero final\u00a0?\n    addne r2,#1                                 @ no -> increment counter\n    bne 2b                                      @ and loop\n    cmp r2,#0                                   @ empty input string\u00a0?\n    moveq r0,#0                                 @ yes -> not found\n    beq 100f\n    sub r2,#1                                   @ index last character\n3:\n    ldrb r5,[r0,r2]                             @ load byte string input\n    cmp r4,r5                                   @ bytes equals\u00a0?\n    movne r0,#0                                 @ no -> not found\n    bne 100f\n    subs r3,#1                                  @ decrement counter\n    movlt r0,#1                                 @ if zero -> ok found\n    blt 100f \n    subs r2,#1                                  @ decrement counter input string\n    movlt r0,#0                                 @ if zero -> not found\n    blt 100f\n    ldrb r4,[r1,r3]                             @ load previous byte of substring\n    b 3b                                        @ and loop\n    \n100:\n    pop {r1-r5,lr}                              @ restaur registers\n    bx lr                                       @ return\n\n/******************************************************************/\n/*   search a substring in the string                            */ \n/******************************************************************/\n/* r0 contains the address of the input string */\n/* r1 contains the address of substring */\n/* r0 returns index of substring in string or -1 if not found */\nsearchSubString:\n    push {r1-r6,lr}                       @ save registers \n    mov r2,#0                             @ counter byte input string\n    mov r3,#0                             @ counter byte string \n    mov r6,#-1                            @ index found\n    ldrb r4,[r1,r3]\n1:\n    ldrb r5,[r0,r2]                       @ load byte string \n    cmp r5,#0                             @ zero final\u00a0?\n    moveq r0,#-1                          @ yes returns error\n    beq 100f\n    cmp r5,r4                             @ compare character \n    beq 2f\n    mov r6,#-1                            @ no equals - > raz index \n    mov r3,#0                             @ and raz counter byte\n    add r2,#1                             @ and increment counter byte\n    b 1b                                  @ and loop\n2:                                        @ characters equals\n    cmp r6,#-1                            @ first characters equals\u00a0?\n    moveq r6,r2                           @ yes -> index begin in r6\n    add r3,#1                             @ increment counter substring\n    ldrb r4,[r1,r3]                       @ and load next byte\n    cmp r4,#0                             @ zero final\u00a0?\n    beq 3f                                @ yes -> end search\n    add r2,#1                             @ else increment counter string\n    b 1b                                  @ and loop\n3:\n    mov r0,r6\n100:\n    pop {r1-r6,lr}                        @ restaur registers\n    bx lr   \n\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                       @ save  registers \n    mov r2,#0                                   @ counter length */\n1:                                              @ loop length calculation\n    ldrb r1,[r0,r2]                             @ read octet start position + index \n    cmp r1,#0                                   @ if 0 its over\n    addne r2,r2,#1                              @ else add 1 in the length\n    bne 1b                                      @ and loop \n                                                @ so here r2 contains the length of the message \n    mov r1,r0                                   @ address message in r1 \n    mov r0,#STDOUT                              @ code to write to the standard output Linux\n    mov r7, #WRITE                              @ code call system \"write\" \n    svc #0                                      @ call system\n    pop {r0,r1,r2,r7,lr}                        @ restaur registers\n    bx lr                                       @ return\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "MIPS_Assembly", "code": "\n\nIf it returns strlen($a0), then $a1 was not found.\nIf it returns 0, then $a0 begins with $a1.\nIf it returns strlen($a0)-strlen($a1), then $a0 ends with $a1.\nOtherwise, $a0 contains $a1 starting at the specified location.\nMultiple occurrences can be detected by adding the output to $a0 and repeating the process; this is left as an exercise to the reader.\nInString:\n\t;input: $a0 = ptr to string 1\n\t;\t\t$a1 = ptr to string 2\n\t;\tassumes len($a1) <= len($a0)\n\t;out: $v0 = zero-based index where the second string is placed in the first.\n\t\n\t;clobbers: $t0,$t1\n\tsubiu sp,sp,4\t\t;set up a stack frame of 4 bytes.\n\tsw $a1,(sp)\n\tli $v0,0\nInString_again:\n\tlbu $t0,($a0)\n\tnop\n\tbeqz $t0,InString_terminated\n\tnop\n\t\n\tlbu $t1,($a1)\n\tnop\n\tbeqz $t1,InString_terminated\n\tnop\n\t\n\tbne $t0,$t1,InString_noMatch\n\tnop\n\t\tb InString_overhead\n\t\taddiu $a1,1\n\t\t\nInString_noMatch:\n\tlw $a1,(sp)\t\t;reset the substring pointer if the letters don't match\n\taddiu $v0,1\t\t;load delay slot\nInString_overhead:\n\taddiu $a0,1\n\tb InString_Again\n\tnop\nInString_terminated:\n\taddiu sp,sp,4\n\tjr ra\n\tnop\n\nOutput:\nmain:\n\tla $a0,MyString\n\tla $a1,Test1      ;this code was recompiled 5 times, testing a different string each time.\n\tjal InString\n\tnop\n\t\n\tjal Monitor\n\tnop\n\t\n\t\nshutdown:     \n\tnop  ;Project 64 will detect an infinite loop and close the ROM if I don't have this nop here.\n\tb shutdown\n\tnop\n\n\nMyString:    ;this was loaded into $a0\n\t.ascii \"abcdefghijklmnopqrstuvwxyz\"   \n\t.byte 0\n\t.align 4\n;each of these was loaded into $a1 individually for testing\nTest1:\n\t.ascii \"abc\"  ;InString returned 0\n\t.byte 0\n\t.align 4\nTest2:\n\t.ascii \"xyz\"  ;InString returned 0x17 (decimal 23)\n\t.byte 0\n\t.align 4\nTest3:\n\t.ascii \"def\"  ;InString returned 3\n\t.byte 0\n\t.align 4\nTest4:\n\t.ascii \"z\",0  ;InString returned 0x19 (decimal 25)\n\t.byte 0\n\t.align 4\nTest5:\n\t.ascii \"1\",0 ;InString returned 0x1A (decimal 26)\n\t.byte 0\n\t.align 4\n", "explain": "The function below returns the zero-based index where the string pointed to by $a1 occurs in $a0.\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Delphi", "code": "\nprogram CharacterMatching;\n\n{$APPTYPE CONSOLE}\n\nuses StrUtils;\n\nbegin\n  WriteLn(AnsiStartsText('ab', 'abcd')); // True\n  WriteLn(AnsiEndsText('zn', 'abcd')); // False\n  WriteLn(AnsiContainsText('abcd', 'bb')); // False\n  Writeln(AnsiContainsText('abcd', 'ab')); // True\n  WriteLn(Pos('ab', 'abcd')); // 1\nend.\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Ruby", "code": "\np 'abcd'.start_with?('ab')  #returns true\np 'abcd'.end_with?('ab')    #returns false\np 'abab'.include?('bb')     #returns false\np 'abab'.include?('ab')     #returns true\np 'abab'['bb']              #returns nil\np 'abab'['ab']              #returns \"ab\"\np 'abab'.index('bb')        #returns nil\np 'abab'.index('ab')        #returns 0\np 'abab'.index('ab', 1)     #returns 2\np 'abab'.rindex('ab')       #returns 2\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Rust", "code": "\nfn print_match(possible_match: Option<usize>) {\n    match possible_match {\n        Some(match_pos) => println!(\"Found match at pos {}\", match_pos),\n        None => println!(\"Did not find any matches\")\n    }\n}\n\nfn main() {\n    let s1 = \"abcd\";\n    let s2 = \"abab\";\n    let s3 = \"ab\";\n    \n    // Determining if the first string starts with second string\n    assert!(s1.starts_with(s3));\n    // Determining if the first string contains the second string at any location\n    assert!(s1.contains(s3));\n    // Print the location of the match \n    print_match(s1.find(s3)); // Found match at pos 0\n    print_match(s1.find(s2)); // Did not find any matches\n    // Determining if the first string ends with the second string\n    assert!(s2.ends_with(s3));\n}\n\nfn main(){\n    let hello = String::from(\"Hello world\");\n    println!(\" Start with \\\"he\\\" {} \\n Ends with \\\"rd\\\" {}\\n Contains \\\"wi\\\" {}\", \n                                                        hello.starts_with(\"He\"),\n                                                        hello.ends_with(\"ld\"),\n                                                        hello.contains(\"wi\"));\n}\n\nOutput:\nStart with \"he\" true \nEnds with \"ld\" true\nContains \"wi\" false\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Swift", "code": "\nvar str = \"Hello, playground\"\nstr.hasPrefix(\"Hell\")           //True\nstr.hasPrefix(\"hell\")           //False\n\nstr.containsString(\"llo\")       //True\nstr.containsString(\"xxoo\")      //False\n\nstr.hasSuffix(\"playground\")     //True\nstr.hasSuffix(\"world\")          //False\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\n\n", "explain": "works the same as in VBA, see String_matching#VBA\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Ada", "code": "\nwith Ada.Strings.Fixed;  use Ada.Strings.Fixed;\nwith Ada.Text_IO;        use Ada.Text_IO;\n\nprocedure Match_Strings is\n   S1 : constant String := \"abcd\";\n   S2 : constant String := \"abab\";\n   S3 : constant String := \"ab\";\nbegin\n   if S1'Length >= S3'Length and then S1 (S1'First..S1'First + S3'Length - 1) = S3 then\n      Put_Line (''' & S1 & \"' starts with '\" & S3 & ''');\n   end if;\n   if S2'Length >= S3'Length and then S2 (S2'Last - S3'Length + 1..S2'Last) = S3 then\n      Put_Line (''' & S2 & \"' ends with '\" & S3 & ''');\n   end if;\n   Put_Line (''' & S3 & \"' first appears in '\" & S1 & \"' at\" & Integer'Image (Index (S1, S3)));\n   Put_Line\n   (  ''' & S3 & \"' appears in '\" & S2 & ''' &\n      Integer'Image (Ada.Strings.Fixed.Count (S2, S3)) & \" times\"\n   );\nend Match_Strings;\n\n\nOutput:\n'abcd' starts with 'ab'\n'abab' ends with 'ab'\n'ab' first appears in 'abcd' at 1\n'ab' appears in 'abab' 2 times\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Julia", "code": "\nstartswith(\"abcd\",\"ab\")            #returns true\nfindfirst(\"ab\", \"abcd\")            #returns 1:2, indices range where string was found\nendswith(\"abcd\",\"zn\")              #returns false\nmatch(r\"ab\",\"abcd\") != Nothing     #returns true where 1st arg is regex string\nfor r in eachmatch(r\"ab\",\"abab\")\n\tprintln(r.offset)\nend                                #returns 1, then 3 matching the two starting indices where the substring was found\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Kotlin", "code": "\nfun main() {\n    val s1 = \"abracadabra\"\n    val s2 = \"abra\"    \n    println(\"$s1 begins with $s2: ${s1.startsWith(s2)}\")\n    println(\"$s1 ends with $s2: ${s1.endsWith(s2)}\")\n    val b = s2 in s1\n    if (b) {\n        print(\"$s1 contains $s2 at these indices: \")\n        // can use indexOf to get first index or lastIndexOf to get last index\n        // to get ALL indices, use a for loop or Regex\n        println(\n            s2.toRegex(RegexOption.LITERAL).findAll(s1).joinToString { it.range.start.toString() }\n        )\n    }\n    else println(\"$s1 does not contain $2.\")\n}\n\n\nOutput:\nabracadabra begins with abra: true\nabracadabra ends with abra: true\nabracadabra contains abra at these indices: 0, 7\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Perl", "code": "\n\n$str1 =~ /^\\Q$str2\\E/  # true if $str1 starts with $str2\n$str1 =~ /\\Q$str2\\E/   # true if $str1 contains $str2\n$str1 =~ /\\Q$str2\\E$/  # true if $str1 ends with $str2\n\n\nindex($str1, $str2) == 0                               # true if $str1 starts with $str2\nindex($str1, $str2) != -1                              # true if $str1 contains $str2\nrindex($str1, $str2) == length($str1) - length($str2)  # true if $str1 ends with $str2\n\n\nsubstr($str1, 0, length($str2)) eq $str2  # true if $str1 starts with $str2\nsubstr($str1, - length($str2)) eq $str2   # true if $str1 ends with $str2\n\n\nprint $-[0], \"\\n\" while $str1 =~ /\\Q$str2\\E/g;  # using a regex\n\nmy $i = -1; print $i, \"\\n\" while ($i = index $str1, $str2, $i + 1) != -1;  # using index\n\n", "explain": "Using regexes:\nUsing index:\nUsing substr:\nBonus task (printing all positions where $str2 appears in $str1):\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Objective-C", "code": "\n[@\"abcd\" hasPrefix:@\"ab\"] //returns true\n[@\"abcd\" hasSuffix:@\"zn\"] //returns false\nint loc = [@\"abab\" rangeOfString:@\"bb\"].location //returns -1\nloc = [@\"abab\" rangeOfString:@\"ab\"].location //returns 0\nloc = [@\"abab\" rangeOfString:@\"ab\" options:0 range:NSMakeRange(loc+1, [@\"abab\" length]-(loc+1))].location //returns 2\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Prolog", "code": "\n:- system:set_prolog_flag(double_quotes,codes) .\n\n:- [library(lists)] .\n\n%!  starts_with(FIRSTz,SECONDz)\n%\n% True if `SECONDz` is the beginning of `FIRSTz` .\n\nstarts_with(FIRSTz,SECONDz)\n:-\nlists:append(SECONDz,_,FIRSTz)\n.\n\n%!  contains(FIRSTz,SECONDz)\n%\n% True once if `SECONDz` is contained within `FIRSTz` at one or more positions .\n\ncontains(FIRSTz,SECONDz)\n:-\ncontains(FIRSTz,SECONDz,_) ,\n!\n.\n\n%!  contains(FIRSTz,SECONDz,NTH1)\n%\n% True if `SECONDz` is contained within `FIRSTz` at position `NTH1` .\n\ncontains(FIRSTz,SECONDz,NTH1)\n:-\nlists:append([PREFIXz,SECONDz,_SUFFIXz_],FIRSTz) ,\nprolog:length(PREFIXz,NTH0) ,\nNTH1 is NTH0 + 1\n.\n\n%!  ends_with(FIRSTz,SECONDz)\n%\n% True if `SECONDz` is the ending of `FIRSTz` .\n\nends_with(FIRSTz,SECONDz)\n:-\nlists:append(_,SECONDz,FIRSTz)\n.\n\n\nOutput:\n\n\n?- starts_with(\"abcdef\",\"abc\") .\ntrue .\n\n?- starts_with(\"abc\",\"abc\") .\ntrue .\n\n?- starts_with(\"abc\",\"abcd\") .\nfalse .\n\n?- starts_with(\"dabc\",\"abc\") .\nfalse .\n\n?- starts_with(\"\",\"\") .\ntrue .\n\n?- \n\n?- contains(\"abcdef\",\"abc\") .\ntrue.\n\n?- contains(\"abcdef\",\"abc\",NTH).\nNTH = 1\u00a0;\nfalse.\n\n?- contains(\"abcdef\",\"de\",NTH).\nNTH = 4\u00a0;\nfalse.\n\n?- contains(\"abcdef\",\"f\",NTH).\nNTH = 6\u00a0;\nfalse.\n\n?- contains(\"abcde\",\"f\",NTH).\nfalse.\n\n?- contains(\"\",\"\",NTH).\nNTH = 1\u00a0;\u00a0% wtf\u00a0?\nfalse.\n\n?- contains(\"a\",\"a\",NTH).\nNTH = 1\u00a0;\u00a0% wtf\u00a0?\nfalse.\n\n?- \n\n?- ends_with(\"abc\",\"abc\") .\ntrue\u00a0;\nfalse .\n\n?- ends_with(\"abc\",\"bc\") .\ntrue\u00a0;\nfalse .\n\n?- ends_with(\"abcd\",\"bc\") .\nfalse .\n\n?- ends_with(\"\",\"\") .\ntrue\u00a0;\nfalse .\n\n?- \n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Lua", "code": "\ns1 = \"string\"\ns2 = \"str\"\ns3 = \"ing\"\ns4 = \"xyz\"\n\nprint( \"s1 starts with s2: \", string.find( s1, s2 ) == 1 )\nprint( \"s1 starts with s3: \", string.find( s1, s3 ) == 1, \"\\n\" )\n\nprint( \"s1 contains s3: \", string.find( s1, s3 ) ~= nil )\nprint( \"s1 contains s3: \", string.find( s1, s4 ) ~= nil, \"\\n\" )   \n   \nprint( \"s1 ends with s2: \", select( 2, string.find( s1, s2 ) ) == string.len( s1 ) )\nprint( \"s1 ends with s3: \", select( 2, string.find( s1, s3 ) ) == string.len( s1 ) )\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Scala", "code": "\n\"abcd\".startsWith(\"ab\") //returns true\n\"abcd\".endsWith(\"zn\") //returns false\n\"abab\".contains(\"bb\") //returns false\n\"abab\".contains(\"ab\") //returns true\n\t\t\nvar loc=\"abab\".indexOf(\"bb\") //returns -1\nloc = \"abab\".indexOf(\"ab\") //returns 0\nloc = \"abab\".indexOf(\"ab\", loc+1) //returns 2\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "D", "code": "\nvoid main() {\n    import std.stdio;\n    import std.algorithm: startsWith, endsWith, find, countUntil;\n\n    \"abcd\".startsWith(\"ab\").writeln;      // true\n    \"abcd\".endsWith(\"zn\").writeln;        // false\n    \"abab\".find(\"bb\").writeln;            // empty array (no match)\n    \"abcd\".find(\"bc\").writeln;            // \"bcd\" (substring start\n                                           //        at match)\n    \"abab\".countUntil(\"bb\").writeln;      // -1 (no match)\n    \"abab\".countUntil(\"ba\").writeln;      //  1 (index of 1st match)\n\n    // std.algorithm.startsWith also works on arrays and ranges:\n    [1, 2, 3].countUntil(3).writeln;      //  2\n    [1, 2, 3].countUntil([2, 3]).writeln; //  1\n}\n\n\nOutput:\ntrue\nfalse\n\nbcd\n-1\n1\n2\n1\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Haskell", "code": "\n> import Data.List\n> \"abc\" `isPrefixOf` \"abcdefg\"\nTrue\n> \"efg\" `isSuffixOf` \"abcdefg\"\nTrue\n> \"bcd\" `isInfixOf` \"abcdefg\"\nTrue\n> \"abc\" `isInfixOf` \"abcdefg\" -- Prefixes and suffixes are also infixes\nTrue\n> let infixes a b = findIndices (isPrefixOf a) $ tails b\n> infixes \"ab\" \"abcdefabqqab\"\n[0,6,10]\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "VBScript", "code": "\nFunction StartsWith(s1,s2)\n\tStartsWith = False\n\tIf Left(s1,Len(s2)) = s2 Then\n\t\tStartsWith = True\n\tEnd If\nEnd Function\n\nFunction Contains(s1,s2)\n\tContains = False\n\tIf InStr(1,s1,s2) Then\n\t\tContains = True & \" at positions \"\n\t\tj = 1\n\t\tDo Until InStr(j,s1,s2) = False\n\t\t\tContains = Contains & InStr(j,s1,s2) & \", \"\n\t\t\tIf j = 1 Then\n\t\t\t\tIf Len(s2) = 1 Then\n\t\t\t\t\tj = j + InStr(j,s1,s2)\n\t\t\t\tElse\n\t\t\t\t\tj = j + (InStr(j,s1,s2) + (Len(s2) - 1))\n\t\t\t\tEnd If\n\t\t\tElse\n\t\t\t\tIf Len(s2) = 1 Then\n\t\t\t\t\tj = j + ((InStr(j,s1,s2) - j) + 1)\n\t\t\t\tElse\n\t\t\t\t\tj = j + ((InStr(j,s1,s2) - j) + (Len(s2) - 1))\n\t\t\t\tEnd If\n\t\t\tEnd If\n\t\tLoop\n\tEnd If\nEnd Function\n\nFunction EndsWith(s1,s2)\n\tEndsWith = False\n\tIf Right(s1,Len(s2)) = s2 Then\n\t\tEndsWith = True\n\tEnd If\nEnd Function\n\nWScript.StdOut.Write \"Starts with test, 'foo' in 'foobar': \" & StartsWith(\"foobar\",\"foo\")\nWScript.StdOut.WriteLine\nWScript.StdOut.Write \"Contains test, 'o' in 'fooooobar': \" & Contains(\"fooooobar\",\"o\")\nWScript.StdOut.WriteLine\nWScript.StdOut.Write \"Ends with test, 'bar' in 'foobar': \" & EndsWith(\"foobar\",\"bar\")\n\nOutput:\n\n\nStarts with test, 'foo' in 'foobar': True\nContains test, 'o' in 'fooooobar': True at positions 2, 3, 4, 5, 6, \nEnds with test, 'bar' in 'foobar': True\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "PowerShell", "code": "\n\"spicywiener\".StartsWith(\"spicy\")\n\"spicywiener\".Contains(\"icy\")\n\"spicywiener\".EndsWith(\"wiener\")\n\"spicywiener\".IndexOf(\"icy\")\n[regex]::Matches(\"spicywiener\", \"i\").count\n\n\nOutput:\nTrue\nTrue\nTrue\n2\n2\n\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Logo", "code": "\nto starts.with? :sub :thing\n  if empty? :sub [output \"true]\n  if empty? :thing [output \"false]\n  if not equal? first :sub first :thing [output \"false]\n  output starts.with? butfirst :sub butfirst :thing\nend\n\nto ends.with? :sub :thing\n  if empty? :sub [output \"true]\n  if empty? :thing [output \"false]\n  if not equal? last :sub last :thing [output \"false]\n  output ends.with? butlast :sub butlast :thing\nend\n\nshow starts.with? \"dog \"doghouse   \u00a0; true\nshow ends.with? \"house \"doghouse   \u00a0; true\nshow substring? \"gho \"doghouse      \u00a0; true  (built-in)\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "F#", "code": "\n[<EntryPoint>]\nlet main args =\n\n    let text = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\n    let starts = \"\u4e00\u4e8c\"\n    let ends = \"\u4e5d\u5341\"\n    let contains = \"\u4e94\u516d\"\n    let notContains = \"\u767e\"\n\n    printfn \"text = %A\" text\n    printfn \"starts with %A: %A\" starts (text.StartsWith(starts))\n    printfn \"starts with %A: %A\" ends (text.StartsWith(ends))\n    printfn \"ends with %A: %A\" ends (text.EndsWith(ends))\n    printfn \"ends with %A: %A\" starts (text.EndsWith(starts))\n    printfn \"contains %A: %A\" contains (text.Contains(contains))\n    printfn \"contains %A: %A\" notContains (text.Contains(notContains))\n    printfn \"substring %A begins at position %d (zero-based)\" contains (text.IndexOf(contains))\n    let text2 = text + text\n    printfn \"text = %A\" text2\n    Seq.unfold (fun (n : int) ->\n            let idx = text2.IndexOf(contains, n)\n            if idx < 0 then None else Some (idx, idx+1)) 0\n    |> Seq.iter (printfn \"substring %A begins at position %d (zero-based)\" contains)\n    0\n\n\nOutput:\ntext = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\nstarts with \"\u4e00\u4e8c\": true\nstarts with \"\u4e5d\u5341\": false\nends with \"\u4e5d\u5341\": true\nends with \"\u4e00\u4e8c\": false\ncontains \"\u4e94\u516d\": true\ncontains \"\u767e\": false\nsubstring \"\u4e94\u516d\" begins at position 4 (zero-based)\ntext = \"\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\u4e00\u4e8c\u4e09\u56db\u4e94\u516d\u4e03\u516b\u4e5d\u5341\"\nsubstring \"\u4e94\u516d\" begins at position 4 (zero-based)\nsubstring \"\u4e94\u516d\" begins at position 14 (zero-based)\n", "explain": ""}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "Groovy", "code": "\n\nassert \"abcd\".startsWith(\"ab\")\nassert ! \"abcd\".startsWith(\"zn\")\nassert \"abcd\".endsWith(\"cd\")\nassert ! \"abcd\".endsWith(\"zn\")\nassert \"abab\".contains(\"ba\")\nassert ! \"abab\".contains(\"bb\")\n\n\nassert \"abab\".indexOf(\"bb\") == -1 // not found flag\nassert \"abab\".indexOf(\"ab\") == 0\n\ndef indicesOf = { string, substring ->\n    if (!string) { return [] }\n    def indices = [-1]\n    while (true) {\n        indices << string.indexOf(substring, indices.last()+1)\n        if (indices.last() == -1) break\n    }\n    indices[1..<(indices.size()-1)]\n}\nassert indicesOf(\"abab\", \"ab\") == [0, 2]\nassert indicesOf(\"abab\", \"ba\") == [1]\nassert indicesOf(\"abab\", \"xy\") == []\n\n\n", "explain": "Examples:\nAll assertions pass, so there is no output.\n"}, {"task_name": "String matching", "task_url": "https://rosettacode.org/wiki/String_matching", "task_cat": "String manipulation", "lang": "AWK", "code": "\n#!/usr/bin/awk -f\n{ pos=index($2,$1)\n print $2, (pos==1 ? \"begins\" : \"does not begin\" ), \"with \" $1\n print $2, (pos ? \"contains an\" : \"does not contain\" ), \"\\\"\" $1 \"\\\"\"\n if (pos) {\n\tl=length($1)\n\tPos=pos\n\ts=$2\n\twhile (Pos){\n\t\tprint \" \" $1 \" is at index\", x+Pos\n\t\tx+=Pos\n\t\ts=substr(s,Pos+l)\n\t\tPos=index(s,$1)\n\t}\n }\n print $2, (substr($2,pos)==$1 ? \"ends\" : \"does not end\"), \"with \" $1\n}\n\n", "explain": ""}]