[{"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Python", "code": "\nPython Original[edit]\n\n'''\n The 24 Game Player\n \n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n \n An answer of \"q\"  will quit the game.\n An answer of \"!\"  will generate a new set of four digits.\n An answer of \"!!\" will ask you for a new set of four digits.\n An answer of \"?\"  will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n \n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n \n'''\n \nfrom   __future__ import division, print_function\nfrom   itertools  import permutations, combinations, product, \\\n                         chain\nfrom   pprint     import pprint as pp\nfrom   fractions  import Fraction as F\nimport random, ast, re\nimport sys\n \nif sys.version_info[0] < 3:\n    input = raw_input\n    from itertools import izip_longest as zip_longest\nelse:\n    from itertools import zip_longest\n \n \ndef choose4():\n    'four random digits >0 as characters'\n    return [str(random.randint(1,9)) for i in range(4)]\n \ndef ask4():\n    'get four random digits >0 from the player'\n    digits = ''\n    while len(digits) != 4 or not all(d in '123456789' for d in digits):\n        digits = input('Enter the digits to solve for: ')\n        digits = ''.join(digits.strip().split())\n    return list(digits)\n \ndef welcome(digits):\n    print (__doc__)\n    print (\"Your four digits: \" + ' '.join(digits))\n \ndef check(answer, digits):\n    allowed = set('() +-*/\\t'+''.join(digits))\n    ok = all(ch in allowed for ch in answer) and \\\n         all(digits.count(dig) == answer.count(dig) for dig in set(digits)) \\\n         and not re.search('\\d\\d', answer)\n    if ok:\n        try:\n            ast.parse(answer)\n        except:\n            ok = False\n    return ok\n \ndef solve(digits):\n    \"\"\"\\\n    >>> for digits in '3246 4788 1111 123456 1127 3838'.split():\n            solve(list(digits))\n \n \n    Solution found: 2 + 3 * 6 + 4\n    '2 + 3 * 6 + 4'\n    Solution found: ( 4 + 7 - 8 ) * 8\n    '( 4 + 7 - 8 ) * 8'\n    No solution found for: 1 1 1 1\n    '!'\n    Solution found: 1 + 2 + 3 * ( 4 + 5 ) - 6\n    '1 + 2 + 3 * ( 4 + 5 ) - 6'\n    Solution found: ( 1 + 2 ) * ( 1 + 7 )\n    '( 1 + 2 ) * ( 1 + 7 )'\n    Solution found: 8 / ( 3 - 8 / 3 )\n    '8 / ( 3 - 8 / 3 )'\n    >>> \"\"\"\n    digilen = len(digits)\n    # length of an exp without brackets \n    exprlen = 2 * digilen - 1\n    # permute all the digits\n    digiperm = sorted(set(permutations(digits)))\n    # All the possible operator combinations\n    opcomb   = list(product('+-*/', repeat=digilen-1))\n    # All the bracket insertion points:\n    brackets = ( [()] + [(x,y)\n                         for x in range(0, exprlen, 2)\n                         for y in range(x+4, exprlen+2, 2)\n                         if (x,y) != (0,exprlen+1)]\n                 + [(0, 3+1, 4+2, 7+3)] ) # double brackets case\n    for d in digiperm:\n        for ops in opcomb:\n            if '/' in ops:\n                d2 = [('F(%s)' % i) for i in d] # Use Fractions for accuracy\n            else:\n                d2 = d\n            ex = list(chain.from_iterable(zip_longest(d2, ops, fillvalue='')))\n            for b in brackets:\n                exp = ex[::]\n                for insertpoint, bracket in zip(b, '()'*(len(b)//2)):\n                    exp.insert(insertpoint, bracket)\n                txt = ''.join(exp)\n                try:\n                    num = eval(txt)\n                except ZeroDivisionError:\n                    continue\n                if num == 24:\n                    if '/' in ops:\n                        exp = [ (term if not term.startswith('F(') else term[2])\n                               for term in exp ]\n                    ans = ' '.join(exp).rstrip()\n                    print (\"Solution found:\",ans)\n                    return ans\n    print (\"No solution found for:\", ' '.join(digits))            \n    return '!'\n \ndef main():    \n    digits = choose4()\n    welcome(digits)\n    trial = 0\n    answer = ''\n    chk = ans = False\n    while not (chk and ans == 24):\n        trial +=1\n        answer = input(\"Expression %i: \" % trial)\n        chk = check(answer, digits)\n        if answer == '?':\n            solve(digits)\n            answer = '!'\n        if answer.lower() == 'q':\n            break\n        if answer == '!':\n            digits = choose4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if answer == '!!':\n            digits = ask4()\n            trial = 0\n            print (\"\\nNew digits:\", ' '.join(digits))\n            continue\n        if not chk:\n            print (\"The input '%s' was wonky!\" % answer)\n        else:\n            if '/' in answer:\n                # Use Fractions for accuracy in divisions\n                answer = ''.join( (('F(%s)' % char) if char in '123456789' else char)\n                                  for char in answer )\n            ans = eval(answer)\n            print (\" = \", ans)\n            if ans == 24:\n                print (\"Thats right!\")\n    print (\"Thank you and goodbye\")   \n \nmain()\n\n\nOutput:\n The 24 Game Player\n\n Given any four digits in the range 1 to 9, which may have repetitions,\n Using just the +, -, *, and / operators; and the possible use of\n brackets, (), show how to make an answer of 24.\n\n An answer of \"q\" will quit the game.\n An answer of \"!\" will generate a new set of four digits.\n An answer of \"?\" will compute an expression for the current digits.\n \n Otherwise you are repeatedly asked for an expression until it evaluates to 24\n\n Note: you cannot form multiple digit numbers from the supplied digits,\n so an answer of 12+12 when given 1, 2, 2, and 1 would not be allowed.\n\n\nYour four digits: 6 7 9 5\nExpression 1:\u00a0?\nSolution found: 6 - ( 5 - 7 ) * 9\nThank you and goodbye\nDifficult case requiring precise division[edit]\n\n\nOutput:\n...\nExpression 1:\u00a0!!\nEnter the digits to solve for: 3388\n\nNew digits: 3 3 8 8\nExpression 1: 8/(3-(8/3))\n =  24\nThats right!\nThank you and goodbye\n\n\nOutput:\n...\nExpression 1:\u00a0!!\nEnter the digits to solve for: 3388\n\nNew digits: 3 3 8 8\nExpression 1:\u00a0?\nSolution found: 8 / ( 3 - 8 / 3 )\nPython Succinct[edit]\n\n# -*- coding: utf-8 -*-\nimport operator\nfrom itertools import product, permutations\n\ndef mydiv(n, d):\n    return n / d if d != 0 else 9999999\n\nsyms = [operator.add, operator.sub, operator.mul, mydiv]\nop = {sym: ch for sym, ch in zip(syms, '+-*/')}\n\ndef solve24(nums):\n    for x, y, z in product(syms, repeat=3):\n        for a, b, c, d in permutations(nums):\n            if round(x(y(a,b),z(c,d)),5) == 24:\n                return f\"({a} {op[y]} {b}) {op[x]} ({c} {op[z]} {d})\"\n            elif round(x(a,y(b,z(c,d))),5) == 24:\n                return f\"{a} {op[x]} ({b} {op[y]} ({c} {op[z]} {d}))\"\n            elif round(x(y(z(c,d),b),a),5) == 24:\n                return f\"(({c} {op[z]} {d}) {op[y]} {b}) {op[x]} {a}\"\n            elif round(x(y(b,z(c,d)),a),5) == 24:\n                return f\"({b} {op[y]} ({c} {op[z]} {d})) {op[x]} {a}\"\n    return '--Not Found--'\n\nif __name__ == '__main__':\n    #nums = eval(input('Four integers in the range 1:9 inclusive, separated by commas: '))\n    for nums in [\n        [9,4,4,5],\n        [1,7,2,7],\n        [5,7,5,4],\n        [1,4,6,6],\n        [2,3,7,3],\n        [8,7,9,7],\n        [1,6,2,6],\n        [7,9,4,1],\n        [6,4,2,2],\n        [5,7,9,7],\n        [3,3,8,8],  # Difficult case requiring precise division\n            ]:\n        print(f\"solve24({nums}) -> {solve24(nums)}\")\n\n\nOutput:\nsolve24([9, 4, 4, 5]) -> --Not Found--\nsolve24([1, 7, 2, 7]) -> ((7 * 7) - 1) / 2\nsolve24([5, 7, 5, 4]) -> 4 * (7 - (5 / 5))\nsolve24([1, 4, 6, 6]) -> 6 + (6 * (4 - 1))\nsolve24([2, 3, 7, 3]) -> ((2 + 7) * 3) - 3\nsolve24([8, 7, 9, 7]) -> --Not Found--\nsolve24([1, 6, 2, 6]) -> 6 + (6 * (1 + 2))\nsolve24([7, 9, 4, 1]) -> (7 - 4) * (9 - 1)\nsolve24([6, 4, 2, 2]) -> (2 - 2) + (6 * 4)\nsolve24([5, 7, 9, 7]) -> (5 + 7) * (9 - 7)\nsolve24([3, 3, 8, 8]) -> 8 / (3 - (8 / 3))\nPython Recursive[edit]\n\n# -*- coding: utf-8 -*-\n# Python 3\nfrom operator import mul, sub, add\n\n\ndef div(a, b):\n    if b == 0:\n        return 999999.0\n    return a / b\n\nops = {mul: '*', div: '/', sub: '-', add: '+'}\n\ndef solve24(num, how, target):\n    if len(num) == 1:\n        if round(num[0], 5) == round(target, 5):\n            yield str(how[0]).replace(',', '').replace(\"'\", '')\n    else:\n        for i, n1 in enumerate(num):\n            for j, n2 in enumerate(num):\n                if i != j:\n                    for op in ops:\n                        new_num = [n for k, n in enumerate(num) if k != i and k != j] + [op(n1, n2)]\n                        new_how = [h for k, h in enumerate(how) if k != i and k != j] + [(how[i], ops[op], how[j])]\n                        yield from solve24(new_num, new_how, target)\n\ntests = [\n         [1, 7, 2, 7],\n         [5, 7, 5, 4],\n         [1, 4, 6, 6],\n         [2, 3, 7, 3],\n         [1, 6, 2, 6],\n         [7, 9, 4, 1],\n         [6, 4, 2, 2],\n         [5, 7, 9, 7],\n         [3, 3, 8, 8],  # Difficult case requiring precise division\n         [8, 7, 9, 7],  # No solution\n         [9, 4, 4, 5],  # No solution\n            ]\nfor nums in tests:\n    print(nums, end='\u00a0: ')\n    try:\n        print(next(solve24(nums, nums, 24)))\n    except StopIteration:\n        print(\"No solution found\")\n\n\nOutput:\n[1, 7, 2, 7]\u00a0: (((7 * 7) - 1) / 2)\n[5, 7, 5, 4]\u00a0: (4 * (7 - (5 / 5)))\n[1, 4, 6, 6]\u00a0: (6 - (6 * (1 - 4)))\n[2, 3, 7, 3]\u00a0: ((2 * 3) * (7 - 3))\n[1, 6, 2, 6]\u00a0: ((1 * 6) * (6 - 2))\n[7, 9, 4, 1]\u00a0: ((7 - 4) * (9 - 1))\n[6, 4, 2, 2]\u00a0: ((6 * 4) * (2 / 2))\n[5, 7, 9, 7]\u00a0: ((5 + 7) * (9 - 7))\n[3, 3, 8, 8]\u00a0: (8 / (3 - (8 / 3)))\n[8, 7, 9, 7]\u00a0: No solution found\n[9, 4, 4, 5]\u00a0: No solution found\nPython: using tkinter[edit]\n''' Python 3.6.5 code using Tkinter graphical user interface.\n    Combination of '24 game' and '24 game/Solve'\n    allowing user or random selection of 4-digit number\n    and user or computer solution.\n    Note that all computer solutions are displayed'''\n\nfrom tkinter import *\nfrom tkinter import messagebox\nfrom tkinter.scrolledtext import ScrolledText\n# 'from tkinter import scrolledtext' in later versions? \nimport random\nimport itertools\n\n# ************************************************\n\nclass Game:\n    def __init__(self, gw):\n        self.window = gw\n        self.digits = '0000'\n\n        a1 = \"(Enter '4 Digits' & click 'My Digits'\"\n        a2 = \"or click 'Random Digits')\"\n        self.msga = a1 + '\\n' + a2\n\n        b1 = \"(Enter 'Solution' & click 'Check Solution'\"\n        b2 = \"or click 'Show Solutions')\"\n        self.msgb = b1 + '\\n' + b2\n\n        # top frame:\n        self.top_fr = Frame(gw,\n                            width=600,\n                            height=100,\n                            bg='dodger blue')\n        self.top_fr.pack(fill=X)\n\n        self.hdg = Label(self.top_fr,\n                         text='  24 Game  ',\n                         font='arial 22 bold',\n                         fg='navy',\n                         bg='lemon chiffon')\n        self.hdg.place(relx=0.5, rely=0.5,\n                       anchor=CENTER)\n\n        self.close_btn = Button(self.top_fr,\n                                text='Quit',\n                                bd=5,\n                                bg='navy',\n                                fg='lemon chiffon',\n                                font='arial 12 bold',\n                                command=self.close_window)\n        self.close_btn.place(relx=0.07, rely=0.5,\n                             anchor=W)\n\n        self.clear_btn = Button(self.top_fr,\n                                text='Clear',\n                                bd=5,\n                                bg='navy',\n                                fg='lemon chiffon',\n                                font='arial 12 bold',\n                                command=self.clear_screen)\n        self.clear_btn.place(relx=0.92, rely=0.5,\n                             anchor=E)\n\n        # bottom frame:\n        self.btm_fr = Frame(gw,\n                            width=600,\n                            height=500,\n                            bg='lemon chiffon')\n        self.btm_fr.pack(fill=X)\n   \n        self.msg = Label(self.btm_fr,\n                         text=self.msga,\n                         font='arial 16 bold',\n                         fg='navy',\n                         bg='lemon chiffon')\n        self.msg.place(relx=0.5, rely=0.1,\n                       anchor=CENTER)\n\n        self.user_dgt_btn = Button(self.btm_fr,\n                                   text='My Digits',\n                                   width=12,                 \n                                   bd=5,\n                                   bg='navy',\n                                   fg='lemon chiffon',\n                                   font='arial 12 bold',\n                                   command=self.get_digits)\n        self.user_dgt_btn.place(relx=0.07, rely=0.2,\n                                anchor=W)\n\n        self.rdm_dgt_btn = Button(self.btm_fr,\n                                  text='Random Digits',\n                                  width=12,\n                                  bd=5,\n                                  bg='navy',\n                                  fg='lemon chiffon',\n                                  font='arial 12 bold',\n                                  command=self.gen_digits)\n        self.rdm_dgt_btn.place(relx=0.92, rely=0.2,\n                               anchor=E)\n\n        self.dgt_fr = LabelFrame(self.btm_fr,\n                                 text='   4 Digits  ',\n                                 bg='dodger blue',\n                                 fg='navy',\n                                 bd=4,\n                                 relief=RIDGE,\n                                 font='arial 12 bold')\n        self.dgt_fr.place(relx=0.5, rely=0.27,\n                          anchor=CENTER)\n\n        self.digit_ent = Entry(self.dgt_fr,\n                               justify='center',\n                               font='arial 16 bold',\n                               fg='navy',\n                               disabledforeground='navy',\n                               bg='lemon chiffon',\n                               disabledbackground='lemon chiffon',\n                               bd=4,\n                               width=6)\n        self.digit_ent.grid(row=0, column=0,\n                            padx=(8,8),\n                            pady=(8,8))\n        \n        self.chk_soln_btn = Button(self.btm_fr,\n                                   text='Check Solution',\n                                   state='disabled',\n                                   width=14,                 \n                                   bd=5,\n                                   bg='navy',\n                                   fg='lemon chiffon',\n                                   font='arial 12 bold',\n                                   command=self.check_soln)\n        self.chk_soln_btn.place(relx=0.07, rely=.42,\n                                anchor=W)\n\n        self.show_soln_btn = Button(self.btm_fr,\n                                    text='Show Solutions',\n                                    state='disabled',\n                                    width=14,\n                                    bd=5,\n                                    bg='navy',\n                                    fg='lemon chiffon',\n                                    font='arial 12 bold',\n                                    command=self.show_soln)\n        self.show_soln_btn.place(relx=0.92, rely=.42,\n                                 anchor=E)\n\n        self.soln_fr = LabelFrame(self.btm_fr,\n                                  text='  Solution  ',\n                                  bg='dodger blue',\n                                  fg='navy',\n                                  bd=4,\n                                  relief=RIDGE,\n                                  font='arial 12 bold')\n        self.soln_fr.place(relx=0.07, rely=0.58,\n                           anchor=W)\n\n        self.soln_ent = Entry(self.soln_fr,\n                              justify='center',\n                              font='arial 16 bold',\n                              fg='navy',\n                              disabledforeground='navy',\n                              bg='lemon chiffon',\n                              disabledbackground='lemon chiffon',\n                              state='disabled',\n                              bd=4,\n                              width=15)\n        self.soln_ent.grid(row=0, column=0,\n                           padx=(8,8), pady=(8,8))\n\n        self.solns_fr = LabelFrame(self.btm_fr,\n                                   text='  Solutions  ',\n                                   bg='dodger blue',\n                                   fg='navy',\n                                   bd=4,\n                                   relief=RIDGE,\n                                   font='arial 12 bold')\n        self.solns_fr.place(relx=0.92, rely=0.5,\n                            anchor='ne')\n\n        self.solns_all = ScrolledText(self.solns_fr,\n                                      font='courier 14 bold',\n                                      state='disabled',\n                                      fg='navy',\n                                      bg='lemon chiffon',\n                                      height=8,\n                                      width=14)\n        self.solns_all.grid(row=0, column=0,\n                            padx=(8,8), pady=(8,8))\n\n    # validate '4 Digits' entry.\n    # save if valid and switch screen to solution mode.\n    def get_digits(self):\n        txt = self.digit_ent.get()\n        if not(len(txt) == 4 and txt.isdigit()):\n            self.err_msg('Please enter 4 digits (eg 1357)')\n            return\n        self.digits = txt       # save\n        self.reset_one()        # to solution mode\n        return\n\n    # generate 4 random digits, display them,\n    # save them, and switch screen to solution mode.\n    def gen_digits(self):\n        self.digit_ent.delete(0, 'end')\n        self.digits = ''.join([random.choice('123456789')\n                       for i in range(4)])\n        self.digit_ent.insert(0, self.digits)   # display\n        self.reset_one()        # to solution mode\n        return\n\n    # switch screen from get digits to solution mode:\n    def reset_one(self):\n        self.digit_ent.config(state='disabled')\n        self.user_dgt_btn.config(state='disabled')\n        self.rdm_dgt_btn.config(state='disabled')\n        self.msg.config(text=self.msgb)\n        self.chk_soln_btn.config(state='normal')\n        self.show_soln_btn.config(state='normal')\n        self.soln_ent.config(state='normal')\n        return\n\n    # edit user's solution:\n    def check_soln(self):\n        txt = self.soln_ent.get()   # user's expression\n        d = ''                      # save digits in expression\n        dgt_op = 'd'                # expecting d:digit or o:operation\n        for t in txt:\n            if t not in '123456789+-*/() ':\n                self.err_msg('Invalid character found: ' + t)\n                return\n            if t.isdigit():\n                if dgt_op == 'd':\n                    d += t\n                    dgt_op = 'o'\n                else:\n                    self.err_msg('Need operator between digits')\n                    return\n            if t in '+-*/':\n                if dgt_op == 'o':\n                    dgt_op = 'd'\n                else:\n                    self.err_msg('Need digit befor operator')\n                    return\n        if sorted(d) != sorted(self.digits):\n            self.err_msg(\"Use each digit in '4 Digits' once\")\n            return\n        try:\n            # round covers up Python's\n            # representation of floats\n            if round(eval(txt),5) == 24:\n                messagebox.showinfo(\n                    'Success',\n                    'YOUR SOLUTION IS VADLID!')\n                self.show_soln()        # show all solutions\n                return                     \n        except:\n            self.err_msg('Invalid arithmetic expression')\n            return\n        messagebox.showinfo(\n            'Failure',\n            'Your expression does not yield 24')\n        return              \n\n    # show all solutions:\n    def show_soln(self):\n        # get all sets of 3 operands: ('+', '+', '*'), ...)\n        ops = ['+-*/', '+-*/', '+-*/']\n        combs = [p for p in itertools.product(*ops)]\n        \n        # get unique permutations for requested 4 digits:\n        d = self.digits\n        perms = set([''.join(p) for p in itertools.permutations(d)])\n\n        # list of all (hopefully) expressions for\n        # 4 operands and 3 operations:\n        formats = ['Aop1Bop2Cop3D',\n                   '(Aop1Bop2C)op3D',\n                   '((Aop1B)op2C)op3D',\n                   '(Aop1(Bop2C))op3D',\n                   'Aop1Bop2(Cop3D)',\n                   'Aop1(Bop2C)op3D',\n                   '(Aop1B)op2Cop3D',\n                   '(Aop1B)op2(Cop3D)',\n                   'Aop1(Bop2Cop3D)',\n                   'Aop1((Bop2C)op3D)',\n                   'Aop1(Bop2(Cop3D))']\n\n        lox = []            # list of valid expressions\n        \n        for fm in formats:                      # pick a format\n            for c in combs:                     # plug in 3 ops\n                f = fm.replace('op1', c[0])\n                f = f.replace('op2', c[1])\n                f = f.replace('op3', c[2])\n                for A, B, C, D in perms:        # plug in 4 digits\n                    x = f.replace('A', A)\n                    x = x.replace('B', B)\n                    x = x.replace('C', C)\n                    x = x.replace('D', D)\n                    try:                        # evaluate expression\n                        # round covers up Python's\n                        # representation of floats\n                        if round(eval(x),5) == 24:\n                            lox.append(' ' + x)\n                    except ZeroDivisionError:   # can ignore these\n                        continue\n        if lox:\n            txt = '\\n'.join(x for x in lox)\n        else:\n            txt =' No Solution'   \n        self.solns_all.config(state='normal')\n        self.solns_all.insert('end', txt)       # show solutions\n        self.solns_all.config(state='disabled')\n\n        self.chk_soln_btn.config(state='disabled')\n        self.show_soln_btn.config(state='disabled')\n        self.soln_ent.config(state='disabled')\n        return\n\n    def err_msg(self, msg):\n        messagebox.showerror('Error Message', msg)\n        return  \n\n    # restore screen to it's 'initial' state:\n    def clear_screen(self):\n        self.digits = ''\n        self.digit_ent.config(state='normal')\n        self.user_dgt_btn.config(state='normal')\n        self.rdm_dgt_btn.config(state='normal')\n        self.digit_ent.delete(0, 'end')\n        self.chk_soln_btn.config(state='disabled')\n        self.show_soln_btn.config(state='disabled')\n        self.soln_ent.config(state='normal')\n        self.soln_ent.delete(0, 'end')\n        self.soln_ent.config(state='disabled')\n        self.msg.config(text=self.msga)\n        self.clear_solns_all()\n        return\n\n    # clear the 'Solutions' frame.\n    # note: state must be 'normal' to change data\n    def clear_solns_all(self):\n        self.solns_all.config(state='normal')\n        self.solns_all.delete(1.0, 'end')\n        self.solns_all.config(state='disabled')\n        return\n        \n    def close_window(self):\n        self.window.destroy()\n\n# ************************************************\n\nroot = Tk()\nroot.title('24 Game')\nroot.geometry('600x600+100+50')\nroot.resizable(False, False)\ng = Game(root)\nroot.mainloop()\n\n", "explain": "The function is called solve, and is integrated into the game player.\nThe docstring of the solve function shows examples of its use when isolated at the Python command line.\nThe digits 3,3,8 and 8 have a solution that is not equal to 24 when using Pythons double-precision floating point because of a division in all answers. \nThe solver above switches to precise fractional arithmetic when division is involved and so can both recognise and solve for cases like this, (rather than allowing some range of closeness to 24).\nEvaluation needing precise division\nSolving needing precise division\nBased on the Julia example above.\nThis works for any amount of numbers by recursively picking two and merging them using all available operands until there is only one value left.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "C", "code": "\n\n#include <stdio.h>\n\ntypedef struct {int val, op, left, right;} Node;\n\nNode nodes[10000];\nint iNodes;\n\nint b;\nfloat eval(Node x){\n    if (x.op != -1){\n        float l = eval(nodes[x.left]), r = eval(nodes[x.right]);\n        switch(x.op){\n            case 0: return l+r;\n            case 1: return l-r;\n            case 2: return r-l;\n            case 3: return l*r;\n            case 4: return r?l/r:(b=1,0);\n            case 5: return l?r/l:(b=1,0);\n        }\n    }\n    else return x.val*1.;\n}\n\nvoid show(Node x){\n    if (x.op != -1){\n        printf(\"(\");\n        switch(x.op){\n            case 0: show(nodes[x.left]); printf(\" + \"); show(nodes[x.right]); break;\n            case 1: show(nodes[x.left]); printf(\" - \"); show(nodes[x.right]); break;\n            case 2: show(nodes[x.right]); printf(\" - \"); show(nodes[x.left]); break;\n            case 3: show(nodes[x.left]); printf(\" * \"); show(nodes[x.right]); break;\n            case 4: show(nodes[x.left]); printf(\" / \"); show(nodes[x.right]); break;\n            case 5: show(nodes[x.right]); printf(\" / \"); show(nodes[x.left]); break;\n        }\n        printf(\")\");\n    }\n    else printf(\"%d\", x.val);\n}\n\nint float_fix(float x){ return x < 0.00001 && x > -0.00001; }\n\nvoid solutions(int a[], int n, float t, int s){\n    if (s == n){\n        b = 0;\n        float e = eval(nodes[0]);        \n        \n        if (!b && float_fix(e-t)){\n            show(nodes[0]);\n            printf(\"\\n\");\n        }\n    }\n    else{\n        nodes[iNodes++] = (typeof(Node)){a[s],-1,-1,-1};\n        \n        for (int op = 0; op < 6; op++){    \n            int k = iNodes-1;\n            for (int i = 0; i < k; i++){\n                nodes[iNodes++] = nodes[i];\n                nodes[i] = (typeof(Node)){-1,op,iNodes-1,iNodes-2};\n                solutions(a, n, t, s+1);\n                nodes[i] = nodes[--iNodes];\n            }\n        }\n        \n        iNodes--;\n    }\n};\n\nint main(){\n    // define problem\n\n    int a[4] = {8, 3, 8, 3};\n    float t = 24;\n\n    // print all solutions\n\n    nodes[0] = (typeof(Node)){a[0],-1,-1,-1};\n    iNodes = 1;\n\n    solutions(a, sizeof(a)/sizeof(int), t, 1);\n\n    return 0;\n}\n\n", "explain": "Tested with GCC 10.2.0, but should work with all versions supporting C99.\nProvided code prints all solutions or nothing in case no solutions are found.\nIt can be modified or extended to work with more than 4 numbers, goals other than 24 and additional operations.\nNote: This a brute-force approach with time complexity O(6n.n.(2n-3)!!) and recursion depth n.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "C++", "code": "\nWorks with: C++11\nWorks with: GCC version 4.8\n\n#include <iostream>\n#include <ratio>\n#include <array>\n#include <algorithm>\n#include <random>\n\ntypedef short int Digit;  // Typedef for the digits data type.\n\nconstexpr Digit nDigits{4};      // Amount of digits that are taken into the game.\nconstexpr Digit maximumDigit{9}; // Maximum digit that may be taken into the game.\nconstexpr short int gameGoal{24};    // Desired result.\n\ntypedef std::array<Digit, nDigits> digitSet; // Typedef for the set of digits in the game.\ndigitSet d;\n\nvoid printTrivialOperation(std::string operation) { // Prints a commutative operation taking all the digits.\n\tbool printOperation(false);\n\tfor(const Digit& number : d) {\n\t\tif(printOperation)\n\t\t\tstd::cout << operation;\n\t\telse\n\t\t\tprintOperation = true;\n\t\tstd::cout << number;\n\t}\n\tstd::cout << std::endl;\n}\n\nvoid printOperation(std::string prefix, std::string operation1, std::string operation2, std::string operation3, std::string suffix = \"\") {\n\tstd::cout << prefix << d[0] << operation1 << d[1] << operation2 << d[2] << operation3 << d[3] << suffix << std::endl;\n}\n\nint main() {\n\tstd::mt19937_64 randomGenerator;\n\tstd::uniform_int_distribution<Digit> digitDistro{1, maximumDigit};\n\t// Let us set up a number of trials:\n\tfor(int trial{10}; trial; --trial) {\n\t\tfor(Digit& digit : d) {\n\t\t\tdigit = digitDistro(randomGenerator);\n\t\t\tstd::cout << digit << \" \";\n\t\t}\n\t\tstd::cout << std::endl;\n\t\tstd::sort(d.begin(), d.end());\n\t\t// We start with the most trivial, commutative operations:\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 0) == gameGoal)\n\t\t\tprintTrivialOperation(\" + \");\n\t\tif(std::accumulate(d.cbegin(), d.cend(), 1, std::multiplies<Digit>{}) == gameGoal)\n\t\t\tprintTrivialOperation(\" * \");\n\t\t// Now let's start working on every permutation of the digits.\n\t\tdo {\n\t\t\t// Operations with 2 symbols + and one symbol -:\n\t\t\tif(d[0] + d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" + \", \" + \", \" - \"); // If gameGoal is ever changed to a smaller value, consider adding more operations in this category.\n\t\t\t// Operations with 2 symbols + and one symbol *:\n\t\t\tif(d[0] * d[1] + d[2] + d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" + \");\n\t\t\tif(d[0] * (d[1] + d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] + d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" + \", \" )\");\n\t\t\t// Operations with one symbol + and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) + d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) + \");\n\t\t\tif(d[0] * d[1] * (d[2] + d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" + \", \" )\");\n\t\t\tif((d[0] * d[1]) + (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) + ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol - and 2 symbols *:\n\t\t\tif((d[0] * d[1] * d[2]) - d[3] == gameGoal) printOperation(\"( \", \" * \", \" * \", \" ) - \");\n\t\t\tif(d[0] * d[1] * (d[2] - d[3]) == gameGoal) printOperation(\"( \", \" * \", \" * ( \", \" - \", \" )\");\n\t\t\tif((d[0] * d[1]) - (d[2] * d[3]) == gameGoal) printOperation(\"( \", \" * \", \" ) - ( \", \" * \", \" )\");\n\t\t\t// Operations with one symbol +, one symbol *, and one symbol -:\n\t\t\tif(d[0] * d[1] + d[2] - d[3] == gameGoal) printOperation(\"\", \" * \", \" + \", \" - \");\n\t\t\tif(d[0] * (d[1] + d[2]) - d[3] == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" ) - \");\n\t\t\tif(d[0] * (d[1] - d[2]) + d[3] == gameGoal) printOperation(\"\", \" * ( \", \" - \", \" ) + \");\n\t\t\tif(d[0] * (d[1] + d[2] - d[3]) == gameGoal) printOperation(\"\", \" * ( \", \" + \", \" - \", \" )\");\n\t\t\tif(d[0] * d[1] - (d[2] + d[3]) == gameGoal) printOperation(\"\", \" * \", \" - ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol +:\n\t\t\tif(d[0] * d[1] == (gameGoal - d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) + \");\n\t\t\tif(((d[0] * d[1]) + d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) + \", \" ) / \");\n\t\t\tif((d[0] + d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" + \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] + d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" + \", \" )\");\n\t\t\t// Operations with one symbol *, one symbol /, one symbol -:\n\t\t\tif(d[0] * d[1] == (gameGoal + d[3]) * d[2]) printOperation(\"( \", \" * \", \" / \", \" ) - \");\n\t\t\tif(((d[0] * d[1]) - d[2]) == gameGoal * d[3]) printOperation(\"(( \", \" * \", \" ) - \", \" ) / \");\n\t\t\tif((d[0] - d[1]) * d[2] == gameGoal * d[3]) printOperation(\"(( \", \" - \", \" ) * \", \" ) / \");\n\t\t\tif(d[0] * d[1] == gameGoal * (d[2] - d[3])) printOperation(\"( \", \" * \", \" ) / ( \", \" - \", \" )\");\n\t\t\t// Operations with 2 symbols *, one symbol /:\n\t\t\tif(d[0] * d[1] * d[2] == gameGoal * d[3]) printOperation(\"\", \" * \", \" * \", \" / \");\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"\", \" * \", \" / ( \", \" * \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol -:\n\t\t\tif(d[0] * d[3] == gameGoal * (d[1] * d[3] - d[2])) printOperation(\"\", \" / ( \", \" - \", \" / \", \" )\");\n\t\t\t// Operations with 2 symbols /, one symbol *:\n\t\t\tif(d[0] * d[1] == gameGoal * d[2] * d[3]) printOperation(\"( \", \" * \", \" / \", \" ) / \", \"\");\n\t\t} while(std::next_permutation(d.begin(), d.end())); // All operations are repeated for all possible permutations of the numbers.\n\t}\n\treturn 0;\n}\n\n\nOutput:\n8 3 7 9 \n3 * ( 7 + 9 - 8 )\n3 * ( 9 + 7 - 8 )\n1 4 3 1 \n( 3 * 4 * ( 1 + 1 )\n( 4 * 3 * ( 1 + 1 )\n5 4 3 6 \n6 * ( 3 + 5 - 4 )\n6 * ( 5 + 3 - 4 )\n2 5 5 8 \n5 4 7 3 \n3 * 4 + 5 + 7\n3 * 4 + 7 + 5\n( 3 * 4 * ( 7 - 5 )\n3 * ( 5 + 7 - 4 )\n3 * ( 7 + 5 - 4 )\n4 * 3 + 5 + 7\n4 * 3 + 7 + 5\n( 4 * 3 * ( 7 - 5 )\n4 * 5 + 7 - 3\n5 * 4 + 7 - 3\n5 * ( 7 - 3 ) + 4\n3 3 9 2 \n2 * 9 + 3 + 3\n3 * ( 2 + 3 ) + 9\n3 * ( 2 + 9 - 3 )\n3 * ( 3 + 2 ) + 9\n3 * ( 9 - 2 ) + 3\n3 * ( 9 + 2 - 3 )\n9 * 2 + 3 + 3\n3 2 7 9 \n3 * ( 7 - 2 ) + 9\n(( 7 + 9 ) * 3 ) / 2\n(( 9 + 7 ) * 3 ) / 2\n7 1 5 3 \n7 6 9 4 \n(( 7 + 9 ) * 6 ) / 4\n(( 9 + 7 ) * 6 ) / 4\n3 5 3 1 \n( 1 * 3 * ( 3 + 5 )\n( 1 * 3 * ( 5 + 3 )\n( 3 * 1 * ( 3 + 5 )\n( 3 * 1 * ( 5 + 3 )\n(( 3 + 5 ) * 3 ) / 1\n(( 5 + 3 ) * 3 ) / 1\n\n", "explain": "This code may be extended to work with more than 4 numbers, goals other than 24, or different digit ranges. Operations have been manually determined for these parameters, with the belief they are complete.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Java", "code": "\nWorks with: Java version 7\n\nimport java.util.*;\n\npublic class Game24Player {\n    final String[] patterns = {\"nnonnoo\", \"nnonono\", \"nnnoono\", \"nnnonoo\",\n        \"nnnnooo\"};\n    final String ops = \"+-*/^\";\n\n    String solution;\n    List<Integer> digits;\n\n    public static void main(String[] args) {\n        new Game24Player().play();\n    }\n\n    void play() {\n        digits = getSolvableDigits();\n\n        Scanner in = new Scanner(System.in);\n        while (true) {\n            System.out.print(\"Make 24 using these digits: \");\n            System.out.println(digits);\n            System.out.println(\"(Enter 'q' to quit, 's' for a solution)\");\n            System.out.print(\"> \");\n\n            String line = in.nextLine();\n            if (line.equalsIgnoreCase(\"q\")) {\n                System.out.println(\"\\nThanks for playing\");\n                return;\n            }\n\n            if (line.equalsIgnoreCase(\"s\")) {\n                System.out.println(solution);\n                digits = getSolvableDigits();\n                continue;\n            }\n\n            char[] entry = line.replaceAll(\"[^*+-/)(\\\\d]\", \"\").toCharArray();\n\n            try {\n                validate(entry);\n\n                if (evaluate(infixToPostfix(entry))) {\n                    System.out.println(\"\\nCorrect! Want to try another? \");\n                    digits = getSolvableDigits();\n                } else {\n                    System.out.println(\"\\nNot correct.\");\n                }\n\n            } catch (Exception e) {\n                System.out.printf(\"%n%s Try again.%n\", e.getMessage());\n            }\n        }\n    }\n\n    void validate(char[] input) throws Exception {\n        int total1 = 0, parens = 0, opsCount = 0;\n\n        for (char c : input) {\n            if (Character.isDigit(c))\n                total1 += 1 << (c - '0') * 4;\n            else if (c == '(')\n                parens++;\n            else if (c == ')')\n                parens--;\n            else if (ops.indexOf(c) != -1)\n                opsCount++;\n            if (parens < 0)\n                throw new Exception(\"Parentheses mismatch.\");\n        }\n\n        if (parens != 0)\n            throw new Exception(\"Parentheses mismatch.\");\n\n        if (opsCount != 3)\n            throw new Exception(\"Wrong number of operators.\");\n\n        int total2 = 0;\n        for (int d : digits)\n            total2 += 1 << d * 4;\n\n        if (total1 != total2)\n            throw new Exception(\"Not the same digits.\");\n    }\n\n    boolean evaluate(char[] line) throws Exception {\n        Stack<Float> s = new Stack<>();\n        try {\n            for (char c : line) {\n                if ('0' <= c && c <= '9')\n                    s.push((float) c - '0');\n                else\n                    s.push(applyOperator(s.pop(), s.pop(), c));\n            }\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return (Math.abs(24 - s.peek()) < 0.001F);\n    }\n\n    float applyOperator(float a, float b, char c) {\n        switch (c) {\n            case '+':\n                return a + b;\n            case '-':\n                return b - a;\n            case '*':\n                return a * b;\n            case '/':\n                return b / a;\n            default:\n                return Float.NaN;\n        }\n    }\n\n    List<Integer> randomDigits() {\n        Random r = new Random();\n        List<Integer> result = new ArrayList<>(4);\n        for (int i = 0; i < 4; i++)\n            result.add(r.nextInt(9) + 1);\n        return result;\n    }\n\n    List<Integer> getSolvableDigits() {\n        List<Integer> result;\n        do {\n            result = randomDigits();\n        } while (!isSolvable(result));\n        return result;\n    }\n\n    boolean isSolvable(List<Integer> digits) {\n        Set<List<Integer>> dPerms = new HashSet<>(4 * 3 * 2);\n        permute(digits, dPerms, 0);\n\n        int total = 4 * 4 * 4;\n        List<List<Integer>> oPerms = new ArrayList<>(total);\n        permuteOperators(oPerms, 4, total);\n\n        StringBuilder sb = new StringBuilder(4 + 3);\n\n        for (String pattern : patterns) {\n            char[] patternChars = pattern.toCharArray();\n\n            for (List<Integer> dig : dPerms) {\n                for (List<Integer> opr : oPerms) {\n\n                    int i = 0, j = 0;\n                    for (char c : patternChars) {\n                        if (c == 'n')\n                            sb.append(dig.get(i++));\n                        else\n                            sb.append(ops.charAt(opr.get(j++)));\n                    }\n\n                    String candidate = sb.toString();\n                    try {\n                        if (evaluate(candidate.toCharArray())) {\n                            solution = postfixToInfix(candidate);\n                            return true;\n                        }\n                    } catch (Exception ignored) {\n                    }\n                    sb.setLength(0);\n                }\n            }\n        }\n        return false;\n    }\n\n    String postfixToInfix(String postfix) {\n        class Expression {\n            String op, ex;\n            int prec = 3;\n\n            Expression(String e) {\n                ex = e;\n            }\n\n            Expression(String e1, String e2, String o) {\n                ex = String.format(\"%s %s %s\", e1, o, e2);\n                op = o;\n                prec = ops.indexOf(o) / 2;\n            }\n        }\n\n        Stack<Expression> expr = new Stack<>();\n\n        for (char c : postfix.toCharArray()) {\n            int idx = ops.indexOf(c);\n            if (idx != -1) {\n\n                Expression r = expr.pop();\n                Expression l = expr.pop();\n\n                int opPrec = idx / 2;\n\n                if (l.prec < opPrec)\n                    l.ex = '(' + l.ex + ')';\n\n                if (r.prec <= opPrec)\n                    r.ex = '(' + r.ex + ')';\n\n                expr.push(new Expression(l.ex, r.ex, \"\" + c));\n            } else {\n                expr.push(new Expression(\"\" + c));\n            }\n        }\n        return expr.peek().ex;\n    }\n\n    char[] infixToPostfix(char[] infix) throws Exception {\n        StringBuilder sb = new StringBuilder();\n        Stack<Integer> s = new Stack<>();\n        try {\n            for (char c : infix) {\n                int idx = ops.indexOf(c);\n                if (idx != -1) {\n                    if (s.isEmpty())\n                        s.push(idx);\n                    else {\n                        while (!s.isEmpty()) {\n                            int prec2 = s.peek() / 2;\n                            int prec1 = idx / 2;\n                            if (prec2 >= prec1)\n                                sb.append(ops.charAt(s.pop()));\n                            else\n                                break;\n                        }\n                        s.push(idx);\n                    }\n                } else if (c == '(') {\n                    s.push(-2);\n                } else if (c == ')') {\n                    while (s.peek() != -2)\n                        sb.append(ops.charAt(s.pop()));\n                    s.pop();\n                } else {\n                    sb.append(c);\n                }\n            }\n            while (!s.isEmpty())\n                sb.append(ops.charAt(s.pop()));\n\n        } catch (EmptyStackException e) {\n            throw new Exception(\"Invalid entry.\");\n        }\n        return sb.toString().toCharArray();\n    }\n\n    void permute(List<Integer> lst, Set<List<Integer>> res, int k) {\n        for (int i = k; i < lst.size(); i++) {\n            Collections.swap(lst, i, k);\n            permute(lst, res, k + 1);\n            Collections.swap(lst, k, i);\n        }\n        if (k == lst.size())\n            res.add(new ArrayList<>(lst));\n    }\n\n    void permuteOperators(List<List<Integer>> res, int n, int total) {\n        for (int i = 0, npow = n * n; i < total; i++)\n            res.add(Arrays.asList((i / npow), (i % npow) / n, i % n));\n    }\n}\n\n\nOutput:\nMake 24 using these digits: [5, 7, 1, 8]\n(Enter 'q' to quit, 's' for a solution)\n> (8-5) * (7+1)\n\nCorrect! Want to try another?\nMake 24 using these digits: [3, 9, 2, 9]\n(Enter 'q' to quit, 's' for a solution)\n> (3*2) + 9 + 9\n\nCorrect! Want to try another?\nMake 24 using these digits: [4, 4, 8, 5]\n(Enter 'q' to quit, 's' for a solution)\n> s\n4 * 5 - (4 - 8)\nMake 24 using these digits: [2, 5, 9, 1]\n(Enter 'q' to quit, 's' for a solution)\n> 2+5+9+1\n\nNot correct.\nMake 24 using these digits: [2, 5, 9, 1]\n(Enter 'q' to quit, 's' for a solution)\n> 2 * 9 + 5 + 1\n\nCorrect! Want to try another?\nMake 24 using these digits: [8, 4, 3, 1]\n(Enter 'q' to quit, 's' for a solution)\n> s\n(8 + 4) * (3 - 1)\nMake 24 using these digits: [9, 4, 5, 6]\n(Enter 'q' to quit, 's' for a solution)\n> (9 +4) * 2 - 2\n\nNot the same digits. Try again.\nMake 24 using these digits: [9, 4, 5, 6]\n(Enter 'q' to quit, 's' for a solution)\n> q\n\nThanks for playing\n", "explain": "Playable version, will print solution on request.\nNote that this version does not extend to different digit ranges.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "C#", "code": "\n\nWorks with: C sharp version 8\nusing System;\nusing System.Collections.Generic;\nusing static System.Linq.Enumerable;\n\npublic static class Solve24Game\n{\n    public static void Main2() {\n        var testCases = new [] {\n            new [] { 1,1,2,7 },\n            new [] { 1,2,3,4 },\n            new [] { 1,2,4,5 },\n            new [] { 1,2,7,7 },\n            new [] { 1,4,5,6 },\n            new [] { 3,3,8,8 },\n            new [] { 4,4,5,9 },\n            new [] { 5,5,5,5 },\n            new [] { 5,6,7,8 },\n            new [] { 6,6,6,6 },\n            new [] { 6,7,8,9 },\n        };\n        foreach (var t in testCases) Test(24, t);\n        Test(100, 9,9,9,9,9,9);\n\n        static void Test(int target, params int[] numbers) {\n            foreach (var eq in GenerateEquations(target, numbers)) Console.WriteLine(eq);\n            Console.WriteLine();\n        }\n    }\n\n    static readonly char[] ops = { '*', '/', '+', '-' };\n    public static IEnumerable<string> GenerateEquations(int target, params int[] numbers) {\n        var operators = Repeat(ops, numbers.Length - 1).CartesianProduct().Select(e => e.ToArray()).ToList();\n        return (\n            from pattern in Patterns(numbers.Length)\n            let expression = CreateExpression(pattern)\n            from ops in operators\n            where expression.WithOperators(ops).HasPreferredTree()\n            from permutation in Permutations(numbers)\n            let expr = expression.WithValues(permutation)\n            where expr.Value == target && expr.HasPreferredValues()\n            select $\"{expr.ToString()} = {target}\")\n            .Distinct()\n            .DefaultIfEmpty($\"Cannot make {target} with {string.Join(\", \", numbers)}\");\n    }\n\n    ///<summary>Generates postfix expression trees where 1's represent operators and 0's represent numbers.</summary>\n    static IEnumerable<int> Patterns(int length) {\n        if (length == 1) yield return 0; //0\n        if (length == 2) yield return 1; //001\n        if (length < 3) yield break;\n        //Of each tree, the first 2 bits must always be 0 and the last bit must be 1. Generate the bits in between.\n        length -= 2;\n        int len = length * 2 + 3;\n        foreach (int permutation in BinaryPatterns(length, length * 2)) {\n            (int p, int l) = ((permutation << 1) + 1, len);\n            if (IsValidPattern(ref p, ref l)) yield return (permutation << 1) + 1;\n        }\n    }\n\n    ///<summary>Generates all numbers with the given number of 1's and total length.</summary>\n    static IEnumerable<int> BinaryPatterns(int ones, int length) {\n        int initial = (1 << ones) - 1;\n        int blockMask = (1 << length) - 1;\n        for (int v = initial; v >= initial; ) {\n            yield return v;\n            int w = (v | (v - 1)) + 1;\n            w |= (((w & -w) / (v & -v)) >> 1) - 1;\n            v = w & blockMask;\n        }\n    }\n\n    static bool IsValidPattern(ref int pattern, ref int len) {\n        bool isNumber = (pattern & 1) == 0;\n        pattern >>= 1;\n        len--;\n        if (isNumber) return true;\n        IsValidPattern(ref pattern, ref len);\n        IsValidPattern(ref pattern, ref len);\n        return len == 0;\n    }\n\n    static Expr CreateExpression(int pattern) {\n        return Create();\n\n        Expr Create() {\n            bool isNumber = (pattern & 1) == 0;\n            pattern >>= 1;\n            if (isNumber) return new Const(0);\n            Expr right = Create();\n            Expr left = Create();\n            return new Binary('*', left, right);\n        }\n    }\n\n    static IEnumerable<IEnumerable<T>> CartesianProduct<T>(this IEnumerable<IEnumerable<T>> sequences) {\n        IEnumerable<IEnumerable<T>> emptyProduct = new[] { Empty<T>() };\n        return sequences.Aggregate(\n            emptyProduct,\n            (accumulator, sequence) =>\n                from acc in accumulator\n                from item in sequence\n                select acc.Concat(new [] { item }));\n    }\n\n    private static List<int> helper = new List<int>();\n    public static IEnumerable<T[]> Permutations<T>(params T[] input) {\n        if (input == null || input.Length == 0) yield break;\n        helper.Clear();\n        for (int i = 0; i < input.Length; i++) helper.Add(i);\n        while (true) {\n            yield return input;\n            int cursor = helper.Count - 2;\n            while (cursor >= 0 && helper[cursor] > helper[cursor + 1]) cursor--;\n            if (cursor < 0) break;\n            int i = helper.Count - 1;\n            while (i > cursor && helper[i] < helper[cursor]) i--;\n            (helper[cursor], helper[i]) = (helper[i], helper[cursor]);\n            (input[cursor], input[i]) = (input[i], input[cursor]);\n            int firstIndex = cursor + 1;\n            for (int lastIndex = helper.Count - 1; lastIndex > firstIndex; ++firstIndex, --lastIndex) {\n                (helper[firstIndex], helper[lastIndex]) = (helper[lastIndex], helper[firstIndex]);\n                (input[firstIndex], input[lastIndex]) = (input[lastIndex], input[firstIndex]);\n            }\n        }\n    }\n\n    static Expr WithOperators(this Expr expr, char[] operators) {\n        int i = 0;\n        SetOperators(expr, operators, ref i);\n        return expr;\n\n        static void SetOperators(Expr expr, char[] operators, ref int i) {\n            if (expr is Binary b) {\n                b.Symbol = operators[i++];\n                SetOperators(b.Right, operators, ref i);\n                SetOperators(b.Left, operators, ref i);\n            }\n        }\n    }\n\n    static Expr WithValues(this Expr expr, int[] values) {\n        int i = 0;\n        SetValues(expr, values, ref i);\n        return expr;\n\n        static void SetValues(Expr expr, int[] values, ref int i) {\n            if (expr is Binary b) {\n                SetValues(b.Left, values, ref i);\n                SetValues(b.Right, values, ref i);\n            } else {\n                expr.Value = values[i++];\n            }\n        }\n    }\n\n    static bool HasPreferredTree(this Expr expr) => expr switch {\n        Const _ => true,\n    \n        // a / b * c => a * c / b\n        ((_, '/' ,_), '*', _) => false,\n        // c + a * b => a * b + c\n        (var l, '+', (_, '*' ,_) r) when l.Depth < r.Depth => false,\n        // c + a / b => a / b + c\n        (var l, '+', (_, '/' ,_) r) when l.Depth < r.Depth => false,\n        // a * (b + c) => (b + c) * a\n        (var l, '*', (_, '+' ,_) r) when l.Depth < r.Depth => false,\n        // a * (b - c) => (b - c) * a\n        (var l, '*', (_, '-' ,_) r) when l.Depth < r.Depth => false,\n        // (a +- b) + (c */ d) => ((c */ d) + a) +- b\n        ((_, var p, _), '+', (_, var q, _)) when \"+-\".Contains(p) && \"*/\".Contains(q) => false,\n        // a + (b + c) => (a + b) + c\n        (var l, '+', (_, '+' ,_) r) => false,\n        // a + (b - c) => (a + b) - c\n        (var l, '+', (_, '-' ,_) r) => false,\n        // a - (b + c) => (a - b) + c\n        (_, '-', (_, '+', _)) => false,\n        // a * (b * c) => (a * b) * c\n        (var l, '*', (_, '*' ,_) r) => false,\n        // a * (b / c) => (a * b) / c\n        (var l, '*', (_, '/' ,_) r) => false,\n        // a / (b / c) => (a * c) / b\n        (var l, '/', (_, '/' ,_) r) => false,\n        // a - (b - c) * d => (c - b) * d + a\n        (_, '-', ((_, '-' ,_), '*', _)) => false,\n        // a - (b - c) / d => (c - b) / d + a\n        (_, '-', ((_, '-' ,_), '/', _)) => false,\n        // a - (b - c) => a + c - b\n        (_, '-', (_, '-', _)) => false,\n        // (a - b) + c => (a + c) - b\n        ((_, '-', var b), '+', var c) => false,\n\n        (var l, _, var r) => l.HasPreferredTree() && r.HasPreferredTree()\n    };\n\n    static bool HasPreferredValues(this Expr expr) => expr switch {\n        Const _ => true,\n\n        // -a + b => b - a\n        (var l, '+', var r) when l.Value < 0 && r.Value >= 0 => false,\n        // b * a => a * b\n        (var l, '*', var r) when l.Depth == r.Depth && l.Value > r.Value => false,\n        // b + a => a + b\n        (var l, '+', var r) when l.Depth == r.Depth && l.Value > r.Value => false,\n        // (b o c) * (a o d) => (a o d) * (b o c)\n        ((var a, _, _) l, '*', (var c, _, _) r) when l.Value == r.Value && l.Depth == r.Depth && a.Value < c.Value => false,\n        // (b o c) + (a o d) => (a o d) + (b o c)\n        ((var a, var p, _) l, '+', (var c, var q, _) r) when l.Value == r.Value && l.Depth == r.Depth && a.Value < c.Value => false,\n        // (a * c) * b => (a * b) * c\n        ((_, '*', var c), '*', var b) when b.Value < c.Value => false,\n        // (a + c) + b => (a + b) + c\n        ((_, '+', var c), '+', var b) when b.Value < c.Value => false,\n        // (a - b) - c => (a - c) - b\n        ((_, '-', var b), '-', var c) when b.Value < c.Value => false,\n        // a / 1 => a * 1\n        (_, '/', var b) when b.Value == 1 => false,\n        // a * b / b => a + b - b\n        ((_, '*', var b), '/', var c) when b.Value == c.Value => false,\n        // a * 1 * 1 => a + 1 - 1\n        ((_, '*', var b), '*', var c) when b.Value == 1 && c.Value == 1 => false,\n\n        (var l, _, var r) => l.HasPreferredValues() && r.HasPreferredValues()\n    };\n\n    private struct Fraction : IEquatable<Fraction>, IComparable<Fraction>\n    {\n        public readonly int Numerator, Denominator;\n\n        public Fraction(int numerator, int denominator)\n            => (Numerator, Denominator) = (numerator, denominator) switch\n        {\n            (_, 0) => (Math.Sign(numerator), 0),\n            (0, _) => (0, 1),\n            (_, var d) when d < 0 => (-numerator, -denominator),\n            _ => (numerator, denominator)\n        };\n\n        public static implicit operator Fraction(int i) => new Fraction(i, 1);\n        public static Fraction operator +(Fraction a, Fraction b) =>\n            new Fraction(a.Numerator * b.Denominator + a.Denominator * b.Numerator, a.Denominator * b.Denominator);\n        public static Fraction operator -(Fraction a, Fraction b) =>\n            new Fraction(a.Numerator * b.Denominator + a.Denominator * -b.Numerator, a.Denominator * b.Denominator);\n        public static Fraction operator *(Fraction a, Fraction b) =>\n            new Fraction(a.Numerator * b.Numerator, a.Denominator * b.Denominator);\n        public static Fraction operator /(Fraction a, Fraction b) =>\n            new Fraction(a.Numerator * b.Denominator, a.Denominator * b.Numerator);\n\n        public static bool operator ==(Fraction a, Fraction b) => a.CompareTo(b) == 0;\n        public static bool operator !=(Fraction a, Fraction b) => a.CompareTo(b) != 0;\n        public static bool operator  <(Fraction a, Fraction b) => a.CompareTo(b)  < 0;\n        public static bool operator  >(Fraction a, Fraction b) => a.CompareTo(b)  > 0;\n        public static bool operator <=(Fraction a, Fraction b) => a.CompareTo(b) <= 0;\n        public static bool operator >=(Fraction a, Fraction b) => a.CompareTo(b) >= 0;\n\n        public bool Equals(Fraction other) => Numerator == other.Numerator && Denominator == other.Denominator;\n        public override string ToString() => Denominator == 1 ? Numerator.ToString() : $\"[{Numerator}/{Denominator}]\";\n\n        public int CompareTo(Fraction other) => (Numerator, Denominator, other.Numerator, other.Denominator) switch {\n            var (    n1, d1,     n2, d2) when n1 == n2 && d1 == d2 => 0,\n                (     0,  0,      _,  _) => (-1),\n                (     _,  _,      0,  0) => 1,\n            var (    n1, d1,     n2, d2) when d1 == d2 => n1.CompareTo(n2),\n                (var n1,  0,      _,  _) => Math.Sign(n1),\n                (     _,  _, var n2,  0) => Math.Sign(n2),\n            var (    n1, d1,     n2, d2) => (n1 * d2).CompareTo(n2 * d1)\n        };\n    }\n\n    private abstract class Expr\n    {\n        protected Expr(char symbol) => Symbol = symbol;\n        public char Symbol { get; set; }\n        public abstract Fraction Value { get; set; }\n        public abstract int Depth { get; }\n        public abstract void Deconstruct(out Expr left, out char symbol, out Expr right);\n    }\n\n    private sealed class Const : Expr\n    {\n        public Const(Fraction value) : base('c') => Value = value;\n        public override Fraction Value { get; set; }\n        public override int Depth => 0;\n        public override void Deconstruct(out Expr left, out char symbol, out Expr right) => (left, symbol, right) = (this, Symbol, this);\n        public override string ToString() => Value.ToString();\n    }\n\n    private sealed class Binary : Expr\n    {\n        public Binary(char symbol, Expr left, Expr right) : base(symbol) => (Left, Right) = (left, right);\n        public Expr Left { get; }\n        public Expr Right { get; }\n        public override int Depth => Math.Max(Left.Depth, Right.Depth) + 1;\n        public override void Deconstruct(out Expr left, out char symbol, out Expr right) => (left, symbol, right) = (Left, Symbol, Right);\n\n        public override Fraction Value {\n            get => Symbol switch {\n                '*' => Left.Value * Right.Value,\n                '/' => Left.Value / Right.Value,\n                '+' => Left.Value + Right.Value,\n                '-' => Left.Value - Right.Value,\n                _ => throw new InvalidOperationException() };\n            set {}\n        }\n\n        public override string ToString() => Symbol switch {\n            '*' => ToString(\"+-\".Contains(Left.Symbol), \"+-\".Contains(Right.Symbol)),\n            '/' => ToString(\"+-\".Contains(Left.Symbol), \"*/+-\".Contains(Right.Symbol)),\n            '+' => ToString(false, false),\n            '-' => ToString(false, \"+-\".Contains(Right.Symbol)),\n            _ => $\"[{Value}]\"\n        };\n\n        private string ToString(bool wrapLeft, bool wrapRight) =>\n            $\"{(wrapLeft\u00a0? $\"({Left})\"\u00a0: $\"{Left}\")} {Symbol} {(wrapRight\u00a0? $\"({Right})\"\u00a0: $\"{Right}\")}\";\n    }\n}\n\n\nOutput:\n(1 + 2) * (1 + 7) = 24\n\n(1 + 3) * (2 + 4) = 24\n1 * 2 * 3 * 4 = 24\n(1 + 2 + 3) * 4 = 24\n\n(5 - 1) * (2 + 4) = 24\n(2 + 5 - 1) * 4 = 24\n\n(7 * 7 - 1) / 2 = 24\n\n4 / (1 - 5 / 6) = 24\n6 / (5 / 4 - 1) = 24\n\n8 / (3 - 8 / 3) = 24\n\nCannot make 24 with 4, 4, 5, 9\n\n5 * 5 - 5 / 5 = 24\n\n(8 - 6) * (5 + 7) = 24\n6 * 8 / (7 - 5) = 24\n(5 + 7 - 8) * 6 = 24\n\n6 + 6 + 6 + 6 = 24\n6 * 6 - 6 - 6 = 24\n\n6 * 8 / (9 - 7) = 24\n\n(9 / 9 + 9) * (9 / 9 + 9) = 100\n", "explain": "Generate binary trees -> generate permutations -> create expression -> evaluate expression\nThis works with other targets and more numbers but it will of course become slower.\nRedundant expressions are filtered out (based on https://www.4nums.com/theory/) but I'm not sure I caught them all.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\n\nvar ar=[],order=[0,1,2],op=[],val=[];\nvar NOVAL=9999,oper=\"+-*/\",out;\n\nfunction rnd(n){return Math.floor(Math.random()*n)}\n\nfunction say(s){\n try{document.write(s+\"<br>\")}\n catch(e){WScript.Echo(s)}\n}\n\nfunction getvalue(x,dir){\n var r=NOVAL;\n if(dir>0)++x;\n while(1){\n  if(val[x]!=NOVAL){\n   r=val[x];\n   val[x]=NOVAL;\n   break;\n  }\n  x+=dir;\n }\n return r*1;\n}\n\nfunction calc(){\n var c=0,l,r,x;\n val=ar.join('/').split('/');\n while(c<3){\n  x=order[c];\n  l=getvalue(x,-1);\n  r=getvalue(x,1);\n  switch(op[x]){\n   case 0:val[x]=l+r;break;\n   case 1:val[x]=l-r;break;\n   case 2:val[x]=l*r;break;\n   case 3:\n   if(!r||l%r)return 0;\n   val[x]=l/r;\n  }\n  ++c;\n }\n return getvalue(-1,1);\n}\n\nfunction shuffle(s,n){\n var x=n,p=eval(s),r,t;\n while(x--){\n  r=rnd(n);\n  t=p[x];\n  p[x]=p[r];\n  p[r]=t;\n }\n}\n\nfunction parenth(n){\n while(n>0)--n,out+='(';\n while(n<0)++n,out+=')';\n}\n\nfunction getpriority(x){\n for(var z=3;z--;)if(order[z]==x)return 3-z;\n return 0;\n}\n\nfunction showsolution(){\n var x=0,p=0,lp=0,v=0;\n while(x<4){\n  if(x<3){\n   lp=p;\n   p=getpriority(x);\n   v=p-lp;\n   if(v>0)parenth(v);\n  }\n  out+=ar[x];\n  if(x<3){\n   if(v<0)parenth(v);\n   out+=oper.charAt(op[x]);\n  }\n  ++x;\n }\n parenth(-p);\n say(out);\n}\n\nfunction solve24(s){\n var z=4,r;\n while(z--)ar[z]=s.charCodeAt(z)-48;\n out=\"\";\n for(z=100000;z--;){\n  r=rnd(256);\n  op[0]=r&3;\n  op[1]=(r>>2)&3;\n  op[2]=(r>>4)&3;\n  shuffle(\"ar\",4);\n  shuffle(\"order\",3);\n  if(calc()!=24)continue;\n  showsolution();\n  break;\n }\n}\n\nsolve24(\"1234\");\nsolve24(\"6789\");\nsolve24(\"1127\");\n\n\n(((3*1)*4)*2)\n((6*8)/((9-7)))\n(((1+7))*(2+1))\n", "explain": "This is a translation of the C code.\nExamples:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Fortran", "code": "\nprogram solve_24\n  use helpers\n  implicit none\n  real                 :: vector(4), reals(4), p, q, r, s\n  integer              :: numbers(4), n, i, j, k, a, b, c, d\n  character, parameter :: ops(4) = (/ '+', '-', '*', '/' /)\n  logical              :: last\n  real,parameter       :: eps = epsilon(1.0)\n\n  do n=1,12\n    call random_number(vector)\n    reals   = 9 * vector + 1\n    numbers = int(reals)\n    call Insertion_Sort(numbers)\n    \n    permutations: do\n      a = numbers(1); b = numbers(2); c = numbers(3); d = numbers(4)\n      reals = real(numbers)\n      p = reals(1);   q = reals(2);   r = reals(3);   s = reals(4)\n      ! combinations of operators:\n      do i=1,4\n        do j=1,4\n          do k=1,4\n            if      ( abs(op(op(op(p,i,q),j,r),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '((',a,ops(i),b,')',ops(j),c,')',ops(k),d\n              exit permutations\n            else if ( abs(op(op(p,i,op(q,j,r)),k,s)-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),'(',b,ops(j),c,'))',ops(k),d\n              exit permutations\n            else if ( abs(op(p,i,op(op(q,j,r),k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'((',b,ops(j),c,')',ops(k),d,')'\n              exit permutations\n            else if ( abs(op(p,i,op(q,j,op(r,k,s)))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', a,ops(i),'(',b,ops(j),'(',c,ops(k),d,'))'\n              exit permutations\n            else if ( abs(op(op(p,i,q),j,op(r,k,s))-24.0) < eps ) then\n              write (*,*) numbers, '\u00a0: ', '(',a,ops(i),b,')',ops(j),'(',c,ops(k),d,')'\n              exit permutations\n            end if\n          end do\n        end do\n      end do\n      call nextpermutation(numbers,last)  \n      if ( last ) then\n        write (*,*) numbers, '\u00a0: no solution.'\n        exit permutations\n      end if\n    end do permutations\n\n  end do\n\ncontains\n\n  pure real function op(x,c,y)\n    integer, intent(in) :: c\n    real, intent(in)    :: x,y\n    select case ( ops(c) )\n      case ('+')\n        op = x+y\n      case ('-')\n        op = x-y\n      case ('*')\n        op = x*y\n      case ('/')\n        op = x/y\n    end select\n  end function op\n\nend program solve_24\n\nmodule helpers\n\ncontains\n  \n  pure subroutine Insertion_Sort(a)\n    integer, intent(inout) :: a(:)\n    integer                :: temp, i, j\n    do i=2,size(a)\n      j = i-1\n      temp = a(i)\n      do while ( j>=1 .and. a(j)>temp )\n        a(j+1) = a(j)\n        j = j - 1\n      end do\n      a(j+1) = temp\n    end do\n  end subroutine Insertion_Sort\n\n  subroutine nextpermutation(perm,last)\n    integer, intent(inout) :: perm(:)\n    logical, intent(out)   :: last\n    integer :: k,l\n    k = largest1()\n    last = k == 0\n    if ( .not. last ) then    \n      l = largest2(k)\n      call swap(l,k)\n      call reverse(k)\n    end if\n  contains\n    pure integer function largest1()\n      integer :: k, max\n      max = 0\n      do k=1,size(perm)-1\n        if ( perm(k) < perm(k+1) ) then\n          max = k\n        end if\n      end do\n      largest1 = max\n    end function largest1\n\n    pure integer function largest2(k)\n      integer, intent(in) :: k\n      integer             :: l, max\n      max = k+1\n      do l=k+2,size(perm)\n        if ( perm(k) < perm(l) ) then\n          max = l\n        end if\n      end do\n      largest2 = max\n    end function largest2\n\n    subroutine swap(l,k)\n      integer, intent(in) :: k,l\n      integer             :: temp\n      temp    = perm(k)\n      perm(k) = perm(l)\n      perm(l) = temp\n    end subroutine swap\n    \n    subroutine reverse(k)\n      integer, intent(in) :: k\n      integer             :: i\n      do i=1,(size(perm)-k)/2\n        call swap(k+i,size(perm)+1-i)\n      end do\n    end subroutine reverse\n    \n  end subroutine nextpermutation\n\nend module helpers\n\n\nOutput: (using g95)\n\n 3 6 7 9 \u00a0:  3 *(( 6 - 7 )+ 9 )\n 3 9 5 8 \u00a0: (( 3 * 9 )+ 5 )- 8\n 4 5 6 9 \u00a0: (( 4 + 5 )+ 6 )+ 9\n 2 9 9 8 \u00a0: ( 2 +( 9 / 9 ))* 8\n 1 4 7 5 \u00a0: ( 1 +( 4 * 7 ))- 5\n 8 7 7 6 \u00a0: no solution.\n 3 3 8 9 \u00a0: ( 3 *( 3 + 8 ))- 9\n 1 5 6 7 \u00a0: ( 1 +( 5 * 6 ))- 7\n 2 3 5 3 \u00a0:  2 *(( 3 * 5 )- 3 )\n 4 5 6 9 \u00a0: (( 4 + 5 )+ 6 )+ 9\n 1 1 3 6 \u00a0: ( 1 +( 1 * 3 ))* 6\n 2 4 6 8 \u00a0: (( 2 / 4 )* 6 )* 8\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"fmt\"\n\t\"math/rand\"\n\t\"time\"\n)\n\nconst (\n\top_num = iota\n\top_add\n\top_sub\n\top_mul\n\top_div\n)\n\ntype frac struct {\n\tnum, denom int\n}\n\n// Expression: can either be a single number, or a result of binary\n// operation from left and right node\ntype Expr struct {\n\top          int\n\tleft, right *Expr\n\tvalue       frac\n}\n\nvar n_cards = 4\nvar goal = 24\nvar digit_range = 9\n\nfunc (x *Expr) String() string {\n\tif x.op == op_num {\n\t\treturn fmt.Sprintf(\"%d\", x.value.num)\n\t}\n\n\tvar bl1, br1, bl2, br2, opstr string\n\tswitch {\n\tcase x.left.op == op_num:\n\tcase x.left.op >= x.op:\n\tcase x.left.op == op_add && x.op == op_sub:\n\t\tbl1, br1 = \"\", \"\"\n\tdefault:\n\t\tbl1, br1 = \"(\", \")\"\n\t}\n\n\tif x.right.op == op_num || x.op < x.right.op {\n\t\tbl2, br2 = \"\", \"\"\n\t} else {\n\t\tbl2, br2 = \"(\", \")\"\n\t}\n\n\tswitch {\n\tcase x.op == op_add:\n\t\topstr = \" + \"\n\tcase x.op == op_sub:\n\t\topstr = \" - \"\n\tcase x.op == op_mul:\n\t\topstr = \" * \"\n\tcase x.op == op_div:\n\t\topstr = \" / \"\n\t}\n\n\treturn bl1 + x.left.String() + br1 + opstr +\n\t\tbl2 + x.right.String() + br2\n}\n\nfunc expr_eval(x *Expr) (f frac) {\n\tif x.op == op_num {\n\t\treturn x.value\n\t}\n\n\tl, r := expr_eval(x.left), expr_eval(x.right)\n\n\tswitch x.op {\n\tcase op_add:\n\t\tf.num = l.num*r.denom + l.denom*r.num\n\t\tf.denom = l.denom * r.denom\n\t\treturn\n\n\tcase op_sub:\n\t\tf.num = l.num*r.denom - l.denom*r.num\n\t\tf.denom = l.denom * r.denom\n\t\treturn\n\n\tcase op_mul:\n\t\tf.num = l.num * r.num\n\t\tf.denom = l.denom * r.denom\n\t\treturn\n\n\tcase op_div:\n\t\tf.num = l.num * r.denom\n\t\tf.denom = l.denom * r.num\n\t\treturn\n\t}\n\treturn\n}\n\nfunc solve(ex_in []*Expr) bool {\n\t// only one expression left, meaning all numbers are arranged into\n\t// a binary tree, so evaluate and see if we get 24\n\tif len(ex_in) == 1 {\n\t\tf := expr_eval(ex_in[0])\n\t\tif f.denom != 0 && f.num == f.denom*goal {\n\t\t\tfmt.Println(ex_in[0].String())\n\t\t\treturn true\n\t\t}\n\t\treturn false\n\t}\n\n\tvar node Expr\n\tex := make([]*Expr, len(ex_in)-1)\n\n\t// try to combine a pair of expressions into one, thus reduce\n\t// the list length by 1, and recurse down\n\tfor i := range ex {\n\t\tcopy(ex[i:len(ex)], ex_in[i+1:len(ex_in)])\n\n\t\tex[i] = &node\n\t\tfor j := i + 1; j < len(ex_in); j++ {\n\t\t\tnode.left = ex_in[i]\n\t\t\tnode.right = ex_in[j]\n\n\t\t\t// try all 4 operators\n\t\t\tfor o := op_add; o <= op_div; o++ {\n\t\t\t\tnode.op = o\n\t\t\t\tif solve(ex) {\n\t\t\t\t\treturn true\n\t\t\t\t}\n\t\t\t}\n\n\t\t\t// also - and / are not commutative, so swap arguments\n\t\t\tnode.left = ex_in[j]\n\t\t\tnode.right = ex_in[i]\n\n\t\t\tnode.op = op_sub\n\t\t\tif solve(ex) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tnode.op = op_div\n\t\t\tif solve(ex) {\n\t\t\t\treturn true\n\t\t\t}\n\n\t\t\tif j < len(ex) {\n\t\t\t\tex[j] = ex_in[j]\n\t\t\t}\n\t\t}\n\t\tex[i] = ex_in[i]\n\t}\n\treturn false\n}\n\nfunc main() {\n\tcards := make([]*Expr, n_cards)\n\trand.Seed(time.Now().Unix())\n\n\tfor k := 0; k < 10; k++ {\n\t\tfor i := 0; i < n_cards; i++ {\n\t\t\tcards[i] = &Expr{op_num, nil, nil,\n\t\t\t\tfrac{rand.Intn(digit_range-1) + 1, 1}}\n\t\t\tfmt.Printf(\" %d\", cards[i].value.num)\n\t\t}\n\t\tfmt.Print(\":  \")\n\t\tif !solve(cards) {\n\t\t\tfmt.Println(\"No solution\")\n\t\t}\n\t}\n}\n\n\nOutput:\n 8 6 7 6:  No solution\n 7 2 6 6:  (7 - 2) * 6 - 6\n 4 8 7 3:  4 * (7 - 3) + 8\n 3 8 8 7:  3 * 8 * (8 - 7)\n 5 7 3 7:  No solution\n 5 7 8 3:  5 * 7 - 8 - 3\n 3 6 5 2:  ((3 + 5) * 6) / 2\n 8 4 5 4:  (8 - 4) * 5 + 4\n 2 2 8 8:  (2 + 2) * 8 - 8\n 6 8 8 2:  6 + 8 + 8 + 2\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program game24Solver.s   */ \n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n.equ STDIN,      0       @ Linux input console\n.equ READ,       3       @ Linux syscall\n.equ NBDIGITS,   4       @ digits number\n.equ TOTAL,      24\n.equ BUFFERSIZE, 80\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessRules:        .ascii \"24 Game\\n\"\n                    .ascii \"The program will display four randomly-generated \\n\"\n                    .asciz \"single-digit numbers and search a solution for a total to 24\\n\\n\"\n\nszMessDigits:       .asciz \"The four digits are @ @ @ @ and the score is 24. \\n\"\nszMessOK:           .asciz \"Solution\u00a0: \\n\"\nszMessNotOK:        .asciz \"No solution for this problem\u00a0!! \\n\"\nszMessNewGame:      .asciz \"New game (y/n)\u00a0? \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n.align 4\niGraine:            .int 123456\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\n.align 4\nsZoneConv:        .skip 24\nsBuffer:          .skip BUFFERSIZE\niTabDigit:        .skip 4 * NBDIGITS @ digits table\niTabOperand1:     .skip 4 * NBDIGITS @ operand 1 table \niTabOperand2:     .skip 4 * NBDIGITS @ operand 2 table\niTabOperation:    .skip 4 * NBDIGITS @ operator table\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                 @ entry of program \n    \n    ldr r0,iAdrszMessRules            @ display rules\n    bl affichageMess\n1:\n    mov r3,#0\n    ldr r12,iAdriTabDigit\n    ldr r5,iAdrszMessDigits\n2:                                    @ loop generate random digits \n    mov r0,#8\n    bl genereraleas \n    add r0,r0,#1\n    str r0,[r12,r3,lsl #2]            @ store in table\n    ldr r1,iAdrsZoneConv\n    bl conversion10                   @ call decimal conversion\n    mov r2,#0\n    strb r2,[r1,r0]                   @ reduce size display area with z\u00e9ro final\n    mov r0,r5\n    ldr r1,iAdrsZoneConv              @ insert conversion in message\n    bl strInsertAtCharInc\n    mov r5,r0\n    add r3,r3,#1\n    cmp r3,#NBDIGITS                  @ end\u00a0?\n    blt 2b                            @ no -> loop\n    mov r0,r5\n    bl affichageMess\n    \n    mov r0,#0                         @ start leval\n    mov r1,r12                        @ address digits table\n    bl searchSoluce\n    cmp r0,#-1                        @ solution\u00a0?\n    bne 3f                            @ no \n    ldr r0,iAdrszMessOK\n    bl affichageMess\n    bl writeSoluce                    @ yes -> write solution in buffer \n    ldr r0,iAdrsBuffer                @ and display buffer\n    bl affichageMess\n    b 10f\n3:                                    @ display message no solution\n    ldr r0,iAdrszMessNotOK\n    bl affichageMess\n\n\n10:                                   @ display new game\u00a0?\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    ldr r0,iAdrszMessNewGame\n    bl affichageMess\n    bl saisie\n    cmp r0,#'y'\n    beq 1b\n    cmp r0,#'Y'\n    beq 1b\n    \n100:                                  @ standard end of the program \n    mov r0, #0                        @ return code\n    mov r7, #EXIT                     @ request to exit program\n    svc #0                            @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessRules:          .int szMessRules\niAdrszMessDigits:         .int szMessDigits\niAdrszMessNotOK:          .int szMessNotOK\niAdrszMessOK:             .int szMessOK\niAdrszMessNewGame:        .int szMessNewGame\niAdrsZoneConv:            .int sZoneConv\niAdriTabDigit:            .int iTabDigit\n/******************************************************************/\n/*            recherche solution                                       */ \n/******************************************************************/\n/* r0 level   */\n/* r1 table value address */\n/* r0 return -1 if ok     */\nsearchSoluce:\n    push {r1-r12,lr}                @ save registers\n    sub sp,#4* NBDIGITS             @ reserve size new digits table\n    mov fp,sp                       @ frame pointer = address stack\n    mov r10,r1                      @ save table\n    add r9,r0,#1                    @ new  level\n    rsb r3,r9,#NBDIGITS             @ last element digits table\n    ldr r4,[r1,r3,lsl #2]           @ load last element\n    cmp r4,#TOTAL                   @ equal to total to search\u00a0?\n    bne 0f                          @ no\n    cmp r9,#NBDIGITS                @ all digits are used\u00a0?\n    bne 0f                          @ no\n    mov r0,#-1                      @ yes -> it is ok -> end\n    b 100f\n0:\n    mov r5,#0                       @ indice loop 1\n1:                                  @ begin loop 1\n    cmp r5,r3\n    bge 9f\n    ldr r4,[r10,r5,lsl #2]          @ load first operand\n    ldr r8,iAdriTabOperand1\n    str r4,[r8,r9,lsl #2]           @ and store in operand1 table\n    add r6,r5,#1                    @ indice loop 2\n2:                                  @ begin loop 2\n    cmp r6,r3\n    bgt 8f\n    ldr r12,[r10,r6,lsl #2]         @ load second operand\n    ldr r8,iAdriTabOperand2\n    str r12,[r8,r9,lsl #2]          @ and store in operand2 table\n    mov r7,#0   @ k\n    mov r8,#0   @ n\n3:  \n    cmp r7,r5\n    beq 4f\n    cmp r7,r6\n    beq 4f\n    ldr r0,[r10,r7,lsl #2]          @ copy other digits in new table on stack\n    str r0,[fp,r8,lsl #2]\n    add r8,r8,#1\n4:\n    add r7,r7,#1\n    cmp r7,r3\n    ble 3b\n\n    add r7,r4,r12                   @ addition test\n    str r7,[fp,r8,lsl #2]           @ store result of addition\n    mov r7,#'+'\n    ldr r0,iAdriTabOperation\n    str r7,[r0,r9,lsl #2]           @ store operator\n    mov r0,r9                       @ pass new level\n    mov r1,fp                       @ pass new table address on stack\n    bl searchSoluce\n    cmp r0,#0\n    blt 100f\n                                    @ soustraction test\n    cmp r4,r12\n    subgt r7,r4,r12\n    suble r7,r12,r4\n    str r7,[fp,r8,lsl #2]\n    mov r7,#'-'\n    ldr r0,iAdriTabOperation\n    str r7,[r0,r9,lsl #2]\n    mov r0,r9\n    mov r1,fp\n    bl searchSoluce\n    cmp r0,#0\n    blt 100f\n    \n    mul r7,r4,r12                    @ multiplication test\n    str r7,[fp,r8,lsl #2]\n    mov r7,#'*'\n    //vidregtit mult\n    ldr r0,iAdriTabOperation\n    str r7,[r0,r9,lsl #2]\n    mov r0,r9\n    mov r1,fp\n    bl searchSoluce\n    cmp r0,#0\n    blt 100f\n5:                                    @ division test\n    push {r1-r3}\n    mov r0,r4\n    mov r1,r12\n    bl division\n   // mov r7,r9\n    cmp r3,#0\n    bne 6f\n    str r2,[fp,r8,lsl #2]\n    mov r7,#'/'\n    ldr r0,iAdriTabOperation\n    str r7,[r0,r9,lsl #2]\n    mov r0,r9\n    mov r1,fp\n    bl searchSoluce\n    b 7f\n6:\n    mov r0,r12\n    mov r1,r4\n    bl division\n    cmp r3,#0\n    bne 7f\n    str r2,[fp,r8,lsl #2]\n    mov r7,#'/'\n    ldr r0,iAdriTabOperation\n    str r7,[r0,r9,lsl #2]\n    mov r0,r9\n    mov r1,fp\n    bl searchSoluce\n7:\n    pop {r1-r3}\n    cmp r0,#0\n    blt 100f\n    \n    add r6,r6,#1                      @ increment indice loop 2\n    b 2b\n\n8:\n    add r5,r5,#1                      @ increment indice loop 1\n    b 1b\n9:\n    \n100:\n    add sp,#4* NBDIGITS               @ stack alignement\n    pop {r1-r12,lr}\n    bx lr                             @ return \niAdriTabOperand1:         .int iTabOperand1\niAdriTabOperand2:         .int iTabOperand2\niAdriTabOperation:        .int iTabOperation\n/******************************************************************/\n/*            write solution                                      */ \n/******************************************************************/\nwriteSoluce:\n    push {r1-r12,lr}            @ save registers\n    ldr r6,iAdriTabOperand1\n    ldr r7,iAdriTabOperand2\n    ldr r8,iAdriTabOperation\n    ldr r10,iAdrsBuffer\n    mov r4,#0                    @ buffer indice\n    mov r9,#1\n1:\n    ldr r5,[r6,r9,lsl #2]       @ operand 1\n    ldr r11,[r7,r9,lsl #2]       @ operand  2\n    ldr r12,[r8,r9,lsl #2]       @ operator\n    cmp r12,#'-'\n    beq 2f\n    cmp r12,#'/'\n    beq 2f\n    b 3f\n2:                               @ if division or soustraction\n    cmp r5,r11                   @ reverse operand if operand 1 is < operand 2\n    movlt r2,r5\n    movlt r5,r11\n    movlt r11,r2\n3:                               @ conversion operand 1 = r0\n    mov r0,r5\n    mov r1,#10\n    bl division\n    cmp r2,#0\n    addne r2,r2,#0x30\n    strneb r2,[r10,r4]\n    addne r4,r4,#1\n    add r3,r3,#0x30\n    strb r3,[r10,r4]\n    add r4,r4,#1\n    ldr r2,[r7,r9,lsl #2]\n\n    strb r12,[r10,r4]           @ operator\n    add r4,r4,#1\n    \n    mov r0,r11                  @ conversion operand  2\n    mov r1,#10\n    bl division\n    cmp r2,#0\n    addne r2,r2,#0x30\n    strneb r2,[r10,r4]\n    addne r4,r4,#1\n    add r3,r3,#0x30\n    strb r3,[r10,r4]\n    add r4,r4,#1\n    \n    mov r0,#'='\n    str r0,[r10,r4]             @ conversion sous total\n    add r4,r4,#1\n    cmp r12,#'+'\n    addeq r0,r5,r11\n    cmp r12,#'-'\n    subeq r0,r5,r11\n    cmp r12,#'*'\n    muleq r0,r5,r11\n    cmp r12,#'/'\n    udiveq r0,r5,r11\n\n    mov r1,#10\n    bl division\n    cmp r2,#0\n    addne r2,r2,#0x30\n    strneb r2,[r10,r4]\n    addne r4,r4,#1\n    add r3,r3,#0x30\n    strb r3,[r10,r4]\n    add r4,r4,#1\n    mov r0,#'\\n'\n    str r0,[r10,r4]\n    add r4,r4,#1\n    \n    add r9,#1\n    cmp r9,#NBDIGITS\n    blt 1b\n    mov r1,#0\n    strb r1,[r10,r4]            @ store 0 final\n    \n100:\n    pop {r1-r12,lr}\n    bx lr                       @ return \niAdrsBuffer:         .int sBuffer\n\n/******************************************************************/\n/*            string entry                                       */ \n/******************************************************************/\n/* r0 return the first character of human entry */\nsaisie:\n    push {r1-r7,lr}        @ save registers\n    mov r0,#STDIN          @ Linux input console\n    ldr r1,iAdrsBuffer     @ buffer address \n    mov r2,#BUFFERSIZE     @ buffer size \n    mov r7,#READ           @ request to read datas\n    svc 0                  @ call system\n    ldr r1,iAdrsBuffer     @ buffer address \n    ldrb r0,[r1]           @ load first character\n100:\n    pop {r1-r7,lr}\n    bx lr                   @ return \n/***************************************************/\n/*   Generation random number                  */\n/***************************************************/\n/* r0 contains limit  */\ngenereraleas:\n    push {r1-r4,lr}         @ save registers \n    ldr r4,iAdriGraine\n    ldr r2,[r4]\n    ldr r3,iNbDep1\n    mul r2,r3,r2\n    ldr r3,iNbDep2\n    add r2,r2,r3\n    str r2,[r4]             @ maj de la graine pour l appel suivant \n    cmp r0,#0\n    beq 100f\n    add r1,r0,#1            @ divisor\n    mov r0,r2               @ dividende\n    bl division\n    mov r0,r3               @ r\u00e9sult = remainder\n  \n100:                        @ end function\n    pop {r1-r4,lr}          @ restaur registers\n    bx lr                   @ return\n/*****************************************************/\niAdriGraine: .int iGraine\niNbDep1:     .int 0x343FD\niNbDep2:     .int 0x269EC3 \n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nNew game (y/n)\u00a0?\ny\nThe four digits are 8 3 9 1 and the score is 24.\nSolution\u00a0:\n8*9=72\n3*1=3\n72/3=24\n\nNew game (y/n)\u00a0?\ny\nThe four digits are 7 7 9 4 and the score is 24.\nNo solution for this problem\u00a0!!\n\nNew game (y/n)\u00a0?\ny\nThe four digits are 3 5 8 9 and the score is 24.\nSolution\u00a0:\n3*9=27\n8-5=3\n27-3=24\n\nNew game (y/n)\u00a0?\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Ruby", "code": "\nTranslation of: Tcl\nWorks with: Ruby version 2.1\nclass TwentyFourGame\n  EXPRESSIONS = [\n    '((%dr %s %dr) %s %dr) %s %dr',\n    '(%dr %s (%dr %s %dr)) %s %dr',\n    '(%dr %s %dr) %s (%dr %s %dr)',\n    '%dr %s ((%dr %s %dr) %s %dr)',\n    '%dr %s (%dr %s (%dr %s %dr))',\n  ]\n  \n  OPERATORS = [:+, :-, :*, :/].repeated_permutation(3).to_a\n  \n  def self.solve(digits)\n    solutions = []\n    perms = digits.permutation.to_a.uniq\n    perms.product(OPERATORS, EXPRESSIONS) do |(a,b,c,d), (op1,op2,op3), expr|\n      # evaluate using rational arithmetic\n      text = expr % [a, op1, b, op2, c, op3, d]\n      value = eval(text)  rescue next                 # catch division by zero\n      solutions << text.delete(\"r\")  if value == 24\n    end\n    solutions\n  end\nend\n\n# validate user input\ndigits = ARGV.map do |arg| \n  begin\n    Integer(arg)\n  rescue ArgumentError\n    raise \"error: not an integer: '#{arg}'\"\n  end\nend\ndigits.size == 4 or raise \"error: need 4 digits, only have #{digits.size}\"\n\nsolutions = TwentyFourGame.solve(digits)\nif solutions.empty?\n  puts \"no solutions\"\nelse\n  puts \"found #{solutions.size} solutions, including #{solutions.first}\"\n  puts solutions.sort\nend\n\n\nOutput:\n$ ruby game24_solver.rb 1 1 1 1\nno solutions\n\n$ ruby game24_solver.rb 1 1 2 7\nfound 8 solutions, including (1 + 2) * (1 + 7)\n(1 + 2) * (1 + 7)\n(1 + 2) * (7 + 1)\n(1 + 7) * (1 + 2)\n(1 + 7) * (2 + 1)\n(2 + 1) * (1 + 7)\n(2 + 1) * (7 + 1)\n(7 + 1) * (1 + 2)\n(7 + 1) * (2 + 1)\n\n$ ruby game24_solver.rb 2 3 8 9\nfound 12 solutions, including (8 / 2) * (9 - 3)\n((9 - 3) * 8) / 2\n((9 - 3) / 2) * 8\n(8 * (9 - 3)) / 2\n(8 / 2) * (9 - 3)\n(9 - (2 * 3)) * 8\n(9 - (3 * 2)) * 8\n(9 - 3) * (8 / 2)\n(9 - 3) / (2 / 8)\n8 * ((9 - 3) / 2)\n8 * (9 - (2 * 3))\n8 * (9 - (3 * 2))\n8 / (2 / (9 - 3))\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Rust", "code": "\nWorks with: Rust version 1.17\n#[derive(Clone, Copy, Debug)]\nenum Operator {\n    Sub,\n    Plus,\n    Mul,\n    Div,\n}\n\n#[derive(Clone, Debug)]\nstruct Factor {\n    content: String,\n    value: i32,\n}\n\nfn apply(op: Operator, left: &[Factor], right: &[Factor]) -> Vec<Factor> {\n    let mut ret = Vec::new();\n    for l in left.iter() {\n        for r in right.iter() {\n            use Operator::*;\n            ret.push(match op {\n                Sub if l.value > r.value => Factor {\n                    content: format!(\"({} - {})\", l.content, r.content),\n                    value: l.value - r.value,\n                },\n                Plus => Factor {\n                    content: format!(\"({} + {})\", l.content, r.content),\n                    value: l.value + r.value,\n                },\n                Mul => Factor {\n                    content: format!(\"({} x {})\", l.content, r.content),\n                    value: l.value * r.value,\n                },\n                Div if l.value >= r.value && r.value > 0 && l.value % r.value == 0 => Factor {\n                    content: format!(\"({} / {})\", l.content, r.content),\n                    value: l.value / r.value,\n                },\n                _ => continue,\n            })\n        }\n    }\n    ret\n}\n\nfn calc(op: [Operator; 3], numbers: [i32; 4]) -> Vec<Factor> {\n    fn calc(op: &[Operator], numbers: &[i32], acc: &[Factor]) -> Vec<Factor> {\n        use Operator::*;\n        if op.is_empty() {\n            return Vec::from(acc)\n        }\n        let mut ret = Vec::new();\n        let mono_factor = [Factor {\n            content: numbers[0].to_string(),\n            value: numbers[0],\n        }];\n        match op[0] {\n            Mul => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),\n            Div => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Sub => {\n                ret.extend_from_slice(&apply(op[0], acc, &mono_factor));\n                ret.extend_from_slice(&apply(op[0], &mono_factor, acc));\n            },\n            Plus => ret.extend_from_slice(&apply(op[0], acc, &mono_factor)),   \n        }\n        calc(&op[1..], &numbers[1..], &ret)\n    }\n    calc(&op, &numbers[1..], &[Factor { content: numbers[0].to_string(), value: numbers[0] }])\n}\n\nfn solutions(numbers: [i32; 4]) -> Vec<Factor> {\n    use std::collections::hash_set::HashSet;\n    let mut ret = Vec::new();\n    let mut hash_set = HashSet::new();\n    \n    for ops in OpIter(0) {\n        for o in orders().iter() {\n            let numbers = apply_order(numbers, o);\n            let r = calc(ops, numbers);\n            ret.extend(r.into_iter().filter(|&Factor { value, ref content }| value == 24 && hash_set.insert(content.to_owned())))\n        }\n    }\n    ret\n}\n\nfn main() {\n    let mut numbers = Vec::new();\n    if let Some(input) = std::env::args().skip(1).next() {\n        for c in input.chars() {\n            if let Ok(n) = c.to_string().parse() {\n                numbers.push(n)\n            }\n            if numbers.len() == 4 {\n                let numbers = [numbers[0], numbers[1], numbers[2], numbers[3]];\n                let solutions = solutions(numbers);\n                let len = solutions.len();\n                if len == 0 {\n                    println!(\"no solution for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                    return\n                }\n                println!(\"solutions for {}, {}, {}, {}\", numbers[0], numbers[1], numbers[2], numbers[3]);\n                for s in solutions {\n                    println!(\"{}\", s.content)\n                }\n                println!(\"{} solutions found\", len);\n                return\n            }\n        }\n    } else {\n        println!(\"empty input\")\n    }\n}\n\n\nstruct OpIter (usize);\n\nimpl Iterator for OpIter {\n    type Item = [Operator; 3];\n    fn next(&mut self) -> Option<[Operator; 3]> {\n        use Operator::*;\n        const OPTIONS: [Operator; 4] = [Mul, Sub, Plus, Div];\n        if self.0 >= 1 << 6 {\n            return None\n        }\n        let f1 = OPTIONS[(self.0 & (3 << 4)) >> 4];\n        let f2 = OPTIONS[(self.0 & (3 << 2)) >> 2];\n        let f3 = OPTIONS[(self.0 & (3 << 0)) >> 0];\n        self.0 += 1;\n        Some([f1, f2, f3])\n    }\n}\n\nfn orders() -> [[usize; 4]; 24] {\n    [\n        [0, 1, 2, 3],\n        [0, 1, 3, 2],\n        [0, 2, 1, 3],\n        [0, 2, 3, 1],\n        [0, 3, 1, 2],\n        [0, 3, 2, 1],\n        [1, 0, 2, 3],\n        [1, 0, 3, 2],\n        [1, 2, 0, 3],\n        [1, 2, 3, 0],\n        [1, 3, 0, 2],\n        [1, 3, 2, 0],\n        [2, 0, 1, 3],\n        [2, 0, 3, 1],\n        [2, 1, 0, 3],\n        [2, 1, 3, 0],\n        [2, 3, 0, 1],\n        [2, 3, 1, 0],\n        [3, 0, 1, 2],\n        [3, 0, 2, 1],\n        [3, 1, 0, 2],\n        [3, 1, 2, 0],\n        [3, 2, 0, 1],\n        [3, 2, 1, 0]\n    ]\n}\n\nfn apply_order(numbers: [i32; 4], order: &[usize; 4]) -> [i32; 4] {\n    [numbers[order[0]], numbers[order[1]], numbers[order[2]], numbers[order[3]]]\n}\n\n\nOutput:\n$cargo run 5598\nsolutions for 5, 5, 9, 8\n(((5 x 5) - 9) + 8)\n(((5 x 5) + 8) - 9)\n(((8 - 5) x 5) + 9)\n3 solutions found\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Swift", "code": "\nimport Darwin\nimport Foundation\n\nvar solution = \"\"\n\nprintln(\"24 Game\")\nprintln(\"Generating 4 digits...\")\n\nfunc randomDigits() -> [Int] {\n  var result = [Int]()\n  for i in 0 ..< 4 {\n    result.append(Int(arc4random_uniform(9)+1))\n  }\n  return result\n}\n\n// Choose 4 digits\nlet digits = randomDigits()\n\nprint(\"Make 24 using these digits\u00a0: \")\n\nfor digit in digits {\n  print(\"\\(digit) \")\n}\nprintln()\n\n// get input from operator\nvar input = NSString(data:NSFileHandle.fileHandleWithStandardInput().availableData, encoding:NSUTF8StringEncoding)!\n\nvar enteredDigits = [Double]()\n\nvar enteredOperations = [Character]()\n\nlet inputString = input as String\n\n// store input in the appropriate table\nfor character in inputString {\n  switch character {\n  case \"1\", \"2\", \"3\", \"4\", \"5\", \"6\", \"7\", \"8\", \"9\":\n    let digit = String(character)\n    enteredDigits.append(Double(digit.toInt()!))\n  case \"+\", \"-\", \"*\", \"/\":\n    enteredOperations.append(character)\n  case \"\\n\":\n    println()\n  default:\n    println(\"Invalid expression\")\n  }\n}\n\n// check value of expression provided by the operator\nvar value = 0.0\n\nif enteredDigits.count == 4 && enteredOperations.count == 3 {\n  value = enteredDigits[0]\n  for (i, operation) in enumerate(enteredOperations) {\n    switch operation {\n    case \"+\":\n      value = value + enteredDigits[i+1]\n    case \"-\":\n      value = value - enteredDigits[i+1]\n    case \"*\":\n      value = value * enteredDigits[i+1]\n    case \"/\":\n      value = value / enteredDigits[i+1]\n    default:\n      println(\"This message should never happen!\")\n    }\n  }\n}\n\nfunc evaluate(dPerm: [Double], oPerm: [String]) -> Bool {\n  var value = 0.0\n  \n  if dPerm.count == 4 && oPerm.count == 3 {\n    value = dPerm[0]\n    for (i, operation) in enumerate(oPerm) {\n      switch operation {\n      case \"+\":\n        value = value + dPerm[i+1]\n      case \"-\":\n        value = value - dPerm[i+1]\n      case \"*\":\n        value = value * dPerm[i+1]\n      case \"/\":\n        value = value / dPerm[i+1]\n      default:\n        println(\"This message should never happen!\")\n      }\n    }\n  }\n  return (abs(24 - value) < 0.001)\n}\n\nfunc isSolvable(inout digits: [Double]) -> Bool {\n  \n  var result = false\n  var dPerms = [[Double]]()\n  permute(&digits, &dPerms, 0)\n  \n  let total = 4 * 4 * 4\n  var oPerms = [[String]]()\n  permuteOperators(&oPerms, 4, total)\n  \n  \n  for dig in dPerms {\n    for opr in oPerms {\n      var expression = \"\"\n      \n      if evaluate(dig, opr) {\n        for digit in dig {\n          expression += \"\\(digit)\"\n        }\n        \n        for oper in opr {\n          expression += oper\n        }\n        \n        solution = beautify(expression)\n        result = true\n      }\n    }\n  }\n  return result\n}\n\nfunc permute(inout lst: [Double], inout res: [[Double]], k: Int) -> Void {\n  for i in k ..< lst.count {\n    swap(&lst[i], &lst[k])\n    permute(&lst, &res, k + 1)\n    swap(&lst[k], &lst[i])\n  }\n  if k == lst.count {\n    res.append(lst)\n  }\n}\n\n// n=4, total=64, npow=16\nfunc permuteOperators(inout res: [[String]], n: Int, total: Int) -> Void {\n  let posOperations = [\"+\", \"-\", \"*\", \"/\"]\n  let npow = n * n\n  for i in 0 ..< total {\n    res.append([posOperations[(i / npow)], posOperations[((i % npow) / n)], posOperations[(i % n)]])\n  }\n}\n\nfunc beautify(infix: String) -> String {\n  let newString = infix as NSString\n  \n  var solution = \"\"\n  \n  solution += newString.substringWithRange(NSMakeRange(0, 1))\n  solution += newString.substringWithRange(NSMakeRange(12, 1))\n  solution += newString.substringWithRange(NSMakeRange(3, 1))\n  solution += newString.substringWithRange(NSMakeRange(13, 1))\n  solution += newString.substringWithRange(NSMakeRange(6, 1))\n  solution += newString.substringWithRange(NSMakeRange(14, 1))\n  solution += newString.substringWithRange(NSMakeRange(9, 1))\n  \n  return solution\n}\n\nif value != 24 {\n  println(\"The value of the provided expression is \\(value) instead of 24!\")\n  if isSolvable(&enteredDigits) {\n    println(\"A possible solution could have been \" + solution)\n  } else {\n    println(\"Anyway, there was no known solution to this one.\")\n  }\n} else {\n  println(\"Congratulations, you found a solution!\")\n}\n\n\nOutput:The program in action\n\n24 Game\nGenerating 4 digits...\nMake 24 using these digits\u00a0: 2 4 1 9 \n2+1*4+9\n\nThe value of the provided expression is 21.0 instead of 24!\nA possible solution could have been 9-2-1*4\n\n24 Game\nGenerating 4 digits...\nMake 24 using these digits\u00a0: 2 7 2 3 \n7-2*2*3\n\nThe value of the provided expression is 30.0 instead of 24!\nA possible solution could have been 3+7+2*2\n\n24 Game\nGenerating 4 digits...\nMake 24 using these digits\u00a0: 4 6 3 4 \n4+4+6+3\n\nThe value of the provided expression is 17.0 instead of 24!\nA possible solution could have been 3*4-6*4\n\n24 Game\nGenerating 4 digits...\nMake 24 using these digits\u00a0: 8 8 2 6 \n8+8+2+6\n\nCongratulations, you found a solution!\n\n24 Game\nGenerating 4 digits...\nMake 24 using these digits\u00a0: 6 7 8 9 \n6+7+8+9\n\nThe value of the provided expression is 30.0 instead of 24!\nAnyway, there was no known solution to this one.\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "R", "code": "\n\nlibrary(gtools)\n\nsolve24 <- function(vals=c(8, 4, 2, 1),\n                    goal=24,\n                    ops=c(\"+\", \"-\", \"*\", \"/\")) {\n  \n  val.perms <- as.data.frame(t(\n                  permutations(length(vals), length(vals))))\n\n  nop <- length(vals)-1\n  op.perms <- as.data.frame(t(\n                  do.call(expand.grid,\n                          replicate(nop, list(ops)))))\n  \n  ord.perms <- as.data.frame(t(\n                   do.call(expand.grid,\n                           replicate(n <- nop, 1:((n <<- n-1)+1)))))\n\n  for (val.perm in val.perms)\n    for (op.perm in op.perms)\n      for (ord.perm in ord.perms)\n        {\n          expr <- as.list(vals[val.perm])\n          for (i in 1:nop) {\n            expr[[ ord.perm[i] ]] <- call(as.character(op.perm[i]),\n                                          expr[[ ord.perm[i]   ]],\n                                          expr[[ ord.perm[i]+1 ]])\n            expr <- expr[ -(ord.perm[i]+1) ]\n          }\n          if (identical(eval(expr[[1]]), goal)) return(expr[[1]])\n        }\n\n  return(NA)\n}\n\n\nOutput:\n> solve24()\n8 * (4 - 2 + 1)\n> solve24(c(6,7,9,5))\n6 + (7 - 5) * 9\n> solve24(c(8,8,8,8))\n[1] NA\n> solve24(goal=49) #different goal value\n8 * (4 + 2) + 1\n> solve24(goal=52) #no solution\n[1] NA\n> solve24(ops=c('-', '/')) #restricted set of operators\n(8 - 2)/(1/4)\n\n", "explain": "This uses exhaustive search and makes use of R's ability to work with expressions as data. It is in principle general for any set of operands and binary operators.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "COBOL", "code": "\n        >>SOURCE FORMAT FREE\n*> This code is dedicated to the public domain\n*> This is GNUCobol 2.0\nidentification division.\nprogram-id. twentyfoursolve.\nenvironment division.\nconfiguration section.\nrepository. function all intrinsic.\ninput-output section.\nfile-control.\n    select count-file\n        assign to count-file-name\n        file status count-file-status\n        organization line sequential.\ndata division.\nfile section.\nfd  count-file.\n01  count-record pic x(7).\n\nworking-storage section.\n01  count-file-name pic x(64) value 'solutioncounts'.\n01  count-file-status pic xx.\n\n01  command-area.\n    03  nd pic 9.\n    03  number-definition.\n        05  n occurs 4 pic 9.\n    03  number-definition-9 redefines number-definition\n        pic 9(4).\n    03  command-input pic x(16).\n    03  command pic x(5).\n    03  number-count pic 9999.\n    03  l1 pic 99.\n    03  l2 pic 99.\n    03  expressions pic zzz,zzz,zz9.\n\n01  number-validation.\n    03  px pic 99.\n    03  permutations value\n          '1234'\n        & '1243'\n        & '1324'\n        & '1342'\n        & '1423'\n        & '1432'\n\n        & '2134'\n        & '2143'\n        & '2314'\n        & '2341'\n        & '2413'\n        & '2431'\n\n        & '3124'\n        & '3142'\n        & '3214'\n        & '3241'\n        & '3423'\n        & '3432'\n\n        & '4123'\n        & '4132'\n        & '4213'\n        & '4231'\n        & '4312'\n        & '4321'.\n        05  permutation occurs 24 pic x(4).\n    03  cpx pic 9.\n    03  current-permutation pic x(4).\n    03  od1 pic 9.\n    03  od2 pic 9.\n    03  od3 pic 9.\n    03  operator-definitions pic x(4) value '+-*/'.\n    03  cox pic 9.\n    03  current-operators pic x(3).\n    03  rpn-forms value\n          'nnonono'\n        & 'nnonnoo'\n        & 'nnnonoo'\n        & 'nnnoono'\n        & 'nnnnooo'.\n        05  rpn-form occurs 5 pic x(7).\n    03  rpx pic 9.\n    03  current-rpn-form pic x(7).\n\n01  calculation-area.\n    03  oqx pic 99.\n    03  output-queue pic x(7).\n    03  work-number pic s9999.\n    03  top-numerator pic s9999 sign leading separate.\n    03  top-denominator pic s9999 sign leading separate.\n    03  rsx pic 9.\n    03  result-stack occurs 8.\n        05  numerator pic s9999.\n        05  denominator pic s9999.\n    03  divide-by-zero-error pic x.\n\n01  totals.\n    03  s pic 999.\n    03  s-lim pic 999 value 600.\n    03  s-max pic 999 value 0.\n    03  solution occurs 600 pic x(7).\n    03  sc pic 999.\n    03  sc1 pic 999.\n    03  sc2 pic 9.\n    03  sc-max pic 999 value 0.\n    03  sc-lim pic 999 value 600.\n    03  solution-counts value zeros.\n        05  solution-count occurs 600 pic 999.\n    03  ns pic 9999.\n    03  ns-max pic 9999 value 0.\n    03  ns-lim pic 9999 value 6561.\n    03  number-solutions occurs 6561.\n        05 ns-number pic x(4).\n        05 ns-count pic 999.\n    03  record-counts pic 9999.\n    03  total-solutions pic 9999.\n\n01  infix-area.\n    03  i pic 9.\n    03  i-s pic 9.\n    03  i-s1 pic 9.\n    03  i-work pic x(16).\n    03  i-stack occurs 7 pic x(13).\n\nprocedure division.\nstart-twentyfoursolve.\n    display 'start twentyfoursolve'\n    perform display-instructions\n    perform get-command\n    perform until command-input = spaces\n        display space\n        initialize command number-count\n        unstring command-input delimited by all space\n            into command number-count\n        move command-input to number-definition\n        move spaces to command-input\n        evaluate command\n        when 'h'\n        when 'help'\n            perform display-instructions\n        when 'list'\n            if ns-max = 0\n                perform load-solution-counts\n            end-if\n            perform list-counts\n        when 'show'\n            if ns-max = 0\n                perform load-solution-counts\n            end-if\n            perform show-numbers\n        when other\n            if number-definition-9 not numeric\n                display 'invalid number'\n            else\n                perform get-solutions\n                perform display-solutions\n            end-if\n        end-evaluate\n        if command-input = spaces\n            perform get-command\n        end-if\n    end-perform\n    display 'exit twentyfoursolve'\n    stop run\n    .\ndisplay-instructions.\n    display space\n    display 'enter a number <n> as four integers from 1-9 to see its solutions'\n    display 'enter list to see counts of solutions for all numbers'\n    display 'enter show <n> to see numbers having <n> solutions'\n    display '<enter> ends the program'\n    .\nget-command.\n    display space\n    move spaces to command-input\n    display '(h for help)?' with no advancing\n    accept command-input\n    .\nask-for-more.\n    display space\n    move 0 to l1\n    add 1 to l2\n    if l2 = 10\n        display 'more (<enter>)?' with no advancing\n        accept command-input\n        move 0 to l2\n    end-if\n    .\nlist-counts. \n    add 1 to sc-max giving sc\n    display 'there are ' sc ' solution counts'\n    display space\n    display 'solutions/numbers'\n    move 0 to l1\n    move 0 to l2\n    perform varying sc from 1 by 1 until sc > sc-max\n    or command-input <> spaces\n        if solution-count(sc) > 0\n            subtract 1 from sc giving sc1 *> offset to capture zero counts\n            display sc1 '/' solution-count(sc) space with no advancing\n            add 1 to l1\n            if l1 = 8\n                perform ask-for-more\n            end-if\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\nshow-numbers. *> with number-count solutions\n    add 1 to number-count giving sc1 *> offset for zero count\n    evaluate true\n    when number-count >= sc-max\n        display 'no number has ' number-count ' solutions'\n        exit paragraph\n    when solution-count(sc1) = 1 and number-count = 1\n        display '1 number has 1 solution'\n    when solution-count(sc1) = 1\n        display '1 number has ' number-count ' solutions'\n    when number-count = 1\n        display solution-count(sc1) ' numbers have 1 solution'\n    when other\n        display solution-count(sc1) ' numbers have ' number-count ' solutions'\n    end-evaluate\n    display space\n    move 0 to l1\n    move 0 to l2\n    perform varying ns from 1 by 1 until ns > ns-max\n    or command-input <> spaces\n        if ns-count(ns) = number-count\n            display ns-number(ns) space with no advancing\n            add 1 to l1\n            if l1 = 14\n                perform ask-for-more\n            end-if\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\ndisplay-solutions.\n    evaluate s-max\n    when 0 display number-definition ' has no solutions'\n    when 1 display number-definition ' has 1 solution'\n    when other display number-definition ' has ' s-max ' solutions'\n    end-evaluate\n    display space\n    move 0 to l1\n    move 0 to l2\n    perform varying s from 1 by 1 until s > s-max\n    or command-input <> spaces\n        *> convert rpn solution(s) to infix\n        move 0 to i-s\n        perform varying i from 1 by 1 until i > 7\n            if solution(s)(i:1) >= '1' and <= '9'\n                add 1 to i-s\n                move solution(s)(i:1) to i-stack(i-s)\n            else\n                subtract 1 from i-s giving i-s1\n                move spaces to i-work\n                string '(' i-stack(i-s1) solution(s)(i:1) i-stack(i-s) ')'\n                    delimited by space into i-work\n                move i-work to i-stack(i-s1)\n                subtract 1 from i-s\n            end-if\n        end-perform\n        display solution(s) space i-stack(1) space space with no advancing\n        add 1 to l1\n        if l1 = 3\n            perform ask-for-more\n        end-if\n    end-perform\n    if l1 > 0\n        display space\n    end-if\n    .\nload-solution-counts.\n    move 0 to ns-max *> numbers and their solution count\n    move 0 to sc-max *> solution counts\n    move spaces to count-file-status\n    open input count-file\n    if count-file-status <> '00'\n        perform create-count-file\n        move 0 to ns-max *> numbers and their solution count\n        move 0 to sc-max *> solution counts\n        open input count-file\n    end-if\n    read count-file\n    move 0 to record-counts\n    move zeros to solution-counts\n    perform until count-file-status <> '00'\n        add 1 to record-counts\n        perform increment-ns-max\n        move count-record to number-solutions(ns-max)\n        add 1 to ns-count(ns-max) giving sc *> offset 1 for zero counts\n        if sc > sc-lim\n            display 'sc ' sc ' exceeds sc-lim ' sc-lim\n            stop run\n        end-if\n        if sc > sc-max\n            move sc to sc-max\n        end-if\n        add 1 to solution-count(sc)\n        read count-file\n    end-perform\n    close count-file\n    .\ncreate-count-file.\n    open output count-file\n    display 'Counting solutions for all numbers'\n    display 'We will examine 9*9*9*9 numbers'\n    display 'For each number we will examine 4! permutations of the digits'\n    display 'For each permutation we will examine 4*4*4 combinations of operators'\n    display 'For each permutation and combination we will examine 5 rpn forms'\n    display 'We will count the number of unique solutions for the given number'\n    display 'Each number and its counts will be written to file ' trim(count-file-name)\n    compute expressions = 9*9*9*9*factorial(4)*4*4*4*5\n    display 'So we will evaluate ' trim(expressions) ' statements'\n    display 'This will take a few minutes'\n    display 'In the future if ' trim(count-file-name) ' exists, this step will be bypassed'\n    move 0 to record-counts\n    move 0 to total-solutions\n    perform varying n(1) from 1 by 1 until n(1) = 0\n        perform varying n(2) from 1 by 1 until n(2) = 0\n            display n(1) n(2) '..' *> show progress\n            perform varying n(3) from 1 by 1 until n(3) = 0\n                perform varying n(4) from 1 by 1 until n(4) = 0\n                    perform get-solutions\n                    perform increment-ns-max\n                    move number-definition to ns-number(ns-max)\n                    move s-max to ns-count(ns-max)\n                    move number-solutions(ns-max) to count-record\n                    write count-record\n                    add s-max to total-solutions\n                    add 1 to record-counts\n                    add 1 to ns-count(ns-max) giving sc *> offset by 1 for zero counts\n                    if sc > sc-lim\n                        display 'error: ' sc ' solution count exceeds ' sc-lim\n                        stop run\n                    end-if\n                    add 1 to solution-count(sc)\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    close count-file\n    display record-counts ' numbers and counts written to ' trim(count-file-name)\n    display total-solutions ' total solutions'\n    display space\n    .\nincrement-ns-max.\n    if ns-max >= ns-lim\n        display 'error: numbers exceeds ' ns-lim\n        stop run\n    end-if\n    add 1 to ns-max\n    .\nget-solutions.\n    move 0 to s-max\n    perform varying px from 1 by 1 until px > 24\n        move permutation(px) to current-permutation\n        perform varying od1 from 1 by 1 until od1 > 4\n            move operator-definitions(od1:1) to current-operators(1:1)\n            perform varying od2 from 1 by 1 until od2 > 4\n                move operator-definitions(od2:1) to current-operators(2:1)\n                perform varying od3 from 1 by 1 until od3 > 4\n                    move operator-definitions(od3:1) to current-operators(3:1)\n                    perform varying rpx from 1 by 1 until rpx > 5\n                        move rpn-form(rpx) to current-rpn-form\n                        move 0 to cpx cox\n                        move spaces to output-queue\n                        perform varying oqx from 1 by 1 until oqx > 7\n                            if current-rpn-form(oqx:1) = 'n'\n                                add 1 to cpx\n                                move current-permutation(cpx:1) to nd\n                                move n(nd) to output-queue(oqx:1)\n                            else\n                                add 1 to cox\n                                move current-operators(cox:1) to output-queue(oqx:1)\n                            end-if\n                        end-perform\n                        perform evaluate-rpn\n                        if divide-by-zero-error = space\n                        and 24 * top-denominator = top-numerator\n                            perform varying s from 1 by 1 until s > s-max\n                            or solution(s) = output-queue\n                                continue\n                            end-perform\n                            if s > s-max\n                                if s >= s-lim\n                                    display 'error: solutions ' s ' for ' number-definition ' exceeds ' s-lim\n                                    stop run\n                                end-if\n                                move s to s-max\n                                move output-queue to solution(s-max)\n                            end-if\n                        end-if\n                    end-perform\n                end-perform\n            end-perform\n        end-perform\n    end-perform\n    .\nevaluate-rpn.\n    move space to divide-by-zero-error\n    move 0 to rsx *> stack depth\n    perform varying oqx from 1 by 1 until oqx > 7\n        if output-queue(oqx:1) >= '1' and <= '9'\n            *> push the digit onto the stack\n            add 1 to rsx\n            move top-numerator to numerator(rsx)\n            move top-denominator to denominator(rsx)\n            move output-queue(oqx:1) to top-numerator\n            move 1 to top-denominator\n        else\n            *> apply the operation\n            evaluate output-queue(oqx:1)\n            when '+'\n                compute top-numerator = top-numerator * denominator(rsx)\n                    + top-denominator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '-'\n                compute top-numerator = top-denominator * numerator(rsx)\n                    - top-numerator * denominator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '*'\n                compute top-numerator = top-numerator * numerator(rsx)\n                compute top-denominator = top-denominator * denominator(rsx)\n            when '/'\n                compute work-number = numerator(rsx) * top-denominator\n                compute top-denominator = denominator(rsx) * top-numerator\n                if top-denominator = 0\n                    move 'y' to divide-by-zero-error\n                    exit paragraph\n                end-if\n                move work-number to top-numerator\n            end-evaluate\n            *> pop the stack\n            subtract 1 from rsx\n        end-if\n    end-perform\n    .\nend program twentyfoursolve.\n\n\nOutput:\nprompt$ cobc -xj twentyfoursolve.cob\nstart twentyfoursolve\n\nenter a number <n> as four integers from 1-9 to see its solutions\nenter list to see counts of solutions for all numbers\nenter show <n> to see numbers having <n> solutions\n<enter> ends the program\n\n(h for help)?5678\n\n5678 has 026 solutions\n\n57+8-6* (((5+7)-8)*6)  57+86-* ((5+7)*(8-6))  578-+6* ((5+(7-8))*6)\n58-7+6* (((5-8)+7)*6)  587--6* ((5-(8-7))*6)  657+8-* (6*((5+7)-8))\n6578-+* (6*(5+(7-8)))  658-7+* (6*((5-8)+7))  6587--* (6*(5-(8-7)))\n675+8-* (6*((7+5)-8))  6758-+* (6*(7+(5-8)))  675-/8* ((6/(7-5))*8)\n675-8// (6/((7-5)/8))  678-5+* (6*((7-8)+5))  6785--* (6*(7-(8-5)))\n6875-/* (6*(8/(7-5)))  68*75-/ ((6*8)/(7-5))  75+8-6* (((7+5)-8)*6)\n75+86-* ((7+5)*(8-6))  758-+6* ((7+(5-8))*6)  86-57+* ((8-6)*(5+7))\n86-75+* ((8-6)*(7+5))  8675-/* (8*(6/(7-5)))  86*75-/ ((8*6)/(7-5))\n875-/6* ((8/(7-5))*6)  875-6// (8/((7-5)/6))\n\n(h for help)?\n\n", "explain": ""}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Julia", "code": "\n\nfunction solve24(nums)\n    length(nums) != 4 && error(\"Input must be a 4-element Array\")\n    syms = [+,-,*,/]\n    for x in syms, y in syms, z in syms\n        for i = 1:24\n            a,b,c,d = nthperm(nums,i)\n            if round(x(y(a,b),z(c,d)),5) == 24\n                return \"($a$y$b)$x($c$z$d)\"\n            elseif round(x(a,y(b,z(c,d))),5) == 24 \n                return \"$a$x($b$y($c$z$d))\"\n            elseif round(x(y(z(c,d),b),a),5) == 24 \n                return \"(($c$z$d)$y$b)$x$a\"\n            elseif round(x(y(b,z(c,d)),a),5) == 24 \n                return \"($b$y($c$z$d))$x$a\"\n            end\n        end\n    end\n    return \"0\"\nend\n\n\nOutput:\njulia> for i in 1:10\n            nums = rand(1:9, 4)\n            println(\"solve24($nums) -> $(solve24(nums))\")\n       end\nsolve24([9,4,4,5]) -> 0\nsolve24([1,7,2,7]) -> ((7*7)-1)/2\nsolve24([5,7,5,4]) -> 4*(7-(5/5))\nsolve24([1,4,6,6]) -> 6+(6*(4-1))\nsolve24([2,3,7,3]) -> ((2+7)*3)-3\nsolve24([8,7,9,7]) -> 0\nsolve24([1,6,2,6]) -> 6+(6*(1+2))\nsolve24([7,9,4,1]) -> (7-4)*(9-1)\nsolve24([6,4,2,2]) -> (2-2)+(6*4)\nsolve24([5,7,9,7]) -> (5+7)*(9-7)\n", "explain": "For julia version 0.5 and higher, the Combinatorics package must be installed and imported (`using Combinatorics`). Combinatorial functions like `nthperm` have been moved from Base to that package and are not available by default anymore.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\nTranslation of: C\n// version 1.1.3\n\nimport java.util.Random\n\nconst val N_CARDS = 4\nconst val SOLVE_GOAL = 24\nconst val MAX_DIGIT = 9\n\nclass Frac(val num: Int, val den: Int)\n\nenum class OpType { NUM, ADD, SUB, MUL, DIV }\n\nclass Expr(\n    var op:    OpType = OpType.NUM,\n    var left:  Expr?  = null,\n    var right: Expr?  = null,\n    var value: Int    = 0\n)\n\nfun showExpr(e: Expr?, prec: OpType, isRight: Boolean) {\n    if (e == null) return\n    val op = when (e.op) {\n        OpType.NUM -> { print(e.value); return }\n        OpType.ADD -> \" + \"\n        OpType.SUB -> \" - \"\n        OpType.MUL -> \" x \"\n        OpType.DIV -> \" / \"\n    }\n\n    if ((e.op == prec && isRight) || e.op < prec) print(\"(\")\n    showExpr(e.left, e.op, false)\n    print(op)\n    showExpr(e.right, e.op, true)\n    if ((e.op == prec && isRight) || e.op < prec) print(\")\")\n}\n\nfun evalExpr(e: Expr?): Frac {\n    if (e == null) return Frac(0, 1)\n    if (e.op == OpType.NUM) return Frac(e.value, 1)\n    val l = evalExpr(e.left)\n    val r = evalExpr(e.right)\n    return when (e.op) {\n        OpType.ADD -> Frac(l.num * r.den + l.den * r.num, l.den * r.den)\n        OpType.SUB -> Frac(l.num * r.den - l.den * r.num, l.den * r.den)\n        OpType.MUL -> Frac(l.num * r.num, l.den * r.den)\n        OpType.DIV -> Frac(l.num * r.den, l.den * r.num)\n        else       -> throw IllegalArgumentException(\"Unknown op: ${e.op}\")\n    }\n}\n\nfun solve(ea: Array<Expr?>, len: Int): Boolean {\n    if (len == 1) {\n        val final = evalExpr(ea[0])\n        if (final.num == final.den * SOLVE_GOAL && final.den != 0) {\n            showExpr(ea[0], OpType.NUM, false)\n            return true\n        }\n    }\n\n    val ex = arrayOfNulls<Expr>(N_CARDS)\n    for (i in 0 until len - 1) {\n        for (j in i + 1 until len) ex[j - 1] = ea[j]\n        val node = Expr()\n        ex[i] = node\n        for (j in i + 1 until len) {\n            node.left = ea[i]\n            node.right = ea[j]\n            for (k in OpType.values().drop(1)) {\n                node.op = k\n                if (solve(ex, len - 1)) return true\n            }\n            node.left = ea[j]\n            node.right = ea[i]\n            node.op = OpType.SUB\n            if (solve(ex, len - 1)) return true\n            node.op = OpType.DIV\n            if (solve(ex, len - 1)) return true\n            ex[j] = ea[j]\n        }\n        ex[i] = ea[i]\n    }\n    return false\n}\n\nfun solve24(n: IntArray) =\n    solve (Array(N_CARDS) { Expr(value = n[it]) }, N_CARDS)\n\nfun main(args: Array<String>) {\n    val r = Random()\n    val n = IntArray(N_CARDS)\n    for (j in 0..9) {\n        for (i in 0 until N_CARDS) {\n            n[i] = 1 + r.nextInt(MAX_DIGIT)\n            print(\" ${n[i]}\")\n        }\n        print(\":  \")\n        println(if (solve24(n)) \"\" else \"No solution\")\n    }\n}\n\n\n 8 4 1 7:  (8 - 4) x (7 - 1)\n 6 1 4 1:  ((6 + 1) - 1) x 4\n 8 8 5 4:  (8 / 8 + 5) x 4\n 9 6 9 8:  8 / ((9 - 6) / 9)\n 6 6 9 6:  (6 x 6) / 9 x 6\n 9 9 7 7:  No solution\n 1 1 2 5:  No solution\n 6 9 4 1:  6 x (9 - 4 - 1)\n 7 7 6 4:  7 + 7 + 6 + 4\n 4 8 8 4:  4 + 8 + 8 + 4\n\n", "explain": "Sample output:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Perl", "code": "\n\n# Fischer-Krause ordered permutation generator\n# http://faq.perl.org/perlfaq4.html#How_do_I_permute_N_e\nsub permute :prototype(&@) {\n\t\tmy $code = shift;\n\t\tmy @idx = 0..$#_;\n\t\twhile ( $code->(@_[@idx]) ) {\n\t\t\tmy $p = $#idx;\n\t\t\t--$p while $idx[$p-1] > $idx[$p];\n\t\t\tmy $q = $p or return;\n\t\t\tpush @idx, reverse splice @idx, $p;\n\t\t\t++$q while $idx[$p-1] > $idx[$q];\n\t\t\t@idx[$p-1,$q]=@idx[$q,$p-1];\n\t\t}\n\t}\n\n@formats = (\n\t'((%d %s %d) %s %d) %s %d',\n\t'(%d %s (%d %s %d)) %s %d',\n\t'(%d %s %d) %s (%d %s %d)',\n\t'%d %s ((%d %s %d) %s %d)',\n\t'%d %s (%d %s (%d %s %d))',\n\t);\n\n# generate all possible combinations of operators\n@op = qw( + - * / );\n@operators = map{ $a=$_; map{ $b=$_; map{ \"$a $b $_\" }@op }@op }@op;\n\nwhile(1)\n{\n\tprint \"Enter four integers or 'q' to exit: \";\n\tchomp($ent = <>);\n\tlast if $ent eq 'q';\n\n\t\n\tif($ent !~ /^[1-9] [1-9] [1-9] [1-9]$/){ print \"invalid input\\n\"; next }\n\n\t@n = split / /,$ent;\n\tpermute { push @numbers,join ' ',@_ }@n;\n\n\tfor $format (@formats)\n\t{\n\t\tfor(@numbers)\n\t\t{\n\t\t\t@n = split;\n\t\t\tfor(@operators)\n\t\t\t{\n\t\t\t\t@o = split;\n\t\t\t\t$str = sprintf $format,$n[0],$o[0],$n[1],$o[1],$n[2],$o[2],$n[3];\n\t\t\t\t$r = eval($str);\n\t\t\t\tprint \"$str\\n\" if $r == 24;\n\t\t\t}\n\t\t}\n\t}\n}\n\n\nOutput:\nE:\\Temp>24solve.pl\nEnter four integers or 'q' to exit: 1 3 3 8\n((1 + 8) * 3) - 3\n((1 + 8) * 3) - 3\n((8 + 1) * 3) - 3\n((8 - 1) * 3) + 3\n((8 + 1) * 3) - 3\n((8 - 1) * 3) + 3\n(3 * (1 + 8)) - 3\n(3 * (8 + 1)) - 3\n(3 * (8 - 1)) + 3\n(3 * (1 + 8)) - 3\n(3 * (8 + 1)) - 3\n(3 * (8 - 1)) + 3\n3 - ((1 - 8) * 3)\n3 + ((8 - 1) * 3)\n3 - ((1 - 8) * 3)\n3 + ((8 - 1) * 3)\n3 - (3 * (1 - 8))\n3 + (3 * (8 - 1))\n3 - (3 * (1 - 8))\n3 + (3 * (8 - 1))\nEnter four integers or 'q' to exit: q\n\nE:\\Temp>\n", "explain": "Will generate all possible solutions of any given four numbers according to the rules of the 24 game.\nNote: the permute function was taken from here\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Prolog", "code": "\n\nplay24(Len, Range, Goal) :-\n\tgame(Len, Range, Goal, L, S),\n\tmaplist(my_write, L),\n\tformat(': ~w~n', [S]).\n\ngame(Len, Range, Value, L, S) :-\n\tlength(L, Len),\n\tmaplist(choose(Range), L),\n\tcompute(L, Value, [], S).\n\n\nchoose(Range, V) :-\n\tV is random(Range) + 1.\n\n\nwrite_tree([M], [M]).\n\nwrite_tree([+, M, N], S) :-\n\twrite_tree(M, MS),\n\twrite_tree(N, NS),\n\tappend(MS, [+ | NS], S).\n\nwrite_tree([-, M, N], S) :-\n\twrite_tree(M, MS),\n\twrite_tree(N, NS),\n\t(   is_add(N) -> append(MS, [-, '(' | NS], Temp), append(Temp, ')', S)\n\t;   append(MS, [- | NS], S)).\n\n\nwrite_tree([Op, M, N], S) :-\n\tmember(Op, [*, /]),\n\twrite_tree(M, MS),\n\twrite_tree(N, NS),\n\t(   is_add(M) -> append(['(' | MS], [')'], TempM)\n\t;  TempM = MS),\n\t(   is_add(N) -> append(['(' | NS], [')'], TempN)\n\t;   TempN = NS),\n\tappend(TempM, [Op | TempN], S).\n\nis_add([Op, _, _]) :-\n\tmember(Op, [+, -]).\n\ncompute([Value], Value, [[_R-S1]], S) :-\n\twrite_tree(S1, S2),\n\twith_output_to(atom(S), maplist(write, S2)).\n\ncompute(L, Value, CS, S) :-\n\tselect(M, L, L1),\n\tselect(N, L1, L2),\n\tnext_value(M, N, R, CS, Expr),\n\tcompute([R|L2], Value, Expr, S).\n\nnext_value(M, N, R, CS,[[R - [+, M1, N1]] | CS2]) :-\n\tR is M+N,\n\t(   member([M-ExprM], CS) -> select([M-ExprM], CS, CS1), M1 = ExprM\n\t;   M1 = [M], CS1 = CS\n\t),\n\t(   member([N-ExprN], CS1) -> select([N-ExprN], CS1, CS2), N1 = ExprN\n\t;   N1 = [N], CS2 = CS1\n\t).\n\nnext_value(M, N, R, CS,[[R - [-, M1, N1]] | CS2]) :-\n\tR is M-N,\n\t(   member([M-ExprM], CS) -> select([M-ExprM], CS, CS1), M1 = ExprM\n\t;   M1 = [M], CS1 = CS\n\t),\n\t(   member([N-ExprN], CS1) -> select([N-ExprN], CS1, CS2), N1 = ExprN\n\t;   N1 = [N], CS2 = CS1\n\t).\n\nnext_value(M, N, R, CS,[[R - [*, M1, N1]] | CS2]) :-\n\tR is M*N,\n\t(   member([M-ExprM], CS) -> select([M-ExprM], CS, CS1), M1 = ExprM\n\t;   M1 = [M], CS1 = CS\n\t),\n\t(   member([N-ExprN], CS1) -> select([N-ExprN], CS1, CS2), N1 = ExprN\n\t;   N1 = [N], CS2 = CS1\n\t).\n\nnext_value(M, N, R, CS,[[R - [/, M1, N1]] | CS2]) :-\n\tN \\= 0,\n\tR is rdiv(M,N),\n\t(   member([M-ExprM], CS) -> select([M-ExprM], CS, CS1), M1 = ExprM\n\t;   M1 = [M], CS1 = CS\n\t),\n\t(   member([N-ExprN], CS1) -> select([N-ExprN], CS1, CS2), N1 = ExprN\n\t;   N1 = [N], CS2 = CS1\n\t).\n\nmy_write(V) :-\n\tformat('~w ', [V]).\n\n\nOutput:\n?- play24(4,9, 24).\n6 2 3 4\u00a0: (6-2+4)*3\ntrue\u00a0;\n6 2 3 4\u00a0: 3*(6-2+4)\ntrue\u00a0;\n6 2 3 4\u00a0: (6-2+4)*3\ntrue\u00a0;\n6 2 3 4\u00a0: 3*(6-2+4)\ntrue\u00a0;\n6 2 3 4\u00a0: (6*2-4)*3\ntrue\u00a0;\n6 2 3 4\u00a0: 3*(6*2-4)\ntrue\u00a0;\n6 2 3 4\u00a0: 3*4+6*2\ntrue\u00a0;\n6 2 3 4\u00a0: 3*4+6*2\ntrue\u00a0;\n6 2 3 4\u00a0: 4*3+6*2\ntrue\u00a0;\n6 2 3 4\u00a0: 4*3+6*2\ntrue\u00a0;\n6 2 3 4\u00a0: (6/2+3)*4\ntrue\u00a0;\n6 2 3 4\u00a0: 4*(6/2+3)\ntrue\u00a0;\n6 2 3 4\u00a0: (6/2+3)*4\ntrue\u00a0;\n6 2 3 4\u00a0: 4*(6/2+3)\ntrue\u00a0;\n6 2 3 4\u00a0: (6-3)*2*4\ntrue\u00a0;\n6 2 3 4\u00a0: 4*(6-3)*2\ntrue\u00a0;\n6 2 3 4\u00a0: (6-3)*4*2\n...\n\n?- play24(7,99, 1).\n66 40 2 76 95 59 12\u00a0: (66+40)/2-76+95-59-12\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: (66+40)/2-76+95-12-59\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: (66+40)/2-76-59+95-12\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: (66+40)/2-76-59-12+95\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: 95+(66+40)/2-76-59-12\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: 95+(66+40)/2-76-59-12\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: 95-12+(66+40)/2-76-59\ntrue\u00a0;\n66 40 2 76 95 59 12\u00a0: (66+40)/2-76-59+95-12\n....\n\nMinimal version[edit]\n\n\nThis example is incorrect.  Please fix the code and remove this message.Details: Does not follow 24 game rules for division: <quote>Division should use floating point or rational arithmetic, etc, to preserve remainders.</quote>\n\nWorks with: GNU Prolog version 1.4.4\n\n:- initialization(main).\n\nsolve(N,Xs,Ast) :-\n    Err = evaluation_error(zero_divisor)\n  , gen_ast(Xs,Ast), catch(Ast =:= N, error(Err,_), fail)\n  .\n\ngen_ast([N],N) :- between(1,9,N).\ngen_ast(Xs,Ast) :-\n    Ys = [_|_], Zs = [_|_], split(Xs,Ys,Zs)\n  , ( member(Op, [(+),(*)]), Ys @=< Zs ; member(Op, [(-),(//)]) )\n  , gen_ast(Ys,A), gen_ast(Zs,B), Ast =.. [Op,A,B]\n  .\n\nsplit(Xs,Ys,Zs) :- sublist(Ys,Xs), select_all(Ys,Xs,Zs).\n    % where\n    select_all([],Xs,Xs).\n    select_all([Y|Ys],Xs,Zs) :- select(Y,Xs,X1), !, select_all(Ys,X1,Zs).\n\n\ntest(T) :- solve(24, [2,3,8,9], T).\nmain :- forall(test(T), (write(T), nl)), halt.\n\n\nOutput:\n(9-3)*8//2\n3*8-2//9\n(8+9)//2*3\n(8-2//9)*3\n(2//9+8)*3\n(2+8*9)//3\n2//9+3*8\n8//2*(9-3)\n(9-3)//2*8\n(9-2*3)*8\n(3-2//9)*8\n(2//9+3)*8\n(2+9)//3*8\n", "explain": "Works with SWI-Prolog.\nThe game is generic, you can choose to play with a goal different of 24, \nany number of numbers in other ranges than 1 .. 9\u00a0! \nrdiv/2 is use instead of //2 to enable the program to solve difficult cases as [3 3 8 8].\nLittle efforts to remove duplicates (e.g. output for [4,6,9,9]).\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Lua", "code": "\n\nlocal SIZE = #arg[1]\nlocal GOAL = tonumber(arg[2]) or 24\n\nlocal input = {}\nfor v in arg[1]:gmatch(\"%d\") do\n\ttable.insert(input, v)\nend\nassert(#input == SIZE, 'Invalid input')\n\nlocal operations = {'+', '-', '*', '/'}\n\nlocal function BinaryTrees(vert)\n\tif vert == 0 then\n\t\treturn {false}\n\telse\n\t\tlocal buf = {}\n\t\tfor leften = 0, vert - 1 do\n\t\t\tlocal righten = vert - leften - 1\n\t\t\tfor _, left in pairs(BinaryTrees(leften)) do\n\t\t\t\tfor _, right in pairs(BinaryTrees(righten)) do\n\t\t\t\t\ttable.insert(buf, {left, right})\n\t\t\t\tend\n\t\t\tend\n\t\tend\n\t\treturn buf\n\tend\nend\nlocal trees = BinaryTrees(SIZE-1)\nlocal c, opc, oper, str\nlocal max = math.pow(#operations, SIZE-1)\nlocal function op(a,b)\n\topc = opc + 1\n\tlocal i = math.floor(oper/math.pow(#operations, opc-1))%#operations+1\n\treturn '('.. a .. operations[i] .. b ..')'\nend\n\nlocal function EvalTree(tree)\n\tif tree == false then\n\t\tc = c + 1\n\t\treturn input[c-1]\n\telse\n\t\treturn op(EvalTree(tree[1]), EvalTree(tree[2]))\n\tend\nend\n\nlocal function printResult()\n\tfor _, v in ipairs(trees) do\n\t\tfor i = 0, max do\n\t\t\tc, opc, oper = 1, 0, i\n\t\t\tstr = EvalTree(v)\n\t\t\tloadstring('res='..str)()\n\t\t\tif(res == GOAL) then print(str, '=', res) end\n\t\tend\n\tend\nend\n\nlocal uniq = {}\nlocal function permgen (a, n)\n\tif n == 0 then\n\t\tlocal str = table.concat(a)\n\t\tif not uniq[str] then \n\t\t\tprintResult()\n\t\t\tuniq[str] = true\n\t\tend\n\telse\n\t\tfor i = 1, n do\n\t\t\ta[n], a[i] = a[i], a[n]\n\t\t\tpermgen(a, n - 1)\n\t\t\ta[n], a[i] = a[i], a[n]\n\t\tend\n\tend\nend\n\npermgen(input, SIZE)\n\n\nOutput:\n$ lua 24game.solve.lua 2389\n(8*(9-(3*2)))\t=\t24\n(8*((9-3)/2))\t=\t24\n((8*(9-3))/2)\t=\t24\n((9-3)*(8/2))\t=\t24\n(((9-3)*8)/2)\t=\t24\n(8*(9-(2*3)))\t=\t24\n(8/(2/(9-3)))\t=\t24\n((8/2)*(9-3))\t=\t24\n((9-3)/(2/8))\t=\t24\n((9-(3*2))*8)\t=\t24\n(((9-3)/2)*8)\t=\t24\n((9-(2*3))*8)\t=\t24\n$ lua 24game.solve.lua 1172\n((1+7)*(2+1))\t=\t24\n((7+1)*(2+1))\t=\t24\n((1+2)*(7+1))\t=\t24\n((2+1)*(7+1))\t=\t24\n((1+2)*(1+7))\t=\t24\n((2+1)*(1+7))\t=\t24\n((1+7)*(1+2))\t=\t24\n((7+1)*(1+2))\t=\t24\n$ lua 24game.solve.lua 123456789 1000\n(2*(3+(4-(5+(6-(7*(8*(9*1))))))))\t=\t1000\n(2*(3+(4-(5+(6-(7*(8*(9/1))))))))\t=\t1000\n(2*(3*(4*(5+(6*(7-(8/(9*1))))))))\t=\t1000\n(2*(3*(4*(5+(6*(7-(8/(9/1))))))))\t=\t1000\n(2*(3+(4-(5+(6-(7*((8*9)*1)))))))\t=\t1000\n(2*(3+(4-(5+(6-(7*((8*9)/1)))))))\t=\t1000\n(2*(3*(4*(5+(6*(7-((8/9)*1)))))))\t=\t1000\n(2*(3*(4*(5+(6*(7-((8/9)/1)))))))\t=\t1000\n.....\n\n", "explain": "Generic solver: pass card of any size with 1st argument and target number with second.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Scala", "code": "\n\ndef permute(l: List[Double]): List[List[Double]] = l match {\n  case Nil => List(Nil)\n  case x :: xs =>\n    for {\n      ys <- permute(xs)\n      position <- 0 to ys.length\n      (left, right) = ys splitAt position\n    } yield left ::: (x :: right)\n}\n\ndef computeAllOperations(l: List[Double]): List[(Double,String)] = l match {\n  case Nil => Nil\n  case x :: Nil => List((x, \"%1.0f\" format x))\n  case x :: xs =>\n    for {\n      (y, ops) <- computeAllOperations(xs)\n      (z, op) <- \n        if (y == 0) \n          List((x*y, \"*\"), (x+y, \"+\"), (x-y, \"-\")) \n        else \n          List((x*y, \"*\"), (x/y, \"/\"), (x+y, \"+\"), (x-y, \"-\"))\n    } yield (z, \"(%1.0f%s%s)\" format (x,op,ops))\n}\n\ndef hasSolution(l: List[Double]) = permute(l) flatMap computeAllOperations filter (_._1 == 24) map (_._2)\n\n\nval problemsIterator = (\n    Iterator\n    continually List.fill(4)(scala.util.Random.nextInt(9) + 1 toDouble)\n    filter (!hasSolution(_).isEmpty)\n)\n\nval solutionIterator = problemsIterator map hasSolution\n\nscala> solutionIterator.next\nres8: List[String] = List((3*(5-(3-6))), (3*(5-(3-6))), (3*(5+(6-3))), (3+(6+(3*5))), (3*(6-(3-5))), (3+(6+(5*3))), (3*(\n6+(5-3))), (3*(5+(6-3))), (3+(6+(5*3))), (3*(6+(5-3))), (6+(3+(5*3))), (6*(5-(3/3))), (6*(5-(3/3))), (3+(6+(3*5))), (3*(\n6-(3-5))), (6+(3+(3*5))), (6+(3+(3*5))), (6+(3+(5*3))))\n\nscala> solutionIterator.next\nres9: List[String] = List((4-(5*(5-9))), (4-(5*(5-9))), (4+(5*(9-5))), (4+(5*(9-5))), (9-(5-(4*5))), (9-(5-(5*4))), (9-(\n5-(4*5))), (9-(5-(5*4))))\n\nscala> solutionIterator.next\nres10: List[String] = List((2*(4+(3+5))), (2*(3+(4+5))), (2*(3+(5+4))), (4*(3-(2-5))), (4*(3+(5-2))), (2*(4+(5+3))), (2*\n(5+(4+3))), (2*(5+(3+4))), (4*(5-(2-3))), (4*(5+(3-2))))\n\nscala> solutionIterator.next\nres11: List[String] = List((4*(5-(2-3))), (2*(4+(5+3))), (2*(5+(4+3))), (2*(5+(3+4))), (2*(4+(3+5))), (2*(3+(4+5))), (2*\n(3+(5+4))), (4*(5+(3-2))), (4*(3+(5-2))), (4*(3-(2-5))))\n\n", "explain": "A non-interactive player.\nExample:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "D", "code": "\n\nTranslation of: Scala\nimport std.stdio, std.algorithm, std.range, std.conv, std.string,\n       std.concurrency, permutations2, arithmetic_rational;\n\nstring solve(in int target, in int[] problem) {\n    static struct T { Rational r; string e; }\n\n    Generator!T computeAllOperations(in Rational[] L) {\n        return new typeof(return)({\n            if (!L.empty) {\n                immutable x = L[0];\n                if (L.length == 1) {\n                    yield(T(x, x.text));\n                } else {\n                    foreach (const o; computeAllOperations(L.dropOne)) {\n                        immutable y = o.r;\n                        auto sub = [T(x * y, \"*\"), T(x + y, \"+\"), T(x - y, \"-\")];\n                        if (y) sub ~= [T(x / y, \"/\")];\n                        foreach (const e; sub)\n                            yield(T(e.r, format(\"(%s%s%s)\", x, e.e, o.e)));\n                    }\n                }\n            }\n        });\n    }\n\n    foreach (const p; problem.map!Rational.array.permutations!false)\n        foreach (const sol; computeAllOperations(p))\n            if (sol.r == target)\n                return sol.e;\n    return \"No solution\";\n}\n\nvoid main() {\n    foreach (const prob; [[6, 7, 9, 5], [3, 3, 8, 8], [1, 1, 1, 1]])\n        writeln(prob, \": \", solve(24, prob));\n}\n\n\nOutput:\n[6, 7, 9, 5]: (6+(9*(7-5)))\n[3, 3, 8, 8]: (8/(3-(8/3)))\n[1, 1, 1, 1]: No solution\n", "explain": "This uses the Rational struct and permutations functions of two other Rosetta Code Tasks.\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Haskell", "code": "\nimport Data.List\nimport Data.Ratio\nimport Control.Monad\nimport System.Environment (getArgs)\n\ndata Expr = Constant Rational |\n    Expr :+ Expr | Expr :- Expr |\n    Expr :* Expr | Expr :/ Expr\n    deriving (Eq)\n\nops = [(:+), (:-), (:*), (:/)]\n\ninstance Show Expr where\n    show (Constant x) = show $ numerator x\n      -- In this program, we need only print integers.\n    show (a :+ b)     = strexp \"+\" a b\n    show (a :- b)     = strexp \"-\" a b\n    show (a :* b)     = strexp \"*\" a b\n    show (a :/ b)     = strexp \"/\" a b\n\nstrexp :: String -> Expr -> Expr -> String\nstrexp op a b = \"(\" ++ show a ++ \" \" ++ op ++ \" \" ++ show b ++ \")\"\n\ntemplates :: [[Expr] -> Expr]\ntemplates = do\n    op1 <- ops\n    op2 <- ops\n    op3 <- ops\n    [\\[a, b, c, d] -> op1 a $ op2 b $ op3 c d,\n     \\[a, b, c, d] -> op1 (op2 a b) $ op3 c d,\n     \\[a, b, c, d] -> op1 a $ op2 (op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 a $ op3 b c) d,\n     \\[a, b, c, d] -> op1 (op2 (op3 a b) c) d]\n\neval :: Expr -> Maybe Rational\neval (Constant c) = Just c\neval (a :+ b)     = liftM2 (+) (eval a) (eval b)\neval (a :- b)     = liftM2 (-) (eval a) (eval b)\neval (a :* b)     = liftM2 (*) (eval a) (eval b)\neval (a :/ b)     = do\n    denom <- eval b\n    guard $ denom /= 0\n    liftM (/ denom) $ eval a\n\nsolve :: Rational -> [Rational] -> [Expr]\nsolve target r4 = filter (maybe False (== target) . eval) $\n    liftM2 ($) templates $\n    nub $ permutations $ map Constant r4 \n\nmain = getArgs >>= mapM_ print . solve 24 . map (toEnum . read)\n\n\n$ runghc 24Player.hs 2 3 8 9\n(8 * (9 - (3 * 2)))\n(8 * (9 - (2 * 3)))\n((9 - (2 * 3)) * 8)\n((9 - (3 * 2)) * 8)\n((9 - 3) * (8 / 2))\n((8 / 2) * (9 - 3))\n(8 * ((9 - 3) / 2))\n(((9 - 3) / 2) * 8)\n((9 - 3) / (2 / 8))\n((8 * (9 - 3)) / 2)\n(((9 - 3) * 8) / 2)\n(8 / (2 / (9 - 3)))\nAlternative version[edit]\nimport Control.Applicative\nimport Data.List\nimport Text.PrettyPrint\n\n\ndata Expr = C Int | Op String Expr Expr\n\ntoDoc (C     x  ) = int x\ntoDoc (Op op x y) = parens $ toDoc x <+> text op <+> toDoc y\n\nops :: [(String, Int -> Int -> Int)]\nops = [(\"+\",(+)), (\"-\",(-)), (\"*\",(*)), (\"/\",div)]\n\n\nsolve :: Int -> [Int] -> [Expr]\nsolve res = filter ((Just res ==) . eval) . genAst\n  where\n    genAst [x] = [C x]\n    genAst xs  = do\n      (ys,zs) <- split xs\n      let f (Op op _ _) = op `notElem` [\"+\",\"*\"] || ys <= zs\n      filter f $ Op <$> map fst ops <*> genAst ys <*> genAst zs\n\n    eval (C      x  ) = Just x\n    eval (Op \"/\" _ y) | Just 0 <- eval y = Nothing\n    eval (Op op  x y) = lookup op ops <*> eval x <*> eval y\n\n\nselect :: Int -> [Int] -> [[Int]]\nselect 0 _  = [[]]\nselect n xs = [x:zs | k <- [0..length xs - n]\n                    , let (x:ys) = drop k xs\n                    , zs <- select (n - 1) ys\n                    ]\n\nsplit :: [Int] -> [([Int],[Int])]\nsplit xs = [(ys, xs \\\\ ys) | n <- [1..length xs - 1]\n                           , ys <- nub . sort $ select n xs\n                           ]\n\n                           \nmain = mapM_ (putStrLn . render . toDoc) $ solve 24 [2,3,8,9]\n\n\nOutput:\n((8 / 2) * (9 - 3))\n((2 / 9) + (3 * 8))\n((3 * 8) - (2 / 9))\n((8 - (2 / 9)) * 3)\n(((2 / 9) + 8) * 3)\n(((8 + 9) / 2) * 3)\n((2 + (8 * 9)) / 3)\n((3 - (2 / 9)) * 8)\n((9 - (2 * 3)) * 8)\n(((2 / 9) + 3) * 8)\n(((2 + 9) / 3) * 8)\n(((9 - 3) / 2) * 8)\n(((9 - 3) * 8) / 2)\n", "explain": "Example use:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "Scheme", "code": "\n\n#!r6rs\n\n(import (rnrs)\n        (rnrs eval)\n        (only (srfi :1 lists) append-map delete-duplicates iota))\n\n(define (map* fn . lis)\n  (if (null? lis)\n      (list (fn))\n      (append-map (lambda (x)\n                    (apply map*\n                           (lambda xs (apply fn x xs))\n                           (cdr lis)))\n                  (car lis))))\n\n(define (insert x li n)\n  (if (= n 0)\n      (cons x li)\n      (cons (car li) (insert x (cdr li) (- n 1)))))\n\n(define (permutations li)\n  (if (null? li)\n      (list ())\n      (map* insert (list (car li)) (permutations (cdr li)) (iota (length li)))))\n\n(define (evaluates-to-24 expr)\n  (guard (e ((assertion-violation? e) #f))\n    (= 24 (eval expr (environment '(rnrs base))))))\n\n(define (tree n o0 o1 o2 xs)\n  (list-ref\n   (list\n    `(,o0 (,o1 (,o2 ,(car xs) ,(cadr xs)) ,(caddr xs)) ,(cadddr xs))\n    `(,o0 (,o1 (,o2 ,(car xs) ,(cadr xs)) ,(caddr xs)) ,(cadddr xs))\n    `(,o0 (,o1 ,(car xs) (,o2 ,(cadr xs) ,(caddr xs))) ,(cadddr xs))\n    `(,o0 (,o1 ,(car xs) ,(cadr xs)) (,o2 ,(caddr xs) ,(cadddr xs)))\n    `(,o0 ,(car xs) (,o1 (,o2 ,(cadr xs) ,(caddr xs)) ,(cadddr xs)))\n    `(,o0 ,(car xs) (,o1 ,(cadr xs) (,o2 ,(caddr xs) ,(cadddr xs)))))\n   n))\n\n(define (solve a b c d)\n  (define ops '(+ - * /))\n  (define perms (delete-duplicates (permutations (list a b c d))))\n  (delete-duplicates\n   (filter evaluates-to-24\n           (map* tree (iota 6) ops ops ops perms))))\n\n\n> (solve 1 3 5 7)\n((* (+ 1 5) (- 7 3))\n (* (+ 5 1) (- 7 3))\n (* (+ 5 7) (- 3 1))\n (* (+ 7 5) (- 3 1))\n (* (- 3 1) (+ 5 7))\n (* (- 3 1) (+ 7 5))\n (* (- 7 3) (+ 1 5))\n (* (- 7 3) (+ 5 1)))\n> (solve 3 3 8 8)\n((/ 8 (- 3 (/ 8 3))))\n> (solve 3 4 9 10)\n()\n\n", "explain": "This version outputs an S-expression that will eval to 24 (rather than converting to infix notation).\nExample output:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "ABAP", "code": "\n\ndata: lv_flag type c,\n      lv_number type i,\n      lt_numbers type table of i.\n\nconstants: c_no_val type i value 9999.\n\nappend 1 to lt_numbers.\nappend 1 to lt_numbers.\nappend 2 to lt_numbers.\nappend 7 to lt_numbers.\n\nwrite 'Evaluating 24 with the following input: '.\nloop at lt_numbers into lv_number.\n  write lv_number.\nendloop.  \nperform solve_24 using lt_numbers.\n\nform eval_formula using iv_eval type string changing ev_out type i.\n  call function 'EVAL_FORMULA' \"analysis of a syntactically correct formula\n    exporting\n      formula = iv_eval\n    importing\n      value   = ev_out\n    exceptions\n   others     = 1.\n\n  if sy-subrc <> 0.\n    ev_out = -1.\n  endif.\nendform.\n\n\" Solve a 24 puzzle.\nform solve_24 using it_numbers like lt_numbers.\n  data: lv_flag   type c,\n        lv_op1    type c,\n        lv_op2    type c,\n        lv_op3    type c,\n        lv_var1   type c,\n        lv_var2   type c,\n        lv_var3   type c,\n        lv_var4   type c,\n        lv_eval   type string,\n        lv_result type i,\n        lv_var     type i.\n\n  define retrieve_var.\n    read table it_numbers index &1 into lv_var.\n    &2 = lv_var.\n  end-of-definition.\n\n  define retrieve_val.\n    perform eval_formula using lv_eval changing lv_result.\n    if lv_result = 24.\n        write / lv_eval.\n    endif.\n  end-of-definition.\n  \" Loop through all the possible number permutations.\n  do.\n    \" Init. the operations table.\n\n    retrieve_var: 1 lv_var1, 2 lv_var2, 3 lv_var3, 4 lv_var4.\n    do 4 times.\n      case sy-index.\n        when 1.\n          lv_op1 = '+'.\n        when 2.\n          lv_op1 = '*'.\n        when 3.\n          lv_op1 = '-'.\n        when 4.\n          lv_op1 = '/'.\n      endcase.\n      do 4 times.\n        case sy-index.\n        when 1.\n          lv_op2 = '+'.\n        when 2.\n          lv_op2 = '*'.\n        when 3.\n          lv_op2 = '-'.\n        when 4.\n          lv_op2 = '/'.\n        endcase.\n        do 4 times.\n          case sy-index.\n          when 1.\n            lv_op3 = '+'.\n          when 2.\n            lv_op3 = '*'.\n          when 3.\n            lv_op3 = '-'.\n          when 4.\n            lv_op3 = '/'.\n          endcase.\n          concatenate '(' '(' lv_var1 lv_op1 lv_var2 ')' lv_op2 lv_var3 ')' lv_op3 lv_var4  into lv_eval separated by space.\n          retrieve_val.\n          concatenate '(' lv_var1 lv_op1 lv_var2 ')' lv_op2 '(' lv_var3 lv_op3 lv_var4 ')'  into lv_eval separated by space.\n          retrieve_val.\n          concatenate '(' lv_var1 lv_op1 '(' lv_var2 lv_op2 lv_var3 ')' ')' lv_op3 lv_var4  into lv_eval separated by space.\n          retrieve_val.\n          concatenate lv_var1 lv_op1 '(' '(' lv_var2 lv_op2 lv_var3 ')' lv_op3 lv_var4 ')'  into lv_eval separated by space.\n          retrieve_val.\n          concatenate lv_var1 lv_op1 '(' lv_var2 lv_op2 '(' lv_var3 lv_op3 lv_var4 ')' ')'  into lv_eval separated by space.\n          retrieve_val.\n        enddo.\n      enddo.\n    enddo.\n\n    \" Once we've reached the last permutation -> Exit.\n    perform permute using it_numbers changing lv_flag.\n    if lv_flag = 'X'.\n      exit.\n    endif.\n  enddo.\nendform.\n\n\n\" Permutation function - this is used to permute:\n\" A = {A1...AN} -> Set of supplied variables.\n\" B = {B1...BN - 1} -> Set of operators.\n\" Can be used for an unbounded size set. Relies\n\" on lexicographic ordering of the set.\nform permute using iv_set like lt_numbers\n             changing ev_last type c.\n  data: lv_len     type i,\n        lv_first   type i,\n        lv_third   type i,\n        lv_count   type i,\n        lv_temp    type i,\n        lv_temp_2  type i,\n        lv_second  type i,\n        lv_changed type c,\n        lv_perm    type i.\n  describe table iv_set lines lv_len.\n\n  lv_perm = lv_len - 1.\n  lv_changed = ' '.\n  \" Loop backwards through the table, attempting to find elements which\n  \" can be permuted. If we find one, break out of the table and set the\n  \" flag indicating a switch.\n  do.\n    if lv_perm <= 0.\n      exit.\n    endif.\n    \" Read the elements.\n    read table iv_set index lv_perm into lv_first.\n    add 1 to lv_perm.\n    read table iv_set index lv_perm into lv_second.\n    subtract 1 from lv_perm.\n    if lv_first < lv_second.\n      lv_changed = 'X'.\n      exit.\n    endif.\n    subtract 1 from lv_perm.\n  enddo.\n\n  \" Last permutation.\n  if lv_changed <> 'X'.\n    ev_last = 'X'.\n    exit.\n  endif.\n\n  \" Swap tail decresing to get a tail increasing.\n  lv_count = lv_perm + 1.\n  do.\n    lv_first = lv_len + lv_perm - lv_count + 1.\n    if lv_count >= lv_first.\n      exit.\n    endif.\n\n    read table iv_set index lv_count into lv_temp.\n    read table iv_set index lv_first into lv_temp_2.\n    modify iv_set index lv_count from lv_temp_2.\n    modify iv_set index lv_first from lv_temp.\n    add 1 to lv_count.\n  enddo.\n\n  lv_count = lv_len - 1.\n  do.\n    if lv_count <= lv_perm.\n      exit.\n    endif.\n\n    read table iv_set index lv_count into lv_first.\n    read table iv_set index lv_perm into lv_second.\n    read table iv_set index lv_len into lv_third.\n    if ( lv_first < lv_third ) and ( lv_first > lv_second ).\n      lv_len = lv_count.\n    endif.\n\n    subtract 1 from lv_count.\n  enddo.\n\n  read table iv_set index lv_perm into lv_temp.\n  read table iv_set index lv_len into lv_temp_2.\n  modify iv_set index lv_perm from lv_temp_2.\n  modify iv_set index lv_len from lv_temp.\nendform.\n\n\nEvaluating 24 with the following input:  1 1 2 7\n( 1 + 2 ) * ( 1 + 7 )\n( 1 + 2 ) * ( 7 + 1 )\n( 1 + 7 ) * ( 1 + 2 )\n( 1 + 7 ) * ( 2 + 1 )\n( 2 + 1 ) * ( 1 + 7 )\n( 2 + 1 ) * ( 7 + 1 )\n( 7 + 1 ) * ( 1 + 2 )\n( 7 + 1 ) * ( 2 + 1 )\n\nEvaluating 24 with the following input:  1\n( ( 1 + 2 ) + 3 ) * 4\n( 1 + ( 2 + 3 ) ) * 4\n( ( 1 * 2 ) * 3 ) * 4\n( 1 * 2 ) * ( 3 * 4 )\n( 1 * ( 2 * 3 ) ) * 4\n1 * ( ( 2 * 3 ) * 4 )\n1 * ( 2 * ( 3 * 4 ) )\n( ( 1 * 2 ) * 4 ) * 3\n( 1 * 2 ) * ( 4 * 3 )\n( 1 * ( 2 * 4 ) ) * 3\n1 * ( ( 2 * 4 ) * 3 )\n1 * ( 2 * ( 4 * 3 ) )\n( ( 1 + 3 ) + 2 ) * 4\n( 1 + ( 3 + 2 ) ) * 4\n( 1 + 3 ) * ( 2 + 4 )\n( ( 1 * 3 ) * 2 ) * 4\n( 1 * 3 ) * ( 2 * 4 )\n( 1 * ( 3 * 2 ) ) * 4\n1 * ( ( 3 * 2 ) * 4 )\n1 * ( 3 * ( 2 * 4 ) )\n( 1 + 3 ) * ( 4 + 2 )\n( ( 1 * 3 ) * 4 ) * 2\n( 1 * 3 ) * ( 4 * 2 )\n( 1 * ( 3 * 4 ) ) * 2\n1 * ( ( 3 * 4 ) * 2 )\n1 * ( 3 * ( 4 * 2 ) )\n( ( 1 * 4 ) * 2 ) * 3\n( 1 * 4 ) * ( 2 * 3 )\n( 1 * ( 4 * 2 ) ) * 3\n1 * ( ( 4 * 2 ) * 3 )\n1 * ( 4 * ( 2 * 3 ) )\n( ( 1 * 4 ) * 3 ) * 2\n( 1 * 4 ) * ( 3 * 2 )\n( 1 * ( 4 * 3 ) ) * 2\n1 * ( ( 4 * 3 ) * 2 )\n1 * ( 4 * ( 3 * 2 ) )\n( ( 2 + 1 ) + 3 ) * 4\n( 2 + ( 1 + 3 ) ) * 4\n( ( 2 * 1 ) * 3 ) * 4\n( 2 * 1 ) * ( 3 * 4 )\n( 2 * ( 1 * 3 ) ) * 4\n2 * ( ( 1 * 3 ) * 4 )\n2 * ( 1 * ( 3 * 4 ) )\n( ( 2 / 1 ) * 3 ) * 4\n( 2 / 1 ) * ( 3 * 4 )\n( 2 / ( 1 / 3 ) ) * 4\n2 / ( 1 / ( 3 * 4 ) )\n2 / ( ( 1 / 3 ) / 4 )\n( ( 2 * 1 ) * 4 ) * 3\n( 2 * 1 ) * ( 4 * 3 )\n( 2 * ( 1 * 4 ) ) * 3\n2 * ( ( 1 * 4 ) * 3 )\n2 * ( 1 * ( 4 * 3 ) )\n( ( 2 / 1 ) * 4 ) * 3\n( 2 / 1 ) * ( 4 * 3 )\n( 2 / ( 1 / 4 ) ) * 3\n2 / ( 1 / ( 4 * 3 ) )\n2 / ( ( 1 / 4 ) / 3 )\n( ( 2 + 3 ) + 1 ) * 4\n( 2 + ( 3 + 1 ) ) * 4\n( ( 2 * 3 ) * 1 ) * 4\n( 2 * 3 ) * ( 1 * 4 )\n( 2 * ( 3 * 1 ) ) * 4\n2 * ( ( 3 * 1 ) * 4 )\n2 * ( 3 * ( 1 * 4 ) )\n( ( 2 * 3 ) / 1 ) * 4\n( 2 * ( 3 / 1 ) ) * 4\n2 * ( ( 3 / 1 ) * 4 )\n( 2 * 3 ) / ( 1 / 4 )\n2 * ( 3 / ( 1 / 4 ) )\n( ( 2 * 3 ) * 4 ) * 1\n( 2 * 3 ) * ( 4 * 1 )\n( 2 * ( 3 * 4 ) ) * 1\n2 * ( ( 3 * 4 ) * 1 )\n2 * ( 3 * ( 4 * 1 ) )\n( ( 2 * 3 ) * 4 ) / 1\n( 2 * 3 ) * ( 4 / 1 )\n( 2 * ( 3 * 4 ) ) / 1\n2 * ( ( 3 * 4 ) / 1 )\n2 * ( 3 * ( 4 / 1 ) )\n( 2 + 4 ) * ( 1 + 3 )\n( ( 2 * 4 ) * 1 ) * 3\n( 2 * 4 ) * ( 1 * 3 )\n( 2 * ( 4 * 1 ) ) * 3\n2 * ( ( 4 * 1 ) * 3 )\n2 * ( 4 * ( 1 * 3 ) )\n( ( 2 * 4 ) / 1 ) * 3\n( 2 * ( 4 / 1 ) ) * 3\n2 * ( ( 4 / 1 ) * 3 )\n( 2 * 4 ) / ( 1 / 3 )\n2 * ( 4 / ( 1 / 3 ) )\n( 2 + 4 ) * ( 3 + 1 )\n( ( 2 * 4 ) * 3 ) * 1\n( 2 * 4 ) * ( 3 * 1 )\n( 2 * ( 4 * 3 ) ) * 1\n2 * ( ( 4 * 3 ) * 1 )\n2 * ( 4 * ( 3 * 1 ) )\n( ( 2 * 4 ) * 3 ) / 1\n( 2 * 4 ) * ( 3 / 1 )\n( 2 * ( 4 * 3 ) ) / 1\n2 * ( ( 4 * 3 ) / 1 )\n2 * ( 4 * ( 3 / 1 ) )\n( ( 3 + 1 ) + 2 ) * 4\n( 3 + ( 1 + 2 ) ) * 4\n( 3 + 1 ) * ( 2 + 4 )\n( ( 3 * 1 ) * 2 ) * 4\n( 3 * 1 ) * ( 2 * 4 )\n( 3 * ( 1 * 2 ) ) * 4\n3 * ( ( 1 * 2 ) * 4 )\n3 * ( 1 * ( 2 * 4 ) )\n( ( 3 / 1 ) * 2 ) * 4\n( 3 / 1 ) * ( 2 * 4 )\n( 3 / ( 1 / 2 ) ) * 4\n3 / ( 1 / ( 2 * 4 ) )\n3 / ( ( 1 / 2 ) / 4 )\n( 3 + 1 ) * ( 4 + 2 )\n( ( 3 * 1 ) * 4 ) * 2\n( 3 * 1 ) * ( 4 * 2 )\n( 3 * ( 1 * 4 ) ) * 2\n3 * ( ( 1 * 4 ) * 2 )\n3 * ( 1 * ( 4 * 2 ) )\n( ( 3 / 1 ) * 4 ) * 2\n( 3 / 1 ) * ( 4 * 2 )\n( 3 / ( 1 / 4 ) ) * 2\n3 / ( 1 / ( 4 * 2 ) )\n3 / ( ( 1 / 4 ) / 2 )\n( ( 3 + 2 ) + 1 ) * 4\n( 3 + ( 2 + 1 ) ) * 4\n( ( 3 * 2 ) * 1 ) * 4\n( 3 * 2 ) * ( 1 * 4 )\n( 3 * ( 2 * 1 ) ) * 4\n3 * ( ( 2 * 1 ) * 4 )\n3 * ( 2 * ( 1 * 4 ) )\n( ( 3 * 2 ) / 1 ) * 4\n( 3 * ( 2 / 1 ) ) * 4\n3 * ( ( 2 / 1 ) * 4 )\n( 3 * 2 ) / ( 1 / 4 )\n3 * ( 2 / ( 1 / 4 ) )\n( ( 3 * 2 ) * 4 ) * 1\n( 3 * 2 ) * ( 4 * 1 )\n( 3 * ( 2 * 4 ) ) * 1\n3 * ( ( 2 * 4 ) * 1 )\n3 * ( 2 * ( 4 * 1 ) )\n( ( 3 * 2 ) * 4 ) / 1\n( 3 * 2 ) * ( 4 / 1 )\n( 3 * ( 2 * 4 ) ) / 1\n3 * ( ( 2 * 4 ) / 1 )\n3 * ( 2 * ( 4 / 1 ) )\n( ( 3 * 4 ) * 1 ) * 2\n( 3 * 4 ) * ( 1 * 2 )\n( 3 * ( 4 * 1 ) ) * 2\n3 * ( ( 4 * 1 ) * 2 )\n3 * ( 4 * ( 1 * 2 ) )\n( ( 3 * 4 ) / 1 ) * 2\n( 3 * ( 4 / 1 ) ) * 2\n3 * ( ( 4 / 1 ) * 2 )\n( 3 * 4 ) / ( 1 / 2 )\n3 * ( 4 / ( 1 / 2 ) )\n( ( 3 * 4 ) * 2 ) * 1\n( 3 * 4 ) * ( 2 * 1 )\n( 3 * ( 4 * 2 ) ) * 1\n3 * ( ( 4 * 2 ) * 1 )\n3 * ( 4 * ( 2 * 1 ) )\n( ( 3 * 4 ) * 2 ) / 1\n( 3 * 4 ) * ( 2 / 1 )\n( 3 * ( 4 * 2 ) ) / 1\n3 * ( ( 4 * 2 ) / 1 )\n3 * ( 4 * ( 2 / 1 ) )\n4 * ( ( 1 + 2 ) + 3 )\n4 * ( 1 + ( 2 + 3 ) )\n( ( 4 * 1 ) * 2 ) * 3\n( 4 * 1 ) * ( 2 * 3 )\n( 4 * ( 1 * 2 ) ) * 3\n4 * ( ( 1 * 2 ) * 3 )\n4 * ( 1 * ( 2 * 3 ) )\n( ( 4 / 1 ) * 2 ) * 3\n( 4 / 1 ) * ( 2 * 3 )\n( 4 / ( 1 / 2 ) ) * 3\n4 / ( 1 / ( 2 * 3 ) )\n4 / ( ( 1 / 2 ) / 3 )\n4 * ( ( 1 + 3 ) + 2 )\n4 * ( 1 + ( 3 + 2 ) )\n( ( 4 * 1 ) * 3 ) * 2\n( 4 * 1 ) * ( 3 * 2 )\n( 4 * ( 1 * 3 ) ) * 2\n4 * ( ( 1 * 3 ) * 2 )\n4 * ( 1 * ( 3 * 2 ) )\n( ( 4 / 1 ) * 3 ) * 2\n( 4 / 1 ) * ( 3 * 2 )\n( 4 / ( 1 / 3 ) ) * 2\n4 / ( 1 / ( 3 * 2 ) )\n4 / ( ( 1 / 3 ) / 2 )\n( 4 + 2 ) * ( 1 + 3 )\n4 * ( ( 2 + 1 ) + 3 )\n4 * ( 2 + ( 1 + 3 ) )\n( ( 4 * 2 ) * 1 ) * 3\n( 4 * 2 ) * ( 1 * 3 )\n( 4 * ( 2 * 1 ) ) * 3\n4 * ( ( 2 * 1 ) * 3 )\n4 * ( 2 * ( 1 * 3 ) )\n( ( 4 * 2 ) / 1 ) * 3\n( 4 * ( 2 / 1 ) ) * 3\n4 * ( ( 2 / 1 ) * 3 )\n( 4 * 2 ) / ( 1 / 3 )\n4 * ( 2 / ( 1 / 3 ) )\n( 4 + 2 ) * ( 3 + 1 )\n4 * ( ( 2 + 3 ) + 1 )\n4 * ( 2 + ( 3 + 1 ) )\n( ( 4 * 2 ) * 3 ) * 1\n( 4 * 2 ) * ( 3 * 1 )\n( 4 * ( 2 * 3 ) ) * 1\n4 * ( ( 2 * 3 ) * 1 )\n4 * ( 2 * ( 3 * 1 ) )\n( ( 4 * 2 ) * 3 ) / 1\n( 4 * 2 ) * ( 3 / 1 )\n( 4 * ( 2 * 3 ) ) / 1\n4 * ( ( 2 * 3 ) / 1 )\n4 * ( 2 * ( 3 / 1 ) )\n4 * ( ( 3 + 1 ) + 2 )\n4 * ( 3 + ( 1 + 2 ) )\n( ( 4 * 3 ) * 1 ) * 2\n( 4 * 3 ) * ( 1 * 2 )\n( 4 * ( 3 * 1 ) ) * 2\n4 * ( ( 3 * 1 ) * 2 )\n4 * ( 3 * ( 1 * 2 ) )\n( ( 4 * 3 ) / 1 ) * 2\n( 4 * ( 3 / 1 ) ) * 2\n4 * ( ( 3 / 1 ) * 2 )\n( 4 * 3 ) / ( 1 / 2 )\n4 * ( 3 / ( 1 / 2 ) )\n4 * ( ( 3 + 2 ) + 1 )\n4 * ( 3 + ( 2 + 1 ) )\n( ( 4 * 3 ) * 2 ) * 1\n( 4 * 3 ) * ( 2 * 1 )\n( 4 * ( 3 * 2 ) ) * 1\n4 * ( ( 3 * 2 ) * 1 )\n4 * ( 3 * ( 2 * 1 ) )\n( ( 4 * 3 ) * 2 ) / 1\n( 4 * 3 ) * ( 2 / 1 )\n( 4 * ( 3 * 2 ) ) / 1\n4 * ( ( 3 * 2 ) / 1 )\n4 * ( 3 * ( 2 / 1 ) )\n\nEvaluating 24 with the following input:  5 6 7 8\n5 * ( 6 - ( 8 / 7 ) )\n( 5 + 7 ) * ( 8 - 6 )\n( ( 5 + 7 ) - 8 ) * 6\n( 5 + ( 7 - 8 ) ) * 6\n( ( 5 - 8 ) + 7 ) * 6\n( 5 - ( 8 - 7 ) ) * 6\n6 * ( ( 5 + 7 ) - 8 )\n6 * ( 5 + ( 7 - 8 ) )\n6 * ( ( 5 - 8 ) + 7 )\n6 * ( 5 - ( 8 - 7 ) )\n6 * ( ( 7 + 5 ) - 8 )\n6 * ( 7 + ( 5 - 8 ) )\n( 6 / ( 7 - 5 ) ) * 8\n6 / ( ( 7 - 5 ) / 8 )\n6 * ( ( 7 - 8 ) + 5 )\n6 * ( 7 - ( 8 - 5 ) )\n( 6 * 8 ) / ( 7 - 5 )\n6 * ( 8 / ( 7 - 5 ) )\n( 6 - ( 8 / 7 ) ) * 5\n( 7 + 5 ) * ( 8 - 6 )\n( ( 7 + 5 ) - 8 ) * 6\n( 7 + ( 5 - 8 ) ) * 6\n( ( 7 - 8 ) + 5 ) * 6\n( 7 - ( 8 - 5 ) ) * 6\n( 8 - 6 ) * ( 5 + 7 )\n( 8 * 6 ) / ( 7 - 5 )\n8 * ( 6 / ( 7 - 5 ) )\n( 8 - 6 ) * ( 7 + 5 )\n( 8 / ( 7 - 5 ) ) * 6\n8 / ( ( 7 - 5 ) / 6 )\n\n", "explain": "Will generate all possible solutions of any given four numbers according to the rules of the 24 game. \nNote: the permute function was locally from here\nSample Runs:\n"}, {"task_name": "24 game/Solve", "task_url": "https://rosettacode.org/wiki/24_game/Solve", "task_cat": "Puzzles", "lang": "F#", "code": "\n\nopen System\n\nlet rec gcd x y = if x = y || x = 0 then y else if x < y then gcd y x else gcd y (x-y)\nlet abs (x : int) = Math.Abs x\nlet sign (x: int) = Math.Sign x\nlet cint s = Int32.Parse(s)\n\ntype Rat(x : int, y : int) =\n    let g = if y = 0 then 0 else gcd (abs x) (abs y)\n    member this.n = if g = 0 then sign y * sign x else sign y * x / g   // store a minus sign in the numerator\n    member this.d =\n        if y = 0 then 0 else sign y * y / g\n    static member (~-) (x : Rat) = Rat(-x.n, x.d)\n    static member (+) (x : Rat, y : Rat) = Rat(x.n * y.d + y.n * x.d, x.d * y.d)\n    static member (-) (x : Rat, y : Rat) = x + Rat(-y.n, y.d)\n    static member (*) (x : Rat, y : Rat) = Rat(x.n * y.n, x.d * y.d)\n    static member (/) (x : Rat, y : Rat) = x * Rat(y.d, y.n)\n    interface System.IComparable with\n      member this.CompareTo o = \n        match o with\n        | :? Rat as that -> compare (this.n * that.d) (that.n * this.d)\n        | _ -> invalidArg \"o\" \"cannot compare values of differnet types.\"\n    override this.Equals(o) =\n        match o with\n        | :? Rat as that -> this.n = that.n && this.d = that.d\n        | _ -> false\n    override this.ToString() =\n        if this.d = 1 then this.n.ToString()\n        else sprintf @\"<%d,%d>\" this.n this.d\n    new(x : string, y : string) = if y = \"\" then Rat(cint x, 1) else Rat(cint x, cint y)\n\ntype expression =\n    | Const of Rat\n    | Sum  of expression * expression\n    | Diff of expression * expression\n    | Prod of expression * expression\n    | Quot of expression * expression\n \nlet rec eval = function\n    | Const c -> c\n    | Sum (f, g) -> eval f + eval g\n    | Diff(f, g) -> eval f - eval g\n    | Prod(f, g) -> eval f * eval g\n    | Quot(f, g) -> eval f / eval g\n\nlet print_expr expr =\n    let concat (s : seq<string>) = System.String.Concat s\n    let paren p prec op_prec = if prec > op_prec then p else \"\"\n    let rec print prec = function\n    | Const c -> c.ToString()\n    | Sum(f, g) ->\n        concat [ (paren \"(\" prec 0); (print 0 f); \" + \"; (print 0 g); (paren \")\" prec 0) ]\n    | Diff(f, g) ->\n        concat [ (paren \"(\" prec 0); (print 0 f); \" - \"; (print 1 g); (paren \")\" prec 0) ]\n    | Prod(f, g) ->\n        concat [ (paren \"(\" prec 2); (print 2 f); \" * \"; (print 2 g); (paren \")\" prec 2) ]\n    | Quot(f, g) ->\n        concat [ (paren \"(\" prec 2); (print 2 f); \" / \"; (print 3 g); (paren \")\" prec 2) ]\n    print 0 expr\n    \nlet rec normal expr =\n    let norm epxr =\n        match expr with\n        | Sum(x, y) -> if eval x <= eval y then expr else Sum(normal y, normal x)\n        | Prod(x, y) -> if eval x <= eval y then expr else Prod(normal y, normal x)\n        | _ -> expr\n    match expr with\n    | Const c -> expr\n    | Sum(x, y) -> norm (Sum(normal x, normal y))\n    | Prod(x, y) -> norm (Prod(normal x, normal y))\n    | Diff(x, y) -> Diff(normal x, normal y)\n    | Quot(x, y) -> Quot(normal x, normal y)\n \nlet rec insert v = function\n    | [] -> [[v]]\n    | x::xs as li -> (v::li) :: (List.map (fun y -> x::y) (insert v xs))\n \nlet permutations li = \n    List.foldBack (fun x z -> List.concat (List.map (insert x) z)) li [[]]\n\nlet rec comp expr rest = seq {\n    match rest with\n    | x::xs ->\n        yield! comp (Sum (expr, x)) xs;\n        yield! comp (Diff(x, expr)) xs;\n        yield! comp (Diff(expr, x)) xs;\n        yield! comp (Prod(expr, x)) xs;\n        yield! comp (Quot(x, expr)) xs;\n        yield! comp (Quot(expr, x)) xs;\n    | [] -> if eval expr = Rat(24,1) then yield print_expr (normal expr)\n}\n\n[<EntryPoint>]\nlet main argv =\n    let digits = List.init 4 (fun i -> Const (Rat(argv.[i],\"\")))\n    let solutions =\n        permutations digits\n        |> Seq.groupBy (sprintf \"%A\")\n        |> Seq.map snd |> Seq.map Seq.head\n        |> Seq.map (fun x -> comp (List.head x) (List.tail x))\n        |> Seq.choose (fun x -> if Seq.isEmpty x then None else Some x)\n        |> Seq.concat\n    if Seq.isEmpty solutions then\n        printfn \"No solutions.\"\n    else\n        solutions\n        |> Seq.groupBy id\n        |> Seq.iter (fun x -> printfn \"%s\" (fst x))\n    0\n\n\nOutput:\n>solve24 3 3 3 4\n4 * (3 * 3 - 3)\n3 + 3 * (3 + 4)\n\n>solve24 3 3 3 5\nNo solutions.\n\nsolve24 3 3 3 6\n6 + 3 * (3 + 3)\n(3 / 3 + 3) * 6\n3 * (3 + 6) - 3\n3 + 3 + 3 * 6\n\n>solve24 3 3 8 8\n8 / (3 - 8 / 3)\n\n>solve24 3 8 8 9\n3 * (9 - 8 / 8)\n(9 - 8) * 3 * 8\n3 / (9 - 8) * 8\n8 / ((9 - 8) / 3)\n3 * (9 - 8) * 8\n3 * 8 / (9 - 8)\n3 / ((9 - 8) / 8)\n", "explain": "The program wants to give all solutions for a given set of 4 digits.\nIt eliminates all duplicate solutions which result from transposing equal digits.\nThe basic solution is an adaption of the OCaml program. \n"}]