[{"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Python", "code": "\ndef encode(input_string):\n    count = 1\n    prev = None\n    lst = []\n    for character in input_string:\n        if character != prev:\n            if prev:\n                entry = (prev, count)\n                lst.append(entry)\n            count = 1\n            prev = character\n        else:\n            count += 1\n    else:\n        try:\n            entry = (character, count)\n            lst.append(entry)\n            return (lst, 0)\n        except Exception as e:\n            print(\"Exception encountered {e}\".format(e=e)) \n            return (e, 1)\n \ndef decode(lst):\n    q = []\n    for character, count in lst:\n        q.append(character * count)\n    return ''.join(q)\n \n#Method call\nvalue = encode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\nif value[1] == 0:\n    print(\"Encoded value is {}\".format(value[0]))\n    decode(value[0])\n\n\nWorks with: Python version 2.4\nfrom itertools import groupby\ndef encode(input_string):\n    return [(len(list(g)), k) for k,g in groupby(input_string)]\n\ndef decode(lst):\n    return ''.join(c * n for n,c in lst)\n\nencode(\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\")\ndecode([(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')])\n\n\nfrom re import sub\n\ndef encode(text):\n    '''\n    Doctest:\n        >>> encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW')\n        '12W1B12W3B24W1B14W'    \n    '''\n    return sub(r'(.)\\1*', lambda m: str(len(m.group(0))) + m.group(1),\n               text)\n\ndef decode(text):\n    '''\n    Doctest:\n        >>> decode('12W1B12W3B24W1B14W')\n        'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\n    '''\n    return sub(r'(\\d+)(\\D)', lambda m: m.group(2) * int(m.group(1)),\n               text)\n\ntextin = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nassert decode(encode(textin)) == textin\n\n", "explain": "Functional\nBy regular expression\nThe simplified input range of only uppercase characters allows a simple regular expression to be applied repeatedly for encoding, and another for decoding:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct stream_t stream_t, *stream;\nstruct stream_t {\n\t/* get function is supposed to return a byte value (0-255),\n\t\tor -1 to signify end of input */\n\tint (*get)(stream);\n\t/* put function does output, one byte at a time */\n\tint (*put)(stream, int);\n};\n\n/* next two structs inherit from stream_t */\ntypedef struct {\n\tint (*get)(stream);\n\tint (*put)(stream, int);\n\tchar *string;\n\tint pos;\n} string_stream;\n\ntypedef struct {\n\tint (*get)(stream);\n\tint (*put)(stream, int);\n\tFILE *fp;\n} file_stream;\n\n/* methods for above streams */\nint sget(stream in)\n{\n\tint c;\n\tstring_stream* s = (string_stream*) in;\n\tc = (unsigned char)(s->string[s->pos]);\n\tif (c == '\\0') return -1;\n\ts->pos++;\n\treturn c;\n}\n\nint sput(stream out, int c)\n{\n\tstring_stream* s = (string_stream*) out;\n\ts->string[s->pos++] = (c == -1) ? '\\0' : c;\n\tif (c == -1) s->pos = 0;\n\treturn 0;\n}\n\nint file_put(stream out, int c)\n{\n\tfile_stream *f = (file_stream*) out;\n\treturn fputc(c, f->fp);\n}\n\n/* helper function */\nvoid output(stream out, unsigned char* buf, int len)\n{\n\tint i;\n\tout->put(out, 128 + len);\n\tfor (i = 0; i < len; i++)\n\t\tout->put(out, buf[i]);\n}\n\n/* Specification: encoded stream are unsigned bytes consisting of sequences.\n * First byte of each sequence is the length, followed by a number of bytes.\n * If length <=128, the next byte is to be repeated length times;\n * If length > 128, the next (length - 128) bytes are not repeated.\n * this is to improve efficiency for long non-repeating sequences.\n * This scheme can encode arbitrary byte values efficiently.\n * c.f. Adobe PDF spec RLE stream encoding (not exactly the same)\n */\nvoid encode(stream in, stream out)\n{\n\tunsigned char buf[256];\n\tint len = 0, repeat = 0, end = 0, c;\n\tint (*get)(stream) = in->get;\n\tint (*put)(stream, int) = out->put;\n\n\twhile (!end) {\n\t\tend = ((c = get(in)) == -1);\n\t\tif (!end) {\n\t\t\tbuf[len++] = c;\n\t\t\tif (len <= 1) continue;\n\t\t}\n\n\t\tif (repeat) {\n\t\t\tif (buf[len - 1] != buf[len - 2])\n\t\t\t\trepeat = 0;\n\t\t\tif (!repeat || len == 129 || end) {\n\t\t\t\t/* write out repeating bytes */\n\t\t\t\tput(out, end ? len : len - 1);\n\t\t\t\tput(out, buf[0]);\n\t\t\t\tbuf[0] = buf[len - 1];\n\t\t\t\tlen = 1;\n\t\t\t}\n\t\t} else {\n\t\t\tif (buf[len - 1] == buf[len - 2]) {\n\t\t\t\trepeat = 1;\n\t\t\t\tif (len > 2) {\n\t\t\t\t\toutput(out, buf, len - 2);\n\t\t\t\t\tbuf[0] = buf[1] = buf[len - 1];\n\t\t\t\t\tlen = 2;\n\t\t\t\t}\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tif (len == 128 || end) {\n\t\t\t\toutput(out, buf, len);\n\t\t\t\tlen = 0;\n\t\t\t\trepeat = 0;\n\t\t\t}\n\t\t}\n\t}\n\tput(out, -1);\n}\n\nvoid decode(stream in, stream out)\n{\n\tint c, i, cnt;\n\twhile (1) {\n\t\tc = in->get(in);\n\t\tif (c == -1) return;\n\t\tif (c > 128) {\n\t\t\tcnt = c - 128;\n\t\t\tfor (i = 0; i < cnt; i++)\n\t\t\t\tout->put(out, in->get(in));\n\t\t} else {\n\t\t\tcnt = c;\n\t\t\tc = in->get(in);\n\t\t\tfor (i = 0; i < cnt; i++)\n\t\t\t\tout->put(out, c);\n\t\t}\n\t}\n}\n\nint main()\n{\n\tchar buf[256];\n\tstring_stream str_in = { sget, 0,\n\t\t\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\", 0};\n\tstring_stream str_out = { sget, sput, buf, 0 };\n\tfile_stream file = { 0, file_put, stdout };\n\n\t/* encode from str_in to str_out */\n\tencode((stream)&str_in, (stream)&str_out);\n\n\t/* decode from str_out to file (stdout) */\n\tdecode((stream)&str_out, (stream)&file);\n\n\treturn 0;\n}\n\n\n", "explain": "Encoder that can deal with byte streams.  Can encode/decode any byte values and any length with reasonable efficiency.  Also showing OO and polymophism with structs.\nSee Run-length encoding/C\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "C++", "code": "\n#include <algorithm>\n#include <array>\n#include <iterator>\n#include <limits>\n#include <tuple>\n\nnamespace detail_ {\n\n// For constexpr digit<->number conversions.\nconstexpr auto digits = std::array{'0','1','2','3','4','5','6','7','8','9'};\n\n// Helper function to encode a run-length.\ntemplate <typename OutputIterator>\nconstexpr auto encode_run_length(std::size_t n, OutputIterator out)\n{\n    constexpr auto base = digits.size();\n    \n    // Determine the number of digits needed.\n    auto const num_digits = [base](auto n)\n    {\n        auto d = std::size_t{1};\n        while ((n /= digits.size()))\n            ++d;\n        return d;\n    }(n);\n    \n    // Helper lambda to raise the base to an integer power.\n    auto base_power = [base](auto n)\n    {\n        auto res = decltype(base){1};\n        for (auto i = decltype(n){1}; i < n; ++i)\n            res *= base;\n        return res;\n    };\n    \n    // From the most significant digit to the least, output the digit.\n    for (auto i = decltype(num_digits){0}; i < num_digits; ++i)\n        *out++ = digits[(n / base_power(num_digits - i)) % base];\n    \n    return out;\n}\n\n// Helper function to decode a run-length.\n// As of C++20, this can be constexpr, because std::find() is constexpr.\n// Before C++20, it can be constexpr by emulating std::find().\ntemplate <typename InputIterator>\nauto decode_run_length(InputIterator first, InputIterator last)\n{\n    auto count = std::size_t{0};\n    \n    while (first != last)\n    {\n        // If the next input character is not a digit, we're done.\n        auto const p = std::find(digits.begin(), digits.end(), *first);\n        if (p == digits.end())\n            break;\n        \n        // Convert the digit to a number, and append it to the size.\n        count *= digits.size();\n        count += std::distance(digits.begin(), p);\n        \n        // Move on to the next input character.\n        ++first;\n    }\n    \n    return std::tuple{count, first};\n}\n\n} // namespace detail_\n\ntemplate <typename InputIterator, typename OutputIterator>\nconstexpr auto encode(InputIterator first, InputIterator last, OutputIterator out)\n{\n    while (first != last)\n    {\n        // Read the next value.\n        auto const value = *first++;\n        \n        // Increase the count as long as the next value is the same.\n        auto count = std::size_t{1};\n        while (first != last && *first == value)\n        {\n            ++count;\n            ++first;\n        }\n        \n        // Write the value and its run length.\n        out = detail_::encode_run_length(count, out);\n        *out++ = value;\n    }\n    \n    return out;\n}\n\n// As of C++20, this can be constexpr, because std::find() and\n// std::fill_n() are constexpr (and decode_run_length() can be\n// constexpr, too).\n// Before C++20, it can be constexpr by emulating std::find() and\n// std::fill_n().\ntemplate <typename InputIterator, typename OutputIterator>\nauto decode(InputIterator first, InputIterator last, OutputIterator out)\n{\n    while (first != last)\n    {\n        using detail_::digits;\n        \n        // Assume a run-length of 1, then try to decode the actual\n        // run-length, if any.\n        auto count = std::size_t{1};\n        if (std::find(digits.begin(), digits.end(), *first) != digits.end())\n            std::tie(count, first) = detail_::decode_run_length(first, last);\n        \n        // Write the run.\n        out = std::fill_n(out, count, *first++);\n    }\n    \n    return out;\n}\n\ntemplate <typename Range, typename OutputIterator>\nconstexpr auto encode(Range&& range, OutputIterator out)\n{\n    using std::begin;\n    using std::end;\n    \n    return encode(begin(range), end(range), out);\n}\n\ntemplate <typename Range, typename OutputIterator>\nauto decode(Range&& range, OutputIterator out)\n{\n    using std::begin;\n    using std::end;\n    \n    return decode(begin(range), end(range), out);\n}\n\n// Sample application and checking ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~\n\n#include <iostream>\n#include <string_view>\n\nint main()\n{\n    using namespace std::literals;\n    \n    constexpr auto test_string = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"sv;\n    \n    std::cout << \"Input:  \\\"\" << test_string << \"\\\"\\n\";\n    std::cout << \"Output: \\\"\";\n    // No need for a temporary string - can encode directly to cout.\n    encode(test_string, std::ostreambuf_iterator<char>{std::cout});\n    std::cout << \"\\\"\\n\";\n    \n    auto encoded_str = std::string{};\n    auto decoded_str = std::string{};\n    encode(test_string, std::back_inserter(encoded_str));\n    decode(encoded_str, std::back_inserter(decoded_str));\n    \n    std::cout.setf(std::cout.boolalpha);\n    std::cout << \"Round trip works: \" << (test_string == decoded_str) << '\\n';\n}\n\nLibrary: boost\n#include <iostream>\n#include <string>\n#include <sstream>\n#include <boost/regex.hpp>\n#include <cstdlib>\n\nstd::string encode ( const std::string & ) ;\nstd::string decode ( const std::string & ) ;\n\nint main( ) {\n   std::string to_encode ( \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\" ) ;\n   std::cout << to_encode << \" encoded:\" << std::endl ;\n   std::string encoded ( encode ( to_encode ) ) ;\n   std::cout << encoded << std::endl ;\n   std::string decoded ( decode( encoded ) ) ;\n   std::cout << \"Decoded again:\\n\" ;\n   std::cout << decoded << std::endl ;\n   if ( to_encode == decoded ) \n      std::cout << \"It must have worked!\\n\" ;\n   return 0 ;\n}\n\nstd::string encode( const std::string & to_encode ) {\n   std::string::size_type found = 0 , nextfound = 0 ;\n   std::ostringstream oss ;\n   nextfound = to_encode.find_first_not_of( to_encode[ found ] , found ) ;\n   while ( nextfound != std::string::npos ) {\n      oss << nextfound - found ;\n      oss << to_encode[ found ] ;\n      found = nextfound ;\n      nextfound = to_encode.find_first_not_of( to_encode[ found ] , found ) ;\n   }\n   //since we must not discard the last characters we add them at the end of the string\n   std::string rest ( to_encode.substr( found ) ) ;//last run of characters starts at position found \n   oss << rest.length( ) << to_encode[ found ] ;\n   return oss.str( ) ;\n}\n\nstd::string decode ( const std::string & to_decode ) {\n   boost::regex e ( \"(\\\\d+)(\\\\w)\" ) ;\n   boost::match_results<std::string::const_iterator> matches ;\n   std::ostringstream oss ;\n   std::string::const_iterator start = to_decode.begin( ) , end = to_decode.end( ) ;\n   while ( boost::regex_search ( start , end , matches , e ) ) {\n      std::string numberstring ( matches[ 1 ].first , matches[ 1 ].second ) ;\n      int number = atoi( numberstring.c_str( ) ) ;\n      std::string character ( matches[ 2 ].first , matches[ 2 ].second ) ;\n      for ( int i = 0 ; i < number ; i++ ) \n\t oss << character ;\n      start = matches[ 2 ].second ;\n   }\n   return oss.str( ) ;\n}\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Java", "code": "\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nString encode(String string) {\n    Pattern pattern = Pattern.compile(\"(.)\\\\1*\");\n    Matcher matcher = pattern.matcher(string);\n    StringBuilder encoded = new StringBuilder();\n    while (matcher.find()) {\n        encoded.append(matcher.group().length());\n        encoded.append(matcher.group().charAt(0));\n    }\n    return encoded.toString();\n}\n\nString decode(String string) {\n    Pattern pattern = Pattern.compile(\"(\\\\d+)(.)\");\n    Matcher matcher = pattern.matcher(string);\n    StringBuilder decoded = new StringBuilder();\n    int count;\n    while (matcher.find()) {\n        count = Integer.parseInt(matcher.group(1));\n        decoded.append(matcher.group(2).repeat(count));\n    }\n    return decoded.toString();\n}\n\nstring = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nencoded = 12W1B12W3B24W1B14W\ndecoded = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nstring.equals(decoded) = true\n\nstring = https://www.rosettacode.org/\nencoded = 1h2t1p1s1:2/3w1.1r1o1s1e2t1a1c1o1d1e1.1o1r1g1/\ndecoded = https://www.rosettacode.org/\nstring.equals(decoded) = true\n\n\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\npublic class RunLengthEncoding {\n\n    public static String encode(String source) {\n        StringBuffer dest = new StringBuffer();\n        for (int i = 0; i < source.length(); i++) {\n            int runLength = 1;\n            while (i+1 < source.length() && source.charAt(i) == source.charAt(i+1)) {\n                runLength++;\n                i++;\n            }\n            dest.append(runLength);\n            dest.append(source.charAt(i));\n        }\n        return dest.toString();\n    }\n\n    public static String decode(String source) {\n        StringBuffer dest = new StringBuffer();\n        Pattern pattern = Pattern.compile(\"[0-9]+|[a-zA-Z]\");\n        Matcher matcher = pattern.matcher(source);\n        while (matcher.find()) {\n            int number = Integer.parseInt(matcher.group());\n            matcher.find();\n            while (number-- != 0) {\n                dest.append(matcher.group());\n            }\n        }\n        return dest.toString();\n    }\n\n    public static void main(String[] args) {\n        String example = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        System.out.println(encode(example));\n        System.out.println(decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n    }\n}\n\n\nLibrary: JUnit\nimport static org.junit.Assert.assertEquals;\n\nimport org.junit.Test;\n\npublic class RunLengthEncodingTest {\n\tprivate RLE = new RunLengthEncoding();\n\n\t@Test\n\tpublic void encodingTest() {\n\t\tassertEquals(\"1W\", RLE.encode(\"W\"));\n\t\tassertEquals(\"4W\", RLE.encode(\"WWWW\"));\n\t\tassertEquals(\"5w4i7k3i6p5e4d2i1a\",\n\t\t\t\tRLE.encode(\"wwwwwiiiikkkkkkkiiippppppeeeeeddddiia\"));\n\t\tassertEquals(\"12B1N12B3N24B1N14B\",\n\t\t\t\tRLE.encode(\"BBBBBBBBBBBBNBBBBBBBBBBBBNNNBBBBBBBBBBBBBBBBBBBBBBBBNBBBBBBBBBBBBBB\"));\n\t\tassertEquals(\"12W1B12W3B24W1B14W\",\n\t\t\t\tRLE.encode(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"));\n\t\tassertEquals(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\", RLE.encode(\"WBWBWBWBWBWBWB\"));\n\n\t}\n\n\t@Test\n\tpublic void decodingTest() {\n\t\tassertEquals(\"W\", RLE.decode(\"1W\"));\n\t\tassertEquals(\"WWWW\", RLE.decode(\"4W\"));\n\t\tassertEquals(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\",\n\t\t\t\tRLE.decode(\"12W1B12W3B24W1B14W\"));\n\t\tassertEquals(\"WBWBWBWBWBWBWB\", RLE.decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n\t\tassertEquals(\"WBWBWBWBWBWBWB\", RLE.decode(\"1W1B1W1B1W1B1W1B1W1B1W1B1W1B\"));\n\n\t}\n}\n\n", "explain": "This can be achieved using regular expression capturing\n\nAn alternate demonstration\nTests:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "C#", "code": "\nLinq[edit]\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Linq.Enumerable;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n          public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])))\n            .Select(p=> $\"{p.key}{p.chr}\")\n            .StringConcat();\n\n        public static string Decode(string input) => input\n            .Aggregate((t: \"\", o: Empty<string>()), (a, c) => !char.IsDigit(c) ? (\"\", a.o.Append(a.t+c)) : (a.t + c,a.o)).o \n            .Select(p => new string(p.Last(), int.Parse(string.Concat(p.Where(char.IsDigit)))))\n            .StringConcat();\n\n        private static string StringConcat(this IEnumerable<string> seq) => string.Concat(seq);\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n\n\nraw = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nencoded = 12W1B12W3B24W1B14W\nEncode(raw) = encoded = 12W1B12W3B24W1B14W\nDecode(encode) = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nDecode(Encode(raw)) = True\n\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n         public static string Encode(string input) => input.Length ==0 ? \"\" : input.Skip(1)\n            .Aggregate((t:input[0].ToString(),o:Empty<string>()),\n               (a,c)=>a.t[0]==c ? (a.t+c,a.o) : (c.ToString(),a.o.Append(a.t)),\n               a=>a.o.Append(a.t).Select(p => (key: p.Length, chr: p[0])));\n\n        public static string Decode(IEnumerable<(int i , char c)> input) =>\n            string.Concat(input.Select(t => new string(t.c, t.i)));\n\n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            var encoded = new[] { (12, 'W'), (1, 'B'), (12, 'W'), (3, 'B'), (24, 'W'), (1, 'B'), (14, 'W') };\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw).TupleListToString()}\");\n            WriteLine($\"Decode(encoded) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n        private static string TupleListToString(this IEnumerable<(int i, char c)> list) =>\n            string.Join(\",\", list.Select(t => $\"[{t.i},{t.c}]\"));\n    }\n}\n\n\nraw = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nEncode(raw) = encoded = [12,W],[1,B],[12,W],[3,B],[24,W],[1,B],[14,W]\nDecode(encoded) = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nDecode(Encode(raw)) = True\n\n\nusing System.Collections.Generic;\nusing System.Linq;\nusing static System.Console;\nusing static System.Text;\n\nnamespace RunLengthEncoding\n{\n    static class Program\n    {\n         public static string Encode(string input) => input.Length == 0 ? \"\" : input.Skip(1)\n          .Aggregate((len: 1, chr: input[0], sb: new StringBuilder()),\n             (a, c) => a.chr == c ? (a.len + 1, a.chr, a.sb) \n                                  : (1, c, a.sb.Append(a.len).Append(a.chr))),\n             a => a.sb.Append(a.len).Append(a.chr)))\n          .ToString();\n\n         public static string Decode(string input) => input\n           .Aggregate((t: \"\", sb: new StringBuilder()),\n             (a, c) => !char.IsDigit(c) ? (\"\", a.sb.Append(new string(c, int.Parse(a.t)))) \n                                        : (a.t + c, a.sb))\n           .sb.ToString();\n        \n        public static void Main(string[] args)\n        {\n            const string  raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n            const string encoded = \"12W1B12W3B24W1B14W\";\n\n            WriteLine($\"raw = {raw}\");\n            WriteLine($\"encoded = {encoded}\");\n            WriteLine($\"Encode(raw) = encoded = {Encode(raw)}\");\n            WriteLine($\"Decode(encode) = {Decode(encoded)}\");\n            WriteLine($\"Decode(Encode(raw)) = {Decode(Encode(raw)) == raw}\");\n            ReadLine();\n        }\n    }\n}\n\n\nraw = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nencoded = 12W1B12W3B24W1B14W\nEncode(raw) = encoded = 12W1B12W3B24W1B14W\nDecode(encode) = WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nDecode(Encode(raw)) = True\n\nImperative[edit]\n\n       public static void Main(string[] args)\n       {\n           string input = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n           Console.WriteLine(Encode(input));//Outputs: 12W1B12W3B24W1B14W\n           Console.WriteLine(Decode(Encode(input)));//Outputs: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n           Console.ReadLine();\n       }\n       public static string Encode(string s)\n       {\n           StringBuilder sb = new StringBuilder();\n           int count = 1;\n           char current =s[0];\n           for(int i = 1; i < s.Length;i++)\n           {\n               if (current == s[i])\n               {\n                   count++;\n               }\n               else\n               {\n                   sb.AppendFormat(\"{0}{1}\", count, current);\n                   count = 1;\n                   current = s[i];\n               }\n           }\n           sb.AppendFormat(\"{0}{1}\", count, current);\n           return sb.ToString();\n       }\n       public static string Decode(string s)\n       {\n           string a = \"\";\n           int count = 0;\n           StringBuilder sb = new StringBuilder();\n           char current = char.MinValue;\n           for(int i = 0; i < s.Length; i++)\n           {\n               current = s[i];\n               if (char.IsDigit(current))\n                   a += current;\n               else\n               {\n                   count = int.Parse(a);\n                   a = \"\";\n                   for (int j = 0; j < count; j++)\n                       sb.Append(current);\n               }\n           }\n           return sb.ToString();\n       }\n\nRegEx[edit]\n\nusing System;\nusing System.Text.RegularExpressions;\n\npublic class Program\n{\n    private delegate void fOk(bool ok, string message);\n\n    public static int Main(string[] args)\n    {\n        const string raw = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n        const string code = \"12W1B12W3B24W1B14W\";\n\n        fOk Ok = delegate(bool ok, string message)\n        {\n            Console.WriteLine(\"{0}: {1}\", ok ? \"ok\" : \"not ok\", message);\n        };\n        Ok(code.Equals(Encode(raw)), \"Encode\");\n        Ok(raw.Equals(Decode(code)), \"Decode\");\n        return 0;\n    }\n\n    public static string Encode(string input)\n    {\n        return Regex.Replace(input, @\"(.)\\1*\", delegate(Match m)\n        {\n            return string.Concat(m.Value.Length, m.Groups[1].Value);\n        });\n    }\n\n    public static string Decode(string input)\n    {\n        return Regex.Replace(input, @\"(\\d+)(\\D)\", delegate(Match m)\n        {\n            return new string(m.Groups[2].Value[0], int.Parse(m.Groups[1].Value));\n        });\n    }\n}\n\n", "explain": "Output:\nMany solutions do not follow the suggested output guideline in the challenge (not helped by its wording), instead producing a list of tuples or equivalent. This is much simpler (especially for decode) and the following provides an equivalent of those (IMHO deficient) solutions, to make comparisons easier.\nOutput:\nStringbuilder version. Might be more performant but mixes output formatting with encoding/decoding logic. \nOutput:\nThis example only works if there are no digits in the string to be encoded and then decoded.\nSomewhat shorter, using Regex.Replace with MatchEvaluator (using C#2 syntax only):\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "JavaScript", "code": "\nES5[edit]\n\nfunction encode(input) {\n    var encoding = [];\n    var prev, count, i;\n    for (count = 1, prev = input[0], i = 1; i < input.length; i++) {\n        if (input[i] != prev) {\n            encoding.push([count, prev]);\n            count = 1;\n            prev = input[i];\n        }\n        else \n            count ++;\n    }\n    encoding.push([count, prev]);\n    return encoding;\n}\n\nHere's an encoding method that uses a regular expression to grab the character runs (Works with: JavaScript version 1.6 for the forEach method)\nfunction encode_re(input) {\n    var encoding = [];\n    input.match(/(.)\\1*/g).forEach(function(substr){ encoding.push([substr.length, substr[0]]) });\n    return encoding;\n}\n\n\nfunction decode(encoded) {\n    var output = \"\";\n    encoded.forEach(function(pair){ output += new Array(1+pair[0]).join(pair[1]) })\n    return output;\n}\n\nES6[edit]\n\n(() => {\n    'use strict';\n\n    // runLengthEncode\u00a0:: String -> [(Int, Char)]\n    const runLengthEncoded = s =>\n        group(s.split('')).map(\n            cs => [cs.length, cs[0]]\n        );\n\n    // runLengthDecoded\u00a0:: [(Int, Char)] -> String\n    const runLengthDecoded = pairs =>\n        pairs.map(([n, c]) => c.repeat(n)).join('');\n\n\n    // ------------------------TEST------------------------\n    const main = () => {\n        const\n            xs = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWW' +\n            'WWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW',\n            ys = runLengthEncoded(xs);\n\n        console.log('From: ', show(xs));\n        [ys, runLengthDecoded(ys)].forEach(\n            x => console.log('  ->  ', show(x))\n        )\n    };\n\n    // ----------------------GENERIC-----------------------\n\n    // group\u00a0:: [a] -> [[a]]\n    const group = xs => {\n        // A list of lists, each containing only equal elements,\n        // such that the concatenation of these lists is xs.\n        const go = xs =>\n            0 < xs.length ? (() => {\n                const\n                    h = xs[0],\n                    i = xs.findIndex(x => h !== x);\n                return i !== -1 ? (\n                    [xs.slice(0, i)].concat(go(xs.slice(i)))\n                ) : [xs];\n            })() : [];\n        return go(xs);\n    };\n\n    // show\u00a0:: a -> String\n    const show = JSON.stringify;\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\nFrom:  \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n  ->   [[12,\"W\"],[1,\"B\"],[12,\"W\"],[3,\"B\"],[24,\"W\"],[1,\"B\"],[14,\"W\"]]\n  ->   \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n\n \nconst rlEncode = (s: string) => s.match(/(.)\\1*/g).reduce((result,char) => result+char.length+char[0],\"\")\nconst rlValidate = (s: string) => /^(\\d+\\D)+$/.test(s)\nconst rlDecode = (s: string) => rlValidate(s) ? s.match(/(\\d[a-z\\s])\\1*/ig).reduce((res,p) => res+p[p.length-1].repeat(parseInt(p)),\"\") : Error(\"Invalid rl\")\n\n", "explain": "Here's an encoding method that walks the input string character by character\nAnd to decode (see Repeating a string)\nBy defining a generic group function:\nA .reduce() based one-liner\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "SQL", "code": "\nWorks with: PL/pgSQL\n\nRLE encoding\n-- variable table\ndrop table if exists var;\ncreate temp table var (\tvalue varchar(1000) );\ninsert into var(value) select 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW';\n\n-- select\nwith recursive\nints(num) as \n(\n\tselect 1\n\tunion all\n\tselect num+1\n\tfrom ints\n\twhere num+1 <= length((select value from var))\n)\n,\nchars(num,chr,nextChr,isGroupEnd) as\n(\n\tselect tmp.*, case when tmp.nextChr <> tmp.chr then 1 else 0 end groupEnds\n\tfrom (\n\tselect num, \n\t\t   substring((select value from var), num, 1) chr,\n\t\t   (select substring((select value from var), num+1, 1)) nextChr\n\tfrom ints\n\t) tmp\n)\nselect (select value from var) plain_text, (\n\tselect string_agg(concat(cast(maxNoWithinGroup as varchar(10)) , chr), '' order by num)\n\tfrom (\n\t\tselect *, max(noWithinGroup) over (partition by chr, groupNo) maxNoWithinGroup\n\t\tfrom (\n\t\t\tselect\tnum, \n\t\t\t\t\tchr, \n\t\t\t\t\tgroupNo, \n\t\t\t\t\trow_number() over( partition by chr, groupNo order by num) noWithinGroup\n\t\t\tfrom (\n\t\t\tselect *, (select count(*) \n\t\t\t\t\t   from chars chars2 \n\t\t\t\t\t   where chars2.isGroupEnd = 1 and \n\t\t\t\t\t   chars2.chr = chars.chr and \n\t\t\t\t\t   chars2.num < chars.num) groupNo \n\t\t\tfrom chars\n\t\t\t) tmp\n\t\t) sub\n\t) final\n\twhere noWithinGroup = 1\n\t) Rle_Compressed\nRLE decoding\n-- variable table\nDROP TABLE IF EXISTS var;\nCREATE temp TABLE var (\tVALUE VARCHAR(1000) );\nINSERT INTO var(VALUE) SELECT '1A2B3C4D5E6F';\n\n-- select\nWITH recursive\nints(num) AS \n(\n\tSELECT 1\n\tUNION ALL\n\tSELECT num+1\n\tFROM ints\n\tWHERE num+1 <= LENGTH((SELECT VALUE FROM var))\n)\n,\nchars(num,chr,nextChr) AS\n(\n\tSELECT tmp.*\n\tFROM (\n\tSELECT num, \n\t\tSUBSTRING((SELECT VALUE FROM var), num, 1) chr,\n\t\t(SELECT SUBSTRING((SELECT VALUE FROM var), num+1, 1)) nextChr\n\tFROM ints\n\t) tmp\n)\n,\ncharsWithGroup(num,chr,nextChr,group_no) AS\n(\n\tSELECT *,(SELECT COUNT(*) \n\t\tFROM chars chars2 \n\t\tWHERE chars2.chr\u00a0!~ '[0-9]' AND \n\t\tchars2.num < chars.num) group_No\n\tFROM chars\n)\n,\ncharsWithGroupAndLetter(num,chr,nextChr,group_no,group_letter) AS\n(\n\tSELECT *,(SELECT chr \n\t\tFROM charsWithGroup g2 \n\t\twhere g2.group_no = charsWithGroup.group_no \n\t\tORDER BY num DESC \n\t\tLIMIT 1)\n\tFROM charsWithGroup\n)\n,\nlettersWithCount(group_no,amount,group_letter) AS\n(\n\tSELECT group_no, string_agg(chr, '' ORDER BY num), group_letter\n\tFROM charsWithGroupAndLetter\n\tWHERE chr ~ '[0-9]'\n\tGROUP BY group_no, group_letter\n)\n,\nlettersReplicated(group_no,amount,group_letter, replicated_Letter) AS\n(\n\tSELECT *, rpad(group_letter, cast(amount as int), group_letter) \n\tFROM lettersWithCount\n)\nselect (SELECT value FROM var) rle_encoded, \n\tstring_agg(replicated_Letter, '' ORDER BY group_no) decoded_string \nFROM lettersReplicated\n", "explain": "\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "PHP", "code": "\n<?php\nfunction encode($str)\n{\n    return preg_replace_callback('/(.)\\1*/', function ($match) {\n        return strlen($match[0]) . $match[1];\n    }, $str);\n}\n\nfunction decode($str)\n{\n    return preg_replace_callback('/(\\d+)(\\D)/', function($match) {\n        return str_repeat($match[2], $match[1]);\n    }, $str);\n}\n\necho encode('WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'), PHP_EOL;\necho decode('12W1B12W3B24W1B14W'), PHP_EOL;\n?>\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Fortran", "code": "\nWorks with: Fortran version 95 and later\nprogram RLE\n  implicit none\n\n  integer, parameter :: bufsize = 100   ! Sets maximum size of coded and decoded strings, adjust as necessary\n  character(bufsize) :: teststr = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n  character(bufsize) :: codedstr = \"\", decodedstr = \"\"\n    \n  call Encode(teststr, codedstr)\n  write(*,\"(a)\") trim(codedstr)\n  call Decode(codedstr, decodedstr)\n  write(*,\"(a)\") trim(decodedstr)\n\ncontains\n\nsubroutine Encode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(8) :: tempstr = \"\"\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: a, b, c, i\n\n  if(verify(trim(instr), validchars) /= 0) then\n    outstr = \"Invalid input\"\n    return\n  end if\n  outstr = \"\"\n  c = 1\n  a = iachar(instr(1:1))\n  do i = 2, len(trim(instr))\n    b = iachar(instr(i:i))\n    if(a == b) then\n      c = c + 1\n    else\n      write(tempstr, \"(i0)\") c\n      outstr = trim(outstr) // trim(tempstr) // achar(a)\n      a = b\n      c = 1\n    end if\n  end do\n  write(tempstr, \"(i0)\") c\n  outstr = trim(outstr) // trim(tempstr) // achar(b)\nend subroutine\n\nsubroutine Decode(instr, outstr)\n  character(*), intent(in)  :: instr\n  character(*), intent(out) :: outstr\n  character(26) :: validchars = \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n  integer :: startn, endn, n\n\n  outstr = \"\"\n  startn = 1\n  do while(startn < len(trim(instr)))\n    endn = scan(instr(startn:), validchars) + startn - 1\n    read(instr(startn:endn-1), \"(i8)\") n\n    outstr = trim(outstr) // repeat(instr(endn:endn), n)\n    startn = endn + 1\n  end do\nend subroutine\nend program\n\n\n12W1B12W3B24W1B14W\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": "Output:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\n// encoding scheme:\n// encode to byte array\n// byte value < 26 means single character: byte value + 'A'\n// byte value 26..255 means (byte value - 24) copies of next byte\nfunc rllEncode(s string) (r []byte) {\n    if s == \"\" {\n        return\n    }\n    c := s[0]\n    if c < 'A' || c > 'Z' {\n        panic(\"invalid\")\n    }\n    nc := byte(1)\n    for i := 1; i < len(s); i++ {\n        d := s[i]\n        switch {\n        case d != c:\n        case nc < (255 - 24):\n            nc++\n            continue\n        }\n        if nc > 1 {\n            r = append(r, nc+24)\n        }\n        r = append(r, c-'A')\n        if d < 'A' || d > 'Z' {\n            panic(\"invalid\")\n        }\n        c = d\n        nc = 1\n    }\n    if nc > 1 {\n        r = append(r, nc+24)\n    }\n    r = append(r, c-'A')\n    return\n}\n\nfunc main() {\n    s := \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n    fmt.Println(\"source: \", len(s), \"bytes:\", s)\n    e := rllEncode(s)\n    fmt.Println(\"encoded:\", len(e), \"bytes:\", e)\n    d := rllDecode(e)\n    fmt.Println(\"decoded:\", len(d), \"bytes:\", d)\n    fmt.Println(\"decoded = source:\", d == s)\n}\n\nfunc rllDecode(e []byte) string {\n    var c byte\n    var d []byte\n    for i := 0; i < len(e); i++ {\n        b := e[i]\n        if b < 26 {\n            c = 1\n        } else {\n            c = b - 24\n            i++\n            b = e[i]\n        }\n        for c > 0 {\n            d = append(d, b+'A')\n            c--\n        }\n    }\n    return string(d)\n}\n\n\nsource:  67 bytes: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nencoded: 12 bytes: [36 22 1 36 22 27 1 48 22 1 38 22]\ndecoded: 67 bytes: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\ndecoded = source: true\n\n", "explain": "Decoder kind of necessary to demonstrate task requirement that I can recreate the input.\nOutput:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nprogram RunLengthTest;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\ntype\n  TRLEPair = record\n    count: Integer;\n    letter: Char;\n  end;\n\n  TRLEncoded = TArray<TRLEPair>;\n\n  TRLEncodedHelper = record helper for TRLEncoded\n  public\n    procedure Clear;\n    function Add(c: Char): Integer;\n    procedure Encode(Data: string);\n    function Decode: string;\n    function ToString: string;\n  end;\n\n{ TRLEncodedHelper }\n\nfunction TRLEncodedHelper.Add(c: Char): Integer;\nbegin\n  SetLength(self, length(self) + 1);\n  Result := length(self) - 1;\n  with self[Result] do\n  begin\n    count := 1;\n    letter := c;\n  end;\nend;\n\nprocedure TRLEncodedHelper.Clear;\nbegin\n  SetLength(self, 0);\nend;\n\nfunction TRLEncodedHelper.Decode: string;\nvar\n  p: TRLEPair;\nbegin\n  Result := '';\n  for p in Self do\n    Result := Result + string.Create(p.letter, p.count);\nend;\n\nprocedure TRLEncodedHelper.Encode(Data: string);\nvar\n  pivot: Char;\n  i, index: Integer;\nbegin\n  Clear;\n  if Data.Length = 0 then\n    exit;\n\n  pivot := Data[1];\n  index := Add(pivot);\n\n  for i := 2 to Data.Length do\n  begin\n    if pivot = Data[i] then\n      inc(self[index].count)\n    else\n    begin\n      pivot := Data[i];\n      index := Add(pivot);\n    end;\n  end;\nend;\n\nfunction TRLEncodedHelper.ToString: string;\nvar\n  p: TRLEPair;\nbegin\n  Result := '';\n  for p in Self do\n    Result := Result + p.count.ToString + p.letter;\nend;\n\nconst\n  Input = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW';\n\nvar\n  Data: TRLEncoded;\n\nbegin\n  Data.Encode(Input);\n  Writeln(Data.ToString);\n  writeln(Data.Decode);\n  Readln;\nend.\n\n\nOutput:\n12W1B12W3B24W1B14W\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Ruby", "code": "\n\n# run_encode(\"aaabbbbc\") #=> [[\"a\", 3], [\"b\", 4], [\"c\", 1]]\ndef run_encode(string)\n  string\n    .chars\n    .chunk{|i| i}\n    .map {|kind, array| [kind, array.length]}\nend\n\n# run_decode([[\"a\", 3], [\"b\", 4], [\"c\", 1]]) #=> \"aaabbbbc\"\ndef run_decode(char_counts)\n  char_counts\n    .map{|char, count| char * count}\n    .join\nend\ndef encode(string)\n  string.scan(/(.)(\\1*)/).collect do |char, repeat|\n    [1 + repeat.length, char] \n  end.join\nend\n\ndef decode(string)\n  string.scan(/(\\d+)(\\D)/).collect {|length, char| char * length.to_i}.join\nend\n\ndef encode(string)\n  string.scan(/(.)(\\1*)/).inject(\"\") do |encoding, (char, repeat)|\n    encoding << (1 + repeat.length).to_s << char\n  end\nend\n\ndef decode(string)\n  string.scan(/(\\d+)(\\D)/).inject(\"\") do |decoding, (length, char)|\n    decoding << char * length.to_i\n  end\nend\n\ndef encode(str)\n    str.gsub(/(.)\\1*/) {$&.length.to_s + $1}\nend\n\ndef decode(str)\n    str.gsub(/(\\d+)(\\D)/) {$2 * $1.to_i}\nend\n\norig = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\np enc = encode(orig)\np dec = decode(enc)\nputs \"success!\" if dec == orig\n\nOutput:\n\"12W1B12W3B24W1B14W\"\n\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nsuccess!\n\n", "explain": "Built-in\nRuby has built-in run-length encoding in the form of chunk, here I provide a thin wrapper around it:\nThis usage also seems to be idiomatic, and perhaps less cryptic:\nBy regular expression\nThe simplified input range of only uppercase characters allows a simple regular expression to be applied repeatedly for encoding, and another for decoding:\nTest:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Rust", "code": "\nfn encode(s: &str) -> String {\n    s.chars()\n        // wrap all values in Option::Some\n        .map(Some)\n        // add an Option::None onto the iterator to clean the pipeline at the end\n        .chain(std::iter::once(None))\n        .scan((0usize, '\\0'), |(n, c), elem| match elem {\n            Some(elem) if *n == 0 || *c == elem => {\n                // the run continues or starts here\n                *n += 1;\n                *c = elem;\n                // this will not have an effect on the final string because it is empty\n                Some(String::new())\n            }\n            Some(elem) => {\n                // the run ends here\n                let run = format!(\"{}{}\", n, c);\n                *n = 1;\n                *c = elem;\n                Some(run)\n            }\n            None => {\n                // the string ends here\n                Some(format!(\"{}{}\", n, c))\n            }\n        })\n        // concatenate together all subresults\n        .collect()\n}\n\nfn decode(s: &str) -> String {\n    s.chars()\n        .fold((0usize, String::new()), |(n, text), c| {\n            if c.is_ascii_digit() {\n                // some simple number parsing\n                (\n                    n * 10 + c.to_digit(10).expect(\"invalid encoding\") as usize,\n                    text,\n                )\n            } else {\n                // this must be the character that is repeated\n                (0, text + &format!(\"{}\", c.to_string().repeat(n)))\n            }\n        })\n        .1\n}\n\nfn main() {\n    let text = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n    let encoded = encode(text);\n    let decoded = decode(&encoded);\n\n    println!(\"original: {}\\n encoded: {}\\n decoded: {}\", text, encoded, decoded);\n    assert_eq!(text, decoded);\n}\n\nOutput:\noriginal: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n encoded: 12W1B12W3B24W1B14W\n decoded: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Swift", "code": "\n\nimport Foundation\n\n// \"WWWBWW\" -> [(3, W), (1, B), (2, W)]\nfunc encode(input: String) -> [(Int, Character)] {\n    return input.characters.reduce([(Int, Character)]()) {\n        if $0.last?.1 == $1 { var r = $0; r[r.count - 1].0++; return r }\n        return $0 + [(1, $1)]\n    }\n}\n\n// [(3, W), (1, B), (2, W)] -> \"WWWBWW\"\nfunc decode(encoded: [(Int, Character)]) -> String {\n    return encoded.reduce(\"\") { $0 + String(count: $1.0, repeatedValue: $1.1) }\n}\n\nlet input = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nlet output = decode(encode(input))\nprint(output == input)\n\nOutput:\ntrue\n\n// \"3W1B2W\" -> \"WWWBWW\"\nfunc decode(encoded: String) -> String {\n    let scanner = NSScanner(string: encoded)\n    var char: NSString? = nil\n    var count: Int = 0\n    var out = \"\"\n\n    while scanner.scanInteger(&count) {\n        while scanner.scanCharactersFromSet(NSCharacterSet.letterCharacterSet(), intoString: &char) {\n            out += String(count: count, repeatedValue: Character(char as! String))\n        }\n    }\n\n    return out\n}\nlet encodedString = encode(input).reduce(\"\") { $0 + \"\\($1.0)\\($1.1)\" }\nprint(encodedString)\nlet outputString = decode(encodedString)\nprint(outputString == input)\n\nOutput:\n12W1B12W3B24W1B14W\ntrue\n\n", "explain": "Using array as the internal representation of the encoded input:\nUsage:\nConverting encoded array into the string and then decoding it using NSScanner:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "R", "code": "\n\nrunlengthencoding <- function(x)\n{\n   splitx <- unlist(strsplit(input, \"\"))\n   rlex <- rle(splitx)\n   paste(with(rlex, as.vector(rbind(lengths, values))), collapse=\"\")\n}\n\ninput <- \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\nrunlengthencoding(input)\n\ninverserunlengthencoding <- function(x)\n{\n    lengths <- as.numeric(unlist(strsplit(output, \"[[:alpha:]]\")))\n    values <- unlist(strsplit(output, \"[[:digit:]]\"))\n    values <- values[values\u00a0!= \"\"]\n    uncompressed <- inverse.rle(list(lengths=lengths, values=values))\n    paste(uncompressed, collapse=\"\")\n}\n\noutput <- \"12W1B12W3B24W1B14W\"\ninverserunlengthencoding(output)\n", "explain": "R has a built-in function, rle, for run length encoding.  This modification allows input and output in the forms specified above.\nSimilarly, inverse.rle provides decompression after a run length encoding.\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "COBOL", "code": "\nWorks with: GNU Cobol version 2.0\n       >>SOURCE FREE\nIDENTIFICATION DIVISION.\nPROGRAM-ID. run-length-encoding.\n\nENVIRONMENT DIVISION.\nCONFIGURATION SECTION.\nREPOSITORY.\n    FUNCTION encode\n    FUNCTION decode\n    .\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  input-str                           PIC A(100).\n01  encoded                             PIC X(200).\n01  decoded                             PIC X(200).\n\nPROCEDURE DIVISION.\n    ACCEPT input-str\n    MOVE encode(FUNCTION TRIM(input-str)) TO encoded\n    DISPLAY \"Encoded: \" FUNCTION TRIM(encoded)\n    DISPLAY \"Decoded: \" FUNCTION TRIM(decode(encoded))\n    .\nEND PROGRAM run-length-encoding.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. encode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  str-len                             PIC 9(3) COMP.\n\n01  i                                   PIC 9(3) COMP.\n\n01  current-char                        PIC A.\n\n01  num-chars                           PIC 9(3) COMP.\n01  num-chars-disp                      PIC Z(3).\n\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n\nLINKAGE SECTION.\n01  str                                 PIC X ANY LENGTH.\n\n01  encoded                             PIC X(200).\n\nPROCEDURE DIVISION USING str RETURNING encoded.\n    MOVE FUNCTION LENGTH(str) TO str-len\n    MOVE str (1:1) TO current-char\n    MOVE 1 TO num-chars\n    PERFORM VARYING i FROM 2 BY 1 UNTIL i > str-len\n        IF str (i:1) <> current-char\n            CALL \"add-num-chars\" USING encoded, encoded-pos,\n                CONTENT current-char, num-chars\n                \n            MOVE str (i:1) TO current-char\n            MOVE 1 TO num-chars\n        ELSE\n            ADD 1 TO num-chars\n        END-IF\n    END-PERFORM\n\n    CALL \"add-num-chars\" USING encoded, encoded-pos, CONTENT current-char,\n        num-chars\n    .\nEND FUNCTION encode.\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. add-num-chars.\n\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  num-chars-disp                      PIC Z(3).\n\nLINKAGE SECTION.\n01  str                                 PIC X(200).\n\n01  current-pos                         PIC 9(3) COMP.\n\n01  char-to-encode                      PIC X.\n\n01  num-chars                           PIC 9(3) COMP.\n\nPROCEDURE DIVISION USING str, current-pos, char-to-encode, num-chars.\n    MOVE num-chars TO num-chars-disp\n    MOVE FUNCTION TRIM(num-chars-disp) TO str (current-pos:3)\n    ADD FUNCTION LENGTH(FUNCTION TRIM(num-chars-disp)) TO current-pos\n    MOVE char-to-encode TO str (current-pos:1)\n    ADD 1 TO current-pos\n    .\nEND PROGRAM add-num-chars.\n\n\nIDENTIFICATION DIVISION.\nFUNCTION-ID. decode.\n\nDATA DIVISION.\nLOCAL-STORAGE SECTION.\n01  encoded-pos                         PIC 9(3) COMP VALUE 1.\n01  decoded-pos                         PIC 9(3) COMP VALUE 1.\n\n01  num-of-char                         PIC 9(3) COMP VALUE 0.\n\nLINKAGE SECTION.\n01  encoded                             PIC X(200).\n\n01  decoded                             PIC X(100).\n\nPROCEDURE DIVISION USING encoded RETURNING decoded.\n    PERFORM VARYING encoded-pos FROM 1 BY 1\n            UNTIL encoded (encoded-pos:2) = SPACES OR encoded-pos > 200\n        IF encoded (encoded-pos:1) IS NUMERIC\n            COMPUTE num-of-char = num-of-char * 10\n                + FUNCTION NUMVAL(encoded (encoded-pos:1))\n        ELSE\n            PERFORM UNTIL num-of-char = 0\n                MOVE encoded (encoded-pos:1) TO decoded (decoded-pos:1)\n                ADD 1 TO decoded-pos\n                SUBTRACT 1 FROM num-of-char\n            END-PERFORM\n        END-IF\n    END-PERFORM\n    .\nEND FUNCTION decode.\n\n\nOutput:\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nEncoded: 12W1B12W3B24W1B14W\nDecoded: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Ada", "code": "\nwith Ada.Text_IO;        use Ada.Text_IO;\nwith Ada.Strings.Fixed;  use Ada.Strings.Fixed;\nprocedure Test_Run_Length_Encoding is\n   function Encode (Data : String) return String is\n   begin\n      if Data'Length = 0 then\n         return \"\";\n      else\n         declare\n            Code  : constant Character := Data (Data'First);\n            Index : Integer := Data'First + 1;\n         begin\n            while Index <= Data'Last and then Code = Data (Index) loop\n               Index := Index + 1;\n            end loop;\n            declare\n               Prefix : constant String := Integer'Image (Index - Data'First);\n            begin\n               return Prefix (2..Prefix'Last) & Code & Encode (Data (Index..Data'Last));\n            end;\n         end;\n      end if;\n   end Encode;\n   function Decode (Data : String) return String is\n   begin\n      if Data'Length = 0 then\n         return \"\";\n      else\n         declare\n            Index : Integer := Data'First;\n            Count : Natural := 0;\n         begin\n            while Index < Data'Last and then Data (Index) in '0'..'9' loop\n               Count := Count * 10 + Character'Pos (Data (Index)) - Character'Pos ('0');\n               Index := Index + 1;\n            end loop;\n            if Index > Data'First then\n               return Count * Data (Index) & Decode (Data (Index + 1..Data'Last));\n            else\n               return Data;\n            end if;\n         end;\n      end if;\n   end Decode;\nbegin\n   Put_Line (Encode (\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"));\n   Put_Line (Decode (\"12W1B12W3B24W1B14W\"));\nend Test_Run_Length_Encoding;\n\n\n12W1B12W3B24W1B14W\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": "Sample output:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nusing IterTools\n\nencode(str::String) = collect((length(g), first(g)) for g in groupby(first, str))\ndecode(cod::Vector) = join(repeat(\"$l\", n) for (n, l) in cod)\n\nfor original in [\"aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\", \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"]\n    encoded = encode(original)\n    decoded = decode(encoded)\n    println(\"Original: $original\\n -> encoded: $encoded\\n -> decoded: $decoded\")\nend\n\n\nOutput:\nOriginal: aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\n -> encoded: Tuple{Int64,Char}[(5, 'a'), (6, 'h'), (7, 'm'), (1, 'u'), (7, 'i'), (6, 'a')]\n -> decoded: aaaaahhhhhhmmmmmmmuiiiiiiiaaaaaa\nOriginal: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n -> encoded: Tuple{Int64,Char}[(12, 'W'), (1, 'B'), (12, 'W'), (3, 'B'), (24, 'W'), (1, 'B'), (14, 'W')]\n -> decoded: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Kotlin", "code": "\n\ntailrec fun runLengthEncoding(text:String,prev:String=\"\"):String {\n    if (text.isEmpty()){\n        return prev\n    }\n    val initialChar = text.get(0)\n    val count = text.takeWhile{ it==initialChar }.count()\n    return runLengthEncoding(text.substring(count),prev + \"$count$initialChar\" )\n}\n\nfun main(args: Array<String>) {\n    assert(runLengthEncoding(\"TTESSST\") == \"2T1E3S1T\")\n    assert(runLengthEncoding(\"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\")\n                   == \"12W1B12W3B24W1B14W\")\n}\n\n", "explain": "Tail recursive implementation of Run Length Encoding\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Perl", "code": "\n\nsub encode {\n    shift =~ s/(.)\\1*/length($&).$1/grse;\n}\n\nsub decode {\n    shift =~ s/(\\d+)(.)/$2 x $1/grse;\n}\n\n\nsub encode {\n    shift =~ s/(.)\\1{0,254}/pack(\"C\", length($&)).$1/grse;\n}\n\nsub decode {\n    shift =~ s/(.)(.)/$2 x unpack(\"C\", $1)/grse;\n}\n\n\nsub encode {\n    my $str = shift;\n    my $ret = \"\";\n    my $nonrep = \"\";\n    while ($str =~ m/(.)\\1{0,127}|\\z/gs) {\n        my $len = length($&);\n        if (length($nonrep) && (length($nonrep) == 127 || $len != 1)) {\n            $ret .= pack(\"C\", 128 + length($nonrep)) . $nonrep;\n            $nonrep = \"\";\n        }\n        if    ($len == 1) { $nonrep .= $1 }\n        elsif ($len > 1)  { $ret .= pack(\"C\", $len) . $1 }\n    }\n    return $ret;\n}\n\nsub decode {\n    my $str = shift;\n    my $ret = \"\";\n    for (my $i = 0; $i < length($str);) {\n        my $len = unpack(\"C\", substr($str, $i, 1));\n        if ($len <= 128) {\n            $ret .= substr($str, $i + 1, 1) x $len;\n            $i += 2;\n        }\n        else {\n            $ret .= substr($str, $i + 1, $len - 128);\n            $i += 1 + $len - 128;\n        }\n    }\n    return $ret;\n}\n\n\nuse Data::Dump qw(dd);\ndd my $str = \"XXXXXABCDEFGHIoooooooooooooooooooooooooAAAAAA\";\ndd my $enc = encode($str);\ndd decode($enc);\n\n\nOutput:\n\"XXXXXABCDEFGHIoooooooooooooooooooooooooAAAAAA\"\n\"\\5X\\x89ABCDEFGHI\\31o\\6A\"\n\"XXXXXABCDEFGHIoooooooooooooooooooooooooAAAAAA\"\n\n", "explain": "Simple version using ASCII numerals as length markers, like the example in the task description (won't work correctly on input strings that already contain digits):\nModified version that can take arbitrary byte strings as input (produces encoded byte strings that are compatible with the C solution):\nFurther modified version that supports compact representation of longer non-repeating substrings, just like the C solution (so should be fully compatible with that solution for both encoding and decoding):\nDemonstration of the third version:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Objective-C", "code": "\n\n", "explain": "See Run-length encoding/Objective-C\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Prolog", "code": "\n\n% the test\nrun_length :-\n\tL = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\",\n\twritef('encode %s\\n', [L]),\n\tencode(L, R),\n\twriteln(R), nl,\n\twritef('decode %w\\n', [R]),\n\tdecode(R, L1),\n\twriteln(L1).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  encode\n%  \n%  translation\n%  from\n%  \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n%  to\n%  \"12W1B12W3B24W1B14W\"\n%  \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\nencode(In, Out) :-\n\t% Because of the special management of the \"strings\" by Prolog\n\t( is_list(In) -> I = In; string_to_list(In, I)),\n\tpackList(I, R1),\n\tdcg_packList2List(R1,R2, []),\n\tstring_to_list(Out,R2).\n\n\n\ndcg_packList2List([[N, V]|T]) -->\n\t{ number_codes(N, LN)},\n\tLN,\n\t[V],\n\tdcg_packList2List(T).\n\ndcg_packList2List([]) --> [].\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%  decode\n%  \n%  translation\n%  from\n%  \"12W1B12W3B24W1B14W\"\n%  to\n%  \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n%  \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\ndecode(In, Out) :-\n\t% Because of the special management of the \"strings\" by Prolog\n\t( is_list(In) -> I = In; string_to_list(In, I)),\n\tdcg_List2packList(I, R1, []),\n\tpackList(L1, R1),\n\tstring_to_list(Out, L1).\n\n\ndcg_List2packList([H|T]) -->\n\t{code_type(H, digit)},\n\tparse_number([H|T], 0).\n\ndcg_List2packList([]) --> [].\n\n\nparse_number([H|T], N) -->\n\t{code_type(H, digit), !,\n\tN1 is N*10 + H - 48 },\n\tparse_number(T, N1).\n\nparse_number([H|T], N) -->\n\t[[N, H]],\n\tdcg_List2packList(T).\n\n\n% use of library clpfd allows packList(?In, ?Out) to works\n% in both ways In --> Out and In <-- Out.\n\n:- use_module(library(clpfd)).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\n%\u00a0?- packList([a,a,a,b,c,c,c,d,d,e], L).\n%  L = [[3,a],[1,b],[3,c],[2,d],[1,e]] .\n%\u00a0?- packList(R,  [[3,a],[1,b],[3,c],[2,d],[1,e]]).\n% R = [a,a,a,b,c,c,c,d,d,e] .\n%  \n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\npackList([],[]).\n\npackList([X],[[1,X]]) :- !.\n\n\npackList([X|Rest],[XRun|Packed]):-\n    run(X,Rest, XRun,RRest),\n    packList(RRest,Packed).\n\n\nrun(Var,[],[1,Var],[]).\n\nrun(Var,[Var|LRest],[N1, Var],RRest):-\n    N #> 0,\n    N1 #= N + 1,\n    run(Var,LRest,[N, Var],RRest).\n\n\nrun(Var,[Other|RRest], [1,Var],[Other|RRest]):-\n    dif(Var,Other).\n\n\n\u00a0?- run_length.\nencode WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n12W1B12W3B24W1B14W\n\ndecode 12W1B12W3B24W1B14W\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\ntrue .\n\n", "explain": "Works with SWI-Prolog.\nThis code is inspired from a code found here\u00a0: http://groups.google.com/group/comp.lang.prolog/browse_thread/thread/b053ea2512e8b350 (author\u00a0: Pascal J. Bourguignon).\nOutput\u00a0:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Lua", "code": "\nlocal C, Ct, R, Cf, Cc = lpeg.C, lpeg.Ct, lpeg.R, lpeg.Cf, lpeg.Cc\nastable = Ct(C(1)^0)\n\nfunction compress(t)\n    local ret = {}\n    for i, v in ipairs(t) do\n      if t[i-1] and v == t[i-1] then\n        ret[#ret - 1] = ret[#ret - 1] + 1\n      else\n        ret[#ret + 1] = 1\n        ret[#ret + 1] = v\n      end\n    end\n    t = ret\n    return table.concat(ret)\nend\nq = io.read()\nprint(compress(astable:match(q))) \n\nundo = Ct((Cf(Cc\"0\" * C(R\"09\")^1, function(a, b) return 10 * a + b end) * C(R\"AZ\"))^0)\n\nfunction decompress(s)\n  t = undo:match(s)\n  local ret = \"\"\n  for i = 1, #t - 1, 2 do\n    for _ = 1, t[i] do\n      ret = ret .. t[i+1]\n    end\n  end\n  return ret\nend\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Scala", "code": "\n\ndef encode(s: String) = (1 until s.size).foldLeft((1, s(0), new StringBuilder)) {\n  case ((len, c, sb), index) if c\u00a0!= s(index) => sb.append(len); sb.append(c); (1, s(index), sb)\n  case ((len, c, sb), _) => (len + 1, c, sb)\n} match {\n  case (len, c, sb) => sb.append(len); sb.append(c); sb.toString\n}\n\ndef decode(s: String) = {\n  val sb = new StringBuilder\n  val Code = \"\"\"(\\d+)([A-Z])\"\"\".r\n  for (Code(len, c) <- Code findAllIn s) sb.append(c * len.toInt)\n  sb.toString\n}\n\ndef encode(s:String) = {\n  s.foldLeft((0,s(0),\"\"))( (t,c) => t match {case (i,p,s) => if (p==c) (i+1,p,s) else (1,c,s+i+p)})\n    match {case (i,p,s) => s+i+p}\n}\n\ndef decode(s: String, Code: scala.util.matching.Regex = \"\"\"(\\d+)?([a-zA-Z])\"\"\".r) =\n  Code.findAllIn(s).foldLeft(\"\") { case (acc, Code(len, c)) =>\n    acc + c * Option(len).map(_.toInt).getOrElse(1)\n  }\n", "explain": "Care is taken to use StringBuilder for performance reasons.\nA simpler (?) encoder:\nTo make it faster (it's also faster than the longer implementation above) just replace \"\" with new StringBuilder and s+i+p with {s.append(i);s.append(p)}\nA simpler (?) decoder (that can handle a string like \"2AB\", producing \"AAB\"):\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "D", "code": "\nShort Functional Version[edit]\nimport std.algorithm, std.array;\n\nalias encode = group;\n\nauto decode(Group!(\"a == b\", string) enc) {\n    return enc.map!(t => [t[0]].replicate(t[1])).join;\n}\n\nvoid main() {\n    immutable s = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWW\" ~\n                  \"WWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n    assert(s.encode.decode.equal(s));\n}\n\nBasic Imperative Version[edit]\nimport std.stdio, std.array, std.conv;\n\n// Similar to the 'look and say' function.\nstring encode(in string input) pure nothrow @safe {\n    if (input.empty)\n        return input;\n    char last = input[$ - 1];\n    string output;\n    int count;\n\n    foreach_reverse (immutable c; input) {\n        if (c == last) {\n            count++;\n        } else {\n            output = count.text ~ last ~ output;\n            count = 1;\n            last = c;\n        }\n    }\n\n    return count.text ~ last ~ output;\n}\n\nstring decode(in string input) pure /*@safe*/ {\n    string i, result;\n\n    foreach (immutable c; input)\n        switch (c) {\n            case '0': .. case '9':\n                i ~= c;\n                break;\n            case 'A': .. case 'Z':\n                if (i.empty)\n                    throw new Exception(\"Can not repeat a letter \" ~\n                        \"without a number of repetitions\");\n                result ~= [c].replicate(i.to!int);\n                i.length = 0;\n                break;\n            default:\n                throw new Exception(\"'\" ~ c ~ \"' is not alphanumeric\");\n        }\n\n    return result;\n}\n\nvoid main() {\n    immutable txt = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWW\" ~\n                    \"WWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n    writeln(\"Input: \", txt);\n    immutable encoded = txt.encode;\n    writeln(\"Encoded: \", encoded);\n    assert(txt == encoded.decode);\n}\n\n\nOutput:\nInput: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nEncoded: 12W1B12W3B24W1B14W\nUTF String Version[edit]\n\nimport std.stdio, std.conv, std.utf, std.array;\nimport vlq;\n\nstruct RLE { // for utf string \n    ubyte[] encoded;\n\n    RLE encode(const string s) {\n        validate(s); // check if s is well-formed utf, throw if not \n        encoded.length = 0; // reset \n        if (s.length == 0) return this; // empty string\n        string last;\n        VLQ count;\n        for (int i = 0; i < s.length; ) {\n            auto k = s.stride(i);\n            auto ucode = cast(string)s[i .. i + k];\n            if (i == 0) last = ucode;\n            if (ucode == last)\n                count++;\n            else {\n                encoded ~= count.toVLQ ~ cast(ubyte[])last;\n                last = ucode;\n                count = 1;\n            }\n            i += k;\n        }\n        encoded ~= VLQ(count).toVLQ ~ cast(ubyte[])last;\n        return this;\n    }\n\n    int opApply(int delegate(ref ulong c, ref string u) dg) {\n        VLQ count;\n        string ucode;\n\n        for (int i = 0; i < encoded.length; ) {\n            auto k = count.extract(encoded[i .. $]);\n            i += k;\n            if (i >= encoded.length)\n                throw new Exception(\"not valid encoded string\");\n            k = stride(cast(string) encoded[i .. $], 0);\n            if (k == 0xff) // not valid utf code point \n                throw new Exception(\"not valid encoded string\");\n            ucode = cast(string)encoded[i .. i + k].dup;\n            dg(count.value, ucode);\n            i += k;\n        }\n\n        return 0;\n    }\n\n    string toString() {\n        string res;\n        foreach (ref i, s ; this)\n            if (indexOf(\"0123456789#\", s) == -1)\n                res ~= text(i) ~ s;\n            else \n                res ~= text(i) ~ '#' ~ s;\n        return res;\n    }\n \n    string decode() {\n        string res;\n        foreach (ref i, s; this)\n            res ~= replicate(s, cast(uint)i);\n        return res;\n    }       \n}\n\nvoid main() {\n    RLE r;\n    auto s = \"\u5c0b\u5c0b\u8993\u8993\u51b7\u51b7\u6e05\u6e05\u6dd2\u6dd2\u6158\u6158\u621a\u621a\\nWWWWWWWWWWWWBWWWWWWWWWWW\" ~\n             \"WBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\\n\" ~\n             \"11#222##333\";\n    auto f = File(\"display.txt\", \"w\");\n    f.writeln(s);\n    r.encode(s);\n    f.writefln(\"-----\\n%s\\n-----\\n%s\", r, r.decode());\n    auto sEncoded = RLE.init.encode(s).encoded ;\n    assert(s == RLE(sEncoded).decode(), \"Not work\");\n}\n\n\n\u5c0b\u5c0b\u8993\u8993\u51b7\u51b7\u6e05\u6e05\u6dd2\u6dd2\u6158\u6158\u621a\u621a\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n11#222##333\n-----\n2\u5c0b2\u89932\u51b72\u6e052\u6dd22\u61582\u621a1\n12W1B12W3B24W1B14W1\n2#11##3#22##3#3\n-----\n\u5c0b\u5c0b\u8993\u8993\u51b7\u51b7\u6e05\u6e05\u6dd2\u6dd2\u6158\u6158\u621a\u621a\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n11#222##333\n\nUTF String Version with Regular Expression[edit]\nTranslation of: Python\n\nimport std.stdio, std.conv, std.array, std.regex, std.utf,\n       std.algorithm;\n\nstring reEncode(string s) {\n    validate(s); // Throw if it's not a well-formed UTF string\n    static string rep(Captures!string m) {\n        auto c = canFind(\"0123456789#\", m[1]) ? \"#\" ~ m[1] : m[1];\n        return text(m.hit.length / m[1].length) ~ c;\n    }\n    return std.regex.replace!rep(s, regex(`(.|[\\n\\r\\f])\\1*`, \"g\"));\n}\n\n\nstring reDecode(string s) {\n    validate(s); // Throw if it's not a well-formed UTF string\n    static string rep(Captures!string m) {\n        string c = m[2];\n        if (c.length > 1 && c[0] == '#')\n            c = c[1 .. $];\n        return replicate(c, to!int(m[1]));\n    }\n    auto r=regex(`(\\d+)(#[0123456789#]|[\\n\\r\\f]|[^0123456789#\\n\\r\\f]+)`\n                 , \"g\");\n    return std.regex.replace!rep(s, r);\n}\n\nvoid main() {\n    auto s = \"\u5c0b\u5c0b\u8993\u8993\u51b7\u51b7\u6e05\u6e05\u6dd2\u6dd2\u6158\u6158\u621a\u621a\\nWWWWWWWWWWWWBWWWWWWWWWWW\" ~\n             \"WBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\\n\" ~\n             \"11#222##333\";\n    assert(s == reDecode(reEncode(s)));\n}\n\n", "explain": "D's native string is utf-encoded. This version works for utf string, and uses a Variable-length Quantity module. \noutput from \"display.txt\":\nNOTE: some characters in this section use Chinese font.\nThe code looks more complex than the third Python version because this also handles digits by escaping them with #.\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Haskell", "code": "\nIn terms of group[edit]\nimport Data.List (group)\n\n-- Datatypes\ntype Encoded = [(Int, Char)] -- An encoded String with form [(times, char), ...]\n\ntype Decoded = String\n\n-- Takes a decoded string and returns an encoded list of tuples\nrlencode :: Decoded -> Encoded\nrlencode = fmap ((,) <$> length <*> head) . group\n\n-- Takes an encoded list of tuples and returns the associated decoded String\nrldecode :: Encoded -> Decoded\nrldecode = concatMap (uncurry replicate)\n\nmain :: IO ()\nmain = do\n  let input = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n      -- Output encoded and decoded versions of input\n      encoded = rlencode input\n      decoded = rldecode encoded\n  putStrLn $ \"Encoded: \" <> show encoded <> \"\\nDecoded: \" <> show decoded\n\n\nOutput:\nEncoded: [(12,'W'),(1,'B'),(12,'W'),(3,'B'),(24,'W'),(1,'B'),(14,'W')]\nDecoded: \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n\nimport Data.Char (isDigit)\nimport Data.List (group, groupBy)\n\nrunLengthEncode :: String -> String\nrunLengthEncode =\n  concatMap\n    ( \\xs@(x : _) ->\n        ( show . length $ xs\n        )\n          <> [x]\n    )\n    . group\n\nrunLengthDecode :: String -> String\nrunLengthDecode =\n  concat . uncurry (zipWith (\\[x] ns -> replicate (read ns) x))\n    . foldr (\\z (x, y) -> (y, z : x)) ([], [])\n    . groupBy (\\x y -> all isDigit [x, y])\n\nmain :: IO ()\nmain = do\n  let text = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n      encode = runLengthEncode text\n      decode = runLengthDecode encode\n  mapM_ putStrLn [text, encode, decode]\n  putStrLn $ \"test: text == decode => \" <> show (text == decode)\n\n\nOutput:\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n12W1B12W3B24W1B14W\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\ntest: text == decode => True\nIn terms of span[edit]\nimport Data.Char (isDigit)\nimport Data.List (span)\n\nencode :: String -> String\nencode [] = []\nencode (x : xs) =\n  let (run, rest) = span (x ==) xs\n   in x : (show . succ . length) run <> encode rest\n\ndecode :: String -> String\ndecode [] = []\ndecode (x : xs) =\n  let (ds, rest) = span isDigit xs\n      n = read ds :: Int\n   in replicate n x <> decode rest\n\nmain :: IO ()\nmain =\n  putStrLn encoded\n    >> putStrLn decoded\n    >> print (src == decoded)\n  where\n    src = \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n    encoded = encode src\n    decoded = decode encoded\n\n\nOutput:\nW12B1W12B3W24B1W14\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nTrue\nAs a fold[edit]\n----------------------- RUN LENGTHS ----------------------\n\nrunLengths :: String -> [(Int, Char)]\nrunLengths \"\" = []\nrunLengths s = uncurry (:) (foldr go ((0, ' '), []) s)\n  where\n    go c ((0, _), xs) = ((1, c), xs)\n    go c ((n, x), xs)\n      | c == x = ((succ n, x), xs)\n      | otherwise = ((1, c), (n, x) : xs)\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = do\n  let testString =\n        \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWW\"\n          <> \"WWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n      encoded = runLengths testString\n  putStrLn $ showLengths encoded\n  print $\n    concatMap (uncurry replicate) encoded == testString\n\n------------------------- DISPLAY ------------------------\nshowLengths :: [(Int, Char)] -> String\nshowLengths [] = []\nshowLengths ((n, c) : xs) = show n <> [c] <> showLengths xs\n\n\nOutput:\n12W1B12W3B24W1B14W\nTrue\n", "explain": "Or:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Scheme", "code": "\n(define (run-length-decode v)\n   (apply string-append (map (lambda (p) (make-string (car p) (cdr p))) v)))\n\n(define (run-length-encode s)\n(let ((n (string-length s)))\n(let loop ((i (- n 2)) (c (string-ref s (- n 1))) (k 1) (v '()))\n(if (negative? i) (cons (cons k c) v)\n    (let ((x (string-ref s i)))\n    (if (char=? c x) (loop (- i 1) c (+ k 1) v)\n                     (loop (- i 1) x 1 (cons (cons k c) v))))))))\n\n(run-length-encode \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\")\n; ((12 . #\\W) (1 . #\\B) (12 . #\\W) (3 . #\\B) (24 . #\\W) (1 . #\\B) (14 . #\\W))\n(run-length-decode '((12 . #\\W) (1 . #\\B) (12 . #\\W) (3 . #\\B) (24 . #\\W) (1 . #\\B) (14 . #\\W)))\n; \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "PowerShell", "code": "\nfunction Compress-RLE ($s) {\n    $re = [regex] '(.)\\1*'\n    $ret = \"\"\n    foreach ($m in $re.Matches($s)) {\n        $ret += $m.Length\n        $ret += $m.Value[0]\n    }\n    return $ret\n}\n\nfunction Expand-RLE ($s) {\n    $re = [regex] '(\\d+)(.)'\n    $ret = \"\"\n    foreach ($m in $re.Matches($s)) {\n        $ret += [string] $m.Groups[2] * [int] [string] $m.Groups[1]\n    }\n    return $ret\n}\n\n\nPS> Compress-RLE \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\"\n12W1B12W3B24W1B14W\nPS> Expand-RLE \"12W1B12W3B24W1B14W\"\nWWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n", "explain": "Output:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Logo", "code": "\nto encode :str [:out \"||] [:count 0] [:last first :str]\n  if empty? :str [output (word :out :count :last)]\n  if equal? first :str :last [output (encode bf :str :out :count+1 :last)]\n  output (encode bf :str (word :out :count :last) 1 first :str)\nend\n\nto reps :n :w\n  output ifelse :n = 0 [\"||] [word :w reps :n-1 :w]\nend\nto decode :str [:out \"||] [:count 0]\n  if empty? :str [output :out]\n  if number? first :str [output (decode bf :str :out 10*:count + first :str)]\n  output (decode bf :str word :out reps :count first :str)\nend\n\nmake \"foo \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nmake \"rle encode :foo\nshow equal? :foo decode :rle\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "F#", "code": "\nopen System\nopen System.Text.RegularExpressions\n\nlet encode data =\n    // encodeData\u00a0: seq<'T> -> seq<int * 'T> i.e. Takes a sequence of 'T types and return a sequence of tuples containing the run length and an instance of 'T.\n    let rec encodeData input =\n        seq { if not (Seq.isEmpty input) then\n                 let head = Seq.head input              \n                 let runLength = Seq.length (Seq.takeWhile ((=) head) input)\n                 yield runLength, head\n                 yield! encodeData (Seq.skip runLength input) }\n \n    encodeData data |> Seq.fold(fun acc (len, d) -> acc + len.ToString() + d.ToString()) \"\"\n\nlet decode str =\n    [ for m in Regex.Matches(str, \"(\\d+)(.)\") -> m ]\n    |> List.map (fun m -> Int32.Parse(m.Groups.[1].Value), m.Groups.[2].Value)\n    |> List.fold (fun acc (len, s) -> acc + String.replicate len s) \"\"\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Groovy", "code": "\ndef rleEncode(text) {\n    def encoded = new StringBuilder()\n    (text =~ /(([A-Z])\\2*)/).each { matcher ->\n        encoded.append(matcher[1].size()).append(matcher[2])\n    }\n    encoded.toString()\n}\n\ndef rleDecode(text) {\n    def decoded = new StringBuilder()\n    (text =~ /([0-9]+)([A-Z])/).each { matcher ->\n        decoded.append(matcher[2] * Integer.parseInt(matcher[1]))\n    }\n    decoded.toString()\n}\n\n\ndef text = 'WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW'\ndef rleEncoded = rleEncode(text)\nassert rleEncoded == '12W1B12W3B24W1B14W'\nassert text == rleDecode(rleEncoded)\n\nprintln \"Original Text: $text\"\nprintln \"Encoded Text: $rleEncoded\"\n\n\nOriginal Text: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nEncoded Text: 12W1B12W3B24W1B14W\n", "explain": "Test code\nOutput:\n"}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "Zig", "code": "\nconst std = @import(\"std\");\n\nfn Run(comptime T: type) type {\n    return struct {\n        value: T,\n        length: usize,\n    };\n}\n\nfn encode(\n    comptime T: type,\n    input: []const T,\n    allocator: std.mem.Allocator,\n)\u00a0![]Run(T) {\n    var runs = std.ArrayList(Run(T)).init(allocator);\n    defer runs.deinit();\n\n    var previous: ?T = null;\n    var length: usize = 0;\n\n    for (input) |current| {\n        if (previous == current) {\n            length += 1;\n        } else if (previous) |value| {\n            try runs.append(.{\n                .value = value,\n                .length = length,\n            });\n            previous = current;\n            length = 1;\n        } else {\n            previous = current;\n            length += 1;\n        }\n    }\n\n    if (previous) |value| {\n        try runs.append(.{\n            .value = value,\n            .length = length,\n        });\n    }\n\n    return runs.toOwnedSlice();\n}\n\ntest encode {\n    const input =\n        \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\";\n\n    const expected = [_]Run(u8){\n        .{ .length = 12, .value = 'W' },\n        .{ .length = 1, .value = 'B' },\n        .{ .length = 12, .value = 'W' },\n        .{ .length = 3, .value = 'B' },\n        .{ .length = 24, .value = 'W' },\n        .{ .length = 1, .value = 'B' },\n        .{ .length = 14, .value = 'W' },\n    };\n\n    const allocator = std.testing.allocator;\n    const actual = try encode(u8, input, allocator);\n    defer allocator.free(actual);\n\n    try std.testing.expectEqual(expected.len, actual.len);\n    for (expected, actual) |e, a| {\n        try std.testing.expectEqual(e.length, a.length);\n        try std.testing.expectEqual(e.value, a.value);\n    }\n}\n\nfn decode(\n    comptime T: type,\n    runs: []const Run(T),\n    allocator: std.mem.Allocator,\n)\u00a0![]T {\n    var values = std.ArrayList(T).init(allocator);\n    defer values.deinit();\n    for (runs) |r|\n        try values.appendNTimes(r.value, r.length);\n    return values.toOwnedSlice();\n}\n\ntest decode {\n    const runs = [_]Run(u8){\n        .{ .length = 12, .value = 'W' },\n        .{ .length = 1, .value = 'B' },\n        .{ .length = 12, .value = 'W' },\n        .{ .length = 3, .value = 'B' },\n        .{ .length = 24, .value = 'W' },\n        .{ .length = 1, .value = 'B' },\n        .{ .length = 14, .value = 'W' },\n    };\n\n    const allocator = std.testing.allocator;\n    const decoded = try decode(u8, &runs, allocator);\n    defer allocator.free(decoded);\n\n    try std.testing.expectEqualStrings(\n        \"WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\",\n        decoded,\n    );\n}\n\npub fn main() !void {\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer std.debug.assert(gpa.deinit() == .ok);\n\n    const allocator = gpa.allocator();\n    var input = std.ArrayList(u8).init(allocator);\n    defer input.deinit();\n\n    const stdout = std.io.getStdOut().writer();\n    const stdin = std.io.getStdIn().reader();\n    try stdout.print(\"Input: \", .{});\n    try stdin.streamUntilDelimiter(input.writer(), '\\n', null);\n\n    const runs = try encode(u8, input.items, allocator);\n    defer allocator.free(runs);\n\n    try stdout.print(\"Encoded:\\n\", .{});\n    for (runs) |r|\n        try stdout.print(\"  {}\\n\", .{r});\n\n    const decoded = try decode(u8, runs, allocator);\n    defer allocator.free(decoded);\n\n    try stdout.print(\"Decoded: {s}\\n\", .{decoded});\n}\n\nOutput:\nInput: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\nEncoded:\n  run_length_encoding.Run(u8){ .value = 87, .length = 12 }\n  run_length_encoding.Run(u8){ .value = 66, .length = 1 }\n  run_length_encoding.Run(u8){ .value = 87, .length = 12 }\n  run_length_encoding.Run(u8){ .value = 66, .length = 3 }\n  run_length_encoding.Run(u8){ .value = 87, .length = 24 }\n  run_length_encoding.Run(u8){ .value = 66, .length = 1 }\n  run_length_encoding.Run(u8){ .value = 87, .length = 14 }\nDecoded: WWWWWWWWWWWWBWWWWWWWWWWWWBBBWWWWWWWWWWWWWWWWWWWWWWWWBWWWWWWWWWWWWWW\n\n", "explain": ""}, {"task_name": "Run-length encoding", "task_url": "https://rosettacode.org/wiki/Run-length_encoding", "task_cat": "Compression", "lang": "AWK", "code": "\nWorks with: gawk\n\nBEGIN {\n FS=\"\"\n}\n/^[^0-9]+$/ {\n  cp = $1; j = 0\n  for(i=1; i <= NF; i++) {\n    if ( $i == cp ) {\n      j++; \n    } else {\n      printf(\"%d%c\", j, cp)\n      j = 1\n    }\n    cp = $i\n  }\n  printf(\"%d%c\", j, cp)\n}\n\n\nBEGIN {\n  RS=\"[0-9]+[^0-9]\"\n  final = \"\";\n}\n{\n  match(RT, /([0-9]+)([^0-9])/, r)\n  for(i=0; i < int(r[1]); i++) {\n    final = final r[2]\n  }\n}\nEND {\n  print final\n}\n\n", "explain": "It works with \"textual\" input. Lines containing numbers are skipped, since they can't be represented in a not ambiguous way in this implementation (e.g. \"11AA\" would be encoded as \"212A\", which would be decoded as A repeated 212 times!)\nEncoding\nDecoding\n"}]