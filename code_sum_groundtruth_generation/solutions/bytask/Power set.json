[{"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Python", "code": "\ndef list_powerset(lst):\n    # the power set of the empty set has one element, the empty set\n    result = [[]]\n    for x in lst:\n        # for every additional element in our set\n        # the power set consists of the subsets that don't\n        # contain this element (just take the previous power set)\n        # plus the subsets that do contain the element (use list\n        # comprehension to add [x] onto everything in the\n        # previous power set)\n        result.extend([subset + [x] for subset in result])\n    return result\n\n# the above function in one statement\ndef list_powerset2(lst):\n    return reduce(lambda result, x: result + [subset + [x] for subset in result],\n                  lst, [[]])\n\ndef powerset(s):\n    return frozenset(map(frozenset, list_powerset(list(s))))\n\n\nExample:\n>>> list_powerset([1,2,3])\n[[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n>>> powerset(frozenset([1,2,3]))\nfrozenset([frozenset([3]), frozenset([1, 2]), frozenset([]), frozenset([2, 3]), frozenset([1]), frozenset([1, 3]), frozenset([1, 2, 3]), frozenset([2])])\n\nFurther Explanation[edit]\n\ndef powersetlist(s):\n    r = [[]]\n    for e in s:\n        print \"r:\u00a0%-55r e: %r\"\u00a0% (r,e)\n        r += [x+[e] for x in r]\n    return r\n\ns= [0,1,2,3]    \nprint \"\\npowersetlist(%r) =\\n  %r\"\u00a0% (s, powersetlist(s))\n\nOutput:\nr: [[]]                                                    e: 0\nr: [[], [0]]                                               e: 1\nr: [[], [0], [1], [0, 1]]                                  e: 2\nr: [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2]]  e: 3\n\npowersetlist([0, 1, 2, 3]) =\n  [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2], [3], [0, 3], [1, 3], [0, 1, 3], [2, 3], [0, 2, 3], [1, 2, 3], [0, 1, 2, 3]]\n\nBinary Count method[edit]\n\ndef powersequence(val):\n    ''' Generate a 'powerset' for sequence types that are indexable by integers.\n        Uses a binary count to enumerate the members and returns a list\n\n        Examples:\n            >>> powersequence('STR')   # String\n            ['', 'S', 'T', 'ST', 'R', 'SR', 'TR', 'STR']\n            >>> powersequence([0,1,2]) # List\n            [[], [0], [1], [0, 1], [2], [0, 2], [1, 2], [0, 1, 2]]\n            >>> powersequence((3,4,5)) # Tuple\n            [(), (3,), (4,), (3, 4), (5,), (3, 5), (4, 5), (3, 4, 5)]\n            >>> \n    '''\n    vtype = type(val); vlen = len(val); vrange = range(vlen)\n    return [ reduce( lambda x,y: x+y, (val[i:i+1] for i in vrange if 2**i & n), vtype())\n             for n in range(2**vlen) ]\n\ndef powerset(s):\n    ''' Generate the powerset of s\n\n        Example:\n            >>> powerset(set([6,7,8]))\n            set([frozenset([7]), frozenset([8, 6, 7]), frozenset([6]), frozenset([6, 7]), frozenset([]), frozenset([8]), frozenset([8, 7]), frozenset([8, 6])])\n    '''\n    return set( frozenset(x) for x in powersequence(list(s)) )\nRecursive Alternative[edit]\n\ndef p(l):\n    if not l: return [[]]\n    return p(l[1:]) + [[l[0]] + x for x in p(l[1:])]\nPython: Standard documentation[edit]\n\n>>> from pprint import pprint as pp\n>>> from itertools import chain, combinations\n>>> \n>>> def powerset(iterable):\n    \"powerset([1,2,3]) --> () (1,) (2,) (3,) (1,2) (1,3) (2,3) (1,2,3)\"\n    s = list(iterable)\n    return chain.from_iterable(combinations(s, r) for r in range(len(s)+1))\n\n>>> pp(set(powerset({1,2,3,4})))\n{(),\n (1,),\n (1, 2),\n (1, 2, 3),\n (1, 2, 3, 4),\n (1, 2, 4),\n (1, 3),\n (1, 3, 4),\n (1, 4),\n (2,),\n (2, 3),\n (2, 3, 4),\n (2, 4),\n (3,),\n (3, 4),\n (4,)}\n>>>\n", "explain": "list_powerset computes the power set of a list of distinct elements. powerset simply converts the input and output from lists to sets. We use the frozenset type here for immutable sets, because unlike mutable sets, it can be put into other sets.\nIf you take out the requirement to produce sets and produce list versions of each powerset element, then add a print to trace the execution, you get this simplified version of the program above where it is easier to trace the inner workings\nIf you list the members of the set and include them according to if the corresponding bit position of a binary count is true then you generate the powerset. \n(Note that only frozensets can be members of a set in the second function)\nThis is an (inefficient) recursive version that almost reflects the recursive definition of a power set as explained in http://en.wikipedia.org/wiki/Power_set#Algorithms. It does not create a sorted output.\nPythons documentation has a method that produces the groupings, but not as sets:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "C", "code": "\n#include <stdio.h>\n\nstruct node {\n\tchar *s;\n\tstruct node* prev;\n};\n\nvoid powerset(char **v, int n, struct node *up)\n{\n\tstruct node me;\n\n\tif (!n) {\n\t\tputchar('[');\n\t\twhile (up) {\n\t\t\tprintf(\" %s\", up->s);\n\t\t\tup = up->prev;\n\t\t}\n\t\tputs(\" ]\");\n\t} else {\n\t\tme.s = *v;\n\t\tme.prev = up;\n\t\tpowerset(v + 1, n - 1, up);\n\t\tpowerset(v + 1, n - 1, &me);\n\t}\n}\n\nint main(int argc, char **argv)\n{\n\tpowerset(argv + 1, argc - 1, 0);\n\treturn 0;\n}\n\n\nOutput:\n% ./a.out 1 2 3\n[ ]\n[ 3 ]\n[ 2 ]\n[ 3 2 ]\n[ 1 ]\n[ 3 1 ]\n[ 2 1 ]\n[ 3 2 1 ]\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "C++", "code": "\nNon-recursive version[edit]\n#include <iostream>\n#include <set>\n#include <vector>\n#include <iterator>\n#include <algorithm>\ntypedef std::set<int> set_type;\ntypedef std::set<set_type> powerset_type;\n\npowerset_type powerset(set_type const& set)\n{\n  typedef set_type::const_iterator set_iter;\n  typedef std::vector<set_iter> vec;\n  typedef vec::iterator vec_iter;\n\n  struct local\n  {\n    static int dereference(set_iter v) { return *v; }\n  };\n\n  powerset_type result;\n\n  vec elements;\n  do\n  {\n    set_type tmp;\n    std::transform(elements.begin(), elements.end(),\n                   std::inserter(tmp, tmp.end()),\n                   local::dereference);\n    result.insert(tmp);\n    if (!elements.empty() && ++elements.back() == set.end())\n    {\n      elements.pop_back();\n    }\n    else\n    {\n      set_iter iter;\n      if (elements.empty())\n      {\n        iter = set.begin();\n      }\n      else\n      {\n        iter = elements.back();\n        ++iter;\n      }\n      for (; iter != set.end(); ++iter)\n      {\n        elements.push_back(iter);\n      }\n    }\n  } while (!elements.empty());\n\n  return result;\n}\n\nint main()\n{\n  int values[4] = { 2, 3, 5, 7 };\n  set_type test_set(values, values+4);\n\n  powerset_type test_powerset = powerset(test_set);\n\n  for (powerset_type::iterator iter = test_powerset.begin();\n       iter != test_powerset.end();\n       ++iter)\n  {\n    std::cout << \"{ \";\n    char const* prefix = \"\";\n    for (set_type::iterator iter2 = iter->begin();\n         iter2 != iter->end();\n         ++iter2)\n    {\n      std::cout << prefix << *iter2;\n      prefix = \", \";\n    }\n    std::cout << \" }\\n\";\n  }\n}\n\n\nOutput:\n{  }\n{ 2 }\n{ 2, 3 }\n{ 2, 3, 5 }\n{ 2, 3, 5, 7 }\n{ 2, 3, 7 }\n{ 2, 5 }\n{ 2, 5, 7 }\n{ 2, 7 }\n{ 3 }\n{ 3, 5 }\n{ 3, 5, 7 }\n{ 3, 7 }\n{ 5 }\n{ 5, 7 }\n{ 7 }\n\nC++14 version[edit]\n\n#include <set>\n#include <iostream>\n\ntemplate <class S>\nauto powerset(const S& s)\n{\n    std::set<S> ret;\n    ret.emplace();\n    for (auto&& e: s) {\n        std::set<S> rs;\n        for (auto x: ret) {\n            x.insert(e);\n            rs.insert(x);\n        }\n        ret.insert(begin(rs), end(rs));\n    }\n    return ret;\n}\n\nint main()\n{\n    std::set<int> s = {2, 3, 5, 7};\n    auto pset = powerset(s);\n\n    for (auto&& subset: pset) {\n        std::cout << \"{ \";\n        char const* prefix = \"\";\n        for (auto&& e: subset) {\n            std::cout << prefix << e;\n            prefix = \", \";\n        }\n        std::cout << \" }\\n\";\n    }\n}\n\nRecursive version[edit]\n#include <iostream>\n#include <set>\n\ntemplate<typename Set> std::set<Set> powerset(const Set& s, size_t n)\n{\n    typedef typename Set::const_iterator SetCIt;\n    typedef typename std::set<Set>::const_iterator PowerSetCIt;\n    std::set<Set> res;\n    if(n > 0) {\n        std::set<Set> ps = powerset(s, n-1);\n        for(PowerSetCIt ss = ps.begin(); ss != ps.end(); ss++)\n            for(SetCIt el = s.begin(); el != s.end(); el++) {\n                Set subset(*ss);\n                subset.insert(*el);\n                res.insert(subset);\n            }\n        res.insert(ps.begin(), ps.end());\n    } else\n        res.insert(Set());\n    return res;\n}\ntemplate<typename Set> std::set<Set> powerset(const Set& s)\n{\n    return powerset(s, s.size());\n}\n\n", "explain": "This simplified version has identical output to the previous code.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Java", "code": "\nWorks with: Java version 1.5+\nRecursion[edit]\n\npublic static ArrayList<String> getpowerset(int a[],int n,ArrayList<String> ps)\n    {\n        if(n<0)\n        {\n            return null;\n        }\n        if(n==0)\n        {\n            if(ps==null)\n                ps=new ArrayList<String>();\n            ps.add(\" \");\n            return ps;\n        }\n        ps=getpowerset(a, n-1, ps);\n        ArrayList<String> tmp=new ArrayList<String>();\n        for(String s:ps)\n        {\n            if(s.equals(\" \"))\n                tmp.add(\"\"+a[n-1]);\n            else\n                tmp.add(s+a[n-1]);\n        }\n        ps.addAll(tmp);\n        return ps;\n    }\n\nIterative[edit]\n\npublic static <T> List<List<T>> powerset(Collection<T> list) {\n  List<List<T>> ps = new ArrayList<List<T>>();\n  ps.add(new ArrayList<T>());   // add the empty set\n\n  // for every item in the original list\n  for (T item : list) {\n    List<List<T>> newPs = new ArrayList<List<T>>();\n\n    for (List<T> subset : ps) {\n      // copy all of the current powerset's subsets\n      newPs.add(subset);\n\n      // plus the subsets appended with the current item\n      List<T> newSubset = new ArrayList<T>(subset);\n      newSubset.add(item);\n      newPs.add(newSubset);\n    }\n\n    // powerset is now powerset of list.subList(0, list.indexOf(item)+1)\n    ps = newPs;\n  }\n  return ps;\n}\n\nBinary String[edit]\n\npublic static <T extends Comparable<? super T>> LinkedList<LinkedList<T>> BinPowSet(\n\t\tLinkedList<T> A){\n\tLinkedList<LinkedList<T>> ans= new LinkedList<LinkedList<T>>();\n\tint ansSize = (int)Math.pow(2, A.size());\n\tfor(int i= 0;i< ansSize;++i){\n\t\tString bin= Integer.toBinaryString(i); //convert to binary\n\t\twhile(bin.length() < A.size()) bin = \"0\" + bin; //pad with 0's\n\t\tLinkedList<T> thisComb = new LinkedList<T>(); //place to put one combination\n\t\tfor(int j= 0;j< A.size();++j){\n\t\t\tif(bin.charAt(j) == '1')thisComb.add(A.get(j));\n\t\t}\n\t\tCollections.sort(thisComb); //sort it for easy checking\n\t\tans.add(thisComb); //put this set in the answer list\n\t}\n\treturn ans;\n}\n\n", "explain": "This implementation sorts each subset, but not the whole list of subsets (which would require a custom comparator). It also destroys the original set.\nThe iterative implementation of the above idea. Each subset is in the order that the element appears in the input list. This implementation preserves the input. \nThis implementation works on idea that each element in the original set can either be in the power set or not in it. With n elements in the original set, each combination can be represented by a binary string of length n. To get all possible combinations, all you need is a counter from 0 to 2n - 1. If the kth bit in the binary string is 1, the kth element of the original set is in this combination.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "C#", "code": "\npublic IEnumerable<IEnumerable<T>> GetPowerSet<T>(List<T> list)\n{\n    return from m in Enumerable.Range(0, 1 << list.Count)\n                  select\n                      from i in Enumerable.Range(0, list.Count)\n                      where (m & (1 << i)) != 0\n                      select list[i];\n}\n\npublic void PowerSetofColors()\n{\n    var colors = new List<KnownColor> { KnownColor.Red, KnownColor.Green, \n        KnownColor.Blue, KnownColor.Yellow };\n    \n    var result = GetPowerSet(colors);\n    \n    Console.Write( string.Join( Environment.NewLine, \n        result.Select(subset => \n            string.Join(\",\", subset.Select(clr => clr.ToString()).ToArray())).ToArray()));\n}\n\n\nOutput:\n  Red\n  Green\n  Red,Green\n  Blue\n  Red,Blue\n  Green,Blue\n  Red,Green,Blue\n  Yellow\n  Red,Yellow\n  Green,Yellow\n  Red,Green,Yellow\n  Blue,Yellow\n  Red,Blue,Yellow\n  Green,Blue,Yellow\n  Red,Green,Blue,Yellow\n\n\n  public IEnumerable<IEnumerable<T>> GetPowerSet<T>(IEnumerable<T> input) {\n    var seed = new List<IEnumerable<T>>() { Enumerable.Empty<T>() }\n      as IEnumerable<IEnumerable<T>>;\n\n    return input.Aggregate(seed, (a, b) =>\n      a.Concat(a.Select(x => x.Concat(new List<T>() { b }))));\n  }\n\n\n  using System;\n  class Powerset\n  {\n    static int count = 0, n = 4;\n    static int [] buf = new int [n];\n  \n    static void Main()\n    {\n  \tint ind = 0;\n  \tint n_1 = n - 1;\n  \tfor (;;)\n  \t{\n  \t  for (int i = 0; i <= ind; ++i) Console.Write(\"{0, 2}\", buf [i]);\n  \t  Console.WriteLine();\n  \t  count++;\n  \n  \t  if (buf [ind] < n_1) { ind++; buf [ind] = buf [ind - 1] + 1; }\n  \t  else if (ind > 0) { ind--; buf [ind]++; }\n  \t  else break;\n  \t}\n  \tConsole.WriteLine(\"n=\" + n + \"   count=\" + count);\n    }\n  }\n\n\n\nusing System;\nclass Powerset\n{\n  static int n = 4;\n  static int [] buf = new int [n];\n\n  static void Main()\n  {\n    rec(0, 0);\n  }\n\n  static void rec(int ind, int begin)\n  {\n    for (int i = begin; i < n; i++)\n    {\n      buf [ind] = i;\n      for (int j = 0; j <= ind; j++) Console.Write(\"{0, 2}\", buf [j]);\n      Console.WriteLine();\n      rec(ind + 1, buf [ind] + 1);\n    }\n  }\n}\n\n", "explain": "An alternative implementation for an arbitrary number of elements:\n\nNon-recursive version\n\nRecursive version\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "JavaScript", "code": "\nES5[edit]\nIteration[edit]\n\nWorks with: SpiderMonkey\nfunction powerset(ary) {\n    var ps = [[]];\n    for (var i=0; i < ary.length; i++) {\n        for (var j = 0, len = ps.length; j < len; j++) {\n            ps.push(ps[j].concat(ary[i]));\n        }\n    }\n    return ps;\n}\n\nvar res = powerset([1,2,3,4]);\n\nload('json2.js');\nprint(JSON.stringify(res));\n\n\nOutput:\n[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3],[4],[1,4],[2,4],[1,2,4],[3,4],[1,3,4],[2,3,4],[1,2,3,4]]\n\nFunctional composition[edit]\nTranslation of: Haskell\n(function () {\n\n   // translating:  powerset = foldr (\\x acc -> acc ++ map (x:) acc) [[]]\n\n    function powerset(xs) {\n        return xs.reduceRight(function (a, x) {\n            return a.concat(a.map(function (y) {\n                return [x].concat(y);\n            }));\n        }, [[]]);\n    }\n\n\n    // TEST\n    return {\n        '[1,2,3] ->': powerset([1, 2, 3]),\n        'empty set ->': powerset([]),\n        'set which contains only the empty set ->': powerset([[]])\n    }\n\n})();\n\n\nOutput:\n{\n \"[1,2,3] ->\":[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]],\n \"empty set ->\":[[]],\n \"set which contains only the empty set ->\":[[], [[]]]\n}\n\nES6[edit]\n(() => {\n    'use strict';\n\n    // powerset\u00a0:: [a] -> [[a]]\n    const powerset = xs =>\n        xs.reduceRight((a, x) => [...a, ...a.map(y => [x, ...y])], [\n            []\n        ]);\n\n\n    // TEST\n    return {\n        '[1,2,3] ->': powerset([1, 2, 3]),\n        'empty set ->': powerset([]),\n        'set which contains only the empty set ->': powerset([\n            []\n        ])\n    };\n})()\n\n\nOutput:\n{\"[1,2,3] ->\":[[], [3], [2], [2, 3], [1], [1, 3], [1, 2], [1, 2, 3]], \n\"empty set ->\":[[]], \n\"set which contains only the empty set ->\":[[], [[]]]}\n\n", "explain": "Uses a JSON stringifier from http://www.json.org/js.html\n\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "PHP", "code": "\n<?php\nfunction get_subset($binary, $arr) {\n  // based on true/false values in $binary array, include/exclude\n  // values from $arr\n  $subset = array();\n  foreach (range(0, count($arr)-1) as $i) {\n    if ($binary[$i]) {\n      $subset[] = $arr[count($arr) - $i - 1];\n    } \n  }\n  return $subset;\n}\n\nfunction print_array($arr) {\n  if (count($arr) > 0) {\n    echo join(\" \", $arr);\n  } else {\n    echo \"(empty)\";\n  }\n  echo '<br>';\n}\n\nfunction print_power_sets($arr) {\n  echo \"POWER SET of [\" . join(\", \", $arr) . \"]<br>\";\n  foreach (power_set($arr) as $subset) {\n    print_array($subset);\n  }\n}\n  \nfunction power_set($arr) {  \n  $binary = array();\n  foreach (range(1, count($arr)) as $i) {\n    $binary[] = false;\n  }\n  $n = count($arr);\n  $powerset = array();\n  \n  while (count($binary) <= count($arr)) {\n    $powerset[] = get_subset($binary, $arr);\n    $i = 0;\n    while (true) {\n      if ($binary[$i]) {\n        $binary[$i] = false;\n        $i += 1;\n      } else {\n        $binary[$i] = true;\n        break;\n      }\n    }\n    $binary[$i] = true;\n  }\n  \n  return $powerset;\n}\n \nprint_power_sets(array());\nprint_power_sets(array('singleton'));\nprint_power_sets(array('dog', 'c', 'b', 'a'));\n?>\n\n\nOutput:\nPOWER SET of []\nPOWER SET of [singleton]\n(empty)\nsingleton\nPOWER SET of [dog, c, b, a]\n(empty)\na\nb\na b\nc\na c\nb c\na b c\ndog\na dog\nb dog\na b dog\nc dog\na c dog\nb c dog\na b c dog\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "MATLAB", "code": "\n\nfunction pset = powerset(theSet)\n\n    pset = cell(size(theSet)); %Preallocate memory\n\n    %Generate all numbers from 0 to 2^(num elements of the set)-1\n    for i = ( 0:(2^numel(theSet))-1 )\n       \n        %Convert i into binary, convert each digit in binary to a boolean\n        %and store that array of booleans\n        indicies = logical(bitget( i,(1:numel(theSet)) )); \n        \n        %Use the array of booleans to extract the members of the original\n        %set, and store the set containing these members in the powerset\n        pset(i+1) = {theSet(indicies)};\n       \n    end\n    \nend\n\n\npowerset({{}})\n\nans = \n\n     {}    {1x1 cell} %This is the same as { {},{{}} }\n\n\npowerset({{1,2},3})\n\nans = \n\n    {1x0 cell}    {1x1 cell}    {1x1 cell}    {1x2 cell} %This is the same as { {},{{1,2}},{3},{{1,2},3} }\n\n", "explain": "Sets are not an explicit data type in MATLAB, but cell arrays can be used for the same purpose. In fact, cell arrays have the benefit of containing any kind of data structure. So, this powerset function will work on a set of any type of data structure, without the need to overload any operators.\nSample Usage:\nPowerset of the set of the empty set.\nPowerset of { {1,2},3 }.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Go", "code": "\n\npackage main\n\nimport (\n    \"fmt\"\n    \"strconv\"\n    \"strings\"\n)\n\n// types needed to implement general purpose sets are element and set\n\n// element is an interface, allowing different kinds of elements to be\n// implemented and stored in sets.\ntype elem interface {\n    // an element must be distinguishable from other elements to satisfy\n    // the mathematical definition of a set.  a.eq(b) must give the same\n    // result as b.eq(a).\n    Eq(elem) bool\n    // String result is used only for printable output.  Given a, b where\n    // a.eq(b), it is not required that a.String() == b.String().\n    fmt.Stringer\n}\n\n// integer type satisfying element interface\ntype Int int\n\nfunc (i Int) Eq(e elem) bool {\n    j, ok := e.(Int)\n    return ok && i == j\n}\n\nfunc (i Int) String() string {\n    return strconv.Itoa(int(i))\n}\n\n// a set is a slice of elem's.  methods are added to implement\n// the element interface, to allow nesting.\ntype set []elem\n\n// uniqueness of elements can be ensured by using add method\nfunc (s *set) add(e elem) {\n    if !s.has(e) {\n        *s = append(*s, e)\n    }\n}\n\nfunc (s *set) has(e elem) bool {\n    for _, ex := range *s {\n        if e.Eq(ex) {\n            return true\n        }\n    }\n    return false\n}\n\nfunc (s set) ok() bool {\n    for i, e0 := range s {\n        for _, e1 := range s[i+1:] {\n            if e0.Eq(e1) {\n                return false\n            }\n        }\n    }\n    return true\n}\n\n// elem.Eq\nfunc (s set) Eq(e elem) bool {\n    t, ok := e.(set)\n    if !ok {\n        return false\n    }\n    if len(s) != len(t) {\n        return false\n    }\n    for _, se := range s {\n        if !t.has(se) {\n            return false\n        }\n    }\n    return true\n}\n\n// elem.String\nfunc (s set) String() string {\n    if len(s) == 0 {\n        return \"\u2205\"\n    }\n    var buf strings.Builder\n    buf.WriteRune('{')\n    for i, e := range s {\n        if i > 0 {\n            buf.WriteRune(',')\n        }\n        buf.WriteString(e.String())\n    }\n    buf.WriteRune('}')\n    return buf.String()\n}\n\n// method required for task\nfunc (s set) powerSet() set {\n    r := set{set{}}\n    for _, es := range s {\n        var u set\n        for _, er := range r {\n            er := er.(set)\n            u = append(u, append(er[:len(er):len(er)], es))\n        }\n        r = append(r, u...)\n    }\n    return r\n}\n\nfunc main() {\n    var s set\n    for _, i := range []Int{1, 2, 2, 3, 4, 4, 4} {\n        s.add(i)\n    }\n    fmt.Println(\"      s:\", s, \"length:\", len(s))\n    ps := s.powerSet()\n    fmt.Println(\"   \ud835\udc77(s):\", ps, \"length:\", len(ps))\n\n    fmt.Println(\"\\n(extra credit)\")\n    var empty set\n    fmt.Println(\"  empty:\", empty, \"len:\", len(empty))\n    ps = empty.powerSet()\n    fmt.Println(\"   \ud835\udc77(\u2205):\", ps, \"len:\", len(ps))\n    ps = ps.powerSet()\n    fmt.Println(\"\ud835\udc77(\ud835\udc77(\u2205)):\", ps, \"len:\", len(ps))\n\n    fmt.Println(\"\\n(regression test for earlier bug)\")\n    s = set{Int(1), Int(2), Int(3), Int(4), Int(5)}\n    fmt.Println(\"      s:\", s, \"length:\", len(s), \"ok:\", s.ok())\n    ps = s.powerSet()\n    fmt.Println(\"   \ud835\udc77(s):\", \"length:\", len(ps), \"ok:\", ps.ok())\n    for _, e := range ps {\n        if !e.(set).ok() {\n            panic(\"invalid set in ps\")\n        }\n    }\n}\n\n\nOutput:\n      s: {1,2,3,4} length: 4\n   \ud835\udc77(s): {\u2205,{1},{2},{1,2},{3},{1,3},{2,3},{1,2,3},{4},{1,4},{2,4},{1,2,4},{3,4},{1,3,4},{2,3,4},{1,2,3,4}} length: 16\n\n(extra credit)\n  empty: \u2205 len: 0\n   \ud835\udc77(\u2205): {\u2205} len: 1\n\ud835\udc77(\ud835\udc77(\u2205)): {\u2205,{\u2205}} len: 2\n\n(regression test for earlier bug)\n      s: {1,2,3,4,5} length: 5 ok: true\n   \ud835\udc77(s): length: 32 ok: true\n\n", "explain": "No native set type in Go.  While the associative array trick mentioned in the task description works well in Go in most situations, it does not work here because we need sets of sets, and converting a general set to a hashable value for a map key is non-trivial.\nInstead, this solution uses a simple (non-associative) slice as a set representation.  To ensure uniqueness, the element interface requires an equality method, which is used by the\nset add method.  Adding elements with the add method ensures the uniqueness property.\nWhile the \"add\" and \"has\" methods make a usable set type, the power set method implemented here computes a result directly without using the add method.  The algorithm ensures that the result will be a valid set as long as the input is a valid set.  This allows the more efficient append function to be used.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Delphi", "code": "\nLibrary:  System.SysUtils\nTranslation of: C#\nprogram Power_set;\n\n{$APPTYPE CONSOLE}\n\nuses\n  System.SysUtils;\n\nconst\n  n = 4;\n\nvar\n  buf: TArray<Integer>;\n\nprocedure rec(ind, bg: Integer);\nbegin\n  for var i := bg to n - 1 do\n  begin\n    buf[ind] := i;\n    for var j := 0 to ind do\n      write(buf[j]: 2);\n    writeln;\n    rec(ind + 1, buf[ind] + 1);\n  end;\nend;\n\nbegin\n  SetLength(buf, n);\n  rec(0,0);\n  {$IFNDEF UNIX}readln;{$ENDIF}\nend.\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Ruby", "code": "\n# Based on http://johncarrino.net/blog/2006/08/11/powerset-in-ruby/ \n# See the link if you want a shorter version. \n# This was intended to show the reader how the method works. \nclass Array\n  # Adds a power_set method to every array, i.e.: [1, 2].power_set\n  def power_set\n    \n    # Injects into a blank array of arrays.\n    # acc is what we're injecting into\n    # you is each element of the array\n    inject([[]]) do |acc, you|\n      ret = []             # Set up a new array to add into\n      acc.each do |i|      # For each array in the injected array,\n        ret << i           # Add itself into the new array\n        ret << i + [you]   # Merge the array with a new array of the current element\n      end\n      ret       # Return the array we're looking at to inject more.\n    end\n    \n  end\n  \n  # A more functional and even clearer variant.\n  def func_power_set\n    inject([[]]) { |ps,item|    # for each item in the Array\n      ps +                      # take the powerset up to now and add\n      ps.map { |e| e + [item] } # it again, with the item appended to each element\n    }\n  end\nend\n\n#A direct translation of the \"power array\" version above\nrequire 'set'\nclass Set\n  def powerset \n    inject(Set[Set[]]) do |ps, item| \n      ps.union ps.map {|e| e.union (Set.new [item])}\n    end\n  end\nend\n\np [1,2,3,4].power_set\np %w(one two three).func_power_set\n\np Set[1,2,3].powerset\n\nOutput:\n[[], [4], [3], [3, 4], [2], [2, 4], [2, 3], [2, 3, 4], [1], [1, 4], [1, 3], [1, 3, 4], [1, 2], [1, 2, 4], [1, 2, 3], [1, 2, 3, 4]]\n[[], [\"one\"], [\"two\"], [\"one\", \"two\"], [\"three\"], [\"one\", \"three\"], [\"two\", \"three\"], [\"one\", \"two\", \"three\"]]\n#<Set: {#<Set: {}>, #<Set: {1}>, #<Set: {2}>, #<Set: {1, 2}>, #<Set: {3}>, #<Set: {1, 3}>, #<Set: {2, 3}>, #<Set: {1, 2, 3}>}>\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Rust", "code": "\n\nuse std::collections::BTreeSet;\n\nfn powerset<T: Ord + Clone>(mut set: BTreeSet<T>) -> BTreeSet<BTreeSet<T>> {\n    if set.is_empty() {\n        let mut powerset = BTreeSet::new();\n        powerset.insert(set);\n        return powerset;\n    }\n    // Access the first value. This could be replaced with `set.pop_first().unwrap()`\n    // But this is an unstable feature \n    let entry = set.iter().nth(0).unwrap().clone(); \n    set.remove(&entry);\n    let mut powerset = powerset(set);\n    for mut set in powerset.clone().into_iter() {\n        set.insert(entry.clone());\n        powerset.insert(set);\n    }\n    powerset\n}\n\nfn main() {\n    let set = (1..5).collect();\n    let set = powerset(set);\n    println!(\"{:?}\", set);\n\n    let set = [\"a\", \"b\", \"c\", \"d\"].iter().collect();\n    let set = powerset(set);\n    println!(\"{:?}\", set);\n}\n\nOutput:\n{{}, {1}, {1, 2}, {1, 2, 3}, {1, 2, 3, 4}, {1, 2, 4}, {1, 3}, {1, 3, 4}, {1, 4}, {2}, {2, 3}, {2, 3, 4}, {2, 4}, {3}, {3, 4}, {4}}\n{{}, {\"a\"}, {\"a\", \"b\"}, {\"a\", \"b\", \"c\"}, {\"a\", \"b\", \"c\", \"d\"}, {\"a\", \"b\", \"d\"}, {\"a\", \"c\"}, {\"a\", \"c\", \"d\"}, {\"a\", \"d\"}, {\"b\"}, {\"b\", \"c\"}, {\"b\", \"c\", \"d\"}, {\"b\", \"d\"}, {\"c\"}, {\"c\", \"d\"}, {\"d\"}}\n\n\n", "explain": "This implementation consumes the input set, requires that the type T has a full order a.k.a implements the Ord trait and that T is clonable.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Swift", "code": "\nWorks with: Swift version Revision 4 - tested with Xcode 9.2 playground\nfunc powersetFrom<T>(_ elements: Set<T>) -> Set<Set<T>> {\n  guard elements.count > 0 else {\n    return [[]]\n  }\n  var powerset: Set<Set<T>> = [[]]\n  for element in elements {\n    for subset in powerset {\n      powerset.insert(subset.union([element]))\n    }\n  }\n  return powerset\n}\n\n// Example:\npowersetFrom([1, 2, 4])\n\nOutput:\n{\n  {2, 4}\n  {4, 1}\n  {4},\n  {2, 4, 1}\n  {2, 1}\n  Set([])\n  {1}\n  {2}\n}\n//Example:\npowersetFrom([\"a\", \"b\", \"d\"])\n\nOutput:\n{\n  {\"b\", \"d\"}\n  {\"b\"}\n  {\"d\"},\n  {\"a\"}\n  {\"b\", \"d\", \"a\"}\n  Set([])\n  {\"d\", \"a\"}\n  {\"b\", \"a\"}\n}\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "R", "code": "\nNon-recursive version[edit]\n\nfor each element in the set:\n\tfor each subset constructed so far:\n\t\tnew subset = (subset + element)\n\npowerset <- function(set){\n\tps <- list()\n\tps[[1]] <- numeric()\t\t\t\t\t\t#Start with the empty set.\n\tfor(element in set){\t\t\t\t\t\t#For each element in the set, take all subsets\n\t\ttemp <- vector(mode=\"list\",length=length(ps))\t\t#currently in \"ps\" and create new subsets (in \"temp\")\n\t\tfor(subset in 1:length(ps)){\t\t\t\t#by adding \"element\" to each of them.\n\t\t\ttemp[[subset]] = c(ps[[subset]],element)\n\t\t}\n\t\tps <- c(ps,temp)\t\t\t\t\t\t#Add the additional subsets (\"temp\") to \"ps\".\n\t}\n\tps\n}\n\npowerset(1:4)\n\nRecursive version[edit]\nLibrary: sets\n\nlibrary(sets)\n\nv <- (1:3)^2\nsv <- as.set(v)\n2^sv\n{{}, {1}, {4}, {9}, {1, 4}, {1, 9}, {4, 9}, {1, 4, 9}}\n\n\nl <- list(a=1, b=\"qwerty\", c=list(d=TRUE, e=1:3))\nsl <- as.set(l)\n2^sl\n{{}, {1}, {\"qwerty\"}, {<<list(2)>>}, {1, <<list(2)>>}, {\"qwerty\",\n 1}, {\"qwerty\", <<list(2)>>}, {\"qwerty\", 1, <<list(2)>>}}\n\n", "explain": "The conceptual basis for this algorithm is the following:\nThis method is much faster than a recursive method, though the speed is still O(2^n).\nThe list \"temp\" is a compromise between the speed costs of doing \narithmetic and of creating new lists (since R lists are immutable, \nappending to a list means actually creating a new list object). \nThus, \"temp\" collects new subsets that are later added to the power set. \nThis improves the speed by 4x compared to extending the list \"ps\" at every step.\nThe sets package includes a recursive method to calculate the power set. \nHowever, this method takes ~100 times longer than the non-recursive method above.\nAn example with a vector.\nAn example with a list.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Ada", "code": "\n\nwith Ada.Text_IO, Ada.Command_Line;\nuse Ada.Text_IO, Ada.Command_Line;\n \nprocedure powerset is\nbegin\n\tfor set in 0..2**Argument_Count-1 loop\n\t\tPut (\"{\");\t\t\t\n\t\tdeclare\n\t\t\tk : natural := set;\n\t\t\tfirst : boolean := true;\n\t\tbegin\n\t\t\tfor i in 1..Argument_Count loop\n\t\t\t\tif k mod 2 = 1 then\n\t\t\t\t\tPut ((if first then \"\" else \",\") & Argument (i));\n\t\t\t\t\tfirst := false;\n\t\t\t  \tend if;\n\t\t\t\tk := k / 2; -- we go to the next bit of \"set\"\n\t\t\tend loop;\n\t\tend;\n\t\tPut_Line(\"}\");\n\tend loop;\nend powerset;\n\n\n\nOutput:\n>./powerset a b c d\n{}\n{a}\n{b}\n{a,b}\n{c}\n{a,c}\n{b,c}\n{a,b,c}\n{d}\n{a,d}\n{b,d}\n{a,b,d}\n{c,d}\n{a,c,d}\n{b,c,d}\n{a,b,c,d}\n", "explain": "A solution (without recursion) that prints the power set of the n arguments passed by the command line. The idea is that the i'th bit of a natural between 0 and \n\n\n\n\n2\nn\n\n\u2212\n1\n\n\n{\\displaystyle 2^n-1}\n\n indicates whether or not we should put the i'th element of the command line inside the set.\n\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Julia", "code": "\nfunction powerset(x::Vector{T})::Vector{Vector{T}} where T\n    result = Vector{T}[[]]\n    for elem in x, j in eachindex(result)\n        push!(result, [result[j] ; elem])\n    end\n    result\nend\n\n\nOutput:\njulia> show(powerset([1,2,3]))\n[Int64[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\nNon-Mutating Solution[edit]\nusing Base.Iterators\n\nfunction bitmask(u, max_size)\n    res = BitArray(undef, max_size)\n    res.chunks[1] = u%UInt64\n    res\nend\n\nfunction powerset(input_collection::Vector{T})::Vector{Vector{T}} where T\n    num_elements = length(input_collection)\n    bitmask_map(x) = Iterators.map(y -> bitmask(y, num_elements), x)\n    getindex_map(x) = Iterators.map(y -> input_collection[y], x)\n\n    UnitRange(0, (2^num_elements)-1) |>\n        bitmask_map |>\n        getindex_map |>\n        collect\nend\n\n\nOutput:\njulia> show(powerset([1,2,3]))\n[Int64[], [1], [2], [1, 2], [3], [1, 3], [2, 3], [1, 2, 3]]\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "SAS", "code": "\noptions mprint mlogic symbolgen source source2;\n\n%macro SubSets (FieldCount = );\ndata _NULL_;\n\tFields = &FieldCount;\n\tSubSets = 2**Fields;\n\tcall symput (\"NumSubSets\", SubSets);\nrun;\n\n%put &NumSubSets;\n\ndata inital;\n\t%do j = 1 %to &FieldCount;\n\t\tF&j. = 1;\n\t%end;\nrun;\n\ndata SubSets;\n\tset inital;\n\tRowCount =_n_;\n\tcall symput(\"SetCount\",RowCount);\nrun;\n\n%put SetCount\u00a0;\n\n%do %while (&SetCount < &NumSubSets);\n\ndata loop;\n\t%do j=1 %to &FieldCount;\n\t\tif rand('GAUSSIAN') > rand('GAUSSIAN') then F&j. = 1;\n\t%end;\n\ndata SubSets_ \u00a0;\nset SubSets loop;\nrun;\n\nproc sort data=SubSets_  nodupkey;\n\tby F1 - F&FieldCount.;\nrun;\n\ndata Subsets;\n\tset SubSets_;\n\tRowCount =_n_;\nrun;\n\nproc sql noprint;\n\tselect max(RowCount) into :SetCount\n\tfrom SubSets;\nquit;\nrun; \n\n%end;\n%Mend SubSets;\n\n%SubSets(FieldCount = 5);\n\n\nOutput:\nObs\tF1\tF2\tF3\tF4\tF5\tRowCount\n1\t.\t.\t.\t.\t.\t1\n2\t.\t.\t.\t.\t1\t2\n3\t.\t.\t.\t1\t.\t3\n4\t.\t.\t.\t1\t1\t4\n5\t.\t.\t1\t.\t.\t5\n6\t.\t.\t1\t.\t1\t6\n7\t.\t.\t1\t1\t.\t7\n8\t.\t.\t1\t1\t1\t8\n9\t.\t1\t.\t.\t.\t9\n10\t.\t1\t.\t.\t1\t10\n11\t.\t1\t.\t1\t.\t11\n12\t.\t1\t.\t1\t1\t12\n13\t.\t1\t1\t.\t.\t13\n14\t.\t1\t1\t.\t1\t14\n15\t.\t1\t1\t1\t.\t15\n16\t.\t1\t1\t1\t1\t16\n17\t1\t.\t.\t.\t.\t17\n18\t1\t.\t.\t.\t1\t18\n19\t1\t.\t.\t1\t.\t19\n20\t1\t.\t.\t1\t1\t20\n21\t1\t.\t1\t.\t.\t21\n22\t1\t.\t1\t.\t1\t22\n23\t1\t.\t1\t1\t.\t23\n24\t1\t.\t1\t1\t1\t24\n25\t1\t1\t.\t.\t.\t25\n26\t1\t1\t.\t.\t1\t26\n27\t1\t1\t.\t1\t.\t27\n28\t1\t1\t.\t1\t1\t28\n29\t1\t1\t1\t.\t.\t29\n30\t1\t1\t1\t.\t1\t30\n31\t1\t1\t1\t1\t.\t31\n32\t1\t1\t1\t1\t1\t32\n\n", "explain": "You can then call the macro as:\nThe output will be the dataset SUBSETS \nand will have a 5 columns F1, F2, F3, F4, F5 and 32 columns, \none with each combination of 1 and missing values.  \n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Kotlin", "code": "\n// purely functional & lazy version, leveraging recursion and Sequences (a.k.a. streams)\nfun <T> Set<T>.subsets(): Sequence<Set<T>> =\n    when (size) {\n        0 -> sequenceOf(emptySet())\n        else -> {\n            val head = first()\n            val tail = this - head\n            tail.subsets() + tail.subsets().map { setOf(head) + it }\n        }\n    }\n\n// if recursion is an issue, you may change it this way:\n\nfun <T> Set<T>.subsets(): Sequence<Set<T>> = sequence {\n    when (size) {\n        0 -> yield(emptySet<T>())\n        else -> {\n            val head = first()\n            val tail = this@subsets - head\n            yieldAll(tail.subsets())\n            for (subset in tail.subsets()) {\n                yield(setOf(head) + subset)\n            }\n        }\n    }\n}\n\n\nOutput:\nPower set of setOf(1, 2, 3, 4) comprises:\n[]\n[4]\n[3]\n[3, 4]\n[2]\n[2, 4]\n[2, 3]\n[2, 3, 4]\n[1]\n[1, 4]\n[1, 3]\n[1, 3, 4]\n[1, 2]\n[1, 2, 4]\n[1, 2, 3]\n[1, 2, 3, 4]\n\nPower set of emptySet<Any>() comprises:\n[]\n\nPower set of setOf(emptySet<Any>()) comprises:\n[]\n[[]]\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Perl", "code": "\n\nModule: Algorithm::Combinatorics[edit]\n\nuse Algorithm::Combinatorics \"subsets\";\nmy @S = (\"a\",\"b\",\"c\");\nmy @PS;\nmy $iter = subsets(\\@S);\nwhile (my $p = $iter->next) {\n  push @PS, \"[@$p]\"\n}\nsay join(\"  \",@PS);\n\n\nOutput:\n[a b c]  [b c]  [a c]  [c]  [a b]  [b]  [a]  []\nModule: ntheory[edit]\nLibrary: ntheory\n\nuse ntheory \"forcomb\";\nmy @S = qw/a b c/;\nforcomb { print \"[@S[@_]]  \" } scalar(@S);\nprint \"\\n\";\n\n\nOutput:\n[]  [a]  [b]  [c]  [a b]  [a c]  [b c]  [a b c]\n\nuse ntheory \"forcomb\";\nmy @S = qw/a b c/;\nfor $k (0..@S) {\n  # Iterate over each $#S+1,$k combination.\n  forcomb { print \"[@S[@_]]  \" } @S,$k;\n}\nprint \"\\n\";\n\n\nOutput:\n[]  [a]  [b]  [c]  [a b]  [a c]  [b c]  [a b c]  \n\nuse ntheory \"vecextract\";\nmy @S = qw/a b c/;\nmy @PS = map { \"[\".join(\" \",vecextract(\\@S,$_)).\"]\" } 0..2**scalar(@S)-1;\nsay join(\"  \",@PS);\n\n\nOutput:\n[]  [a]  [b]  [a b]  [c]  [a c]  [b c]  [a b c]\nModule: Set::Object[edit]\n\nuse Set::Object qw(set);\n\nsub powerset {\n    my $p = Set::Object->new( set() );\n    foreach my $i (shift->elements) {\n        $p->insert( map { set($_->elements, $i) } $p->elements );\n    }\n    return $p;\n}\n\nmy $set = set(1, 2, 3);\nmy $powerset = powerset($set);\n\nprint $powerset->as_string, \"\\n\";\n\n\nOutput:\nSet::Object(Set::Object() Set::Object(1 2 3) Set::Object(1 2) Set::Object(1 3) Set::Object(1) Set::Object(2 3) Set::Object(2) Set::Object(3))\nSimple custom hash-based set type[edit]\n\npackage Set {\n    sub new       { bless { map {$_ => undef} @_[1..$#_] }, shift; }\n    sub elements  { sort keys %{shift()} }\n    sub as_string { 'Set(' . join(' ', sort keys %{shift()}) . ')' }\n    # ...more set methods could be defined here...\n}\n\n\nuse List::Util qw(reduce);\n\nsub powerset {\n    @{( reduce { [@$a, map { Set->new($_->elements, $b) } @$a ] }\n               [Set->new()], shift->elements )};\n}\n\nmy $set = Set->new(1, 2, 3);\nmy @subsets = powerset($set);\n\nprint $_->as_string, \"\\n\" for @subsets;\n\n\nOutput:\nSet()\nSet(1)\nSet(2)\nSet(1 2)\nSet(3)\nSet(1 3)\nSet(2 3)\nSet(1 2 3)\n\nArrays[edit]\n\nsub powerset {\n    @_ ? map { $_, [$_[0], @$_] } powerset(@_[1..$#_]) : [];\n}\n\n\nuse List::Util qw(reduce);\n\nsub powerset {\n    @{( reduce { [@$a, map([@$_, $b], @$a)] } [[]], @_ )}\n}\n\n\nmy @set = (1, 2, 3);\nmy @powerset = powerset(@set);\n\nsub set_to_string {\n    \"{\" . join(\", \", map { ref $_ ? set_to_string(@$_) : $_ } @_) . \"}\"\n}\n\nprint set_to_string(@powerset), \"\\n\";\n\n\nOutput:\n{{}, {1}, {2}, {1, 2}, {3}, {1, 3}, {2, 3}, {1, 2, 3}}\n\nLazy evaluation[edit]\n\nuse strict;\nuse warnings;\nsub powerset :prototype(&@) {\n    my $callback = shift;\n    my $bitmask = '';\n    my $bytes = @_/8;\n    {\n       my @indices = grep vec($bitmask, $_, 1), 0..$#_;\n       $callback->( @_[@indices] );\n       ++vec($bitmask, $_, 8) and last for 0 .. $bytes;\n       redo if @indices != @_;\n    }\n}\n\nprint \"powerset of empty set:\\n\";\npowerset { print \"[@_]\\n\" };\nprint \"powerset of set {1,2,3,4}:\\n\";\npowerset { print \"[@_]\\n\" } 1..4;\nmy $i = 0;\npowerset { ++$i } 1..9;\nprint \"The powerset of a nine element set contains $i elements.\\n\";\n\n\nOutput:\npowerset of empty set:\n[]\npowerset of set {1,2,3,4}:\n[]\n[1]\n[2]\n[1 2]\n[3]\n[1 3]\n[2 3]\n[1 2 3]\n[4]\n[1 4]\n[2 4]\n[1 2 4]\n[3 4]\n[1 3 4]\n[2 3 4]\n[1 2 3 4]  \nThe powerset of a nine element set contains 512 elements.\n\n\n\n", "explain": "Perl does not have a built-in set data-type. However, you can...\nThis module has an iterator over the power set.  Note that it does not enforce that the input array is a set (no duplication).  If each subset is processed immediately, this has an advantage of very low memory use.\nThe simplest solution is to use the one argument version of the combination iterator, which iterates over the power set.\nUsing the two argument version of the iterator gives a solution similar to the Raku and Python array versions.\nSimilar to the Pari/GP solution, one can also use vecextract with an integer mask to select elements.  Note that it does not enforce that the input array is a set (no duplication).  This also has low memory if each subset is processed immediately and the range is applied with a loop rather than a map.  A solution using vecreduce could be done identical to the array reduce solution shown later.\nThe CPAN module Set::Object provides a set implementation for sets of arbitrary objects, for which a powerset function could be defined and used like so:\nIt's also easy to define a custom type for sets of strings or numbers, \nusing a hash as the underlying representation (like the task description suggests):\n(Note: For a ready-to-use module that uses this approach, and comes with all the standard set methods that you would expect, see the CPAN module Set::Tiny)\nThe limitation of this approach is that only primitive strings/numbers are allowed as hash keys in Perl, so a Set of Set's cannot be represented, and the return value of our powerset function will thus have to be a list of sets rather than being a Set object itself.\nWe could implement the function as an imperative foreach loop similar to the Set::Object based solution above, but using list folding (with the help of Perl's List::Util core module) seems a little more elegant in this case:\nIf you don't actually need a proper set data-type that guarantees uniqueness of its elements, the simplest approach is to use arrays to store \"sets\" of items, in which case the implementation of the powerset function becomes quite short.\nRecursive solution:\nList folding solution:\nUsage & output:\nIf the initial set is quite large, constructing it's powerset all at once can consume lots of memory.\nIf you want to iterate through all of the elements of the powerset of a set, and don't mind each element being generated immediately before you process it, and being thrown away immediately after you're done with it, you can use vastly less memory.  This is similar to the earlier solutions using the Algorithm::Combinatorics and ntheory modules.\nThe following algorithm uses one bit of memory for every element of the original set (technically it uses several bytes per element with current versions of Perl).  This is essentially doing a vecextract operation by hand.\nThe technique shown above will work with arbitrarily large sets, and uses a trivial amount of memory.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\n+ (NSArray *)powerSetForArray:(NSArray *)array {\n\tUInt32 subsetCount = 1 << array.count;\n\tNSMutableArray *subsets = [NSMutableArray arrayWithCapacity:subsetCount];\n\tfor(int subsetIndex = 0; subsetIndex < subsetCount; subsetIndex++) {\n\t\tNSMutableArray *subset = [[NSMutableArray alloc] init];\n\t\tfor (int itemIndex = 0; itemIndex < array.count; itemIndex++) {\n\t\t\tif((subsetIndex >> itemIndex) & 0x1) {\n\t\t\t\t[subset addObject:array[itemIndex]];\n\t\t\t}\n\t\t}\t\t\n\t\t[subsets addObject:subset];\n\t}\n\treturn subsets;\n}\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Prolog", "code": "\nLogical (cut-free) Definition[edit]\n\npowerset(X,Y)\u00a0:- bagof( S, subseq(S,X), Y).\n\nsubseq( [], []).\nsubseq( [], [_|_]).\nsubseq( [X|Xs], [X|Ys] )\u00a0:- subseq(Xs, Ys).\nsubseq( [X|Xs], [_|Ys] )\u00a0:- append(_, [X|Zs], Ys), subseq(Xs, Zs).\n\nOutput:\n?- powerset([1,2,3], X).\nX = [[], [1], [1, 2], [1, 2, 3], [1, 3], [2], [2, 3], [3]].\n\n% Symbolic:\n?- powerset( [X,Y], S).\nS = [[], [X], [X, Y], [Y]].\n\n% In reverse:\n?- powerset( [X,Y], [[], [1], [1, 2], [2]] ).\nX = 1,\nY = 2.\nSingle-Functor Definition[edit]\npower_set( [], [[]]).\npower_set( [X|Xs], PS)\u00a0:-\n  power_set(Xs, PS1),\n  maplist( append([X]), PS1, PS2 ),\u00a0% i.e. prepend X to each PS1\n  append(PS1, PS2, PS).\n\nOutput:\n?- power_set([1,2,3,4,5,6,7,8], X), length(X,N), writeln(N).\n256\n\nConstraint Handling Rules[edit]\n\n:- use_module(library(chr)).\n\n:- chr_constraint chr_power_set/2, chr_power_set/1, clean/0.\n\nclean @ clean \\ chr_power_set(_) <=> true.\nclean @ clean <=> true.\n\nonly_one @ chr_power_set(A) \\ chr_power_set(A) <=> true.\n\n\ncreation @ chr_power_set([H | T], A) <=>\n           append(A, [H], B),\n\t   chr_power_set(T, A),\n           chr_power_set(T, B),\n\t   chr_power_set(B).\n\n\nempty_element @ chr_power_set([], _) <=> chr_power_set([]).\n\nOutput:\n\u00a0?- chr_power_set([1,2,3,4], []), findall(L, find_chr_constraint(chr_power_set(L)), LL), clean.\nLL = [[1],[1,2],[1,2,3],[1,2,3,4],[1,2,4],[1,3],[1,3,4],[1,4],[2],[2,3],[2,3,4],[2,4],[3],[3,4],[4],[]] .\n\n", "explain": "The predicate powerset(X,Y) defined here can be read as \"Y is the\npowerset of X\", it being understood that lists are used to represent sets.\nThe predicate subseq(X,Y) is true if and only if the list X is a subsequence of the list Y.\nThe definitions here are elementary, logical (cut-free), \nand efficient (within the class of comparably generic implementations).\nCHR is a programming language created by Professor Thom Fr\u00fchwirth.\nWorks with SWI-Prolog and module chr written by Tom Schrijvers and Jan Wielemaker.\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Lua", "code": "\n--returns the powerset of s, out of order.\nfunction powerset(s, start)\n  start = start or 1\n  if(start > #s) then return {{}} end\n  local ret = powerset(s, start + 1)\n  for i = 1, #ret do\n    ret[#ret + 1] = {s[start], unpack(ret[i])}\n  end\n  return ret\nend\n\n--non-recurse implementation\nfunction powerset(s)\n   local t = {{}}\n   for i = 1, #s do\n      for j = 1, #t do\n         t[#t+1] = {s[i],unpack(t[j])}\n      end\n   end\n   return t\nend\n\n--alternative, copied from the Python implementation\nfunction powerset2(s)\n  local ret = {{}}\n  for i = 1, #s do\n    local k = #ret\n    for j = 1, k do\n      ret[k + j] = {s[i], unpack(ret[j])}\n    end\n  end\n  return ret\nend\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Scala", "code": "\nimport scala.compat.Platform.currentTime\n\nobject Powerset extends App {\n  def powerset[A](s: Set[A]) = s.foldLeft(Set(Set.empty[A])) { case (ss, el) => ss ++ ss.map(_ + el)}\n\n  assert(powerset(Set(1, 2, 3, 4)) == Set(Set.empty, Set(1), Set(2), Set(3), Set(4), Set(1, 2), Set(1, 3), Set(1, 4),\n    Set(2, 3), Set(2, 4), Set(3, 4), Set(1, 2, 3), Set(1, 3, 4), Set(1, 2, 4), Set(2, 3, 4), Set(1, 2, 3, 4)))\n  println(s\"Successfully completed without errors. [total ${currentTime - executionStart} ms]\")\n}\n\ndef powerset[A](s: Set[A]) = (0 to s.size).map(s.toSeq.combinations(_)).reduce(_ ++ _).map(_.toSet)\n\ndef powerset[A](s: Set[A]) = {\n  def powerset_rec(acc: List[Set[A]], remaining: List[A]): List[Set[A]] = remaining match {\n    case Nil => acc\n    case head\u00a0:: tail => powerset_rec(acc ++ acc.map(_ + head), tail)\n  }\n  powerset_rec(List(Set.empty[A]), s.toList)\n}\n", "explain": "Another option that produces lazy sequence of the sets:\nA tail-recursive version:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "D", "code": "\n\nimport std.algorithm;\nimport std.range;\n\nauto powerSet(R)(R r)\n{\n\treturn\n\t\t(1L<<r.length)\n\t\t.iota\n\t\t.map!(i =>\n\t\t\tr.enumerate\n\t\t\t.filter!(t => (1<<t[0]) & i)\n\t\t\t.map!(t => t[1])\n\t\t);\n}\n\nunittest\n{\n\tint[] emptyArr;\n\tassert(emptyArr.powerSet.equal!equal([emptyArr]));\n\tassert(emptyArr.powerSet.powerSet.equal!(equal!equal)([[], [emptyArr]]));\n}\n\nvoid main(string[] args)\n{\n\timport std.stdio;\n\targs[1..$].powerSet.each!writeln;\n}\n\n\nimport std.range;\n\nstruct PowerSet(R)\n\tif (isRandomAccessRange!R)\n{\n\tR r;\n\tsize_t position;\n\n\tstruct PowerSetItem\n\t{\n\t\tR r;\n\t\tsize_t position;\n\n\t\tprivate void advance()\n\t\t{\n\t\t\twhile (!(position & 1))\n\t\t\t{\n\t\t\t\tr.popFront();\n\t\t\t\tposition >>= 1;\n\t\t\t}\n\t\t}\n\n\t\t@property bool empty() { return position == 0; }\n\t\t@property auto front()\n\t\t{\n\t\t\tadvance();\n\t\t\treturn r.front;\n\t\t}\n\t\tvoid popFront()\n\t\t{\n\t\t\tadvance();\n\t\t\tr.popFront();\n\t\t\tposition >>= 1;\n\t\t}\n\t}\n\n\t@property bool empty() { return position == (1 << r.length); }\n\t@property PowerSetItem front() { return PowerSetItem(r.save, position); }\n\tvoid popFront() { position++; }\n}\n\nauto powerSet(R)(R r) { return PowerSet!R(r); }\n\n\nOutput:\n$ rdmd powerset a b c\n[]\n[\"a\"]\n[\"b\"]\n[\"a\", \"b\"]\n[\"c\"]\n[\"a\", \"c\"]\n[\"b\", \"c\"]\n[\"a\", \"b\", \"c\"]\n\nAlternative: using folds[edit]\n\nIt isn't lazy (but it could be made so by implementing this as a generator)\n\nIt isn't lazy\nIt doesn't rely on integer bit fiddling, so it should work on arrays larger than size_t.\n// Haskell definition:\n// foldr f z []     = z\n// foldr f z (x:xs) = x `f` foldr f z xs\nS foldr(T, S)(S function(T, S) f, S z, T[] rest) {\n    return (rest.length == 0) ? z : f(rest[0], foldr(f, z, rest[1..$]));\n}\n\n// Haskell definition:\n//powerSet = foldr (\\x acc -> acc ++ map (x:) acc) [[]]\nT[][] powerset(T)(T[] set) {\n    import std.algorithm;\n    import std.array;\n    // Note: The types before x and acc aren't needed, so this could be made even more concise, but I think it helps \n    // to make the algorithm slightly clearer.\n    return foldr( (T x, T[][] acc) => acc ~ acc.map!(accx => x ~ accx).array , [[]], set );\n}\n\n", "explain": "This implementation defines a range which *lazily* enumerates the power set.\nAn alternative version, which implements the range construct from scratch:\n\nAn almost verbatim translation of the Haskell code in D.\nSince D doesn't foldr, I've also copied Haskell's foldr implementation here.\nMain difference from the Haskell:  \nMain differences from the version above:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Haskell", "code": "\nimport Data.Set\nimport Control.Monad\n\npowerset :: Ord a => Set a -> Set (Set a)\npowerset = fromList . fmap fromList . listPowerset . toList\n\nlistPowerset :: [a] -> [[a]]\nlistPowerset = filterM (const [True, False])\n\n\npowerset [] = [[]]\npowerset (head:tail) = acc ++ map (head:) acc where acc = powerset tail\n\n\npowerSet :: [a] -> [[a]]\npowerSet = foldr (\\x acc -> acc ++ map (x:) acc) [[]]\n\n\npowerSet :: [a] -> [[a]]\npowerSet = foldr ((mappend <*>) . fmap . (:)) (pure [])\n\n\n*Main> listPowerset [1,2,3]\n[[1,2,3],[1,2],[1,3],[1],[2,3],[2],[3],[]]\n*Main> powerset (Data.Set.fromList [1,2,3])\n{{},{1},{1,2},{1,2,3},{1,3},{2},{2,3},{3}}\n\nWorks with: GHC version 6.10\nPrelude> import Data.List\nPrelude Data.List> subsequences [1,2,3]\n[[],[1],[2],[1,2],[3],[1,3],[2,3],[1,2,3]]\n\n\nimport qualified Data.Set as Set\ntype Set=Set.Set\nunionAll :: (Ord a) => Set (Set a) -> Set a\nunionAll = Set.fold Set.union Set.empty\n\n--slift is the analogue of liftA2 for sets.\nslift :: (Ord a, Ord b, Ord c) => (a->b->c) -> Set a -> Set b -> Set c\nslift f s0 s1 = unionAll (Set.map (\\e->Set.map (f e) s1) s0)\n\n--a -> {{},{a}}\nmakeSet :: (Ord a) => a -> Set (Set a)\nmakeSet = (Set.insert Set.empty) . Set.singleton.Set.singleton\n\npowerSet :: (Ord a) => Set a -> Set (Set a)\npowerSet = (Set.fold (slift Set.union) (Set.singleton Set.empty)) . Set.map makeSet\n\n\nPrelude Data.Set> powerSet fromList [1,2,3]\nfromList [fromList [], fromList [1], fromList [1,2], fromList [1,2,3], fromList [1,3], fromList [2], fromList [2,3], fromList [3]]\n\n", "explain": "listPowerset describes the result as all possible (using the list monad) filterings (using filterM) of the input list, regardless (using const) of each item's value. powerset simply converts the input and output from lists to sets.\nAlternate Solution\nor\nwhich could also be understood, in point-free terms, as:\nExamples:\nAlternate solution\nA method using only set operations and set mapping is also possible. Ideally, Set would be defined as a Monad, but that's impossible given the constraint that the type of inputs to Set.map (and a few other functions) be ordered.\nUsage:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "VBScript", "code": "\nFunction Dec2Bin(n)\n\tq = n\n\tDec2Bin = \"\"\n\tDo Until q = 0\n\t\tDec2Bin = CStr(q Mod 2) & Dec2Bin\n\t\tq = Int(q / 2)\n\tLoop\n\tDec2Bin = Right(\"00000\" & Dec2Bin,6)\nEnd Function\n\nFunction PowerSet(s)\n\tarrS = Split(s,\",\")\n\tPowerSet = \"{\"\n\tFor i = 0 To 2^(UBound(arrS)+1)-1\n\t\tIf i = 0 Then\n\t\t\tPowerSet = PowerSet & \"{},\"\n\t\tElse\n\t\t\tbinS = Dec2Bin(i)\n\t\t\tPowerSet = PowerSet & \"{\"\n\t\t\tc = 0\n\t\t\tFor j = Len(binS) To 1 Step -1\n\t\t\t\tIf CInt(Mid(binS,j,1)) = 1 Then\n\t\t\t\t\tPowerSet = PowerSet & arrS(c) & \",\"\t\n\t\t\t\tEnd If\n\t\t\t\tc = c + 1\n\t\t\tNext\n\t\t\tPowerSet = Mid(PowerSet,1,Len(PowerSet)-1) & \"},\"\n\t\tEnd If\n\tNext\n\tPowerSet = Mid(PowerSet,1,Len(PowerSet)-1) & \"}\"\nEnd Function\n\nWScript.StdOut.Write PowerSet(\"1,2,3,4\")\n\nOutput:\n{{},{1},{2},{1,2},{3},{1,3},{2,3},{1,2,3},{4},{1,4},{2,4},{1,2,4},{3,4},{1,3,4},{2,3,4},{1,2,3,4}}\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Scheme", "code": "\nTranslation of: Common Lisp\n(define (power-set set)\n  (if (null? set)\n      '(())\n      (let ((rest (power-set (cdr set))))\n        (append (map (lambda (element) (cons (car set) element))\n                     rest)\n                rest))))\n\n(display (power-set (list 1 2 3)))\n(newline)\n\n(display (power-set (list \"A\" \"C\" \"E\")))\n(newline)\n\nOutput:\n((1 2 3) (1 2) (1 3) (1) (2 3) (2) (3) ())\n((A C E) (A C) (A E) (A) (C E) (C) (E) ())\n\nCall/cc generation:(define (power-set lst)\n  (define (iter yield)\n    (let recur ((a '()) (b lst))\n      (if (null? b) (set! yield\n\t\t      (call-with-current-continuation\n\t\t\t(lambda (resume)\n\t\t\t  (set! iter resume)\n\t\t\t  (yield a))))\n\t(begin (recur (append a (list (car b))) (cdr b))\n\t       (recur a (cdr b)))))\n\n   \u00a0;; signal end of generation\n    (yield 'end-of-seq))\n\n  (lambda () (call-with-current-continuation iter)))\n\n(define x (power-set '(1 2 3)))\n(let loop ((a (x)))\n  (if (eq? a 'end-of-seq) #f\n    (begin\n      (display a)\n      (newline)\n      (loop (x)))))\n\nOutput:\n(1 2)\n(1 3)\n(1)\n(2 3)\n(2)\n(3)\n()\nIterative:(define (power_set_iter set)\n  (let loop ((res '(())) (s set))\n    (if (empty? s)\n        res\n        (loop (append (map (lambda (i) (cons (car s) i)) res) res) (cdr s)))))\n\nOutput:\n'((e d c b a)\n  (e d c b)\n  (e d c a)\n  (e d c)\n  (e d b a)\n  (e d b)\n  (e d a)\n  (e d)\n  (e c b a)\n  (e c b)\n  (e c a)\n  (e c)\n  (e b a)\n  (e b)\n  (e a)\n  (e)\n  (d c b a)\n  (d c b)\n  (d c a)\n  (d c)\n  (d b a)\n  (d b)\n  (d a)\n  (d)\n  (c b a)\n  (c b)\n  (c a)\n  (c)\n  (b a)\n  (b)\n  (a)\n  ())\n\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "PowerShell", "code": "\nfunction power-set ($array) {\n    if($array) {\n        $n = $array.Count\n        function state($set, $i){  \n            if($i -gt -1) {\n                state $set ($i-1)\n                state ($set+@($array[$i])) ($i-1)   \n            } else {\n                \"$($set | sort)\"\n            }\n        }\n        $set = state @() ($n-1)\n        $power = 0..($set.Count-1) | foreach{@(0)}\n        $i = 0\n        $set | sort | foreach{$power[$i++] = $_.Split()}\n        $power | sort {$_.Count}\n    } else {@()}\n\n}\n$OFS = \" \"\n$setA = power-set  @(1,2,3,4)\n\"number of sets in setA: $($setA.Count)\"\n\"sets in setA:\"\n$OFS = \", \"\n$setA | foreach{\"{\"+\"$_\"+\"}\"} \n$setB = @()\n\"number of sets in setB: $($setB.Count)\"\n\"sets in setB:\"\n$setB | foreach{\"{\"+\"$_\"+\"}\"} \n$setC = @(@(), @(@()))\n\"number of sets in setC: $($setC.Count)\"\n\"sets in setC:\"\n$setC | foreach{\"{\"+\"$_\"+\"}\"} \n$OFS = \" \"\n\nnumber of sets in setA: 16\nsets in setA:\n{}\n{1}\n{2}\n{3}\n{4}\n{1, 2}\n{1, 3}\n{1, 4}\n{2, 3}\n{2, 4}\n{3, 4}\n{1, 2, 3}\n{1, 2, 4}\n{1, 3, 4}\n{2, 3, 4}\n{1, 2, 3, 4}\nnumber of sets in setB: 0\nsets in setB:\nnumber of sets in setC: 2\nsets in setC:\n{}\n{}\n\n", "explain": "Output:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Logo", "code": "\nto powerset :set\n  if empty? :set [output [[]]]\n  localmake \"rest powerset butfirst :set\n  output sentence  map [sentence first :set\u00a0?] :rest  :rest\nend\n\nshow powerset [1 2 3]\n[[1 2 3] [1 2] [1 3] [1] [2 3] [2] [3] []]\n", "explain": ""}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "ColdFusion", "code": "\n\npublic array function powerset(required array data)\n{\n  var ps = [\"\"];\n  var d = arguments.data;\n  var lenData = arrayLen(d);\n  var lenPS = 0;\n  for (var i=1; i LTE lenData; i++)\n  {\n    lenPS = arrayLen(ps);\n    for (var j = 1; j LTE lenPS; j++)\n    {\n      arrayAppend(ps, listAppend(ps[j], d[i]));\n    }\n  }\n  return ps;\n}\n\nvar res = powerset([1,2,3,4]);\n\n\nOutput:\n[\"\",\"1\",\"2\",\"1,2\",\"3\",\"1,3\",\"2,3\",\"1,2,3\",\"4\",\"1,4\",\"2,4\",\"1,2,4\",\"3,4\",\"1,3,4\",\"2,3,4\",\"1,2,3,4\"]\n", "explain": "Port from the JavaScript version, \ncompatible with ColdFusion 8+ or Railo 3+\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "ABAP", "code": "\n\nreport z_powerset.\n\ninterface set.\n  methods:\n    add_element\n      importing\n        element_to_be_added type any\n      returning\n        value(new_set)      type ref to set,\n\n    remove_element\n      importing\n        element_to_be_removed type any\n      returning\n        value(new_set)        type ref to set,\n\n    contains_element\n      importing\n        element_to_be_found type any\n      returning\n        value(contains)     type abap_bool,\n\n    get_size\n      returning\n        value(size) type int4,\n\n    is_equal\n      importing\n        set_to_be_compared_with type ref to set\n      returning\n        value(equal)            type abap_bool,\n\n    get_elements\n      exporting\n        elements type any table,\n\n    stringify\n      returning\n        value(stringified_set) type string.\nendinterface.\n\n\nclass string_set definition.\n  public section.\n    interfaces:\n      set.\n\n\n    methods:\n      constructor\n        importing\n          elements type stringtab optional,\n\n      build_powerset\n        returning\n          value(powerset) type ref to string_set.\n\n\n  private section.\n    data elements type stringtab.\nendclass.\n\n\nclass string_set implementation.\n  method constructor.\n    loop at elements into data(element).\n      me->set~add_element( element ).\n    endloop.\n  endmethod.\n\n\n  method set~add_element.\n    if not line_exists( me->elements[ table_line = element_to_be_added ] ).\n      append element_to_be_added to me->elements.\n    endif.\n\n    new_set = me.\n  endmethod.\n\n\n  method set~remove_element.\n    if line_exists( me->elements[ table_line = element_to_be_removed ] ).\n      delete me->elements where table_line = element_to_be_removed.\n    endif.\n\n    new_set = me.\n  endmethod.\n\n\n  method set~contains_element.\n    contains = cond abap_bool(\n      when line_exists( me->elements[ table_line = element_to_be_found ] )\n      then abap_true\n      else abap_false ).\n  endmethod.\n\n\n  method set~get_size.\n    size = lines( me->elements ).\n  endmethod.\n\n\n  method set~is_equal.\n    if set_to_be_compared_with->get_size( ) ne me->set~get_size( ).\n      equal = abap_false.\n\n      return.\n    endif.\n\n    loop at me->elements into data(element).\n      if not set_to_be_compared_with->contains_element( element ).\n        equal = abap_false.\n\n        return.\n      endif.\n    endloop.\n\n    equal = abap_true.\n  endmethod.\n\n\n  method set~get_elements.\n    elements = me->elements.\n  endmethod.\n\n\n  method set~stringify.\n    stringified_set = cond string(\n      when me->elements is initial\n      then `\u2205`\n      when me->elements eq value stringtab( ( `\u2205` ) )\n      then `{ \u2205 }`\n      else reduce string(\n        init result = `{ `\n        for element in me->elements\n        next result = cond string(\n          when element eq ``\n          then |{ result }\u2205, |\n          when strlen( element ) eq 1 and element ne `\u2205`\n          then |{ result }{ element }, |\n          else |{ result }\\{{ element }\\}, | ) ) ).\n\n    stringified_set = replace(\n      val = stringified_set\n      regex = `, $`\n      with = ` }`).\n  endmethod.\n\n\n  method build_powerset.\n    data(powerset_elements) = value stringtab( ( `` ) ).\n\n    loop at me->elements into data(element).\n      do lines( powerset_elements ) times.\n        if powerset_elements[ sy-index ] ne `\u2205`.\n          append |{ powerset_elements[ sy-index ] }{ element }| to powerset_elements.\n        else.\n          append element to powerset_elements.\n        endif.\n      enddo.\n    endloop.\n\n    powerset = new string_set( powerset_elements ).\n  endmethod.\nendclass.\n\n\nstart-of-selection.\n  data(set1) = new string_set( ).\n  data(set2) = new string_set( ).\n  data(set3) = new string_set( ).\n\n  write: |\ud835\udc77( { set1->set~stringify( ) } ) -> { set1->build_powerset( )->set~stringify( ) }|, /.\n\n  set2->set~add_element( `\u2205` ).\n  write: |\ud835\udc77( { set2->set~stringify( ) } ) -> { set2->build_powerset( )->set~stringify( ) }|, /.\n\n  set3->set~add_element( `1` )->add_element( `2` )->add_element( `3` )->add_element( `3` )->add_element( `4`\n    )->add_element( `4` )->add_element( `4` ).\n  write: |\ud835\udc77( { set3->set~stringify( ) } ) -> { set3->build_powerset( )->set~stringify( ) }|, /.\n\n\nOutput:\n\ud835\udc77( \u2205 ) -> { \u2205 }\n\n\ud835\udc77( { \u2205 } ) -> { \u2205, {\u2205} }\n\n\ud835\udc77( { 1, 2, 3, 4 } ) -> { \u2205, 1, 2, {12}, 3, {13}, {23}, {123}, 4, {14}, {24}, {124}, {34}, {134}, {234}, {1234} }\n\n", "explain": "This works for ABAP Version 7.40 and above\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "F#", "code": "\n\nlet subsets xs = List.foldBack (fun x rest -> rest @ List.map (fun ys -> x::ys) rest) xs [[]]\n\n\nlet rec pow = \n    function\n    | [] -> [[]]\n    | x::xs -> [for i in pow xs do yield! [i;x::i]]\n\n", "explain": "almost exact copy of OCaml version\nalternatively with list comprehension\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "Groovy", "code": "\n\ndef powerSetRec(head, tail) {\n    if (!tail) return [head]\n    powerSetRec(head, tail.tail()) + powerSetRec(head + [tail.head()], tail.tail())\n}\n\ndef powerSet(set) { powerSetRec([], set as List) as Set}\n\n\ndef vocalists = [ 'C', 'S', 'N', 'Y' ] as Set\nprintln vocalists\nprintln powerSet(vocalists)\n\n\nOutput:\n[C, S, N, Y]\n[[], [Y], [N], [N, Y], [S], [S, Y], [S, N], [S, N, Y], [C], [C, Y], [C, N], [C, N, Y], [C, S], [C, S, Y], [C, S, N], [C, S, N, Y]]\n\n", "explain": "Builds on the Combinations solution. Sets are not a \"natural\" collection type in Groovy. Lists are much more richly supported. Thus, this solution is liberally sprinkled with coercion from Set to List and from List to Set.\nTest program:\n"}, {"task_name": "Power set", "task_url": "https://rosettacode.org/wiki/Power_set", "task_cat": "Recursion", "lang": "AWK", "code": "\ncat power_set.awk\n#!/usr/local/bin/gawk -f\n\n# User defined function\nfunction tochar(l,n,\tr) {\n while (l) { n--; if (l%2 != 0) r = r sprintf(\" %c \",49+n); l = int(l/2) }; return r\n}\n\n# For each input\n{ for (i=0;i<=2^NF-1;i++) if (i == 0) printf(\"empty\\n\"); else printf(\"(%s)\\n\",tochar(i,NF)) }\n\n\nOutput:\n$ gawk -f power_set.awk \n1 2 3 4\nempty\n( 4 )\n( 3 )\n( 4  3 )\n( 2 )\n( 4  2 )\n( 3  2 )\n( 4  3  2 )\n( 1 )\n( 4  1 )\n( 3  1 )\n( 4  3  1 )\n( 2  1 )\n( 4  2  1 )\n( 3  2  1 )\n( 4  3  2  1 )\n\n", "explain": ""}]