[{"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Python", "code": "\n\nwhile(True):\n      x = input(\"What is your age? \")\n      print(x)\n\n\nmy_file = open(filename, 'r')\ntry:\n    for line in my_file:\n        pass # process line, includes newline\nfinally:\n    my_file.close()\n\n\n#from __future__ import with_statement  # is not needed in Python 3.6\n\nwith open(filename, 'r') as f:\n    for line in f:\n        pass # process line, includes newline\n\n\nline = my_file.readline() # returns a line from the file\nlines = my_file.readlines() # returns a list of the rest of the lines from the file\n\n\nimport fileinput\nfor line in fileinput.input():\n    pass # process line, includes newline\n\n\n", "explain": "To create a Python3 input loop use python's `input()` function.\nPython file objects can be iterated like lists:\nOne can open a new stream for read and have it automatically close when done, with a new \"with\" statement:\nYou can also get lines manually from a file:\nThis does not mix well with the iteration, however.\n\nWhen you want to read from stdin, or (multiple) filenames are given on the command line:\nThe fileinput module can also do inplace file editing, follow line counts, and the name of the current file being read etc.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "C", "code": "\n\n#include <stdlib.h>\n#include <stdio.h>\n\nchar *get_line(FILE* fp)\n{\n\tint len = 0, got = 0, c;\n\tchar *buf = 0;\n\n\twhile ((c = fgetc(fp)) != EOF) {\n\t\tif (got + 1 >= len) {\n\t\t\tlen *= 2;\n\t\t\tif (len < 4) len = 4;\n\t\t\tbuf = realloc(buf, len);\n\t\t}\n\t\tbuf[got++] = c;\n\t\tif (c == '\\n') break;\n\t}\n\tif (c == EOF && !got) return 0;\n\n\tbuf[got++] = '\\0';\n\treturn buf;\n}\n\nint main()\n{\n\tchar *s;\n\twhile ((s = get_line(stdin))) {\n\t\tprintf(\"%s\",s);\n\t\tfree(s);\n\t}\n\treturn 0;\n}\n\n", "explain": "Reads arbitrarily long line each time and return a null-terminated string.  \nCaller is responsible for freeing the string.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "C++", "code": "\n\n#include <istream>\n#include <string>\n#include <vector>\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n\n// word by word\ntemplate<class OutIt>\nvoid read_words(std::istream& is, OutIt dest)\n{\n  std::string word;\n  while (is >> word)\n  {\n    // send the word to the output iterator\n    *dest = word;\n  }\n}\n\n// line by line:\ntemplate<class OutIt>\nvoid read_lines(std::istream& is, OutIt dest)\n{\n  std::string line;\n  while (std::getline(is, line))\n  {\n    // store the line to the output iterator\n    *dest = line;\n  }\n}\n\nint main()\n{\n  // 1) sending words from std. in std. out (end with Return)\n  read_words(std::cin, \n             std::ostream_iterator<std::string>(std::cout, \" \"));\n\n  // 2) appending lines from std. to vector (end with Ctrl+Z)\n  std::vector<std::string> v;\n  read_lines(std::cin, std::back_inserter(v));\n  \n  return 0;\n}\n\n\ntemplate<class OutIt>\nvoid read_words(std::istream& is, OutIt dest)\n{\n    typedef std::istream_iterator<std::string> InIt;\n    std::copy(InIt(is), InIt(),\n              dest);\n}\n\nnamespace detail \n{\n    struct ReadableLine : public std::string \n    { \n        friend std::istream & operator>>(std::istream & is, ReadableLine & line)\n        {   \n            return std::getline(is, line);\n        }\n    };\n}\n\ntemplate<class OutIt>\nvoid read_lines(std::istream& is, OutIt dest)\n{\n    typedef std::istream_iterator<detail::ReadableLine> InIt;\n    std::copy(InIt(is), InIt(),\n              dest);\n}\n\n", "explain": "The following functions send the words resp. lines \nto a generic output iterator.\nAn alternate way to read words or lines is to use istream iterators:\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Java", "code": "\n\nimport java.io.InputStream;\nimport java.util.Scanner;\n\npublic class InputLoop {\n    public static void main(String args[]) {\n        // To read from stdin:\n        InputStream source = System.in;\n\n        /*\n        Or, to read from a file:\n        InputStream source = new FileInputStream(filename);\n\n        Or, to read from a network stream:\n        InputStream source = socket.getInputStream();\n        */\n\n        Scanner in = new Scanner(source);\n        while(in.hasNext()){\n            String input = in.next(); // Use in.nextLine() for line-by-line reading\n\n            // Process the input here. For example, you could print it out:\n            System.out.println(input);\n        }\n    }\n}\n\n\nimport java.io.BufferedReader;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.io.Reader;\n\npublic class InputLoop {\n    public static void main(String args[]) {\n        // To read from stdin:\n        Reader reader = new InputStreamReader(System.in);\n\n        /*\n        Or, to read from a file:\n        Reader reader = new FileReader(filename);\n\n        Or, to read from a network stream:\n        Reader reader = new InputStreamReader(socket.getInputStream());\n        */\n\n        try {\n            BufferedReader inp = new BufferedReader(reader);\n            while(inp.ready()) {\n                int input = inp.read(); // Use in.readLine() for line-by-line\n\n                // Process the input here. For example, you can print it out.\n                System.out.println(input);\n            }\n        }  catch (IOException e) {\n            // There was an input error.\n        }\n    }\n}\n\n", "explain": "Some people prefer Scanner or BufferedReader, so a way with each is presented.\nOr\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "C#", "code": "\nusing System;\nusing System.IO;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        // For stdin, you could use\n        // new StreamReader(Console.OpenStandardInput(), Console.InputEncoding)\n\n        using (var b = new StreamReader(\"file.txt\"))\n        {\n            string line;\n            while ((line = b.ReadLine()) != null)\n                Console.WriteLine(line);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "JavaScript", "code": "\nWorks with: SpiderMonkey\nWorks with: OSSP js\n\n$ js -e 'while (line = readline()) { do_something_with(line); }' < inputfile\nWorks with: JScript\n\nvar text_stream = WScript.StdIn;\nvar i = 0;\n\nwhile ( ! text_stream.AtEndOfStream ) {\n    var line = text_stream.ReadLine();\n    // do something with line\n    WScript.echo(++i + \": \" + line);\n}\n\n", "explain": "These implementations of JavaScript define a readline() function, so:\nAs above, this operates on standard input\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Visual_Basic_.NET", "code": "\n\nSub Consume(ByVal stream As IO.StreamReader)\n    Dim line = stream.ReadLine\n    Do Until line Is Nothing\n        Console.WriteLine(line)\n        line = stream.ReadLine\n    Loop\nEnd Sub\n", "explain": "This reads a stream line by line, outputing each line to the screen.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "PHP", "code": "\n$fh = fopen($filename, 'r');\nif ($fh) {\n    while (!feof($fh)) {\n        $line = rtrim(fgets($fh)); # removes trailing newline\n        # process $line\n    }\n    fclose($fh);\n}\n\n\n$lines = file($filename);\n\n\n$contents = file_get_contents($filename);\n\n", "explain": "Or you can get an array of all the lines in the file:\nOr you can get the entire file as a string:\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nprogram BasicInputLoop\n\n  implicit none\n\n  integer, parameter        :: in = 50, &\n                               linelen = 1000\n  integer                   :: ecode\n  character(len=linelen)    :: l\n\n  open(in, file=\"afile.txt\", action=\"read\", status=\"old\", iostat=ecode)\n  if ( ecode == 0 ) then\n     do\n        read(in, fmt=\"(A)\", iostat=ecode) l\n        if ( ecode /= 0 ) exit\n        write(*,*) trim(l)\n     end do\n     close(in)\n  end if\n\nend program BasicInputLoop\n\n", "explain": "The code read line-by-line, but the maximum length of the line is limited (by a parameter)\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Go", "code": "\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"io\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\tin := bufio.NewReader(os.Stdin)\n\tfor {\n\t\ts, err := in.ReadString('\\n')\n\t\tif err != nil {\n\t\t\t// io.EOF is expected, anything else\n\t\t\t// should be handled/reported\n\t\t\tif err != io.EOF {\n\t\t\t\tlog.Fatal(err)\n\t\t\t}\n\t\t\tbreak\n\t\t}\n\t\t// Do something with the line of text\n\t\t// in string variable s.\n\t\t_ = s\n\t}\n}\n\n\npackage main\n\nimport (\n\t\"bufio\"\n\t\"log\"\n\t\"os\"\n)\n\nfunc main() {\n\ts := bufio.NewScanner(os.Stdin)\n\t// Select the split function, other ones are available\n\t// in bufio or you can provide your own.\n\ts.Split(bufio.ScanWords)\n\tfor s.Scan() {\n\t\t// Get and use the next 'token'\n\t\tasBytes := s.Bytes() // Bytes does no alloaction\n\t\tasString := s.Text() // Text returns a newly allocated string\n\t\t_, _ = asBytes, asString\n\t}\n\tif err := s.Err(); err != nil {\n\t\t// Handle/report any error (EOF will not be reported)\n\t\tlog.Fatal(err)\n\t}\n}\n\n", "explain": "The following reads a line at a time from stdin.\nOr, using bufio.Scanner you can read\nline at a time,\nword at a time,\nbyte or Unicode code point at a time,\nor by any custom \"split function\".\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program inputLoop.s   */\n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n\n/*********************************************/\n/*constantes                                */\n/********************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ READ,   3\n.equ WRITE,  4\n.equ OPEN,   5\n.equ CLOSE,  6\n.equ CREATE,  8\n/*  file */\n.equ O_RDONLY,    0x0        @ open for reading only\n\n.equ BUFSIZE,  10000\n.equ LINESIZE, 100\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessErreur:     .asciz \"Erreur ouverture fichier input.\\n\"\nszMessErreur1:    .asciz \"Erreur fermeture fichier.\\n\"\nszMessErreur2:    .asciz \"Erreur lecture fichier.\\n\"\nszCarriageReturn: .asciz \"\\n\"\nszMessEndLine:    .asciz \"<<<<<< End line.\\n\"\n\nszNameFileInput:    .asciz \"input.txt\"\n\n/*******************************************/\n/* DONNEES NON INITIALISEES                */\n/*******************************************/ \n.bss\nsBuffer:      .skip BUFSIZE \nsBufferWord:  .skip LINESIZE\n/**********************************************/\n/* -- Code section                            */\n/**********************************************/\n.text            \n.global main    \nmain:\n    /* open file */\n    ldr r0,iAdrszNameFileInput      @ file name\n    mov r1,#O_RDONLY                @  flags   \n    mov r2,#0                       @ mode \n    mov r7,#OPEN                    @ call system OPEN\n    svc #0 \n    cmp r0,#0                       @ open error\u00a0?\n    ble erreur\n    /* read file  */\n    mov r9,r0                       @ save File Descriptor\n    ldr r1,iAdrsBuffer              @ buffer address \n    mov r2,#BUFSIZE                 @ buffer size\n    mov r7, #READ                   @ call system  READ\n    svc 0 \n    cmp r0,#0                       @ read error\u00a0?\n    ble erreur2\n    mov r2,r0                       @ length read characters\n    /* buffer analyze   */\n    ldr r3,iAdrsBuffer              @ buffer address\n    ldr r5,iAdrsBufferWord          @ buffer address\n    mov r7,#0                       @ word byte counter\n    mov r4,#0                       @ byte counter\n1:\n    ldrb r6,[r3,r4]                 @ load byte buffer\n    cmp r6,#' '                     @ space\u00a0?\n    moveq r8,#0                     @ yes\n    beq 2f\n    cmp r6,#0xA                     @ end line\u00a0?\n    moveq r8,#1\n    beq 2f\n    cmp r6,#0xD                     @ end line\u00a0?\n    beq 3f\n    strb r6,[r5,r7]                 @ store byte\n    add r7,#1                       @ increment word byte counter\n    b 4f\n2:                                  @ word end\n    cmp r7,#0\n    beq 3f\n    mov r6,#0                       @ store 0 final\n    strb r6,[r5,r7]\n    mov r0,r5                       @ display word\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n    mov r7,#0                       @ raz word byte counter \n3:\n    cmp r8,#1                       @ end line\u00a0?\n    bne 4f\n    ldr r0,iAdrszMessEndLine\n    bl affichageMess\n4:       \n    add r4,#1                       @ increment read buffer counter\n    cmp r4,r2                       @ end bytes\u00a0?\n    blt 1b                          @ no -> loop \n\n4:\n    /* close imput file */\n    mov r0,r9                       @ Fd\n    mov r7, #CLOSE                  @ call system CLOSE\n    svc 0 \n    cmp r0,#0                       @ close error\u00a0?\n    blt erreur1\n\n\n    mov r0,#0     @ return code OK\n    b 100f\nerreur:\n    ldr r1,iAdrszMessErreur \n    bl displayError\n    mov r0,#1       @ error return code\n    b 100f\nerreur1:    \n    ldr r1,iAdrszMessErreur1   \n    bl displayError\n    mov r0,#1       @ error return code\n    b 100f\nerreur2:\n    ldr r1,iAdrszMessErreur2   \n    bl displayError\n    mov r0,#1       @ error return code\n    b 100f\n\n\n100:        @ end program\n    mov r7, #EXIT \n    svc 0 \niAdrszNameFileInput:      .int szNameFileInput\niAdrszMessErreur:         .int szMessErreur\niAdrszMessErreur1:        .int szMessErreur1\niAdrszMessErreur2:        .int szMessErreur2\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessEndLine:        .int szMessEndLine\niAdrsBuffer:              .int sBuffer\niAdrsBufferWord:          .int sBufferWord\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nword1\nword2\nword3\n<<<<<< End line.\nLine2w1\nline2w2\n<<<<<< End line.\nOneword\n<<<<<< End line.\n<<<<<< End line.\nAfterEmptyLine\n<<<<<< End line.\n\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Delphi", "code": "\nprogram InputLoop;\n\n{$APPTYPE CONSOLE}\n\nuses SysUtils, Classes;\n\nvar\n  lReader: TStreamReader; // Introduced in Delphi XE\nbegin\n  lReader := TStreamReader.Create('input.txt', TEncoding.Default);\n  try\n    while lReader.Peek >= 0 do\n      Writeln(lReader.ReadLine);\n  finally\n    lReader.Free;\n  end;\nend.\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Ruby", "code": "\n\nstream = $stdin\nstream.each do |line|\n  # process line\nend\n\n\n# Create an array of lengths of every line.\nary = stream.map {|line| line.chomp.length}\n\n\n", "explain": "Ruby input streams are IO objects. One can use IO#each or IO#each_line to iterate lines from a stream.\nIO objects are also Enumerable (like Array or Range), and have methods like Enumerable#map, which call IO#each to loop through lines from a stream.\nTo open a new stream for reading, see Read a file line by line#Ruby.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Rust", "code": "\n use std::io::{self, BufReader, Read, BufRead};\nuse std::fs::File;\n\nfn main() {\n    print_by_line(io::stdin())\n        .expect(\"Could not read from stdin\");\n\n    File::open(\"/etc/fstab\")\n        .and_then(print_by_line)\n        .expect(\"Could not read from file\");\n}\n\nfn print_by_line<T: Read>(reader: T) -> io::Result<()> {\n    let buffer = BufReader::new(reader);\n    for line in buffer.lines() {\n        println!(\"{}\", line?)\n    }\n    Ok(())\n}\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "R", "code": "\n\nlines <- readLines(\"file.txt\")\n\n", "explain": "Note that read.csv and read.table provide alternatives for files with 'dataset' style contents.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "COBOL", "code": "\nWorks with: GNU Cobol version 2.0\nWorks with: Visual COBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. input-loop.\n       \n       ENVIRONMENT DIVISION.\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n           SELECT in-stream ASSIGN TO KEYBOARD *> or any other file/stream\n               ORGANIZATION LINE SEQUENTIAL\n               FILE STATUS in-stream-status.\n               \n       DATA DIVISION.\n       FILE SECTION.\n       FD  in-stream.\n       01  stream-line                 PIC X(80).\n       \n       WORKING-STORAGE SECTION.\n       01  in-stream-status            PIC 99.\n           88  end-of-stream           VALUE 10.\n       \n       PROCEDURE DIVISION.\n           OPEN INPUT in-stream\n           \n           PERFORM UNTIL EXIT\n               READ in-stream\n                   AT END\n                       EXIT PERFORM\n               END-READ\n               DISPLAY stream-line\n           END-PERFORM\n           \n           CLOSE in-stream\n           .\n       END PROGRAM input-loop.\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Ada", "code": "\n\nwith Ada.Text_Io; use Ada.Text_Io;\n\nprocedure Read_Stream is\n   Line : String(1..10);\n   Length : Natural;\nbegin\n   while not End_Of_File loop\n      Get_Line(Line, Length); -- read up to 10 characters at a time\n      Put(Line(1..Length));\n      -- The current line of input data may be longer than the string receiving the data.\n      -- If so, the current input file column number will be greater than 0\n      -- and the extra data will be unread until the next iteration.\n      -- If not, we have read past an end of line marker and col will be 1\n      if Col(Current_Input) = 1 then\n         New_Line;\n      end if;\n   end loop;\nend Read_Stream;\n\n", "explain": "This example reads in a text stream from standard input line by line \nand writes the output to standard output.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Julia", "code": "\n\nstream = IOBuffer(\"1\\n2\\n3\\n4\\n\\n6\")\n\nwhile !eof(stream)\n    line = readline(stream)\n    println(line)\nend\n\n\nOutput:\n1\n2\n3\n4\n\n6\n", "explain": "We create a text stream and read the lines from the stream one by one, printing them on screen.\nNote that the lines end by a newline, except the last one. The ending newlines are part of the strings returned by the function readline. Once the end of the stream is reached, readline returns an empty string.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Kotlin", "code": "\n// version 1.1\n\nimport java.util.*\n\nfun main(args: Array<String>) {\n    println(\"Keep entering text or the word 'quit' to end the program:\")\n    val sc = Scanner(System.`in`)\n    val words = mutableListOf<String>()\n    while (true) {\n        val input: String = sc.next()\n        if (input.trim().toLowerCase() == \"quit\") {\n            if (words.size > 0) println(\"\\nYou entered the following words:\\n${words.joinToString(\"\\n\")}\")\n            return\n        }\n        words.add(input)\n    }\n}\n\n\n\nOutput:\nKeep entering text or the word 'quit' to end the program:\nThe quick brown fox\njumps over the lazy dog\nquit\n\nYou entered the following words:\nThe\nquick\nbrown\nfox\njumps\nover\nthe\nlazy\ndog\n\n", "explain": "Sample input/output:\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Perl", "code": "\n\nopen FH, \"< $filename\" or die \"can't open file: $!\";\nwhile (my $line = <FH>) {\n    chomp $line; # removes trailing newline\n    # process $line\n}\nclose FH or die \"can't close file: $!\";\n\n\n@lines = <FH>;\n\n\nwhile (<>) {\n    # $_ contains a line\n}\n\n\n$ seq 5 | perl -pe '$_ = \"Hello $_\"'\nHello 1\nHello 2\nHello 3\nHello 4\nHello 5\n$ seq 5 | perl -ne 'print \"Hello $_\"'\nHello 1\nHello 2\nHello 3\nHello 4\nHello 5\n", "explain": "The angle brackets operator ( <...> ) reads one line at a time from a filehandle in scalar context:\nOr you can get a list of all lines when you use it in list context:\nOr a simpler program for lines of files entered as command line arguments or standard input:\nInvoking perl with the -p or -n option implies the above loop, executing its code once per input line, with the line stored in $_. -p will print $_ automatically at the end of each iteration, -n will not.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Lua", "code": "\nlines = {}\nstr = io.read()\nwhile str do\n    table.insert(lines,str)\n    str = io.read()\nend\n\nVia generic for loop[edit]\n\nlines = {}\n\nfor line in io.lines() do\n    table.insert(lines, line) -- add the line to the list of lines\nend\n\n", "explain": "Reads line-by-line via an iterator (from stdin). Substitute io.lines() with io.open(filename, \"r\"):lines() to read from a file.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Scala", "code": "\nLibrary: Scala\nWorks with: Scala version 2.10.3\n  scala.io.Source.fromFile(\"input.txt\").getLines().foreach {\n    line => ... }\n\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "D", "code": "\nvoid main() {\n    import std.stdio;\n\n    immutable fileName = \"input_loop1.d\";\n\n    foreach (const line; fileName.File.byLine) {\n        pragma(msg, typeof(line)); // Prints: const(char[])\n        // line is a transient slice, so if you need to\n        // retain it for later use, you have to .dup or .idup it.\n        line.writeln; // Do something with each line.\n    }\n\n    // Keeping the line terminators:\n    foreach (const line; fileName.File.byLine(KeepTerminator.yes)) {\n        // line is a transient slice.\n        line.writeln;\n    }\n\n    foreach (const string line; fileName.File.lines) {\n        // line is a transient slice.\n        line.writeln;\n    }\n}\n\nLibrary: Tango\nimport tango.io.Console;\nimport tango.text.stream.LineIterator;\n\nvoid main (char[][] args) {\n    foreach (line; new LineIterator!(char)(Cin.input)) {\n        // do something with each line\n    }\n}\n\nLibrary: Tango\nimport tango.io.Console;\nimport tango.text.stream.SimpleIterator;\n\nvoid main (char[][] args) {\n    foreach (word; new SimpleIterator!(char)(\" \", Cin.input)) {\n        // do something with each word\n    }\n}\n\n\n", "explain": "Note that foreach variables 'line' and 'word' are transient slices. If you need to retain them for later use, you should .dup them.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Haskell", "code": "\n\nimport System.IO\n\nreadLines :: Handle -> IO [String]\nreadLines h = do\n  s <- hGetContents h\n  return $ lines s\n\nreadWords :: Handle -> IO [String]\nreadWords h = do\n  s <- hGetContents h\n  return $ words s\n\n", "explain": "The whole contents of a file can be read lazily. The standard functions lines and words convert that lazily into the lists of lines resp. words. Usually, one wouldn't use extra routines for that, but just use readFile and then put 'lines' or words somewhere in the next processing step.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "VBScript", "code": "\nfilepath = \"SPECIFY PATH TO TEXT FILE HERE\"\n\nSet objFSO = CreateObject(\"Scripting.FileSystemObject\")\nSet objInFile = objFSO.OpenTextFile(filepath,1,False,0)\n\nDo Until objInFile.AtEndOfStream\n\tline = objInFile.ReadLine\n\tWScript.StdOut.WriteLine line\nLoop\n\nobjInFile.Close\nSet objFSO = Nothing\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "TypeScript", "code": "\n#!/usr/bin/env node\n\nimport EventEmitter from 'events';\n\nfunction stdinLineByLine() {\n  const stdin = new EventEmitter();\n  let buff = '';\n  let lines;\n\n  process.stdin\n    .on('data', (data) => {\n      buff += data;\n      lines = buff.split(/\\r\\n|\\n/);\n      buff = lines.pop();\n      lines.forEach((line) => stdin.emit('line', line));\n    })\n    .on('end', () => {\n      if (buff.length > 0) stdin.emit('line', buff);\n    });\n\n  return stdin;\n}\n\nconst stdin = stdinLineByLine();\nstdin.on('line', console.log);\n", "explain": ""}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "PowerShell", "code": "\nGet-Content c:\\file.txt |\n    ForEach-Object {\n        $_\n    }\n\n\nForEach-Object -inputobject (get-content c:\\file.txt) {$_}\n\n", "explain": "or\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Logo", "code": "\n\nreadline - returns a line as a list of words\nreadword - returns a line as a single word, or an empty list if it reached the end of file\nreadrawline - returns a line as a single word, with no characters escaped\nwhile [not eof?] [print readline]\n", "explain": "There are several words which will return a line of input.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "F#", "code": "\n\nlet lines_of_file file =\n  seq { use stream = System.IO.File.OpenRead file\n        use reader = new System.IO.StreamReader(stream)\n        while not reader.EndOfStream do\n          yield reader.ReadLine() }\n\n\n", "explain": "Using a sequence expression:\nThe file is reopened every time the sequence is traversed and lines are read on-demand so this can handle arbitrarily-large files.\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "Groovy", "code": "\n\ndef lineMap = [:]\nSystem.in.eachLine { line, i ->\n    lineMap[i] = line\n}\nlineMap.each { println it }\n\n\nTest:\n$ groovy -e 'def lineMap = [:]\n> System.in.eachLine { line, i ->\n>     lineMap[i] = line\n> }\n> lineMap.each { println it }' <<EOF\n> \n> Whose woods these are I think I know\n> His house is in the village tho'\n> He will not see me stopping here\n> To watch his woods fill up with snow\n> EOF\n\nOutput:\n1=\n2=Whose woods these are I think I know\n3=His house is in the village tho'\n4=He will not see me stopping here\n5=To watch his woods fill up with snow\n", "explain": "Solution:\n"}, {"task_name": "Input loop", "task_url": "https://rosettacode.org/wiki/Input_loop", "task_cat": "Streams", "lang": "AWK", "code": "\n\n{ print $0 }\n\n\n1\n\n", "explain": "This just reads lines from stdin and prints them until EOF is read.\nor, more idiomatic:\n"}]