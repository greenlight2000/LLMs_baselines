[{"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Python", "code": "\n\nimport time\n\ndef counter():\n    n = 0\n    t1 = time.time()\n    while True:\n        try:\n            time.sleep(0.5)\n            n += 1\n            print n\n        except KeyboardInterrupt, e:\n            print 'Program has run for %5.3f seconds.' % (time.time() - t1)\n            break\n\ncounter()\n\n\nimport time\n\ndef intrptWIN():\n   procDone = False\n   n = 0\n\n   while not procDone:\n      try:\n         time.sleep(0.5)\n         n += 1\n         print n\n      except KeyboardInterrupt, e:\n         procDone = True\n\nt1 = time.time()\nintrptWIN()\ntdelt = time.time() - t1\nprint 'Program has run for %5.3f seconds.' % tdelt\n\n\nimport signal, time, threading\ndone = False\nn = 0\n\ndef counter():\n   global n, timer\n   n += 1\n   print n\n   timer = threading.Timer(0.5, counter)\n   timer.start()\n\ndef sigIntHandler(signum, frame):\n   global done\n   timer.cancel()\n   done = True\n\ndef intrptUNIX():\n   global timer\n   signal.signal(signal.SIGINT, sigIntHandler)\n\n   timer = threading.Timer(0.5, counter)\n   timer.start()\n   while not done:\n      signal.pause()\n\nt1 = time.time()\nintrptUNIX()\ntdelt = time.time() - t1\nprint 'Program has run for %5.3f seconds.' % tdelt\n\n\nimport time, signal\n\nclass WeAreDoneException(Exception):\n    pass\n\ndef sigIntHandler(signum, frame):\n    signal.signal(signal.SIGINT, signal.SIG_DFL) # resets to default handler\n    raise WeAreDoneException\n\nt1 = time.time()\n\ntry:\n    signal.signal(signal.SIGINT, sigIntHandler)\n    n = 0\n    while True:\n        time.sleep(0.5)\n        n += 1\n        print n\nexcept WeAreDoneException:\n    pass\n\ntdelt = time.time() - t1\nprint 'Program has run for %5.3f seconds.' % tdelt\n\n", "explain": "Simple version\nThe following example should work on all platforms.\nThere is a signal module in the standard distribution \nthat accomodates the UNIX type signal mechanism. \nHowever the pause() mechanism is not implemented on Windows versions.\nHow about this one? It should work on all platforms; \nand it does show how to install a signal handler:\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "C", "code": "\nLibrary: POSIX\n\n#include <stdio.h>\n#include <stdlib.h>\t// for exit()\n#include <signal.h>\n#include <time.h>\t// for clock()\n#include <unistd.h>\t// for POSIX usleep()\n\nvolatile sig_atomic_t gotint = 0;\n\nvoid handleSigint() {\n    /*\n     * Signal safety: It is not safe to call clock(), printf(),\n     * or exit() inside a signal handler. Instead, we set a flag.\n     */\n    gotint = 1;\n}\n \nint main() {\n    clock_t startTime = clock();\n    signal(SIGINT, handleSigint);\n    int i=0;\n    for (;;) {\n        if (gotint)\n            break;\n        usleep(500000);\n        if (gotint)\n            break;\n\tprintf(\"%d\\n\", ++i);\n    }\n    clock_t endTime = clock();\n    double td = (endTime - startTime) / (double)CLOCKS_PER_SEC;\n    printf(\"Program has run for %5.3f seconds\\n\", td);\n    return 0;\n}\n\n\nOutput:\n1\n2\n3\nProgram has run for 1.953 seconds\n\n", "explain": "Standard C's sleep() only provides one-second resolution, so the POSIX usleep() function is used here. (POSIX is not needed for the actual signal handling part.)\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "C++", "code": "\nTranslation of: C\n#include <chrono>\n#include <csignal>\n#include <ctime>\n#include <iostream>\n#include <thread>\n\nvolatile sig_atomic_t gotint = 0;\n\nvoid handler(int signum) {\n\t// Set a flag for handling the signal, as other methods like printf are not safe here\n\tgotint = 1;\n}\n\nint main() {\n\tusing namespace std;\n\n\tsignal(SIGINT, handler);\n\n\tint i = 0;\n\tclock_t startTime = clock();\n\twhile (true) {\n\t\tif (gotint) break;\n\t\tstd::this_thread::sleep_for(std::chrono::milliseconds(500));\n\t\tif (gotint) break;\n\t\tcout << ++i << endl;\n\t}\n\tclock_t endTime = clock();\n\n\tdouble dt = (endTime - startTime) / (double)CLOCKS_PER_SEC;\n\tcout << \"Program has run for \" << dt << \" seconds\" << endl;\n\n\treturn 0;\n}\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Java", "code": "\n\nimport sun.misc.Signal;\nimport sun.misc.SignalHandler;\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n            public void handle(Signal sig) {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n                System.exit(0);\n            }\n        });\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n\n\npublic class ExampleSignalHandler {\n    public static void main(String... args) throws InterruptedException {\n        final long start = System.nanoTime();\n        Runtime.getRuntime().addShutdownHook(new Thread(new Runnable() {\n            public void run() {\n                System.out.format(\"\\nProgram execution took %f seconds\\n\", (System.nanoTime() - start) / 1e9f);\n            }\n        }));\n        int counter = 0;\n        while(true) {\n            System.out.println(counter++);\n            Thread.sleep(500);\n        }\n    }\n}\n\n\nOutput:\nnode hsignal.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n4.5 seconds elapsed\n\n", "explain": "Use of sun.misc.SignalHandler allows one to specify which signal to catch, though is unsupported and potentially not available in all JVMs\nOr one can use a generic shutdown hook as follows, though a reference to the particular signal is not available.\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "C#", "code": "\n\nusing System; //DateTime, Console, Environment classes\nclass Program\n{\n    static DateTime start;\n    static void Main(string[] args)\n    {\n        start = DateTime.Now;\n        //Add event handler for Ctrl+C command\n        Console.CancelKeyPress += new ConsoleCancelEventHandler(Console_CancelKeyPress);\n        int counter = 0;\n        while (true)\n        {\n            Console.WriteLine(++counter);\n            System.Threading.Thread.Sleep(500);\n        }\n    }\n    static void Console_CancelKeyPress(object sender, ConsoleCancelEventArgs e)\n    {\n        var end = DateTime.Now;\n        Console.WriteLine(\"This program ran for {0:000.000} seconds.\", (end - start).TotalMilliseconds / 1000);\n        Environment.Exit(0);\n    }\n}\n\n", "explain": "Signals in C# are called events, and are handled by attaching event handler functions to the event, which are called when the event is triggered.\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "JavaScript", "code": "\n\n(function(){\n    var count=0\n        secs=0\n    \n    var i= setInterval( function (){\n        count++\n        secs+=0.5\n        console.log(count)\n    }, 500);\n    \n    process.on('SIGINT', function() {\n        clearInterval(i)\n        console.log(secs+' seconds elapsed');\n        process.exit()\n    });\n})();\n\n\nOutput:\nnode hsignal.js\n1\n2\n3\n4\n5\n6\n7\n8\n9\n4.5 seconds elapsed\n\n", "explain": "Based on NodeJS interpreter/engine\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Module1\n    Dim startTime As Date\n\n    Sub Main()\n        startTime = Date.Now\n        ' Add event handler for Cntrl+C command\n        AddHandler Console.CancelKeyPress, AddressOf Console_CancelKeyPress\n\n        Dim counter = 0\n        While True\n            counter += 1\n            Console.WriteLine(counter)\n            Threading.Thread.Sleep(500)\n        End While\n    End Sub\n\n    Sub Console_CancelKeyPress(sender As Object, e As ConsoleCancelEventArgs)\n        Dim stopTime = Date.Now\n        Console.WriteLine(\"This program ran for {0:000.000} seconds\", (stopTime - startTime).TotalMilliseconds / 1000)\n        Environment.Exit(0)\n    End Sub\n\nEnd Module\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "PHP", "code": "\nTranslation of: Perl\n<?php\ndeclare(ticks = 1);\n\n$start = microtime(true);\n\nfunction mySigHandler() {\n  global $start;\n  $elapsed = microtime(true) - $start;\n  echo \"Ran for $elapsed seconds.\\n\";\n  exit();\n}\n\npcntl_signal(SIGINT, 'mySigHandler');\n\nfor ($n = 0; ; usleep(500000)) // 0.5 seconds\n   echo ++$n, \"\\n\";\n?>\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "MATLAB", "code": "\n\nWorks with: MATLAB version 7.6 (R2008a) and later\nfunction sigintHandle\n    k = 1;\n    tic\n    catchObj = onCleanup(@toc);\n    while true\n        pause(0.5)\n        fprintf('%d\\n', k)\n        k = k+1;\n    end\nend\n\n\nOutput:\n>> sigintCleanup\n1\n2\n3\n4\n5\n6\nElapsed time is 3.348772 seconds.\n??? Operation terminated by user during ==> sigintHandle at 6\nWorks with: MATLAB version 6.1 (R12.1) and earlier\n\n\nThis example is untested. Please check that it's correct, debug it as necessary, and remove this message.\n\n\nfunction sigintHandle\n    k = 1;\n    tic\n    try\n        while true\n            pause(0.5)\n            fprintf('%d\\n', k)\n            k = k+1;\n        end\n    catch me\n        toc\n        rethrow me\n    end\nend\n\n", "explain": "MATLAB versions 6.5 (R13) and newer can no longer catch CTRL+C with a try-catch block. The onCleanup() function was introduced in version 7.6 (R2008a), possibly specifically for this situation. However, the designated onCleanup() function will execute no matter how the function ends (task completion, CTRL+C, exception), and CTRL+C will still cause an exception to be thrown and displayed.\n\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Fortran", "code": "\nWorks with: gfortran\n\nprogram signal_handling\n  use, intrinsic :: iso_fortran_env, only: atomic_logical_kind\n  implicit none\n\n  interface\n    integer(C_INT) function usleep(microseconds) bind(c)\n      use, intrinsic :: iso_c_binding, only: C_INT, C_INT32_T\n      integer(C_INT32_T), value :: microseconds\n    end function usleep\n  end interface\n\n  integer, parameter :: half_second = 500000\n  integer, parameter :: sigint = 2\n  integer, parameter :: sigquit = 3\n\n  logical(atomic_logical_kind) :: interrupt_received[*]\n  integer :: half_seconds\n  logical :: interrupt_received_ref\n\n  interrupt_received = .false.\n  half_seconds = 0\n\n  ! \"Install\" the same signal handler for both SIGINT and SIGQUIT.\n  call signal(sigint, signal_handler)\n  call signal(sigquit, signal_handler)\n\n  ! Indefinite loop (until one of the two signals are received).\n  do\n    if (usleep(half_second) == -1) &\n      print *, \"Call to usleep interrupted.\"\n\n    call atomic_ref(interrupt_received_ref, interrupt_received)\n    if (interrupt_received_ref) then\n      print \"(A,I0,A)\", \"Program ran for \", half_seconds / 2, \" second(s).\"\n      stop\n    end if\n\n    half_seconds = half_seconds + 1\n    print \"(I0)\", half_seconds\n  end do\n\ncontains\n\n  subroutine signal_handler(sig_num)\n    use, intrinsic :: iso_c_binding, only: C_INT\n    integer(C_INT), value, intent(in) :: sig_num\n    ! Must be declared with attribute `value` to force pass-by-value semantics\n    ! (what C uses by default).\n\n    select case (sig_num)\n      case (sigint)\n        print *, \"Received SIGINT.\"\n      case (sigquit)\n        print *, \"Received SIGQUIT.\"\n    end select\n\n    call atomic_define(interrupt_received, .true.)\n  end subroutine signal_handler\n\nend program signal_handling\n\n", "explain": "Must be compiled with the -fcoarray=single flag to enable use of atomic operations.\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"os\"\n    \"os/signal\"\n    \"time\"\n)\n\nfunc main() {\n    start := time.Now()\n    k := time.Tick(time.Second / 2)\n    sc := make(chan os.Signal, 1)\n    signal.Notify(sc, os.Interrupt)\n    for n := 1; ; {\n        // not busy waiting, this blocks until one of the two\n        // channel operations is possible\n        select {\n        case <-k:\n            fmt.Println(n)\n            n++\n        case <-sc:\n            fmt.Printf(\"Ran for %f seconds.\\n\",\n                time.Now().Sub(start).Seconds())\n            return\n        }\n    }\n}\n\n\nOutput:\n1\n2\n3\n^C\nRan for 1.804877 seconds.\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "X86_Assembly", "code": "\nWorks with: NASM version Linux\n\n%define sys_signal \t48\n%define SIGINT\t\t\t2\n%define sys_time\t13\n\nextern usleep\nextern printf\n\nsection .text\n\tglobal _start\n\t\n\t_sig_handler:\n\t\tmov ebx, end_time\n\t\tmov eax, sys_time\n\t\tint 0x80\n\t\tmov eax, dword [start_time]\n\t\tmov ebx, dword [end_time]\n\t\tsub ebx, eax\n\t\tmov ax, 100\n\t\tdiv ebx\n\t\tpush ebx\n\t\tpush p_time\n\t\tcall printf\n\t\tpush 0x1\n\t\tmov eax, 1\n\t\tpush eax\n\t\tint 0x80\n\t\tret\n\t\t\n\t_start:\n\t\tmov ebx, start_time\n\t\tmov eax, sys_time\n\t\tint 0x80\n\t\tmov ecx, _sig_handler\n\t\tmov ebx, SIGINT\n\t\tmov eax, sys_signal\n\t\tint 0x80\n\t\txor edi, edi\n\t\t.looper:\n\t\t\tpush 500000\n\t\t\tcall usleep\n\t\t\tpush edi\n\t\t\tpush p_cnt\n\t\t\tcall printf\n\t\t\tinc edi\n\t\tjmp .looper\n\t\t\nsection .data\np_time\tdb \"The program has run for %d seconds.\",13,10,0\np_cnt\t\tdb \"%d\",13,10,0\n\nsection .bss\nstart_time\tresd 1\nend_time\t\tresd 1\n\n", "explain": "Now, I realize linking to C libraries is somewhat cheating. \nIt is entirely possible to do this entirely in syscalls using sys_nanosleep/sys_write but that would require allot more work, \ndefinition of the timespec structure among other things. \n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Ruby", "code": "\nt1 = Time.now\n\ncatch :done do\n  Signal.trap('INT') do\n    Signal.trap('INT', 'DEFAULT') # reset to default\n    throw :done\n  end\n  n = 0\n  loop do\n    sleep(0.5)\n    n += 1\n    puts n\n  end\nend\n\ntdelt = Time.now - t1\nputs 'Program has run for %5.3f seconds.' % tdelt\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Rust", "code": "\n#[cfg(unix)]\nfn main() {\n    use std::sync::atomic::{AtomicBool, Ordering};\n    use std::thread;\n    use std::time::{Duration, Instant};\n\n    use libc::{sighandler_t, SIGINT};\n\n    // The time between ticks of our counter.\n    let duration = Duration::from_secs(1) / 2;\n\n    // \"SIGINT received\" global variable.\n    static mut GOT_SIGINT: AtomicBool = AtomicBool::new(false);\n\n    unsafe {\n        // Initially, \"SIGINT received\" is false.\n        GOT_SIGINT.store(false, Ordering::Release);\n        // Interrupt handler that handles the SIGINT signal\n        unsafe fn handle_sigint() {\n            // It is dangerous to perform any system calls in interrupts, so just set the atomic\n            // \"SIGINT received\" global to true when it arrives.\n            GOT_SIGINT.store(true, Ordering::Release);\n        }\n        // Make handle_sigint the signal handler for SIGINT.\n        libc::signal(SIGINT, handle_sigint as sighandler_t);\n    }\n\n    // Get the start time...\n    let start = Instant::now();\n\n    // Integer counter\n    let mut i = 0u32;\n\n    // Every `duration`...\n    loop {\n        thread::sleep(duration);\n\n        // Break if SIGINT was handled\n        if unsafe { GOT_SIGINT.load(Ordering::Acquire) } {\n            break;\n        }\n\n        // Otherwise, increment and display the integer and continue the loop.\n        i += 1;\n        println!(\"{}\", i);\n    }\n\n    // Get the elapsed time.\n    let elapsed = start.elapsed();\n\n    // Print the difference and exit\n    println!(\"Program has run for {} seconds\", elapsed.as_secs());\n}\n\n#[cfg(not(unix))]\nfn main() {\n    println!(\"Not supported on this platform\");\n}\n\n\n", "explain": "\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Swift", "code": "\nTranslation of: C\nimport Foundation\n\nlet startTime = NSDate()\nvar signalReceived: sig_atomic_t = 0\n\nsignal(SIGINT) { signal in signalReceived = 1 }\n\nfor var i = 0;; {\n    if signalReceived == 1 { break }\n    usleep(500_000)\n    if signalReceived == 1 { break }\n    print(++i)\n}\n\nlet endTime = NSDate()\nprint(\"Program has run for \\(endTime.timeIntervalSinceDate(startTime)) seconds\")\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "COBOL", "code": "\n\n       identification division.\n       program-id. signals.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n          88 signalled value 1.\n       01 half-seconds usage binary-long.\n       01 start-time   usage binary-c-long.\n       01 end-time     usage binary-c-long.\n       01 handler      usage program-pointer.\n       01 SIGINT       constant as 2.\n\n       procedure division.\n       call \"gettimeofday\" using start-time null\n       set handler to entry \"handle-sigint\"\n       call \"signal\" using by value SIGINT by value handler\n\n       perform until exit\n           if signalled then exit perform end-if\n           call \"CBL_OC_NANOSLEEP\" using 500000000\n           if signalled then exit perform end-if\n           add 1 to half-seconds\n           display half-seconds\n       end-perform\n\n       call \"gettimeofday\" using end-time null\n       subtract start-time from end-time\n       display \"Program ran for \" end-time \" seconds\"\n       goback.\n       end program signals.\n\n       identification division.\n       program-id. handle-sigint.\n       data division.\n       working-storage section.\n       01 signal-flag  pic 9 external.\n\n       linkage section.\n       01 the-signal   usage binary-long.\n\n       procedure division using by value the-signal returning omitted.\n       move 1 to signal-flag\n       goback.\n       end program handle-sigint.\n\n\nOutput:\nprompt$ cobc -x -j signals.cob\n+0000000001\n+0000000002\n+0000000003\n+0000000004\n+0000000005\n^CProgram ran for +00000000000000000002 seconds\nprompt$\n\n", "explain": "Works with GnuCOBOL 2.0\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Visual_FoxPro", "code": "\n*!* In VFP, Ctrl+C is normally used to copy text to the clipboard.\n*!* Esc is used to stop execution.\nCLEAR\nSET ESCAPE ON\nON ESCAPE DO StopLoop\nCLEAR DLLS\nDECLARE Sleep IN WIN32API INTEGER nMilliSeconds\nlLoop = .T.\nn = 0\n? \"Press Esc to Cancel...\"\nt1 = INT(SECONDS())\nDO WHILE lLoop\n\tn = n + 1 \n\t? n\n\tSleep(500)\nENDDO\t\n? \"Elapsed time:\", TRANSFORM(INT(SECONDS()) - t1) + \" secs.\"\nCLEAR DLLS\nRETURN TO MASTER\n\nPROCEDURE StopLoop\nlLoop = .F.\nENDPROC\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Ada", "code": "\n\nwith Ada.Interrupts; use Ada.Interrupts;\nwith Ada.Interrupts.Names; use Ada.Interrupts.Names;\n\npackage Sigint_Handler is\n      protected Handler is\n      entry Wait;\n      procedure Handle;\n      pragma Interrupt_Handler(Handle);\n      pragma Attach_Handler(Handle, Sigint);\n      private\n      Call_Count : Natural := 0;\n   end Handler;\n\nend Sigint_Handler;\n\npackage body Sigint_Handler is\n\n   -------------\n   -- Handler --\n   -------------\n\n   protected body Handler is\n\n      ----------\n      -- Wait --\n      ----------\n\n      entry Wait when Call_Count > 0 is\n      begin\n         Call_Count := Call_Count - 1;\n      end Wait;\n\n      ------------\n      -- Handle --\n      ------------\n\n      procedure Handle is\n      begin\n         Call_Count := Call_Count + 1;\n      end Handle;\n\n   end Handler;\n\nend Sigint_Handler;\n\n\nwith Ada.Calendar; use Ada.Calendar;\nwith Ada.Text_Io; use Ada.Text_Io;\nwith Sigint_Handler; use Sigint_Handler;\n\nprocedure Signals is\n   task Counter is\n      entry Stop;\n   end Counter;\n   task body Counter is\n      Current_Count : Natural := 0;\n   begin\n      loop\n         select\n            accept Stop;\n            exit;\n         or delay 0.5;\n         end select;\n         Current_Count := Current_Count + 1;\n         Put_Line(Natural'Image(Current_Count));\n      end loop;\n   end Counter;\n   task Sig_Handler;\n   \n   task body Sig_Handler is\n      Start_Time : Time := Clock;\n      Sig_Time : Time;\n   begin\n      Handler.Wait;\n      Sig_Time := Clock;\n      Counter.Stop;\n      Put_Line(\"Program execution took\" & Duration'Image(Sig_Time - Start_Time) & \" seconds\");\n   end Sig_Handler;\n      \nbegin\n   null;\n         \nend Signals;\n\n\nOutput:\n 1\n 2\n 3\n 4\n 5\n 6\n 7\n 8\nProgram execution took 4.348057086 seconds\n\n", "explain": "Signal Handler\nAda signal handlers must be defined at the library level. \nThe following package defines a simple signal handler for the SigInt signal.\nA signal may be received at any time in a program. Ada signal handling requires a task to suspend on an entry call for the handler which is executed only when the signal has been received. The following program uses the interrupt handler defined above to deal with receipt of SigInt.\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Julia", "code": "\nccall(:jl_exit_on_sigint, Cvoid, (Cint,), 0)\n\nfunction timeit()\n    ticks = 0\n    try\n        while true\n            sleep(0.5)\n            ticks += 1\n            println(ticks)\n        end\n    catch\n    end\nend\n\n@time timeit()\nprintln(\"Done.\")\n\n\n\nOutput:\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n11\n  6.020844 seconds (32.06 k allocations: 1.658 MiB)\nDone.\n\n", "explain": "The tricky bit for this task is the ccall, which tells the main() running Julia to pass SIGINT on to Julia as an error.  This call is not needed when running this code in Julia's REPL, which has the desired behavior by default.\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Kotlin", "code": "\n// version 1.1.3\n\nimport sun.misc.Signal\nimport sun.misc.SignalHandler\n\nfun main(args: Array<String>) {\n    val startTime = System.currentTimeMillis()\n\n    Signal.handle(Signal(\"INT\"), object : SignalHandler {\n        override fun handle(sig: Signal) {\n            val elapsedTime = (System.currentTimeMillis() - startTime) / 1000.0\n            println(\"\\nThe program has run for $elapsedTime seconds\")\n            System.exit(0)\n        }\n    })\n\n    var i = 0\n    while(true) {  \n        println(i++)      \n        Thread.sleep(500)        \n    }\n}\n\n\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n^C\nThe program has run for 5.087 seconds\n\n", "explain": "Sample output:\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Perl", "code": "\n\nmy $start = time;  # seconds since epohc\nmy $arlm=5;  # every 5 seconds show how we're doing\nmy $i;\n\n$SIG{QUIT} = sub\n   {print \" Ran for \", time - $start, \" seconds.\\n\"; die; };\n$SIG{INT} = sub\n   {print \" Running for \", time - $start, \" seconds.\\n\"; };\n$SIG{ALRM} = sub\n   {print \" After $arlm  seconds i= $i. Executing for \",  time - $start, \" seconds.\\n\";  alarm $arlm };\n\n\nalarm $arlm;  # trigger ALaRM after we've run  for a while\n\nprint \" ^C to inerrupt, ^\\\\ to quit, takes a break at $arlm seconds \\n\";\n\nwhile ( 1 ) {\n   for ( $w=11935000; $w--; $w>0 ){}; # spinning is bad, but hey it's only a demo\n\n    print (  ++$i,\" \\n\");\n            }\n\n^C to inerrupt, ^\\ to quit, takes a break at 5 seconds\n\n\nAfter 5  seconds i= 10. Executing for 5 seconds.\n\n\nAfter 5  seconds i= 20. Executing for 10 seconds.\n\n\nuse 5.010;\nuse AnyEvent;\nmy $start = AE::time;\nmy $exit = AE::cv;\nmy $int = AE::signal 'INT', $exit;\nmy $n;\nmy $num = AE::timer 0, 0.5, sub { say $n++ };\n$exit->recv;\nsay \" interrupted after \", AE::time - $start, \" seconds\";\n\n\nOutput:\n0\n1\n2\n3\n4\n5\n6\n7\n8\n9\n10\n^C interrupted after 5.23734092712402 seconds\n\n", "explain": "Before version 5.8 sleep requires an integer argument, so we'll spin (There exist more obtuse methods)\n1\n2\n^C Running for 1 seconds.\n3\n4\n^C Running for 2 seconds.\n5\n6\n7\n^C Running for 3 seconds.\n8\n9\n10\n11\n12\n13\n14\n15\n16\n17\n18\n19\n20\n21\n22\n^\\ Ran for 11 seconds.\nDied at 0.pl line 6..\n\nThis example does the required task:\n"}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Scala", "code": "\nLibrary: Scala\nimport sun.misc.Signal\nimport sun.misc.SignalHandler\n\nobject SignalHandl extends App {\n  val start = System.nanoTime()\n  var counter = 0\n\n  Signal.handle(new Signal(\"INT\"), new SignalHandler() {\n    def handle(sig: Signal) {\n      println(f\"\\nProgram execution took ${(System.nanoTime() - start) / 1e9f}%f seconds\\n\")\n      exit(0)\n    }\n  })\n\n  while (true) {\n    counter += 1\n    println(counter)\n    Thread.sleep(500)\n  }\n}\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "D", "code": "\nTranslation of: C\nimport core.stdc.signal;\nimport core.thread;\nimport std.concurrency;\nimport std.datetime.stopwatch;\nimport std.stdio;\n\n__gshared int gotint = 0;\nextern(C) void handleSigint(int sig) nothrow @nogc @system {\n    /*\n     * Signal safety: It is not safe to call clock(), printf(),\n     * or exit() inside a signal handler. Instead, we set a flag.\n     */\n    gotint = 1;\n}\n\nvoid main() {\n    auto sw = StopWatch(AutoStart.yes);\n    signal(SIGINT, &handleSigint);\n    for (int i=0; !gotint;) {\n        Thread.sleep(500_000.usecs);\n        if (gotint) {\n            break;\n        }\n        writeln(++i);\n    }\n    sw.stop();\n    auto td = sw.peek();\n    writeln(\"Program has run for \", td);\n}\n\n\nOutput:\n1\n2\n3\n4\n5\n6\n7\n8\n9\nProgram has run for 5 secs, 4 ms, 357 \u256c\u255ds, and 4 hnsecs\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "Haskell", "code": "\nimport Prelude hiding (catch)\nimport Control.Exception (catch, throwIO, AsyncException(UserInterrupt))\nimport Data.Time.Clock (getCurrentTime, diffUTCTime)\nimport Control.Concurrent (threadDelay)\n\nmain = do t0 <- getCurrentTime\n          catch (loop 0)\n                (\\e -> if e == UserInterrupt\n                         then do t1 <- getCurrentTime\n                                 putStrLn (\"\\nTime: \" ++ show (diffUTCTime t1 t0))\n                         else throwIO e)\n\nloop i = do print i\n            threadDelay 500000 {- \u00b5s -}\n            loop (i + 1)\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "PowerShell", "code": "\n$Start_Time = (Get-date).second\nWrite-Host \"Type CTRL-C to Terminate...\"\n$n = 1\nTry\n{\n    While($true)\n    {\n        Write-Host $n\n        $n ++\n        Start-Sleep -m 500\n    }\n}\nFinally\n{\n    $End_Time = (Get-date).second\n    $Time_Diff = $End_Time - $Start_Time\n    Write-Host \"Total time in seconds\"$Time_Diff\n}\n\n\nOutput:\nPS F:\\> . .\\signal.ps1\nType CTRL-C to Terminate...\n1\n2\n3\n4\n5\nTotal time in seconds 2\n\n", "explain": ""}, {"task_name": "Handle a signal", "task_url": "https://rosettacode.org/wiki/Handle_a_signal", "task_cat": "Concurrency", "lang": "F#", "code": "\nopen System\n\nlet rec loop n = Console.WriteLine( n:int )\n                 Threading.Thread.Sleep( 500 )\n                 loop (n + 1)\n\nlet main() =\n   let start = DateTime.Now\n   Console.CancelKeyPress.Add(\n      fun _ -> let span = DateTime.Now - start\n               printfn \"Program has run for\u00a0%.0f seconds\" span.TotalSeconds\n             )\n   loop 1\n\nmain()\n\n", "explain": ""}]