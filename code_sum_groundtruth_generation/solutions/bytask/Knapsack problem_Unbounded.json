[{"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\n", "explain": "See Knapsack Problem/Python\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char *name;\n    double value;\n    double weight;\n    double volume;\n} item_t;\n\nitem_t items[] = {\n    {\"panacea\", 3000.0, 0.3, 0.025},\n    {\"ichor\",   1800.0, 0.2, 0.015},\n    {\"gold\",    2500.0, 2.0, 0.002},\n};\n\nint n = sizeof (items) / sizeof (item_t);\nint *count;\nint *best;\ndouble best_value;\n\nvoid knapsack (int i, double value, double weight, double volume) {\n    int j, m1, m2, m;\n    if (i == n) {\n        if (value > best_value) {\n            best_value = value;\n            for (j = 0; j < n; j++) {\n                best[j] = count[j];\n            }\n        }\n        return;\n    }\n    m1 = weight / items[i].weight;\n    m2 = volume / items[i].volume;\n    m = m1 < m2 ? m1 : m2;\n    for (count[i] = m; count[i] >= 0; count[i]--) {\n        knapsack(\n            i + 1,\n            value + count[i] * items[i].value,\n            weight - count[i] * items[i].weight,\n            volume - count[i] * items[i].volume\n        );\n    }\n}\n\nint main () {\n    count = malloc(n * sizeof (int));\n    best = malloc(n * sizeof (int));\n    best_value = 0;\n    knapsack(0, 0.0, 25.0, 0.25);\n    int i;\n    for (i = 0; i < n; i++) {\n        printf(\"%d %s\\n\", best[i], items[i].name);\n    }\n    printf(\"best value:\u00a0%.0f\\n\", best_value);\n    free(count); free(best);\n    return 0;\n}\n\n\nOutput:9 panacea\n0 ichor\n11 gold\nbest value: 54500\n\n\n", "explain": "figures out the best (highest value) set by brute forcing every possible subset.\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.text.*;\n\npublic class UnboundedKnapsack {\n\n    protected Item []  items = {\n                               new Item(\"panacea\", 3000,  0.3, 0.025),\n                               new Item(\"ichor\"  , 1800,  0.2, 0.015),\n                               new Item(\"gold\"   , 2500,  2.0, 0.002)\n                               };\n    protected final int    n = items.length; // the number of items\n    protected Item      sack = new Item(\"sack\"   ,    0, 25.0, 0.250);\n    protected Item      best = new Item(\"best\"   ,    0,  0.0, 0.000);\n    protected int  []  maxIt = new int [n];  // maximum number of items\n    protected int  []    iIt = new int [n];  // current indexes of items\n    protected int  [] bestAm = new int [n];  // best amounts\n\n    public UnboundedKnapsack() {\n        // initializing:\n        for (int i = 0; i < n; i++) {\n            maxIt [i] = Math.min(\n                           (int)(sack.getWeight() / items[i].getWeight()),\n                           (int)(sack.getVolume() / items[i].getVolume())\n                        );\n        } // for (i)\n\n        // calc the solution:\n        calcWithRecursion(0);\n\n        // Print out the solution:\n        NumberFormat nf = NumberFormat.getInstance();\n        System.out.println(\"Maximum value achievable is: \" + best.getValue());\n        System.out.print(\"This is achieved by carrying (one solution): \");\n        for (int i = 0; i < n; i++) {\n            System.out.print(bestAm[i] + \" \" + items[i].getName() + \", \");\n        }\n        System.out.println();\n        System.out.println(\"The weight to carry is: \" + nf.format(best.getWeight()) +\n                           \"   and the volume used is: \" + nf.format(best.getVolume())\n                          );\n\n    }\n\n    // calculation the solution with recursion method\n    // item\u00a0: the number of item in the \"items\" array\n    public void calcWithRecursion(int item) {\n        for (int i = 0; i <= maxIt[item]; i++) {\n            iIt[item] = i;\n            if (item < n-1) {\n                calcWithRecursion(item+1);\n            } else {\n                int    currVal = 0;   // current value\n                double currWei = 0.0; // current weight\n                double currVol = 0.0; // current Volume\n                for (int j = 0; j < n; j++) {\n                    currVal += iIt[j] * items[j].getValue();\n                    currWei += iIt[j] * items[j].getWeight();\n                    currVol += iIt[j] * items[j].getVolume();\n                }\n\n                if (currVal > best.getValue()\n                    &&\n                    currWei <= sack.getWeight()\n                    &&\n                    currVol <= sack.getVolume()\n                )\n                {\n                    best.setValue (currVal);\n                    best.setWeight(currWei);\n                    best.setVolume(currVol);\n                    for (int j = 0; j < n; j++) bestAm[j] = iIt[j];\n                } // if (...)\n            } // else\n        } // for (i)\n    } // calcWithRecursion()\n\n    // the main() function:\n    public static void main(String[] args) {\n        new UnboundedKnapsack();\n    } // main()\n\n} // class\n\npackage hu.pj.obj;\n\npublic class Item {\n    protected String name = \"\";\n    protected int value = 0;\n    protected double weight = 0;\n    protected double volume = 0;\n\n    public Item() {\n    }\n\n    public Item(String name, int value, double weight, double volume) {\n        setName(name);\n        setValue(value);\n        setWeight(weight);\n        setVolume(volume);\n    }\n\n    public int getValue() {\n        return value;\n    }\n\n    public void setValue(int value) {\n        this.value = Math.max(value, 0);\n    }\n\n    public double getWeight() {\n        return weight;\n    }\n\n    public void setWeight(double weight) {\n        this.weight = Math.max(weight, 0);\n    }\n\n    public double getVolume() {\n        return volume;\n    }\n\n    public void setVolume(double volume) {\n        this.volume = Math.max(volume, 0);\n    }\n\n    public String getName() {\n        return name;\n    }\n\n    public void setName(String name) {\n        this.name = name;\n    }\n\n} // class\n\n\nMaximum value achievable is: 54500\nThis is achieved by carrying (one solution): 0 panacea, 15 ichor, 11 gold, \nThe weight to carry is: 25   and the volume used is: 0,247\n", "explain": "With recursion for more than 3 items.\noutput:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n/*    Items  Value  Weight  Volume\n          a     30       3      25\n          b     18       2      15\n          c     25      20       2\n\n                     <=250   <=250      */\nusing System;\nclass Program\n{\n    static void Main()\n    {\n        uint[] r = items1();\n        Console.WriteLine(r[0] + \" v  \" + r[1] + \" a  \" + r[2] + \" b\");  // 0 15 11\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        for (int i = 1000; i > 0; i--) items1();\n        Console.Write(sw.Elapsed); Console.Read();\n    }\n\n    static uint[] items0()  // 1.2 \u00b5s\n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n                for (c = 0; a * 25 + b * 15 + c * 2 <= 250 && a * 3 + b * 2 + c * 20 <= 250; c++)\n                    if (v0 < (v = a * 30 + b * 18 + c * 25))\n                    {\n                        v0 = v; a0 = a; b0 = b; c0 = c;\n                        //Console.WriteLine(\"{0,5} {1,5} {2,5} {3,5}\", v, a, b, c);\n                    }\n        return new uint[] { a0, b0, c0 };\n    }\n\n    static uint[] items1()  // 0,22 \u00b5s \n    {\n        uint v, v0 = 0, a, b, c, a0 = 0, b0 = 0, c0 = 0, c1 = 0;\n        for (a = 0; a <= 10; a++)\n            for (b = 0; a * 5 + b * 3 <= 50; b++)\n            {\n                c = (250 - a * 25 - b * 15) / 2;\n                if ((c1 = (250 - a * 3 - b * 2) / 20) < c) c = c1;\n                if (v0 < (v = a * 30 + b * 18 + c * 25))\n                { v0 = v; a0 = a; b0 = b; c0 = c; }\n            }\n        return new uint[] { a0, b0, c0 };\n    }\n}\n\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\nvar gold = { 'value': 2500, 'weight': 2.0, 'volume': 0.002 },\n    panacea = { 'value': 3000, 'weight': 0.3, 'volume': 0.025 },\n    ichor = { 'value': 1800, 'weight': 0.2, 'volume': 0.015 },\n    \n    items = [gold, panacea, ichor],\n    knapsack = {'weight': 25, 'volume': 0.25},\n    max_val = 0,\n    solutions = [],\n    g, p, i, item, val;\n    \nfor (i = 0; i < items.length; i += 1) {\n    item = items[i];\n    item.max = Math.min(\n        Math.floor(knapsack.weight / item.weight),\n        Math.floor(knapsack.volume / item.volume)\n    );\n}\n \nfor (g = 0; g <= gold.max; g += 1) {\n    for (p = 0; p <= panacea.max; p += 1) {\n        for (i = 0; i <= ichor.max; i += 1) {\n            if (i * ichor.weight + g * gold.weight + p * panacea.weight > knapsack.weight) {\n                continue;\n            }\n            if (i * ichor.volume + g * gold.volume + p * panacea.volume > knapsack.volume) {\n                continue;\n            }\n            val = i * ichor.value + g * gold.value + p * panacea.value;\n            if (val > max_val) {\n                solutions = [];\n                max_val = val;\n            }\n            if (val === max_val) {\n                solutions.push([g, p, i]);\n            }\n        }\n    }\n}\n \ndocument.write(\"maximum value: \" + max_val + '<br>');\nfor (i = 0; i < solutions.length; i += 1) {\n    item = solutions[i];\n    document.write(\"(gold: \" + item[0] + \", panacea: \" + item[1] + \", ichor: \" + item[2] + \")<br>\");\n}\n\noutput:\n<pre>maximum value: 54500\n(gold: 11, panacea: 0, ichor: 15)\n(gold: 11, panacea: 3, ichor: 10)\n(gold: 11, panacea: 6, ichor: 5)\n(gold: 11, panacea: 9, ichor: 0)</pre>\n\n", "explain": "Brute force.\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\nPROGRAM KNAPSACK\n\n  IMPLICIT NONE\n \n  REAL :: totalWeight, totalVolume\n  INTEGER :: maxPanacea, maxIchor, maxGold, maxValue = 0\n  INTEGER :: i, j, k\n  INTEGER :: n(3)  \n\n  TYPE Bounty\n    INTEGER :: value\n    REAL :: weight\n    REAL :: volume\n  END TYPE Bounty\n\n  TYPE(Bounty) :: panacea, ichor, gold, sack, current\n\n  panacea = Bounty(3000, 0.3, 0.025)\n  ichor   = Bounty(1800, 0.2, 0.015)\n  gold    = Bounty(2500, 2.0, 0.002)\n  sack    = Bounty(0, 25.0, 0.25)\n\n  maxPanacea = MIN(sack%weight / panacea%weight, sack%volume / panacea%volume)\n  maxIchor = MIN(sack%weight / ichor%weight, sack%volume / ichor%volume)\n  maxGold = MIN(sack%weight / gold%weight, sack%volume / gold%volume)\n  \n  DO i = 0, maxPanacea\n     DO j = 0, maxIchor\n        Do k = 0, maxGold\n           current%value = k * gold%value + j * ichor%value + i * panacea%value\n           current%weight = k * gold%weight + j * ichor%weight + i * panacea%weight\n           current%volume = k * gold%volume + j * ichor%volume + i * panacea%volume       \n           IF (current%weight > sack%weight .OR. current%volume > sack%volume) CYCLE\n           IF (current%value > maxValue) THEN\n              maxValue = current%value\n              totalWeight = current%weight\n              totalVolume = current%volume\n              n(1) = i ; n(2) = j ; n(3) = k\n           END IF\n        END DO  \n     END DO\n  END DO\n\n  WRITE(*, \"(A,I0)\") \"Maximum value achievable is \", maxValue\n  WRITE(*, \"(3(A,I0),A)\") \"This is achieved by carrying \", n(1), \" panacea, \", n(2), \" ichor and \", n(3), \" gold items\"\n  WRITE(*, \"(A,F4.1,A,F5.3)\") \"The weight to carry is \", totalWeight, \" and the volume used is \", totalVolume\n \nEND PROGRAM KNAPSACK\n\n\nMaximum value achievable is 54500\nThis is achieved by carrying 0 panacea, 15 ichor and 11 gold items\nThe weight to carry is 25.0 and the volume used is 0.247\n\n", "explain": "A straight forward 'brute force' approach\nSample output\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\ntype Item struct {\n\tName           string\n\tValue          int\n\tWeight, Volume float64\n}\n\ntype Result struct {\n\tCounts []int\n\tSum    int\n}\n\nfunc min(a, b int) int {\n\tif a < b {\n\t\treturn a\n\t}\n\treturn b\n}\n\nfunc Knapsack(items []Item, weight, volume float64) (best Result) {\n\tif len(items) == 0 {\n\t\treturn\n\t}\n\tn := len(items) - 1\n\tmaxCount := min(int(weight/items[n].Weight), int(volume/items[n].Volume))\n\tfor count := 0; count <= maxCount; count++ {\n\t\tsol := Knapsack(items[:n],\n\t\t\tweight-float64(count)*items[n].Weight,\n\t\t\tvolume-float64(count)*items[n].Volume)\n\t\tsol.Sum += items[n].Value * count\n\t\tif sol.Sum > best.Sum {\n\t\t\tsol.Counts = append(sol.Counts, count)\n\t\t\tbest = sol\n\t\t}\n\t}\n\treturn\n}\n\nfunc main() {\n\titems := []Item{\n\t\t{\"Panacea\", 3000, 0.3, 0.025},\n\t\t{\"Ichor\", 1800, 0.2, 0.015},\n\t\t{\"Gold\", 2500, 2.0, 0.002},\n\t}\n\tvar sumCount, sumValue int\n\tvar sumWeight, sumVolume float64\n\n\tresult := Knapsack(items, 25, 0.25)\n\n\tfor i := range result.Counts {\n\t\tfmt.Printf(\"%-8s x%3d  -> Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\t\titems[i].Name, result.Counts[i], items[i].Weight*float64(result.Counts[i]),\n\t\t\titems[i].Volume*float64(result.Counts[i]), items[i].Value*result.Counts[i])\n\n\t\tsumCount += result.Counts[i]\n\t\tsumValue += items[i].Value * result.Counts[i]\n\t\tsumWeight += items[i].Weight * float64(result.Counts[i])\n\t\tsumVolume += items[i].Volume * float64(result.Counts[i])\n\t}\n\n\tfmt.Printf(\"TOTAL (%3d items) Weight: %4.1f  Volume: %5.3f  Value: %6d\\n\",\n\t\tsumCount, sumWeight, sumVolume, sumValue)\n}\n\n\nPanacea  x  9  -> Weight:  2.7  Volume: 0.225  Value:  27000\nIchor    x  0  -> Weight:  0.0  Volume: 0.000  Value:      0\nGold     x 11  -> Weight: 22.0  Volume: 0.022  Value:  27500\nTOTAL ( 20 items) Weight: 24.7  Volume: 0.247  Value:  54500\n\n", "explain": "Recursive brute-force.\nOutput:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nBrute force method, Translation of: Tcl\nKnapsackItem = Struct.new(:volume, :weight, :value)\npanacea = KnapsackItem.new(0.025, 0.3, 3000)\nichor   = KnapsackItem.new(0.015, 0.2, 1800)\ngold    = KnapsackItem.new(0.002, 2.0, 2500)\nmaximum = KnapsackItem.new(0.25,  25,  0)\n\nmax_items = {}\nfor item in [panacea, ichor, gold]\n  max_items[item] = [(maximum.volume/item.volume).to_i, (maximum.weight/item.weight).to_i].min\nend\n\nmaxval = 0\nsolutions = []\n\n0.upto(max_items[ichor]) do |i|\n  0.upto(max_items[panacea]) do |p|\n    0.upto(max_items[gold]) do |g|\n      break if i*ichor.weight + p*panacea.weight + g*gold.weight > maximum.weight\n      break if i*ichor.volume + p*panacea.volume + g*gold.volume > maximum.volume\n      val = i*ichor.value + p*panacea.value + g*gold.value\n      if val > maxval\n        maxval = val\n        solutions = [[i, p, g]]\n      elsif val == maxval\n        solutions << [i, p, g]\n      end\n    end\n  end\nend\n\nputs \"The maximal solution has value #{maxval}\"\nsolutions.each do |i, p, g|\n  printf \"  ichor=%2d, panacea=%2d, gold=%2d -- weight:%.1f, volume=%.3f\\n\",\n    i, p, g,\n    i*ichor.weight + p*panacea.weight + g*gold.weight,\n    i*ichor.volume + p*panacea.volume + g*gold.volume \nend\n\n\nOutput:\nThe maximal solution has value 54500\n  ichor= 0, panacea= 9, gold=11 -- weight:24.7, volume=0.247\n  ichor= 5, panacea= 6, gold=11 -- weight:24.8, volume=0.247\n  ichor=10, panacea= 3, gold=11 -- weight:24.9, volume=0.247\n  ichor=15, panacea= 0, gold=11 -- weight:25.0, volume=0.247\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\n# Define consts\nweights <- c(panacea=0.3, ichor=0.2, gold=2.0)\nvolumes <- c(panacea=0.025, ichor=0.015, gold=0.002)\nvalues <- c(panacea=3000, ichor=1800, gold=2500)\nsack.weight <- 25\nsack.volume <- 0.25\nmax.items <- floor(pmin(sack.weight/weights, sack.volume/volumes))\n\n# Some utility functions\ngetTotalValue <- function(n) sum(n*values)\ngetTotalWeight <- function(n) sum(n*weights)\ngetTotalVolume <- function(n) sum(n*volumes)\nwillFitInSack <- function(n) getTotalWeight(n) <= sack.weight && getTotalVolume(n) <= sack.volume\n\n# Find all possible combination, then eliminate those that won't fit in the sack\nknapsack <- expand.grid(lapply(max.items, function(n) seq.int(0, n)))\nok <- apply(knapsack, 1, willFitInSack)\nknapok <- knapsack[ok,]\n\n# Find the solutions with the highest value\nvals <- apply(knapok, 1, getTotalValue)\nknapok[vals == max(vals),]\n\n     panacea ichor gold\n2067       9     0   11\n2119       6     5   11\n2171       3    10   11\n2223       0    15   11\n\n\nData_<-structure(list(item = c(\"Panacea\", \"Ichor\", \"Gold\"), value = c(3000, \n1800, 2500), weight = c(3, 2, 20), volume = c(25, 15, 2)), .Names = c(\"item\", \n\"value\", \"weight\", \"volume\"), row.names = c(NA, 3L), class = \"data.frame\")\n\nknapsack_volume<-function(Data, W, Volume, full_K) \n{\n\n\t# Data must have the colums with names: item, value, weight and volume.\n\tK<-list() # hightest values\n\tK_item<-list() # itens that reach the hightest value\n\tK<-rep(0,W+1) # The position '0'\n\tK_item<-rep('',W+1) # The position '0'\n\tfor(w in 1:W)\n\t{\n\t\ttemp_w<-0\n\t\ttemp_item<-''\n\t\ttemp_value<-0\n\t\tfor(i in 1:dim(Data)[1]) # each row\n\t\t{\n\t\t\twi<-Data$weight[i] # item i\n\t\t\tvi<- Data$value[i]\n\t\t\titem<-Data$item[i]\n\t\t\tvolume_i<-Data$volume[i]\n\t\t\tif(wi<=w & volume_i <= Volume)\n\t\t\t{\n\t\t\t\tback<- full_K[[Volume-volume_i+1]][w-wi+1]\n\t\t\t\ttemp_wi<-vi + back\n\n\t\t\t\tif(temp_w < temp_wi)\n\t\t\t\t{\n\t\t\t\t\ttemp_value<-temp_wi\n\t\t\t\t\ttemp_w<-temp_wi\n\t\t\t\t\ttemp_item <- item\n\t\t\t\t}\t\n\t\t\t}\n\t\t}\n\tK[[w+1]]<-temp_value\n\tK_item[[w+1]]<-temp_item\n\t}\nreturn(list(K=K,Item=K_item))\n}\n\n\nUn_knapsack<-function(Data,W,V)\n{\n\tK<-list();K_item<-list()\n\tK[[1]]<-rep(0,W+1) #the line 0\n\tK_item[[1]]<-rep('', W+1) #the line 0\n\tfor(v in 1:V)\n\t{\n\t\tbest_volum_v<-knapsack_volume(Data, W, v, K)\n\t\tK[[v+1]]<-best_volum_v$K\n\t\tK_item[[v+1]]<-best_volum_v$Item\n\t}\n\nreturn(list(K=data.frame(K),Item=data.frame(K_item,stringsAsFactors=F)))\n}\n\nretrieve_info<-function(knapsack, Data)\n{\n\tW<-dim(knapsack$K)[1]\n\titens<-c()\n\tcol<-dim(knapsack$K)[2]\n\tselected_item<-knapsack$Item[W,col]\n\twhile(selected_item!='')\n\t{\n\t\tselected_item<-knapsack$Item[W,col]\n\t\tif(selected_item!='')\n\t\t{\n\t\t\tselected_item_value<-Data[Data$item == selected_item,]\t\t\t\n\t\t\tW <- W - selected_item_value$weight\n\t\t\titens<-c(itens,selected_item)\t\t\t\n\t\t\tcol <- col - selected_item_value$volume\n\t\t}\n\t}\nreturn(itens)\n}\n\nmain_knapsack<-function(Data, W, Volume)\n{\n\tknapsack_result<-Un_knapsack(Data,W,Volume)\n\titems<-table(retrieve_info(knapsack_result, Data))\n\tK<-knapsack_result$K[W+1, Volume+1]\n\tcat(paste('The Total profit is: ', K, '\\n'))\n\tcat(paste('You must carry:', names(items), '(x',items, ') \\n'))\n}\n\nmain_knapsack(Data_, 250, 250)\n\nOutput:\nThe Total profit is:  54500 \nYou must carry: Gold (x 11 ) \nYou must carry: Panacea (x 9 )\n\n", "explain": "Brute force method\n\nUsing Dynamic Programming\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic", "code": "\n\nFunction Min(E1, E2): Min = IIf(E1 < E2, E1, E2): End Function 'small Helper-Function\n\nSub Main()\nConst Value = 0, Weight = 1, Volume = 2, PC = 3, IC = 4, GC = 5\nDim P&, I&, G&, A&, M, Cur(Value To Volume)\nDim S As New Collection: S.Add Array(0) '<- init Solutions-Coll.\n\nConst SackW = 25, SackV = 0.25\nDim Panacea: Panacea = Array(3000, 0.3, 0.025)\nDim Ichor:     Ichor = Array(1800, 0.2, 0.015)\nDim Gold:       Gold = Array(2500, 2, 0.002)\n\n  For P = 0 To Int(Min(SackW / Panacea(Weight), SackV / Panacea(Volume)))\n    For I = 0 To Int(Min(SackW / Ichor(Weight), SackV / Ichor(Volume)))\n      For G = 0 To Int(Min(SackW / Gold(Weight), SackV / Gold(Volume)))\n        For A = Value To Volume: Cur(A) = G * Gold(A) + I * Ichor(A) + P * Panacea(A): Next\n        If Cur(Value) >= S(1)(Value) And Cur(Weight) <= SackW And Cur(Volume) <= SackV Then _\n          S.Add Array(Cur(Value), Cur(Weight), Cur(Volume), P, I, G), , 1\n  Next G, I, P\n  \n  Debug.Print \"Value\", \"Weight\", \"Volume\", \"PanaceaCount\", \"IchorCount\", \"GoldCount\"\n  For Each M In S '<- enumerate the Attributes of the Maxima\n    If M(Value) = S(1)(Value) Then Debug.Print M(Value), M(Weight), M(Volume), M(PC), M(IC), M(GC)\n  Next\nEnd Sub\n\nOutput: Value        Weight        Volume        PanaceaCount  IchorCount    GoldCount\n 54500         24.7          0.247         9             0             11 \n 54500         24.8          0.247         6             5             11 \n 54500         24.9          0.247         3             10            11 \n 54500         25            0.247         0             15            11 \n\n", "explain": "See: Knapsack Problem/Visual Basic\nThe above Link contains a longer version (which perhaps runs a bit faster),\nwhilst the one below is focussing more on expressing/solving the problem \nin less lines of code.\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nTranslation of: Python\nwith Ada.Text_IO;\n\nprocedure Knapsack_Unbounded is\n\n   type Bounty is record\n      Value  : Natural;\n      Weight : Float;\n      Volume : Float;\n   end record;\n\n   function Min (A, B : Float) return Float is\n   begin\n      if A < B then\n         return A;\n      else\n         return B;\n      end if;\n   end Min;\n\n   Panacea : Bounty := (3000,  0.3, 0.025);\n   Ichor   : Bounty := (1800,  0.2, 0.015);\n   Gold    : Bounty := (2500,  2.0, 0.002);\n   Limits  : Bounty := (   0, 25.0, 0.250);\n   Best    : Bounty := (   0,  0.0, 0.000);\n   Current : Bounty := (   0,  0.0, 0.000);\n\n   Best_Amounts : array (1 .. 3) of Natural := (0, 0, 0);\n\n   Max_Panacea : Natural := Natural (Float'Floor (Min\n                              (Limits.Weight / Panacea.Weight,\n                               Limits.Volume / Panacea.Volume)));\n   Max_Ichor   : Natural := Natural (Float'Floor (Min\n                              (Limits.Weight / Ichor.Weight,\n                               Limits.Volume / Ichor.Volume)));\n   Max_Gold    : Natural := Natural (Float'Floor (Min\n                              (Limits.Weight / Gold.Weight,\n                               Limits.Volume / Gold.Volume)));\n\nbegin\n   for Panacea_Count in 0 .. Max_Panacea loop\n      for Ichor_Count in 0 .. Max_Ichor loop\n         for Gold_Count in 0 .. Max_Gold loop\n            Current.Value  := Panacea_Count * Panacea.Value +\n                              Ichor_Count * Ichor.Value +\n                              Gold_Count * Gold.Value;\n            Current.Weight := Float (Panacea_Count) * Panacea.Weight +\n                              Float (Ichor_Count) * Ichor.Weight +\n                              Float (Gold_Count) * Gold.Weight;\n            Current.Volume := Float (Panacea_Count) * Panacea.Volume +\n                              Float (Ichor_Count) * Ichor.Volume +\n                              Float (Gold_Count) * Gold.Volume;\n            if Current.Value  >  Best.Value and\n               Current.Weight <= Limits.Weight and\n               Current.Volume <= Limits.Volume then\n               Best := Current;\n               Best_Amounts := (Panacea_Count, Ichor_Count, Gold_Count);\n            end if;\n         end loop;\n      end loop;\n   end loop;\n   Ada.Text_IO.Put_Line (\"Maximum value:\" & Natural'Image (Best.Value));\n   Ada.Text_IO.Put_Line (\"Panacea:\" & Natural'Image (Best_Amounts (1)));\n   Ada.Text_IO.Put_Line (\"Ichor:  \" & Natural'Image (Best_Amounts (2)));\n   Ada.Text_IO.Put_Line (\"Gold:   \" & Natural'Image (Best_Amounts (3)));\nend Knapsack_Unbounded;\n\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nLibrary: JuMPusing JuMP\nusing GLPKMathProgInterface\n\nmodel = Model(solver=GLPKSolverMIP())\n\n@variable(model, vials_of_panacea >= 0, Int)\n@variable(model, ampules_of_ichor >= 0, Int)\n@variable(model, bars_of_gold >= 0, Int)\n\n@objective(model, Max, 3000*vials_of_panacea + 1800*ampules_of_ichor + 2500*bars_of_gold)\n\n@constraint(model, 0.3*vials_of_panacea + 0.2*ampules_of_ichor + 2.0*bars_of_gold <= 25.0)\n@constraint(model, 0.025*vials_of_panacea + 0.015*ampules_of_ichor + 0.002*bars_of_gold <= 0.25)\n\nprintln(\"The optimization problem to be solved is:\")\nprintln(model)\n\nstatus = solve(model)\n\nprintln(\"Objective value: \", getobjectivevalue(model))\nprintln(\"vials of panacea = \", getvalue(vials_of_panacea))\nprintln(\"ampules of ichor = \", getvalue(ampules_of_ichor))\nprintln(\"bars of gold = \", getvalue(bars_of_gold))\n\n\nOutput:\nThe optimization problem to be solved is:\nMax 3000 vials_of_panacea + 1800 ampules_of_ichor + 2500 bars_of_gold\nSubject to\n 0.3 vials_of_panacea + 0.2 ampules_of_ichor + 2 bars_of_gold <= 25\n 0.025 vials_of_panacea + 0.015 ampules_of_ichor + 0.002 bars_of_gold <= 0.25\n vials_of_panacea >= 0, integer\n ampules_of_ichor >= 0, integer\n bars_of_gold >= 0, integer\n\nObjective value: 54500.0\nvials of panacea = 9.0\nampules of ichor = 0.0\nbars of gold = 11.0\n\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\n\ndata one;\n   wtpanacea=0.3;    wtichor=0.2;    wtgold=2.0;\n   volpanacea=0.025; volichor=0.015; volgold=0.002;\n   valpanacea=3000;  valichor=1800;  valgold=2500;\n   maxwt=25; maxvol=0.25;\n\n   /* we can prune the possible selections */\n   maxpanacea = floor(min(maxwt/wtpanacea, maxvol/volpanacea));\n   maxichor = floor(min(maxwt/wtichor, maxvol/volichor));\n   maxgold = floor(min(maxwt/wtgold, maxvol/volgold));\n   do i1 = 0 to maxpanacea; \n      do i2 = 0 to maxichor;\n         do i3 = 0 to maxgold;\n            panacea = i1; ichor=i2; gold=i3; output;\n         end;\n      end;\n   end;\nrun;\ndata one; set one;\n   vals = valpanacea*panacea + valichor*ichor + valgold*gold;\n   totalweight = wtpanacea*panacea + wtichor*ichor + wtgold*gold;\n   totalvolume = volpanacea*panacea + volichor*ichor + volgold*gold;\n   if (totalweight le maxwt) and (totalvolume le maxvol);\nrun;\nproc sort data=one;\n   by descending vals;\nrun;\nproc print data=one (obs=4);\n   var panacea ichor gold vals;\nrun;\n\n\n Obs    panacea    ichor    gold     vals\n\n   1       0         15      11     54500\n   2       3         10      11     54500\n   3       6          5      11     54500\n   4       9          0      11     54500\n\n\n/* create SAS data set */\ndata mydata;\n   input Item $1-19 Value weight Volume;\n   datalines;\npanacea (vials of) 3000 0.3 0.025\nichor (ampules of) 1800 0.2 0.015\ngold (bars)        2500 2.0 0.002\n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare sets and parameters, and read input data */\n   set <str> ITEMS;\n   num value {ITEMS};\n   num weight {ITEMS};\n   num volume {ITEMS};\n   read data mydata into ITEMS=[item] value weight volume;\n\n   /* declare variables, objective, and constraints */\n   var NumSelected {ITEMS} >= 0 integer;\n   max TotalValue = sum {i in ITEMS} value[i] * NumSelected[i];\n   con WeightCon:\n      sum {i in ITEMS} weight[i] * NumSelected[i] <= 25;\n   con VolumeCon:\n      sum {i in ITEMS} volume[i] * NumSelected[i] <= 0.25;\n\n   /* call mixed integer linear programming (MILP) solver */\n   solve;\n\n   /* print optimal solution */\n   print TotalValue;\n   print NumSelected;\n\n   /* to get all optimal solutions, call CLP solver instead */\n   solve with CLP / findallsolns;\n\n   /* print all optimal solutions */\n   print TotalValue;\n   for {s in 1.._NSOL_} print {i in ITEMS} NumSelected[i].sol[s];\nquit;\n\n\nTotalValue \n54500 \n\n[1] NumSelected \ngold (bars) 11 \nichor (ampules of) 0 \npanacea (vials of) 9 \n\n\nTotalValue \n54500 \n\n[1]   \ngold (bars) 11 \nichor (ampules of) 15 \npanacea (vials of) 0 \n\n[1]   \ngold (bars) 11 \nichor (ampules of) 10 \npanacea (vials of) 3 \n\n[1]   \ngold (bars) 11 \nichor (ampules of) 5 \npanacea (vials of) 6 \n\n[1]   \ngold (bars) 11 \nichor (ampules of) 0 \npanacea (vials of) 9 \n", "explain": "This is yet another brute force solution.\nOutput:\nUse SAS/OR:\nMILP solver output:\nCLP solver output:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nTranslation of: C\n\n// version 1.1.2\n\ndata class Item(val name: String, val value: Double, val weight: Double, val volume: Double)\n\nval items = listOf(\n    Item(\"panacea\", 3000.0, 0.3, 0.025),\n    Item(\"ichor\", 1800.0, 0.2, 0.015),\n    Item(\"gold\", 2500.0, 2.0, 0.002)\n)\n\nval n = items.size\nval count = IntArray(n)\nval best  = IntArray(n)\nvar bestValue = 0.0\n\nconst val MAX_WEIGHT = 25.0\nconst val MAX_VOLUME = 0.25\n\nfun knapsack(i: Int, value: Double, weight: Double, volume: Double) {\n    if (i == n) {\n        if (value > bestValue) {\n            bestValue = value\n            for (j in 0 until n) best[j] = count[j]\n        }\n        return\n    }\n    val m1 = Math.floor(weight / items[i].weight).toInt()\n    val m2 = Math.floor(volume / items[i].volume).toInt()\n    val m  = minOf(m1, m2)\n    count[i] = m\n    while (count[i] >= 0) {\n        knapsack(\n            i + 1,\n            value  + count[i] * items[i].value,\n            weight - count[i] * items[i].weight,\n            volume - count[i] * items[i].volume\n        )\n        count[i]--\n    }\n}\n\nfun main(args: Array<String>) {\n    knapsack(0, 0.0, MAX_WEIGHT, MAX_VOLUME)\n    println(\"Item Chosen  Number Value  Weight  Volume\")\n    println(\"-----------  ------ -----  ------  ------\")\n    var itemCount = 0\n    var sumNumber = 0\n    var sumWeight = 0.0\n    var sumVolume = 0.0\n    for (i in 0 until n) {\n        if (best[i] == 0) continue\n        itemCount++\n        val name   = items[i].name\n        val number = best[i]\n        val value  = items[i].value  * number\n        val weight = items[i].weight * number\n        val volume = items[i].volume * number\n        sumNumber += number\n        sumWeight += weight\n        sumVolume += volume\n        print(\"${name.padEnd(11)}   ${\"%2d\".format(number)}    ${\"%5.0f\".format(value)}   ${\"%4.1f\".format(weight)}\")\n        println(\"    ${\"%4.2f\".format(volume)}\")\n    }\n    println(\"-----------  ------ -----  ------  ------\")\n    print(\"${itemCount} items       ${\"%2d\".format(sumNumber)}    ${\"%5.0f\".format(bestValue)}   ${\"%4.1f\".format(sumWeight)}\")\n    println(\"    ${\"%4.2f\".format(sumVolume)}\")\n}\n\n\nOutput:\nItem Chosen  Number Value  Weight  Volume\n-----------  ------ -----  ------  ------\npanacea        9    27000    2.7    0.23\ngold          11    27500   22.0    0.02\n-----------  ------ -----  ------  ------\n2 items       20    54500   24.7    0.25\n\n", "explain": "Recursive brute force approach:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\nmy (@names, @val, @weight, @vol, $max_vol, $max_weight, $vsc, $wsc);\n\nif (1) { # change 1 to 0 for different data set\n        @names  = qw(panacea    icor    gold);\n        @val    = qw(3000       1800    2500);\n        @weight = qw(3          2       20  );\n        @vol    = qw(25         15      2   );\n        $max_weight = 250;\n        $max_vol = 250;\n        $vsc = 1000;\n        $wsc = 10;\n} else { # with these numbers cache would have been useful\n        @names  = qw(panacea    icor    gold    banana  monkey  );\n        @val    = qw(17         11      5       3       34      );\n        @weight = qw(14         3       2       2       10      );\n        @vol    = qw(3          4       2       1       12      );\n        $max_weight = 150;\n        $max_vol = 100;\n        $vsc = $wsc = 1;\n}\n\nmy @cache;\nmy ($hits, $misses) = (0, 0);\nsub solu {\n        my ($i, $w, $v) = @_;\n        return [0, []] if $i < 0;\n\n        if ($cache[$i][$w][$v]) {\n                $hits ++;\n                return $cache[$i][$w][$v]\n        }\n        $misses ++;\n\n        my $x = solu($i - 1, $w, $v);\n\n        my ($w1, $v1);\n        for (my $t = 1; ; $t++) {\n                last if ($w1 = $w - $t * $weight[$i]) < 0;\n                last if ($v1 = $v - $t * $vol[$i]) < 0;\n\n                my $y = solu($i - 1, $w1, $v1);\n\n                if ( (my $tmp = $y->[0] + $val[$i] * $t) > $x->[0] ) {\n                        $x = [ $tmp, [ @{$y->[1]}, [$i, $t] ] ];\n                }\n        }\n\n        $cache[$i][$w][$v] = $x\n}\n\nmy $x = solu($#names, $max_weight, $max_vol);\nprint   \"Max value $x->[0], with:\\n\",\n        \"    Item\\tQty\\tWeight   Vol    Value\\n\", '-'x 50, \"\\n\";\n\nmy ($wtot, $vtot) = (0, 0);\nfor (@{$x->[1]}) {\n        my $i = $_->[0];\n        printf  \"    $names[$i]:\\t% 3d \u00a0% 8d% 8g% 8d\\n\",\n                $_->[1],\n                $weight[$i] * $_->[1] / $wsc,\n                $vol[$i] * $_->[1] / $vsc,\n                $val[$i] * $_->[1];\n\n        $wtot += $weight[$i] * $_->[1];\n        $vtot += $vol[$i] * $_->[1];\n}\nprint   \"-\" x 50, \"\\n\";\nprintf  \"    Total:\\t    \u00a0% 8d% 8g% 8d\\n\",\n        $wtot/$wsc, $vtot/$vsc, $x->[0];\n\nprint \"\\nCache hit: $hits\\tmiss: $misses\\n\";\n\nOutput:Max value 54500, with:\n    Item        Qty     Weight   Vol    Value\n--------------------------------------------------\n    panacea:      9         2   0.225   27000\n    gold:        11        22   0.022   27500\n--------------------------------------------------\n    Total:                 24   0.247   54500\n\nCache hit: 0    miss: 218\n\n", "explain": "Dynamic programming solution.  Before you ask, no, it's actually slower for the given data set.  See the alternate data set.\nCache info is not pertinent to this task, just some info.\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\n\n:- use_module(library(simplex)).\n\n% tuples (name, Explantion, Value, weights, volume).\nknapsack :-\n\tL =[(\tpanacea, 'Incredible healing properties', 3000,\t0.3,\t0.025),\n\t    (\tichor,   'Vampires blood',                1800,\t0.2,\t0.015),\n\t    (\tgold ,\t 'Shiney shiney',\t          2500,\t2.0,\t0.002)],\n\n\t gen_state(S0),\n\t length(L, N),\n\t numlist(1, N, LN),\n\n\t % to get statistics\n\t time((create_constraint_N(LN, L, S0, S1, [], LVa, [], LW, [], LVo),\n\t       constraint(LW =< 25.0, S1, S2),\n\t       constraint(LVo =< 0.25, S2, S3),\n\t       maximize(LVa, S3, S4)\n\t      )),\n\n\t% we display the results\n\tcompute_lenword(L, 0, Len),\n\tsformat(A0, '~~w~~t~~~w|', [3]),\n\tsformat(A1, '~~w~~t~~~w|', [Len]),\n\tsformat(A2, '~~t~~w~~~w|', [10]),\n\tsformat(A3, '~~t~~2f~~~w|', [10]),\n\tsformat(A4, '~~t~~3f~~~w|', [10]),\n\tsformat(A33, '~~t~~w~~~w|', [10]),\n\tsformat(A44, '~~t~~w~~~w|', [10]),\n\n\tsformat(W0, A0, ['Nb']),\n\tsformat(W1, A1, ['Items']),\n\tsformat(W2, A2, ['Value']),\n\tsformat(W3, A33, ['Weigth']),\n\tsformat(W4, A44, ['Volume']),\n\tformat('~w~w~w~w~w~n', [W0, W1,W2,W3,W4]),\n\n\tprint_results(S4, A0, A1, A2, A3, A4, L, LN, 0, 0, 0).\n\n\ncreate_constraint_N([], [], S, S, LVa, LVa, LW, LW, LVo, LVo).\n\ncreate_constraint_N([HN|TN], [(_, _,Va, W, Vo) | TL], S1, SF, LVa, LVaF, LW, LWF, LVo, LVoF) :-\n\tconstraint(integral(x(HN)), S1, S2),\n\tconstraint([x(HN)] >= 0, S2, S3),\n\tcreate_constraint_N(TN, TL, S3, SF,\n\t\t\t    [Va * x(HN) | LVa], LVaF,\n\t\t\t    [W * x(HN) | LW], LWF,\n\t\t\t    [Vo * x(HN) | LVo], LVoF).\n\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([(Name, _, _, _, _)|T], N, NF):-\n\tatom_length(Name, L),\n\t(   L > N -> N1 = L; N1 = N),\n\tcompute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(_S, A0, A1, A2, A3, A4, [], [], VaM, WM, VoM) :-\n\tsformat(W0, A0, [' ']),\n\tsformat(W1, A1, [' ']),\n\tsformat(W2, A2, [VaM]),\n\tsformat(W3, A3, [WM]),\n\tsformat(W4, A4, [VoM]),\n\tformat('~w~w~w~w~w~n', [W0, W1,W2,W3,W4]).\n\n\nprint_results(S, A0, A1, A2, A3, A4, [(Name, _, Va, W, Vo)|T], [N|TN], Va1, W1, Vo1) :-\n\tvariable_value(S, x(N), X),\n\t(   X = 0 -> Va1 = Va2, W1 = W2, Vo1 = Vo2\n\t;\n\t    sformat(S0, A0, [X]),\n\t    sformat(S1, A1, [Name]),\n\t    Vatemp is X * Va,\n\t    Wtemp is X * W,\n\t    Votemp is X * Vo,\n\t    sformat(S2, A2, [Vatemp]),\n\t    sformat(S3, A3, [Wtemp]),\n\t    sformat(S4, A4, [Votemp]),\n\t    format('~w~w~w~w~w~n', [S0,S1,S2,S3,S4]),\n\t    Va2 is Va1 + Vatemp,\n\t    W2 is W1 + Wtemp,\n\t    Vo2 is Vo1 + Votemp ),\n\tprint_results(S, A0, A1, A2, A3, A4, T, TN, Va2, W2, Vo2).\n\n\n\u00a0?- knapsack.\n% 145,319 inferences, 0.078 CPU in 0.079 seconds (99% CPU, 1860083 Lips)\nNb Items       Value    Weigth    Volume\n15 ichor       27000      3.00     0.225\n11 gold        27500     22.00     0.022\n               54500     25.00     0.247\ntrue \n", "explain": "Works with SWI-Prolog and library simplex written by Markus Triska.\nOutput\u00a0:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\nitems = {   [\"panaea\"] = { [\"value\"] = 3000, [\"weight\"] = 0.3, [\"volume\"] = 0.025 },\n            [\"ichor\"]  = { [\"value\"] = 1800, [\"weight\"] = 0.2, [\"volume\"] = 0.015 },\n            [\"gold\"]   = { [\"value\"] = 2500, [\"weight\"] = 2.0, [\"volume\"] = 0.002 }\n        }\n\nmax_weight = 25\nmax_volume = 0.25\n\nmax_num_items = {}\nfor i in pairs( items ) do\n   max_num_items[i] = math.floor( math.min( max_weight / items[i].weight, max_volume / items[i].volume ) )\nend\n\nbest = { [\"value\"] = 0.0, [\"weight\"] = 0.0, [\"volume\"] = 0.0 }\nbest_amounts = {}\n\nfor i = 1, max_num_items[\"panaea\"] do\n    for j = 1, max_num_items[\"ichor\"] do\n        for k = 1, max_num_items[\"gold\"] do\n            current = { [\"value\"]  = i*items[\"panaea\"][\"value\"] + j*items[\"ichor\"][\"value\"] + k*items[\"gold\"][\"value\"],\n                        [\"weight\"] = i*items[\"panaea\"][\"weight\"] + j*items[\"ichor\"][\"weight\"] + k*items[\"gold\"][\"weight\"],\n                        [\"volume\"] = i*items[\"panaea\"][\"volume\"] + j*items[\"ichor\"][\"volume\"] + k*items[\"gold\"][\"volume\"]\n                      }\n                      \n            if current.value > best.value and current.weight <= max_weight and current.volume <= max_volume then\n                best = { [\"value\"] = current.value, [\"weight\"] = current.weight, [\"volume\"] = current.volume }\n                best_amounts = { [\"panaea\"] = i, [\"ichor\"] = j, [\"gold\"] = k }\n            end\n        end\n    end\nend\n\nprint( \"Maximum value:\", best.value )\nfor k, v in pairs( best_amounts ) do\n    print( k, v )\nend\n\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nFunctional approach (Tail recursive)[edit]\nimport scala.annotation.tailrec\n \nobject UnboundedKnapsack extends App {\n  private val (maxWeight, maxVolume) = (BigDecimal(25.0), BigDecimal(0.25))\n  private val items = Seq(Item(\"panacea\", 3000, 0.3, 0.025), Item(\"ichor\", 1800, 0.2, 0.015), Item(\"gold\", 2500, 2.0, 0.002))\n \n  @tailrec\n  private def packer(notPacked: Seq[Knapsack], packed: Seq[Knapsack]): Seq[Knapsack] = {\n    def fill(knapsack: Knapsack): Seq[Knapsack] = items.map(i => Knapsack(i +: knapsack.bagged))\n \n    def stuffer(Seq: Seq[Knapsack]): Seq[Knapsack] = // Cause brute force\n      Seq.map(k => Knapsack(k.bagged.sortBy(_.name))).distinct\n \n    if (notPacked.isEmpty) packed.sortBy(-_.totValue).take(4)\n    else packer(stuffer(notPacked.flatMap(fill)).filter(_.isNotFull), notPacked ++ packed)\n  }\n \n  private case class Item(name: String, value: Int, weight: BigDecimal, volume: BigDecimal)\n \n  private case class Knapsack(bagged: Seq[Item]) {\n    def isNotFull: Boolean = totWeight <= maxWeight && totVolume <= maxVolume\n \n    override def toString = s\"[${show(bagged)} | value: $totValue, weight: $totWeight, volume: $totVolume]\"\n \n    def totValue: Int = bagged.map(_.value).sum\n \n    private def totVolume = bagged.map(_.volume).sum\n \n    private def totWeight = bagged.map(_.weight).sum\n \n    private def show(is: Seq[Item]) =\n      (items.map(_.name) zip items.map(i => is.count(_ == i)))\n        .map { case (i, c) => f\"$i:$c%3d\" }\n        .mkString(\", \")\n  }\n \n  packer(items.map(i => Knapsack(Seq(i))), Nil).foreach(println)\n}\n\n\nOutput:\n[panacea:  0, ichor: 15, gold: 11 | value: 54500, weight: 25.0, volume: 0.247]\n[panacea:  3, ichor: 10, gold: 11 | value: 54500, weight: 24.9, volume: 0.247]\n[panacea:  6, ichor:  5, gold: 11 | value: 54500, weight: 24.8, volume: 0.247]\n[panacea:  9, ichor:  0, gold: 11 | value: 54500, weight: 24.7, volume: 0.247]\n\n\nOutput:See it in running in your browser by ScalaFiddle (JavaScript) or by Scastie (JVM).\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nTranslation of: Python\nvoid main() @safe /*@nogc*/ {\n    import std.stdio, std.algorithm, std.typecons, std.conv;\n\n    static struct Bounty {\n        int value;\n        double weight, volume;\n    }\n\n    immutable Bounty panacea = {3000,  0.3, 0.025};\n    immutable Bounty ichor =   {1800,  0.2, 0.015};\n    immutable Bounty gold =    {2500,  2.0, 0.002};\n    immutable Bounty sack =    {   0, 25.0, 0.25 };\n\n    immutable maxPanacea = min(sack.weight / panacea.weight,\n                               sack.volume / panacea.volume).to!int;\n    immutable maxIchor   = min(sack.weight / ichor.weight,\n                               sack.volume / ichor.volume).to!int;\n    immutable maxGold    = min(sack.weight / gold.weight,\n                               sack.volume / gold.volume).to!int;\n\n    Bounty best = {0, 0, 0};\n    Tuple!(int, int, int) bestAmounts;\n\n    foreach (immutable nPanacea; 0 .. maxPanacea)\n        foreach (immutable nIchor; 0 .. maxIchor)\n            foreach (immutable nGold; 0 .. maxGold) {\n                immutable Bounty current = {\n                    value: nPanacea * panacea.value +\n                           nIchor * ichor.value +\n                           nGold * gold.value,\n                    weight: nPanacea * panacea.weight +\n                            nIchor * ichor.weight +\n                            nGold * gold.weight,\n                    volume: nPanacea * panacea.volume +\n                            nIchor * ichor.volume +\n                            nGold * gold.volume};\n\n                if (current.value > best.value &&\n                    current.weight <= sack.weight &&\n                    current.volume <= sack.volume) {\n                    best = Bounty(current.value, current.weight, current.volume);\n                    bestAmounts = tuple(nPanacea, nIchor, nGold);\n                }\n            }\n\n    writeln(\"Maximum value achievable is \", best.value);\n    writefln(\"This is achieved by carrying (one solution) %d\" ~\n             \" panacea, %d ichor and %d gold\", bestAmounts[]);\n    writefln(\"The weight to carry is %4.1f and the volume used is %5.3f\",\n             best.weight, best.volume);\n}\n\n\nOutput:\nMaximum value achievable is 54500\nThis is achieved by carrying (one solution) 0 panacea, 15 ichor and 11 gold\nThe weight to carry is 25.0 and the volume used is 0.247\nAlternative Version[edit]\n\nvoid main() {\n  import std.stdio, std.algorithm, std.typecons, std.range, std.conv;\n\n  alias Bounty = Tuple!(int,\"value\", double,\"weight\", double,\"volume\");\n\n  immutable panacea = Bounty(3000,  0.3, 0.025);\n  immutable ichor =   Bounty(1800,  0.2, 0.015);\n  immutable gold =    Bounty(2500,  2.0, 0.002);\n  immutable sack =    Bounty(   0, 25.0, 0.25);\n\n  immutable maxPanacea = min(sack.weight / panacea.weight, sack.volume / panacea.volume).to!int;\n  immutable maxIchor   = min(sack.weight / ichor.weight,   sack.volume / ichor.volume).to!int;\n  immutable maxGold    = min(sack.weight / gold.weight,    sack.volume / gold.volume).to!int;\n\n  immutable best =\n    cartesianProduct(maxPanacea.iota, maxIchor.iota, maxGold.iota)\n    .map!(t => tuple(Bounty(t[0] * panacea.value  + t[1] * ichor.value  + t[2] * gold.value,\n                            t[0] * panacea.weight + t[1] * ichor.weight + t[2] * gold.weight,\n                            t[0] * panacea.volume + t[1] * ichor.volume + t[2] * gold.volume), t))\n    .filter!(t => t[0].weight <= sack.weight && t[0].volume <= sack.volume)\n    .reduce!max;\n\n  writeln(\"Maximum value achievable is \", best[0].value);\n  writefln(\"This is achieved by carrying (one solution) %d panacea, %d ichor and %d gold\", best[1][]);\n  writefln(\"The weight to carry is %4.1f and the volume used is %5.3f\", best[0][1..$]);\n}\n\n", "explain": "The output is the same.\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\nimport Data.List (maximumBy)\nimport Data.Ord (comparing)\n\n(maxWgt, maxVol) = (25, 0.25)\nitems =\n   [Bounty  \"panacea\"  3000  0.3  0.025,\n    Bounty  \"ichor\"    1800  0.2  0.015,\n    Bounty  \"gold\"     2500  2.0  0.002]\n\ndata Bounty = Bounty\n   {itemName :: String,\n    itemVal :: Int,\n    itemWgt, itemVol :: Double}\n\nnames = map itemName items\nvals = map itemVal items\nwgts = map itemWgt items\nvols = map itemVol items\n\ndotProduct :: (Num a, Integral b) => [a] -> [b] -> a\ndotProduct factors = sum . zipWith (*) factors . map fromIntegral\n\noptions :: [[Int]]\noptions = filter fits $ mapM f items\n  where f (Bounty _ _ w v) = [0 .. m]\n          where m = floor $ min (maxWgt / w) (maxVol / v)\n        fits opt = dotProduct wgts opt <= maxWgt &&\n                   dotProduct vols opt <= maxVol\n\nshowOpt :: [Int] -> String\nshowOpt opt = concat (zipWith showItem names opt) ++\n    \"total weight: \" ++ show (dotProduct wgts opt) ++\n    \"\\ntotal volume: \" ++ show (dotProduct vols opt) ++\n    \"\\ntotal value: \" ++ show (dotProduct vals opt) ++ \"\\n\"\n  where showItem name num = name ++ \": \" ++ show num ++ \"\\n\"\n\nmain = putStr $ showOpt $ best options\n  where best = maximumBy $ comparing $ dotProduct vals\n\n\npanacea: 9\nichor: 0\ngold: 11\ntotal weight: 24.7\ntotal volume: 0.247\ntotal value: 54500\n", "explain": "This is a brute-force solution: it generates a list of every legal combination of items (options) and then finds the option of greatest value.\nOutput:\n"}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "PowerShell", "code": "\nWorks with: PowerShell version 3.0\n#  Define the items to pack\n$Item = @(\n    [pscustomobject]@{ Name = 'panacea'; Unit = 'vials'  ; value = 3000; Weight = 0.3; Volume = 0.025 }\n    [pscustomobject]@{ Name = 'ichor'  ; Unit = 'ampules'; value = 1800; Weight = 0.2; Volume = 0.015 }\n    [pscustomobject]@{ Name = 'gold'   ; Unit = 'bars'   ; value = 2500; Weight = 2.0; Volume = 0.002 }\n    )\n \n#  Define our maximums\n$MaxWeight = 25\n$MaxVolume = 0.25\n \n#  Set our default value to beat\n$OptimalValue = 0\n \n#  Iterate through the possible quantities of item 0, without going over the weight or volume limit\nForEach ( $Qty0 in 0..( [math]::Min( [math]::Truncate( $MaxWeight / $Item[0].Weight ), [math]::Truncate( $MaxVolume / $Item[0].Volume ) ) ) )\n    {\n    #  Calculate the remaining space\n    $RemainingWeight = $MaxWeight - $Qty0 * $Item[0].Weight\n    $RemainingVolume = $MaxVolume - $Qty0 * $Item[0].Volume\n \n    #  Iterate through the possible quantities of item 1, without going over the weight or volume limit\n    ForEach ( $Qty1 in 0..( [math]::Min( [math]::Truncate( $RemainingWeight / $Item[1].Weight ), [math]::Truncate( $RemainingVolume / $Item[1].Volume ) ) ) )\n        {\n        #  Calculate the remaining space\n        $RemainingWeight2 = $RemainingWeight - $Qty1 * $Item[1].Weight\n        $RemainingVolume2 = $RemainingVolume - $Qty1 * $Item[1].Volume\n \n        #  Calculate the maximum quantity of item 2 for the remaining space, without going over the weight or volume limit\n        $Qty2 = [math]::Min( [math]::Truncate( $RemainingWeight2 / $Item[2].Weight ), [math]::Truncate( $RemainingVolume2 / $Item[2].Volume ) )\n \n        #  Calculate the total value of the items packed\n        $TrialValue =   $Qty0 * $Item[0].Value +\n                        $Qty1 * $Item[1].Value +\n                        $Qty2 * $Item[2].Value\n \n        #  Describe the trial solution\n        $Solution  = \"$Qty0 $($Item[0].Unit) of $($Item[0].Name), \"\n        $Solution += \"$Qty1 $($Item[1].Unit) of $($Item[1].Name), and \"\n        $Solution += \"$Qty2 $($Item[2].Unit) of $($Item[2].Name) worth a total of $TrialValue.\"\n \n        #  If the trial value is higher than previous most valuable trial...\n        If ( $TrialValue -gt $OptimalValue )\n            {\n            #  Set the new number to beat\n            $OptimalValue = $TrialValue\n \n            #  Overwrite the previous optimal solution(s) with the trial solution\n            $Solutions  = @( $Solution )\n            }\n \n        #  Else if the trial value matches the previous most valuable trial...\n       ElseIf ( $TrialValue -eq $OptimalValue )\n            {\n            #  Add the trial solution to the list of optimal solutions\n            $Solutions += @( $Solution )\n            }\n        }\n    }\n \n#  Show the results\n$Solutions\n\n\nOutput:\n0 vials of panacea, 15 ampules of ichor, and 11 bars of gold worth a total of 54500.\n3 vials of panacea, 10 ampules of ichor, and 11 bars of gold worth a total of 54500.\n6 vials of panacea, 5 ampules of ichor, and 11 bars of gold worth a total of 54500.\n9 vials of panacea, 0 ampules of ichor, and 11 bars of gold worth a total of 54500.\n", "explain": ""}, {"task_name": "Knapsack problem/Unbounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Unbounded", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef totalWeight = { list -> list.collect{ it.item.weight * it.count }.sum() }\ndef totalVolume = { list -> list.collect{ it.item.volume * it.count }.sum() }\ndef totalValue = { list -> list.collect{ it.item.value * it.count }.sum() }\n\ndef knapsackUnbounded = { possibleItems, BigDecimal weightMax, BigDecimal volumeMax ->\n    def n = possibleItems.size()\n    def wm = weightMax.unscaledValue()\n    def vm = volumeMax.unscaledValue()\n    def m = (0..n).collect{ i -> (0..wm).collect{ w -> (0..vm).collect{ v -> [] } } }\n    (1..wm).each { w ->\n        (1..vm).each { v ->\n            (1..n).each { i ->\n                def item = possibleItems[i-1]\n                def wi = item.weight.unscaledValue()\n                def vi = item.volume.unscaledValue()\n                def bi = [w.intdiv(wi),v.intdiv(vi)].min()\n                m[i][w][v] = (0..bi).collect{ count ->\n                    m[i-1][w - wi * count][v - vi * count] + [[item:item, count:count]]\n                }.max(totalValue).findAll{ it.count }\n            }\n        }\n    }\n    m[n][wm][vm]\n}\n\n\nSet solutions = []\nitems.eachPermutation { itemList ->\n    def start = System.currentTimeMillis()\n    def packingList = knapsackUnbounded(itemList, 25.0, 0.250)\n    def elapsed = System.currentTimeMillis() - start\n    \n    println \"\\n  Item Order: ${itemList.collect{ it.name.split()[0] }}\"\n    println \"Elapsed Time: ${elapsed/1000.0} s\"\n    \n    solutions << (packingList as Set)\n}\n\nsolutions.each { packingList ->\n    println \"\\nTotal Weight: ${totalWeight(packingList)}\"\n    println \"Total Volume: ${totalVolume(packingList)}\"\n    println \" Total Value: ${totalValue(packingList)}\"\n    packingList.each {\n        printf ('  item:\u00a0%-22s  count:%2d  weight:%4.1f  Volume:%5.3f\\n',\n                it.item.name, it.count, it.item.weight * it.count, it.item.volume * it.count)\n    }\n}\n\n\n  Item Order: [panacea, ichor, gold]\nElapsed Time: 26.883 s\n\n  Item Order: [panacea, gold, ichor]\nElapsed Time: 27.17 s\n\n  Item Order: [ichor, panacea, gold]\nElapsed Time: 25.884 s\n\n  Item Order: [ichor, gold, panacea]\nElapsed Time: 26.126 s\n\n  Item Order: [gold, panacea, ichor]\nElapsed Time: 26.596 s\n\n  Item Order: [gold, ichor, panacea]\nElapsed Time: 26.47 s\n\nTotal Weight: 25.0\nTotal Volume: 0.247\n Total Value: 54500\n  item: gold (bars)             count:11  weight:22.0  Volume:0.022\n  item: ichor (ampules of)      count:15  weight: 3.0  Volume:0.225\n\nTotal Weight: 24.7\nTotal Volume: 0.247\n Total Value: 54500\n  item: gold (bars)             count:11  weight:22.0  Volume:0.022\n  item: panacea (vials of)      count: 9  weight: 2.7  Volume:0.225\n\nTotal Weight: 24.9\nTotal Volume: 0.247\n Total Value: 54500\n  item: gold (bars)             count:11  weight:22.0  Volume:0.022\n  item: ichor (ampules of)      count:10  weight: 2.0  Volume:0.150\n  item: panacea (vials of)      count: 3  weight: 0.9  Volume:0.075\n\nTotal Weight: 24.8\nTotal Volume: 0.247\n Total Value: 54500\n  item: gold (bars)             count:11  weight:22.0  Volume:0.022\n  item: ichor (ampules of)      count: 5  weight: 1.0  Volume:0.075\n  item: panacea (vials of)      count: 6  weight: 1.8  Volume:0.150\n", "explain": "Solution: dynamic programming\nTest:\nOutput:\nWhile this solver can only be used to detect two of the four possible solutions, the other two may be discovered by noting that 5 ampules of ichor and 3 vials of panacea have the same value and the same volume and only differ by 0.1 in weight. Thus the other two solutions can be derived by substitution as follows:\n"}]