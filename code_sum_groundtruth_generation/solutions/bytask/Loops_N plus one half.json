[{"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Python", "code": "\n\nprint ( ', '.join(str(i+1) for i in range(10)) )\n\n>>> from sys import stdout\n>>> write = stdout.write\n>>> n, i = 10, 1\n>>> while True:\n    write(i)\n    i += 1\n    if i > n:\n        break\n    write(', ')\n\n    \n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n>>>\n\n[print(str(i+1) + \", \",end='') if i < 9 else print(i+1) for i in range(10)]\nWorks with: Python version 3.x\nn, i = 10, 1\nwhile True:\n    print(i, end=\"\")\n    i += 1\n    if i > n:\n        break\n    print(\", \", end=\"\")\n", "explain": "The particular pattern and example chosen in the task description is recognised by the Python language and there are more idiomatic ways to achieve the result that don't even require an explicit conditional test such as:\nBut the named pattern is shown by code such as the following:\nList comprehension one-liner\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "C", "code": "\nTranslation of: C++\n#include <stdio.h>\n\nint main()\n{\n  int i;\n  for (i = 1; i <= 10; i++) {\n    printf(\"%d\", i);\n    printf(i == 10 ? \"\\n\" : \", \");\n  }\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "C++", "code": "\n#include <iostream>\n \nint main()\n{ \n  int i;\n  for (i = 1; i<=10 ; i++){\n    std::cout << i;\n    if (i < 10)\n     std::cout << \", \";\n  }\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Java", "code": "\npublic static void main(String[] args) {\n    for (int i = 1; ; i++) {\n        System.out.print(i);\n        if (i == 10)\n            break;\n        System.out.print(\", \");\n    }\n    System.out.println();\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "C#", "code": "\nusing System;\n\nclass Program\n{\n    static void Main(string[] args)\n    {\n        for (int i = 1; ; i++)\n        {\n            Console.Write(i);\n            if (i == 10) break;\n            Console.Write(\", \");\n        }\n        Console.WriteLine();\n    }\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "JavaScript", "code": "\nfunction loop_plus_half(start, end) {\n    var str = '',\n        i;\n    for (i = start; i <= end; i += 1) {\n        str += i;\n        if (i === end) {\n          break;\n        }\n        str += ', ';\n    }\n    return str;\n}\n \nalert(loop_plus_half(1, 10));\n\n\nfunction range(m, n) {\n  return Array.apply(null, Array(n - m + 1)).map(\n    function (x, i) {\n      return m + i;\n    }\n  );\n}\n \nconsole.log(\n  range(1, 10).join(', ')\n);\n\n\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n\nfunction range(m, n) {\n  return Array.apply(null, Array(n - m + 1)).map(function (x, i) {\n    return m + i;\n  });\n}\n\nconsole.log(\n  (function (nFrom, nTo) {\n    var iLast = nTo - 1;\n\n    return range(nFrom, nTo).reduce(\n      function (accumulator, n, i) {\n        return accumulator +\n          n.toString() +\n\n          (i < iLast ? ', ' : ''); // conditional sub-expression\n\n      }, ''\n    )\n  })(1, 10)\n);\n\n\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\nOtherwise[edit]\nvar s=1, e=10\nfor (var i=s; i<=e; i+=1) {\n\tdocument.write( i==s ? '' : ', ', i )\n}\n\n\nvar s=1, e=10\nfor (;; s+=1) {\n\tdocument.write( s )\n\tif (s==e) break\n\tdocument.write( ', ' )\n}\n\n\nOutput:\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10 \n\n", "explain": "Alternatively, if we stand back for a moment from imperative assumptions about the nature and structure of computing tasks, it becomes clear that the problem of special transitional cases as a pattern terminates has no necessary connection with loops. (See the comments accompanying the ACL2, Haskell, IDL, J and R examples above and below, and see also some of the approaches taken in languages like Clojure and Scala.\nIf a JavaScript expression evaluates to an array [1 .. 10] of integers, for example, we can map that array directly to a comma-delimited string by using the Array.join() function, writing something like:\nOutput: \nOtherwise, any special transitional case at the end of a pattern can be handled by defining conditional values for one or more sub-expressions:\nOutput:\nor\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "PHP", "code": "\nfor ($i = 1; $i <= 11; $i++) {\n    echo $i;\n    if ($i == 10)\n        break;\n    echo ', ';\n}\necho \"\\n\";\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Fortran", "code": "\nWorks with: FORTRAN version IV and later\nC     Loops N plus one half - Fortran IV (1964)\n      INTEGER I\n      WRITE(6,301) (I,I=1,10)\n  301 FORMAT((I3,','))\n      END\n\nWorks with: Fortran version 77 and later\nC     WARNING: This program is not valid ANSI FORTRAN 77 code. It uses\nC     two nonstandard characters on the lines labelled 5001 and 5002.\nC     Many F77 compilers should be okay with it, but it is *not*\nC     standard.\n      PROGRAM LOOPPLUSONEHALF\n        INTEGER I, TEN\nC       I'm setting a parameter to distinguish from the label 10.\n        PARAMETER (TEN = 10)\n\n        DO 10 I = 1, TEN\nC         Write the number only.\n          WRITE (*,5001) I\n\nC         If we are on the last one, stop here. This will make this test\nC         every iteration, which can slow your program down a little. If\nC         you want to speed this up at the cost of your own convenience,\nC         you could loop only to nine, and handle ten on its own after\nC         the loop is finished. If you don't care, power to you.\n          IF (I .EQ. TEN) GOTO 10\n\nC         Append a comma to the number.\n          WRITE (*,5002) ','\n   10   CONTINUE\n\nC       Always finish with a newline. This programmer hates it when a\nC       program does not end its output with a newline.\n        WRITE (*,5000) ''\n        STOP\n\n 5000   FORMAT (A)\n\nC       Standard FORTRAN 77 is completely incapable of completing a\nC       WRITE statement without printing a newline. This program would\nC       be much more difficult (i.e. impossible) to write in the ANSI\nC       standard, without cheating and saying something like:\nC\nC           WRITE (*,*) '1, 2, 3, 4, 5, 6, 7, 8, 9, 10'\nC\nC       The dollar sign at the end of the format is a nonstandard\nC       character. It tells the compiler not to print a newline. If you\nC       are actually using FORTRAN 77, you should figure out what your\nC       particular compiler accepts. If you are actually using Fortran\nC       90 or later, you should replace this line with the commented\nC       line that follows it.\n 5001   FORMAT (I3, $)\n 5002   FORMAT (A, $)\nC5001   FORMAT (T3, ADVANCE='NO')\nC5001   FORMAT (A, ADVANCE='NO')\n      END\n\nWorks with: Fortran version 90 and later\ni = 1\ndo\n  write(*, '(I0)', advance='no') i\n  if ( i == 10 ) exit\n  write(*, '(A)', advance='no') ', '\n  i = i + 1\nend do\nwrite(*,*)\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    for i := 1; ; i++ {\n        fmt.Print(i)\n        if i == 10 {\n            fmt.Println()\n            break\n        }\n        fmt.Print(\", \")\n    }\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program loopnplusone.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessResult:      .ascii \"\"                    @ message result\nsMessValeur:       .fill 11, 1, ' '\nszMessComma:       .asciz \",\"\nszCarriageReturn:  .asciz \"\\n\"\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                       @ entry of program \n    mov r4,#1                               @ loop counter\n1:                                          @ begin loop \n    mov r0,r4\n    ldr r1,iAdrsMessValeur                  @ display value\n    bl conversion10                         @ decimal conversion\n    ldr r0,iAdrszMessResult\n    bl affichageMess                        @ display message\n    ldr r0,iAdrszMessComma\n    bl affichageMess                        @ display comma\n    add r4,#1                               @ increment counter\n    cmp r4,#10                              @ end\u00a0?\n    blt 1b                                  @ no ->begin loop one\n    mov r0,r4\n    ldr r1,iAdrsMessValeur                  @ display value\n    bl conversion10                         @ decimal conversion\n    ldr r0,iAdrszMessResult\n    bl affichageMess                        @ display message\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess                        @ display return line\n\n100:                                        @ standard end of the program \n    mov r0, #0                              @ return code\n    mov r7, #EXIT                           @ request to exit program\n    svc #0                                  @ perform the system call\n\niAdrsMessValeur:          .int sMessValeur\niAdrszMessResult:         .int szMessResult\niAdrszMessComma:          .int szMessComma\niAdrszCarriageReturn:     .int szCarriageReturn\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                   @ save  registres\n    mov r2,#0                               @ counter length \n1:                                          @ loop length calculation \n    ldrb r1,[r0,r2]                         @ read octet start position + index \n    cmp r1,#0                               @ if 0 its over \n    addne r2,r2,#1                          @ else add 1 in the length \n    bne 1b                                  @ and loop \n                                            @ so here r2 contains the length of the message \n    mov r1,r0                               @ address message in r1 \n    mov r0,#STDOUT                          @ code to write to the standard output Linux \n    mov r7, #WRITE                          @ code call system \"write\" \n    svc #0                                  @ call systeme \n    pop {r0,r1,r2,r7,lr}                    @ restaur registers */ \n    bx lr                                   @ return  \n/******************************************************************/\n/*     Converting a register to a decimal                                 */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                         @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n\n1:                                          @ start loop\n    bl divisionpar10                        @ r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                              @ digit\n    strb r1,[r3,r2]                         @ store digit on area\n    sub r2,#1                               @ previous position\n    cmp r0,#0                               @ stop if quotient = 0 \n    bne 1b                                  @ else loop\n                                            @ end replaces digit in front of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2] \n    strb r1,[r3,r4]                         @ store in area begin\n    add r4,#1\n    add r2,#1                               @ previous position\n    cmp r2,#LGZONECAL                       @ end\n    ble 2b                                  @ loop\n    mov r1,#0                               @ final zero \n    strb r1,[r3,r4]\n100:\n    pop {r1-r4,lr}                          @ restaur registres \n    bx lr                                   @return\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n    push {r2-r4}                           @ save registers  */\n    mov r4,r0  \n    mov r3,#0x6667                         @ r3 <- magic_number  lower\n    movt r3,#0x6666                        @ r3 <- magic_number  upper\n    smull r1, r2, r3, r0                   @ r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) \n    mov r2, r2, ASR #2                     @ r2 <- r2 >> 2\n    mov r1, r0, LSR #31                    @ r1 <- r0 >> 31\n    add r0, r2, r1                         @ r0 <- r2 + r1 \n    add r2,r0,r0, lsl #2                   @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                   @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2-r4}\n    bx lr                                  @ return\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Delphi", "code": "\nprogram LoopsNPlusOneHalf;\n\n{$APPTYPE CONSOLE}\n\nvar\n  i: integer;\nconst\n  MAXVAL = 10;\nbegin\n  for i := 1 to MAXVAL do\n  begin\n    Write(i);\n    if i < MAXVAL then\n      Write(', ');\n  end;\n  Writeln;\nend.\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Ruby", "code": "\n(1..10).each do |i|\n  print i\n  break if i == 10\n  print \", \"\nend\nputs\n\nputs (1..10).join(\", \")\n", "explain": "More idiomatic Ruby to obtain the same result is:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Rust", "code": "\nfn main() {\n    for i in 1..=10 {\n        print!(\"{}{}\", i, if i < 10 { \", \" } else { \"\\n\" });\n    }\n}\n\nfn main() {\n    for i in 1..=10 {\n        print!(\"{}\", i);\n        if i == 10 { \n            break;\n        }\n        print!(\", \");\n    }\n    println!();\n}\n\nfn main() {\n    println!(\n        \"{}\",\n        (1..=10)\n            .map(|i| i.to_string())\n            .collect::<Vec<_>>()\n            .join(\", \")\n    );\n}\n", "explain": "More like the problem description:\nAlternative solution using join.\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Swift", "code": "\nWorks with: Swift version 1.x\nfor var i = 1;\u00a0; i++ {\n    print(i)\n    if i == 10 {\n        println()\n        break\n    }\n    print(\", \")\n}\nWorks with: Swift version 2 The usual way to do this with Swift 2 is:\nfor i in 1...10 {\n    \n    print(i, terminator: i == 10\u00a0? \"\\n\"\u00a0: \", \")\n}\n\nfor var i = 1;\u00a0; i++ {\n    print(i, terminator: \"\")\n    if i == 10 {\n        print(\"\")\n        break\n    }\n    print(\", \", terminator: \"\")\n}\n", "explain": "To satisfy the specification, we have to do something similar to Swift 1.x and other C-like languages:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "R", "code": "\n\npaste(1:10, collapse=\", \")\n\nfor(i in 1:10)\n{\n   cat(i)\n   if(i==10) \n   {\n      cat(\"\\n\")\n      break\n   }\n   cat(\", \")\n}\n", "explain": "The natural way to solve this task in R is:\nThe task specifies that we should use a loop however, so this more verbose code is needed.\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "COBOL", "code": "\nWorks with: OpenCOBOL\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Loop-N-And-Half.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  I    PIC 99.\n       01  List PIC X(45).\n\n       PROCEDURE DIVISION.\n           PERFORM FOREVER\n               *> The list to display must be built up because using\n               *> DISPLAY adds an endline at the end automatically.\n               STRING FUNCTION TRIM(List) \" \"  I  INTO List\n\n               IF I = 10\n                   EXIT PERFORM\n               END-IF\n               \n               STRING FUNCTION TRIM(List) \",\" INTO List\n\n               ADD 1 TO I\n           END-PERFORM\n\n           DISPLAY List\n\n           GOBACK\n           .\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. LOOP-1p5-NOADV.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  I    PIC 99 VALUE 1.\n01\tIDISP\tPIC Z9.\nPROCEDURE DIVISION.\n\tPERFORM FOREVER\n\t\tMOVE I TO IDISP\n\t\tDISPLAY FUNCTION TRIM(IDISP) WITH NO ADVANCING\n\t\tIF I = 10\n\t\t\tEXIT PERFORM\n\t\tEND-IF\n\t\tDISPLAY \", \" WITH NO ADVANCING\n\t\tADD 1 TO I\n\tEND-PERFORM.\n\tSTOP RUN.\n\tEND-PROGRAM.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. LOOP-1p5-NOADV-GOTO.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  I\tPIC 99\tVALUE 1.\n\t88\tEND-LIST\tVALUE 10.\n01\tI-OUT\tPIC Z9.\nPROCEDURE DIVISION.\n01-LOOP.\n\tMOVE I TO I-OUT.\n\tDISPLAY FUNCTION TRIM(I-OUT) WITH NO ADVANCING.\n\tIF END-LIST GO TO 02-DONE.\n\tDISPLAY \", \" WITH NO ADVANCING.\n\tADD 1 TO I.\n\tGO TO 01-LOOP.\n02-DONE.\n\tSTOP RUN.\n\tEND-PROGRAM.\n\n\nIDENTIFICATION DIVISION.\nPROGRAM-ID. LOOP-1p5-NOADV-VARY.\nDATA DIVISION.\nWORKING-STORAGE SECTION.\n01  I    \tPIC 99  VALUE 1.\n\t88\tEND-LIST\tVALUE 10.\n01\tI-OUT\tPIC Z9.\nPROCEDURE DIVISION.\n\tPERFORM WITH TEST AFTER VARYING I FROM 1 BY 1 UNTIL END-LIST \n\t\tMOVE I TO I-OUT\n\t\tDISPLAY FUNCTION TRIM(I-OUT) WITH NO ADVANCING\n\t\tIF NOT END-LIST\n\t\t\tDISPLAY \", \" WITH NO ADVANCING\n\t\tEND-IF\n\tEND-PERFORM.\n\tSTOP RUN.\n\tEND-PROGRAM.\n\n", "explain": "Free-form, 'List'-free version, using DISPLAY NO ADVANCING.\nFree-form, GO TO, 88-level. Paragraphs in PROCEDURE DIVISION.\nUsing 'PERFORM VARYING'\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure LoopsAndHalf is \nbegin\n  for i in 1 .. 10 loop\n    Ada.Text_IO.put (i'Img);\n    exit when i = 10;\n    Ada.Text_IO.put (\",\");\n  end loop;\n  Ada.Text_IO.new_line;\nend LoopsAndHalf;\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Julia", "code": "\n\nfor i = 1:10\n  print(i)\n  i == 10 && break\n  print(\", \")\nend\n\n\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n", "explain": "The short-circuiting && is idiomatic to Julia - the second expression will only be evaluated if the first one is true.\nOutput:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun main(args: Array<String>) {\n    for (i in 1 .. 10) {\n        print(i)\n        if (i < 10) print(\", \")\n    }\n}\n\n\nOutput:\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Perl", "code": "\nfor my $i(1..10) {\n    print $i;\n    last if $i == 10;\n    print ', ';\n}\nprint \"\\n\";\n\nprint join(', ', 1..10), \"\\n\";\n", "explain": "In perl one would solve the task via join.\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Prolog", "code": "\nexample\u00a0:- \n  between(1,10,Val), write(Val), Val<10, write(', '), fail.\nexample.\n?- example.\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\ntrue.\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Lua", "code": "\n\nfor i = 1, 10 do\n  io.write(i)\n  if i == 10 then break end\n  io.write\", \"\nend\n\n", "explain": "Translation of C:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Scala", "code": "\nLibrary: Scala\nvar i = 1\nwhile ({\n  print(i)\n  i < 10\n}) {\n  print(\", \")\n  i += 1\n}\nprintln()\nprintln((1 to 10).mkString(\", \"))\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Dart", "code": "\nString loopPlusHalf(start, end) {\n  var result = '';\n  for(int i = start; i <= end; i++) {\n    result += '$i';\n    if(i == end) {\n      break;\n    }\n    result += ', ';\n  }\n  return result;\n}\n\nvoid main() {\n  print(loopPlusHalf(1, 10));\n}\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "D", "code": "\nIterative[edit]\nimport std.stdio;\n \nvoid main() {\n    for (int i = 1; ; i++) {\n        write(i);\n        if (i >= 10)\n            break;\n        write(\", \");\n    }\n\n    writeln();\n}\n\n\nOutput:\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\nFunctional Style[edit]\nvoid main() {\n    import std.stdio, std.range, std.algorithm, std.conv, std.string;\n    iota(1, 11).map!text.join(\", \").writeln;\n\n    // A simpler solution:\n    writefln(\"%(%d,\u00a0%)\", iota(1, 11));\n}\n\n\nOutput:\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Haskell", "code": "\nmain :: IO ()\nmain = forM_ [1 .. 10] $ \\n -> do\n            putStr $ show n\n            putStr $ if n == 10 then \"\\n\" else \", \"\n\n\nintercalate \", \" (map show [1..10])\n\n", "explain": "You can also use intersperse\u00a0:: a -> [a] -> [a]\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Scheme", "code": "\n\n(call-with-current-continuation\n (lambda (esc)\n   (do ((i 1 (+ 1 i))) (#f)\n     (display i)\n     (if (= i 10) (esc (newline)))\n     (display \", \"))))\n\n(let loop ((i 0))\n  (display i)\n  (if (= i 10)\n      (newline)\n      (begin\n        (display \", \")\n        (loop (+ 1 i)))))\n", "explain": "It is possible to use continuations:\nBut usually making the tail recursion explicit is enough:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "PowerShell", "code": "\nTranslation of: C\nfor ($i = 1; $i -le 10; $i++) {\n    Write-Host -NoNewLine $i\n    if ($i -eq 10) {\n        Write-Host\n        break\n    }\n    Write-Host -NoNewLine \", \"\n}\n\nswitch (1..10) {\n    { $true }     { Write-Host -NoNewLine $_ }\n    { $_ -lt 10 } { Write-Host -NoNewLine \", \" }\n    { $_ -eq 10 } { Write-Host }\n}\n", "explain": "An interesting alternative solution, although not strictly a loop, even though switch certainly loops over the given range.\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Logo", "code": "\nto comma.list :n\n  repeat :n-1 [type repcount type \"|, |]\n  print :n\nend\n\ncomma.list 10\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "ColdFusion", "code": "\n\n<cfloop index = \"i\" from = \"1\" to = \"10\">\n  #i#\n  <cfif i EQ 10>\n    <cfbreak />\n  </cfif>\n  , \n</cfloop>\n\n\n<cfscript>\n  for( i = 1; i <= 10; i++ ) //note: the ++ notation works only on version 8 up, otherwise use i=i+1\n  {\n    writeOutput( i );\n    \n    if( i == 10 )\n    {\n      break;\n    }\n    writeOutput( \", \" );\n  }\n</cfscript>\n\n", "explain": "With tags:\nWith script:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "F#", "code": "\n\nlet rec print (lst : int list) =\n    match lst with\n    | hd :: [] ->\n        printf \"%i \" hd\n    | hd :: tl ->\n        printf \"%i, \" hd\n        print tl\n    | [] -> printf \"\\n\"\n\nprint [1..10]\n\n", "explain": "Functional version that works for lists of any length\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Groovy", "code": "\n\nfor(i in (1..10)) {\n    print i\n    if (i == 10) break\n    print ', '\n}\n\n\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n", "explain": "Solution:\nOutput:\n"}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "Zig", "code": "\nconst std = @import(\"std\");\npub fn main() !void {\n    const stdout_wr = std.io.getStdOut().writer();\n    var i: u8 = 1;\n    while (i <= 10)\u00a0: (i += 1) {\n        try stdout_wr.print(\"{d}\", .{i});\n        if (i == 10) {\n            try stdout_wr.writeAll(\"\\n\");\n        } else {\n            try stdout_wr.writeAll(\", \");\n        }\n    }\n}\n\n\n\n", "explain": ""}, {"task_name": "Loops/N plus one half", "task_url": "https://rosettacode.org/wiki/Loops/N_plus_one_half", "task_cat": "Iteration", "lang": "AWK", "code": "\n\n$ awk 'BEGIN{for(i=1;i<=10;i++){printf i;if(i<10)printf \", \"};print}'\n\n\nOutput:\n1, 2, 3, 4, 5, 6, 7, 8, 9, 10\n\nBEGIN {\n  n=10\n  for(i=1;i<=n;i++) {\n    printf i; \n    if(i<n) printf \", \"\n  }\n  print\n}\n\n\n", "explain": "One-liner:\nReadable version:\nSame output.\n"}]