[{"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Python", "code": "\n\narray = []\n\narray.append(1)\narray.append(3)\n\narray[0] = 2\n\nprint(array[0])\n\nmy_array = [0] * size\n\nmy_array = [[0] * width] * height  # DOES NOT WORK AS INTENDED!!!\n\nmy_array = [[0 for x in range(width)] for y in range(height)]\n\nmy_array = list()\nfor x in range(height):\n   my_array.append([0] * width)\n\n# Retrieve an element directly from the array.\nitem = array[index]\n\n# Use the array like a stack.  Note that using the pop() method removes the element.\narray.pop()  # Pop last item in a list\narray.pop(0)  # Pop first item in a list\n\n# Using a negative element counts from the end of the list.\nitem = array[-1]  # Retrieve last element in a list.\n\ntry:\n    # This will cause an exception, which will then be caught.\n    print(array[len(array)])\nexcept IndexError as e:\n    # Print the exception. \n    print(e)\n\nanother_array = my_array[1:3]\n", "explain": "Python lists are dynamically resizeable.\nA simple, single-dimensional array can also be initialized thus:\nHowever, this will not work as intended if one tries to generalize from the syntax:\nThis creates a list of \"height\" number of references to one list object... which is a list of width instances of the number zero.  Due to the different semantics of immutables (strings, numbers) and mutables (dictionaries, lists), a change to any one of the \"rows\" will affect the values in all of them.  Thus we need to ensure that we initialize each row with a newly generated list.\nTo initialize a list of lists one could use a pair of nested list comprehensions like so:\nThat is equivalent to:\nTo retrieve an element in an array, use any of the following methods:\nPython produces an IndexError when accessing elements out of range:\nSlicing a list creates a new list.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "C", "code": "\n\nint myArray2[10] = { 1, 2, 0 }; /* the rest of elements get the value 0 */\nfloat myFloats[] ={1.2, 2.5, 3.333, 4.92, 11.2, 22.0 }; /* automatically sizes */\n\n\n#define MYFLOAT_SIZE (sizeof(myFloats)/sizeof(myFloats[0]))\n\n\nlong a2D_Array[3][5];    /* 3 rows, 5 columns. */\nfloat my2Dfloats[][3] = { \n   1.0, 2.0, 0.0,\n   5.0, 1.0, 3.0 };\n#define FLOAT_ROWS (sizeof(my2Dfloats)/sizeof(my2dFloats[0]))\n\n\nint numElements = 10;\nint *myArray = malloc(sizeof(int) * numElements);  /* array of 10 integers */\nif ( myArray != NULL )   /* check to ensure allocation succeeded. */\n{\n  /* allocation succeeded */\n  /* at the end, we need to free the allocated memory */\n  free(myArray);\n}\n                    /* calloc() additionally pre-initializes to all zeros */\nshort *myShorts = calloc( numElements, sizeof(short)); /* array of 10 */ \nif (myShorts != NULL)....\n\n\nmyArray[0] = 1;\nmyArray[1] = 3;\n\n\nprintf(\"%d\\n\", myArray[1]);\n\n\n*(array + index) = 1;\nprintf(\"%d\\n\", *(array + index));\n3[array] = 5;\n\n\n#define XSIZE 20\ndouble *kernel = malloc(sizeof(double)*2*XSIZE+1);\nif (kernel) {\n   kernel += XSIZE;\n   for (ix=-XSIZE; ix<=XSIZE; ix++) {\n       kernel[ix] = f(ix);\n   ....\n   free(kernel-XSIZE);\n   }\n}\n\n\nint *array = malloc (sizeof(int) * 20);\n....\narray = realloc(array, sizeof(int) * 40);\n\n\n#include <stdlib.h>\n#include <stdio.h>\ntypedef struct node{\n  char value;\n  struct node* next;\n} node;\ntypedef struct charList{\n  node* first;\n  int size;\n} charList;\n\ncharList createList(){\n  charList foo = {.first = NULL, .size = 0};\n  return foo;\n}\nint addEl(charList* list, char c){\n  if(list != NULL){\n    node* foo = (node*)malloc(sizeof(node));\n    if(foo == NULL) return -1;\n    foo->value = c; foo->next = NULL;\n    if(list->first == NULL){\n      list->first = foo;\n    }else{\n      node* it= list->first;\n      while(it->next != NULL)it = it->next;\n      it->next = foo;\n    }\n    list->size = list->size+1;\n    return 0;\n  }else return -1;\n}\nint removeEl(charList* list, int index){\n    if(list != NULL && list->size > index){\n      node* it = list->first;\n      for(int i = 0; i < index-1; i++) it = it->next;\n      node* el = it->next;\n      it->next = el->next;\n      free(el);\n      list->size--;\n      return 0;\n    }else return -1;\n}\nchar getEl(charList* list, int index){\n    if(list != NULL && list->size > index){\n        node* it = list->first;\n        for(int i = 0; i < index; i++) it = it->next;\n        return it->value;\n    }else return '\\0';\n}\nstatic void cleanHelp(node* el){\n  if(el != NULL){\n    if(el->next != NULL) cleanHelp(el->next);\n    free(el);\n  }\n}\nvoid clean(charList* list){\n  cleanHelp(list->first);\n  list->size = 0;\n}\n\n", "explain": "Fixed size static array of integers with initialization:\nWhen no size is given, the array is automatically sized. Typically this is how initialized arrays are defined. When this is done, you'll often see a definition that produces the number of elements in the array, as follows.\nWhen defining autosized multidimensional arrays, all the dimensions except the first (leftmost) need to be defined. This is required in order for the compiler to generate the proper indexing for the array.\nWhen the size of the array is not known at compile time, arrays may be dynamically\nallocated to the proper size. The malloc(), calloc() and free() functions require the header stdlib.h.\nOnce allocated, myArray can be used as a normal array.\nThe first element of a C array is indexed with 0. To set a value:\nAnd to retrieve it (e.g. for printing, provided that the stdio.h header was included for the printf function)\nThe array[index] syntax can be considered as a shortcut for *(index + array) and\nthus the square brackets are a commutative binary operator:\nThere's no bounds check on the indexes. Negative indexing can be implemented as in the following.\nIn C99, it is possible to declare arrays with a size that is only known at runtime (e.g. a number input by the user).\nTypically dynamic allocation is used and the allocated array is sized to the maximum that might be needed.  A additional variable is \ndeclared and used to maintain the current number of elements used.  In C, arrays may be dynamically resized if they were allocated:\nA Linked List for chars may be implemented like this:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "C++", "code": "\nWorks with: C++11\n\n#include <array>\n#include <vector>\n\n// These headers are only needed for the demonstration\n#include <algorithm>\n#include <iostream>\n#include <iterator>\n#include <string>\n\n// This is a template function that works for any array-like object\ntemplate <typename Array>\nvoid demonstrate(Array& array)\n{\n  // Array element access\n  array[2] = \"Three\";  // Fast, but unsafe - if the index is out of bounds you\n                       // get undefined behaviour\n  array.at(1) = \"Two\"; // *Slightly* less fast, but safe - if the index is out\n                       // of bounds, an exception is thrown\n  \n  // Arrays can be used with standard algorithms\n  std::reverse(begin(array), end(array));\n  std::for_each(begin(array), end(array),\n    [](typename Array::value_type const& element) // in C++14, you can just use auto\n    {\n      std::cout << element << ' ';\n    });\n  \n  std::cout << '\\n';\n}\n\nint main()\n{\n  // Compile-time sized fixed-size array\n  auto fixed_size_array = std::array<std::string, 3>{ \"One\", \"Four\", \"Eight\" };\n  // If you do not supply enough elements, the remainder are default-initialized\n  \n  // Dynamic array\n  auto dynamic_array = std::vector<std::string>{ \"One\", \"Four\" };\n  dynamic_array.push_back(\"Eight\"); // Dynamically grows to accept new element\n  \n  // All types of arrays can be used more or less interchangeably\n  demonstrate(fixed_size_array);\n  demonstrate(dynamic_array);\n}\n\n", "explain": "C++ supports several types of array, depending on whether or not the size is known at compile time, and whether the array must be fixed-size or can grow.\nstd::array<T, N> is a fixed-size array of T objects.\nThe size (N) must be known at compile time.\nIt wraps a C array, and provides additional functionality and safety.\nDepending on how it is used, it may be dynamically allocated on the stack as needed, placed in read-only program memory at load time, or possibly may only exist during compilation and get optimized away, among other possibilities.\nstd::vector<T> is a resizable array of T objects.\nThe memory for the array will be allocated from the heap (unless a custom allocator is used).\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Java", "code": "\n\nString[] strings;\nint[] values;\n\nString strings[];\nint values[];\n\nString[] strings = new String[] { \"rosetta\", \"code\" };\nint[] values = new int[] { 1, 2, 3 };\nString[] strings;\nstrings = new String[] { \"rosetta\", \"code\" };\nint[] values;\nvalues = new int[] { 1, 2, 3 };\n\nString[] strings = new String[2];\nint[] values = new int[3];\n\nString string = strings[0];\nint value = values[2];\n\nString[] strings = new String[2];\nstrings[0] = \"rosetta\";\nstrings[1] = \"code\";\nString string = strings[0] + \" \" + strings[1];\n\nrosetta code\n\n\nint[] values = new int[10];\nArrays.fill(values, 100);\n\nArrays.toString(values);\n\n[100, 100, 100, 100, 100, 100, 100, 100, 100, 100]\n\nList<String> strings;\nList<Integer> values;\n\nList<String> strings = new ArrayList<>();\nList<Integer> values = new ArrayList<>();\n\nstrings.add(\"rosetta\");\nstrings.add(\"code\");\nvalues.add(1);\nvalues.add(2);\nvalues.add(3);\n\nstrings.add(\"code\");\nstrings.add(0, \"rosetta\");\n\nstrings.set(0, \"ROSETTA\");\nstrings.set(1, \"CODE\");\n\nDeque<String> strings = new ArrayDeque<>();\n\nstrings.push(\"code\");\nstrings.push(\"rosetta\");\n\nstrings.pop();\n", "explain": "In Java you can create an immutable array of any Object or primitive data-type by appending the declaring type with square brackets, [ and ].\nAlternately, you could place the brackets after the declaring variable name, although this is discouraged as it aspects the name rather than the type.\nInitialization can appear during the declaration, or after.\nIf your arrays contents are more dynamic, and known only at runtime, you can alternately specify the array size by adding it to the assigned type's square brackets.\nTo access an array element you, again, use the square-bracket syntax, specifying the element's index within it.\nJava indices are 0-based, so, for example, element 1 is at index 0.\nHere is a basic demonstration of using an array.\nIf you printed string to the standard-out, you would get the following.\nJava offers the Arrays class, which provides numerous array-related operations.\nA useful option is the Arrays.fill method, which can be used to initialize each element to a specified value.\nAdditionally, you can print the contents of an array using the Arrays.toString method.\nIf you printed values to the standard-out, you'd get the following.\n\nJava also offers a dynamic, mutable array under the Java Collections Framework List and Deque interfaces.\nBoth which provide a substantial amount of implementing classes, for various types of dynamic array related tasks.\nThe most logical, for this demonstration, would be the ArrayList and ArrayDeque.\nThe ArrayList declaration is slightly different than that of the array, as you are simply calling the constructor of a class.\nWe'll use List as our declaring type, since, as with most interfaces, it's more logical to specify it as the declaring type during the instantiation of any implementing type.\nImmediately after the declaring type you'll use the 'diamond operators', < and >, with the data type of the array specified within.\nSimilar to an array, the initialization can appear during the declaration or after.\nNote, the ArrayList 'diamond-operator' does not require the declared-type, as it's inferred by the declaring-type.\nAdding an element is done via the List.add method.\nAdditionally, you could specify an index at the List.add method, which will insert the element at the index, shifting the current element at that index, and all subsequent elements to the right by 1.\nList.set is used for mutating an already existing element.\nIt's worth noting that Java also offers a Vector class, which is nearly similar to the ArrayList class except it should be used in multi-threaded situations, as ArrayList will produced concurrency issues.\nThe ArrayDeque is also another option for dynamic, mutable array situations, and provides a LIFO, \"Last In First Out\", operation for its elements.\nA LIFO pattern can be assimilated to a stack of plates at a buffet, as the most recent plate to be placed on the stack is the first to be taken.\nYou declare and instantiate an ArrayDeque in the same manner as an ArrayList, using the 'diamond-operators'.\nThere are numerous methods within the Deque class for accessing and mutating the data.\nFor this task, I'll use the most generic and logical to a LIFO pattern.\nTo add an element you use the Deque.push method.\nTo remove an item you use the Deque.pop method.\nElements of a Deque are not index based.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "C#", "code": "\n\n int[] numbers = new int[10];\n\n\n string[] words = { \"these\", \"are\", \"arrays\" };\n\n\n  int[] more_numbers = new int[3]{ 21, 14 ,63 };\n\n\n  int[,] number_matrix = new int[3,2];\n\n\n  string[,] string_matrix = { {\"I\",\"swam\"}, {\"in\",\"the\"}, {\"freezing\",\"water\"} };\n\n\n string[,] funny_matrix = new string[2,2]{ {\"clowns\", \"are\"} , {\"not\", \"funny\"} };\n\nint[] array = new int[10];\n\narray[0] = 1;\narray[1] = 3;\n\nConsole.WriteLine(array[0]);\n\n\nusing System;\nusing System.Collections.Generic;\n\nList<int> list = new List<int>();\n\nlist.Add(1);\nlist.Add(3);\n\nlist[0] = 2;\n\nConsole.WriteLine(list[0]);\n\n", "explain": "Example of array of 10 int types:\nExample of array of 3 string types:\nYou can also declare the size of the array and initialize the values at the same time:\n\nFor Multi-Dimensional arrays you declare them the same except for a comma in the type declaration.\nThe following creates a 3x2 int matrix\nAs with the previous examples you can also initialize the values of the array, the only difference being each row in the matrix must be enclosed in its own braces.\nor\nDynamic\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "JavaScript", "code": "\n\n// Create a new array with length 0\nvar myArray = new Array();\n\n// Create a new array with length 5\nvar myArray1 = new Array(5);\n\n// Create an array with 2 members (length is 2) \nvar myArray2 = new Array(\"Item1\",\"Item2\");\n\n// Create an array with 2 members using an array literal\nvar myArray3 = [\"Item1\", \"Item2\"];\n\n// Assign a value to member [2] (length is now 3)\nmyArray3[2] = 5;\n\nvar x = myArray[2] + myArray.length;   // 8\n\n// You can also add a member to an array with the push function (length is now 4)\nmyArray3.push('Test');\n\n// Elisions are supported, but are buggy in some implementations\nvar y = [0,1,,];  // length 3, or 4 in buggy implementations\n", "explain": "JavaScript arrays are Objects that inherit from Array prototype and have a special length property that is always one higher than the highest non\u2013negative integer index. Methods inherited from Array.prototype are mostly generic and can be applied to other objects with a suitable length property and numeric property names.\nNote that if the Array constructor is provided with one argument, it is treated as specifying the length of the new array, if more than one argument is supplied, they are treated as members of the new array.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Visual_Basic_.NET", "code": "\n'Example of array of 10 int types: \nDim numbers As Integer() = New Integer(9) {}\n'Example of array of 4 string types: \nDim words As String() = {\"hello\", \"world\", \"from\", \"mars\"}\n'You can also declare the size of the array and initialize the values at the same time: \nDim more_numbers As Integer() = New Integer(2) {21, 14, 63}\n\n'For Multi-Dimensional arrays you declare them the same except for a comma in the type declaration. \n'The following creates a 3x2 int matrix \nDim number_matrix As Integer(,) = New Integer(2, 1) {}\n\n\n'As with the previous examples you can also initialize the values of the array, the only difference being each row in the matrix must be enclosed in its own braces. \nDim string_matrix As String(,) = {{\"I\", \"swam\"}, {\"in\", \"the\"}, {\"freezing\", \"water\"}}\n'or\nDim funny_matrix As String(,) = New String(1, 1) {{\"clowns\", \"are\"}, {\"not\", \"funny\"}}\n\nDim array As Integer() = New Integer(9) {}\narray(0) = 1\narray(1) = 3\nConsole.WriteLine(array(0))\n\n\n'Dynamic\nImports System\nImports System.Collections.Generic\nDim list As New List(Of Integer)()\nlist.Add(1)\nlist.Add(3)\nlist(0) = 2\nConsole.WriteLine(list(0))\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "PHP", "code": "\nWriting To An Array[edit]\nSingle Dimension[edit]\n$NumberArray = array(0, 1, 2, 3, 4, 5, 6);\n$LetterArray = array(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\");\n$simpleForm = ['apple', 'orange'];\nMulti-Dimensional[edit]\n$MultiArray = array(\n                array(0, 0, 0, 0, 0, 0),\n                array(1, 1, 1, 1, 1, 1),\n                array(2, 2, 2, 2, 2, 2),\n                array(3, 3, 3, 3, 3, 3)\n          );\nArray push[edit]\n$arr = ['apple', 'orange'];\narray_push($arr, 'pear');\nprint implode(',', $arr); // Returns apple,orange,pear\nReading From An Array[edit]\nSingle Dimension[edit]\n\necho $NumberArray[5]; // Returns 5\necho $LetterArray[5]; // Returns f\nMulti-Dimensional[edit]\n\necho $MultiArray[1][5]; // 2\nPrint a whole array[edit]\n\nprint_r($MultiArray);\n\nArray(\n    0 => array(\n            0 => 0\n            1 => 0\n            2 => 0\n            3 => 0\n            4 => 0\n            5 => 0\n         )\n    1 => array(\n            0 => 1\n            1 => 1\n            2 => 1\n            3 => 1\n            4 => 1\n            5 => 1\n         )\n    2 => array(\n            0 => 2\n            1 => 2\n            2 => 2\n            3 => 2\n            4 => 2\n            5 => 2\n         )\n    3 => array(\n            0 => 3\n            1 => 3\n            2 => 3\n            3 => 3\n            4 => 3\n            5 => 3\n         )\n)\nSet custom keys for values[edit]\n\n$StartIndexAtOne = array(1 => \"A\", \"B\", \"C\", \"D\");\n\n$CustomKeyArray = array(\"d\" => \"A\", \"c\" => \"B\", \"b\" =>\"C\", \"a\" =>\"D\");\n\necho $CustomKeyArray[\"b\"]; // Returns C\nOther Examples[edit]\n\n$BlankArray = array();\n\n$BlankArray[] = \"Not Blank Anymore\";\n\n$AssignArray[\"CertainKey\"] = \"Value\";\n", "explain": "Read the 5th value in the array:\nRead the 2nd line, column 5\nThis is useful while developing to view the contents of an array:\nWhich would give us:\nThis example starts the indexing from 1 instead of 0\nThis example shows how you can apply any key you want\nTo read the 3rd value of the second array:\nCreate a blank array:\nSet a value for the next key in the array:\nAssign a value to a certain key:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\n\ninteger a (10)\ninteger\u00a0:: a (10)\ninteger, dimension (10)\u00a0:: a\n\ninteger, dimension (10)\u00a0:: a\ninteger, dimension (1\u00a0: 10)\u00a0:: a\n\ninteger, dimension (0\u00a0: 9)\u00a0:: a\n\nreal, dimension (10)\u00a0:: a\ntype (my_type), dimension (10)\u00a0:: a\n\ninteger, dimension (10, 10)\u00a0:: a\ninteger, dimension (10, 10, 10)\u00a0:: a\n\ninteger, dimension (:), allocatable\u00a0:: a\ninteger, dimension (:,\u00a0:), allocatable\u00a0:: a\n\nallocate (a (10))\nallocate (a (10, 10))\n\ndeallocate (a)\n\ninteger, dimension (10)\u00a0:: a = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)\ninteger\u00a0:: i\ninteger, dimension (10)\u00a0:: a = (/(i * i, i = 1, 10)/)\ninteger, dimension (10)\u00a0:: a = 0\ninteger\u00a0:: i\ninteger, dimension (10, 10)\u00a0:: a = reshape ((/(i * i, i = 1, 100)/), (/10, 10/))\n\ninteger\u00a0:: i\ninteger, dimension (10), parameter\u00a0:: a = (/(i * i, i = 1, 10)/)\n\na (1) = 1\na (1, 1) = 1\n\na = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)\na = (/(i * i, i = 1, 10)/)\na = reshape ((/(i * i, i = 1, 100)/), (/10, 10/))\na = 0\n\na (:) = (/1, 2, 3, 4, 5, 6, 7, 8, 9, 10/)\na (1\u00a0: 5) = (/1, 2, 3, 4, 5/)\na (: 5) = (/1, 2, 3, 4, 5/)\na (6\u00a0:) = (/1, 2, 3, 4, 5/)\na (1\u00a0: 5) = (/(i * i, i = 1, 10)/)\na (1\u00a0: 5)= 0\na (1,\u00a0:)= (/(i * i, i = 1, 10)/)\na (1\u00a0: 5, 1)= (/(i * i, i = 1, 5)/)\n\ni = a (1)\n\na = b (1\u00a0: 10)\n\ni = size (a)\n\ni = size (a, 1)\n\ni_min = lbound (a)\ni_max = ubound (a)\n\na = ubound (b)\n", "explain": "Basic array declaration:\nArrays are one-based. These declarations are equivalent:\nOther bases can be used:\nArrays can have any type (intrinsic or user-defined), e.g.:\nMultidimensional array declaration:\nAllocatable array declaration:\nArray allocation:\nArray deallocation:\nArray initialisation:\nConstant array declaration:\nElement assignment:\nArray assignment (note that since Fortran 2003 array assignment also allocates or reallocates if necessary):\nArray section assignment:\nElement retrieval:\nArray section retrieval:\nSize retrieval:\nSize along a single dimension retrieval:\nBounds retrieval:\nBounds of a multidimensional array retrieval:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Scratch", "code": "\n\n", "explain": "\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n)\n\nfunc main() {\n    // creates an array of five ints.\n    // specified length must be a compile-time constant expression.\n    // this allows compiler to do efficient bounds checking.\n    var a [5]int\n\n    // since length is compile-time constant, len() is a compile time constant\n    // and does not have the overhead of a function call.\n    fmt.Println(\"len(a) =\", len(a))\n\n    // elements are always initialized to 0\n    fmt.Println(\"a =\", a)\n\n    // assign a value to an element.  indexing is 0 based.\n    a[0] = 3\n    fmt.Println(\"a =\", a)\n\n    // retrieve element value with same syntax\n    fmt.Println(\"a[0] =\", a[0])\n\n    // a slice references an underlying array\n    s\u00a0:= a[:4] // this does not allocate new array space.\n    fmt.Println(\"s =\", s)\n\n    // slices have runtime established length and capacity, but len() and\n    // cap() are built in to the compiler and have overhead more like\n    // variable access than function call.\n    fmt.Println(\"len(s) =\", len(s), \" cap(s) =\", cap(s))\n\n    // slices can be resliced, as long as there is space\n    // in the underlying array.\n    s = s[:5]\n    fmt.Println(\"s =\", s)\n\n    // s still based on a\n    a[0] = 22\n    fmt.Println(\"a =\", a)\n    fmt.Println(\"s =\", s)\n\n    // append will automatically allocate a larger underlying array as needed.\n    s = append(s, 4, 5, 6)\n    fmt.Println(\"s =\", s)\n    fmt.Println(\"len(s) =\", len(s), \" cap(s) =\", cap(s))\n\n    // s no longer based on a\n    a[4] = -1\n    fmt.Println(\"a =\", a)\n    fmt.Println(\"s =\", s)\n\n    // make creates a slice and allocates a new underlying array\n    s = make([]int, 8)\n    fmt.Println(\"s =\", s)\n    fmt.Println(\"len(s) =\", len(s), \" cap(s) =\", cap(s))\n\n    // the cap()=10 array is no longer referenced\n    // and would be garbage collected eventually.\n}\n\nOutput:\nlen(a) = 5\na = [0 0 0 0 0]\na = [3 0 0 0 0]\na[0] = 3\ns = [3 0 0 0]\nlen(s) = 4  cap(s) = 5\ns = [3 0 0 0 0]\na = [22 0 0 0 0]\ns = [22 0 0 0 0]\ns = [22 0 0 0 0 4 5 6]\nlen(s) = 8  cap(s) = 10\na = [22 0 0 0 -1]\ns = [22 0 0 0 0 4 5 6]\ns = [0 0 0 0 0 0 0 0]\nlen(s) = 8  cap(s) = 8\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program areaString.s   */\n\n/* Constantes    */\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/* Initialized data */\n.data\nszMessStringsch: .ascii \"The string is at item\u00a0: \"\nsZoneconv:\t\t .fill 12,1,' '\nszCarriageReturn:  .asciz \"\\n\"\nszMessStringNfound: .asciz \"The string is not found in this area.\\n\"\n\n/* areas strings  */\nszString1:  .asciz \"Apples\"\nszString2:  .asciz \"Oranges\"\nszString3:  .asciz \"Pommes\"\nszString4:  .asciz \"Raisins\"\nszString5:  .asciz \"Abricots\"\n\n/* pointer items area 1*/\ntablesPoi1:\npt1_1:\t    .int szString1\npt1_2:\t    .int szString2\npt1_3:\t    .int szString3\npt1_4:\t    .int szString4\nptVoid_1: .int 0\nptVoid_2: .int 0\nptVoid_3: .int 0\nptVoid_4: .int 0\nptVoid_5: .int 0\n\nszStringSch:\t.asciz \"Raisins\"\nszStringSch1:\t.asciz \"Ananas\"\n\n/* UnInitialized data */\n.bss \n\n/*  code section */\n.text\n.global main \nmain:                /* entry of program  */\n    push {fp,lr}    /* saves 2 registers */\n\t\n    @@@@@@@@@@@@@@@@@@@@@@@@\n    @ add string 5 to area\n   @@@@@@@@@@@@@@@@@@@@@@@@\n    ldr r1,iAdrtablesPoi1  @ begin pointer area 1\n    mov r0,#0    @ counter\n1:   @ search first void pointer\n    ldr r2,[r1,r0,lsl #2]    @ read string pointer address item r0 (4 bytes by pointer)\n    cmp r2,#0                @ is null\u00a0?\n    addne r0,#1             @ no increment counter\n    bne 1b                  @ and loop\n \n    @ store pointer string 5 in area  at position r0\n    ldr r2,iAdrszString5  @ address string 5\n    str r2,[r1,r0,lsl #2]    @ store address \n\t\n    @@@@@@@@@@@@@@@@@@@@@@@@\n    @ display string at item 3\n    @@@@@@@@@@@@@@@@@@@@@@@@\n    mov r2,#2        @ pointers begin in position 0 \n    ldr r1,iAdrtablesPoi1  @ begin pointer area 1\n    ldr r0,[r1,r2,lsl #2]\n    bl affichageMess\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n\t\n    @@@@@@@@@@@@@@@@@@@@@@@@\n    @ search string in area \n    @@@@@@@@@@@@@@@@@@@@@@@@\n    ldr r1,iAdrszStringSch\n    //ldr r1,iAdrszStringSch1  @ uncomment for other search\u00a0: not found\u00a0!!\n    ldr r2,iAdrtablesPoi1  @ begin pointer area 1\n    mov r3,#0  \n2:   @ search \n    ldr r0,[r2,r3,lsl #2]    @ read string pointer address item r0 (4 bytes by pointer)\n    cmp r0,#0                @ is null\u00a0?\n    beq 3f        @ end search\n    bl comparaison\n    cmp r0,#0                @ string =\u00a0?\n    addne r3,#1             @ no increment counter\n    bne 2b                  @ and loop\n    mov r0,r3             @ position item string\n    ldr r1,iAdrsZoneconv   @ conversion decimal\n    bl conversion10S\n    ldr r0,iAdrszMessStringsch\n    bl affichageMess\n    b 100f\n3:   @ end search  string not found\n    ldr r0,iAdrszMessStringNfound\n    bl affichageMess\n\t\n100:   /* standard end of the program */\n    mov r0, #0                  @ return code\n    pop {fp,lr}                 @restaur 2 registers\n    mov r7, #EXIT              @ request to exit program\n    swi 0                       @ perform the system call\niAdrtablesPoi1:\t\t.int tablesPoi1\niAdrszMessStringsch:   .int szMessStringsch\niAdrszString5:\t\t.int szString5\niAdrszStringSch:\t.int szStringSch\niAdrszStringSch1:   .int szStringSch1\niAdrsZoneconv:       .int sZoneconv\niAdrszMessStringNfound:  .int szMessStringNfound\niAdrszCarriageReturn:  .int  szCarriageReturn\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {fp,lr}    \t\t\t/* save  registres */ \n    push {r0,r1,r2,r7}    \t\t/* save others registers */\n    mov r2,#0   \t\t\t\t/* counter length */\n1:      \t/* loop length calculation */\n    ldrb r1,[r0,r2]  \t\t\t/* read octet start position + index */\n    cmp r1,#0       \t\t\t/* if 0 its over */\n    addne r2,r2,#1   \t\t\t/* else add 1 in the length */\n    bne 1b          \t\t\t/* and loop */\n                                /* so here r2 contains the length of the message */\n    mov r1,r0        \t\t\t/* address message in r1 */\n    mov r0,#STDOUT      \t\t/* code to write to the standard output Linux */\n    mov r7, #WRITE             /* code call system \"write\" */\n    swi #0                      /* call systeme */\n    pop {r0,r1,r2,r7}     \t\t/* restaur others registers */\n    pop {fp,lr}    \t\t\t\t/* restaur des  2 registres */ \n    bx lr\t        \t\t\t/* return  */\n/***************************************************/\n/*   conversion register signed d\u00e9cimal     */\n/***************************************************/\n/* r0 contient le registre   */\n/* r1 contient l adresse de la zone de conversion */\nconversion10S:\n    push {r0-r5,lr}    /* save des registres */\n    mov r2,r1       /* debut zone stockage */\n    mov r5,#'+'     /* par defaut le signe est + */\n    cmp r0,#0       /* nombre n\u00e9gatif\u00a0? */\n    movlt r5,#'-'     /* oui le signe est - */\n    mvnlt r0,r0       /* et inversion en valeur positive */\n    addlt r0,#1\n    mov r4,#10   /* longueur de la zone */\n1: /* debut de boucle de conversion */\n    bl divisionpar10 /* division  */\n    add r1,#48        /* ajout de 48 au reste pour conversion ascii */\t\n    strb r1,[r2,r4]  /* stockage du byte en d\u00e9but de zone r5 + la position r4 */\n    sub r4,r4,#1      /* position pr\u00e9cedente */\n    cmp r0,#0     \n    bne 1b\t       /* boucle si quotient different de z\u00e9ro */\n    strb r5,[r2,r4]  /* stockage du signe \u00e0 la position courante */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    blt  100f         /* si r4 < 0  fin  */\n    /* sinon il faut completer le debut de la zone avec des blancs */\n    mov r3,#' '   /* caractere espace */\t\n2:\n    strb r3,[r2,r4]  /* stockage du byte  */\n    subs r4,r4,#1   /* position pr\u00e9cedente */\n    bge 2b        /* boucle si r4 plus grand ou egal a zero */\n100:  /* fin standard de la fonction  */\n    pop {r0-r5,lr}   /*restaur desregistres */\n    bx lr   \n\n/***************************************************/\n/*   division par 10   sign\u00e9                       */\n/* Thanks to http://thinkingeek.com/arm-assembler-raspberry-pi/*  \n/* and   http://www.hackersdelight.org/            */\n/***************************************************/\n/* r0 contient le dividende   */\n/* r0 retourne le quotient */\t\n/* r1 retourne le reste  */\ndivisionpar10:\t\n  /* r0 contains the argument to be divided by 10 */\n   push {r2-r4}   /* save registers  */\n   mov r4,r0 \n   ldr r3, .Ls_magic_number_10 /* r1 <- magic_number */\n   smull r1, r2, r3, r0   /* r1 <- Lower32Bits(r1*r0). r2 <- Upper32Bits(r1*r0) */\n   mov r2, r2, ASR #2     /* r2 <- r2 >> 2 */\n   mov r1, r0, LSR #31    /* r1 <- r0 >> 31 */\n   add r0, r2, r1         /* r0 <- r2 + r1 */\n   add r2,r0,r0, lsl #2   /* r2 <- r0 * 5 */\n   sub r1,r4,r2, lsl #1   /* r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10) */\n   pop {r2-r4}\n   bx lr                  /* leave function */\n   bx lr                  /* leave function */\n.Ls_magic_number_10: .word 0x66666667\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "MIPS_Assembly", "code": "\n\t.data\narray:\t.word\t1, 2, 3, 4, 5, 6, 7, 8, 9 # creates an array of 9 32 Bit words. \n\n\t.text\nmain:\tla \t$s0, array\n\tli\t$s1, 25\n\tsw\t$s1, 4($s0)\t# writes $s1 (25) in the second array element\n# the four counts the bytes after the beginning of the address. 1 word = 4 bytes, so 4 accesses the second element \n\t\n\tlw\t$s2, 20($s0)\t# $s2 now contains 6\t\n\t\n\tli\t$v0, 10\t\t# end program\n\tsyscall\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "X86_Assembly", "code": "\nsection .text\n\tglobal _start\n\t\n\t_print:\n\t\tmov ebx, 1\n\t\tmov eax, 4\n\t\tint 0x80\n\t\tret\n\t\t\n\t_start:\n\t\t;print out our byte array. ergo, String.\n\t\tmov edx, sLen\n\t\tmov ecx, sArray\n\t\tcall _print\n\t\tmov edx, f_len\n\t\tmov ecx, f_msg\n\t\tcall _print\n\t\tmov edx, 6\t\t\t;our array members length.\n\t\txor ecx, ecx\n\t\tmov ecx, 4\n\t\t;turnicate through the array and print all it's members.\n\t\t;At an offset of *4, each array member is referenced\n\t\t;at 1,2,3 and so on. \n\t\t_out_loops:\n\t\t\tpush ecx\n\t\t\tmov ecx, [fArray+esi*4]\n\t\t\tcall _print\n\t\t\tinc esi\n\t\t\tpop ecx\n\t\tloop _out_loops\n\t\tmov edx, u_len\n\t\tmov ecx, u_msg\n\t\tcall _print\n\t\t;Let's populate 'uArray' with something from sArray.\n\t\t;mov edi, uArray\n\t\tmov ecx, 4\n\t\txor esi, esi\n\t\t_read_loops:\t\n\t\t\tpush dword [fArray+esi*4]\n\t\t\tpop dword [uArray+esi*4]\n\t\t\tinc esi\n\t\tloop _read_loops\n\t\tmov ecx, 4\n\t\txor esi, esi\n\t\t_out_loops2:\n\t\t\tpush ecx\n\t\t\tmov ecx, [uArray+esi*4]\n\t\t\tcall _print\n\t\t\tinc esi\n\t\t\tpop ecx\n\t\tloop _out_loops2\n\t\tpush 0x1\n\t\tmov eax, 1\n\t\tpush eax\n\t\tint 0x80\n\t\t\nsection .data\nsArray\tdb 'a','r','r','a','y','s',' ','a','r','e',' ','f','u','n',0xa\nsLen\t\tequ $-sArray\n\ncrap1\t\tdb \"crap1\",0xa\ncrap2\t\tdb \"crap2\",0xa\ncrap3\t\tdb \"crap3\",0xa\ncrap4\t\tdb \"crap4\",0xa\n\nfArray\tdd crap1,crap2\n\tdd crap3,crap4\n\nf_msg\t\tdb \"fArray contents\",0xa,\"----------------------\",0xa\nf_len\t\tequ $-f_msg\nu_msg\t\tdb \"uArray now holds fArray contents.. dumping..\",0xa,\"----------------------\",0xa\nu_len\t\tequ $-u_msg\n\nsection .bss\nuArray\tresd 1\n        resd 1\n\tresd 1\n\tresd 1\n\n", "explain": "Arrays in assembly are a reference to anything, from groups of data such as f/uArray to strings like _msg's or sArray.\nMutlidimentional arrays don't exist in assembly. To make a reference to one from assembly, we use a format as such. \"row * r_len + column * member_size\".\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Delphi", "code": "\n\nprocedure TForm1.Button1Click(Sender: TObject);\nvar\n  StaticArray: array[1..10] of Integer; // static arrays can start at any index\n  DynamicArray: array of Integer; // dynamic arrays always start at 0\n  StaticArrayText,\n  DynamicArrayText: string;\n  ixS, ixD: Integer;\nbegin\n  // Setting the length of the dynamic array the same as the static one\n  SetLength(DynamicArray, Length(StaticArray));\n  // Asking random numbers storing into the static array\n  for ixS := Low(StaticArray) to High(StaticArray) do\n  begin\n    StaticArray[ixS] := StrToInt(\n      InputBox('Random number',\n               'Enter a random number for position',\n               IntToStr(ixS)));\n  end;\n  // Storing entered numbers of the static array in reverse order into the dynamic\n  ixD := High(DynamicArray);\n  for ixS := Low(StaticArray) to High(StaticArray) do\n  begin\n    DynamicArray[ixD] := StaticArray[ixS];\n    Dec(ixD);\n  end;\n  // Concatenating the static and dynamic array into a single string variable\n  StaticArrayText := '';\n  for ixS := Low(StaticArray) to High(StaticArray) do\n    StaticArrayText := StaticArrayText + IntToStr(StaticArray[ixS]);\n  DynamicArrayText := '';\n  for ixD := Low(DynamicArray) to High(DynamicArray) do\n    DynamicArrayText := DynamicArrayText + IntToStr(DynamicArray[ixD]);\n  end;\n  // Displaying both arrays (#13#10 = Carriage Return/Line Feed)\n  ShowMessage(StaticArrayText + #13#10 + DynamicArrayText);\nend;\n\n", "explain": "This example creates a static and dynamic array, asks for a series of numbers storing them in the static one, puts in the dynamic one the numbers in reverse order, concatenates the number in two single string variables and display those strings in a popup window.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Ruby", "code": "\n\n# create an array with one object in it\na = ['foo']\n\n# the Array#new method allows several additional ways to create arrays\n\n# push objects into the array\na << 1         # [\"foo\", 1]\na.push(3,4,5)  # [\"foo\", 1, 3, 4, 5]\n\n# set the value at a specific index in the array\na[0] = 2       # [2, 1, 3, 4, 5]\n\n# a couple of ways to set a slice of the array\na[0,3] = 'bar'    # [\"bar\", 4, 5]\na[1..-1] = 'baz'  # [\"bar\", \"baz\"]\na[0] = nil        # [nil, \"baz\"]\na[0,1] = nil      # [\"baz\"]\n\n# retrieve an element\nputs a[0]\n", "explain": "Dynamic\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Rust", "code": "\n\nlet a = [1, 2, 3]; // immutable array\nlet mut m = [1, 2, 3]; // mutable array\nlet zeroes = [0; 200]; // creates an array of 200 zeroes\n\nlet a = [1, 2, 3];\na.len();\nfor e in a.iter() {\n    e;\n}\n\nlet names = [\"Graydon\", \"Brian\", \"Niko\"];\nnames[1]; // second element\n\nlet v = vec![1, 2, 3];\n\nlet mut v = vec![1, 2, 3];\nv.push(4);\nv.len(); // 4\n", "explain": "The Rust book has a tutorial on arrays.\nBy default, arrays are immutable unless defined otherwise.\nTo get the length and iterate,\nAccessing a particular element uses subscript notation, starting from 0.\nDynamic arrays in Rust are called vectors.\nHowever, this defines an immutable vector. To add elements to a vector, we need to define v to be mutable.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Swift", "code": "\n// Arrays are typed in Swift, however, using the Any object we can add any type. Swift does not support fixed length arrays\nvar anyArray = [Any]()\nanyArray.append(\"foo\") // Adding to an Array\nanyArray.append(1) // [\"foo\", 1]\nanyArray.removeAtIndex(1) // Remove object\nanyArray[0] = \"bar\" // [\"bar\"]\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "R", "code": "\n\narr <- array(1)\n\narr <- append(arr,3)\n\narr[1] <- 2\n\nprint(arr[1])\n", "explain": "Dynamic\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "COBOL", "code": "\n\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. arrays.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       01  fixed-length-table.\n           03  fixed-table-elt      PIC X OCCURS 5 TIMES.\n\n       01  table-length             PIC 9(5) VALUE 1.\n       01  variable-length-table.\n           03  variable-table-elt   PIC X OCCURS 1 TO 5 TIMES\n               DEPENDING ON table-length.\n\n       01  initial-value-area.\n           03  initial-values.\n               05  FILLER           PIC X(10) VALUE \"One\".\n               05  FILLER           PIC X(10) VALUE \"Two\".\n               05  FILLER           PIC X(10) VALUE \"Three\".\n           03 initial-value-table REDEFINES initial-values.\n              05  initial-table-elt PIC X(10) OCCURS 3 TIMES.\n\n       01  indexed-table.\n           03  indexed-elt          PIC X OCCURS 5 TIMES\n               INDEXED BY table-index.\n\n       PROCEDURE DIVISION.\n           *> Assigning the contents of an entire table.\n           MOVE \"12345\" TO fixed-length-table\n           \n           *>  Indexing an array (using an index)\n           MOVE 1 TO table-index\n           MOVE \"1\" TO indexed-elt (table-index)\n\n           *> Pushing a value into a variable-length table.\n           ADD 1 TO table-length\n           MOVE \"1\" TO variable-table-elt (2)\n\n           GOBACK\n           .\n\n", "explain": "In COBOL, arrays are called tables. Also, indexes begin from 1.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Ada", "code": "\nprocedure Array_Test is\n\n   A, B : array (1..20) of Integer;\n\n   -- Ada array indices may begin at any value, not just 0 or 1\n   C : array (-37..20) of integer\n\n   -- Ada arrays may be indexed by enumerated types, which are \n   -- discrete non-numeric types\n   type Days is (Mon, Tue, Wed, Thu, Fri, Sat, Sun);\n   type Activities is (Work, Fish);\n   type Daily_Activities is array(Days) of Activities;\n   This_Week : Daily_Activities := (Mon..Fri => Work, Others => Fish);\n\n   -- Or any numeric type\n   type Fingers is range 1..4; -- exclude thumb\n   type Fingers_Extended_Type is array(fingers) of Boolean;\n   Fingers_Extended : Fingers_Extended_Type;\n\n   -- Array types may be unconstrained. The variables of the type\n   -- must be constrained\n   type Arr is array (Integer range <>) of Integer;\n   Uninitialized : Arr (1 .. 10);\n   Initialized_1 : Arr (1 .. 20) := (others => 1);\n   Initialized_2 : Arr := (1 .. 30 => 2);\n   Const         : constant Arr := (1 .. 10 => 1, 11 .. 20 => 2, 21 | 22 => 3);\n   Centered      : Arr (-50..50) := (0 => 1, Others => 0);\n\n   Result        : Integer\nbegin\n\n   A := (others => 0);     -- Assign whole array\n   B := (1 => 1, 2 => 1, 3 => 2, others => 0); \n                           -- Assign whole array, different values \n   A (1) := -1;            -- Assign individual element\n   A (2..4) := B (1..3);   -- Assign a slice\n   A (3..5) := (2, 4, -1); -- Assign a constant slice\n   A (3..5) := A (4..6);   -- It is OK to overlap slices when assigned\n   \n   Fingers_Extended'First := False; -- Set first element of array\n   Fingers_Extended'Last := False;  -- Set last element of array\n\nend Array_Test;\n\n\n", "explain": "Arrays are first-class objects in Ada. They can be allocated statically or dynamically as any other object. The number of elements in an array object is always constrained. Variable size arrays are provided by the standard container library. They also can be implemented as user-defined types.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Julia", "code": "\n\njulia> A = Vector(undef, 3)   # create an heterogeneous 1-D array of length 3\n3-element Vector{Any}:\n #undef\n #undef\n #undef\n\njulia> A[1] = 4.5\u00a0; A[3] =  \"some string\"\u00a0; show(A)\n{4.5,#undef,\"some string\"}\n\njulia> A[1]          # access a value. Arrays are 1-indexed\n4.5\n\njulia> push!(A, :symbol)\u00a0; show(A)    # append an element\n{4.5,#undef,\"some string\",:symbol}\n\njulia> A[10]         # error if the index is out of range\nERROR: BoundsError()\n\njulia> B = Array(String, 3)\u00a0; B[1]=\"first\"\u00a0; push!(B, \"fourth\")\u00a0; show(B)\n[\"first\",#undef,#undef,\"fourth\"]\n\njulia> push!(B, 3)   # type error\nERROR: no method convert(Type{String}, Int64)\n in push! at array.jl:488\n\njulia> ['a':'c'...]     # type inference\n3-element Vector{Char}:\n 'a': ASCII/Unicode U+0061 (category Ll: Letter, lowercase)\n 'b': ASCII/Unicode U+0062 (category Ll: Letter, lowercase)\n 'c': ASCII/Unicode U+0063 (category Ll: Letter, lowercase)\n", "explain": "Julia has both heterogeneous arrays and typed arrays.\nFor typed arrays, the type can be specified explicitely or infered from its elements.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Kotlin", "code": "\nfun main(x: Array<String>) {\n    var a = arrayOf(1, 2, 3, 4)\n    println(a.asList())\n    a += 5\n    println(a.asList())\n    println(a.reversedArray().asList())\n}\n\nOutput:\n[1, 2, 3, 4]\n[1, 2, 3, 4, 5]\n[5, 4, 3, 2, 1]\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Perl", "code": "\n\n my @empty;\n my @empty_too = ();\n \n my @populated   = ('This', 'That', 'And', 'The', 'Other');\n print $populated[2];  # And\n \n my $aref = ['This', 'That', 'And', 'The', 'Other'];\n print $aref->[2];  # And\n\nmy @arr;\n\npush @arr, 1;\npush @arr, 3;\n\n$arr[0] = 2;\n\nprint $arr[0];\n\n my @multi_dimensional = (\n     [0, 1, 2, 3],\n     [qw(a b c d e f g)],\n     [qw(! $\u00a0% & *)],\n );\n", "explain": "In-line\nDynamic\nTwo-dimensional\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Objective-C", "code": "\n// NSArrays are ordered collections of NSObject subclasses only.\n\n// Create an array of NSString objects.\nNSArray *firstArray = [[NSArray alloc] initWithObjects:@\"Hewey\", @\"Louie\", @\"Dewey\", nil];\n\n// NSArrays are immutable; it does have a mutable subclass, however - NSMutableArray.\n// Let's instantiate one with a mutable copy of our array.\n// We can do this by sending our first array a -mutableCopy message.\nNSMutableArray *secondArray = [firstArray mutableCopy];\n\n// Replace Louie with Launchpad McQuack.\n[secondArray replaceObjectAtIndex:1 withObject:@\"Launchpad\"];\n\n// Display the first object in the array.\nNSLog(@\"%@\", [secondArray objectAtIndex:0]);\n\n// In non-ARC or non-GC environments, retained objects must be released later.\n[firstArray release];\n[secondArray release];\n\n// There is also a modern syntax which allows convenient creation of autoreleased immutable arrays.\n// No nil termination is then needed.\nNSArray *thirdArray = @[ @\"Hewey\", @\"Louie\", @\"Dewey\", @1, @2, @3 ];\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\n\nsingleassignment:-                   \n    functor(Array,array,100),\u00a0% create a term with 100 free Variables as arguments\n                             \u00a0% index of arguments start at 1\n    arg(1 ,Array,a),         \u00a0% put an a at position 1 \n    arg(12,Array,b),         \u00a0% put an b at position 12\n    arg(1 ,Array,Value1),    \u00a0% get the value at position 1\n    print(Value1),nl,        \u00a0% will print Value1 and therefore a followed by a newline \n    arg(4 ,Array,Value2),    \u00a0% get the value at position 4 which is a free Variable\n    print(Value2),nl.        \u00a0% will print that it is a free Variable followed by a newline\n\ndestructive:-                   \n    functor(Array,array,100),\u00a0% create a term with 100 free Variables as arguments\n                             \u00a0% index of arguments start at 1\n    setarg(1 ,Array,a),      \u00a0% put an a at position 1 \n    setarg(12,Array,b),      \u00a0% put an b at position 12\n    setarg(1, Array,c),      \u00a0% overwrite value at position 1 with c\n    arg(1 ,Array,Value1),    \u00a0% get the value at position 1\n    print(Value1),nl.        \u00a0% will print Value1 and therefore c followed by a newline\n\nlistvariant:-\n    length(List,100),         \u00a0% create a list of length 100\n    nth1(1 ,List,a),          \u00a0% put an a at position 1 , nth1/3 uses indexing from 1, nth0/3 from 0\n    nth1(12,List,b),          \u00a0% put an b at position 3\n    append(List,[d],List2),   \u00a0% append an d at the end , List2 has 101 elements\n    length(Add,10),           \u00a0% create a new list of length 10\n    append(List2,Add,List3),  \u00a0% append 10 free variables to List2 , List3 now has 111 elements\n    nth1(1 ,List3,Value),     \u00a0% get the value at position 1\n    print(Value),nl.          \u00a0% will print out a\n", "explain": "Prolog Terms can be abused as array structure. Using\nfunctor/3 to create arrays and arg/3 to nondestructively\nretrieve and set elements.\nTo destructively set an array element, which is the \"normal\" way to set an element in most other \nprogramming languages, setarg/3 can be used.\nLists can be used as arrays.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Lua", "code": "\n\nl = {}\nl[1] = 1      -- Index starts with 1, not 0.\nl[0] = 'zero' -- But you can use 0 if you want\nl[10] = 2     -- Indexes need not be continuous\nl.a = 3       -- Treated as l['a']. Any object can be used as index\nl[l] = l      -- Again, any object can be used as an index. Even other tables\nfor i,v in next,l do print (i,v) end\n", "explain": "Lua does not differentiate between arrays, lists, sets, dictionaries, maps, etc. It supports only one container: Table. Using Lua's simple yet powerful syntax, any of these containers can be emulated. All tables are dynamic. If a static array is necessary, that behavior can be created.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Scala", "code": "\n\n// Create a new integer array with capacity 10\nval a = new Array[Int](10)\n\n// Create a new array containing specified items\nval b = Array(\"foo\", \"bar\", \"baz\")\n\n// Assign a value to element zero\na(0) = 42\n\n// Retrieve item at element 2\nval c = b(2)\n\nval a = new collection.mutable.ArrayBuffer[Int] \na += 5   // Append value 5 to the end of the list\na(0) = 6 // Assign value 6 to element 0\n", "explain": "Arrays are not used often in Scala, since they are mutable and act differently to other collections with respect to type erasure, but are necessary for interoperability with Java. Alternatives such as List, Seq, and Vector are more commonly used.\nDynamic arrays can be made using ArrayBuffers:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Dart", "code": "\nmain(){\n\t// Dart uses Lists which dynamically resize by default\n\tfinal growable = [ 1, 2, 3 ];\n\n        // Add to the list using the add method\n\tgrowable.add(4);\n\n\tprint('growable: $growable');\n\n\t// You can pass an int to the constructor to create a fixed sized List\n\tfinal fixed = List(3);\n\t\n\t// We must assign each element individually using the Subscript operator\n\t// using .add would through an error\n\tfixed[0] = 'one';\n\tfixed[1] = 'two';\n\tfixed[2] = 'three';\n\n\tprint('fixed: $fixed');\n\n\t// If we want to create a fixed list all at once we can use the of constructor\n\t// Setting growable to false is what makes it fixed\n\tfinal fixed2 = List.of( [ 1.5, 2.5, 3.5 ], growable: false);\n\n\tprint('fixed2: $fixed2');\n\t\n\t// A potential gotcha involving the subscript operator [] might surprise JavaScripters\n\t// One cannot add new elements to a List using the subscript operator\n\t// We can only assign to existing elements, even if the List is growable\n\n\tfinal gotcha = [ 1, 2 ];\t\n\t// gotcha[2] = 3 would cause an error in Dart, but not in JavaScript\n\t// We must first add the new element using .add\n\tgotcha.add(3);\n\t// Now we can modify the existing elements with the subscript\n\tgotcha[2] = 4;\n\n\tprint('gotcha: $gotcha');\n\n\n}\n\n\nOutput:\ngrowable: [1, 2, 3, 4]\nfixed: [one, two, three]\nfixed2: [1.5, 2.5, 3.5]\ngotcha: [1, 2, 4]\n\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "D", "code": "\n// All D arrays are capable of bounds checks.\n\nimport std.stdio, core.stdc.stdlib;\nimport std.container: Array;\n\nvoid main() {\n    // GC-managed heap allocated dynamic array:\n    auto array1 = new int[1];\n    array1[0] = 1;\n    array1 ~= 3; // append a second item\n    // array1[10] = 4; // run-time error\n    writeln(\"A) Element 0: \", array1[0]);\n    writeln(\"A) Element 1: \", array1[1]);\n\n    // Stack-allocated fixed-size array:\n    int[5] array2;\n    array2[0] = 1;\n    array2[1] = 3;\n    // array2[2] = 4; // compile-time error\n    writeln(\"B) Element 0: \", array2[0]);\n    writeln(\"B) Element 1: \", array2[1]);\n\n    // Stack-allocated dynamic fixed-sized array,\n    // length known only at run-time:\n    int n = 2;\n    int[] array3 = (cast(int*)alloca(n * int.sizeof))[0 .. n];\n    array3[0] = 1;\n    array3[1] = 3;\n    // array3[10] = 4; // run-time error\n    writeln(\"C) Element 0: \", array3[0]);\n    writeln(\"C) Element 1: \", array3[1]);\n\n    // Phobos-defined  heap allocated not GC-managed array:\n    Array!int array4;\n    array4.length = 2;\n    array4[0] = 1;\n    array4[1] = 3;\n    // array4[10] = 4; // run-time exception\n    writeln(\"D) Element 0: \", array4[0]);\n    writeln(\"D) Element 1: \", array4[1]);\n}\n\n\nOutput:\nA) Element 0: 1\nA) Element 1: 3\nB) Element 0: 1\nB) Element 1: 3\nC) Element 0: 1\nC) Element 1: 3\nD) Element 0: 1\nD) Element 1: 3\n\nimport std.stdio, core.simd;\n\nvoid main() {\n    // Stack-allocated vector for SIMD registers:\n    ubyte16 vector5;\n    vector5.array[0] = 1;\n    vector5.array[1] = 3;\n    // vector5.array[17] = 4; // Compile-time error.\n    writeln(\"E) Element 0: \", vector5.array[0]);\n    writeln(\"E) Element 1: \", vector5.array[1]);\n}\n\n\nOutput:\nE) Element 0: 1\nE) Element 1: 3\n", "explain": "One more kind of built-in array:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Haskell", "code": "\n\nimport Data.Array.IO\n\nmain = do arr <- newArray (1,10) 37\u00a0:: IO (IOArray Int Int)\n          a <- readArray arr 1\n          writeArray arr 1 64\n          b <- readArray arr 1 \n          print (a,b)\n", "explain": "You can read all about Haskell arrays here. The following example is taken from that page:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "VBScript", "code": "\n'Arrays - VBScript - 08/02/2021\n\n    'create a static array\n    Dim a(3)   ' 4 items\u00a0: a(0), a(1), a(2), a(3)\n    'assign a value to elements\n    For i = 1 To 3\n        a(i) = i * i\n    Next\n    'and retrieve elements\n\tbuf=\"\"\n    For i = 1 To 3\n        buf = buf & a(i) & \" \"\n    Next\n    WScript.Echo buf\n\t\n    'create a dynamic array \n    Dim d()\n    ReDim d(3)   ' 4 items\u00a0: d(0), d(1), d(2), d(3)\n    For i = 1 To 3\n        d(i) = i * i\n    Next\n\tbuf=\"\"\n    For i = 1 To 3\n        buf = buf & d(i) & \" \"\n    Next\n\tWScript.Echo buf\n\t\n\td(0) = 0\n    'expand the array and preserve existing values\n    ReDim Preserve d(4)   ' 5 items\u00a0: d(0), d(1), d(2), d(3), d(4)\n    d(4) = 16\n\tbuf=\"\"\n    For i = LBound(d) To UBound(d)\n        buf = buf & d(i) & \" \"\n    Next\n\tWScript.Echo buf\n\n\t'create and initialize an array dynamicaly\n    b = Array(1, 4, 9)\n\t'and retrieve all elements\n\tWScript.Echo Join(b,\",\")\n\n\t'Multi-Dimensional arrays\n\t'The following creates a 5x4 matrix \n\tDim mat(4,3)\n\nOutput:\n1 4 9 \n1 4 9 \n0 1 4 9 16 \n1,4,9\n\n\n", "explain": "\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Scheme", "code": "\n\n(let ((array #(1 2 3 4 5))    \u00a0; vector literal\n      (array2 (make-vector 5)) \u00a0; default is unspecified\n      (array3 (make-vector 5 0)))\u00a0; default 0\n (vector-set! array 0 3)\n (vector-ref array 0))   \u00a0; 3\n", "explain": "Lists are more often used in Scheme than vectors.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Apex", "code": "\nInteger[] array = new Integer[10]; // optionally, append a braced list of Integers like \"{1, 2, 3}\"\narray[0] = 42;\nSystem.debug(array[0]); // Prints 42\n\nList <Integer> aList = new List <Integer>(); // optionally add an initial size as an argument\naList.add(5);// appends to the end of the list\naList.add(1, 6);// assigns the element at index 1\nSystem.debug(list[0]); // Prints 5, alternatively you can use list.get(0)\n", "explain": "Dynamic arrays can be made using Lists. Lists and array can be used interchangeably in Apex, e.g. any method that accepts a List<String> will also accept a String[]\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "PowerShell", "code": "\n\n$a = @()\n\n$a = ,2\n$a = @(2)  # alternative\n\n$a = 1,2,3\n\n$a += 5\n\n$a[1]\n\n$a[1] = 42\n\n$r = 1..100\n\n$r[0..9+25..27+80,85,90]\n\n$r[-1]  # last index\n", "explain": "Empty array:\nArray initialized with only one member:\nLonger arrays can simply be created by separating the values with commas:\nA value can be appended to an array using the += operator:\nSince arrays are immutable this simply creates a new array containing one more member.\nValues can be retrieved using a fairly standard indexing syntax:\nSimilarly, those values can also be replaced:\nThe range operator .. can be used to create contiguous ranges of integers as arrays:\nIndexing for retrieval allows for arrays as well, the following shows a fairly complex example combining two ranges and an arbitrary array in the indexer:\nIndexing from the end of the array can be done with negative numbers:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Logo", "code": "\narray 5     \u00a0; default origin is 1, every item is empty\n(array 5 0) \u00a0; custom origin\nmake \"a {1 2 3 4 5} \u00a0; array literal\nsetitem 1 :a \"ten      \u00a0; Logo is dynamic; arrays can contain different types\nprint item 1 :a  \u00a0; ten\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "ColdFusion", "code": "\n\n<cfset arr1 = ArrayNew(1)>\n\n\n<cfscript>\n  arr2 = ArrayNew(2);\n</cfscript>\n\n\n", "explain": "Creating a one-dimensional Array:\nCreating a two-dimensional Array in CFScript:\nColdFusion Arrays are NOT zero-based, they begin at index 1\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "ABAP", "code": "\n\nTYPES: tty_int TYPE STANDARD TABLE OF i\n                    WITH NON-UNIQUE DEFAULT KEY.\n\nDATA(itab) = VALUE tty_int( ( 1 )\n                            ( 2 )\n                            ( 3 ) ).\n\nINSERT 4 INTO TABLE itab.\nAPPEND 5 TO itab.\nDELETE itab INDEX 1.\n\ncl_demo_output=>display( itab ).\ncl_demo_output=>display( itab[ 2 ] ).\n\n\nOutput:\n2 \n3 \n4 \n5 \n\n3\n\n", "explain": "There are no real arrays in ABAP but a construct called internal tables.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "F#", "code": "\n\n> Array.create 6 'A';;\nval it\u00a0: char [] = [|'A'; 'A'; 'A'; 'A'; 'A'; 'A'|]\n> Array.init 8 (fun i -> i * 10)\u00a0;;\nval it\u00a0: int [] = [|0; 10; 20; 30; 40; 50; 60; 70|]\n> let arr = [|0; 1; 2; 3; 4; 5; 6 |]\u00a0;;\nval arr\u00a0: int [] = [|0; 1; 2; 3; 4; 5; 6|]\n> arr.[4];;\nval it\u00a0: int = 4\n> arr.[4] <- 65\u00a0;;\nval it\u00a0: unit = ()\n> arr;;\nval it\u00a0: int [] = [|0; 1; 2; 3; 65; 5; 6|]\n\n> let arr = new ResizeArray<int>();;\nval arr\u00a0: ResizeArray<int>\n> arr.Add(42);;\nval it\u00a0: unit = ()\n> arr.[0];;\nval it\u00a0: int = 42\n> arr.[0] <- 13;;\nval it\u00a0: unit = ()\n> arr.[0];;\nval it\u00a0: int = 13\n> arr.[1];;\n> System.ArgumentOutOfRangeException: Index was out of range. Must be non-negative and less than the size of the collection.\nParameter name: index ...\n> arr;;\nval it\u00a0: ResizeArray<int> = seq [13]\n", "explain": "Fixed-length arrays:\nDynamic arrays:\nIf dynamic arrays are needed, it is possible to use the .NET class System.Collections.Generic.List<'T> which is aliased as Microsoft.FSharp.Collections.ResizeArray<'T>:\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "Groovy", "code": "\n\ndef aa = [ 1, 25, 31, -3 ]           // list\ndef a = [0] * 100                    // list of 100 zeroes\ndef b = 1..9                         // range notation\ndef c = (1..10).collect { 2.0**it }  // each output element is 2**(corresponding invoking list element)\n\n// There are no true \"multi-dimensional\" arrays in Groovy (as in most C-derived languages).\n// Use lists of lists in natural (\"row major\") order as a stand in.\ndef d = (0..1).collect { i -> (1..5).collect { j -> 2**(5*i+j) as double } }\ndef e = [ [  1.0,  2.0,  3.0,  4.0 ],\n          [  5.0,  6.0,  7.0,  8.0 ],\n          [  9.0, 10.0, 11.0, 12.0 ],\n          [ 13.0, 14.0, 15.0, 16.0 ] ]\n\nprintln aa\nprintln b\nprintln c\nprintln()\nd.each { print \"[\"; it.each { elt -> printf \"%7.1f \", elt }; println \"]\" }\nprintln()\ne.each { print \"[\"; it.each { elt -> printf \"%7.1f \", elt }; println \"]\" }\n\nOutput:\n[1, 25, 31, -3]\n[1, 2, 3, 4, 5, 6, 7, 8, 9]\n[2, 4, 8, 16, 32, 64, 128, 256, 512, 1024]\n\n[    2.0     4.0     8.0    16.0    32.0 ]\n[   64.0   128.0   256.0   512.0  1024.0 ]\n\n[    1.0     2.0     3.0     4.0 ]\n[    5.0     6.0     7.0     8.0 ]\n[    9.0    10.0    11.0    12.0 ]\n[   13.0    14.0    15.0    16.0 ]\n\ndef identity = { n ->\n   (1..n).collect { i -> (1..n).collect { j -> i==j\u00a0? 1.0\u00a0: 0.0 } }\n}\n\ndef i2 = identity(2)\ndef i15 = identity(15)\n\n\ni2.each { print \"[\"; it.each { elt -> printf \"%4.1f \", elt }; println \"]\" }\nprintln()\ni15.each { print \"[\"; it.each { elt -> printf \"%4.1f \", elt }; println \"]\" }\n\nOutput:\n[ 1.0  0.0 ]\n[ 0.0  1.0 ]\n\n[ 1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0  0.0 ]\n[ 0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  0.0  1.0 ]\n\ndef strings = ['Mary', 'had', 'a', 'little', 'lamb', \". It's\", 'fleece', 'was', 'white', 'as', 'snow']\n\nprintln strings\n\nstrings[0] = 'Arthur'\nstrings[4] = 'towel'\nstrings[6] = 'stain'\nstrings[8] = 'ripe'\nstrings[10] = 'strawberries'\n\nprintln strings\n\nOutput:\n[\"Mary\", \"had\", \"a\", \"little\", \"lamb\", \". It's\", \"fleece\", \"was\", \"white\", \"as\", \"snow\"]\n[\"Arthur\", \"had\", \"a\", \"little\", \"towel\", \". It's\", \"stain\", \"was\", \"ripe\", \"as\", \"strawberries\"]\n\n\nprintln strings[-1]\n\nOutput:\nstrawberries\n\n\nprintln strings[0, 7, 2, 3, 8]\nprintln strings[0..4]\nprintln strings[0..3, -5]\n\nOutput:\n[\"Arthur\", \"was\", \"a\", \"little\", \"ripe\"]\n[\"Arthur\", \"had\", \"a\", \"little\", \"towel\"]\n[\"Arthur\", \"had\", \"a\", \"little\", \"stain\"]\n\n", "explain": "Arrays and lists are synonymous in Groovy. They can be initialized with a wide range of operations and Groovy enhancements to the Collection and List classes.\nHere is a more interesting example showing a function that creates and returns a square identity matrix of order N:\nTest program:\nGroovy, like every other C-derived language in the known universe, uses ZERO-based array/list indexing.\nNegative indices are valid. They indicate indexing from the end of the list towards the start.\nGroovy lists can be resequenced and subsequenced by providing lists or ranges of indices in place of a single index.\n"}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "RPG", "code": "\nWorks with: ILE RPG\n      //-Static array\n      //--def of 10 el array of integers, initialised to zeros\n     D array... \n     D                 s             10i 0 dim(10)\n     D                                     inz\n      //--def an el\n     D el_1... \n     D                 s             10i 0 inz\n     \n      /free\n      \n       //-assign first el\n       //--first element of RPG array is indexed with 1\n       array(1) = 111;\n      \n       //-get first el of array\n       el_1 = array(1);\n      \n       //--display it\n       dsply ('First el of array='+%char(el_1));\n       //--displays: First el of array=111\n\n       //---or shorter, without \"el_1\"\n       dsply ('First el of array='+%char(array(1)));\n       //--displays: First el of array=111\n      \n      /end-free\n", "explain": ""}, {"task_name": "Arrays", "task_url": "https://rosettacode.org/wiki/Arrays", "task_cat": "Basic language learning", "lang": "AWK", "code": "\n\nBEGIN {\n  # to make an array, assign elements to it\n  array[1] = \"first\"\n  array[2] = \"second\"\n  array[3] = \"third\"\n  alen = 3  # want the length? store in separate variable\n\n  # or split a string\n  plen = split(\"2 3 5 7 11 13 17 19 23 29\", primes)\n  clen = split(\"Ottawa;Washington DC;Mexico City\", cities, \";\")\n\n  # retrieve an element\n  print \"The 6th prime number is \" primes[6]\n\n  # push an element\n  cities[clen += 1] = \"New York\"\n\n  dump(\"An array\", array, alen)\n  dump(\"Some primes\", primes, plen)\n  dump(\"A list of cities\", cities, clen)\n}\n\nfunction dump(what, array, len,    i) {\n  print what;\n\n  # iterate an array in order\n  for (i = 1; i <= len; i++) {\n    print \"  \" i \": \" array[i]\n  }\n}\n\n\nOutput:\nThe 6th prime number is 13\nAn array\n  1: first\n  2: second\n  3: third\nSome primes\n  1: 2\n  2: 3\n  3: 5\n  4: 7\n  5: 11\n  6: 13\n  7: 17\n  8: 19\n  9: 23\n  10: 29\nA list of cities\n  1: Ottawa\n  2: Washington DC\n  3: Mexico City\n  4: New York\n", "explain": "Every array in AWK is an associative array. AWK converts each array subscript to a string, so a[33], a[\"33\"] and a[29 + 4] are the same element.\nAn ordered array just uses subscripts as integers. Array subscripts can start at 1, or any other integer. The built-in split() function makes arrays that start at 1.\n"}]