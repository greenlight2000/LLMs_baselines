[{"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Python", "code": "\nTranslation of: C\nk8 = [\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 ] \nk7 = [\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 ]\nk6 = [\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 ]\nk5 = [\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 ]\nk4 = [\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 ]\nk3 = [\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 ]\nk2 = [\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 ]\nk1 = [\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 ]\n \nk87 = [0] * 256\nk65 = [0] * 256\nk43 = [0] * 256\nk21 = [0] * 256\n \ndef kboxinit():\n\tfor i in range(256):\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15]\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15]\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15]\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15]\n \ndef f(x):\n\tx = ( k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t      k43[x>> 8 & 255] <<  8 | k21[x & 255] )\n\treturn x<<11 | x>>(32-11)\n\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "C", "code": "\n\nstatic unsigned char const k8[16] = {\t14,  4, 13,  1,  2, 15, 11,  8,  3, 10,  6, 12,  5,  9,  0,  7 }; \nstatic unsigned char const k7[16] = {\t15,  1,  8, 14,  6, 11,  3,  4,  9,  7,  2, 13, 12,  0,  5, 10 };\nstatic unsigned char const k6[16] = {\t10,  0,  9, 14,  6,  3, 15,  5,  1, 13, 12,  7, 11,  4,  2,  8 };\nstatic unsigned char const k5[16] = {\t 7, 13, 14,  3,  0,  6,  9, 10,  1,  2,  8,  5, 11, 12,  4, 15 };\nstatic unsigned char const k4[16] = {\t 2, 12,  4,  1,  7, 10, 11,  6,  8,  5,  3, 15, 13,  0, 14,  9 };\nstatic unsigned char const k3[16] = {\t12,  1, 10, 15,  9,  2,  6,  8,  0, 13,  3,  4, 14,  7,  5, 11 };\nstatic unsigned char const k2[16] = {\t 4, 11,  2, 14, 15,  0,  8, 13,  3, 12,  9,  7,  5, 10,  6,  1 };\nstatic unsigned char const k1[16] = {\t13,  2,  8,  4,  6, 15, 11,  1, 10,  9,  3, 14,  5,  0, 12,  7 };\n\nstatic unsigned char k87[256];\nstatic unsigned char k65[256];\nstatic unsigned char k43[256];\nstatic unsigned char k21[256];\n\nvoid\nkboxinit(void)\n{\n\tint i;\n\tfor (i = 0; i < 256; i++) {\n\t\tk87[i] = k8[i >> 4] << 4 | k7[i & 15];\n\t\tk65[i] = k6[i >> 4] << 4 | k5[i & 15];\n\t\tk43[i] = k4[i >> 4] << 4 | k3[i & 15];\n\t\tk21[i] = k2[i >> 4] << 4 | k1[i & 15];\n\t}\n}\n\nstatic word32\nf(word32 x)\n{\n\tx = k87[x>>24 & 255] << 24 | k65[x>>16 & 255] << 16 |\n\t    k43[x>> 8 & 255] <<  8 | k21[x & 255];\n\treturn x<<11 | x>>(32-11);\n}\n\n", "explain": "Version with packed replacement table.\n"}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "C++", "code": "\nUINT_64 TGost::SWAP32(UINT_32 N1, UINT_32 N2)\n{\n    UINT_64 N;\n\tN = N1;\n\tN = (N<<32)|N2;\n\treturn UINT_64(N);\n}\n\nUINT_32 TGost::ReplaceBlock(UINT_32 x)\n{   \n    register i;\n    UINT_32 res = 0UL;\n    for(i=7;i>=0;i--)\n    {\n       ui4_0 = x>>(i*4);\n       ui4_0 = BS[ui4_0][i];\n       res = (res<<4)|ui4_0;\n    }\n    return res;\n}\n\nUINT_64 TGost::MainStep(UINT_64 N,UINT_32 X)\n{\n   UINT_32 N1,N2,S=0UL;\n   N1=UINT_32(N);\n   N2=N>>32;\n   S = N1 + X % 0x4000000000000;\n   S = ReplaceBlock(S);\n   S = (S<<11)|(S>>21);\n   S ^= N2;\n   N2 = N1;\n   N1 = S;\n   return SWAP32(N2,N1);\n}\n\n\n", "explain": "Variable \"BS\" is the replacement table.\n"}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "JavaScript", "code": "\nconst \u0422\u0430\u0431\u043b\u0438\u0446\u0430_\u0437\u0430\u043c\u0435\u043d = [\n\t[ 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3],\n\t[14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9],\n\t[ 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11],\n\t[ 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3],\n\t[ 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2],\n\t[ 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14],\n\t[13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12],\n\t[ 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12]\n];\n\nconst \u041e\u0441\u043d\u043e\u0432\u043d\u043e\u0439_\u0448\u0430\u0433 = (\u0431\u043b\u043e\u043a_\u0442\u0435\u043a\u0441\u0442\u0430, \u044d\u043b\u0435\u043c\u0435\u043d\u0442_\u043a\u043b\u044e\u0447\u0430, \u0422\u0417) => {\n\tconst\n\t\tN = \u0431\u043b\u043e\u043a_\u0442\u0435\u043a\u0441\u0442\u0430.slice(0),\n\t\tS = N[0] + \u044d\u043b\u0435\u043c\u0435\u043d\u0442_\u043a\u043b\u044e\u0447\u0430 & 0xFFFFFFFF;\n\tlet \u043d\u043e\u0432_S = 0;\n\tfor (let \u0441\u0447 = 0; \u0441\u0447 < 4; \u0441\u0447++) {\n\t\tconst \u044f\u0447 = (S >>> (\u0441\u0447 << 3)) & 0xFF;\n\t\t\u043d\u043e\u0432_S +=\n\t\t\t\u0422\u0417[\u0441\u0447 * 2][\u044f\u0447 & 0x0F]\n\t\t\t+ (\u0422\u0417[\u0441\u0447 * 2 + 1][\u044f\u0447 >>> 4] << 4)\n\t\t\t<< (\u0441\u0447 << 3);\n\t}\n\t\u043d\u043e\u0432_S =\n\t\t(\u043d\u043e\u0432_S << 11)\n\t\t+ (\u043d\u043e\u0432_S >>> 21)\n\t\t& 0xFFFFFFFF\n\t\t^ N[1];\n\tN[1] = N[0]; N[0] = \u043d\u043e\u0432_S;\n\treturn N;\n};\n\n\n", "explain": "Note: the variable \"\u0431\u043b\u043e\u043a_\u0442\u0435\u043a\u0441\u0442\u0430\" is an array of two 32-bit values that make up the block.\n"}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\ntype sBox [8][16]byte\n\ntype gost struct {\n    k87, k65, k43, k21 [256]byte\n    enc                []byte\n}\n\nfunc newGost(s *sBox) *gost {\n    var g gost\n    for i := range g.k87 {\n        g.k87[i] = s[7][i>>4]<<4 | s[6][i&15]\n        g.k65[i] = s[5][i>>4]<<4 | s[4][i&15]\n        g.k43[i] = s[3][i>>4]<<4 | s[2][i&15]\n        g.k21[i] = s[1][i>>4]<<4 | s[0][i&15]\n    }\n    g.enc = make([]byte, 8)\n    return &g\n}\n\nfunc (g *gost) f(x uint32) uint32 {\n    x = uint32(g.k87[x>>24&255])<<24 | uint32(g.k65[x>>16&255])<<16 |\n        uint32(g.k43[x>>8&255])<<8 | uint32(g.k21[x&255])\n    return x<<11 | x>>(32-11)\n}\n\n// code above adapted from posted C code\n\n// validation code below follows example on talk page\n\n// cbrf from WP\nvar cbrf = sBox{\n    {4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3},\n    {14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9},\n    {5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11},\n    {7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3},\n    {6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2},\n    {4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14},\n    {13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12},\n    {1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12},\n}\n\nfunc u32(b []byte) uint32 {\n    return uint32(b[0]) | uint32(b[1])<<8 | uint32(b[2])<<16 | uint32(b[3])<<24\n}\n\nfunc b4(u uint32, b []byte) {\n    b[0] = byte(u)\n    b[1] = byte(u >> 8)\n    b[2] = byte(u >> 16)\n    b[3] = byte(u >> 24)\n}\n\nfunc (g *gost) mainStep(input []byte, key []byte) {\n    key32 := u32(key)\n    input1 := u32(input[:4])\n    input2 := u32(input[4:])\n    b4(g.f(key32+input1)^input2, g.enc[:4])\n    copy(g.enc[4:], input[:4])\n}\n\nfunc main() {\n    input := []byte{0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04}\n    key := []byte{0xF9, 0x04, 0xC1, 0xE2}\n\n    g := newGost(&cbrf)\n    g.mainStep(input, key)\n    for _, b := range g.enc {\n        fmt.Printf(\"[%02x]\", b)\n    }\n    fmt.Println()\n}\n\n\nOutput:\n[1f][88][cf][07][21][04][3b][04]\n\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "X86_Assembly", "code": "\n\nEAX - the youngest part of the transformed block (N1);\nEDX - leading part transformed block (N2);\nESI - address of the first element of the key;\nEBX - table address changes;\nECX - the number of major steps.\n\nEDX = N1, EAX = N2 for cycles 32-\u0417, 32-\u0420;\nEAX = N1, EDX = N2 for cycle 16-\u0417.\n\nAt the end of the run the registers as follows:\nEBX (pointer to table of changes) - the same as that in the early\nESI (pointer to key) - points to the first byte of the key - it's N * 4 larger than the initial values for the SI cycle reps N (for encryption cycles N = 32 => 4 * N = 128, for authentication code generation cycle N = 16 => 4 * N = 64), larger than the initial values for the authentication code generation cycle.\nECX = 0\nThe contents of the segment registers unchanged.\n        .386\n        .model  flat\n        .code\n_gost32 proc    near32\n        public  _gost32\n; The inner loop of a subroutine\n; 1. Beginning of the cycle, and preservation of the old N1\niloop:  mov     EBP,EAX\n; 2. Adding to the S key modulo 2^32\n        add     EAX,[ESI] ; add the key\n        add     ESI,4   ; the next element of the key.\n; 3. Block-replace in the rotation of S by 8 bits to the left\nREPT    3\n        xlat            ; recoding byte\n        ror     EAX,8   ; AL <- next byte\n        add     EBX,100h; next node changes\nENDM\n        xlat            ; recoding byte\n        sub     EBX,300h; BX -> 1st node changes\n; 4. Complete rotation of the S at 3 bits to the left\n        rol     EAX,3\n; 5. The calculation of the new values of N1,N2\n        xor     EAX,EDX\n        mov     EDX,EBP\n; The completion of the inner loop\n        loop    iloop\n        ret\n_gost32 endp\n        end\n\n", "explain": "Parameter in the call:\nOutput results:\nRegister Usage: all except EDI.\nNotes:\n"}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Rust", "code": "\nuse std::convert::TryInto;\nuse std::env;\nuse std::num::Wrapping;\n\nconst REPLACEMENT_TABLE: [[u8; 16]; 8] = [\n    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],\n    [14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9],\n    [5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11],\n    [7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3],\n    [6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2],\n    [4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14],\n    [13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12],\n    [1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12],\n];\nconst KEYS: [u32; 8] = [\n    0xE2C1_04F9,\n    0xE41D_7CDE,\n    0x7FE5_E857,\n    0x0602_65B4,\n    0x281C_CC85,\n    0x2E2C_929A,\n    0x4746_4503,\n    0xE00_CE510,\n];\n\nfn main() {\n    let args: Vec<String> = env::args().collect();\n    if args.len() < 2 {\n        let plain_text: Vec<u8> = vec![0x04, 0x3B, 0x04, 0x21, 0x04, 0x32, 0x04, 0x30];\n        println!(\n            \"Before one step: {}\\n\",\n            plain_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n        let encoded_text = main_step(plain_text, KEYS[0]);\n        println!(\n            \"After one step\u00a0: {}\\n\",\n            encoded_text\n                .iter()\n                .cloned()\n                .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))\n        );\n    } else {\n        let mut t = args[1].clone(); // \"They call him... \u0411\u0430\u0431\u0430 \u042f\u0433\u0430\"\n        t += &\" \".repeat((8 - t.len() % 8) % 8);\n        let text_bytes = t.bytes().collect::<Vec<_>>();\n        let plain_text = text_bytes.chunks(8).collect::<Vec<_>>();\n        println!(\n            \"Plain text \u00a0: {}\\n\",\n            plain_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let encoded_text = plain_text\n            .iter()\n            .map(|c| encode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Encoded text: {}\\n\",\n            encoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let decoded_text = encoded_text\n            .iter()\n            .map(|c| decode(c.to_vec()))\n            .collect::<Vec<_>>();\n        println!(\n            \"Decoded text: {}\\n\",\n            decoded_text.iter().cloned().fold(\"\".to_string(), |a, x| a\n                + \"[\"\n                + &x.into_iter()\n                    .fold(\"\".to_string(), |b, y| b + &format!(\"{:02X} \", y))[..23]\n                + \"]\")\n        );\n        let recovered_text =\n            String::from_utf8(decoded_text.iter().cloned().flatten().collect::<Vec<_>>()).unwrap();\n        println!(\"Recovered text: {}\\n\", recovered_text);\n    }\n}\n\nfn encode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block;\n    for i in 0..24 {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    for i in (0..8).rev() {\n        step = main_step(step, KEYS[i]);\n    }\n    step\n}\n\nfn decode(text_block: Vec<u8>) -> Vec<u8> {\n    let mut step = text_block[4..].to_vec();\n    let mut temp = text_block[..4].to_vec();\n    step.append(&mut temp);\n    for key in &KEYS {\n        step = main_step(step, *key);\n    }\n    for i in (0..24).rev() {\n        step = main_step(step, KEYS[i % 8]);\n    }\n    let mut ans = step[4..].to_vec();\n    let mut temp = step[..4].to_vec();\n    ans.append(&mut temp);\n    ans\n}\n\nfn main_step(text_block: Vec<u8>, key_element: u32) -> Vec<u8> {\n    let mut n = text_block;\n    let mut s = (Wrapping(\n        u32::from(n[0]) << 24 | u32::from(n[1]) << 16 | u32::from(n[2]) << 8 | u32::from(n[3]),\n    ) + Wrapping(key_element))\n    .0;\n    let mut new_s: u32 = 0;\n    for mid in 0..4 {\n        let cell = (s >> (mid << 3)) & 0xFF;\n        new_s += (u32::from(REPLACEMENT_TABLE[(mid * 2) as usize][(cell & 0x0f) as usize])\n            + (u32::from(REPLACEMENT_TABLE[(mid * 2 + 1) as usize][(cell >> 4) as usize]) << 4))\n            << (mid << 3);\n    }\n    s = ((new_s << 11) + (new_s >> 21))\n        ^ (u32::from(n[4]) << 24 | u32::from(n[5]) << 16 | u32::from(n[6]) << 8 | u32::from(n[7]));\n    n[4] = n[0];\n    n[5] = n[1];\n    n[6] = n[2];\n    n[7] = n[3];\n    n[0] = (s >> 24).try_into().unwrap();\n    n[1] = ((s >> 16) & 0xFF).try_into().unwrap();\n    n[2] = ((s >> 8) & 0xFF).try_into().unwrap();\n    n[3] = (s & 0xFF).try_into().unwrap();\n    n\n}\n\n\nOutput:\nWithout parameters:\n\nBefore one step: 04 3B 04 21 04 32 04 30\n\nAfter one step\u00a0: 07 CF 88 1F 04 3B 04 21\n\n\nWith parameter \"They call him... \u0411\u0430\u0431\u0430 \u042f\u0433\u0430\"\n\nPlain text \u00a0: [54 68 65 79 20 63 61 6C][6C 20 68 69 6D 2E 2E 2E][20 D0 91 D0 B0 D0 B1 D0][B0 20 D0 AF D0 B3 D0 B0]\n\nEncoded text: [D6 7C 52 4A EA 9A 58 2D][D9 81 F7 DA ED 89 46 25][0A 75 2D 89 59 8B 3D C4][53 DC D6 E2 79 B6 68 24]\n\nDecoded text: [54 68 65 79 20 63 61 6C][6C 20 68 69 6D 2E 2E 2E][20 D0 91 D0 B0 D0 B1 D0][B0 20 D0 AF D0 B3 D0 B0]\n\nRecovered text: They call him... \u0411\u0430\u0431\u0430 \u042f\u0433\u0430\n\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Julia", "code": "\nTranslation of: Kotlin\nconst k8 = [ 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3]\nconst k7 = [14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9]\nconst k6 = [ 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11]\nconst k5 = [ 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3]\nconst k4 = [ 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2]\nconst k3 = [ 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14]\nconst k2 = [13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12]\nconst k1 = [ 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12]\nconst k87 = zeros(UInt32,256)\nconst k65 = zeros(UInt32,256)\nconst k43 = zeros(UInt32,256)\nconst k21 = zeros(UInt32,256)\nfor i in 1:256\n    j = (i-1) >> 4 + 1\n    k = (i-1) & 15 + 1\n    k87[i] = (k1[j] << 4) | k2[k]\n    k65[i] = (k3[j] << 4) | k4[k]\n    k43[i] = (k5[j] << 4) | k6[k]\n    k21[i] = (k7[j] << 4) | k8[k]\nend\n\nfunction f(x)\n    y = (k87[(x>>24) & 0xff + 1] << 24) | (k65[(x>>16) & 0xff + 1] << 16) |\n        (k43[(x>> 8) & 0xff + 1] <<  8) | k21[x & 0xff + 1]\n    (y << 11) | (y >> (32-11))\nend\n\nbytes2int(arr) = arr[1] + (UInt32(arr[2]) << 8) + (UInt32(arr[3]) << 16) + (UInt32(arr[4])) << 24\nint2bytes(x) = [UInt8(x&0xff), UInt8((x&0xff00)>>8), UInt8((x&0xff0000)>>16), UInt8(x>>24)]\n\nfunction mainstep(inputbytes, keybytes)\n    intkey = bytes2int(keybytes)\n    lowint = bytes2int(inputbytes[1:4])\n    topint = bytes2int(inputbytes[5:8])\n    xorbytes = f(UInt32(intkey) + UInt32(lowint)) \u22bb topint\n    vcat(int2bytes(xorbytes), inputbytes[1:4])\nend\n\nconst input = [0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04]\nconst key = [0xF9, 0x04, 0xC1, 0xE2]   \nprintln(\"The encoded bytes are $(mainstep(input, key))\")\n\n\nOutput:\n\nThe encoded bytes are UInt8[0x1f, 0x88, 0xcf, 0x07, 0x21, 0x04, 0x3b, 0x04]\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Kotlin", "code": "\nTranslation of: Go\n// version 1.1.4-3\n\nfun Byte.toUInt()  = java.lang.Byte.toUnsignedInt(this)\n\nfun Byte.toULong() = java.lang.Byte.toUnsignedLong(this)\n\nfun Int.toULong()  = java.lang.Integer.toUnsignedLong(this)\n\nval s = arrayOf(\n    byteArrayOf( 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3),\n    byteArrayOf(14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9),\n    byteArrayOf( 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11),\n    byteArrayOf( 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3),\n    byteArrayOf( 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2),\n    byteArrayOf( 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14),\n    byteArrayOf(13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12),\n    byteArrayOf( 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12)\n)\n\nclass Gost(val sBox: Array<ByteArray>) {\n\n    val k87 = ByteArray(256)\n    val k65 = ByteArray(256)\n    val k43 = ByteArray(256)\n    val k21 = ByteArray(256)\n    val enc = ByteArray(8)\n\n    init {\n        for (i in 0 until 256) {\n            val j = i ushr 4\n            val k = i and 15 \n            k87[i] = ((sBox[7][j].toUInt() shl 4) or sBox[6][k].toUInt()).toByte()\n            k65[i] = ((sBox[5][j].toUInt() shl 4) or sBox[4][k].toUInt()).toByte()\n            k43[i] = ((sBox[3][j].toUInt() shl 4) or sBox[2][k].toUInt()).toByte()\n            k21[i] = ((sBox[1][j].toUInt() shl 4) or sBox[0][k].toUInt()).toByte()\n        }\n    }\n\n    fun f(x: Int): Int {\n        val y = (k87[(x ushr 24) and 255].toULong() shl 24) or\n                (k65[(x ushr 16) and 255].toULong() shl 16) or\n                (k43[(x ushr  8) and 255].toULong() shl  8) or\n                (k21[ x and 255].toULong())   \n        return ((y shl 11) or (y ushr 21)).toInt()\n    }\n\n    fun u32(ba: ByteArray): Int =\n        (ba[0].toULong() or \n        (ba[1].toULong() shl 8) or \n        (ba[2].toULong() shl 16) or \n        (ba[3].toULong() shl 24)).toInt()\n\n    fun b4(u: Int) {\n        enc[0] = u.toByte()\n        enc[1] = (u ushr  8).toByte()\n        enc[2] = (u ushr 16).toByte()\n        enc[3] = (u ushr 24).toByte()\n    }\n\n    fun mainStep(input: ByteArray, key: ByteArray) {\n        val key32  = u32(key)\n        val input1 = u32(input.sliceArray(0..3))\n        val input2 = u32(input.sliceArray(4..7))\n        val temp   = (key32.toULong() + input1.toULong()).toInt()\n        b4(f(temp) xor input2)\n        for (i in 0..3) enc[4 + i] = input[i]\n    }\n}\n\nfun main(args: Array<String>) {\n    val input = byteArrayOf(0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04)\n    val key = byteArrayOf(0xF9.toByte(), 0x04, 0xC1.toByte(), 0xE2.toByte())   \n    val g = Gost(s)\n    g.mainStep(input, key)\n    for (b in g.enc) print(\"[%02X]\".format(b))\n    println()\n}\n\n\nOutput:\n[1F][88][CF][07][21][04][3B][04]\n\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "Perl", "code": "\nTranslation of: Raku\nLibrary: ntheory\nuse strict;\nuse warnings;\nuse ntheory 'fromdigits';\n\n# sboxes from http://en.wikipedia.org/wiki/GOST_(block_cipher)\nmy @sbox = (\n    [4, 10, 9, 2, 13, 8, 0, 14, 6, 11, 1, 12, 7, 15, 5, 3],\n    [14, 11, 4, 12, 6, 13, 15, 10, 2, 3, 8, 1, 0, 7, 5, 9],\n    [5, 8, 1, 13, 10, 3, 4, 2, 14, 15, 12, 7, 6, 0, 9, 11],\n    [7, 13, 10, 1, 0, 8, 9, 15, 14, 4, 6, 12, 11, 2, 5, 3],\n    [6, 12, 7, 1, 5, 15, 13, 8, 4, 10, 9, 14, 0, 3, 11, 2],\n    [4, 11, 10, 0, 7, 2, 1, 13, 3, 6, 8, 5, 9, 12, 15, 14],\n    [13, 11, 4, 1, 3, 15, 5, 9, 0, 10, 14, 7, 6, 8, 2, 12],\n    [1, 15, 13, 0, 5, 7, 10, 4, 9, 2, 3, 14, 6, 11, 8, 12]\n);\n\nsub rol32 {\n    my($y, $n) = @_;\n    ($y << $n) % 2**32 | ($y >> (32 - $n))\n}\n\nsub GOST_round {\n    my($R, $K) = @_;\n    my $a = ($R + $K) % 2**32;\n    my $b = fromdigits([map { $sbox[$_][($a >> (4*$_))%16] } reverse 0..7],16);\n    rol32($b,11);\n}\n\nsub feistel_step {\n    my($F, $L, $R, $K) = @_;\n    $R, $L ^ &$F($R, $K)\n}\n\nmy @input = (0x21, 0x04, 0x3B, 0x04, 0x30, 0x04, 0x32, 0x04);\nmy @key   = (0xF9, 0x04, 0xC1, 0xE2);\n\nmy $R = fromdigits([reverse @input[0..3]], 256); # 1st half\nmy $L = fromdigits([reverse @input[4..7]], 256); # 2nd half\nmy $K = fromdigits([reverse @key        ], 256);\n\n($L,$R) = feistel_step(\\&GOST_round, $L, $R, $K);\n\nprintf '%02X ', (($L << 32) + $R >> (8*$_))%256 for 0..7;\nprint \"\\n\";\n\n\nOutput:\n1F 88 CF 07 21 04 3B 04\n", "explain": ""}, {"task_name": "Main step of GOST 28147-89", "task_url": "https://rosettacode.org/wiki/Main_step_of_GOST_28147-89", "task_cat": "Encryption", "lang": "D", "code": "\nTranslation of: C\nTranslation of: Go\nimport std.stdio, std.range, std.algorithm;\n\n/// Rotate uint left.\nuint rol(in uint x, in uint nBits) @safe pure nothrow @nogc {\n    return (x << nBits) | (x >> (32 - nBits));\n}\n\nalias Nibble = ubyte; // 4 bits used.\nalias SBox = immutable Nibble[16][8];\n\nprivate bool _validateSBox(in SBox data) @safe pure nothrow @nogc {\n    foreach (const ref row; data)\n        foreach (ub; row)\n            if (ub >= 16) // Verify it's a nibble.\n                return false;\n    return true;\n}\n\nstruct GOST(s...) if (s.length == 1 && s[0]._validateSBox) {\n    private static generate(ubyte k)() @safe pure nothrow {\n        return k87.length.iota\n               .map!(i=> (s[0][k][i >> 4] << 4) | s[0][k - 1][i & 0xF])\n               .array;\n    }\n\n    private uint[2] buffer;\n    private static immutable ubyte[256] k87 = generate!7,\n                                        k65 = generate!5,\n                                        k43 = generate!3,\n                                        k21 = generate!1;\n\n    // Endianess problems?\n    private static uint f(in uint x) pure nothrow @nogc @safe {\n        immutable uint y = (k87[(x >> 24) & 0xFF] << 24) |\n                           (k65[(x >> 16) & 0xFF] << 16) |\n                           (k43[(x >>  8) & 0xFF] <<  8) |\n                            k21[ x        & 0xFF];\n        return rol(y, 11);\n    }\n\n    // This performs only a step of the encoding.\n    public void mainStep(in uint[2] input, in uint key)\n    pure nothrow @nogc @safe {\n        buffer[0] = f(key + input[0]) ^ input[1];\n        buffer[1] = input[0];\n    }\n}\n\nvoid main() {\n    // S-boxes used by the Central Bank of Russian Federation:\n    // http://en.wikipedia.org/wiki/GOST_28147-89\n    // (This is a matrix of nibbles).\n    enum SBox cbrf = [\n      [ 4, 10,  9,  2, 13,  8,  0, 14,  6, 11,  1, 12,  7, 15,  5,  3],\n      [14, 11,  4, 12,  6, 13, 15, 10,  2,  3,  8,  1,  0,  7,  5,  9],\n      [ 5,  8,  1, 13, 10,  3,  4,  2, 14, 15, 12,  7,  6,  0,  9, 11],\n      [ 7, 13, 10,  1,  0,  8,  9, 15, 14,  4,  6, 12, 11,  2,  5,  3],\n      [ 6, 12,  7,  1,  5, 15, 13,  8,  4, 10,  9, 14,  0,  3, 11,  2],\n      [ 4, 11, 10,  0,  7,  2,  1, 13,  3,  6,  8,  5,  9, 12, 15, 14],\n      [13, 11,  4,  1,  3, 15,  5,  9,  0, 10, 14,  7,  6,  8,  2, 12],\n      [ 1, 15, 13,  0,  5,  7, 10,  4,  9,  2,  3, 14,  6, 11,  8, 12]];\n\n    GOST!cbrf g;\n\n    // Example from the talk page (bytes swapped for endianess):\n    immutable uint[2] input = [0x_04_3B_04_21, 0x_04_32_04_30];\n    immutable uint key = 0x_E2_C1_04_F9;\n\n    g.mainStep(input, key);\n    writefln(\"%(%08X\u00a0%)\", g.buffer);\n}\n\n\nOutput:\n07CF881F 043B0421\n", "explain": ""}]