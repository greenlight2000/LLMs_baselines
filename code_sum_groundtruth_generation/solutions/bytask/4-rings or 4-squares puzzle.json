[{"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Python", "code": "\nProcedural[edit]\nItertools[edit]\nimport itertools\n\ndef all_equal(a,b,c,d,e,f,g):\n    return a+b == b+c+d == d+e+f == f+g\n\ndef foursquares(lo,hi,unique,show):\n    solutions = 0\n    if unique:\n        uorn = \"unique\"\n        citer = itertools.combinations(range(lo,hi+1),7)\n    else:\n        uorn = \"non-unique\"\n        citer =  itertools.combinations_with_replacement(range(lo,hi+1),7)\n                    \n    for c in citer:\n            for p in set(itertools.permutations(c)):\n                if all_equal(*p):\n                    solutions += 1\n                    if show:\n                        print str(p)[1:-1]\n\n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n\n\nfoursquares(1,7,True,True)\n4, 5, 3, 1, 6, 2, 7\n3, 7, 2, 1, 5, 4, 6\n5, 6, 2, 3, 1, 7, 4\n4, 7, 1, 3, 2, 6, 5\n6, 4, 5, 1, 2, 7, 3\n7, 3, 2, 5, 1, 4, 6\n7, 2, 6, 1, 3, 5, 4\n6, 4, 1, 5, 2, 3, 7\n8 unique solutions in 1 to 7\n\n\nfoursquares(3,9,True,True)\n7, 8, 3, 4, 5, 6, 9\n9, 6, 4, 5, 3, 7, 8\n8, 7, 3, 5, 4, 6, 9\n9, 6, 5, 4, 3, 8, 7\n4 unique solutions in 3 to 9\n\n\nfoursquares(0,9,False,False)\n2860 non-unique solutions in 0 to 9\nGenerators[edit]\n\ndef foursquares(lo,hi,unique,show):\n\n    def acd_iter():\n        \"\"\"\n        Iterates through all the possible valid values of \n        a, c, and d.\n        \n        a = c + d\n        \"\"\"\n        for c in range(lo,hi+1):\n            for d in range(lo,hi+1):\n                if (not unique) or (c <> d):\n                    a = c + d\n                    if a >= lo and a <= hi:\n                        if (not unique) or (c <> 0 and d <> 0):\n                            yield (a,c,d)\n                            \n    def ge_iter():\n        \"\"\"\n        Iterates through all the possible valid values of \n        g and e.\n        \n        g = d + e\n        \"\"\"\n        for e in range(lo,hi+1):\n            if (not unique) or (e not in (a,c,d)):\n                g = d + e\n                if g >= lo and g <= hi:\n                    if (not unique) or (g not in (a,c,d,e)):\n                        yield (g,e)\n                        \n    def bf_iter():\n        \"\"\"\n        Iterates through all the possible valid values of \n        b and f.\n        \n        b = e + f - c\n        \"\"\"\n        for f in range(lo,hi+1):\n            if (not unique) or (f not in (a,c,d,g,e)):\n                b = e + f - c\n                if b >= lo and b <= hi:\n                    if (not unique) or (b not in (a,c,d,g,e,f)):\n                        yield (b,f)\n\n    solutions = 0                    \n    acd_itr = acd_iter()              \n    for acd in acd_itr:\n        a,c,d = acd\n        ge_itr = ge_iter()\n        for ge in ge_itr:\n            g,e = ge\n            bf_itr = bf_iter()\n            for bf in bf_itr:\n                b,f = bf\n                solutions += 1\n                if show:\n                    print str((a,b,c,d,e,f,g))[1:-1]\n    if unique:\n        uorn = \"unique\"\n    else:\n        uorn = \"non-unique\"\n               \n    print str(solutions)+\" \"+uorn+\" solutions in \"+str(lo)+\" to \"+str(hi)\n    print\n\nOutputfoursquares(1,7,True,True)\n4, 7, 1, 3, 2, 6, 5\n6, 4, 1, 5, 2, 3, 7\n3, 7, 2, 1, 5, 4, 6\n5, 6, 2, 3, 1, 7, 4\n7, 3, 2, 5, 1, 4, 6\n4, 5, 3, 1, 6, 2, 7\n6, 4, 5, 1, 2, 7, 3\n7, 2, 6, 1, 3, 5, 4\n8 unique solutions in 1 to 7\n\n\nfoursquares(3,9,True,True)\n7, 8, 3, 4, 5, 6, 9\n8, 7, 3, 5, 4, 6, 9\n9, 6, 4, 5, 3, 7, 8\n9, 6, 5, 4, 3, 8, 7\n4 unique solutions in 3 to 9\n\n\nfoursquares(0,9,False,False)\n2860 non-unique solutions in 0 to 9\nFunctional[edit]\nTranslation of: Haskell\nTranslation of: JavaScript\nWorks with: Python version 3.7\n'''4-rings or 4-squares puzzle'''\n\nfrom itertools import chain\n\n\n# rings\u00a0:: noRepeatedDigits -> DigitList -> Lists of solutions\n# rings\u00a0:: Bool -> [Int] -> [[Int]]\ndef rings(uniq):\n    '''Sets of unique or non-unique integer values\n       (drawn from the `digits` argument)\n       for each of the seven names [a..g] such that:\n       (a + b) == (b + c + d) == (d + e + f) == (f + g)\n    '''\n    def go(digits):\n        ns = sorted(digits, reverse=True)\n        h = ns[0]\n\n        # CENTRAL DIGIT\u00a0:: d\n        def central(d):\n            xs = list(filter(lambda x: h >= (d + x), ns))\n\n            # LEFT NEIGHBOUR AND LEFTMOST\u00a0:: c and a\n            def left(c):\n                a = c + d\n                if a > h:\n                    return []\n                else:\n                    # RIGHT NEIGHBOUR AND RIGHTMOST\u00a0:: e and g\n                    def right(e):\n                        g = d + e\n                        if ((g > h) or (uniq and (g == c))):\n                            return []\n                        else:\n                            agDelta = a - g\n                            bfs = difference(ns)(\n                                [d, c, e, g, a]\n                            ) if uniq else ns\n\n                            # MID LEFT AND RIGHT\u00a0:: b and f\n                            def midLeftRight(b):\n                                f = b + agDelta\n                                return [[a, b, c, d, e, f, g]] if (\n                                    (f in bfs) and (\n                                        (not uniq) or (\n                                            f not in [a, b, c, d, e, g]\n                                        )\n                                    )\n                                ) else []\n\n    # CANDIDATE DIGITS BOUND TO POSITIONS [a .. g] --------\n\n                            return concatMap(midLeftRight)(bfs)\n\n                    return concatMap(right)(\n                        difference(xs)([d, c, a]) if uniq else ns\n                    )\n\n            return concatMap(left)(\n                delete(d)(xs) if uniq else ns\n            )\n\n        return concatMap(central)(ns)\n\n    return lambda digits: go(digits) if digits else []\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Testing unique digits [1..7], [3..9] and unrestricted digits'''\n\n    print(main.__doc__ + ':\\n')\n    print(unlines(map(\n        lambda tpl: '\\nrings' + repr(tpl) + ':\\n\\n' + unlines(\n            map(repr, uncurry(rings)(*tpl))\n        ), [\n            (True, enumFromTo(1)(7)),\n            (True, enumFromTo(3)(9))\n        ]\n    )))\n    tpl = (False, enumFromTo(0)(9))\n    print(\n        '\\n\\nlen(rings' + repr(tpl) + '):\\n\\n' +\n        str(len(uncurry(rings)(*tpl)))\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# concatMap\u00a0:: (a -> [b]) -> [a] -> [b]\ndef concatMap(f):\n    '''A concatenated list over which a function has been mapped.\n       The list monad can be derived by using a function f which\n       wraps its output in a list,\n       (using an empty list to represent computational failure).\n    '''\n    return lambda xs: list(\n        chain.from_iterable(map(f, xs))\n    )\n\n\n# delete\u00a0:: Eq a => a -> [a] -> [a]\ndef delete(x):\n    '''xs with the first of any instances of x removed.'''\n    def go(xs):\n        xs.remove(x)\n        return xs\n    return lambda xs: go(list(xs)) if (\n        x in xs\n    ) else list(xs)\n\n\n#  difference\u00a0:: Eq a => [a] -> [a] -> [a]\ndef difference(xs):\n    '''All elements of ys except any also found in xs'''\n    def go(ys):\n        s = set(ys)\n        return [x for x in xs if x not in s]\n    return lambda ys: go(ys)\n\n\n# enumFromTo\u00a0:: (Int, Int) -> [Int]\ndef enumFromTo(m):\n    '''Integer enumeration from m to n.'''\n    return lambda n: list(range(m, 1 + n))\n\n\n# uncurry\u00a0:: (a -> b -> c) -> ((a, b) -> c)\ndef uncurry(f):\n    '''A function over a pair of arguments,\n       derived from a vanilla or curried function.\n    '''\n    return lambda x, y: f(x)(y)\n\n\n# unlines\u00a0:: [String] -> String\ndef unlines(xs):\n    '''A single string formed by the intercalation\n       of a list of strings with the newline character.\n    '''\n    return '\\n'.join(xs)\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nTesting unique digits [1..7], [3..9] and unrestricted digits:\n\nrings(True, [1, 2, 3, 4, 5, 6, 7]):\n\n[7, 3, 2, 5, 1, 4, 6]\n[6, 4, 1, 5, 2, 3, 7]\n[5, 6, 2, 3, 1, 7, 4]\n[4, 7, 1, 3, 2, 6, 5]\n[7, 2, 6, 1, 3, 5, 4]\n[6, 4, 5, 1, 2, 7, 3]\n[4, 5, 3, 1, 6, 2, 7]\n[3, 7, 2, 1, 5, 4, 6]\n\nrings(True, [3, 4, 5, 6, 7, 8, 9]):\n\n[9, 6, 4, 5, 3, 7, 8]\n[8, 7, 3, 5, 4, 6, 9]\n[9, 6, 5, 4, 3, 8, 7]\n[7, 8, 3, 4, 5, 6, 9]\n\n\nlen(rings(False, [0, 1, 2, 3, 4, 5, 6, 7, 8, 9])):\n\n2860\n", "explain": "Output\nFaster solution without itertools\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "C", "code": "\n#include <stdio.h>\n\n#define TRUE 1\n#define FALSE 0\n\nint a,b,c,d,e,f,g;\nint lo,hi,unique,show;\nint solutions;\n\nvoid\nbf()\n{\n    for (f = lo;f <= hi; f++)\n        if ((!unique) ||\n           ((f != a) && (f != c) && (f != d) && (f != g) && (f != e)))\n            {\n            b = e + f - c;\n            if ((b >= lo) && (b <= hi) &&\n                   ((!unique) || ((b != a) && (b != c) &&\n                   (b != d) && (b != g) && (b != e) && (b != f))))\n                {\n                solutions++;\n                if (show)\n                    printf(\"%d %d %d %d %d %d %d\\n\",a,b,c,d,e,f,g);\n                }\n            }\n}\n\n\nvoid\nge()\n{\n    for (e = lo;e <= hi; e++)\n        if ((!unique) || ((e != a) && (e != c) && (e != d)))\n            {\n            g = d + e;\n            if ((g >= lo) && (g <= hi) &&\n                   ((!unique) || ((g != a) && (g != c) &&\n                   (g != d) && (g != e))))\n                bf();\n            }\n}\n\nvoid\nacd()\n{\n    for (c = lo;c <= hi; c++)\n        for (d = lo;d <= hi; d++)\n            if ((!unique) || (c != d))\n                {\n                a = c + d;\n                if ((a >= lo) && (a <= hi) &&\n                   ((!unique) || ((c != 0) && (d != 0))))\n                    ge();\n                }\n}\n\n\nvoid\nfoursquares(int plo,int phi, int punique,int pshow)\n{\n    lo = plo;\n    hi = phi;\n    unique = punique;\n    show = pshow;\n    solutions = 0;\n\n    printf(\"\\n\");\n\n    acd();\n\n    if (unique)\n        printf(\"\\n%d unique solutions in %d to %d\\n\",solutions,lo,hi);\n    else\n        printf(\"\\n%d non-unique solutions in %d to %d\\n\",solutions,lo,hi);\n}\n\nmain()\n{\n    foursquares(1,7,TRUE,TRUE);\n    foursquares(3,9,TRUE,TRUE);\n    foursquares(0,9,FALSE,FALSE);\n}\n\n\n\n\n4 7 1 3 2 6 5\n6 4 1 5 2 3 7\n3 7 2 1 5 4 6\n5 6 2 3 1 7 4\n7 3 2 5 1 4 6\n4 5 3 1 6 2 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n\n8 unique solutions in 1 to 7\n\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\n\n4 unique solutions in 3 to 9\n\n\n2860 non-unique solutions in 0 to 9\n\n", "explain": "Output\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "C++", "code": "\n//C++14/17\n#include <algorithm>//std::for_each\n#include <iostream> //std::cout\n#include <numeric>  //std::iota\n#include <vector>   //std::vector, save solutions\n#include <list>     //std::list, for fast erase\n\nusing std::begin, std::end, std::for_each;\n\n//Generates all the valid solutions for the problem in the specified range [from, to)\nstd::list<std::vector<int>> combinations(int from, int to)\n{\n    if (from > to)\n        return {};                          //Return nothing if limits are invalid\n\n    auto pool = std::vector<int>(to - from);//Here we'll save our values\n    std::iota(begin(pool), end(pool), from);//Populates pool\n\n    auto solutions = std::list<std::vector<int>>{};   //List for the solutions\n\n    //Brute-force calculation of valid values...\n    for (auto a : pool)\n        for (auto b : pool)\n            for (auto c : pool)\n                for (auto d : pool)\n                    for (auto e : pool)\n                        for (auto f : pool)\n                            for (auto g : pool)\n                                if ( a      == c + d\n                                  && b + c  == e + f\n                                  && d + e  ==     g )\n                                    solutions.push_back({a, b, c, d, e, f, g});\n    return solutions;\n}\n\n//Filter the list generated from \"combinations\" and return only lists with no repetitions\nstd::list<std::vector<int>> filter_unique(int from, int to)\n{\n    //Helper lambda to check repetitions:\n    //If the count is > 1 for an element, there must be a repetition inside the range\n    auto has_non_unique_values = [](const auto & range, auto target)\n    {\n        return std::count( begin(range), end(range), target) > 1;\n    };\n\n    //Generates all the solutions...\n    auto results = combinations(from, to);\n\n    //For each solution, find duplicates inside\n    for (auto subrange = cbegin(results); subrange != cend(results); ++subrange)\n    {\n        bool repetition = false;\n\n        //If some element is repeated, repetition becomes true \n        for (auto x : *subrange)\n            repetition |= has_non_unique_values(*subrange, x);\n\n        if (repetition)    //If repetition is true, remove the current subrange from the list\n        {\n            results.erase(subrange);        //Deletes subrange from solutions\n            --subrange;                     //Rewind to the last subrange analysed\n        }\n    }\n\n    return results; //Finally return remaining results\n}\n\ntemplate <class Container> //Template for the sake of simplicity\ninline void print_range(const Container & c)\n{\n    for (const auto & subrange : c)\n    {\n        std::cout << \"[\";\n        for (auto elem : subrange)\n            std::cout << elem << ' ';\n        std::cout << \"\\b]\\n\";\n    }\n}\n\n\nint main()\n{\n    std::cout << \"Unique-numbers combinations in range 1-7:\\n\";\n    auto solution1 = filter_unique(1, 8);\n    print_range(solution1);\n    std::cout << \"\\nUnique-numbers combinations in range 3-9:\\n\";\n    auto solution2 = filter_unique(3,10);\n    print_range(solution2);\n    std::cout << \"\\nNumber of combinations in range 0-9: \" \n              << combinations(0, 10).size() << \".\" << std::endl;\n\n    return 0;\n}\n\n\nUnique-numbers combinations in range 1-7:\n[3 7 2 1 5 4 6]\n[4 5 3 1 6 2 7]\n[4 7 1 3 2 6 5]\n[5 6 2 3 1 7 4]\n[6 4 1 5 2 3 7]\n[6 4 5 1 2 7 3]\n[7 2 6 1 3 5 4]\n[7 3 2 5 1 4 6]\n\nUnique-numbers combinations in range 3-9:\n[7 8 3 4 5 6 9]\n[8 7 3 5 4 6 9]\n[9 6 4 5 3 7 8]\n[9 6 5 4 3 8 7]\n\nNumber of combinations in range 0-9: 2860.\n\n\n", "explain": "Output\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Java", "code": "\n\nimport java.util.Arrays;\n\npublic class FourSquares {\n    public static void main(String[] args) {\n        fourSquare(1, 7, true, true);\n        fourSquare(3, 9, true, true);\n        fourSquare(0, 9, false, false);\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0;\n\n        if (print) {\n            System.out.println(\"a b c d e f g\");\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue;\n\n                int fp = a + b;\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue;\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue;\n                        if (fp != b + c + d) continue;\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue;\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue;\n                                if (fp != d + e + f) continue;\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue;\n                                    if (fp != f + g) continue;\n\n                                    ++count;\n                                    if (print) {\n                                        System.out.printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g);\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            System.out.printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high);\n        } else {\n            System.out.printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high);\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch(p -> p == needle);\n    }\n}\n\n\nOutput:\na b c d e f g\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\nThere are 8 unique solutions in [1, 7]\na b c d e f g\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\nThere are 4 unique solutions in [3, 9]\nThere are 2860 non-unique solutions in [0, 9]\n", "explain": "Uses java 8 features.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "C#", "code": "\nTranslation of: Java\nusing System;\nusing System.Linq;\n\nnamespace Four_Squares_Puzzle {\n    class Program {\n        static void Main(string[] args) {\n            fourSquare(1, 7, true, true);\n            fourSquare(3, 9, true, true);\n            fourSquare(0, 9, false, false);\n        }\n\n        private static void fourSquare(int low, int high, bool unique, bool print) {\n            int count = 0;\n\n            if (print) {\n                Console.WriteLine(\"a b c d e f g\");\n            }\n            for (int a = low; a <= high; ++a) {\n                for (int b = low; b <= high; ++b) {\n                    if (notValid(unique, b, a)) continue;\n\n                    int fp = a + b;\n                    for (int c = low; c <= high; ++c) {\n                        if (notValid(unique, c, b, a)) continue;\n                        for (int d = low; d <= high; ++d) {\n                            if (notValid(unique, d, c, b, a)) continue;\n                            if (fp != b + c + d) continue;\n\n                            for (int e = low; e <= high; ++e) {\n                                if (notValid(unique, e, d, c, b, a)) continue;\n                                for (int f = low; f <= high; ++f) {\n                                    if (notValid(unique, f, e, d, c, b, a)) continue;\n                                    if (fp != d + e + f) continue;\n\n                                    for (int g = low; g <= high; ++g) {\n                                        if (notValid(unique, g, f, e, d, c, b, a)) continue;\n                                        if (fp != f + g) continue;\n\n                                        ++count;\n                                        if (print) {\n                                            Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\", a, b, c, d, e, f, g);\n                                        }\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n            if (unique) {\n                Console.WriteLine(\"There are {0} unique solutions in [{1}, {2}]\", count, low, high);\n            }\n            else {\n                Console.WriteLine(\"There are {0} non-unique solutions in [{1}, {2}]\", count, low, high);\n            }\n        }\n\n        private static bool notValid(bool unique, int needle, params int[] haystack) {\n            return unique && haystack.Any(p => p == needle);\n        }\n    }\n}\n\n\nOutput:\na b c d e f g\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\nThere are 8 unique solutions in [1, 7]\na b c d e f g\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\nThere are 4 unique solutions in [3, 9]\nThere are 2860 non-unique solutions in [0, 9]\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "JavaScript", "code": "\nES6[edit]\nTranslation of: Haskell (Structured search version)\n(() => {\n    \"use strict\";\n\n    // ----------- 4-RINGS OR 4-SQUARES PUZZLE -----------\n\n    // rings\u00a0:: noRepeatedDigits -> DigitList -> solutions\n    // rings\u00a0:: Bool -> [Int] -> [[Int]]\n    const rings = uniq =>\n        digits => Boolean(digits.length) ? (\n            () => {\n                const ns = digits.sort(flip(compare));\n\n                // CENTRAL DIGIT\u00a0:: d\n                return ns.flatMap(\n                    ringTriage(uniq)(ns)\n                );\n            })() : [];\n\n\n    const ringTriage = uniq => ns => d => {\n        const\n            h = head(ns),\n            ts = ns.filter(x => (x + d) <= h);\n\n        // LEFT OF CENTRE\u00a0:: c and a\n        return (\n            uniq ? (delete_(d)(ts)) : ns\n        )\n        .flatMap(c => {\n            const a = c + d;\n\n            // RIGHT OF CENTRE\u00a0:: e and g\n            return a > h ? (\n                []\n            ) : (\n                uniq ? (\n                    difference(ts)([d, c, a])\n                ) : ns\n            )\n            .flatMap(subTriage(uniq)([ns, h, a, c, d]));\n        });\n    };\n\n\n    const subTriage = uniq =>\n        ([ns, h, a, c, d]) => e => {\n            const g = d + e;\n\n            return ((g > h) || (\n                uniq && (g === c))\n            ) ? (\n                    []\n                ) : (() => {\n                    const\n                        agDelta = a - g,\n                        bfs = uniq ? (\n                            difference(ns)([\n                                d, c, e, g, a\n                            ])\n                        ) : ns;\n\n                    // MID LEFT, MID RIGHT\u00a0:: b and f\n                    return bfs.flatMap(b => {\n                        const f = b + agDelta;\n\n                        return (bfs).includes(f) && (\n                            !uniq || ![\n                                a, b, c, d, e, g\n                            ].includes(f)\n                        ) ? ([\n                                [a, b, c, d, e, f, g]\n                            ]) : [];\n                    });\n                })();\n        };\n\n    // ---------------------- TEST -----------------------\n    const main = () => unlines([\n        \"rings(true, enumFromTo(1,7))\\n\",\n        unlines(\n            rings(true)(\n                enumFromTo(1)(7)\n            ).map(show)\n        ),\n\n        \"\\nrings(true, enumFromTo(3, 9))\\n\",\n        unlines(\n            rings(true)(\n                enumFromTo(3)(9)\n            ).map(show)\n        ),\n\n        \"\\nlength(rings(false, enumFromTo(0, 9)))\\n\",\n        rings(false)(\n            enumFromTo(0)(9)\n        )\n        .length\n        .toString(),\n        \"\"\n    ]);\n\n\n    // ---------------- GENERIC FUNCTIONS ----------------\n\n    // compare\u00a0:: a -> a -> Ordering\n    const compare = (a, b) =>\n        a < b ? -1 : (a > b ? 1 : 0);\n\n\n    // delete\u00a0:: Eq a => a -> [a] -> [a]\n    const delete_ = x => {\n        // xs with first instance of x (if any) removed.\n        const go = xs =>\n            Boolean(xs.length) ? (\n                (x === xs[0]) ? (\n                    xs.slice(1)\n                ) : [xs[0]].concat(go(xs.slice(1)))\n            ) : [];\n\n        return go;\n    };\n\n\n    // difference\u00a0:: Eq a => [a] -> [a] -> [a]\n    const difference = xs =>\n        ys => {\n            const s = new Set(ys);\n\n            return xs.filter(x => !s.has(x));\n        };\n\n\n    // enumFromTo\u00a0:: Int -> Int -> [Int]\n    const enumFromTo = m =>\n        n => Array.from({\n            length: 1 + n - m\n        }, (_, i) => m + i);\n\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = op =>\n        // The binary function op with\n        // its arguments reversed.\n        1 !== op.length ? (\n            (a, b) => op(b, a)\n        ) : (a => b => op(b)(a));\n\n\n    // head\u00a0:: [a] -> a\n    const head = xs =>\n        // The first item (if any) in a list.\n        Boolean(xs.length) ? (\n            xs[0]\n        ) : null;\n\n\n    // show\u00a0:: a -> String\n    const show = x =>\n        JSON.stringify(x);\n\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join(\"\\n\");\n\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\nrings(true, enumFromTo(1,7))\n\n[7,3,2,5,1,4,6]\n[6,4,1,5,2,3,7]\n[5,6,2,3,1,7,4]\n[4,7,1,3,2,6,5]\n[7,2,6,1,3,5,4]\n[6,4,5,1,2,7,3]\n[4,5,3,1,6,2,7]\n[3,7,2,1,5,4,6]\n\nrings(true, enumFromTo(3, 9))\n\n[9,6,4,5,3,7,8]\n[8,7,3,5,4,6,9]\n[9,6,5,4,3,8,7]\n[7,8,3,4,5,6,9]\n\nlength(rings(false, enumFromTo(0, 9)))\n\n2860\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Visual_Basic_.NET", "code": "\n\nModule Module1\n\n    Dim CA As Char() = \"0123456789ABC\".ToCharArray()\n\n    Sub FourSquare(lo As Integer, hi As Integer, uni As Boolean, sy As Char())\n        If sy IsNot Nothing Then Console.WriteLine(\"a b c d e f g\" & vbLf & \"-------------\")\n        Dim r = Enumerable.Range(lo, hi - lo + 1).ToList(), u As New List(Of Integer),\n            t As Integer, cn As Integer = 0\n        For Each a In r\n            u.Add(a)\n            For Each b In r\n                If uni AndAlso u.Contains(b) Then Continue For\n                u.Add(b)\n                t = a + b\n                For Each c In r : If uni AndAlso u.Contains(c) Then Continue For\n                    u.Add(c)\n                    For d = a - c To a - c\n                        If d < lo OrElse d > hi OrElse uni AndAlso u.Contains(d) OrElse\n                            t <> b + c + d Then Continue For\n                        u.Add(d)\n                        For Each e In r\n                            If uni AndAlso u.Contains(e) Then Continue For\n                            u.Add(e)\n                            For f = b + c - e To b + c - e\n                                If f < lo OrElse f > hi OrElse uni AndAlso u.Contains(f) OrElse\n                                    t <> d + e + f Then Continue For\n                                u.Add(f)\n                                For g = t - f To t - f : If g < lo OrElse g > hi OrElse\n                                    uni AndAlso u.Contains(g) Then Continue For\n                                    cn += 1 : If sy IsNot Nothing Then _\n                                        Console.WriteLine(\"{0} {1} {2} {3} {4} {5} {6}\",\n                                            sy(a), sy(b), sy(c), sy(d), sy(e), sy(f), sy(g))\n                                Next : u.Remove(f) : Next : u.Remove(e) : Next : u.Remove(d)\n                    Next : u.Remove(c) : Next : u.Remove(b) : Next : u.Remove(a)\n        Next : Console.WriteLine(\"{0} {1}unique solutions for [{2},{3}]{4}\",\n                                 cn, If(uni, \"\", \"non-\"), lo, hi, vbLf)\n    End Sub\n\n    Sub main()\n        fourSquare(1, 7, True, CA)\n        fourSquare(3, 9, True, CA)\n        fourSquare(0, 9, False, Nothing)\n        fourSquare(5, 12, True, CA)\n    End Sub\n\nEnd Module\n\n\nOutput:\nAdded the zkl example for [5,12]a b c d e f g\n-------------\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\n8 unique solutions for [1,7]\n\na b c d e f g\n-------------\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\n4 unique solutions for [3,9]\n\n2860 non-unique solutions for [0,9]\n\na b c d e f g\n-------------\nB 9 6 5 7 8 C\nB A 6 5 7 9 C\nC 8 7 5 6 9 B\nC 9 7 5 6 A B\n4 unique solutions for [5,12]\n", "explain": "Similar to the other brute-force algorithims, but with a couple of enhancements.  A \"used\" list is maintained to simplify checking of the nested variables overlap.  Also the d, f and g For Each loops are constrained by the other variables instead of blindly going through all combinations.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Fortran", "code": "\n\nAlso standardised in F90 is the $ format code, which specifies that the output line is not to end with the WRITE statement. The problem here is that Fortran does not offer an IF ...FI bracketing construction inside an expression, that would allow something like WRITE(...) FIRST,LAST,IF (UNIQUE) THEN \"Distinct values only\" ELSE \"Repeated values allowed\" FI // \".\"\n so that the correct alternative will be selected. Further, an array (that would hold those two texts) can't be indexed by a LOGICAL variable, and playing with EQUIVALENCE won't help, because the numerical values revealed thereby for .TRUE. and .FALSE. may not be 1 and 0. And anyway, parameters are not allowed to be accessed via EQUIVALENCE to another variable.\nSo, a two-part output, and to reduce the blather, two IF-statements.       SUBROUTINE FOURSHOW(FIRST,LAST,UNIQUE)\t!The \"Four Rings\" or \"Four Squares\" puzzle.\nChoose values such that A+B = B+C+D = D+E+F = F+G, all being integers in FIRST:LAST...\n       INTEGER FIRST,LAST\t!The range of allowed values.\n       LOGICAL UNIQUE\t\t!Solutions need not have unique values.\n       INTEGER A,B,C,D,E,F,G\t!Ah, Diophantus of Alexandria.\n       INTEGER V(7),S,N\t\t!Assistants.\n       EQUIVALENCE (V(1),A),(V(2),B),(V(3),C),\t\t!Yes,\n     1             (V(4),D),(V(5),E),(V(6),F),(V(7),G)\t!We're all individuals.\n        WRITE (6,1) FIRST,LAST\t!Announce: first part.\n    1   FORMAT (/,\"The Four Rings puzzle, over \",I0,\" to \",I0,\".\",$)\t!$: An addendum follows.\n        IF (UNIQUE) WRITE (6,*) \"Distinct values only.\"\t!Save on the THEN ... ELSE ... END IF blather.\n        IF (.NOT.UNIQUE) WRITE (6,*) \"Repeated values allowed.\"\t!Perhaps the compiler will be smarter.\n\n        N = 0\t!No solutions have been found.\n      BB:DO B = FIRST,LAST\t!Start chugging through the possibilities.\n        CC:DO C = FIRST,LAST\t\t!Brute force and ignorance.\n             IF (UNIQUE .AND. B.EQ.C) CYCLE CC\t!The first constraint shows up.\n          DD:DO D = FIRST,LAST\t\t!Start by forming B, C, and D.\n               IF (UNIQUE .AND. ANY(V(2:3).EQ.D)) CYCLE DD\t!Ignoring A just for now.\n               S = B + C + D\t\t!This is the common sum.\n               A = S - B\t\t!The value of A is not free from BCD.\n               IF (A < FIRST .OR. A > LAST) CYCLE DD\t!And it may not be within bounds.\n               IF (UNIQUE .AND. ANY(V(2:4).EQ.A)) CYCLE DD\t!Or, if required so, unique.\n            EE:DO E = FIRST,LAST\t!Righto, A,B,C,D are valid. Try an E.\n                 IF (UNIQUE .AND. ANY(V(1:4).EQ.E)) CYCLE EE\t!Precluded already?\n                 F = S - (E + D)\t\t!No. So therefore, F is determined.\n                 IF (F < FIRST .OR. F > LAST) CYCLE EE\t!Acceptable?\n                 IF (UNIQUE .AND. ANY(V(1:5).EQ.F)) CYCLE EE\t!And, if required, unique?\n                 G = S - F\t\t\t!Yes! So finally, G is determined.\n                 IF (G < FIRST .OR. G > LAST) CYCLE EE\t!Acceptable?\n                 IF (UNIQUE .AND. ANY(V(1:6).EQ.G)) CYCLE EE\t!And, if required, unique?\n                 N = N + 1\t\t\t!Yes! Count a solution set!\n                 IF (UNIQUE) WRITE (6,\"(7I3)\") V\t!Show its values.\n               END DO EE\t\t\t!Consder another E.\n             END DO DD\t\t\t!Consider another D.\n           END DO CC\t\t!Consider another C.\n         END DO BB\t!Consider another B.\n        WRITE (6,2) N\t!Announce the count.\n    2   FORMAT (I9,\" found.\")\t!Numerous, if no need for distinct values.\n      END SUBROUTINE FOURSHOW\t!That was fun!\n\n      PROGRAM POKE\n\n      CALL FOURSHOW(1,7,.TRUE.)\n      CALL FOURSHOW(3,9,.TRUE.)\n      CALL FOURSHOW(0,9,.FALSE.)\n\n      END\n\n\nThe Four Rings puzzle, over 1 to 7. Distinct values only.\n  7  2  6  1  3  5  4\n  7  3  2  5  1  4  6\n  6  4  1  5  2  3  7\n  6  4  5  1  2  7  3\n  4  5  3  1  6  2  7\n  5  6  2  3  1  7  4\n  4  7  1  3  2  6  5\n  3  7  2  1  5  4  6\n        8 found.\n\nThe Four Rings puzzle, over 3 to 9. Distinct values only.\n  9  6  4  5  3  7  8\n  9  6  5  4  3  8  7\n  8  7  3  5  4  6  9\n  7  8  3  4  5  6  9\n        4 found.\n\nThe Four Rings puzzle, over 0 to 9. Repeated values allowed.\n     2860 found.\n\n\n31:                    IF (UNIQUE .AND. ANY(V(1:6).EQ.G)) CYCLE EE    !And, if required, unique?\n00401496   mov         edi,dword ptr [UNIQUE]\n00401499   mov         edi,dword ptr [edi]\n0040149B   mov         ebx,dword ptr [G (00470380)]\n004014A1   mov         eax,0\n004014A6   mov         ecx,1\n004014AB   mov         dword ptr [ebp-60h],1\n004014B2   cmp         dword ptr [ebp-60h],6\n004014B6   jg          FOURSHOW+4C4h (004014fc)\n004014B8   cmp         ecx,1\n004014BB   jl          FOURSHOW+48Ah (004014c2)\n004014BD   cmp         ecx,7\n004014C0   jle         FOURSHOW+493h (004014cb)\n004014C2   xor         esi,esi\n004014C4   mov         dword ptr [ebp-6Ch],esi\n004014C7   dec         esi\n004014C8   bound       esi,qword ptr [ebp-6Ch]\n004014CB   imul        esi,ecx,4\n004014CE   mov         esi,dword ptr S+4 (00470364)[esi]\n004014D4   xor         edx,edx\n004014D6   cmp         esi,ebx\n004014D8   sete        dl\n004014DB   mov         dword ptr [ebp-6Ch],edx\n004014DE   mov         edx,eax\n004014E0   or          edx,dword ptr [ebp-6Ch]\n004014E3   and         edx,1\n004014E6   mov         eax,edx\n004014E8   neg         eax\n004014EA   mov         esi,ecx\n004014EC   add         esi,1\n004014EF   mov         ecx,esi\n004014F1   mov         edx,dword ptr [ebp-60h]\n004014F4   add         edx,1\n004014F7   mov         dword ptr [ebp-60h],edx\n004014FA   jmp         FOURSHOW+47Ah (004014b2)\n004014FC   and         edi,eax\n004014FE   mov         edx,edi\n00401500   and         edx,1\n00401503   cmp         edx,0\n00401506   jne         FOURSHOW+531h (00401569)\n32:                    N = N + 1          !Yes! Count a solution set!\n00401508   mov         esi,dword ptr [N (0047035c)]\n0040150E   add         esi,1\n00401511   mov         dword ptr [N (0047035c)],esi\n33:                    IF (UNIQUE) WRITE (6,\"(7I3)\") V    !Show its values.\n\n\n", "explain": "This uses the facility standardised in F90 whereby DO-loops can have text labels attached (not in the usual label area) so that the END DO statement can have the corresponding label, and any CYCLE statements can use it also. Similarly, the subroutine's END statement bears the name of the subroutine. This is just syntactic decoration. Rather more useful is extended syntax for dealing with arrays and especially the function ANY for making multiple tests without having to enumerate them in the code. To gain this convenience, the EQUIVALENCE statement makes variables A, B, C, D, E, F, and G occupy the same storage as INTEGER V(7), an array. \nOne could abandon the use of the named variables in favour of manipulating the array equivalent, and indeed develop code which performs the nested loops via messing with the array, but for simplicity, the individual variables are used. However, tempting though it is to write a systematic sequence of seven nested DO-loops, the variables are not in fact all independent: some are fixed once others are chosen. Just cycling through all the notional possibilities when one only is in fact possible is a bit too much brute-force-and-ignorance, though other problems with other constraints, may encourage such exhaustive stepping. As a result, the code is more tightly bound to the specific features of the problem. \nOutput: not in a neat order because the first variable is not determined first.\nOne might hope that the ANY function will quit as soon as possible and that it will not be invoked if UNIQUE is false, but the modernisers have rejected reliance on short-circuit evaluation and the \"help\" is quite general on the workings of the ANY function, as also is modern. Here is a sample of the code produced by the Compaq 6.6a Visual Fortran F90/95 compiler, in its normal \"debugging\" condition and array bound checking of course active...\nI'd rather say nothing at all.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Go", "code": "\npackage main\n\nimport \"fmt\"\n\nfunc main(){\n\tn, c := getCombs(1,7,true)\n\tfmt.Printf(\"%d unique solutions in 1 to 7\\n\",n)\n\tfmt.Println(c)\n\tn, c = getCombs(3,9,true)\n\tfmt.Printf(\"%d unique solutions in 3 to 9\\n\",n)\n\tfmt.Println(c)\n\tn, _ = getCombs(0,9,false)\n\tfmt.Printf(\"%d non-unique solutions in 0 to 9\\n\",n)\n}\n\nfunc getCombs(low,high int,unique bool) (num int,validCombs [][]int){\n\tfor a := low; a <= high; a++ {\n\t\tfor b := low; b <= high; b++ {\n\t\t\tfor c := low; c <= high; c++ {\n\t\t\t\tfor d := low; d <= high; d++ {\n\t\t\t\t\tfor e := low; e <= high; e++ {\n\t\t\t\t\t\tfor f := low; f <= high; f++ {\n\t\t\t\t\t\t\tfor g := low; g <= high; g++ {\n\t\t\t\t\t\t\t\tif validComb(a,b,c,d,e,f,g) {\n\t\t\t\t\t\t\t\t\tif !unique || isUnique(a,b,c,d,e,f,g) {\n\t\t\t\t\t\t\t\t\t\tnum++\n\t\t\t\t\t\t\t\t\t\tvalidCombs = append(validCombs,[]int{a,b,c,d,e,f,g})\n\t\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t\t}\n\t\t\t\t\t\t\t}\n\t\t\t\t\t\t}\n\t\t\t\t\t}\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn\n}\nfunc isUnique(a,b,c,d,e,f,g int) (res bool) {\n\tdata := make(map[int]int)\n\tdata[a]++\n\tdata[b]++\n\tdata[c]++\n\tdata[d]++\n\tdata[e]++\n\tdata[f]++\n\tdata[g]++\n\treturn len(data) == 7\n}\nfunc validComb(a,b,c,d,e,f,g int) bool{\n\tsquare1 := a + b\n\tsquare2 := b + c + d\n\tsquare3 := d + e + f\n\tsquare4 := f + g\n\treturn square1 == square2 && square2 == square3 && square3 == square4\n}\n\n\nOutput:\n8 unique solutions in 1 to 7\n[[3 7 2 1 5 4 6] [4 5 3 1 6 2 7] [4 7 1 3 2 6 5] [5 6 2 3 1 7 4] [6 4 1 5 2 3 7] [6 4 5 1 2 7 3] [7 2 6 1 3 5 4] [7 3 2 5 1 4 6]]\n4 unique solutions in 3 to 9\n[[7 8 3 4 5 6 9] [8 7 3 5 4 6 9] [9 6 4 5 3 7 8] [9 6 5 4 3 8 7]]\n2860 non-unique solutions in 0 to 9\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program square4.s   */\n \n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n\n.equ NBBOX,  7\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nsMessDeb:           .ascii \"a=\"\nsMessValeur_a:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"b=\"\nsMessValeur_b:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"c=\"\nsMessValeur_c:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"d=\"\nsMessValeur_d:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"\\n\"\n                    .ascii \"e=\"\nsMessValeur_e:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"f=\"\nsMessValeur_f:     .fill 11, 1, ' '            @ size => 11\n                    .ascii \"g=\"\nsMessValeur_g:     .fill 11, 1, ' '            @ size => 11\n\nszCarriageReturn:   .asciz \"\\n************************\\n\"\n\nsMessNbSolution:   .ascii \"Number of solutions\u00a0:\"\nsMessCounter:     .fill 11, 1, ' '            @ size => 11\n                   .asciz \"\\n\\n\\n\"\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n.align 4\niValues_a:                .skip 4 * NBBOX\niValues_b:                .skip 4 * NBBOX - 1\niValues_c:                .skip 4 * NBBOX - 2\niValues_d:                .skip 4 * NBBOX - 3\niValues_e:                .skip 4 * NBBOX - 4\niValues_f:                .skip 4 * NBBOX - 5\niValues_g:                .skip 4 * NBBOX - 6\niCounterSol:              .skip 4\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                             @ entry of program \n    mov r0,#1\n    mov r1,#7\n    mov r2,#3                                     @ 0 = rien 1 = display 2 = count 3 = les deux\n    bl searchPb\n    mov r0,#3\n    mov r1,#9\n    mov r2,#3                                     @ 0 = rien 1 = display 2 = count 3 = les deux\n    bl searchPb\n    mov r0,#0\n    mov r1,#9\n    mov r2,#2                                     @ 0 = rien 1 = display 2 = count 3 = les deux\n    bl prepSearchNU\n\n100:                                              @ standard end of the program \n    mov r0, #0                                    @ return code\n    mov r7, #EXIT                                 @ request to exit program\n    svc #0                                        @ perform the system call\n \niAdrszCarriageReturn:            .int szCarriageReturn\n\n/******************************************************************/\n/*     search probl\u00e8m  value not unique                           */ \n/******************************************************************/\n/* r0 contains start digit */\n/* r1 contains end digit */\n/* r2 contains action (0 display 1 count) */\nprepSearchNU:\n    push {r3-r12,lr}                              @ save  registers\n    mov r5,#0                                     @ counter\n    mov r12,r0                                    @ a\n1:\n    mov r11,r0                                    @ b\n2:\n    mov r10,r0                                    @ c\n3:\n    mov r9,r0                                     @ d\n4:\n    add r4,r12,r11                                @ a + b reference\n    add r3,r11,r10\n    add r3,r9                                     @ b + c + d\n    cmp r4,r3\n    bne 10f\n    mov r8,r0                                     @ e\n5:\n    mov r7,r0                                     @ f\n6:\n    add r3,r9,r8\n    add r3,r7                                     @ d + e + f\n    cmp r3,r4\n    bne 9f\n    mov r6,r0                                     @ g\n7:\n    add r3,r7,r6                                  @ f + g\n    cmp r3,r4\n    bne 8f                                        @ not OK\n                                                  @ OK\n    add r5,#1                                     @ increment counter\n\n8:\n    add r6,#1                                     @ increment g\n    cmp r6,r1\n    ble 7b\n9:\n    add r7,#1                                     @ increment f\n    cmp r7,r1\n    ble 6b\n    add r8,#1                                     @ increment e\n    cmp r8,r1\n    ble 5b\n10:\n    add r9,#1                                     @ increment d\n    cmp r9,r1\n    ble 4b\n    add r10,#1                                    @ increment c\n    cmp r10,r1\n    ble 3b\n    add r11,#1                                    @ increment b\n    cmp r11,r1\n    ble 2b\n    add r12,#1                                    @ increment a\n    cmp r12,r1\n    ble 1b\n\n    @ end\n    tst r2,#0b10                                    @ print count\u00a0?\n    beq 100f\n    mov r0,r5                                       @ counter\n    ldr r1,iAdrsMessCounter\n    bl conversion10\n    ldr r0,iAdrsMessNbSolution\n    bl affichageMess\n\n100:\n    pop {r3-r12,lr}                                 @ restaur registers \n    bx lr                                           @return\niAdrsMessCounter:                .int sMessCounter\niAdrsMessNbSolution:             .int sMessNbSolution\n\n/******************************************************************/\n/*     search problem  unique solution                            */ \n/******************************************************************/\n/* r0 contains start digit */\n/* r1 contains end digit */\n/* r2 contains action (0 display 1 count) */\nsearchPb:\n    push {r0-r12,lr}                                  @ save  registers\n    @ init\n    ldr r3,iAdriValues_a                              @ area value a\n    mov r4,#0\n1:                                                    @ loop init value a\n    str r0,[r3,r4,lsl #2]\n    add r4,#1\n    add r0,#1\n    cmp r0,r1\n    ble 1b\n\n    mov r5,#0                                         @ solution counter\n    mov r12,#-1\n2:\n    add r12,#1                                        @ increment indice a\n    cmp r12,#NBBOX-1\n    bgt 90f\n    ldr r0,iAdriValues_a                              @ area value a\n    ldr r1,iAdriValues_b                              @ area value b\n    mov r2,r12                                        @ indice  a\n    mov r3,#NBBOX                                     @ number of origin values \n    bl prepValues\n    mov r11,#-1\n3:\n    add r11,#1                                        @ increment indice b\n    cmp r11,#NBBOX - 2\n    bgt 2b\n    ldr r0,iAdriValues_b                              @ area value b\n    ldr r1,iAdriValues_c                              @ area value c\n    mov r2,r11                                        @ indice b\n    mov r3,#NBBOX -1                                  @ number of origin values\n    bl prepValues\n    mov r10,#-1\n4:\n    add r10,#1\n    cmp r10,#NBBOX - 3\n    bgt 3b\n    ldr r0,iAdriValues_c\n    ldr r1,iAdriValues_d\n    mov r2,r10\n    mov r3,#NBBOX - 2\n    bl prepValues\n    mov r9,#-1\n5:\n    add r9,#1\n    cmp r9,#NBBOX - 4\n    bgt 4b\n    @ control 2 firsts squares\n    ldr r0,iAdriValues_a\n    ldr r0,[r0,r12,lsl #2]\n    ldr r1,iAdriValues_b\n    ldr r1,[r1,r11,lsl #2]\n    add r4,r0,r1                               @ a + b   value first square\n    ldr r0,iAdriValues_c\n    ldr r0,[r0,r10,lsl #2]\n    add r7,r1,r0                               @ b + c\n    ldr r1,iAdriValues_d\n    ldr r1,[r1,r9,lsl #2]\n    add r7,r1                                  @ b + c + d\n    cmp r7,r4                                  @ equal first square\u00a0?\n    bne 5b\n    ldr r0,iAdriValues_d\n    ldr r1,iAdriValues_e\n    mov r2,r9\n    mov r3,#NBBOX - 3\n    bl prepValues\n    mov r8,#-1\n6:\n    add r8,#1\n    cmp r8,#NBBOX - 5\n    bgt 5b\n    ldr r0,iAdriValues_e\n    ldr r1,iAdriValues_f\n    mov r2,r8\n    mov r3,#NBBOX - 4\n    bl prepValues\n    mov r7,#-1\n7:\n    add r7,#1\n    cmp r7,#NBBOX - 6\n    bgt 6b\n    ldr r0,iAdriValues_d\n    ldr r0,[r0,r9,lsl #2]\n    ldr r1,iAdriValues_e\n    ldr r1,[r1,r8,lsl #2]\n    add r3,r0,r1                                @ d + e\n    ldr r1,iAdriValues_f\n    ldr r1,[r1,r7,lsl #2]\n    add r3,r1                                   @ de + e + f\n    cmp r3,r4                                   @ equal first square\u00a0?\n    bne 7b\n    ldr r0,iAdriValues_f\n    ldr r1,iAdriValues_g\n    mov r2,r7\n    mov r3,#NBBOX - 5\n    bl prepValues\n    mov r6,#-1\n8:\n    add r6,#1\n    cmp r6,#NBBOX - 7\n    bgt 7b\n    ldr r0,iAdriValues_f\n    ldr r0,[r0,r7,lsl #2]\n    ldr r1,iAdriValues_g\n    ldr r1,[r1,r6,lsl #2]\n    add r3,r0,r1                               @ f +g \n    cmp r4,r3                                  @ equal first square\u00a0?\n    bne 8b\n    add r5,#1                                  @ increment counter\n    ldr r0,[sp,#8]                             @ load action for two parameter in stack\n    tst r0,#0b1\n    beq 9f                                     @ display solution\u00a0?\n    ldr r0,iAdriValues_a\n    ldr r0,[r0,r12,lsl #2]\n    ldr r1,iAdrsMessValeur_a\n    bl conversion10\n    ldr r0,iAdriValues_b\n    ldr r0,[r0,r11,lsl #2]\n    ldr r1,iAdrsMessValeur_b\n    bl conversion10\n    ldr r0,iAdriValues_c\n    ldr r0,[r0,r10,lsl #2]\n    ldr r1,iAdrsMessValeur_c\n    bl conversion10\n    ldr r0,iAdriValues_d\n    ldr r0,[r0,r9,lsl #2]\n    ldr r1,iAdrsMessValeur_d\n    bl conversion10\n    ldr r0,iAdriValues_e\n    ldr r0,[r0,r8,lsl #2]\n    ldr r1,iAdrsMessValeur_e\n    bl conversion10\n    ldr r0,iAdriValues_f\n    ldr r0,[r0,r7,lsl #2]\n    ldr r1,iAdrsMessValeur_f\n    bl conversion10\n    ldr r0,iAdriValues_g\n    ldr r0,[r0,r6,lsl #2]\n    ldr r1,iAdrsMessValeur_g\n    bl conversion10\n    ldr r0,iAdrsMessDeb\n    bl affichageMess\n9:\n    b 8b    @ suite \n\n90:\n    ldr r0,[sp,#8]                                @ load action for two parameter in stack\n    tst r0,#0b10\n    beq 100f                                      @ display counter\u00a0?\n    mov r0,r5\n    ldr r1,iAdrsMessCounter\n    bl conversion10\n    ldr r0,iAdrsMessNbSolution\n    bl affichageMess\n100:\n    pop {r0-r12,lr}                               @ restaur registers \n    bx lr                                         @return\niAdriValues_a:                   .int iValues_a\niAdriValues_b:                   .int iValues_b\niAdriValues_c:                   .int iValues_c\niAdriValues_d:                   .int iValues_d\niAdriValues_e:                   .int iValues_e\niAdriValues_f:                   .int iValues_f\niAdriValues_g:                   .int iValues_g\n\niAdrsMessValeur_a:               .int sMessValeur_a\niAdrsMessValeur_b:               .int sMessValeur_b\niAdrsMessValeur_c:               .int sMessValeur_c\niAdrsMessValeur_d:               .int sMessValeur_d\niAdrsMessValeur_e:               .int sMessValeur_e\niAdrsMessValeur_f:               .int sMessValeur_f\niAdrsMessValeur_g:               .int sMessValeur_g\niAdrsMessDeb:                    .int sMessDeb\niAdriCounterSol:                 .int iCounterSol\n/******************************************************************/\n/*     copy value area  and substract value of indice             */ \n/******************************************************************/\n/* r0 contains the address of values origin */\n/* r1 contains the address of values destination */\n/* r2 contains value indice to substract     */\n/* r3 contains origin values number          */\nprepValues:\n    push {r1-r6,lr}                                @ save  registres\n    mov r4,#0                                      @ indice origin value\n    mov r5,#0                                      @ indice destination value\n1:\n    cmp r4,r2                                      @ substract indice\u00a0?\n    beq 2f                                         @ yes -> jump\n    ldr r6,[r0,r4,lsl #2]                          @ no -> copy value\n    str r6,[r1,r5,lsl #2]\n    add r5,#1                                      @ increment destination indice\n2:\n   add r4,#1                                       @ increment origin indice\n   cmp r4,r3                                       @ end\u00a0?\n   blt 1b\n100:\n    pop {r1-r6,lr}                                 @ restaur registres \n    bx lr                                          @return\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n1:                                                  @ start loop\n    bl divisionpar10U                               @ unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b                                          @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n \n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient    */\n/* r1 remainder   */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n\nOutput:\na=3          b=7          c=2          d=1\ne=5          f=4          g=6\n************************\na=4          b=5          c=3          d=1\ne=6          f=2          g=7\n************************\na=4          b=7          c=1          d=3\ne=2          f=6          g=5\n************************\na=5          b=6          c=2          d=3\ne=1          f=7          g=4\n************************\na=6          b=4          c=1          d=5\ne=2          f=3          g=7\n************************\na=6          b=4          c=5          d=1\ne=2          f=7          g=3\n************************\na=7          b=2          c=6          d=1\ne=3          f=5          g=4\n************************\na=7          b=3          c=2          d=5\ne=1          f=4          g=6\n************************\nNumber of solutions :8\n\na=7          b=8          c=3          d=4\ne=5          f=6          g=9\n************************\na=8          b=7          c=3          d=5\ne=4          f=6          g=9\n************************\na=9          b=6          c=4          d=5\ne=3          f=7          g=8\n************************\na=9          b=6          c=5          d=4\ne=3          f=8          g=7\n************************\nNumber of solutions :4\n\nNumber of solutions :2860\n\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "X86_Assembly", "code": "\n\n", "explain": "See 4-rings_or_4-squares_puzzle/X86 Assembly\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Delphi", "code": "\n\n", "explain": "See #Pascal\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Ruby", "code": "\ndef four_squares(low, high, unique=true, show=unique)\n  f = -> (a,b,c,d,e,f,g) {[a+b, b+c+d, d+e+f, f+g].uniq.size == 1}\n  if unique\n    uniq = \"unique\"\n    solutions = [*low..high].permutation(7).select{|ary| f.call(*ary)}\n  else\n    uniq = \"non-unique\"\n    solutions = [*low..high].repeated_permutation(7).select{|ary| f.call(*ary)}\n  end\n  if show\n    puts \" \" + [*\"a\"..\"g\"].join(\"  \")\n    solutions.each{|ary| p ary}\n  end\n  puts \"#{solutions.size} #{uniq} solutions in #{low} to #{high}\"\n  puts\nend\n\n[[1,7], [3,9]].each do |low, high|\n  four_squares(low, high)\nend\nfour_squares(0, 9, false)\n\n\nOutput:\n a  b  c  d  e  f  g\n[3, 7, 2, 1, 5, 4, 6]\n[4, 5, 3, 1, 6, 2, 7]\n[4, 7, 1, 3, 2, 6, 5]\n[5, 6, 2, 3, 1, 7, 4]\n[6, 4, 1, 5, 2, 3, 7]\n[6, 4, 5, 1, 2, 7, 3]\n[7, 2, 6, 1, 3, 5, 4]\n[7, 3, 2, 5, 1, 4, 6]\n8 unique solutions in 1 to 7\n\n a  b  c  d  e  f  g\n[7, 8, 3, 4, 5, 6, 9]\n[8, 7, 3, 5, 4, 6, 9]\n[9, 6, 4, 5, 3, 7, 8]\n[9, 6, 5, 4, 3, 8, 7]\n4 unique solutions in 3 to 9\n\n2860 non-unique solutions in 0 to 9\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Rust", "code": "\n#![feature(inclusive_range_syntax)]\n\nfn is_unique(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a != b && a != c && a != d && a != e && a != f && a != g &&\n    b != c && b != d && b != e && b != f && b != g &&\n    c != d && c != e && c != f && c != g &&\n    d != e && d != f && d != g &&\n    e != f && e != g &&\n    f != g\n}\n\nfn is_solution(a: u8, b: u8, c: u8, d: u8, e: u8, f: u8, g: u8) -> bool {\n    a + b == b + c + d &&\n        b + c + d == d + e + f &&\n        d + e + f == f + g\n}\n\nfn four_squares(low: u8, high: u8, unique: bool) -> Vec<Vec<u8>> {\n    let mut results: Vec<Vec<u8>> = Vec::new();\n\n    for a in low..=high {\n        for b in low..=high {\n            for c in low..=high {\n                for d in low..=high {\n                    for e in low..=high {\n                        for f in low..=high {\n                            for g in low..=high {\n                                if (!unique || is_unique(a, b, c, d, e, f, g)) &&\n                                    is_solution(a, b, c, d, e, f, g) {\n                                    results.push(vec![a, b, c, d, e, f, g]);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    results\n}\n\nfn print_results(solutions: &Vec<Vec<u8>>) {\n    for solution in solutions {\n        println!(\"{:?}\", solution)\n    }\n}\n\nfn print_results_summary(solutions: usize, low: u8, high: u8, unique: bool) {\n    let uniqueness = if unique {\n        \"unique\"\n    } else {\n        \"non-unique\"\n    };\n    println!(\"{} {} solutions in {} to {} range\", solutions, uniqueness, low, high)\n}\n\nfn uniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, true);\n    print_results(&solutions);\n    print_results_summary(solutions.len(), low, high, true);\n}\n\nfn nonuniques(low: u8, high: u8) {\n    let solutions = four_squares(low, high, false);\n    print_results_summary(solutions.len(), low, high, false);\n}\n\nfn main() {\n    uniques(1, 7);\n    println!();\n    uniques(3, 9);\n    println!();\n    nonuniques(0, 9);\n}\n\n\nOutput:\n[3, 7, 2, 1, 5, 4, 6]\n[4, 5, 3, 1, 6, 2, 7]\n[4, 7, 1, 3, 2, 6, 5]\n[5, 6, 2, 3, 1, 7, 4]\n[6, 4, 1, 5, 2, 3, 7]\n[6, 4, 5, 1, 2, 7, 3]\n[7, 2, 6, 1, 3, 5, 4]\n[7, 3, 2, 5, 1, 4, 6]\n8 unique solutions in 1 to 7 range\n\n[7, 8, 3, 4, 5, 6, 9]\n[8, 7, 3, 5, 4, 6, 9]\n[9, 6, 4, 5, 3, 7, 8]\n[9, 6, 5, 4, 3, 8, 7]\n4 unique solutions in 3 to 9 range\n\n2860 non-unique solutions in 0 to 9 range\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "R", "code": "\n\n# 4 rings or 4 squares puzzle\n\nperms <- function (n, r, v = 1:n, repeats.allowed = FALSE) {\n  if (repeats.allowed) \n    sub <- function(n, r, v) {\n      if (r == 1) \n        matrix(v, n, 1)\n      else if (n == 1) \n        matrix(v, 1, r)\n      else {\n        inner <- Recall(n, r - 1, v)\n        cbind(rep(v, rep(nrow(inner), n)), matrix(t(inner), \n                                                  ncol = ncol(inner), nrow = nrow(inner) * n, \n                                                  byrow = TRUE))\n      }\n    }\n  else sub <- function(n, r, v) {\n    if (r == 1) \n      matrix(v, n, 1)\n    else if (n == 1) \n      matrix(v, 1, r)\n    else {\n      X <- NULL\n      for (i in 1:n) X <- rbind(X, cbind(v[i], Recall(n - 1, r - 1, v[-i])))\n      X\n    }\n  }\n  X <- sub(n, r, v[1:n])\n  \n  result <- vector(mode = \"numeric\")\n\n  for(i in 1:nrow(X)){\n    y <- X[i, ]\n    x1 <- y[1] + y[2]\n    x2 <- y[2] + y[3] + y[4]\n    x3 <- y[4] + y[5] + y[6]\n    x4 <- y[6] + y[7]\n    if(x1 == x2 & x2 == x3 & x3 == x4) result <- rbind(result, y)\n  }\n  return(result)\n}\n\nprint_perms <- function(n, r, v = 1:n, repeats.allowed = FALSE, table.out = FALSE) {\n  a <- perms(n, r, v, repeats.allowed)\n  colnames(a) <- rep(\"\", ncol(a))\n  rownames(a) <- rep(\"\", nrow(a)) \n  if(!repeats.allowed){\n    print(a)\n    cat(paste('\\n', nrow(a), 'unique solutions from', min(v), 'to', max(v)))\n  } else {\n    cat(paste('\\n', nrow(a), 'non-unique solutions from', min(v), 'to', max(v)))\n  }\n}\n\nregisterS3method(\"print_perms\", \"data.frame\", print_perms)\n\nprint_perms(7, 7, repeats.allowed = FALSE, table.out = TRUE)\nprint_perms(7, 7, v = 3:9, repeats.allowed = FALSE, table.out = TRUE)\nprint_perms(10, 7, v = 0:9, repeats.allowed = TRUE, table.out = FALSE)\n\n\nOutput:\n              \n 3 7 2 1 5 4 6\n 4 5 3 1 6 2 7\n 4 7 1 3 2 6 5\n 5 6 2 3 1 7 4\n 6 4 1 5 2 3 7\n 6 4 5 1 2 7 3\n 7 2 6 1 3 5 4\n 7 3 2 5 1 4 6\n\n 8 unique solutions from 1 to 7\n             \n 7 8 3 4 5 6 9\n 8 7 3 5 4 6 9\n 9 6 4 5 3 7 8\n 9 6 5 4 3 8 7\n\n 4 unique solutions from 3 to 9\n\n 2860 non-unique solutions from 0 to 9\n\n", "explain": "Function \"perms\" is a modified version of the \"permutations\" function from the \"gtools\" R package.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Puzzle_Square_4 is\n\n   procedure Four_Rings (Low, High : in Natural; Unique, Show : in Boolean) is\n      subtype Test_Range is Natural range Low .. High;\n\n      type Value_List is array (Positive range <>) of Natural;\n      function Is_Unique (Values : Value_List) return Boolean is\n         Count : array (Test_Range) of Natural := (others => 0);\n      begin\n         for Value of Values loop\n            Count (Value) := Count (Value) + 1;\n            if Count (Value) > 1 then\n               return False;\n            end if;\n         end loop;\n         return True;\n      end Is_Unique;\n\n      function Is_Valid (A,B,C,D,E,F,G : in Natural) return Boolean is\n         Ring_1 : constant Integer := A + B;\n         Ring_2 : constant Integer := B + C + D;\n         Ring_3 : constant Integer := D + E + F;\n         Ring_4 : constant Integer := F + G;\n      begin\n         return\n           Ring_1 = Ring_2 and\n           Ring_1 = Ring_3 and\n           Ring_1 = Ring_4;\n      end Is_Valid;\n\n      use Ada.Text_IO;\n      Count : Natural := 0;\n   begin\n      for A in Test_Range loop\n         for B in Test_Range loop\n            for C in Test_Range loop\n               for D in Test_Range loop\n                  for E in Test_Range loop\n                     for F in Test_Range loop\n                        for G in Test_Range loop\n                           if Is_Valid (A,B,C,D,E,F,G) then\n                              if not Unique or (Unique and Is_Unique ((A,B,C,D,E,F,G))) then\n                                 Count := Count + 1;\n                                 if Show then\n                                    Put_Line (A'Image & B'Image & C'Image & D'Image & E'Image & F'Image & G'Image);\n                                 end if;\n                              end if;\n                           end if;\n                        end loop;\n                     end loop;\n                  end loop;\n               end loop;\n            end loop;\n         end loop;\n      end loop;\n      Put_Line (\"There are \" & Count'Image &\n                  (if Unique then \" unique \" else \" non-unique \") &\n                    \"solutions in \" & Low'Image & \" ..\" & High'Image);\n      New_Line;\n   end Four_Rings;\n\nbegin\n   Four_Rings (Low => 1, High => 7, Unique => True,  Show => True);\n   Four_Rings (Low => 3, High => 9, Unique => True,  Show => True);\n   Four_Rings (Low => 0, High => 9, Unique => False, Show => False);\nend Puzzle_Square_4;\n\n\nOutput:\n 3 7 2 1 5 4 6\n 4 5 3 1 6 2 7\n 4 7 1 3 2 6 5\n 5 6 2 3 1 7 4\n 6 4 1 5 2 3 7\n 6 4 5 1 2 7 3\n 7 2 6 1 3 5 4\n 7 3 2 5 1 4 6\nThere are  8 unique solutions in  1 .. 7\n\n 7 8 3 4 5 6 9\n 8 7 3 5 4 6 9\n 9 6 4 5 3 7 8\n 9 6 5 4 3 8 7\nThere are  4 unique solutions in  3 .. 9\n\nThere are  2860 non-unique solutions in  0 .. 9\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Julia", "code": "\nTranslation of: Python\nusing Combinatorics\n\nfunction foursquares(low, high, onlyunique=true, showsolutions=true)\n    integers = collect(low:high)\n    count = 0\n    sumsallequal(c) = c[1] + c[2] == c[2] + c[3] + c[4] == c[4] + c[5] + c[6] == c[6] + c[7]\n    combos = onlyunique ? combinations(integers) :\n                          with_replacement_combinations(integers, 7)\n    for combo in combos, plist in unique(collect(permutations(combo, 7)))\n        if sumsallequal(plist)\n            count += 1\n            if showsolutions\n                println(\"$plist is a solution for the list $integers\")\n            end\n        end\n    end\n    println(\"\"\"Total $(onlyunique?\"unique \":\"\")solutions for HIGH $high, LOW $low: $count\"\"\")\nend\n\nfoursquares(1, 7, true, true)\nfoursquares(3, 9, true, true)\nfoursquares(0, 9, false, false)\n\n\nOutput:\n[3, 7, 2, 1, 5, 4, 6] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[4, 5, 3, 1, 6, 2, 7] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[4, 7, 1, 3, 2, 6, 5] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[5, 6, 2, 3, 1, 7, 4] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[6, 4, 1, 5, 2, 3, 7] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[6, 4, 5, 1, 2, 7, 3] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[7, 2, 6, 1, 3, 5, 4] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\n[7, 3, 2, 5, 1, 4, 6] is a solution for the list [1, 2, 3, 4, 5, 6, 7]\nTotal unique solutions for HIGH 7, LOW 1: 8\n[7, 8, 3, 4, 5, 6, 9] is a solution for the list [3, 4, 5, 6, 7, 8, 9]\n[8, 7, 3, 5, 4, 6, 9] is a solution for the list [3, 4, 5, 6, 7, 8, 9]\n[9, 6, 4, 5, 3, 7, 8] is a solution for the list [3, 4, 5, 6, 7, 8, 9]\n[9, 6, 5, 4, 3, 8, 7] is a solution for the list [3, 4, 5, 6, 7, 8, 9]\nTotal unique solutions for HIGH 9, LOW 3: 4\nTotal solutions for HIGH 9, LOW 0: 2860\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Kotlin", "code": "\nTranslation of: C\n// version 1.1.2\n\nclass FourSquares(\n    private val lo: Int,\n    private val hi: Int,\n    private val unique: Boolean,\n    private val show: Boolean\n) {\n    private var a = 0\n    private var b = 0\n    private var c = 0\n    private var d = 0\n    private var e = 0\n    private var f = 0\n    private var g = 0\n    private var s = 0\n\n    init {\n        println()\n        if (show) {\n            println(\"a b c d e f g\")\n            println(\"-------------\")\n        }\n        acd()\n        println(\"\\n$s ${if (unique) \"unique\" else \"non-unique\"} solutions in $lo to $hi\")\n    }\n\n    private fun acd() {\n        c = lo\n        while (c <= hi) {\n            d = lo\n            while (d <= hi) {\n                if (!unique || c != d) {\n                    a = c + d\n                    if ((a in lo..hi) && (!unique || (c != 0 && d!= 0))) ge()\n                }\n                d++\n            }\n            c++\n        }\n    }\n\n    private fun bf() {\n        f = lo\n        while (f <= hi) {\n            if (!unique || (f != a && f != c && f != d && f != e && f!= g)) {\n                b = e + f - c\n                if ((b in lo..hi) && (!unique || (b != a && b != c && b != d && b != e && b != f && b!= g))) {\n                    s++\n                    if (show) println(\"$a $b $c $d $e $f $g\")\n                }\n            }\n            f++\n        }\n    }\n\n    private fun ge() {\n        e = lo\n        while (e <= hi) {\n            if (!unique || (e != a && e != c && e != d)) {\n                g = d + e\n                if ((g in lo..hi) && (!unique || (g != a && g != c && g != d && g != e))) bf()\n            }\n            e++\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    FourSquares(1, 7, true, true)\n    FourSquares(3, 9, true, true)\n    FourSquares(0, 9, false, false)\n}\n\n\nOutput:\na b c d e f g\n-------------\n4 7 1 3 2 6 5\n6 4 1 5 2 3 7\n3 7 2 1 5 4 6\n5 6 2 3 1 7 4\n7 3 2 5 1 4 6\n4 5 3 1 6 2 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n\n8 unique solutions in 1 to 7\n\na b c d e f g\n-------------\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\n\n4 unique solutions in 3 to 9\n\n\n2860 non-unique solutions in 0 to 9\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Perl", "code": "\n\nLibrary: ntheory\nuse ntheory qw/forperm/;\nuse Set::CrossProduct;\n\nsub four_sq_permute {\n    my($list) = @_;\n    my @solutions;\n    forperm {\n       @c = @$list[@_];\n       push @solutions, [@c] if check(@c);\n    } @$list;\n    print +@solutions . \" unique solutions found using: \" . join(', ', @$list) . \"\\n\";\n    return @solutions;\n}\n\nsub four_sq_cartesian {\n    my(@list) = @_;\n    my @solutions;\n    my $iterator = Set::CrossProduct->new( [(@list) x 7] );\n    while( my $c = $iterator->get ) {\n       push @solutions, [@$c] if check(@$c);\n    }\n    print +@solutions . \" non-unique solutions found using: \" . join(', ', @{@list[0]}) . \"\\n\";\n    return @solutions;\n}\n\nsub check {\n    my(@c) = @_;\n    $a = $c[0] + $c[1];\n    $b = $c[1] + $c[2] + $c[3];\n    $c = $c[3] + $c[4] + $c[5];\n    $d = $c[5] + $c[6];\n    $a == $b and $a == $c and $a == $d;\n}\n\nsub display {\n    my(@solutions) = @_;\n    my $fmt = \"%2s \" x 7 . \"\\n\";\n    printf $fmt, ('a'..'g');\n    printf $fmt, @$_ for @solutions;\n    print \"\\n\";\n}\n\ndisplay four_sq_permute( [1..7] );\ndisplay four_sq_permute( [3..9] );\ndisplay four_sq_permute( [8, 9, 11, 12, 17, 18, 20, 21] );\nfour_sq_cartesian( [0..9] );\n\n\nOutput:\n8 unique solutions found using: 1, 2, 3, 4, 5, 6, 7\n a  b  c  d  e  f  g\n 3  7  2  1  5  4  6\n 4  5  3  1  6  2  7\n 4  7  1  3  2  6  5\n 5  6  2  3  1  7  4\n 6  4  1  5  2  3  7\n 6  4  5  1  2  7  3\n 7  2  6  1  3  5  4\n 7  3  2  5  1  4  6\n\n4 unique solutions found using: 3, 4, 5, 6, 7, 8, 9\n a  b  c  d  e  f  g\n 7  8  3  4  5  6  9\n 8  7  3  5  4  6  9\n 9  6  4  5  3  7  8\n 9  6  5  4  3  8  7\n\n8 unique solutions found using: 8, 9, 11, 12, 17, 18, 20, 21\n a  b  c  d  e  f  g\n17 21  8  9 11 18 20\n17 21  9  8 12 18 20\n20 18  8 12  9 17 21\n20 18 11  9  8 21 17\n20 18 11  9 12 17 21\n20 18 12  8  9 21 17\n21 17  9 12  8 18 20\n21 17 12  9 11 18 20\n\n2860 non-unique solutions found using: 0, 1, 2, 3, 4, 5, 6, 7, 8, 9\nWith Recursion[edit]\n#!/usr/bin/perl\n\nuse strict; # https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle\nuse warnings;\n\nfor ( [1 .. 7], [3 .. 9] )\n  {\n  print \"for @$_\\n\\n\";\n  findunique( $_ );\n  print \"\\n\";\n  }\nmy $count = 0;\nfindcount();\nprint \"count of non-unique 0-9: $count\\n\";\n\nsub findunique\n  {\n  my @allowed = @{ shift @_ };\n  if( @_ == 4 ) { $_[0] == $_[2] + $_[3] or return }\n  elsif( @_ == 6 ) { $_[1] + $_[2] == $_[4] + $_[5] or return }\n  elsif( @_ == 7 ) { $_[3] + $_[4] == $_[6] and print \"@_\\n\"; return }\n  for my $n ( @allowed )\n    {\n    findunique( [ grep $n != $_, @allowed ], @_, $n );\n    }\n  }\n\nsub findcount\n  {\n  if( @_ == 4 ) { $_[0] == $_[2] + $_[3] or return }\n  elsif( @_ == 6 ) { $_[1] + $_[2] == $_[4] + $_[5] or return }\n  elsif( @_ == 7 ) { $_[3] + $_[4] == $_[6] and $count++; return }\n  findcount( @_, $_ ) for 0 .. 9;\n  }\n\n\nOutput:\nfor 1 2 3 4 5 6 7\n\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\n\nfor 3 4 5 6 7 8 9\n\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\n\ncount of non-unique 0-9: 2860\n\n", "explain": "Relying on the modules ntheory and Set::CrossProduct to generate the tuples needed. Both are supply results via iterators, particularly important in the latter case, to avoid gobbling too much memory.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Prolog", "code": "\n\n:- use_module(library(clpfd)).\n\n% main predicate\nmy_sum(Min, Max, Top, LL):-\n    L = [A,B,C,D,E,F,G],\n    L ins Min..Max,\n    (   Top == 0\n    ->  all_distinct(L)\n    ;    true),\n    R #= A+B,\n    R #= B+C+D,\n    R #= D+E+F,\n    R #= F+G,\n    setof(L, labeling([ff], L), LL).\n\n\nmy_sum_1(Min, Max) :-\n    my_sum(Min, Max, 0, LL),\n    maplist(writeln, LL).\n\nmy_sum_2(Min, Max, Len) :-\n    my_sum(Min, Max, 1, LL),\n    length(LL, Len).\n\n\n\u00a0?- my_sum_1(1,7).\n[3,7,2,1,5,4,6]\n[4,5,3,1,6,2,7]\n[4,7,1,3,2,6,5]\n[5,6,2,3,1,7,4]\n[6,4,1,5,2,3,7]\n[6,4,5,1,2,7,3]\n[7,2,6,1,3,5,4]\n[7,3,2,5,1,4,6]\ntrue.\n\n\u00a0?- my_sum_1(3,9).\n[7,8,3,4,5,6,9]\n[8,7,3,5,4,6,9]\n[9,6,4,5,3,7,8]\n[9,6,5,4,3,8,7]\ntrue.\n\n\u00a0?- my_sum_2(0,9,N).\nN = 2860.\n\n", "explain": "Works with SWI-Prolog 7.5.8\nOutput\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Lua", "code": "\nTranslation of: D\nfunction valid(unique,needle,haystack)\n    if unique then\n        for _,value in pairs(haystack) do\n            if needle == value then\n                return false\n            end\n        end\n    end\n    return true\nend\n\nfunction fourSquare(low,high,unique,prnt)\n    count = 0\n    if prnt then\n        print(\"a\", \"b\", \"c\", \"d\", \"e\", \"f\", \"g\")\n    end\n    for a=low,high do\n        for b=low,high do\n            if valid(unique, a, {b}) then\n                fp = a + b\n                for c=low,high do\n                    if valid(unique, c, {a, b}) then\n                        for d=low,high do\n                            if valid(unique, d, {a, b, c}) and fp == b + c + d then\n                                for e=low,high do\n                                    if valid(unique, e, {a, b, c, d}) then\n                                        for f=low,high do\n                                            if valid(unique, f, {a, b, c, d, e}) and fp == d + e + f then\n                                                for g=low,high do\n                                                    if valid(unique, g, {a, b, c, d, e, f}) and fp == f + g then\n                                                        count = count + 1\n                                                        if prnt then\n                                                            print(a, b, c, d, e, f, g)\n                                                        end\n                                                    end\n                                                end\n                                            end\n                                        end\n                                    end\n                                end\n                            end\n                        end\n                    end\n                end\n            end\n        end\n    end\n    if unique then\n        print(string.format(\"There are %d unique solutions in [%d, %d]\", count, low, high))\n    else\n        print(string.format(\"There are %d non-unique solutions in [%d, %d]\", count, low, high))\n    end\nend\n\nfourSquare(1,7,true,true)\nfourSquare(3,9,true,true)\nfourSquare(0,9,false,false)\n\n\nOutput:\na       b       c       d       e       f       g\n3       7       2       1       5       4       6\n4       5       3       1       6       2       7\n4       7       1       3       2       6       5\n5       6       2       3       1       7       4\n6       4       1       5       2       3       7\n6       4       5       1       2       7       3\n7       2       6       1       3       5       4\n7       3       2       5       1       4       6\nThere are 8 unique solutions in [1, 7]\na       b       c       d       e       f       g\n7       8       3       4       5       6       9\n8       7       3       5       4       6       9\n9       6       4       5       3       7       8\n9       6       5       4       3       8       7\nThere are 4 unique solutions in [3, 9]\nThere are 2860 non-unique solutions in [0, 9]\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Scala", "code": "\nTranslation of: Java\nobject FourRings {\n \n  def fourSquare(low: Int, high: Int, unique: Boolean, print: Boolean): Unit = {\n    def isValid(needle: Integer, haystack: Integer*) = !unique || !haystack.contains(needle)\n\n    if (print) println(\"a b c d e f g\")\n\n    var count = 0\n    for {\n      a <- low to high\n      b <- low to high if isValid(a, b)\n      fp = a + b\n      c <- low to high if isValid(c, a, b)\n      d <- low to high if isValid(d, a, b, c) && fp == b + c + d\n      e <- low to high if isValid(e, a, b, c, d)\n      f <- low to high if isValid(f, a, b, c, d, e) && fp == d + e + f\n      g <- low to high if isValid(g, a, b, c, d, e, f) && fp == f + g\n    } {\n      count += 1\n      if (print) println(s\"$a $b $c $d $e $f $g\")\n    }\n    \n    println(s\"There are $count ${if(unique) \"unique\" else \"non-unique\"} solutions in [$low, $high]\")\n  }\n \n  def main(args: Array[String]): Unit = {\n    fourSquare(1, 7, unique = true, print = true)\n    fourSquare(3, 9, unique = true, print = true)\n    fourSquare(0, 9, unique = false, print = false)\n  }\n}\n\n\nOutput:\na b c d e f g\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\nThere are 8 unique solutions in [1, 7]\na b c d e f g\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\nThere are 4 unique solutions in [3, 9]\nThere are 2860 non-unique solutions in [0, 9]\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main() {\n    fourSquare(1,7,true,true);\n    fourSquare(3,9,true,true);\n    fourSquare(0,9,false,false);\n}\n\nvoid fourSquare(int low, int high, bool unique, bool print) {\n    int count;\n\n    if (print) {\n        writeln(\"a b c d e f g\");\n    }\n    for (int a=low; a<=high; ++a) {\n        for (int b=low; b<=high; ++b) {\n            if (!valid(unique, a, b)) continue;\n\n            int fp = a+b;\n            for (int c=low; c<=high; ++c) {\n                if (!valid(unique, c, a, b)) continue;\n                for (int d=low; d<=high; ++d) {\n                    if (!valid(unique, d, a, b, c)) continue;\n                    if (fp != b+c+d) continue;\n\n                    for (int e=low; e<=high; ++e) {\n                        if (!valid(unique, e, a, b, c, d)) continue;\n                        for (int f=low; f<=high; ++f) {\n                            if (!valid(unique, f, a, b, c, d, e)) continue;\n                            if (fp != d+e+f) continue;\n\n                            for (int g=low; g<=high; ++g) {\n                                if (!valid(unique, g, a, b, c, d, e, f)) continue;\n                                if (fp != f+g) continue;\n\n                                ++count;\n                                if (print) {\n                                    writeln(a,' ',b,' ',c,' ',d,' ',e,' ',f,' ',g);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n    }\n    if (unique) {\n        writeln(\"There are \", count, \" unique solutions in [\",low,\",\",high,\"]\");\n    } else {\n        writeln(\"There are \", count, \" non-unique solutions in [\",low,\",\",high,\"]\");\n    }\n}\n\nbool valid(bool unique, int needle, int[] haystack ...) {\n    if (unique) {\n        foreach (value; haystack) {\n            if (needle == value) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\n\nOutput:\na b c d e f g\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\nThere are 8 unique solutions in [1,7]\na b c d e f g\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\nThere are 4 unique solutions in [3,9]\nThere are 2860 non-unique solutions in [0,9]\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Haskell", "code": "\nBy exhaustive search[edit]\nimport Data.List\nimport Control.Monad\n\nperms :: (Eq a) => [a] -> [[a]]\nperms [] = [[]]\nperms xs = [ x:xr | x <- xs, xr <- perms (xs\\\\[x]) ]\n\ncombs :: (Eq a) => Int -> [a] -> [[a]]\ncombs 0 _ = [[]]\ncombs n xs = [ x:xr | x <- xs, xr <- combs (n-1) xs ]\n\nringCheck :: [Int] -> Bool\nringCheck [x0, x1, x2, x3, x4, x5, x6] = \n          v == x1+x2+x3 \n       && v == x3+x4+x5 \n       && v == x5+x6\n    where v = x0 + x1\n\nfourRings :: Int -> Int -> Bool -> Bool -> IO ()\nfourRings low high allowRepeats verbose = do\n    let candidates = if allowRepeats\n                     then combs 7 [low..high]\n                     else perms [low..high]\n\n        solutions = filter ringCheck candidates\n\n    when verbose $ mapM_ print solutions\n\n    putStrLn $    show (length solutions)  \n               ++ (if allowRepeats then \" non\" else \"\")\n               ++ \" unique solutions for \" \n               ++ show low \n               ++ \" to \" \n               ++ show high\n\n    putStrLn \"\"\n\nmain = do\n   fourRings 1 7 False True\n   fourRings 3 9 False True\n   fourRings 0 9 True False\n\n\nOutput:\n[3,7,2,1,5,4,6]\n[4,5,3,1,6,2,7]\n[4,7,1,3,2,6,5]\n[5,6,2,3,1,7,4]\n[6,4,1,5,2,3,7]\n[6,4,5,1,2,7,3]\n[7,2,6,1,3,5,4]\n[7,3,2,5,1,4,6]\n8 unique solutions for 1 to 7\n\n[7,8,3,4,5,6,9]\n[8,7,3,5,4,6,9]\n[9,6,4,5,3,7,8]\n[9,6,5,4,3,8,7]\n4 unique solutions for 3 to 9\n\n2860 non unique solutions for 0 to 9\nBy structured search[edit]\n\nIf we call the central digit the Queen, then in any solution the Queen plus its left neighbour (left Bishop) must sum to the value of the left Rook (leftmost digit). Symmetrically, the right Rook must be the sum of the Queen and right Bishop.\nThe difference between the left Rook and the right Rook must be (minus) the difference between the left Knight (between bishop and rook) and the right Knight.\n\nimport Data.List (delete, sortBy, (\\\\))\n\n--------------- 4 RINGS OR 4 SQUARES PUZZLE --------------\n\ntype Rings = [(Int, Int, Int, Int, Int, Int, Int)]\n\nrings :: Bool -> [Int] -> Rings\nrings u digits =\n  ((>>=) <*> (queen u =<< head))\n    (sortBy (flip compare) digits)\n\nqueen :: Bool -> Int -> [Int] -> Int -> Rings\nqueen u h ds q = xs >>= leftBishop u q h ts ds\n  where\n    ts = filter ((<= h) . (q +)) ds\n    xs\n      | u = delete q ts\n      | otherwise = ds\n\nleftBishop ::\n  Bool ->\n  Int ->\n  Int ->\n  [Int] ->\n  [Int] ->\n  Int ->\n  Rings\nleftBishop u q h ts ds lb\n  | lRook <= h = xs >>= rightBishop u q h lb ds lRook\n  | otherwise = []\n  where\n    lRook = lb + q\n    xs\n      | u = ts \\\\ [q, lb, lRook]\n      | otherwise = ds\n\nrightBishop ::\n  Bool ->\n  Int ->\n  Int ->\n  Int ->\n  [Int] ->\n  Int ->\n  Int ->\n  Rings\nrightBishop u q h lb ds lRook rb\n  | (rRook <= h) && (not u || (rRook /= lb)) =\n    let ks\n          | u = (ds \\\\ [q, lb, rb, rRook, lRook])\n          | otherwise = ds\n     in ks\n          >>= knights\n            u\n            (lRook - rRook)\n            lRook\n            lb\n            q\n            rb\n            rRook\n            ks\n  | otherwise = []\n  where\n    rRook = q + rb\n\nknights ::\n  Bool ->\n  Int ->\n  Int ->\n  Int ->\n  Int ->\n  Int ->\n  Int ->\n  [Int] ->\n  Int ->\n  Rings\nknights u rookDelta lRook lb q rb rRook ks k =\n  [ (lRook, k, lb, q, rb, k2, rRook)\n    | (k2 `elem` ks)\n        && ( not u\n               || notElem\n                 k2\n                 [lRook, k, lb, q, rb, rRook]\n           )\n  ]\n  where\n    k2 = k + rookDelta\n\n--------------------------- TEST -------------------------\nmain :: IO ()\nmain = do\n  let f (k, xs) = putStrLn k >> nl >> mapM_ print xs >> nl\n      nl = putStrLn []\n  mapM_\n    f\n    [ (\"rings True [1 .. 7]\", rings True [1 .. 7]),\n      (\"rings True [3 .. 9]\", rings True [3 .. 9])\n    ]\n  f\n    ( \"length (rings False [0 .. 9])\",\n      [length (rings False [0 .. 9])]\n    )\n\n\nOutput:\nrings True [1 .. 7]\n\n(7,3,2,5,1,4,6)\n(6,4,1,5,2,3,7)\n(5,6,2,3,1,7,4)\n(4,7,1,3,2,6,5)\n(7,2,6,1,3,5,4)\n(6,4,5,1,2,7,3)\n(4,5,3,1,6,2,7)\n(3,7,2,1,5,4,6)\n\nrings True [3 .. 9]\n\n(9,6,4,5,3,7,8)\n(8,7,3,5,4,6,9)\n(9,6,5,4,3,8,7)\n(7,8,3,4,5,6,9)\n\nlength (rings False [0 .. 9])\n\n2860\n", "explain": "For a faster solution (under a third of a second, vs over 25 seconds on this system for the brute force approach above), we can nest a series of smaller and more focused searches from the central digit outwards.\nTwo things to notice:\n\nNesting four bind operators (>>=), we can then build the set of solutions in the order: queens, left bishops and rooks, right bishops and rooks, knights.\nProbably less readable, but already fast, and could be further optimised.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "PL/SQL", "code": "\nWorks with: Oracle\ncreate table allints (v number);\ncreate table results \n(\na number,\nb number,\nc number,\nd number,\ne number,\nf number,\ng number\n);\n\ncreate or replace procedure foursquares(lo number,hi number,uniq boolean,show boolean)\nas\n    a number;\n    b number;\n    c number;\n    d number;\n    e number;\n    f number;\n    g number;\n    out_line varchar2(2000);\n   \n    cursor results_cur is \n    select\n       a,\n       b,\n       c,\n       d,\n       e,\n       f,\n       g\n    from\n        results\n    order by \n        a,b,c,d,e,f,g;\n\n    results_rec results_cur%rowtype;\n    \n    solutions number;\n    uorn varchar2(2000);\nbegin\n    solutions := 0;\n    delete from allints;\n    delete from results;\n    for i in lo..hi loop\n        insert into allints values (i);\n    end loop;\n    commit;\n    \n    if uniq = TRUE then\n        insert into results\n            select\n                a.v a,\n                b.v b,\n                c.v c,\n                d.v d,\n                e.v e,\n                f.v f,\n                g.v g\n            from\n                allints a, allints b, allints c,allints d,\n                allints e, allints f, allints g\n            where\n                a.v not in (b.v,c.v,d.v,e.v,f.v,g.v) and\n                b.v not in (c.v,d.v,e.v,f.v,g.v) and\n                c.v not in (d.v,e.v,f.v,g.v) and\n                d.v not in (e.v,f.v,g.v) and\n                e.v not in (f.v,g.v) and\n                f.v not in (g.v) and\n                a.v = c.v + d.v and\n                g.v = d.v + e.v and\n                b.v = e.v + f.v - c.v\n            order by \n                a,b,c,d,e,f,g;\n        uorn := ' unique solutions in ';\n    else\n        insert into results\n            select\n                a.v a,\n                b.v b,\n                c.v c,\n                d.v d,\n                e.v e,\n                f.v f,\n                g.v g\n            from\n                allints a, allints b, allints c,allints d,\n                allints e, allints f, allints g\n            where\n                a.v = c.v + d.v and\n                g.v = d.v + e.v and\n                b.v = e.v + f.v - c.v\n            order by \n                a,b,c,d,e,f,g;   \n        uorn := ' non-unique solutions in ';\n    end if;\n    commit;\n\n    open results_cur;\n    loop\n        fetch results_cur into results_rec;\n        exit when results_cur%notfound;\n        a := results_rec.a;\n        b := results_rec.b;\n        c := results_rec.c;\n        d := results_rec.d;\n        e := results_rec.e;\n        f := results_rec.f;\n        g := results_rec.g;\n        \n        solutions := solutions + 1;\n        if show = TRUE then\n            out_line := to_char(a) || ' ';\n            out_line := out_line || ' ' || to_char(b) || ' ';\n            out_line := out_line || ' ' || to_char(c) || ' ';\n            out_line := out_line || ' ' || to_char(d) || ' ';\n            out_line := out_line || ' ' || to_char(e) || ' ';\n            out_line := out_line || ' ' || to_char(f) ||' ';\n            out_line := out_line || ' ' || to_char(g);\n        end if;\n        \n        dbms_output.put_line(out_line);\n    end loop;\n    close results_cur;\n    out_line := to_char(solutions) || uorn;\n    out_line := out_line || to_char(lo) || ' to ' || to_char(hi);\n    dbms_output.put_line(out_line);\n   \nend;\n/\n\n\nSQL> execute foursquares(1,7,TRUE,TRUE);\n3  7  2  1  5  4  6                                                             \n4  5  3  1  6  2  7                                                             \n4  7  1  3  2  6  5                                                             \n5  6  2  3  1  7  4                                                             \n6  4  1  5  2  3  7                                                             \n6  4  5  1  2  7  3                                                             \n7  2  6  1  3  5  4                                                             \n7  3  2  5  1  4  6                                                             \n8 unique solutions in 1 to 7                                                    \n\nPL/SQL procedure successfully completed.\n\nSQL> execute foursquares(3,9,TRUE,TRUE);\n7  8  3  4  5  6  9                                                             \n8  7  3  5  4  6  9                                                             \n9  6  4  5  3  7  8                                                             \n9  6  5  4  3  8  7                                                             \n4 unique solutions in 3 to 9                                                    \n\nPL/SQL procedure successfully completed.\n\nSQL> execute foursquares(0,9,FALSE,FALSE);\n2860 non-unique solutions in 0 to 9                                             \n\nPL/SQL procedure successfully completed.\n\n", "explain": "Output\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Scheme", "code": "\n(import (scheme base)\n        (scheme write)\n        (srfi 1))\n\n;; return all combinations of size elements from given set\n(define (combinations size set unique?)\n  (if (zero? size)\n    (list '())\n    (let loop ((base-combns (combinations (- size 1) set unique?))\n               (results '())\n               (items set))\n      (cond ((null? base-combns) ; end, as no base-combinations to process\n             results)\n            ((null? items)       ; check next base-combination\n             (loop (cdr base-combns)\n                   results\n                   set))\n            ((and unique?        ; ignore if wanting list unique\n                  (member (car items) (car base-combns) =))\n             (loop base-combns\n                   results\n                   (cdr items)))\n            (else                ; keep the new combination\n              (loop base-combns\n                    (cons (cons (car items) (car base-combns))\n                          results)\n                    (cdr items)))))))\n\n;; checks if all 4 sums are the same\n(define (solution? a b c d e f g)\n  (= (+ a b)\n     (+ b c d)\n     (+ d e f)\n     (+ f g)))\n\n;; Tasks\n(display \"Solutions: LOW=1 HIGH=7\\n\")\n(display (filter (lambda (combination) (apply solution? combination))\n                 (combinations 7 (iota 7 1) #t))) (newline)\n\n(display \"Solutions: LOW=3 HIGH=9\\n\")\n(display (filter (lambda (combination) (apply solution? combination))\n                 (combinations 7 (iota 7 3) #t))) (newline)\n\n(display \"Solution count: LOW=0 HIGH=9 non-unique\\n\")\n(display (count (lambda (combination) (apply solution? combination))\n                (combinations 7 (iota 10 0) #f))) (newline)\n\n\nOutput:\nSolutions: LOW=1 HIGH=7\n((4 5 3 1 6 2 7) (6 4 1 5 2 3 7) (3 7 2 1 5 4 6) (7 3 2 5 1 4 6) (4 7 1 3 2 6 5) (7 2 6 1 3 5 4) (5 6 2 3 1 7 4) (6 4 5 1 2 7 3))\nSolutions: LOW=3 HIGH=9\n((7 8 3 4 5 6 9) (8 7 3 5 4 6 9) (9 6 4 5 3 7 8) (9 6 5 4 3 8 7))\nSolution count: LOW=0 HIGH=9 non-unique\n2860\n\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "F#", "code": "\n(* A simple function to generate the sequence\n   Nigel Galloway: January 31st., 2017 *)\ntype G = {d:int;x:int;b:int;f:int}\nlet N n g = \n  {(max (n-g) n) .. (min (g-n) g)} |> Seq.collect(fun d->{(max (d+n+n) (n+n))..(min (g+g) (d+g+g))}           |> Seq.collect(fun x -> \n  seq{for a in n .. g do for b in n .. g do if (a+b) = x then for c in n .. g do if (b+c+d) = x then yield b} |> Seq.collect(fun b ->\n  seq{for f in n .. g do for G in n .. g do if (f+G) = x then for e in n .. g do if (f+e+d) = x then yield f} |> Seq.map(fun f -> {d=d;x=x;b=b;f=f}))))\n\n\nprintfn \"%d\" (Seq.length (N 0 9))\n\n\nOutput:\n2860\n\n(* A simple function to generate the sequence with unique values\n   Nigel Galloway: January 31st., 2017 *)\ntype G = {d:int;x:int;b:int;f:int}\nlet N n g = \n  {(max (n-g) n) .. (min (g-n) g)} |> Seq.filter(fun d -> d <> 0) |> Seq.collect(fun d->{(max (d+n+n) (n+n)) .. (min (g+g) (d+g+g))} |> Seq.collect(fun x -> \n  seq{for a in n .. g do if a <> d then for b in n .. g do if (a+b) = x && b <> a && b <> d then for c in n .. g do if (b+c+d) = x && c <> d && c <> a && c <> b then yield b} |> Seq.collect(fun b ->\n  seq{for f in n .. g do if f <> d && f <> b && f <> (x-b) && f <> (x-d-b) then for G in n .. g do if (f+G) = x && G <> d && G <> b && G <> f && G <> (x-b) && G <> (x-d-b) then for e in n .. g do if (f+e+d) = x && e <> d && e <> b && e <> f && e <> G && e <> (x-b) && e <> (x-d-b) then yield f} |> Seq.map(fun f -> {d=d;x=x;b=b;f=f}))))\n\n\nfor n in N 1 7 do printfn \"%d,%d,%d,%d,%d,%d,%d\" (n.x-n.b) n.b (n.x-n.d-n.b) n.d (n.x-n.d-n.f) n.f (n.x-n.f)\n\n\nOutput:\n4,5,3,1,6,2,7\n7,2,6,1,3,5,4\n3,7,2,1,5,4,6\n6,4,5,1,2,7,3\n4,7,1,3,2,6,5\n5,6,2,3,1,7,4\n6,4,1,5,2,3,7\n7,3,2,5,1,4,6\n\n\nfor n in N 3 9 do printfn \"%d,%d,%d,%d,%d,%d,%d\" (n.x-n.b) n.b (n.x-n.d-n.b) n.d (n.x-n.d-n.f) n.f (n.x-n.f)\n\n\nOutput:\n7,8,3,4,5,6,9\n9,6,5,4,3,8,7\n8,7,3,5,4,6,9\n9,6,4,5,3,7,8\n\n", "explain": "Then:\nThen:\nand:\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Groovy", "code": "\nTranslation of: Java\nclass FourRings {\n    static void main(String[] args) {\n        fourSquare(1, 7, true, true)\n        fourSquare(3, 9, true, true)\n        fourSquare(0, 9, false, false)\n    }\n\n    private static void fourSquare(int low, int high, boolean unique, boolean print) {\n        int count = 0\n\n        if (print) {\n            println(\"a b c d e f g\")\n        }\n        for (int a = low; a <= high; ++a) {\n            for (int b = low; b <= high; ++b) {\n                if (notValid(unique, a, b)) continue\n\n                int fp = a + b\n                for (int c = low; c <= high; ++c) {\n                    if (notValid(unique, c, a, b)) continue\n                    for (int d = low; d <= high; ++d) {\n                        if (notValid(unique, d, a, b, c)) continue\n                        if (fp != b + c + d) continue\n\n                        for (int e = low; e <= high; ++e) {\n                            if (notValid(unique, e, a, b, c, d)) continue\n                            for (int f = low; f <= high; ++f) {\n                                if (notValid(unique, f, a, b, c, d, e)) continue\n                                if (fp != d + e + f) continue\n\n                                for (int g = low; g <= high; ++g) {\n                                    if (notValid(unique, g, a, b, c, d, e, f)) continue\n                                    if (fp != f + g) continue\n\n                                    ++count\n                                    if (print) {\n                                        printf(\"%d %d %d %d %d %d %d%n\", a, b, c, d, e, f, g)\n                                    }\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        if (unique) {\n            printf(\"There are %d unique solutions in [%d, %d]%n\", count, low, high)\n        } else {\n            printf(\"There are %d non-unique solutions in [%d, %d]%n\", count, low, high)\n        }\n    }\n\n    private static boolean notValid(boolean unique, int needle, int ... haystack) {\n        return unique && Arrays.stream(haystack).anyMatch({ p -> p == needle })\n    }\n}\n\n\nOutput:\na b c d e f g\n3 7 2 1 5 4 6\n4 5 3 1 6 2 7\n4 7 1 3 2 6 5\n5 6 2 3 1 7 4\n6 4 1 5 2 3 7\n6 4 5 1 2 7 3\n7 2 6 1 3 5 4\n7 3 2 5 1 4 6\nThere are 8 unique solutions in [1, 7]\na b c d e f g\n7 8 3 4 5 6 9\n8 7 3 5 4 6 9\n9 6 4 5 3 7 8\n9 6 5 4 3 8 7\nThere are 4 unique solutions in [3, 9]\nThere are 2860 non-unique solutions in [0, 9]\n", "explain": ""}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "Zig", "code": "\nTranslation of: Go\n\nconst std = @import(\"std\");\nconst Allocator = std.mem.Allocator;\npub fn main() !void {\n    const stdout = std.io.getStdOut().writer();\n\n    var gpa = std.heap.GeneralPurposeAllocator(.{}){};\n    defer {\n        const ok = gpa.deinit();\n        std.debug.assert(ok == .ok);\n    }\n    const allocator = gpa.allocator();\n\n    {\n        const nc = try getCombs(allocator, 1, 7, true);\n        defer allocator.free(nc.combinations);\n        try stdout.print(\"{d} unique solutions in 1 to 7\\n\", .{nc.num});\n        try stdout.print(\"{any}\\n\", .{nc.combinations});\n    }\n    {\n        const nc = try getCombs(allocator, 3, 9, true);\n        defer allocator.free(nc.combinations);\n        try stdout.print(\"{d} unique solutions in 3 to 9\\n\", .{nc.num});\n        try stdout.print(\"{any}\\n\", .{nc.combinations});\n    }\n    {\n        const nc = try getCombs(allocator, 0, 9, false);\n        defer allocator.free(nc.combinations);\n        try stdout.print(\"{d} non-unique solutions in 0 to 9\\n\", .{nc.num});\n    }\n}\n/// Caller owns combinations slice memory.\nfn getCombs(allocator: Allocator, low: u16, high: u16, unique: bool) !struct { num: usize, combinations: [][7]usize } {\n    var num: usize = 0;\n    var valid_combinations = std.ArrayList([7]usize).init(allocator);\n    for (low..high + 1) |a|\n        for (low..high + 1) |b|\n            for (low..high + 1) |c|\n                for (low..high + 1) |d|\n                    for (low..high + 1) |e|\n                        for (low..high + 1) |f|\n                            for (low..high + 1) |g|\n                                if (validComb(a, b, c, d, e, f, g))\n                                    if (!unique or try isUnique(allocator, a, b, c, d, e, f, g)) {\n                                        num += 1;\n                                        try valid_combinations.append([7]usize{ a, b, c, d, e, f, g });\n                                    };\n    return .{ .num = num, .combinations = try valid_combinations.toOwnedSlice() };\n}\nfn isUnique(allocator: Allocator, a: usize, b: usize, c: usize, d: usize, e: usize, f: usize, g: usize) !bool {\n    var data = std.AutoArrayHashMap(usize, void).init(allocator);\n    defer data.deinit();\n    try data.put(a, {});\n    try data.put(b, {});\n    try data.put(c, {});\n    try data.put(d, {});\n    try data.put(e, {});\n    try data.put(f, {});\n    try data.put(g, {});\n    return data.count() == 7;\n}\nfn validComb(a: usize, b: usize, c: usize, d: usize, e: usize, f: usize, g: usize) bool {\n    const square1 = a + b;\n    const square2 = b + c + d;\n    const square3 = d + e + f;\n    const square4 = f + g;\n    return square1 == square2 and square2 == square3 and square3 == square4;\n}\n\n\nOutput:\n8 unique solutions in 1 to 7\n{ { 3, 7, 2, 1, 5, 4, 6 }, { 4, 5, 3, 1, 6, 2, 7 }, { 4, 7, 1, 3, 2, 6, 5 }, { 5, 6, 2, 3, 1, 7, 4 }, { 6, 4, 1, 5, 2, 3, 7 }, { 6, 4, 5, 1, 2, 7, 3 }, { 7, 2, 6, 1, 3, 5, 4 }, { 7, 3, 2, 5, 1, 4, 6 } }\n4 unique solutions in 3 to 9\n{ { 7, 8, 3, 4, 5, 6, 9 }, { 8, 7, 3, 5, 4, 6, 9 }, { 9, 6, 4, 5, 3, 7, 8 }, { 9, 6, 5, 4, 3, 8, 7 } }\n2860 non-unique solutions in 0 to 9\n", "explain": "This is a direct translation of the Go solution - the Zig implementation\nhaving manual memory management and Zig not ignoring errors or return values.\n"}, {"task_name": "4-rings or 4-squares puzzle", "task_url": "https://rosettacode.org/wiki/4-rings_or_4-squares_puzzle", "task_cat": "Puzzles", "lang": "AWK", "code": "\n# syntax: GAWK -f 4-RINGS_OR_4-SQUARES_PUZZLE.AWK\n# converted from C\nBEGIN {\n    cmd = \"SORT /+16\"\n    four_squares(1,7,1,1)\n    four_squares(3,9,1,1)\n    four_squares(0,9,0,0)\n    four_squares(0,6,1,0)\n    four_squares(2,8,1,0)\n    exit(0)\n}\nfunction four_squares(plo,phi,punique,pshow) {\n    lo = plo\n    hi = phi\n    unique = punique\n    show = pshow\n    solutions = 0\n    print(\"\")\n    if (show) {\n      print(\"A B C D E F G  sum  A+B B+C+D D+E+F F+G\")\n      print(\"-------------  ---  -------------------\")\n    }\n    acd()\n    close(cmd)\n    tmp = (unique) ? \"unique\" : \"non-unique\"\n    printf(\"%d-%d: %d %s solutions\\n\",lo,hi,solutions,tmp)\n}\nfunction acd() {\n    for (c=lo; c<=hi; c++) {\n      for (d=lo; d<=hi; d++) {\n        if (!unique || c != d) {\n          a = c + d\n          if (a >= lo && a <= hi && (!unique || (c != 0 && d != 0))) {\n            ge()\n          }\n        }\n      }\n    }\n}\nfunction bf() {\n    for (f=lo; f<=hi; f++) {\n      if (!unique || (f != a && f != c && f != d && f != g && f != e)) {\n        b = e + f - c\n        if (b >= lo && b <= hi && (!unique || (b != a && b != c && b != d && b != g && b != e && b != f))) {\n          solutions++\n          if (show) {\n            printf(\"%d %d %d %d %d %d %d %4d  \",a,b,c,d,e,f,g,a+b) | cmd\n            printf(\"%d+%d \",a,b) | cmd\n            printf(\"%d+%d+%d \",b,c,d) | cmd\n            printf(\"%d+%d+%d \",d,e,f) | cmd\n            printf(\"%d+%d\\n\",f,g) | cmd\n          }\n        }\n      }\n    }\n}\nfunction ge() {\n    for (e=lo; e<=hi; e++) {\n      if (!unique || (e != a && e != c && e != d)) {\n        g = d + e\n        if (g >= lo && g <= hi && (!unique || (g != a && g != c && g != d && g != e))) {\n          bf()\n        }\n      }\n    }\n}\n\n\nOutput:\nA B C D E F G  sum  A+B B+C+D D+E+F F+G\n-------------  ---  -------------------\n4 5 3 1 6 2 7    9  4+5 5+3+1 1+6+2 2+7\n7 2 6 1 3 5 4    9  7+2 2+6+1 1+3+5 5+4\n3 7 2 1 5 4 6   10  3+7 7+2+1 1+5+4 4+6\n6 4 1 5 2 3 7   10  6+4 4+1+5 5+2+3 3+7\n6 4 5 1 2 7 3   10  6+4 4+5+1 1+2+7 7+3\n7 3 2 5 1 4 6   10  7+3 3+2+5 5+1+4 4+6\n4 7 1 3 2 6 5   11  4+7 7+1+3 3+2+6 6+5\n5 6 2 3 1 7 4   11  5+6 6+2+3 3+1+7 7+4\n1-7: 8 unique solutions\n\nA B C D E F G  sum  A+B B+C+D D+E+F F+G\n-------------  ---  -------------------\n7 8 3 4 5 6 9   15  7+8 8+3+4 4+5+6 6+9\n8 7 3 5 4 6 9   15  8+7 7+3+5 5+4+6 6+9\n9 6 4 5 3 7 8   15  9+6 6+4+5 5+3+7 7+8\n9 6 5 4 3 8 7   15  9+6 6+5+4 4+3+8 8+7\n3-9: 4 unique solutions\n\n0-9: 2860 non-unique solutions\n\n0-6: 4 unique solutions\n\n2-8: 8 unique solutions\n\n", "explain": ""}]