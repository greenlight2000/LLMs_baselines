[{"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Python", "code": "\nWorks with: Python version 2.5\nnumbers = [1, 2, 3]\ntotal = sum(numbers)\n\nproduct = 1\nfor i in numbers:\n    product *= i\n\nWorks with: Python version 2.5\nfrom operator import mul, add\nsum = reduce(add, numbers) # note: this version doesn't work with empty lists\nsum = reduce(add, numbers, 0)\nproduct = reduce(mul, numbers) # note: this version doesn't work with empty lists\nproduct = reduce(mul, numbers, 1)\nLibrary: NumPy\nfrom numpy import r_\nnumbers = r_[1:4]\ntotal = numbers.sum()\nproduct = numbers.prod()\n\nWorks with: Python version 2.6, 3.x\nimport math\ntotal = math.fsum(floats)\n\n", "explain": "Or functionally (faster but perhaps less clear):\nIf you are summing floats in Python 2.6+, you should use math.fsum() to avoid loss of precision:\n\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "C", "code": "\n/* using pointer arithmetic (because we can, I guess) */\nint arg[] = { 1,2,3,4,5 };\nint arg_length = sizeof(arg)/sizeof(arg[0]);\nint *end = arg+arg_length;\nint sum = 0, prod = 1;\nint *p;\n\nfor (p = arg; p!=end; ++p) {\n   sum += *p;\n   prod *= *p;\n}\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "C++", "code": "\nLibrary: STL\n#include <numeric>\n#include <functional>\n\nint arg[] = { 1, 2, 3, 4, 5 };\nint sum  = std::accumulate(arg, arg+5, 0, std::plus<int>());\n// or just\n// std::accumulate(arg, arg + 5, 0);\n// since plus() is the default functor for accumulate\nint prod = std::accumulate(arg, arg+5, 1, std::multiplies<int>());\n\n\n// this would be more elegant using STL collections\ntemplate <typename T> T sum (const T *array, const unsigned n)\n{\n    T accum = 0;\n    for (unsigned i=0; i<n; i++)\n        accum += array[i];\n    return accum;\n}\ntemplate <typename T> T prod (const T *array, const unsigned n)\n{\n    T accum = 1;\n    for (unsigned i=0; i<n; i++)\n        accum *= array[i];\n    return accum;\n}\n\n#include <iostream>\nusing std::cout;\nusing std::endl;\n\nint main ()\n{\n    int aint[] = {1, 2, 3};\n    cout << sum(aint,3) << \" \" << prod(aint, 3) << endl;\n    float aflo[] = {1.1, 2.02, 3.003, 4.0004};\n    cout << sum(aflo,4) << \" \" << prod(aflo,4) << endl;\n    return 0;\n}\n\n", "explain": "Template alternative:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Java", "code": "\nWorks with: Java version 1.5+\npublic class SumProd\n{\n public static void main(final String[] args)\n {\n  int sum = 0;\n  int prod = 1;\n  int[] arg = {1,2,3,4,5};\n  for (int i : arg)\n  {\n   sum += i;\n   prod *= i;\n  }\n }\n}\n\nWorks with: Java version 1.8+\nimport java.util.Arrays;\n\npublic class SumProd\n{\n public static void main(final String[] args)\n {\n  int[] arg = {1,2,3,4,5};\n  System.out.printf(\"sum = %d\\n\", Arrays.stream(arg).sum());\n  System.out.printf(\"sum = %d\\n\", Arrays.stream(arg).reduce(0, (a, b) -> a + b));\n  System.out.printf(\"product = %d\\n\", Arrays.stream(arg).reduce(1, (a, b) -> a * b));\n }\n}\n\n\nOutput:\nsum = 15\nsum = 15\nproduct = 120\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "C#", "code": "\nint sum = 0, prod = 1;\nint[] arg = { 1, 2, 3, 4, 5 };\nforeach (int value in arg) {\n  sum += value;\n  prod *= value;\n}\n\nAlternative using Linq (C# 3)[edit]\nWorks with: C# version 3\nint[] arg = { 1, 2, 3, 4, 5 };\nint sum = arg.Sum();\nint prod = arg.Aggregate((runningProduct, nextFactor) => runningProduct * nextFactor);\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "JavaScript", "code": "\nES5[edit]\nvar array = [1, 2, 3, 4, 5],\n    sum = 0,\n    prod = 1,\n    i;\nfor (i = 0; i < array.length; i += 1) {\n    sum += array[i];\n    prod *= array[i];\n}\nalert(sum + ' ' + prod);\n\n\nWorks with: Javascript version 1.8\n\nvar array = [1, 2, 3, 4, 5],\n    sum = array.reduce(function (a, b) {\n        return a + b;\n    }, 0),\n    prod = array.reduce(function (a, b) {\n        return a * b;\n    }, 1);\nalert(sum + ' ' + prod);\n\nES6[edit]\n(() => {\n    'use strict';\n\n    // sum\u00a0:: (Num a) => [a] -> a\n    const sum = xs => xs.reduce((a, x) => a + x, 0);\n\n    // product\u00a0:: (Num a) => [a] -> a\n    const product = xs => xs.reduce((a, x) => a * x, 1);\n\n\n    // TEST\n    // show\u00a0:: a -> String\n    const show = x => JSON.stringify(x, null, 2);\n\n    return show(\n        [sum, product]\n        .map(f => f([1, 2, 3, 4, 5, 6, 7, 8, 9, 10]))\n    );\n})();\n\n\nOutput:\n[\n  55,\n  3628800\n]\n", "explain": "\nWhere supported, the reduce method can also be used:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Visual_Basic_.NET", "code": "\nTranslation of: C#\nModule Program\n    Sub Main()\n        Dim arg As Integer() = {1, 2, 3, 4, 5}\n        Dim sum = arg.Sum()\n        Dim prod = arg.Aggregate(Function(runningProduct, nextFactor) runningProduct * nextFactor)\n    End Sub\nEnd Module\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "PHP", "code": "\n$array = array(1,2,3,4,5,6,7,8,9);\necho array_sum($array);\necho array_product($array);\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "MATLAB", "code": "\n\n>> array = [1 2 3;4 5 6;7 8 9]\n\narray =\n\n     1     2     3\n     4     5     6\n     7     8     9\n\n>> sum(array,1)\n\nans =\n\n    12    15    18\n\n>> sum(array,2)\n\nans =\n\n     6\n    15\n    24\n\n>> prod(array,1)\n\nans =\n\n    28    80   162\n\n>> prod(array,2)\n\nans =\n\n     6\n   120\n   504\n\n", "explain": "These two function are built into MATLAB as the \"sum(array)\" and \"prod(array)\" functions.\nSample Usage:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Fortran", "code": "\n\ninteger, dimension(10) :: a = (/ (i, i=1, 10) /)\ninteger :: sresult, presult\n\nsresult = sum(a)\npresult = product(a)\n\n", "explain": "In ISO Fortran 90 and later, use SUM and PRODUCT intrinsics:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Go", "code": "\nImplementation\npackage main\n\nimport \"fmt\"\n\nfunc main() {\n    sum, prod := 0, 1\n    for _, x := range []int{1,2,5} {\n        sum += x\n        prod *= x\n    }\n    fmt.Println(sum, prod)\n}\n\n\nOutput:\n8 10\n\nLibrary\npackage main\n\nimport (\n    \"fmt\"\n\n    \"github.com/gonum/floats\"\n)\n\nvar a = []float64{1, 2, 5}\n\nfunc main() {\n    fmt.Println(\"Sum:    \", floats.Sum(a))\n    fmt.Println(\"Product:\", floats.Prod(a))\n}\n\n\nOutput:\nSum:     8\nProduct: 10\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program sumandproduct.s   */\n\n /* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessSum:            .asciz \"Sum = \"\nszMessProd:           .asciz \"Product = \"\nszMessStart:          .asciz \"Program 32 bits start.\\n\"\nszCarriageReturn:     .asciz \"\\n\"\nszMessErreur:         .asciz \"Overflow\u00a0! \\n\"\n\ntabArray:       .int  2, 11, 19, 90, 55,1000\n.equ TABARRAYSIZE,    (. - tabArray) / 4\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\nsZoneConv:             .skip 24\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                            @ entry of program \n    ldr r0,iAdrszMessStart\n    bl affichageMess\n    ldr r2,iAdrtabArray\n    mov r1,#0                    @ indice\n    mov r0,#0                    @ sum init    \n1:\n    ldr r3,[r2,r1,lsl #2]\n    adds r0,r0,r3\n    bcs 99f\n    add r1,r1,#1\n    cmp r1,#TABARRAYSIZE\n    blt 1b\n    \n    ldr r1,iAdrsZoneConv\n    bl conversion10              @ decimal conversion\n    mov r3,#0\n    strb r3,[r1,r0]\n    mov r0,#3                   @ number string to display\n    ldr r1,iAdrszMessSum\n    ldr r2,iAdrsZoneConv         @ insert conversion in message\n    ldr r3,iAdrszCarriageReturn\n    bl displayStrings            @ display message\n    \n    ldr r2,iAdrtabArray\n    mov r1,#0                    @ indice\n    mov r0,#1                    @ product init    \n2:\n    ldr r3,[r2,r1,lsl #2]\n    umull r0,r4,r3,r0\n    cmp r4,#0\n    bne 99f\n    add r1,r1,#1\n    cmp r1,#TABARRAYSIZE\n    blt 2b\n    \n    ldr r1,iAdrsZoneConv\n    bl conversion10              @ decimal conversion\n    mov r3,#0\n    strb r3,[r1,r0]\n    mov r0,#3                   @ number string to display\n    ldr r1,iAdrszMessProd\n    ldr r2,iAdrsZoneConv         @ insert conversion in message\n    ldr r3,iAdrszCarriageReturn\n    bl displayStrings            @ display message\n    b 100f\n99:\n    ldr r0,iAdrszMessErreur\n    bl affichageMess\n100:                              @ standard end of the program \n    mov r0, #0                    @ return code\n    mov r7, #EXIT                 @ request to exit program\n    svc #0                        @ perform the system call\niAdrszCarriageReturn:        .int szCarriageReturn\niAdrsZoneConv:               .int sZoneConv\niAdrszMessSum:               .int szMessSum\niAdrszMessProd:              .int szMessProd\niAdrszMessErreur:            .int szMessErreur\niAdrszMessStart:             .int szMessStart\niAdrtabArray:                .int tabArray\n\n/***************************************************/\n/*   display multi strings                    */\n/***************************************************/\n/* r0  contains number strings address */\n/* r1 address string1 */\n/* r2 address string2 */\n/* r3 address string3 */\n/* other address on the stack */\n/* thinck to add  number other address * 4 to add to the stack */\ndisplayStrings:            @ INFO:  displayStrings\n    push {r1-r4,fp,lr}     @ save des registres\n    add fp,sp,#24          @ save param\u00e9ters address (6 registers saved * 4 bytes)\n    mov r4,r0              @ save strings number\n    cmp r4,#0              @ 0 string -> end\n    ble 100f\n    mov r0,r1              @ string 1\n    bl affichageMess\n    cmp r4,#1              @ number > 1\n    ble 100f\n    mov r0,r2\n    bl affichageMess\n    cmp r4,#2\n    ble 100f\n    mov r0,r3\n    bl affichageMess\n    cmp r4,#3\n    ble 100f\n    mov r3,#3\n    sub r2,r4,#4\n1:                         @ loop extract address string on stack\n    ldr r0,[fp,r2,lsl #2]\n    bl affichageMess\n    subs r2,#1\n    bge 1b\n100:\n    pop {r1-r4,fp,pc}\n\n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\n\nOutput:\nProgram 32 bits start.\nSum = 1177\nProduct = 2069100000\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Delphi", "code": "\nprogram SumAndProductOfArray;\n\n{$APPTYPE CONSOLE}\n\nvar\n  i: integer;\n  lIntArray: array [1 .. 5] of integer = (1, 2, 3, 4, 5);\n  lSum: integer = 0;\n  lProduct: integer = 1;\nbegin\n  for i := 1 to length(lIntArray) do\n  begin\n    Inc(lSum, lIntArray[i]);\n    lProduct := lProduct * lIntArray[i]\n  end;\n\n  Write('Sum: ');\n  Writeln(lSum);\n  Write('Product: ');\n  Writeln(lProduct);\nend.\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Ruby", "code": "\narr = [1,2,3,4,5]     # or ary = *1..5, or ary = (1..5).to_a\np sum = arr.inject(0) { |sum, item| sum + item }\n# => 15\np product = arr.inject(1) { |prod, element| prod * element }\n# => 120\nWorks with: Ruby version 1.8.7\narr = [1,2,3,4,5]\np sum = arr.inject(0,\u00a0:+)         #=> 15\np product = arr.inject(1,\u00a0:*)     #=> 120\n\n# If you do not explicitly specify an initial value for memo,\n# then the first element of collection is used as the initial value of memo.\np sum = arr.inject(:+)            #=> 15\np product = arr.inject(:*)        #=> 120\n\narr = []\np arr.inject(0,\u00a0:+)               #=> 0\np arr.inject(1,\u00a0:*)               #=> 1\np arr.inject(:+)                  #=> nil\np arr.inject(:*)                  #=> nil\n\nWorks with: Ruby version 1.9.3\narr = [1,2,3,4,5]\np sum = arr.sum                   #=> 15\np [].sum                          #=> 0\n", "explain": "Note: When the Array is empty, the initial value returns. However, nil returns if not giving an initial value.\nEnumerable#reduce is the alias of Enumerable#inject.\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Rust", "code": "\nfn main() {\n    let arr = vec![1, 2, 3, 4, 5, 6, 7, 8, 9];\n\n    // using fold\n    let sum = arr.iter().fold(0i32, |a, &b| a + b);\n    let product = arr.iter().fold(1i32, |a, &b| a * b);\n    println!(\"the sum is {} and the product is {}\", sum, product);\n\n    // or using sum and product\n    let sum = arr.iter().sum::<i32>();\n    let product = arr.iter().product::<i32>();\n    println!(\"the sum is {} and the product is {}\", sum, product);\n}\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Swift", "code": "\nlet a = [1, 2, 3, 4, 5]\nprintln(a.reduce(0, +)) // prints 15\nprintln(a.reduce(1, *)) // prints 120\n\nprintln(reduce(a, 0, +)) // prints 15\nprintln(reduce(a, 1, *)) // prints 120\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "R", "code": "\ntotal <- sum(1:5)\nproduct <- prod(1:5)\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. array-sum-and-product.\n\n       DATA DIVISION.\n       WORKING-STORAGE SECTION.\n       78  Array-Size              VALUE 10.\n       01  array-area              VALUE \"01020304050607080910\".\n           03  array               PIC 99 OCCURS Array-Size TIMES.\n\n       01  array-sum               PIC 9(8).\n       01  array-product           PIC 9(10) VALUE 1.\n\n       01  i                       PIC 99.\n\n       PROCEDURE DIVISION.\n           PERFORM VARYING i FROM 1 BY 1 UNTIL Array-Size < i\n               ADD array (i) TO array-sum\n               MULTIPLY array (i) BY array-product\n           END-PERFORM\n\n           DISPLAY \"Sum:     \" array-sum\n           DISPLAY \"Product: \" array-product\n\n           GOBACK\n           .\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Ada", "code": "\ntype Int_Array is array(Integer range <>) of Integer;\n\narray : Int_Array := (1,2,3,4,5,6,7,8,9,10);\nSum : Integer := 0;\nfor I in array'range loop\n   Sum := Sum + array(I);\nend loop;\n\n\nfunction Product(Item : Int_Array) return Integer is\n  Prod : Integer := 1;\nbegin\n  for I in Item'range loop\n     Prod := Prod * Item(I);\n  end loop;\n  return Prod;\nend Product;\n\n\n", "explain": "Define the product function\nThis function will raise the predefined exception Constraint_Error if the product overflows the values represented by type Integer\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Julia", "code": "\njulia> sum([4,6,8])\n18\n\njulia> +((1:10)...)\n55\n\njulia +([1,2,3]...)\n6\n\njulia> prod([4,6,8])\n192\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "SAS", "code": "\ndata _null_;\n   array a{*} a1-a100;\n   do i=1 to 100;\n      a{i}=i*i;\n   end;\n   b=sum(of a{*});\n   put b c;\nrun;\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nfun main(args: Array<String>) {\n    val a = intArrayOf(1, 5, 8, 11, 15)\n    println(\"Array contains\u00a0: ${a.contentToString()}\")\n    val sum = a.sum()\n    println(\"Sum is $sum\")\n    val product = a.fold(1) { acc, i -> acc * i }\n    println(\"Product is $product\")\n}\n\n\nOutput:\nArray contains\u00a0: [1, 5, 8, 11, 15]\nSum is 40\nProduct is 6600\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Perl", "code": "\nmy @list = ( 1, 2, 3 );\n\nmy ( $sum, $prod ) = ( 0, 1 );\n$sum  += $_ foreach @list;\n$prod *= $_ foreach @list;\n\nuse List::Util qw/sum0 product/;\nmy @list = (1..9);\n\nsay \"Sum: \", sum0(@list);    # sum0 returns 0 for an empty list\nsay \"Product: \", product(@list);\n\nOutput:\nSum: 45\nProduct: 362880\n", "explain": "Or using the List::Util module:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Objective-C", "code": "\nWorks with: GCC version 4.0.1 (apple)\n\n- (float) sum:(NSMutableArray *)array\n{ \n\tint i, sum, value;\n\tsum = 0;\n\tvalue = 0;\n\t\n\tfor (i = 0; i < [array count]; i++) {\n\t\tvalue = [[array objectAtIndex: i] intValue];\n\t\tsum += value;\n\t}\n\t\n\treturn suml;\n}\n\n\n- (float) prod:(NSMutableArray *)array\n{ \n\tint i, prod, value;\n\tprod = 0;\n\tvalue = 0;\n\t\n\tfor (i = 0; i < [array count]; i++) {\n\t\tvalue = [[array objectAtIndex: i] intValue];\n\t\tprod *= value;\n\t}\n\t\n\treturn suml;\n}\n\n", "explain": "Sum:\nProduct:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Prolog", "code": "\nsum([],0).\nsum([H|T],X)\u00a0:- sum(T,Y), X is H + Y.\nproduct([],1).\nproduct([H|T],X)\u00a0:- product(T,Y), X is H * X.\n\n:- sum([1,2,3,4,5,6,7,8,9],X).\nX =45;\n:- product([1,2,3,4,5],X).\nX = 120;\n\n\nadd(A,B,R):-\n    R is A + B.\n\nmul(A,B,R):-\n    R is A * B.\n\n% define fold now.\nfold([], Act, Init, Init).\n\nfold(Lst, Act, Init, Res):-\n    head(Lst,Hd),\n    tail(Lst,Tl),\n    apply(Act,[Init, Hd, Ra]),\n    fold(Tl, Act, Ra, Res).\n\nsumproduct(Lst, Sum, Prod):-\n    fold(Lst,mul,1, Prod),\n    fold(Lst,add,0, Sum).\n\n?- sumproduct([1,2,3,4],Sum,Prod).\nSum = 10,\nProd = 24 .\n", "explain": "test\n\nUsing fold\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Lua", "code": "\nfunction sumf(a, ...) return a and a + sumf(...) or 0 end\nfunction sumt(t) return sumf(unpack(t)) end\nfunction prodf(a, ...) return a and a * prodf(...) or 1 end\nfunction prodt(t) return prodf(unpack(t)) end\n\nprint(sumt{1, 2, 3, 4, 5})\nprint(prodt{1, 2, 3, 4, 5})\n\nfunction table.sum(arr, length) \n      --same as if <> then <> else <>\n      return length == 1 and arr[1] or arr[length] + table.sum(arr, length -1)\nend\n\nfunction table.product(arr, length)\n      return length == 1 and arr[1] or arr[length] * table.product(arr, length -1)\nend\n\nt = {1,2,3}\nprint(table.sum(t,#t))\nprint(table.product(t,3))\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Scala", "code": "\nval seq = Seq(1, 2, 3, 4, 5)\nval sum = seq.foldLeft(0)(_ + _)\nval product = seq.foldLeft(1)(_ * _)\n\nval sum = seq.sum\nval product = seq.product\n\n", "explain": "Or even shorter:\nWorks with all data types for which a Numeric implicit is available.\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "D", "code": "\nimport std.stdio;\n\nvoid main() {\n    immutable array = [1, 2, 3, 4, 5];\n\n    int sum = 0;\n    int prod = 1;\n\n    foreach (x; array) {\n        sum += x;\n        prod *= x;\n    }\n\n    writeln(\"Sum: \", sum);\n    writeln(\"Product: \", prod);\n}\n\n\nOutput:\nSum: 15\nProduct: 120\n\nimport std.stdio, std.algorithm, std.typecons;\n\nvoid main() {\n    immutable array = [1, 2, 3, 4, 5];\n\n    // Results are stored in a 2-tuple\n    immutable r = reduce!(q{a + b}, q{a * b})(tuple(0, 1), array);\n\n    writeln(\"Sum: \", r[0]);\n    writeln(\"Product: \", r[1]);\n}\n\n", "explain": "Compute sum and product of array in one pass (same output):\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Haskell", "code": "\n\nvalues = [1..10]\n\ns = sum values           -- the easy way\np = product values\n\ns1 = foldl (+) 0 values  -- the hard way\np1 = foldl (*) 1 values\n\n\nimport Data.Array\n\nvalues = listArray (1,10) [1..10]\n\ns = sum . elems $ values\np = product . elems $ values\n\n\nimport Data.Array (listArray, elems)\n\nmain :: IO ()\nmain = mapM_ print $ [sum, product] <*> [elems $ listArray (1, 10) [11 .. 20]]\n\n\nOutput:\n155\n670442572800\n", "explain": "For lists, sum and product are already defined in the Prelude: \nTo do the same for an array, just convert it lazily to a list:\nOr perhaps:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "VBScript", "code": "\nFunction sum_and_product(arr)\n\tsum = 0\n\tproduct = 1\n\tFor i = 0 To UBound(arr)\n\t\tsum = sum + arr(i)\n\t\tproduct = product * arr(i)\n\tNext\n\tWScript.StdOut.Write \"Sum: \" & sum\n\tWScript.StdOut.WriteLine\n\tWScript.StdOut.Write \"Product: \" & product\n\tWScript.StdOut.WriteLine\nEnd Function\n\nmyarray = Array(1,2,3,4,5,6)\nsum_and_product(myarray)\n\nOutput:\nSum: 21\nProduct: 720\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Scheme", "code": "\n(apply + '(1 2 3 4 5))\n(apply * '(1 2 3 4 5))\n\n(define (reduce f i l)\n  (if (null? l)\n    i\n    (reduce f (f i (car l)) (cdr l))))\n\n(reduce + 0 '(1 2 3 4 5))\u00a0;; 0 is unit for +\n(reduce * 1 '(1 2 3 4 5))\u00a0;; 1 is unit for *\n", "explain": "A tail-recursive solution, without the n-ary operator \"trick\". Because Scheme supports tail call optimization, this is as space-efficient as an imperative loop.\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "PowerShell", "code": "\n\nfunction Get-Sum ($a) {\n    return ($a | Measure-Object -Sum).Sum\n}\n\nfunction Get-Product ($a) {\n    if ($a.Length -eq 0) {\n        return 0\n    } else {\n        $p = 1\n        foreach ($x in $a) {\n            $p *= $x\n        }\n        return $p\n    }\n}\n\nWorks with: PowerShell version 2\nfunction Get-Product ($a) {\n    if ($a.Length -eq 0) {\n        return 0\n    }\n    $s = $a -join '*'\n    return (Invoke-Expression $s)\n}\n\nfunction Get-SumAndProduct ($a) {\n    $sum = 0\n    if ($a.Length -eq 0) {\n        $prod = 0\n    } else {\n        $prod = 1\n        foreach ($x in $a) {\n            $sum += $x\n            $prod *= $x\n        }\n    }\n    $ret = New-Object PSObject\n    $ret | Add-Member NoteProperty Sum $sum\n    $ret | Add-Member NoteProperty Product $prod\n    return $ret\n}\n\nOutput:\nPS> Get-SumAndProduct 5,9,7,2,3,8,4\n\nSum Product\n--- -------\n 38   60480\n", "explain": "The Measure-Object cmdlet already knows how to compute a sum:\nBut not how to compute a product:\nOne could also let PowerShell do all the work by simply creating an expression to evaluate:\nEven nicer, however, is a function which computes both at once and returns a custom object with appropriate properties:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Logo", "code": "\nprint apply \"sum arraytolist {1 2 3 4 5}\nprint apply \"product arraytolist {1 2 3 4 5}\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "ColdFusion", "code": "\n\n<cfset Variables.myArray = [1,2,3,4,5,6,7,8,9,10]>\n<cfoutput>#ArraySum(Variables.myArray)#</cfoutput>\n\n\n<cfset Variables.myArray = [1,2,3,4,5,6,7,8,9,10]>\n<cfset Variables.Product = 1>\n<cfloop array=\"#Variables.myArray#\" index=\"i\">\n <cfset Variables.Product *= i>\n</cfloop>\n<cfoutput>#Variables.Product#</cfoutput>\n\n", "explain": "Sum of an Array,\nProduct of an Array,\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "F#", "code": "\nlet numbers = [| 1..10 |]\nlet sum = numbers |> Array.sum\nlet product = numbers |> Array.reduce (*)\n\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Groovy", "code": "\n\n[1,2,3,4,5].sum()\n\n\n[1,2,3,4,5].inject(0) { sum, val -> sum + val }\n[1,2,3,4,5].inject(1) { prod, val -> prod * val }\n\n\nprintln ([1,2,3,4,5].inject([sum: 0, product: 1]) { result, value ->\n    [sum: result.sum + value, product: result.product * value]})\n\n", "explain": "Groovy adds a \"sum()\" method for collections, but not a \"product()\" method:\nHowever, for general purpose \"reduction\" or \"folding\" operations, Groovy does provide an \"inject()\" method for collections similar to \"inject\" in Ruby.\nYou can also combine these operations:\n"}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "Zig", "code": "\nconst print = @import(\"std\").debug.print;\npub fn main() void {\n  const numbers = [_]u8{ 1, 2, 3, 4, 5 };\n  var sum: u8 = 0;\n  var product: u8 = 1;\n  for (numbers) |number| {\n    product *= number;\n    sum += number;\n  }\n  print(\"{} {}\\n\", .{ product, sum });\n}\n", "explain": ""}, {"task_name": "Sum and product of an array", "task_url": "https://rosettacode.org/wiki/Sum_and_product_of_an_array", "task_cat": "Iteration", "lang": "AWK", "code": "\n\n$ awk 'func sum(s){split(s,a);r=0;for(i in a)r+=a[i];return r}{print sum($0)}'\n1 2 3 4 5 6 7 8 9 10\n55\n\n$ awk 'func prod(s){split(s,a);r=1;for(i in a)r*=a[i];return r}{print prod($0)}'\n1 2 3 4 5 6 7 8 9 10\n3628800\n\n", "explain": "For array input, it is easiest to \"deserialize\" it from a string with the split() function.\n"}]