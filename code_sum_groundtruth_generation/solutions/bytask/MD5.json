[{"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Python", "code": "\n\nPython 3.x, 2.5 and later 2.x versions\n\n>>> import hashlib\n>>> # RFC 1321    test suite:\n>>> tests = (\n  (b\"\", 'd41d8cd98f00b204e9800998ecf8427e'),\n  (b\"a\", '0cc175b9c0f1b6a831c399e269772661'),\n  (b\"abc\", '900150983cd24fb0d6963f7d28e17f72'),\n  (b\"message digest\", 'f96b697d7cb7938d525a2f31aaf161d0'),\n  (b\"abcdefghijklmnopqrstuvwxyz\", 'c3fcd3d76192e4007dfb496cca67e13b'),\n  (b\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\", 'd174ab98d277d9f5a5611c2c9f419d9f'),\n  (b\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\", '57edf4a22be3c955ac49da2e2107b67a') )\n>>> for text, golden in tests: assert hashlib.md5(text).hexdigest() == golden\n\n>>>\n\nPython 2.5 and later\n\n>>> import hashlib\n>>> print hashlib.md5(\"The quick brown fox jumped over the lazy dog's back\").hexdigest()\ne38ca1d920c4b8b8d3946b2c72f01680\n\nPre-2.5; removed in 3.x\n\n>>> import md5\n>>> print md5.md5(\"The quick brown fox jumped over the lazy dog's back\").hexdigest()\ne38ca1d920c4b8b8d3946b2c72f01680\n\n", "explain": "Using builtin libraries:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "C", "code": "\nLibrary: OpenSSL\n#include <stdio.h>\n#include <stdlib.h>\n#include <string.h>\n#include <openssl/md5.h>\n\nconst char *string = \"The quick brown fox jumped over the lazy dog's back\";\n\nint main()\n{\n  int i;\n  unsigned char result[MD5_DIGEST_LENGTH];\n\n  MD5(string, strlen(string), result);\n\n  // output\n  for(i = 0; i < MD5_DIGEST_LENGTH; i++)\n    printf(\"%02x\", result[i]);\n  printf(\"\\n\");\n\n  return EXIT_SUCCESS;\n}\n\n\n#include <stdlib.h>\n#include <stdio.h>\n#include <string.h>\n#include <math.h>\n\ntypedef union uwb {\n    unsigned w;\n    unsigned char b[4];\n} WBunion;\n\ntypedef unsigned Digest[4];\n\nunsigned f0( unsigned abcd[] ){\n    return ( abcd[1] & abcd[2]) | (~abcd[1] & abcd[3]);}\n\nunsigned f1( unsigned abcd[] ){\n    return ( abcd[3] & abcd[1]) | (~abcd[3] & abcd[2]);}\n\nunsigned f2( unsigned abcd[] ){\n    return  abcd[1] ^ abcd[2] ^ abcd[3];}\n\nunsigned f3( unsigned abcd[] ){\n    return abcd[2] ^ (abcd[1] |~ abcd[3]);}\n\ntypedef unsigned (*DgstFctn)(unsigned a[]);\n\nunsigned *calcKs( unsigned *k)\n{\n    double s, pwr;\n    int i;\n\n    pwr = pow( 2, 32);\n    for (i=0; i<64; i++) {\n        s = fabs(sin(1+i));\n        k[i] = (unsigned)( s * pwr );\n    }\n    return k;\n}\n\n// ROtate v Left by amt bits\nunsigned rol( unsigned v, short amt )\n{\n    unsigned  msk1 = (1<<amt) -1;\n    return ((v>>(32-amt)) & msk1) | ((v<<amt) & ~msk1);\n}\n\nunsigned *md5( const char *msg, int mlen) \n{\n    static Digest h0 = { 0x67452301, 0xEFCDAB89, 0x98BADCFE, 0x10325476 };\n//    static Digest h0 = { 0x01234567, 0x89ABCDEF, 0xFEDCBA98, 0x76543210 };\n    static DgstFctn ff[] = { &f0, &f1, &f2, &f3 };\n    static short M[] = { 1, 5, 3, 7 };\n    static short O[] = { 0, 1, 5, 0 };\n    static short rot0[] = { 7,12,17,22};\n    static short rot1[] = { 5, 9,14,20};\n    static short rot2[] = { 4,11,16,23};\n    static short rot3[] = { 6,10,15,21};\n    static short *rots[] = {rot0, rot1, rot2, rot3 };\n    static unsigned kspace[64];\n    static unsigned *k;\n\n    static Digest h;\n    Digest abcd;\n    DgstFctn fctn;\n    short m, o, g;\n    unsigned f;\n    short *rotn;\n    union {\n        unsigned w[16];\n        char     b[64];\n    }mm;\n    int os = 0;\n    int grp, grps, q, p;\n    unsigned char *msg2;\n\n    if (k==NULL) k= calcKs(kspace);\n\n    for (q=0; q<4; q++) h[q] = h0[q];   // initialize\n\n    {\n        grps  = 1 + (mlen+8)/64;\n        msg2 = malloc( 64*grps);\n        memcpy( msg2, msg, mlen);\n        msg2[mlen] = (unsigned char)0x80;  \n        q = mlen + 1;\n        while (q < 64*grps){ msg2[q] = 0; q++ ; }\n        {\n//            unsigned char t;\n            WBunion u;\n            u.w = 8*mlen;\n//            t = u.b[0]; u.b[0] = u.b[3]; u.b[3] = t;\n//            t = u.b[1]; u.b[1] = u.b[2]; u.b[2] = t;\n            q -= 8;\n            memcpy(msg2+q, &u.w, 4 );\n        }\n    }\n\n    for (grp=0; grp<grps; grp++)\n    {\n        memcpy( mm.b, msg2+os, 64);\n        for(q=0;q<4;q++) abcd[q] = h[q];\n        for (p = 0; p<4; p++) {\n            fctn = ff[p];\n            rotn = rots[p];\n            m = M[p]; o= O[p];\n            for (q=0; q<16; q++) {\n                g = (m*q + o) % 16;\n                f = abcd[1] + rol( abcd[0]+ fctn(abcd) + k[q+16*p] + mm.w[g], rotn[q%4]);\n\n                abcd[0] = abcd[3];\n                abcd[3] = abcd[2];\n                abcd[2] = abcd[1];\n                abcd[1] = f;\n            }\n        }\n        for (p=0; p<4; p++)\n            h[p] += abcd[p];\n        os += 64;\n    }\n\n    if( msg2 )\n        free( msg2 );\n\n    return h;\n}    \n\nint main( int argc, char *argv[] )\n{\n    int j,k;\n    const char *msg = \"The quick brown fox jumps over the lazy dog.\";\n    unsigned *d = md5(msg, strlen(msg));\n    WBunion u;\n\n    printf(\"= 0x\");\n    for (j=0;j<4; j++){\n        u.w = d[j];\n        for (k=0;k<4;k++) printf(\"%02x\",u.b[k]);\n    }\n    printf(\"\\n\");\n\n    return 0;\n}\n\n", "explain": "Implementation of md5 \n(Needs review - differences observed for the last 8 characters when compared with openssl implementation)\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "C++", "code": "\nLibrary: Poco Crypto\n#include <string>\n#include <iostream>\n#include \"Poco/MD5Engine.h\"\n#include \"Poco/DigestStream.h\"\n\nusing Poco::DigestEngine ;\nusing Poco::MD5Engine ;\nusing Poco::DigestOutputStream ;\n\nint main( ) {\n   std::string myphrase ( \"The quick brown fox jumped over the lazy dog's back\" ) ;\n   MD5Engine md5 ;\n   DigestOutputStream outstr( md5 ) ;\n   outstr << myphrase ;\n   outstr.flush( ) ; //to pass everything to the digest engine\n   const DigestEngine::Digest& digest = md5.digest( ) ;\n   std::cout << myphrase << \" as a MD5 digest\u00a0:\\n\" << DigestEngine::digestToHex( digest ) \n      << \"\u00a0!\" << std::endl ;\n   return 0 ;\n}\n\n\nOutput:\nThe quick brown fox jumped over the lazy dog's back as a MD5 digest\u00a0:\ne38ca1d920c4b8b8d3946b2c72f01680\u00a0!\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Java", "code": "\nimport java.nio.charset.StandardCharsets;\nimport java.security.MessageDigest;\nimport java.security.NoSuchAlgorithmException;\n\npublic class Digester {\n\n    public static void main(String[] args) {\n        System.out.println(hexDigest(\"Rosetta code\", \"MD5\"));\n    }\n\n    static String hexDigest(String str, String digestName) {\n        try {\n            MessageDigest md = MessageDigest.getInstance(digestName);\n            byte[] digest = md.digest(str.getBytes(StandardCharsets.UTF_8));\n            char[] hex = new char[digest.length * 2];\n            for (int i = 0; i < digest.length; i++) {\n                hex[2 * i] = \"0123456789abcdef\".charAt((digest[i] & 0xf0) >> 4);\n                hex[2 * i + 1] = \"0123456789abcdef\".charAt(digest[i] & 0x0f);\n            }\n            return new String(hex);\n        } catch (NoSuchAlgorithmException e) {\n            throw new IllegalStateException(e);\n        }\n    }\n}\n\n\n", "explain": "Other options for digest algorithms (to replace \"MD5\" in the example above) include: MD2, SHA-1, SHA-256, SHA-384, and SHA-512.\nOther encoding options (to replace \"UTF_8\" in the example above) are available from the Charset and StandardCharsets classes.\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "C#", "code": "\nusing System.Text;\nusing System.Security.Cryptography;\n\nbyte[] data = Encoding.ASCII.GetBytes(\"The quick brown fox jumped over the lazy dog's back\");\nbyte[] hash = MD5.Create().ComputeHash(data);\nConsole.WriteLine(BitConverter.ToString(hash).Replace(\"-\", \"\").ToLower());\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Visual_Basic_.NET", "code": "\nWorks with: Visual Basic .NET version 9.0+\nImports System.Security.Cryptography\nImports System.Text\n\nModule MD5hash\n    Sub Main(args As String())\n        Console.WriteLine(GetMD5(\"Visual Basic .Net\"))\n    End Sub\n\n    Private Function GetMD5(plainText As String) As String\n        Dim hash As String = \"\"\n\n        Using hashObject As MD5 = MD5.Create()\n            Dim ptBytes As Byte() = hashObject.ComputeHash(Encoding.UTF8.GetBytes(plainText))\n            Dim hashBuilder As New StringBuilder\n\n            For i As Integer = 0 To ptBytes.Length - 1\n                hashBuilder.Append(ptBytes(i).ToString(\"X2\"))\n            Next\n            hash = hashBuilder.ToString\n        End Using\n\n        Return hash\n    End Function\n\nEnd Module\n\n\nOutput:\nAF397EA30996B22759740AC66452D47A\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "SQL", "code": "\nWorks with: MySQL\nSELECT MD5('The quick brown fox jumped over the lazy dog\\'s back')\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "PHP", "code": "\n$string = \"The quick brown fox jumped over the lazy dog's back\";\necho md5( $string );\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "MATLAB", "code": "\n\nfunction digest = md5(message)\n    % digest = md5(message)\n    %  Compute the MD5 digest of the message, as a hexadecimal digest.\n\n    % Follow the MD5 algorithm from RFC 1321 [1] and Wikipedia [2].\n    %  [1] http://tools.ietf.org/html/rfc1321\n    %  [2] http://en.wikipedia.org/wiki/MD5\n\n    % m is the modulus for 32-bit unsigned arithmetic.\n    m = 2 ^ 32;\n\n    % s is the shift table for circshift(). Each shift is negative\n    % because it is a left shift.\n    s = [-7, -12, -17, -22\n         -5,  -9, -14, -20\n         -4, -11, -16, -23\n         -6, -10, -15, -21];\n\n    % t is the sine table. Each sine is a 32-bit integer, unsigned.\n    t = floor(abs(sin(1:64)) .* m);\n\n    % Initialize the hash, as a row vector of 32-bit integers.\n    digest = [hex2dec('67452301') ...\n              hex2dec('EFCDAB89') ...\n              hex2dec('98BADCFE') ...\n              hex2dec('10325476')];\n\n    % If message contains characters, convert them to ASCII values.\n    message = double(message);\n    bytelen = numel(message);\n\n    % Pad the message by appending a 1, then appending enough 0s to make\n    % the bit length congruent to 448 mod 512. Because we have bytes, we\n    % append 128 '10000000', then append enough 0s '00000000's to make\n    % the byte length congruent to 56 mod 64.\n    message = [message, 128, zeros(1, mod(55 - bytelen, 64))];\n\n    % Convert the message to 32-bit integers, little endian.\n    % For little endian, first byte is least significant byte.\n    message = reshape(message, 4, numel(message) / 4);\n    message = message(1,:) + ...           \u00a0% least significant byte\n              message(2,:) * 256 + ...\n              message(3,:) * 65536 + ...\n              message(4,:) * 16777216;      % most significant byte\n\n    % Append the bit length as a 64-bit integer, little endian.\n    bitlen = bytelen * 8;\n    message = [message, mod(bitlen, m), mod(bitlen / m, m)];\n\n    % Process each 512-bit block. Because we have 32-bit integers, each\n    % block has 16 elements, message(k + (0:15)).\n    for k = 1:16:numel(message)\n        % Copy hash.\n        a = digest(1); b = digest(2); c = digest(3); d = digest(4);\n\n        % Do 64 operations.\n        for i = (1:64)\n            % Convert b, c, d to row vectors of bits (0s and 1s).\n            bv = dec2bin(b, 32) - '0';\n            cv = dec2bin(c, 32) - '0';\n            dv = dec2bin(d, 32) - '0';\n\n            % Find f  = mix of b, c, d.\n            %      ki = index in 0:15, to message(k + ki).\n            %      sr = row in 1:4, to s(sr,\u00a0:).\n            if i <= 16          % Round 1\n                f = (bv & cv) | (~bv & dv);\n                ki = i - 1;\n                sr = 1;\n            elseif i <= 32      % Round 2\n                f = (bv & dv) | (cv & ~dv);\n                ki = mod(5 * i - 4, 16);\n                sr = 2;\n            elseif i <= 48      % Round 3\n                f = xor(bv, xor(cv, dv));\n                ki = mod(3 * i + 2, 16);\n                sr = 3;\n            else                % Round 4\n                f = xor(cv, bv | ~dv);\n                ki = mod(7 * i - 7, 16);\n                sr = 4;\n            end\n\n            % Convert f, from row vector of bits, to 32-bit integer.\n            f = bin2dec(char(f + '0'));\n\n            % Do circular shift of sum.\n            sc = mod(i - 1, 4) + 1;\n            sum = mod(a + f + message(k + ki) + t(i), m);\n            sum = dec2bin(sum, 32);\n            sum = circshift(sum, [0, s(sr, sc)]);\n            sum = bin2dec(sum);\n\n            % Update a, b, c, d.\n            temp = d;\n            d = c;\n            c = b;\n            b = mod(b + sum, m);\n            a = temp;\n        end %for i\n\n        % Add hash of this block to hash of previous blocks.\n        digest = mod(digest + [a, b, c, d], m);\n    end %for k\n\n    % Convert hash from 32-bit integers, little endian, to bytes.\n    digest = [digest                % least significant byte\n              digest / 256\n              digest / 65536\n              digest / 16777216];   % most significant byte\n    digest = reshape(mod(floor(digest), 256), 1, numel(digest));\n\n    % Convert hash to hexadecimal.\n    digest = dec2hex(digest);\n    digest = reshape(transpose(digest), 1, numel(digest));\nend %md5\n\n\noctave:14> md5('Rosetta Code')\nans = CCA1BF66B09554E10F837838C3D3EFB1\n\n", "explain": "This code also works with Octave (but Octave already provides md5sum(), see Octave example).\nSample Usage:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Fortran", "code": "\nIntel Fortran on Windows[edit]\n\nmodule md5_mod\n    use kernel32\n    use advapi32\n    implicit none\n    integer, parameter :: MD5LEN = 16\ncontains\n    subroutine md5hash(name, hash, dwStatus, filesize)\n        implicit none\n        character(*) :: name\n        integer, parameter :: BUFLEN = 32768\n        integer(HANDLE) :: hFile, hProv, hHash\n        integer(DWORD) :: dwStatus, nRead\n        integer(BOOL) :: status\n        integer(BYTE) :: buffer(BUFLEN)\n        integer(BYTE) :: hash(MD5LEN)\n        integer(UINT64) :: filesize\n \n        dwStatus = 0\n        filesize = 0\n        hFile = CreateFile(trim(name) // char(0), GENERIC_READ, FILE_SHARE_READ, NULL, &\n                           OPEN_EXISTING, FILE_FLAG_SEQUENTIAL_SCAN, NULL)\n \n        if (hFile == INVALID_HANDLE_VALUE) then\n            dwStatus = GetLastError()\n            print *, \"CreateFile failed.\"\n            return\n        end if\n \n        if (CryptAcquireContext(hProv, NULL, NULL, PROV_RSA_FULL, &\n                                CRYPT_VERIFYCONTEXT) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptAcquireContext failed.\"\n            goto 3\n        end if\n \n        if (CryptCreateHash(hProv, CALG_MD5, 0_ULONG_PTR, 0_DWORD, hHash) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptCreateHash failed.\"\n            go to 2\n        end if\n \n        do\n            status = ReadFile(hFile, loc(buffer), BUFLEN, nRead, NULL)\n            if (status == FALSE .or. nRead == 0) exit\n            filesize = filesize + nRead\n            if (CryptHashData(hHash, buffer, nRead, 0) == FALSE) then\n                dwStatus = GetLastError()\n                print *, \"CryptHashData failed.\"\n                go to 1\n            end if\n        end do\n \n        if (status == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"ReadFile failed.\"\n            go to 1\n        end if\n \n        nRead = MD5LEN\n        if (CryptGetHashParam(hHash, HP_HASHVAL, hash, nRead, 0) == FALSE) then\n            dwStatus = GetLastError()\n            print *, \"CryptGetHashParam failed.\", status, nRead, dwStatus\n        end if\n \n      1 status = CryptDestroyHash(hHash)\n      2 status = CryptReleaseContext(hProv, 0)\n      3 status = CloseHandle(hFile)\n    end subroutine\nend module\n \nprogram md5\n    use md5_mod\n    implicit none\n    integer :: n, m, i, j\n    character(:), allocatable :: name\n    integer(DWORD) :: dwStatus\n    integer(BYTE) :: hash(MD5LEN)\n    integer(UINT64) :: filesize\n \n    n = command_argument_count()\n    do i = 1, n\n        call get_command_argument(i, length=m)\n        allocate(character(m) :: name)\n        call get_command_argument(i, name)\n        call md5hash(name, hash, dwStatus, filesize)\n        if (dwStatus == 0) then\n            do j = 1, MD5LEN\n                write(*, \"(Z2.2)\", advance=\"NO\") hash(j)\n            end do\n            write(*, \"(' ',A,' (',G0,' bytes)')\") name, filesize\n        end if\n        deallocate(name)\n    end do\nend program\n\n", "explain": "Using Windows API. See CryptAcquireContextA, CryptCreateHash, CryptHashData and CryptGetHashParam in Microsoft documentation.\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"crypto/md5\"\n    \"fmt\"\n)\n\nfunc main() {\n    for _, p := range [][2]string{\n        // RFC 1321 test cases\n        {\"d41d8cd98f00b204e9800998ecf8427e\", \"\"},\n        {\"0cc175b9c0f1b6a831c399e269772661\", \"a\"},\n        {\"900150983cd24fb0d6963f7d28e17f72\", \"abc\"},\n        {\"f96b697d7cb7938d525a2f31aaf161d0\", \"message digest\"},\n        {\"c3fcd3d76192e4007dfb496cca67e13b\", \"abcdefghijklmnopqrstuvwxyz\"},\n        {\"d174ab98d277d9f5a5611c2c9f419d9f\",\n            \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"},\n        {\"57edf4a22be3c955ac49da2e2107b67a\", \"12345678901234567890\" +\n            \"123456789012345678901234567890123456789012345678901234567890\"},\n        // test case popular with other RC solutions\n        {\"e38ca1d920c4b8b8d3946b2c72f01680\",\n            \"The quick brown fox jumped over the lazy dog's back\"},\n    } {\n        validate(p[0], p[1])\n    }\n}\n\nvar h = md5.New()\n\nfunc validate(check, s string) {\n    h.Reset()\n    h.Write([]byte(s))\n    sum := fmt.Sprintf(\"%x\", h.Sum(nil))\n    if sum != check {\n        fmt.Println(\"MD5 fail\")\n        fmt.Println(\"  for string,\", s)\n        fmt.Println(\"  expected:  \", check)\n        fmt.Println(\"  got:       \", sum)\n    }\n}\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi  or android 32 bits with application Termux\n/* ARM assembly Raspberry PI  */\n/*  program MD5.s   */\n\n/* REMARK 1\u00a0: this program use routines in a include file \n   see task Include a file language arm assembly \n   for the routine affichageMess conversion10 \n   see at end of this program the instruction include */\n/* for constantes see task include a file in arm assembly */\n/************************************/\n/* Constantes                       */\n/************************************/\n.include \"../constantes.inc\"\n\n.equ LGHASH, 16                  // result length \n.equ ZWORKSIZE,        1000      // work area size\n\n/*******************************************/\n/* Structures                               */\n/********************************************/\n/* example structure  variables  */\n    .struct  0\nvar_a:                     // a\n    .struct  var_a + 4\nvar_b:                     // b\n    .struct  var_b + 4\nvar_c:                     // c\n    .struct  var_c + 4\nvar_d:                     // d\n    .struct  var_d + 4\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessTest1:           .asciz \"abc\" \nszMessTest4:           .asciz \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"\nszMessTest2:           .asciz \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"\nszMessTest3:           .asciz \"abcdefghijklmnopqrstuvwxyz\"\nszMessFinPgm:          .asciz \"Program End ok.\\n\"\nszMessResult:          .asciz \"Result for \"\nszMessResult1:         .asciz \" => \"\nszMessSizeError:       .asciz \"\\033[31mWork area too small\u00a0!! \\033[0m \\n\"\nszCarriageReturn:   .asciz \"\\n\"\n\n.align 4\n/* array constantes K */\ntbConstK:  .int 0xd76aa478,0xe8c7b756,0x242070db,0xc1bdceee\n           .int 0xf57c0faf,0x4787c62a,0xa8304613,0xfd469501\n           .int 0x698098d8,0x8b44f7af,0xffff5bb1,0x895cd7be\n           .int 0x6b901122,0xfd987193,0xa679438e,0x49b40821\n           .int 0xf61e2562,0xc040b340,0x265e5a51,0xe9b6c7aa\n           .int 0xd62f105d,0x2441453,0xd8a1e681,0xe7d3fbc8\n           .int 0x21e1cde6,0xc33707d6,0xf4d50d87,0x455a14ed\n           .int 0xa9e3e905,0xfcefa3f8,0x676f02d9,0x8d2a4c8a\n           .int 0xfffa3942,0x8771f681,0x6d9d6122,0xfde5380c\n           .int 0xa4beea44,0x4bdecfa9,0xf6bb4b60,0xbebfbc70\n           .int 0x289b7ec6,0xeaa127fa,0xd4ef3085,0x4881d05\n           .int 0xd9d4d039,0xe6db99e5,0x1fa27cf8,0xc4ac5665\n           .int 0xf4292244,0x432aff97,0xab9423a7,0xfc93a039\n           .int 0x655b59c3,0x8f0ccc92,0xffeff47d,0x85845dd1\n           .int 0x6fa87e4f,0xfe2ce6e0,0xa3014314,0x4e0811a1\n           .int 0xf7537e82,0xbd3af235,0x2ad7d2bb,0xeb86d391  \n\n/* array rotation coef R */\ntbRotaR:   .int  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22,  7, 12, 17, 22\n           .int  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20,  5,  9, 14, 20\n           .int  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23,  4, 11, 16, 23\n           .int  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21,  6, 10, 15, 21\n\ntbConstH:            .int 0x67452301       // H0\n                     .int 0xEFCDAB89       // H1\n                     .int 0x98BADCFE       // H2\n                     .int 0x10325476       // H3\n\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss\n.align 4\nsZoneConv:                   .skip 24\ntbH:                         .skip 4 * 4         @ 4 variables H\ntbabcd:                      .skip 4 * 4         @ 4 variables a b c d\nsZoneTrav:                   .skip 1000\n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                           @ entry of program \n                      \n    ldr r0,iAdrszMessTest1\n    bl computeExemple\n    \n    ldr r0,iAdrszMessTest2\n    bl computeExemple\n    \n    ldr r0,iAdrszMessTest3\n    bl computeExemple\n    \n    ldr r0,iAdrszMessTest4\n    bl computeExemple\n\n    ldr r0,iAdrszMessFinPgm\n    bl affichageMess            @ display message\n\n\n100:                            @ standard end of the program \n    mov r0, #0                  @ return code\n    mov r7, #EXIT               @ request to exit program\n    svc #0                      @ perform the system call\n \niAdrszCarriageReturn:     .int szCarriageReturn\niAdrszMessResult:         .int szMessResult\niAdrszMessResult1:        .int szMessResult1\niAdrszMessTest1:          .int szMessTest1\niAdrszMessTest2:          .int szMessTest2\niAdrszMessTest3:          .int szMessTest3\niAdrszMessTest4:          .int szMessTest4\niAdrsZoneTrav:            .int sZoneTrav\niAdrsZoneConv:            .int sZoneConv\niAdrszMessFinPgm:         .int szMessFinPgm\niAdrszMessSizeError:      .int szMessSizeError\n/***********************************************/\n/*     compute exemple                         */ \n/***********************************************/\n/* r0 contains the address of the message */\ncomputeExemple:\n    push {r1,lr}         @ save  registres\n    mov r1,r0\n    bl computeMD5        @ call routine MD5\n \n    ldr r0,iAdrszMessResult\n    bl affichageMess\n    mov r0,r1\n    bl affichageMess  \n    ldr r0,iAdrszMessResult1\n    bl affichageMess\n    ldr r0, iAdrtbH\n    bl displayMD5\n    \n100:\n    pop {r1,pc}           @ restaur registers\n\n/******************************************************************/\n/*     compute MD5                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\ncomputeMD5:\n    push {r1-r12,lr}         @ save  registres\n    ldr r1,iAdrsZoneTrav\n    mov r2,#0                @ counter length \n1:                           @ copy string in work area\n    cmp r2,#ZWORKSIZE        @ maxi\u00a0?\n    bge 99f                  @ error\n    ldrb r3,[r0,r2]\n    strb r3,[r1,r2]\n    cmp r3,#0                    \n    addne r2,r2,#1\n    bne 1b\n    lsl r6,r2,#3             @ initial message length in bits \n    mov r3,#0b10000000       @ add bit 1 at end of string\n    strb r3,[r1,r2]\n    add r2,r2,#1             @ length in bytes\n    lsl r4,r2,#3             @ length in bits\n    mov r3,#0\n2:\n    lsr r5,r2,#6\n    lsl r5,r5,#6\n    sub r5,r2,r5\n    cmp r5,#56\n    beq 3f                   @ yes -> end add\n    strb r3,[r1,r2]          @ add zero at message end\n    add r2,#1                @ increment lenght bytes \n    add r4,#8                @ increment length in bits\n    b 2b\n3:\n    str r6,[r1,r2]           @ and store length at end\n    add r5,r2,#4\n    str r3,[r1,r5]           @ store zero in hight bits for 64 bits\n\n    ldr r7,iAdrtbConstH      @ constantes H address\n    ldr r4,iAdrtbH           @ start area H\n    mov r5,#0\n4:                           @ init array H with start constantes\n    ldr r6,[r7,r5,lsl #2]    @ load constante\n    str r6,[r4,r5,lsl #2]    @ and store\n    add r5,r5,#1\n    cmp r5,#4\n    blt 4b\n                             @ split into block of 64 bytes\n    add r2,#4                @  TODO\u00a0: \u00e0 revoir\n    lsr r4,r2,#6             @ blocks number\n\n    ldr r0,iAdrtbH             @ variables H\n    ldr r1,iAdrsZoneTrav\n    ldr r5,iAdrtbConstK\n    ldr r3,iAdrtbRotaR\n    ldr r8,iAdrtbabcd\n    mov r7,#0                @ n\u00b0 de block et r1 contient l adresse zone de travail\n5:                           @ begin loop of each block of 64 bytes\n    add r2,r1,r7,lsl #6            @  compute block begin  indice * 4 * 16\n    mov r6,#0                @ indice t\n   /* COMPUTING THE MESSAGE DIGEST */\n    /* r0  variables H address */\n    /* r1  work area  */\n    /* r2  block work area begin address  */\n    /* r3  address constantes rotate */\n    /* r4  block number  */\n    /* r5  constance K address */\n    /* r6  counter t */\n    /* r7  block counter */\n    /* r8  addresse variables a b c d   */\n                                   @ init variable a b c d with variables H\n    mov r10,#0\n6:                                 @ loop init\n    ldr r9,[r0,r10,lsl #2]         @ variables H\n    str r9,[r8,r10,lsl #2]         @ variables a b c d\n    add r10,r10,#1\n    cmp r10,#4\n    blt 6b\n    \n7:                                 @ loop begin\n    cmp r6,#15\n    bgt 8f\n                                   @ cas 1 f\u00a0:= (b et c) ou ((non b) et d)\n                                   @ g\u00a0:= i\n    ldr r9,[r8,#var_b]\n    ldr r10,[r8,#var_c]\n    and r12,r10,r9\n    mvn r9,r9\n    ldr r10,[r8,#var_d]\n    and r11,r9,r10\n    orr r12,r12,r11                @ f\n    mov r9,r6                      @ g\n    b 11f\n8:\n    cmp r6,#31\n    bgt 9f\n                                   @ f\u00a0:= (d et b) ou ((non d) et c)\n                                   @ g\u00a0:= (5\u00d7i + 1) mod 16\n    ldr r9,[r8,#var_b]\n    ldr r10,[r8,#var_d]\n    and r12,r10,r9\n    mvn r10,r10\n    ldr r9,[r8,#var_c]\n    and r11,r9,r10\n    orr r12,r12,r11                @ f\n    mov r9,#5\n    mul r9,r6,r9\n    add r9,r9,#1\n    lsr r10,r9,#4\n    lsl r10,r10,#4\n    sub r9,r9,r10                  @ g\n    \n    b 11f\n9:\n    cmp r6,#47\n    bgt 10f\n                                   @ f\u00a0:= b xor c xor d\n                                   @ g\u00a0:= (3\u00d7i + 5) mod 16\n    ldr r9,[r8,#var_b]\n    ldr r10,[r8,#var_c]\n    eor r12,r10,r9\n    ldr r10,[r8,#var_d]\n    eor r12,r12,r10                @ f\n    mov r9,#3\n    mul r9,r6,r9\n    add r9,r9,#5\n    lsr r10,r9,#4\n    lsl r10,r10,#4\n    sub r9,r9,r10                  @ g\n    b 11f\n10:\n                                   @ f\u00a0:= c xor (b ou (non d))\n                                   @ g\u00a0:= (7\u00d7i) mod 16\n    ldr r10,[r8,#var_d]\n    mvn r12,r10\n    ldr r10,[r8,#var_b] \n    orr r12,r12,r10\n    ldr r10,[r8,#var_c] \n    eor r12,r12,r10                @ f\n    mov r9,#7\n    mul r9,r6,r9\n    lsr r10,r9,#4\n    lsl r10,r10,#4\n    sub r9,r9,r10                  @ g\n    \n11:\n    ldr r10,[r8,#var_d]\n    mov r11,r10                    @ save old d\n    ldr r10,[r8,#var_c]\n    str r10,[r8,#var_d]            @ new d = c\n    ldr r10,[r8,#var_b]\n    str r10,[r8,#var_c]            @ new c = b\n    ldr r10,[r8,#var_a]\n    add r12,r12,r10                @ a + f\n    ldr r10,[r2,r9,lsl #2] \n    add r12,r12,r10                @ + valeur bloc g\n    ldr r10,[r5,r6,lsl #2]\n    add r12,r12,r10                @ + valeur constante K de i\n    ldr r10,[r3,r6,lsl #2]         @ rotate left value\n    rsb r10,r10,#32                @ compute right rotate\n    ror r12,r12,r10\n    ldr r10,[r8,#var_b]\n    add r12,r12,r10\n    str r12,[r8,#var_b]            @ new b\n    str r11,[r8,#var_a]            @ new a = old d\n    \n    add r6,r6,#1\n    cmp r6,#63\n    ble 7b\n                                   @ maj area H\n    ldr r10,[r0]                   @ H0\n    ldr r11,[r8,#var_a]\n    add r10,r10,r11                @ + a\n    str r10,[r0]\n    ldr r10,[r0,#4]                @ H1\n    ldr r11,[r8,#var_b]\n    add r10,r10,r11                @ + b\n    str r10,[r0,#4]\n    ldr r10,[r0,#8]                @ H2\n    ldr r11,[r8,#var_c]\n    add r10,r10,r11                @ + c\n    str r10,[r0,#8]\n    ldr r10,[r0,#12]               @ H3\n    ldr r11,[r8,#var_d]\n    add r10,r10,r11                @ + d\n    str r10,[r0,#12]\n \n                                 @ loop other block\n    add r7,r7,#1                 @ increment block\n    cmp r7,r4                    @ maxi\u00a0?\n    ble 5b\n    \n    mov r9,#0                    @ reverse bytes loop\n12:\n    ldr r10,[r0,r9,lsl #2]\n    rev r10,r10                  @ reverse bytes\n    str r10,[r0,r9,lsl #2]\n    add r9,r9,#1\n    cmp r9,#LGHASH / 4\n    blt 12b\n    mov r0,#0                    @ routine OK\n    b 100f\n99:                              @ size error\n    ldr r0,iAdrszMessSizeError\n    bl affichageMess\n    mov r0,#-1                   @ error routine\n    \n100:\n    pop {r1-r12,pc}              @ restaur registers\niAdrtbConstH:        .int tbConstH\niAdrtbConstK:        .int tbConstK\niAdrtbRotaR:         .int tbRotaR\niAdrtbH:             .int tbH\niAdrtbabcd:          .int tbabcd\n\n/*************************************************/\n/*     display hash  MD5                         */ \n/*************************************************/\n/* r0 contains the address of hash  */\ndisplayMD5:\n    push {r1-r3,lr}                @ save  registres\n    mov r3,r0\n    mov r2,#0\n1:\n    ldr r0,[r3,r2,lsl #2]          @ load 4 bytes\n    ldr r1,iAdrsZoneConv\n    bl conversion16                @ conversion hexa\n    ldr r0,iAdrsZoneConv\n    bl affichageMess\n    add r2,r2,#1\n    cmp r2,#LGHASH / 4\n    blt 1b                         @ and loop\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess               @ display message\n100:\n    pop {r1-r3,lr}                 @ restaur registers\n    bx lr                          @ return  \n/***************************************************/\n/*      ROUTINES INCLUDE                           */\n/***************************************************/\n.include \"../affichage.inc\"\nResult for abc => 900150983CD24FB0D6963F7D28E17F72\nResult for ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789 => D174AB98D277D9F5A5611C2C9F419D9F\nResult for abcdefghijklmnopqrstuvwxyz => C3FCD3D76192E4007DFB496CCA67E13B\nResult for 12345678901234567890123456789012345678901234567890123456789012345678901234567890 => 57EDF4A22BE3C955AC49DA2E2107B67A\nProgram End ok.\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Delphi", "code": "\n\nprogram MD5Hash;\n\n{$APPTYPE CONSOLE}\n\nuses\n  SysUtils,\n  IdHashMessageDigest;\n\nfunction MD5(aValue: string): string;\nbegin\n  with TIdHashMessageDigest5.Create do\n  begin\n    Result:= HashStringAsHex(aValue);\n    Free;\n  end;\nend;\n\nbegin\n  Writeln(MD5(''));\n  Writeln(MD5('a'));\n  Writeln(MD5('abc'));\n  Writeln(MD5('message digest'));\n  Writeln(MD5('abcdefghijklmnopqrstuvwxyz'));\n  Writeln(MD5('ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789'));\n  Writeln(MD5('12345678901234567890123456789012345678901234567890123456789012345678901234567890'));\n  Readln;\nend.\n\n\nD41D8CD98F00B204E9800998ECF8427E\n0CC175B9C0F1B6A831C399E269772661\n900150983CD24FB0D6963F7D28E17F72\nF96B697D7CB7938D525A2F31AAF161D0\nC3FCD3D76192E4007DFB496CCA67E13B\nD174AB98D277D9F5A5611C2C9F419D9F\n57EDF4A22BE3C955AC49DA2E2107B67A\n\n", "explain": "If you require a native implementation, look inside the class TIdHashMessageDigest5. This class is placed in the unit IdHashMessageDigest.pas.\nOutput:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Ruby", "code": "\nrequire 'digest'\nDigest::MD5.hexdigest(\"The quick brown fox jumped over the lazy dog's back\")\n# => \"e38ca1d920c4b8b8d3946b2c72f01680\"\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Rust", "code": "\n\n[dependencies]\nrust-crypto = \"0.2\"\n\n\nextern crate crypto;\n\nuse crypto::digest::Digest;\nuse crypto::md5::Md5;\n\nfn main() {\n    let mut sh = Md5::new();\n    sh.input_str(\"The quick brown fox jumped over the lazy dog's back\");\n    println!(\"{}\", sh.result_str());\n}\n\n", "explain": "Cargo.toml\nsrc/main.rs\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "R", "code": "\nlibrary(digest)\nhexdigest <- digest(\"The quick brown fox jumped over the lazy dog's back\", \n                    algo=\"md5\", serialize=FALSE)\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Use the md5sum utility and pass the HASH back using\n      **     a temp file.  Not elegant, but it works.\n      ************************************************************\n       \n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Tmp-MD5 ASSIGN TO \"/tmp/MD5\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n\n\n       DATA DIVISION.\n\n       FILE SECTION.\n       \n       FD  Tmp-MD5\n           DATA RECORD IS MD5-Rec.\n       01  MD5-Rec       PIC X(32).\n\n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n       01 Str1.\n          05  Pre-cmd   PIC X(8)\n              VALUE 'echo -n '.\n          05  Str1-complete.\n              10  Str1-Part1  PIC X(26)\n                  VALUE  'The quick brown fox jumps'.\n              10  Str1-Part2  PIC X(19)\n                  VALUE  ' over the lazy dog'.\n          05  Post-cmd    PIC X(20)\n              VALUE  ' | md5sum > /tmp/MD5'.\n       01  Str1-MD5          PIC X(32).\n       \n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n\n           DISPLAY Str1-complete.\n           PERFORM Get-MD5.\n           DISPLAY Str1-MD5.\n\n           STOP RUN.\n\n       Get-MD5.\n       \n           CALL \"SYSTEM\" USING Str1.\n           OPEN INPUT Tmp-MD5.\n           READ Tmp-MD5 INTO Str1-MD5.\n           CLOSE Tmp-MD5.\n           CALL \"CBL_DELETE_FILE\" USING '/tmp/MD5'.\n\n \n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. MD5-DEMO.\n       AUTHOR.  Bill Gunshannon\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  16 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   Use the md5sum utility and pass the HASH back using\n      **     a temp file.  Not elegant, but it works.\n      **   Same program but made MD5 a User Defined Function\n      **     instead of a procedure.\n      ************************************************************\n \n \n       ENVIRONMENT DIVISION.\n \n       CONFIGURATION SECTION.\n\n       REPOSITORY.\n          FUNCTION MD5.\n\n       DATA DIVISION.\n \n       WORKING-STORAGE SECTION.\n \n       01 Eof                   PIC X     VALUE 'F'.\n       01 Str1.\n          05  Pre-cmd   PIC X(8)\n              VALUE 'echo -n '.\n          05  Str1-complete.\n              10  Str1-Part1  PIC X(26)\n                  VALUE  'The quick brown fox jumps'.\n              10  Str1-Part2  PIC X(19)\n                  VALUE  ' over the lazy dog'.\n          05  Post-cmd    PIC X(20)\n              VALUE  ' | md5sum > /tmp/MD5'.\n       01  Str1-MD5          PIC X(32).\n \n \n       PROCEDURE DIVISION.\n \n       Main-Program.\n \n           DISPLAY Str1-complete.\n      *    PERFORM Get-MD5.\n           MOVE FUNCTION MD5(Str1) TO Str1-MD5.\n           DISPLAY Str1-MD5.\n \n           STOP RUN.\n\n        END PROGRAM MD5-DEMO.\n \n       IDENTIFICATION DIVISION.\n       FUNCTION-ID. MD5.\n\n       ENVIRONMENT DIVISION.\n\n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Tmp-MD5 ASSIGN TO \"/tmp/MD5\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n\n\n       DATA DIVISION.\n\n       FILE SECTION.\n\n       FD  Tmp-MD5\n           DATA RECORD IS MD5-Rec.\n       01  MD5-Rec       PIC X(32).\n\n\n\n       LINKAGE SECTION.\n       01  Str1        PIC X(128).\n       01  Str1-MD5    PIC X(32).\n\n       PROCEDURE DIVISION USING Str1 RETURNING Str1-MD5.\n \n           CALL \"SYSTEM\" USING FUNCTION TRIM(Str1).\n           OPEN INPUT Tmp-MD5.\n           READ Tmp-MD5 INTO Str1-MD5.\n           CLOSE Tmp-MD5.\n           CALL \"CBL_DELETE_FILE\" USING '/tmp/MD5'.\n           GO-BACK. \n\n        END FUNCTION MD5.\n\n\nOutput:\nThe quick brown fox jumps  over the lazy dog \n9e107d9d372bb6826bd81d3542a419d6\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Ada", "code": "\nWorks with: GNAT\nwith Ada.Text_IO; use Ada.Text_IO;\nwith GNAT.MD5;\n\nprocedure MD5_Digest is\nbegin\n   Put(GNAT.MD5.Digest(\"Foo bar baz\"));\nend MD5_Digest;\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\nusing Nettle\n\nfunction Base.trunc(s::AbstractString, n::Integer)\n    n > 0 || throw(DomainError())\n    l = length(s)\n    l > n || return s\n    n > 3 || return s[1:n]\n    return s[1:n-3] * \"...\"\nend\n\ntests = [\"\"    => \"d41d8cd98f00b204e9800998ecf8427e\",\n         \"a\"   => \"0cc175b9c0f1b6a831c399e269772661\",\n         \"abc\" => \"900150983cd24fb0d6963f7d28e17f72\",\n         \"message digest\" => \"f96b697d7cb7938d525a2f31aaf161d0\",\n         \"abcdefghijklmnopqrstuvwxyz\" => \"c3fcd3d76192e4007dfb496cca67e13b\",\n         \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\" =>\n         \"d174ab98d277d9f5a5611c2c9f419d9f\",\n         \"12345678901234567890123456789012345678901234567890123456789012345678901234567890\" =>\n         \"57edf4a22be3c955ac49da2e2107b67a\",\n         \"foobad\" => \"3858f62230ac3c915f300c664312c63f\"]\n\nprintln(\"Testing Julia's MD5 hash against RFC 1321.\")\nfor (k, h) in sort(tests, by = length \u2218 first)\n    md5sum = hexdigest(\"md5\", k)\n    @printf(\"%20s \u2192 %s \", trunc(k, 15), md5sum)\n    if md5sum == h\n        println(\"MD5 OK\")\n    else\n        println(\"MD5 Bad\")\n        println(\"* The sum should be  \", h)\n    end\nend\n\n\nOutput:\n                     \u2192 d41d8cd98f00b204e9800998ecf8427e MD5 OK\n                   a \u2192 0cc175b9c0f1b6a831c399e269772661 MD5 OK\n                 abc \u2192 900150983cd24fb0d6963f7d28e17f72 MD5 OK\n              foobad \u2192 6ce0d31e08fc3c4de8e3b2fa0d3d72ff MD5 Bad\n* The sum should be  3858f62230ac3c915f300c664312c63f\n      message digest \u2192 f96b697d7cb7938d525a2f31aaf161d0 MD5 OK\n     abcdefghijkl... \u2192 c3fcd3d76192e4007dfb496cca67e13b MD5 OK\n     ABCDEFGHIJKL... \u2192 d174ab98d277d9f5a5611c2c9f419d9f MD5 OK\n     123456789012... \u2192 57edf4a22be3c955ac49da2e2107b67a MD5 O\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nimport java.security.MessageDigest\n\nfun main(args: Array<String>) {\n    val text  = \"The quick brown fox jumped over the lazy dog's back\"\n    val bytes = text.toByteArray()\n    val md = MessageDigest.getInstance(\"MD5\")\n    val digest = md.digest(bytes)\n    for (byte in digest) print(\"%02x\".format(byte))\n    println() \n}\n\n\nOutput:\ne38ca1d920c4b8b8d3946b2c72f01680\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Perl", "code": "\nLibrary: Digest::MD5MD5\nuse Digest::MD5 qw(md5_hex);\n\nprint md5_hex(\"The quick brown fox jumped over the lazy dog's back\"), \"\\n\";\n\n\nuse Digest::MD5;\n\n$md5 = Digest::MD5->new;\n$md5->add(\"The quick brown fox jumped over the lazy dog's back\");\nprint $md5->hexdigest, \"\\n\";\n\n", "explain": "The same in OO manner\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Objective-C", "code": "\nWorks with: GNUstep only; not Cocoa\nNSString *myString = @\"The quick brown fox jumped over the lazy dog's back\";\nNSData *digest = [[myString dataUsingEncoding:NSUTF8StringEncoding] md5Digest]; // or another encoding of your choosing\nNSLog(@\"%@\", [digest hexadecimalRepresentation]);\n\nWorks with: iPhone\nWorks with: Mac OS X\n#import <CommonCrypto/CommonDigest.h>\n\nNSString *myString = @\"The quick brown fox jumped over the lazy dog's back\";\nNSData *data = [myString dataUsingEncoding:NSUTF8StringEncoding]; // or another encoding of your choosing\nunsigned char digest[CC_MD5_DIGEST_LENGTH];\nif (CC_MD5([data bytes], [data length], digest)) {\n    NSMutableString *hex = [NSMutableString string];\n    for (int i = 0; i < CC_MD5_DIGEST_LENGTH; i++) {\n        [hex appendFormat: @\"%02x\", (int)(digest[i])];\n    }\n    NSLog(@\"%@\", hex);\n}\n\nWorks with: Mac OS X (need to include \"libcrypto.dylib\" framework)\n#include <openssl/md5.h>\n\nNSString *myString = @\"The quick brown fox jumped over the lazy dog's back\";\nNSData *data = [myString dataUsingEncoding:NSUTF8StringEncoding]; // or another encoding of your choosing\nunsigned char digest[MD5_DIGEST_LENGTH];\nif (MD5([data bytes], [data length], digest)) {\n    NSMutableString *hex = [NSMutableString string];\n    for (int i = 0; i < MD5_DIGEST_LENGTH; i++) {\n        [hex appendFormat: @\"%02x\", (int)(digest[i])];\n    }\n    NSLog(@\"%@\", hex);\n}\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Lua", "code": "\n\nrequire \"md5\"\n\n--printing a sum:\nprint(md5.sumhexa\"The quick brown fox jumps over the lazy dog\")\n\n--running the test suite:\n\nlocal function test(msg,sum) assert(md5.sumhexa(msg)==sum) end\n\ntest(\"\",\"d41d8cd98f00b204e9800998ecf8427e\")\ntest(\"a\",\"0cc175b9c0f1b6a831c399e269772661\")\ntest(\"abc\",\"900150983cd24fb0d6963f7d28e17f72\")\ntest(\"message digest\",\"f96b697d7cb7938d525a2f31aaf161d0\")\ntest(\"abcdefghijklmnopqrstuvwxyz\",\"c3fcd3d76192e4007dfb496cca67e13b\")\ntest(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\",\"d174ab98d277d9f5a5611c2c9f419d9f\")\ntest(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\",\"57edf4a22be3c955ac49da2e2107b67a\")\n\n", "explain": "Using the Kepler MD5 library:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Scala", "code": "\nobject RosettaMD5 extends App {\n\n  def MD5(s: String): String = {\n    // Besides \"MD5\", \"SHA-256\", and other hashes are available\n    val m = java.security.MessageDigest.getInstance(\"MD5\").digest(s.getBytes(\"UTF-8\"))\n    m.map(\"%02x\".format(_)).mkString\n  }\n\n  assert(\"d41d8cd98f00b204e9800998ecf8427e\" == MD5(\"\"))\n  assert(\"0cc175b9c0f1b6a831c399e269772661\" == MD5(\"a\"))\n  assert(\"900150983cd24fb0d6963f7d28e17f72\" == MD5(\"abc\"))\n  assert(\"f96b697d7cb7938d525a2f31aaf161d0\" == MD5(\"message digest\"))\n  assert(\"c3fcd3d76192e4007dfb496cca67e13b\" == MD5(\"abcdefghijklmnopqrstuvwxyz\"))\n  assert(\"e38ca1d920c4b8b8d3946b2c72f01680\" == MD5(\"The quick brown fox jumped over the lazy dog's back\"))\n  assert(\"d174ab98d277d9f5a5611c2c9f419d9f\" ==\n    MD5(\"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789\"))\n  assert(\"57edf4a22be3c955ac49da2e2107b67a\" ==\n    MD5(\"12345678901234567890123456789012345678901234567890123456789012345678901234567890\"))\n  import scala.compat.Platform.currentTime\n  println(s\"Successfully completed without errors. [total ${currentTime - executionStart} ms]\")\n}\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.digest.md;\n\n    auto txt = \"The quick brown fox jumped over the lazy dog's back\";\n    writefln(\"%-(%02x%)\", txt.md5Of);\n}\n\n\nOutput:\ne38ca1d920c4b8b8d3946b2c72f01680\n\nLibrary: Tango\nimport tango.io.digest.Md5, tango.io.Stdout;\n\nvoid main(char[][] args) {\n  auto md5 = new Md5();\n  for(int i = 1; i < args.length; i++) {\n    md5.update(args[i]);\n    Stdout.formatln(\"[{}]=>\\n[{}]\", args[i], md5.hexDigest());\n  }\n}\n\n\n>md5test \"The quick brown fox jumped over the lazy dog's back\"\n[The quick brown fox jumped over the lazy dog's back]=>\n[e38ca1d920c4b8b8d3946b2c72f01680]\n", "explain": "Alternative version:\nOutput:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Haskell", "code": "\n\nimport Data.Digest.OpenSSL.MD5 (md5sum)\nimport Data.ByteString (pack)\nimport Data.Char (ord)\n\nmain = do\n  let message = \"The quick brown fox jumped over the lazy dog's back\"\n      digest  = (md5sum . pack . map (fromIntegral . ord)) message\n  putStrLn digest\n\n\n*Main> main\ne38ca1d920c4b8b8d3946b2c72f01680\n\nLibrary: Cryptonite\n#!/usr/bin/env runhaskell\n\nimport Data.ByteString.Char8 (pack)\nimport System.Environment (getArgs)\nimport Crypto.Hash\n\nmain :: IO ()\nmain = print . md5 . pack . unwords =<< getArgs\n         where md5 x = hash x :: Digest MD5\n\n\nOutput:\n$ ./md5.hs The quick brown fox jumped over the lazy dog\\'s back\ne38ca1d920c4b8b8d3946b2c72f01680\n\n", "explain": "Use modules nano-MD5 and ByteString from HackageDB\nUse in GHCi:\nThis version uses the Cryptonite package:\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "PowerShell", "code": "\nTranslation of: C#\n$string = \"The quick brown fox jumped over the lazy dog's back\"\n$data = [Text.Encoding]::UTF8.GetBytes($string)\n$hash = [Security.Cryptography.MD5]::Create().ComputeHash($data)\n([BitConverter]::ToString($hash) -replace '-').ToLower()\n\n", "explain": ""}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "F#", "code": "\n\nlet md5ootb (msg: string) =\n  use md5 = System.Security.Cryptography.MD5.Create()\n  msg\n  |> System.Text.Encoding.ASCII.GetBytes\n  |> md5.ComputeHash\n  |> Seq.map (fun c -> c.ToString(\"X2\"))\n  |> Seq.reduce ( + )\n\nmd5ootb @\"The quick brown fox jumped over the lazy dog's back\"\n\n", "explain": "Using built-in System.Security.Cryptography.MD5 class (Link to original blog [2]).\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "Groovy", "code": "\nimport java.security.MessageDigest\n\nString.metaClass.md5Checksum = {\n    MessageDigest.getInstance('md5').digest(delegate.bytes).collect { String.format(\"%02x\", it) }.join('')\n}\n\n\nassert 'The quick brown fox jumps over the lazy dog'.md5Checksum() == '9e107d9d372bb6826bd81d3542a419d6'\n\n", "explain": "Testing\n"}, {"task_name": "MD5", "task_url": "https://rosettacode.org/wiki/MD5", "task_cat": "Checksums", "lang": "RPG", "code": "\n\n**FREE\nCtl-opt MAIN(Main);\nCtl-opt DFTACTGRP(*NO) ACTGRP(*NEW);\n\ndcl-pr QDCXLATE EXTPGM('QDCXLATE');\n  dataLen         packed(5\u00a0: 0) CONST;\n  data            char(32767) options(*VARSIZE);\n  conversionTable char(10) CONST;\nend-pr;\n\ndcl-pr Qc3CalculateHash EXTPROC('Qc3CalculateHash');\n  inputData             pointer value;\n  inputDataLen          int(10) const;\n  inputDataFormat       char(8) const;\n  algorithmDscr         char(16) const;\n  algorithmFormat       char(8) const;\n  cryptoServiceProvider char(1) const;\n  cryptoDeviceName      char(1) const options(*OMIT);\n  hash                  char(64) options(*VARSIZE\u00a0: *OMIT);\n  errorCode             char(32767) options(*VARSIZE);\nend-pr;\n\ndcl-c HEX_CHARS CONST('0123456789ABCDEF');\n\ndcl-proc Main;\n  dcl-s inputData char(45);\n  dcl-s inputDataLen int(10) INZ(0);\n  dcl-s outputHash char(16);\n  dcl-s outputHashHex char(32);\n  dcl-ds algorithmDscr QUALIFIED;\n    hashAlgorithm int(10) INZ(0);\n  end-ds;\n  dcl-ds ERRC0100_NULL QUALIFIED;\n    bytesProvided int(10) INZ(0);  // Leave at zero\n    bytesAvailable int(10);\n  end-ds;\n  \n  dow inputDataLen = 0;\n    DSPLY 'Input: ' '' inputData;\n    inputData = %trim(inputData);\n    inputDataLen = %len(%trim(inputData));\n    DSPLY ('Input=' + inputData);\n    DSPLY ('InputLen=' + %char(inputDataLen));\n    if inputDataLen = 0;\n      DSPLY 'Input must not be blank';\n    endif;\n  enddo;\n  \n  // Convert from EBCDIC to ASCII\n  QDCXLATE(inputDataLen\u00a0: inputData\u00a0: 'QTCPASC');\n  algorithmDscr.hashAlgorithm = 1;   // MD5\n  // Calculate hash\n  Qc3CalculateHash(%addr(inputData)\u00a0: inputDataLen\u00a0: 'DATA0100'\u00a0: algorithmDscr\n                  \u00a0: 'ALGD0500'\u00a0: '0'\u00a0: *OMIT\u00a0: outputHash\u00a0: ERRC0100_NULL);\n  // Convert to hex\n  CVTHC(outputHashHex\u00a0: outputHash\u00a0: 32);\n  DSPLY ('MD5: ' + outputHashHex);\n  return;\nend-proc;\n\n// This procedure is actually a MI, but I couldn't get it to bind so I wrote my own version\ndcl-proc CVTHC;\n  dcl-pi *N;\n    target char(65534) options(*VARSIZE);\n    srcBits char(32767) options(*VARSIZE) CONST;\n    targetLen int(10) value;\n  end-pi;\n  dcl-s i int(10);\n  dcl-s lowNibble ind INZ(*OFF);\n  dcl-s inputOffset int(10) INZ(1);\n  dcl-ds dataStruct QUALIFIED;\n    numField int(5) INZ(0);\n    // IBM i is big-endian\n    charField char(1) OVERLAY(numField\u00a0: 2);\n  end-ds;\n  \n  for i = 1 to targetLen;\n    if lowNibble;\n      dataStruct.charField = %BitAnd(%subst(srcBits\u00a0: inputOffset\u00a0: 1)\u00a0: X'0F');\n      inputOffset += 1;\n    else;\n      dataStruct.charField = %BitAnd(%subst(srcBits\u00a0: inputOffset\u00a0: 1)\u00a0: X'F0');\n      dataStruct.numField /= 16;\n    endif;\n    %subst(target\u00a0: i\u00a0: 1) = %subst(HEX_CHARS\u00a0: dataStruct.numField + 1\u00a0: 1);\n    lowNibble = NOT lowNibble;\n  endfor;\n  return;\nend-proc;\n\n DSPLY  Input:\n abcdefghijklmnopqrstuvwxyz\n DSPLY  Input=abcdefghijklmnopqrstuvwxyz\n DSPLY  InputLen=26\n DSPLY  MD5: C3FCD3D76192E4007DFB496CCA67E13B\n", "explain": "Modified from [3]:\nNote that this implementation converts the input from EBCDIC to ASCII before computing the hash.\nSample output:\n"}]