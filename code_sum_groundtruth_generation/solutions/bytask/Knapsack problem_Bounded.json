[{"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\n\nfrom itertools import groupby\nfrom collections import namedtuple\n\ndef anyvalidcomb(items, maxwt, val=0, wt=0):\n    ' All combinations below the maxwt '\n    if not items:\n        yield [], val, wt\n    else:\n        this, *items = items            # car, cdr\n        for n in range(this.number + 1):\n            w = wt  + n * this.weight\n            if w > maxwt:\n                break\n            v = val + n * this.value\n            this_comb = [this] * n\n            for comb, value, weight in anyvalidcomb(items, maxwt, v, w):\n                yield this_comb + comb, value, weight\n\nmaxwt = 400\nCOMB, VAL, WT = range(3)\nItem  = namedtuple('Items', 'name weight value number')\nitems = [ Item(*x) for x in\n          (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           ) ]  \n\nbagged = max( anyvalidcomb(items, maxwt), key=lambda c: (c[VAL], -c[WT])) # max val or min wt if values equal\nprint(\"Bagged the following %i items\" % len(bagged[COMB]))\nprint('\\n\\t'.join('%i off: %s' % (len(list(grp)), item.name) for item, grp in groupby(sorted(bagged[COMB]))))\nprint(\"for a total value of %i and a total weight of %i\" % bagged[1:])\n\n\nOutput:\nBagged the following 14 items\n  3 off: banana\n  1 off: cheese\n  1 off: compass\n  2 off: glucose\n  1 off: map\n  1 off: note-case\n  1 off: socks\n  1 off: sunglasses\n  1 off: suntan cream\n  1 off: water\n  1 off: waterproof overclothes\nfor a total value of 1010 and a total weight of 396\nDynamic programming solution[edit]\n\nfrom itertools import groupby\n\ntry:\n    xrange\nexcept:\n    xrange = range\n\nmaxwt = 400\n\ngroupeditems = (\n            (\"map\", 9, 150, 1),\n            (\"compass\", 13, 35, 1),\n            (\"water\", 153, 200, 3),\n            (\"sandwich\", 50, 60, 2),\n            (\"glucose\", 15, 60, 2),\n            (\"tin\", 68, 45, 3),\n            (\"banana\", 27, 60, 3),\n            (\"apple\", 39, 40, 3),\n            (\"cheese\", 23, 30, 1),\n            (\"beer\", 52, 10, 3),\n            (\"suntan cream\", 11, 70, 1),\n            (\"camera\", 32, 30, 1),\n            (\"t-shirt\", 24, 15, 2),\n            (\"trousers\", 48, 10, 2),\n            (\"umbrella\", 73, 40, 1),\n            (\"waterproof trousers\", 42, 70, 1),\n            (\"waterproof overclothes\", 43, 75, 1),\n            (\"note-case\", 22, 80, 1),\n            (\"sunglasses\", 7, 20, 1),\n            (\"towel\", 18, 12, 2),\n            (\"socks\", 4, 50, 1),\n            (\"book\", 30, 10, 2),\n           )\nitems = sum( ([(item, wt, val)]*n for item, wt, val,n in groupeditems), [])\n\ndef knapsack01_dp(items, limit):\n    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]\n \n    for j in xrange(1, len(items) + 1):\n        item, wt, val = items[j-1]\n        for w in xrange(1, limit + 1):\n            if wt > w:\n                table[j][w] = table[j-1][w]\n            else:\n                table[j][w] = max(table[j-1][w],\n                                  table[j-1][w-wt] + val)\n \n    result = []\n    w = limit\n    for j in range(len(items), 0, -1):\n        was_added = table[j][w] != table[j-1][w]\n \n        if was_added:\n            item, wt, val = items[j-1]\n            result.append(items[j-1])\n            w -= wt\n \n    return result\n \n \nbagged = knapsack01_dp(items, maxwt)\nprint(\"Bagged the following %i items\\n  \" % len(bagged) +\n      '\\n  '.join('%i off: %s' % (len(list(grp)), item[0])\n                  for item,grp in groupby(sorted(bagged))))\nprint(\"for a total value of %i and a total weight of %i\" % (\n    sum(item[2] for item in bagged), sum(item[1] for item in bagged)))\n\nNon-zero-one solution[edit]\nitems = {\n\t\"sandwich\":\t(50,\t60,\t2),\n\t\"map\": \t\t(9,\t150,\t1),\n\t\"compass\": \t(13,\t35,\t1),\n\t\"water\": \t(153,\t200,\t3),\n\t\"glucose\": \t(15,\t60,\t2),\n\t\"tin\": \t\t(68,\t45,\t3),\n\t\"banana\": \t(27,\t60,\t3),\n\t\"apple\": \t(39,\t40,\t3),\n\t\"cheese\": \t(23,\t30,\t1),\n\t\"beer\": \t(52,\t10,\t3),\n\t\"suntan cream\": (11,\t70,\t1),\n\t\"camera\": \t(32,\t30,\t1),\n\t\"t-shirt\": \t(24,\t15,\t2),\n\t\"trousers\": \t(48,\t10,\t2),\n\t\"umbrella\": \t(73,\t40,\t1),\n\t\"w-trousers\": \t(42,\t70,\t1),\n\t\"w-overcoat\": \t(43,\t75,\t1),\n\t\"note-case\": \t(22,\t80,\t1),\n\t\"sunglasses\": \t(7,\t20,\t1),\n\t\"towel\": \t(18,\t12,\t2),\n\t\"socks\": \t(4,\t50,\t1),\n\t\"book\": \t(30,\t10,\t2),\n}\n\nitem_keys = list(items.keys())\n\n#cache: could just use memoize module, but explicit caching is clearer\ndef choose_item(weight, idx, cache):\n    if idx < 0: return 0, []\n \n    k = (weight, idx)\n    if k in cache: return cache[k]\n \n    name, w, v, qty = item_keys[idx], *items[item_keys[idx]]\n    best_v, best_list = 0, []\n \n    for i in range(0, qty + 1):\n        wlim = weight - i * w\n        if wlim < 0: break\n \n        val, taken = choose_item(wlim, idx - 1, cache)\n        if val + i * v > best_v:\n            best_v = val + i * v\n            best_list = taken[:]\n            best_list.append((i, name))\n \n    cache[k] = [best_v, best_list]\n    return best_v, best_list\n \n \nv, lst = choose_item(400, len(items) - 1, {})\nw = 0\nfor cnt, name in lst:\n    if cnt > 0:\n        print(cnt, name)        \n        w = w + items[name][0] * cnt\n \nprint(\"Total weight:\", w, \"Value:\", v)\n\n", "explain": "Not as dumb a search over all possible combinations under the maximum allowed weight:\nThis is much faster. It expands the multiple possible instances of an item into individual instances then applies the zero-one dynamic knapsack solution:\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char *name;\n    int weight;\n    int value;\n    int count;\n} item_t;\n\nitem_t items[] = {\n    {\"map\",                      9,   150,   1},\n    {\"compass\",                 13,    35,   1},\n    {\"water\",                  153,   200,   2},\n    {\"sandwich\",                50,    60,   2},\n    {\"glucose\",                 15,    60,   2},\n    {\"tin\",                     68,    45,   3},\n    {\"banana\",                  27,    60,   3},\n    {\"apple\",                   39,    40,   3},\n    {\"cheese\",                  23,    30,   1},\n    {\"beer\",                    52,    10,   3},\n    {\"suntan cream\",            11,    70,   1},\n    {\"camera\",                  32,    30,   1},\n    {\"T-shirt\",                 24,    15,   2},\n    {\"trousers\",                48,    10,   2},\n    {\"umbrella\",                73,    40,   1},\n    {\"waterproof trousers\",     42,    70,   1},\n    {\"waterproof overclothes\",  43,    75,   1},\n    {\"note-case\",               22,    80,   1},\n    {\"sunglasses\",               7,    20,   1},\n    {\"towel\",                   18,    12,   2},\n    {\"socks\",                    4,    50,   1},\n    {\"book\",                    30,    10,   2},\n};\n\nint n = sizeof (items) / sizeof (item_t);\n\nint *knapsack (int w) {\n    int i, j, k, v, *mm, **m, *s;\n    mm = calloc((n + 1) * (w + 1), sizeof (int));\n    m = malloc((n + 1) * sizeof (int *));\n    m[0] = mm;\n    for (i = 1; i <= n; i++) {\n        m[i] = &mm[i * (w + 1)];\n        for (j = 0; j <= w; j++) {\n            m[i][j] = m[i - 1][j];\n            for (k = 1; k <= items[i - 1].count; k++) {\n                if (k * items[i - 1].weight > j) {\n                    break;\n                }\n                v = m[i - 1][j - k * items[i - 1].weight] + k * items[i - 1].value;\n                if (v > m[i][j]) {\n                    m[i][j] = v;\n                }\n            }\n        }\n    }\n    s = calloc(n, sizeof (int));\n    for (i = n, j = w; i > 0; i--) {\n        int v = m[i][j];\n        for (k = 0; v != m[i - 1][j] + k * items[i - 1].value; k++) {\n            s[i - 1]++;\n            j -= items[i - 1].weight;\n        }\n    }\n    free(mm);\n    free(m);\n    return s;\n}\n\nint main () {\n    int i, tc = 0, tw = 0, tv = 0, *s;\n    s = knapsack(400);\n    for (i = 0; i < n; i++) {\n        if (s[i]) {\n            printf(\"%-22s %5d %5d %5d\\n\", items[i].name, s[i], s[i] * items[i].weight, s[i] * items[i].value);\n            tc += s[i];\n            tw += s[i] * items[i].weight;\n            tv += s[i] * items[i].value;\n        }\n    }\n    printf(\"%-22s %5d %5d %5d\\n\", \"count, weight, value:\", tc, tw, tv);\n    return 0;\n}\n\n\nOutput:\nmap                        1     9   150\ncompass                    1    13    35\nwater                      1   153   200\nglucose                    2    30   120\nbanana                     3    81   180\ncheese                     1    23    30\nsuntan cream               1    11    70\nwaterproof overclothes     1    43    75\nnote-case                  1    22    80\nsunglasses                 1     7    20\nsocks                      1     4    50\ncount, weight, value:     14   396  1010\n", "explain": ""}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\n\n#include <iostream>\n#include <vector>\n#include <algorithm>\n#include <stdexcept>\n#include <memory>\n#include <sys/time.h>\n\nusing std::cout;\nusing std::endl;\n\nclass StopTimer\n{\npublic:\n    StopTimer(): begin_(getUsec()) {}\n    unsigned long long getTime() const { return getUsec() - begin_; }\nprivate:\n    static unsigned long long getUsec()\n    {//...you might want to use something else under Windows\n        timeval tv;\n        const int res = ::gettimeofday(&tv, 0);\n        if(res)\n            return 0;\n        return tv.tv_usec + 1000000 * tv.tv_sec;\n    }\n    unsigned long long begin_;\n};\n\nstruct KnapsackTask\n{\n    struct Item\n    {\n        std::string name;\n        unsigned w, v, qty;\n        Item(): w(), v(), qty() {}\n        Item(const std::string& iname, unsigned iw, unsigned iv, unsigned iqty):\n            name(iname), w(iw), v(iv), qty(iqty)\n        {}\n    };\n    typedef std::vector<Item> Items;\n    struct Solution\n    {\n        unsigned v, w;\n        unsigned long long iterations, usec;\n        std::vector<unsigned> n;\n        Solution(): v(), w(), iterations(), usec() {}\n    };\n    //...\n    KnapsackTask(): maxWeight_(), totalWeight_() {}\n    void add(const Item& item)\n    {\n        const unsigned totalItemWeight = item.w * item.qty;\n        if(const bool invalidItem = !totalItemWeight)\n            throw std::logic_error(\"Invalid item: \" + item.name);\n        totalWeight_ += totalItemWeight;\n        items_.push_back(item);\n    }\n    const Items& getItems() const { return items_; }\n    void setMaxWeight(unsigned maxWeight) { maxWeight_ = maxWeight; }\n    unsigned getMaxWeight() const { return std::min(totalWeight_, maxWeight_); }\n\nprivate:\n    unsigned maxWeight_, totalWeight_;\n    Items items_;\n};\n\nclass BoundedKnapsackRecursiveSolver\n{\npublic:\n    typedef KnapsackTask Task;\n    typedef Task::Item Item;\n    typedef Task::Items Items;\n    typedef Task::Solution Solution;\n\n    void solve(const Task& task)\n    {\n        Impl(task, solution_).solve();\n    }\n    const Solution& getSolution() const { return solution_; }\nprivate:\n    class Impl\n    {\n        struct Candidate\n        {\n            unsigned v, n;\n            bool visited;\n            Candidate(): v(), n(), visited(false) {}\n        };\n        typedef std::vector<Candidate> Cache;\n    public:\n        Impl(const Task& task, Solution& solution):\n            items_(task.getItems()),\n            maxWeight_(task.getMaxWeight()),\n            maxColumnIndex_(task.getItems().size() - 1),\n            solution_(solution),\n            cache_(task.getMaxWeight() * task.getItems().size()),\n            iterations_(0)\n        {}\n        void solve()\n        {\n            if(const bool nothingToSolve = !maxWeight_ || items_.empty())\n                return;\n            StopTimer timer;\n            Candidate candidate;\n            solve(candidate, maxWeight_, items_.size() - 1);\n            convertToSolution(candidate);\n            solution_.usec = timer.getTime();\n        }\n    private:\n        void solve(Candidate& current, unsigned reminderWeight, const unsigned itemIndex)\n        {\n            ++iterations_;\n\n            const Item& item(items_[itemIndex]);\n\n            if(const bool firstColumn = !itemIndex)\n            {\n                const unsigned maxQty = std::min(item.qty, reminderWeight/item.w);\n                current.v = item.v * maxQty;\n                current.n = maxQty;\n                current.visited = true;\n            }\n            else\n            {\n                const unsigned nextItemIndex = itemIndex - 1;\n                {\n                    Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);\n                    if(!nextItem.visited)\n                        solve(nextItem, reminderWeight, nextItemIndex);\n                    current.visited = true;\n                    current.v = nextItem.v;\n                    current.n = 0;\n                }\n                if(reminderWeight >= item.w)\n                {\n                    for (unsigned numberOfItems = 1; numberOfItems <= item.qty; ++numberOfItems)\n                    {\n                        reminderWeight -= item.w;\n                        Candidate& nextItem = cachedItem(reminderWeight, nextItemIndex);\n                        if(!nextItem.visited)\n                            solve(nextItem, reminderWeight, nextItemIndex);\n\n                        const unsigned checkValue = nextItem.v + numberOfItems * item.v;\n                        if ( checkValue > current.v)\n                        {\n                            current.v = checkValue;\n                            current.n = numberOfItems;\n                        }\n                        if(!(reminderWeight >= item.w))\n                            break;\n                    }\n                }\n            }\n        }\n        void convertToSolution(const Candidate& candidate)\n        {\n            solution_.iterations = iterations_;\n            solution_.v = candidate.v;\n            solution_.n.resize(items_.size());\n\n            const Candidate* iter = &candidate;\n            unsigned weight = maxWeight_, itemIndex = items_.size() - 1;\n            while(true)\n            {\n                const unsigned currentWeight = iter->n * items_[itemIndex].w;\n                solution_.n[itemIndex] = iter->n;\n                weight -= currentWeight;\n                if(!itemIndex--)\n                    break;\n                iter = &cachedItem(weight, itemIndex);\n            }\n            solution_.w = maxWeight_ - weight;\n        }\n        Candidate& cachedItem(unsigned weight, unsigned itemIndex)\n        {\n            return cache_[weight * maxColumnIndex_ + itemIndex];\n        }\n        const Items& items_;\n        const unsigned maxWeight_;\n        const unsigned maxColumnIndex_;\n        Solution& solution_;\n        Cache cache_;\n        unsigned long long iterations_;\n    };\n    Solution solution_;\n};\n\nvoid populateDataset(KnapsackTask& task)\n{\n    typedef KnapsackTask::Item Item;\n    task.setMaxWeight( 400 );\n    task.add(Item(\"map\",9,150,1));\n    task.add(Item(\"compass\",13,35,1));\n    task.add(Item(\"water\",153,200,2));\n    task.add(Item(\"sandwich\",50,60,2));\n    task.add(Item(\"glucose\",15,60,2));\n    task.add(Item(\"tin\",68,45,3));\n    task.add(Item(\"banana\",27,60,3));\n    task.add(Item(\"apple\",39,40,3));\n    task.add(Item(\"cheese\",23,30,1));\n    task.add(Item(\"beer\",52,10,3));\n    task.add(Item(\"suntancream\",11,70,1));\n    task.add(Item(\"camera\",32,30,1));\n    task.add(Item(\"T-shirt\",24,15,2));\n    task.add(Item(\"trousers\",48,10,2));\n    task.add(Item(\"umbrella\",73,40,1));\n    task.add(Item(\"w-trousers\",42,70,1));\n    task.add(Item(\"w-overclothes\",43,75,1));\n    task.add(Item(\"note-case\",22,80,1));\n    task.add(Item(\"sunglasses\",7,20,1));\n    task.add(Item(\"towel\",18,12,2));\n    task.add(Item(\"socks\",4,50,1));\n    task.add(Item(\"book\",30,10,2));\n}\n\nint main()\n{\n    KnapsackTask task;\n    populateDataset(task);\n\n    BoundedKnapsackRecursiveSolver solver;\n    solver.solve(task);\n    const KnapsackTask::Solution& solution = solver.getSolution();\n\n    cout << \"Iterations to solve: \" << solution.iterations << endl;\n    cout << \"Time to solve: \" << solution.usec << \" usec\" << endl;\n    cout << \"Solution:\" << endl;\n    for (unsigned i = 0; i < solution.n.size(); ++i)\n    {\n        if (const bool itemIsNotInKnapsack = !solution.n[i])\n            continue;\n        cout << \"  \" << solution.n[i] << ' ' << task.getItems()[i].name << \" ( item weight = \" << task.getItems()[i].w << \" )\" << endl;\n    }\n\n    cout << \"Weight: \" << solution.w << \" Value: \" << solution.v << endl;\n    return 0;\n}\n\n", "explain": "C++ DP solution. Initially taken from C but than fixed and refactored.\nRemark: The above comment implies there is a bug in the C code, but refers to a much older and very different version Pete Lomax (talk) 19:28, 20 March 2017 (UTC)\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npackage hu.pj.alg.test;\n\nimport hu.pj.alg.BoundedKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class BoundedKnapsackForTourists {\n    public BoundedKnapsackForTourists() {\n        BoundedKnapsack bok = new BoundedKnapsack(400); // 400 dkg = 400 dag = 4 kg\n\n        // making the list of items that you want to bring\n        bok.add(\"map\", 9, 150, 1);\n        bok.add(\"compass\", 13, 35, 1);\n        bok.add(\"water\", 153, 200, 3);\n        bok.add(\"sandwich\", 50, 60, 2);\n        bok.add(\"glucose\", 15, 60, 2);\n        bok.add(\"tin\", 68, 45, 3);\n        bok.add(\"banana\", 27, 60, 3);\n        bok.add(\"apple\", 39, 40, 3);\n        bok.add(\"cheese\", 23, 30, 1);\n        bok.add(\"beer\", 52, 10, 3);\n        bok.add(\"suntan cream\", 11, 70, 1);\n        bok.add(\"camera\", 32, 30, 1);\n        bok.add(\"t-shirt\", 24, 15, 2);\n        bok.add(\"trousers\", 48, 10, 2);\n        bok.add(\"umbrella\", 73, 40, 1);\n        bok.add(\"waterproof trousers\", 42, 70, 1);\n        bok.add(\"waterproof overclothes\", 43, 75, 1);\n        bok.add(\"note-case\", 22, 80, 1);\n        bok.add(\"sunglasses\", 7, 20, 1);\n        bok.add(\"towel\", 18, 12, 2);\n        bok.add(\"socks\", 4, 50, 1);\n        bok.add(\"book\", 30, 10, 2);\n\n        // calculate the solution:\n        List<Item> itemList = bok.calcSolution();\n\n        // write out the solution in the standard output\n        if (bok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(bok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(bok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                bok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry te following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() > 0) {\n                    System.out.format(\n                        \"%1$-10s %2$-23s %3$-3s %4$-5s %5$-15s \\n\",\n                        item.getInKnapsack() + \" unit(s) \",\n                        item.getName(),\n                        item.getInKnapsack() * item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getInKnapsack() * item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new BoundedKnapsackForTourists();\n    }\n} // class\n\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.util.*;\n\npublic class BoundedKnapsack extends ZeroOneKnapsack {\n    public BoundedKnapsack() {}\n\n    public BoundedKnapsack(int _maxWeight) {\n        setMaxWeight(_maxWeight);\n    }\n\n    public BoundedKnapsack(List<Item> _itemList) {\n        setItemList(_itemList);\n    }\n\n    public BoundedKnapsack(List<Item> _itemList, int _maxWeight) {\n        setItemList(_itemList);\n        setMaxWeight(_maxWeight);\n    }\n\n    @Override\n    public List<Item> calcSolution() {\n        int n = itemList.size();\n\n        // add items to the list, if bounding > 1\n        for (int i = 0; i < n; i++) {\n            Item item = itemList.get(i);\n            if (item.getBounding() > 1) {\n                for (int j = 1; j < item.getBounding(); j++) {\n                    add(item.getName(), item.getWeight(), item.getValue());\n                }\n            }\n        }\n        \n        super.calcSolution();\n\n        // delete the added items, and increase the original items\n        while (itemList.size() > n) {\n            Item lastItem = itemList.get(itemList.size() - 1);\n            if (lastItem.getInKnapsack() == 1) {\n                for (int i = 0; i < n; i++) {\n                    Item iH = itemList.get(i);\n                    if (lastItem.getName().equals(iH.getName())) {\n                        iH.setInKnapsack(1 + iH.getInKnapsack());\n                        break;\n                    }\n                }\n            }\n            itemList.remove(itemList.size() - 1);\n        }\n\n        return itemList;\n    }\n\n    // add an item to the item list\n    public void add(String name, int weight, int value, int bounding) {\n        if (name.equals(\"\"))\n            name = \"\" + (itemList.size() + 1);\n        itemList.add(new Item(name, weight, value, bounding));\n        setInitialStateForCalculation();\n    }\n} // class\n\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.util.*;\n\npublic class ZeroOneKnapsack {\n    protected List<Item> itemList  = new ArrayList<Item>();\n    protected int maxWeight        = 0;\n    protected int solutionWeight   = 0;\n    protected int profit           = 0;\n    protected boolean calculated   = false;\n\n    public ZeroOneKnapsack() {}\n\n    public ZeroOneKnapsack(int _maxWeight) {\n        setMaxWeight(_maxWeight);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList) {\n        setItemList(_itemList);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList, int _maxWeight) {\n        setItemList(_itemList);\n        setMaxWeight(_maxWeight);\n    }\n\n    // calculte the solution of 0-1 knapsack problem with dynamic method:\n    public List<Item> calcSolution() {\n        int n = itemList.size();\n\n        setInitialStateForCalculation();\n        if (n > 0  &&  maxWeight > 0) {\n            List< List<Integer> > c = new ArrayList< List<Integer> >();\n            List<Integer> curr = new ArrayList<Integer>();\n\n            c.add(curr);\n            for (int j = 0; j <= maxWeight; j++)\n                curr.add(0);\n            for (int i = 1; i <= n; i++) {\n                List<Integer> prev = curr;\n                c.add(curr = new ArrayList<Integer>());\n                for (int j = 0; j <= maxWeight; j++) {\n                    if (j > 0) {\n                        int wH = itemList.get(i-1).getWeight();\n                        curr.add(\n                            (wH > j)\n                            ?\n                            prev.get(j)\n                            :\n                            Math.max(\n                                prev.get(j),\n                                itemList.get(i-1).getValue() + prev.get(j-wH)\n                            )\n                        );\n                    } else {\n                        curr.add(0);\n                    }\n                } // for (j...)\n            } // for (i...)\n            profit = curr.get(maxWeight);\n\n            for (int i = n, j = maxWeight; i > 0  &&  j >= 0; i--) {\n                int tempI   = c.get(i).get(j);\n                int tempI_1 = c.get(i-1).get(j);\n                if (\n                    (i == 0  &&  tempI > 0)\n                    ||\n                    (i > 0  &&  tempI != tempI_1)\n                )\n                {\n                    Item iH = itemList.get(i-1);\n                    int  wH = iH.getWeight();\n                    iH.setInKnapsack(1);\n                    j -= wH;\n                    solutionWeight += wH;\n                }\n            } // for()\n            calculated = true;\n        } // if()\n        return itemList;\n    }\n\n    // add an item to the item list\n    public void add(String name, int weight, int value) {\n        if (name.equals(\"\"))\n            name = \"\" + (itemList.size() + 1);\n        itemList.add(new Item(name, weight, value));\n        setInitialStateForCalculation();\n    }\n\n    // add an item to the item list\n    public void add(int weight, int value) {\n        add(\"\", weight, value); // the name will be \"itemList.size() + 1\"!\n    }\n\n    // remove an item from the item list\n    public void remove(String name) {\n        for (Iterator<Item> it = itemList.iterator(); it.hasNext(); ) {\n            if (name.equals(it.next().getName())) {\n                it.remove();\n            }\n        }\n        setInitialStateForCalculation();\n    }\n\n    // remove all items from the item list\n    public void removeAllItems() {\n        itemList.clear();\n        setInitialStateForCalculation();\n    }\n\n    public int getProfit() {\n        if (!calculated)\n            calcSolution();\n        return profit;\n    }\n\n    public int getSolutionWeight() {return solutionWeight;}\n    public boolean isCalculated() {return calculated;}\n    public int getMaxWeight() {return maxWeight;}\n\n    public void setMaxWeight(int _maxWeight) {\n        maxWeight = Math.max(_maxWeight, 0);\n    }\n\n    public void setItemList(List<Item> _itemList) {\n        if (_itemList != null) {\n            itemList = _itemList;\n            for (Item item : _itemList) {\n                item.checkMembers();\n            }\n        }\n    }\n\n    // set the member with name \"inKnapsack\" by all items:\n    private void setInKnapsackByAll(int inKnapsack) {\n        for (Item item : itemList)\n            if (inKnapsack > 0)\n                item.setInKnapsack(1);\n            else\n                item.setInKnapsack(0);\n    }\n\n    // set the data members of class in the state of starting the calculation:\n    protected void setInitialStateForCalculation() {\n        setInKnapsackByAll(0);\n        calculated     = false;\n        profit         = 0;\n        solutionWeight = 0;\n    }\n} // class\n\npackage hu.pj.obj;\n\npublic class Item {\n    protected String name    = \"\";\n    protected int weight     = 0;\n    protected int value      = 0;\n    protected int bounding   = 1; // the maximal limit of item's pieces\n    protected int inKnapsack = 0; // the pieces of item in solution\n\n    public Item() {}\n\n    public Item(Item item) {\n        setName(item.name);\n        setWeight(item.weight);\n        setValue(item.value);\n        setBounding(item.bounding);\n    }\n\n    public Item(int _weight, int _value) {\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(int _weight, int _value, int _bounding) {\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public Item(String _name, int _weight, int _value) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(String _name, int _weight, int _value, int _bounding) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public void setName(String _name) {name = _name;}\n    public void setWeight(int _weight) {weight = Math.max(_weight, 0);}\n    public void setValue(int _value) {value = Math.max(_value, 0);}\n\n    public void setInKnapsack(int _inKnapsack) {\n        inKnapsack = Math.min(getBounding(), Math.max(_inKnapsack, 0));\n    }\n\n    public void setBounding(int _bounding) {\n        bounding = Math.max(_bounding, 0);\n        if (bounding == 0)\n            inKnapsack = 0;\n    }\n\n    public void checkMembers() {\n        setWeight(weight);\n        setValue(value);\n        setBounding(bounding);\n        setInKnapsack(inKnapsack);\n    }\n\n    public String getName() {return name;}\n    public int getWeight() {return weight;}\n    public int getValue() {return value;}\n    public int getInKnapsack() {return inKnapsack;}\n    public int getBounding() {return bounding;}\n} // class\n\n\nOutput:\nMaximal weight           = 4 kg\nTotal weight of solution = 3,96 kg\nTotal value              = 1010\n\nYou can carry te following materials in the knapsack:\n1 unit(s)  map                     9   dag   (value = 150)   \n1 unit(s)  compass                 13  dag   (value = 35)    \n1 unit(s)  water                   153 dag   (value = 200)   \n2 unit(s)  glucose                 30  dag   (value = 120)   \n3 unit(s)  banana                  81  dag   (value = 180)   \n1 unit(s)  cheese                  23  dag   (value = 30)    \n1 unit(s)  suntan cream            11  dag   (value = 70)    \n1 unit(s)  waterproof overclothes  43  dag   (value = 75)    \n1 unit(s)  note-case               22  dag   (value = 80)    \n1 unit(s)  sunglasses              7   dag   (value = 20)    \n1 unit(s)  socks                   4   dag   (value = 50)   \n\n", "explain": "General dynamic solution after wikipedia. The solution extends the method of Knapsack problem/0-1#Java .\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\n\nusing System;  // 4790@3.6\nclass program\n{\n    static void Main()\n    {\n        knapSack(40);\n        var sw = System.Diagnostics.Stopwatch.StartNew();\n        Console.Write(knapSack(400) + \"\\n\" + sw.Elapsed);  // 51 \u00b5s\n        Console.Read();\n    }\n\n    static string knapSack(uint w1)\n    {\n        init(); change();\n        uint n = (uint)w.Length; var K = new uint[n + 1, w1 + 1];\n        for (uint vi, wi, w0, x, i = 0; i < n; i++)\n            for (vi = v[i], wi = w[i], w0 = 1; w0 <= w1; w0++)\n            {\n                x = K[i, w0];\n                if (wi <= w0) x = max(vi + K[i, w0 - wi], x);\n                K[i + 1, w0] = x;\n            }\n        string str = \"\";\n        for (uint v1 = K[n, w1]; v1 > 0; n--)\n            if (v1 != K[n - 1, w1])\n            {\n                v1 -= v[n - 1]; w1 -= w[n - 1]; str += items[n - 1] + \"\\n\";\n            }\n        return str;\n    }\n\n    static uint max(uint a, uint b) { return a > b ? a : b; }\n\n    static byte[] w, v; static string[] items;\n\n    static byte[] p = { 1, 1, 2, 2, 2, 3, 3, 3, 1, 3, 1, 1, 2, 2, 1, 1, 1, 1, 1, 2, 1, 2 };\n\n    static void init()\n    {\n        w = new byte[] { 9, 13, 153, 50, 15, 68, 27, 39, 23, 52, 11,\n                          32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30 };\n\n        v = new byte[] { 150, 35, 200, 60, 60, 45, 60, 40, 30, 10, 70,\n                          30, 15, 10, 40, 70, 75, 80, 20, 12, 50, 10 };\n\n        items = new string[] {\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\n                              \"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\n                              \"camera\",\"T-shirt\",\"trousers\",\"umbrella\",\n                              \"waterproof trousers\",\"waterproof overclothes\",\n                              \"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\"};\n    }\n\n    static void change()\n    {\n        int n = w.Length, s = 0, i, j, k; byte xi;\n        for (i = 0; i < n; i++) s += p[i];\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = w[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            w = x;\n        }\n        {\n            byte[] x = new byte[s];\n            for (k = i = 0; i < n; i++)\n                for (xi = v[i], j = p[i]; j > 0; j--) x[k++] = xi;\n            v = x;\n        }\n        string[] pItems = new string[s]; string itemI;\n        for (k = i = 0; i < n; i++)\n            for (itemI = items[i], j = p[i]; j > 0; j--) pItems[k++] = itemI;\n        items = pItems;\n    }\n}\n\n", "explain": "Similar to Knapsack/0-1.\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\n<html><head><title></title></head><body></body></html>\n\n<script type=\"text/javascript\">\nvar data= [\n  {name: 'map',                    weight:  9, value:150, pieces:1},\n  {name: 'compass',                weight: 13, value: 35, pieces:1},\n  {name: 'water',                  weight:153, value:200, pieces:2},\n  {name: 'sandwich',               weight: 50, value: 60, pieces:2},\n  {name: 'glucose',                weight: 15, value: 60, pieces:2},\n  {name: 'tin',                    weight: 68, value: 45, pieces:3},\n  {name: 'banana',                 weight: 27, value: 60, pieces:3},\n  {name: 'apple',                  weight: 39, value: 40, pieces:3},\n  {name: 'cheese',                 weight: 23, value: 30, pieces:1},\n  {name: 'beer',                   weight: 52, value: 10, pieces:3},\n  {name: 'suntan, cream',          weight: 11, value: 70, pieces:1},\n  {name: 'camera',                 weight: 32, value: 30, pieces:1},\n  {name: 'T-shirt',                weight: 24, value: 15, pieces:2},\n  {name: 'trousers',               weight: 48, value: 10, pieces:2},\n  {name: 'umbrella',               weight: 73, value: 40, pieces:1},\n  {name: 'waterproof, trousers',   weight: 42, value: 70, pieces:1},\n  {name: 'waterproof, overclothes',weight: 43, value: 75, pieces:1},\n  {name: 'note-case',              weight: 22, value: 80, pieces:1},\n  {name: 'sunglasses',             weight:  7, value: 20, pieces:1},\n  {name: 'towel',                  weight: 18, value: 12, pieces:2},\n  {name: 'socks',                  weight:  4, value: 50, pieces:1},\n  {name: 'book',                   weight: 30, value: 10, pieces:2}\n];\n\nfunction findBestPack() {\n\tvar m= [[0]]; // maximum pack value found so far\n\tvar b= [[0]]; // best combination found so far\n\tvar opts= [0]; // item index for 0 of item 0 \n\tvar P= [1]; // item encoding for 0 of item 0\n\tvar choose= 0;\n\tfor (var j= 0; j<data.length; j++) {\n\t\topts[j+1]= opts[j]+data[j].pieces; // item index for 0 of item j+1\n\t\tP[j+1]= P[j]*(1+data[j].pieces); // item encoding for 0 of item j+1\n\t}\n\tfor (var j= 0; j<opts[data.length]; j++) {\n\t\tm[0][j+1]= b[0][j+1]= 0; // best values and combos for empty pack: nothing\n\t}\n\tfor (var w=1; w<=400; w++) {\n\t\tm[w]= [0];\n\t\tb[w]= [0];\n\t\tfor (var j=0; j<data.length; j++) {\n\t\t\tvar N= data[j].pieces; // how many of these can we have?\n\t\t\tvar base= opts[j]; // what is the item index for 0 of these?\n\t\t\tfor (var n= 1; n<=N; n++) {\n\t\t\t\tvar W= n*data[j].weight; // how much do these items weigh?\n\t\t\t\tvar s= w>=W ?1 :0; // can we carry this many?\n\t\t\t\tvar v= s*n*data[j].value; // how much are they worth?\n\t\t\t\tvar I= base+n; // what is the item number for this many?\n\t\t\t\tvar wN= w-s*W; // how much other stuff can we be carrying?\n\t\t\t\tvar C= n*P[j] + b[wN][base]; // encoded combination\n\t\t\t\tm[w][I]= Math.max(m[w][I-1], v+m[wN][base]); // best value\n\t\t\t\tchoose= b[w][I]= m[w][I]>m[w][I-1] ?C :b[w][I-1];\n\t\t\t}\n\t\t}\n\t}\n\tvar best= [];\n\tfor (var j= data.length-1; j>=0; j--) {\n\t\tbest[j]= Math.floor(choose/P[j]);\n\t\tchoose-= best[j]*P[j];\n\t}\n\tvar out='<table><tr><td><b>Count</b></td><td><b>Item</b></td><th>unit weight</th><th>unit value</th>';\n\tvar wgt= 0;\n\tvar val= 0;\n\tfor (var i= 0; i<best.length; i++) {\n\t\tif (0==best[i]) continue;\n\t\tout+='</tr><tr><td>'+best[i]+'</td><td>'+data[i].name+'</td><td>'+data[i].weight+'</td><td>'+data[i].value+'</td>'\n\t\twgt+= best[i]*data[i].weight;\n\t\tval+= best[i]*data[i].value;\n\t}\n\tout+= '</tr></table><br/>Total weight: '+wgt;\n\tout+= '<br/>Total value: '+val;\n\tdocument.body.innerHTML= out;\n}\nfindBestPack();\n</script>\n\n\n\n\nCount\n\nItem\n\nunit weight\n\nunit value\n\n\n1\n\nmap\n\n9\n\n150\n\n\n1\n\ncompass\n\n13\n\n35\n\n\n1\n\nwater\n\n153\n\n200\n\n\n2\n\nglucose\n\n15\n\n60\n\n\n3\n\nbanana\n\n27\n\n60\n\n\n1\n\ncheese\n\n23\n\n30\n\n\n1\n\nsuntan, cream\n\n11\n\n70\n\n\n1\n\nwaterproof, overclothes\n\n43\n\n75\n\n\n1\n\nnote-case\n\n22\n\n80\n\n\n1\n\nsunglasses\n\n7\n\n20\n\n\n1\n\nsocks\n\n4\n\n50\n\n\n", "explain": "Based on the (dynamic) J implementation.  Expressed as an htm page:\nThis will generate (translating html to mediawiki markup):\nTotal weight: 396\nTotal value: 1010\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\ntype Item struct {\n\tname               string\n\tweight, value, qty int\n}\n\nvar items = []Item{\n\t{\"map\",\t\t\t9,\t150,\t1},\n\t{\"compass\",\t\t13,\t35,\t1},\n\t{\"water\",\t\t153,\t200,\t2},\n\t{\"sandwich\",\t\t50,\t60,\t2},\n\t{\"glucose\",\t\t15,\t60,\t2},\n\t{\"tin\",\t\t\t68,\t45,\t3},\n\t{\"banana\",\t\t27,\t60,\t3},\n\t{\"apple\",\t\t39,\t40,\t3},\n\t{\"cheese\",\t\t23,\t30,\t1},\n\t{\"beer\",\t\t52,\t10,\t3},\n\t{\"suntancream\",\t\t11,\t70,\t1},\n\t{\"camera\",\t\t32,\t30,\t1},\n\t{\"T-shirt\",\t\t24,\t15,\t2},\n\t{\"trousers\",\t\t48,\t10,\t2},\n\t{\"umbrella\",\t\t73,\t40,\t1},\n\t{\"w-trousers\",\t\t42,\t70,\t1},\n\t{\"w-overclothes\",\t43,\t75,\t1},\n\t{\"note-case\",\t\t22,\t80,\t1},\n\t{\"sunglasses\",\t\t7,      20,\t1},\n\t{\"towel\",\t\t18,\t12,\t2},\n\t{\"socks\",\t\t4,      50,\t1},\n\t{\"book\",\t\t30,\t10,\t2},\n}\n\ntype Chooser struct {\n\tItems []Item\n\tcache map[key]solution\n}\n\ntype key struct {\n\tw, p int\n}\n\ntype solution struct {\n\tv, w int\n\tqty  []int\n}\n\nfunc (c Chooser) Choose(limit int) (w, v int, qty []int) {\n\tc.cache = make(map[key]solution)\n\ts := c.rchoose(limit, len(c.Items)-1)\n\tc.cache = nil // allow cache to be garbage collected\n\treturn s.v, s.w, s.qty\n}\n\nfunc (c Chooser) rchoose(limit, pos int) solution {\n\tif pos < 0 || limit <= 0 {\n\t\treturn solution{0, 0, nil}\n\t}\n\n\tkey := key{limit, pos}\n\tif s, ok := c.cache[key]; ok {\n\t\treturn s\n\t}\n\n\tbest_i, best := 0, solution{0, 0, nil}\n\tfor i := 0; i*items[pos].weight <= limit && i <= items[pos].qty; i++ {\n\t\tsol := c.rchoose(limit-i*items[pos].weight, pos-1)\n\t\tsol.v += i * items[pos].value\n\t\tif sol.v > best.v {\n\t\t\tbest_i, best = i, sol\n\t\t}\n\t}\n\n\tif best_i > 0 {\n\t\t// best.qty is used in another cache entry,\n\t\t// we need to duplicate it before modifying it to\n\t\t// store as our cache entry.\n\t\told := best.qty\n\t\tbest.qty = make([]int, len(items))\n\t\tcopy(best.qty, old)\n\t\tbest.qty[pos] = best_i\n\t\tbest.w += best_i * items[pos].weight\n\t}\n\tc.cache[key] = best\n\treturn best\n}\n\nfunc main() {\n\tv, w, s := Chooser{Items: items}.Choose(400)\n\n\tfmt.Println(\"Taking:\")\n\tfor i, t := range s {\n\t\tif t > 0 {\n\t\t\tfmt.Printf(\"  %d of %d %s\\n\", t, items[i].qty, items[i].name)\n\t\t}\n\t}\n\tfmt.Printf(\"Value: %d; weight: %d\\n\", v, w)\n}\n\n\n\nOutput:\nTaking:\n  1 of 1 map\n  1 of 1 compass\n  1 of 2 water\n  2 of 2 glucose\n  3 of 3 banana\n  1 of 1 cheese\n  1 of 1 suntancream\n  1 of 1 w-overclothes\n  1 of 1 note-case\n  1 of 1 sunglasses\n  1 of 1 socks\nValue: 1010; weight: 396\n", "explain": "Solution with caching.\n(A simple test and benchmark used while making changes to make sure performance wasn't sacrificed is available at /Go_test.)\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nTranslation of: Python\n# Item struct to represent each item in the problem\nStruct.new('Item', :name, :weight, :value, :count)\n\n$items = [\n  Struct::Item.new('map', 9, 150, 1),\n  Struct::Item.new('compass', 13, 35, 1),\n  Struct::Item.new('water', 153, 200, 3),\n  Struct::Item.new('sandwich', 50, 60, 2),\n  Struct::Item.new('glucose', 15, 60, 2),\n  Struct::Item.new('tin', 68, 45, 3),\n  Struct::Item.new('banana', 27, 60, 3),\n  Struct::Item.new('apple', 39, 40, 3),\n  Struct::Item.new('cheese', 23, 30, 1),\n  Struct::Item.new('beer', 52, 10, 3),\n  Struct::Item.new('suntan cream', 11, 70, 1),\n  Struct::Item.new('camera', 32, 30, 1),\n  Struct::Item.new('t-shirt', 24, 15, 2),\n  Struct::Item.new('trousers', 48, 10, 2),\n  Struct::Item.new('umbrella', 73, 40, 1),\n  Struct::Item.new('w-trousers', 42, 70, 1),\n  Struct::Item.new('w-overcoat', 43, 75, 1),\n  Struct::Item.new('note-case', 22, 80, 1),\n  Struct::Item.new('sunglasses', 7, 20, 1),\n  Struct::Item.new('towel', 18, 12, 2),\n  Struct::Item.new('socks', 4, 50, 1),\n  Struct::Item.new('book', 30, 10, 2)\n]\n\ndef choose_item(weight, id, cache)\n  return 0, [] if id < 0\n\n  k = [weight, id]\n  return cache[k] unless cache[k].nil?\n  value = $items[id].value\n  best_v = 0\n  best_list = []\n  ($items[id].count+1).times do |i|\n    wlim = weight - i * $items[id].weight\n    break if wlim < 0\n    val, taken = choose_item(wlim, id - 1, cache)\n    if val + i * value > best_v\n      best_v = val + i * value\n      best_list = taken + [i]\n    end\n  end\n  cache[k] = [best_v, best_list]\n  return [best_v, best_list]\nend\n\nval, list = choose_item(400, $items.length - 1, {})\nw = 0\nlist.each_with_index do |cnt, i|\n  if cnt > 0\n    print \"#{cnt} #{$items[i].name}\\n\"\n    w += $items[i][1] * cnt\n  end\nend\n\np \"Total weight: #{w}, Value: #{val}\"\n\n", "explain": ""}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nTranslation of: Python\npublic struct KnapsackItem: Hashable {\n  public var name: String\n  public var weight: Int\n  public var value: Int\n\n  public init(name: String, weight: Int, value: Int) {\n    self.name = name\n    self.weight = weight\n    self.value = value\n  }\n}\n\npublic func knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n\n  for j in 1...items.count {\n    let item = items[j-1]\n\n    for w in 1...limit {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n\n  var result = [KnapsackItem]()\n  var w = limit\n\n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w] != table[j-1][w] {\n    let item = items[j-1]\n\n    result.append(item)\n\n    w -= item.weight\n  }\n\n  return result\n}\n\ntypealias GroupedItem = (name: String, weight: Int, val: Int, n: Int)\n\nlet groupedItems: [GroupedItem] = [\n  (\"map\", 9, 150, 1),\n  (\"compass\", 13, 35, 1),\n  (\"water\", 153, 200, 3),\n  (\"sandwich\", 50, 60, 2),\n  (\"glucose\", 15, 60, 2),\n  (\"tin\", 68, 45, 3),\n  (\"banana\", 27, 60, 3),\n  (\"apple\", 39, 40, 3),\n  (\"cheese\", 23, 30, 1),\n  (\"beer\", 52, 10, 3),\n  (\"suntan cream\", 11, 70, 1),\n  (\"camera\", 32, 30, 1),\n  (\"t-shirt\", 24, 15, 2),\n  (\"trousers\", 48, 10, 2),\n  (\"umbrella\", 73, 40, 1),\n  (\"waterproof trousers\", 42, 70, 1),\n  (\"waterproof overclothes\", 43, 75, 1),\n  (\"note-case\", 22, 80, 1),\n  (\"sunglasses\", 7, 20, 1),\n  (\"towel\", 18, 12, 2),\n  (\"socks\", 4, 50, 1),\n  (\"book\", 30, 10, 2)\n]\n\nlet items = groupedItems.flatMap({item in\n  (0..<item.n).map({_ in KnapsackItem(name: item.name, weight: item.weight, value: item.val) })\n})\n\nlet bagged = knapsack(items: items, limit: 400)\nlet (totalVal, totalWeight) = bagged.reduce((0, 0), {cur, item in (cur.0 + item.value, cur.1 + item.weight) })\n\nprint(\"Bagged the following \\(bagged.count) items:\")\n\nfor item in bagged {\n  print(\"\\t\\(item.name)\")\n}\n\nprint(\"For a total value of \\(totalVal) and weight of \\(totalWeight)\")\n\n\nOutput:\nBagged the following 14 items:\n\tsocks\n\tsunglasses\n\tnote-case\n\twaterproof overclothes\n\tsuntan cream\n\tcheese\n\tbanana\n\tbanana\n\tbanana\n\tglucose\n\tglucose\n\twater\n\tcompass\n\tmap\nFor a total value of 1010 and weight of 396\n\n", "explain": ""}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\n\nlibrary(tidyverse)\nlibrary(rvest)\n\ntask_html= read_html(\"http://rosettacode.org/wiki/Knapsack_problem/Bounded\")\ntask_table= html_nodes(html, \"table\")[[1]] %>%\n  html_table(table, header= T, trim= T) %>%\n  set_names(c(\"items\", \"weight\", \"value\", \"pieces\")) %>%\n  filter(items != \"knapsack\") %>%\n  mutate(weight= as.numeric(weight),\n         value= as.numeric(value),\n         pieces= as.numeric(pieces))\n\n\nlibrary(rgenoud)\n\nfitness= function(x= rep(1, nrow(task_table))){\n  total_value= sum(task_table$value * x)\n  total_weight= sum(task_table$weight * x)\n  ifelse(total_weight <= 400, total_value, 400-total_weight)\n}\n\nallowed= matrix(c(rep(0, nrow(task_table)), task_table$pieces), ncol = 2)\nset.seed(42)\nevolution= genoud(fn= fitness, \n                  nvars= nrow(allowed), \n                  max= TRUE,\n                  pop.size= 10000,\n                  data.type.int= TRUE, \n                  Domains= allowed)\n\ncat(\"Value: \", evolution$value, \"\\n\")\ncat(\"Weight:\", sum(task_table$weight * evolution$par), \"dag\", \"\\n\")\ndata.frame(item= task_table$items, pieces= as.integer(solution)) %>%\n  filter(solution> 0)\n\n\nOutput:\nValue:  1010 \nWeight: 396 dag \n                     item pieces\n1                     map      1\n2                 compass      1\n3                sandwich      1\n4                 glucose      2\n5                  banana      3\n6                   apple      2\n7                  cheese      1\n8            suntan cream      1\n9  waterproof overclothes      1\n10              note-case      1\n11             sunglasses      1\n12                  towel      1\n13                  socks      1\n\n", "explain": "Reading in task via web scraping.\n\nSolution of the task using genetic algorithm.\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\nWorks with: Julia version 0.6\n\nusing MathProgBase, Cbc\n\nstruct KPDSupply{T<:Integer}\n    item::String\n    weight::T\n    value::T\n    quant::T\nend\nBase.show(io::IO, kdps::KPDSupply) = print(io, kdps.quant, \" \", kdps.item, \" ($(kdps.weight) kg, $(kdps.value) \u20ac)\")\n\nfunction solve(gear::Vector{KPDSupply{T}}, capacity::Integer) where T<:Integer\n    w = getfield.(gear, :weight)\n    v = getfield.(gear, :value)\n    q = getfield.(gear, :quant)\n    sol = mixintprog(-v, w', '<', capacity, :Int, 0, q, CbcSolver())\n    sol.status == :Optimal || error(\"this problem could not be solved\")\n\n    if all(q .== 1) # simpler case\n        return gear[sol.sol == 1.0]\n    else\n        pack = similar(gear, 0)\n        s = round.(Int, sol.sol)\n        for (i, g) in enumerate(gear)\n            iszero(s[i]) && continue\n            push!(pack, KPDSupply(g.item, g.weight, g.value, s[i]))\n        end\n        return pack\n    end\nend\n\n\ngear = [KPDSupply(\"map\", 9, 150, 1),\n        KPDSupply(\"compass\", 13, 35, 1),\n        KPDSupply(\"water\", 153, 200, 2),\n        KPDSupply(\"sandwich\", 50, 60, 2),\n        KPDSupply(\"glucose\", 15, 60, 2),\n        KPDSupply(\"tin\", 68, 45, 3),\n        KPDSupply(\"banana\", 27, 60, 3),\n        KPDSupply(\"apple\", 39, 40, 3),\n        KPDSupply(\"cheese\", 23, 30, 1),\n        KPDSupply(\"beer\", 52, 10, 3),\n        KPDSupply(\"suntan cream\", 11, 70, 1),\n        KPDSupply(\"camera\", 32, 30, 1),\n        KPDSupply(\"T-shirt\", 24, 15, 2),\n        KPDSupply(\"trousers\", 48, 10, 2),\n        KPDSupply(\"umbrella\", 73, 40, 1),\n        KPDSupply(\"waterproof trousers\", 42, 70, 1),\n        KPDSupply(\"waterproof overclothes\", 43, 75, 1),\n        KPDSupply(\"note-case\", 22, 80, 1),\n        KPDSupply(\"sunglasses\", 7, 20, 1),\n        KPDSupply(\"towel\", 18, 12, 2),\n        KPDSupply(\"socks\", 4, 50, 1),\n        KPDSupply(\"book\", 30, 10, 2)]\n\npack = solve(gear, 400)\nprintln(\"The hiker should pack: \\n - \", join(pack, \"\\n - \"))\nprintln(\"\\nPacked weight: \", sum(getfield.(pack, :weight)), \" kg\")\nprintln(\"Packed value: \", sum(getfield.(pack, :value)), \" \u20ac\")\n\n\nOutput:\nThe hiker should pack:\n - 1 map (9 kg, 150 \u20ac)\n - 1 compass (13 kg, 35 \u20ac)\n - 1 water (153 kg, 200 \u20ac)\n - 2 glucose (15 kg, 60 \u20ac)\n - 3 banana (27 kg, 60 \u20ac)\n - 1 cheese (23 kg, 30 \u20ac)\n - 1 suntan cream (11 kg, 70 \u20ac)\n - 1 waterproof overclothes (43 kg, 75 \u20ac)\n - 1 note-case (22 kg, 80 \u20ac)\n - 1 sunglasses (7 kg, 20 \u20ac)\n - 1 socks (4 kg, 50 \u20ac)\n\nPacked weight: 327 kg\nPacked value: 830 \u20ac\n", "explain": "The solution uses Julia's MathProgBase.  Most of the work is done with this package's mixintprog function.\nType and Function:\nMain:\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\n\n/* create SAS data set */\ndata mydata;\n   input item $1-23 weight value pieces;\n   datalines;\nmap                      9  150  1  \ncompass                 13   35  1  \nwater                  153  200  2  \nsandwich                50   60  2  \nglucose                 15   60  2  \ntin                     68   45  3  \nbanana                  27   60  3  \napple                   39   40  3  \ncheese                  23   30  1  \nbeer                    52   10  3  \nsuntan cream            11   70  1  \ncamera                  32   30  1  \nT-shirt                 24   15  2  \ntrousers                48   10  2  \numbrella                73   40  1  \nwaterproof trousers     42   70  1  \nwaterproof overclothes  43   75  1  \nnote-case               22   80  1  \nsunglasses               7   20  1  \ntowel                   18   12  2  \nsocks                    4   50  1  \nbook                    30   10  2  \n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare sets and parameters, and read input data */\n   set <str> ITEMS;\n   num weight {ITEMS};\n   num value {ITEMS};\n   num pieces {ITEMS};\n   read data mydata into ITEMS=[item] weight value pieces;\n\n   /* declare variables, objective, and constraints */\n   var NumSelected {i in ITEMS} >= 0 <= pieces[i] integer;\n   max TotalValue = sum {i in ITEMS} value[i] * NumSelected[i];\n   con WeightCon:\n      sum {i in ITEMS} weight[i] * NumSelected[i] <= 400;\n\n   /* call mixed integer linear programming (MILP) solver */\n   solve;\n\n   /* print optimal solution */\n   print TotalValue;\n   print {i in ITEMS: NumSelected[i].sol > 0.5} NumSelected;\nquit;\n\n\nTotalValue \n1010 \n\n[1] NumSelected \nbanana 3 \ncheese 1 \ncompass 1 \nglucose 2 \nmap 1 \nnote-case 1 \nsocks 1 \nsunglasses 1 \nsuntan cream 1 \nwater 1 \nwaterproof overclothes 1 \n\n", "explain": "Use MILP solver in SAS/OR:\nOutput:\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nTranslation of: C\n// version 1.1.2\n\ndata class Item(val name: String, val weight: Int, val value: Int, val count: Int)\n\nval items = listOf(\n    Item(\"map\", 9, 150, 1),\n    Item(\"compass\", 13, 35, 1),\n    Item(\"water\", 153, 200, 2),\n    Item(\"sandwich\", 50, 60, 2),\n    Item(\"glucose\", 15, 60, 2),\n    Item(\"tin\", 68, 45, 3),\n    Item(\"banana\", 27, 60, 3),\n    Item(\"apple\", 39, 40, 3),\n    Item(\"cheese\", 23, 30, 1),\n    Item(\"beer\", 52, 10, 3),\n    Item(\"suntan cream\", 11, 70, 1),\n    Item(\"camera\", 32, 30, 1),\n    Item(\"T-shirt\", 24, 15, 2),\n    Item(\"trousers\", 48, 10, 2),\n    Item(\"umbrella\", 73, 40, 1),\n    Item(\"waterproof trousers\", 42, 70, 1),\n    Item(\"waterproof overclothes\", 43, 75, 1),\n    Item(\"note-case\", 22, 80, 1),\n    Item(\"sunglasses\", 7, 20, 1),\n    Item(\"towel\", 18, 12, 2),\n    Item(\"socks\", 4, 50, 1),\n    Item(\"book\", 30, 10, 2)\n)\n\nval n = items.size\n\nconst val MAX_WEIGHT = 400\n\nfun knapsack(w: Int): IntArray {\n    val m  = Array(n + 1) { IntArray(w + 1) }\n    for (i in 1..n) {\n        for (j in 0..w) {\n            m[i][j] = m[i - 1][j]\n            for (k in 1..items[i - 1].count) {\n                if (k * items[i - 1].weight > j) break\n                val v = m[i - 1][j - k * items[i - 1].weight] + k * items[i - 1].value\n                if (v > m[i][j]) m[i][j] = v\n            }\n        }\n    }\n    val s = IntArray(n)\n    var j = w\n    for (i in n downTo 1) {\n        val v = m[i][j]\n        var k = 0\n        while (v != m[i - 1][j] + k * items[i - 1].value) {\n            s[i - 1]++\n            j -= items[i - 1].weight\n            k++\n        }\n    }\n    return s\n}\n\nfun main(args: Array<String>) {\n   val s = knapsack(MAX_WEIGHT)\n   println(\"Item Chosen             Weight Value  Number\")\n   println(\"---------------------   ------ -----  ------\")\n   var itemCount = 0\n   var sumWeight = 0\n   var sumValue  = 0\n   var sumNumber = 0\n   for (i in 0 until n) {\n       if (s[i] == 0) continue\n       itemCount++\n       val name   = items[i].name\n       val number = s[i]\n       val weight = items[i].weight * number\n       val value  = items[i].value  * number\n       sumNumber += number\n       sumWeight += weight\n       sumValue  += value\n       println(\"${name.padEnd(22)}    ${\"%3d\".format(weight)}   ${\"%4d\".format(value)}    ${\"%2d\".format(number)}\")\n   }\n   println(\"---------------------   ------ -----  ------\")\n   println(\"Items chosen $itemCount           ${\"%3d\".format(sumWeight)}   ${\"%4d\".format(sumValue)}    ${\"%2d\".format(sumNumber)}\")\n}\n\n\nOutput:\nItem Chosen             Weight Value  Number\n---------------------   ------ -----  ------\nmap                         9    150     1\ncompass                    13     35     1\nwater                     153    200     1\nglucose                    30    120     2\nbanana                     81    180     3\ncheese                     23     30     1\nsuntan cream               11     70     1\nwaterproof overclothes     43     75     1\nnote-case                  22     80     1\nsunglasses                  7     20     1\nsocks                       4     50     1\n---------------------   ------ -----  ------\nItems chosen 11           396   1010    14\n\n", "explain": ""}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\n#!/usr/bin/perl\n\nuse strict;\n\nmy $raw = <<'TABLE';\nmap     \t9       150     1\ncompass \t13      35      1\nwater   \t153     200     2\nsandwich        50      60      2\nglucose \t15      60      2\ntin     \t68      45      3\nbanana  \t27      60      3\napple  \t\t39      40      3\ncheese  \t23      30      1\nbeer    \t52      10      1\nsuntancream     11      70      1\ncamera  \t32      30      1\nT-shirt \t24      15      2\ntrousers        48      10      2\numbrella        73      40      1\nw_trousers     \t42      70      1\nw_overcoat  \t43      75      1\nnote-case       22      80      1\nsunglasses      7       20      1\ntowel   \t18      12      2\nsocks   \t4       50      1\nbook    \t30      10      2\nTABLE\n \nmy @items;\nfor (split \"\\n\", $raw) {\n        my @x = split /\\s+/;\n\tpush @items, {\n\t\tname\t=> $x[0],\n\t\tweight\t=> $x[1],\n\t\tvalue\t=> $x[2],\n\t\tquant\t=> $x[3],\n\t}\n}\n\nmy $max_weight = 400;\n\nmy %cache;\nsub pick {\n\tmy ($weight, $pos) = @_;\n\tif ($pos < 0 or $weight <= 0) {\n\t\treturn 0, 0, []\n\t}\n\n\t@{ $cache{$weight, $pos} //= [do{\t# odd construct: for caching\n\t\tmy $item = $items[$pos];\n\t\tmy ($bv, $bi, $bw, $bp) = (0, 0, 0, []);\n\n\t\tfor my $i (0 .. $item->{quant}) {\n\t\t\tlast if $i * $item->{weight} > $weight;\n\t\t\tmy ($v, $w, $p) = pick($weight - $i * $item->{weight}, $pos - 1);\n\t\t\tnext if ($v += $i * $item->{value}) <= $bv;\n\n\t\t\t($bv, $bi, $bw, $bp) = ($v, $i, $w, $p);\n\t\t}\n\n\t\tmy @picked = ( @$bp, $bi );\n\t\t$bv, $bw + $bi * $item->{weight}, \\@picked\n\t}]}\n}\n\nmy ($v, $w, $p) = pick($max_weight, $#items);\nfor (0 .. $#$p) {\n\tif ($p->[$_] > 0) {\n\t\tprint \"$p->[$_] of $items[$_]{name}\\n\";\n\t}\n}\nprint \"Value: $v; Weight: $w\\n\";\n\n\nOutput:\n1 of map\n1 of compass\n1 of water\n2 of glucose\n3 of banana\n1 of cheese\n1 of suntancream\n1 of w_overcoat\n1 of note-case\n1 of sunglasses\n1 of socks\nValue: 1010; Weight: 396\n", "explain": "Recursive solution with caching.\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI Prolog\nLibrary clpfd[edit]\nLibrary: clpfd\n\n:- use_module(library(clpfd)).\n\n% tuples (name, weights, value, nb pieces).\nknapsack :-\n\tL = [(   map, \t        9, \t150, \t1),\n\t     (   compass, \t13, \t35, \t1),\n\t     (   water, \t153, \t200, \t2),\n\t     (   sandwich, \t50, \t60, \t2),\n\t     (   glucose, \t15, \t60, \t2),\n\t     (   tin, \t68, \t45, \t3),\n\t     (   banana, \t27, \t60, \t3),\n\t     (   apple, \t39, \t40, \t3),\n\t     (   cheese, \t23, \t30, \t1),\n\t     (   beer, \t52, \t10, \t3),\n\t     (   'suntan cream', \t11, \t70, \t1),\n\t     (   camera, \t32, \t30, \t1),\n\t     (   'T-shirt', \t24, \t15, \t2),\n\t     (   trousers, \t48, \t10, \t2),\n\t     (   umbrella, \t73, \t40, \t1),\n\t     (   'waterproof trousers', \t42, \t70, \t1),\n\t     (   'waterproof overclothes', \t43, \t75, \t1),\n\t     (   'note-case', \t22, \t80, \t1),\n\t     (   sunglasses, \t7, \t20, \t1),\n\t     (   towel, \t18, \t12, \t2),\n\t     (   socks, \t4, \t50, \t1),\n\t     (   book, \t30, \t10, \t2)],\n\n\t% Takes is the list of the numbers of each items\n\t% these numbers are between 0 and the 4th value of the tuples of the items\n        maplist(collect, L, Ws, Vs, Takes),\n        scalar_product(Ws, Takes, #=<, 400),\n        scalar_product(Vs, Takes, #=, VM),\n\n\t% to have statistics on the resolution of the problem.\n\ttime(labeling([max(VM), down], Takes)),\n        scalar_product(Ws, Takes, #=, WM),\n\n\t%% displayinf of the results.\n\tcompute_lenword(L, 0, Len),\n\tsformat(A1, '~~w~~t~~~w|', [Len]),\n\tsformat(A2, '~~t~~w~~~w|', [4]),\n\tsformat(A3, '~~t~~w~~~w|', [5]),\n\tprint_results(A1,A2,A3, L, Takes, WM, VM).\n\ncollect((_, W, V, N), W, V, Take) :-\n\tTake in 0..N.\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([(Name, _, _, _)|T], N, NF):-\n\tatom_length(Name, L),\n\t(   L > N -> N1 = L; N1 = N),\n\tcompute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(A1,A2,A3, [], [], WM, WR) :-\n\tsformat(W0, '~w ', [' ']),\n\tsformat(W1, A1, [' ']),\n\tsformat(W2, A2, [WM]),\n\tsformat(W3, A3, [WR]),\n\tformat('~w~w~w~w~n', [W0,W1,W2,W3]).\n\n\nprint_results(A1,A2,A3, [_H|T], [0|TR], WM, VM) :-\n\t!,\n\tprint_results(A1,A2,A3, T, TR, WM, VM).\n\nprint_results(A1, A2, A3, [(Name, W, V, _)|T], [N|TR], WM, VM) :-\n\tsformat(W0, '~w ', [N]),\n\tsformat(W1, A1, [Name]),\n\tsformat(W2, A2, [W]),\n\tsformat(W3, A3, [V]),\n\tformat('~w~w~w~w~n', [W0,W1,W2,W3]),\n\tprint_results(A1, A2, A3, T, TR, WM, VM).\n\n\nOutput:\n\u00a0?- knapsack.\n% 21,154,932 inferences, 3.187 CPU in 3.186 seconds (100% CPU, 6638515 Lips)\n1 map                      9  150\n1 compass                 13   35\n1 water                  153  200\n2 glucose                 15   60\n3 banana                  27   60\n1 cheese                  23   30\n1 suntan cream            11   70\n1 waterproof overclothes  43   75\n1 note-case               22   80\n1 sunglasses               7   20\n1 socks                    4   50\n                         396 1010\ntrue\nLibrary simplex[edit]\n\n:- use_module(library(simplex)).\n% tuples (name, weights, value, pieces).\nknapsack :-\n\tL = [(map, \t9, \t150, \t1),\n\t     (   compass, \t13, \t35, \t1),\n\t     (   water, \t153, \t200, \t2),\n\t     (   sandwich, \t50, \t60, \t2),\n\t     (   glucose, \t15, \t60, \t2),\n\t     (   tin, \t68, \t45, \t3),\n\t     (   banana, \t27, \t60, \t3),\n\t     (   apple, \t39, \t40, \t3),\n\t     (   cheese, \t23, \t30, \t1),\n\t     (   beer, \t52, \t10, \t3),\n\t     (   'suntan cream', \t11, \t70, \t1),\n\t     (   camera, \t32, \t30, \t1),\n\t     (   'T-shirt', \t24, \t15, \t2),\n\t     (   trousers, \t48, \t10, \t2),\n\t     (   umbrella, \t73, \t40, \t1),\n\t     (   'waterproof trousers', \t42, \t70, \t1),\n\t     (   'waterproof overclothes', \t43, \t75, \t1),\n\t     (   'note-case', \t22, \t80, \t1),\n\t     (   sunglasses, \t7, \t20, \t1),\n\t     (   towel, \t18, \t12, \t2),\n\t     (   socks, \t4, \t50, \t1),\n\t     (   book, \t30, \t10, \t2)],\n\n\t gen_state(S0),\n\t length(L, N),\n\t numlist(1, N, LN),\n\t time(( create_constraint_N(LN, L, S0, S1),\n\t\tmaplist(create_constraint_WV, LN, L, LW, LV),\n\t\tconstraint(LW =< 400, S1, S2),\n\t\tmaximize(LV, S2, S3)\n\t      )),\n\tcompute_lenword(L, 0, Len),\n\tsformat(A1, '~~w~~t~~~w|', [Len]),\n\tsformat(A2, '~~t~~w~~~w|', [4]),\n\tsformat(A3, '~~t~~w~~~w|', [5]),\n\tprint_results(S3, A1,A2,A3, L, LN, 0, 0).\n\n\ncreate_constraint_N([], [], S, S).\n\ncreate_constraint_N([HN|TN], [(_, _, _, Nb) | TL], S1, SF) :-\n\tconstraint(integral(x(HN)), S1, S2),\n\tconstraint([x(HN)] =< Nb, S2, S3),\n\tconstraint([x(HN)] >= 0, S3, S4),\n\tcreate_constraint_N(TN, TL, S4, SF).\n\ncreate_constraint_WV(N, (_, W, V, _), W * x(N), V * x(N)).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([(Name, _, _, _)|T], N, NF):-\n\tatom_length(Name, L),\n\t(   L > N -> N1 = L; N1 = N),\n\tcompute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(_S, A1, A2, A3, [], [], WM, VM) :-\n\tsformat(W0, '~w ', [' ']),\n\tsformat(W1, A1, [' ']),\n\tsformat(W2, A2, [WM]),\n\tsformat(W3, A3, [VM]),\n\tformat('~w~w~w~w~n', [W0, W1,W2,W3]).\n\n\nprint_results(S, A1, A2, A3, [(Name, W, V,_)|T], [N|TN], W1, V1) :-\n\tvariable_value(S, x(N), X),\n\t(   X = 0 -> W1 = W2, V1 = V2\n\t;   sformat(S0, '~w ', [X]),\n\t    sformat(S1, A1, [Name]),\n\t    sformat(S2, A2, [W]),\n\t    sformat(S3, A3, [V]),\n\t    format('~w~w~w~w~n', [S0, S1,S2,S3]),\n\t    W2 is W1 + X * W,\n\t    V2 is V1 + X * V),\n\tprint_results(S, A1, A2, A3, T, TN, W2, V2).\n\n", "explain": "Library clpfd is written by Markus Triska. Takes about 3 seconds to compute the best solution.\nLibrary simplex is written by Markus Triska. Takes about 10 seconds to compute the best solution.\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nTranslation of: Python\n\nimport std.stdio, std.typecons, std.functional;\n\nimmutable struct Item {\n    string name;\n    int weight, value, quantity;\n}\n\nimmutable Item[] items = [\n    {\"map\",           9, 150, 1}, {\"compass\",      13,  35, 1},\n    {\"water\",       153, 200, 3}, {\"sandwich\",     50,  60, 2},\n    {\"glucose\",      15,  60, 2}, {\"tin\",          68,  45, 3},\n    {\"banana\",       27,  60, 3}, {\"apple\",        39,  40, 3},\n    {\"cheese\",       23,  30, 1}, {\"beer\",         52,  10, 3},\n    {\"suntan cream\", 11,  70, 1}, {\"camera\",       32,  30, 1},\n    {\"t-shirt\",      24,  15, 2}, {\"trousers\",     48,  10, 2},\n    {\"umbrella\",     73,  40, 1}, {\"w-trousers\",   42,  70, 1},\n    {\"w-overcoat\",   43,  75, 1}, {\"note-case\",    22,  80, 1},\n    {\"sunglasses\",    7,  20, 1}, {\"towel\",        18,  12, 2},\n    {\"socks\",         4,  50, 1}, {\"book\",         30,  10, 2}];\n\nTuple!(int, const(int)[]) chooseItem(in int iWeight, in int idx) nothrow @safe {\n    alias memoChooseItem = memoize!chooseItem;\n    if (idx < 0)\n        return typeof(return)();\n\n    int bestV;\n    const(int)[] bestList;\n    with (items[idx])\n        foreach (immutable i; 0 .. quantity + 1) {\n            immutable wlim = iWeight - i * weight;\n            if (wlim < 0)\n                break;\n\n            //const (val, taken) = memoChooseItem(wlim, idx - 1);\n            const val_taken = memoChooseItem(wlim, idx - 1);\n            if (val_taken[0] + i * value > bestV) {\n                bestV = val_taken[0] + i * value;\n                bestList = val_taken[1] ~ i;\n            }\n        }\n\n    return tuple(bestV, bestList);\n}\n\nvoid main() {\n    // const (v, lst) = chooseItem(400, items.length - 1);\n    const v_lst = chooseItem(400, items.length - 1);\n\n    int w;\n    foreach (immutable i, const cnt; v_lst[1])\n        if (cnt > 0) {\n            writeln(cnt, \" \", items[i].name);\n            w += items[i].weight * cnt;\n        }\n\n    writeln(\"Total weight: \", w, \" Value: \", v_lst[0]);\n}\n\n\nOutput:\n1 map\n1 compass\n1 water\n2 glucose\n3 banana\n1 cheese\n1 suntan cream\n1 w-overcoat\n1 note-case\n1 sunglasses\n1 socks\nTotal weight: 396 Value: 1010\n", "explain": "Solution with memoization.\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\ninv = \t[(\"map\",9,150,1), (\"compass\",13,35,1), (\"water\",153,200,2), (\"sandwich\",50,60,2),\n\t(\"glucose\",15,60,2), (\"tin\",68,45,3), (\"banana\",27,60,3), (\"apple\",39,40,3),\n\t(\"cheese\",23,30,1), (\"beer\",52,10,3), (\"cream\",11,70,1), (\"camera\",32,30,1),\n\t-- what to do if we end up taking one trouser?\n\t(\"tshirt\",24,15,2), (\"trousers\",48,10,2), (\"umbrella\",73,40,1), (\"wtrousers\",42,70,1),\n\t(\"woverclothes\",43,75,1), (\"notecase\",22,80,1), (\"sunglasses\",7,20,1), (\"towel\",18,12,2),\n\t(\"socks\",4,50,1), (\"book\",30,10,2)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n\taddItem (name,w,v,c) old = foldr inc old [1..c] where\n\t\tinc i list = left ++ zipWith max right new where\n\t\t\t(left, right) = splitAt (w * i) list\n\t\t\tnew = map (\\(val,itms)->(val + v * i, (name,i):itms)) old\n\nmain = print $ (knapsack inv) !! 400\n\n\nOutput:\n(1010,[(\"socks\",1),(\"sunglasses\",1),(\"notecase\",1),(\"woverclothes\",1),(\"cream\",1),(\"cheese\",1),(\"banana\",3),(\"glucose\",2),(\"water\",1),(\"compass\",1),(\"map\",1)])\n\n\nimport Data.Array\n\n-- snipped the item list; use the one from above\nknapsack items cap = (solu items) ! cap where\n\tsolu = foldr f (listArray (0,cap) (repeat (0,[])))\n\tf (name,w,v,cnt) ss = listArray (0,cap) $ map optimal [0..] where\n\t\toptimal ww = maximum $ (ss!ww):[prepend (v*i,(name,i)) (ss!(ww - i*w))\n\t\t\t\t\t| i <- [1..cnt], i*w < ww]\n\t\tprepend (x,n) (y,s) = (x+y,n:s)\n\nmain = do print $ knapsack inv 400\n\n", "explain": "Directly lifted from 1-0 problem:\nThe above uses merging lists for cache. It's faster, and maybe easier to understand when some constant-time lookup structure is used for cache (same output):\n"}, {"task_name": "Knapsack problem/Bounded", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/Bounded", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef totalWeight = { list -> list.collect{ it.item.weight * it.count }.sum() }\ndef totalValue = { list -> list.collect{ it.item.value * it.count }.sum() }\n\ndef knapsackBounded = { possibleItems ->\n    def n = possibleItems.size()\n    def m = (0..n).collect{ i -> (0..400).collect{ w -> []} }\n    (1..400).each { w ->\n        (1..n).each { i ->\n            def item = possibleItems[i-1]\n            def wi = item.weight, pi = item.pieces\n            def bi = [w.intdiv(wi),pi].min()\n            m[i][w] = (0..bi).collect{ count ->\n                m[i-1][w - wi * count] + [[item:item, count:count]]\n            }.max(totalValue).findAll{ it.count }\n        }\n    }\n    m[n][400]\n}\n\n\ndef items = [ \n        [name:\"map\",                    weight:  9, value:150, pieces:1],\n        [name:\"compass\",                weight: 13, value: 35, pieces:1],\n        [name:\"water\",                  weight:153, value:200, pieces:2],\n        [name:\"sandwich\",               weight: 50, value: 60, pieces:2],\n        [name:\"glucose\",                weight: 15, value: 60, pieces:2],\n        [name:\"tin\",                    weight: 68, value: 45, pieces:3],\n        [name:\"banana\",                 weight: 27, value: 60, pieces:3],\n        [name:\"apple\",                  weight: 39, value: 40, pieces:3],\n        [name:\"cheese\",                 weight: 23, value: 30, pieces:1],\n        [name:\"beer\",                   weight: 52, value: 10, pieces:3],\n        [name:\"suntan cream\",           weight: 11, value: 70, pieces:1],\n        [name:\"camera\",                 weight: 32, value: 30, pieces:1],\n        [name:\"t-shirt\",                weight: 24, value: 15, pieces:2],\n        [name:\"trousers\",               weight: 48, value: 10, pieces:2],\n        [name:\"umbrella\",               weight: 73, value: 40, pieces:1],\n        [name:\"waterproof trousers\",    weight: 42, value: 70, pieces:1],\n        [name:\"waterproof overclothes\", weight: 43, value: 75, pieces:1],\n        [name:\"note-case\",              weight: 22, value: 80, pieces:1],\n        [name:\"sunglasses\",             weight:  7, value: 20, pieces:1],\n        [name:\"towel\",                  weight: 18, value: 12, pieces:2],\n        [name:\"socks\",                  weight:  4, value: 50, pieces:1],\n        [name:\"book\",                   weight: 30, value: 10, pieces:2],\n]\n \ndef start = System.currentTimeMillis()\ndef packingList = knapsackBounded(items)\ndef elapsed = System.currentTimeMillis() - start\n\nprintln \"Elapsed Time: ${elapsed/1000.0} s\"\nprintln \"Total Weight: ${totalWeight(packingList)}\"\nprintln \" Total Value: ${totalValue(packingList)}\"\npackingList.each {\n    printf ('  item:\u00a0%-22s  weight:%4d  value:%4d  count:%2d\\n',\n            it.item.name, it.item.weight, it.item.value, it.count)\n}\n\n\nOutput:\nElapsed Time: 0.603 s\nTotal Weight: 396\n Total Value: 1010\n  item: map                     weight:   9  value: 150  count: 1\n  item: compass                 weight:  13  value:  35  count: 1\n  item: water                   weight: 153  value: 200  count: 1\n  item: glucose                 weight:  15  value:  60  count: 2\n  item: banana                  weight:  27  value:  60  count: 3\n  item: cheese                  weight:  23  value:  30  count: 1\n  item: suntan cream            weight:  11  value:  70  count: 1\n  item: waterproof overclothes  weight:  43  value:  75  count: 1\n  item: note-case               weight:  22  value:  80  count: 1\n  item: sunglasses              weight:   7  value:  20  count: 1\n  item: socks                   weight:   4  value:  50  count: 1\n", "explain": "Solution: dynamic programming\nTest:\n"}]