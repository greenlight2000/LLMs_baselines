[{"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Python", "code": "\nWorks with: Python version 3.1\n\n# String masquerading as ppm file (version P3)\nimport io\nppmfileout = io.StringIO('')\n\ndef togreyscale(self):\n    for h in range(self.height):\n        for w in range(self.width):\n            r, g, b = self.get(w, h)\n            l = int(0.2126 * r + 0.7152 * g + 0.0722 * b)\n            self.set(w, h, Colour(l, l, l))\n\nBitmap.togreyscale = togreyscale    \n\n\n# Draw something simple\nbitmap = Bitmap(4, 4, white)\nbitmap.fillrect(1, 0, 1, 2, Colour(127, 0, 63))\nbitmap.set(3, 3, Colour(0, 127, 31))\nprint('Colour:')\n# Write to the open 'file' handle\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\nprint('Grey:')\nbitmap.togreyscale()\nppmfileout = io.StringIO('')\nbitmap.writeppmp3(ppmfileout)\nprint(ppmfileout.getvalue())\n\n\n'''\nThe print statement above produces the following output\u00a0:\n\nColour:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n255\n   255 255 255   255 255 255   255 255 255     0 127  31\n   255 255 255   255 255 255   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n   255 255 255   127   0  63   255 255 255   255 255 255\n\nGrey:\nP3\n# generated from Bitmap.writeppmp3\n4 4\n254\n   254 254 254   254 254 254   254 254 254    93  93  93\n   254 254 254   254 254 254   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n   254 254 254    31  31  31   254 254 254   254 254 254\n\n'''\n\n", "explain": "Extending the example given here\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "C", "code": "\n\ntypedef unsigned char luminance;\ntypedef luminance pixel1[1];\ntypedef struct {\n   unsigned int width;\n   unsigned int height;\n   luminance *buf;\n} grayimage_t;\ntypedef grayimage_t *grayimage;\n\ngrayimage alloc_grayimg(unsigned int, unsigned int);\ngrayimage tograyscale(image);\nimage tocolor(grayimage);\n\n\ngrayimage alloc_grayimg(unsigned int width, unsigned int height)\n{\n     grayimage img;\n     img = malloc(sizeof(grayimage_t));\n     img->buf = malloc(width*height*sizeof(pixel1));\n     img->width = width;\n     img->height = height;\n     return img;\n}\n\n\ngrayimage tograyscale(image img)\n{\n   unsigned int x, y;\n   grayimage timg;\n   double rc, gc, bc, l;\n   unsigned int ofs;\n\n   timg = alloc_grayimg(img->width, img->height);\n   \n   for(x=0; x < img->width; x++)\n   {\n      for(y=0; y < img->height; y++)\n      {\n        ofs = (y * img->width) + x;\n        rc = (double) img->buf[ofs][0];\n        gc = (double) img->buf[ofs][1];\n        bc = (double) img->buf[ofs][2];\n        l = 0.2126*rc + 0.7152*gc + 0.0722*bc;\n        timg->buf[ofs][0] = (luminance) (l+0.5);\n      }\n   }\n   return timg;\n}\n\n\nimage tocolor(grayimage img)\n{\n   unsigned int x, y;\n   image timg;\n   luminance l;\n   unsigned int ofs;\n\n   timg = alloc_img(img->width, img->height);\n   \n   for(x=0; x < img->width; x++)\n   {\n      for(y=0; y < img->height; y++)\n      {\n        ofs = (y * img->width) + x;\n        l = img->buf[ofs][0];\n        timg->buf[ofs][0] = l;\n        timg->buf[ofs][1] = l;\n        timg->buf[ofs][2] = l;\n      }\n   }\n   return timg;\n}\n\n\ntocolor and tograyscale do not free the previous image, so it must be freed normally calling free_img. With a cast we can use the same function also for grayscale images, or we can define something like\n#define free_grayimg(IMG) free_img((image)(IMG))\n\nLuminance is rounded. Since the C implementation is based on unsigned char (256 possible values per components), L can be at most 255.0 and rounding gives 255, as we expect. Changing the color_component type would only change 256, 255.0 and 255 values here written in something else, the code would work the same.\n", "explain": "Definition/interface for a grayscale image.\nThe same as alloc_img, but for grayscale images.\nConvert from color image to grayscale image.\nAnd back from a grayscale image to a color image.\nNotes\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Java", "code": "\nvoid convertToGrayscale(final BufferedImage image){\n    for(int i=0; i<image.getWidth(); i++){\n        for(int j=0; j<image.getHeight(); j++){\n            int color = image.getRGB(i,j);\n\n            int alpha = (color >> 24) & 255;\n            int red = (color >> 16) & 255;\n            int green = (color >> 8) & 255;\n            int blue = (color) & 255;\n\n            final int lum = (int)(0.2126 * red + 0.7152 * green + 0.0722 * blue);\n\n            alpha = (alpha << 24);\n            red = (lum << 16);\n            green = (lum << 8);\n            blue = lum;\n\n            color = alpha + red + green + blue;\n\n            image.setRGB(i,j,color);\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "C#", "code": "\n\nBitmap tImage = new Bitmap(\"spectrum.bmp\");\n\nfor (int x = 0; x < tImage.Width; x++)\n{\n\tfor (int y = 0; y < tImage.Height; y++)\n\t{\n\t\tColor tCol = tImage.GetPixel(x, y);\n\n\t\t// L = 0.2126\u00b7R + 0.7152\u00b7G + 0.0722\u00b7B \n\t\tdouble L = 0.2126 * tCol.R + 0.7152 * tCol.G + 0.0722 * tCol.B;\n\t\ttImage.SetPixel(x, y, Color.FromArgb(Convert.ToInt32(L), Convert.ToInt32(L), Convert.ToInt32(L)));\n\t}\n}\n\n// Save\ntImage.Save(\"spectrum2.bmp\");\n\n", "explain": "To convert TO grayscale:\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "JavaScript", "code": "\n\nfunction toGray(img) {\n  let cnv = document.getElementById(\"canvas\");\n  let ctx = cnv.getContext('2d');\n  let imgW = img.width;\n  let imgH = img.height;\n  cnv.width = imgW;\n  cnv.height = imgH;\n  \n  ctx.drawImage(img, 0, 0);\n  let pixels = ctx.getImageData(0, 0, imgW, imgH);\n  for (let y = 0; y < pixels.height; y ++) {\n    for (let x = 0; x < pixels.width; x ++) {\n      let i = (y * 4) * pixels.width + x * 4;\n      let avg = (pixels.data[i] + pixels.data[i + 1] + pixels.data[i + 2]) / 3;\n      \n      pixels.data[i] = avg;\n      pixels.data[i + 1] = avg;\n      pixels.data[i + 2] = avg;\n    }\n  }\n  ctx.putImageData(pixels, 0, 0, 0, 0, pixels.width, pixels.height);\n  return cnv.toDataURL();\n}\n\n", "explain": "HTML 5\nDemonstration: https://repl.it/repls/NiceFaroffRockrat\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Visual_Basic_.NET", "code": "\n\nImports System.Drawing.Imaging\n\n  Public Function Grayscale(ByVal Map As Bitmap) As Bitmap\n\n    Dim oData() As Integer = GetData(Map)\n    Dim oReturn As New Bitmap(Map.Width, Map.Height, Map.PixelFormat)\n    Dim a As Integer = 0\n    Dim r As Integer = 0\n    Dim g As Integer = 0\n    Dim b As Integer = 0\n    Dim l As Integer = 0\n\n    For i As Integer = 0 To oData.GetUpperBound(0)\n      a = (oData(i) >> 24)\n      r = (oData(i) >> 16) And 255\n      g = (oData(i) >> 8) And 255\n      b = oData(i) And 255\n\n      l = CInt(r * 0.2126F + g * 0.7152F + b * 0.0722F)\n\n      oData(i) = (a << 24) Or (l << 16) Or (l << 8) Or l\n    Next\n\n    SetData(oReturn, oData)\n\n    Return oReturn\n\n  End Function\n\n  Private Function GetData(ByVal Map As Bitmap) As Integer()\n\n    Dim oBMPData As BitmapData = Nothing\n    Dim oData() As Integer = Nothing\n\n    oBMPData = Map.LockBits(New Rectangle(0, 0, Map.Width, Map.Height), ImageLockMode.ReadOnly, PixelFormat.Format32bppArgb)\n\n    Array.Resize(oData, Map.Width * Map.Height)\n\n    Runtime.InteropServices.Marshal.Copy(oBMPData.Scan0, oData, 0, oData.Length)\n\n    Map.UnlockBits(oBMPData)\n\n    Return oData\n\n  End Function\n\n  Private Sub SetData(ByVal Map As Bitmap, ByVal Data As Integer())\n\n    Dim oBMPData As BitmapData = Nothing\n\n    oBMPData = Map.LockBits(New Rectangle(0, 0, Map.Width, Map.Height), ImageLockMode.WriteOnly, PixelFormat.Format32bppArgb)\n\n    Runtime.InteropServices.Marshal.Copy(Data, 0, oBMPData.Scan0, Data.Length)\n\n    Map.UnlockBits(oBMPData)\n\n  End Sub\n\n", "explain": "Convert a Bitmap to Grayscale.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "PHP", "code": "\n\nclass BitmapGrayscale extends Bitmap {\n  public function toGrayscale(){\n    for ($i = 0; $i < $this->h; $i++){\n      for ($j = 0; $j < $this->w; $j++){\n        $l = ($this->data[$j][$i][0] * 0.2126)\n           + ($this->data[$j][$i][1] * 0.7152)\n           + ($this->data[$j][$i][2] * 0.0722);\n        $l = round($l);\n        $this->data[$j][$i] = array($l,$l,$l);\n      }\n    }\n  }\n}\n\n$b = new BitmapGrayscale(16,16);\n$b->fill(0,0,null,null, array(255,255,0));\n$b->setPixel(0, 15, array(255,0,0));\n$b->setPixel(0, 14, array(0,255,0));\n$b->setPixel(0, 13, array(0,0,255));\n$b->toGrayscale();\n$b->writeP6('p6-grayscale.ppm');\n\n", "explain": "Uses the Bitmap class defined for writing a PPM file\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "MATLAB", "code": "\n\nfunction [grayImage] = colortograyscale(inputImage)\n   grayImage = rgb2gray(inputImage);\n\n", "explain": "Built in colour to grayscale converter uses the following forumula:\n0.2989*R + 0.5870*G + 0.1140*B \n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Fortran", "code": "\n\ntype scimage\n   integer, dimension(:,:), pointer :: channel\n   integer :: width, height\nend type scimage\n\n\ninterface alloc_img\n   module procedure alloc_img_rgb, alloc_img_sc\nend interface\n\ninterface free_img\n   module procedure free_img_rgb, free_img_sc\nend interface\n\n\ninterface assignment(=)\n   module procedure rgbtosc, sctorgb\nend interface\n\nsubroutine alloc_img_sc(img, w, h)\n  type(scimage) :: img\n  integer, intent(in) :: w, h\n\n  allocate(img%channel(w, h))\n  img%width = w\n  img%height = h\nend subroutine alloc_img_sc\n\nsubroutine free_img_sc(img)\n  type(scimage) :: img\n\n  if ( associated(img%channel) ) deallocate(img%channel)\nend subroutine free_img_sc\n\nsubroutine rgbtosc(sc, colored)\n  type(rgbimage), intent(in) :: colored\n  type(scimage), intent(inout) :: sc\n\n  if ( ( .not. valid_image(sc) ) .and. valid_image(colored) ) then\n     call alloc_img(sc, colored%width, colored%height)\n  end if\n\n  if ( valid_image(sc) .and. valid_image(colored) ) then\n     sc%channel = floor(0.2126*colored%red + 0.7152*colored%green + &\n                        0.0722*colored%blue)\n  end if\n  \nend subroutine rgbtosc\n\nsubroutine sctorgb(colored, sc)\n  type(scimage), intent(in) :: sc\n  type(rgbimage), intent(inout) :: colored\n\n  if ( ( .not. valid_image(colored) ) .and. valid_image(sc) ) then\n     call alloc_img_rgb(colored, sc%width, sc%height)\n  end if\n\n  if ( valid_image(sc) .and. valid_image(colored) ) then\n     colored%red = sc%channel\n     colored%green = sc%channel\n     colored%blue = sc%channel\n  end if\n\nend subroutine sctorgb\n\n\ntype(scimage) :: gray\ntype(rgbimage) :: animage\n  ! ... here we \"load\" or create animage\n  ! while gray must be created or initialized to null\n  ! or errors can arise...\n  call init_img(gray)\n  gray = animage\n  animage = gray\n  call output_ppm(an_unit, animage)\n\n", "explain": "(These fragments should be added to RCImageBasic module, see Basic bitmap storage)\nFirst let's define a new type; the sc stands for Single Channel, which can be luminance (as it is here).\nIn order to allow proper overloading, the following subroutines of the storage should be renamed appending the _rgb suffix: valid_image, inside_image, alloc_img, free_img, fill_img, get_pixel, put_pixel, init_img. The single channel version would be named with the _sc suffix, then we should define the proper interfaces to use the already written code as before. Here there are only the interfaces and subroutines needed for the task.\nNow we can define useful interfaces and subroutines more task-related:\nUsage example (fragment) which can be used to convert from rgb image to grayscale image and back (since we only can output the rgb kind):\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Go", "code": "\npackage raster\n\nimport (\n    \"math\"\n    \"math/rand\"\n)\n\n// Grmap parallels Bitmap, but with an element type of uint16\n// in place of Pixel.\ntype Grmap struct {\n    Comments   []string\n    rows, cols int\n    px         []uint16\n    pxRow      [][]uint16\n}\n\n// NewGrmap constructor.\nfunc NewGrmap(x, y int) (b *Grmap) {\n    g := &Grmap{\n        Comments: []string{creator}, // creator a const in bitmap source file\n        rows:     y,\n        cols:     x,\n        px:       make([]uint16, x*y),\n        pxRow:    make([][]uint16, y),\n    }\n    x0, x1 := 0, x\n    for i := range g.pxRow {\n        g.pxRow[i] = g.px[x0:x1]\n        x0, x1 = x1, x1+x\n    }\n    return g\n}\n\nfunc (b *Grmap) Extent() (cols, rows int) {\n    return b.cols, b.rows\n}\n\nfunc (g *Grmap) Fill(c uint16) {\n    for i := range g.px {\n        g.px[i] = c\n    }\n}\n\nfunc (g *Grmap) SetPx(x, y int, c uint16) bool {\n    defer func() { recover() }()\n    g.pxRow[y][x] = c\n    return true\n}\n\nfunc (g *Grmap) GetPx(x, y int) (uint16, bool) {\n    defer func() { recover() }()\n    return g.pxRow[y][x], true\n}\n\n// Grmap method of Bitmap, converts (color) Bitmap to (grayscale) Grmap\nfunc (b *Bitmap) Grmap() *Grmap {\n    g := NewGrmap(b.cols, b.rows)\n    g.Comments = append([]string{}, b.Comments...)\n    for i, p := range b.px {\n        g.px[i] = uint16((int64(p.R)*2126 + int64(p.G)*7152 + int64(p.B)*722) *\n            math.MaxUint16 / (math.MaxUint8 * 10000))\n    }\n    return g\n}\n\n// Bitmap method Grmap, converts Grmap to Bitmap.  All pixels in the resulting\n// color Bitmap will be (very nearly) shades of gray.\nfunc (g *Grmap) Bitmap() *Bitmap {\n    b := NewBitmap(g.cols, g.rows)\n    b.Comments = append([]string{}, g.Comments...)\n    for i, p := range g.px {\n        roundedSum := int(p) * 3 * math.MaxUint8 / math.MaxUint16\n        rounded := uint8(roundedSum / 3)\n        remainder := roundedSum % 3\n        b.px[i].R = rounded\n        b.px[i].G = rounded\n        b.px[i].B = rounded\n        if remainder > 0 {\n            odd := rand.Intn(3)\n            switch odd + (remainder * 3) {\n            case 3:\n                b.px[i].R++\n            case 4:\n                b.px[i].G++\n            case 5:\n                b.px[i].B++\n            case 6:\n                b.px[i].G++\n                b.px[i].B++\n            case 7:\n                b.px[i].R++\n                b.px[i].B++\n            case 8:\n                b.px[i].R++\n                b.px[i].G++\n            }\n        }\n    }\n    return b\n}\n\n\n", "explain": "For demonstration program see task Bitmap/Read a PPM file.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Delphi", "code": "\n\n", "explain": "Solution in this page [[1]]\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Ruby", "code": "\n\nclass RGBColour\n  def to_grayscale\n    luminosity = Integer(0.2126*@red + 0.7152*@green + 0.0722*@blue)\n    self.class.new(luminosity, luminosity, luminosity)\n  end\nend\n\nclass Pixmap\n  def to_grayscale\n    gray = self.class.new(@width, @height)\n    @width.times do |x|\n      @height.times do |y|\n        gray[x,y] = self[x,y].to_grayscale\n      end\n    end\n    gray\n  end\nend\n\n", "explain": "Extending Basic_bitmap_storage#Ruby\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "R", "code": "\nLibrary: pixmap\n# Conversion from Grey to RGB uses the following code\nsetAs(\"pixmapGrey\", \"pixmapRGB\",\nfunction(from, to){\n    z = new(to, as(from, \"pixmap\"))\n    z@red = from@grey\n    z@green = from@grey\n    z@blue = from@grey\n    z@channels = c(\"red\", \"green\", \"blue\")\n    z\n})\n\n# Conversion from RGB to grey uses built-in coefficients of 0.3, 0.59, 0.11.  To see this, type\ngetMethods(addChannels)\n\n# We can override this behaviour with\nsetMethod(\"addChannels\", \"pixmapRGB\",\nfunction(object, coef=NULL){\n    if(is.null(coef)) coef = c(0.2126, 0.7152, 0.0722)\n    z = new(\"pixmapGrey\", object)\n    z@grey = coef[1] * object@red + coef[2] * object@green +\n        coef[3] * object@blue\n    z@channels = \"grey\"\n    z\n})\n\n# Colour image\nplot(p1 <- pixmapRGB(c(c(1,0,0,0,0,1), c(0,1,0,0,1,0), c(0,0,1,1,0,0)), nrow=6, ncol=6))\n\n#Convert to grey\nplot(p2 <- as(p1, \"pixmapGrey\"))\n\n# Convert back to \"colour\"\nplot(p3 <- as(p2, \"pixmapRGB\"))\n\n", "explain": ""}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version 5\nWorks with: Visual Basic version 6\nLibrary: Win32\nOption Explicit\n\nPrivate Type BITMAP\n  bmType As Long\n  bmWidth As Long\n  bmHeight As Long\n  bmWidthBytes As Long\n  bmPlanes As Integer\n  bmBitsPixel As Integer\n  bmBits As Long\nEnd Type\n\nPrivate Type RGB\n  Red As Byte\n  Green As Byte\n  Blue As Byte\n  Alpha As Byte\nEnd Type\n\nPrivate Type RGBColor\n  Color As Long\nEnd Type\n\nPublic Declare Function CreateCompatibleDC Lib \"gdi32.dll\" (ByVal hdc As Long) As Long\nPublic Declare Function GetObjectA Lib \"gdi32.dll\" (ByVal hObject As Long, ByVal nCount As Long, ByRef lpObject As Any) As Long\nPublic Declare Function SelectObject Lib \"gdi32.dll\" (ByVal hdc As Long, ByVal hObject As Long) As Long\nPublic Declare Function GetPixel Lib \"gdi32.dll\" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long) As Long\nPublic Declare Function SetPixel Lib \"gdi32.dll\" (ByVal hdc As Long, ByVal x As Long, ByVal y As Long, ByVal crColor As Long) As Long\nPublic Declare Function DeleteDC Lib \"gdi32.dll\" (ByVal hdc As Long) As Long\n\n\nSub Main()\nDim p As stdole.IPictureDisp\nDim hdc As Long\nDim bmp As BITMAP\nDim i As Long, x As Long, y As Long\nDim tRGB As RGB, cRGB As RGBColor\n\nSet p = VB.LoadPicture(\"T:\\TestData\\Input_Colored.bmp\")\nGetObjectA p.Handle, Len(bmp), bmp\n\nhdc = CreateCompatibleDC(0)\nSelectObject hdc, p.Handle\n\nFor x = 0 To bmp.bmWidth - 1\n  For y = 0 To bmp.bmHeight - 1\n    cRGB.Color = GetPixel(hdc, x, y)\n    LSet tRGB = cRGB\n    i = (0.2126 * tRGB.Red + 0.7152 * tRGB.Green + 0.0722 * tRGB.Blue)\n    SetPixel hdc, x, y, RGB(i, i, i)\n  Next y\nNext x\n\nVB.SavePicture p, \"T:\\TestData\\Output_GrayScale.bmp\"\nDeleteDC hdc\n\nEnd Sub\n\n", "explain": ""}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Ada", "code": "\ntype Grayscale_Image is array (Positive range <>, Positive range <>) of Luminance;\n\n\nfunction Grayscale (Picture : Image) return Grayscale_Image is\n   type Extended_Luminance is range 0..10_000_000;\n   Result : Grayscale_Image (Picture'Range (1), Picture'Range (2));\n   Color  : Pixel;\nbegin\n   for I in Picture'Range (1) loop\n      for J in Picture'Range (2) loop\n         Color := Picture (I, J);\n         Result (I, J) :=\n            Luminance\n            (  (  2_126 * Extended_Luminance (Color.R)\n               +  7_152 * Extended_Luminance (Color.G)\n               +    722 * Extended_Luminance (Color.B)\n               )\n            /  10_000\n            );\n      end loop;\n   end loop;\n   return Result;\nend Grayscale;\n\n\nfunction Color (Picture : Grayscale_Image) return Image is\n   Result : Image (Picture'Range (1), Picture'Range (2));\nbegin\n   for I in Picture'Range (1) loop\n      for J in Picture'Range (2) loop\n         Result (I, J) := (others => Picture (I, J));\n      end loop;\n   end loop;\n   return Result;\nend Color;\n\n", "explain": "Conversion to a grayscale image:\nConversion to a color image:\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Julia", "code": "\n\nusing Color, Images, FixedPointNumbers\n\nconst M_RGB_Y = reshape(Color.M_RGB_XYZ[2,:], 3)\n\nfunction rgb2gray(img::Image)\n    g = red(img)*M_RGB_Y[1] + green(img)*M_RGB_Y[2] + blue(img)*M_RGB_Y[3]\n    g = clamp(g, 0.0, 1.0)\n    return grayim(g)\nend\n\nfunction gray2rgb(img::Image)\n    colorspace(img) == \"Gray\" || return img\n    g = map((x)->RGB{Ufixed8}(x, x, x), img.data)\n    return Image(g, spatialorder=spatialorder(img))\nend\n \nima = imread(\"grayscale_image_color.png\")\nimb = rgb2gray(ima)\nimc = gray2rgb(imb)\nimwrite(imc, \"grayscale_image_rc.png\")\n\n\nusing Color, Images, FixedPointNumbers\n\nima = imread(\"grayscale_image_color.png\")\nimb = convert(Image{Gray{Ufixed8}}, ima)\nimwrite(imb, \"grayscale_image_julia.png\")\n\n\nOutput:\n\n", "explain": "Adhering to the Task Description\nRounding errors are unlikely to be an issue for rgb2gray.  The calculation of g promotes it to the literal float type (typically Float64).\nA More Idiomatic Approach\nI didn't find a colorful image that I was comfortable modifying and sharing, so I'm omitting the image files from my solution to this task.  Try out these images for something to work with.  Although these images are intended for image processing testing and development and are said to be available for unrestricted use, I could find no clear and definitive statement of their usage rights.\nThe results of the two approaches (according to task, rc, and idiomatic, julia) are indistinguishable except perhaps by close examination.  The julia file is native grayscale, and the rc file is RGB that shows only grays.\nThe task description is silent on the issue of companded sRGB versus linear RGB.  Most images are actually sRGB, and strictly speaking, the transformation to get Y from RGB is applicable to linear RGB.  I imagine that, unlike the rc version, the julia version reverses compansion prior to applying the CIE transformation to extract luminance from RGB.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Kotlin", "code": "\n\n// version 1.2.10\n\nimport java.io.File\nimport java.awt.image.BufferedImage\nimport javax.imageio.ImageIO\n\nfun BufferedImage.toGrayScale() {\n    for (x in 0 until width) {\n        for (y in 0 until height) {\n            var argb  = getRGB(x, y)\n            val alpha = (argb shr 24) and 0xFF\n            val red   = (argb shr 16) and 0xFF\n            val green = (argb shr  8) and 0xFF\n            val blue  =  argb and 0xFF\n            val lumin = (0.2126 * red + 0.7152 * green + 0.0722 * blue).toInt()\n            argb = (alpha shl 24) or (lumin shl 16) or (lumin shl 8) or lumin\n            setRGB(x, y, argb)\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val image = ImageIO.read(File(\"bbc.jpg\")) // using BBC BASIC image\n    image.toGrayScale()\n    val grayFile = File(\"bbc_gray.jpg\")\n    ImageIO.write(image, \"jpg\", grayFile)\n}\n\n\nOutput:\nImages same as BBC BASIC entry\n\n", "explain": "This just converts a colored image to grayscale.\nAs it's not possible to recover the original colored image (because different combinations of RGB values could have produced the same luminance), I have not bothered with the reverse operation.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Perl", "code": "\nLibrary: Imlib2\n\n#! /usr/bin/perl\n\nuse strict;\nuse Image::Imlib2;\n\nsub tograyscale\n{\n    my $img = shift;\n    my $gimg = Image::Imlib2->new($img->width, $img->height);\n    for ( my $x = 0; $x < $gimg->width; $x++ ) {\n\tfor ( my $y = 0; $y < $gimg->height; $y++ ) {\n\t    my ( $r, $g, $b, $a ) = $img->query_pixel($x, $y);\n\t    my $gray = int(0.2126 * $r + 0.7152 * $g + 0.0722 * $b);\n\t    # discard alpha info...\n\t    $gimg->set_color($gray, $gray, $gray, 255);\n\t    $gimg->draw_point($x, $y);\n\t}\n    }\n    return $gimg;\n}\n\nmy $animage = Image::Imlib2->load(\"Lenna100.jpg\");\nmy $gscale = tograyscale($animage);\n$gscale->set_quality(80);\n$gscale->save(\"Lennagray.jpg\");\n\nexit 0;\n\n", "explain": "Since we are using Imlib2, this one does not implement really a gray-scale (single channel) storage; it only converts an RGB image to an RGB image with the same three colour components for each pixel (which result in a gray-scale-like image)\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Lua", "code": "\nfunction ConvertToGrayscaleImage( bitmap )\n    local size_x, size_y = #bitmap, #bitmap[1]\n    local gray_im = {}\n  \n    for i = 1, size_x do\n        gray_im[i] = {}\n        for j = 1, size_y do \n            gray_im[i][j] = math.floor( 0.2126*bitmap[i][j][1] + 0.7152*bitmap[i][j][2] + 0.0722*bitmap[i][j][3] )\n        end\n    end\n    \n    return gray_im\nend\n\nfunction ConvertToColorImage( gray_im )\n    local size_x, size_y = #gray_im, #gray_im[1]    \n    local bitmap = Allocate_Bitmap( size_x, size_y )         -- this function is defined at http://rosettacode.org/wiki/Basic_bitmap_storage#Lua\n\n    for i = 1, size_x do\n        for j = 1, size_y do \n            bitmap[i][j] = { gray_im[i][j], gray_im[i][j], gray_im[i][j] }\n        end\n    end\n    \n    return bitmap\nend\n\n", "explain": ""}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Scala", "code": "\n\nobject BitmapOps {\n   def luminosity(c:Color)=(0.2126*c.getRed + 0.7152*c.getGreen + 0.0722*c.getBlue+0.5).toInt\n\n   def grayscale(bm:RgbBitmap)={\n      val image=new RgbBitmap(bm.width, bm.height)\n      for(x <- 0 until bm.width; y <- 0 until bm.height; l=luminosity(bm.getPixel(x,y)))\n         image.setPixel(x, y, new Color(l,l,l))\n      image\n   }\n}\n\n", "explain": "Uses the Scala Basic Bitmap Storage class.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "D", "code": "\n\nmodule grayscale_image;\n\nimport core.stdc.stdio, std.array, std.algorithm, std.string, std.ascii;\npublic import bitmap;\n\nstruct Gray {\n    ubyte c;\n    enum black = typeof(this)(0);\n    enum white = typeof(this)(255);\n    alias c this;\n}\n\n\nImage!Color loadPGM(Color)(Image!Color img, in string fileName) {\n    static int readNum(FILE* f) nothrow @nogc {\n        int n;\n        while (!fscanf(f, \"%d \", &n)) {\n            if ((n = fgetc(f)) == '#') {\n                while ((n = fgetc(f)) != '\\n')\n                    if (n == EOF)\n                        return 0;\n            } else\n                return 0;\n        }\n        return n;\n    }\n\n    if (img is null)\n        img = new Image!Color();\n\n    auto fin = fopen(fileName.toStringz(), \"rb\");\n    scope(exit) if (fin) fclose(fin);\n    if (!fin)\n        throw new Exception(\"Can't open input file.\");\n\n    if (fgetc(fin) != 'P' ||\n        fgetc(fin) != '5' ||\n        !isWhite(fgetc(fin)))\n        throw new Exception(\"Not a PGM (PPM P5) image.\");\n\n    immutable int nc = readNum(fin);\n    immutable int nr = readNum(fin);\n    immutable int maxVal = readNum(fin);\n    if (nc <= 0 || nr <= 0 || maxVal <= 0)\n        throw new Exception(\"Wrong input image sizes.\");\n    img.allocate(nc, nr);\n    auto pix = new ubyte[img.image.length];\n\n    immutable count = fread(pix.ptr, 1, nc * nr, fin);\n    if (count != nc * nr)\n        throw new Exception(\"Wrong number of items read.\");\n\n    pix.copy(img.image);\n    return img;\n}\n\n\nvoid savePGM(Color)(in Image!Color img, in string fileName)\nin {\n    assert(img !is null);\n    assert(!fileName.empty);\n    assert(img.nx > 0 && img.ny > 0 &&\n           img.image.length == img.nx * img.ny,\n           \"Wrong image.\");\n} body {\n    auto fout = fopen(fileName.toStringz(), \"wb\");\n    if (fout == null)\n        throw new Exception(\"File can't be opened.\");\n    fprintf(fout, \"P5\\n%d %d\\n255\\n\", img.nx, img.ny);\n    auto pix = new ubyte[img.image.length];\n    foreach (i, ref p; pix)\n        p = cast(typeof(pix[0]))img.image[i];\n    immutable count = fwrite(pix.ptr, ubyte.sizeof,\n                             img.nx * img.ny, fout);\n    if (count != img.nx * img.ny)\n        new Exception(\"Wrong number of items written.\");\n    fclose(fout);\n}\n\n\nGray lumCIE(in RGB c) pure nothrow @nogc {\n    return Gray(cast(ubyte)(0.2126 * c.r +\n                            0.7152 * c.g +\n                            0.0722 * c.b + 0.5));\n}\n\nGray lumAVG(in RGB c) pure nothrow @nogc {\n    return Gray(cast(ubyte)(0.3333 * c.r +\n                            0.3333 * c.g +\n                            0.3333 * c.b + 0.5));\n}\n\nImage!Gray rgb2grayImage(alias Conv=lumCIE)(in Image!RGB im) nothrow {\n    auto result = new typeof(return)(im.nx, im.ny);\n    foreach (immutable i, immutable rgb; im.image)\n        result.image[i] = Conv(rgb);\n    return result;\n}\n\nImage!RGB gray2rgbImage(in Image!Gray im) nothrow {\n    auto result = new typeof(return)(im.nx, im.ny);\n    foreach (immutable i, immutable gr; im.image)\n        result.image[i] = RGB(gr, gr, gr);\n    return result;\n}\n\nversion (grayscale_image_main) {\n    void main() {\n        auto im1 = new Image!Gray;\n        im1.loadPGM(\"lena.pgm\");\n        gray2rgbImage(im1).savePPM6(\"lena_rgb.ppm\");\n\n        auto img2 = new Image!RGB;\n        img2.loadPPM6(\"quantum_frog.ppm\");\n        img2.rgb2grayImage.savePGM(\"quantum_frog_grey.pgm\");\n    }\n}\n\n", "explain": "This example uses the bitmap module defined in the Bitmap Task page.\n"}, {"task_name": "Grayscale image", "task_url": "https://rosettacode.org/wiki/Grayscale_image", "task_cat": "Image processing", "lang": "Haskell", "code": "\nmodule Bitmap.Gray(module Bitmap.Gray) where\n\nimport Bitmap\nimport Control.Monad.ST\n\nnewtype Gray = Gray Int deriving (Eq, Ord)\n\ninstance Color Gray where\n    luminance (Gray x) = x\n    black = Gray 0\n    white = Gray 255\n    toNetpbm = map $ toEnum . luminance\n    fromNetpbm = map $ Gray . fromEnum\n    netpbmMagicNumber _ = \"P5\"\n    netpbmMaxval _ = \"255\"\n\ntoGrayImage :: Color c => Image s c -> ST s (Image s Gray)\ntoGrayImage = mapImage $ Gray . luminance\n\n\n", "explain": "A Gray image can be converted to an RGB image with Bitmap.RGB.toRGBImage, defined here.\n"}]