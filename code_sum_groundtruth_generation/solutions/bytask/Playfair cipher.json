[{"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Python", "code": "\nTranslation of: Raku\nfrom string import ascii_uppercase\nfrom itertools import product\nfrom re import findall\n\ndef uniq(seq):\n    seen = {}\n    return [seen.setdefault(x, x) for x in seq if x not in seen]\n\ndef partition(seq, n):\n    return [seq[i : i + n] for i in xrange(0, len(seq), n)]\n\n\n\"\"\"Instantiate a specific encoder/decoder.\"\"\"\ndef playfair(key, from_ = 'J', to = None):\n    if to is None:\n        to = 'I' if from_ == 'J' else ''\n\n    def canonicalize(s):\n        return filter(str.isupper, s.upper()).replace(from_, to)\n\n    # Build 5x5 matrix.\n    m = partition(uniq(canonicalize(key + ascii_uppercase)), 5)\n\n    # Pregenerate all forward translations.\n    enc = {}\n\n    # Map pairs in same row.\n    for row in m:\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[row[i] + row[j]] = row[(i + 1) % 5] + row[(j + 1) % 5]\n\n    # Map pairs in same column.\n    for c in zip(*m):\n        for i, j in product(xrange(5), repeat=2):\n            if i != j:\n                enc[c[i] + c[j]] = c[(i + 1) % 5] + c[(j + 1) % 5]\n\n    # Map pairs with cross-connections.\n    for i1, j1, i2, j2 in product(xrange(5), repeat=4):\n        if i1 != i2 and j1 != j2:\n            enc[m[i1][j1] + m[i2][j2]] = m[i1][j2] + m[i2][j1]\n\n    # Generate reverse translations.\n    dec = dict((v, k) for k, v in enc.iteritems())\n\n    def sub_enc(txt):\n        lst = findall(r\"(.)(?:(?!\\1)(.))?\", canonicalize(txt))\n        return \" \".join(enc[a + (b if b else 'X')] for a, b in lst)\n\n    def sub_dec(encoded):\n        return \" \".join(dec[p] for p in partition(canonicalize(encoded), 2))\n\n    return sub_enc, sub_dec\n\n\n(encode, decode) = playfair(\"Playfair example\")\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprint \"Original:\", orig\nenc = encode(orig)\nprint \"Encoded:\", enc\nprint \"Decoded:\", decode(enc)\n\n\nOutput:\nOriginal: Hide the gold in...the TREESTUMP!!!\nEncoded: BM OD ZB XD NA BE KU DM UI XM MO UV IF\nDecoded: HI DE TH EG OL DI NT HE TR EX ES TU MP\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "C++", "code": "\n#include <iostream>\n#include <string>\n\nusing namespace std;\n\nclass playfair\n{\npublic:\n    void doIt( string k, string t, bool ij, bool e )\n    {\n\tcreateGrid( k, ij ); getTextReady( t, ij, e );\n\tif( e ) doIt( 1 ); else doIt( -1 );\n\tdisplay();\n    }\n\nprivate:\n    void doIt( int dir )\n    {\n\tint a, b, c, d; string ntxt;\n\tfor( string::const_iterator ti = _txt.begin(); ti != _txt.end(); ti++ )\n\t{\n\t    if( getCharPos( *ti++, a, b ) )\n\t\tif( getCharPos( *ti, c, d ) )\n\t\t{\n\t\t    if( a == c )     { ntxt += getChar( a, b + dir ); ntxt += getChar( c, d + dir ); }\n\t\t    else if( b == d ){ ntxt += getChar( a + dir, b ); ntxt += getChar( c + dir, d ); }\n\t\t    else             { ntxt += getChar( c, b ); ntxt += getChar( a, d ); }\n\t\t}\n\t}\n\t_txt = ntxt;\n    }\n\n    void display()\n    {\n\tcout << \"\\n\\n OUTPUT:\\n=========\" << endl;\n\tstring::iterator si = _txt.begin(); int cnt = 0;\n\twhile( si != _txt.end() )\n\t{\n\t    cout << *si; si++; cout << *si << \" \"; si++;\n\t    if( ++cnt >= 26 ) cout << endl, cnt = 0;\n\t}\n\tcout << endl << endl;\n    }\n\n    char getChar( int a, int b )\n    {\n\treturn _m[ (b + 5) % 5 ][ (a + 5) % 5 ];\n    }\n\n    bool getCharPos( char l, int &a, int &b )\n    {\n\tfor( int y = 0; y < 5; y++ )\n\t    for( int x = 0; x < 5; x++ )\n\t\tif( _m[y][x] == l )\n\t\t{ a = x; b = y; return true; }\n\n\treturn false;\n    }\n\n    void getTextReady( string t, bool ij, bool e )\n    {\n\tfor( string::iterator si = t.begin(); si != t.end(); si++ )\n\t{\n\t    *si = toupper( *si ); if( *si < 65 || *si > 90 ) continue;\n\t    if( *si == 'J' && ij ) *si = 'I';\n\t    else if( *si == 'Q' && !ij ) continue;\n\t    _txt += *si;\n\t}\n\tif( e )\n\t{\n\t    string ntxt = \"\"; size_t len = _txt.length();\n\t    for( size_t x = 0; x < len; x += 2 )\n\t    {\n\t\tntxt += _txt[x];\n\t\tif( x + 1 < len )\n\t\t{\n\t\t    if( _txt[x] == _txt[x + 1] ) ntxt += 'X';\n\t\t    ntxt += _txt[x + 1];\n\t\t}\n\t    }\n\t    _txt = ntxt;\n\t}\n\tif( _txt.length() & 1 ) _txt += 'X';\n    }\n\n    void createGrid( string k, bool ij )\n    {\n\tif( k.length() < 1 ) k = \"KEYWORD\"; \n\tk += \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"; string nk = \"\";\n\tfor( string::iterator si = k.begin(); si != k.end(); si++ )\n\t{\n\t    *si = toupper( *si ); if( *si < 65 || *si > 90 ) continue;\n\t    if( ( *si == 'J' && ij ) || ( *si == 'Q' && !ij ) )continue;\n\t    if( nk.find( *si ) == -1 ) nk += *si;\n\t}\n\tcopy( nk.begin(), nk.end(), &_m[0][0] );\n    }\n\n    string _txt; char _m[5][5];\n};\n\nint main( int argc, char* argv[] )\n{\n    string key, i, txt; bool ij, e;\n    cout << \"(E)ncode or (D)ecode? \"; getline( cin, i ); e = ( i[0] == 'e' || i[0] == 'E' );\n    cout << \"Enter a en/decryption key: \"; getline( cin, key ); \n    cout << \"I <-> J (Y/N): \"; getline( cin, i ); ij = ( i[0] == 'y' || i[0] == 'Y' );\n    cout << \"Enter the text: \"; getline( cin, txt ); \n    playfair pf; pf.doIt( key, txt, ij, e ); return system( \"pause\" );\n}\n\n\nOutput:\n\n(E)ncode or (D)ecode? e\nEnter a en/decryption key: playfair example\nI <-> J (Y/N): y\nEnter the text: Hide the gold in the tree stump\nOUTPUT:\n=========\nBM OD ZB XD NA BE KU DM UI XM MO UV IF\n\n(E)ncode or (D)ecode? d\nEnter a en/decryption key: playfair example\nI <-> J (Y/N): y\nEnter the text: BMODZBXDNABEKUDMUIXMMOUVIF\nOUTPUT:\n=========\nHI DE TH EG OL DI NT HE TR EX ES TU MP\n\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Java", "code": "\nimport java.awt.Point;\nimport java.util.Scanner;\n\npublic class PlayfairCipher {\n    private static char[][] charTable;\n    private static Point[] positions;\n\n    public static void main(String[] args) {\n        Scanner sc = new Scanner(System.in);\n\n        String key = prompt(\"Enter an encryption key (min length 6): \", sc, 6);\n        String txt = prompt(\"Enter the message: \", sc, 1);\n        String jti = prompt(\"Replace J with I? y/n: \", sc, 1);\n\n        boolean changeJtoI = jti.equalsIgnoreCase(\"y\");\n\n        createTable(key, changeJtoI);\n\n        String enc = encode(prepareText(txt, changeJtoI));\n\n        System.out.printf(\"%nEncoded message: %n%s%n\", enc);\n        System.out.printf(\"%nDecoded message: %n%s%n\", decode(enc));\n    }\n\n    private static String prompt(String promptText, Scanner sc, int minLen) {\n        String s;\n        do {\n            System.out.print(promptText);\n            s = sc.nextLine().trim();\n        } while (s.length() < minLen);\n        return s;\n    }\n\n    private static String prepareText(String s, boolean changeJtoI) {\n        s = s.toUpperCase().replaceAll(\"[^A-Z]\", \"\");\n        return changeJtoI ? s.replace(\"J\", \"I\") : s.replace(\"Q\", \"\");\n    }\n\n    private static void createTable(String key, boolean changeJtoI) {\n        charTable = new char[5][5];\n        positions = new Point[26];\n\n        String s = prepareText(key + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", changeJtoI);\n\n        int len = s.length();\n        for (int i = 0, k = 0; i < len; i++) {\n            char c = s.charAt(i);\n            if (positions[c - 'A'] == null) {\n                charTable[k / 5][k % 5] = c;\n                positions[c - 'A'] = new Point(k % 5, k / 5);\n                k++;\n            }\n        }\n    }\n\n    private static String encode(String s) {\n        StringBuilder sb = new StringBuilder(s);\n\n        for (int i = 0; i < sb.length(); i += 2) {\n\n            if (i == sb.length() - 1)\n                sb.append(sb.length() % 2 == 1 ? 'X' : \"\");\n\n            else if (sb.charAt(i) == sb.charAt(i + 1))\n                sb.insert(i + 1, 'X');\n        }\n        return codec(sb, 1);\n    }\n\n    private static String decode(String s) {\n        return codec(new StringBuilder(s), 4);\n    }\n\n    private static String codec(StringBuilder text, int direction) {\n        int len = text.length();\n        for (int i = 0; i < len; i += 2) {\n            char a = text.charAt(i);\n            char b = text.charAt(i + 1);\n\n            int row1 = positions[a - 'A'].y;\n            int row2 = positions[b - 'A'].y;\n            int col1 = positions[a - 'A'].x;\n            int col2 = positions[b - 'A'].x;\n\n            if (row1 == row2) {\n                col1 = (col1 + direction) % 5;\n                col2 = (col2 + direction) % 5;\n\n            } else if (col1 == col2) {\n                row1 = (row1 + direction) % 5;\n                row2 = (row2 + direction) % 5;\n\n            } else {\n                int tmp = col1;\n                col1 = col2;\n                col2 = tmp;\n            }\n\n            text.setCharAt(i, charTable[row1][col1]);\n            text.setCharAt(i + 1, charTable[row2][col2]);\n        }\n        return text.toString();\n    }\n}\n\nalternative version[edit]\nimport java.util.Scanner;\n \npublic class PlayfairCipherEncryption\n{\n    private String KeyWord        = new String();\n    private String Key            = new String();\n    private char   matrix_arr[][] = new char[5][5];\n \n    public void setKey(String k)\n    {\n        String K_adjust = new String();\n        boolean flag = false;\n        K_adjust = K_adjust + k.charAt(0);\n        for (int i = 1; i < k.length(); i++)\n        {\n            for (int j = 0; j < K_adjust.length(); j++)\n            {\n                if (k.charAt(i) == K_adjust.charAt(j))\n                {\n                    flag = true;\n                }\n            }\n            if (flag == false)\n                K_adjust = K_adjust + k.charAt(i);\n            flag = false;\n        }\n        KeyWord = K_adjust;\n    }\n \n    public void KeyGen()\n    {\n        boolean flag = true;\n        char current;\n        Key = KeyWord;\n        for (int i = 0; i < 26; i++)\n        {\n            current = (char) (i + 97);\n            if (current == 'j')\n                continue;\n            for (int j = 0; j < KeyWord.length(); j++)\n            {\n                if (current == KeyWord.charAt(j))\n                {\n                    flag = false;\n                    break;\n                }\n            }\n            if (flag)\n                Key = Key + current;\n            flag = true;\n        }\n        System.out.println(Key);\n        matrix();\n    }\n \n    private void matrix()\n    {\n        int counter = 0;\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j < 5; j++)\n            {\n                matrix_arr[i][j] = Key.charAt(counter);\n                System.out.print(matrix_arr[i][j] + \" \");\n                counter++;\n            }\n            System.out.println();\n        }\n    }\n \n    private String format(String old_text)\n    {\n        int i = 0;\n        int len = 0;\n        String text = new String();\n        len = old_text.length();\n        for (int tmp = 0; tmp < len; tmp++)\n        {\n            if (old_text.charAt(tmp) == 'j')\n            {\n                text = text + 'i';\n            }\n            else\n                text = text + old_text.charAt(tmp);\n        }\n        len = text.length();\n        for (i = 0; i < len; i = i + 2)\n        {\n            if (text.charAt(i + 1) == text.charAt(i))\n            {\n                text = text.substring(0, i + 1) + 'x' + text.substring(i + 1);\n            }\n        }\n        return text;\n    }\n \n    private String[] Divid2Pairs(String new_string)\n    {\n        String Original = format(new_string);\n        int size = Original.length();\n        if (size % 2 != 0)\n        {\n            size++;\n            Original = Original + 'x';\n        }\n        String x[] = new String[size / 2];\n        int counter = 0;\n        for (int i = 0; i < size / 2; i++)\n        {\n            x[i] = Original.substring(counter, counter + 2);\n            counter = counter + 2;\n        }\n        return x;\n    }\n \n    public int[] GetDiminsions(char letter)\n    {\n        int[] key = new int[2];\n        if (letter == 'j')\n            letter = 'i';\n        for (int i = 0; i < 5; i++)\n        {\n            for (int j = 0; j < 5; j++)\n            {\n                if (matrix_arr[i][j] == letter)\n                {\n                    key[0] = i;\n                    key[1] = j;\n                    break;\n                }\n            }\n        }\n        return key;\n    }\n \n    public String encryptMessage(String Source)\n    {\n        String src_arr[] = Divid2Pairs(Source);\n        String Code = new String();\n        char one;\n        char two;\n        int part1[] = new int[2];\n        int part2[] = new int[2];\n        for (int i = 0; i < src_arr.length; i++)\n        {\n            one = src_arr[i].charAt(0);\n            two = src_arr[i].charAt(1);\n            part1 = GetDiminsions(one);\n            part2 = GetDiminsions(two);\n            if (part1[0] == part2[0])\n            {\n                if (part1[1] < 4)\n                    part1[1]++;\n                else\n                    part1[1] = 0;\n                if (part2[1] < 4)\n                    part2[1]++;\n                else\n                    part2[1] = 0;\n            }\n            else if (part1[1] == part2[1])\n            {\n                if (part1[0] < 4)\n                    part1[0]++;\n                else\n                    part1[0] = 0;\n                if (part2[0] < 4)\n                    part2[0]++;\n                else\n                    part2[0] = 0;\n            }\n            else\n            {\n                int temp = part1[1];\n                part1[1] = part2[1];\n                part2[1] = temp;\n            }\n            Code = Code + matrix_arr[part1[0]][part1[1]]\n                    + matrix_arr[part2[0]][part2[1]];\n        }\n        return Code;\n    }\n \n    public static void main(String[] args)\n    {\n        PlayfairCipherEncryption x = new PlayfairCipherEncryption();\n        Scanner sc = new Scanner(System.in);\n        System.out.println(\"Enter a keyword:\");\n        String keyword = sc.next();\n        x.setKey(keyword);\n        x.KeyGen();\n        System.out\n                .println(\"Enter word to encrypt: (Make sure length of message is even)\");\n        String key_input = sc.next();\n        if (key_input.length() % 2 == 0)\n        {\n            System.out.println(\"Encryption: \" + x.encryptMessage(key_input));\n        }\n        else\n        {\n            System.out.println(\"Message length should be even\");\n        }\n        sc.close();\n    }\n}\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "SQL", "code": "\n--Clean up previous run  \nIF EXISTS (SELECT * \n           FROM   SYS.TYPES \n           WHERE  NAME = 'FairPlayTable') \n  DROP TYPE FAIRPLAYTABLE \n\n--Set Types  \nCREATE TYPE FAIRPLAYTABLE AS TABLE (LETTER VARCHAR(1), COLID INT, ROWID INT) \n\nGO \n\n--Configuration Variables  \nDECLARE @KEYWORD VARCHAR(25) = 'CHARLES' --Keyword for encryption  \nDECLARE @INPUT VARCHAR(MAX) = 'Testing Seeconqz' --Word to be encrypted  \nDECLARE @Q INT = 0 -- Q removed?  \nDECLARE @ENCRYPT INT = 1 --Encrypt?  \n--Setup Variables  \nDECLARE @WORDS TABLE \n  ( \n     WORD_PRE  VARCHAR(2), \n     WORD_POST VARCHAR(2) \n  ) \nDECLARE @T_TABLE FAIRPLAYTABLE \nDECLARE @NEXTLETTER CHAR(1) \nDECLARE @WORD VARCHAR(2), \n        @COL1 INT, \n        @COL2 INT, \n        @ROW1 INT, \n        @ROW2 INT, \n        @TMP  INT \nDECLARE @SQL     NVARCHAR(MAX) = '', \n        @COUNTER INT = 1, \n        @I       INT = 1 \nDECLARE @COUNTER_2 INT = 1 \n\nSET @INPUT = REPLACE(@INPUT, ' ', '') \nSET @KEYWORD = UPPER(@KEYWORD) \n\nDECLARE @USEDLETTERS VARCHAR(MAX) = '' \nDECLARE @TESTWORDS VARCHAR(2), \n        @A         INT = 0 \n\nWHILE @COUNTER_2 <= 5 \n  BEGIN \n      WHILE @COUNTER <= 5 \n        BEGIN \n            IF LEN(@KEYWORD) > 0 \n              BEGIN \n                  SET @NEXTLETTER = LEFT(@KEYWORD, 1) \n                  SET @KEYWORD = RIGHT(@KEYWORD, LEN(@KEYWORD) - 1) \n\n                  IF CHARINDEX(@NEXTLETTER, @USEDLETTERS) = 0 \n                    BEGIN \n                        INSERT INTO @T_TABLE \n                        SELECT @NEXTLETTER, \n                               @COUNTER, \n                               @COUNTER_2 \n\n                        SET @COUNTER = @COUNTER + 1 \n                        SET @USEDLETTERS = @USEDLETTERS + @NEXTLETTER \n                    END \n              END \n            ELSE \n              BEGIN \n                  WHILE 1 = 1 \n                    BEGIN \n                        IF CHARINDEX(CHAR(64 + @I), @USEDLETTERS) = 0 \n                           AND NOT ( CHAR(64 + @I) = 'Q' \n                                     AND @Q = 1 ) \n                           AND NOT ( @Q = 0 \n                                     AND CHAR(64 + @I) = 'J' ) \n                          BEGIN \n                              SET @NEXTLETTER = CHAR(64 + @I) \n                              SET @USEDLETTERS = @USEDLETTERS + CHAR(64 + @I) \n                              SET @I = @I + 1 \n\n                              BREAK \n                          END \n\n                        SET @I = @I + 1 \n                    END \n\n                  -- SELECT 1 AS [T] \n                  --BREAK \n                  INSERT INTO @T_TABLE \n                  SELECT @NEXTLETTER, \n                         @COUNTER, \n                         @COUNTER_2 \n\n                  SET @COUNTER = @COUNTER + 1 \n              END \n        END \n\n      SET @COUNTER_2 = @COUNTER_2 + 1 \n      SET @COUNTER = 1 \n  END \n\n--Split word into Digraphs  \nWHILE @A < 1 \n  BEGIN \n      SET @TESTWORDS = UPPER(LEFT(@INPUT, 2)) \n\n      IF LEN(@TESTWORDS) = 1 \n        BEGIN \n            SET @TESTWORDS = @TESTWORDS + 'X' \n            SET @A = 1 \n        END \n      ELSE IF RIGHT(@TESTWORDS, 1) = LEFT(@TESTWORDS, 1) \n        BEGIN \n            SET @TESTWORDS = RIGHT(@TESTWORDS, 1) + 'X' \n            SET @INPUT = RIGHT(@INPUT, LEN(@INPUT) - 1) \n        END \n      ELSE \n        SET @INPUT = RIGHT(@INPUT, LEN(@INPUT) - 2) \n\n      IF LEN(@INPUT) = 0 \n        SET @A = 1 \n\n      INSERT @WORDS \n      SELECT @TESTWORDS, \n             '' \n  END \n\n--Start Encryption \nIF @ENCRYPT = 1 \n  BEGIN \n      --Loop through Digraphs amd encrypt  \n      DECLARE WORDS_LOOP CURSOR LOCAL FORWARD_ONLY FOR \n        SELECT WORD_PRE \n        FROM   @WORDS \n        FOR UPDATE OF WORD_POST \n\n      OPEN WORDS_LOOP \n\n      FETCH NEXT FROM WORDS_LOOP INTO @WORD \n\n      WHILE @@FETCH_STATUS = 0 \n        BEGIN \n            --Find letter positions  \n            SET @ROW1 = (SELECT ROWID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = LEFT(@WORD, 1)) \n            SET @ROW2 = (SELECT ROWID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = RIGHT(@WORD, 1)) \n            SET @COL1 = (SELECT COLID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = LEFT(@WORD, 1)) \n            SET @COL2 = (SELECT COLID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = RIGHT(@WORD, 1)) \n\n            --Move positions according to encryption rules  \n            IF @COL1 = @COL2 \n              BEGIN \n                  SET @ROW1 = @ROW1 + 1 \n                  SET @ROW2 = @ROW2 + 1 \n              --select 'row'  \n              END \n            ELSE IF @ROW1 = @ROW2 \n              BEGIN \n                  SET @COL1 = @COL1 + 1 \n                  SET @COL2 = @COL2 + 1 \n              --select 'col'  \n              END \n            ELSE \n              BEGIN \n                  SET @TMP = @COL2 \n                  SET @COL2 = @COL1 \n                  SET @COL1 = @TMP \n              --select 'reg'  \n              END \n\n            IF @ROW1 = 6 \n              SET @ROW1 = 1 \n\n            IF @ROW2 = 6 \n              SET @ROW2 = 1 \n\n            IF @COL1 = 6 \n              SET @COL1 = 1 \n\n            IF @COL2 = 6 \n              SET @COL2 = 1 \n\n            --Find encrypted letters by positions  \n            UPDATE @WORDS \n            SET    WORD_POST = (SELECT (SELECT LETTER \n                                        FROM   @T_TABLE \n                                        WHERE  ROWID = @ROW1 \n                                               AND COLID = @COL1) \n                                       + (SELECT LETTER \n                                          FROM   @T_TABLE \n                                          WHERE  COLID = @COL2 \n                                                 AND ROWID = @ROW2)) \n            WHERE  WORD_PRE = @WORD \n\n            FETCH NEXT FROM WORDS_LOOP INTO @WORD \n        END \n\n      CLOSE WORDS_LOOP \n\n      DEALLOCATE WORDS_LOOP \n  END \n--Start Decryption \nELSE \n  BEGIN \n      --Loop through Digraphs amd decrypt  \n      DECLARE WORDS_LOOP CURSOR LOCAL FORWARD_ONLY FOR \n        SELECT WORD_PRE \n        FROM   @WORDS \n        FOR UPDATE OF WORD_POST \n\n      OPEN WORDS_LOOP \n\n      FETCH NEXT FROM WORDS_LOOP INTO @WORD \n\n      WHILE @@FETCH_STATUS = 0 \n        BEGIN \n            --Find letter positions  \n            SET @ROW1 = (SELECT ROWID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = LEFT(@WORD, 1)) \n            SET @ROW2 = (SELECT ROWID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = RIGHT(@WORD, 1)) \n            SET @COL1 = (SELECT COLID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = LEFT(@WORD, 1)) \n            SET @COL2 = (SELECT COLID \n                         FROM   @T_TABLE \n                         WHERE  LETTER = RIGHT(@WORD, 1)) \n\n            --Move positions according to encryption rules  \n            IF @COL1 = @COL2 \n              BEGIN \n                  SET @ROW1 = @ROW1 - 1 \n                  SET @ROW2 = @ROW2 - 1 \n              --select 'row'  \n              END \n            ELSE IF @ROW1 = @ROW2 \n              BEGIN \n                  SET @COL1 = @COL1 - 1 \n                  SET @COL2 = @COL2 - 1 \n              --select 'col'  \n              END \n            ELSE \n              BEGIN \n                  SET @TMP = @COL2 \n                  SET @COL2 = @COL1 \n                  SET @COL1 = @TMP \n              --select 'reg'  \n              END \n\n            IF @ROW1 = 0 \n              SET @ROW1 = 5 \n\n            IF @ROW2 = 0 \n              SET @ROW2 = 5 \n\n            IF @COL1 = 0 \n              SET @COL1 = 5 \n\n            IF @COL2 = 0 \n              SET @COL2 = 5 \n\n            --Find decrypted letters by positions  \n            UPDATE @WORDS \n            SET    WORD_POST = (SELECT (SELECT LETTER \n                                        FROM   @T_TABLE \n                                        WHERE  ROWID = @ROW1 \n                                               AND COLID = @COL1) \n                                       + (SELECT LETTER \n                                          FROM   @T_TABLE \n                                          WHERE  COLID = @COL2 \n                                                 AND ROWID = @ROW2)) \n            WHERE  WORD_PRE = @WORD \n\n            FETCH NEXT FROM WORDS_LOOP INTO @WORD \n        END \n\n      CLOSE WORDS_LOOP \n\n      DEALLOCATE WORDS_LOOP \n  END \n\n--Output \nDECLARE WORDS CURSOR LOCAL FAST_FORWARD FOR \n  SELECT WORD_POST \n  FROM   @WORDS \n\nOPEN WORDS \n\nFETCH NEXT FROM WORDS INTO @WORD \n\nWHILE @@FETCH_STATUS = 0 \n  BEGIN \n      SET @SQL = @SQL + @WORD + ' '\n\n      FETCH NEXT FROM WORDS INTO @WORD \n  END \n\nCLOSE WORDS \n\nDEALLOCATE WORDS \n\nSELECT @SQL \n\n--Cleanup  \nIF EXISTS (SELECT * \n           FROM   SYS.TYPES \n           WHERE  NAME = 'FairPlayTable') \n  DROP TYPE FAIRPLAYTABLE\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Go", "code": "\nTranslation of: Kotlin\npackage main\n\nimport (\n    \"bufio\"\n    \"fmt\"\n    \"os\"\n    \"strings\"\n)\n\ntype playfairOption int\n\nconst (\n    noQ playfairOption = iota\n    iEqualsJ\n)\n\ntype playfair struct {\n    keyword string\n    pfo     playfairOption\n    table   [5][5]byte\n}\n\nfunc (p *playfair) init() {\n    // Build table.\n    var used [26]bool // all elements false\n    if p.pfo == noQ {\n        used[16] = true // Q used\n    } else {\n        used[9] = true // J used\n    }\n    alphabet := strings.ToUpper(p.keyword) + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n    for i, j, k := 0, 0, 0; k < len(alphabet); k++ {\n        c := alphabet[k]\n        if c < 'A' || c > 'Z' {\n            continue\n        }\n        d := int(c - 65)\n        if !used[d] {\n            p.table[i][j] = c\n            used[d] = true\n            j++\n            if j == 5 {\n                i++\n                if i == 5 {\n                    break // table has been filled\n                }\n                j = 0\n            }\n        }\n    }\n}\n\nfunc (p *playfair) getCleanText(plainText string) string {\n    // Ensure everything is upper case.\n    plainText = strings.ToUpper(plainText)\n    // Get rid of any non-letters and insert X between duplicate letters.\n    var cleanText strings.Builder\n    // Safe to assume null byte won't be present in plainText.\n    prevByte := byte('\\000')\n    for i := 0; i < len(plainText); i++ {\n        nextByte := plainText[i]\n        // It appears that Q should be omitted altogether if NO_Q option is specified;\n        // we assume so anyway.\n        if nextByte < 'A' || nextByte > 'Z' || (nextByte == 'Q' && p.pfo == noQ) {\n            continue\n        }\n        // If iEqualsJ option specified, replace J with I.\n        if nextByte == 'J' && p.pfo == iEqualsJ {\n            nextByte = 'I'\n        }\n        if nextByte != prevByte {\n            cleanText.WriteByte(nextByte)\n        } else {\n            cleanText.WriteByte('X')\n            cleanText.WriteByte(nextByte)\n        }\n        prevByte = nextByte\n    }\n    l := cleanText.Len()\n    if l%2 == 1 {\n        // Dangling letter at end so add another letter to complete digram.\n        if cleanText.String()[l-1] != 'X' {\n            cleanText.WriteByte('X')\n        } else {\n            cleanText.WriteByte('Z')\n        }\n    }\n    return cleanText.String()\n}\n\nfunc (p *playfair) findByte(c byte) (int, int) {\n    for i := 0; i < 5; i++ {\n        for j := 0; j < 5; j++ {\n            if p.table[i][j] == c {\n                return i, j\n            }\n        }\n    }\n    return -1, -1\n}\n\nfunc (p *playfair) encode(plainText string) string {\n    cleanText := p.getCleanText(plainText)\n    var cipherText strings.Builder\n    l := len(cleanText)\n    for i := 0; i < l; i += 2 {\n        row1, col1 := p.findByte(cleanText[i])\n        row2, col2 := p.findByte(cleanText[i+1])\n        switch {\n        case row1 == row2:\n            cipherText.WriteByte(p.table[row1][(col1+1)%5])\n            cipherText.WriteByte(p.table[row2][(col2+1)%5])\n        case col1 == col2:\n            cipherText.WriteByte(p.table[(row1+1)%5][col1])\n            cipherText.WriteByte(p.table[(row2+1)%5][col2])\n        default:\n            cipherText.WriteByte(p.table[row1][col2])\n            cipherText.WriteByte(p.table[row2][col1])\n        }\n        if i < l-1 {\n            cipherText.WriteByte(' ')\n        }\n    }\n    return cipherText.String()\n}\n\nfunc (p *playfair) decode(cipherText string) string {\n    var decodedText strings.Builder\n    l := len(cipherText)\n    // cipherText will include spaces so we need to skip them.\n    for i := 0; i < l; i += 3 {\n        row1, col1 := p.findByte(cipherText[i])\n        row2, col2 := p.findByte(cipherText[i+1])\n        switch {\n        case row1 == row2:\n            temp := 4\n            if col1 > 0 {\n                temp = col1 - 1\n            }\n            decodedText.WriteByte(p.table[row1][temp])\n            temp = 4\n            if col2 > 0 {\n                temp = col2 - 1\n            }\n            decodedText.WriteByte(p.table[row2][temp])\n        case col1 == col2:\n            temp := 4\n            if row1 > 0 {\n                temp = row1 - 1\n            }\n            decodedText.WriteByte(p.table[temp][col1])\n            temp = 4\n            if row2 > 0 {\n                temp = row2 - 1\n            }\n            decodedText.WriteByte(p.table[temp][col2])\n        default:\n            decodedText.WriteByte(p.table[row1][col2])\n            decodedText.WriteByte(p.table[row2][col1])\n        }\n        if i < l-1 {\n            decodedText.WriteByte(' ')\n        }\n    }\n    return decodedText.String()\n}\n\nfunc (p *playfair) printTable() {\n    fmt.Println(\"The table to be used is\u00a0:\\n\")\n    for i := 0; i < 5; i++ {\n        for j := 0; j < 5; j++ {\n            fmt.Printf(\"%c \", p.table[i][j])\n        }\n        fmt.Println()\n    }\n}\n\nfunc main() {\n    scanner := bufio.NewScanner(os.Stdin)\n    fmt.Print(\"Enter Playfair keyword\u00a0: \")\n    scanner.Scan()\n    keyword := scanner.Text()\n    var ignoreQ string\n    for ignoreQ != \"y\" && ignoreQ != \"n\" {\n        fmt.Print(\"Ignore Q when building table  y/n\u00a0: \")\n        scanner.Scan()\n        ignoreQ = strings.ToLower(scanner.Text())\n    }\n    pfo := noQ\n    if ignoreQ == \"n\" {\n        pfo = iEqualsJ\n    }\n    var table [5][5]byte\n    pf := &playfair{keyword, pfo, table}\n    pf.init()\n    pf.printTable()\n    fmt.Print(\"\\nEnter plain text\u00a0: \")\n    scanner.Scan()\n    plainText := scanner.Text()\n    if err := scanner.Err(); err != nil {\n        fmt.Fprintln(os.Stderr, \"reading standard input:\", err)\n        return\n    }\n    encodedText := pf.encode(plainText)\n    fmt.Println(\"\\nEncoded text is\u00a0:\", encodedText)\n    decodedText := pf.decode(encodedText)\n    fmt.Println(\"Deccoded text is\u00a0:\", decodedText)\n}\n\n\nOutput:\n\nEnter Playfair keyword\u00a0: Playfair example\nIgnore Q when building table  y/n\u00a0: n\nThe table to be used is\u00a0:\n\nP L A Y F \nI R E X M \nB C D G H \nK N O Q S \nT U V W Z \n\nEnter plain text\u00a0: Hide the gold...in the TREESTUMP!!!!\n\nEncoded text is\u00a0: BM OD ZB XD NA BE KU DM UI XM MO UV IF \nDeccoded text is\u00a0: HI DE TH EG OL DI NT HE TR EX ES TU MP \n\n", "explain": "Sample run:\n"}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Ruby", "code": "\n\nclass Playfair\n  Size = 5\n  def initialize(key, missing)\n    @missing = missing.upcase\n    alphabet = ('A'..'Z').to_a.join.upcase.delete(@missing).split''\n    extended = key.upcase.gsub(/[^A-Z]/,'').split('') + alphabet\n    grid = extended.uniq[0...Size*Size].each_slice(Size).to_a\n    coords = {}\n    grid.each_with_index do |row, i|\n      row.each_with_index do |letter, j|\n       coords[letter] = [i,j]\n      end\n    end\n    @encode = {}\n    alphabet.product(alphabet).reject { |a,b| a==b }.each do |a, b|\n      i1, j1 = coords[a]\n      i2, j2 = coords[b]\n      if i1 == i2 then\n         j1 = (j1 + 1) % Size\n         j2 = (j2 + 1) % Size\n      elsif j1 == j2 then\n         i1 = (i1 + 1) % Size\n         i2 = (i2 + 1) % Size\n      else\n         j1, j2 = j2, j1\n      end\n      @encode[\"#{a}#{b}\"] = \"#{grid[i1][j1]}#{grid[i2][j2]}\"\n      @decode = @encode.invert\n    end\n  end\n\n  def encode(plaintext) \n    plain = plaintext.upcase.gsub(/[^A-Z]/,'')\n    if @missing == 'J' then\n      plain = plain.gsub(/J/, 'I')\n    else\n      plain = plain.gsub(@missing, 'X')\n    end\n    plain = plain.gsub(/(.)\\1/, '\\1X\\1')\n    if plain.length % 2 == 1 then\n      plain += 'X'\n    end\n    return plain.upcase.split('').each_slice(2).map do |pair|\n      @encode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\n\n  def decode(ciphertext) \n    cipher = ciphertext.upcase.gsub(/[^A-Z]/,'')\n    return cipher.upcase.split('').each_slice(2).map do |pair|\n      @decode[pair.join]\n    end.join.split('').each_slice(5).map{|s|s.join}.join(' ')\n  end\nend\n\n\nOutput:\nirb(main):001:0> cipher = (p=Playfair.new 'Playfair example','J').encode('hide the gold in the tree stump')\n=> \"BMODZ BXDNA BEKUD MUIXM MOUVI F\"\nirb(main):002:0> p.decode(cipher)\n=> \"HIDET HEGOL DINTH ETREX ESTUM P\"\n", "explain": "Printing the cipher in pairs just advertises the mechanism of encoding; I've gone with the traditional grouping into sequences of five letters instead.\n"}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Julia", "code": "\nfunction playfair(key, txt, isencode=true, from = \"J\", to = \"\")\n    to = (to == \"\" && from == \"J\") ? \"I\" : to\n\n    function canonical(s, dup_toX=true)\n        s = replace(replace(uppercase(s), from => to), r\"[^A-Z]\" => \"\")\n        a, dupcount = [c for c in s], 0\n        for i in 1:2:length(a)-1\n            if s[i] == s[i + 1]\n                dup_toX && splice!(a, i+1+dupcount:i+dupcount, 'X')\n                dupcount += 1\n            end\n        end\n        s = String(a)\n        return isodd(length(s)) ? s * \"X\" : s\n    end\n\n    # Translate key into an encoding 5x5 translation matrix.\n    keyletters = unique([c for c in canonical(key * \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\", false)])\n    m = Char.((reshape(UInt8.(keyletters[1:25]), 5, 5)'))\n\n    # encod is a dictionary of letter pairs for encoding.\n    encod = Dict()\n\n    # Map pairs in same row or same column of matrix m.\n    for i in 1:5, j in 1:5, k in 1:5\n        if j != k\n            encod[m[i, j] * m[i, k]] = m[i, mod1(j + 1, 5)] * m[i, mod1(k + 1, 5)]\n        end\n        if i != k\n            encod[m[i, j] * m[k, j]] = m[mod1(i + 1, 5), j] * m[mod1(k + 1, 5), j]\n        end\n        # Map pairs not on same row or same column.\n        for l in 1:5\n            if i != k && j != l\n                encod[m[i, j] * m[k, l]] = m[i, l] * m[k, j]\n            end\n        end\n    end\n\n    # Get array of pairs of letters from text.\n    canontxt = canonical(txt)\n    letterpairs = [canontxt[i:i+1] for i in 1:2:length(canontxt)-1]\n\n    if isencode\n        # Encode text\n        return join([encod[pair] for pair in letterpairs], \" \")\n    else\n        # Decode text\n        decod = Dict((v, k) for (k, v) in encod)\n        return join([decod[pair] for pair in letterpairs], \" \")\n    end\nend\n\norig = \"Hide the gold in...the TREESTUMP!!!\"\nprintln(\"Original: \", orig)\n\nencoded = playfair(\"Playfair example\", orig)\nprintln(\"Encoded: \", encoded)\n\nprintln(\"Decoded: \", playfair(\"Playfair example\", encoded, false))\n\nOutput:\nOriginal: Hide the gold in...the TREESTUMP!!!\nEncoded: BM OD ZB XD NA BE KU DM UI XM MO UV IF\nDecoded: HI DE TH EG OL DI NT HE TR EX ES TU MP\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Kotlin", "code": "\nTranslation of: FreeBASIC\n// version 1.0.5-2\n\nenum class PlayfairOption {\n    NO_Q, \n    I_EQUALS_J\n}\n\nclass Playfair(keyword: String, val pfo: PlayfairOption) {\n    private val table: Array<CharArray> = Array(5, { CharArray(5) })  // 5 x 5 char array\n\n    init {\n        // build table\n        val used = BooleanArray(26)  // all elements false  \n        if (pfo == PlayfairOption.NO_Q) \n            used[16] = true  // Q used\n        else\n            used[9]  = true  // J used\n        val alphabet = keyword.toUpperCase() + \"ABCDEFGHIJKLMNOPQRSTUVWXYZ\"\n        var i = 0\n        var j = 0\n        var c: Char\n        var d: Int\n        for (k in 0 until alphabet.length) {\n            c = alphabet[k]\n            if (c !in 'A'..'Z') continue\n            d = c.toInt() - 65\n            if (!used[d]) {\n                table[i][j] = c\n                used[d] = true\n                if (++j == 5) { \n                    if (++i == 5) break // table has been filled \n                    j = 0\n                }\n            }          \n        }\n    }\n    \n    private fun getCleanText(plainText: String): String {\n        val plainText2 = plainText.toUpperCase()  // ensure everything is upper case\n        // get rid of any non-letters and insert X between duplicate letters\n        var cleanText = \"\"\n        var prevChar = '\\u0000'  // safe to assume null character won't be present in plainText\n        var nextChar: Char\n        for (i in 0 until plainText2.length) {\n            nextChar = plainText2[i]\n            // It appears that Q should be omitted altogether if NO_Q option is specified - we assume so anyway\n            if (nextChar !in 'A'..'Z' || (nextChar == 'Q' && pfo == PlayfairOption.NO_Q)) continue\n            // If I_EQUALS_J option specified, replace J with I\n            if (nextChar == 'J' && pfo == PlayfairOption.I_EQUALS_J) nextChar = 'I'\n            if (nextChar != prevChar)\n                cleanText += nextChar\n            else\n                cleanText += \"X\" + nextChar\n            prevChar = nextChar\n        }        \n        val len = cleanText.length\n        if (len % 2 == 1)  {  // dangling letter at end so add another letter to complete digram\n            if (cleanText[len - 1] != 'X')\n                cleanText += 'X'\n            else \n                cleanText += 'Z'\n        }\n        return cleanText    \n    }\n\n    private fun findChar(c: Char): Pair<Int, Int> {\n       for (i in 0..4)\n           for (j in 0..4)\n               if (table[i][j] == c) return Pair(i, j)\n       return Pair(-1, -1)\n    }\n\n    fun encode(plainText: String): String {\n        val cleanText = getCleanText(plainText)\n        var cipherText = \"\"\n        val length = cleanText.length\n        for (i in 0 until length step 2) {\n            val (row1, col1) = findChar(cleanText[i])\n            val (row2, col2) = findChar(cleanText[i + 1])  \n            cipherText += when {\n                row1 == row2 -> table[row1][(col1 + 1) % 5].toString() + table[row2][(col2 + 1) % 5]\n                col1 == col2 -> table[(row1 + 1) % 5][col1].toString() + table[(row2 + 1) % 5][col2]\n                else         -> table[row1][col2].toString() + table[row2][col1]\n            }\n            if (i < length - 1) cipherText += \" \"  \n        }\n        return cipherText\n    }\n\n    fun decode(cipherText: String): String {\n        var decodedText = \"\"\n        val length = cipherText.length\n        for (i in 0 until length step 3) {  // cipherText will include spaces so we need to skip them\n            val (row1, col1) = findChar(cipherText[i])\n            val (row2, col2) = findChar(cipherText[i + 1])  \n            decodedText += when {\n                row1 == row2 -> table[row1][if (col1 > 0) col1 - 1 else 4].toString() + table[row2][if (col2 > 0) col2 - 1 else 4]\n                col1 == col2 -> table[if (row1 > 0) row1- 1 else 4][col1].toString() + table[if (row2 > 0) row2 - 1 else 4][col2]\n                else         -> table[row1][col2].toString() + table[row2][col1]\n            }\n            if (i < length - 1) decodedText += \" \"\n        }\n        return decodedText\n    }   \n\n    fun printTable() {\n        println(\"The table to be used is\u00a0:\\n\")\n        for (i in 0..4) {\n            for (j in 0..4) print(table[i][j] + \" \")\n            println()\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    print(\"Enter Playfair keyword\u00a0: \")\n    val keyword: String = readLine()!!\n    var ignoreQ: String\n    do {\n         print(\"Ignore Q when buiding table  y/n\u00a0: \")\n         ignoreQ = readLine()!!.toLowerCase() \n    }\n    while (ignoreQ != \"y\" && ignoreQ != \"n\")\n    val pfo = if (ignoreQ == \"y\") PlayfairOption.NO_Q else PlayfairOption.I_EQUALS_J\n    val playfair = Playfair(keyword, pfo)\n    playfair.printTable()\n    print(\"\\nEnter plain text\u00a0: \")\n    val plainText: String = readLine()!!\n    val encodedText = playfair.encode(plainText)\n    println(\"\\nEncoded text is\u00a0: $encodedText\") \n    val decodedText = playfair.decode(encodedText)\n    println(\"Decoded text is\u00a0: $decodedText\")\n}\n\n\nOutput:\nEnter Playfair keyword\u00a0: Playfair example\nIgnore Q when buiding table  y/n\u00a0: n\nThe table to be used is\u00a0:\n\nP L A Y F\nI R E X M\nB C D G H\nK N O Q S\nT U V W Z\n\nEnter plain text\u00a0: Hide the gold...in the TREESTUMP!!!!\n\nEncoded text is\u00a0: BM OD ZB XD NA BE KU DM UI XM MO UV IF\nDecoded text is\u00a0: HI DE TH EG OL DI NT HE TR EX ES TU MP\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Perl", "code": "\nTranslation of: Raku\nuse Math::Cartesian::Product;\n\n# Pregenerate all forward and reverse translations\nsub playfair {\n    our($key,$from) = @_;\n    $from //= 'J';\n    our $to = $from eq 'J' ? 'I' : '';\n    my(%ENC,%DEC,%seen,@m);\n\n    sub canon {\n        my($str) = @_;\n        $str =~ s/[^[:alpha:]]//g;\n        $str =~ s/$from/$to/gi;\n        uc $str;\n    }\n\n    my @uniq = grep { ! $seen{$_}++ } split '', canon($key . join '', 'A'..'Z');\n    while (@uniq) { push @m, [splice @uniq, 0, 5] }\n\n    # Map pairs in same row.\n    for my $r (@m)  {\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ @$r[$i] . @$r[$j] } =  @$r[($i+1)%5] . @$r[($j+1)%5];\n        }\n    }\n\n    # Map pairs in same column.\n    for my $c (0..4) {\n        my @c = map { @$_[$c] } @m;\n        for my $x (cartesian {@_} [0..4], [0..4]) {\n        my($i,$j) = @$x;\n        next if $i == $j;\n        $ENC{ $c[$i] . $c[$j] } = $c[($i+1)%5] . $c[($j+1)%5];\n        }\n    }\n\n    # Map pairs with cross-connections.\n    for my $x (cartesian {@_} [0..4], [0..4], [0..4], [0..4]) {\n        my($i1,$j1,$i2,$j2) = @$x;\n        next if $i1 == $i2 or $j1 == $j2;\n        $ENC{ $m[$i1][$j1] . $m[$i2][$j2] } = $m[$i1][$j2] . $m[$i2][$j1];\n    }\n\n    # Generate reverse translations.\n     while (my ($k, $v) = each %ENC) { $DEC{$v} = $k }\n\n    # Return code-refs for encoding/decoding routines\n    return\n    sub { my($red) = @_; # encode\n        my $str = canon($red);\n\n        my @list;\n        while ($str =~ /(.)(?(?=\\1)|(.?))/g) {\n            push @list, substr($str,$-[0], $-[2] ? 2 : 1);\n        }\n        join ' ', map { length($_)==1 ? $ENC{$_.'X'} : $ENC{$_} } @list;\n    },\n    sub { my($black) = @_; # decode\n        join ' ', map { $DEC{$_} } canon($black) =~ /../g;\n    }\n}\n\nmy($encode,$decode) = playfair('Playfair example');\n\nmy $orig  = \"Hide the gold in...the TREESTUMP!!!\";\nmy $black = &$encode($orig);\nmy $red   = &$decode($black);\nprint \" orig:\\t$orig\\n\";\nprint \"black:\\t$black\\n\";\nprint \"  red:\\t$red\\n\";\n\n\nOutput:\n orig:  Hide the gold in...the TREESTUMP!!!\nblack:  BM OD ZB XD NA BE KU DM UI XM MO UV IF\n  red:  HI DE TH EG OL DI NT HE TR EX ES TU MP\n\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "D", "code": "\nTranslation of: Python\nimport std.stdio, std.array, std.algorithm, std.range, std.ascii,\n       std.conv, std.string, std.regex, std.typecons;\n\nstring unique(in string s) pure nothrow @safe {\n    string result;\n    foreach (immutable char c; s)\n        if (!result.representation.canFind(c)) // Assumes ASCII string.\n            result ~= c;\n    return result;\n}\n\nstruct Playfair {\n    string from, to;\n    string[string] enc, dec;\n\n    this(in string key, in string from_ = \"J\", in string to_ = null)\n    pure /*nothrow @safe*/ {\n        this.from = from_;\n        if (to_.empty)\n            this.to = (from_ == \"J\") ? \"I\" : \"\";\n\n        immutable m = _canonicalize(key ~ uppercase)\n                      .unique\n                      .chunks(5)\n                      .map!text\n                      .array;\n        auto I5 = 5.iota;\n\n        foreach (immutable R; m)\n            foreach (immutable i, immutable j; cartesianProduct(I5, I5))\n                if (i != j)\n                    enc[[R[i], R[j]]] = [R[(i + 1) % 5], R[(j+1) % 5]];\n\n        foreach (immutable r; I5) {\n            immutable c = m.transversal(r).array;\n            foreach (immutable i, immutable j; cartesianProduct(I5, I5))\n                if (i != j)\n                    enc[[c[i], c[j]]] = [c[(i + 1) % 5], c[(j+1) % 5]];\n        }\n\n        foreach (i1, j1, i2, j2; cartesianProduct(I5, I5, I5, I5))\n            if (i1 != i2 && j1 != j2)\n                enc[[m[i1][j1], m[i2][j2]]] = [m[i1][j2], m[i2][j1]];\n\n        dec = enc.byKeyValue.map!(t => tuple(t.value, t.key)).assocArray;\n    }\n\n    private string _canonicalize(in string s) const pure @safe {\n        return s.toUpper.removechars(\"^A-Z\").replace(from, to);\n    }\n\n    string encode(in string s) const /*pure @safe*/ {\n        return _canonicalize(s)\n               .matchAll(r\"(.)(?:(?!\\1)(.))?\")\n               .map!(m => enc[m[0].leftJustify(2, 'X')])\n               .join(' ');\n    }\n\n    string decode(in string s) const pure @safe {\n        return _canonicalize(s).chunks(2).map!(p => dec[p.text]).join(' ');\n    }\n}\n\nvoid main() /*@safe*/ {\n    /*immutable*/ const pf = Playfair(\"Playfair example\");\n    immutable orig = \"Hide the gold in...the TREESTUMP!!!\";\n    writeln(\"Original: \", orig);\n    immutable enc = pf.encode(orig);\n    writeln(\" Encoded: \", enc);\n    writeln(\" Decoded: \", pf.decode(enc));\n}\n\n\nOutput:\nOriginal: Hide the gold in...the TREESTUMP!!!\n Encoded: BM OD ZB XD NA BE KU DM UI XM MO UV IF\n Decoded: HI DE TH EG OL DI NT HE TR EX ES TU MP\n", "explain": ""}, {"task_name": "Playfair cipher", "task_url": "https://rosettacode.org/wiki/Playfair_cipher", "task_cat": "Encryption", "lang": "Haskell", "code": "\n\n\nThis example is incorrect.  Please fix the code and remove this message.Details: TREESTUMP -> TREXSTUMPX, should be TREXESTUMP\n\n\nimport Control.Monad     (guard)\nimport Data.Array        (Array, assocs, elems, listArray, (!))\nimport Data.Char         (toUpper)\nimport Data.List         (nub, (\\\\))\nimport Data.List.Split   (chunksOf)\nimport Data.Maybe        (listToMaybe)\nimport Data.String.Utils (replace)\n\ntype Square a = Array (Int, Int) a\n\n-- | Turns a list into an n*m-array.\narray2D ::\n       (Int, Int) -- ^ n * m\n    -> [e] -> Square e\narray2D maxCoord = listArray ((1, 1), maxCoord)\n\n-- | Generates a playfair table starting with the specified string.\n--\n-- >>> makeTable \"hello\"\n-- \"HELOABCDFGIKMNPQRSTUVWXYZ\"\nmakeTable :: String -> String\nmakeTable k = nub key ++ (alpha \\\\ key)\n    where\n      alpha = ['A' .. 'Z'] \\\\ \"J\"\n      key = map toUpper =<< words k\n\n-- | Turns a playfair table into a 5*5 alphabet square.\nmakeSquare :: [a] -> Square a\nmakeSquare = array2D (5, 5)\n\n-- | Displays a playfair square, formatted as a square.\nshowSquare :: Square Char -> String\nshowSquare d = unlines $ chunksOf 5 (elems d)\n\n-- | Given a value and an association list of x-coordinate * y-coordinate * value, returns the coordinates\ngetIndex' :: (Eq a) => a -> [((Int, Int), a)] -> Maybe (Int, Int)\ngetIndex' el = fmap fst . listToMaybe . filter ((== el) . snd)\n\nencodePair, decodePair :: Eq a => Square a -> (a, a) -> Maybe (a, a)\nencodePair = pairHelper (\\x -> if x == 5 then 1 else x + 1)\ndecodePair = pairHelper (\\x -> if x == 1 then 5 else x - 1)\n\npairHelper :: (Eq t)\n    => (Int -> Int) -- ^ a function used for wrapping around the square\n    -> Square t -- ^ a playfair square\n    -> (t, t) -- ^ two characters\n    -> Maybe (t, t) -- ^ the two resulting/encoded characters\npairHelper adjust sqr (c1, c2) =\n    do let ps = assocs sqr\n       -- assigns an association list of (x-coord * y-coord) * value to ps\n       (x1, y1) <- getIndex' c1 ps\n       (x2, y2) <- getIndex' c2 ps\n       -- returns the coordinates of two values in the square\n       -- these will later be swapped\n       guard $ c1 /= c2\n       -- the characters (and coordinates) cannot be the same\n       let get x = sqr ! x\n       -- a small utility function for extracting a value from the square\n       Just $\n           -- wrap the coordinates around and find the encrypted characters\n           case () of\n             () | y1 == y2 ->\n                    (get (adjust x1, y1), get (adjust x2, y2))\n                | x1 == x2 ->\n                    (get (x1, adjust y1), get (x2, adjust y2))\n                | otherwise ->\n                    (get (x1, y2), get (x2, y1))\n\n-- | Turns two characters into a tuple.\nparsePair :: String -> [(Char, Char)]\nparsePair = fmap (\\[x, y] -> (x, y)) . words . fmap toUpper\n\n-- | Turns a tuple of two characters into a string.\nunparsePair :: [(Char, Char)] -> String\nunparsePair = unwords . fmap (\\(x, y) -> [x, y])\n\ncodeHelper :: (Square Char -> (Char, Char) -> Maybe (Char, Char))\n    -> String -> String -> Maybe String\ncodeHelper subs key =\n    fmap unparsePair .\n    mapM (subs (makeSquare $ makeTable key)) .\n    parsePair\n\nplayfair, unplayfair :: String -> String -> Maybe String\nplayfair key = codeHelper encodePair key . formatEncode\nunplayfair = codeHelper decodePair\n\nformatEncode :: String -> String\nformatEncode =\n    map toUpper .\n    unwords .\n    map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]) .\n    chunksOf 2 .\n    replace \"j\" \"i\" .\n    concatMap adjustLength .\n    words .\n    filter (\\n -> n `elem` (['A'..'Z'] ++ ['a'..'z']))\n    where\n      adjustLength str\n          | odd (length str) = str ++ \"x\"\n          | otherwise = str\n\n>>> playfair \"playfair example\" \"hide the gold in the tree stump\"\nJust \"BM OD ZB XD NA BE KU DM UI XM KZ ZR YI\"\n\n>>> unplayfair \"playfair example\" \"BM OD ZB XD NA BE KU DM UI XM KZ ZR YI\"\nJust \"HI DE TH EG OL DI NT HE TR EX ST UM PX\"\n\n", "explain": "(My guess is that  map (\\[x, y] -> if x == y then [x, 'x'] else [x, y]).chunksOf 2 is simply discarding the y. Pete Lomax (talk) 05:54, 13 October 2018 (UTC))\n"}]