[{"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Python", "code": "\nBrute force algorithm[edit]\nfrom itertools import combinations\n\ndef anycomb(items):\n    ' return combinations of any length from the items '\n    return ( comb\n             for r in range(1, len(items)+1)\n             for comb in combinations(items, r)\n             )\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nbagged = max( anycomb(items), key=totalvalue) # max val or min wt if values equal\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\n\nOutput:\nBagged the following items\n  banana\n  compass\n  glucose\n  map\n  note-case\n  sandwich\n  socks\n  sunglasses\n  suntan cream\n  water\n  waterproof overclothes\n  waterproof trousers\nfor a total value of 1030 and a total weight of 396\n\nDynamic programming solution[edit]\ntry:\n    xrange\nexcept:\n    xrange = range\n\ndef totalvalue(comb):\n    ' Totalise a particular combination of items'\n    totwt = totval = 0\n    for item, wt, val in comb:\n        totwt  += wt\n        totval += val\n    return (totval, -totwt) if totwt <= 400 else (0, 0)\n\nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\n\ndef knapsack01_dp(items, limit):\n    table = [[0 for w in range(limit + 1)] for j in xrange(len(items) + 1)]\n \n    for j in xrange(1, len(items) + 1):\n        item, wt, val = items[j-1]\n        for w in xrange(1, limit + 1):\n            if wt > w:\n                table[j][w] = table[j-1][w]\n            else:\n                table[j][w] = max(table[j-1][w],\n                                  table[j-1][w-wt] + val)\n \n    result = []\n    w = limit\n    for j in range(len(items), 0, -1):\n        was_added = table[j][w] != table[j-1][w]\n\n        if was_added:\n            item, wt, val = items[j-1]\n            result.append(items[j-1])\n            w -= wt\n \n    return result\n\n\nbagged = knapsack01_dp(items, 400)\nprint(\"Bagged the following items\\n  \" +\n      '\\n  '.join(sorted(item for item,_,_ in bagged)))\nval, wt = totalvalue(bagged)\nprint(\"for a total value of %i and a total weight of %i\" % (val, -wt))\n\nRecursive dynamic programming algorithm[edit]\ndef total_value(items, max_weight):\n    return  sum([x[2] for x in items]) if sum([x[1] for x in items]) <= max_weight else 0\n \ncache = {}\ndef solve(items, max_weight):\n    if not items:\n        return ()\n    if (items,max_weight) not in cache:\n        head = items[0]\n        tail = items[1:]\n        include = (head,) + solve(tail, max_weight - head[1])\n        dont_include = solve(tail, max_weight)\n        if total_value(include, max_weight) > total_value(dont_include, max_weight):\n            answer = include\n        else:\n            answer = dont_include\n        cache[(items,max_weight)] = answer\n    return cache[(items,max_weight)]\n \nitems = (\n    (\"map\", 9, 150), (\"compass\", 13, 35), (\"water\", 153, 200), (\"sandwich\", 50, 160),\n    (\"glucose\", 15, 60), (\"tin\", 68, 45), (\"banana\", 27, 60), (\"apple\", 39, 40),\n    (\"cheese\", 23, 30), (\"beer\", 52, 10), (\"suntan cream\", 11, 70), (\"camera\", 32, 30),\n    (\"t-shirt\", 24, 15), (\"trousers\", 48, 10), (\"umbrella\", 73, 40),\n    (\"waterproof trousers\", 42, 70), (\"waterproof overclothes\", 43, 75),\n    (\"note-case\", 22, 80), (\"sunglasses\", 7, 20), (\"towel\", 18, 12),\n    (\"socks\", 4, 50), (\"book\", 30, 10),\n    )\nmax_weight = 400\n\nsolution = solve(items, max_weight)\nprint \"items:\"\nfor x in solution:\n    print x[0]\nprint \"value:\", total_value(solution, max_weight)\nprint \"weight:\", sum([x[1] for x in solution])\n\n\nPython Russian Binary ciphers[edit]\n\nn=5; N=n+1; G=5; a=2**N\t# KNAPSACK 0-1 DANILIN \t\nL=[];C=[];e=[];j=[];q=[];s=[] # rextester.com/BCKP19591\nd=[];L=[1]*n;C=[1]*n;e=[1]*a\t\nj=[1]*n;q=[0]*a;s=[0]*a;d=[0]*a\n\nfrom random import randint\nfor i in range(0,n):\n    L[i]=randint(1,3)\n    C[i]=10+randint(1,9)\n    print(i+1,L[i],C[i])\nprint()\n\nfor h in range(a-1,(a-1)//2,-1):\n    b=str(bin(h))\n    e[h]=b[3:len(b)]\n        \n    for k in range (n):\n        j[k]=int(e[h][k])\n        q[h]=q[h]+L[k]*j[k]*C[k]\n        d[h]=d[h]+L[k]*j[k]\n        \n    if d[h]<= G:\n        print(e[h], G, d[h], q[h])\nprint()   \n\nmax=0; m=1 \nfor i in range(a):\n    if d[i]<=G and q[i]>max:\n        max=q[i]; m=i\t\nprint (d[m], q[m], e[m])\n\n\nOutput:\n# Mass Cost\n1 2 12\n2 3 17\n3 1 14\n4 3 17\n5 1 13\nChifer Mass Cost           \n11000 5 5 75\n10101 5 4 51\n01001 5 4 64\n00111 5 5 78\u00a0!!!\n00110 5 4 65\n00101 5 2 27\n00000 5 0 0\nMass MAX Chifer\n5 78 00111\n", "explain": "\nRussian Knapsack 0-1 synthesizes all ciphers from 0 & 1 adding left +1 register and 0 remain on left in cipher\nNumber of comparisons decreases from N! to 2^N for example N=8 N!=40320 >> 2^N=256\nRandom values origin are automatically assigned create integral of quantity and quality \n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "C", "code": "\n#include <stdio.h>\n#include <stdlib.h>\n\ntypedef struct {\n    char *name;\n    int weight;\n    int value;\n} item_t;\n\nitem_t items[] = {\n    {\"map\",                      9,   150},\n    {\"compass\",                 13,    35},\n    {\"water\",                  153,   200},\n    {\"sandwich\",                50,   160},\n    {\"glucose\",                 15,    60},\n    {\"tin\",                     68,    45},\n    {\"banana\",                  27,    60},\n    {\"apple\",                   39,    40},\n    {\"cheese\",                  23,    30},\n    {\"beer\",                    52,    10},\n    {\"suntan cream\",            11,    70},\n    {\"camera\",                  32,    30},\n    {\"T-shirt\",                 24,    15},\n    {\"trousers\",                48,    10},\n    {\"umbrella\",                73,    40},\n    {\"waterproof trousers\",     42,    70},\n    {\"waterproof overclothes\",  43,    75},\n    {\"note-case\",               22,    80},\n    {\"sunglasses\",               7,    20},\n    {\"towel\",                   18,    12},\n    {\"socks\",                    4,    50},\n    {\"book\",                    30,    10},\n};\n\nint *knapsack (item_t *items, int n, int w) {\n    int i, j, a, b, *mm, **m, *s;\n    mm = calloc((n + 1) * (w + 1), sizeof (int));\n    m = malloc((n + 1) * sizeof (int *));\n    m[0] = mm;\n    for (i = 1; i <= n; i++) {\n        m[i] = &mm[i * (w + 1)];\n        for (j = 0; j <= w; j++) {\n            if (items[i - 1].weight > j) {\n                m[i][j] = m[i - 1][j];\n            }\n            else {\n                a = m[i - 1][j];\n                b = m[i - 1][j - items[i - 1].weight] + items[i - 1].value;\n                m[i][j] = a > b ? a : b;\n            }\n        }\n    }\n    s = calloc(n, sizeof (int));\n    for (i = n, j = w; i > 0; i--) {\n        if (m[i][j] > m[i - 1][j]) {\n            s[i - 1] = 1;\n            j -= items[i - 1].weight;\n        }\n    }\n    free(mm);\n    free(m);\n    return s;\n}\n\nint main () {\n    int i, n, tw = 0, tv = 0, *s;\n    n = sizeof (items) / sizeof (item_t);\n    s = knapsack(items, n, 400);\n    for (i = 0; i < n; i++) {\n        if (s[i]) {\n            printf(\"%-22s %5d %5d\\n\", items[i].name, items[i].weight, items[i].value);\n            tw += items[i].weight;\n            tv += items[i].value;\n        }\n    }\n    printf(\"%-22s %5d %5d\\n\", \"totals:\", tw, tv);\n    return 0;\n}\n\n\nOutput:\nmap                        9   150\ncompass                   13    35\nwater                    153   200\nsandwich                  50   160\nglucose                   15    60\nbanana                    27    60\nsuntan cream              11    70\nwaterproof trousers       42    70\nwaterproof overclothes    43    75\nnote-case                 22    80\nsunglasses                 7    20\nsocks                      4    50\ntotals:                  396  1030\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "C++", "code": "\nFirst version[edit]\nLibrary: Boost\n#include <vector>\n#include <string>\n#include <iostream>\n#include <boost/tuple/tuple.hpp>\n#include <set>\n\nint findBestPack( const std::vector<boost::tuple<std::string , int , int> > & , \n      std::set<int> & , const int  ) ;\n\nint main( ) {\n   std::vector<boost::tuple<std::string , int , int> > items ;\n   //===========fill the vector with data====================\n   items.push_back( boost::make_tuple( \"\" , 0  ,  0 ) ) ;\n   items.push_back( boost::make_tuple( \"map\" , 9 , 150 ) ) ;\n   items.push_back( boost::make_tuple( \"compass\" , 13 , 35 ) ) ;\n   items.push_back( boost::make_tuple( \"water\" , 153 , 200 ) ) ;\n   items.push_back( boost::make_tuple( \"sandwich\", 50 , 160 ) ) ;\n   items.push_back( boost::make_tuple( \"glucose\" , 15 , 60 ) ) ;\n   items.push_back( boost::make_tuple( \"tin\", 68 , 45 ) ) ;\n   items.push_back( boost::make_tuple( \"banana\", 27 , 60 ) ) ;\n   items.push_back( boost::make_tuple( \"apple\" , 39 , 40 ) ) ;\n   items.push_back( boost::make_tuple( \"cheese\" , 23 , 30 ) ) ;\n   items.push_back( boost::make_tuple( \"beer\" , 52 , 10 ) ) ;\n   items.push_back( boost::make_tuple( \"suntan creme\" , 11 , 70 ) ) ;\n   items.push_back( boost::make_tuple( \"camera\" , 32 , 30 ) ) ;\n   items.push_back( boost::make_tuple( \"T-shirt\" , 24 , 15 ) ) ;\n   items.push_back( boost::make_tuple( \"trousers\" , 48 , 10 ) ) ;\n   items.push_back( boost::make_tuple( \"umbrella\" , 73 , 40 ) ) ;\n   items.push_back( boost::make_tuple( \"waterproof trousers\" , 42 , 70 ) ) ;\n   items.push_back( boost::make_tuple( \"waterproof overclothes\" , 43 , 75 ) ) ;\n   items.push_back( boost::make_tuple( \"note-case\" , 22 , 80 ) ) ;\n   items.push_back( boost::make_tuple( \"sunglasses\" , 7 , 20 ) ) ;\n   items.push_back( boost::make_tuple( \"towel\" , 18 , 12 ) ) ;\n   items.push_back( boost::make_tuple( \"socks\" , 4 , 50 ) ) ;\n   items.push_back( boost::make_tuple( \"book\" , 30 , 10 ) ) ;\n   const int maximumWeight = 400 ;\n   std::set<int> bestItems ; //these items will make up the optimal value\n   int bestValue = findBestPack( items , bestItems , maximumWeight ) ;\n   std::cout << \"The best value that can be packed in the given knapsack is \" <<\n      bestValue << \"\u00a0!\\n\" ;\n   int totalweight = 0 ;\n   std::cout << \"The following items should be packed in the knapsack:\\n\" ;\n   for ( std::set<int>::const_iterator si = bestItems.begin( ) ; \n\t si != bestItems.end( ) ; si++ ) { \n      std::cout << (items.begin( ) + *si)->get<0>( ) << \"\\n\" ;\n      totalweight += (items.begin( ) + *si)->get<1>( ) ;\n   }\n   std::cout << \"The total weight of all items is \" << totalweight << \"\u00a0!\\n\" ;\n   return 0 ;\n}\n   \nint findBestPack( const std::vector<boost::tuple<std::string , int , int> > & items ,std::set<int> & bestItems , const int weightlimit ) {\n   //dynamic programming approach sacrificing storage space for execution\n   //time , creating a table of optimal values for every weight and a \n   //second table of sets with the items collected so far in the knapsack\n   //the best value is in the bottom right corner of the values table,\n   //the set of items in the bottom right corner of the sets' table.\n   const int n = items.size( ) ;\n   int bestValues [ n ][ weightlimit ] ;\n   std::set<int> solutionSets[ n ][ weightlimit ] ;\n   std::set<int> emptyset ;\n   for ( int i = 0 ; i < n ; i++ ) {\n      for ( int j = 0 ; j < weightlimit  ; j++ ) {\n\t bestValues[ i ][ j ] = 0 ;\n\t solutionSets[ i ][ j ] = emptyset ;\n       }\n    }\n    for ( int i = 0 ; i < n ; i++ ) {\n       for ( int weight = 0 ; weight < weightlimit ; weight++ ) {\n\t  if ( i == 0 )\n\t     bestValues[ i ][ weight ] = 0 ;\n\t  else  {\n\t     int itemweight = (items.begin( ) + i)->get<1>( ) ; \n\t     if ( weight < itemweight ) {\n\t\tbestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;\n\t\tsolutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;\n\t     } else { // weight >= itemweight\n\t\tif ( bestValues[ i - 1 ][ weight - itemweight ] + \n\t\t   (items.begin( ) + i)->get<2>( ) >\n\t\t        bestValues[ i - 1 ][ weight ] ) {\n\t\t   bestValues[ i ][ weight ] = \n\t\t       bestValues[ i - 1 ][ weight - itemweight ] + \n\t        \t(items.begin( ) + i)->get<2>( ) ;\n\t\t  solutionSets[ i ][ weight ] = \n\t\t      solutionSets[ i - 1 ][ weight - itemweight ] ;\n\t\t  solutionSets[ i ][ weight ].insert( i ) ;\n\t     }\n\t     else {\n\t\tbestValues[ i ][ weight ] = bestValues[ i - 1 ][ weight ] ;\n\t\tsolutionSets[ i ][ weight ] = solutionSets[ i - 1 ][ weight ] ;\n\t     }\n\t  }\n       }\n      }\n    }\n    bestItems.swap( solutionSets[ n - 1][ weightlimit - 1 ] ) ;\n    return bestValues[ n - 1 ][ weightlimit - 1 ] ;\n}\n\n\nOutput:\nThe best value that can be packed in the given knapsack is 1030\u00a0!\nThe following items should be packed in the knapsack:\nmap\ncompass\nwater\nsandwich\nglucose\nbanana\nsuntan creme\nwaterproof trousers\nwaterproof overclothes\nnote-case\nsunglasses\nsocks\nThe total weight of all items is 396\u00a0!\n\nSecond version[edit]\nWorks with: C++17\n#include <iomanip>\n#include <iostream>\n#include <set>\n#include <string>\n#include <tuple>\n#include <vector>\n\nstd::tuple<std::set<int>, int> findBestPack(const std::vector<std::tuple<std::string, int, int> > &items, const int weightlimit) {\n    const auto n = items.size();\n    int bestValues[n][weightlimit] = { 0 };\n    std::set<int> solutionSets[n][weightlimit];\n    std::set<int> bestItems;\n    for (auto i = 0u; i < n; i++)\n        for (auto weight = 0; weight < weightlimit; weight++) {\n            if (i == 0)\n                bestValues[i][weight] = 0;\n            else {\n                auto [_, itemweight, value] = *(items.begin() + i);\n                if (weight < itemweight) {\n                    bestValues[i][weight] = bestValues[i - 1][weight];\n                    solutionSets[i][weight] = solutionSets[i - 1][weight];\n                } else {\n                    if (bestValues[i - 1][weight - itemweight] + value > bestValues[i - 1][weight]) {\n                        bestValues[i][weight] = bestValues[i - 1][weight - itemweight] + value;\n                        solutionSets[i][weight] = solutionSets[i - 1][weight - itemweight];\n                        solutionSets[i][weight].insert(i);\n                    } else {\n                        bestValues[i][weight] = bestValues[i - 1][weight];\n                        solutionSets[i][weight] = solutionSets[i - 1][weight];\n                    }\n                }\n            }\n        }\n\n    bestItems.swap(solutionSets[n - 1][weightlimit - 1]);\n    return { bestItems, bestValues[n - 1][weightlimit - 1] };\n}\n\nint main() {\n    const std::vector<std::tuple<std::string, int, int>> items = {\n            { \"\", 0, 0 },\n            { \"map\", 9, 150 },\n            { \"compass\", 13, 35 },\n            { \"water\", 153, 200 },\n            { \"sandwich\", 50, 160 },\n            { \"glucose\", 15, 60 },\n            { \"tin\", 68, 45 },\n            { \"banana\", 27, 60 },\n            { \"apple\", 39, 40 },\n            { \"cheese\", 23, 30 },\n            { \"beer\", 52, 10 },\n            { \"suntan creme\", 11, 70 },\n            { \"camera\", 32, 30 },\n            { \"T-shirt\", 24, 15 },\n            { \"trousers\", 48, 10 },\n            { \"umbrella\", 73, 40 },\n            { \"waterproof trousers\", 42, 70 },\n            { \"waterproof overclothes\", 43, 75 },\n            { \"note-case\", 22, 80 },\n            { \"sunglasses\", 7, 20 },\n            { \"towel\", 18, 12 },\n            { \"socks\", 4, 50 },\n            { \"book\", 30, 10 } };\n\n    const int maximumWeight = 400;\n    const auto &[bestItems, bestValue] = findBestPack(items, maximumWeight);\n    int totalweight = 0;\n    std::cout << std::setw(24) << \"best knapsack:\" << std::endl;\n    for (auto si = bestItems.begin(); si != bestItems.end(); si++) {\n       auto [name, weight, value] = *(items.begin() + *si);\n       std::cout << std::setw(24) << name << std::setw(6) << weight << std::setw(6) << value << std::endl;\n       totalweight += weight;\n    }\n    std::cout << std::endl << std::setw(24) << \"total:\" << std::setw(6) << totalweight << std::setw(6) << bestValue << std::endl;\n    return 0;\n}\n\n\nOutput:\n          best knapsack:\n                     map     9   150\n                 compass    13    35\n                   water   153   200\n                sandwich    50   160\n                 glucose    15    60\n                  banana    27    60\n            suntan creme    11    70\n     waterproof trousers    42    70\n  waterproof overclothes    43    75\n               note-case    22    80\n              sunglasses     7    20\n                   socks     4    50\n\n                  total:   396  1030\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Java", "code": "\n\npackage hu.pj.alg.test;\n\nimport hu.pj.alg.ZeroOneKnapsack;\nimport hu.pj.obj.Item;\nimport java.util.*;\nimport java.text.*;\n\npublic class ZeroOneKnapsackForTourists {\n\n    public ZeroOneKnapsackForTourists() {\n        ZeroOneKnapsack zok = new ZeroOneKnapsack(400); // 400 dkg = 400 dag = 4 kg\n\n        // making the list of items that you want to bring\n        zok.add(\"map\", 9, 150);\n        zok.add(\"compass\", 13, 35);\n        zok.add(\"water\", 153, 200);\n        zok.add(\"sandwich\", 50, 160);\n        zok.add(\"glucose\", 15, 60);\n        zok.add(\"tin\", 68, 45);\n        zok.add(\"banana\", 27, 60);\n        zok.add(\"apple\", 39, 40);\n        zok.add(\"cheese\", 23, 30);\n        zok.add(\"beer\", 52, 10);\n        zok.add(\"suntan cream\", 11, 70);\n        zok.add(\"camera\", 32, 30);\n        zok.add(\"t-shirt\", 24, 15);\n        zok.add(\"trousers\", 48, 10);\n        zok.add(\"umbrella\", 73, 40);\n        zok.add(\"waterproof trousers\", 42, 70);\n        zok.add(\"waterproof overclothes\", 43, 75);\n        zok.add(\"note-case\", 22, 80);\n        zok.add(\"sunglasses\", 7, 20);\n        zok.add(\"towel\", 18, 12);\n        zok.add(\"socks\", 4, 50);\n        zok.add(\"book\", 30, 10);\n\n        // calculate the solution:\n        List<Item> itemList = zok.calcSolution();\n\n        // write out the solution in the standard output\n        if (zok.isCalculated()) {\n            NumberFormat nf  = NumberFormat.getInstance();\n\n            System.out.println(\n                \"Maximal weight           = \" +\n                nf.format(zok.getMaxWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total weight of solution = \" +\n                nf.format(zok.getSolutionWeight() / 100.0) + \" kg\"\n            );\n            System.out.println(\n                \"Total value              = \" +\n                zok.getProfit()\n            );\n            System.out.println();\n            System.out.println(\n                \"You can carry the following materials \" +\n                \"in the knapsack:\"\n            );\n            for (Item item : itemList) {\n                if (item.getInKnapsack() == 1) {\n                    System.out.format(\n                        \"%1$-23s %2$-3s %3$-5s %4$-15s \\n\",\n                        item.getName(),\n                        item.getWeight(), \"dag  \",\n                        \"(value = \" + item.getValue() + \")\"\n                    );\n                }\n            }\n        } else {\n            System.out.println(\n                \"The problem is not solved. \" +\n                \"Maybe you gave wrong data.\"\n            );\n        }\n\n    }\n\n    public static void main(String[] args) {\n        new ZeroOneKnapsackForTourists();\n    }\n\n} // class\n\npackage hu.pj.alg;\n\nimport hu.pj.obj.Item;\nimport java.util.*;\n\npublic class ZeroOneKnapsack {\n\n    protected List<Item> itemList  = new ArrayList<Item>();\n    protected int maxWeight        = 0;\n    protected int solutionWeight   = 0;\n    protected int profit           = 0;\n    protected boolean calculated   = false;\n\n    public ZeroOneKnapsack() {}\n\n    public ZeroOneKnapsack(int _maxWeight) {\n        setMaxWeight(_maxWeight);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList) {\n        setItemList(_itemList);\n    }\n\n    public ZeroOneKnapsack(List<Item> _itemList, int _maxWeight) {\n        setItemList(_itemList);\n        setMaxWeight(_maxWeight);\n    }\n\n    // calculte the solution of 0-1 knapsack problem with dynamic method:\n    public List<Item> calcSolution() {\n        int n = itemList.size();\n\n        setInitialStateForCalculation();\n        if (n > 0  &&  maxWeight > 0) {\n            List< List<Integer> > c = new ArrayList< List<Integer> >();\n            List<Integer> curr = new ArrayList<Integer>();\n\n            c.add(curr);\n            for (int j = 0; j <= maxWeight; j++)\n                curr.add(0);\n            for (int i = 1; i <= n; i++) {\n                List<Integer> prev = curr;\n                c.add(curr = new ArrayList<Integer>());\n                for (int j = 0; j <= maxWeight; j++) {\n                    if (j > 0) {\n                        int wH = itemList.get(i-1).getWeight();\n                        curr.add(\n                            (wH > j)\n                            ?\n                            prev.get(j)\n                            :\n                            Math.max(\n                                prev.get(j),\n                                itemList.get(i-1).getValue() + prev.get(j-wH)\n                            )\n                        );\n                    } else {\n                        curr.add(0);\n                    }\n                } // for (j...)\n            } // for (i...)\n            profit = curr.get(maxWeight);\n\n            for (int i = n, j = maxWeight; i > 0  &&  j >= 0; i--) {\n                int tempI   = c.get(i).get(j);\n                int tempI_1 = c.get(i-1).get(j);\n                if (\n                    (i == 0  &&  tempI > 0)\n                    ||\n                    (i > 0  &&  tempI != tempI_1)\n                )\n                {\n                    Item iH = itemList.get(i-1);\n                    int  wH = iH.getWeight();\n                    iH.setInKnapsack(1);\n                    j -= wH;\n                    solutionWeight += wH;\n                }\n            } // for()\n            calculated = true;\n        } // if()\n        return itemList;\n    }\n\n    // add an item to the item list\n    public void add(String name, int weight, int value) {\n        if (name.equals(\"\"))\n            name = \"\" + (itemList.size() + 1);\n        itemList.add(new Item(name, weight, value));\n        setInitialStateForCalculation();\n    }\n\n    // add an item to the item list\n    public void add(int weight, int value) {\n        add(\"\", weight, value); // the name will be \"itemList.size() + 1\"!\n    }\n\n    // remove an item from the item list\n    public void remove(String name) {\n        for (Iterator<Item> it = itemList.iterator(); it.hasNext(); ) {\n            if (name.equals(it.next().getName())) {\n                it.remove();\n            }\n        }\n        setInitialStateForCalculation();\n    }\n\n    // remove all items from the item list\n    public void removeAllItems() {\n        itemList.clear();\n        setInitialStateForCalculation();\n    }\n\n    public int getProfit() {\n        if (!calculated)\n            calcSolution();\n        return profit;\n    }\n\n    public int getSolutionWeight() {return solutionWeight;}\n    public boolean isCalculated() {return calculated;}\n    public int getMaxWeight() {return maxWeight;}\n\n    public void setMaxWeight(int _maxWeight) {\n        maxWeight = Math.max(_maxWeight, 0);\n    }\n\n    public void setItemList(List<Item> _itemList) {\n        if (_itemList != null) {\n            itemList = _itemList;\n            for (Item item : _itemList) {\n                item.checkMembers();\n            }\n        }\n    }\n\n    // set the member with name \"inKnapsack\" by all items:\n    private void setInKnapsackByAll(int inKnapsack) {\n        for (Item item : itemList)\n            if (inKnapsack > 0)\n                item.setInKnapsack(1);\n            else\n                item.setInKnapsack(0);\n    }\n\n    // set the data members of class in the state of starting the calculation:\n    protected void setInitialStateForCalculation() {\n        setInKnapsackByAll(0);\n        calculated     = false;\n        profit         = 0;\n        solutionWeight = 0;\n    }\n\n} // class\n\npackage hu.pj.obj;\n\npublic class Item {\n\n    protected String name    = \"\";\n    protected int weight     = 0;\n    protected int value      = 0;\n    protected int bounding   = 1; // the maximal limit of item's pieces\n    protected int inKnapsack = 0; // the pieces of item in solution\n\n    public Item() {}\n\n    public Item(Item item) {\n        setName(item.name);\n        setWeight(item.weight);\n        setValue(item.value);\n        setBounding(item.bounding);\n    }\n\n    public Item(int _weight, int _value) {\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(int _weight, int _value, int _bounding) {\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public Item(String _name, int _weight, int _value) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n    }\n\n    public Item(String _name, int _weight, int _value, int _bounding) {\n        setName(_name);\n        setWeight(_weight);\n        setValue(_value);\n        setBounding(_bounding);\n    }\n\n    public void setName(String _name) {name = _name;}\n    public void setWeight(int _weight) {weight = Math.max(_weight, 0);}\n    public void setValue(int _value) {value = Math.max(_value, 0);}\n\n    public void setInKnapsack(int _inKnapsack) {\n        inKnapsack = Math.min(getBounding(), Math.max(_inKnapsack, 0));\n    }\n\n    public void setBounding(int _bounding) {\n        bounding = Math.max(_bounding, 0);\n        if (bounding == 0)\n            inKnapsack = 0;\n    }\n\n    public void checkMembers() {\n        setWeight(weight);\n        setValue(value);\n        setBounding(bounding);\n        setInKnapsack(inKnapsack);\n    }\n\n    public String getName() {return name;}\n    public int getWeight() {return weight;}\n    public int getValue() {return value;}\n    public int getInKnapsack() {return inKnapsack;}\n    public int getBounding() {return bounding;}\n\n} // class\n\n\nOutput:\nMaximal weight           = 4 kg\nTotal weight of solution = 3,96 kg\nTotal value              = 1030\n\nYou can carry te following materials in the knapsack:\nmap                     9   dag   (value = 150)   \ncompass                 13  dag   (value = 35)    \nwater                   153 dag   (value = 200)   \nsandwich                50  dag   (value = 160)   \nglucose                 15  dag   (value = 60)    \nbanana                  27  dag   (value = 60)    \nsuntan cream            11  dag   (value = 70)    \nwaterproof trousers     42  dag   (value = 70)    \nwaterproof overclothes  43  dag   (value = 75)    \nnote-case               22  dag   (value = 80)    \nsunglasses              7   dag   (value = 20)    \nsocks                   4   dag   (value = 50)    \n\n", "explain": "General dynamic solution after wikipedia.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "C#", "code": "\nLibrary: System\nLibrary: System.Collections.Generic\nusing System;\nusing System.Collections.Generic;\n\nnamespace Tests_With_Framework_4\n{\n\nclass Bag : IEnumerable<Bag.Item>\n        {\n            List<Item> items;\n            const int MaxWeightAllowed = 400;\n\n            public Bag()\n            {\n                items = new List<Item>();\n            }\n\n            void AddItem(Item i)\n            {\n                if ((TotalWeight + i.Weight) <= MaxWeightAllowed)\n                    items.Add(i);\n            }\n\n            public void Calculate(List<Item> items)\n            {\n                foreach (Item i in Sorte(items))\n                {\n                    AddItem(i);\n                }\n            }\n\n            List<Item> Sorte(List<Item> inputItems)\n            {\n                List<Item> choosenItems = new List<Item>();\n                for (int i = 0; i < inputItems.Count; i++)\n                {\n                    int j = -1;\n                    if (i == 0)\n                    {\n                        choosenItems.Add(inputItems[i]);\n                    }\n                    if (i > 0)\n                    {\n                        if (!RecursiveF(inputItems, choosenItems, i, choosenItems.Count - 1, false, ref j))\n                        {\n                            choosenItems.Add(inputItems[i]);\n                        }\n                    }\n                }\n                return choosenItems;\n            }\n\n            bool RecursiveF(List<Item> knapsackItems, List<Item> choosenItems, int i, int lastBound, bool dec, ref int indxToAdd)\n            {\n                if (!(lastBound < 0))\n                {\n                    if ( knapsackItems[i].ResultWV < choosenItems[lastBound].ResultWV )\n                    {\n                        indxToAdd = lastBound;\n                    }\n                    return RecursiveF(knapsackItems, choosenItems, i, lastBound - 1, true, ref indxToAdd);\n                }\n                if (indxToAdd > -1)\n                {\n                    choosenItems.Insert(indxToAdd, knapsackItems[i]);\n                    return true;\n                }\n                return false;\n            }\n\n            #region IEnumerable<Item> Members\n            IEnumerator<Item> IEnumerable<Item>.GetEnumerator()\n            {\n                foreach (Item i in items)\n                    yield return i;\n            }\n            #endregion\n\n            #region IEnumerable Members\n            System.Collections.IEnumerator System.Collections.IEnumerable.GetEnumerator()\n            {\n                return items.GetEnumerator();\n            }\n            #endregion\n\n            public int TotalWeight\n            {\n                get\n                {\n                    var sum = 0;\n                    foreach (Item i in this)\n                    {\n                        sum += i.Weight;\n                    }\n                    return sum;\n                }\n            }\n\n            public class Item\n            {\n                public string Name { get; set; } public int Weight { get; set; } public int Value { get; set; } public int ResultWV { get { return  Weight-Value; } }\n                public override string ToString()\n                {\n                    return \"Name\u00a0: \" + Name + \"        Wieght\u00a0: \" + Weight + \"       Value\u00a0: \" + Value + \"     ResultWV\u00a0: \" + ResultWV;\n                }\n            }\n        }\n\n    class Program\n    {\n        static void Main(string[] args)\n        {List<Bag.Item> knapsackItems = new List<Bag.Item>();\n            knapsackItems.Add(new Bag.Item() { Name = \"Map\", Weight = 9, Value = 150 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Water\", Weight = 153, Value = 200 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Compass\", Weight = 13, Value = 35 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sandwitch\", Weight = 50, Value = 160 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Glucose\", Weight = 15, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Tin\", Weight = 68, Value = 45 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Banana\", Weight = 27, Value = 60 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Apple\", Weight = 39, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Cheese\", Weight = 23, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Beer\", Weight = 52, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Suntan Cream\", Weight = 11, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Camera\", Weight = 32, Value = 30 });\n            knapsackItems.Add(new Bag.Item() { Name = \"T-shirt\", Weight = 24, Value = 15 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Trousers\", Weight = 48, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Umbrella\", Weight = 73, Value = 40 });\n            knapsackItems.Add(new Bag.Item() { Name = \"WaterProof Trousers\", Weight = 42, Value = 70 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Note-Case\", Weight = 22, Value = 80 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Sunglasses\", Weight = 7, Value = 20 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Towel\", Weight = 18, Value = 12 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Socks\", Weight = 4, Value = 50 });\n            knapsackItems.Add(new Bag.Item() { Name = \"Book\", Weight = 30, Value = 10 });\n            knapsackItems.Add(new Bag.Item() { Name = \"waterproof overclothes \", Weight = 43, Value = 75 });\n\n            Bag b = new Bag();\n            b.Calculate(knapsackItems);\n            b.All(x => { Console.WriteLine(x); return true; });\n            Console.WriteLine(b.Sum(x => x.Weight));\n            Console.ReadKey();\n        }\n    }\n}\n\n\nC#, Alternative Version[edit]\n\nusing System;\t\t// Knapsack C# binary DANILIN\nusing System.Text;\t// rextester.com/YRFA61366\nnamespace Knapsack \n{ \nclass Knapsack  \n    { \n    static void Main()\n        { \n            int n = 7; \n            int Inside = 5; \n            int all=Convert.ToInt32(Math.Pow(2,(n+1))); \n            int[] mass = new int[n]; \n            int[] cost = new int[n]; \n            int[] jack = new int[n]; \n            int[] quality = new int[all]; \n            int[] amount = new int[all];   \n            int i; \t\t\t// circle\n            int k; \t\t\t// circle\n            int dec;  \n            string[] bin = new string[all]; \n            int list; \n            int max;\n            int max_num;\n            Random rand = new Random();\n\n            for (i=0; i<n; i++)\n            {\n                mass[i]=1+rand.Next(3);\n                cost[i]=10+rand.Next(9);\n                Console.WriteLine(\"{0} {1} {2}\", i+1, mass[i], cost[i]); \n            } \n            Console.WriteLine();\n\n            for (list = all-1; list>(all-1)/2; list--) \n            { \n                dec=list; \n                while (dec > 0)\n                { \n                    bin[list] = dec % 2 + bin[list]; // from 10 to 2 \n                    dec/=2; \n                }\n                if (bin[list] == \"\") \n                {\n                    bin[list] = \"0\";\n                }\n                bin[list]=bin[list].Substring(1,bin[list].Length-1); \n                for (k=0; k<n; k++) // inside 01\n                {\n                    jack[k]=Convert.ToInt32(bin[list].Substring(k,1));\n                    quality[list]=quality[list]+mass[k]*jack[k]*cost[k]; \t// integral of costs\n                    amount[list]=amount[list]+mass[k]*jack[k]; \t// integral of mass\n                }        \n                if (amount[list]<= Inside)\t\t// current mass < Knapsack\n                { \n                    Console.WriteLine(\"{0} {1} {2} {3}\", Inside, amount[list], quality[list], bin[list]); \n                } \n            } \n            Console.WriteLine();\n\n            max=0; \n            max_num=1;\n            for (i=0; i < all; i++)\n            { \n                if (amount[i]<=Inside && quality[i]>max)\n                { \n                    max = quality[i]; max_num =i ;\n                }\n            }\n            Console.WriteLine(\"{0} {1} {2}\",amount[max_num],quality[max_num],bin[max_num]);\n        }\n    }\n}\n\n\nOutput:\n # Mass Cost\n1 2 12\n2 3 17\n3 1 14\n4 3 17\n5 1 13\nChifer Mass Cost \n11000 5 5 75\n01001 5 4 64\n00111 5 5 78\u00a0!!!\n00110 5 4 65\n00101 5 2 27\nMass MAX Chifer\n5 78 00111\n\nOutput:\nint n = 20; \nint Inside = 400; \nint all=Convert.ToInt32(Math.Pow(2,(n+1))); \nint[] mass = {9,13,153,50,15,68,27,39,23,52,11,32,24,48,73,42,43,22,7,4,30}; \nint[] cost = {150,35,200,160,60,45,60,40,30,10,70,30,15,10,40,70,75,80,20,50,10}; \n\n396 1030 11111010001000011111\n\njdoodle.com/ia/rSn\n", "explain": "(\"Bag\" might not be the best name for the class, since \"bag\" is sometimes also used to refer to a multiset data structure.)\n\nC# Knapsak 0-1 Russian Binary ciphers\nRussian Knapsack 0-1 synthesizes all ciphers from 0 & 1 adding left +1 register and 0 remain on left in cipher\nNumber of comparisons decreases from N! to 2^N for example N=8 N!=40320 >> 2^N=256\nRandom values origin are automatically assigned create integral of quantity and quality \n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "JavaScript", "code": "\n\n/*global portviz:false, _:false */\n/*\n * 0-1 knapsack solution, recursive, memoized, approximate.\n *\n * credits:\n *\n * the Go implementation here:\n *   http://rosettacode.org/mw/index.php?title=Knapsack_problem/0-1\n *\n * approximation details here:\n *   http://math.mit.edu/~goemans/18434S06/knapsack-katherine.pdf\n */\nportviz.knapsack = {};\n(function() {\n  this.combiner = function(items, weightfn, valuefn) {\n    // approximation guarantees result >= (1-e) * optimal\n    var _epsilon = 0.01;\n    var _p = _.max(_.map(items,valuefn));\n    var _k = _epsilon * _p / items.length;\n \n    var _memo = (function(){\n      var _mem = {};\n      var _key = function(i, w) {\n        return i + '::' + w;\n      };\n      return {\n        get: function(i, w) {\n          return _mem[_key(i,w)];\n        },\n        put: function(i, w, r) {\n          _mem[_key(i,w)]=r;\n          return r;\n        }\n      };\n    })();\n \n    var _m = function(i, w) {\n \n      i = Math.round(i);\n      w = Math.round(w);\n \n \n      if (i < 0 || w === 0) {\n        // empty base case\n        return {items: [], totalWeight: 0, totalValue: 0};\n      }\n \n      var mm = _memo.get(i,w);\n      if (!_.isUndefined(mm)) {\n        return mm;\n      }\n \n      var item = items[i];\n      if (weightfn(item) > w) {\n        //item does not fit, try the next item\n        return _memo.put(i, w, _m(i-1, w));\n      }\n      // this item could fit.\n      // are we better off excluding it?\n      var excluded = _m(i-1, w);\n      // or including it?\n      var included = _m(i-1, w - weightfn(item));\n      if (included.totalValue + Math.floor(valuefn(item)/_k) > excluded.totalValue) {\n        // better off including it\n        // make a copy of the list\n        var i1 = included.items.slice();\n        i1.push(item);\n        return _memo.put(i, w,\n          {items: i1,\n           totalWeight: included.totalWeight + weightfn(item),\n           totalValue: included.totalValue + Math.floor(valuefn(item)/_k)});\n      }\n      //better off excluding it\n      return _memo.put(i,w, excluded);\n    };\n    return {\n      /* one point */\n      one: function(maxweight) {\n        var scaled = _m(items.length - 1, maxweight);\n        return {\n          items: scaled.items,\n          totalWeight: scaled.totalWeight,\n          totalValue: scaled.totalValue * _k\n        };\n      },\n      /* the entire EF */\n      ef: function(maxweight, step) {\n        return _.map(_.range(0, maxweight+1, step), function(weight) {\n          var scaled = _m(items.length - 1, weight);\n          return {\n            items: scaled.items,\n            totalWeight: scaled.totalWeight,\n            totalValue: scaled.totalValue * _k\n          };\n        });\n      }\n    };\n  };\n}).apply(portviz.knapsack);\n\n/*global portviz:false, _:false */\n/*\n * after rosettacode.org/mw/index.php?title=Knapsack_problem/0-1\n */\nvar allwants = [\n  {name:\"map\", weight:9, value: 150},\n  {name:\"compass\", weight:13, value: 35},\n  {name:\"water\", weight:153, value: 200},\n  {name:\"sandwich\", weight: 50, value: 160},\n  {name:\"glucose\", weight:15, value: 60},\n  {name:\"tin\", weight:68, value: 45},\n  {name:\"banana\", weight:27, value: 60},\n  {name:\"apple\", weight:39, value: 40},\n  {name:\"cheese\", weight:23, value: 30},\n  {name:\"beer\", weight:52, value: 10},\n  {name:\"suntan cream\", weight:11, value: 70},\n  {name:\"camera\", weight:32, value: 30},\n  {name:\"T-shirt\", weight:24, value: 15},\n  {name:\"trousers\", weight:48, value: 10},\n  {name:\"umbrella\", weight:73, value: 40},\n  {name:\"waterproof trousers\", weight:42, value: 70},\n  {name:\"waterproof overclothes\", weight:43, value: 75},\n  {name:\"note-case\", weight:22, value: 80},\n  {name:\"sunglasses\", weight:7, value: 20},\n  {name:\"towel\", weight:18, value: 12},\n  {name:\"socks\", weight:4, value: 50},\n  {name:\"book\", weight:30, value: 10}\n];\n \nvar near = function(actual, expected, tolerance) {\n  if (expected === 0 && actual === 0) return true;\n  if (expected === 0) {\n    return Math.abs(expected - actual) / actual < tolerance;\n  }\n  return Math.abs(expected - actual) / expected < tolerance;\n};\n \ntest(\"one knapsack\", function() {\n  var combiner =\n    portviz.knapsack.combiner(allwants,\n      function(x){return x.weight;},\n      function(x){return x.value;});\n  var oneport = combiner.one(400);\n  ok(near(oneport.totalValue, 1030, 0.01), \"correct total value\");\n  ok(near(oneport.totalValue, 1030, 0.01), \"correct total value\");\n  equal(oneport.totalWeight, 396, \"correct total weight\");\n});\n \ntest(\"frontier\", function() {\n  var combiner =\n    portviz.knapsack.combiner(allwants,\n      function(x){return x.weight;},\n      function(x){return x.value;});\n  var ef = combiner.ef(400, 1);\n  equal(ef.length, 401, \"401 because it includes the endpoints\");\n  ef = combiner.ef(400, 40);\n  equal(ef.length, 11, \"11 because it includes the endpoints\");\n  var expectedTotalValue = [\n    0,\n    330,\n    445,\n    590,\n    685,\n    755,\n    810,\n    860,\n    902,\n    960,\n    1030\n  ] ;\n  _.each(ef, function(element, index) {\n    // 15% error!  bleah!\n    ok(near(element.totalValue, expectedTotalValue[index], 0.15),\n      'actual ' + element.totalValue + ' expected ' + expectedTotalValue[index]);\n  });\n  deepEqual(_.pluck(ef, 'totalWeight'), [\n    0,\n    39,\n    74,\n    118,\n    158,\n    200,\n    236,\n    266,\n    316,\n    354,\n    396\n  ]);\n  deepEqual(_.map(ef, function(x){return x.items.length;}), [\n    0,\n    4,\n    6,\n    7,\n    9,\n    10,\n    10,\n    12,\n    14,\n    11,\n    12\n   ]);\n});\n\n\n", "explain": "Also available at gist.\n\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic_.NET", "code": "\nWorks with: Visual Basic .NET version 2013\n'Knapsack problem/0-1 - 12/02/2017\nPublic Class KnapsackBin\n    Const knam = 0, kwei = 1, kval = 2\n    Const maxWeight = 400\n    Dim xList(,) As Object = { _\n            {\"map\", 9, 150}, _\n            {\"compass\", 13, 35}, _\n            {\"water\", 153, 200}, _\n            {\"sandwich\", 50, 160}, _\n            {\"glucose\", 15, 60}, _\n            {\"tin\", 68, 45}, _\n            {\"banana\", 27, 60}, _\n            {\"ChoiceBinle\", 39, 40}, _\n            {\"cheese\", 23, 30}, _\n            {\"beer\", 52, 10}, _\n            {\"suntan cream\", 11, 70}, _\n            {\"camera\", 32, 30}, _\n            {\"T-shirt\", 24, 15}, _\n            {\"trousers\", 48, 10}, _\n            {\"umbrella\", 73, 40}, _\n            {\"waterproof trousers\", 42, 70}, _\n            {\"waterproof overclothes\", 43, 75}, _\n            {\"note-case\", 22, 80}, _\n            {\"sunglasses\", 7, 20}, _\n            {\"towel\", 18, 12}, _\n            {\"socks\", 4, 50}, _\n            {\"book\", 30, 10}}\n    Dim s, xss As String, xwei, xval, nn As Integer\n\n    Private Sub KnapsackBin_Load(sender As Object, e As EventArgs) Handles MyBase.Load\n        Dim i As Integer\n        xListView.View = View.Details\n        xListView.Columns.Add(\"item\", 120, HorizontalAlignment.Left)\n        xListView.Columns.Add(\"weight\", 50, HorizontalAlignment.Right)\n        xListView.Columns.Add(\"value\", 50, HorizontalAlignment.Right)\n        For i = 0 To UBound(xList, 1)\n            xListView.Items.Add(New ListViewItem(New String() {xList(i, 0), _\n                                xList(i, 1).ToString, xList(i, 2).ToString}))\n        Next i\n    End Sub 'KnapsackBin_Load\n\n    Private Sub cmdOK_Click(sender As Object, e As EventArgs) Handles cmdOK.Click\n        Dim i, j, nItems As Integer\n        For i = xListView.Items.Count - 1 To 0 Step -1\n            xListView.Items.RemoveAt(i)\n        Next i\n        Me.Refresh()\n        nItems = UBound(xList, 1) + 1\n        s = \"\"\n        For i = 1 To nItems\n            s = s & Chr(i - 1)\n        Next\n        nn = 0\n        Call ChoiceBin(1, \"\")\n        For i = 1 To Len(xss)\n            j = Asc(Mid(xss, i, 1))\n            xListView.Items.Add(New ListViewItem(New String() {xList(j, 0), _\n                                xList(j, 1).ToString, xList(j, 2).ToString}))\n        Next i\n        xListView.Items.Add(New ListViewItem(New String() {\"*Total*\", xwei, xval}))\n    End Sub 'cmdOK_Click\n\n    Private Sub ChoiceBin(n As String, ss As String)\n        Dim r As String, i, j, iwei, ival As Integer\n        Dim ipct As Integer\n        If n = Len(s) + 1 Then\n            iwei = 0\u00a0: ival = 0\n            For i = 1 To Len(ss)\n                j = Asc(Mid(ss, i, 1))\n                iwei = iwei + xList(j, 1)\n                ival = ival + xList(j, 2)\n            Next\n            If iwei <= maxWeight And ival > xval Then\n                xss = ss\u00a0: xwei = iwei\u00a0: xval = ival\n            End If\n        Else\n            r = Mid(s, n, 1)\n            Call ChoiceBin(n + 1, ss & r)\n            Call ChoiceBin(n + 1, ss)\n        End If\n    End Sub 'ChoiceBin\n\nEnd Class 'KnapsackBin\n\nOutput:\nKnapsackBin_Load\ncmdOK_Click\nmap\ncompass\nwater\nsandwich\nglucose\nbanana\nsuntan cream\nwaterproof trousers\nwaterproof overclothes\nnote-case\nsunglasses\nsocks\n*Total*  weight=396  val=1030\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "SQL", "code": "\n\nWITH KnapsackItems (item, [weight], value) AS\n(\n    SELECT 'map',9,  150  \n    UNION ALL SELECT 'compass',13,  35  \n    UNION ALL SELECT 'water',153,  200  \n    UNION ALL SELECT 'sandwich',50,  160  \n    UNION ALL SELECT 'glucose',15,  60  \n    UNION ALL SELECT 'tin',68,  45  \n    UNION ALL SELECT 'banana',27,  60  \n    UNION ALL SELECT 'apple',39,  40  \n    UNION ALL SELECT 'cheese',23,  30  \n    UNION ALL SELECT 'beer',52,  10  \n    UNION ALL SELECT 'suntan cream',11,  70  \n    UNION ALL SELECT 'camera',32,  30  \n    UNION ALL SELECT 'T-shirt',24,  15  \n    UNION ALL SELECT 'trousers',48,  10  \n    UNION ALL SELECT 'umbrella',73,  40  \n    UNION ALL SELECT 'waterproof trousers',42,  70  \n    UNION ALL SELECT 'waterproof overclothes',43,  75  \n    UNION ALL SELECT 'note-case',22,  80  \n    UNION ALL SELECT 'sunglasses',7,  20  \n    UNION ALL SELECT 'towel',18,  12  \n    UNION ALL SELECT 'socks',4,  50  \n    UNION ALL SELECT 'book',30,  10  \n)\nSELECT *\nINTO #KnapsackItems\nFROM KnapsackItems;\n\nWITH UNIQUEnTuples (n, Tuples, ID, [weight], value) AS (\n    SELECT 1, CAST(item AS VARCHAR(8000)), item, [weight], value\n    FROM #KnapsackItems\n    UNION ALL\n    SELECT 1 + n.n, t.item + ',' + n.Tuples, item, n.[weight] + t.[weight], n.value + t.value\n    FROM UNIQUEnTuples n \n    CROSS APPLY (\n        SELECT item, [weight], value \n        FROM #KnapsackItems t \n        WHERE t.item < n.ID AND n.[weight] + t.[weight] < 400) t\n    )\nSELECT TOP 5 *\nFROM UNIQUEnTuples\nORDER BY value DESC, n, Tuples;\n\nGO\nDROP TABLE #KnapsackItems;\n\n\nOutput:\nweight  value  Solution\n396     1030   banana,compass,glucose,map,note-case,sandwich,socks,sunglasses,suntan cream,water,waterproof overclothes,waterproof trousers\n389     1010   banana,compass,glucose,map,note-case,sandwich,socks,suntan cream,water,waterproof overclothes,waterproof trousers\n399     1005   banana,cheese,glucose,map,note-case,sandwich,socks,suntan cream,water,waterproof overclothes,waterproof trousers\n395     1002   banana,cheese,compass,glucose,map,note-case,sandwich,socks,sunglasses,suntan cream,towel,water,waterproof overclothes\n393     1000   apple,banana,compass,glucose,map,note-case,sandwich,socks,sunglasses,suntan cream,water,waterproof overclothes\n\n", "explain": "A brute force solution that runs in SQL Server 2005 or later using a recursive CTE.\nDisplays the top 5 solutions and runs in about 39 seconds.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "PHP", "code": "\n#########################################################\n# 0-1 Knapsack Problem Solve with memoization optimize and index returns\n# $w = weight of item\n# $v = value of item\n# $i = index\n# $aW = Available Weight\n# $m = Memo items array\n# PHP Translation from Python, Memoization,\n# and index return functionality added by Brian Berneker\n#\n#########################################################\n\nfunction knapSolveFast2($w, $v, $i, $aW, &$m) {\n\n\tglobal $numcalls;\n\t$numcalls ++;\n\t// echo \"Called with i=$i, aW=$aW<br>\";\n\n\t// Return memo if we have one\n\tif (isset($m[$i][$aW])) {\n\t\treturn array( $m[$i][$aW], $m['picked'][$i][$aW] );\n\t} else {\n\n\t\t// At end of decision branch\n\t\tif ($i == 0) {\n\t\t\tif ($w[$i] <= $aW) { // Will this item fit?\n\t\t\t\t$m[$i][$aW] = $v[$i]; // Memo this item\n\t\t\t\t$m['picked'][$i][$aW] = array($i); // and the picked item\n\t\t\t\treturn array($v[$i],array($i)); // Return the value of this item and add it to the picked list\n\n\t\t\t} else {\n\t\t\t\t// Won't fit\n\t\t\t\t$m[$i][$aW] = 0; // Memo zero\n\t\t\t\t$m['picked'][$i][$aW] = array(); // and a blank array entry...\n\t\t\t\treturn array(0,array()); // Return nothing\n\t\t\t}\n\t\t}\t\n\t\n\t\t// Not at end of decision branch..\n\t\t// Get the result of the next branch (without this one)\n\t\tlist ($without_i, $without_PI) = knapSolveFast2($w, $v, $i-1, $aW, $m);\n\n\t\tif ($w[$i] > $aW) { // Does it return too many?\n\t\t\t\n\t\t\t$m[$i][$aW] = $without_i; // Memo without including this one\n\t\t\t$m['picked'][$i][$aW] = $without_PI; // and a blank array entry...\n\t\t\treturn array($without_i, $without_PI); // and return it\n\n\t\t} else {\n\t\t\n\t\t\t// Get the result of the next branch (WITH this one picked, so available weight is reduced)\n\t\t\tlist ($with_i,$with_PI) = knapSolveFast2($w, $v, ($i-1), ($aW - $w[$i]), $m);\n\t\t\t$with_i += $v[$i];  // ..and add the value of this one..\n\t\t\t\n\t\t\t// Get the greater of WITH or WITHOUT\n\t\t\tif ($with_i > $without_i) {\n\t\t\t\t$res = $with_i;\n\t\t\t\t$picked = $with_PI;\n\t\t\t\tarray_push($picked,$i);\n\t\t\t} else {\n\t\t\t\t$res = $without_i;\n\t\t\t\t$picked = $without_PI;\n\t\t\t}\n\t\t\t\t\t\t\n\t\t\t$m[$i][$aW] = $res; // Store it in the memo\n\t\t\t$m['picked'][$i][$aW] = $picked; // and store the picked item\n\t\t\treturn array ($res,$picked); // and then return it\n\t\t}\t\n\t}\n}\n\n\n\n$items4 = array(\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"tin\",\"banana\",\"apple\",\"cheese\",\"beer\",\"suntan cream\",\"camera\",\"t-shirt\",\"trousers\",\"umbrella\",\"waterproof trousers\",\"waterproof overclothes\",\"note-case\",\"sunglasses\",\"towel\",\"socks\",\"book\");\n$w4 = array(9,13,153,50,15,68,27,39,23,52,11,32,24,48,73,42,43,22,7,18,4,30);\n$v4 = array(150,35,200,160,60,45,60,40,30,10,70,30,15,10,40,70,75,80,20,12,50,10);\n\n## Initialize\n$numcalls = 0; $m = array(); $pickedItems = array();\n\n## Solve\nlist ($m4,$pickedItems) = knapSolveFast2($w4, $v4, sizeof($v4) -1, 400, $m);\n\n# Display Result \necho \"<b>Items:</b><br>\".join(\", \",$items4).\"<br>\";\necho \"<b>Max Value Found:</b><br>$m4 (in $numcalls calls)<br>\";\necho \"<b>Array Indices:</b><br>\".join(\",\",$pickedItems).\"<br>\";\n\n\necho \"<b>Chosen Items:</b><br>\";\necho \"<table border cellspacing=0>\";\necho \"<tr><td>Item</td><td>Value</td><td>Weight</td></tr>\";\n$totalVal = $totalWt = 0;\nforeach($pickedItems as $key) {\n\t$totalVal += $v4[$key];\n\t$totalWt += $w4[$key];\n\techo \"<tr><td>\".$items4[$key].\"</td><td>\".$v4[$key].\"</td><td>\".$w4[$key].\"</td></tr>\";\n}\necho \"<tr><td align=right><b>Totals</b></td><td>$totalVal</td><td>$totalWt</td></tr>\";\necho \"</table><hr>\";\n\n\nOutput:\n\nItems:map, compass, water, sandwich, glucose, tin, banana, apple, cheese, beer, suntan cream, camera, t-shirt, trousers, umbrella, waterproof trousers, waterproof overclothes, note-case, sunglasses, towel, socks, bookMax Value Found:1030 (in 8725 calls)Array Indices:0,1,2,3,4,6,10,15,16,17,18,20Chosen Items:ItemValueWeightmap1509compass3513water200153sandwich16050glucose6015banana6027suntan cream7011waterproof trousers7042waterproof overclothes7543note-case8022sunglasses207socks504Totals1030396\n\n\n#########################################################\n# 0-1 Knapsack Problem Solve\n# $w = weight of item\n# $v = value of item\n# $i = index\n# $aW = Available Weight\n# PHP Translation by Brian Berneker\n#########################################################\n\nfunction knapSolve($w,$v,$i,$aW) {\n\n\tglobal $numcalls;\n\t$numcalls ++;\n\t// echo \"Called with i=$i, aW=$aW<br>\";\n\n\tif ($i == 0) {\n\t\tif ($w[$i] <= $aW) {\n\t\t\treturn $v[$i];\n\t\t} else {\n\t\t\treturn 0;\n\t\t}\n\t}\t\n\t\n\t$without_i = knapSolve($w, $v, $i-1, $aW);\n\tif ($w[$i] > $aW) { \n\t\treturn $without_i;\n\t} else {\n\t\t$with_i = $v[$i] + knapSolve($w, $v, ($i-1), ($aW - $w[$i]));\n\t\treturn max($with_i, $without_i);\n\t}\t\n\n}\n\n\n#########################################################\n# 0-1 Knapsack Problem Solve (with \"memo\"-ization optimization)\n# $w = weight of item\n# $v = value of item\n# $i = index\n# $aW = Available Weight\n# $m = 'memo' array\n# PHP Translation by Brian Berneker\n#########################################################\n\nfunction knapSolveFast($w,$v,$i,$aW,&$m) { // Note: We use &$m because the function writes to the $m array \n\n\tglobal $numcalls;\n\t$numcalls ++;\n\t// echo \"Called with i=$i, aW=$aW<br>\";\n\n\t// Return memo if we have one\n\tif (isset($m[$i][$aW])) {\n\t\treturn $m[$i][$aW];\n\t} else {\n\n\t\tif ($i == 0) {\n\t\t\tif ($w[$i] <= $aW) {\n\t\t\t\t$m[$i][$aW] = $v[$i]; // save memo\n\t\t\t\treturn $v[$i];\n\t\t\t} else {\n\t\t\t\t$m[$i][$aW] = 0; // save memo\n\t\t\t\treturn 0;\n\t\t\t}\n\t\t}\t\n\t\n\t\t$without_i = knapSolveFast($w, $v, $i-1, $aW,$m);\n\t\tif ($w[$i] > $aW) {\n\t\t\t$m[$i][$aW] = $without_i; // save memo\n\t\t\treturn $without_i;\n\t\t} else {\n\t\t\t$with_i = $v[$i] + knapSolveFast($w, $v, ($i-1), ($aW - $w[$i]),$m);\n\t\t\t$res = max($with_i, $without_i); \n\t\t\t$m[$i][$aW] = $res; // save memo\n\t\t\treturn $res;\n\t\t}\t\n\t}\n}\n\n\n$w3 = array(1, 1, 1, 2, 2, 2, 4, 4, 4, 44, 96, 96, 96);\n$v3 = array(1, 1, 1, 2, 2, 2, 4, 4, 4, 44, 96, 96, 96);\n\n$numcalls = 0;\n$m = array();\n$m3 = knapSolveFast($w3, $v3, sizeof($v3) -1, 54,$m);\nprint_r($w3); echo \"<br>FAST: \";\necho \"<b>Max: $m3</b> ($numcalls calls)<br><br>\";\n\n\n$numcalls = 0;\n$m = array();\n$m3 = knapSolve($w3, $v3, sizeof($v3) -1, 54 );\nprint_r($w3); echo \"<br>\";\necho \"<b>Max: $m3</b> ($numcalls calls)<br><br>\";\n\n\nOutput:\nArray ( [0] => 1 [1] => 1 [2] => 1 [3] => 2 [4] => 2 [5] => 2 [6] => 4 [7] => 4 [8] => 4 [9] => 44 [10] => 96 [11] => 96 [12] => 96 ) \nFAST: Max: 54 (191 calls)\n\nArray ( [0] => 1 [1] => 1 [2] => 1 [3] => 2 [4] => 2 [5] => 2 [6] => 4 [7] => 4 [8] => 4 [9] => 44 [10] => 96 [11] => 96 [12] => 96 ) \nMax: 54 (828 calls)\n\n", "explain": "Minimal PHP Algorithm for totals only translated from Python version as discussed in the YouTube posted video at: http://www.youtube.com/watch?v=ZKBUu_ahSR4\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\ntype item struct {\n    string\n    w, v int\n}\n\nvar wants = []item{\n    {\"map\", 9, 150},\n    {\"compass\", 13, 35},\n    {\"water\", 153, 200},\n    {\"sandwich\", 50, 160},\n    {\"glucose\", 15, 60},\n    {\"tin\", 68, 45},\n    {\"banana\", 27, 60},\n    {\"apple\", 39, 40},\n    {\"cheese\", 23, 30},\n    {\"beer\", 52, 10},\n    {\"suntan cream\", 11, 70},\n    {\"camera\", 32, 30},\n    {\"T-shirt\", 24, 15},\n    {\"trousers\", 48, 10},\n    {\"umbrella\", 73, 40},\n    {\"waterproof trousers\", 42, 70},\n    {\"waterproof overclothes\", 43, 75},\n    {\"note-case\", 22, 80},\n    {\"sunglasses\", 7, 20},\n    {\"towel\", 18, 12},\n    {\"socks\", 4, 50},\n    {\"book\", 30, 10},\n}\n\nconst maxWt = 400\n\nfunc main() {\n    items, w, v := m(len(wants)-1, maxWt)\n    fmt.Println(items)\n    fmt.Println(\"weight:\", w)\n    fmt.Println(\"value:\", v)\n}\n\nfunc m(i, w int) ([]string, int, int) {\n    if i < 0 || w == 0 {\n        return nil, 0, 0\n    } else if wants[i].w > w {\n        return m(i-1, w)\n    }\n    i0, w0, v0 := m(i-1, w)\n    i1, w1, v1 := m(i-1, w-wants[i].w)\n    v1 += wants[i].v\n    if v1 > v0 {\n        return append(i1, wants[i].string), w1 + wants[i].w, v1\n    }\n    return i0, w0, v0\n}\n\n\nOutput:\n[map compass water sandwich glucose banana suntan cream waterproof trousers waterproof overclothes note-case sunglasses socks]\nweight: 396\nvalue: 1030\n\n\nvar wants = []item{\n    {\"sunscreen\", 15, 2},\n    {\"GPS\", 25, 2},\n    {\"beer\", 35, 3},\n}\n\nconst maxWt = 40\n\n\nOutput:\n[sunscreen GPS]\nweight: 40\nvalue: 4\n\n", "explain": "From WP, \"0-1 knapsack problem\" under The Knapsack Problem, although the solution here simply follows the recursive defintion and doesn't even use the array optimization.\nAlternative test case\nData for which a greedy algorithm might give an incorrect result:\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: SysUtils,StdCtrls\n\n{Item to store data in}\n\ntype TPackItem = record\n Name: string;\n Weight,Value: integer;\n end;\n\n{List of items, weights and values}\n\nconst ItemsList: array [0..21] of TPackItem = (\n   (Name: 'map'; Weight: 9; Value: 150),\n   (Name: 'compass'; Weight: 13; Value: 35),\n   (Name: 'water'; Weight: 153; Value: 200),\n   (Name: 'sandwich'; Weight: 50; Value: 160),\n   (Name: 'glucose'; Weight: 15; Value: 60),\n   (Name: 'tin'; Weight: 68; Value: 45),\n   (Name: 'banana'; Weight: 27; Value: 60),\n   (Name: 'apple'; Weight: 39; Value: 40),\n   (Name: 'cheese'; Weight: 23; Value: 30),\n   (Name: 'beer'; Weight: 52; Value: 10),\n   (Name: 'suntan cream'; Weight: 11; Value: 70),\n   (Name: 'camera'; Weight: 32; Value: 30),\n   (Name: 't-shirt'; Weight: 24; Value: 15),\n   (Name: 'trousers'; Weight: 48; Value: 10),\n   (Name: 'umbrella'; Weight: 73; Value: 40),\n   (Name: 'waterproof trousers'; Weight: 42; Value: 70),\n   (Name: 'waterproof overclothes'; Weight: 43; Value: 75),\n   (Name: 'note-case'; Weight: 22; Value: 80),\n   (Name: 'sunglasses'; Weight: 7; Value: 20),\n   (Name: 'towel'; Weight: 18; Value: 12),\n   (Name: 'socks'; Weight: 4; Value: 50),\n   (Name: 'book'; Weight: 30; Value: 10));\n\n{Iterater object to step through all the indices\n{ corresponding to the bits in \"N\". This is used }\n{ step through all the combinations of items }\n\ntype TBitIterator = class(TObject)\n private\n   FNumber,FIndex: integer;\n public\n  procedure Start(StartNumber: integer);\n  function Next(var Index: integer): boolean;\n end;\n\nprocedure TBitIterator.Start(StartNumber: integer);\n{Set the starting value of the number }\nbegin\nFNumber:=StartNumber;\nend;\n\n\nfunction TBitIterator.Next(var Index: integer): boolean;\n{Return the next available index}\nbegin\nResult:=False;\nwhile FNumber>0 do\n\tbegin\n\tResult:=(FNumber and 1)=1;\n\tif Result then Index:=FIndex;\n\tFNumber:=FNumber shr 1;\n\tInc(FIndex);\n\tif Result then break;\n\tend;\nend;\n\n{=============================================================================}\n\n\nprocedure GetSums(N: integer; var Weight,Value: integer);\n{Iterate through all indices corresponding to N}\n{Get get the sum of their values}\nvar Inx: integer;\nvar BI: TBitIterator;\nbegin\nBI:=TBitIterator.Create;\ntry\nBI.Start(N);\nWeight:=0; Value:=0;\nwhile BI.Next(Inx) do\n\tbegin\n\tWeight:=Weight+ItemsList[Inx].Weight;\n\tValue:=Value+ItemsList[Inx].Value;\n\tend;\nfinally BI.Free; end;\nend;\n\n\n\nprocedure DoKnapsackProblem(Memo: TMemo);\n{Find optimized solution to Knapsack problem}\n{By iterating through all binary combinations}\nvar I,J,Inx: integer;\nvar Max: integer;\nvar WeightSum,ValueSum: integer;\nvar BestValue,BestIndex,BestWeight: integer;\nvar S: string;\nvar BI: TBitIterator;\nbegin\nBI:=TBitIterator.Create;\ntry\n{Get value that will cover all binary combinations}\nMax:=1 shl Length(ItemsList)-1;\nBestValue:=0;\n{Iterate through all combinations of bits}\nfor I:=1 to Max do\n\tbegin\n\t{Get the sum of the weights and values}\n\tGetSums(I,WeightSum,ValueSum);\n\t{Ignore any weight greater than 400}\n\tif WeightSum>400 then continue;\n\t{Test if this is the best value so far}\n\tif ValueSum>BestValue then\n\t\tbegin\n\t\tBestValue:=ValueSum;\n\t\tBestWeight:=WeightSum;\n\t\tBestIndex:=I;\n\t\tend;\n\tend;\n{Display the best result}\nMemo.Lines.Add('  Item                    Weight  Value');\nMemo.Lines.Add('---------------------------------------');\nBI.Start(BestIndex);\nwhile BI.Next(Inx) do\n\tbegin\n\tS:='  '+Format('%-25s',[ItemsList[Inx].Name]);\n\tS:=S+Format('%5d',[ItemsList[Inx].Weight]);\n\tS:=S+Format('%7d',[ItemsList[Inx].Value]);\n\tMemo.Lines.Add(S);\n\tend;\nMemo.Lines.Add('---------------------------------------');\nMemo.Lines.Add(Format('Total                     %6d %6d',[BestWeight,BestValue]));\nMemo.Lines.Add('Best Inx: '+IntToStr(BestIndex));\nMemo.Lines.Add('Best Value: '+IntToStr(BestValue));\nMemo.Lines.Add('Best Weight: '+IntToStr(BestWeight));\nfinally BI.Free; end;\nend;\n\n\nOutput:\n  Item                    Weight  Value\n---------------------------------------\n  map                          9    150\n  compass                     13     35\n  water                      153    200\n  sandwich                    50    160\n  glucose                     15     60\n  banana                      27     60\n  suntan cream                11     70\n  waterproof trousers         42     70\n  waterproof overclothes      43     75\n  note-case                   22     80\n  sunglasses                   7     20\n  socks                        4     50\n---------------------------------------\nTotal                        396   1030\nBest Inx: 1541215\nBest Value: 1030\nBest Weight: 396\n\n", "explain": "This is a good example of using an iterator. The problem involves looking at all different compinations of items in the list. If you increment a number up to a certain maximum, you systematically set all combination of bits in that number. The trick is turning the pattern of bits in a number into indices into the packing list. The iterater handles that and so it can be used in multiple places in the code to step through various the combinations of items in the list.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Ruby", "code": "\nBrute force[edit]\nKnapsackItem = Struct.new(:name, :weight, :value)\npotential_items = [\n  KnapsackItem['map', 9, 150],              KnapsackItem['compass', 13, 35],\n  KnapsackItem['water', 153, 200],          KnapsackItem['sandwich', 50, 160],\n  KnapsackItem['glucose', 15, 60],          KnapsackItem['tin', 68, 45],\n  KnapsackItem['banana', 27, 60],           KnapsackItem['apple', 39, 40],\n  KnapsackItem['cheese', 23, 30],           KnapsackItem['beer', 52, 10],\n  KnapsackItem['suntan cream', 11, 70],     KnapsackItem['camera', 32, 30],\n  KnapsackItem['t-shirt', 24, 15],          KnapsackItem['trousers', 48, 10],\n  KnapsackItem['umbrella', 73, 40],         KnapsackItem['waterproof trousers', 42, 70],\n  KnapsackItem['waterproof overclothes', 43, 75], KnapsackItem['note-case', 22, 80],\n  KnapsackItem['sunglasses', 7, 20],        KnapsackItem['towel', 18, 12],\n  KnapsackItem['socks', 4, 50],             KnapsackItem['book', 30, 10],\n]\nknapsack_capacity = 400\n\nclass Array\n  # do something for each element of the array's power set\n  def power_set\n    yield [] if block_given?\n    self.inject([[]]) do |ps, elem|\n      ps.each_with_object([]) do |i,r|\n        r << i\n        new_subset = i + [elem]\n        yield new_subset if block_given?\n        r << new_subset\n      end\n    end\n  end\nend\n\nmaxval, solutions = potential_items.power_set.group_by {|subset|\n  weight = subset.inject(0) {|w, elem| w + elem.weight}\n  weight>knapsack_capacity ? 0 : subset.inject(0){|v, elem| v + elem.value}\n}.max\n\nputs \"value: #{maxval}\"\nsolutions.each do |set|\n  wt, items = 0, []\n  set.each {|elem| wt += elem.weight; items << elem.name}\n  puts \"weight: #{wt}\"\n  puts \"items: #{items.join(',')}\"\nend\n\n\nOutput:\nvalue: 1030\nweight: 396\nitems: map,compass,water,sandwich,glucose,banana,suntan cream,waterproof trousers,waterproof overclothes,note-case,sunglasses,socks\n\nDynamic Programming[edit]\n\nKnapsackItem = Struct.new(:name, :weight, :value)\n\ndef dynamic_programming_knapsack(items, max_weight)\n  num_items = items.size\n  cost_matrix = Array.new(num_items){Array.new(max_weight+1, 0)}\n  \n  num_items.times do |i|\n    (max_weight + 1).times do |j|\n      if(items[i].weight > j)\n        cost_matrix[i][j] = cost_matrix[i-1][j]\n      else\n        cost_matrix[i][j] = [cost_matrix[i-1][j], items[i].value + cost_matrix[i-1][j-items[i].weight]].max\n      end\n    end\n  end\n  used_items = get_used_items(items, cost_matrix)\n  [get_list_of_used_items_names(items, used_items),                     # used items names\n   items.zip(used_items).map{|item,used| item.weight*used}.inject(:+),  # total weight\n   cost_matrix.last.last]                                               # total value\nend\n\ndef get_used_items(items, cost_matrix)\n  i = cost_matrix.size - 1\n  currentCost = cost_matrix[0].size - 1\n  marked = cost_matrix.map{0}\n  \n  while(i >= 0 && currentCost >= 0)\n    if(i == 0 && cost_matrix[i][currentCost] > 0 ) || (cost_matrix[i][currentCost] != cost_matrix[i-1][currentCost])\n      marked[i] = 1\n      currentCost -= items[i].weight\n    end\n    i -= 1\n  end\n  marked\nend\n\ndef get_list_of_used_items_names(items, used_items)\n  items.zip(used_items).map{|item,used| item.name if used>0}.compact.join(', ')\nend\n\nif $0 == __FILE__\n  items = [\n    KnapsackItem['map'                   ,   9, 150], KnapsackItem['compass'            , 13,  35],\n    KnapsackItem['water'                 , 153, 200], KnapsackItem['sandwich'           , 50, 160],\n    KnapsackItem['glucose'               ,  15,  60], KnapsackItem['tin'                , 68,  45],\n    KnapsackItem['banana'                ,  27,  60], KnapsackItem['apple'              , 39,  40],\n    KnapsackItem['cheese'                ,  23,  30], KnapsackItem['beer'               , 52,  10],\n    KnapsackItem['suntan cream'          ,  11,  70], KnapsackItem['camera'             , 32,  30],\n    KnapsackItem['t-shirt'               ,  24,  15], KnapsackItem['trousers'           , 48,  10],\n    KnapsackItem['umbrella'              ,  73,  40], KnapsackItem['waterproof trousers', 42,  70],\n    KnapsackItem['waterproof overclothes',  43,  75], KnapsackItem['note-case'          , 22,  80],\n    KnapsackItem['sunglasses'            ,   7,  20], KnapsackItem['towel'              , 18,  12],\n    KnapsackItem['socks'                 ,   4,  50], KnapsackItem['book'               , 30,  10]\n  ]\n  \n  names, weight, value = dynamic_programming_knapsack(items, 400)\n  puts\n  puts 'Dynamic Programming:'\n  puts\n  puts \"Found solution: #{names}\"\n  puts \"total weight: #{weight}\"\n  puts \"total value: #{value}\"\nend\n\n\nOutput:\nDynamic Programming:\n\nFound solution: map, compass, water, sandwich, glucose, banana, suntan cream, waterproof trousers, waterproof overclothes, note-case, sunglasses, socks\ntotal weight: 396\ntotal value: 1030\n\n", "explain": "Translated from http://sites.google.com/site/mikescoderama/Home/0-1-knapsack-problem-in-p\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Rust", "code": "\n\nuse std::cmp;\n\nstruct Item {\n    name: &'static str,\n    weight: usize,\n    value: usize\n}\n\nfn knapsack01_dyn(items: &[Item], max_weight: usize) -> Vec<&Item> {\n    let mut best_value = vec![vec![0; max_weight + 1]; items.len() + 1];\n    for (i, it) in items.iter().enumerate() {\n        for w in 1 .. max_weight + 1 {\n            best_value[i + 1][w] =\n                if it.weight > w {\n                    best_value[i][w]\n                } else {\n                    cmp::max(best_value[i][w], best_value[i][w - it.weight] + it.value)\n                }\n        }\n    }\n\n    let mut result = Vec::with_capacity(items.len());\n    let mut left_weight = max_weight;\n\n    for (i, it) in items.iter().enumerate().rev() {\n        if best_value[i + 1][left_weight] != best_value[i][left_weight] {\n            result.push(it);\n            left_weight -= it.weight;\n        }\n    }\n\n    result\n}\n\n\nfn main () {\n    const MAX_WEIGHT: usize = 400;\n\n    const ITEMS: &[Item] = &[\n        Item { name: \"map\",                    weight: 9,   value: 150 },\n        Item { name: \"compass\",                weight: 13,  value: 35 },\n        Item { name: \"water\",                  weight: 153, value: 200 },\n        Item { name: \"sandwich\",               weight: 50,  value: 160 },\n        Item { name: \"glucose\",                weight: 15,  value: 60 },\n        Item { name: \"tin\",                    weight: 68,  value: 45 },\n        Item { name: \"banana\",                 weight: 27,  value: 60 },\n        Item { name: \"apple\",                  weight: 39,  value: 40 },\n        Item { name: \"cheese\",                 weight: 23,  value: 30 },\n        Item { name: \"beer\",                   weight: 52,  value: 10 },\n        Item { name: \"suntancream\",            weight: 11,  value: 70 },\n        Item { name: \"camera\",                 weight: 32,  value: 30 },\n        Item { name: \"T-shirt\",                weight: 24,  value: 15 },\n        Item { name: \"trousers\",               weight: 48,  value: 10 },\n        Item { name: \"umbrella\",               weight: 73,  value: 40 },\n        Item { name: \"waterproof trousers\",    weight: 42,  value: 70 },\n        Item { name: \"waterproof overclothes\", weight: 43,  value: 75 },\n        Item { name: \"note-case\",              weight: 22,  value: 80 },\n        Item { name: \"sunglasses\",             weight: 7,   value: 20 },\n        Item { name: \"towel\",                  weight: 18,  value: 12 },\n        Item { name: \"socks\",                  weight: 4,   value: 50 },\n        Item { name: \"book\",                   weight: 30,  value: 10 }\n    ];\n\n    let items = knapsack01_dyn(ITEMS, MAX_WEIGHT);\n\n    // We reverse the order because we solved the problem backward.\n    for it in items.iter().rev() {\n        println!(\"{}\", it.name);\n    }\n\n    println!(\"Total weight: {}\", items.iter().map(|w| w.weight).sum::<usize>());\n    println!(\"Total value: {}\", items.iter().map(|w| w.value).sum::<usize>());\n}\n\n\nOutput:\nmap\ncompass\nwater\nsandwich\nglucose\nbanana\nsuntancream\nwaterproof trousers\nwaterproof overclothes\nnote-case\nsunglasses\nsocks\nTotal weight: 396\nTotal value: 1030\n", "explain": "Dynamic Programming solution.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Swift", "code": "\nTranslation of: Python\nDynamic Programming[edit]\nstruct KnapsackItem {\n  var name: String\n  var weight: Int\n  var value: Int\n}\n\nfunc knapsack(items: [KnapsackItem], limit: Int) -> [KnapsackItem] {\n  var table = Array(repeating: Array(repeating: 0, count: limit + 1), count: items.count + 1)\n  \n  for j in 1..<items.count+1 {\n    let item = items[j-1]\n    \n    for w in 1..<limit+1 {\n      if item.weight > w {\n        table[j][w] = table[j-1][w]\n      } else {\n        table[j][w] = max(table[j-1][w], table[j-1][w-item.weight] + item.value)\n      }\n    }\n  }\n  \n  var result = [KnapsackItem]()\n  var w = limit\n  \n  for j in stride(from: items.count, to: 0, by: -1) where table[j][w]\u00a0!= table[j-1][w] {\n    let item = items[j-1]\n    \n    result.append(item)\n    \n    w -= item.weight\n  }\n  \n  return result\n}\n\nlet items = [\n  KnapsackItem(name: \"map\", weight: 9, value: 150), KnapsackItem(name: \"compass\", weight: 13, value: 35),\n  KnapsackItem(name: \"water\", weight: 153, value: 200), KnapsackItem(name: \"sandwich\", weight: 50, value: 160),\n  KnapsackItem(name: \"glucose\", weight: 15, value: 60), KnapsackItem(name: \"tin\", weight: 68, value: 45),\n  KnapsackItem(name: \"banana\", weight: 27, value: 60), KnapsackItem(name: \"apple\", weight: 39, value: 40),\n  KnapsackItem(name: \"cheese\", weight: 23, value: 30), KnapsackItem(name: \"beer\", weight: 52, value: 10),\n  KnapsackItem(name: \"suntan cream\", weight: 11, value: 70), KnapsackItem(name: \"camera\", weight: 32, value: 30),\n  KnapsackItem(name: \"t-shirt\", weight: 24, value: 15), KnapsackItem(name: \"trousers\", weight: 48, value: 10),\n  KnapsackItem(name: \"umbrella\", weight: 73, value: 40), KnapsackItem(name: \"waterproof trousers\", weight: 42, value: 70),\n  KnapsackItem(name: \"waterproof overclothes\", weight: 43, value: 75), KnapsackItem(name: \"note-case\", weight: 22, value: 80),\n  KnapsackItem(name: \"sunglasses\", weight: 7, value: 20), KnapsackItem(name: \"towel\", weight: 18, value: 12),\n  KnapsackItem(name: \"socks\", weight: 4, value: 50), KnapsackItem(name: \"book\", weight: 30, value: 10)\n]\n\nlet kept = knapsack(items: items, limit: 400)\n\nprint(\"Kept: \")\n\nfor item in kept {\n  print(\"  \\(item.name)\")\n}\n\nlet (tValue, tWeight) = kept.reduce((0, 0), { ($0.0 + $1.value, $0.1 + $1.weight) })\n\nprint(\"For a total value of \\(tValue) and a total weight of \\(tWeight)\")\n\nOutput:\nKept: \n  socks\n  sunglasses\n  note-case\n  waterproof overclothes\n  waterproof trousers\n  suntan cream\n  banana\n  glucose\n  sandwich\n  water\n  compass\n  map\nFor a total value of 1030 and a total weight of 396\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "R", "code": "\nFull_Data<-structure(list(item = c(\"map\", \"compass\", \"water\", \"sandwich\", \n\"glucose\", \"tin\", \"banana\", \"apple\", \"cheese\", \"beer\", \"suntan_cream\", \n\"camera\", \"T-shirt\", \"trousers\", \"umbrella\", \"waterproof_trousers\", \n\"waterproof_overclothes\", \"note-case\", \"sunglasses\", \"towel\", \n\"socks\", \"book\"), weigth = c(9, 13, 153, 50, 15, 68, 27, 39, \n23, 52, 11, 32, 24, 48, 73, 42, 43, 22, 7, 18, 4, 30), value = c(150, \n35, 200, 160, 60, 45, 60, 40, 30, 10, 70, 30, 15, 10, 40, 70, \n75, 80, 20, 12, 50, 10)), .Names = c(\"item\", \"weigth\", \"value\"\n), row.names = c(NA, 22L), class = \"data.frame\")\n\n\nBounded_knapsack<-function(Data,W)\n{\n\tK<-matrix(NA,nrow=W+1,ncol=dim(Data)[1]+1)\n\t0->K[1,]->K[,1]\n\tmatrix_item<-matrix('',nrow=W+1,ncol=dim(Data)[1]+1)\n\tfor(j in 1:dim(Data)[1])\n\t{\n\t\tfor(w in 1:W)\n\t\t{\n\t\t\twj<-Data$weigth[j]\n\t\t\titem<-Data$item[j]\n\t\t\tvalue<-Data$value[j]\n\t\t\tif( wj > w )\n\t\t\t{\n\t\t\t\tK[w+1,j+1]<-K[w+1,j]\n\t\t\t\tmatrix_item[w+1,j+1]<-matrix_item[w+1,j]\n\t\t\t}\n\t\t\telse\n\t\t\t{\n\t\t\t\tif( K[w+1,j] >= K[w+1-wj,j]+value )\n\t\t\t\t{\n\t\t\t\t\tK[w+1,j+1]<-K[w+1,j]\n\t\t\t\t\tmatrix_item[w+1,j+1]<-matrix_item[w+1,j]\t\t\t\t\t\n\t\t\t\t}\n\t\t\t\telse\n\t\t\t\t{\n\t\t\t\t\tK[w+1,j+1]<-K[w+1-wj,j]+value\n\t\t\t\t\tmatrix_item[w+1,j+1]<-item\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\nreturn(list(K=K,Item=matrix_item))\n}\n\nbacktracking<-function(knapsack, Data)\n{\n\tW<-dim(knapsack$K)[1]\n\titens<-c()\n\tcol<-dim(knapsack$K)[2]\n\tselected_item<-knapsack$Item[W,col]\n\twhile(selected_item!='')\n\t{\n\t\tselected_item<-knapsack$Item[W,col]\n\t\tif(selected_item!='')\n\t\t{\n\t\t\tselected_item_value<-Data[Data$item == selected_item,]\n\t\t\tif(-knapsack$K[W - selected_item_value$weigth,col-1]+knapsack$K[W,col]==selected_item_value$value)\n\t\t\t{\n\t\t\t\tW <- W - selected_item_value$weigth\n\t\t\t\titens<-c(itens,selected_item)\n\t\t\t}\n\t\t\tcol <- col - 1\n\t\t}\n\t}\nreturn(itens)\n}\n\nprint_output<-function(Data,W)\n{\n\tBounded_knapsack(Data,W)->Knap\n\tbacktracking(Knap, Data)->Items\n\toutput<-paste('You must carry:', paste(Items, sep = ', '), sep=' ' )\n\treturn(output)\n}\n\nprint_output(Full_Data, 400)\n\n\nOutput:\n [1] \"You must carry: socks\"                 \n [2] \"You must carry: sunglasses\"            \n [3] \"You must carry: note-case\"             \n [4] \"You must carry: waterproof_overclothes\"\n [5] \"You must carry: waterproof_trousers\"   \n [6] \"You must carry: suntan_cream\"          \n [7] \"You must carry: banana\"                \n [8] \"You must carry: glucose\"               \n [9] \"You must carry: sandwich\"              \n[10] \"You must carry: water\"                 \n[11] \"You must carry: compass\"               \n[12] \"You must carry: map\"\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Visual_Basic", "code": "\nWorks with: Visual Basic version VB6 Standard\n'Knapsack problem/0-1 - 12/02/2017\nOption Explicit\nConst maxWeight = 400\nDim DataList As Variant\nDim xList(64, 3) As Variant\nDim nItems As Integer\nDim s  As String, xss As String\nDim xwei As Integer, xval As Integer, nn As Integer\n\nPrivate Sub Form_Load()\n    Dim i As Integer, j As Integer\n    DataList = Array(\"map\", 9, 150, \"compass\", 13, 35, \"water\", 153, 200, \"sandwich\", 50, 160, _\n           \"glucose\", 15, 60, \"tin\", 68, 45, \"banana\", 27, 60, \"apple\", 39, 40, _\n           \"cheese\", 23, 30, \"beer\", 52, 10, \"suntan cream\", 11, 70, \"camera\", 32, 30, _\n           \"T-shirt\", 24, 15, \"trousers\", 48, 10, \"umbrella\", 73, 40, \"book\", 30, 10, _\n           \"waterproof trousers\", 42, 70, \"waterproof overclothes\", 43, 75, _\n           \"note-case\", 22, 80, \"sunglasses\", 7, 20, \"towel\", 18, 12, \"socks\", 4, 50)\n    nItems = (UBound(DataList) + 1) / 3\n    j = 0\n    For i = 1 To nItems\n        xList(i, 1) = DataList(j)\n        xList(i, 2) = DataList(j + 1)\n        xList(i, 3) = DataList(j + 2)\n        j = j + 3\n    Next i\n    For i = 1 To nItems\n        xListBox.AddItem xList(i, 1)\n    Next i\nEnd Sub\n\nPrivate Sub cmdOK_Click()\n    Dim i As Integer, j As Integer\n    For i = 1 To xListBox.ListCount\n        xListBox.RemoveItem 0\n    Next i\n    s = \"\"\n    For i = 1 To nItems\n        s = s & Chr(i)\n    Next\n    nn = 0\n    Call ChoiceBin(1, \"\")\n    For i = 1 To Len(xss)\n        j = Asc(Mid(xss, i, 1))\n        xListBox.AddItem xList(j, 1)\n    Next i\n    xListBox.AddItem \"*Total* \" & xwei & \" \" & xval\nEnd Sub\n\nPrivate Sub ChoiceBin(n As String, ss As String)\n    Dim r As String\n    Dim i As Integer, j As Integer, iwei As Integer, ival As Integer\n    Dim ipct As Integer\n    If n = Len(s) + 1 Then\n        iwei = 0: ival = 0\n        For i = 1 To Len(ss)\n            j = Asc(Mid(ss, i, 1))\n            iwei = iwei + xList(j, 2)\n            ival = ival + xList(j, 3)\n        Next\n        If iwei <= maxWeight And ival > xval Then\n            xss = ss: xwei = iwei: xval = ival\n        End If\n    Else\n        r = Mid(s, n, 1)\n        Call ChoiceBin(n + 1, ss & r)\n        Call ChoiceBin(n + 1, ss)\n    End If\nEnd Sub 'ChoiceBin\n\nOutput:\nmap\ncompass\nwater\nsandwich\nglucose\nbanana\nsuntan cream\nwaterproof trousers\nwaterproof overclothes\nnote-case\nsunglasses\nsocks\n*Total*  weight=396  val=1030\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Ada", "code": "\nwith Ada.Text_IO;\nwith Ada.Strings.Unbounded;\n\nprocedure Knapsack_01 is\n   package US renames Ada.Strings.Unbounded;\n\n   type Item is record\n      Name   : US.Unbounded_String;\n      Weight : Positive;\n      Value  : Positive;\n      Taken  : Boolean;\n   end record;\n\n   type Item_Array is array (Positive range <>) of Item;\n\n   function Total_Weight (Items : Item_Array; Untaken : Boolean := False) return Natural is\n      Sum : Natural := 0;\n   begin\n      for I in Items'Range loop\n         if Untaken or else Items (I).Taken then\n            Sum := Sum + Items (I).Weight;\n         end if;\n      end loop;\n      return Sum;\n   end Total_Weight;\n\n   function Total_Value (Items : Item_Array; Untaken : Boolean := False) return Natural is\n      Sum : Natural := 0;\n   begin\n      for I in Items'Range loop\n         if Untaken or else Items (I).Taken then\n            Sum := Sum + Items (I).Value;\n         end if;\n      end loop;\n      return Sum;\n   end Total_Value;\n\n   function Max (Left, Right : Natural) return Natural is\n   begin\n      if Right > Left then\n         return Right;\n      else\n         return Left;\n      end if;\n   end Max;\n\n   procedure Solve_Knapsack_01 (Items : in out Item_Array;\n                                Weight_Limit : Positive := 400) is\n      type W_Array is array (0..Items'Length, 0..Weight_Limit) of Natural;\n      W : W_Array := (others => (others => 0));\n   begin\n      -- fill W\n      for I in Items'Range loop\n         for J in 1 .. Weight_Limit loop\n            if Items (I).Weight > J then\n               W (I, J) := W (I - 1, J);\n            else\n               W (I, J) := Max (W (I - 1, J),\n                                W (I - 1, J - Items (I).Weight) + Items (I).Value);\n            end if;\n         end loop;\n      end loop;\n      declare\n         Rest : Natural := Weight_Limit;\n      begin\n         for I in reverse Items'Range loop\n            if W (I, Rest) /= W (I - 1, Rest) then\n               Items (I).Taken := True;\n               Rest := Rest - Items (I).Weight;\n            end if;\n         end loop;\n      end;\n   end Solve_Knapsack_01;\n\n   All_Items : Item_Array :=\n     ( (US.To_Unbounded_String (\"map\"),                      9, 150, False),\n       (US.To_Unbounded_String (\"compass\"),                 13,  35, False),\n       (US.To_Unbounded_String (\"water\"),                  153, 200, False),\n       (US.To_Unbounded_String (\"sandwich\"),                50, 160, False),\n       (US.To_Unbounded_String (\"glucose\"),                 15,  60, False),\n       (US.To_Unbounded_String (\"tin\"),                     68,  45, False),\n       (US.To_Unbounded_String (\"banana\"),                  27,  60, False),\n       (US.To_Unbounded_String (\"apple\"),                   39,  40, False),\n       (US.To_Unbounded_String (\"cheese\"),                  23,  30, False),\n       (US.To_Unbounded_String (\"beer\"),                    52,  10, False),\n       (US.To_Unbounded_String (\"suntan cream\"),            11,  70, False),\n       (US.To_Unbounded_String (\"camera\"),                  32,  30, False),\n       (US.To_Unbounded_String (\"t-shirt\"),                 24,  15, False),\n       (US.To_Unbounded_String (\"trousers\"),                48,  10, False),\n       (US.To_Unbounded_String (\"umbrella\"),                73,  40, False),\n       (US.To_Unbounded_String (\"waterproof trousers\"),     42,  70, False),\n       (US.To_Unbounded_String (\"waterproof overclothes\"),  43,  75, False),\n       (US.To_Unbounded_String (\"note-case\"),               22,  80, False),\n       (US.To_Unbounded_String (\"sunglasses\"),               7,  20, False),\n       (US.To_Unbounded_String (\"towel\"),                   18,  12, False),\n       (US.To_Unbounded_String (\"socks\"),                    4,  50, False),\n       (US.To_Unbounded_String (\"book\"),                    30,  10, False) );\n\nbegin\n   Solve_Knapsack_01 (All_Items, 400);\n   Ada.Text_IO.Put_Line (\"Total Weight: \" & Natural'Image (Total_Weight (All_Items)));\n   Ada.Text_IO.Put_Line (\"Total Value:  \" & Natural'Image (Total_Value  (All_Items)));\n   Ada.Text_IO.Put_Line (\"Items:\");\n   for I in All_Items'Range loop\n      if All_Items (I).Taken then\n         Ada.Text_IO.Put_Line (\"   \" & US.To_String (All_Items (I).Name));\n      end if;\n   end loop;\nend Knapsack_01;\n\n\nOutput:\nTotal Weight:  396\nTotal Value:   1030\nItems:\n   map\n   compass\n   water\n   sandwich\n   glucose\n   banana\n   suntan cream\n   waterproof trousers\n   waterproof overclothes\n   note-case\n   sunglasses\n   socks\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Julia", "code": "\n\nstruct KPDSupply{T<:Integer}\n    item::String\n    weight::T\n    value::T\n    quant::T\nend\n\nKPDSupply{T<:Integer}(itm::AbstractString, w::T, v::T, q::T=one(T)) = KPDSupply(itm, w, v, q)\nBase.show(io::IO, kdps::KPDSupply) = print(io, kdps.quant, \" \", kdps.item, \" ($(kdps.weight) kg, $(kdps.value) \u20ac)\")\n\nusing MathProgBase, Cbc\nfunction solve(gear::Vector{<:KPDSupply}, capacity::Integer)\n    w = getfield.(gear, :weight)\n    v = getfield.(gear, :value)\n    sol = mixintprog(-v, w', '<', capacity, :Bin, 0, 1, CbcSolver())\n    gear[sol.sol .\u2248 1]\nend\n\n\ngear = [KPDSupply(\"map\", 9, 150),\n        KPDSupply(\"compass\", 13, 35),\n        KPDSupply(\"water\", 153, 200),\n        KPDSupply(\"sandwich\", 50, 160),\n        KPDSupply(\"glucose\", 15, 60),\n        KPDSupply(\"tin\", 68, 45),\n        KPDSupply(\"banana\", 27, 60),\n        KPDSupply(\"apple\", 39, 40),\n        KPDSupply(\"cheese\", 23, 30),\n        KPDSupply(\"beer\", 52, 10),\n        KPDSupply(\"suntan cream\", 11, 70),\n        KPDSupply(\"camera\", 32, 30),\n        KPDSupply(\"T-shirt\", 24, 15),\n        KPDSupply(\"trousers\", 48, 10),\n        KPDSupply(\"umbrella\", 73, 40),\n        KPDSupply(\"waterproof trousers\", 42, 70),\n        KPDSupply(\"waterproof overclothes\", 43, 75),\n        KPDSupply(\"note-case\", 22, 80),\n        KPDSupply(\"sunglasses\", 7, 20),\n        KPDSupply(\"towel\", 18, 12),\n        KPDSupply(\"socks\", 4, 50),\n        KPDSupply(\"book\", 30, 10)]\n\npack = solve(gear, 400)\nprintln(\"The hicker should pack: \\n - \", join(pack, \"\\n - \"))\nprintln(\"\\nPacked weight: \", mapreduce(x -> x.weight, +, pack), \" kg\")\nprintln(\"Packed value: \", mapreduce(x -> x.value, +, pack), \" \u20ac\")\n\n\nOutput:\nThe hicker should pack: \n - 1 map (9 kg, 150 \u20ac)\n - 1 compass (13 kg, 35 \u20ac)\n - 1 water (153 kg, 200 \u20ac)\n - 1 sandwich (50 kg, 160 \u20ac)\n - 1 glucose (15 kg, 60 \u20ac)\n - 1 banana (27 kg, 60 \u20ac)\n - 1 suntan cream (11 kg, 70 \u20ac)\n - 1 waterproof trousers (42 kg, 70 \u20ac)\n - 1 waterproof overclothes (43 kg, 75 \u20ac)\n - 1 note-case (22 kg, 80 \u20ac)\n - 1 sunglasses (7 kg, 20 \u20ac)\n - 1 socks (4 kg, 50 \u20ac)\n\nPacked weight: 396 kg\nPacked value: 1030 \u20ac\n", "explain": "This solution uses the MathProgBase package (with the Cbc solver package installed).  It is the mixintprog function from this package that does the heavy lifting of this solution.  \nKPDSupply has one more field than is needed, quant.  This field is may be useful in a solution to the bounded version of this task.\nType and Functions:\nMain:\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "SAS", "code": "\n\n/* create SAS data set */\ndata mydata;\n   input item $1-23 weight value;\n   datalines;\nmap                      9  150\ncompass                 13   35\nwater                  153  200\nsandwich                50  160\nglucose                 15   60\ntin                     68   45\nbanana                  27   60\napple                   39   40\ncheese                  23   30\nbeer                    52   10\nsuntan cream            11   70\ncamera                  32   30\nT-shirt                 24   15\ntrousers                48   10\numbrella                73   40\nwaterproof trousers     42   70\nwaterproof overclothes  43   75\nnote-case               22   80\nsunglasses               7   20\ntowel                   18   12\nsocks                    4   50\nbook                    30   10\n;\n\n/* call OPTMODEL procedure in SAS/OR */\nproc optmodel;\n   /* declare sets and parameters, and read input data */\n   set <str> ITEMS;\n   num weight {ITEMS};\n   num value {ITEMS};\n   read data mydata into ITEMS=[item] weight value;\n\n   /* declare variables, objective, and constraints */\n   var NumSelected {ITEMS} binary;\n   max TotalValue = sum {i in ITEMS} value[i] * NumSelected[i];\n   con WeightCon:\n      sum {i in ITEMS} weight[i] * NumSelected[i] <= 400;\n\n   /* call mixed integer linear programming (MILP) solver */\n   solve;\n\n   /* print optimal solution */\n   print TotalValue;\n   print {i in ITEMS: NumSelected[i].sol > 0.5} NumSelected;\nquit;\n\n\nTotalValue \n1030 \n\n[1] NumSelected \nbanana 1 \ncompass 1 \nglucose 1 \nmap 1 \nnote-case 1 \nsandwich 1 \nsocks 1 \nsunglasses 1 \nsuntan cream 1 \nwater 1 \nwaterproof overclothes 1 \nwaterproof trousers 1 \n\n", "explain": "Use MILP solver in SAS/OR:\nOutput:\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Kotlin", "code": "\nTranslation of: Go\n// version 1.1.2\n\ndata class Item(val name: String, val weight: Int, val value: Int)\n\nval wants = listOf(\n    Item(\"map\", 9, 150),\n    Item(\"compass\", 13, 35),\n    Item(\"water\", 153, 200),\n    Item(\"sandwich\", 50, 160),\n    Item(\"glucose\", 15, 60),\n    Item(\"tin\", 68, 45),\n    Item(\"banana\", 27, 60),\n    Item(\"apple\", 39, 40),\n    Item(\"cheese\", 23, 30),\n    Item(\"beer\", 52, 10),\n    Item(\"suntan cream\", 11, 70),\n    Item(\"camera\", 32, 30),\n    Item(\"T-shirt\", 24, 15),\n    Item(\"trousers\", 48, 10),\n    Item(\"umbrella\", 73, 40),\n    Item(\"waterproof trousers\", 42, 70),\n    Item(\"waterproof overclothes\", 43, 75),\n    Item(\"note-case\", 22, 80),\n    Item(\"sunglasses\", 7, 20),\n    Item(\"towel\", 18, 12),\n    Item(\"socks\", 4, 50),\n    Item(\"book\", 30, 10)\n)\n\nconst val MAX_WEIGHT = 400\n\nfun m(i: Int, w: Int): Triple<MutableList<Item>, Int, Int> {\n    val chosen = mutableListOf<Item>()\n    if (i < 0 || w == 0) return Triple(chosen, 0, 0)\n    else if (wants[i].weight > w) return m(i - 1, w)\n    val (l0, w0, v0) = m(i - 1, w)\n    var (l1, w1, v1) = m(i - 1, w - wants[i].weight)\n    v1 += wants[i].value\n    if (v1 > v0) {\n        l1.add(wants[i])\n        return Triple(l1, w1 + wants[i].weight, v1)\n    }\n    return Triple(l0, w0, v0)\n}\n\nfun main(args: Array<String>) {\n    val (chosenItems, totalWeight, totalValue) = m(wants.size - 1, MAX_WEIGHT)\n    println(\"Knapsack Item Chosen    Weight Value\")\n    println(\"----------------------  ------ -----\")\n    for (item in chosenItems.sortedByDescending { it.value} )\n        println(\"${item.name.padEnd(24)}  ${\"%3d\".format(item.weight)}    ${\"%3d\".format(item.value)}\")\n    println(\"----------------------  ------ -----\")\n    println(\"Total ${chosenItems.size} Items Chosen     $totalWeight   $totalValue\")\n}\n\n\nOutput:\nKnapsack Item Chosen    Weight Value\n----------------------  ------ -----\nwater                     153    200\nsandwich                   50    160\nmap                         9    150\nnote-case                  22     80\nwaterproof overclothes     43     75\nsuntan cream               11     70\nwaterproof trousers        42     70\nglucose                    15     60\nbanana                     27     60\nsocks                       4     50\ncompass                    13     35\nsunglasses                  7     20\n----------------------  ------ -----\nTotal 12 Items Chosen     396   1030\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Perl", "code": "\n\nmy $raw = <<'TABLE';\nmap\t\t\t9\t150\ncompass\t\t\t13\t35\nwater\t\t\t153\t200\nsandwich\t\t50\t160\nglucose\t\t\t15\t60\ntin\t\t\t68\t45\nbanana\t\t\t27\t60\napple\t\t\t39\t40\ncheese\t\t\t23\t30\nbeer\t\t\t52\t10\nsuntancream\t\t11\t70\ncamera\t\t\t32\t30\nT-shirt\t\t\t24\t15\ntrousers\t\t48\t10\numbrella\t\t73\t40\nwaterproof trousers\t42\t70\nwaterproof overclothes\t43\t75\nnote-case\t\t22\t80\nsunglasses\t\t7\t20\ntowel\t\t\t18\t12\nsocks\t\t\t4\t50\nbook\t\t\t30\t10\nTABLE\n\nmy (@name, @weight, @value);\nfor (split \"\\n\", $raw) {\n    for ([ split /\\t+/ ]) {\n        push @name,   $_->[0];\n        push @weight, $_->[1];\n        push @value,  $_->[2];\n    }\n}\n\nmy $max_weight = 400;\nmy @p = map [map undef, 0 .. 1+$max_weight], 0 .. $#name;\n\nsub optimal {\n    my ($i, $w) = @_;\n    return [0, []] if $i < 0;\n    return $p[$i][$w] if $p[$i][$w];\n\n    if ($weight[$i] > $w) {\n        $p[$i][$w] = optimal($i - 1, $w)\n    } else {\n        my $x = optimal($i - 1, $w);\n        my $y = optimal($i - 1, $w - $weight[$i]);\n\n        if ($x->[0] > $y->[0] + $value[$i]) {\n            $p[$i][$w] = $x\n        } else {\n            $p[$i][$w] = [  $y->[0] + $value[$i], [ @{$y->[1]}, $name[$i] ]]\n        }\n    }\n    return $p[$i][$w]\n}\n\nmy $solution = optimal($#name, $max_weight);\nprint \"$solution->[0]: @{$solution->[1]}\\n\";\n\n\nOutput:\n1030: map compass water sandwich glucose banana suntancream waterproof trousers waterproof overclothes note-case sunglasses socks\n", "explain": "The dynamic programming solution from Wikipedia.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Prolog", "code": "\nWorks with: SWI-Prolog\nUsing the clpfd library[edit]\nLibrary: clpfd\n:- use_module(library(clpfd)).\n\nknapsack :-\n        L = [\n             item(map,  9,      150),\n             item(compass,      13,     35),\n             item(water,        153,    200),\n             item(sandwich, 50,         160),\n             item(glucose,      15,     60),\n             item(tin,  68,     45),\n             item(banana,       27,     60),\n             item(apple,        39,     40),\n             item(cheese,       23,     30),\n             item(beer,         52,     10),\n             item('suntan cream',       11,     70),\n             item(camera,       32,     30),\n             item('t-shirt',    24,     15),\n             item(trousers, 48,         10),\n             item(umbrella, 73,         40),\n             item('waterproof trousers',        42,     70),\n             item('waterproof overclothes',     43,     75),\n             item('note-case',22,       80),\n             item(sunglasses,   7,      20),\n             item(towel,        18,     12),\n             item(socks,        4,      50),\n             item(book,         30,     10 )],\n        length(L, N),\n        length(R, N),\n        R ins 0..1,\n        maplist(arg(2), L, LW),\n        maplist(arg(3), L, LV),\n        scalar_product(LW, R, #=<, 400),\n        scalar_product(LV, R, #=, VM),\n        labeling([max(VM)], R),\n        scalar_product(LW, R, #=, WM),\n        %% affichage des r\u00e9sultats\n        compute_lenword(L, 0, Len),\n        sformat(A1, '~~w~~t~~~w|', [Len]),\n        sformat(A2, '~~t~~w~~~w|', [4]),\n        sformat(A3, '~~t~~w~~~w|', [5]),\n        print_results(A1,A2,A3, L, R, WM, VM).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n% to show the results in a good way\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([item(Name, _, _)|T], N, NF):-\n        atom_length(Name, L),\n        (   L > N -> N1 = L; N1 = N),\n        compute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(A1,A2,A3, [], [], WM, WR) :-\n        sformat(W1, A1, [' ']),\n        sformat(W2, A2, [WM]),\n        sformat(W3, A3, [WR]),\n        format('~w~w~w~n', [W1,W2,W3]).\n\n\nprint_results(A1,A2,A3, [_H|T], [0|TR], WM, VM) :-\n        print_results(A1,A2,A3, T, TR, WM, VM).\n\nprint_results(A1, A2, A3, [item(Name, W, V)|T], [1|TR], WM, VM) :-\n        sformat(W1, A1, [Name]),\n        sformat(W2, A2, [W]),\n        sformat(W3, A3, [V]),\n        format('~w~w~w~n', [W1,W2,W3]),\n        print_results(A1, A2, A3, T, TR, WM, VM).\n\n\nOutput:\n?- knapsack\nmap                      9  150\ncompass                 13   35\nwater                  153  200\nsandwich                50  160\nglucose                 15   60\nbanana                  27   60\nsuntan cream            11   70\nwaterproof trousers     42   70\nwaterproof overclothes  43   75\nnote-case               22   80\nsunglasses               7   20\nsocks                    4   50\n                       396 1030\n\nUsing the simplex library[edit]\nLibrary: simplex\n\n:- use_module(library(simplex)).\n\nknapsack  :-\n\tL = [\n\t     (map, \t9, \t150),\n\t     (compass, \t13, \t35),\n\t     (water, \t153, \t200),\n\t     (sandwich, 50, \t160),\n\t     (glucose, \t15, \t60),\n\t     (tin, \t68, \t45),\n\t     (banana, \t27, \t60),\n\t     (apple, \t39, \t40),\n\t     (cheese, \t23, \t30),\n\t     (beer, \t52, \t10),\n\t     ('suntan cream', \t11, \t70),\n\t     (camera, \t32, \t30),\n\t     ('t-shirt', \t24, \t15),\n\t     (trousers, 48, \t10),\n\t     (umbrella, 73, \t40),\n\t     ('waterproof trousers', \t42, \t70),\n\t     ('waterproof overclothes', \t43, \t75),\n\t     ('note-case',22, \t80),\n\t     (sunglasses, \t7, \t20),\n\t     (towel, \t18, \t12),\n\t     (socks, \t4, \t50),\n\t     (book, \t30, \t10 )],\n\t gen_state(S0),\n\t length(L, N),\n\t numlist(1, N, LN),\n\t time(( create_constraint_N(LN, S0, S1),\n\t\tmaplist(create_constraint_WV, LN, L, LW, LV),\n\t\tconstraint(LW =< 400, S1, S2),\n\t\tmaximize(LV, S2, S3)\n\t      )),\n\tcompute_lenword(L, 0, Len),\n\tsformat(A1, '~~w~~t~~~w|', [Len]),\n\tsformat(A2, '~~t~~w~~~w|', [4]),\n\tsformat(A3, '~~t~~w~~~w|', [5]),\n\tprint_results(S3, A1,A2,A3, L, LN, 0, 0).\n\n\ncreate_constraint_N([], S, S).\n\ncreate_constraint_N([HN|TN], S1, SF) :-\n\tconstraint(integral(x(HN)), S1, S2),\n\tconstraint([x(HN)] =< 1, S2, S3),\n\tconstraint([x(HN)] >= 0, S3, S4),\n\tcreate_constraint_N(TN, S4, SF).\n\ncreate_constraint_WV(N, (_, W, V), W * x(N), V * x(N)).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\ncompute_lenword([], N, N).\ncompute_lenword([(Name, _, _)|T], N, NF):-\n\tatom_length(Name, L),\n\t(   L > N -> N1 = L; N1 = N),\n\tcompute_lenword(T, N1, NF).\n\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\nprint_results(_S, A1, A2, A3, [], [], WM, VM) :-\n\tsformat(W1, A1, [' ']),\n\tsformat(W2, A2, [WM]),\n\tsformat(W3, A3, [VM]),\n\tformat('~w~w~w~n', [W1,W2,W3]).\n\n\nprint_results(S, A1, A2, A3, [(Name, W, V)|T], [N|TN], W1, V1) :-\n\tvariable_value(S, x(N), X),\n\t(   X = 0 -> W1 = W2, V1 = V2\n\t;   sformat(S1, A1, [Name]),\n\t    sformat(S2, A2, [W]),\n\t    sformat(S3, A3, [V]),\n\t    format('~w~w~w~n', [S1,S2,S3]),\n\t    W2 is W1 + W,\n\t    V2 is V1 + V),\n\tprint_results(S, A1, A2, A3, T, TN, W2, V2).\n\n", "explain": "Library written by Markus Triska. The problem is solved in about 3 seconds.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Lua", "code": "\n\nitems = {\n    {\"map\", 9, 150},\n    {\"compass\", 13, 35},\n    {\"water\", 153, 200},\n    {\"sandwich\", 50, 160},\n    {\"glucose\", 15, 60},\n    {\"tin\", 68, 45},\n    {\"banana\", 27, 60},\n    {\"apple\", 39,  40},\n    {\"cheese\", 23, 30},\n    {\"beer\", 52, 10},\n    {\"suntan cream\", 11, 70},\n    {\"camera\", 32, 30},\n    {\"t-shirt\", 24, 15},\n    {\"trousers\", 48, 10},\n    {\"umbrella\", 73, 40},\n    {\"waterproof trousers\", 42, 70},\n    {\"waterproof overclothes\", 43, 75},\n    {\"note-case\", 22, 80},\n    {\"sunglasses\", 7, 20},\n    {\"towel\", 18, 12},\n    {\"socks\", 4, 50},\n    {\"book\", 30, 10},\n}\n\nlocal unpack = table.unpack\n\nfunction m(i, w)\n    if i<1 or w==0 then\n        return 0, {}\n    else\n        local _, wi, vi = unpack(items[i])\n        if wi > w then\n            return mm(i - 1, w)\n        else\n            local vn, ln = mm(i - 1, w)\n            local vy, ly = mm(i - 1, w - wi)\n            if vy + vi > vn then\n                return vy + vi, { i, ly }\n            else\n                return vn, ln\n            end\n        end\n    end\nend\n\nlocal memo, mm_calls = {}, 0\nfunction mm(i, w) -- memoization function for m\n    mm_calls = mm_calls + 1\n    local key = 10000*i + w\n    local result = memo[key]\n    if not result then\n        result = { m(i, w) }\n        memo[key] = result\n    end\n    return unpack(result)\nend\n\nlocal total_value, index_list = m(#items, 400)\n\nfunction list_items(head) -- makes linked list iterator function \n    return function()\n        local item, rest = unpack(head)\n        head = rest\n        return item\n    end\nend\n\nlocal names = {}\nlocal total_weight = 0\nfor i in list_items(index_list) do\n    local name, weight = unpack(items[i])\n    table.insert(names, 1, name)\n    total_weight = total_weight + weight\nend\n\nlocal function printf(fmt, ...) print(string.format(fmt, ...)) end\nprintf(\"items to pack: %s\", table.concat(names, \", \"))\nprintf(\"total value: %d\", total_value)\nprintf(\"total weight: %d\", total_weight)\n\n-- out of curiosity\nlocal count = 0\nfor k,v in pairs(memo) do count = count + 1 end\nprintf(\"\\n(memo count: %d; mm call count: %d)\", count, mm_calls)\n\n\nOutput:\nitems to pack: map, compass, water, sandwich, glucose, banana, suntan cream, waterproof trousers, waterproof overclothes, note-case, sunglasses, socks\ntotal value: 1030\ntotal weight: 396\n\n(memo count: 5329; mm call count: 9485)\n\n", "explain": "This version is adapted from the Clojure version.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Scala", "code": "\nWorks with: Scala version 2.9.2\nobject Knapsack extends App {\n\n  case class Item(name: String, weight: Int, value: Int)\n\n  val elapsed: (=> Unit) => Long = f => {val s = System.currentTimeMillis; f; (System.currentTimeMillis - s)/1000}\n\n  //===== brute force (caution: increase the heap!) ====================================\n  val ks01b: List[Item] => Unit = loi => {\n    val tw:Set[Item]=>Int=ps=>(ps:\\0)((a,b)=>a.weight+b) //total weight\n    val tv:Set[Item]=>Int=ps=>(ps:\\0)((a,b)=>a.value+b) //total value\n    val pis = (loi.toSet.subsets).toList.filterNot(_==Set())\n\n   #[test]\nfn test_dp_results() {\n    let dp_results = knap_01_dp(items, 400);\n    let dp_weights= dp_results.iter().fold(0, |a, &b| a + b.weight);\n    let dp_values = dp_results.iter().fold(0, |a, &b| a + b.value);\n    assert_eq!(dp_weights, 396);\n    assert_eq!(dp_values, 1030);\n} val res = pis.map(ss=>Pair(ss,tw(ss)))\n      .filter(p=>p._2>350 && p._2<401).map(p=>Pair(p,tv(p._1)))\n      .sortWith((s,t)=>s._2.compareTo(t._2) < 0)\n      .last\n    println{val h = \"packing list of items (brute force):\"; h+\"\\n\"+\"=\"*h.size}\n    res._1._1.foreach{p=>print(\"  \"+p.name+\": weight=\"+p.weight+\" value=\"+p.value+\"\\n\")}\n    println(\"\\n\"+\"  resulting items: \"+res._1._1.size+\" of \"+loi.size) \n    println(\"  total weight: \"+res._1._2+\", total value: \"+res._2)\n  }\n\n  //===== dynamic programming ==========================================================\n  val ks01d: List[Item] => Unit = loi => { \n    val W = 400\n    val N = loi.size\n\n    val m = Array.ofDim[Int](N+1,W+1)\n    val plm = (List((for {w <- 0 to W} yield Set[Item]()).toArray)++(\n                for {\n                  n <- 0 to N-1\n                  colN = (for {w <- 0 to W} yield Set[Item](loi(n))).toArray\n                } yield colN)).toArray\n\n    1 to N foreach {n =>\n      0 to W foreach {w =>\n        def in = loi(n-1)\n        def wn = loi(n-1).weight\n        def vn = loi(n-1).value\n        if (w<wn) {\n          m(n)(w) = m(n-1)(w)\n          plm(n)(w) = plm(n-1)(w)\n        } \n        else {\n          if (m(n-1)(w)>=m(n-1)(w-wn)+vn) {\n            m(n)(w) = m(n-1)(w)\n            plm(n)(w) = plm(n-1)(w)\n          }\n          else {\n            m(n)(w) = m(n-1)(w-wn)+vn\n\t    plm(n)(w) = plm(n-1)(w-wn)+in\n\t  }\n\t}\n      }\n    }\n\n    println{val h = \"packing list of items (dynamic programming):\"; h+\"\\n\"+\"=\"*h.size}\n    plm(N)(W).foreach{p=>print(\"  \"+p.name+\": weight=\"+p.weight+\" value=\"+p.value+\"\\n\")}\n    println(\"\\n\"+\"  resulting items: \"+plm(N)(W).size+\" of \"+loi.size) \n    println(\"  total weight: \"+(0/:plm(N)(W).toVector.map{item=>item.weight})(_+_)+\", total value: \"+m(N)(W))\n  }\n\n  val items = List(\n     Item(\"map\", 9, 150)\n    ,Item(\"compass\", 13, 35) \n    ,Item(\"water\", 153, 200)\n    ,Item(\"sandwich\", 50, 160)\n    ,Item(\"glucose\", 15, 60)\n    ,Item(\"tin\", 68, 45)\n    ,Item(\"banana\", 27, 60)\n    ,Item(\"apple\", 39, 40)\n    ,Item(\"cheese\", 23, 30)\n    ,Item(\"beer\", 52, 10)\n    ,Item(\"suntan cream\", 11, 70)\n    ,Item(\"camera\", 32, 30)\n    ,Item(\"t-shirt\", 24, 15)\n    ,Item(\"trousers\", 48, 10)\n    ,Item(\"umbrella\", 73, 40)\n    ,Item(\"waterproof trousers\", 42, 70)\n    ,Item(\"waterproof overclothes\", 43, 75)\n    ,Item(\"note-case\", 22, 80)\n    ,Item(\"sunglasses\", 7, 20)\n    ,Item(\"towel\", 18, 12)\n    ,Item(\"socks\", 4, 50)\n    ,Item(\"book\", 30, 10)\n  ) \n\n  List(ks01b, ks01d).foreach{f=>\n    val t = elapsed{f(items)}\n    println(\"  elapsed time: \"+t+\" sec\"+\"\\n\")\n  }\n}\n\n\nOutput:\npacking list of items (brute force):\n====================================\n  waterproof overclothes: weight=43 value=75\n  note-case: weight=22 value=80\n  socks: weight=4 value=50\n  sandwich: weight=50 value=160\n  banana: weight=27 value=60\n  glucose: weight=15 value=60\n  map: weight=9 value=150\n  water: weight=153 value=200\n  suntan cream: weight=11 value=70\n  sunglasses: weight=7 value=20\n  waterproof trousers: weight=42 value=70\n  compass: weight=13 value=35\n\n  resulting items: 12 of 22\n  total weight: 396, total value: 1030\n  elapsed time: 19 sec\n\npacking list of items (dynamic programming):\n============================================\n  waterproof overclothes: weight=43 value=75\n  note-case: weight=22 value=80\n  socks: weight=4 value=50\n  sandwich: weight=50 value=160\n  banana: weight=27 value=60\n  glucose: weight=15 value=60\n  map: weight=9 value=150\n  water: weight=153 value=200\n  suntan cream: weight=11 value=70\n  sunglasses: weight=7 value=20\n  waterproof trousers: weight=42 value=70\n  compass: weight=13 value=35\n\n  resulting items: 12 of 22\n  total weight: 396, total value: 1030\n  elapsed time: 0 sec\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Dart", "code": "\nList solveKnapsack(items, maxWeight) {\n  int MIN_VALUE=-100;\n  int N = items.length; // number of items \n  int W = maxWeight; // maximum weight of knapsack\n  \n  List profit = new List(N+1);\n  List weight = new List(N+1);\n  \n  // generate random instance, items 1..N\n  for(int n = 1; n<=N; n++) {\n    profit[n] = items[n-1][2];\n    weight[n] = items[n-1][1];\n    \n  }\n  \n  // opt[n][w] = max profit of packing items 1..n with weight limit w\n  // sol[n][w] = does opt solution to pack items 1..n with weight limit w include item n?\n  List<List<int>> opt = new List<List<int>>(N+1);\n  for (int i=0; i<N+1; i++) {\n    opt[i] = new List<int>(W+1);\n    for(int j=0; j<W+1; j++) {\n      opt[i][j] = MIN_VALUE;\n    }\n  }\n  \n  List<List<bool>> sol = new List<List<bool>>(N+1);\n  for (int i=0; i<N+1; i++) {\n    sol[i] = new List<bool>(W+1);\n    for(int j=0; j<W+1; j++) {\n      sol[i][j] = false;\n    }\n  }\n  \n  for(int n=1; n<=N; n++) {\n    for (int w=1; w <= W; w++) {\n      // don't take item n      \n      int option1 = opt[n-1][w];\n      \n      // take item n\n      int option2 = MIN_VALUE;\n      if (weight[n] <= w) {\n        option2 = profit[n] + opt[n-1][w - weight[n]];\n      }\n            \n      // select better of two options\n      opt[n][w] = Math.max(option1, option2);\n      sol[n][w] = (option2 > option1);\n    }\n  }\n  \n  // determine which items to take\n  List<List> packItems = new List<List>();\n  List<bool> take = new List(N+1);\n  for (int n = N, w = W; n > 0; n--) {\n    if (sol[n][w]) {\n      take[n] = true;\n      w = w - weight[n];\n      packItems.add(items[n-1]); \n    } else {\n      take[n] = false; \n    }\n  }\n    \n  return packItems;\n  \n}\n\nmain() {\n  List knapsackItems = [];\n  knapsackItems.add([\"map\", 9, 150]);\n  knapsackItems.add([\"compass\", 13, 35]);\n  knapsackItems.add([\"water\", 153, 200]);\n  knapsackItems.add([\"sandwich\", 50, 160]);\n  knapsackItems.add([\"glucose\", 15, 60]);\n  knapsackItems.add([\"tin\", 68, 45]);\n  knapsackItems.add([\"banana\", 27, 60]);\n  knapsackItems.add([\"apple\", 39, 40]);\n  knapsackItems.add([\"cheese\", 23, 30]);\n  knapsackItems.add([\"beer\", 52, 10]);\n  knapsackItems.add([\"suntan cream\", 11, 70]);\n  knapsackItems.add([\"camera\", 32, 30]);\n  knapsackItems.add([\"t-shirt\", 24, 15]);\n  knapsackItems.add([\"trousers\", 48, 10]);\n  knapsackItems.add([\"umbrella\", 73, 40]);\n  knapsackItems.add([\"waterproof trousers\", 42, 70]);\n  knapsackItems.add([\"waterproof overclothes\", 43, 75]);\n  knapsackItems.add([\"note-case\", 22, 80]);\n  knapsackItems.add([\"sunglasses\", 7, 20]);\n  knapsackItems.add([\"towel\", 18, 12]);\n  knapsackItems.add([\"socks\", 4, 50]);\n  knapsackItems.add([\"book\", 30, 10]);\n  int maxWeight = 400;\n  Stopwatch sw = new Stopwatch.start();\n  List p = solveKnapsack(knapsackItems, maxWeight);\n  sw.stop();\n  int totalWeight = 0;\n  int totalValue = 0;\n  print([\"item\",\"profit\",\"weight\"]);\n  p.forEach((var i) { print(\"${i}\"); totalWeight+=i[1]; totalValue+=i[2]; });\n  print(\"Total Value = ${totalValue}\");\n  print(\"Total Weight = ${totalWeight}\");\n  print(\"Elapsed Time = ${sw.elapsedInMs()}ms\");\n  \n}\n\n\nOutput:\n[item, profit, weight]\n[socks, 4, 50]\n[sunglasses, 7, 20]\n[note-case, 22, 80]\n[waterproof overclothes, 43, 75]\n[waterproof trousers, 42, 70]\n[suntan cream, 11, 70]\n[banana, 27, 60]\n[glucose, 15, 60]\n[sandwich, 50, 160]\n[water, 153, 200]\n[compass, 13, 35]\n[map, 9, 150]\nTotal Value = 1030\nTotal Weight = 396\nElapsed Time = 6ms\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "D", "code": "\nDynamic Programming Version[edit]\nTranslation of: Python\nimport std.stdio, std.algorithm, std.typecons, std.array, std.range;\n\nstruct Item { string name; int weight, value; }\n\nItem[] knapsack01DinamicProgramming(immutable Item[] items, in int limit)\npure nothrow @safe {\n    auto tab = new int[][](items.length + 1, limit + 1);\n\n    foreach (immutable i, immutable it; items)\n        foreach (immutable w; 1 .. limit + 1)\n            tab[i + 1][w] = (it.weight > w) ? tab[i][w] :\n                max(tab[i][w], tab[i][w - it.weight] + it.value);\n\n    typeof(return) result;\n    int w = limit;\n    foreach_reverse (immutable i, immutable it; items)\n        if (tab[i + 1][w] != tab[i][w]) {\n            w -= it.weight;\n            result ~= it;\n        }\n\n    return result;\n}\n\nvoid main() @safe {\n    enum int limit = 400;\n    immutable Item[] items = [\n        {\"apple\",      39,  40}, {\"banana\",        27,  60},\n        {\"beer\",       52,  10}, {\"book\",          30,  10},\n        {\"camera\",     32,  30}, {\"cheese\",        23,  30},\n        {\"compass\",    13,  35}, {\"glucose\",       15,  60},\n        {\"map\",         9, 150}, {\"note-case\",     22,  80},\n        {\"sandwich\",   50, 160}, {\"socks\",          4,  50},\n        {\"sunglasses\",  7,  20}, {\"suntan cream\",  11,  70},\n        {\"t-shirt\",    24,  15}, {\"tin\",           68,  45},\n        {\"towel\",      18,  12}, {\"trousers\",      48,  10},\n        {\"umbrella\",   73,  40}, {\"water\",        153, 200},\n        {\"waterproof overclothes\", 43, 75},\n        {\"waterproof trousers\",    42, 70}];\n\n    immutable bag = knapsack01DinamicProgramming(items, limit);\n    writefln(\"Items:\\n%-(  %s\\n%)\", bag.map!q{ a.name }.retro);\n    const t = reduce!q{ a[] += [b.weight, b.value] }([0, 0], bag);\n    writeln(\"\\nTotal weight and value: \", t[0] <= limit ? t : [0, 0]);\n}\n\n\nOutput:\nItems:\n  banana\n  compass\n  glucose\n  map\n  note-case\n  sandwich\n  socks\n  sunglasses\n  suntan cream\n  water\n  waterproof overclothes\n  waterproof trousers\n\nTotal weight and value: [396, 1030]\nBrute Force Version[edit]\nTranslation of: C\nstruct Item { string name; int weight, value; }\n\nimmutable Item[] items = [\n    {\"apple\",      39,  40}, {\"banana\",        27,  60},\n    {\"beer\",       52,  10}, {\"book\",          30,  10},\n    {\"camera\",     32,  30}, {\"cheese\",        23,  30},\n    {\"compass\",    13,  35}, {\"glucose\",       15,  60},\n    {\"map\",         9, 150}, {\"note-case\",     22,  80},\n    {\"sandwich\",   50, 160}, {\"socks\",          4,  50},\n    {\"sunglasses\",  7,  20}, {\"suntan cream\",  11,  70},\n    {\"t-shirt\",    24,  15}, {\"tin\",           68,  45},\n    {\"towel\",      18,  12}, {\"trousers\",      48,  10},\n    {\"umbrella\",   73,  40}, {\"water\",        153, 200},\n    {\"waterproof overclothes\", 43, 75},\n    {\"waterproof trousers\",    42, 70}];\n\nstruct Solution { uint bits; int value; }\nstatic assert(items.length <= Solution.bits.sizeof * 8);\n\nvoid solve(in int weight, in int idx, ref Solution s)\npure nothrow @nogc @safe {\n    if (idx < 0) {\n        s.bits = s.value = 0;\n        return;\n    }\n\n    if (weight < items[idx].weight) {\n        solve(weight, idx - 1, s);\n        return;\n     }\n\n    Solution v1, v2;\n    solve(weight, idx - 1, v1);\n    solve(weight - items[idx].weight, idx - 1, v2);\n\n    v2.value += items[idx].value;\n    v2.bits |= (1 << idx);\n\n    s = (v1.value >= v2.value) ? v1 : v2;\n}\n\nvoid main() @safe {\n    import std.stdio;\n\n    auto s = Solution(0, 0);\n    solve(400, items.length - 1, s);\n\n    writeln(\"Items:\");\n    int w = 0;\n    foreach (immutable i, immutable it; items)\n        if (s.bits & (1 << i)) {\n            writeln(\"  \", it.name);\n            w += it.weight;\n        }\n    writefln(\"\\nTotal value: %d; weight: %d\", s.value, w);\n}\n\n\n\nOutput:\nItems:\n  banana\n  compass\n  glucose\n  map\n  note-case\n  sandwich\n  socks\n  sunglasses\n  suntan cream\n  water\n  waterproof overclothes\n  waterproof trousers\n\nTotal value: 1030; weight: 396\nShort Dynamic Programming Version[edit]\nTranslation of: Haskell\nimport std.stdio, std.algorithm, std.typecons, std.array, std.range;\n\nstruct Item { string name; int w, v; }\nalias Pair = Tuple!(int,\"tot\", string[],\"names\");\n\nimmutable Item[] items = [{\"apple\",39,40}, {\"banana\", 27, 60},\n    {\"beer\", 52, 10}, {\"book\", 30, 10}, {\"camera\", 32, 30},\n    {\"cheese\", 23, 30}, {\"compass\", 13, 35}, {\"glucose\", 15, 60},\n    {\"map\", 9, 150}, {\"note-case\", 22, 80}, {\"sandwich\", 50, 160},\n    {\"socks\", 4, 50}, {\"sunglasses\", 7, 20}, {\"suntan cream\", 11, 70},\n    {\"t-shirt\", 24, 15}, {\"tin\", 68, 45}, {\"towel\", 18, 12},\n    {\"trousers\", 48, 10}, {\"umbrella\", 73, 40}, {\"water\", 153, 200},\n    {\"overclothes\", 43, 75}, {\"waterproof trousers\", 42, 70}];\n\nauto addItem(Pair[] lst, in Item it) pure /*nothrow*/ {\n    auto aux = lst.map!(vn => Pair(vn.tot + it.v, vn.names ~ it.name));\n    return lst[0..it.w] ~ lst[it.w..$].zip(aux).map!q{ a[].max }.array;\n}\n\nvoid main() {\n    reduce!addItem(Pair().repeat.take(400).array, items).back.writeln;\n}\n\n\n\nOutput:\nTuple!(int, \"tot\", string[], \"names\")(1030, [\"banana\", \"compass\", \"glucose\", \"map\", \"note-case\", \"sandwich\", \"socks\", \"sunglasses\", \"suntan cream\", \"water\", \"overclothes\", \"waterproof trousers\"])\n", "explain": "The runtime is about 0.09 seconds.\nRuntime about 0.04 seconds.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Haskell", "code": "\n\ninv = [(\"map\",9,150), (\"compass\",13,35), (\"water\",153,200), (\"sandwich\",50,160),\n\t(\"glucose\",15,60), (\"tin\",68,45), (\"banana\",27,60), (\"apple\",39,40),\n\t(\"cheese\",23,30), (\"beer\",52,10), (\"cream\",11,70), (\"camera\",32,30),\n\t(\"tshirt\",24,15), (\"trousers\",48,10), (\"umbrella\",73,40), (\"trousers\",42,70),\n\t(\"overclothes\",43,75), (\"notecase\",22,80), (\"sunglasses\",7,20), (\"towel\",18,12),\n\t(\"socks\",4,50), (\"book\",30,10)]\n\n-- get all combos of items under total weight sum; returns value sum and list\ncombs [] _ = [ (0, []) ]\ncombs ((name,w,v):rest) cap = combs rest cap ++ \n\t\t      if w > cap then [] else map (prepend (name,w,v)) (combs rest (cap - w))\n\t\t      \twhere prepend (name,w,v) (v2, lst) = (v2 + v, (name,w,v):lst)\n\nmain = do\n\tputStr \"Total value: \"; print value\n\tmapM_ print items\n\t\twhere (value, items) = maximum $ combs inv 400\n\n\nOutput:\nTotal value: 1030\n(\"map\",9,150)\n(\"compass\",13,35)\n(\"water\",153,200)\n(\"sandwich\",50,160)\n(\"glucose\",15,60)\n(\"banana\",27,60)\n(\"cream\",11,70)\n(\"trousers\",42,70)\n(\"overclothes\",43,75)\n(\"notecase\",22,80)\n(\"sunglasses\",7,20)\n(\"socks\",4,50)\n\n\ninv = [(\"map\",9,150), (\"compass\",13,35), (\"water\",153,200), (\"sandwich\",50,160),\n\t(\"glucose\",15,60), (\"tin\",68,45), (\"banana\",27,60), (\"apple\",39,40),\n\t(\"cheese\",23,30), (\"beer\",52,10), (\"cream\",11,70), (\"camera\",32,30),\n\t(\"tshirt\",24,15), (\"trousers\",48,10), (\"umbrella\",73,40), (\"trousers\",42,70),\n\t(\"overclothes\",43,75), (\"notecase\",22,80), (\"sunglasses\",7,20), (\"towel\",18,12),\n\t(\"socks\",4,50), (\"book\",30,10)]\n\ncombs [] _ = (0, [])\ncombs ((name,w,v):rest) cap\n\t| w <= cap  = max skipthis $ prepend (name,w,v) (combs rest (cap - w))\n\t| otherwise = skipthis\n\twhere\tprepend (name,w,v) (v2, lst) = (v2 + v, (name,w,v):lst)\n\t\tskipthis = combs rest cap\n\nmain = do print $ combs inv 400\n\n\nOutput:\n(1030,[(\"map\",9,150),(\"compass\",13,35),(\"water\",153,200),(\"sandwich\",50,160),(\"glucose\",15,60),(\"banana\",27,60),(\"cream\",11,70),(\"trousers\",42,70),(\"overclothes\",43,75),(\"notecase\",22,80),(\"sunglasses\",7,20),(\"socks\",4,50)])\n\ninv = [(\"map\",9,150), (\"compass\",13,35), (\"water\",153,200), (\"sandwich\",50,160),\n       (\"glucose\",15,60), (\"tin\",68,45), (\"banana\",27,60), (\"apple\",39,40),\n       (\"cheese\",23,30), (\"beer\",52,10), (\"cream\",11,70), (\"camera\",32,30),\n       (\"tshirt\",24,15), (\"trousers\",48,10), (\"umbrella\",73,40),\n       (\"waterproof trousers\",42,70), (\"overclothes\",43,75), (\"notecase\",22,80),\n       (\"sunglasses\",7,20), (\"towel\",18,12), (\"socks\",4,50), (\"book\",30,10)]\n\nknapsack = foldr addItem (repeat (0,[])) where\n\taddItem (name,w,v) list = left ++ zipWith max right newlist where\n\t\tnewlist = map (\\(val, names)->(val + v, name:names)) list\n\t\t(left,right) = splitAt w list\n\nmain = print $ (knapsack inv) !! 400\n\n\nOutput:\n(1030,[\"map\",\"compass\",\"water\",\"sandwich\",\"glucose\",\"banana\",\"cream\",\"waterproof trousers\",\"overclothes\",\"notecase\",\"sunglasses\",\"socks\"])\n\n", "explain": "Brute force:\nMuch faster brute force solution that computes the maximum before prepending, saving most of the prepends:\nDynamic programming with a list for caching (this can be adapted to bounded problem easily):\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "VBScript", "code": "\n\n' Knapsack problem/0-1 - 13/02/2017\ndim w(22),v(22),m(22)\ndata=array( \"map\", 9, 150, \"compass\", 13, 35, \"water\", 153, 200, _\n \"sandwich\", 50, 160 , \"glucose\", 15, 60, \"tin\", 68, 45, _\n \"banana\", 27, 60, \"apple\", 39, 40 , \"cheese\", 23, 30, \"beer\", 52, 10, _\n \"suntan cream\", 11, 70, \"camera\", 32, 30 , \"T-shirt\", 24, 15, _\n \"trousers\", 48, 10, \"umbrella\", 73, 40, \"book\", 30, 10 , _\n \"waterproof trousers\", 42, 70, \"waterproof overclothes\", 43, 75 , _\n \"note-case\", 22, 80, \"sunglasses\", 7, 20, \"towel\", 18, 12, \"socks\", 4, 50)\nww=400\nxw=0:iw=0:iv=0\nw(1)=iw:v(1)=iv\nfor i1=0 to 1:m(1)=i1:j=0\n if i1=1 then\n  iw=w(1)+data(j*3+1):iv=v(1)+data(j*3+2)\n  if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n end if 'i1\n if iw<=ww then\n  w(2)=iw: v(2)=iv\n  for i2=0 to 1:m(2)=i2:j=1\n   if i2=1 then\n    iw=w(2)+data(j*3+1):iv=v(2)+data(j*3+2)\n    if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n   end if 'i2\n   if iw<=ww then\n    w(3)=iw: v(3)=iv\n    for i3=0 to 1:m(3)=i3:j=2\n     if i3=1 then\n      iw=w(3)+data(j*3+1):iv=v(3)+data(j*3+2)\n      if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n     end if 'i3\n     if iw<=ww then\n      w(4)=iw: v(4)=iv\n      for i4=0 to 1:m(4)=i4:j=3\n       if i4=1 then\n        iw=w(4)+data(j*3+1):iv=v(4)+data(j*3+2)\n        if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n       end if 'i4\n       if iw<=ww then\n        w(5)=iw: v(5)=iv\n        for i5=0 to 1:m(5)=i5:j=4\n         if i5=1 then\n          iw=w(5)+data(j*3+1):iv=v(5)+data(j*3+2)\n          if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n         end if 'i5\n         if iw<=ww then\n          w(6)=iw: v(6)=iv\n          for i6=0 to 1:m(6)=i6:j=5\n           if i6=1 then\n            iw=w(6)+data(j*3+1):iv=v(6)+data(j*3+2)\n            if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n           end if 'i6\n           if iw<=ww then\n            w(7)=iw: v(7)=iv\n            for i7=0 to 1:m(7)=i7:j=6\n             if i7=1 then\n              iw=w(7)+data(j*3+1):iv=v(7)+data(j*3+2)\n              if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n             end if 'i7\n             if iw<=ww then\n              w(8)=iw: v(8)=iv\n              for i8=0 to 1:m(8)=i8:j=7\n               if i8=1 then\n                iw=w(8)+data(j*3+1):iv=v(8)+data(j*3+2)\n                if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n               end if 'i8\n               if iw<=ww then\n                w(9)=iw: v(9)=iv\n                for i9=0 to 1:m(9)=i9:j=8\n                 if i9=1 then\n                  iw=w(9)+data(j*3+1):iv=v(9)+data(j*3+2)\n                  if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                 end if 'i9\n                 if iw<=ww then\n                  w(10)=iw: v(10)=iv\n                  for i10=0 to 1:m(10)=i10:j=9\n                   if i10=1 then\n                    iw=w(10)+data(j*3+1):iv=v(10)+data(j*3+2)\n                    if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                   end if 'i10\n                   if iw<=ww then\n                    w(11)=iw: v(11)=iv\n                    for i11=0 to 1:m(11)=i11:j=10\n                     if i11=1 then\n                      iw=w(11)+data(j*3+1):iv=v(11)+data(j*3+2)\n                      if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                     end if 'i11\n                     if iw<=ww then\n                      w(12)=iw: v(12)=iv\n                      for i12=0 to 1:m(12)=i12:j=11\n                       if i12=1 then\n                        iw=w(12)+data(j*3+1):iv=v(12)+data(j*3+2)\n                        if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                       end if 'i12\n                       if iw<=ww then\n                        w(13)=iw: v(13)=iv\n                        for i13=0 to 1:m(13)=i13:j=12\n                         if i13=1 then\n                          iw=w(13)+data(j*3+1):iv=v(13)+data(j*3+2)\n                          if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                         end if 'i13\n                         if iw<=ww then\n                          w(14)=iw: v(14)=iv\n                          for i14=0 to 1:m(14)=i14:j=13\n                           if i14=1 then\n                            iw=w(14)+data(j*3+1):iv=v(14)+data(j*3+2)\n                            if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                           end if 'i14\n                           if iw<=ww then\n                            w(15)=iw: v(15)=iv\n                            for i15=0 to 1:m(15)=i15:j=14\n                             if i15=1 then\n                              iw=w(15)+data(j*3+1):iv=v(15)+data(j*3+2)\n                              if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                             end if 'i15\n                             if iw<=ww then\n                              w(16)=iw: v(16)=iv\n                              for i16=0 to 1:m(16)=i16:j=15\n                               if i16=1 then\n                                iw=w(16)+data(j*3+1):iv=v(16)+data(j*3+2)\n                                if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                               end if 'i16\n                               if iw<=ww then\n                                w(17)=iw: v(17)=iv\n                                for i17=0 to 1:m(17)=i17:j=16\n                                 if i17=1 then\n                                  iw=w(17)+data(j*3+1):iv=v(17)+data(j*3+2)\n                                  if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                 end if 'i17\n                                 if iw<=ww then\n                                  w(18)=iw: v(18)=iv\n                                  for i18=0 to 1:m(18)=i18:j=17\n                                   if i18=1 then\n                                    iw=w(18)+data(j*3+1):iv=v(18)+data(j*3+2)\n                                    if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                   end if 'i18\n                                   if iw<=ww then\n                                    w(19)=iw: v(19)=iv\n                                    for i19=0 to 1:m(19)=i19:j=18\n                                     if i19=1 then\n                                      iw=w(19)+data(j*3+1):iv=v(19)+data(j*3+2)\n                                      if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                     end if 'i19\n                                     if iw<=ww then\n                                      w(20)=iw: v(20)=iv\n                                      for i20=0 to 1:m(20)=i20:j=19\n                                       if i20=1 then\n                                        iw=w(20)+data(j*3+1):iv=v(20)+data(j*3+2)\n                                        if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                       end if 'i20\n                                       if iw<=ww then\n                                        w(21)=iw: v(21)=iv\n                                        for i21=0 to 1:m(21)=i21:j=20\n                                         if i21=1 then\n                                          iw=w(21)+data(j*3+1):iv=v(21)+data(j*3+2)\n                                          if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                         end if 'i21\n                                         if iw<=ww then\n                                          w(22)=iw: v(22)=iv\n                                          for i22=0 to 1:m(22)=i22:j=21\n                                           nn=nn+1\n                                           if i22=1 then\n                                            iw=w(22)+data(j*3+1):iv=v(22)+data(j*3+2)\n                                            if iv>xv and iw<=ww then xw=iw:xv=iv:l=m\n                                           end if 'i22\n                                           if iw<=ww then\n                                           end if 'i22\n                                          next:m(22)=0\n                                         end if 'i21\n                                        next:m(21)=0\n                                       end if 'i20\n                                      next:m(20)=0\n                                     end if 'i19\n                                    next:m(19)=0\n                                   end if 'i18\n                                  next:m(18)=0\n                                 end if 'i17\n                                next:m(17)=0\n                               end if 'i16\n                              next:m(16)=0\n                             end if 'i15\n                            next:m(15)=0\n                           end if 'i14\n                          next:m(14)=0\n                         end if 'i13\n                        next:m(13)=0\n                       end if 'i12\n                      next:m(12)=0\n                     end if 'i11\n                    next:m(11)=0\n                   end if 'i10\n                  next:m(10)=0\n                 end if 'i9\n                next:m(9)=0\n               end if 'i8\n              next:m(8)=0\n             end if 'i7\n            next:m(7)=0\n           end if 'i6\n          next:m(6)=0\n         end if 'i5\n        next:m(5)=0\n       end if 'i4\n      next:m(4)=0\n     end if 'i3\n    next:m(3)=0\n   end if 'i2\n  next:m(2)=0\n end if 'i1\nnext:m(1)=0\nfor i=1 to 22\n if l(i)=1 then wlist=wlist&vbCrlf&data((i-1)*3)\nnext\nMsgbox mid(wlist,3)&vbCrlf&vbCrlf&\"weight=\"&xw&vbCrlf&\"value=\"&xv,,\"Knapsack - nn=\"&nn\n\nOutput:\nmap\ncompass\nwater\nsandwich\nglucose\nbanana\nsuntan cream\nwaterproof trousers\nwaterproof overclothes\nnote-case\nsunglasses\nsocks\n\nweight=396\nvalue=1030\n\n", "explain": "Non recurvive unfolded force version. Created by an other script. It runs 13 times faster than the recursive one.\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "F#", "code": "\nUsing A* Algorithm[edit]\n//Solve Knapsack 0-1 using A* algorithm\n//Nigel Galloway, August 3rd., 2018\nlet knapStar items maxW=\n  let l=List.length items\n  let p=System.Collections.Generic.SortedSet<float*int*float*float*list<int>>() //H*; level; value of items taken so far; weight so far\n  p.Add (0.0,0,0.0,0.0,[])|>ignore\n  let H items maxW=let rec H n g a=match g with |(_,w,v)::e->let t=n+w\n                                                             if t<=maxW then H t e (a+v) else a+(v/w)*(maxW-n)\n                                                |_->a\n                   H 0.0 items 0.0\n  let pAdd ((h,_,_,_,_) as n) bv=if h>bv then p.Add n |> ignore\n  let fH n (bv,t) w' v' t'=let _,w,v=List.item n items\n                           let e=max bv (if w<=(maxW-w') then v'+v else bv)\n                           let rt=n::t'\n                           if n+1<l then pAdd ((v'+H (List.skip (n+1) items) maxW),n+1,v',w',t') bv\n                                         if w<=(maxW-w') then pAdd ((v'+v+H (List.skip (n+1) items) (maxW-w')),n+1,v'+v,w'+w,rt) bv\n                           if e>bv then (e,rt) else (bv,t)\n  let rec fN (bv,t)=\n    let h,zl,zv,zw,zt as r=p.Max\n    p.Remove r |> ignore\n    if bv>=h then t else fN (fH zl (bv,t) zw zv zt)\n  fN (fH 0 (0.0,[]) 0.0 0.0 [])\n\n\nOutput:\nlet itemsf = [\n  \"map\",                     9.0,  150.0;\n  \"compass\",                13.0,   35.0;\n  \"water\",                 153.0,  200.0;\n  \"sandwich\",               50.0,  160.0;\n  \"glucose\",                15.0,   60.0;\n  \"tin\",                    68.0,   45.0;\n  \"banana\",                 27.0,   60.0;\n  \"apple\",                  39.0,   40.0;\n  \"cheese\",                 23.0,   30.0;\n  \"beer\",                   52.0,   10.0;\n  \"suntan cream\",           11.0,   70.0;\n  \"camera\",                 32.0,   30.0;\n  \"t-shirt\",                24.0,   15.0;\n  \"trousers\",               48.0,   10.0;\n  \"umbrella\",               73.0,   40.0;\n  \"waterproof trousers\",    42.0,   70.0;\n  \"waterproof overclothes\", 43.0,   75.0;\n  \"note-case\",              22.0,   80.0;\n  \"sunglasses\",              7.0,   20.0;\n  \"towel\",                  18.0,   12.0;\n  \"socks\",                   4.0,   50.0;\n  \"book\",                   30.0,   10.0;]|> List.sortBy(fun(_,n,g)->n/g)\n\n> let x=knapStar itemsf 400.0;;\n> x|>Seq.map (fun n->Seq.item n itemsf)|>Seq.sumBy(fun (_,_,n)->(+n));;                                                                 \nval it\u00a0: float = 1030.0\n> x|>Seq.map (fun n->Seq.item n itemsf)|>Seq.sumBy(fun (_,n,_)->(+n));;\nval it\u00a0: float = 396.0\n> x|>Seq.iter(fun n->printfn \"%A\" (List.item n itemsf));; \n(\"map\", 9.0, 150.0)\n(\"socks\", 4.0, 50.0)\n(\"suntan cream\", 11.0, 70.0)\n(\"glucose\", 15.0, 60.0)\n(\"note-case\", 22.0, 80.0)\n(\"sandwich\", 50.0, 160.0)\n(\"sunglasses\", 7.0, 20.0)\n(\"compass\", 13.0, 35.0)\n(\"banana\", 27.0, 60.0)\n(\"waterproof overclothes\", 43.0, 75.0)\n(\"waterproof trousers\", 42.0, 70.0)\n(\"water\", 153.0, 200.0)\n\n", "explain": ""}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "Groovy", "code": "\n\ndef totalWeight = { list -> list*.weight.sum() }\ndef totalValue = { list -> list*.value.sum() }\n \ndef knapsack01bf = { possibleItems ->\n    possibleItems.subsequences().findAll{ ss ->\n        def w = totalWeight(ss)\n        350 < w && w < 401\n    }.max(totalValue)\n}\n\n\ndef knapsack01dp = { possibleItems ->\n    def n = possibleItems.size()\n    def m = (0..n).collect{ i -> (0..400).collect{ w -> []} }\n    (1..400).each { w ->\n        (1..n).each { i ->\n            def wi = possibleItems[i-1].weight\n            m[i][w] = wi > w ? m[i-1][w] : ([m[i-1][w], m[i-1][w-wi] + [possibleItems[i-1]]].max(totalValue))\n        }\n    }\n    m[n][400]\n}\n\n\ndef items = [ \n        [name:\"map\", weight:9, value:150],\n        [name:\"compass\", weight:13, value:35],\n        [name:\"water\", weight:153, value:200],\n        [name:\"sandwich\", weight:50, value:160],\n        [name:\"glucose\", weight:15, value:60],\n        [name:\"tin\", weight:68, value:45],\n        [name:\"banana\", weight:27, value:60],\n        [name:\"apple\", weight:39, value:40],\n        [name:\"cheese\", weight:23, value:30],\n        [name:\"beer\", weight:52, value:10],\n        [name:\"suntan cream\", weight:11, value:70],\n        [name:\"camera\", weight:32, value:30],\n        [name:\"t-shirt\", weight:24, value:15],\n        [name:\"trousers\", weight:48, value:10],\n        [name:\"umbrella\", weight:73, value:40],\n        [name:\"waterproof trousers\", weight:42, value:70],\n        [name:\"waterproof overclothes\", weight:43, value:75],\n        [name:\"note-case\", weight:22, value:80],\n        [name:\"sunglasses\", weight:7, value:20],\n        [name:\"towel\", weight:18, value:12],\n        [name:\"socks\", weight:4, value:50],\n        [name:\"book\", weight:30, value:10],\n]\n\n[knapsack01bf, knapsack01dp].each { knapsack01 ->\n    def start = System.currentTimeMillis()\n    def packingList = knapsack01(items)\n    def elapsed = System.currentTimeMillis() - start\n    \n    println \"\\n\\n\\nElapsed Time: ${elapsed/1000.0} s\"\n    println \"Total Weight: ${totalWeight(packingList)}\"\n    println \" Total Value: ${totalValue(packingList)}\"\n    packingList.each {\n        printf (\"  item:\u00a0%-25s  weight:%4d  value:%4d\\n\", it.name, it.weight, it.value)\n    }\n}\n\n\nOutput:\nElapsed Time: 132.267 s\nTotal Weight: 396\n Total Value: 1030\n  item: map                        weight:   9  value: 150\n  item: compass                    weight:  13  value:  35\n  item: water                      weight: 153  value: 200\n  item: sandwich                   weight:  50  value: 160\n  item: glucose                    weight:  15  value:  60\n  item: banana                     weight:  27  value:  60\n  item: suntan cream               weight:  11  value:  70\n  item: waterproof trousers        weight:  42  value:  70\n  item: waterproof overclothes     weight:  43  value:  75\n  item: note-case                  weight:  22  value:  80\n  item: sunglasses                 weight:   7  value:  20\n  item: socks                      weight:   4  value:  50\n\n\n\nElapsed Time: 0.27 s\nTotal Weight: 396\n Total Value: 1030\n  item: map                        weight:   9  value: 150\n  item: compass                    weight:  13  value:  35\n  item: water                      weight: 153  value: 200\n  item: sandwich                   weight:  50  value: 160\n  item: glucose                    weight:  15  value:  60\n  item: banana                     weight:  27  value:  60\n  item: suntan cream               weight:  11  value:  70\n  item: waterproof trousers        weight:  42  value:  70\n  item: waterproof overclothes     weight:  43  value:  75\n  item: note-case                  weight:  22  value:  80\n  item: sunglasses                 weight:   7  value:  20\n  item: socks                      weight:   4  value:  50\n", "explain": "Solution #1: brute force\nSolution #2: dynamic programming\nTest:\n"}, {"task_name": "Knapsack problem/0-1", "task_url": "https://rosettacode.org/wiki/Knapsack_problem/0-1", "task_cat": "Classic CS problems and programs", "lang": "AWK", "code": "\n# syntax: GAWK -f KNAPSACK_PROBLEM_0-1.AWK\nBEGIN {\n#   arr[\"item,weight\"] = value\n    arr[\"map,9\"] = 150\n    arr[\"compass,13\"] = 35\n    arr[\"water,153\"] = 200\n    arr[\"sandwich,50\"] = 160\n    arr[\"glucose,15\"] = 60\n    arr[\"tin,68\"] = 45\n    arr[\"banana,27\"] = 60\n    arr[\"apple,39\"] = 40\n    arr[\"cheese,23\"] = 30\n    arr[\"beer,52\"] = 10\n    arr[\"suntan cream,11\"] = 70\n    arr[\"camera,32\"] = 30\n    arr[\"T-shirt,24\"] = 15\n    arr[\"trousers,48\"] = 10\n    arr[\"umbrella,73\"] = 40\n    arr[\"waterproof trousers,42\"] = 70\n    arr[\"waterproof overclothes,43\"] = 75\n    arr[\"note-case,22\"] = 80\n    arr[\"sunglasses,7\"] = 20\n    arr[\"towel,18\"] = 12\n    arr[\"socks,4\"] = 50\n    arr[\"book,30\"] = 10\n    sack_size = 400 # dag\n    PROCINFO[\"sorted_in\"] = \"@val_num_desc\"\n    for (i in arr) {\n      if (total_weight >= sack_size) {\n        break\n      }\n      split(i,tmp,\",\")\n      weight = tmp[2]\n      if (total_weight + weight <= sack_size) {\n        printf(\"%s\\n\",tmp[1])\n        total_items++\n        total_value += arr[i]\n        total_weight += weight\n      }\n    }\n    printf(\"items=%d (out of %d) weight=%d value=%d\\n\",total_items,length(arr),total_weight,total_value)\n    exit(0)\n}\n\n\nOutput:\nwater\nsandwich\nmap\nnote-case\nwaterproof overclothes\nwaterproof trousers\nsuntan cream\nbanana\nglucose\nsocks\ncompass\nsunglasses\nitems=12 (out of 22) weight=396 value=1030\n\n", "explain": ""}]