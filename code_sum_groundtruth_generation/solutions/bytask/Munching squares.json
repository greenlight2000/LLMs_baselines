[{"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Python", "code": "\nLibrary: PIL\nimport Image, ImageDraw\n\nimage = Image.new(\"RGB\", (256, 256))\ndrawingTool = ImageDraw.Draw(image)\n\nfor x in range(256):\n    for y in range(256):\n        drawingTool.point((x, y), (0, x^y, 0))\n\ndel drawingTool\nimage.save(\"xorpic.png\", \"PNG\")\n\n\n", "explain": "\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "C", "code": "\n#include <stdlib.h>\n#include <stdio.h>\n#include <math.h>\n#include <string.h>\n\nvoid hue_to_rgb(double hue, double sat, unsigned char *p)\n{\n\tdouble x;\n\tint c = 255 * sat;\n\thue /= 60;\n\tx = (1 - fabs(fmod(hue, 2) - 1)) * 255;\n\n\tswitch((int)hue) {\n\tcase 0:\tp[0] = c; p[1] = x; p[2] = 0; return;\n\tcase 1:\tp[0] = x; p[1] = c; p[2] = 0; return;\n\tcase 2:\tp[0] = 0; p[1] = c; p[2] = x; return;\n\tcase 3:\tp[0] = 0; p[1] = x; p[2] = c; return;\n\tcase 4:\tp[0] = x; p[1] = 0; p[2] = c; return;\n\tcase 5:\tp[0] = c; p[1] = 0; p[2] = x; return;\n\t}\n}\n\nint main(void)\n{\n\tconst int size = 512;\n\tint i, j;\n\tunsigned char *colors = malloc(size * 3);\n\tunsigned char *pix = malloc(size * size * 3), *p;\n\tFILE *fp;\n\n\tfor (i = 0; i < size; i++)\n\t\thue_to_rgb(i * 240. / size, i * 1. / size, colors + 3 * i);\n\n\tfor (i = 0, p = pix; i < size; i++)\n\t\tfor (j = 0; j < size; j++, p += 3)\n\t\t\tmemcpy(p, colors + (i ^ j) * 3, 3);\n\n\tfp = fopen(\"xor.ppm\", \"wb\");\n\tfprintf(fp, \"P6\\n%d %d\\n255\\n\", size, size);\n\tfwrite(pix, size * size * 3, 1, fp);\n\tfclose(fp);\n\n\treturn 0;\n}\n\n\nOutput: \n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "C++", "code": "\n\n#include <windows.h>\n#include <string>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nconst int BMP_SIZE = 512;\n\n//--------------------------------------------------------------------------------------------------\nclass myBitmap\n{\npublic:\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\n    ~myBitmap()\n    {\n\tDeleteObject( pen );\n\tDeleteObject( brush );\n\tDeleteDC( hdc );\n\tDeleteObject( bmp );\n    }\n \n    bool create( int w, int h )\n    {\n\tBITMAPINFO    bi;\n\tZeroMemory( &bi, sizeof( bi ) );\n\tbi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\n\tbi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\n\tbi.bmiHeader.biCompression = BI_RGB;\n\tbi.bmiHeader.biPlanes      = 1;\n\tbi.bmiHeader.biWidth       =  w;\n\tbi.bmiHeader.biHeight      = -h;\n \n\tHDC dc = GetDC( GetConsoleWindow() );\n\tbmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n\tif( !bmp ) return false;\n \n\thdc = CreateCompatibleDC( dc );\n\tSelectObject( hdc, bmp );\n\tReleaseDC( GetConsoleWindow(), dc );\n \n\twidth = w; height = h;\n\treturn true;\n    }\n \n    void clear( BYTE clr = 0 )\n    {\n\tmemset( pBits, clr, width * height * sizeof( DWORD ) );\n    }\n \n    void setBrushColor( DWORD bClr )\n    {\n\tif( brush ) DeleteObject( brush );\n\tbrush = CreateSolidBrush( bClr );\n\tSelectObject( hdc, brush );\n    }\n \n    void setPenColor( DWORD c ) { clr = c; createPen(); }\n \n    void setPenWidth( int w )   { wid = w; createPen(); }\n \n    void saveBitmap( string path )\n    {\n\tBITMAPFILEHEADER fileheader;\n\tBITMAPINFO       infoheader;\n\tBITMAP           bitmap;\n\tDWORD            wb;\n \n\tGetObject( bmp, sizeof( bitmap ), &bitmap );\n\tDWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n \n\tZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n\tZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n\tZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n \n\tinfoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n\tinfoheader.bmiHeader.biCompression = BI_RGB;\n\tinfoheader.bmiHeader.biPlanes = 1;\n\tinfoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n\tinfoheader.bmiHeader.biHeight = bitmap.bmHeight;\n\tinfoheader.bmiHeader.biWidth = bitmap.bmWidth;\n\tinfoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n \n\tfileheader.bfType    = 0x4D42;\n\tfileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n\tfileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n \n\tGetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n \n\tHANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\tWriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n\tWriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n\tWriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n\tCloseHandle( file );\n \n\tdelete [] dwpBits;\n    }\n \n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\n \nprivate:\n    void createPen()\n    {\n\tif( pen ) DeleteObject( pen );\n\tpen = CreatePen( PS_SOLID, wid, clr );\n\tSelectObject( hdc, pen );\n    }\n \n    HBITMAP bmp;\n    HDC     hdc;\n    HPEN    pen;\n    HBRUSH  brush;\n    void    *pBits;\n    int     width, height, wid;\n    DWORD   clr;\n};\n//--------------------------------------------------------------------------------------------------\nclass mSquares\n{\npublic:\n    mSquares()\n    {\n        bmp.create( BMP_SIZE, BMP_SIZE );\n        createPallete();\n    }\n\n    void draw()\n    {\n\tHDC dc = bmp.getDC();\n\tfor( int y = 0; y < BMP_SIZE; y++ )\n\t    for( int x = 0; x < BMP_SIZE; x++ )\n\t    {\n\t\tint c = ( x ^ y ) % 256;\n\t\tSetPixel( dc, x, y, clrs[c] );\n\t    }\n\n\tBitBlt( GetDC( GetConsoleWindow() ), 30, 30, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );\n\t//bmp.saveBitmap( \"f:\\\\rc\\\\msquares_cpp.bmp\" );\n    }\n\nprivate:\n    void createPallete()\n    {\n\tfor( int x = 0; x < 256; x++ )\n\tclrs[x] = RGB( x<<1, x, x<<2 );//rand()\u00a0% 180 + 50, rand()\u00a0% 200 + 50, rand()\u00a0% 180 + 50 );\n    }\n\n    unsigned int clrs[256];\n    myBitmap bmp;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    ShowWindow( GetConsoleWindow(), SW_MAXIMIZE );\n    srand( GetTickCount() );\n    mSquares s; s.draw();\n    return system( \"pause\" );\n}\n//--------------------------------------------------------------------------------------------------\n\n", "explain": "\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Java", "code": "\nLibrary: Swing\n\nimport java.awt.Color;\nimport java.awt.Graphics;\n\nimport javax.swing.JFrame;\nimport javax.swing.JPanel;\n\npublic class XorPattern extends JFrame{\n    private JPanel xorPanel;\n\n    public XorPattern(){\n        xorPanel = new JPanel(){\n            @Override\n            public void paint(Graphics g) {\n                for(int y = 0; y < getHeight();y++){\n                    for(int x = 0; x < getWidth();x++){\n                        g.setColor(new Color(0, (x ^ y) % 256, 0));\n                        g.drawLine(x, y, x, y);\n                    }\n                }\n            }\n        };\n        add(xorPanel);\n        setSize(300, 300);\n        setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n        setVisible(true);\n    }\n\n    public static void main(String[] args){\n        new XorPattern();\n    }\n}\n\n\n", "explain": "This example will repeat the pattern if you expand the window.\n\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "C#", "code": "\nusing System.Drawing;\nusing System.Drawing.Imaging;\nusing System.Linq;\n\nclass XORPattern\n{\n    static void Main()\n    {\n        var size = 0x100;\n        var black = Color.Black.ToArgb();\n        var palette = Enumerable.Range(black, size).Select(Color.FromArgb).ToArray();\n        using (var image = new Bitmap(size, size))\n        {\n            for (var x = 0; x < size; x++)\n            {\n                for (var y = 0; y < size; y++)\n                {\n                    image.SetPixel(x, y, palette[x ^ y]);\n                }\n            }\n            image.Save(\"XORPatternCSharp.png\", ImageFormat.Png);\n        }\n    }\n}\n\n\nOutput:\n\n", "explain": "\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "PHP", "code": "\nheader(\"Content-Type: image/png\");\n\n$w = 256;\n$h = 256;\n\n$im = imagecreate($w, $h)\n    or die(\"Cannot Initialize new GD image stream\");\n\n$color = array();\nfor($i=0;$i<256;$i++)\n{\n        array_push($color,imagecolorallocate($im,sin(($i)*(2*3.14/256))*128+128,$i/2,$i));\n}\n\nfor($i=0;$i<$w;$i++)\n{\n        for($j=0;$j<$h;$j++)\n        {\n                imagesetpixel($im,$i,$j,$color[$i^$j]);\n        }\n}\n\nimagepng($im);\nimagedestroy($im);\n\n\nOutput:\n\n", "explain": "\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "MATLAB", "code": "\nsize = 256;\n[x,y] = meshgrid([0:size-1]);\n\nc = bitxor(x,y);\n\ncolormap bone(size);\nimage(c);\naxis equal;\n\n\nOutput: \n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"image\"\n    \"image/png\"\n    \"os\"\n)\n\nfunc main() {\n    g := image.NewGray(image.Rect(0, 0, 256, 256))\n    for i := range g.Pix {\n        g.Pix[i] = uint8(i>>8 ^ i)\n    }\n    f, _ := os.Create(\"xor.png\")\n    png.Encode(f, g)\n    f.Close()\n}\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Delphi", "code": "\nWorks with: Delphi version 6.0\nLibrary: Windows,Types,ExtCtrls,Graphics\n\nprocedure MunchingSquares(Image: TImage);\n{XOR's X and Y to select an RGB level}\nvar W,H,X,Y: integer;\nbegin\nW:=Image.Width;\nH:=Image.Height;\nfor Y:=0 to Image.Height-1 do\n for X:=0 to Image.Width-1 do\n\tbegin\n\tImage.Canvas.Pixels[X,Y]:=RGB(0,X xor Y,0);\n\tend;\nend;\n\n\nOutput:\n\n\n\n\n", "explain": "\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Ruby", "code": "\n\nSample output from Ruby program\nload 'raster_graphics.rb'\n\nclass Pixmap\n  def self.xor_pattern(width, height, rgb1, rgb2)\n    # create colour table\n    size = 256\n    colours = Array.new(size) do |i|\n      RGBColour.new(\n        (rgb1.red + (rgb2.red - rgb1.red) * i / size), \n        (rgb1.green + (rgb2.green - rgb1.green) * i / size), \n        (rgb1.blue + (rgb2.blue - rgb1.blue) * i / size), \n      )\n    end\n\n    # create the image\n    pixmap = new(width, height)\n    pixmap.each_pixel do |x, y|\n      pixmap[x,y] = colours[(x^y)%size]\n    end\n    pixmap\n  end\nend\n\nimg = Pixmap.xor_pattern(384, 384, RGBColour::RED, RGBColour::YELLOW)\nimg.save_as_png('xorpattern.png')\n\n", "explain": "Uses Raster graphics operations/Ruby\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Rust", "code": "\nextern crate image;\n\nuse image::{ImageBuffer, Pixel, Rgb};\n\nfn main() {\n    let mut img = ImageBuffer::new(256, 256);\n\n    for x in 0..256 {\n        for y in 0..256 {\n            let pixel = Rgb::from_channels(0, x as u8 ^ y as u8, 0, 0);\n            img.put_pixel(x, y, pixel);\n        }\n    }\n\n    let _ = img.save(\"output.png\");\n}\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Ada", "code": "\nLibrary: GtkAda\n\nwith Cairo; use Cairo;\nwith Cairo.Png; use Cairo.Png;\nwith Cairo.Image_Surface; use Cairo.Image_Surface;\nprocedure XorPattern is\n   type xorable is mod 256;\n   Surface : Cairo_Surface;\n   Data : RGB24_Array_Access;\n   Status : Cairo_Status;\n   Num : Byte;\nbegin\n   Data := new RGB24_Array(0..256*256-1);\n   for x in Natural range 0..255 loop\n      for y in Natural range 0..255 loop\n         Num := Byte(xorable(x) xor xorable(y));\n         Data(x+256*y) := RGB24_Data'(Num,0,Num);\n      end loop;\n   end loop;\n   Surface := Create_For_Data_RGB24(Data, 256, 256);\n   Status := Write_To_Png (Surface, \"AdaXorPattern.png\");\n   pragma Assert (Status = Cairo_Status_Success);\nend XorPattern;\n\n\nOutput: \n", "explain": "Uses the Cairo component of GtkAda to create and save as png\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Julia", "code": "\nusing Gtk, Cairo\n\nconst can = @GtkCanvas()\nconst win = GtkWindow(can, \"Munching Squares\", 512, 512)\n\n@guarded draw(can) do widget\n    ctx = getgc(can)\n    for x in 0:255, y in 0:255\n        set_source_rgb(ctx, abs(255 - x - y) / 255, ((255 - x) \u22bb y) / 255, (x \u22bb (255 - y)) / 255)\n        circle(ctx, 2x, 2y, 2)\n        fill(ctx)\n    end\nend\n\nshow(can)\nconst cond = Condition()\nendit(w) = notify(cond)\nsignal_connect(endit, win, :destroy)\nwait(cond)\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Kotlin", "code": "\n// version 1.1.4-3\n\nimport javax.swing.JFrame\nimport javax.swing.JPanel\nimport java.awt.Graphics\nimport java.awt.Graphics2D\nimport java.awt.Color\nimport java.awt.Dimension\nimport java.awt.BorderLayout\nimport java.awt.RenderingHints\nimport javax.swing.SwingUtilities\n\nclass XorPattern : JPanel() {\n\n    init {\n        preferredSize = Dimension(256, 256)\n        background = Color.white\n    }\n\n    override fun paint(gg: Graphics) {\n        super.paintComponent(gg)\n        val g = gg as Graphics2D\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, \n                           RenderingHints.VALUE_ANTIALIAS_ON)\n        for (y in 0 until width) {\n            for (x in 0 until height) {\n                g.color = Color(0, (x xor y) % 256, 255)\n                g.drawLine(x, y, x, y)\n            }\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater {\n        val f = JFrame()\n        with (f) {\n            defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n            title = \"Munching squares\"\n            isResizable = false\n            add(XorPattern(), BorderLayout.CENTER)\n            pack()\n            setLocationRelativeTo(null)\n            isVisible = true\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Perl", "code": "\nuse GD;\n\nmy $img = GD::Image->new(256, 256, 1);\n\nfor my $y (0..255) {\n        for my $x (0..255) {\n                my $color = $img->colorAllocate( abs(255 - $x - $y),  (255-$x) ^ $y , $x ^ (255-$y));\n                $img->setPixel($x, $y, $color);\n        }\n}\n\nprint $img->png\n\n\nOutput: \n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Prolog", "code": "\n\nxor_pattern :-\n\tnew(D, window('XOR Pattern')),\n\tsend(D, size, size(512,512)),\n\tnew(Img, image(@nil, width := 512, height := 512 , kind := pixmap)),\n\n\tforall(between(0,511, I),\n\t       (   forall(between(0,511, J),\n\t\t\t  (   V is I xor J,\n\t\t\t      R is (V * 1024) mod 65536,\n\t\t\t      G is (65536 - V * 1024) mod 65536,\n\t\t\t      (\t  V mod 2 =:= 0\n\t\t\t      ->  B is  (V * 4096) mod 65536\n\t\t\t      ;\t   B is  (65536 - (V * 4096)) mod 65536),\n\t\t\t      send(Img, pixel(I, J, colour(@default, R, G, B))))))),\n\n\tnew(Bmp, bitmap(Img)),\n\tsend(D, display, Bmp, point(0,0)),\n\tsend(D, open).\n\n\n", "explain": "Works with SWI-Prolog and his GUI XPCE.\n\n"}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Lua", "code": "\nWorks with: L\u00d6VE version 11.0 or higher\nlocal clr =  {}\nfunction drawMSquares()\n\tlocal points = {}\n\tfor y = 0, hei-1 do\n\t\tfor x = 0, wid-1 do\n\t\t\tlocal idx = bit.bxor(x, y)%256\n\t\t\tlocal r, g, b = clr[idx][1], clr[idx][2], clr[idx][3]\n\t\t\tlocal point = {x+1, y+1, r/255, g/255, b/255, 1}\n\t\t\ttable.insert (points, point)\n\t\tend\n\tend\n\tlove.graphics.points(points)\nend\n\nfunction createPalette()\n\tfor i = 0, 255 do\n\t\tclr[i] = {i*2.8%256, i*3.2%256, i*1.5%256}\n\tend\nend\n\nfunction love.load()\n\twid, hei = 256, 256\n\tlove.window.setMode(wid, hei)\n\tcanvas = love.graphics.newCanvas()\n\tlove.graphics.setCanvas(canvas)\n\t\tcreatePalette()\n\t\tdrawMSquares()\n\tlove.graphics.setCanvas()\nend\n\nfunction love.draw()\n\tlove.graphics.setColor(1,1,1)\n\tlove.graphics.draw(canvas)\nend\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Scala", "code": "\nScala Swing[edit]\nLibrary: org.scala-lang.modules scala-swing\nimport scala.swing.Swing.pair2Dimension\nimport scala.swing.{Color, Graphics2D, MainFrame, Panel, SimpleSwingApplication}\n\nobject XorPattern extends SimpleSwingApplication {\n\n  def top = new MainFrame {\n    preferredSize = (300, 300)\n    title = \"Rosetta Code >>> Task: Munching squares | Language: Scala\"\n    contents = new Panel {\n\n      protected override def paintComponent(g: Graphics2D) = {\n        super.paintComponent(g)\n        for {\n          y <- 0 until size.getHeight.toInt\n          x <- 0 until size.getWidth.toInt\n        } {\n          g.setColor(new Color(0, (x ^ y) % 256, 0))\n          g.drawLine(x, y, x, y)\n        }\n      }\n    }\n\n    centerOnScreen()\n  }\n}\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "D", "code": "\nvoid main() {\n    import std.stdio;\n\n    enum width = 512, height = 512;\n\n    auto f = File(\"xor_pattern.ppm\", \"wb\");\n    f.writefln(\"P6\\n%d %d\\n255\", width, height);\n    foreach (immutable y; 0 .. height)\n        foreach (immutable x; 0 .. width) {\n            immutable c = (x ^ y) & ubyte.max;\n            immutable ubyte[3] u3 = [255 - c, c / 2, c];\n            f.rawWrite(u3);\n        }\n}\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "Haskell", "code": "\nimport qualified Data.ByteString as BY (writeFile, pack)\n\nimport Data.Bits (xor)\n\nmain :: IO ()\nmain =\n  BY.writeFile\n    \"out.pgm\"\n    (BY.pack\n       (fmap (fromIntegral . fromEnum) \"P5\\n256 256\\n256\\n\" ++\n        [ x `xor` y\n        | x <- [0 .. 255] \n        , y <- [0 .. 255] ]))\n\n", "explain": ""}, {"task_name": "Munching squares", "task_url": "https://rosettacode.org/wiki/Munching_squares", "task_cat": "Graphics algorithms", "lang": "AWK", "code": "\nWorks with: gawk\n\nBEGIN {\n    # square size\n    s = 256\n    # the PPM image header needs 3 lines:\n    # P3\n    # width height\n    # max colors number (per channel)\n    print(\"P3\\n\", s, s, \"\\n\", s - 1)\n    # and now we generate pixels as a RGB pair in a relaxed\n    # form \"R G B\\n\"\n    for (x = 0; x < s; x++) { \n        for (y = 0; y < s; y++) {\n            p = xor(x, y)\n            print(0, p, p)\n        }\n    }\n}\n\n", "explain": "This program generates a PPM image, that you can view/convert using The GIMP or ImageMagick\n"}]