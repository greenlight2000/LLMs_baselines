[{"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Python", "code": "\nWorks with: Python version 3.0.Works with: Python version 2.6\ndef F(n): return 1 if n == 0 else n - M(F(n-1))\ndef M(n): return 0 if n == 0 else n - F(M(n-1))\n\nprint ([ F(n) for n in range(20) ])\nprint ([ M(n) for n in range(20) ])\n\n\nOutput:\n[1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12]\n[0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12]\n\n", "explain": "In python there is no need to pre-declare M for it to be used in the definition of F. (However M must be defined before F calls it).\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n\n/* let us declare our functions; indeed here we need\n   really only M declaration, so that F can \"see\" it\n   and the compiler won't complain with a warning */\nint F(const int n);\nint M(const int n);\n\nint F(const int n)\n{\n  return (n == 0) ? 1 : n - M(F(n - 1));\n}\n\nint M(const int n)\n{\n  return (n == 0) ? 0 : n - F(M(n - 1));\n}\n\nint main(void)\n{\n  int i;\n  for (i = 0; i < 20; i++)\n    printf(\"%2d \", F(i));\n  printf(\"\\n\");\n  for (i = 0; i < 20; i++)\n    printf(\"%2d \", M(i));\n  printf(\"\\n\");\n  return EXIT_SUCCESS;\n}\n\n", "explain": "To let C see functions that will be used, it is enough to declare them. Normally this is done in a header file; in this example we do it directly in the code. If we do not declare them explicitly, they get an implicit declaration (if implicit declaration matches the use, everything's fine; but it is better however to write an explicit declaration)\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "C++", "code": "\n\n#include <iostream>\n#include <vector>\n#include <iterator>\n\nclass Hofstadter\n{\npublic:\n  static int F(int n) {\n    if ( n == 0 ) return 1;\n    return n - M(F(n-1));\n  }\n  static int M(int n) {\n    if ( n == 0 ) return 0;\n    return n - F(M(n-1));\n  }\n};\n\nusing namespace std;\n\nint main()\n{\n  int i;\n  vector<int> ra, rb;\n\n  for(i=0; i < 20; i++) {\n    ra.push_back(Hofstadter::F(i));\n    rb.push_back(Hofstadter::M(i));\n  }\n  copy(ra.begin(), ra.end(),\n       ostream_iterator<int>(cout, \" \"));\n  cout << endl;\n  copy(rb.begin(), rb.end(),\n       ostream_iterator<int>(cout, \" \"));\n  cout << endl;\n  return 0;\n}\n\n\nclass Hofstadter\n{\npublic:\n  static int F(int n);\n  static int M(int n);\n};\n\nint Hofstadter::F(int n)\n{\n  if ( n == 0 ) return 1;\n  return n - M(F(n-1));\n}\n\nint Hofstadter::M(int n)\n{\n  if ( n == 0 ) return 0;\n  return n - F(M(n-1));\n}\n\n", "explain": "C++ has prior declaration rules similar to those stated above for C, if we would use two functions. Instead here we define M and F as static (class) methods of a class, and specify the bodies inline in the declaration of the class. Inlined methods in the class can still call other methods or access fields in the class, no matter what order they are declared in, without any additional pre-declaration. This is possible because all the possible methods and fields are declared somewhere in the class declaration, which is known the first time the class declaration is parsed.\nThe following version shows better what's going on and why we seemingly didn't need pre-declaration (like C) when \"encapsulating\" the functions as static (class) methods.\nThis version is equivalent to the above but does not inline the definition of the methods into the definition of the class. Here the method declarations in the class definition serves as the \"pre-declaration\" for the methods, as in C.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Java", "code": "\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class MutualRecursion {\n\n    public static void main(final String args[]) {\n        int max = 20;\n        System.out.printf(\"First %d values of the Female sequence:  %n\", max);\n        for (int i = 0; i < max; i++) {\n            System.out.printf(\"  f(%d) = %d%n\", i, f(i));\n        }\n        System.out.printf(\"First %d values of the Male sequence:  %n\", max);\n        for (int i = 0; i < 20; i++) {\n            System.out.printf(\"  m(%d) = %d%n\", i, m(i));\n        }\n    }\n\n    private static Map<Integer,Integer> F_MAP = new HashMap<>();\n\n    private static int f(final int n) {\n        if ( F_MAP.containsKey(n) ) {\n            return F_MAP.get(n);\n        }\n        int fn = n == 0 ? 1 : n - m(f(n - 1));\n        F_MAP.put(n, fn);\n        return fn;\n    }\n\n    private static Map<Integer,Integer> M_MAP = new HashMap<>();\n\n    private static int m(final int n) {\n        if ( M_MAP.containsKey(n) ) {\n            return M_MAP.get(n);\n        }\n        int mn = n == 0 ? 0 : n - f(m(n - 1));\n        M_MAP.put(n, mn);\n        return mn;\n    }\n     \n\n}\n\n\nOutput:\n\n f(0) = 1\n f(1) = 1\n f(2) = 2\n f(3) = 2\n f(4) = 3\n f(5) = 3\n f(6) = 4\n f(7) = 5\n f(8) = 5\n f(9) = 6\n f(10) = 6\n f(11) = 7\n f(12) = 8\n f(13) = 8\n f(14) = 9\n f(15) = 9\n f(16) = 10\n f(17) = 11\n f(18) = 11\n f(19) = 12\n\n\n m(0) = 0\n m(1) = 0\n m(2) = 1\n m(3) = 2\n m(4) = 2\n m(5) = 3\n m(6) = 4\n m(7) = 4\n m(8) = 5\n m(9) = 6\n m(10) = 6\n m(11) = 7\n m(12) = 7\n m(13) = 8\n m(14) = 9\n m(15) = 9\n m(16) = 10\n m(17) = 11\n m(18) = 11\n m(19) = 12\n\n", "explain": "Replace translation (that doesn't compile) with a Java native implementation.\nFirst 20 values of the Female sequence:  \nFirst 20 values of the Male sequence:  \n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "C#", "code": "\nnamespace RosettaCode {\n    class Hofstadter {\n        static public int F(int n) {\n            int result = 1;\n            if (n > 0) {\n                result = n - M(F(n-1));\n            }\n\n            return result;\n        }\n\n        static public int M(int n) {\n            int result = 0;\n            if (n > 0) {\n                result = n - F(M(n - 1));\n            }\n\n            return result;\n        }\n    }\n}\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "JavaScript", "code": "\nfunction f(num) {\n return (num === 0) ? 1 : num - m(f(num - 1));\n}\n\nfunction m(num) {\n return (num === 0) ? 0 : num - f(m(num - 1));\n}\n\nfunction range(m, n) {\n  return Array.apply(null, Array(n - m + 1)).map(\n    function (x, i) { return m + i; }\n  );\n}\n\nvar a = range(0, 19);\n\n//return a new array of the results and join with commas to print\nconsole.log(a.map(function (n) { return f(n); }).join(', '));\nconsole.log(a.map(function (n) { return m(n); }).join(', '));\n\n\nOutput:\n1,1,2,2,3,3,4,5,5,6,6,7,8,8,9,9,10,11,11,12\n0,0,1,2,2,3,4,4,5,6,6,7,7,8,9,9,10,11,11,12\n\nvar f = num => (num === 0) ? 1 : num - m(f(num - 1));\nvar m = num => (num === 0) ? 0 : num - f(m(num - 1));\n\nfunction range(m, n) {\n  return Array.apply(null, Array(n - m + 1)).map(\n    function (x, i) { return m + i; }\n  );\n}\n\nvar a = range(0, 19);\n\n//return a new array of the results and join with commas to print\nconsole.log(a.map(n => f(n)).join(', '));\nconsole.log(a.map(n => m(n)).join(', '));\n\n\nvar range = (m, n) => Array(... Array(n - m + 1)).map((x, i) => m + i)\n\n", "explain": "ES6 implementation\nMore ES6 implementation\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "PHP", "code": "\n<?php\nfunction F($n)\n{\n  if ( $n == 0 ) return 1;\n  return $n - M(F($n-1));\n}\n\nfunction M($n)\n{\n  if ( $n == 0) return 0;\n  return $n - F(M($n-1));\n}\n\n$ra = array();\n$rb = array();\nfor($i=0; $i < 20; $i++)\n{\n  array_push($ra, F($i));\n  array_push($rb, M($i));\n}\necho implode(\" \", $ra) . \"\\n\";\necho implode(\" \", $rb) . \"\\n\";\n?>\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "MATLAB", "code": "\n\nfunction Fn = female(n)\n\n    if n == 0\n        Fn = 1;\n        return\n    end\n    \n    Fn = n - male(female(n-1));\nend\n\n\nfunction Mn = male(n)\n    \n    if n == 0\n        Mn = 0;\n        return\n    end\n    \n    Mn = n - female(male(n-1));\nend\n\n\nOutput:\n>> n = (0:10);\n>> arrayfun(@female,n)\n\nans =\n\n     1     1     2     2     3     3     4     5     5     6     6\n\n>> arrayfun(@male,n)\n\nans =\n\n     0     0     1     2     2     3     4     4     5     6     6\n\n", "explain": "female.m:\nmale.m:\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Fortran", "code": "\n\nWorks with: Fortran version 95 and later\nmodule MutualRec\n  implicit none\ncontains\n  pure recursive function m(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 0\n       return\n    end if\n    r = n - f(m(n-1))\n  end function m\n  \n  pure recursive function f(n) result(r)\n    integer :: r\n    integer, intent(in) :: n\n    if ( n == 0 ) then\n       r = 1\n       return\n    end if\n    r = n - m(f(n-1))\n  end function f\n\nend module\n\n\nprogram testmutrec\n  use MutualRec\n  implicit none\n\n  integer :: i\n  integer, dimension(20) :: a = (/ (i, i=0,19) /), b = (/ (i, i=0,19) /)\n  integer, dimension(20) :: ra, rb\n  \n  forall(i=1:20) \n     ra(i) = m(a(i))\n     rb(i) = f(b(i))\n  end forall\n\n  write(*,'(20I3)') rb\n  write(*,'(20I3)') ra\n  \nend program testmutrec\n\n", "explain": "As long as the code of the two functions is inside the same \"block\" (module or program) we don't need special care. Otherwise, we should \"load\" at least the interface of the other function (each module will load mutually the other; of course the compiler won't enter in a infinite loop), e.g. by using a \"use\" (we do that if M and F function are inside different modules)\nI've added the attribute pure so that we can use them in a forall statement.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Go", "code": "\n\npackage main\nimport \"fmt\"\n\nfunc F(n int) int {\n  if n == 0 { return 1 }\n  return n - M(F(n-1))\n}\n\nfunc M(n int) int {\n  if n == 0 { return 0 }\n  return n - F(M(n-1))\n}\n\nfunc main() {\n  for i := 0; i < 20; i++ {\n    fmt.Printf(\"%2d \", F(i))\n  }\n  fmt.Println()\n  for i := 0; i < 20; i++ {\n    fmt.Printf(\"%2d \", M(i))\n  }\n  fmt.Println()\n}\n\n", "explain": "It just works. No special pre-declaration is necessary.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "ARM_Assembly", "code": "\n\n.text\n.global _start\n\t@@@\tImplementation of F(n), n in R0. n is considered unsigned.\nF:\ttst\tr0,r0\t\t@ n = 0?\n\tmoveq\tr0,#1\t\t@ In that case, the result is 1\n\tbxeq\tlr\t\t@ And we can return to the caller\n\tpush\t{r0,lr}\t\t@ Save link register and argument to stack\n\tsub\tr0,r0,#1\t@ r0 -= 1    = n-1\n\tbl\tF\t\t@ r0 = F(r0) = F(n-1)\n\tbl\tM\t\t@ r0 = M(r0) = M(F(n-1))\n\tpop\t{r1,lr}\t\t@ Restore link register and argument in r1\n\tsub\tr0,r1,r0\t@ Result is n-F(M(n-1))\n\tbx\tlr\t\t@ Return to caller.\n\n\t@@@\tImplementation of M(n), n in R0. n is considered unsigned.\nM:\ttst\tr0,r0\t\t@ n = 0?\n\tbxeq\tlr\t\t@ In that case the result is also 0; return.\n\tpush\t{r0,lr}\t\t@ Save link register and argument to stack\n\tsub\tr0,r0,#1\t@ r0 -= 1    = n-1\n\tbl\tM\t\t@ r0 = M(r0) = M(n-1)\n\tbl\tF\t\t@ r0 = M(r0) = F(M(n-1))\n\tpop\t{r1,lr}\t\t@ Restore link register and argument in r1\n\tsub\tr0,r1,r0\t@ Result is n-M(F(n-1))\n\tbx\tlr\t\t@ Return to caller\n\n\t@@@\tPrint F(0..15) and M(0..15)\n_start:\tldr\tr1,=fmsg\t@ Print values for F\n\tldr\tr4,=F\n\tbl\tprfn\n\tldr\tr1,=mmsg\t@ Print values for M\n\tldr\tr4,=M\n\tbl\tprfn\n\tmov\tr7,#1\t\t@ Exit process\n\tswi\t#0\n\t\n\t@@@\tHelper function for output: print [r1], then [r4](0..15)\n\t@@@\tThis assumes [r4] preserves r3 and r4; M and F do.\nprfn:\tpush\t{lr}\t\t@ Keep link register\n\tbl\tpstr\t\t@ Print the string\n\tmov\tr3,#0\t\t@ Start at 0\n1:\tmov\tr0,r3\t\t@ Call the function in r4 with current number\t\n\tblx\tr4\n\tadd\tr0,r0,#'0\t@ Make ASCII digit\n\tldr\tr1,=dgt\t\t@ Store in digit string\n\tstrb\tr0,[r1]\n\tldr\tr1,=dstr\t@ Print result\n\tbl\tpstr\n\tadd\tr3,r3,#1\t@ Next number\n\tcmp\tr3,#15\t\t@ Keep going up to and including 15\n\tbls\t1b\n\tldr\tr1,=nl\t\t@ Print newline afterwards\n\tbl\tpstr\n\tpop\t{pc}\t\t@ Return to address on stack\n\t@@@\tPrint length-prefixed string r1 to stdout\npstr:\tpush\t{lr}\t\t@ Keep link register\n\tmov\tr0,#1\t\t@ stdout = 1\n\tldrb\tr2,[r1],#1\t@ r2 = length prefix\n\tmov\tr7,#4\t\t@ 4 = write syscall\n\tswi\t#0\n\tpop\t{pc}\t\t@ Return to address on stack\n.data\nfmsg:\t.ascii\t\"\\3F: \"\nmmsg:\t.ascii\t\"\\3M: \"\ndstr:\t.ascii\t\"\\2\"\ndgt:\t.ascii\t\"* \"\nnl:\t.ascii \t\"\\1\\n\"\n\n\nOutput:\nF: 1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9\nM: 0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9\n", "explain": "Unlike on the x86 family of processors, the ARM instruction set does not include specialized\ncall and ret instructions. However, the program counter is a visible\nregister (r15, also called pc), so it can be loaded and saved\nas any other. Nor is there a specialized stack pointer, though the load and store instructions offer\npre- and postincrement as well as pre- and postdecrement on the register used as a pointer, making\nany register usable as a stack pointer.\nBy convention, r13 is used as the system stack pointer and is therefore also\ncalled sp, and r14 is used to store the return address for\na function, and is therefore also called the *link register* or lr.\nThe assembler recognizes push {x} and pop {x} instructions, though these\nare really pseudoinstructions, that generate the exact same machine code as \nldmia r13!,{x} and stmdb r13!,{x},\nthese being, respectively, load with postincrement and store with predecrement on r13.\nThe link register is slightly special in that there is a family of branch-and-link instructions\n(bl). These are the same as mov r14,pc\u00a0; mov/ldr pc,<destination>, but in\none machine instruction instead of two. This is the general way of calling subroutines,\nmeaning no stack access is necessary unless the subroutine wants to call others in turn, in which case\nthe link register must be saved by hand (as the code below shows several ways of doing).\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Delphi", "code": "\nunit Hofstadter;\n\ninterface\n\ntype\n  THofstadterFemaleMaleSequences = class\n  public\n    class function F(n: Integer): Integer;\n    class function M(n: Integer): Integer;\n  end;\n\nimplementation\n\nclass function THofstadterFemaleMaleSequences.F(n: Integer): Integer;\nbegin\n  Result:= 1;\n  if (n > 0) then\n    Result:= n - M(F(n-1));\nend;\n\nclass function THofstadterFemaleMaleSequences.M(n: Integer): Integer;\nbegin\n  Result:= 0;\n  if (n > 0) then\n    Result:= n - F(M(n - 1));\nend;\n\nend.\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Ruby", "code": "\ndef F(n)\n  n == 0\u00a0? 1\u00a0: n - M(F(n-1))\nend\ndef M(n)\n  n == 0\u00a0? 0\u00a0: n - F(M(n-1))\nend\n\np (Array.new(20) {|n| F(n) })\np (Array.new(20) {|n| M(n) })\n\nOutput:\n[1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12]\n[0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12]\n\n", "explain": "In ruby there is no need to pre-declare M for it to be used in the definition of F. (However M must be defined before F calls it).\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Rust", "code": "\nfn f(n: u32) -> u32 {\n    match n {\n        0 => 1,\n        _ => n - m(f(n - 1))\n    }\n}\n\nfn m(n: u32) -> u32 {\n    match n {\n        0 => 0,\n        _ => n - f(m(n - 1))\n    }\n}\n\nfn main() {\n    for i in (0..20).map(f) {\n        print!(\"{} \", i);\n    }\n    println!(\"\");\n\n    for i in (0..20).map(m) {\n        print!(\"{} \", i);\n    }\n    println!(\"\")\n}\n\nOutput:\n1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12\n0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Swift", "code": "\n\nfunc F(n: Int) -> Int {\n  return n == 0\u00a0? 1\u00a0: n - M(F(n-1))\n}\n\nfunc M(n: Int) -> Int {\n  return n == 0\u00a0? 0\u00a0: n - F(M(n-1))\n}\n\nfor i in 0..20 {\n  print(\"\\(F(i)) \")\n}\nprintln()\nfor i in 0..20 {\n  print(\"\\(M(i)) \")\n}\nprintln()\n", "explain": "It just works. No special pre-declaration is necessary.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "R", "code": "\nF <- function(n) ifelse(n == 0, 1, n - M(F(n-1)))\nM <- function(n) ifelse(n == 0, 0, n - F(M(n-1)))\n\nprint.table(lapply(0:19, M))\nprint.table(lapply(0:19, F))\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Ada", "code": "\nwith Ada.Text_Io; use Ada.Text_Io; \nprocedure Mutual_Recursion is\n   function M(N : Integer) return Integer;\n   function F(N : Integer) return Integer is\n   begin\n      if N = 0 then\n         return 1;\n      else\n         return N - M(F(N - 1));\n      end if;\n   end F;\n   function M(N : Integer) return Integer is\n   begin\n      if N = 0 then\n         return 0;\n      else\n         return N - F(M(N-1));\n      end if;\n   end M;\nbegin\n   for I in 0..19 loop\n      Put_Line(Integer'Image(F(I)));\n   end loop;\n   New_Line;\n   for I in 0..19 loop\n      Put_Line(Integer'Image(M(I)));\n   end loop;\nend Mutual_recursion;\n\nWorks with: Ada 2012\nwith Ada.Text_Io; use Ada.Text_Io;\nprocedure Mutual_Recursion is\n   function M(N: Natural) return Natural;\n   function F(N: Natural) return Natural;\n \n   function M(N: Natural) return Natural is\n       (if N = 0 then 0 else N \u2013 F(M(N\u20131)));\n \n   function F(N: Natural) return Natural is\n       (if N =0 then 1 else N \u2013 M(F(N\u20131)));\nbegin\n   for I in 0..19 loop\n      Put_Line(Integer'Image(F(I)));\n   end loop;\n   New_Line;\n   for I in 0..19 loop\n      Put_Line(Integer'Image(M(I)));\n   end loop;\n   \nend Mutual_recursion;\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Julia", "code": "\nF(n) = n < 1 ? one(n) : n - M(F(n - 1))\nM(n) = n < 1 ? zero(n) : n - F(M(n - 1))\n\n\nOutput:\njulia> [F(i) for i = 0:19], [M(i) for i = 0:19]\n([1,1,2,2,3,3,4,5,5,6,6,7,8,8,9,9,10,11,11,12],[0,0,1,2,2,3,4,4,5,6,6,7,7,8,9,9,10,11,11,12])\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Kotlin", "code": "\n// version 1.0.6\n\nfun f(n: Int): Int = \n    when {\n        n == 0 -> 1\n        else   -> n - m(f(n - 1))\n    }\n\nfun m(n: Int): Int =\n    when {\n        n == 0 -> 0\n        else   -> n - f(m(n - 1))\n    }\n\nfun main(args: Array<String>) {\n    val n = 24\n    print(\"n\u00a0:\")\n    for (i in 0..n) print(\"%3d\".format(i))\n    println()\n    println(\"-\".repeat(78))\n    print(\"F\u00a0:\") \n    for (i in 0..24) print(\"%3d\".format(f(i)))\n    println()\n    print(\"M\u00a0:\") \n    for (i in 0..24) print(\"%3d\".format(m(i)))\n    println()\n}\n\n\nOutput:\nn\u00a0:  0  1  2  3  4  5  6  7  8  9 10 11 12 13 14 15 16 17 18 19 20 21 22 23 24\n------------------------------------------------------------------------------\nF\u00a0:  1  1  2  2  3  3  4  5  5  6  6  7  8  8  9  9 10 11 11 12 13 13 14 14 15\nM\u00a0:  0  0  1  2  2  3  4  4  5  6  6  7  7  8  9  9 10 11 11 12 12 13 14 14 15\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Perl", "code": "\nsub F { my $n = shift; $n ? $n - M(F($n-1)) : 1 }\nsub M { my $n = shift; $n ? $n - F(M($n-1)) : 0 }\n\n# Usage:\nforeach my $sequence (\\&F, \\&M) {\n    print join(' ', map $sequence->($_), 0 .. 19), \"\\n\";\n}\n\n\nOutput:\n1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12 \n0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12 \n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Objective-C", "code": "\n\n#import <Foundation/Foundation.h>\n\n@interface Hofstadter\u00a0: NSObject\n+ (int)M: (int)n;\n+ (int)F: (int)n;\n@end\n\n@implementation Hofstadter\n+ (int)M: (int)n\n{\n  if ( n == 0 ) return 0;\n  return n - [self F: [self M: (n-1)]];\n}\n+ (int)F: (int)n\n{\n  if ( n == 0 ) return 1;\n  return n - [self M: [self F: (n-1)]];\n}\n@end\n\nint main()\n{\n  int i;\n\n  for(i=0; i < 20; i++) {\n    printf(\"%3d \", [Hofstadter F: i]);\n  }\n  printf(\"\\n\");\n  for(i=0; i < 20; i++) {\n    printf(\"%3d \", [Hofstadter M: i]);\n  }\n  printf(\"\\n\");\n  return 0;\n}\n\n", "explain": "Objective-C has prior declaration rules similar to those stated above for C, for C-like types. In this example we show the use of a two class method; this works since we need an interface block that is like declaration of functions in C code.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Prolog", "code": "\nfemale(0,1).\nfemale(N,F) :- N>0, \n\t       N1 is N-1, \n\t       female(N1,R),\n\t       male(R, R1),\n\t       F is N-R1.\n\nmale(0,0).\nmale(N,F) :- N>0, \n\t     N1 is N-1, \n\t     male(N1,R),\n\t     female(R, R1),\n\t     F is N-R1.\n\nWorks with: GNU Prolog\nflist(S) :- for(X, 0, S), female(X, R), format('~d ', [R]), fail.\nmlist(S) :- for(X, 0, S), male(X, R), format('~d ', [R]), fail.\n\n\n|\u00a0?- flist(19).\n1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12 \n\nno\n|\u00a0?- mlist(19).\n0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12\n", "explain": "Testing\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Lua", "code": "\nfunction m(n) return n > 0 and n - f(m(n-1)) or 0 end\nfunction f(n) return n > 0 and n - m(f(n-1)) or 1 end\n\n\nlocal m,n\nfunction m(n) return n > 0 and n - f(m(n-1)) or 0 end\nfunction f(n) return n > 0 and n - m(f(n-1)) or 1 end\n\n", "explain": "It is important to note, that if m and f are to be locally scoped functions rather than global, that they would need to be forward declared:\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Scala", "code": "\ndef F(n:Int):Int =\n  if (n == 0) 1 else n - M(F(n-1))\ndef M(n:Int):Int =\n  if (n == 0) 0 else n - F(M(n-1))\n\nprintln((0 until 20).map(F).mkString(\", \"))\nprintln((0 until 20).map(M).mkString(\", \"))\n\nOutput:\n1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12\n0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Dart", "code": "\nint M(int n) => n==0?1:n-F(M(n-1));\nint F(int n) => n==0?0:n-M(F(n-1));\n\nmain() {\n  String f=\"\",m=\"\";\n  for(int i=0;i<20;i++) {\n    m+=\"${M(i)} \";\n    f+=\"${F(i)} \";\n  }\n  print(\"M: $m\");\n  print(\"F: $f\");\n}\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "D", "code": "\nimport std.stdio, std.algorithm, std.range;\n\nint male(in int n) pure nothrow {\n    return n ? n - male(n - 1).female : 0;\n}\n\nint female(in int n) pure nothrow {\n    return n ? n - female(n - 1).male : 1;\n}\n\nvoid main() {\n    20.iota.map!female.writeln;\n    20.iota.map!male.writeln;\n}\n\n\nOutput:\n[1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12]\n[0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12]\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Haskell", "code": "\n\nf 0 = 1\nf n | n > 0 = n - m (f $ n-1)\n\nm 0 = 0 \nm n | n > 0 = n - f (m $ n-1)\n \nmain = do\n       print $ map f [0..19]\n       print $ map m [0..19]\n\n", "explain": "Haskell's definitions constructs (at the top level, or inside a let or where construct) are always mutually-recursive:\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Scheme", "code": "\n\n(define (F n)\n  (if (= n 0) 1\n      (- n (M (F (- n 1))))))\n\n(define (M n)\n  (if (= n 0) 0\n      (- n (F (M (- n 1))))))\n\n(letrec ((F (lambda (n)\n              (if (= n 0) 1\n                  (- n (M (F (- n 1)))))))\n         (M (lambda (n)\n              (if (= n 0) 0\n                  (- n (F (M (- n 1))))))))\n  (F 19)) # evaluates to 12\n\n", "explain": "define declarations are automatically mutually recursive:\nIf you wanted to use a let-like construct to create local bindings, you would do the following. The define construct above is just a syntactic sugar for the following where the entire rest of the scope is used as the body.\nThe letrec indicates that the definitions can be recursive, and fact that we placed these two in the same letrec block makes them mutually recursive.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "PowerShell", "code": "\nfunction F($n) {\n    if ($n -eq 0) { return 1 }\n    return $n - (M (F ($n - 1)))\n}\n\nfunction M($n) {\n    if ($n -eq 0) { return 0 }\n    return $n - (F (M ($n - 1)))\n}\n\n", "explain": ""}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Logo", "code": "\n\nto m :n\n  if 0 = :n [output 0]\n  output :n - f m :n-1\nend\nto f :n\n  if 0 = :n [output 1]\n  output :n - m f :n-1\nend\n\nshow cascade 20 [lput m #-1\u00a0?] []\n[1 1 2 2 3 3 4 5 5 6 6 7 8 8 9 9 10 11 11 12]\nshow cascade 20 [lput f #-1\u00a0?] []\n[0 0 1 2 2 3 4 4 5 6 6 7 7 8 9 9 10 11 11 12]\n", "explain": "Like Lisp, symbols in Logo are late-bound so no special syntax is required for forward references.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "ABAP", "code": "\n\nreport z_mutual_recursion.\n\nclass hoffstadter_sequences definition.\n  public section.\n    class-methods:\n      f\n        importing\n          n             type int4\n        returning\n          value(result) type int4,\n\n      m\n        importing\n          n             type int4\n        returning\n          value(result) type int4.\nendclass.\n\n\nclass hoffstadter_sequences implementation.\n  method f.\n    result = cond int4(\n      when n eq 0\n      then 1\n      else n - m( f( n - 1 ) ) ).\n  endmethod.\n\n\n  method m.\n    result = cond int4(\n      when n eq 0\n      then 0\n      else n - f( m( n - 1 ) ) ).\n  endmethod.\nendclass.\n\n\nstart-of-selection.\n  write: |{ reduce string(\n    init results = |f(0 - 19): { hoffstadter_sequences=>f( 0 ) }|\n    for i = 1 while i < 20\n    next results = |{ results }, { hoffstadter_sequences=>f( i ) }| ) }|, /.\n\n  write: |{ reduce string(\n    init results = |m(0 - 19): { hoffstadter_sequences=>m( 0 ) }|\n    for i = 1 while i < 20\n    next results = |{ results }, { hoffstadter_sequences=>m( i ) }| ) }|, /.\n\n\nOutput:\nf(0 - 19): 1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12\n\nm(0 - 19): 0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12\n\n", "explain": "This works for ABAP Version 7.40 and can be implemented in procedural ABAP as well, but with classes it is much more readable. As this allows a method with a returning value to be an input for a subsequent method call.\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "F#", "code": "\nlet rec f n =\n    match n with\n    | 0 -> 1\n    | _ -> n - (m (f (n-1)))\nand m n =\n    match n with\n    | 0 -> 0\n    | _ -> n - (f (m (n-1)))\n\n\n", "explain": "Like OCaml, the let rec f .. and m ... construct indicates that the functions call themselves (rec) and each other (and).\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "Groovy", "code": "\n\ndef f, m  // recursive closures must be declared before they are defined\nf = { n -> n == 0 ? 1 : n - m(f(n-1)) }\nm = { n -> n == 0 ? 0 : n - f(m(n-1)) }\n\n\nprintln 'f(0..20): ' + (0..20).collect { f(it) }\nprintln 'm(0..20): ' + (0..20).collect { m(it) }\n\n\nOutput:\nf(0..20): [1, 1, 2, 2, 3, 3, 4, 5, 5, 6, 6, 7, 8, 8, 9, 9, 10, 11, 11, 12, 13]\nm(0..20): [0, 0, 1, 2, 2, 3, 4, 4, 5, 6, 6, 7, 7, 8, 9, 9, 10, 11, 11, 12, 12]\n", "explain": "Solution:\nTest program:\n"}, {"task_name": "Mutual recursion", "task_url": "https://rosettacode.org/wiki/Mutual_recursion", "task_cat": "Recursion", "lang": "AWK", "code": "\n\ncat mutual_recursion.awk:\n#!/usr/local/bin/gawk -f\n\n# User defined functions\nfunction F(n)\n{ return n == 0 ? 1 : n - M(F(n-1)) }\n\nfunction M(n)\n{ return n == 0 ? 0 : n - F(M(n-1)) }\n\nBEGIN {\n  for(i=0; i <= 20; i++) {\n    printf \"%3d \", F(i)\n  }\n  print \"\"\n  for(i=0; i <= 20; i++) {\n    printf \"%3d \", M(i)\n  }\n  print \"\"\n}\n\n\nOutput:\n$ awk -f mutual_recursion.awk \n  1   1   2   2   3   3   4   5   5   6   6   7   8   8   9   9  10  11  11  12  13 \n  0   0   1   2   2   3   4   4   5   6   6   7   7   8   9   9  10  11  11  12  12\n\n", "explain": "In AWK it is enough that both functions are defined somewhere. It matters not whether the BEGIN block is before or after the function definitions.\n"}]