[{"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Python", "code": "\nFunctional[edit]\nUsing collections.Counter[edit]\nWorks with: Python version 2.7+ and 3.1+\nimport collections, sys\n\ndef filecharcount(openfile):\n    return sorted(collections.Counter(c for l in openfile for c in l).items())\n\nf = open(sys.argv[1])\nprint(filecharcount(f))\n\nAs a fold[edit]\n\nWorks with: Python version 3\n'''Character counting as a fold'''\n\nfrom functools import reduce\nfrom itertools import repeat\nfrom os.path import expanduser\n\n\n# charCounts\u00a0:: String -> Dict Char Int\ndef charCounts(s):\n    '''A dictionary of\n       (character, frequency) mappings\n    '''\n    def tally(dct, c):\n        dct[c] = 1 + dct[c] if c in dct else 1\n        return dct\n    return reduce(tally, list(s), {})\n\n\n# TEST ----------------------------------------------------\n# main\u00a0:: IO ()\ndef main():\n    '''Listing in descending order of frequency.'''\n\n    print(\n        tabulated(\n            'Descending order of frequency:\\n'\n        )(compose(repr)(fst))(compose(str)(snd))(\n            5\n        )(stet)(\n            sorted(\n                charCounts(\n                    readFile('~/Code/charCount/readme.txt')\n                ).items(),\n                key=swap,\n                reverse=True\n            )\n        )\n    )\n\n\n# GENERIC -------------------------------------------------\n\n# chunksOf\u00a0:: Int -> [a] -> [[a]]\ndef chunksOf(n):\n    '''A series of lists of length n,\n       subdividing the contents of xs.\n       Where the length of xs is not evenly divible,\n       the final list will be shorter than n.'''\n    return lambda xs: reduce(\n        lambda a, i: a + [xs[i:n + i]],\n        range(0, len(xs), n), []\n    ) if 0 < n else []\n\n\n# compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\ndef compose(g):\n    '''Right to left function composition.'''\n    return lambda f: lambda x: g(f(x))\n\n\n# fst\u00a0:: (a, b) -> a\ndef fst(tpl):\n    '''First member of a pair.'''\n    return tpl[0]\n\n\n# readFile\u00a0:: FilePath -> IO String\ndef readFile(fp):\n    '''The contents of any file at the path\n       derived by expanding any ~ in fp.'''\n    with open(expanduser(fp), 'r', encoding='utf-8') as f:\n        return f.read()\n\n\n# paddedMatrix\u00a0:: a -> [[a]] -> [[a]]\ndef paddedMatrix(v):\n    ''''A list of rows padded to equal length\n        (where needed) with instances of the value v.'''\n    def go(rows):\n        return paddedRows(\n            len(max(rows, key=len))\n        )(v)(rows)\n    return lambda rows: go(rows) if rows else []\n\n\n# paddedRows\u00a0:: Int -> a -> [[a]] -[[a]]\ndef paddedRows(n):\n    '''A list of rows padded (but never truncated)\n       to length n with copies of value v.'''\n    def go(v, xs):\n        def pad(x):\n            d = n - len(x)\n            return (x + list(repeat(v, d))) if 0 < d else x\n        return list(map(pad, xs))\n    return lambda v: lambda xs: go(v, xs) if xs else []\n\n\n# showColumns\u00a0:: Int -> [String] -> String\ndef showColumns(n):\n    '''A column-wrapped string\n       derived from a list of rows.'''\n    def go(xs):\n        def fit(col):\n            w = len(max(col, key=len))\n\n            def pad(x):\n                return x.ljust(4 + w, ' ')\n            return ''.join(map(pad, col)).rstrip()\n\n        q, r = divmod(len(xs), n)\n        return '\\n'.join(map(\n            fit,\n            zip(*paddedMatrix('')(\n                chunksOf(q + int(bool(r)))(xs)\n            ))\n        ))\n    return lambda xs: go(xs)\n\n\n# snd\u00a0:: (a, b) -> b\ndef snd(tpl):\n    '''Second member of a pair.'''\n    return tpl[1]\n\n\n# stet\u00a0:: a -> a\ndef stet(x):\n    '''The identity function.\n       The usual 'id' is reserved in Python.'''\n    return x\n\n\n# swap\u00a0:: (a, b) -> (b, a)\ndef swap(tpl):\n    '''The swapped components of a pair.'''\n    return (tpl[1], tpl[0])\n\n\n# tabulated\u00a0:: String -> (a -> String) ->\n#                        (b -> String) ->\n#                        Int ->\n#                        (a -> b) -> [a] -> String\ndef tabulated(s):\n    '''Heading -> x display function -> fx display function ->\n          number of columns -> f -> value list -> tabular string.'''\n    def go(xShow, fxShow, intCols, f, xs):\n        def mxw(fshow, g):\n            return max(map(compose(len)(fshow), map(g, xs)))\n        w = mxw(xShow, lambda x: x)\n        fw = mxw(fxShow, f)\n        return s + '\\n' + showColumns(intCols)([\n            xShow(x).rjust(w, ' ') + ' -> ' + (\n                fxShow(f(x)).rjust(fw, ' ')\n            )\n            for x in xs\n        ])\n    return lambda xShow: lambda fxShow: lambda nCols: (\n        lambda f: lambda xs: go(\n            xShow, fxShow, nCols, f, xs\n        )\n    )\n\n\n# MAIN ---\nif __name__ == '__main__':\n    main()\n\n\nOutput:\nDescending order of frequency:\n\n ' ' -> 568     ')' ->  62     'v' ->  25     'w' ->   7     '5' ->   3\n'\\t' -> 382     '(' ->  62     '1' ->  24     'k' ->   7     '4' ->   3\n 'e' -> 274     'd' ->  60     'G' ->  22     '9' ->   6     '+' ->   3\n 'n' -> 233     'g' ->  59     ']' ->  17     'S' ->   5     '\u00ac' ->   2\n'\\n' -> 228     'u' ->  58     '[' ->  17     'R' ->   5     '=' ->   2\n 't' -> 204     '|' ->  54     '\u03bb' ->  16     'M' ->   5     '.' ->   2\n 's' -> 198     'x' ->  53     '2' ->  15     'F' ->   5     'L' ->   1\n '-' -> 178     'm' ->  52     'N' ->  11     '<' ->   5     'C' ->   1\n 'i' -> 145     'c' ->  52     '}' ->  10     '6' ->   5     'A' ->   1\n 'o' -> 126     'h' ->  47     '{' ->  10     'z' ->   4     '3' ->   1\n 'f' -> 100     ':' ->  47     'T' ->  10     \"'\" ->   4     '&' ->   1\n 'r' ->  96     ',' ->  38     'I' ->  10     '^' ->   3     '$' ->   1\n 'a' ->  86     'b' ->  32     '0' ->  10     'E' ->   3\n 'l' ->  70     'y' ->  31     '\"' ->  10     '8' ->   3\n 'p' ->  68     '>' ->  28     'J' ->   9     '7' ->   3\nProcedural[edit]\nWithout using collections.Counter[edit]\nimport string\nif hasattr(string, 'ascii_lowercase'):\n    letters = string.ascii_lowercase       # Python 2.2 and later\nelse:\n    letters = string.lowercase             # Earlier versions\noffset = ord('a')\n\ndef countletters(file_handle):\n    \"\"\"Traverse a file and compute the number of occurences of each letter\n    return results as a simple 26 element list of integers.\"\"\"\n    results = [0] * len(letters)\n    for line in file_handle:\n        for char in line:\n            char = char.lower()\n            if char in letters:\n                results[ord(char) - offset] += 1\n                # Ordinal minus ordinal of 'a' of any lowercase ASCII letter -> 0..25\n    return results\n\nif __name__ == \"__main__\":\n    sourcedata = open(sys.argv[1])\n    lettercounts = countletters(sourcedata)\n    for i in xrange(len(lettercounts)):\n        print \"%s=%d\" % (chr(i + ord('a')), lettercounts[i]),\n\n\nUsing defaultdict[edit]\nWorks with: Python version 2.5+ and 3.x\n...\nfrom collections import defaultdict\ndef countletters(file_handle):\n    \"\"\"Count occurences of letters and return a dictionary of them\n    \"\"\"\n    results = defaultdict(int)\n    for line in file_handle:\n        for char in line:\n            if char.lower() in letters:\n                c = char.lower()\n                results[c] += 1\n    return results\n\n\nlettercounts = countletters(sourcedata)\nfor letter,count in lettercounts.iteritems():\n    print \"%s=%s\" % (letter, count),\n\n\n", "explain": "Character counting can be conveniently expressed in terms of fold/reduce. See the example below, which also generates column-wrapped output:\nThis example defines the function and provides a sample usage.  The if ... __main__... line allows it to be cleanly imported into any other Python code while also allowing it to function as a standalone script.  (A very common Python idiom).\nUsing a numerically indexed array (list) for this is artificial and clutters the code somewhat.\nWhich eliminates the ungainly fiddling with ordinal values and offsets in function countletters of a previous example above.  More importantly it allows the results to be more simply printed using:\nAgain eliminating all fussing with the details of converting letters into list indices.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "C", "code": "\n/* declare array */\nint frequency[26];\nint ch;\nFILE* txt_file = fopen (\"a_text_file.txt\", \"rt\");\n\n/* init the freq table: */\nfor (ch = 0; ch < 26; ch++)\n    frequency[ch] = 0;\n\nwhile (1) {\n    ch = fgetc(txt_file);\n    if (ch == EOF) break; /* end of file or read error.  EOF is typically -1 */\n\n    /* assuming ASCII; \"letters\" means \"a to z\" */\n    if ('a' <= ch && ch <= 'z')      /* lower case */\n        frequency[ch-'a']++;\n    else if ('A' <= ch && ch <= 'Z') /* upper case */\n        frequency[ch-'A']++;\n}\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "C++", "code": "\n#include <fstream>\n#include <iostream>\n\nint main()\n{\n\tstd::ifstream input(\"filename.txt\", std::ios_base::binary);\n\tif (!input)\n\t{\n\t\tstd::cerr << \"error: can't open file\\n\";\n\t\treturn -1;\n\t}\n\n\tsize_t count[256];\n\tstd::fill_n(count, 256, 0);\n\n\tfor (char c; input.get(c); ++count[uint8_t(c)]) // process input file\n\t\t; // empty loop body\n\n\tfor (size_t i = 0; i < 256; ++i)\n\t{\n\t\tif (count[i] && isgraph(i)) // non-zero counts of printable characters\n\t\t{\n\t\t\tstd::cout << char(i) << \" = \" << count[i] << '\\n';\n\t\t}\n\t}\n}\n\n\nOutput: when file contains \"Hello, world!\" (without quotes)\n\n! = 1\n, = 1\nH = 1\nd = 1\ne = 1\nl = 3\no = 2\nr = 1\nw = 1\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Java", "code": "\n\nimport java.io.FileInputStream;\nimport java.io.IOException;\nimport java.io.InputStreamReader;\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic static void main(String[] args) throws IOException {\n    Map<Integer, Integer> frequencies = frequencies(\"src/LetterFrequency.java\");\n    System.out.println(print(frequencies));\n}\n\nstatic String print(Map<Integer, Integer> frequencies) {\n    StringBuilder string = new StringBuilder();\n    int key;\n    for (Map.Entry<Integer, Integer> entry : frequencies.entrySet()) {\n        key = entry.getKey();\n        string.append(\"%,-8d\".formatted(entry.getValue()));\n        /* display the hexadecimal value for non-printable characters */\n        if ((key >= 0 && key < 32) || key == 127) {\n            string.append(\"%02x%n\".formatted(key));\n        } else {\n            string.append(\"%s%n\".formatted((char) key));\n        }\n    }\n    return string.toString();\n}\n\nstatic Map<Integer, Integer> frequencies(String path) throws IOException {\n    try (InputStreamReader reader = new InputStreamReader(new FileInputStream(path))) {\n        /* key = character, and value = occurrences */\n        Map<Integer, Integer> map = new HashMap<>();\n        int value;\n        while ((value = reader.read()) != -1) {\n            if (map.containsKey(value)) {\n                map.put(value, map.get(value) + 1);\n            } else {\n                map.put(value, 1);\n            }\n        }\n        return map;\n    }\n}\n\n44      0a\n463      \n1      \u00a0!\n8       \"\n5      \u00a0%\n2       &\n33      (\n33      )\n4       *\n1       +\n9       ,\n3       -\n29      .\n5       /\n2       0\n4       1\n3       2\n1       3\n1       7\n1       8\n1      \u00a0:\n19     \u00a0;\n7       <\n12      =\n7       >\n2       B\n4       E\n4       F\n2       H\n18      I\n2       K\n2       L\n8       M\n3       O\n3       R\n13      S\n1       V\n1       [\n1       ]\n73      a\n3       b\n28      c\n19      d\n121     e\n13      f\n25      g\n11      h\n53      i\n6       j\n8       k\n25      l\n22      m\n67      n\n24      o\n44      p\n8       q\n81      r\n30      s\n87      t\n34      u\n15      v\n7       w\n5       x\n20      y\n11      {\n2       |\n11      }\n\n\nWorks with: Java version 5+\nimport java.io.BufferedReader;\nimport java.io.FileReader;\nimport java.io.IOException;\nimport java.util.Arrays;\n\npublic class LetterFreq {\n\tpublic static int[] countLetters(String filename) throws IOException{\n\t\tint[] freqs = new int[26];\n\t\tBufferedReader in = new BufferedReader(new FileReader(filename));\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t\tin.close();\n\t\treturn freqs;\n\t}\n\t\n\tpublic static void main(String[] args) throws IOException{\n\t\tSystem.out.println(Arrays.toString(countLetters(\"filename.txt\")));\n\t}\n}\n\nWorks with: Java version 7+\n\npublic static int[] countLetters(String filename) throws IOException{\n\tint[] freqs = new int[26];\n\ttry(BufferedReader in = new BufferedReader(new FileReader(filename))){\n\t\tString line;\n\t\twhile((line = in.readLine()) != null){\n\t\t\tline = line.toUpperCase();\n\t\t\tfor(char ch:line.toCharArray()){\n\t\t\t\tif(Character.isLetter(ch)){\n\t\t\t\t\tfreqs[ch - 'A']++;\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\t}\n\treturn freqs;\n}\n\nWorks with: Java version 8+\n\npublic static Map<Integer, Long> countLetters(String filename) throws IOException {\n    return Files.lines(Paths.get(filename))\n        .flatMapToInt(String::chars)\n        .filter(Character::isLetter)\n        .boxed()\n        .collect(Collectors.groupingBy(Function.identity(), Collectors.counting()));\n}\n\n", "explain": "This implementation will capture the frequency of all characters\n\nIn Java 7, we can use try with resources. The countLetters method would look like this:\nIn Java 8, we can use streams.  This code also handles unicode codepoints as well.  The countLetters method would look like this:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "C#", "code": "\nusing System;\nusing System.Collections.Generic;\nusing System.IO;\nusing System.Linq;\n\nclass Program\n{\n    static SortedDictionary<TItem, int> GetFrequencies<TItem>(IEnumerable<TItem> items)\n    {\n        var dictionary = new SortedDictionary<TItem, int>();\n        foreach (var item in items)\n        {\n            if (dictionary.ContainsKey(item))\n            {\n                dictionary[item]++;\n            }\n            else\n            {\n                dictionary[item] = 1;\n            }\n        }\n        return dictionary;\n    }\n\n    static void Main(string[] arguments)\n    {\n        var file = arguments.FirstOrDefault();\n        if (File.Exists(file))\n        {\n            var text = File.ReadAllText(file);\n            foreach (var entry in GetFrequencies(text))\n            {\n                Console.WriteLine(\"{0}: {1}\", entry.Key, entry.Value);\n            }\n        }\n    }\n}\n\n\nOutput:\n\u00a0: 1\n!: 1\n,: 1\nH: 1\nd: 1\ne: 1\nl: 3\no: 2\nr: 1\nw: 1\n\nvar freq =  from c in str\n            where char.IsLetter(c)\n            orderby c\n            group c by c into g\n            select g.Key + \":\" + g.Count();\n\nforeach(var g in freq)\n    Console.WriteLine(g);\n\nC:2\nI:1\nK:1\nL:2\nW:1\na:4\n...\ny:2\n\n", "explain": "Declarative approach:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "JavaScript", "code": "\nES5[edit]\n\n(function(txt) {\n\n    var cs = txt.split(''),\n        i = cs.length,\n        dct =  {},\n        c = '',\n        keys;\n        \n    while (i--) {\n        c = cs[i];\n        dct[c] = (dct[c] || 0) + 1;\n    }\n    \n    keys = Object.keys(dct);\n    keys.sort();\n    return keys.map(function (c) { return [c, dct[c]]; });\n\n})(\"Not all that Mrs. Bennet, however, with the assistance of her five\\\ndaughters, could ask on the subject, was sufficient to draw from her\\\nhusband any satisfactory description of Mr. Bingley. They attacked him\\\nin various ways--with barefaced questions, ingenious suppositions, and\\\ndistant surmises; but he eluded the skill of them all, and they were at\\\nlast obliged to accept the second-hand intelligence of their neighbour,\\\nLady Lucas. Her report was highly favourable. Sir William had been\\\ndelighted with him. He was quite young, wonderfully handsome, extremely\\\nagreeable, and, to crown the whole, he meant to be at the next assembly\\\nwith a large party. Nothing could be more delightful! To be fond of\\\ndancing was a certain step towards falling in love; and very lively\\\nhopes of Mr. Bingley's heart were entertained.\");\n\n\nOutput:\n[[\" \", 121], [\"!\", 1], [\"'\", 1], [\",\", 13], [\"-\", 3], [\".\", 9], [\";\", 2], \n[\"B\", 3], [\"H\", 2], [\"L\", 2], [\"M\", 3], [\"N\", 2], [\"S\", 1], [\"T\", 2], [\"W\", 1], \n[\"a\", 53], [\"b\", 13], [\"c\", 17], [\"d\", 29], [\"e\", 82], [\"f\", 17], [\"g\", 16], [\"h\", 36],\n[\"i\", 44], [\"j\", 1], [\"k\", 3], [\"l\", 34], [\"m\", 11], [\"n\", 41], [\"o\", 40], [\"p\", 8], \n[\"q\", 2], [\"r\", 35], [\"s\", 39], [\"t\", 55], [\"u\", 20], [\"v\", 7], [\"w\", 17], [\"x\", 2], [\"y\", 16]]\n\nES6[edit]\n\n(() => {\n    'use strict';\n\n\n    // charCounts\u00a0:: String -> [(Char, Int)]\n    const charCounts = s =>\n        sortBy(flip(comparing(snd)))(\n            Object.entries(\n                chars(s).reduce(\n                    (a, c) => (\n                        a[c] = 1 + (a[c] || 0),\n                        a\n                    ), {}\n                )\n            )\n        );\n\n    // ----------------------- TEST -----------------------\n    // main\u00a0:: IO ()\n    const main = () =>\n        either(msg => msg)(\n            compose(\n                unlines,\n                map(JSON.stringify),\n                charCounts\n            )\n        )(readFileLR('~/Code/charCount/miserables.txt'));\n\n\n    // -----------------GENERIC FUNCTIONS -----------------\n\n    // Left\u00a0:: a -> Either a b\n    const Left = x => ({\n        type: 'Either',\n        Left: x\n    });\n\n\n    // Right\u00a0:: b -> Either a b\n    const Right = x => ({\n        type: 'Either',\n        Right: x\n    });\n\n\n    // chars\u00a0:: String -> [Char]\n    const chars = s =>\n        s.split('');\n\n\n    // comparing\u00a0:: (a -> b) -> (a -> a -> Ordering)\n    const comparing = f =>\n        x => y => {\n            const\n                a = f(x),\n                b = f(y);\n            return a < b ? -1 : (a > b ? 1 : 0);\n        };\n\n    // compose (<<<)\u00a0:: (b -> c) -> (a -> b) -> a -> c\n    const compose = (...fs) =>\n        fs.reduce(\n            (f, g) => x => f(g(x)),\n            x => x\n        );\n\n    // either\u00a0:: (a -> c) -> (b -> c) -> Either a b -> c\n    const either = fl =>\n        fr => e => 'Either' === e.type ? (\n            undefined !== e.Left ? (\n                fl(e.Left)\n            ) : fr(e.Right)\n        ) : undefined;\n\n\n    // flip\u00a0:: (a -> b -> c) -> b -> a -> c\n    const flip = f =>\n        1 < f.length ? (\n            (a, b) => f(b, a)\n        ) : (x => y => f(y)(x));\n\n\n    // map\u00a0:: (a -> b) -> [a] -> [b]\n    const map = f =>\n        // The list obtained by applying f\n        // to each element of xs.\n        // (The image of xs under f).\n        xs => (\n            Array.isArray(xs) ? (\n                xs\n            ) : xs.split('')\n        ).map(f);\n\n\n    // readFileLR\u00a0:: FilePath -> Either String IO String\n    const readFileLR = fp => {\n        const\n            e = $(),\n            ns = $.NSString\n            .stringWithContentsOfFileEncodingError(\n                $(fp).stringByStandardizingPath,\n                $.NSUTF8StringEncoding,\n                e\n            );\n        return ns.isNil() ? (\n            Left(ObjC.unwrap(e.localizedDescription))\n        ) : Right(ObjC.unwrap(ns));\n    };\n\n\n    // snd\u00a0:: (a, b) -> b\n    const snd = tpl => tpl[1];\n\n\n    // sortBy\u00a0:: (a -> a -> Ordering) -> [a] -> [a]\n    const sortBy = f =>\n        xs => xs.slice()\n        .sort((a, b) => f(a)(b));\n\n\n    // unlines\u00a0:: [String] -> String\n    const unlines = xs =>\n        // A single string formed by the intercalation\n        // of a list of strings with the newline character.\n        xs.join('\\n');\n\n    // MAIN ---\n    return main();\n})();\n\n\nOutput:\n[\" \",516452]\n[\"e\",325769]\n[\"t\",222955]\n[\"a\",199774]\n[\"o\",180987]\n[\"h\",170234]\n[\"n\",166901]\n[\"i\",165221]\n[\"s\",157643]\n[\"r\",145136]\n[\"d\",106989]\n[\"l\",97091]\n[\"\\n\",73828]\n[\"u\",67370]\n[\"c\",62760]\n[\"m\",56011]\n[\"f\",53438]\n[\"w\",53332]\n[\",\",48784]\n[\"g\",46086]\n[\"p\",39958]\n[\"y\",37945]\n[\"b\",34313]\n[\".\",30487]\n[\"v\",24058]\n[\"\u20ac\",21159]\n[\"\u00e2\",21155]\n[\"k\",14110]\n[\"T\",12571]\n[\"I\",10067]\n[\"A\",7359]\n[\"\u0153\",7121]\n[\"\ufffd\",7033]\n[\"H\",6605]\n[\"M\",6208]\n[\";\",5885]\n[\"E\",4969]\n[\"-\",4775]\n[\"C\",4594]\n[\"S\",4404]\n[\"x\",3694]\n[\"\u2122\",3633]\n[\"!\",3539]\n[\"R\",3535]\n[\"P\",3429]\n[\"O\",3401]\n[\"j\",3392]\n[\"B\",3193]\n[\"W\",3181]\n[\"\u201d\",3071]\n[\"N\",3053]\n[\"?\",2976]\n[\"F\",2768]\n[\"G\",2512]\n[\":\",2463]\n[\"L\",2452]\n[\"J\",2448]\n[\"q\",2398]\n[\"\u00c3\",2296]\n[\"V\",2210]\n[\"_\",2068]\n[\"z\",1847]\n[\"D\",1758]\n[\"\u00a9\",1328]\n[\"Y\",1238]\n[\"U\",900]\n[\"1\",732]\n[\"8\",412]\n[\"X\",333]\n[\"K\",323]\n[\"\u02dc\",298]\n[\"\u00a8\",294]\n[\"3\",254]\n[\"2\",242]\n[\"0\",212]\n[\"5\",208]\n[\"*\",179]\n[\"(\",172]\n[\")\",172]\n[\"4\",170]\n[\"\u2030\",146]\n[\"6\",143]\n[\"7\",140]\n[\"Q\",135]\n[\"[\",122]\n[\"]\",122]\n[\"9\",118]\n[\"\u00a6\",107]\n[\"\u00aa\",74]\n[\"Z\",59]\n[\"\u00a2\",56]\n[\"\u00a7\",48]\n[\"\u00ae\",39]\n[\"\u00c5\",38]\n[\"\u00bc\",37]\n[\"\\\"\",37]\n[\"\u201c\",35]\n[\"\u00b4\",34]\n[\"|\",24]\n[\"\u00af\",18]\n[\"\u00b9\",18]\n[\"/\",12]\n[\"\u2020\",10]\n[\"\u00bb\",9]\n[\"'\",8]\n[\"\u02c6\",5]\n[\"\u00ab\",5]\n[\"+\",5]\n[\"\u2019\",3]\n[\"\u00b1\",2]\n[\"\u2021\",2]\n[\"$\",2]\n[\"#\",1]\n[\"&\",1]\n[\"\u00c2\",1]\n[\"\u00bd\",1]\n[\"{\",1]\n[\"}\",1]\n[\"%\",1]\n[\"@\",1]\n\n(() => {\n    'use strict';\n\n    const letterfreq = text => [...text]\n        .reduce(\n            (a, c) => (a[c] = (a[c] || 0) + 1, a), \n            {}\n        );\n\n    return JSON.stringify(\n        letterfreq(\n            `remember, remember, the fifth of november\n             gunpowder treason and plot\n             I see no reason why gunpowder treason\n             should ever be forgot`\n        ),\n        null, 2\n    );\n})();\n\n\n\nOutput:\n{\n  \"r\": 12,\n  \"e\": 19,\n  \"m\": 5,\n  \"b\": 4,\n  \",\": 2,\n  \" \": 56,\n  \"t\": 6,\n  \"h\": 4,\n  \"f\": 4,\n  \"i\": 1,\n  \"o\": 12,\n  \"n\": 8,\n  \"v\": 2,\n  \"\\n\": 3,\n  \"g\": 3,\n  \"u\": 3,\n  \"p\": 3,\n  \"w\": 3,\n  \"d\": 4,\n  \"a\": 4,\n  \"s\": 5,\n  \"l\": 2,\n  \"I\": 1,\n  \"y\": 1\n}\n", "explain": "JavaScript is no longer used only in environments which are carefully isolated from file systems, but JavaScript standards still do not specify standard file-system functions. \nLeaving aside the particular and variable details of how files will be opened and read in environments like Node.js and OS X JavaScript for Automation etc., \nwe can still use core JavasScript (ES5 in the example below), to count the characters in a text once it has been read from a file system.\nUsing the 'JavaScript for Automation' embedding of a JSContext on macOS, for access to the file system:\n\nOr, using an object as a hash-table, and the reduce method: \n(note that this version omits the opening of a text file which is specified in the task description):\nUsing the spread operator, you get the unicode characters rather than the UTF-16 code units. \n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "PHP", "code": "\n<?php\nprint_r(array_count_values(str_split(file_get_contents($argv[1]))));\n?>\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Fortran", "code": "\n\n-*- mode: compilation; default-directory: \"/tmp/\" -*-\nCompilation started at Sat May 18 18:09:46\n\na=./F && make $a && $a < configuration.file\nf95 -Wall -ffree-form F.F -o F\n          92          21          17          24          82          19          19          22          67           0           2          27          27          57          55          31           1          61          43          60          20           6           2           0          10           0\n\nCompilation finished at Sat May 18 18:09:46\n\n\n! count letters from stdin\nprogram LetterFrequency\n  implicit none\n  character (len=1) :: s\n  integer, dimension(26) :: a\n  integer :: ios, i, t\n  data a/26*0/,i/0/\n  open(unit=7, file='/dev/stdin', access='direct', form='formatted', recl=1, status='old', iostat=ios)\n  if (ios .ne. 0) then\n    write(0,*)'Opening stdin failed'\n    stop\n  endif\n  do i=1, huge(i)\n    read(unit=7, rec = i, fmt = '(a)', iostat = ios ) s\n    if (ios .ne. 0) then\n      !write(0,*)'ios on failure is ',ios\n      close(unit=7)\n      exit\n    endif\n    t = ior(iachar(s(1:1)), 32) - iachar('a')\n    if ((0 .le. t) .and. (t .le. iachar('z'))) then\n      t = t+1\n      a(t) = a(t) + 1\n    endif\n  end do\n  write(6, *) a\nend program LetterFrequency\n\n", "explain": "Using the configuration file (which has changed since the example was documented) of the J example, compilation and output of this program on a gnu/linux system is\nAnd here's the FORTRAN90 program source.  The program reads stdin and writes the result to stdout.  Future enhancement: use block size records.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Go", "code": "\npackage main\n\nimport (\n    \"fmt\"\n    \"io/ioutil\"\n    \"sort\"\n    \"unicode\"\n)\n\nconst file = \"unixdict.txt\"\n\nfunc main() {\n    bs, err := ioutil.ReadFile(file)\n    if err != nil {\n        fmt.Println(err)\n        return\n    }\n    m := make(map[rune]int)\n    for _, r := range string(bs) {\n        m[r]++\n    }\n    // answer is now in m.  sort and format output:\n    lfs := make(lfList, 0, len(m))\n    for l, f := range m {\n        lfs = append(lfs, &letterFreq{l, f})\n    }\n    sort.Sort(lfs)\n    fmt.Println(\"file:\", file)\n    fmt.Println(\"letter  frequency\")\n    for _, lf := range lfs {\n        if unicode.IsGraphic(lf.rune) {\n            fmt.Printf(\"   %c    %7d\\n\", lf.rune, lf.freq)\n        } else {\n            fmt.Printf(\"%U  %7d\\n\", lf.rune, lf.freq)\n        }\n    }\n}\n\ntype letterFreq struct {\n    rune\n    freq int\n}\ntype lfList []*letterFreq\n\nfunc (lfs lfList) Len() int { return len(lfs) }\nfunc (lfs lfList) Less(i, j int) bool {\n    switch fd := lfs[i].freq - lfs[j].freq; {\n    case fd < 0:\n        return false\n    case fd > 0:\n        return true\n    }\n    return lfs[i].rune < lfs[j].rune\n}\nfunc (lfs lfList) Swap(i, j int) {\n    lfs[i], lfs[j] = lfs[j], lfs[i]\n}\n\n\nOutput:\nfile: unixdict.txt\nletter  frequency\nU+000A    25104\n   e      20144\n   a      16421\n   i      13980\n   r      13436\n   t      12836\n   o      12738\n   n      12097\n   s      10210\n   l      10061\n   c       8216\n   u       6489\n   m       5828\n   d       5799\n   p       5516\n   h       5208\n   g       4129\n   b       4115\n   y       3633\n   f       2662\n   w       1968\n   k       1925\n   v       1902\n   x        617\n   z        433\n   j        430\n   q        378\n   '        105\n   &          6\n   .          6\n   1          2\n   0          1\n   2          1\n   3          1\n   4          1\n   5          1\n   6          1\n   7          1\n   8          1\n   9          1\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Delphi", "code": "\n\n", "explain": "See Pascal.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Ruby", "code": "\ndef letter_frequency(file)\n  letters = 'a' .. 'z'\n  File.read(file) .\n       split(//) .\n       group_by {|letter| letter.downcase} .\n       select   {|key, val| letters.include? key} .\n       collect  {|key, val| [key, val.length]} \nend\n\nletter_frequency(ARGV[0]).sort_by {|key, val| -val}.each {|pair| p pair}\n\n\n$ ruby letterFrequency.rb letterFrequency.rb\n[\"e\", 34]\n[\"l\", 20]\n[\"t\", 17]\n[\"r\", 14]\n[\"a\", 12]\n[\"y\", 9]\n[\"c\", 8]\n[\"i\", 7]\n[\"v\", 6]\n[\"n\", 6]\n[\"f\", 6]\n[\"s\", 6]\n[\"d\", 5]\n[\"p\", 5]\n[\"k\", 5]\n[\"u\", 4]\n[\"o\", 4]\n[\"g\", 3]\n[\"b\", 2]\n[\"h\", 2]\n[\"q\", 2]\n[\"z\", 1]\n[\"w\", 1]\nRuby 2.0[edit]\ndef letter_frequency(file)\n  freq = Hash.new(0)\n  file.each_char.lazy.grep(/[[:alpha:]]/).map(&:upcase).each_with_object(freq) do |char, freq_map|\n    freq_map[char] += 1\n  end\nend\n\nletter_frequency(ARGF).sort.each do |letter, frequency|\n  puts \"#{letter}: #{frequency}\"\nend\n\n\n$ ruby letter_frequency.rb /usr/share/dict/words\nA: 64439\nB: 15526\nC: 31872\nD: 28531\nE: 88833\nF: 10675\nG: 22712\nH: 19320\nI: 66986\nJ: 1948\nK: 8409\nL: 41107\nM: 22508\nN: 57144\nO: 48944\nP: 22274\nQ: 1524\nR: 57347\nS: 90113\nT: 53006\nU: 26118\nV: 7989\nW: 7530\nX: 2124\nY: 12652\nZ: 3281\n\u00c5: 1\n\u00e1: 10\n\u00e2: 6\n\u00e4: 7\n\u00e5: 3\n\u00e7: 5\n\u00e8: 28\n\u00e9: 144\n\u00ea: 6\n\u00ed: 2\n\u00f1: 8\n\u00f3: 8\n\u00f4: 2\n\u00f6: 16\n\u00fb: 3\n\u00fc: 12\n\nRuby 2.7[edit]\n\np File.open(\"/usr/share/dict/words\",\"r\").each_char.tally\n\n", "explain": "example output, using the program file as input:\nnote that this version *should* use less memory, even on a gigantic file. This is done by using lazy enumerables, which ruby 2.0 introduces.\nexample output, using the (somewhat large) dictionary file as the input. Also note that this versions works on unicode text.\nRuby 2.7 introduced \"tally\", which delivers a tally on anything enumerable.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Rust", "code": "\n\nuse std::collections::btree_map::BTreeMap;\nuse std::{env, process};\nuse std::io::{self, Read, Write};\nuse std::fmt::Display;\nuse std::fs::File;\n\nfn main() {\n    let filename = env::args().nth(1)\n        .ok_or(\"Please supply a file name\")\n        .unwrap_or_else(|e| exit_err(e, 1));\n\n    let mut buf = String::new();\n    let mut count = BTreeMap::new();\n\n    File::open(&filename)\n        .unwrap_or_else(|e| exit_err(e, 2))\n        .read_to_string(&mut buf)\n        .unwrap_or_else(|e| exit_err(e, 3));\n\n\n    for c in buf.chars() {\n        *count.entry(c).or_insert(0) += 1;\n    }\n\n    println!(\"Number of occurences per character\");\n    for (ch, count) in &count {\n        println!(\"{:?}: {}\", ch, count);\n    }\n}\n\n#[inline]\nfn exit_err<T>(msg: T, code: i32) -> ! where T: Display {\n    writeln!(&mut io::stderr(), \"{}\", msg).expect(\"Could not write to stderr\");\n    process::exit(code)\n}\n\n\nNumber of occurences per character\n'\\n': 35\n' ': 167\n'!': 4\n'\\\"': 10\n'#': 1\n'&': 4\n'(': 25\n')': 25\n'*': 1\n'+': 1\n',': 12\n'-': 1\n'.': 10\n'0': 1\n'1': 3\n'2': 2\n'3': 2\n':': 37\n';': 13\n'<': 1\n'=': 4\n'>': 2\n'?': 1\n'B': 2\n'C': 1\n'D': 2\n'F': 2\n'M': 2\n'N': 1\n'P': 1\n'R': 1\n'S': 1\n'T': 5\n'W': 1\n'[': 1\n']': 1\n'_': 15\n'a': 20\n'b': 5\n'c': 22\n'd': 12\n'e': 75\n'f': 14\n'g': 5\n'h': 6\n'i': 29\n'k': 1\n'l': 23\n'm': 13\n'n': 36\n'o': 28\n'p': 17\n'r': 45\n's': 33\n't': 42\n'u': 24\n'v': 2\n'w': 8\n'x': 6\n'y': 4\n'{': 9\n'|': 6\n'}': 9\n\n", "explain": "Works with all UTF-8 characters\nOutput when run on source file:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Swift", "code": "\nimport Foundation\n\nlet dictPath: String\n\nswitch CommandLine.arguments.count {\ncase 2:\n  dictPath = CommandLine.arguments[1]\ncase _:\n  dictPath = \"/usr/share/dict/words\"\n}\n\nlet wordsData = FileManager.default.contents(atPath: dictPath)!\nlet allWords = String(data: wordsData, encoding: .utf8)!\nlet words = allWords.components(separatedBy: \"\\n\")\nlet counts = words.flatMap({ $0.map({ ($0, 1) }) }).reduce(into: [:], { $0[$1.0, default: 0] += $1.1 })\n\nfor (char, count) in counts {\n  print(\"\\(char): \\(count)\")\n}\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "R", "code": "\nUsing summary[edit]\nletter.frequency <- function(filename)\n{\n    file <- paste(readLines(filename), collapse = '')\n    chars <- strsplit(file, NULL)[[1]]\n    summary(factor(chars))\n}\n\n\n> source('letter.frequency.r')\n> letter.frequency('letter.frequency.r')\n    -  ,  .  '  (  )  [  ]  {  }  <  =  1  a  c  d  e  f  h  i  l  L  m  n  N  o  p  q  r  s  t  u  U  y \n22  3  2  1  2  6  6  2  2  1  1  3  1  1  9  6  1 14  7  2  7  8  3  4  6  1  3  3  1  8  8  7  3  1  2\n\nUsing table[edit]\n\nletterFreq <- function(filename, lettersOnly)\n{\n  txt <- read.delim(filename, header = FALSE, stringsAsFactors = FALSE, allowEscapes = FALSE, quote = \"\")\n  count <- table(strsplit(paste0(txt[,], collapse = \"\"), \"\"))\n  if(lettersOnly) count[names(count) %in% c(LETTERS, letters)] else count\n}\n\n\nOutput:\n\n> print(letterFreq('https://rosettacode.org/wiki/Letter_frequency', TRUE))\n\n    a     A     b     B     c     C     d     D     e     E     f     F     g     G     h     H     i     I \n38186   666  8008   350 16585  1263  4151   277 15020   713  3172   529  3079   149  4549   161  9397   690 \n    j     J     k     K     l     L     m     M     n     N     o     O     p     P     q     Q     r     R \n  311   113  3294    76 15906   928  3333   322 26795   355  8926   456 22702   497  1877    39 15055   591 \n    s     S     t     T     u     U     v     V     w     W     x     X     y     Y     z     Z \n46527   695 15549   597  5268   269  1003   128  4134   148  1239   144  3037    55   127    77 \n", "explain": "Usage on itself:\nR's table function is more idiomatic. For variety, we will use read.delim rather than readLines and show how to only count letters. It is worth noting that readLines is prone to counting empty lines. This may be undesirable.\nFor fun, we'll use this page for input. However, HTML rarely parses well and the variety of text here is so large that I suspect inaccurate output.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "COBOL", "code": "\n       IDENTIFICATION DIVISION.\n       PROGRAM-ID. Letter-Frequency.\n       AUTHOR.  Bill Gunshannon.\n       INSTALLATION.  Home.\n       DATE-WRITTEN.  12 December 2021.\n      ************************************************************\n      ** Program Abstract:\n      **   A rather simplistic program to do the kind of thing\n      **   that COBOL does really well.                \n      ************************************************************\n       \n       ENVIRONMENT DIVISION.\n       \n       INPUT-OUTPUT SECTION.\n       FILE-CONTROL.\n            SELECT Text-File ASSIGN TO \"File.txt\"\n                 ORGANIZATION IS LINE SEQUENTIAL.\n       \n       DATA DIVISION.\n       \n       FILE SECTION.\n       \n       FD  Text-File\n           DATA RECORD IS Record-Name.\n       01  Record-Name           PIC X(80).\n       \n       \n       WORKING-STORAGE SECTION.\n       \n       01 Eof                   PIC X     VALUE 'F'.\n\n       01  Letter-cnt.\n           05  A-cnt            PIC 9(5)    VALUE 0.\n           05  B-cnt            PIC 9(5)    VALUE 0.\n           05  C-cnt            PIC 9(5)    VALUE 0.\n           05  D-cnt            PIC 9(5)    VALUE 0.\n           05  E-cnt            PIC 9(5)    VALUE 0.\n           05  F-cnt            PIC 9(5)    VALUE 0.\n           05  G-cnt            PIC 9(5)    VALUE 0.\n           05  H-cnt            PIC 9(5)    VALUE 0.\n           05  I-cnt            PIC 9(5)    VALUE 0.\n           05  J-cnt            PIC 9(5)    VALUE 0.\n           05  K-cnt            PIC 9(5)    VALUE 0.\n           05  L-cnt            PIC 9(5)    VALUE 0.\n           05  M-cnt            PIC 9(5)    VALUE 0.\n           05  N-cnt            PIC 9(5)    VALUE 0.\n           05  O-cnt            PIC 9(5)    VALUE 0.\n           05  P-cnt            PIC 9(5)    VALUE 0.\n           05  Q-cnt            PIC 9(5)    VALUE 0.\n           05  R-cnt            PIC 9(5)    VALUE 0.\n           05  S-cnt            PIC 9(5)    VALUE 0.\n           05  T-cnt            PIC 9(5)    VALUE 0.\n           05  U-cnt            PIC 9(5)    VALUE 0.\n           05  V-cnt            PIC 9(5)    VALUE 0.\n           05  W-cnt            PIC 9(5)    VALUE 0.\n           05  X-cnt            PIC 9(5)    VALUE 0.\n           05  Y-cnt            PIC 9(5)    VALUE 0.\n           05  Z-cnt            PIC 9(5)    VALUE 0.\n       \n       01  Letter-disp.\n           05  A-cnt            PIC ZZZZ9.\n           05  B-cnt            PIC ZZZZ9.\n           05  C-cnt            PIC ZZZZ9.\n           05  D-cnt            PIC ZZZZ9.\n           05  E-cnt            PIC ZZZZ9.\n           05  F-cnt            PIC ZZZZ9.\n           05  G-cnt            PIC ZZZZ9.\n           05  H-cnt            PIC ZZZZ9.\n           05  I-cnt            PIC ZZZZ9.\n           05  J-cnt            PIC ZZZZ9.\n           05  K-cnt            PIC ZZZZ9.\n           05  L-cnt            PIC ZZZZ9.\n           05  M-cnt            PIC ZZZZ9.\n           05  N-cnt            PIC ZZZZ9.\n           05  O-cnt            PIC ZZZZ9.\n           05  P-cnt            PIC ZZZZ9.\n           05  Q-cnt            PIC ZZZZ9.\n           05  R-cnt            PIC ZZZZ9.\n           05  S-cnt            PIC ZZZZ9.\n           05  T-cnt            PIC ZZZZ9.\n           05  U-cnt            PIC ZZZZ9.\n           05  V-cnt            PIC ZZZZ9.\n           05  W-cnt            PIC ZZZZ9.\n           05  X-cnt            PIC ZZZZ9.\n           05  Y-cnt            PIC ZZZZ9.\n           05  Z-cnt            PIC ZZZZ9.\n       \n       PROCEDURE DIVISION.\n       \n       Main-Program.\n           OPEN INPUT  Text-File\n           PERFORM UNTIL Eof = 'T'\n              READ  Text-File\n                    AT END MOVE 'T' to Eof\n              END-READ\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING A-cnt OF Letter-cnt  FOR ALL 'A'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING B-cnt OF Letter-cnt  FOR ALL 'B'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING C-cnt OF Letter-cnt  FOR ALL 'C'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING D-cnt OF Letter-cnt  FOR ALL 'D'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING E-cnt OF Letter-cnt  FOR ALL 'E'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING F-cnt OF Letter-cnt  FOR ALL 'F'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING G-cnt OF Letter-cnt  FOR ALL 'G'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING H-cnt OF Letter-cnt  FOR ALL 'H'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING I-cnt OF Letter-cnt  FOR ALL 'I'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING J-cnt OF Letter-cnt  FOR ALL 'J'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING K-cnt OF Letter-cnt  FOR ALL 'K'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING L-cnt OF Letter-cnt  FOR ALL 'L'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING M-cnt OF Letter-cnt  FOR ALL 'M'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING N-cnt OF Letter-cnt  FOR ALL 'N'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING O-cnt OF Letter-cnt  FOR ALL 'O'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING P-cnt OF Letter-cnt  FOR ALL 'P'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Q-cnt OF Letter-cnt  FOR ALL 'Q'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING R-cnt OF Letter-cnt  FOR ALL 'R'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING S-cnt OF Letter-cnt  FOR ALL 'S'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING T-cnt OF Letter-cnt  FOR ALL 'T'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING U-cnt OF Letter-cnt  FOR ALL 'U'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING V-cnt OF Letter-cnt  FOR ALL 'V'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING W-cnt OF Letter-cnt  FOR ALL 'W'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING X-cnt OF Letter-cnt  FOR ALL 'X'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Y-cnt OF Letter-cnt  FOR ALL 'Y'\n           INSPECT FUNCTION UPPER-CASE(Record-Name)\n                   TALLYING Z-cnt OF Letter-cnt  FOR ALL 'Z'\n           END-PERFORM.\n           CLOSE Text-File.\n           MOVE CORRESPONDING Letter-cnt To Letter-disp.\n           DISPLAY 'Letter Frequency Distribution'.\n           DISPLAY '-----------------------------'.\n           DISPLAY 'A\u00a0: ' A-cnt OF Letter-disp '          '\n                   'N\u00a0: ' N-cnt OF Letter-disp.\n           DISPLAY 'B\u00a0: ' B-cnt OF Letter-disp '          '\n                   'O\u00a0: ' O-cnt OF Letter-disp.\n           DISPLAY 'C\u00a0: ' C-cnt OF Letter-disp '          '\n                   'P\u00a0: ' P-cnt OF Letter-disp.\n           DISPLAY 'D\u00a0: ' D-cnt OF Letter-disp '          '\n                   'Q\u00a0: ' Q-cnt OF Letter-disp.\n           DISPLAY 'E\u00a0: ' E-cnt OF Letter-disp '          '\n                   'R\u00a0: ' R-cnt OF Letter-disp.\n           DISPLAY 'F\u00a0: ' F-cnt OF Letter-disp '          '\n                   'S\u00a0: ' S-cnt OF Letter-disp.\n           DISPLAY 'G\u00a0: ' G-cnt OF Letter-disp '          '\n                   'T\u00a0: ' T-cnt OF Letter-disp.\n           DISPLAY 'H\u00a0: ' H-cnt OF Letter-disp '          '\n                   'U\u00a0: ' U-cnt OF Letter-disp.\n           DISPLAY 'I\u00a0: ' I-cnt OF Letter-disp '          '\n                   'V\u00a0: ' V-cnt OF Letter-disp.\n           DISPLAY 'J\u00a0: ' J-cnt OF Letter-disp '          '\n                   'W\u00a0: ' W-cnt OF Letter-disp.\n           DISPLAY 'K\u00a0: ' K-cnt OF Letter-disp '          '\n                   'X\u00a0: ' X-cnt OF Letter-disp.\n           DISPLAY 'L\u00a0: ' L-cnt OF Letter-disp '          '\n                   'Y\u00a0: ' Y-cnt OF Letter-disp.\n           DISPLAY 'M\u00a0: ' M-cnt OF Letter-disp '          '\n                   'Z\u00a0: ' Z-cnt OF Letter-disp.\n           STOP RUN.\n       \n       \n       END-PROGRAM.\n\n\nOutput:\nLetter Frequency Distribution\n-----------------------------\nA\u00a0:   416          N\u00a0:   434\nB\u00a0:   120          O\u00a0:   545\nC\u00a0:   316          P\u00a0:   215\nD\u00a0:   267          Q\u00a0:    12\nE\u00a0:   679          R\u00a0:   436\nF\u00a0:   122          S\u00a0:   432\nG\u00a0:   171          T\u00a0:   493\nH\u00a0:   131          U\u00a0:   180\nI\u00a0:   429          V\u00a0:    57\nJ\u00a0:    12          W\u00a0:    97\nK\u00a0:    17          X\u00a0:    35\nL\u00a0:   303          Y\u00a0:    50\nM\u00a0:   162          Z\u00a0:    60\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Ada", "code": "\nwith Ada.Text_IO;\n\nprocedure Letter_Frequency is\n   Counters: array (Character) of Natural := (others => 0); -- initialize all Counters to 0\n   C:        Character;\n   File:     Ada.Text_IO.File_Type;\n\nbegin\n   Ada.Text_IO.Open(File, Mode => Ada.Text_IO.In_File, Name => \"letter_frequency.adb\");\n   while not Ada.Text_IO.End_Of_File(File) loop\n      Ada.Text_IO.Get(File, C);\n      Counters(C) := Counters(C) + 1;\n   end loop;\n\n   for I in Counters'Range loop\n      if Counters(I) > 0 then\n            Ada.Text_IO.Put_Line(\"'\" & I & \"':\" & Integer'Image(Counters(I)));\n      end if;\n   end loop;\nend Letter_Frequency;\n\n\nOutput: (counting the characters of its own source code)\n\n>./letter_frequency\n' ': 122\n'\"': 6\n'&': 3\n\n... [a lot of lines omitted]\n\n'x': 7\n'y': 5\n'z': 1\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Julia", "code": "\nusing DataStructures\n \nfunction letterfreq(file::AbstractString; fltr::Function=(_) -> true)\n    sort(Dict(counter(filter(fltr, read(file, String)))))\nend\n \ndisplay(letterfreq(\"src/Letter_frequency.jl\"; fltr=isletter))\n\nOutput:\nDataStructures.OrderedDict{Char,Int64} with 29 entries:\n  'A' => 1\n  'C' => 1\n  'D' => 2\n  'F' => 1\n  'L' => 3\n  'S' => 2\n  'a' => 9\n  'b' => 1\n  'c' => 13\n  'd' => 5\n  'e' => 30\n  'f' => 13\n  'g' => 4\n  'h' => 10\n  'i' => 14\n  'j' => 1\n  'k' => 3\n  'l' => 11\n  'n' => 15\n  \u22ee   => \u22ee\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Kotlin", "code": "\n// version 1.1.2\n\nimport java.io.File\n\nfun main(args: Array<String>) {\n    val text = File(\"input.txt\").readText().toLowerCase()\n    val letterMap = text.filter { it in 'a'..'z' }.groupBy { it }.toSortedMap()\n    for (letter in letterMap) println(\"${letter.key} = ${letter.value.size}\")\n    val sum = letterMap.values.sumBy { it.size }\n    println(\"\\nTotal letters = $sum\")\n}\n\n\nOutput:\n\na = 3\nb = 2\nc = 2\nd = 2\ne = 4\nf = 2\ng = 2\nh = 3\ni = 2\nj = 2\nk = 2\nl = 2\nm = 2\nn = 2\no = 6\np = 2\nq = 2\nr = 3\ns = 2\nt = 3\nu = 4\nv = 2\nw = 2\nx = 2\ny = 2\nz = 2\n\nTotal letters = 64\n\n", "explain": "'input.txt' just contains two pangrams:\nThe quick brown fox jumps over the lazy dog.\nSphinx of black quartz, judge my vow.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Perl", "code": "\n\nwhile (<>) { $cnt{lc chop}++ while length }\nprint \"$_: \", $cnt{$_}//0, \"\\n\" for 'a' .. 'z';\n\n", "explain": "Counts letters in files given on command line or piped to stdin.  Case insensitive.\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Objective-C", "code": "\n#import <Foundation/Foundation.h>\n\nint main (int argc, const char *argv[]) {\n  @autoreleasepool {\n\n    NSData *data = [NSData dataWithContentsOfFile:@(argv[1])];\n    NSString *string = [[NSString alloc] initWithData:data encoding:NSUTF8StringEncoding];\n    NSCountedSet *countedSet = [[NSCountedSet alloc] init];\n    NSUInteger len = [string length];\n    for (NSUInteger i = 0; i < len; i++) {\n      unichar c = [string characterAtIndex:i];\n      if ([[NSCharacterSet letterCharacterSet] characterIsMember:c])\n        [countedSet addObject:@(c)];\n    }\n    for (NSNumber *chr in countedSet) {\n      NSLog(@\"%C => %lu\", (unichar)[chr integerValue], [countedSet countForObject:chr]);\n    }\n  \n  }\n  return 0;\n}\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Prolog", "code": "\n\nfrequency(File) :-\n\tread_file_to_codes(File, Code, []),\n\n\t% we only keep alphabetic codes\n\tinclude(my_code_type, Code, LstCharCode),\n\n\t% we translate char_codes into uppercase atoms.\n\tmaplist(my_upcase, LstCharCode, LstChar),\n\n\t% sort and pack the list\n\tmsort(LstChar, SortLstChar),\n\tpackList(SortLstChar, Freq),\n\tmaplist(my_write, Freq).\n\n\nmy_write([Num, Atom]) :-\n\tswritef(A, '%3r', [Num]),\n\twritef('Number of %w\u00a0:%w\\n', [Atom, A]).\n\n\nmy_code_type(Code) :-\n\tcode_type(Code, alpha).\n\nmy_upcase(CharCode, UpChar) :-\n\tchar_code(Atom, CharCode),\n\tupcase_atom(Atom, UpChar).\n\n:- use_module(library(clpfd)).\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\n%\u00a0?- packList([a,a,a,b,c,c,c,d,d,e], L).\n%  L = [[3,a],[1,b],[3,c],[2,d],[1,e]] .\n%\n%\u00a0?- packList(R,  [[3,a],[1,b],[3,c],[2,d],[1,e]]).\n% R = [a,a,a,b,c,c,c,d,d,e] .\n%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%\npackList([],[]).\n\npackList([X],[[1,X]]) :-\n\t!.\n\npackList([X|Rest],[XRun|Packed]):-\n\trun(X,Rest, XRun,RRest),\n\tpackList(RRest,Packed).\n\nrun(Var,[],[1,Var],[]).\n\nrun(Var,[Var|LRest],[N1, Var],RRest):-\n\tN #> 0,\n\tN1 #= N + 1,\n\trun(Var,LRest,[N, Var],RRest).\n\nrun(Var,[Other|RRest], [1,Var],[Other|RRest]):-\n\tdif(Var,Other).\n\n\nOutput: for this file\nNumber of A\u00a0: 63\nNumber of B\u00a0:  7\nNumber of C\u00a0: 53\nNumber of D\u00a0: 29\nNumber of E\u00a0: 65\n...\nNumber of T\u00a0: 52\nNumber of U\u00a0: 20\nNumber of V\u00a0: 10\nNumber of W\u00a0:  8\nNumber of X\u00a0:  6\nNumber of Y\u00a0: 12\ntrue .\n\n", "explain": "Works with SWI-Prolog. \nOnly alphabetic codes are computed in uppercase state. \nUses packlist/2 defined there\u00a0: Run-length encoding#Prolog \n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Lua", "code": "\n\n-- Return entire contents of named file\nfunction readFile (filename)\n  local file = assert(io.open(filename, \"r\"))\n  local contents = file:read(\"*all\")\n  file:close()\n  return contents\nend\n\n-- Return a closure to keep track of letter counts\nfunction tally ()\n  local t = {}\n  \n  -- Add x to tally if supplied, return tally list otherwise\n  local function count (x)\n    if x then\n      if t[x] then\n        t[x] = t[x] + 1\n      else\n        t[x] = 1\n      end\n    else\n      return t\n    end\n  end\n  \n  return count\nend\n\n-- Main procedure\nlocal letterCount = tally()\nfor letter in readFile(arg[1] or arg[0]):gmatch(\"%a\") do\n  letterCount(letter)\nend\nfor k, v in pairs(letterCount()) do\n  print(k, v)\nend\n\n\ni       24\nf       16\nR       2\nv       2\nc       19\nk       4\nM       1\ns       14\nd       17\nl       40\ne       61\nt       54\nm       4\nr       34\nu       18\nC       3\no       32\nA       1\ng       3\nx       7\nF       2\ny       4\nw       1\nn       42\nh       4\na       25\np       7\n", "explain": "This solution counts letters only, which could be changed by altering the pattern argument to 'gmatch' on line 31.  It also treats upper and lower case letters as distinct, which could be changed by changing everything to upper or lower case with string.upper() or string.lower() before tallying.\nOutput from running this script on itself:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Scala", "code": "\nimport io.Source.fromFile\n\ndef letterFrequencies(filename: String) = \n  fromFile(filename).mkString groupBy (c => c) mapValues (_.length)\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "D", "code": "\nvoid main() {\n    import std.stdio, std.ascii, std.algorithm, std.range;\n\n    uint[26] frequency;\n\n    foreach (const buffer; \"unixdict.txt\".File.byChunk(2 ^^ 15))\n        foreach (immutable c; buffer.filter!isAlpha)\n            frequency[c.toLower - 'a']++;\n\n    writefln(\"%(%(%s,\u00a0%),\\n%)\", frequency[].chunks(10));\n}\n\n\nOutput:\n16421, 4115, 8216, 5799, 20144, 2662, 4129, 5208, 13980, 430,\n1925, 10061, 5828, 12097, 12738, 5516, 378, 13436, 10210, 12836,\n6489, 1902, 1968, 617, 3633, 433\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Haskell", "code": "\n\nimport Data.List (group,sort)\nimport Control.Arrow ((&&&))\nmain = interact (show . map (head &&& length) . group . sort)\n\n\nimport Data.List (sortBy)\nimport qualified Data.Map.Strict as M\nimport Data.Ord (comparing)\n\ncharCounts :: String -> M.Map Char Int\ncharCounts = foldr (M.alter f) M.empty\n  where\n    f (Just x) = Just (succ x)\n    f _ = Just 1\n\nmain :: IO ()\nmain =\n  readFile \"miserables.txt\"\n    >>= mapM_ print\n      . sortBy\n        (flip $ comparing snd)\n      . M.toList\n      . charCounts\n\n\nOutput:\n(' ',516452)\n('e',325769)\n('t',222955)\n('a',199774)\n('o',180987)\n('h',170234)\n('n',166901)\n('i',165221)\n('s',157643)\n('r',145136)\n('d',106989)\n('l',97091)\n('\\n',73828)\n('u',67370)\n('c',62760)\n('m',56011)\n('f',53438)\n('w',53332)\n(',',48784)\n('g',46086)\n('p',39958)\n('y',37945)\n('b',34313)\n('.',30487)\n('v',24058)\n('\\8364',21159)\n('\\226',21155)\n('k',14110)\n('T',12571)\n('I',10067)\n('A',7359)\n('\\339',7121)\n('\\157',7033)\n('H',6605)\n('M',6208)\n(';',5885)\n('E',4969)\n('-',4775)\n('C',4594)\n('S',4404)\n('x',3694)\n('\\8482',3633)\n('!',3539)\n('R',3535)\n('P',3429)\n('O',3401)\n('j',3392)\n('B',3193)\n('W',3181)\n('\\8221',3071)\n('N',3053)\n('?',2976)\n('F',2768)\n('G',2512)\n(':',2463)\n('L',2452)\n('J',2448)\n('q',2398)\n('\\195',2296)\n('V',2210)\n('_',2068)\n('z',1847)\n('D',1758)\n('\\169',1328)\n('Y',1238)\n('U',900)\n('1',732)\n('8',412)\n('X',333)\n('K',323)\n('\\732',298)\n('\\168',294)\n('3',254)\n('2',242)\n('0',212)\n('5',208)\n('*',179)\n('(',172)\n(')',172)\n('4',170)\n('\\8240',146)\n('6',143)\n('7',140)\n('Q',135)\n('[',122)\n(']',122)\n('9',118)\n('\\166',107)\n('\\170',74)\n('Z',59)\n('\\162',56)\n('\\167',48)\n('\\174',39)\n('\\197',38)\n('\"',37)\n('\\188',37)\n('\\8220',35)\n('\\180',34)\n('|',24)\n('\\175',18)\n('\\185',18)\n('/',12)\n('\\8224',10)\n('\\187',9)\n('\\'',8)\n('+',5)\n('\\171',5)\n('\\710',5)\n('\\8217',3)\n('$',2)\n('\\177',2)\n('\\8225',2)\n('#',1)\n('%',1)\n('&',1)\n('@',1)\n('{',1)\n('}',1)\n('\\189',1)\n('\\194',1)\n", "explain": "Short version:\nor, as an alternative to sorting and grouping the whole string, we could use some kind of container as the accumulator for a single fold, for example:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "VBScript", "code": "\nfilepath = \"SPECIFY FILE PATH HERE\"\n\nSet objfso = CreateObject(\"Scripting.FileSystemObject\")\nSet objdict = CreateObject(\"Scripting.Dictionary\")\nSet objfile = objfso.OpenTextFile(filepath,1)\n\ntxt = objfile.ReadAll\n\nFor i = 1 To Len(txt)\n\tchar = Mid(txt,i,1)\n\tIf objdict.Exists(char) Then\n\t\tobjdict.Item(char) = objdict.Item(char) + 1\n\tElse\n\t\tobjdict.Add char,1\n\tEnd If\nNext\n\nFor Each key In objdict.Keys\n\tWScript.StdOut.WriteLine key & \" = \" & objdict.Item(key)\nNext\t\n\nobjfile.Close\nSet objfso = Nothing\nSet objdict = Nothing\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Scheme", "code": "\n\n(use-modules (ice-9 format))\n\n(define (char-freq port table)\n  (if\n   (eof-object? (peek-char port))\n   table\n   (char-freq port (add-char (read-char port) table))))\n\n(define (add-char char table)\n  (cond\n   ((null? table) (list (list char 1)))\n   ((eq? (caar table) char) (cons (list char (+ (cadar table) 1)) (cdr table)))\n   (#t (cons (car table) (add-char char (cdr table))))))\n\n(define (format-table table)\n  (for-each (lambda (t) (format #t \"~10s~10d~%\" (car t) (cadr t))) table))\n\n(define (print-freq filename)\n  (format-table (char-freq (open-input-file filename) '())))\n\n(print-freq \"letter-frequency.scm\")\n\n\n#\\(               45\n#\\u                5\n#\\s                9\n#\\e               47\n#\\-               19\n#\\m                9\n#\\o               16\n#\\d               19\n#\\l               25\n#\\space           83\n#\\i               15\n#\\c               28\n#\\9                1\n#\\f               20\n#\\r               39\n#\\a               47\n#\\t               36\n#\\)               45\n#\\newline         21\n#\\n               15\n#\\h               14\n#\\q                7\n#\\p                9\n#\\b               16\n#\\j                1\n#\\?                3\n#\\k                1\n#\\1                4\n#\\+                1\n#\\#                2\n#\\\"                4\n#\\~                3\n#\\0                2\n#\\%                1\n#\\'                1\n#\\y                1\n#\\.                1\n\n\n(with-input-from-string \"foobar\"\n  (lambda ()\n    (port-fold (lambda (x s)\n                 (alist-update x\n                               (add1 (alist-ref x s eq? 0))\n                               s))\n               '()\n               read-char)))\n\n\n", "explain": "Using guile scheme 2.0.11.\nNote that this prints the scheme representations of characters in no particular order.\nOutput when reading own source:\nAn implementation for CHICKEN scheme:\nwhich shows: ((#\\f . 1) (#\\o . 2) (#\\b . 1) (#\\a . 1) (#\\r . 1))\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "PowerShell", "code": "\nfunction frequency ($string) {\n    $arr = $string.ToUpper().ToCharArray() |where{$_ -match '[A-KL-Z]'} \n    $n = $arr.count\n    $arr | group | foreach{\n        [pscustomobject]@{letter = \"$($_.name)\"; frequency  = \"$([math]::round($($_.Count/$n),5))\"; count = \"$($_.count)\"}\n    } | sort letter\n}\n$file = \"$($MyInvocation.MyCommand.Name )\" #Put the name of your file here\nfrequency $(get-content $file -Raw)\n\n\nletter frequency count\n------ --------- -----\nA      0.06809   16   \nB      0.00426   1    \nC      0.06809   16   \nD      0.00851   2    \nE      0.11064   26   \nF      0.0383    9    \nG      0.01702   4    \nH      0.02979   7    \nI      0.03404   8    \nJ      0.00426   1    \nK      0.00426   1    \nL      0.02553   6    \nM      0.04255   10   \nN      0.09362   22   \nO      0.08085   19   \nP      0.02128   5    \nQ      0.01277   3    \nR      0.10638   25   \nS      0.02128   5    \nT      0.10213   24   \nU      0.05957   14   \nV      0.00426   1    \nW      0.00851   2    \nY      0.02979   7    \nZ      0.00426   1 \n\n", "explain": "Output:\n"}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "F#", "code": "\nlet alphabet =\n    ['A'..'Z'] |> Set.ofList\n\nlet letterFreq (text : string) =\n    text.ToUpper().ToCharArray()\n    |> Array.filter (fun x -> alphabet.Contains(x))\n    |> Seq.countBy (fun x -> x)\n    |> Seq.sort\n\nlet v = \"Now is the time for all good men to come to the aid of the party\"\n\nlet res = letterFreq v\n\nfor (letter, freq) in res do\n    printfn \"%A, %A\" letter freq\n\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "Groovy", "code": "\ndef frequency = { it.inject([:]) { map, value -> map[value] = (map[value] ?: 0) + 1; map } }\n\nfrequency(new File('frequency.groovy').text).each { key, value ->\n    println \"'$key': $value\"\n}\n\n\nOutput:\n'd': 1\n'e': 19\n'f': 4\n' ': 29\n'r': 5\n'q': 3\n'u': 8\n[lines omitted]\n'o': 2\n'x': 1\n'h': 1\n'k': 2\n'\"': 2\n'$': 2\n", "explain": ""}, {"task_name": "Letter frequency", "task_url": "https://rosettacode.org/wiki/Letter_frequency", "task_cat": "Randomness", "lang": "AWK", "code": "\n# usage: awk -f letters.awk HolyBible.txt\n\nBEGIN { FS=\"\" }\n      { for(i=1;i<=NF;i++) m[$i]++}\nEND   { for(i in m) printf(\"%9d\u00a0%-14s\\n\", m[i],i) }\n\n", "explain": ""}]