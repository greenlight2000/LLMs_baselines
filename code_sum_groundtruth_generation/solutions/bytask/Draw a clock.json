[{"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Python", "code": "\n\nWorks with: Python version 2.6+, 3.0+\nTextmode[edit]\nimport time\n\ndef chunks(l, n=5):\n    return [l[i:i+n] for i in range(0, len(l), n)]\n\ndef binary(n, digits=8):\n    n=int(n)\n    return '{0:0{1}b}'.format(n, digits)\n\ndef secs(n):\n    n=int(n)\n    h='x' * n\n    return \"|\".join(chunks(h))\n\ndef bin_bit(h):\n    h=h.replace(\"1\",\"x\")\n    h=h.replace(\"0\",\" \")\n    return \"|\".join(list(h))\n\n\nx=str(time.ctime()).split()\ny=x[3].split(\":\")\n\ns=y[-1]\ny=map(binary,y[:-1])\n\nprint bin_bit(y[0])\nprint\nprint bin_bit(y[1])\nprint\nprint secs(s)\n\nLibrary: VPython[edit]\n\n", "explain": "Think Geek Binary Clock\nThere is a 3D analog clock in the \nVPython contributed section\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "C", "code": "\n\n#include <stdio.h>\n#include <stdlib.h>\n#include <math.h>\n#include <time.h>\n#include <sys/time.h>\n \n#define PI 3.14159265\nconst char * shades = \" .:-*ca&#%@\";\n \n/* distance of (x, y) from line segment (0, 0)->(x0, y0) */\ndouble dist(double x, double y, double x0, double y0) {\n\tdouble l = (x * x0 + y * y0) / (x0 * x0 + y0 * y0);\n \n\tif (l > 1) {\n\t\tx -= x0;\n\t\ty -= y0;\n\t} else if (l >= 0) {\n\t\tx -= l * x0;\n\t\ty -= l * y0;\n\t}\n\treturn sqrt(x * x + y * y);\n}\n \nenum { sec = 0, min, hur }; // for subscripts\n \nvoid draw(int size)\n{\n#\tdefine for_i for(int i = 0; i < size; i++)\n#\tdefine for_j for(int j = 0; j < size * 2; j++)\n \n\tdouble angle, cx = size / 2.;\n\tdouble sx[3], sy[3], sw[3];\n\tdouble fade[] = { 1, .35, .35 }; /* opacity of each arm */\n\tstruct timeval tv;\n\tstruct tm *t;\n \n\t/* set width of each arm */\n\tsw[sec] = size * .02;\n\tsw[min] = size * .03;\n\tsw[hur] = size * .05;\n \nevery_second:\n\tgettimeofday(&tv, 0);\n\tt = localtime(&tv.tv_sec);\n \n\tangle = t->tm_sec * PI / 30;\n\tsy[sec] = -cx * cos(angle);\n\tsx[sec] =  cx * sin(angle);\n \n\tangle = (t->tm_min + t->tm_sec / 60.) / 30 * PI;\n\tsy[min] = -cx * cos(angle) * .8;\n\tsx[min] =  cx * sin(angle) * .8;\n \n\tangle = (t->tm_hour + t->tm_min / 60.) / 6 * PI;\n\tsy[hur] = -cx * cos(angle) * .6;\n\tsx[hur] =  cx * sin(angle) * .6;\n \n\tprintf(\"\\033[s\"); /* save cursor position */\n\tfor_i {\n\t\tprintf(\"\\033[%d;0H\", i);  /* goto row i, col 0 */\n\t\tdouble y = i - cx;\n\t\tfor_j {\n\t\t\tdouble x = (j - 2 * cx) / 2;\n \n\t\t\tint pix = 0;\n\t\t\t/* calcs how far the \"pixel\" is from each arm and set\n\t\t\t * shade, with some anti-aliasing.  It's ghetto, but much\n\t\t\t * easier than a real scanline conversion.\n\t\t\t */\n\t\t\tfor (int k = hur; k >= sec; k--) {\n\t\t\t\tdouble d = dist(x, y, sx[k], sy[k]);\n\t\t\t\tif (d < sw[k] - .5)\n\t\t\t\t\tpix = 10 * fade[k];\n\t\t\t\telse if (d < sw[k] + .5)\n\t\t\t\t\tpix = (5 + (sw[k] - d) * 10) * fade[k];\n\t\t\t}\n\t\t\tputchar(shades[pix]);\n\t\t}\n\t}\n\tprintf(\"\\033[u\"); /* restore cursor pos so you can bg the job -- value unclear */\n \n\tfflush(stdout);\n\tsleep(1); /* sleep 1 can at times miss a second, but will catch up next update */\n\tgoto every_second;\n}\n \nint main(int argc, char *argv[])\n{\n\tint s;\n\tif (argc <= 1 || (s = atoi(argv[1])) <= 0) s = 20;\n\tdraw(s);\n\treturn 0;\n}\n\nClock in xlib (for X windows)[edit]\n// clockrosetta.c - https://rosettacode.org/wiki/Draw_a_clock\n\n// # Makefile\n// CFLAGS = -O3 -Wall -Wfatal-errors -Wpedantic -Werror\n// LDLIBS = -lX11 -lXext -lm\n// all:  clockrosetta\n\n#define SIZE 500\n\n#include <X11/Xlib.h>\n#include <X11/Xutil.h>\n#include <stdio.h>\n#include <stdlib.h>\n#include <unistd.h>\n#include <sys/select.h>\n#include <time.h>\n#include <X11/extensions/Xdbe.h>\n#include <math.h>\n\nstatic XdbeBackBuffer dbewindow = 0;\nstatic Display *display;\nstatic Window window;\nstatic int needseg = 1;\nstatic double d2r;\nstatic XSegment seg[61];\nstatic GC gc;\nstatic int mw = SIZE / 2;\nstatic int mh = SIZE / 2;\n\nstatic void\ndraw(void)\n  {\n  struct tm *ptm;\n  int i;\n  double angle;\n  double delta;\n  int radius = (mw < mh ? mw : mh) - 2;\n  XPoint pt[3];\n  double onetwenty = 3.1415926 * 2 / 3;\n  XdbeSwapInfo swapi;\n   time_t newtime;\n\n  if(dbewindow == 0)\n    {\n    dbewindow = XdbeAllocateBackBufferName(display, window, XdbeBackground);\n    XClearWindow(display, window);\n    }\n\n  time(&newtime);\n  ptm = localtime(&newtime);\n\n  if(needseg)\n    {\n    d2r = atan2(1.0, 0.0) / 90.0;\n    for(i = 0; i < 60; i++)\n      {\n      angle = (double)i * 6.0 * d2r;\n      delta = i % 5 ? 0.97 : 0.9;\n      seg[i].x1 = mw + radius * delta * sin(angle);\n      seg[i].y1 = mh - radius * delta * cos(angle);\n      seg[i].x2 = mw + radius * sin(angle);\n      seg[i].y2 = mh - radius * cos(angle);\n      }\n    needseg = 0;\n    }\n\n  angle = (double)(ptm->tm_sec) * 6.0 * d2r;\n  seg[60].x1 = mw;\n  seg[60].y1 = mh;\n  seg[60].x2 = mw + radius * 0.9 * sin(angle);\n  seg[60].y2 = mh - radius * 0.9 * cos(angle);\n  XDrawSegments(display, dbewindow, gc, seg, 61);\n\n  angle = (double)ptm->tm_min * 6.0 * d2r;\n  pt[0].x = mw + radius * 3 / 4 * sin(angle);\n  pt[0].y = mh - radius * 3 / 4 * cos(angle);\n  pt[1].x = mw + 6 * sin(angle + onetwenty);\n  pt[1].y = mh - 6 * cos(angle + onetwenty);\n  pt[2].x = mw + 6 * sin(angle - onetwenty);\n  pt[2].y = mh - 6 * cos(angle - onetwenty);\n  XFillPolygon(display, dbewindow, gc, pt, 3, Nonconvex, CoordModeOrigin);\n\n  angle = (double)(ptm->tm_hour * 60 + ptm->tm_min) / 2.0 * d2r;\n  pt[0].x = mw + radius / 2 * sin(angle);\n  pt[0].y = mh - radius / 2 * cos(angle);\n  pt[1].x = mw + 6 * sin(angle + onetwenty);\n  pt[1].y = mh - 6 * cos(angle + onetwenty);\n  pt[2].x = mw + 6 * sin(angle - onetwenty);\n  pt[2].y = mh - 6 * cos(angle - onetwenty);\n  XFillPolygon(display, dbewindow, gc, pt, 3, Nonconvex, CoordModeOrigin);\n\n  swapi.swap_window = window;\n  swapi.swap_action = XdbeBackground;\n  XdbeSwapBuffers(display, &swapi, 1);\n  }\n\nint\nmain(int argc, char *argv[])\n  {\n  Atom wm_both_protocols[1];\n  Atom wm_delete;\n  Atom wm_protocols;\n  Window root;\n  XEvent event;\n  XSetWindowAttributes attr;\n  fd_set fd;\n  int exposed = 0;\n  int more = 1;\n  struct timeval tv;\n\n  display = XOpenDisplay(NULL);\n\n  if(display == NULL)\n    {\n    fprintf(stderr,\"Error: The display cannot be opened\\n\");\n    exit(1);\n    }\n\n  root = DefaultRootWindow(display);\n  wm_delete = XInternAtom(display, \"WM_DELETE_WINDOW\", False);\n  wm_protocols = XInternAtom(display, \"WM_PROTOCOLS\", False);\n\n  attr.background_pixel = 0x000000;\n  attr.event_mask = KeyPress | KeyRelease |\n    ButtonPressMask | ButtonReleaseMask | ExposureMask;\n\n  window = XCreateWindow(display, root,\n    0, 0, SIZE, SIZE, 0,\n    CopyFromParent, InputOutput, CopyFromParent,\n    CWBackPixel | CWEventMask,\n    &attr\n    );\n\n  XStoreName(display, window, \"Clock for RosettaCode\");\n\n  wm_both_protocols[0] = wm_delete;\n  XSetWMProtocols(display, window, wm_both_protocols, 1);\n\n  gc = XCreateGC(display, window, 0, NULL);\n  XSetForeground(display, gc, 0xFFFF80);\n\n  XMapWindow(display, window);\n\n  while(more)\n    {\n    if(QLength(display) > 0)\n      {\n      XNextEvent(display, &event);\n      }\n    else\n      {\n      int maxfd = ConnectionNumber(display);\n\n      XFlush(display);\n      FD_ZERO(&fd);\n      FD_SET(ConnectionNumber(display), &fd);\n\n      event.type = LASTEvent;\n      tv.tv_sec = 0;\n      tv.tv_usec = 250000;\n      if(select(maxfd + 1, &fd, NULL, NULL, &tv) > 0)\n        {\n        if(FD_ISSET(ConnectionNumber(display), &fd))\n          {\n          XNextEvent(display, &event);\n          }\n        }\n      }\n\n    switch(event.type)\n      {\n    case Expose:\n      exposed = 1;\n      draw();\n      break;\n\n    case ButtonRelease:\n    case KeyRelease:\n      more = 0;\n    case ButtonPress:  // ignore\n    case KeyPress:     // ignore\n      break;\n\n    case LASTEvent:  // the timeout comes here\n      if(exposed) draw();\n      break;\n\n    case ConfigureNotify:\n      mw = event.xconfigure.width / 2;\n      mh = event.xconfigure.height / 2;\n      needseg = 1;\n      break;\n\n\n    case ClientMessage: // for close request from WM\n      if(event.xclient.window == window &&\n        event.xclient.message_type == wm_protocols &&\n        event.xclient.format == 32 &&\n        event.xclient.data.l[0] == wm_delete)\n        {\n        more = 0;\n        }\n      break;\n\n//    default:\n//      printf(\"unexpected event.type %d\\n\", event.type);;\n      }\n    }\n\n  XCloseDisplay(display);\n  exit(0);\n  }\n\n// END\n\n", "explain": "Draws a crude clock in terminal.  C99, compiled with gcc -std=c99.\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "C++", "code": "\n\n#include <windows.h>\n#include <string>\n#include <math.h>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nconst int BMP_SIZE = 300, MY_TIMER = 987654, CENTER = BMP_SIZE >> 1, SEC_LEN = CENTER - 20,\n          MIN_LEN = SEC_LEN - 20, HOUR_LEN = MIN_LEN - 20;\nconst float PI = 3.1415926536f;\n\n//--------------------------------------------------------------------------------------------------\nclass vector2\n{\npublic:\n    vector2() { x = y = 0; }\n    vector2( int a, int b ) { x = a; y = b; }\n    void set( int a, int b ) { x = a; y = b; }\n    void rotate( float angle_r )\n    {\n\tfloat _x = static_cast<float>( x ),\n\t      _y = static_cast<float>( y ),\n\t       s = sinf( angle_r ),\n\t       c = cosf( angle_r ),\n\t       a = _x * c - _y * s,\n\t       b = _x * s + _y * c;\n\n\tx = static_cast<int>( a );\n\ty = static_cast<int>( b );\n    }\n    int x, y;\n};\n//--------------------------------------------------------------------------------------------------\nclass myBitmap\n{\npublic:\n    myBitmap() : pen( NULL ), brush( NULL ), clr( 0 ), wid( 1 ) {}\n    ~myBitmap()\n    {\n\tDeleteObject( pen );\n\tDeleteObject( brush );\n\tDeleteDC( hdc );\n\tDeleteObject( bmp );\n    }\n\n    bool create( int w, int h )\n    {\n\tBITMAPINFO    bi;\n\tZeroMemory( &bi, sizeof( bi ) );\n\tbi.bmiHeader.biSize        = sizeof( bi.bmiHeader );\n\tbi.bmiHeader.biBitCount    = sizeof( DWORD ) * 8;\n\tbi.bmiHeader.biCompression = BI_RGB;\n\tbi.bmiHeader.biPlanes      = 1;\n\tbi.bmiHeader.biWidth       =  w;\n\tbi.bmiHeader.biHeight      = -h;\n\n\tHDC dc = GetDC( GetConsoleWindow() );\n\tbmp = CreateDIBSection( dc, &bi, DIB_RGB_COLORS, &pBits, NULL, 0 );\n\tif( !bmp ) return false;\n\n\thdc = CreateCompatibleDC( dc );\n\tSelectObject( hdc, bmp );\n\tReleaseDC( GetConsoleWindow(), dc );\n\n\twidth = w; height = h;\n\treturn true;\n    }\n\n    void clear( BYTE clr = 0 )\n    {\n\tmemset( pBits, clr, width * height * sizeof( DWORD ) );\n    }\n\n    void setBrushColor( DWORD bClr )\n    {\n\tif( brush ) DeleteObject( brush );\n\tbrush = CreateSolidBrush( bClr );\n\tSelectObject( hdc, brush );\n    }\n\n    void setPenColor( DWORD c )\n    {\n\tclr = c;\n\tcreatePen();\n    }\n\n    void setPenWidth( int w )\n    {\n\twid = w;\n\tcreatePen();\n    }\n\n    void saveBitmap( string path )\n    {\n\tBITMAPFILEHEADER fileheader;\n\tBITMAPINFO       infoheader;\n\tBITMAP           bitmap;\n\tDWORD            wb;\n\n\tGetObject( bmp, sizeof( bitmap ), &bitmap );\n\tDWORD* dwpBits = new DWORD[bitmap.bmWidth * bitmap.bmHeight];\n\t\n        ZeroMemory( dwpBits, bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD ) );\n\tZeroMemory( &infoheader, sizeof( BITMAPINFO ) );\n\tZeroMemory( &fileheader, sizeof( BITMAPFILEHEADER ) );\n\n\tinfoheader.bmiHeader.biBitCount = sizeof( DWORD ) * 8;\n\tinfoheader.bmiHeader.biCompression = BI_RGB;\n\tinfoheader.bmiHeader.biPlanes = 1;\n\tinfoheader.bmiHeader.biSize = sizeof( infoheader.bmiHeader );\n\tinfoheader.bmiHeader.biHeight = bitmap.bmHeight;\n\tinfoheader.bmiHeader.biWidth = bitmap.bmWidth;\n\tinfoheader.bmiHeader.biSizeImage = bitmap.bmWidth * bitmap.bmHeight * sizeof( DWORD );\n\n\tfileheader.bfType    = 0x4D42;\n\tfileheader.bfOffBits = sizeof( infoheader.bmiHeader ) + sizeof( BITMAPFILEHEADER );\n\tfileheader.bfSize    = fileheader.bfOffBits + infoheader.bmiHeader.biSizeImage;\n\n\tGetDIBits( hdc, bmp, 0, height, ( LPVOID )dwpBits, &infoheader, DIB_RGB_COLORS );\n\n\tHANDLE file = CreateFile( path.c_str(), GENERIC_WRITE, 0, NULL, CREATE_ALWAYS, FILE_ATTRIBUTE_NORMAL, NULL );\n\tWriteFile( file, &fileheader, sizeof( BITMAPFILEHEADER ), &wb, NULL );\n\tWriteFile( file, &infoheader.bmiHeader, sizeof( infoheader.bmiHeader ), &wb, NULL );\n\tWriteFile( file, dwpBits, bitmap.bmWidth * bitmap.bmHeight * 4, &wb, NULL );\n\tCloseHandle( file );\n\n\tdelete [] dwpBits;\n    }\n\n    HDC getDC() const     { return hdc; }\n    int getWidth() const  { return width; }\n    int getHeight() const { return height; }\n\nprivate:\n    void createPen()\n    {\n\tif( pen ) DeleteObject( pen );\n\tpen = CreatePen( PS_SOLID, wid, clr );\n\tSelectObject( hdc, pen );\n    }\n\n    HBITMAP bmp;\n    HDC     hdc;\n    HPEN    pen;\n    HBRUSH  brush;\n    void    *pBits;\n    int     width, height, wid;\n    DWORD   clr;\n};\n//--------------------------------------------------------------------------------------------------\nclass clock\n{\npublic:\n    clock()  \n    {\n\t_bmp.create( BMP_SIZE, BMP_SIZE );\n\t_bmp.clear( 100 );\n\t_bmp.setPenWidth( 2 );\n\t_ang = DegToRadian( 6 );\n    }\n\t\n    void setNow()\n    {\n\tGetLocalTime( &_sysTime );\n\tdraw();\n    }\n\n    float DegToRadian( float degree ) { return degree * ( PI / 180.0f ); }\n\n    void setHWND( HWND hwnd ) { _hwnd = hwnd; }\n\nprivate:\n    void drawTicks( HDC dc )\n    {\n\tvector2 line;\n\t_bmp.setPenWidth( 1 );\n\tfor( int x = 0; x < 60; x++ )\n\t{\n\t    line.set( 0, 50 );\n\t    line.rotate( static_cast<float>( x + 30 ) * _ang );\n\t    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );\n\t    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );\n\t}\n\n\t_bmp.setPenWidth( 3 );\n\tfor( int x = 0; x < 60; x += 5 )\n\t{\n\t    line.set( 0, 50 );\n\t    line.rotate( static_cast<float>( x + 30 ) * _ang );\n\t    MoveToEx( dc, CENTER - static_cast<int>( 2.5f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.5f * static_cast<float>( line.y ) ), NULL );\n\t    LineTo( dc, CENTER - static_cast<int>( 2.81f * static_cast<float>( line.x ) ), CENTER - static_cast<int>( 2.81f * static_cast<float>( line.y ) ) );\n\t}\n    }\n\n    void drawHands( HDC dc )\n    {\n\tfloat hp = DegToRadian( ( 30.0f * static_cast<float>( _sysTime.wMinute ) ) / 60.0f );\n\tint h = ( _sysTime.wHour > 12 ? _sysTime.wHour - 12 : _sysTime.wHour ) * 5;\n\t\t\n\t_bmp.setPenWidth( 3 );\n\t_bmp.setPenColor( RGB( 0, 0, 255 ) );\n\tdrawHand( dc, HOUR_LEN, ( _ang * static_cast<float>( 30 + h ) ) + hp );\n\n\t_bmp.setPenColor( RGB( 0, 128, 0 ) );\n\tdrawHand( dc, MIN_LEN, _ang * static_cast<float>( 30 + _sysTime.wMinute ) );\n\n\t_bmp.setPenWidth( 2 );\n\t_bmp.setPenColor( RGB( 255, 0, 0 ) );\n\tdrawHand( dc, SEC_LEN, _ang * static_cast<float>( 30 + _sysTime.wSecond ) );\n    }\n\n    void drawHand( HDC dc, int len, float ang )\n    {\n\tvector2 line;\n\tline.set( 0, len );\n\tline.rotate( ang );\n\tMoveToEx( dc, CENTER, CENTER, NULL );\n\tLineTo( dc, line.x + CENTER, line.y + CENTER );\n    }\n\n    void draw()\n    {\n\tHDC dc = _bmp.getDC();\n\n\t_bmp.setBrushColor( RGB( 250, 250, 250 ) );\n\tEllipse( dc, 0, 0, BMP_SIZE, BMP_SIZE );\n\t_bmp.setBrushColor( RGB( 230, 230, 230 ) );\n\tEllipse( dc, 10, 10, BMP_SIZE - 10, BMP_SIZE - 10 );\n\n\tdrawTicks( dc );\n\tdrawHands( dc );\n\n\t_bmp.setPenColor( 0 ); _bmp.setBrushColor( 0 );\n\tEllipse( dc, CENTER - 5, CENTER - 5, CENTER + 5, CENTER + 5 );\n\n\t_wdc = GetDC( _hwnd );\n\tBitBlt( _wdc, 0, 0, BMP_SIZE, BMP_SIZE, dc, 0, 0, SRCCOPY );\n\tReleaseDC( _hwnd, _wdc );\n    }\n\n    myBitmap   _bmp;\n    HWND       _hwnd;\n    HDC        _wdc;\n    SYSTEMTIME _sysTime;\n    float      _ang;\n};\n//--------------------------------------------------------------------------------------------------\nclass wnd\n{\npublic:\n    wnd() { _inst = this; }\n    int wnd::Run( HINSTANCE hInst )\n    {\n\t_hInst = hInst;\n\t_hwnd = InitAll();\n\tSetTimer( _hwnd, MY_TIMER, 1000, NULL );\n\t_clock.setHWND( _hwnd );\n\n\tShowWindow( _hwnd, SW_SHOW );\n\tUpdateWindow( _hwnd );\n\n\tMSG msg;\n\tZeroMemory( &msg, sizeof( msg ) );\n\twhile( msg.message != WM_QUIT )\n\t{\n\t    if( PeekMessage( &msg, NULL, 0, 0, PM_REMOVE ) != 0 )\n\t    {\n\t\tTranslateMessage( &msg );\n\t\tDispatchMessage( &msg );\n\t    }\n\t}\n\treturn UnregisterClass( \"_MY_CLOCK_\", _hInst );\n    }\nprivate:\n    void wnd::doPaint( HDC dc ) { _clock.setNow(); }\n    void wnd::doTimer()         { _clock.setNow(); }\n    static int WINAPI wnd::WndProc( HWND hWnd, UINT msg, WPARAM wParam, LPARAM lParam )\n    {\n\tswitch( msg )\n\t{\n\t    case WM_DESTROY: PostQuitMessage( 0 ); break;\n\t    case WM_PAINT:\n\t    {\n\t\tPAINTSTRUCT ps;\n\t\tHDC dc = BeginPaint( hWnd, &ps );\n\t\t_inst->doPaint( dc );\n\t\tEndPaint( hWnd, &ps );\n\t\treturn 0;\n\t    }\n\t    case WM_TIMER: _inst->doTimer(); break;\n\t    default:\n\t\treturn DefWindowProc( hWnd, msg, wParam, lParam );\n\t}\n\treturn 0;\n    }\n\n    HWND InitAll()\n    {\n\tWNDCLASSEX wcex;\n\tZeroMemory( &wcex, sizeof( wcex ) );\n\twcex.cbSize           = sizeof( WNDCLASSEX );\n\twcex.style           = CS_HREDRAW | CS_VREDRAW;\n\twcex.lpfnWndProc   = ( WNDPROC )WndProc;\n\twcex.hInstance     = _hInst;\n\twcex.hCursor       = LoadCursor( NULL, IDC_ARROW );\n\twcex.hbrBackground = ( HBRUSH )( COLOR_WINDOW + 1 );\n\twcex.lpszClassName = \"_MY_CLOCK_\";\n\n\tRegisterClassEx( &wcex );\n\n\tRECT rc = { 0, 0, BMP_SIZE, BMP_SIZE };\n\tAdjustWindowRect( &rc, WS_SYSMENU | WS_CAPTION, FALSE );\n\tint w = rc.right - rc.left, h = rc.bottom - rc.top;\n\treturn CreateWindow( \"_MY_CLOCK_\", \".: Clock -- PJorente\u00a0:.\", WS_SYSMENU, CW_USEDEFAULT, 0, w, h, NULL, NULL, _hInst, NULL );\n    }\n\n    static wnd* _inst;\n    HINSTANCE  _hInst;\n    HWND       _hwnd;\n    clock      _clock;\n};\nwnd* wnd::_inst = 0;\n//--------------------------------------------------------------------------------------------------\nint APIENTRY _tWinMain( HINSTANCE hInstance, HINSTANCE hPrevInstance, LPTSTR lpCmdLine, int nCmdShow )\n{\n    wnd myWnd;\n    return myWnd.Run( hInstance );\n}\n//--------------------------------------------------------------------------------------------------\n\n", "explain": "\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Java", "code": "\nWorks with: Java version 8\nimport java.awt.*;\nimport java.awt.event.*;\nimport static java.lang.Math.*;\nimport java.time.LocalTime;\nimport javax.swing.*;\n\nclass Clock extends JPanel {\n\n    final float degrees06 = (float) (PI / 30);\n    final float degrees30 = degrees06 * 5;\n    final float degrees90 = degrees30 * 3;\n\n    final int size = 590;\n    final int spacing = 40;\n    final int diameter = size - 2 * spacing;\n    final int cx = diameter / 2 + spacing;\n    final int cy = diameter / 2 + spacing;\n\n    public Clock() {\n        setPreferredSize(new Dimension(size, size));\n        setBackground(Color.white);\n\n        new Timer(1000, (ActionEvent e) -> {\n            repaint();\n        }).start();\n    }\n\n    @Override\n    public void paintComponent(Graphics gg) {\n        super.paintComponent(gg);\n        Graphics2D g = (Graphics2D) gg;\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING,\n                RenderingHints.VALUE_ANTIALIAS_ON);\n\n        drawFace(g);\n\n        final LocalTime time  = LocalTime.now();\n        int hour = time.getHour();\n        int minute = time.getMinute();\n        int second = time.getSecond();\n\n        float angle = degrees90 - (degrees06 * second);\n        drawHand(g, angle, diameter / 2 - 30, Color.red);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        drawHand(g, angle, diameter / 3 + 10, Color.black);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        drawHand(g, angle, diameter / 4 + 10, Color.black);\n    }\n\n    private void drawFace(Graphics2D g) {\n        g.setStroke(new BasicStroke(2));\n        g.setColor(Color.white);\n        g.fillOval(spacing, spacing, diameter, diameter);\n        g.setColor(Color.black);\n        g.drawOval(spacing, spacing, diameter, diameter);\n    }\n\n    private void drawHand(Graphics2D g, float angle, int radius, Color color) {\n        int x = cx + (int) (radius * cos(angle));\n        int y = cy - (int) (radius * sin(angle));\n        g.setColor(color);\n        g.drawLine(cx, cy, x, y);\n    }\n\n    public static void main(String[] args) {\n        SwingUtilities.invokeLater(() -> {\n            JFrame f = new JFrame();\n            f.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);\n            f.setTitle(\"Clock\");\n            f.setResizable(false);\n            f.add(new Clock(), BorderLayout.CENTER);\n            f.pack();\n            f.setLocationRelativeTo(null);\n            f.setVisible(true);\n        });\n    }\n}\n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "C#", "code": "\nusing System;\nusing System.Drawing;\nusing System.Drawing.Drawing2D;\nusing System.Windows.Forms;\n\npublic class Clock : Form\n{\n    static readonly float degrees06 = (float)Math.PI / 30;\n    static readonly float degrees30 = degrees06 * 5;\n    static readonly float degrees90 = degrees30 * 3;\n\n    readonly int margin = 20;\n\n    private Point p0;\n\n    public Clock()\n    {\n        Size = new Size(500, 500);\n        StartPosition = FormStartPosition.CenterScreen;\n        Resize += (sender, args) => ResetSize();\n        ResetSize();\n        var timer = new Timer() { Interval = 1000, Enabled = true };\n        timer.Tick += (sender, e) => Refresh();\n        DoubleBuffered = true;\n    }\n\n    private void ResetSize()\n    {\n        p0 = new Point(ClientRectangle.Width / 2, ClientRectangle.Height / 2);\n        Refresh();\n    }\n\n    protected override void OnPaint(PaintEventArgs e)\n    {\n        base.OnPaint(e);\n        e.Graphics.SmoothingMode = SmoothingMode.AntiAlias;\n\n        drawFace(e.Graphics);\n\n        var time = DateTime.Now;\n        int second = time.Second;\n        int minute = time.Minute;\n        int hour = time.Hour;\n\n        float angle = degrees90 - (degrees06 * second);\n        DrawHand(e.Graphics, Pens.Red, angle, 0.95);\n\n        float minsecs = (minute + second / 60.0F);\n        angle = degrees90 - (degrees06 * minsecs);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.9);\n\n        float hourmins = (hour + minsecs / 60.0F);\n        angle = degrees90 - (degrees30 * hourmins);\n        DrawHand(e.Graphics, Pens.Black, angle, 0.6);\n    }\n\n    private void drawFace(Graphics g)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n        g.FillEllipse(Brushes.White, p0.X - radius, p0.Y - radius, radius * 2, radius * 2);\n\n        for (int h = 0; h < 12; h++)\n            DrawHand(g, Pens.LightGray, h * degrees30, -0.05);\n\n        for (int m = 0; m < 60; m++)\n            DrawHand(g, Pens.LightGray, m * degrees06, -0.025);\n    }\n\n    private void DrawHand(Graphics g, Pen pen, float angle, double size)\n    {\n        int radius = Math.Min(p0.X, p0.Y) - margin;\n\n        int x0 = p0.X + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Cos(angle)));\n        int y0 = p0.Y + (size > 0 ? 0 : Convert.ToInt32(radius * (1 + size) * Math.Sin(-angle)));\n\n        int x1 = p0.X + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Cos(angle));\n        int y1 = p0.Y + Convert.ToInt32(radius * (size > 0 ? size : 1) * Math.Sin(-angle));\n\n        g.DrawLine(pen, x0, y0, x1, y1);\n    }\n\n    [STAThread]\n    static void Main()\n    {\n        Application.Run(new Clock());\n    }\n}\n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "JavaScript", "code": "\n\nvar sec_old = 0;\nfunction update_clock() {\n\tvar t = new Date();\n\tvar arms = [t.getHours(), t.getMinutes(), t.getSeconds()];\n\tif (arms[2] == sec_old) return;\n\tsec_old = arms[2];\n\n\tvar c = document.getElementById('clock');\n\tvar ctx = c.getContext('2d');\n\tctx.fillStyle = \"rgb(0,200,200)\";\n\tctx.fillRect(0, 0, c.width, c.height);\n\tctx.fillStyle = \"white\";\n\tctx.fillRect(3, 3, c.width - 6, c.height - 6);\n\tctx.lineCap = 'round';\n\n\tvar orig = { x: c.width / 2, y: c.height / 2 };\n\tarms[1] += arms[2] / 60;\n\tarms[0] += arms[1] / 60;\n\tdraw_arm(ctx, orig, arms[0] * 30, c.width/2.5 - 15, c.width / 20,  \"green\");\n\tdraw_arm(ctx, orig, arms[1] * 6,  c.width/2.2 - 10, c.width / 30,  \"navy\");\n\tdraw_arm(ctx, orig, arms[2] * 6,  c.width/2.0 - 6,  c.width / 100, \"maroon\");\n}\n\nfunction draw_arm(ctx, orig, deg, len, w, style)\n{\n\tctx.save();\n\tctx.lineWidth = w;\n\tctx.lineCap = 'round';\n\tctx.translate(orig.x, orig.y);\n\tctx.rotate((deg - 90) * Math.PI / 180);\n\tctx.strokeStyle = style;\n\tctx.beginPath();\n\tctx.moveTo(-len / 10, 0);\n\tctx.lineTo(len, 0);\n\tctx.stroke();\n\tctx.restore();\n}\n\nfunction init_clock() {\n\tvar clock = document.createElement('canvas');\n\tclock.width = 100;\n\tclock.height = 100;\n\tclock.id = \"clock\";\n\tdocument.body.appendChild(clock);\n\n\twindow.setInterval(update_clock, 200);\n}\n\ndigital[edit]\n<!DOCTYPE html>\n<html lang=\"en\">\n<head>\n    <meta charset=\"UTF-8\">\n    <style>\n        canvas {\n            background-color: black;\n        }\n    </style>\n</head>\n<body>\n    <canvas></canvas>\n    <script>\n        var canvas = document.querySelector(\"canvas\");\n        canvas.width = window.innerWidth;\n        canvas.height = window.innerHeight;\n\n        var g = canvas.getContext(\"2d\");\n\n        // which leds are on or off for each digit\n        var masks = [\"1110111\", \"0010010\", \"1011101\", \"1011011\", \"0111010\",\n            \"1101011\", \"1101111\", \"1010010\", \"1111111\", \"1111011\"];\n\n        // horizontal and vertical layouts in scalable units\n        var vertices = [\n            [\n                [0, 0], [1, 1], [7, 1], [8, 0], [7, -1], [1, -1]\n            ],\n            [\n                [0, 0], [-1, 1], [-1, 7], [0, 8], [1, 7], [1, 1]\n            ]\n        ];        \n\n        function Led(x, y, idx, ox, oy) {\n            // starting points in scalable units \n            this.x = x;\n            this.y = y;\n\n            // horizontal or vertical layout\n            this.idx = idx;\n\n            // pixel values to create small gaps between the leds\n            this.offset_x = ox;\n            this.offset_y = oy;\n        }\n\n        var leds = [];\n        leds.push(new Led(0, 0, 0, 0, -1));\n        leds.push(new Led(0, 0, 1, -1, 0));\n        leds.push(new Led(8, 0, 1, 1, 0));\n        leds.push(new Led(0, 8, 0, 0, 1));\n        leds.push(new Led(0, 8, 1, -1, 2));\n        leds.push(new Led(8, 8, 1, 1, 2));\n        leds.push(new Led(0, 16, 0, 0, 3));\n\n        var onColor, offColor;\n\n        function drawDigitalClock(color1, color2, size) {\n\n            var clockWidth = (6 * 15 + 2 * 10) * size;\n            var clockHeight = 20 * size;\n            var x = (canvas.width - clockWidth) / 2;\n            var y = (canvas.height - clockHeight) / 2;\n\n            onColor = color1;\n            offColor = color2;\n\n            g.clearRect(0, 0, canvas.width, canvas.height);\n\n            var date = new Date();\n            var segments = [date.getHours(), date.getMinutes(), date.getSeconds()];\n\n            segments.forEach(function (value, index) {\n                x = drawDigits(x, y, size, value);\n                if (index < 2) {\n                    x = drawSeparator(x, y, size);\n                }\n            });\n        }\n\n        function drawDigits(x, y, size, timeUnit) {\n\n            var digit1 = Math.floor(timeUnit / 10);\n            var digit2 = timeUnit % 10;\n\n            x = drawLeds(x, y, size, masks[digit1]);\n            x = drawLeds(x, y, size, masks[digit2]);\n\n            return x;\n        }\n\n        function drawSeparator(x, y, size) {\n\n            g.fillStyle = onColor;\n            g.fillRect(x + 0.5 * size, y + 3 * size, 2 * size, 2 * size);\n            g.fillRect(x + 0.5 * size, y + 10 * size, 2 * size, 2 * size);\n\n            return x + size * 10;\n        }\n\n        function drawLeds(x, y, size, mask) {\n\n            leds.forEach(function (led, i) {\n\n                g.fillStyle = mask[i] == '1' ? onColor : offColor;\n\n                var xx = x + led.x * size + led.offset_x;\n                var yy = y + led.y * size + led.offset_y;\n\n                drawLed(xx, yy, size, vertices[led.idx]);\n            });\n\n            return x + size * 15;\n        }\n\n        function drawLed(x, y, size, vertices) {\n\n            g.beginPath();\n            g.moveTo(x, y);\n\n            vertices.forEach(function (vertex) {\n                g.lineTo(x + vertex[0] * size, y + vertex[1] * size);\n            });\n\n            g.closePath();\n            g.fill();\n        }\n\n        setInterval(drawDigitalClock, 1000, \"#00FF00\", \"#002200\", 12);\n    </script>\n\n</body>\n</html>\n\n", "explain": "Tested on Gecko.  Put the following in a <script> tag somewhere, and call init_clock() after body load.\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Fortran", "code": "\n\n!Digital Text implemented as in C version - Anant Dixit (Oct, 2014)\nprogram clock\nimplicit none\ninteger :: t(8)\ndo\n  call date_and_time(values=t)\n  call sleep(1)\n  call system('clear')\n  call digital_display(t(5),t(6),t(7))\nend do\nend program\n\nsubroutine digital_display(H,M,S)\n!arguments\ninteger :: H, M, S\n!local\ncharacter(len=*), parameter :: nfmt='(A8)', cfmt='(A6)'\ncharacter(len=88), parameter :: d1 = ' 00000     1     22222   33333      4   5555555  66666  7777777  88888   99999        '\ncharacter(len=88), parameter :: d2 = '0     0   11    2     2 3     3    44   5       6     6 7     7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d3 = '0    00  1 1          2       3   4 4   5       6             7 8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d4 = '0   0 0    1         2        3  4  4   5       6            7  8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d5 = '0  0  0    1        2      333  4444444 555555  666666      7    88888   999999       '\ncharacter(len=88), parameter :: d6 = '0 0   0    1       2          3     4         5 6     6    7    8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d7 = '00    0    1      2           3     4         5 6     6   7     8     8       9 \u00a0::   '\ncharacter(len=88), parameter :: d8 = '0     0    1     2      3     3     4   5     5 6     6  7      8     8 9     9 \u00a0::   '\ncharacter(len=88), parameter :: d9 = ' 00000  1111111 2222222  33333      4    55555   66666  7        88888   99999        '\ninteger :: h1, h2, m1, m2, s1, s2\nh1 = 1+8*floor(dble(H)/10.D0)\nh2 = 1+8*modulo(H,10)\nm1 = 1+8*floor(dble(M)/10.D0)\nm2 = 1+8*modulo(M,10)\ns1 = 1+8*floor(dble(S)/10.D0)\ns2 = 1+8*modulo(S,10)\n\nwrite(*,nfmt,advance='no') d1(h1:h1+8)\nwrite(*,nfmt,advance='no') d1(h2:h2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(m1:m1+8)\nwrite(*,nfmt,advance='no') d1(m2:m2+8)\nwrite(*,cfmt,advance='no') d1(81:88)\nwrite(*,nfmt,advance='no') d1(s1:s1+8)\nwrite(*,nfmt) d1(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d2(h1:h1+8)\nwrite(*,nfmt,advance='no') d2(h2:h2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(m1:m1+8)\nwrite(*,nfmt,advance='no') d2(m2:m2+8)\nwrite(*,cfmt,advance='no') d2(81:88)\nwrite(*,nfmt,advance='no') d2(s1:s1+8)\nwrite(*,nfmt) d2(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d3(h1:h1+8)\nwrite(*,nfmt,advance='no') d3(h2:h2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(m1:m1+8)\nwrite(*,nfmt,advance='no') d3(m2:m2+8)\nwrite(*,cfmt,advance='no') d3(81:88)\nwrite(*,nfmt,advance='no') d3(s1:s1+8)\nwrite(*,nfmt) d3(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d4(h1:h1+8)\nwrite(*,nfmt,advance='no') d4(h2:h2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(m1:m1+8)\nwrite(*,nfmt,advance='no') d4(m2:m2+8)\nwrite(*,cfmt,advance='no') d4(81:88)\nwrite(*,nfmt,advance='no') d4(s1:s1+8)\nwrite(*,nfmt) d4(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d5(h1:h1+8)\nwrite(*,nfmt,advance='no') d5(h2:h2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(m1:m1+8)\nwrite(*,nfmt,advance='no') d5(m2:m2+8)\nwrite(*,cfmt,advance='no') d5(81:88)\nwrite(*,nfmt,advance='no') d5(s1:s1+8)\nwrite(*,nfmt) d5(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d6(h1:h1+8)\nwrite(*,nfmt,advance='no') d6(h2:h2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(m1:m1+8)\nwrite(*,nfmt,advance='no') d6(m2:m2+8)\nwrite(*,cfmt,advance='no') d6(81:88)\nwrite(*,nfmt,advance='no') d6(s1:s1+8)\nwrite(*,nfmt) d6(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d7(h1:h1+8)\nwrite(*,nfmt,advance='no') d7(h2:h2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(m1:m1+8)\nwrite(*,nfmt,advance='no') d7(m2:m2+8)\nwrite(*,cfmt,advance='no') d7(81:88)\nwrite(*,nfmt,advance='no') d7(s1:s1+8)\nwrite(*,nfmt) d7(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d8(h1:h1+8)\nwrite(*,nfmt,advance='no') d8(h2:h2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(m1:m1+8)\nwrite(*,nfmt,advance='no') d8(m2:m2+8)\nwrite(*,cfmt,advance='no') d8(81:88)\nwrite(*,nfmt,advance='no') d8(s1:s1+8)\nwrite(*,nfmt) d8(s2:s2+8)\n\nwrite(*,nfmt,advance='no') d9(h1:h1+8)\nwrite(*,nfmt,advance='no') d9(h2:h2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(m1:m1+8)\nwrite(*,nfmt,advance='no') d9(m2:m2+8)\nwrite(*,cfmt,advance='no') d9(81:88)\nwrite(*,nfmt,advance='no') d9(s1:s1+8)\nwrite(*,nfmt) d9(s2:s2+8)\n\nend subroutine\n\n\n\n\n 22222   33333           1     88888           1       1    \n2     2 3     3 \u00a0::     11    8     8 \u00a0::     11      11    \n      2       3 \u00a0::    1 1    8     8 \u00a0::    1 1     1 1    \n     2        3 \u00a0::      1    8     8 \u00a0::      1       1    \n    2      333           1     88888           1       1    \n   2          3 \u00a0::      1    8     8 \u00a0::      1       1    \n  2           3 \u00a0::      1    8     8 \u00a0::      1       1    \n 2      3     3 \u00a0::      1    8     8 \u00a0::      1       1    \n2222222  33333        1111111  88888        1111111 1111111 \n\n\n", "explain": "Uses system commands to clear the screen, sleep and obtain time\nPreview:\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Scratch", "code": "\n\n", "explain": "One can view the Scratch solution to this task and inspect its code at the Scratch Website.  (The code for visual programming languages is difficult to post directly here at Rosetta Code.)\nTrue to the spirit of the task description, this is a very bare-bones clock.  It's a blank-faced analog clock having second (red), minute (green) and hour (blue) hands.  Each hand is a sprite, which has its own script to provide a movement.  When the program is started, all hands are positioned at the pivot and rotated to indicate the current (apparently local) time.  The second hand is then put into an infinite loop that provides the tick, moving it every second to the current second.  I found that a loop delay of 0.1 seconds resulted is smooth operation of the second hand.  When the second hand reaches 0, it broadcasts a set_minute signal.  Acting upon this signal, the minute hand advances to the current minute.  When the minute is 0 modulo 12, is broadcasts a set_hour signal.  The hour hand responds to this signal by advancing by a fifth of an hour (so that like the minute and second hands, it advances 60 times as it makes a complete circuit of the clock face).\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Go", "code": "\npackage main\n\nimport (\n\t\"golang.org/x/net/websocket\"\n\t\"flag\"\n\t\"fmt\"\n\t\"html/template\"\n\t\"io\"\n\t\"math\"\n\t\"net/http\"\n\t\"time\"\n)\n\nvar (\n\tPortnum  string\n\tHostsite string\n)\n\ntype PageSettings struct {\n\tHost string\n\tPort string\n}\n\nconst (\n\tCanvaswidth  = 512\n\tCanvasheight = 512\n\t//color constants\n\tHourColor   = \"#ff7373\" // pinkish\n\tMinuteColor = \"#00b7e4\" //light blue\n\tSecondColor = \"#b58900\" //gold\n)\n\nfunc main() {\n\tflag.StringVar(&Portnum, \"Port\", \"1234\", \"Port to host server.\")\n\tflag.StringVar(&Hostsite, \"Site\", \"localhost\", \"Site hosting server\")\n\tflag.Parse()\n\thttp.HandleFunc(\"/\", webhandler)\n\thttp.Handle(\"/ws\", websocket.Handler(wshandle))\n\terr := http.ListenAndServe(Hostsite+\":\"+Portnum, nil)\n\tif err != nil {\n\t\tfmt.Println(err)\n\t}\n\tfmt.Println(\"server running\")\n}\n\nfunc webhandler(w http.ResponseWriter, r *http.Request) {\n\twsurl := PageSettings{Host: Hostsite, Port: Portnum}\n\ttemplate, _ := template.ParseFiles(\"clock.html\")\n\ttemplate.Execute(w, wsurl)\n}\n\n//Given a websocket connection,\n//serves updating time function\nfunc wshandle(ws *websocket.Conn) {\n\tfor {\n\t\thour, min, sec := time.Now().Clock()\n\t\thourx, houry := HourCords(hour, Canvasheight/2)\n\t\tminx, miny := MinSecCords(min, Canvasheight/2)\n\t\tsecx, secy := MinSecCords(sec, Canvasheight/2)\n\t\tmsg := \"CLEAR\\n\"\n\t\tmsg += fmt.Sprintf(\"HOUR %d %d %s\\n\", hourx, houry, HourColor)\n\t\tmsg += fmt.Sprintf(\"MIN %d %d %s\\n\", minx, miny, MinuteColor)\n\t\tmsg += fmt.Sprintf(\"SEC %d %d %s\", secx, secy, SecondColor)\n\t\tio.WriteString(ws, msg)\n\t\ttime.Sleep(time.Second / 60.0)\n\t}\n}\n\n//Given current minute or second time(i.e 30 min, 60 minutes)\n//and the radius, returns pair of cords to draw line to\nfunc MinSecCords(ctime int, radius int) (int, int) {\n\t//converts min/sec to angle and then to radians\n\n\ttheta := ((float64(ctime)*6 - 90) * (math.Pi / 180))\n\tx := float64(radius) * math.Cos(theta)\n\ty := float64(radius) * math.Sin(theta)\n\treturn int(x) + 256, int(y) + 256\n}\n\n//Given current hour time(i.e. 12, 8) and the radius,\n//returns pair of cords to draw line to\nfunc HourCords(ctime int, radius int) (int, int) {\n\t//converts hours to angle and then to radians\n\ttheta := ((float64(ctime)*30 - 90) * (math.Pi / 180))\n\tx := float64(radius) * math.Cos(theta)\n\ty := float64(radius) * math.Sin(theta)\n\treturn int(x) + 256, int(y) + 256\n}\n\n\n<!DOCTYPE html>\n<meta charset=\"utf-8\" />\n<title>Clock</title>\n<script language=\"javascript\" type=\"text/javascript\">\n\n  var connurl = \"ws://{{.Host}}:{{.Port}}/ws\";\n  //var ctx;\n  var secondhand;\n  var minutehand;\n  var hourhand;\n  function wsConnect()\n  {\n\t//get contexts for drawing\n    //var canvas = document.getElementById( \"canvas\" );\n    //ctx = canvas.getContext( '2d' );\n\tvar canvas = document.getElementById(\"rim\");\n    //draw circle for rim\n    rim =  canvas.getContext('2d');\n    rim.beginPath();\n    rim.arc(256,256,256,0,2*Math.PI);\n    rim.stroke();\n    //minute hand\n    canvas = document.getElementById(\"minutehand\");\n    minutehand = canvas.getContext('2d');\n    //hour hand\n    canvas = document.getElementById(\"hourhand\");\n    hourhand = canvas.getContext('2d');\n    //second hand\n    canvas = document.getElementById(\"secondhand\");\n    secondhand = canvas.getContext('2d');\n\n    ws = new WebSocket( connurl );\n    ws.onopen = function( e ) {\n      console.log( \"CONNECTED\" );\n      ws.send( \"READY\" );\n    };\n    /*ws.onclose = function( e ) { \n      console.log( \"DISCONNECTED\" );\n    };*/\n    ws.onmessage = function( e ) {\n      var data = e.data.split(\"\\n\");\n      for ( var line in data ) {\n        var msg = data[line].split(\" \");\n        var cmd = msg[0];\n        if (cmd ==\"CLEAR\"){\n          minutehand.clearRect(0,0,512,512);\n          secondhand.clearRect(0,0,512,512);\n          hourhand.clearRect(0,0,512,512);\n        }else if (cmd === \"HOUR\"){\n          renderline(hourhand, msg);\n        }else if (cmd === \"MIN\"){\n          renderline(minutehand, msg);\n        }else if (cmd === \"SEC\"){\n          renderline(secondhand, msg);\n        }else if (cmd ===\"\"){\n          cmd = \"\";\n        }else{\n          console.log(\"BAD COMMAND: \"+cmd + \"; \"+msg);\n        }\n      }\n    };\n    ws.onerror = function( e ) {\n      console.log( 'WS Error: ' + e.data );\n    };\n  }\n  //render line given paramets\n  function renderline(ctx, msg){\n    ctx.clearRect(0,0,512,512);\n    ctx.width = ctx.width;\n    var x = parseInt(msg[1],10);\n    var y = parseInt(msg[2],10);\n    var color = msg[3];\n    ctx.strokeStyle = color;\n    ctx.beginPath();\n    ctx.moveTo(256,256);\n    ctx.lineTo(x,y);\n    ctx.stroke();\n  }\n\n  window.addEventListener( \"load\", wsConnect, false );\n\n</script>\n\n<body>\n    <h2>Clock</h2>\n\t\n  <canvas id=\"rim\" width=\"512\" height=\"512\" style=\"position: absolute; left: 0; top: 0; z-index: 0;\">\n        Sorry, your browser does not support Canvas\n  </canvas>\n\t<canvas id=\"hourhand\" width=\"512\" height=\"512\"style=\"position: absolute; left: 0; top: 0; z-index: 1;\">\n        Sorry, your browser does not support Canvas\n  </canvas>\n\t<canvas id=\"minutehand\" width=\"512\" height=\"512\"style=\"position: absolute; left: 0; top: 0; z-index: 2;\">\n        Sorry, your browser does not support Canvas\n  </canvas>\n\t<canvas id=\"secondhand\" width=\"512\" height=\"512\"style=\"position: absolute; left: 0; top: 0; z-index: 3;\">\n        Sorry, your browser does not support Canvas\n  </canvas>\n\t\n</body>\n</html>\n\n", "explain": "The following html file, 'clock.html', should be in the same folder as the wsclock binary.\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Delphi", "code": "\nLibrary:  Winapi.Windows\nLibrary:  System.SysUtils\nLibrary:  System.Classes\nLibrary:  Vcl.Graphics\nLibrary:  Vcl.Forms\nLibrary:  Vcl.ExtCtrls\nTranslation of: C#\n\nunit main;\n\ninterface\n\nuses\n  Winapi.Windows, System.SysUtils, System.Classes, Vcl.Graphics, Vcl.Forms,\n  Vcl.ExtCtrls;\n\ntype\n  TClock = class(TForm)\n    tmrTimer: TTimer;\n    procedure FormResize(Sender: TObject);\n    procedure tmrTimerTimer(Sender: TObject);\n  private\n    { Private declarations }\n    const\n      degrees06 = PI / 30;\n      degrees30 = degrees06 * 5;\n      degrees90 = degrees30 * 3;\n      margin = 20;\n    var\n      p0: TPoint;\n      MinP0XY: Integer;\n    class function IfThen(Condition: Boolean; TrueValue, FalseValue: Integer):\n      Integer; overload; static;\n    class function IfThen(Condition: Boolean; TrueValue, FalseValue: Double):\n      Double; overload; static;\n    procedure Paint; override;\n    procedure DrawHand(Color: TColor; Angle, Size: Double; aWidth: Integer = 2);\n    procedure DrawFace;\n    procedure DrawCenter;\n    procedure DrawNumbers(Angle: Double; Value: Integer);\n  public\n    { Public declarations }\n  end;\n\nvar\n  Clock: TClock;\n\nimplementation\n\n{$R *.dfm}\n\n{ TClock }\n\nprocedure TClock.DrawCenter;\nvar\n  radius: Integer;\nbegin\n  radius := 6;\n  with Canvas do\n  begin\n    pen.Color := clNone;\n    Brush.Color := clBlack;\n    Ellipse(p0.x - radius, p0.y - radius, p0.x + radius, p0.y + radius);\n  end;\nend;\n\nprocedure TClock.DrawFace;\nvar\n  radius, h, m: Integer;\nbegin\n  radius := MinP0XY - margin;\n  with Canvas do\n  begin\n    Pen.Color := clBlack;\n    Pen.Width := 2;\n    Brush.Color := clWhite;\n    Ellipse(p0.x - radius, p0.y - radius, p0.x + radius, p0.y + radius);\n    for m := 0 to 59 do\n      DrawHand(clGray, m * degrees06, -0.08, 2);\n\n    for h := 0 to 11 do\n    begin\n      DrawHand(clBlack, h * degrees30, -0.09, 3);\n      DrawNumbers((h + 3) * degrees30, 12 - h);\n    end;\n  end;\nend;\n\nprocedure TClock.DrawHand(Color: TColor; Angle, Size: Double; aWidth: Integer = 2);\nvar\n  radius, x0, y0, x1, y1: Integer;\nbegin\n  radius := MinP0XY - margin;\n\n  x0 := p0.X + (IfThen(Size > 0, 0, Round(radius * (Size + 1) * cos(Angle))));\n  y0 := p0.Y + (IfThen(Size > 0, 0, Round(radius * (Size + 1) * sin(-Angle))));\n\n  x1 := p0.X + round(radius * IfThen(Size > 0, Size, 1) * cos(Angle));\n  y1 := p0.y + round(radius * IfThen(Size > 0, Size, 1) * sin(-Angle));\n\n  with Canvas do\n  begin\n    Pen.Color := Color;\n    pen.Width := aWidth;\n    MoveTo(x0, y0);\n    LineTo(x1, y1);\n  end;\nend;\n\nprocedure TClock.DrawNumbers(Angle: Double; Value: Integer);\nvar\n  radius, x0, y0, x1, y1, h, w: Integer;\n  Size: Double;\n  s: string;\nbegin\n  radius := MinP0XY - margin;\n  Size := 0.85;\n  s := (Value).ToString;\n\n  x1 := p0.X + round(radius * Size * cos(Angle));\n  y1 := p0.y + round(radius * Size * sin(-Angle));\n\n  with Canvas do\n  begin\n    radius := 5;\n    Font.Size := 12;\n    w := TextWidth(s);\n    h := TextHeight(s);\n\n    x0 := x1 - (w div 2);\n    y0 := y1 - (h div 2);\n\n    TextOut(x0, y0, s);\n  end;\nend;\n\nprocedure TClock.FormResize(Sender: TObject);\nbegin\n  p0 := Tpoint.create(ClientRect.CenterPoint);\n  MinP0XY := p0.x;\n  if MinP0XY > p0.Y then\n    MinP0XY := p0.y;\n  Refresh();\nend;\n\nclass function TClock.IfThen(Condition: Boolean; TrueValue, FalseValue: Double): Double;\nbegin\n  if Condition then\n    exit(TrueValue);\n  exit(FalseValue);\nend;\n\nclass function TClock.IfThen(Condition: Boolean; TrueValue, FalseValue: Integer): Integer;\nbegin\n  if Condition then\n    exit(TrueValue);\n  exit(FalseValue);\nend;\n\nprocedure TClock.Paint;\nvar\n  t: TDateTime;\n  second, minute, hour: Integer;\n  angle, minsecs, hourmins: Double;\nbegin\n  inherited;\n\n  t := time;\n  second := trunc(Frac(t * 24 * 60) * 60);\n  minute := trunc(Frac(t * 24) * 60);\n  hour := trunc(t * 24);\n\n  DrawFace;\n\n  angle := degrees90 - (degrees06 * second);\n  DrawHand(clred, angle, 0.95, 3);\n\n  minsecs := (minute + second / 60.0);\n\n  angle := degrees90 - (degrees06 * minsecs);\n  DrawHand(clGreen, angle, 0.8, 4);\n\n  hourmins := (hour + minsecs / 60.0);\n  angle := degrees90 - (degrees30 * hourmins);\n  DrawHand(clBlue, angle, 0.6, 5);\n\n  DrawCenter;\n\n  Caption := Format('%.2d:%.2d:%.2d', [hour, minute, second]);\nend;\n\nprocedure TClock.tmrTimerTimer(Sender: TObject);\nbegin\n  Refresh;\nend;\n\nend.\n\n\nobject Clock: TClock\n  Left = 0\n  Top = 0\n  Caption = 'Draw_a_clock'\n  ClientHeight = 462\n  ClientWidth = 484\n  Color = clBtnFace\n  DoubleBuffered = True\n  Font.Charset = DEFAULT_CHARSET\n  Font.Color = clWindowText\n  Font.Height = -11\n  Font.Name = 'Tahoma'\n  Font.Style = []\n  OldCreateOrder = False\n  Position = poDesktopCenter\n  OnResize = FormResize\n  PixelsPerInch = 96\n  TextHeight = 13\n  object tmrTimer: TTimer\n    OnTimer = tmrTimerTimer\n    Left = 16\n    Top = 8\n  end\nend\n\n\n\nOutput:\n\n", "explain": "Form application\nResources:\n\n[1]\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Ruby", "code": "\nLibrary: Shoes\nSample display of Ruby solution\nShoes.app(:width=>205, :height => 228, :title => \"A Clock\") do\n  def draw_ray(width, start, stop, ratio)\n    angle = Math::PI * 2 * ratio - Math::PI/2\n    strokewidth width\n    cos = Math::cos(angle)\n    sin = Math::sin(angle)\n    line 101+cos*start, 101+sin*start, 101+cos*stop, 101+sin*stop\n  end\n\n  def update\n    t = Time.now\n    @time.text = t.strftime(\"%H:%M:%S\")\n    h, m, s = (t.hour % 12).to_f, t.min.to_f, t.sec.to_f\n    s += t.to_f - t.to_i  # add the fractional seconds\n\n    @hands.clear do\n      draw_ray(3, 0, 70, (h + m/60)/12)\n      draw_ray(2, 0, 90, (m + s/60)/60)\n      draw_ray(1, 0, 95, s/60)\n    end\n  end\n\n  # a place for the text display\n  @time = para(:align=>\"center\", :family => \"monospace\")\n\n  # draw the clock face\n  stack(:width=>203, :height=>203) do\n    strokewidth 1\n    fill gradient(deepskyblue, aqua)\n    oval 1, 1, 200\n    fill black\n    oval 98, 98, 6\n    # draw the minute indicators\n    0.upto(59) {|m| draw_ray(1, (m % 5 == 0 ? 96 : 98), 100, m.to_f/60)}\n  end.move(0,23)\n\n  # the drawing area for the hands\n  @hands = stack(:width=>203, :height=>203) {}.move(0,23)\n\n  animate(5) {update}\nend\n\n\nBerlin-Uhr clock\nShoes.app(:title => \"Berlin-Uhr Clock\", :width => 209, :height => 300) do\n  background lightgrey\n\n  Red = rgb(255, 20, 20)\n  Yellow = rgb(173, 255, 47)\n  Green = rgb(154, 205, 50)\n  Gray = rgb(128, 128, 128)\n\n  @time = para(:align => \"center\")\n  stack do\n    fill Gray\n    stroke black\n    strokewidth 2\n    @seconds = oval 75, 3, 50\n    @hrs_a  =  4.times.collect {|i| rect   51*i,  56, 48, 30, 4}\n    @hrs_b  =  4.times.collect {|i| rect   51*i,  89, 48, 30, 4}\n    @mins_a = 11.times.collect {|i| rect 2+18*i, 122, 15, 30, 4}\n    @mins_b =  4.times.collect {|i| rect   51*i, 155, 48, 30, 4}\n    # some decoration\n    fill white\n    stroke darkslategray\n    rect -10, -30, 75, 70, 10\n    rect 140, -30, 75, 70, 10\n    rect -13, 192, 105, 100, 10\n    rect 110, 192, 105, 100, 10\n  end.move(3,20)\n    \n  animate(1) do\n    now = Time.now\n    @time.text = now.strftime(\"%H:%M:%S\")\n    @seconds.style(:fill => now.sec.even? ? Green : Gray)\n    a, b = now.hour.divmod(5)\n    4.times {|i| @hrs_a[i].style(:fill => i < a ? Red : Gray)}\n    4.times {|i| @hrs_b[i].style(:fill => i < b ? Red : Gray)}\n    a, b = now.min.divmod(5)\n    11.times {|i| @mins_a[i].style(:fill => i < a ? (i%3==2 ? Red : Yellow) : Gray)}\n    4.times  {|i| @mins_b[i].style(:fill => i < b ? Yellow : Gray)}\n  end\n  \n  keypress do |key|\n    case key\n    when :control_q, \"\\x11\" then exit\n    end\n  end\nend\n\nLibrary: RubyGems\nLibrary: JRubyArt\n\ndef setup\n  sketch_title 'Clock'\n  stroke 255\n  font = create_font 'NimbusRoman-Regular', 20\n  text_font font\nend\n\ndef draw\n  background 0\n  fill 80\n  no_stroke\n  clock_x = lambda do |val, adj, length|\n    DegLut.cos((val * adj).to_i - 90) * length + width / 2\n  end\n  clock_y = lambda do |val, adj, length|\n    DegLut.sin((val * adj).to_i - 90) * length + height / 2\n  end\n  ellipse 100, 100, 160, 160\n  stroke 220\n  stroke_weight 6\n  t = Time.now\n  line(100, 100, clock_x.call(t.hour % 12 + (t.min / 60.0), 30, 50),\n    clock_y.call(t.hour % 12 + (t.min / 60.0), 30, 50))\n  stroke_weight 3\n  line(100, 100, clock_x.call(t.min + (t.sec / 60.0), 6, 60),\n    clock_y.call(t.min + (t.sec / 60.0), 6, 60))\n  stroke 255, 0, 0\n  stroke_weight 1\n  line(100, 100, clock_x.call(t.sec, 6, 72), clock_y.call(t.sec, 6, 72))\n  # Draw the minute ticks\n  stroke_weight 2\n  stroke 255\n  (0..360).step(6) do |a|\n    x = 100 + DegLut.cos(a) * 72\n    y = 100 + DegLut.sin(a) * 72\n    point x, y\n  end\n  fill 200\n  text t.strftime('%H:%M:%S'), 50, 200\nend\n\ndef settings\n  size 200, 220\n  smooth 8\nend\n\n", "explain": "Inspired by the PicoLisp solution, here's an implementation of the Berlin-Uhr clock.\nJRubyArt is port of processing to ruby\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Rust", "code": "\n// cargo-deps: time=\"0.1\"\nextern crate time;\n\nuse std::thread;\nuse std::time::Duration;\n\nconst TOP: &str = \" \u284e\u2889\u28b5 \u2800\u28ba\u2800 \u280a\u2809\u2871 \u280a\u28c9\u2871 \u2880\u2814\u2847 \u28cf\u28c9\u2849 \u28ce\u28c9\u2841 \u280a\u2889\u281d \u288e\u28c9\u2871 \u284e\u2809\u28b1 \u2800\u2836\u2800\";\nconst BOT: &str = \" \u2897\u28c1\u2878 \u2880\u28f8\u28c0 \u28d4\u28c9\u28c0 \u2884\u28c0\u2878 \u2809\u2809\u284f \u2884\u28c0\u2878 \u2887\u28c0\u2878 \u28b0\u2801\u2800 \u2887\u28c0\u2878 \u2888\u28c9\u2879 \u2800\u2836\u2800\";\n\nfn main() {\n    let top: Vec<&str> = TOP.split_whitespace().collect();\n    let bot: Vec<&str> = BOT.split_whitespace().collect();\n\n    loop {\n        let tm = &time::now().rfc822().to_string()[17..25];\n        let top_str: String = tm.chars().map(|x| top[x as usize - '0' as usize]).collect();\n        let bot_str: String = tm.chars().map(|x| bot[x as usize - '0' as usize]).collect();\n\n        clear_screen();\n        println!(\"{}\", top_str);\n        println!(\"{}\", bot_str);\n\n        thread::sleep(Duration::from_secs(1));\n    }\n}\n\nfn clear_screen() {\n    println!(\"{}[H{}[J\", 27 as char, 27 as char);\n}\n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Ada", "code": "\nLibrary: SDLAda\nwith Ada.Numerics.Elementary_Functions;\nwith Ada.Calendar.Formatting;\nwith Ada.Calendar.Time_Zones;\n\nwith SDL.Video.Windows.Makers;\nwith SDL.Video.Renderers.Makers;\nwith SDL.Events.Events;\n\nprocedure Draw_A_Clock is\n   use Ada.Calendar;\n   use Ada.Calendar.Formatting;\n   Window   : SDL.Video.Windows.Window;\n   Renderer : SDL.Video.Renderers.Renderer;\n   Event    : SDL.Events.Events.Events;\n   Offset   : Time_Zones.Time_Offset;\n\n   procedure Draw_Clock (Stamp : Time)\n   is\n      use SDL.C;\n      use Ada.Numerics.Elementary_Functions;\n      Radi : constant array (0 .. 59) of int := (0 | 15 | 30 | 45 => 2,\n                                                 5 | 10 | 20 | 25 | 35 | 40 | 50 | 55 => 1,\n                                                 others => 0);\n      Diam : constant array (0 .. 59) of int := (0 | 15 | 30 | 45 => 5,\n                                                 5 | 10 | 20 | 25 | 35 | 40 | 50 | 55 => 3,\n                                                 others => 1);\n      Width  : constant int   := Window.Get_Surface.Size.Width;\n      Height : constant int   := Window.Get_Surface.Size.Height;\n      Radius : constant Float := Float (int'Min (Width, Height));\n      R_1    : constant Float := 0.48 * Radius;\n      R_2    : constant Float := 0.35 * Radius;\n      R_3    : constant Float := 0.45 * Radius;\n      R_4    : constant Float := 0.47 * Radius;\n      Hour   : constant Hour_Number   := Formatting.Hour   (Stamp, Offset);\n      Minute : constant Minute_Number := Formatting.Minute (Stamp, Offset);\n      Second : constant Second_Number := Formatting.Second (Stamp);\n\n      function To_X (A : Float; R : Float) return int is\n         (Width / 2 + int (R * Sin (A, 60.0)));\n\n      function To_Y (A : Float; R : Float) return int is\n         (Height / 2 - int (R * Cos (A, 60.0)));\n\n   begin\n      SDL.Video.Renderers.Makers.Create (Renderer, Window.Get_Surface);\n      Renderer.Set_Draw_Colour ((0, 0, 150, 255));\n      Renderer.Fill (Rectangle => (0, 0, Width, Height));\n      Renderer.Set_Draw_Colour ((200, 200, 200, 255));\n      for A in 0 .. 59 loop\n         Renderer.Fill (Rectangle => (To_X (Float (A), R_1) - Radi (A),\n                                      To_Y (Float (A), R_1) - Radi (A), Diam (A), Diam (A)));\n      end loop;\n      Renderer.Set_Draw_Colour ((200, 200, 0, 255));\n      Renderer.Draw (Line => ((Width / 2, Height / 2),\n                              (To_X (5.0 * (Float (Hour) + Float (Minute) / 60.0), R_2),\n                               To_Y (5.0 * (Float (Hour) + Float (Minute) / 60.0), R_2))));\n      Renderer.Draw (Line => ((Width / 2, Height / 2),\n                              (To_X (Float (Minute) + Float (Second) / 60.0, R_3),\n                               To_Y (Float (Minute) + Float (Second) / 60.0, R_3))));\n      Renderer.Set_Draw_Colour ((220, 0, 0, 255));\n      Renderer.Draw (Line => ((Width / 2, Height / 2),\n                              (To_X (Float (Second), R_4),\n                               To_Y (Float (Second), R_4))));\n      Renderer.Fill (Rectangle => (Width / 2 - 3, Height / 2 - 3, 7, 7));\n   end Draw_Clock;\n\n   function Poll_Quit return Boolean is\n      use type SDL.Events.Event_Types;\n   begin\n      while SDL.Events.Events.Poll (Event) loop\n         if Event.Common.Event_Type = SDL.Events.Quit then\n            return True;\n         end if;\n      end loop;\n      return False;\n   end Poll_Quit;\n\nbegin\n   Offset := Time_Zones.UTC_Time_Offset;\n\n   if not SDL.Initialise (Flags => SDL.Enable_Screen) then\n      return;\n   end if;\n\n   SDL.Video.Windows.Makers.Create (Win      => Window,\n                                    Title    => \"Draw a clock\",\n                                    Position => SDL.Natural_Coordinates'(X => 10, Y => 10),\n                                    Size     => SDL.Positive_Sizes'(300, 300),\n                                    Flags    => SDL.Video.Windows.Resizable);\n   loop\n      Draw_Clock (Clock);\n      Window.Update_Surface;\n      delay 0.200;\n      exit when Poll_Quit;\n   end loop;\n\n   Window.Finalize;\n   SDL.Finalise;\nend Draw_A_Clock;\n\n\n", "explain": "\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Julia", "code": "\nusing Gtk, Colors, Graphics, Dates\n\nconst radius = 300\nconst win = GtkWindow(\"Clock\", radius, radius)\nconst can = GtkCanvas()\npush!(win, can)\n\nglobal drawcontext = []\n\nfunction drawline(ctx, l, color)\n    isempty(l) && return\n    p = first(l)\n    move_to(ctx, p.x, p.y)\n    set_source(ctx, color)\n    for i = 2:length(l)\n        p = l[i]\n        line_to(ctx, p.x, p.y)\n    end\n    stroke(ctx)\nend\n\nfunction clockbody(ctx)\n    set_coordinates(ctx, BoundingBox(0, 100, 0, 100))\n    rectangle(ctx, 0, 0, 100, 100)\n    set_source(ctx, colorant\"yellow\")\n    fill(ctx)\n    set_source(ctx, colorant\"blue\")\n    arc(ctx, 50, 50, 45, 45, 360)\n    stroke(ctx)\n    for hr in 1:12\n        radians = hr * pi / 6.0\n        drawline(ctx, [Point(50 + 0.95 * 45 * sin(radians),\n            50 - 0.95 * 45 * cos(radians)),\n            Point(50 + 1.0 * 45 * sin(radians),\n            50 - 1.0 * 45 * cos(radians))], colorant\"blue\")\n    end\nend\n\nGtk.draw(can) do widget\n    ctx = getgc(can)\n    if length(drawcontext) < 1\n        push!(drawcontext, ctx)\n    else\n        drawcontext[1] = ctx\n    end\n    clockbody(ctx)\nend\n\nfunction update(can)\n    dtim = now()\n    hr = hour(dtim)\n    mi = minute(dtim)\n    sec = second(dtim)\n    if length(drawcontext) < 1\n        return\n    end\n    ctx = drawcontext[1]\n    clockbody(ctx)\n    rad = (hr % 12) * pi / 6.0 + mi * pi / 360.0\n    drawline(ctx, [Point(50, 50),\n        Point(50 + 45 * 0.5 * sin(rad), 50 - 45 * 0.5 * cos(rad))], colorant\"black\")\n    stroke(ctx)\n    rad = mi * pi / 30.0  + sec * pi / 1800.0\n    drawline(ctx, [Point(50, 50),\n        Point(50 + 0.7 * 45 * sin(rad), 50 - 0.7 * 45 * cos(rad))], colorant\"darkgreen\")\n    stroke(ctx)\n    rad = sec * pi / 30.0\n    drawline(ctx, [Point(50, 50),\n        Point(50 + 0.9 * 45 * sin(rad), 50 - 0.9 * 45 * cos(rad))], colorant\"red\")\n    stroke(ctx)\n    reveal(can)\nend\n\nGtk.showall(win)\nsloc = Base.Threads.SpinLock()\nlock(sloc)\nsignal_connect(win, :destroy) do widget\n    unlock(sloc)\nend\nwhile !trylock(sloc)\n    update(win)\n    sleep(1.0)\nend\n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Kotlin", "code": "\nTranslation of: Java\n// version 1.1\n\nimport java.awt.*\nimport java.time.LocalTime\nimport javax.swing.*\n\nclass Clock : JPanel() {\n    private val degrees06: Float = (Math.PI / 30.0).toFloat()\n    private val degrees30: Float = degrees06 * 5.0f\n    private val degrees90: Float =  degrees30 * 3.0f\n    private val size = 590\n    private val spacing = 40\n    private val diameter = size - 2 * spacing\n    private val cx = diameter / 2 + spacing\n    private val cy = cx\n\n    init {\n        preferredSize = Dimension(size, size)\n        background =  Color.white\n        Timer(1000) {\n            repaint()\n        }.start()\n    }\n\n    override public fun paintComponent(gg: Graphics) {\n        super.paintComponent(gg)\n        val g = gg as Graphics2D\n        g.setRenderingHint(RenderingHints.KEY_ANTIALIASING, RenderingHints.VALUE_ANTIALIAS_ON)\n        drawFace(g)\n        val time  = LocalTime.now()\n        val hour = time.hour\n        val minute = time.minute\n        val second = time.second\n        var angle: Float = degrees90 - degrees06 * second\n        drawHand(g, angle, diameter / 2 - 30, Color.red)\n        val minsecs: Float = minute + second / 60.0f\n        angle = degrees90 - degrees06 * minsecs\n        drawHand(g, angle, diameter / 3 + 10, Color.black)\n        val hourmins: Float = hour + minsecs / 60.0f\n        angle = degrees90 - degrees30 * hourmins\n        drawHand(g, angle, diameter / 4 + 10, Color.black)\n    }\n\n    private fun drawFace(g: Graphics2D) {\n        g.stroke = BasicStroke(2.0f)\n        g.color = Color.yellow\n        g.fillOval(spacing, spacing, diameter, diameter)\n        g.color = Color.black\n        g.drawOval(spacing, spacing, diameter, diameter)\n    }\n\n    private fun drawHand(g: Graphics2D, angle: Float, radius: Int, color: Color) {\n        val x: Int  = cx + (radius.toDouble() * Math.cos(angle.toDouble())).toInt()\n        val y: Int =  cy - (radius.toDouble() * Math.sin(angle.toDouble())).toInt()\n        g.color = color\n        g.drawLine(cx, cy, x, y)\n    }\n}\n\nfun main(args: Array<String>) {\n    SwingUtilities.invokeLater {\n        val f = JFrame()\n        f.defaultCloseOperation = JFrame.EXIT_ON_CLOSE\n        f.title = \"Clock\"\n        f.isResizable = false\n        f.add(Clock(), BorderLayout.CENTER)\n        f.pack()\n        f.setLocationRelativeTo(null)\n        f.isVisible = true\n    }\n}\n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Perl", "code": "\nTranslation of: Raku\nuse utf8;                # interpret source code as UTF8\nbinmode STDOUT, ':utf8'; # allow printing wide chars without warning\n$|++;                    # disable output buffering\n\nmy ($rows, $cols) = split /\\s+/, `stty size`;\nmy $x = int($rows / 2 - 1);\nmy $y = int($cols / 2 - 16);\n\nmy @chars = map {[ /(...)/g ]}\n            (\"\u250c\u2500\u2510  \u2577\u2576\u2500\u2510\u2576\u2500\u2510\u2577 \u2577\u250c\u2500\u2574\u250c\u2500\u2574\u2576\u2500\u2510\u250c\u2500\u2510\u250c\u2500\u2510   \",\n             \"\u2502 \u2502  \u2502\u250c\u2500\u2518\u2576\u2500\u2524\u2514\u2500\u2524\u2514\u2500\u2510\u251c\u2500\u2510  \u2502\u251c\u2500\u2524\u2514\u2500\u2524\u00a0: \",\n             \"\u2514\u2500\u2518  \u2575\u2514\u2500\u2574\u2576\u2500\u2518  \u2575\u2576\u2500\u2518\u2514\u2500\u2518  \u2575\u2514\u2500\u2518\u2576\u2500\u2518   \");\n\nwhile (1) {\n    my @indices = map { ord($_) - ord('0') } split //,\n                  sprintf(\"%02d:%02d:%02d\", (localtime(time))[2,1,0]);\n    \n    clear();\n    for (0 .. $#chars) {\n      position($x + $_, $y);\n      print \"@{$chars[$_]}[@indices]\";\n    }\n    position(1, 1);\n    \n    sleep 1;\n}\n\nsub clear { print \"\\e[H\\e[J\" }\nsub position { printf \"\\e[%d;%dH\", shift, shift }\n\n\nOutput:\n     \u2577 \u250c\u2500\u2574     \u2576\u2500\u2510 \u250c\u2500\u2510     \u250c\u2500\u2510 \u250c\u2500\u2574   \n     \u2502 \u251c\u2500\u2510 \u00a0:  \u250c\u2500\u2518 \u2502 \u2502 \u00a0:  \u2502 \u2502 \u2514\u2500\u2510   \n     \u2575 \u2514\u2500\u2518     \u2514\u2500\u2574 \u2514\u2500\u2518     \u2514\u2500\u2518 \u2576\u2500\u2518   \n\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Lua", "code": "\nLibrary: L\u00d6VE[edit]\n\n", "explain": "Several nice clocks in the L\u00d6VE-forum\n\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Scala", "code": "\nCircular ASCII clock[edit]\n\nimport java.util.{ Timer, TimerTask }\nimport java.time.LocalTime\nimport scala.math._\n\nobject Clock extends App {\n  private val (width, height) = (80, 35)\n\n  def getGrid(localTime: LocalTime): Array[Array[Char]] = {\n    val (minute, second) = (localTime.getMinute, localTime.getSecond())\n    val grid = Array.fill[Char](height, width)(' ')\n\n    def toGridCoord(x: Double, y: Double): (Int, Int) =\n      (floor((y + 1.0) / 2.0 * height).toInt, floor((x + 1.0) / 2.0 * width).toInt)\n\n    def makeText(grid: Array[Array[Char]], r: Double, theta: Double, str: String) {\n      val (row, col) = toGridCoord(r * cos(theta), r * sin(theta))\n      (0 until str.length).foreach(i =>\n        if (row >= 0 && row < height && col + i >= 0 && col + i < width) grid(row)(col + i) = str(i))\n    }\n\n    def makeCircle(grid: Array[Array[Char]], r: Double, c: Char) {\n      var theta = 0.0\n      while (theta < 2 * Pi) {\n        val (row, col) = toGridCoord(r * cos(theta), r * sin(theta))\n        if (row >= 0 && row < height && col >= 0 && col < width) grid(row)(col) = c\n        theta = theta + 0.01\n      }\n    }\n\n    def makeHand(grid: Array[Array[Char]], maxR: Double, theta: Double, c: Char) {\n      var r = 0.0\n      while (r < maxR) {\n        val (row, col) = toGridCoord(r * cos(theta), r * sin(theta))\n        if (row >= 0 && row < height && col >= 0 && col < width) grid(row)(col) = c\n        r = r + 0.01\n      }\n    }\n\n    makeCircle(grid, 0.98, '@')\n    makeHand(grid, 0.6, (localTime.getHour() + minute / 60.0 + second / 3600.0) * Pi / 6 - Pi / 2, 'O')\n    makeHand(grid, 0.85, (minute + second / 60.0) * Pi / 30 - Pi / 2, '*')\n    makeHand(grid, 0.90, second * Pi / 30 - Pi / 2, '.')\n\n    (1 to 12).foreach(n => makeText(grid, 0.87, n * Pi / 6 - Pi / 2, n.toString))\n    grid\n  } // def getGrid(\n\n  private val timerTask = new TimerTask {\n    private def printGrid(grid: Array[Array[Char]]) = grid.foreach(row => println(row.mkString))\n    def run() = printGrid(getGrid(LocalTime.now()))\n  }\n  (new Timer).schedule(timerTask, 0, 1000)\n}\n\nBerliner Uhr[edit]\n\nimport java.time.LocalTime\nimport java.awt.{ Color, Graphics }\n\n/** The Berlin clock as a Java (8.0) applet\n */\nclass QDclock extends java.applet.Applet with Runnable {\n  val bclockThread: Thread = new Thread(this, \"QDclock\")\n\n  override def init() = resize(242, 180) // fixed size, at first... doesn't work...\n\n  override def start() = if (!bclockThread.isAlive()) bclockThread.start()\n\n  def run() {\n    while (true) {\n      repaint()\n      try Thread.sleep(1000) catch { case _: Throwable => sys.exit(-1) }\n    }\n  }\n\n  override def update(g: Graphics) {\n    val now = LocalTime.now\n\n    def booleanToColor(cond: Boolean, colorOn: Color = Color.red): Color =\n      if (cond) colorOn else Color.black\n\n    g.setColor(booleanToColor(now.getSecond() % 2 == 0, Color.yellow))\n    g.fillOval(100, 4, 40, 40)\n\n    val (stu, min) = (now.getHour(), now.getMinute()) match {\n      case (0, 0)     => (24, 0)\n      case (hrs, min) => (hrs, min)\n    }\n\n    def drawRectangle(color: Color, rect: (Int, Int, Int, Int)) {\n      g.setColor(color)\n      g.fillRoundRect(rect._1, rect._2, rect._3, rect._4, 4, 4)\n    }\n\n    for (i <- 0 until 4) {\n      drawRectangle(booleanToColor(stu / ((i + 1) * 5) > 0), (i * 60 + 2, 46, 58, 30))\n      drawRectangle(booleanToColor(stu % 5 > i), (i * 60 + 2, 78, 58, 30))\n      drawRectangle(booleanToColor(min % 5 > i, Color.yellow), (i * 60 + 2, 142, 58, 30))\n    }\n\n    for (i <- 0 until 11) {\n      drawRectangle(booleanToColor(min / ((i + 1) * 5) > 0,\n        if (2 to 8 by 3 contains i) Color.red else Color.yellow), (i * 20 + 10, 110, 18, 30))\n    }\n  }\n}\n\n", "explain": "Generates and prints a simple ASCII clock every second\nSee [The Berlin set theory clock]\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Haskell", "code": "\nLibrary: ansi-terminal\nimport Control.Concurrent\nimport Data.List\nimport System.Time\n\n-- Library: ansi-terminal\nimport System.Console.ANSI\n\nnumber :: (Integral a) => a -> [String]\nnumber 0 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 1 =\n  [\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"]\nnumber 2 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588    \"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 3 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 4 =\n  [\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"]\nnumber 5 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588    \"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 6 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588    \"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 7 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"    \u2588\u2588\"]\nnumber 8 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\nnumber 9 =\n  [\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"\u2588\u2588  \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"\n  ,\"    \u2588\u2588\"\n  ,\"\u2588\u2588\u2588\u2588\u2588\u2588\"]\n\ncolon :: [String]\ncolon =\n  [\"      \"\n  ,\"  \u2588\u2588  \"\n  ,\"      \"\n  ,\"  \u2588\u2588  \"\n  ,\"      \"]\n\nnewline :: [String]\nnewline =\n  [\"\\n\"\n  ,\"\\n\"\n  ,\"\\n\"\n  ,\"\\n\"\n  ,\"\\n\"]\n\nspace :: [String]\nspace =\n  [\" \"\n  ,\" \"\n  ,\" \"\n  ,\" \"\n  ,\" \"]\n\nleadingZero :: (Integral a) => a -> [[String]]\nleadingZero num =\n  let (tens, ones) = divMod num 10\n  in [number tens, space, number ones]\n\nfancyTime :: CalendarTime -> String\nfancyTime time =\n  let hour   = leadingZero $ ctHour time\n      minute = leadingZero $ ctMin time\n      second = leadingZero $ ctSec time\n      nums   = hour ++ [colon] ++ minute ++ [colon] ++ second ++ [newline]\n  in concat $ concat $ transpose nums\n\nmain :: IO ()\nmain = do\n  time <- getClockTime >>= toCalendarTime\n  putStr $ fancyTime time\n  threadDelay 1000000\n  setCursorColumn 0\n  cursorUp 5\n  main\n\nOutput:    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\n    \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588      \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588      \u2588\u2588 \u2588\u2588  \u2588\u2588\n    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588  \u2588\u2588\n    \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588      \u2588\u2588 \u2588\u2588  \u2588\u2588  \u2588\u2588  \u2588\u2588     \u2588\u2588  \u2588\u2588\n    \u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588      \u2588\u2588\u2588\u2588\u2588\u2588 \u2588\u2588\u2588\u2588\u2588\u2588\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "VBScript", "code": "\n\n'ANSI Clock\n\n'ansi escape functions\nans0=chr(27)&\"[\"\nsub cls()  wscript.StdOut.Write ans0 &\"2J\"&ans0 &\"?25l\":end sub\nsub torc(r,c,s)  wscript.StdOut.Write ans0 & r & \";\" & c & \"f\"  & s :end sub\n\n'bresenham\nSub draw_line(r1,c1, r2,c2,c)\n  Dim x,y,xf,yf,dx,dy,sx,sy,err,err2\n  x =r1    : y =c1\n  xf=r2    : yf=c2\n  dx=Abs(xf-x) : dy=Abs(yf-y)\n  If x<xf Then sx=+1: Else sx=-1\n  If y<yf Then sy=+1: Else sy=-1\n  err=dx-dy\n  Do\n    torc x,y,c\n    If x=xf And y=yf Then Exit Do\n    err2=err+err\n    If err2>-dy Then err=err-dy: x=x+sx\n    If err2< dx Then err=err+dx: y=y+sy\n  Loop\nEnd Sub \n\nconst pi180=0.017453292519943\n'center of the clock\nconst r0=13\nconst c0=26\n\n'angles\nnangi=-30*pi180\naangi=-6*pi180\nang0=90*pi180\n\n'lengths of hands\nlh=7\nlm=9\nls=9\nln=12\n\n\nwhile 1\n     cls\n\n    'dial\n    angn=ang0+nangi\n    for i=1 to 12\n      torc r0-cint(ln*sin(angn)),cint(c0+2*ln*cos(angn)),i\n      angn=angn+nangi \n    next \n\n    'get time and display it in numbers\n    t=now()\n    torc 1,1, hour(t) &\":\"& minute(t) &\":\"& second(t) \n    \n    'angle for each hand\n    angh=ang0+hour(t) *nangi\n    angm=ang0+minute(t) *aangi\n    angS=ang0+second(t) *aangi\n\n    'draw them\n    draw_line r0,c0,cint(r0-ls*sin(angs)),cint(c0+2*ls*cos(angs)),\".\"\n    draw_line r0,c0,cint(r0-lm*sin(angm)),cint(c0+2*lm*cos(angm)),\"*\"\n    draw_line r0,c0,cint(r0-lh*sin(angh)),cint(c0+2*lh*cos(angh)),\"W\"\n    torc r0,c0,\"O\"\n    \n    'wait one second     \n    wscript.sleep(1000)\nwend\n\n\nOutput:\n15:8:37                  12\n\n             11                      1\n\n\n\n    10                               **       2\n                                   **\n                                 **\n                               **\n                             **\n                           **\n 9                       OWWWWWWWWWWWWWW         3\n                       ..\n                     ..\n                   ..\n                  .\n                ..\n    8         ..                              4\n             .\n\n\n             7                       5\n\n                         6\n\n\n", "explain": "The only way to do animation in VBScript is to use ANSI codes in the console. The program will work only in Windows 10 or up. Should be invoked from cscript\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "Scheme", "code": "\nLibrary: Scheme/PsTk\n\n(import (scheme base)\n        (scheme inexact)\n        (scheme time)\n        (pstk))\n\n(define PI 3.1415927)\n\n;; Draws the hands on the canvas using the current time, and repeats each second\n(define (hands canvas)\n  (canvas 'delete 'withtag \"hands\")\n\n  (let* ((time (current-second)) ; no time locality used, so displays time in GMT\n         (hours (floor (/ time 3600)))\n         (rem (- time (* hours 3600)))\n         (mins (floor (/ rem 60)))\n         (secs (- rem (* mins 60)))\n         (second-angle (* secs (* 2 PI 1/60)))\n         (minute-angle (* mins (* 2 PI 1/60)))\n         (hour-angle (* hours (* 2 PI 1/12))))\n    (canvas 'create 'line ; second hand\n            100 100 \n            (+ 100 (* 90 (sin second-angle)))\n            (- 100 (* 90 (cos second-angle)))\n            'width: 1 'tags: \"hands\")\n    (canvas 'create 'line ; minute hand\n            100 100 \n            (+ 100 (* 85 (sin minute-angle)))\n            (- 100 (* 85 (cos minute-angle)))\n            'width: 3 \n            'capstyle: \"projecting\"\n            'tags: \"hands\")\n    (canvas 'create 'line ; hour hand\n            100 100 \n            (+ 100 (* 60 (sin hour-angle)))\n            (- 100 (* 60 (cos hour-angle)))\n            'width: 7 \n            'capstyle: \"projecting\"\n            'tags: \"hands\"))\n  (tk/after 1000 (lambda () (hands canvas))))\n\n;; Create the initial frame, clock frame and hours\n(let ((tk (tk-start)))\n  (tk/wm 'title tk \"GMT Clock\")\n\n  (let ((canvas (tk 'create-widget 'canvas)))\n    (tk/pack canvas)\n    (canvas 'configure 'height: 200 'width: 200)\n    (canvas 'create 'oval 2 2 198 198 'fill: \"white\" 'outline: \"black\")\n    (do ((h 1 (+ 1 h)))\n      ((> h 12) )\n      (let ((angle (- (/ PI 2) (* h PI 1/6))))\n        (canvas 'create 'text \n                (+ 100 (* 90 (cos angle)))\n                (- 100 (* 90 (sin angle)))\n                'text: (number->string h)\n                'font: \"{Helvetica -12}\")))\n\n    (hands canvas))\n  (tk-event-loop tk))\n\n", "explain": "Translation of a Tcl example at http://wiki.tcl.tk/1011\nThe program displays an analogue clock with three hands, updating once a second.\n"}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "F#", "code": "\nopen System.Text.RegularExpressions\n\nlet numberTemplate = \"\"\"\n _     _  _     _     __ _  _       \n/ \\ /|  ) _)|_||_  /   /(_)(_) * \n\\_/  | /_ _)  | _)(_) / (_) /  * \n\"\"\"\nlet g =\n    numberTemplate.Split([|'\\n';'\\r'|], System.StringSplitOptions.RemoveEmptyEntries)\n    |> Array.map (fun s ->\n        Regex.Matches(s, \"...\")\n        |> Seq.cast<Match>\n        |> Seq.map (fun m -> m.ToString())\n        |> Seq.toArray)\n\nlet idx c =\n    let v c = ((int) c) - ((int) '0')\n    let i = v c\n    if 0 <= i && i <= 9 then i\n    elif c = ':' then 10\n    else failwith (\"Cannot draw character \" + c.ToString())\n\nlet draw (s :string) =\n    System.Console.Clear()\n    g\n    |> Array.iter (fun a ->\n        s.ToCharArray() |> Array.iter (fun c ->\n            let i = idx c\n            printf \"%s\" (a.[i]))\n        printfn \"\"\n        )\n\n[<EntryPoint>]\nlet main argv =\n    let showTime _ = draw (System.String.Format(\"{0:HH:mm:ss}\", (System.DateTime.Now)))\n    let timer = new System.Timers.Timer(500.)\n    timer.AutoReset <- true // The timer triggers cyclically\n    timer.Elapsed // An event stream\n    |> Observable.subscribe showTime |> ignore // Subscribe to the event stream\n    timer.Start() // Now it counts\n    System.Console.ReadLine() |> ignore // Until return is hit\n    showTime ()\n    0\n\n\nOutput:\n _  _     _        _  __\n  ) _) *   ) /  *  _)  /\n /_ _) *  /_(_) *  _) /\n", "explain": ""}, {"task_name": "Draw a clock", "task_url": "https://rosettacode.org/wiki/Draw_a_clock", "task_cat": "Date and time", "lang": "AWK", "code": "\n# syntax: GAWK -f DRAW_A_CLOCK.AWK [-v xc=\"*\"]\nBEGIN {\n#   clearscreen_cmd = \"clear\"\u00a0; sleep_cmd = \"sleep 1s\" # Unix\n    clearscreen_cmd = \"CLS\" ; sleep_cmd = \"TIMEOUT /T 1 >NUL\" # MS-Windows\n    clock_build_digits()\n    while (1) {\n      now = strftime(\"%H:%M:%S\")\n      t[1] = substr(now,1,1)\n      t[2] = substr(now,2,1)\n      t[3] = 10\n      t[4] = substr(now,4,1)\n      t[5] = substr(now,5,1)\n      t[6] = 10\n      t[7] = substr(now,7,1)\n      t[8] = substr(now,8,1)\n      if (prev_now != now) {\n        system(clearscreen_cmd)\n        for (v=1; v<=8; v++) {\n          printf(\"\\t\")\n          for (h=1; h<=8; h++) {\n            printf(\"%-8s\",a[t[h],v])\n          }\n          printf(\"\\n\")\n        }\n        prev_now = now\n      }\n      system(sleep_cmd)\n    }\n    exit(0)\n}\nfunction clock_build_digits(  arr,i,j,x,y) {\n    arr[1] = \" 0000     1    2222   3333      4  555555  6666   777777 8888   9999         \"\n    arr[2] = \"0    0   11   2    2 3    3    44  5      6      7     78    8 9    9        \"\n    arr[3] = \"0   00  1 1        2      3   4 4  5      6           7 8    8 9    9  \u00a0::   \"\n    arr[4] = \"0  0 0    1       2    333   4  4  555555 66666      7   8888  9    9  \u00a0::   \"\n    arr[5] = \"0 0  0    1     22        3 444444      5 6    6    7   8    8  99999        \"\n    arr[6] = \"00   0    1    2          3     4       5 6    6   7    8    8      9  \u00a0::   \"\n    arr[7] = \"0    0    1   2      3    3     4  5    5 6    6  7     8    8      9  \u00a0::   \"\n    arr[8] = \" 0000  1111111222222  3333      4   5555   6666   7      8888   9999         \"\n    for (i=1; i<=8; i++) {\n      if (xc != \"\") {\n        gsub(/[0-9:]/,substr(xc,1,1),arr[i]) # change \"0-9\" and \":\" to substitution character\n      }\n      y++\n      x = -1\n      for (j=1; j<=77; j=j+7) {\n        a[++x,y] = substr(arr[i],j,7)\n      }\n    }\n}\n\n\nSample run and output:\nGAWK -f DRAW_A_CLOCK.AWK -v xc=\"#\"\n\n         ####    ####              #     ####            ####    ####\n        #    #  #    #            ##    #    #          #    #  #    #\n        #   ##  #    #    ##     # #    #    #    ##    #   ##  #   ##\n        #  # #   ####     ##       #    #    #    ##    #  # #  #  # #\n        # #  #  #    #             #     #####          # #  #  # #  #\n        ##   #  #    #    ##       #         #    ##    ##   #  ##   #\n        #    #  #    #    ##       #         #    ##    #    #  #    #\n         ####    ####           #######  ####            ####    ####\n\n", "explain": ""}]