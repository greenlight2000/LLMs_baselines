[{"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Python", "code": "\nTranslation of: Java\n\ndef shell(seq):\n    inc = len(seq) // 2\n    while inc:\n        for i, el in enumerate(seq[inc:], inc):\n            while i >= inc and seq[i - inc] > el:\n                seq[i] = seq[i - inc]\n                i -= inc\n            seq[i] = el\n        inc = 1 if inc == 2 else inc * 5 // 11\n\n\nOutput:\n>>> data = [22, 7, 2, -5, 8, 4]\n>>> shell(data)\n>>> print(data)\n[-5, 2, 4, 7, 8, 22]\n\n", "explain": "This method sorts in place. \nIf you want to preserve your unsorted list, copy it first.\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "C", "code": "\n#include <stdio.h>\n\nvoid shell_sort (int *a, int n) {\n    int h, i, j, t;\n    for (h = n; h /= 2;) {\n        for (i = h; i < n; i++) {\n            t = a[i];\n            for (j = i; j >= h && t < a[j - h]; j -= h) {\n                a[j] = a[j - h];\n            }\n            a[j] = t;\n        }\n    }\n}\n\nint main (int ac, char **av) {\n    int a[] = {4, 65, 2, -31, 0, 99, 2, 83, 782, 1};\n    int n = sizeof a / sizeof a[0];\n    int i;\n    for (i = 0; i < n; i++)\n        printf(\"%d%s\", a[i], i == n - 1 ? \"\\n\" : \" \");\n    shell_sort(a, n);\n    for (i = 0; i < n; i++)\n        printf(\"%d%s\", a[i], i == n - 1 ? \"\\n\" : \" \");\n    return 0;\n}\n\n\nOutput:\n4 65 2 -31 0 99 2 83 782 1\n-31 0 1 2 2 4 65 83 99 782\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "C++", "code": "\n#include <time.h>\n#include <iostream>\n\n//--------------------------------------------------------------------------------------------------\nusing namespace std;\n\n//--------------------------------------------------------------------------------------------------\nconst int MAX = 126;\nclass shell\n{\npublic:\n    shell() \n    { _gap[0] = 1750; _gap[1] = 701; _gap[2] = 301; _gap[3] = 132; _gap[4] = 57; _gap[5] = 23; _gap[6] = 10; _gap[7] = 4; _gap[8] = 1; }\n\n    void sort( int* a, int count )\n    {\n\t_cnt = count;\n\tfor( int x = 0; x < 9; x++ )\n\t    if( count > _gap[x] )\n\t    { _idx = x; break; }\n\n\tsortIt( a );\n    }\n\nprivate:\t\n    void sortIt( int* arr )\n    {\n\tbool sorted = false;\n\twhile( true )\n\t{\n\t    sorted = true;\n\t    int st = 0;\n\t    for( int x = _gap[_idx]; x < _cnt; x += _gap[_idx] )\n\t    {\n\t\tif( arr[st] > arr[x] )\n\t\t{ swap( arr[st], arr[x] ); sorted = false; }\n\t\tst = x;\n\t    }\n\t    if( ++_idx >= 8 ) _idx = 8;\n\t    if( sorted && _idx == 8 ) break;\n\t}\n    }\n\n    void swap( int& a, int& b ) { int t = a; a = b; b = t; }\n\n    int _gap[9], _idx, _cnt;\n};\n//--------------------------------------------------------------------------------------------------\nint main( int argc, char* argv[] )\n{\n    srand( static_cast<unsigned int>( time( NULL ) ) ); int arr[MAX];\n    for( int x = 0; x < MAX; x++ )\n\tarr[x] = rand() % MAX - rand() % MAX;\n\n    cout << \" Before: \\n=========\\n\";\n    for( int x = 0; x < 7; x++ )\n    {\n\tfor( int a = 0; a < 18; a++ )\n\t{ cout << arr[x * 18 + a] << \" \"; }\n\tcout << endl;\n    }\n    cout << endl; shell s; s.sort( arr, MAX );\n\t\n    cout << \" After: \\n========\\n\";\n    for( int x = 0; x < 7; x++ )\n    {\n\tfor( int a = 0; a < 18; a++ )\n\t{ cout << arr[x * 18 + a] << \" \"; }\n\tcout << endl;\n    }\n    cout << endl << endl; return system( \"pause\" );\n}\n//--------------------------------------------------------------------------------------------------\n\n\nOutput:\nBefore:\n=======\n-28 64 51 96 24 -51 15 4 51 37 -28 64 -18 -45 63 -64 -75 16\n32 -44 -26 -50 -30 94 -55 -60 51 -30 14 -16 -42 22 91 -85 100 -14\n-35 20 -73 11 -65 53 -25 -21 -65 16 -36 35 -69 -16 -13 -21 -103 80\n-51 40 2 -7 11 29 65 -28 63 -108 -45 -8 -11 73 -8 -34 41 -20\n-55 -64 4 41 5 -13 37 -39 -11 20 -24 -62 30 -19 30 -17 -11 -15\n104 -14 -35 14 5 20 58 -38 6 -41 -23 88 49 -7 -54 -40 10 6\n-57 -77 -6 -72 122 23 -39 67 121 63 28 31 43 -33 -1 59 -5 -91\n\nAfter:\n======\n-108 -103 -91 -85 -77 -75 -73 -72 -69 -65 -65 -64 -64 -62 -60 -57 -55 -55\n-54 -51 -51 -50 -45 -45 -44 -42 -41 -40 -39 -39 -38 -36 -35 -35 -34 -33\n-30 -30 -28 -28 -28 -26 -25 -24 -23 -21 -21 -20 -19 -18 -17 -16 -16 -15\n-14 -14 -13 -13 -11 -11 -11 -8 -8 -7 -7 -6 -5 -1 2 4 4 5\n5 6 6 10 11 11 14 14 15 16 16 20 20 20 22 23 24 28\n29 30 30 31 32 35 37 37 40 41 41 43 49 51 51 51 53 58\n59 63 63 63 64 64 65 67 73 80 88 91 94 96 100 104 121 122\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Java", "code": "\nTranslation of: Fortran\n\npublic static void shell(int[] a) {\n\tint increment = a.length / 2;\n\twhile (increment > 0) {\n\t\tfor (int i = increment; i < a.length; i++) {\n\t\t\tint j = i;\n\t\t\tint temp = a[i];\n\t\t\twhile (j >= increment && a[j - increment] > temp) {\n\t\t\t\ta[j] = a[j - increment];\n\t\t\t\tj = j - increment;\n\t\t\t}\n\t\t\ta[j] = temp;\n\t\t}\n\t\tif (increment == 2) {\n\t\t\tincrement = 1;\n\t\t} else {\n\t\t\tincrement *= (5.0 / 11);\n\t\t}\n\t}\n}\n\n", "explain": "This method will sort in place. If you want to preserve your unsorted array, use a copy of the array as an argument to this method.\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "C#", "code": "\npublic static class ShellSorter\n{\n    public static void Sort<T>(IList<T> list) where T\u00a0: IComparable\n    {\n        int n = list.Count;\n        int h = 1;\n\n        while (h < (n >> 1))\n        {   \n            h = (h << 1) + 1;\n        }\n\n        while (h >= 1)\n        {\n            for (int i = h; i < n; i++)\n            {\n                int k = i - h;\n                for (int j = i; j >= h && list[j].CompareTo(list[k]) < 0; k -= h)\n                {\n                    T temp = list[j];\n                    list[j] = list[k];\n                    list[k] = temp;\n                    j = k;\n                }\n            }\n            h >>= 1;\n        }\n    }\n}\n\nOutput:\nBefore:\n=======\n-28 64 51 96 24 -51 15 4 51 37 -28 64 -18 -45 63 -64 -75 16\n32 -44 -26 -50 -30 94 -55 -60 51 -30 14 -16 -42 22 91 -85 100 -14\n-35 20 -73 11 -65 53 -25 -21 -65 16 -36 35 -69 -16 -13 -21 -103 80\n-51 40 2 -7 11 29 65 -28 63 -108 -45 -8 -11 73 -8 -34 41 -20\n-55 -64 4 41 5 -13 37 -39 -11 20 -24 -62 30 -19 30 -17 -11 -15\n104 -14 -35 14 5 20 58 -38 6 -41 -23 88 49 -7 -54 -40 10 6\n-57 -77 -6 -72 122 23 -39 67 121 63 28 31 43 -33 -1 59 -5 -91\n\nAfter:\n======\n-108 -103 -91 -85 -77 -75 -73 -72 -69 -65 -65 -64 -64 -62 -60 -57 -55 -55\n-54 -51 -51 -50 -45 -45 -44 -42 -41 -40 -39 -39 -38 -36 -35 -35 -34 -33\n-30 -30 -28 -28 -28 -26 -25 -24 -23 -21 -21 -20 -19 -18 -17 -16 -16 -15\n-14 -14 -13 -13 -11 -11 -11 -8 -8 -7 -7 -6 -5 -1 2 4 4 5\n5 6 6 10 11 11 14 14 15 16 16 20 20 20 22 23 24 28\n29 30 30 31 32 35 37 37 40 41 41 43 49 51 51 51 53 58\n59 63 63 63 64 64 65 67 73 80 88 91 94 96 100 104 121 122\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "JavaScript", "code": "\nfunction shellSort (a) {\n    for (var h = a.length; h > 0; h = parseInt(h / 2)) {\n        for (var i = h; i < a.length; i++) {\n            var k = a[i];\n            for (var j = i; j >= h && k < a[j - h]; j -= h)\n                a[j] = a[j - h];\n            a[j] = k;\n        }\n    }\n    return a;\n}\n\nvar a = [];\nvar n = location.href.match(/\\?(\\d+)|$/)[1] || 10;\nfor (var i = 0; i < n; i++)\n    a.push(parseInt(Math.random() * 100));\nshellSort(a);\ndocument.write(a.join(\" \"));\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "PHP", "code": "\nfunction shellSort($arr)\n{\n\t$inc = round(count($arr)/2);\n\twhile($inc > 0)\n\t{\n\t\tfor($i = $inc; $i < count($arr);$i++){\n\t\t\t$temp = $arr[$i];\n\t\t\t$j = $i;\n\t\t\twhile($j >= $inc && $arr[$j-$inc] > $temp)\n\t\t\t{\n\t\t\t\t$arr[$j] = $arr[$j - $inc];\n\t\t\t\t$j -= $inc;\n\t\t\t}\n\t\t\t$arr[$j] = $temp;\n\t\t}\n\t\t$inc = round($inc/2.2);\n\t}\n\treturn $arr;\n}\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Fortran", "code": "\nWorks with: Fortran version 90 and later\nMODULE sort\n\nCONTAINS\n\nSUBROUTINE Shell_Sort(a)\n\n  IMPLICIT NONE\n  INTEGER :: i, j, increment\n  REAL :: temp\n  REAL, INTENT(in out) :: a(:)\n\t\n  increment = SIZE(a) / 2\n  DO WHILE (increment > 0)\n      DO i = increment+1, SIZE(a)\n         j = i\n         temp = a(i)\n         DO WHILE (j >= increment+1 .AND. a(j-increment) > temp)\n            a(j) = a(j-increment)\n            j = j - increment\n         END DO\n         a(j) = temp\n      END DO\n      IF (increment == 2) THEN\n   \t  increment = 1\n      ELSE\n         increment = increment * 5 / 11\n      END IF      \n  END DO\n \nEND SUBROUTINE Shell_Sort\n\nEND MODULE sort\n\nPROGRAM Shellsort\n\nUSE sort\n\n  IMPLICIT NONE\n  REAL :: array(1000)\n     \n  CALL RANDOM_SEED\n  CALL RANDOM_NUMBER(array)\n \n  WRITE (*,*) \"Unsorted array\"\n  WRITE (*,*) array\n  WRITE (*,*) \n  CALL Shell_Sort(array)\n  WRITE (*,*) \"Sorted array\"\n  WRITE (*,*) array\n  \nEND PROGRAM Shellsort\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Go", "code": "\n\npackage main\n\nimport \"fmt\"\n\nvar a = []int{170, 45, 75, -90, -802, 24, 2, 66}\n\nfunc main() {\n    fmt.Println(\"before:\", a)\n    for inc := len(a) / 2; inc > 0; inc = (inc + 1) * 5 / 11 {\n        for i := inc; i < len(a); i++ {\n            j, temp := i, a[i]\n            for ; j >= inc && a[j-inc] > temp; j -= inc {\n                a[j] = a[j-inc]\n            }\n            a[j] = temp\n        }\n    }\n    fmt.Println(\"after: \", a)\n}\n\n\nOutput:\nbefore: [170 45 75 -90 -802 24 2 66]\nafter:  [-802 -90 2 24 45 66 75 170]\n\n", "explain": "Following WP pseudocode:\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "ARM_Assembly", "code": "\nWorks with: as version Raspberry Pi\n/* ARM assembly Raspberry PI  */\n/*  program shellSort.s   */\n \n/************************************/\n/* Constantes                       */\n/************************************/\n.equ STDOUT, 1     @ Linux output console\n.equ EXIT,   1     @ Linux syscall\n.equ WRITE,  4     @ Linux syscall\n/*********************************/\n/* Initialized data              */\n/*********************************/\n.data\nszMessSortOk:       .asciz \"Table sorted.\\n\"\nszMessSortNok:      .asciz \"Table not sorted\u00a0!!!!!.\\n\"\nsMessResult:        .ascii \"Value \u00a0: \"\nsMessValeur:        .fill 11, 1, ' '            @ size => 11\nszCarriageReturn:   .asciz \"\\n\"\n \n.align 4\niGraine:  .int 123456\n.equ NBELEMENTS,      10\n#TableNumber:      .int   1,3,6,2,5,9,10,8,4,7\nTableNumber:     .int   10,9,8,7,6,5,4,3,2,1\n/*********************************/\n/* UnInitialized data            */\n/*********************************/\n.bss  \n/*********************************/\n/*  code section                 */\n/*********************************/\n.text\n.global main \nmain:                                             @ entry of program \n \n1:\n    ldr r0,iAdrTableNumber                        @ address number table\n    mov r1,#0                                     @ not use in routine\n    mov r2,#NBELEMENTS                            @ number of \u00e9lements \n    bl shellSort\n    ldr r0,iAdrTableNumber                        @ address number table\n    bl displayTable\n \n    ldr r0,iAdrTableNumber                        @ address number table\n    mov r1,#NBELEMENTS                            @ number of \u00e9lements \n    bl isSorted                                   @ control sort\n    cmp r0,#1                                     @ sorted\u00a0?\n    beq 2f\n    ldr r0,iAdrszMessSortNok                      @ no\u00a0!! error sort\n    bl affichageMess\n    b 100f\n2:                                                @ yes\n    ldr r0,iAdrszMessSortOk\n    bl affichageMess\n100:                                              @ standard end of the program \n    mov r0, #0                                    @ return code\n    mov r7, #EXIT                                 @ request to exit program\n    svc #0                                        @ perform the system call\n \niAdrsMessValeur:          .int sMessValeur\niAdrszCarriageReturn:     .int szCarriageReturn\niAdrsMessResult:          .int sMessResult\niAdrTableNumber:          .int TableNumber\niAdrszMessSortOk:         .int szMessSortOk\niAdrszMessSortNok:        .int szMessSortNok\n/******************************************************************/\n/*     control sorted table                                   */ \n/******************************************************************/\n/* r0 contains the address of table */\n/* r1 contains the number of elements  > 0  */\n/* r0 return 0  if not sorted   1  if sorted */\nisSorted:\n    push {r2-r4,lr}                                    @ save registers\n    mov r2,#0\n    ldr r4,[r0,r2,lsl #2]\n1:\n    add r2,#1\n    cmp r2,r1\n    movge r0,#1\n    bge 100f\n    ldr r3,[r0,r2, lsl #2]\n    cmp r3,r4\n    movlt r0,#0\n    blt 100f\n    mov r4,r3\n    b 1b\n100:\n    pop {r2-r4,lr}\n    bx lr                                              @ return \n/***************************************************/\n/*   shell Sort                                    */\n/***************************************************/\n\n/* r0 contains the address of table */\n/* r1 contains the first element but not use\u00a0!!   */\n/*   this routine use first element at index zero\u00a0!!!  */\n/* r2 contains the number of element */\nshellSort:\n    push {r0-r7,lr}              @save registers\n\n    sub r2,#1                    @ index last item\n    mov r1,r2                    @ init gap = last item\n1:                               @ start loop 1\n    lsrs r1,#1                   @ gap = gap / 2\n    beq 100f                     @ if gap = 0 -> end\n    mov r3,r1                    @ init loop indice 1 \n2:                               @ start loop 2\n    ldr r4,[r0,r3,lsl #2]        @ load first value\n    mov r5,r3                    @ init loop indice 2\n3:                               @ start loop 3\n    cmp r5,r1                    @ indice < gap\n    blt 4f                       @ yes -> end loop 2\n    sub r6,r5,r1                 @ index = indice - gap\n    ldr r7,[r0,r6,lsl #2]        @ load second value\n    cmp r4,r7                    @ compare values\n    strlt r7,[r0,r5,lsl #2]      @ store if <\n    sublt r5,r1                  @ indice = indice - gap\n    blt 3b                       @ and loop\n4:                               @ end loop 3\n    str r4,[r0,r5,lsl #2]        @ store value 1 at indice 2\n    add r3,#1                    @ increment indice 1\n    cmp r3,r2                    @ end\u00a0?\n    ble 2b                       @ no -> loop 2\n    b 1b                         @ yes loop for new gap\n \n100:                             @ end function\n    pop {r0-r7,lr}               @ restaur registers\n    bx lr                        @ return \n\n\n/******************************************************************/\n/*      Display table elements                                */ \n/******************************************************************/\n/* r0 contains the address of table */\ndisplayTable:\n    push {r0-r3,lr}                                    @ save registers\n    mov r2,r0                                          @ table address\n    mov r3,#0\n1:                                                     @ loop display table\n    ldr r0,[r2,r3,lsl #2]\n    ldr r1,iAdrsMessValeur                             @ display value\n    bl conversion10                                    @ call function\n    ldr r0,iAdrsMessResult\n    bl affichageMess                                   @ display message\n    add r3,#1\n    cmp r3,#NBELEMENTS - 1\n    ble 1b\n    ldr r0,iAdrszCarriageReturn\n    bl affichageMess\n100:\n    pop {r0-r3,lr}\n    bx lr\n/******************************************************************/\n/*     display text with size calculation                         */ \n/******************************************************************/\n/* r0 contains the address of the message */\naffichageMess:\n    push {r0,r1,r2,r7,lr}                          @ save  registres\n    mov r2,#0                                      @ counter length \n1:                                                 @ loop length calculation \n    ldrb r1,[r0,r2]                                @ read octet start position + index \n    cmp r1,#0                                      @ if 0 its over \n    addne r2,r2,#1                                 @ else add 1 in the length \n    bne 1b                                         @ and loop \n                                                   @ so here r2 contains the length of the message \n    mov r1,r0                                      @ address message in r1 \n    mov r0,#STDOUT                                 @ code to write to the standard output Linux \n    mov r7, #WRITE                                 @ code call system \"write\" \n    svc #0                                         @ call systeme \n    pop {r0,r1,r2,r7,lr}                           @ restaur des  2 registres */ \n    bx lr                                          @ return  \n/******************************************************************/\n/*     Converting a register to a decimal unsigned                */ \n/******************************************************************/\n/* r0 contains value and r1 address area   */\n/* r0 return size of result (no zero final in area) */\n/* area size => 11 bytes          */\n.equ LGZONECAL,   10\nconversion10:\n    push {r1-r4,lr}                                 @ save registers \n    mov r3,r1\n    mov r2,#LGZONECAL\n \n1:                                                  @ start loop\n    bl divisionpar10U                               @ unsigned  r0 <- dividende. quotient ->r0 reste -> r1\n    add r1,#48                                      @ digit\n    strb r1,[r3,r2]                                 @ store digit on area\n    cmp r0,#0                                       @ stop if quotient = 0 \n    subne r2,#1                                     @ else previous position\n    bne 1b                                          @ and loop\n                                                    @ and move digit from left of area\n    mov r4,#0\n2:\n    ldrb r1,[r3,r2]\n    strb r1,[r3,r4]\n    add r2,#1\n    add r4,#1\n    cmp r2,#LGZONECAL\n    ble 2b\n                                                      @ and move spaces in end on area\n    mov r0,r4                                         @ result length \n    mov r1,#' '                                       @ space\n3:\n    strb r1,[r3,r4]                                   @ store space in area\n    add r4,#1                                         @ next position\n    cmp r4,#LGZONECAL\n    ble 3b                                            @ loop if r4 <= area size\n \n100:\n    pop {r1-r4,lr}                                    @ restaur registres \n    bx lr                                             @return\n \n/***************************************************/\n/*   division par 10   unsigned                    */\n/***************************************************/\n/* r0 dividende   */\n/* r0 quotient */\t\n/* r1 remainder  */\ndivisionpar10U:\n    push {r2,r3,r4, lr}\n    mov r4,r0                                          @ save value\n    //mov r3,#0xCCCD                                   @ r3 <- magic_number lower  raspberry 3\n    //movt r3,#0xCCCC                                  @ r3 <- magic_number higter raspberry 3\n    ldr r3,iMagicNumber                                @ r3 <- magic_number    raspberry 1 2\n    umull r1, r2, r3, r0                               @ r1<- Lower32Bits(r1*r0) r2<- Upper32Bits(r1*r0) \n    mov r0, r2, LSR #3                                 @ r2 <- r2 >> shift 3\n    add r2,r0,r0, lsl #2                               @ r2 <- r0 * 5 \n    sub r1,r4,r2, lsl #1                               @ r1 <- r4 - (r2 * 2)  = r4 - (r0 * 10)\n    pop {r2,r3,r4,lr}\n    bx lr                                              @ leave function \niMagicNumber:  \t.int 0xCCCCCCCD\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Delphi", "code": "\nProcedure ShellSort(var buf:Array of Integer);\nconst\n  gaps:array[0..7] of Integer = (701, 301, 132, 57, 23, 10, 4, 1);\n\nvar\n  whichGap, i, j, n, gap, temp : Integer;\n\nbegin\n  n := high(buf);\n  for whichGap := 0 to high(gaps) do begin\n    gap := gaps[whichGap];\n    for i := gap to n do begin\n      temp := buf[i];\n\n      j := i;\n      while ( (j >= gap ) and ( (buf[j-gap] > dt) ) do begin\n        buf[j] := buf[j-gap];\n        dec(j, gap);\n      end;\n      buf[j] := temp;\n    end;\n  end;\nend;\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Ruby", "code": "\nTranslation of: Java\n\nclass Array\n  def shellsort!\n    inc = length / 2\n    while inc != 0\n      inc.step(length-1) do |i|\n        el = self[i]\n        while i >= inc and self[i - inc] > el\n          self[i] = self[i - inc]\n          i -= inc\n        end\n        self[i] = el\n      end\n      inc = (inc == 2 ? 1 : (inc * 5.0 / 11).to_i)\n    end\n    self\n  end\nend\n\ndata = [22, 7, 2, -5, 8, 4]\ndata.shellsort!\np data # [-5, 2, 4, 7, 8, 22]\n\n", "explain": "This method sorts in place. If you want to preserve your unsorted list, copy it first.\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Rust", "code": "\nfn shell_sort<T: Ord + Copy>(v: &mut [T]) {\n    let mut gap = v.len() / 2;\n    let len = v.len();\n    while gap > 0 {\n        for i in gap..len {\n            let temp = v[i];\n            let mut j = i;\n            while j >= gap && v[j - gap] > temp {\n                v[j] = v[j - gap];\n                j -= gap;\n            }\n            v[j] = temp;\n        }\n        gap /= 2;\n    }\n}\n\nfn main() {\n    let mut numbers = [4i32, 65, 2, -31, 0, 99, 2, 83, 782, 1];\n    println!(\"Before: {:?}\", numbers);\n    shell_sort(&mut numbers);\n    println!(\"After: {:?}\", numbers);\n}\n\n\nOutput:\nBefore: [4, 65, 2, -31, 0, 99, 2, 83, 782, 1]\nAfter: [-31, 0, 1, 2, 2, 4, 65, 83, 99, 782]\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Swift", "code": "\nWorks with: Swift version 2.1\nfunc shellsort<T where T : Comparable>(inout seq: [T]) {\n    var inc = seq.count / 2\n    while inc > 0 {\n        for (var i, el) in EnumerateSequence(seq) {\n            while i >= inc && seq[i - inc] > el {\n                seq[i] = seq[i - inc]\n                i -= inc\n            }\n            seq[i] = el\n        }\n        if inc == 2 {\n            inc = 1\n        } else {\n            inc = inc * 5 / 11\n        }\n    }\n}\n\n\nInput:\nvar data = [22, 7, 2, -5, 8, 4]\n\nOutput:\nshellsort(&data) // [-5, 2, 4, 7, 8, 22]\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "COBOL", "code": "\nComplete Program[edit]\nWorks with: IBM Enterprise COBOL for z/OS\n\n      *******************************************************           \n       IDENTIFICATION DIVISION.                                         \n      *******************************************************           \n       PROGRAM-ID.      SHELLSRT.                                       \n      ************************************************************      \n      *** SHELLSORT                                           ****      \n      ************************************************************      \n       ENVIRONMENT DIVISION.                                            \n       DATA DIVISION.                                                   \n       WORKING-STORAGE SECTION.                                         \n       01 II                        PIC S9(008) COMP-5.                 \n       01 IJ                        PIC S9(008) COMP-5.                 \n       01 IZ                        PIC S9(008) COMP-5.                 \n       01 IA                        PIC S9(008) COMP-5.                 \n       01 STRT1                     PIC S9(008) COMP-5.                 \n       01 STRT2                     PIC S9(008) COMP-5.                 \n       01 LGT                       PIC S9(008) COMP-5.                 \n       01 ORG                       PIC S9(008) COMP-5.                 \n       01 DST                       PIC S9(008) COMP-5.                 \n      *                                                                 \n       01 GAP                       PIC S9(008) COMP-5.                 \n       01 NEGAP                     PIC S9(008) COMP-5.                 \n       01 TEMP                      PIC X(32768).                       \n       77 KEY-RESULT                PIC X.                              \n      *                                                                 \n       LINKAGE SECTION.                                                 \n       01 SRT-ARRAY                 PIC  X(1000000).                    \n       01 NUM-ITEM                  PIC  9(008) COMP-5.                 \n       01 SRT-DATA.                                                     \n          03 LGT-ITEM               PIC  9(004) COMP-5.                 \n          03 SRT-KEYS.                                                  \n             05 SRT-KEY OCCURS 10.                                      \n                07 K-START         PIC S9(004) COMP-5.                  \n                07 K-LENGTH        PIC S9(004) COMP-5.                  \n                07 K-ASC           PIC X.                               \n      *                                                                 \n      *    P R O C E D U R E      D I V I S I O N                       \n      *                                                                 \n       PROCEDURE DIVISION USING SRT-ARRAY NUM-ITEM SRT-DATA.                \n                                                                        \n           COMPUTE GAP = NUM-ITEM / 2.                                  \n           PERFORM UNTIL GAP < 1                                        \n              COMPUTE NEGAP = GAP * -1                                  \n              PERFORM VARYING II FROM GAP BY 1                          \n                        UNTIL II GREATER  NUM-ITEM                      \n                 MOVE ' ' TO KEY-RESULT                                 \n                 COMPUTE ORG = (II - 1) * LGT-ITEM + 1                  \n                 MOVE SRT-ARRAY(ORG:LGT-ITEM) TO TEMP(1:LGT-ITEM)       \n                 PERFORM VARYING IJ FROM II BY NEGAP                    \n                           UNTIL IJ NOT GREATER  GAP                    \n                              OR (KEY-RESULT NOT EQUAL '<' AND ' ')     \n                    COMPUTE IA = IJ - GAP                               \n                    IF IA < 1                                           \n                       MOVE 1 TO IA                                     \n                    END-IF                                              \n                    PERFORM COMPARE-KEYS                                \n                    IF KEY-RESULT = '<'                                 \n                       COMPUTE ORG = (IA - 1) * LGT-ITEM + 1            \n                       COMPUTE DST = (IJ - 1) * LGT-ITEM + 1            \n                       MOVE SRT-ARRAY(ORG:LGT-ITEM)                     \n                         TO SRT-ARRAY(DST:LGT-ITEM)                     \n                       COMPUTE DST = (IA - 1) * LGT-ITEM + 1            \n                       MOVE TEMP(1:LGT-ITEM) TO SRT-ARRAY(DST:LGT-ITEM) \n                    END-IF                                              \n                 END-PERFORM                                            \n              END-PERFORM                                               \n              IF GAP = 2                                                \n                 MOVE 1 TO GAP                                          \n              ELSE                                                      \n                 COMPUTE GAP = GAP / 2.2                                \n              END-IF                                                    \n           END-PERFORM.                                                 \n           GOBACK.                                                      \n      *                                                                 \n       COMPARE-KEYS.                                                    \n           MOVE ' ' TO KEY-RESULT                                       \n           PERFORM VARYING IZ FROM 1 BY 1                               \n                     UNTIL IZ GREATER 10                                \n                        OR (KEY-RESULT NOT EQUAL '=' AND ' ')           \n              IF SRT-KEY(IZ) GREATER LOW-VALUES                         \n                 COMPUTE STRT1 = (IJ - 1) * LGT-ITEM + K-START(IZ)      \n                 COMPUTE STRT2 = (IA - 1) * LGT-ITEM + K-START(IZ)      \n                 MOVE K-LENGTH(IZ) TO LGT                               \n                 IF SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '>' TO KEY-RESULT                              \n                 END-IF                                                 \n                 IF SRT-ARRAY(STRT1:LGT) < SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'A'                                 \n                 OR SRT-ARRAY(STRT1:LGT) > SRT-ARRAY(STRT2:LGT) AND     \n                    K-ASC(IZ) EQUAL 'D'                                 \n                    MOVE '<' TO KEY-RESULT                              \n                 END-IF                                                 \n              END-IF                                                    \n           END-PERFORM.                                                 \n           IF KEY-RESULT = ' '                                          \n              MOVE '=' TO KEY-RESULT                                    \n           END-IF.\n\nSorting Process[edit]\n\n       C-PROCESS SECTION.\n       C-000.\n           DISPLAY \"SORT STARTING\".\n\n           DIVIDE WC-SIZE BY 2 GIVING WC-GAP.\n\n           PERFORM E-PROCESS-GAP UNTIL WC-GAP = 0.\n\n           DISPLAY \"SORT FINISHED\".\n\n       C-999.\n           EXIT.\n\n\n       E-PROCESS-GAP SECTION.\n       E-000.\n           PERFORM F-SELECTION VARYING WB-IX-1 FROM WC-GAP BY 1\n                               UNTIL WB-IX-1 > WC-SIZE.\n\n           DIVIDE WC-GAP BY 2.2 GIVING WC-GAP.\n\n       E-999.\n           EXIT.\n\n       F-SELECTION SECTION.\n       F-000.\n           SET WB-IX-2            TO WB-IX-1.\n           MOVE WB-ENTRY(WB-IX-1) TO WC-TEMP.\n\n           SET WB-IX-3 TO WB-IX-2.\n           SET WB-IX-3 DOWN BY WC-GAP.\n           PERFORM G-PASS UNTIL WB-IX-2 NOT > WC-GAP\n      * The next line logically reads\u00a0:\n      *                   or wb-entry(wb-ix-2 - wc-gap) not > wc-temp.\n                          OR WB-ENTRY(WB-IX-3) NOT > WC-TEMP.\n\n           IF WB-IX-1 NOT = WB-IX-2\n              MOVE WC-TEMP TO WB-ENTRY(WB-IX-2).\n\n       F-999.\n           EXIT.\n\n       G-PASS SECTION.\n      * Note that WB-IX-3 is WC-GAP less than WB-IX-2.\n      * Logically this should be\u00a0:\n      *    move wb-entry(wb-ix-2 - wc-gap) to wb-entry(wb-ix-2).\n      *    set wb-ix-2 down by wc-gap.\n      * Unfortunately wb-entry(wb-ix-2 - wc-gap) is not legal in C2 cobol\n       G-000.\n           MOVE WB-ENTRY(WB-IX-3) TO WB-ENTRY(WB-IX-2).\n           SET WB-IX-2            DOWN BY WC-GAP.\n           SET WB-IX-3            DOWN BY WC-GAP.\n\n       G-999.\n           EXIT.\n\n", "explain": "Should work in Cobol/2 too. Picture for array to be sorted is purely fictional, there's no boundary check - hence: be careful!\nProgram will sort any array using standard EBCDIC sequence (won't work properly with signed packed variables). In addition to the \"usual\" array and array lenght parameters, you need to supply an area (initialized to low-values) to detail row-length and up to 10 sort keys defined as follows: start position (1 based), length and sequence (Ascending/Descending).\nThis excerpt contains just enough of the procedure division to show the workings. See the example for the bubble sort for a more complete program.\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Visual_Basic", "code": "\nSub arrShellSort(ByVal arrData As Variant)\n  Dim lngHold, lngGap As Long\n  Dim lngCount, lngMin, lngMax As Long\n  Dim varItem As Variant\n  '\n  lngMin = LBound(arrData)\n  lngMax = UBound(arrData)\n  lngGap = lngMin\n  Do While (lngGap < lngMax)\n    lngGap = 3 * lngGap + 1\n  Loop\n  Do While (lngGap > 1)\n    lngGap = lngGap \\ 3\n    For lngCount = lngGap + lngMin To lngMax\n      varItem = arrData(lngCount)\n      lngHold = lngCount\n      Do While ((arrData(lngHold - lngGap) > varItem))\n        arrData(lngHold) = arrData(lngHold - lngGap)\n        lngHold = lngHold - lngGap\n        If (lngHold < lngMin + lngGap) Then Exit Do\n      Loop\n      arrData(lngHold) = varItem\n    Next\n  Loop\n  arrShellSort = arrData\nEnd Sub'\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Ada", "code": "\n\ngeneric\n   type Element_Type is digits <>;\n   type Index_Type is (<>);\n   type Array_Type is array(Index_Type range <>) of Element_Type;\npackage Shell_Sort is\n   procedure Sort(Item : in out Array_Type);\nend Shell_Sort;\n\npackage body Shell_Sort is\n   \n   ----------\n   -- Sort --\n   ----------\n\n   procedure Sort (Item : in out Array_Type) is\n      Increment : Natural := Index_Type'Pos(Item'Last) / 2;\n      J : Index_Type;\n      Temp : Element_Type;\n   begin\n      while Increment > 0 loop\n         for I in Index_Type'Val(Increment) .. Item'Last loop\n            J := I;\n            Temp := Item(I);\n            while J > Index_Type'val(Increment) and then Item (Index_Type'Val(Index_Type'Pos(J) - Increment)) > Temp loop\n               Item(J) := Item (Index_Type'Val(Index_Type'Pos(J) - Increment));\n               J := Index_Type'Val(Index_Type'Pos(J) - Increment);\n            end loop;\n            Item(J) := Temp;\n         end loop;\n         if Increment = 2 then\n            Increment := 1;\n         else\n            Increment := Increment * 5 / 11;\n         end if;\n      end loop;\n   end Sort;\n\nend Shell_Sort;\n\n", "explain": "This is a generic implementation of the shell sort. Ada allows arrays to be indexed by integer or enumeration types starting at any value. This version deals with any kind or value of valid index type.\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Julia", "code": "\nTranslation of: Java\n# v0.6\n\nfunction shellsort!(a::Array{Int})::Array{Int}\n    incr = div(length(a), 2)\n    while incr > 0\n        for i in incr+1:length(a)\n            j = i\n            tmp = a[i]\n            while j > incr && a[j - incr] > tmp\n                a[j] = a[j-incr]\n                j -= incr\n            end\n            a[j] = tmp\n        end\n        if incr == 2\n            incr = 1\n        else\n            incr = floor(Int, incr * 5.0 / 11)\n        end\n    end\n    return a\nend\n\nx = rand(1:10, 10)\n@show x shellsort!(x)\n@assert issorted(x)\n\n\nOutput:\nx = [2, 6, 9, 2, 3, 9, 5, 2, 5, 9]\nshellsort!(x) = [2, 2, 2, 3, 5, 5, 6, 9, 9, 9]\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Kotlin", "code": "\n// version 1.1.0\n\nval gaps = listOf(701, 301, 132, 57, 23, 10, 4, 1)  // Marcin Ciura's gap sequence\n\nfun shellSort(a: IntArray) {\n    for (gap in gaps) {\n        for (i in gap until a.size) {\n            val temp = a[i]\n            var j = i\n            while (j >= gap && a[j - gap] > temp) {\n                a[j] = a[j - gap]\n                j -= gap\n            }\n            a[j] = temp\n        }\n    }\n}\n\nfun main(args: Array<String>) {\n    val aa = arrayOf(\n        intArrayOf(100, 2, 56, 200, -52, 3, 99, 33, 177, -199),\n        intArrayOf(4, 65, 2, -31, 0, 99, 2, 83, 782, 1),\n        intArrayOf(62, 83, 18, 53, 7, 17, 95, 86, 47, 69, 25, 28)\n    )\n    for (a in aa) {\n        shellSort(a)\n        println(a.joinToString(\", \"))\n    }\n}\n\n\nOutput:\n-199, -52, 2, 3, 33, 56, 99, 100, 177, 200\n-31, 0, 1, 2, 2, 4, 65, 83, 99, 782\n7, 17, 18, 25, 28, 47, 53, 62, 69, 83, 86, 95\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Perl", "code": "\nsub shell_sort {\n    my (@a, $h, $i, $j, $k) = @_;\n    for ($h = @a; $h = int $h / 2;) {\n        for $i ($h .. $#a) {\n            $k = $a[$i];\n            for ($j = $i; $j >= $h && $k < $a[$j - $h]; $j -= $h) {\n                $a[$j] = $a[$j - $h];\n            }\n            $a[$j] = $k;\n        }\n    }\n    @a;\n}\n\nmy @a = map int rand 100, 1 .. $ARGV[0] || 10;\nsay \"@a\";\n@a = shell_sort @a;\nsay \"@a\";\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Lua", "code": "\nfunction shellsort( a )\n    local inc = math.ceil( #a / 2 )\n    while inc > 0 do\n        for i = inc, #a do\n            local tmp = a[i]\n            local j = i\n            while j > inc and a[j-inc] > tmp do\n                a[j] = a[j-inc]\n                j = j - inc\n            end\n            a[j] = tmp\n        end\n        inc = math.floor( 0.5 + inc / 2.2 )\n    end \n    \n    return a\nend\n\na = { -12, 3, 0, 4, 7, 4, 8, -5, 9 }\na = shellsort( a )\n\nfor _, i in pairs(a) do\n    print(i)\nend\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Scala", "code": "\nobject ShellSort {\n  def incSeq(len:Int)=new Iterator[Int]{\n    private[this] var x:Int=len/2\n    def hasNext=x>0\n    def next()={x=if (x==2) 1 else x*5/11; x}\n  }\n\n  def InsertionSort(a:Array[Int], inc:Int)={\n    for (i <- inc until a.length; temp=a(i)){ \n      var j=i;\n      while (j>=inc && a(j-inc)>temp){ \n        a(j)=a(j-inc)\n        j=j-inc\n      }\n      a(j)=temp\n    }\n  }\n  \n  def shellSort(a:Array[Int])=for(inc<-incSeq(a.length)) InsertionSort(a, inc)\n  \n  def main(args: Array[String]): Unit = {\n    var a=Array(2, 5, 3, 4, 3, 9, 3, 2, 5, 4, 1, 3, 22, 7, 2, -5, 8, 4)\n    println(a.mkString(\",\"))\n    shellSort(a)\n    println(a.mkString(\",\"))\n  }\n}\n\n\nOutput:\n2,5,3,4,3,9,3,2,5,4,1,3,22,7,2,-5,8,4\n-5,1,2,2,2,3,3,3,3,4,4,4,5,5,7,8,9,22\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Dart", "code": "\nvoid main() {\n    List<int> a = shellSort([1100, 2, 56, 200, -52, 3, 99, 33, 177, -199]);\n    print('$a');\n}\n\nshellSort(List<int> array) {\n\tint n = array.length;\n \n        // Start with a big gap, then reduce the gap\n        for (int gap = n~/2; gap > 0; gap ~/= 2)\n        {\n            // Do a gapped insertion sort for this gap size.\n            // The first gap elements a[0..gap-1] are already\n            // in gapped order keep adding one more element\n            // until the entire array is gap sorted\n            for (int i = gap; i < n; i += 1)\n            {\n                // add a[i] to the elements that have been gap\n                // sorted save a[i] in temp and make a hole at\n                // position i\n                int temp = array[i];\n \n                // shift earlier gap-sorted elements up until\n                // the correct location for a[i] is found\n                int j;\n                for (j = i; j >= gap && array[j - gap] > temp; j -= gap)\n                    array[j] = array[j - gap];\n \n                // put temp (the original a[i]) in its correct\n                // location\n                array[j] = temp;\n            }\n        }\n  return array;\n}\n\n\nOutput:\n[-199, -52, 2, 3, 33, 56, 99, 177, 200, 1100]\n\n", "explain": "\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "D", "code": "\nimport std.stdio: writeln;\n\nvoid shellSort(T)(T[] seq) pure nothrow {\n    int inc = seq.length / 2;\n    while (inc) {\n        foreach (ref i, el; seq) {\n            while (i >= inc && seq[i - inc] > el) {\n                seq[i] = seq[i - inc];\n                i -= inc;\n            }\n            seq[i] = el;\n        }\n        inc = (inc == 2) ? 1 : cast(int)(inc * 5.0 / 11);\n    }\n}\n\nvoid main() {\n    auto data = [22, 7, 2, -5, 8, 4];\n    shellSort(data);\n    writeln(data);\n}\n\n\nOutput:\n[-5, 2, 4, 7, 8, 22]\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "Haskell", "code": "\n\nimport Data.List\n\nshellSort xs = foldr (invColumnize (map (foldr insert []))) xs gaps\n  where gaps = takeWhile (< length xs) $ iterate (succ.(3*)) 1\n        invColumnize f k = concat. transpose. f. transpose\n                           . takeWhile (not.null). unfoldr (Just. splitAt k)\n\n", "explain": "Adapted version from [2]\n"}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "PowerShell", "code": "\nFunction ShellSort( [Array] $data )\n{\n\t# http://oeis.org/A108870\n\t$A108870 = [Int64[]] ( 1, 4, 9, 20, 46, 103, 233, 525, 1182, 2660, 5985, 13467, 30301, 68178, 153401, 345152, 776591, 1747331, 3931496, 8845866, 19903198, 44782196, 100759940, 226709866, 510097200, 1147718700, 2582367076, 5810325920, 13073233321, 29414774973 )\n\t$datal = $data.length - 1\n\t$inci = [Array]::BinarySearch( $A108870, [Int64] ( [Math]::Floor( $datal / 2 ) ) )\n\tif( $inci -lt 0 )\n\t{\n\t\t$inci = ( $inci -bxor -1 ) - 1\n\t}\n\t$A108870[ $inci..0 ] | ForEach-Object {\n\t\t$inc = $_\n\t\t$_..$datal | ForEach-Object {\n\t\t\t$temp = $data[ $_ ]\n\t\t\t$j = $_\n\t\t\tfor( ; ( $j -ge $inc ) -and ( $data[ $j - $inc ] -gt $temp ); $j -= $inc )\n\t\t\t{\n\t\t\t\t$data[ $j ] = $data[ $j - $inc ]\n\t\t\t}\n\t\t\t$data[ $j ] = $temp\n\t\t}\n\t}\n\t$data\n}\n\n$l = 10000; ShellSort( ( 1..$l | ForEach-Object { $Rand = New-Object Random }{ $Rand.Next( 0, $l - 1 ) } ) )\n\n", "explain": ""}, {"task_name": "Sorting algorithms/Shell sort", "task_url": "https://rosettacode.org/wiki/Sorting_algorithms/Shell_sort", "task_cat": "Sorting", "lang": "AWK", "code": "\nTranslation of: Fortran\n{\n  line[NR] = $0\n}\nEND { # sort it with shell sort\n  increment = int(NR / 2)\n  while ( increment > 0 ) {\n    for(i=increment+1; i <= NR; i++) {\n      j = i\n      temp = line[i]\n      while ( (j >= increment+1) && (line[j-increment] > temp) ) {\n\tline[j] = line[j-increment]\n\tj -= increment\n      }\n      line[j] = temp\n    }\n    if ( increment == 2 )\n      increment = 1\n    else \n      increment = int(increment*5/11)\n  }\n  #print it\n  for(i=1; i <= NR; i++) {\n    print line[i]\n  }\n}\n\n", "explain": ""}]